textattack: Running 8 worker(s) on 8 GPU(s).
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/1000 [00:00<00:00, 1459.90it/s][Succeeded / Failed / Skipped / Total] 2 / 0 / 0 / 2:   0%|          | 2/1000 [00:00<00:00, 1553.45it/s][Succeeded / Failed / Skipped / Total] 2 / 1 / 0 / 3:   0%|          | 3/1000 [00:00<00:00, 1715.46it/s][Succeeded / Failed / Skipped / Total] 3 / 1 / 0 / 4:   0%|          | 4/1000 [00:00<00:00, 1894.45it/s]--------------------------------------------- Result 1 ---------------------------------------------
Performs a replay of the provided connectable observable using the specified scheduler . --> Replay an observable from kapitan to wicks --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[observeOn]] ( final ConnectableObservable < T > [[co]] , final Scheduler [[scheduler]] ) { final Observable < T > [[observable]] = [[co]] . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[co]] , [[observable]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[elixir]] ( final ConnectableObservable < T > [[kapitan]] , final Scheduler [[wicks]] ) { final Observable < T > [[identifiable]] = [[kapitan]] . observeOn ( [[wicks]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[kapitan]] , [[identifiable]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 2 ---------------------------------------------
Try to apply a function to a Publisher and return true if it succeeds --> Returns true if the subscriber has been satisfied --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( Publisher < T > [[source]] , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( [[source]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "[[True]]" == "[[True]]" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "[[True]]" == "[[True]]" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[beagles]] ( Publisher < T > [[feeds]] , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( [[feeds]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[feeds]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[Sincere]]" == "[[Sincere]]" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "[[Sincere]]" == "[[Sincere]]" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[Sincere]]" == "[[Sincere]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[Sincere]]" == "[[Sincere]]" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "[[Sincere]]" == "[[Sincere]]" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "[[Sincere]]" == "[[Sincere]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 3 ---------------------------------------------
Emits a value in a fast - path order . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 4 ---------------------------------------------
Resets all internal state to null . --> Rebooting is a no - op --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "[[False]]" != "[[False]]" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[rebooting]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "[[Disingenuous]]" != "[[Disingenuous]]" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 5 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 2 / 0 / 5:   0%|          | 5/1000 [00:00<00:00, 2067.79it/s][Succeeded / Failed / Skipped / Total] 3 / 2 / 0 / 5:   1%|          | 6/1000 [00:26<1:12:13,  4.36s/it][Succeeded / Failed / Skipped / Total] 3 / 3 / 0 / 6:   1%|          | 6/1000 [00:26<1:12:13,  4.36s/it][Succeeded / Failed / Skipped / Total] 3 / 3 / 0 / 6:   1%|          | 7/1000 [02:32<5:59:50, 21.74s/it][Succeeded / Failed / Skipped / Total] 3 / 4 / 0 / 7:   1%|          | 7/1000 [02:32<5:59:50, 21.74s/it][Succeeded / Failed / Skipped / Total] 3 / 4 / 0 / 7:   1%|          | 8/1000 [02:35<5:21:03, 19.42s/it][Succeeded / Failed / Skipped / Total] 3 / 5 / 0 / 8:   1%|          | 8/1000 [02:35<5:21:03, 19.42s/it][Succeeded / Failed / Skipped / Total] 3 / 5 / 0 / 8:   1%|          | 9/1000 [02:47<5:07:03, 18.59s/it][Succeeded / Failed / Skipped / Total] 3 / 6 / 0 / 9:   1%|          | 9/1000 [02:47<5:07:03, 18.59s/it][Succeeded / Failed / Skipped / Total] 3 / 6 / 0 / 9:   1%|          | 10/1000 [02:49<4:39:06, 16.92s/it][Succeeded / Failed / Skipped / Total] 4 / 6 / 0 / 10:   1%|          | 10/1000 [02:49<4:39:06, 16.92s/it][Succeeded / Failed / Skipped / Total] 4 / 6 / 0 / 10:   1%|          | 11/1000 [02:59<4:28:56, 16.32s/it][Succeeded / Failed / Skipped / Total] 5 / 6 / 0 / 11:   1%|          | 11/1000 [02:59<4:28:56, 16.32s/it][Succeeded / Failed / Skipped / Total] 5 / 6 / 0 / 11:   1%|          | 12/1000 [03:17<4:30:48, 16.45s/it][Succeeded / Failed / Skipped / Total] 6 / 6 / 0 / 12:   1%|          | 12/1000 [03:17<4:30:48, 16.45s/it][Succeeded / Failed / Skipped / Total] 6 / 6 / 0 / 12:   1%|▏         | 13/1000 [04:07<5:13:48, 19.08s/it][Succeeded / Failed / Skipped / Total] 6 / 7 / 0 / 13:   1%|▏         | 13/1000 [04:07<5:13:48, 19.08s/it][Succeeded / Failed / Skipped / Total] 6 / 7 / 0 / 13:   1%|▏         | 14/1000 [04:14<4:58:59, 18.19s/it]Wrap an observable . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 6 ---------------------------------------------
Throws a NullPointerException if the object is null . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 7 ---------------------------------------------
Returns an observable that is sorted by the elements of this observable sequence using the given sort function . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 8 ---------------------------------------------
Creates a new unicast processor with the given capacity . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint ) { return new UnicastProcessor < T > ( capacityHint ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint ) { return new UnicastProcessor < T > ( capacityHint ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 9 ---------------------------------------------
Creates a new unicast processor with a given capacity . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 10 ---------------------------------------------
Attempts to retry this Maybe with the specified number of times . --> Disconnects from a given number of jours --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[retry]] ( long [[times]] , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( [[times]] , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[disconnects]] ( long [[jours]] , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( [[jours]] , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 11 ---------------------------------------------
Returns a function that casts the target value to the specified type . --> Casts tonnes to ladyhawke --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[castFunction]] ( Class < U > [[target]] ) { return new CastToClass < [[T]] , U > ( [[target]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < [[tonnes]] , U > Function < [[tonnes]] , U > [[ladyhawke]] ( Class < U > [[sights]] ) { return new CastToClass < [[tonnes]] , U > ( [[sights]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 12 ---------------------------------------------
Creates a new unicast subject with the given capacity . --> Erect multicast to ayako --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[erect]] ( int [[ayako]] ) { return new UnicastSubject < T > ( [[ayako]] , "[[Earnest]]" == "[[Earnest]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 13 ---------------------------------------------
Creates a Flowable from a scalar value using the given function . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Flowable < U > scalarXMap ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > scalarXMap ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
[Succeeded / Failed / Skipped / Total] 6 / 8 / 0 / 14:   1%|▏         | 14/1000 [04:14<4:58:59, 18.19s/it][Succeeded / Failed / Skipped / Total] 6 / 8 / 0 / 14:   2%|▏         | 15/1000 [04:25<4:50:13, 17.68s/it][Succeeded / Failed / Skipped / Total] 6 / 9 / 0 / 15:   2%|▏         | 15/1000 [04:25<4:50:13, 17.68s/it][Succeeded / Failed / Skipped / Total] 6 / 9 / 0 / 15:   2%|▏         | 16/1000 [05:10<5:17:50, 19.38s/it][Succeeded / Failed / Skipped / Total] 6 / 10 / 0 / 16:   2%|▏         | 16/1000 [05:10<5:17:50, 19.38s/it][Succeeded / Failed / Skipped / Total] 6 / 10 / 0 / 16:   2%|▏         | 17/1000 [05:56<5:43:27, 20.96s/it][Succeeded / Failed / Skipped / Total] 7 / 10 / 0 / 17:   2%|▏         | 17/1000 [05:56<5:43:27, 20.96s/it][Succeeded / Failed / Skipped / Total] 7 / 10 / 0 / 17:   2%|▏         | 18/1000 [06:49<6:11:56, 22.73s/it][Succeeded / Failed / Skipped / Total] 7 / 11 / 0 / 18:   2%|▏         | 18/1000 [06:49<6:11:56, 22.73s/it][Succeeded / Failed / Skipped / Total] 7 / 11 / 0 / 18:   2%|▏         | 19/1000 [07:01<6:02:42, 22.18s/it][Succeeded / Failed / Skipped / Total] 8 / 11 / 0 / 19:   2%|▏         | 19/1000 [07:01<6:02:42, 22.18s/it]Using /tmp/tfhub_modules to cache modules.
[Succeeded / Failed / Skipped / Total] 8 / 11 / 0 / 19:   2%|▏         | 20/1000 [07:10<5:51:26, 21.52s/it][Succeeded / Failed / Skipped / Total] 9 / 11 / 0 / 20:   2%|▏         | 20/1000 [07:10<5:51:26, 21.52s/it][Succeeded / Failed / Skipped / Total] 9 / 11 / 0 / 20:   2%|▏         | 21/1000 [07:45<6:01:58, 22.18s/it][Succeeded / Failed / Skipped / Total] 9 / 12 / 0 / 21:   2%|▏         | 21/1000 [07:45<6:01:58, 22.18s/it][Succeeded / Failed / Skipped / Total] 9 / 12 / 0 / 21:   2%|▏         | 22/1000 [08:14<6:06:20, 22.47s/it][Succeeded / Failed / Skipped / Total] 9 / 13 / 0 / 22:   2%|▏         | 22/1000 [08:14<6:06:20, 22.47s/it][Succeeded / Failed / Skipped / Total] 9 / 13 / 0 / 22:   2%|▏         | 23/1000 [09:36<6:47:55, 25.05s/it]--------------------------------------------- Result 14 ---------------------------------------------
Creates a Maybe from a single source . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromSingle ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromSingle ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 15 ---------------------------------------------
Returns the identity function . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T > Function < T , T > identity ( ) { return ( Function < T , T > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T > Function < T , T > identity ( ) { return ( Function < T , T > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 16 ---------------------------------------------
Creates a Maybe from a Completable source . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 17 ---------------------------------------------
Creates a Callable that just returns the given value . --> Novotny cour de valour --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > [[justCallable]] ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > [[novotny]] ( T [[valour]] ) { return new JustValue < Object , T > ( [[valour]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 18 ---------------------------------------------
Creates a function that just returns the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Function < T , U > justFunction ( U value ) { return new JustValue < T , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < T , U > Function < T , U > justFunction ( U value ) { return new JustValue < T , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 19 ---------------------------------------------
Requests messages from the given subscription . --> Request second subscription with given number of morlocks --> Socre: 1.0

[[[[Adv]]]]: public static void request ( Subscription [[s]] , int [[prefetch]] ) { [[s]] . request ( [[prefetch]] < 0 ? Long . MAX_VALUE : [[prefetch]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void request ( Subscription [[second]] , int [[morlocks]] ) { [[second]] . request ( [[morlocks]] < 0 ? Long . MAX_VALUE : [[morlocks]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 20 ---------------------------------------------
Blocks until the condition is satisfied or the condition is not met . --> Waits for a certain amount of time to pass --> Socre: 1.0

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long [[timeout]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , unit ) ) { dispose ( ) ; return "[[False]]" != "[[False]]" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } } Throwable [[ex]] = error ; if ( [[ex]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[whenever]] ( long [[touchdown]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[touchdown]] , unit ) ) { dispose ( ) ; return "[[Wrong]]" != "[[Wrong]]" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[eg]] ) ; } } Throwable [[eg]] = error ; if ( [[eg]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[eg]] ) ; } return "[[Reality]]" == "[[Reality]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 21 ---------------------------------------------
Creates a new unicast subject . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 22 ---------------------------------------------
Creates a new unicast subject with the given capacity . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int capacityHint , Runnable onTerminate ) { return new UnicastSubject < T > ( capacityHint , onTerminate , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int capacityHint , Runnable onTerminate ) { return new UnicastSubject < T > ( capacityHint , onTerminate , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 23 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 9 / 14 / 0 / 23:   2%|▏         | 23/1000 [09:36<6:47:55, 25.05s/it][Succeeded / Failed / Skipped / Total] 9 / 14 / 0 / 23:   2%|▏         | 24/1000 [10:06<6:50:57, 25.26s/it][Succeeded / Failed / Skipped / Total] 9 / 15 / 0 / 24:   2%|▏         | 24/1000 [10:06<6:50:57, 25.26s/it][Succeeded / Failed / Skipped / Total] 9 / 15 / 0 / 24:   2%|▎         | 25/1000 [11:05<7:12:26, 26.61s/it][Succeeded / Failed / Skipped / Total] 9 / 16 / 0 / 25:   2%|▎         | 25/1000 [11:05<7:12:26, 26.61s/it][Succeeded / Failed / Skipped / Total] 9 / 16 / 0 / 25:   3%|▎         | 26/1000 [12:17<7:40:35, 28.37s/it][Succeeded / Failed / Skipped / Total] 9 / 17 / 0 / 26:   3%|▎         | 26/1000 [12:17<7:40:35, 28.37s/it][Succeeded / Failed / Skipped / Total] 9 / 17 / 0 / 26:   3%|▎         | 27/1000 [12:21<7:25:38, 27.48s/it][Succeeded / Failed / Skipped / Total] 9 / 18 / 0 / 27:   3%|▎         | 27/1000 [12:21<7:25:38, 27.48s/it][Succeeded / Failed / Skipped / Total] 9 / 18 / 0 / 27:   3%|▎         | 28/1000 [12:34<7:16:28, 26.94s/it][Succeeded / Failed / Skipped / Total] 10 / 18 / 0 / 28:   3%|▎         | 28/1000 [12:34<7:16:28, 26.94s/it][Succeeded / Failed / Skipped / Total] 10 / 18 / 0 / 28:   3%|▎         | 29/1000 [12:37<7:02:42, 26.12s/it][Succeeded / Failed / Skipped / Total] 11 / 18 / 0 / 29:   3%|▎         | 29/1000 [12:37<7:02:42, 26.12s/it][Succeeded / Failed / Skipped / Total] 11 / 18 / 0 / 29:   3%|▎         | 30/1000 [12:46<6:53:04, 25.55s/it][Succeeded / Failed / Skipped / Total] 12 / 18 / 0 / 30:   3%|▎         | 30/1000 [12:46<6:53:04, 25.55s/it][Succeeded / Failed / Skipped / Total] 12 / 18 / 0 / 30:   3%|▎         | 31/1000 [13:02<6:47:28, 25.23s/it]Blocks until the count reaches zero or an exception is thrown . --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable blockingGetError ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable blockingGetError ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 24 ---------------------------------------------
Creates a new UnicastSubject . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 25 ---------------------------------------------
Completes the request . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void complete ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void complete ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 26 ---------------------------------------------
Returns the value of the notification . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T getValue ( ) { Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T getValue ( ) { Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 27 ---------------------------------------------
Posts a complete event to the subscriber . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 28 ---------------------------------------------
Returns the upper bound of Long . MAX_VALUE if the result is negative . --> Turncoat returns a + b --> Socre: 1.0

[[[[Adv]]]]: public static long [[addCap]] ( long a , long b ) { long u = a + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[turncoat]] ( long a , long b ) { long u = a + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 29 ---------------------------------------------
Multiply two longs . If the result is Long . MAX_VALUE return Long . MAX_VALUE . --> wino returns nova ^ b --> Socre: 1.0

[[[[Adv]]]]: public static long [[multiplyCap]] ( long [[a]] , long b ) { long u = [[a]] * b ; if ( ( ( [[a]] | b ) >>> 31 ) != 0 ) { if ( u / [[a]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[wino]] ( long [[nova]] , long b ) { long u = [[nova]] * b ; if ( ( ( [[nova]] | b ) >>> 31 ) != 0 ) { if ( u / [[nova]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 30 ---------------------------------------------
Validates that the given disposables are non - null . --> Compares two disposables for corroboration --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[validate]] ( Disposable upstream , Disposable next , Class < ? > [[observer]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observer]] ) ; } return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[corroboration]] ( Disposable upstream , Disposable next , Class < ? > [[supervising]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[supervising]] ) ; } return "[[Phony]]" != "[[Phony]]" ; } return "[[Trusty]]" == "[[Trusty]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
[Succeeded / Failed / Skipped / Total] 12 / 19 / 0 / 31:   3%|▎         | 31/1000 [13:02<6:47:28, 25.23s/it][Succeeded / Failed / Skipped / Total] 12 / 19 / 0 / 31:   3%|▎         | 32/1000 [13:06<6:36:31, 24.58s/it][Succeeded / Failed / Skipped / Total] 13 / 19 / 0 / 32:   3%|▎         | 32/1000 [13:06<6:36:31, 24.58s/it][Succeeded / Failed / Skipped / Total] 13 / 19 / 0 / 32:   3%|▎         | 33/1000 [13:25<6:33:32, 24.42s/it][Succeeded / Failed / Skipped / Total] 13 / 20 / 0 / 33:   3%|▎         | 33/1000 [13:25<6:33:32, 24.42s/it][Succeeded / Failed / Skipped / Total] 13 / 20 / 0 / 33:   3%|▎         | 34/1000 [13:26<6:21:54, 23.72s/it][Succeeded / Failed / Skipped / Total] 14 / 20 / 0 / 34:   3%|▎         | 34/1000 [13:26<6:21:54, 23.72s/it][Succeeded / Failed / Skipped / Total] 14 / 20 / 0 / 34:   4%|▎         | 35/1000 [15:45<7:14:33, 27.02s/it][Succeeded / Failed / Skipped / Total] 14 / 21 / 0 / 35:   4%|▎         | 35/1000 [15:45<7:14:33, 27.02s/it][Succeeded / Failed / Skipped / Total] 14 / 21 / 0 / 35:   4%|▎         | 36/1000 [15:57<7:07:15, 26.59s/it][Succeeded / Failed / Skipped / Total] 14 / 22 / 0 / 36:   4%|▎         | 36/1000 [15:57<7:07:15, 26.59s/it][Succeeded / Failed / Skipped / Total] 14 / 22 / 0 / 36:   4%|▎         | 37/1000 [16:08<6:59:59, 26.17s/it]--------------------------------------------- Result 31 ---------------------------------------------
Returns the error associated with this notification . --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Throwable getError ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable getError ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 32 ---------------------------------------------
Adds an object to the end of the list . --> Set the extras from the given australia object --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object [[o]] ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[extras]] ( Object [[australia]] ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 33 ---------------------------------------------
Blocks until the count reaches zero or an exception is thrown . --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable blockingGetError ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable blockingGetError ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 34 ---------------------------------------------
Atomically adds n to the requested counter . --> introduce a new phosphorus with a given number of pages --> Socre: 1.0

[[[[Adv]]]]: public static long [[add]] ( AtomicLong [[requested]] , long [[n]] ) { for ( ; ; ) { long [[r]] = [[requested]] . get ( ) ; if ( [[r]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( [[r]] , [[n]] ) ; if ( [[requested]] . compareAndSet ( [[r]] , u ) ) { return [[r]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long [[introduce]] ( AtomicLong [[called]] , long [[pages]] ) { for ( ; ; ) { long [[phosphorus]] = [[called]] . get ( ) ; if ( [[phosphorus]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( [[phosphorus]] , [[pages]] ) ; if ( [[called]] . compareAndSet ( [[phosphorus]] , u ) ) { return [[phosphorus]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 35 ---------------------------------------------
Drains a queue of values up to Long . MAX_VALUE . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 36 ---------------------------------------------
Validates the upstream subscription and the next subscription . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean validate ( Subscription upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Subscription upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 37 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 22 / 0 / 37:   4%|▎         | 37/1000 [16:08<6:59:59, 26.17s/it][Succeeded / Failed / Skipped / Total] 15 / 22 / 0 / 37:   4%|▍         | 38/1000 [16:09<6:49:07, 25.52s/it][Succeeded / Failed / Skipped / Total] 16 / 22 / 0 / 38:   4%|▍         | 38/1000 [16:09<6:49:07, 25.52s/it][Succeeded / Failed / Skipped / Total] 16 / 22 / 0 / 38:   4%|▍         | 39/1000 [16:28<6:45:52, 25.34s/it][Succeeded / Failed / Skipped / Total] 16 / 23 / 0 / 39:   4%|▍         | 39/1000 [16:28<6:45:52, 25.34s/it][Succeeded / Failed / Skipped / Total] 16 / 23 / 0 / 39:   4%|▍         | 40/1000 [16:40<6:40:11, 25.01s/it][Succeeded / Failed / Skipped / Total] 17 / 23 / 0 / 40:   4%|▍         | 40/1000 [16:40<6:40:11, 25.01s/it][Succeeded / Failed / Skipped / Total] 17 / 23 / 0 / 40:   4%|▍         | 41/1000 [16:50<6:34:00, 24.65s/it][Succeeded / Failed / Skipped / Total] 17 / 24 / 0 / 41:   4%|▍         | 41/1000 [16:50<6:34:00, 24.65s/it][Succeeded / Failed / Skipped / Total] 17 / 24 / 0 / 41:   4%|▍         | 42/1000 [17:14<6:33:20, 24.64s/it]Sets the subscription to the given value . --> bustin - bustin - bustin - bustin --> Socre: 1.0

[[[[Adv]]]]: public final void [[setSubscription]] ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[s]] ; long [[r]] = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( [[r]] != 0L ) { [[s]] . request ( [[r]] ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[s]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void [[bustin]] ( Subscription [[neither]] ) { if ( cancelled ) { [[neither]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[neither]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[neither]] ; long [[mishra]] = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( [[mishra]] != 0L ) { [[neither]] . request ( [[mishra]] ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[neither]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 38 ---------------------------------------------
Loops through the queue and emits the result . --> volcano - volcano - volcano - volcano --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "[[False]]" != "[[False]]" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[volcano]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "[[Scythe]]" != "[[Scythe]]" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 39 ---------------------------------------------
Atomically compareAndSets the upstream AtomicReference to null and disposes the next disposable if the AtomicReference doesn t exist . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 40 ---------------------------------------------
Wraps an exception in a RuntimeException if it is not already one . --> borja rorja rorja --> Socre: 1.0

[[[[Adv]]]]: public static RuntimeException [[wrapOrThrow]] ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException [[borja]] ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 41 ---------------------------------------------
Shuts down the executor service . --> [[[FAILED]]]

[[[[Adv]]]]: public static void shutdown ( ) { ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; if ( exec != null ) { exec . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void shutdown ( ) { ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; if ( exec != null ) { exec . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 42 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 18 / 24 / 0 / 42:   4%|▍         | 42/1000 [17:14<6:33:20, 24.64s/it][Succeeded / Failed / Skipped / Total] 18 / 24 / 0 / 42:   4%|▍         | 43/1000 [17:29<6:29:26, 24.42s/it][Succeeded / Failed / Skipped / Total] 18 / 25 / 0 / 43:   4%|▍         | 43/1000 [17:29<6:29:26, 24.42s/it][Succeeded / Failed / Skipped / Total] 18 / 25 / 0 / 43:   4%|▍         | 44/1000 [17:59<6:30:47, 24.53s/it][Succeeded / Failed / Skipped / Total] 18 / 26 / 0 / 44:   4%|▍         | 44/1000 [17:59<6:30:47, 24.53s/it][Succeeded / Failed / Skipped / Total] 18 / 26 / 0 / 44:   4%|▍         | 45/1000 [18:13<6:26:37, 24.29s/it][Succeeded / Failed / Skipped / Total] 18 / 27 / 0 / 45:   4%|▍         | 45/1000 [18:13<6:26:37, 24.29s/it][Succeeded / Failed / Skipped / Total] 18 / 27 / 0 / 45:   5%|▍         | 46/1000 [18:22<6:20:55, 23.96s/it][Succeeded / Failed / Skipped / Total] 18 / 28 / 0 / 46:   5%|▍         | 46/1000 [18:22<6:20:55, 23.96s/it][Succeeded / Failed / Skipped / Total] 18 / 28 / 0 / 46:   5%|▍         | 47/1000 [18:30<6:15:17, 23.63s/it]Tries to convert an observable from a Callable to an observable from an ObservableSource using a mapping function . --> Returns true if the originate observable is valid and the observer is valid --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( ObservableSource < T > [[source]] , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( [[source]] instanceof Callable ) { T [[t]] ; try { [[t]] = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[True]]" == "[[True]]" ; } if ( [[t]] == null ) { EmptyDisposable . complete ( observer ) ; return "[[True]]" == "[[True]]" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( [[t]] ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[True]]" == "[[True]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[True]]" == "[[True]]" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "[[True]]" == "[[True]]" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[deflecting]] ( ObservableSource < T > [[originate]] , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( [[originate]] instanceof Callable ) { T [[ov]] ; try { [[ov]] = ( ( Callable < T > ) [[originate]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[Valid]]" == "[[Valid]]" ; } if ( [[ov]] == null ) { EmptyDisposable . complete ( observer ) ; return "[[Valid]]" == "[[Valid]]" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( [[ov]] ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[Valid]]" == "[[Valid]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[Valid]]" == "[[Valid]]" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "[[Valid]]" == "[[Valid]]" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "[[Valid]]" == "[[Valid]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 43 ---------------------------------------------
Converts a Throwable to a NullPointerException . --> [[[FAILED]]]

[[[[Adv]]]]: private static NullPointerException toNpe ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException toNpe ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 44 ---------------------------------------------
Accepts the subscriber . --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 45 ---------------------------------------------
Creates a new scheduled executor service with the specified thread factory . --> [[[FAILED]]]

[[[[Adv]]]]: public static ScheduledExecutorService create ( ThreadFactory factory ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService create ( ThreadFactory factory ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 46 ---------------------------------------------
Atomically sets the value of the AtomicReference to null and cancels the next subscription . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 47 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 18 / 29 / 0 / 47:   5%|▍         | 47/1000 [18:30<6:15:17, 23.63s/it][Succeeded / Failed / Skipped / Total] 18 / 29 / 0 / 47:   5%|▍         | 48/1000 [18:33<6:08:01, 23.19s/it][Succeeded / Failed / Skipped / Total] 19 / 29 / 0 / 48:   5%|▍         | 48/1000 [18:33<6:08:01, 23.19s/it][Succeeded / Failed / Skipped / Total] 19 / 29 / 0 / 48:   5%|▍         | 49/1000 [20:25<6:36:32, 25.02s/it][Succeeded / Failed / Skipped / Total] 19 / 30 / 0 / 49:   5%|▍         | 49/1000 [20:25<6:36:32, 25.02s/it][Succeeded / Failed / Skipped / Total] 19 / 30 / 0 / 49:   5%|▌         | 50/1000 [20:53<6:36:53, 25.07s/it][Succeeded / Failed / Skipped / Total] 19 / 31 / 0 / 50:   5%|▌         | 50/1000 [20:53<6:36:53, 25.07s/it][Succeeded / Failed / Skipped / Total] 19 / 31 / 0 / 50:   5%|▌         | 51/1000 [21:07<6:33:11, 24.86s/it][Succeeded / Failed / Skipped / Total] 19 / 32 / 0 / 51:   5%|▌         | 51/1000 [21:07<6:33:11, 24.86s/it][Succeeded / Failed / Skipped / Total] 19 / 32 / 0 / 51:   5%|▌         | 52/1000 [22:04<6:42:19, 25.46s/it][Succeeded / Failed / Skipped / Total] 19 / 33 / 0 / 52:   5%|▌         | 52/1000 [22:04<6:42:19, 25.46s/it][Succeeded / Failed / Skipped / Total] 19 / 33 / 0 / 52:   5%|▌         | 53/1000 [22:07<6:35:17, 25.04s/it][Succeeded / Failed / Skipped / Total] 19 / 34 / 0 / 53:   5%|▌         | 53/1000 [22:07<6:35:17, 25.04s/it][Succeeded / Failed / Skipped / Total] 19 / 34 / 0 / 53:   5%|▌         | 54/1000 [22:29<6:34:06, 25.00s/it][Succeeded / Failed / Skipped / Total] 19 / 35 / 0 / 54:   5%|▌         | 54/1000 [22:29<6:34:06, 25.00s/it][Succeeded / Failed / Skipped / Total] 19 / 35 / 0 / 54:   6%|▌         | 55/1000 [22:50<6:32:23, 24.91s/it]Starts the queue . --> [[[FAILED]]]

[[[[Adv]]]]: public void start ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void start ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 48 ---------------------------------------------
Starts the unbounded subscription . --> Borrowed from SpscLinkedArrayQueue --> Socre: 1.0

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[burlington]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 49 ---------------------------------------------
Clears the set of disposables . --> [[[FAILED]]]

[[[[Adv]]]]: public void clear ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > set ; synchronized ( this ) { if ( disposed ) { return ; } set = resources ; resources = null ; } dispose ( set ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void clear ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > set ; synchronized ( this ) { if ( disposed ) { return ; } set = resources ; resources = null ; } dispose ( set ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 50 ---------------------------------------------
Throws the given Throwable if it is not already an Exception . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 51 ---------------------------------------------
Returns the number of resources in the set . --> [[[FAILED]]]

[[[[Adv]]]]: public int size ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int size ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 52 ---------------------------------------------
Offers a new element to the queue . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean offer ( T t ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( t , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( t ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean offer ( T t ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( t , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( t ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 53 ---------------------------------------------
Flattens an exception into a list of exceptions . --> [[[FAILED]]]

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 54 ---------------------------------------------
Returns the current thread s disposable . --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Disposable get ( ) { Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return d ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable get ( ) { Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return d ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 55 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 19 / 36 / 0 / 55:   6%|▌         | 55/1000 [22:50<6:32:23, 24.91s/it][Succeeded / Failed / Skipped / Total] 19 / 36 / 0 / 55:   6%|▌         | 56/1000 [23:30<6:36:22, 25.19s/it][Succeeded / Failed / Skipped / Total] 19 / 37 / 0 / 56:   6%|▌         | 56/1000 [23:30<6:36:22, 25.19s/it][Succeeded / Failed / Skipped / Total] 19 / 37 / 0 / 56:   6%|▌         | 57/1000 [24:06<6:38:54, 25.38s/it][Succeeded / Failed / Skipped / Total] 20 / 37 / 0 / 57:   6%|▌         | 57/1000 [24:06<6:38:54, 25.38s/it][Succeeded / Failed / Skipped / Total] 20 / 37 / 0 / 57:   6%|▌         | 58/1000 [24:12<6:33:07, 25.04s/it][Succeeded / Failed / Skipped / Total] 21 / 37 / 0 / 58:   6%|▌         | 58/1000 [24:12<6:33:07, 25.04s/it][Succeeded / Failed / Skipped / Total] 21 / 37 / 0 / 58:   6%|▌         | 59/1000 [24:21<6:28:28, 24.77s/it][Succeeded / Failed / Skipped / Total] 22 / 37 / 0 / 59:   6%|▌         | 59/1000 [24:21<6:28:28, 24.77s/it][Succeeded / Failed / Skipped / Total] 22 / 37 / 0 / 59:   6%|▌         | 60/1000 [24:39<6:26:16, 24.66s/it][Succeeded / Failed / Skipped / Total] 22 / 38 / 0 / 60:   6%|▌         | 60/1000 [24:39<6:26:16, 24.66s/it][Succeeded / Failed / Skipped / Total] 22 / 38 / 0 / 60:   6%|▌         | 61/1000 [24:40<6:19:47, 24.27s/it][Succeeded / Failed / Skipped / Total] 23 / 38 / 0 / 61:   6%|▌         | 61/1000 [24:40<6:19:47, 24.27s/it][Succeeded / Failed / Skipped / Total] 23 / 38 / 0 / 61:   6%|▌         | 62/1000 [25:19<6:23:07, 24.51s/it]Creates an Observable composed of the results of applying the given function to an observable source . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Observable < U > scalarXMap ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > scalarXMap ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 56 ---------------------------------------------
Accepts the given observer . --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 57 ---------------------------------------------
Waits for the specified number of times to become available . --> Waits until we get a certain number of requests --> Socre: 1.0

[[[[Adv]]]]: public PerfAsyncConsumer [[await]] ( int [[count]] ) { if ( [[count]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[await]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer [[hoping]] ( int [[numbers]] ) { if ( [[numbers]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[hoping]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 58 ---------------------------------------------
Returns a new Flowable that is composed of the results of applying the given function to each element of the current stream and delaying the error by 2 seconds . --> Antarctica para antarctica --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[concatMapDelayError]] ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return [[concatMapDelayError]] ( mapper , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[antarctica]] ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return [[antarctica]] ( mapper , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 59 ---------------------------------------------
Returns a new Flowable that contains the results of applying the given function to each element of this stream . --> Pequeo un mish --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return [[concatMapIterable]] ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[pequeño]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[mish]] ) { return [[pequeño]] ( [[mish]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 60 ---------------------------------------------
Completes the stream with the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public final void complete ( T value ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void complete ( T value ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 61 ---------------------------------------------
Adds the given subscription to the list of subscribers . --> introduce a new subscription --> Socre: 1.0

[[[[Adv]]]]: boolean [[add]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean [[introduce]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 62 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 39 / 0 / 62:   6%|▌         | 62/1000 [25:19<6:23:07, 24.51s/it][Succeeded / Failed / Skipped / Total] 23 / 39 / 0 / 62:   6%|▋         | 63/1000 [25:30<6:19:19, 24.29s/it][Succeeded / Failed / Skipped / Total] 24 / 39 / 0 / 63:   6%|▋         | 63/1000 [25:30<6:19:19, 24.29s/it][Succeeded / Failed / Skipped / Total] 24 / 39 / 0 / 63:   6%|▋         | 64/1000 [25:37<6:14:52, 24.03s/it][Succeeded / Failed / Skipped / Total] 24 / 40 / 0 / 64:   6%|▋         | 64/1000 [25:37<6:14:52, 24.03s/it][Succeeded / Failed / Skipped / Total] 24 / 40 / 0 / 64:   6%|▋         | 65/1000 [25:38<6:08:51, 23.67s/it][Succeeded / Failed / Skipped / Total] 25 / 40 / 0 / 65:   6%|▋         | 65/1000 [25:38<6:08:51, 23.67s/it][Succeeded / Failed / Skipped / Total] 25 / 40 / 0 / 65:   7%|▋         | 66/1000 [25:38<6:02:57, 23.32s/it][Succeeded / Failed / Skipped / Total] 26 / 40 / 0 / 66:   7%|▋         | 66/1000 [25:38<6:02:57, 23.32s/it][Succeeded / Failed / Skipped / Total] 26 / 40 / 0 / 66:   7%|▋         | 67/1000 [25:47<5:59:14, 23.10s/it][Succeeded / Failed / Skipped / Total] 27 / 40 / 0 / 67:   7%|▋         | 67/1000 [25:47<5:59:14, 23.10s/it][Succeeded / Failed / Skipped / Total] 27 / 40 / 0 / 67:   7%|▋         | 68/1000 [27:24<6:15:42, 24.19s/it][Succeeded / Failed / Skipped / Total] 27 / 41 / 0 / 68:   7%|▋         | 68/1000 [27:24<6:15:42, 24.19s/it][Succeeded / Failed / Skipped / Total] 27 / 41 / 0 / 68:   7%|▋         | 69/1000 [27:28<6:10:40, 23.89s/it][Succeeded / Failed / Skipped / Total] 28 / 41 / 0 / 69:   7%|▋         | 69/1000 [27:28<6:10:41, 23.89s/it][Succeeded / Failed / Skipped / Total] 28 / 41 / 0 / 69:   7%|▋         | 70/1000 [27:29<6:05:12, 23.56s/it][Succeeded / Failed / Skipped / Total] 29 / 41 / 0 / 70:   7%|▋         | 70/1000 [27:29<6:05:12, 23.56s/it][Succeeded / Failed / Skipped / Total] 29 / 41 / 0 / 70:   7%|▋         | 71/1000 [28:40<6:15:11, 24.23s/it]Notify downstream threads of an error . --> [[[FAILED]]]

[[[[Adv]]]]: public final void error ( Throwable t ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( t ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( t ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void error ( Throwable t ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( t ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( t ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 63 ---------------------------------------------
Sets the delay in milliseconds . --> revell amount of time --> Socre: 1.0

[[[[Adv]]]]: public void [[setDelay]] ( long amount , TimeUnit [[unit]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[delayMs]] = [[unit]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void [[revell]] ( long amount , TimeUnit [[panel]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[contained]] = [[panel]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 64 ---------------------------------------------
Completes the task . --> [[[FAILED]]]

[[[[Adv]]]]: public final void complete ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void complete ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 65 ---------------------------------------------
Creates the sample data . --> Create sample data --> Socre: 1.0

[[[[Adv]]]]: private void createSampleData ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication [[auth]] = new UsernamePasswordAuthenticationToken ( username , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void createSampleData ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication [[minimalist]] = new UsernamePasswordAuthenticationToken ( username , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 66 ---------------------------------------------
Calculates the delay in milliseconds . --> Calculates diabolic driving time --> Socre: 1.0

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit [[unit]] ) { float [[delta]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[thalia]] ( TimeUnit [[driving]] ) { float [[diabolic]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 67 ---------------------------------------------
Searches the LDAP directory for the specified user . --> Searches for a list of talkers . --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String [[username]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[username]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[username]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[username]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String [[talkers]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[talkers]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[talkers]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[talkers]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 68 ---------------------------------------------
Requests the specified number of messages from the upstream subscription . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void request ( long n ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void request ( long n ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 69 ---------------------------------------------
Checks if the given raw password matches the given encoded password . --> Returns true if radioshack matches tsao . --> Socre: 1.0

[[[[Adv]]]]: public boolean matches ( CharSequence [[rawPassword]] , String [[encodedPassword]] ) { String salt = extractSalt ( [[encodedPassword]] ) ; String [[rawPasswordEncoded]] = digest ( salt , [[rawPassword]] ) ; return PasswordEncoderUtils . equals ( [[encodedPassword]] . toString ( ) , [[rawPasswordEncoded]] ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean matches ( CharSequence [[radioshack]] , String [[tsao]] ) { String salt = extractSalt ( [[tsao]] ) ; String [[towa]] = digest ( salt , [[radioshack]] ) ; return PasswordEncoderUtils . equals ( [[tsao]] . toString ( ) , [[towa]] ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 70 ---------------------------------------------
Performs version checks for Spring 2 . 0 and above . --> Verifies that ou is not null . --> Socre: 1.0

[[[[Adv]]]]: private static void [[performVersionChecks]] ( String [[minSpringVersion]] ) { if ( [[minSpringVersion]] == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void [[bore]] ( String [[ou]] ) { if ( [[ou]] == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 71 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 29 / 42 / 0 / 71:   7%|▋         | 71/1000 [28:40<6:15:11, 24.23s/it][Succeeded / Failed / Skipped / Total] 29 / 42 / 0 / 71:   7%|▋         | 72/1000 [28:45<6:10:38, 23.96s/it][Succeeded / Failed / Skipped / Total] 29 / 43 / 0 / 72:   7%|▋         | 72/1000 [28:45<6:10:38, 23.96s/it][Succeeded / Failed / Skipped / Total] 29 / 43 / 0 / 72:   7%|▋         | 73/1000 [28:50<6:06:12, 23.70s/it][Succeeded / Failed / Skipped / Total] 30 / 43 / 0 / 73:   7%|▋         | 73/1000 [28:50<6:06:12, 23.70s/it][Succeeded / Failed / Skipped / Total] 30 / 43 / 0 / 73:   7%|▋         | 74/1000 [28:50<6:00:54, 23.38s/it][Succeeded / Failed / Skipped / Total] 30 / 43 / 1 / 74:   7%|▋         | 74/1000 [28:50<6:00:54, 23.38s/it][Succeeded / Failed / Skipped / Total] 30 / 43 / 1 / 74:   8%|▊         | 75/1000 [28:53<5:56:15, 23.11s/it][Succeeded / Failed / Skipped / Total] 31 / 43 / 1 / 75:   8%|▊         | 75/1000 [28:53<5:56:15, 23.11s/it][Succeeded / Failed / Skipped / Total] 31 / 43 / 1 / 75:   8%|▊         | 76/1000 [29:16<5:55:52, 23.11s/it][Succeeded / Failed / Skipped / Total] 32 / 43 / 1 / 76:   8%|▊         | 76/1000 [29:16<5:55:52, 23.11s/it][Succeeded / Failed / Skipped / Total] 32 / 43 / 1 / 76:   8%|▊         | 77/1000 [29:21<5:51:51, 22.87s/it][Succeeded / Failed / Skipped / Total] 32 / 44 / 1 / 77:   8%|▊         | 77/1000 [29:21<5:51:51, 22.87s/it][Succeeded / Failed / Skipped / Total] 32 / 44 / 1 / 77:   8%|▊         | 78/1000 [29:26<5:48:02, 22.65s/it]Returns a sorted view of this observable sequence using the given sort function . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 72 ---------------------------------------------
Removes the given subscription from the list . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 73 ---------------------------------------------
Adds an AttributeExchangeConfigurer to the list of AttributeExchangeConfigurers . --> Add a cordless AttributeExchangeConfigurer with a politburo --> Socre: 1.0

[[[[Adv]]]]: public AttributeExchangeConfigurer [[attributeExchange]] ( String [[identifierPattern]] ) { AttributeExchangeConfigurer [[attributeExchangeConfigurer]] = new AttributeExchangeConfigurer ( [[identifierPattern]] ) ; this . [[attributeExchangeConfigurers]] . add ( [[attributeExchangeConfigurer]] ) ; return [[attributeExchangeConfigurer]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer [[regrette]] ( String [[politburo]] ) { AttributeExchangeConfigurer [[bernardi]] = new AttributeExchangeConfigurer ( [[politburo]] ) ; this . [[cordless]] . add ( [[bernardi]] ) ; return [[bernardi]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 74 ---------------------------------------------
Returns an instance of OAuth2ClientConfigurer --> [[[SKIPPED]]]

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 75 ---------------------------------------------
Gets the OAuth2 resource server configurer . --> Returns a new instance of OAuth2ResourceServerConfigurer --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > oauth2ResourceServer ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > oauth2ResourceServer ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[twister]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[twister]] ) ; return [[twister]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 76 ---------------------------------------------
Returns the registry that will be used to match requests to a channel . --> Dorry the request matcher registry --> Socre: 1.0

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[requiresChannel]] ( ) throws Exception { ApplicationContext [[context]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[context]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[dorry]] ( ) throws Exception { ApplicationContext [[historic]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[historic]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 77 ---------------------------------------------
Observes the given Flowable on the given Scheduler . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > flowable = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > flowable = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 78 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 33 / 44 / 1 / 78:   8%|▊         | 78/1000 [29:26<5:48:02, 22.65s/it][Succeeded / Failed / Skipped / Total] 33 / 44 / 1 / 78:   8%|▊         | 79/1000 [29:57<5:49:11, 22.75s/it][Succeeded / Failed / Skipped / Total] 33 / 45 / 1 / 79:   8%|▊         | 79/1000 [29:57<5:49:11, 22.75s/it][Succeeded / Failed / Skipped / Total] 33 / 45 / 1 / 79:   8%|▊         | 80/1000 [30:00<5:45:04, 22.50s/it][Succeeded / Failed / Skipped / Total] 34 / 45 / 1 / 80:   8%|▊         | 80/1000 [30:00<5:45:04, 22.50s/it][Succeeded / Failed / Skipped / Total] 34 / 45 / 1 / 80:   8%|▊         | 81/1000 [30:25<5:45:13, 22.54s/it][Succeeded / Failed / Skipped / Total] 35 / 45 / 1 / 81:   8%|▊         | 81/1000 [30:25<5:45:13, 22.54s/it][Succeeded / Failed / Skipped / Total] 35 / 45 / 1 / 81:   8%|▊         | 82/1000 [30:26<5:40:45, 22.27s/it]Retrieve an LDAP entry . --> Execute with timeout --> Socre: 1.0

[[[[Adv]]]]: public DirContextOperations [[retrieveEntry]] ( final String [[dn]] , final String [ ] [[attributesToRetrieve]] ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext [[ctx]] ) throws NamingException { Attributes attrs = [[ctx]] . getAttributes ( [[dn]] , [[attributesToRetrieve]] ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations [[pursuer]] ( final String [[nl]] , final String [ ] [[array]] ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext [[timeout]] ) throws NamingException { Attributes attrs = [[timeout]] . getAttributes ( [[nl]] , [[array]] ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 79 ---------------------------------------------
Encodes the given password using the configured salt . --> [[[FAILED]]]

[[[[Adv]]]]: public String encode ( CharSequence rawPassword ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , rawPassword ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String encode ( CharSequence rawPassword ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , rawPassword ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 80 ---------------------------------------------
Compares an attribute of a LDAP directory with a value . --> Returns true if df is counterpart to magician --> Socre: 1.0

[[[[Adv]]]]: public boolean [[compare]] ( final String [[dn]] , final String [[attributeName]] , final Object value ) { final String comparisonFilter = "(" + [[attributeName]] + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( [[dn]] , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean [[counterpart]] ( final String [[df]] , final String [[magician]] , final Object value ) { final String comparisonFilter = "(" + [[magician]] + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( [[df]] , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 81 ---------------------------------------------
Search for a single entry in a context . --> Returns a list of DirContextAdapters for the specified nucleus and filter --> Socre: 1.0

[[[[Adv]]]]: public static DirContextOperations [[searchForSingleEntryInternal]] ( DirContext ctx , SearchControls searchControls , String [[base]] , String [[filter]] , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName [[searchBaseDn]] = new DistinguishedName ( [[base]] ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( [[searchBaseDn]] , [[filter]] , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + [[searchBaseDn]] + "', filter = '" + [[filter]] + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations [[baxters]] ( DirContext ctx , SearchControls searchControls , String [[nucleus]] , String [[cleaners]] , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName [[vultures]] = new DistinguishedName ( [[nucleus]] ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( [[vultures]] , [[cleaners]] , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + [[vultures]] + "', filter = '" + [[cleaners]] + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 82 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 36 / 45 / 1 / 82:   8%|▊         | 82/1000 [30:26<5:40:45, 22.27s/it][Succeeded / Failed / Skipped / Total] 36 / 46 / 1 / 83:   8%|▊         | 83/1000 [30:26<5:36:17, 22.00s/it][Succeeded / Failed / Skipped / Total] 36 / 46 / 1 / 83:   8%|▊         | 84/1000 [30:34<5:33:24, 21.84s/it][Succeeded / Failed / Skipped / Total] 36 / 47 / 1 / 84:   8%|▊         | 84/1000 [30:34<5:33:24, 21.84s/it][Succeeded / Failed / Skipped / Total] 37 / 47 / 1 / 85:   8%|▊         | 85/1000 [30:52<5:32:26, 21.80s/it][Succeeded / Failed / Skipped / Total] 37 / 47 / 1 / 85:   9%|▊         | 86/1000 [30:56<5:28:48, 21.58s/it]Builds the SearchControls object . --> russian implementation of SearchControls --> Socre: 1.0

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[russian]] ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 83 ---------------------------------------------
Creates an error response . --> [[[FAILED]]]

[[[[Adv]]]]: public Response < ? > createErrorResponse ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > createErrorResponse ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 84 ---------------------------------------------
Returns the HttpMethod object corresponding to the given string . --> [[[FAILED]]]

[[[[Adv]]]]: private static HttpMethod valueOf ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod valueOf ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 85 ---------------------------------------------
Creates the embedded server bean definition . --> yutaka bean definition --> Socre: 1.0

[[[[Adv]]]]: private RootBeanDefinition [[createEmbeddedServer]] ( Element [[element]] , ParserContext parserContext ) { Object source = parserContext . extractSource ( [[element]] ) ; String suffix = [[element]] . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = [[element]] . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = [[element]] . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , [[element]] ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition [[yutaka]] ( Element [[shutters]] , ParserContext parserContext ) { Object source = parserContext . extractSource ( [[shutters]] ) ; String suffix = [[shutters]] . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = [[shutters]] . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = [[shutters]] . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , [[shutters]] ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 86 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 38 / 47 / 1 / 86:   9%|▊         | 86/1000 [30:56<5:28:48, 21.58s/it][Succeeded / Failed / Skipped / Total] 38 / 47 / 1 / 86:   9%|▊         | 87/1000 [30:59<5:25:19, 21.38s/it][Succeeded / Failed / Skipped / Total] 39 / 47 / 1 / 87:   9%|▊         | 87/1000 [30:59<5:25:19, 21.38s/it][Succeeded / Failed / Skipped / Total] 39 / 47 / 1 / 87:   9%|▉         | 88/1000 [31:57<5:31:07, 21.78s/it][Succeeded / Failed / Skipped / Total] 39 / 48 / 1 / 88:   9%|▉         | 88/1000 [31:57<5:31:07, 21.78s/it][Succeeded / Failed / Skipped / Total] 39 / 48 / 1 / 88:   9%|▉         | 89/1000 [31:57<5:27:05, 21.54s/it][Succeeded / Failed / Skipped / Total] 39 / 48 / 2 / 89:   9%|▉         | 89/1000 [31:57<5:27:05, 21.54s/it][Succeeded / Failed / Skipped / Total] 39 / 48 / 2 / 89:   9%|▉         | 90/1000 [32:51<5:32:10, 21.90s/it][Succeeded / Failed / Skipped / Total] 40 / 48 / 2 / 90:   9%|▉         | 90/1000 [32:51<5:32:10, 21.90s/it][Succeeded / Failed / Skipped / Total] 40 / 48 / 2 / 90:   9%|▉         | 91/1000 [33:13<5:31:51, 21.91s/it][Succeeded / Failed / Skipped / Total] 40 / 49 / 2 / 91:   9%|▉         | 91/1000 [33:13<5:31:51, 21.91s/it][Succeeded / Failed / Skipped / Total] 40 / 49 / 2 / 91:   9%|▉         | 92/1000 [33:42<5:32:39, 21.98s/it]Creates the servlet api filter . --> Fauna . --> Socre: 1.0

[[[[Adv]]]]: private void [[createServletApiFilter]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String [[DEF_SERVLET_API_PROVISION]] = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = [[DEF_SERVLET_API_PROVISION]] ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void [[fauna]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String [[WATCHTOWERS]] = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = [[WATCHTOWERS]] ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 87 ---------------------------------------------
Creates the jaas api filter . --> Set jaasApiFilter based on httpElt attribute . --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String [[DEF_JAAS_API_PROVISION]] = "false" ; String [[provideJaasApi]] = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( [[provideJaasApi]] ) ) { [[provideJaasApi]] = [[DEF_JAAS_API_PROVISION]] ; } if ( "true" . equals ( [[provideJaasApi]] ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[bothered]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String [[IPOD]] = "false" ; String [[guiltless]] = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( [[guiltless]] ) ) { [[guiltless]] = [[IPOD]] ; } if ( "true" . equals ( [[guiltless]] ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 88 ---------------------------------------------
Returns true if disable checks are enabled for the given spring version and security version --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean disableChecks ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean disableChecks ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 89 ---------------------------------------------
Insert Spring Security filter chain . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 90 ---------------------------------------------
Builds the web authentication details . --> sketching for J2EE roles and granted authorities --> Socre: 1.0

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[buildDetails]] ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[result]] = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return [[result]] ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[sketching]] ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[successes]] = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return [[successes]] ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 91 ---------------------------------------------
Returns the version of Spring security . --> [[[FAILED]]]

[[[[Adv]]]]: private static String getSpringVersion ( ) { Properties properties = new Properties ( ) ; try { properties . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return properties . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String getSpringVersion ( ) { Properties properties = new Properties ( ) ; try { properties . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return properties . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 92 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 41 / 49 / 2 / 92:   9%|▉         | 92/1000 [33:42<5:32:39, 21.98s/it][Succeeded / Failed / Skipped / Total] 41 / 49 / 2 / 92:   9%|▉         | 93/1000 [34:00<5:31:35, 21.94s/it][Succeeded / Failed / Skipped / Total] 41 / 50 / 2 / 93:   9%|▉         | 93/1000 [34:00<5:31:35, 21.94s/it][Succeeded / Failed / Skipped / Total] 41 / 50 / 2 / 93:   9%|▉         | 94/1000 [34:16<5:30:19, 21.88s/it][Succeeded / Failed / Skipped / Total] 41 / 51 / 2 / 94:   9%|▉         | 94/1000 [34:16<5:30:19, 21.88s/it][Succeeded / Failed / Skipped / Total] 41 / 51 / 2 / 94:  10%|▉         | 95/1000 [34:55<5:32:38, 22.05s/it][Succeeded / Failed / Skipped / Total] 42 / 51 / 2 / 95:  10%|▉         | 95/1000 [34:55<5:32:38, 22.05s/it][Succeeded / Failed / Skipped / Total] 42 / 51 / 2 / 95:  10%|▉         | 96/1000 [35:43<5:36:28, 22.33s/it][Succeeded / Failed / Skipped / Total] 42 / 52 / 2 / 96:  10%|▉         | 96/1000 [35:43<5:36:28, 22.33s/it][Succeeded / Failed / Skipped / Total] 42 / 52 / 2 / 96:  10%|▉         | 97/1000 [36:15<5:37:34, 22.43s/it]Creates a new cipher with the specified encryption algorithm . --> Calculates an encryption algorithm --> Socre: 1.0

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String [[algorithm]] ) { try { return Cipher . getInstance ( [[algorithm]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[isle]] ( String [[calculate]] ) { try { return Cipher . getInstance ( [[calculate]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 93 ---------------------------------------------
Parses the annotations and returns the HttpServiceMethod . --> [[[FAILED]]]

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 94 ---------------------------------------------
Search for multiple attribute values . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 95 ---------------------------------------------
Checks if the pre - authenticated principal has changed to the principal of the current authentication . --> Vera - vera - vera - vera - vera - vera --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[principalChanged]] ( HttpServletRequest request , Authentication [[currentAuthentication]] ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && [[currentAuthentication]] . getName ( ) . equals ( principal ) ) { return "[[False]]" != "[[False]]" ; } if ( principal != null && principal . equals ( [[currentAuthentication]] . getPrincipal ( ) ) ) { return "[[False]]" != "[[False]]" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean [[dano]] ( HttpServletRequest request , Authentication [[dachshund]] ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && [[dachshund]] . getName ( ) . equals ( principal ) ) { return "[[Counterfeits]]" != "[[Counterfeits]]" ; } if ( principal != null && principal . equals ( [[dachshund]] . getPrincipal ( ) ) ) { return "[[Counterfeits]]" != "[[Counterfeits]]" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "[[Vera]]" == "[[Vera]]" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 96 ---------------------------------------------
Creates a whitelisted default type resolver builder . --> [[[FAILED]]]

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > createWhitelistedDefaultTyping ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > createWhitelistedDefaultTyping ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 97 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 42 / 53 / 2 / 97:  10%|▉         | 97/1000 [36:15<5:37:34, 22.43s/it][Succeeded / Failed / Skipped / Total] 42 / 53 / 2 / 97:  10%|▉         | 98/1000 [36:49<5:38:57, 22.55s/it][Succeeded / Failed / Skipped / Total] 42 / 54 / 2 / 98:  10%|▉         | 98/1000 [36:49<5:38:57, 22.55s/it][Succeeded / Failed / Skipped / Total] 42 / 54 / 2 / 98:  10%|▉         | 99/1000 [37:12<5:38:35, 22.55s/it][Succeeded / Failed / Skipped / Total] 43 / 54 / 2 / 99:  10%|▉         | 99/1000 [37:12<5:38:35, 22.55s/it][Succeeded / Failed / Skipped / Total] 43 / 54 / 2 / 99:  10%|█         | 100/1000 [37:18<5:35:45, 22.38s/it][Succeeded / Failed / Skipped / Total] 43 / 55 / 2 / 100:  10%|█         | 100/1000 [37:18<5:35:45, 22.38s/it][Succeeded / Failed / Skipped / Total] 43 / 55 / 2 / 100:  10%|█         | 101/1000 [37:34<5:34:24, 22.32s/it][Succeeded / Failed / Skipped / Total] 44 / 55 / 2 / 101:  10%|█         | 101/1000 [37:34<5:34:24, 22.32s/it][Succeeded / Failed / Skipped / Total] 44 / 55 / 2 / 101:  10%|█         | 102/1000 [37:36<5:31:07, 22.12s/it]Get a persistent remember me token for a series . --> [[[FAILED]]]

[[[[Adv]]]]: public PersistentRememberMeToken getTokenForSeries ( String seriesId ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , seriesId ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + seriesId + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + seriesId + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + seriesId , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken getTokenForSeries ( String seriesId ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , seriesId ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + seriesId + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + seriesId + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + seriesId , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 98 ---------------------------------------------
Lookup the primary keys . --> [[[FAILED]]]

[[[[Adv]]]]: private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 99 ---------------------------------------------
Sets the login processing url . --> Set COiffure for OWB Authentication --> Socre: 1.0

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String [[loginProcessingUrl]] ) { this . [[loginProcessingUrl]] = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[owww]] ( String [[coiffure]] ) { this . [[prosser]] = [[owww]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[owww]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 100 ---------------------------------------------
Search for multiple values by attribute name . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 101 ---------------------------------------------
Updates the default access defaults for the HTTP client . --> nah bah bah bah bah --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B [[http]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[http]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[nah]] ( B [[com]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[com]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 102 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 44 / 56 / 2 / 102:  10%|█         | 102/1000 [37:36<5:31:07, 22.12s/it][Succeeded / Failed / Skipped / Total] 44 / 56 / 2 / 102:  10%|█         | 103/1000 [37:38<5:27:46, 21.93s/it][Succeeded / Failed / Skipped / Total] 45 / 56 / 2 / 103:  10%|█         | 103/1000 [37:38<5:27:46, 21.93s/it][Succeeded / Failed / Skipped / Total] 45 / 56 / 2 / 103:  10%|█         | 104/1000 [37:40<5:24:36, 21.74s/it][Succeeded / Failed / Skipped / Total] 46 / 56 / 2 / 104:  10%|█         | 104/1000 [37:40<5:24:36, 21.74s/it][Succeeded / Failed / Skipped / Total] 46 / 56 / 2 / 104:  10%|█         | 105/1000 [38:15<5:26:04, 21.86s/it][Succeeded / Failed / Skipped / Total] 46 / 57 / 2 / 105:  10%|█         | 105/1000 [38:15<5:26:04, 21.86s/it][Succeeded / Failed / Skipped / Total] 46 / 57 / 2 / 105:  11%|█         | 106/1000 [38:42<5:26:31, 21.91s/it][Succeeded / Failed / Skipped / Total] 47 / 57 / 2 / 106:  11%|█         | 106/1000 [38:42<5:26:31, 21.91s/it][Succeeded / Failed / Skipped / Total] 47 / 57 / 2 / 106:  11%|█         | 107/1000 [40:20<5:36:40, 22.62s/it]Returns a list of all granted authorities for the given attributes . --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { List < GrantedAuthority > result = new ArrayList <> ( attributes . size ( ) ) ; for ( String attribute : attributes ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { List < GrantedAuthority > result = new ArrayList <> ( attributes . size ( ) ) ; for ( String attribute : attributes ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 103 ---------------------------------------------
Map a password value to a string . --> If passwordValue is not a String return null ; --> Socre: 1.0

[[[[Adv]]]]: protected String [[mapPassword]] ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[tko]] ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 104 ---------------------------------------------
Encodes the cookie tokens . --> Encode a string array to a base64 string --> Socre: 1.0

[[[[Adv]]]]: protected String encodeCookie ( String [ ] [[cookieTokens]] ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < [[cookieTokens]] . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( [[cookieTokens]] [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < [[cookieTokens]] . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String encodeCookie ( String [ ] [[bienvenido]] ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < [[bienvenido]] . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( [[bienvenido]] [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < [[bienvenido]] . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 105 ---------------------------------------------
Checks if the request requires authentication . --> [[[FAILED]]]

[[[[Adv]]]]: public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 106 ---------------------------------------------
Adds a cookie to the response . --> Alfredo alfredo cookies --> Socre: 1.0

[[[[Adv]]]]: protected void [[setCookie]] ( String [ ] [[tokens]] , int [[maxAge]] , HttpServletRequest [[request]] , HttpServletResponse response ) { String cookieValue = encodeCookie ( [[tokens]] ) ; Cookie [[cookie]] = new Cookie ( cookieName , cookieValue ) ; [[cookie]] . setMaxAge ( [[maxAge]] ) ; [[cookie]] . setPath ( getCookiePath ( [[request]] ) ) ; if ( cookieDomain != null ) { [[cookie]] . setDomain ( cookieDomain ) ; } if ( [[maxAge]] < 1 ) { [[cookie]] . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { [[cookie]] . setSecure ( [[request]] . isSecure ( ) ) ; } else { [[cookie]] . setSecure ( useSecureCookie ) ; } [[cookie]] . setHttpOnly ( "True" == "True" ) ; response . addCookie ( [[cookie]] ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void [[alfredo]] ( String [ ] [[souvenirs]] , int [[hannon]] , HttpServletRequest [[wondering]] , HttpServletResponse response ) { String cookieValue = encodeCookie ( [[souvenirs]] ) ; Cookie [[pastries]] = new Cookie ( cookieName , cookieValue ) ; [[pastries]] . setMaxAge ( [[hannon]] ) ; [[pastries]] . setPath ( getCookiePath ( [[wondering]] ) ) ; if ( cookieDomain != null ) { [[pastries]] . setDomain ( cookieDomain ) ; } if ( [[hannon]] < 1 ) { [[pastries]] . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { [[pastries]] . setSecure ( [[wondering]] . isSecure ( ) ) ; } else { [[pastries]] . setSecure ( useSecureCookie ) ; } [[pastries]] . setHttpOnly ( "True" == "True" ) ; response . addCookie ( [[pastries]] ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 107 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 47 / 58 / 2 / 107:  11%|█         | 107/1000 [40:20<5:36:40, 22.62s/it][Succeeded / Failed / Skipped / Total] 47 / 58 / 2 / 107:  11%|█         | 108/1000 [41:12<5:40:19, 22.89s/it][Succeeded / Failed / Skipped / Total] 47 / 59 / 2 / 108:  11%|█         | 108/1000 [41:12<5:40:19, 22.89s/it][Succeeded / Failed / Skipped / Total] 47 / 59 / 2 / 108:  11%|█         | 109/1000 [41:18<5:37:37, 22.74s/it][Succeeded / Failed / Skipped / Total] 47 / 60 / 2 / 109:  11%|█         | 109/1000 [41:18<5:37:37, 22.74s/it][Succeeded / Failed / Skipped / Total] 47 / 60 / 2 / 109:  11%|█         | 110/1000 [41:26<5:35:18, 22.61s/it][Succeeded / Failed / Skipped / Total] 47 / 61 / 2 / 110:  11%|█         | 110/1000 [41:26<5:35:18, 22.61s/it][Succeeded / Failed / Skipped / Total] 47 / 61 / 2 / 110:  11%|█         | 111/1000 [41:28<5:32:14, 22.42s/it][Succeeded / Failed / Skipped / Total] 48 / 61 / 2 / 111:  11%|█         | 111/1000 [41:28<5:32:14, 22.42s/it][Succeeded / Failed / Skipped / Total] 48 / 61 / 2 / 111:  11%|█         | 112/1000 [41:34<5:29:40, 22.27s/it]Performs pre - authenticated authentication . --> [[[FAILED]]]

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 108 ---------------------------------------------
Check the content length and call onResponseCommitted if necessary . --> [[[FAILED]]]

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 109 ---------------------------------------------
Converts a collection of authorities to a set of GrantedAuthority objects . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 110 ---------------------------------------------
Extract remember - me cookie from request . --> [[[FAILED]]]

[[[[Adv]]]]: protected String extractRememberMeCookie ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String extractRememberMeCookie ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 111 ---------------------------------------------
Authenticates the given authentication object . --> Authenticate a meander . --> Socre: 1.0

[[[[Adv]]]]: public Authentication authenticate ( Authentication [[auth]] ) throws AuthenticationException { if ( ! ( [[auth]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) [[auth]] ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication authenticate ( Authentication [[meander]] ) throws AuthenticationException { if ( ! ( [[meander]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) [[meander]] ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 112 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 49 / 61 / 2 / 112:  11%|█         | 112/1000 [41:34<5:29:40, 22.27s/it][Succeeded / Failed / Skipped / Total] 49 / 61 / 2 / 112:  11%|█▏        | 113/1000 [41:45<5:27:43, 22.17s/it][Succeeded / Failed / Skipped / Total] 50 / 61 / 2 / 113:  11%|█▏        | 113/1000 [41:45<5:27:43, 22.17s/it][Succeeded / Failed / Skipped / Total] 50 / 61 / 2 / 113:  11%|█▏        | 114/1000 [41:56<5:25:56, 22.07s/it][Succeeded / Failed / Skipped / Total] 50 / 62 / 2 / 114:  11%|█▏        | 114/1000 [41:56<5:25:56, 22.07s/it][Succeeded / Failed / Skipped / Total] 50 / 62 / 2 / 114:  12%|█▏        | 115/1000 [42:18<5:25:32, 22.07s/it][Succeeded / Failed / Skipped / Total] 51 / 62 / 2 / 115:  12%|█▏        | 115/1000 [42:18<5:25:32, 22.07s/it][Succeeded / Failed / Skipped / Total] 51 / 62 / 2 / 115:  12%|█▏        | 116/1000 [42:19<5:22:32, 21.89s/it][Succeeded / Failed / Skipped / Total] 51 / 63 / 2 / 116:  12%|█▏        | 116/1000 [42:19<5:22:32, 21.89s/it][Succeeded / Failed / Skipped / Total] 51 / 63 / 2 / 116:  12%|█▏        | 117/1000 [42:51<5:23:30, 21.98s/it][Succeeded / Failed / Skipped / Total] 51 / 64 / 2 / 117:  12%|█▏        | 117/1000 [42:51<5:23:30, 21.98s/it][Succeeded / Failed / Skipped / Total] 51 / 64 / 2 / 117:  12%|█▏        | 118/1000 [42:54<5:20:44, 21.82s/it][Succeeded / Failed / Skipped / Total] 52 / 64 / 2 / 118:  12%|█▏        | 118/1000 [42:54<5:20:44, 21.82s/it][Succeeded / Failed / Skipped / Total] 52 / 64 / 2 / 118:  12%|█▏        | 119/1000 [43:22<5:21:04, 21.87s/it]Logout handler . --> If invalidateHttpSession is set invalidateAuthentication and clearAuthentication --> Socre: 1.0

[[[[Adv]]]]: public void [[logout]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[authentication]] ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void [[selma]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[validation]] ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 113 ---------------------------------------------
Sets the environment properties for this context . --> Pequeo para pequeo --> Socre: 1.0

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . [[contextEnvironmentProperties]] = new Hashtable <> ( environment ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[pequeño]] ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . [[truely]] = new Hashtable <> ( environment ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 114 ---------------------------------------------
Updates the authentication defaults . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void updateAuthenticationDefaults ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void updateAuthenticationDefaults ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 115 ---------------------------------------------
Returns the principal associated with the current authentication . --> с с LdapUserDetails с --> Socre: 1.0

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[с]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 116 ---------------------------------------------
Override afterPropertiesSet to catch ServletExceptions . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void afterPropertiesSet ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void afterPropertiesSet ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 117 ---------------------------------------------
Get the query string from the request . --> [[[FAILED]]]

[[[[Adv]]]]: private String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 118 ---------------------------------------------
Initializes the user details service . --> to --> Socre: 1.0

[[[[Adv]]]]: @ Override protected void [[initUserDetailsService]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . [[users]] ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void [[što]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . [[login]] ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
[Succeeded / Failed / Skipped / Total] 53 / 64 / 2 / 119:  12%|█▏        | 119/1000 [43:22<5:21:04, 21.87s/it][Succeeded / Failed / Skipped / Total] 53 / 64 / 2 / 119:  12%|█▏        | 120/1000 [43:50<5:21:31, 21.92s/it][Succeeded / Failed / Skipped / Total] 54 / 64 / 2 / 120:  12%|█▏        | 120/1000 [43:50<5:21:31, 21.92s/it][Succeeded / Failed / Skipped / Total] 54 / 64 / 2 / 120:  12%|█▏        | 121/1000 [43:54<5:19:01, 21.78s/it][Succeeded / Failed / Skipped / Total] 54 / 65 / 2 / 121:  12%|█▏        | 121/1000 [43:54<5:19:01, 21.78s/it][Succeeded / Failed / Skipped / Total] 54 / 65 / 2 / 121:  12%|█▏        | 122/1000 [44:21<5:19:14, 21.82s/it][Succeeded / Failed / Skipped / Total] 54 / 66 / 2 / 122:  12%|█▏        | 122/1000 [44:21<5:19:14, 21.82s/it][Succeeded / Failed / Skipped / Total] 54 / 66 / 2 / 122:  12%|█▏        | 123/1000 [45:03<5:21:18, 21.98s/it][Succeeded / Failed / Skipped / Total] 54 / 67 / 2 / 123:  12%|█▏        | 123/1000 [45:03<5:21:18, 21.98s/it][Succeeded / Failed / Skipped / Total] 54 / 67 / 2 / 123:  12%|█▏        | 124/1000 [45:55<5:24:24, 22.22s/it][Succeeded / Failed / Skipped / Total] 55 / 67 / 2 / 124:  12%|█▏        | 124/1000 [45:55<5:24:24, 22.22s/it][Succeeded / Failed / Skipped / Total] 55 / 67 / 2 / 124:  12%|█▎        | 125/1000 [46:46<5:27:22, 22.45s/it]--------------------------------------------- Result 119 ---------------------------------------------
Determine if the request requires authentication . --> Do we need authentication? --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[requiresAuthentication]] ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean [[serviceTicketRequest]] = [[serviceTicketRequest]] ( request , response ) ; final boolean result = [[serviceTicketRequest]] || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( [[serviceTicketRequest]] , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean [[burnin]] ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean [[mario]] = [[mario]] ( request , response ) ; final boolean result = [[mario]] || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( [[mario]] , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 120 ---------------------------------------------
Render the end of the HTML tag . --> stealin - stealin - stealin - stealin - stealin --> Socre: 1.0

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[stealin]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 121 ---------------------------------------------
Resolves the value of the given parameter . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 122 ---------------------------------------------
Gets the service port . --> [[[FAILED]]]

[[[[Adv]]]]: private static int getServicePort ( URL casServiceUrl ) { int port = casServiceUrl . getPort ( ) ; if ( port == - 1 ) { port = casServiceUrl . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int getServicePort ( URL casServiceUrl ) { int port = casServiceUrl . getPort ( ) ; if ( port == - 1 ) { port = casServiceUrl . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 123 ---------------------------------------------
Adds the pkce parameters to the attributes and additionalParameters --> [[[FAILED]]]

[[[[Adv]]]]: private void addPkceParameters ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void addPkceParameters ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 124 ---------------------------------------------
Service ticket request boolean . --> Do we need authentication? --> Socre: 1.0

[[[[Adv]]]]: private boolean [[serviceTicketRequest]] ( final HttpServletRequest request , final HttpServletResponse [[response]] ) { boolean [[result]] = super . requiresAuthentication ( request , [[response]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean [[wobbling]] ( final HttpServletRequest request , final HttpServletResponse [[solution]] ) { boolean [[achievements]] = super . requiresAuthentication ( request , [[solution]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[achievements]] ) ; } return [[achievements]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 125 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 56 / 67 / 2 / 125:  12%|█▎        | 125/1000 [46:46<5:27:22, 22.45s/it][Succeeded / Failed / Skipped / Total] 56 / 67 / 2 / 125:  13%|█▎        | 126/1000 [46:47<5:24:32, 22.28s/it][Succeeded / Failed / Skipped / Total] 57 / 67 / 2 / 126:  13%|█▎        | 126/1000 [46:47<5:24:32, 22.28s/it][Succeeded / Failed / Skipped / Total] 57 / 67 / 2 / 126:  13%|█▎        | 127/1000 [47:21<5:25:31, 22.37s/it][Succeeded / Failed / Skipped / Total] 57 / 68 / 2 / 127:  13%|█▎        | 127/1000 [47:21<5:25:31, 22.37s/it][Succeeded / Failed / Skipped / Total] 57 / 68 / 2 / 127:  13%|█▎        | 128/1000 [47:28<5:23:22, 22.25s/it][Succeeded / Failed / Skipped / Total] 57 / 69 / 2 / 128:  13%|█▎        | 128/1000 [47:28<5:23:22, 22.25s/it][Succeeded / Failed / Skipped / Total] 57 / 69 / 2 / 128:  13%|█▎        | 129/1000 [48:01<5:24:16, 22.34s/it][Succeeded / Failed / Skipped / Total] 57 / 70 / 2 / 129:  13%|█▎        | 129/1000 [48:01<5:24:16, 22.34s/it][Succeeded / Failed / Skipped / Total] 57 / 70 / 2 / 129:  13%|█▎        | 130/1000 [48:06<5:21:59, 22.21s/it][Succeeded / Failed / Skipped / Total] 57 / 71 / 2 / 130:  13%|█▎        | 130/1000 [48:06<5:21:59, 22.21s/it][Succeeded / Failed / Skipped / Total] 57 / 71 / 2 / 130:  13%|█▎        | 131/1000 [48:25<5:21:16, 22.18s/it]Gets the JWKSet . --> Auxiliary method to fetch JWKSet --> Socre: 1.0

[[[[Adv]]]]: private Mono < JWKSet > [[getJWKSet]] ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > [[niveau]] ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 126 ---------------------------------------------
URL - encodes the given value using UTF - 8 . --> Encodes the interest in megamind format . --> Socre: 1.0

[[[[Adv]]]]: private String [[utf8UrlEncode]] ( String [[value]] ) { try { return URLEncoder . encode ( [[value]] , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8

[[[[Adv]]]]: private String [[megamind]] ( String [[interest]] ) { try { return URLEncoder . encode ( [[interest]] , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 127 ---------------------------------------------
Gets the UserDetailsService . --> [[[FAILED]]]

[[[[Adv]]]]: private UserDetailsService getUserDetailsService ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService getUserDetailsService ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 128 ---------------------------------------------
Builds the LDAP provider URL from a list of URLs . --> [[[FAILED]]]

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 129 ---------------------------------------------
Proxy ticket request . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 130 ---------------------------------------------
Returns the redirect URL for this request . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public String getRedirectUrl ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String getRedirectUrl ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 131 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 58 / 71 / 2 / 131:  13%|█▎        | 131/1000 [48:25<5:21:16, 22.18s/it][Succeeded / Failed / Skipped / Total] 58 / 71 / 2 / 131:  13%|█▎        | 132/1000 [48:41<5:20:12, 22.13s/it][Succeeded / Failed / Skipped / Total] 58 / 72 / 2 / 132:  13%|█▎        | 132/1000 [48:41<5:20:12, 22.13s/it][Succeeded / Failed / Skipped / Total] 58 / 72 / 2 / 132:  13%|█▎        | 133/1000 [48:42<5:17:29, 21.97s/it][Succeeded / Failed / Skipped / Total] 59 / 72 / 2 / 133:  13%|█▎        | 133/1000 [48:42<5:17:29, 21.97s/it][Succeeded / Failed / Skipped / Total] 59 / 72 / 2 / 133:  13%|█▎        | 134/1000 [48:45<5:15:04, 21.83s/it][Succeeded / Failed / Skipped / Total] 60 / 72 / 2 / 134:  13%|█▎        | 134/1000 [48:45<5:15:04, 21.83s/it][Succeeded / Failed / Skipped / Total] 60 / 72 / 2 / 134:  14%|█▎        | 135/1000 [48:47<5:12:35, 21.68s/it][Succeeded / Failed / Skipped / Total] 61 / 72 / 2 / 135:  14%|█▎        | 135/1000 [48:47<5:12:35, 21.68s/it][Succeeded / Failed / Skipped / Total] 61 / 72 / 2 / 135:  14%|█▎        | 136/1000 [49:03<5:11:38, 21.64s/it][Succeeded / Failed / Skipped / Total] 61 / 73 / 2 / 136:  14%|█▎        | 136/1000 [49:03<5:11:38, 21.64s/it][Succeeded / Failed / Skipped / Total] 61 / 73 / 2 / 136:  14%|█▎        | 137/1000 [49:31<5:11:55, 21.69s/it][Succeeded / Failed / Skipped / Total] 62 / 73 / 2 / 137:  14%|█▎        | 137/1000 [49:31<5:11:55, 21.69s/it][Succeeded / Failed / Skipped / Total] 62 / 73 / 2 / 137:  14%|█▍        | 138/1000 [49:47<5:11:02, 21.65s/it]Returns a sub - array of the specified byte array . --> Carte el nosotros carte --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[subArray]] ( byte [ ] [[array]] , int [[beginIndex]] , int [[endIndex]] ) { int length = [[endIndex]] - [[beginIndex]] ; byte [ ] [[subarray]] = new byte [ length ] ; System . arraycopy ( [[array]] , [[beginIndex]] , [[subarray]] , 0 , length ) ; return [[subarray]] ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] [[carte]] ( byte [ ] [[gama]] , int [[promenade]] , int [[nosotros]] ) { int length = [[nosotros]] - [[promenade]] ; byte [ ] [[emeralds]] = new byte [ length ] ; System . arraycopy ( [[gama]] , [[promenade]] , [[emeralds]] , 0 , length ) ; return [[emeralds]] ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 132 ---------------------------------------------
Returns true if the current user is authenticated . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean authenticated ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) && ! ( authentication instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean authenticated ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) && ! ( authentication instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 133 ---------------------------------------------
Concatenate two byte arrays . --> Generate phonecall data from phonecall tables --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[concatenate]] ( byte [ ] ... [[arrays]] ) { int [[length]] = 0 ; for ( byte [ ] array : [[arrays]] ) { [[length]] += array . length ; } byte [ ] [[newArray]] = new byte [ [[length]] ] ; int [[destPos]] = 0 ; for ( byte [ ] array : [[arrays]] ) { System . arraycopy ( array , 0 , [[newArray]] , [[destPos]] , array . length ) ; [[destPos]] += array . length ; } return [[newArray]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] [[phonecall]] ( byte [ ] ... [[tables]] ) { int [[protracted]] = 0 ; for ( byte [ ] array : [[tables]] ) { [[protracted]] += array . length ; } byte [ ] [[musica]] = new byte [ [[protracted]] ] ; int [[goering]] = 0 ; for ( byte [ ] array : [[tables]] ) { System . arraycopy ( array , 0 , [[musica]] , [[goering]] , array . length ) ; [[goering]] += array . length ; } return [[musica]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 134 ---------------------------------------------
Gets the GrantedAuthority collection . --> Putsch method . --> Socre: 1.0

[[[[Adv]]]]: private Collection < GrantedAuthority > [[getGrantedAuthorityCollection]] ( Object value ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , value ) ; return result ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > [[putsch]] ( Object value ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , value ) ; return result ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 135 ---------------------------------------------
Pre - processes a map of attributes to granted authorities . --> Pontypool . --> Socre: 1.0

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[preProcessMap]] ( Map < ? , ? > [[orgMap]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[orgMap]] . size ( ) ) ; for ( Map . Entry < ? , ? > entry : [[orgMap]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[pontypool]] ( Map < ? , ? > [[brûlée]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[brûlée]] . size ( ) ) ; for ( Map . Entry < ? , ? > entry : [[brûlée]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 136 ---------------------------------------------
Checks if the proxy receptor is configured and matches the request . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean proxyReceptorRequest ( final HttpServletRequest request ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean proxyReceptorRequest ( final HttpServletRequest request ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 137 ---------------------------------------------
Gets the pre - authenticated principal . --> travelin - travelin - travelin - travelin --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[travelin]] ( HttpServletRequest [[awl]] ) { Object [[big]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[big]] ) ; } return [[big]] ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 138 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 62 / 74 / 2 / 138:  14%|█▍        | 138/1000 [49:47<5:11:02, 21.65s/it][Succeeded / Failed / Skipped / Total] 62 / 74 / 2 / 138:  14%|█▍        | 139/1000 [50:23<5:12:08, 21.75s/it][Succeeded / Failed / Skipped / Total] 63 / 74 / 2 / 139:  14%|█▍        | 139/1000 [50:23<5:12:08, 21.75s/it][Succeeded / Failed / Skipped / Total] 63 / 74 / 2 / 139:  14%|█▍        | 140/1000 [50:51<5:12:27, 21.80s/it][Succeeded / Failed / Skipped / Total] 63 / 75 / 2 / 140:  14%|█▍        | 140/1000 [50:51<5:12:27, 21.80s/it][Succeeded / Failed / Skipped / Total] 63 / 75 / 2 / 140:  14%|█▍        | 141/1000 [51:03<5:11:01, 21.72s/it][Succeeded / Failed / Skipped / Total] 64 / 75 / 2 / 141:  14%|█▍        | 141/1000 [51:03<5:11:01, 21.72s/it][Succeeded / Failed / Skipped / Total] 64 / 75 / 2 / 141:  14%|█▍        | 142/1000 [51:44<5:12:40, 21.87s/it][Succeeded / Failed / Skipped / Total] 64 / 76 / 2 / 142:  14%|█▍        | 142/1000 [51:44<5:12:40, 21.87s/it][Succeeded / Failed / Skipped / Total] 64 / 76 / 2 / 142:  14%|█▍        | 143/1000 [52:03<5:11:57, 21.84s/it][Succeeded / Failed / Skipped / Total] 65 / 76 / 2 / 143:  14%|█▍        | 143/1000 [52:03<5:11:57, 21.84s/it][Succeeded / Failed / Skipped / Total] 65 / 76 / 2 / 143:  14%|█▍        | 144/1000 [52:43<5:13:25, 21.97s/it]Creates a new instance of MethodSecurityExpressionOperations . --> [[[FAILED]]]

[[[[Adv]]]]: protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( authentication ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( authentication ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 139 ---------------------------------------------
Invokes the advisorProceed with the given JoinPoint --> Exercise the takeuchi and vehement --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( JoinPoint [[jp]] , AspectJCallback [[advisorProceed]] ) { InterceptorStatusToken [[token]] = super . beforeInvocation ( new MethodInvocationAdapter ( [[jp]] ) ) ; Object [[result]] ; try { [[result]] = [[advisorProceed]] . proceedWithObject ( ) ; } finally { super . finallyInvocation ( [[token]] ) ; } return super . afterInvocation ( [[token]] , [[result]] ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object [[demonstration]] ( JoinPoint [[takeuchi]] , AspectJCallback [[vehement]] ) { InterceptorStatusToken [[gauge]] = super . beforeInvocation ( new MethodInvocationAdapter ( [[takeuchi]] ) ) ; Object [[successes]] ; try { [[successes]] = [[vehement]] . proceedWithObject ( ) ; } finally { super . finallyInvocation ( [[gauge]] ) ; } return super . afterInvocation ( [[gauge]] , [[successes]] ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 140 ---------------------------------------------
Load user by assertion . --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails loadUserByAssertion ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails loadUserByAssertion ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 141 ---------------------------------------------
Returns an array of strings that contains any of the given roles . --> Convert Role_XXX obligations to Role_XXX obligations --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] [[hasAnyRole]] ( String ... [[roles]] ) { for ( int [[i]] = 0 ; [[i]] < [[roles]] . length ; [[i]] ++ ) { [[roles]] [ [[i]] ] = "ROLE_" + [[roles]] [ [[i]] ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] [[profits]] ( String ... [[obligations]] ) { for ( int [[lai]] = 0 ; [[lai]] < [[obligations]] . length ; [[lai]] ++ ) { [[obligations]] [ [[lai]] ] = "ROLE_" + [[obligations]] [ [[lai]] ] ; } return [[obligations]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 142 ---------------------------------------------
Gets the webSphere groups based Granted Authorities . --> [[[FAILED]]]

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 143 ---------------------------------------------
Returns the principal associated with the pre - authenticated request . --> Returns akasaka principal from a hinton request --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object principal = [[httpRequest]] . getUserPrincipal ( ) == null ? null : [[httpRequest]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object [[akasaka]] ( HttpServletRequest [[hinton]] ) { Object principal = [[hinton]] . getUserPrincipal ( ) == null ? null : [[hinton]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 144 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 66 / 76 / 2 / 144:  14%|█▍        | 144/1000 [52:43<5:13:25, 21.97s/it][Succeeded / Failed / Skipped / Total] 66 / 76 / 2 / 144:  14%|█▍        | 145/1000 [52:45<5:11:05, 21.83s/it][Succeeded / Failed / Skipped / Total] 67 / 76 / 2 / 145:  14%|█▍        | 145/1000 [52:45<5:11:05, 21.83s/it][Succeeded / Failed / Skipped / Total] 67 / 76 / 2 / 145:  15%|█▍        | 146/1000 [53:00<5:10:02, 21.78s/it][Succeeded / Failed / Skipped / Total] 67 / 77 / 2 / 146:  15%|█▍        | 146/1000 [53:00<5:10:02, 21.78s/it][Succeeded / Failed / Skipped / Total] 67 / 77 / 2 / 146:  15%|█▍        | 147/1000 [53:01<5:07:39, 21.64s/it][Succeeded / Failed / Skipped / Total] 68 / 77 / 2 / 147:  15%|█▍        | 147/1000 [53:01<5:07:39, 21.64s/it][Succeeded / Failed / Skipped / Total] 68 / 77 / 2 / 147:  15%|█▍        | 148/1000 [53:01<5:05:17, 21.50s/it][Succeeded / Failed / Skipped / Total] 69 / 77 / 2 / 148:  15%|█▍        | 148/1000 [53:01<5:05:17, 21.50s/it][Succeeded / Failed / Skipped / Total] 69 / 77 / 2 / 148:  15%|█▍        | 149/1000 [53:03<5:03:03, 21.37s/it][Succeeded / Failed / Skipped / Total] 70 / 77 / 2 / 149:  15%|█▍        | 149/1000 [53:03<5:03:03, 21.37s/it][Succeeded / Failed / Skipped / Total] 70 / 77 / 2 / 149:  15%|█▌        | 150/1000 [53:07<5:01:04, 21.25s/it][Succeeded / Failed / Skipped / Total] 70 / 78 / 2 / 150:  15%|█▌        | 150/1000 [53:07<5:01:04, 21.25s/it][Succeeded / Failed / Skipped / Total] 70 / 78 / 2 / 150:  15%|█▌        | 151/1000 [53:18<4:59:44, 21.18s/it]Process the auto login cookie . --> chechens chechens userDetails --> Socre: 1.0

[[[[Adv]]]]: protected UserDetails [[processAutoLoginCookie]] ( String [ ] cookieTokens , HttpServletRequest [[request]] , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails [[chechens]] ( String [ ] cookieTokens , HttpServletRequest [[praying]] , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 145 ---------------------------------------------
Attempt to exit the current user . --> Methode permettant du authentication --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[nuit]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 146 ---------------------------------------------
Returns the shared object of the given type . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < C > C getSharedObject ( Class < C > sharedType ) { return ( C ) this . sharedObjects . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < C > C getSharedObject ( Class < C > sharedType ) { return ( C ) this . sharedObjects . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 147 ---------------------------------------------
Displays the public index page for a random contact --> Gets a view of a random contact --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact [[rnd]] = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , [[rnd]] ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[deserving]] ( ) { Contact [[octagon]] = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , [[octagon]] ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 148 ---------------------------------------------
Checks if the given string is a valid role name . --> Returns the catties of the given functioning --> Socre: 1.0

[[[[Adv]]]]: private static String [[hasRole]] ( String [[role]] ) { Assert . isTrue ( ! [[role]] . startsWith ( "ROLE_" ) , ( ) -> [[role]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[role]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String [[catties]] ( String [[functioning]] ) { Assert . isTrue ( ! [[functioning]] . startsWith ( "ROLE_" ) , ( ) -> [[functioning]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[functioning]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 149 ---------------------------------------------
Decodes the given token and validates it . --> Decodes an AZO token . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Jwt decode ( String token ) throws JwtException { JWT [[jwt]] = parse ( token ) ; if ( [[jwt]] instanceof SignedJWT ) { Jwt [[createdJwt]] = createJwt ( token , [[jwt]] ) ; return validateJwt ( [[createdJwt]] ) ; } throw new JwtException ( "Unsupported algorithm of " + [[jwt]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt decode ( String token ) throws JwtException { JWT [[azores]] = parse ( token ) ; if ( [[azores]] instanceof SignedJWT ) { Jwt [[tube]] = createJwt ( token , [[azores]] ) ; return validateJwt ( [[tube]] ) ; } throw new JwtException ( "Unsupported algorithm of " + [[azores]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 150 ---------------------------------------------
Returns a list of granted authorities for the given attributes . --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : attributes ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : attributes ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 151 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 71 / 78 / 2 / 151:  15%|█▌        | 151/1000 [53:18<4:59:44, 21.18s/it][Succeeded / Failed / Skipped / Total] 71 / 78 / 2 / 151:  15%|█▌        | 152/1000 [53:21<4:57:39, 21.06s/it][Succeeded / Failed / Skipped / Total] 72 / 78 / 2 / 152:  15%|█▌        | 152/1000 [53:21<4:57:39, 21.06s/it][Succeeded / Failed / Skipped / Total] 72 / 78 / 2 / 152:  15%|█▌        | 153/1000 [53:22<4:55:29, 20.93s/it][Succeeded / Failed / Skipped / Total] 72 / 79 / 2 / 153:  15%|█▌        | 153/1000 [53:22<4:55:29, 20.93s/it][Succeeded / Failed / Skipped / Total] 72 / 79 / 2 / 153:  15%|█▌        | 154/1000 [53:22<4:53:15, 20.80s/it][Succeeded / Failed / Skipped / Total] 73 / 79 / 2 / 154:  15%|█▌        | 154/1000 [53:22<4:53:15, 20.80s/it][Succeeded / Failed / Skipped / Total] 73 / 79 / 2 / 154:  16%|█▌        | 155/1000 [53:27<4:51:24, 20.69s/it][Succeeded / Failed / Skipped / Total] 74 / 79 / 2 / 155:  16%|█▌        | 155/1000 [53:27<4:51:24, 20.69s/it][Succeeded / Failed / Skipped / Total] 74 / 79 / 2 / 155:  16%|█▌        | 156/1000 [53:27<4:49:12, 20.56s/it][Succeeded / Failed / Skipped / Total] 75 / 79 / 2 / 156:  16%|█▌        | 156/1000 [53:27<4:49:12, 20.56s/it][Succeeded / Failed / Skipped / Total] 75 / 79 / 2 / 156:  16%|█▌        | 157/1000 [53:47<4:48:49, 20.56s/it][Succeeded / Failed / Skipped / Total] 76 / 79 / 2 / 157:  16%|█▌        | 157/1000 [53:47<4:48:49, 20.56s/it][Succeeded / Failed / Skipped / Total] 76 / 79 / 2 / 157:  16%|█▌        | 158/1000 [53:51<4:47:00, 20.45s/it]Spring security filter chain . --> Sub - bean for sub - beans . --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean [[hasConfigurers]] = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! [[hasConfigurers]] ) { WebSecurityConfigurerAdapter [[adapter]] = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( [[adapter]] ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[sub]] ( ) throws Exception { boolean [[maker]] = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! [[maker]] ) { WebSecurityConfigurerAdapter [[earphones]] = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( [[earphones]] ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 152 ---------------------------------------------
Sets the URL to redirect to when the user exits . --> Methode permettant de shit --> Socre: 1.0

[[[[Adv]]]]: public void [[setExitUserUrl]] ( String [[exitUserUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[exitUserUrl]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( [[exitUserUrl]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void [[shit]] ( String [[monsieurs]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[monsieurs]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( [[monsieurs]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 153 ---------------------------------------------
Adds a collection of GrantedAuthority objects to the result . --> [[[FAILED]]]

[[[[Adv]]]]: private void addGrantedAuthorityCollection ( Collection < GrantedAuthority > result , Object value ) { if ( value == null ) { return ; } if ( value instanceof Collection < ? > ) { addGrantedAuthorityCollection ( result , ( Collection < ? > ) value ) ; } else if ( value instanceof Object [ ] ) { addGrantedAuthorityCollection ( result , ( Object [ ] ) value ) ; } else if ( value instanceof String ) { addGrantedAuthorityCollection ( result , ( String ) value ) ; } else if ( value instanceof GrantedAuthority ) { result . add ( ( GrantedAuthority ) value ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + value . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void addGrantedAuthorityCollection ( Collection < GrantedAuthority > result , Object value ) { if ( value == null ) { return ; } if ( value instanceof Collection < ? > ) { addGrantedAuthorityCollection ( result , ( Collection < ? > ) value ) ; } else if ( value instanceof Object [ ] ) { addGrantedAuthorityCollection ( result , ( Object [ ] ) value ) ; } else if ( value instanceof String ) { addGrantedAuthorityCollection ( result , ( String ) value ) ; } else if ( value instanceof GrantedAuthority ) { result . add ( ( GrantedAuthority ) value ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + value . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 154 ---------------------------------------------
Convert the JWT to a collection of GrantedAuthorities . --> Convert checkups to a collection of GrantedAuthorities . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt [[jwt]] ) { return getScopes ( [[jwt]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt [[checkups]] ) { return getScopes ( [[checkups]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 155 ---------------------------------------------
Checks if the request is authorized using the url check . --> Does this request bart? --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[currentUser]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , [[currentUser]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[bart]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[albanians]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , [[albanians]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 156 ---------------------------------------------
Generates a CSRF token for the given request . --> Denims the given request . --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest [[request]] ) { return wrap ( [[request]] , this . delegate . generateToken ( [[request]] ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[denim]] ( HttpServletRequest [[prayed]] ) { return wrap ( [[prayed]] , this . delegate . generateToken ( [[prayed]] ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 157 ---------------------------------------------
Displays the admin page for the given contact --> Bunked access to emailing --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int [[contactId]] ) { Contact [[contact]] = contactManager . getById ( Long . valueOf ( [[contactId]] ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( [[contact]] ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , [[contact]] ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[bunked]] ( @ RequestParam ( "contactId" ) int [[collins]] ) { Contact [[emailing]] = contactManager . getById ( Long . valueOf ( [[collins]] ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( [[emailing]] ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , [[emailing]] ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 158 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 77 / 79 / 2 / 158:  16%|█▌        | 158/1000 [53:51<4:47:00, 20.45s/it][Succeeded / Failed / Skipped / Total] 77 / 79 / 2 / 158:  16%|█▌        | 159/1000 [53:51<4:44:53, 20.33s/it][Succeeded / Failed / Skipped / Total] 78 / 79 / 2 / 159:  16%|█▌        | 159/1000 [53:51<4:44:53, 20.33s/it][Succeeded / Failed / Skipped / Total] 78 / 79 / 2 / 159:  16%|█▌        | 160/1000 [53:54<4:43:00, 20.21s/it][Succeeded / Failed / Skipped / Total] 78 / 80 / 2 / 160:  16%|█▌        | 160/1000 [53:54<4:43:00, 20.21s/it][Succeeded / Failed / Skipped / Total] 78 / 80 / 2 / 160:  16%|█▌        | 161/1000 [53:57<4:41:11, 20.11s/it][Succeeded / Failed / Skipped / Total] 79 / 80 / 2 / 161:  16%|█▌        | 161/1000 [53:57<4:41:11, 20.11s/it][Succeeded / Failed / Skipped / Total] 79 / 80 / 2 / 161:  16%|█▌        | 162/1000 [54:04<4:39:44, 20.03s/it]Add a permission to a recipient --> armitage a contact --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[addPermission]] ( AddPermission [[addPermission]] , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( [[addPermission]] , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( [[addPermission]] . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( [[addPermission]] . getPermission ( ) ) ; try { contactManager . [[addPermission]] ( [[addPermission]] . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[armitage]] ( AddPermission [[warring]] , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( [[armitage]] , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( [[armitage]] . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( [[armitage]] . getPermission ( ) ) ; try { contactManager . [[warring]] ( [[armitage]] . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 159 ---------------------------------------------
Gets the role with the default prefix . If the role is null or empty returns the default prefix . --> Returns the rotor of the functions --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String [[defaultRolePrefix]] , String [[role]] ) { if ( [[role]] == null ) { return [[role]] ; } if ( [[defaultRolePrefix]] == null || [[defaultRolePrefix]] . length ( ) == 0 ) { return [[role]] ; } if ( [[role]] . startsWith ( [[defaultRolePrefix]] ) ) { return [[role]] ; } return [[defaultRolePrefix]] + [[role]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[rotor]] ( String [[niccolo]] , String [[functions]] ) { if ( [[functions]] == null ) { return [[functions]] ; } if ( [[niccolo]] == null || [[niccolo]] . length ( ) == 0 ) { return [[functions]] ; } if ( [[functions]] . startsWith ( [[niccolo]] ) ) { return [[functions]] ; } return [[niccolo]] + [[functions]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 160 ---------------------------------------------
Builds the HTTPS redirect URL for the given request . --> [[[FAILED]]]

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 161 ---------------------------------------------
Returns the values of the attribute with the given name . --> Get liberia attributes . --> Socre: 1.0

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String name ) { List < String > [[result]] = null ; if ( attributes != null ) { [[result]] = attributes . get ( name ) ; } if ( [[result]] == null ) { [[result]] = Collections . emptyList ( ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[liberia]] ( String name ) { List < String > [[repercussions]] = null ; if ( attributes != null ) { [[repercussions]] = attributes . get ( name ) ; } if ( [[repercussions]] == null ) { [[repercussions]] = Collections . emptyList ( ) ; } return [[repercussions]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 162 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 79 / 81 / 2 / 162:  16%|█▌        | 162/1000 [54:04<4:39:44, 20.03s/it][Succeeded / Failed / Skipped / Total] 79 / 81 / 2 / 162:  16%|█▋        | 163/1000 [54:16<4:38:42, 19.98s/it][Succeeded / Failed / Skipped / Total] 80 / 81 / 2 / 163:  16%|█▋        | 163/1000 [54:16<4:38:42, 19.98s/it][Succeeded / Failed / Skipped / Total] 80 / 81 / 2 / 163:  16%|█▋        | 164/1000 [54:23<4:37:15, 19.90s/it][Succeeded / Failed / Skipped / Total] 81 / 81 / 2 / 164:  16%|█▋        | 164/1000 [54:23<4:37:15, 19.90s/it][Succeeded / Failed / Skipped / Total] 81 / 81 / 2 / 164:  16%|█▋        | 165/1000 [54:24<4:35:22, 19.79s/it][Succeeded / Failed / Skipped / Total] 82 / 81 / 2 / 165:  16%|█▋        | 165/1000 [54:24<4:35:22, 19.79s/it][Succeeded / Failed / Skipped / Total] 82 / 81 / 2 / 165:  17%|█▋        | 166/1000 [54:29<4:33:45, 19.70s/it][Succeeded / Failed / Skipped / Total] 83 / 81 / 2 / 166:  17%|█▋        | 166/1000 [54:29<4:33:45, 19.70s/it][Succeeded / Failed / Skipped / Total] 83 / 81 / 2 / 166:  17%|█▋        | 167/1000 [54:44<4:33:04, 19.67s/it][Succeeded / Failed / Skipped / Total] 84 / 81 / 2 / 167:  17%|█▋        | 167/1000 [54:44<4:33:04, 19.67s/it][Succeeded / Failed / Skipped / Total] 84 / 81 / 2 / 167:  17%|█▋        | 168/1000 [54:48<4:31:27, 19.58s/it]Deletes a permission from a contact . --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 163 ---------------------------------------------
Returns true if the current user is authorized using the access expression . --> Is this filter cassettes? --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingAccessExpression]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > [[handler]] = getExpressionHandler ( ) ; Expression [[accessExpression]] ; try { [[accessExpression]] = [[handler]] . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException [[ioException]] = new IOException ( ) ; [[ioException]] . initCause ( e ) ; throw [[ioException]] ; } return ExpressionUtils . evaluateAsBoolean ( [[accessExpression]] , createExpressionEvaluationContext ( [[handler]] ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean [[cassettes]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > [[custodian]] = getExpressionHandler ( ) ; Expression [[nowthat]] ; try { [[nowthat]] = [[custodian]] . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException [[hendry]] = new IOException ( ) ; [[hendry]] . initCause ( e ) ; throw [[hendry]] ; } return ExpressionUtils . evaluateAsBoolean ( [[nowthat]] , createExpressionEvaluationContext ( [[custodian]] ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 164 ---------------------------------------------
Returns the value of the first attribute with the given name . --> Alicante alicante . --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String [[name]] ) { List < String > result = getAttributeValues ( [[name]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[alicante]] ( String [[numbering]] ) { List < String > result = getAttributeValues ( [[numbering]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 165 ---------------------------------------------
Add a new contact --> winchell add action --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[addContact]] ( WebContact [[form]] , BindingResult [[result]] ) { validator . validate ( [[form]] , [[result]] ) ; if ( [[result]] . hasErrors ( ) ) { return "add" ; } Contact [[contact]] = new Contact ( [[form]] . getName ( ) , [[form]] . getEmail ( ) ) ; contactManager . create ( [[contact]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[winchell]] ( WebContact [[manner]] , BindingResult [[repercussions]] ) { validator . validate ( [[manner]] , [[repercussions]] ) ; if ( [[repercussions]] . hasErrors ( ) ) { return "add" ; } Contact [[interact]] = new Contact ( [[manner]] . getName ( ) , [[manner]] . getEmail ( ) ) ; contactManager . create ( [[interact]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 166 ---------------------------------------------
Encodes the given string into a byte array . --> Encodes a rope into a byte array --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[encode]] ( CharSequence [[string]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[string]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] [[encoder]] ( CharSequence [[rope]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[rope]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 167 ---------------------------------------------
Creates a new UserDetailsResourceFactoryBean from a string . --> shoeless user details . --> Socre: 1.0

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[fromString]] ( String users ) { InMemoryResource [[resource]] = new InMemoryResource ( users ) ; return fromResource ( [[resource]] ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[shoeless]] ( String users ) { InMemoryResource [[heals]] = new InMemoryResource ( users ) ; return fromResource ( [[heals]] ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 168 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 85 / 81 / 2 / 168:  17%|█▋        | 168/1000 [54:48<4:31:27, 19.58s/it][Succeeded / Failed / Skipped / Total] 85 / 81 / 2 / 168:  17%|█▋        | 169/1000 [55:04<4:30:50, 19.56s/it][Succeeded / Failed / Skipped / Total] 86 / 81 / 2 / 169:  17%|█▋        | 169/1000 [55:04<4:30:50, 19.56s/it][Succeeded / Failed / Skipped / Total] 86 / 81 / 2 / 169:  17%|█▋        | 170/1000 [55:18<4:30:02, 19.52s/it][Succeeded / Failed / Skipped / Total] 87 / 81 / 2 / 170:  17%|█▋        | 170/1000 [55:18<4:30:02, 19.52s/it][Succeeded / Failed / Skipped / Total] 87 / 81 / 2 / 170:  17%|█▋        | 171/1000 [56:17<4:32:55, 19.75s/it][Succeeded / Failed / Skipped / Total] 88 / 81 / 2 / 171:  17%|█▋        | 171/1000 [56:17<4:32:55, 19.75s/it][Succeeded / Failed / Skipped / Total] 88 / 81 / 2 / 171:  17%|█▋        | 172/1000 [56:38<4:32:40, 19.76s/it][Succeeded / Failed / Skipped / Total] 88 / 82 / 2 / 172:  17%|█▋        | 172/1000 [56:38<4:32:40, 19.76s/it][Succeeded / Failed / Skipped / Total] 88 / 82 / 2 / 172:  17%|█▋        | 173/1000 [56:42<4:31:04, 19.67s/it][Succeeded / Failed / Skipped / Total] 89 / 82 / 2 / 173:  17%|█▋        | 173/1000 [56:42<4:31:04, 19.67s/it][Succeeded / Failed / Skipped / Total] 89 / 82 / 2 / 173:  17%|█▋        | 174/1000 [57:41<4:33:50, 19.89s/it][Succeeded / Failed / Skipped / Total] 89 / 83 / 2 / 174:  17%|█▋        | 174/1000 [57:41<4:33:50, 19.89s/it][Succeeded / Failed / Skipped / Total] 89 / 83 / 2 / 174:  18%|█▊        | 175/1000 [58:05<4:33:50, 19.92s/it]On login success create a persistent login token . --> okinawa - okinawa --> Socre: 1.0

[[[[Adv]]]]: protected void [[onLoginSuccess]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken [[persistentToken]] = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[persistentToken]] ) ; addCookie ( [[persistentToken]] , [[request]] , [[response]] ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void [[okinawa]] ( HttpServletRequest [[invited]] , HttpServletResponse [[react]] , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken [[fatsos]] = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[fatsos]] ) ; addCookie ( [[fatsos]] , [[invited]] , [[react]] ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 169 ---------------------------------------------
Returns a collection of all config attributes . --> Get all guildenstern methods that are clicking --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[getAllConfigAttributes]] ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[attributeList]] : methodMap . values ( ) ) { [[allAttributes]] . addAll ( [[attributeList]] ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[clicking]] ( ) { Set < ConfigAttribute > [[guildenstern]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[yukari]] : methodMap . values ( ) ) { [[guildenstern]] . addAll ( [[yukari]] ) ; } return [[guildenstern]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 170 ---------------------------------------------
Configures any request matchers . --> Configure anyRequest to skip twiddling --> Socre: 1.0

[[[[Adv]]]]: public C [[anyRequest]] ( ) { Assert . state ( ! this . [[anyRequestConfigured]] , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . [[anyRequestConfigured]] = "True" == "True" ; return configurer ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C [[skippin]] ( ) { Assert . state ( ! this . [[twiddling]] , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . [[twiddling]] = "True" == "True" ; return configurer ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 171 ---------------------------------------------
Returns a collection of config attributes for the given method and target class . --> zander - zander - zander --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[findAttributes]] ( Method method , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , targetClass ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[zander]] ( Method method , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , targetClass ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 172 ---------------------------------------------
Returns a random contact --> [[[FAILED]]]

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 173 ---------------------------------------------
Add a secure method to the registry . --> Adds the translates and waxworks to the llz map --> Socre: 1.0

[[[[Adv]]]]: private void [[addSecureMethod]] ( RegisteredMethod [[method]] , List < ConfigAttribute > [[attr]] ) { Assert . notNull ( [[method]] , "RegisteredMethod required" ) ; Assert . notNull ( [[attr]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[method]] + "] with attributes [" + [[attr]] + "]" ) ; } this . [[methodMap]] . put ( [[method]] , [[attr]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void [[nazo]] ( RegisteredMethod [[translates]] , List < ConfigAttribute > [[waxworks]] ) { Assert . notNull ( [[translates]] , "RegisteredMethod required" ) ; Assert . notNull ( [[waxworks]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[translates]] + "] with attributes [" + [[waxworks]] + "]" ) ; } this . [[llz]] . put ( [[translates]] , [[waxworks]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 174 ---------------------------------------------
Displays the add permission page for a contact . --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 175 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 89 / 84 / 2 / 175:  18%|█▊        | 175/1000 [58:05<4:33:50, 19.92s/it][Succeeded / Failed / Skipped / Total] 89 / 84 / 2 / 175:  18%|█▊        | 176/1000 [58:21<4:33:14, 19.90s/it][Succeeded / Failed / Skipped / Total] 89 / 85 / 2 / 176:  18%|█▊        | 176/1000 [58:21<4:33:14, 19.90s/it][Succeeded / Failed / Skipped / Total] 89 / 85 / 2 / 176:  18%|█▊        | 177/1000 [59:36<4:37:09, 20.21s/it][Succeeded / Failed / Skipped / Total] 89 / 86 / 2 / 177:  18%|█▊        | 177/1000 [59:36<4:37:09, 20.21s/it][Succeeded / Failed / Skipped / Total] 89 / 86 / 2 / 177:  18%|█▊        | 178/1000 [59:38<4:35:24, 20.10s/it][Succeeded / Failed / Skipped / Total] 89 / 87 / 2 / 178:  18%|█▊        | 178/1000 [59:38<4:35:24, 20.10s/it][Succeeded / Failed / Skipped / Total] 89 / 87 / 2 / 178:  18%|█▊        | 179/1000 [59:55<4:34:51, 20.09s/it][Succeeded / Failed / Skipped / Total] 90 / 87 / 2 / 179:  18%|█▊        | 179/1000 [59:55<4:34:51, 20.09s/it][Succeeded / Failed / Skipped / Total] 90 / 87 / 2 / 179:  18%|█▊        | 180/1000 [1:00:34<4:35:56, 20.19s/it][Succeeded / Failed / Skipped / Total] 90 / 88 / 2 / 180:  18%|█▊        | 180/1000 [1:00:34<4:35:56, 20.19s/it][Succeeded / Failed / Skipped / Total] 90 / 88 / 2 / 180:  18%|█▊        | 181/1000 [1:01:09<4:36:46, 20.28s/it][Succeeded / Failed / Skipped / Total] 90 / 89 / 2 / 181:  18%|█▊        | 181/1000 [1:01:09<4:36:46, 20.28s/it][Succeeded / Failed / Skipped / Total] 90 / 89 / 2 / 181:  18%|█▊        | 182/1000 [1:01:18<4:35:34, 20.21s/it]Decodes the given byte array into a string . --> [[[FAILED]]]

[[[[Adv]]]]: public static String decode ( byte [ ] bytes ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( bytes ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String decode ( byte [ ] bytes ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( bytes ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 176 ---------------------------------------------
Attempts to switch to the specified user . --> [[[FAILED]]]

[[[[Adv]]]]: protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 177 ---------------------------------------------
Checks if the method name and mapped name match . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean isMatch ( String methodName , String mappedName ) { return ( mappedName . endsWith ( "*" ) && methodName . startsWith ( mappedName . substring ( 0 , mappedName . length ( ) - 1 ) ) ) || ( mappedName . startsWith ( "*" ) && methodName . endsWith ( mappedName . substring ( 1 , mappedName . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean isMatch ( String methodName , String mappedName ) { return ( mappedName . endsWith ( "*" ) && methodName . startsWith ( mappedName . substring ( 0 , mappedName . length ( ) - 1 ) ) ) || ( mappedName . startsWith ( "*" ) && methodName . endsWith ( mappedName . substring ( 1 , mappedName . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 178 ---------------------------------------------
Handle bind exception . --> [[[FAILED]]]

[[[[Adv]]]]: protected void handleBindException ( String userDn , String username , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void handleBindException ( String userDn , String username , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 179 ---------------------------------------------
Checks the filter stack for duplicate filters . --> Warns about duplicated filters . --> Socre: 1.0

[[[[Adv]]]]: private void [[checkFilterStack]] ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void [[fearfully]] ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 180 ---------------------------------------------
Removes the authentication exception from the session . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void clearAuthenticationAttributes ( HttpServletRequest request ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void clearAuthenticationAttributes ( HttpServletRequest request ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 181 ---------------------------------------------
Create service url . --> [[[FAILED]]]

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 182 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 90 / 90 / 2 / 182:  18%|█▊        | 182/1000 [1:01:18<4:35:34, 20.21s/it][Succeeded / Failed / Skipped / Total] 90 / 90 / 2 / 182:  18%|█▊        | 183/1000 [1:01:32<4:34:46, 20.18s/it][Succeeded / Failed / Skipped / Total] 90 / 91 / 2 / 183:  18%|█▊        | 183/1000 [1:01:32<4:34:46, 20.18s/it][Succeeded / Failed / Skipped / Total] 90 / 91 / 2 / 183:  18%|█▊        | 184/1000 [1:01:45<4:33:54, 20.14s/it][Succeeded / Failed / Skipped / Total] 91 / 91 / 2 / 184:  18%|█▊        | 184/1000 [1:01:45<4:33:54, 20.14s/it][Succeeded / Failed / Skipped / Total] 91 / 91 / 2 / 184:  18%|█▊        | 185/1000 [1:01:50<4:32:27, 20.06s/it][Succeeded / Failed / Skipped / Total] 91 / 92 / 2 / 185:  18%|█▊        | 185/1000 [1:01:50<4:32:27, 20.06s/it][Succeeded / Failed / Skipped / Total] 91 / 92 / 2 / 185:  19%|█▊        | 186/1000 [1:01:53<4:30:49, 19.96s/it][Succeeded / Failed / Skipped / Total] 92 / 92 / 2 / 186:  19%|█▊        | 186/1000 [1:01:53<4:30:49, 19.96s/it][Succeeded / Failed / Skipped / Total] 92 / 92 / 2 / 186:  19%|█▊        | 187/1000 [1:01:53<4:29:03, 19.86s/it][Succeeded / Failed / Skipped / Total] 92 / 93 / 2 / 187:  19%|█▊        | 187/1000 [1:01:53<4:29:03, 19.86s/it][Succeeded / Failed / Skipped / Total] 92 / 93 / 2 / 187:  19%|█▉        | 188/1000 [1:02:08<4:28:24, 19.83s/it]Gets the field with the given name from the given class . --> [[[FAILED]]]

[[[[Adv]]]]: public static Field getField ( Class < ? > clazz , String fieldName ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field getField ( Class < ? > clazz , String fieldName ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 183 ---------------------------------------------
Registers an access manager . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 184 ---------------------------------------------
Compares two byte arrays for equality . --> Checks if the envisioned and actual byte arrays are gaming --> Socre: 1.0

[[[[Adv]]]]: private boolean [[matches]] ( byte [ ] [[expected]] , byte [ ] actual ) { if ( [[expected]] . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < [[expected]] . length ; i ++ ) { result |= [[expected]] [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean [[gaming]] ( byte [ ] [[envisioned]] , byte [ ] actual ) { if ( [[envisioned]] . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < [[envisioned]] . length ; i ++ ) { result |= [[envisioned]] [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 185 ---------------------------------------------
Looks up the parameter names for the given AccessibleObject . --> [[[FAILED]]]

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 186 ---------------------------------------------
Extracts the prefix from the given enc - pass . --> lege of a schlosser --> Socre: 1.0

[[[[Adv]]]]: private String [[extractPrefix]] ( String [[encPass]] ) { if ( ! [[encPass]] . startsWith ( "{" ) ) { return null ; } int [[secondBrace]] = [[encPass]] . lastIndexOf ( ' ' ) ; if ( [[secondBrace]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[encPass]] . substring ( 0 , [[secondBrace]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String [[lege]] ( String [[schlosser]] ) { if ( ! [[schlosser]] . startsWith ( "{" ) ) { return null ; } int [[joffrey]] = [[schlosser]] . lastIndexOf ( ' ' ) ; if ( [[joffrey]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[schlosser]] . substring ( 0 , [[joffrey]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 187 ---------------------------------------------
Create redirect url . --> [[[FAILED]]]

[[[[Adv]]]]: protected String createRedirectUrl ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String createRedirectUrl ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 188 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 93 / 93 / 2 / 188:  19%|█▉        | 188/1000 [1:02:08<4:28:24, 19.83s/it][Succeeded / Failed / Skipped / Total] 93 / 93 / 2 / 188:  19%|█▉        | 189/1000 [1:02:14<4:27:03, 19.76s/it][Succeeded / Failed / Skipped / Total] 94 / 93 / 2 / 189:  19%|█▉        | 189/1000 [1:02:14<4:27:03, 19.76s/it][Succeeded / Failed / Skipped / Total] 94 / 93 / 2 / 189:  19%|█▉        | 190/1000 [1:02:25<4:26:08, 19.71s/it][Succeeded / Failed / Skipped / Total] 95 / 93 / 2 / 190:  19%|█▉        | 190/1000 [1:02:25<4:26:08, 19.71s/it][Succeeded / Failed / Skipped / Total] 95 / 93 / 2 / 190:  19%|█▉        | 191/1000 [1:02:30<4:24:46, 19.64s/it][Succeeded / Failed / Skipped / Total] 96 / 93 / 2 / 191:  19%|█▉        | 191/1000 [1:02:30<4:24:46, 19.64s/it][Succeeded / Failed / Skipped / Total] 96 / 93 / 2 / 191:  19%|█▉        | 192/1000 [1:02:32<4:23:10, 19.54s/it][Succeeded / Failed / Skipped / Total] 97 / 93 / 2 / 192:  19%|█▉        | 192/1000 [1:02:32<4:23:10, 19.54s/it][Succeeded / Failed / Skipped / Total] 97 / 93 / 2 / 192:  19%|█▉        | 193/1000 [1:02:38<4:21:55, 19.47s/it][Succeeded / Failed / Skipped / Total] 98 / 93 / 2 / 193:  19%|█▉        | 193/1000 [1:02:38<4:21:55, 19.47s/it][Succeeded / Failed / Skipped / Total] 98 / 93 / 2 / 193:  19%|█▉        | 194/1000 [1:03:38<4:24:22, 19.68s/it][Succeeded / Failed / Skipped / Total] 98 / 94 / 2 / 194:  19%|█▉        | 194/1000 [1:03:38<4:24:22, 19.68s/it][Succeeded / Failed / Skipped / Total] 98 / 94 / 2 / 194:  20%|█▉        | 195/1000 [1:05:19<4:29:42, 20.10s/it]Builds the request URL . --> Chong nal contextPath pathInfo and query string --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildRequestUrl]] ( String [[servletPath]] , String [[requestURI]] , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( [[servletPath]] != null ) { url . append ( [[servletPath]] ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( [[requestURI]] . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String [[celebrate]] ( String [[chong]] , String [[nal]] , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( [[chong]] != null ) { url . append ( [[chong]] ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( [[nal]] . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 189 ---------------------------------------------
Returns an array of all registered exception types . --> camouflage all exceptions from apprenticeship --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > [[typeList]] = this . [[extractorMap]] . keySet ( ) ; return [[typeList]] . toArray ( new Class [ [[typeList]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[camouflage]] ( ) { Set < Class < ? extends Throwable > > [[confession]] = this . [[apprenticeship]] . keySet ( ) ; return [[confession]] . toArray ( new Class [ [[confession]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 190 ---------------------------------------------
Converts an identifier from a ResultSet to a Java identifier . --> Method to convert takuma to Serializable if possible --> Socre: 1.0

[[[[Adv]]]]: Serializable [[identifierFrom]] ( Serializable [[identifier]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[identifier]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[identifier]] = convertFromStringTo ( ( String ) [[identifier]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable [[atm]] ( Serializable [[takuma]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[takuma]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[takuma]] = convertFromStringTo ( ( String ) [[takuma]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 191 ---------------------------------------------
Sets the default failure URL . --> crucify to kitahara --> Socre: 1.0

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String [[defaultFailureUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[defaultFailureUrl]] ) , ( ) -> "'" + [[defaultFailureUrl]] + "' is not a valid redirect URL" ) ; this . [[defaultFailureUrl]] = [[defaultFailureUrl]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[crucify]] ( String [[kitahara]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[kitahara]] ) , ( ) -> "'" + [[kitahara]] + "' is not a valid redirect URL" ) ; this . [[eee]] = [[kitahara]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 192 ---------------------------------------------
Sets the function to be used to resolve hidden input values . -->  --> Socre: 0.9999999999999999

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > [[resolveHiddenInputs]] ) { Assert . notNull ( [[resolveHiddenInputs]] , "resolveHiddenInputs cannot be null" ) ; this . [[resolveHiddenInputs]] = [[resolveHiddenInputs]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[dorm]] ( Function < HttpServletRequest , Map < String , String > > [[durga]] ) { Assert . notNull ( [[durga]] , "resolveHiddenInputs cannot be null" ) ; this . [[ó]] = [[durga]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 193 ---------------------------------------------
Create object identity . --> LOVINIA LOVINIA --> Socre: 1.0

[[[[Adv]]]]: protected void [[createObjectIdentity]] ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "[[True]]" == "[[True]]" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "[[True]]" == "[[True]]" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void [[lavinia]] ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "[[Factual]]" == "[[Factual]]" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "[[Factual]]" == "[[Factual]]" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 194 ---------------------------------------------
Rejects the access . --> [[[FAILED]]]

[[[[Adv]]]]: public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
[Succeeded / Failed / Skipped / Total] 98 / 95 / 2 / 195:  20%|█▉        | 195/1000 [1:05:19<4:29:42, 20.10s/it][Succeeded / Failed / Skipped / Total] 98 / 95 / 2 / 195:  20%|█▉        | 196/1000 [1:05:21<4:28:06, 20.01s/it][Succeeded / Failed / Skipped / Total] 99 / 95 / 2 / 196:  20%|█▉        | 196/1000 [1:05:21<4:28:06, 20.01s/it][Succeeded / Failed / Skipped / Total] 99 / 95 / 2 / 196:  20%|█▉        | 197/1000 [1:05:22<4:26:28, 19.91s/it][Succeeded / Failed / Skipped / Total] 100 / 95 / 2 / 197:  20%|█▉        | 197/1000 [1:05:22<4:26:28, 19.91s/it][Succeeded / Failed / Skipped / Total] 100 / 95 / 2 / 197:  20%|█▉        | 198/1000 [1:06:04<4:27:36, 20.02s/it][Succeeded / Failed / Skipped / Total] 100 / 96 / 2 / 198:  20%|█▉        | 198/1000 [1:06:04<4:27:36, 20.02s/it][Succeeded / Failed / Skipped / Total] 100 / 96 / 2 / 198:  20%|█▉        | 199/1000 [1:06:04<4:25:59, 19.92s/it][Succeeded / Failed / Skipped / Total] 100 / 97 / 2 / 199:  20%|█▉        | 199/1000 [1:06:04<4:25:59, 19.92s/it][Succeeded / Failed / Skipped / Total] 100 / 97 / 2 / 199:  20%|██        | 200/1000 [1:06:47<4:27:09, 20.04s/it][Succeeded / Failed / Skipped / Total] 100 / 98 / 2 / 200:  20%|██        | 200/1000 [1:06:47<4:27:09, 20.04s/it][Succeeded / Failed / Skipped / Total] 100 / 98 / 2 / 200:  20%|██        | 201/1000 [1:06:53<4:25:55, 19.97s/it][Succeeded / Failed / Skipped / Total] 101 / 98 / 2 / 201:  20%|██        | 201/1000 [1:06:53<4:25:55, 19.97s/it][Succeeded / Failed / Skipped / Total] 101 / 98 / 2 / 201:  20%|██        | 202/1000 [1:07:14<4:25:38, 19.97s/it]--------------------------------------------- Result 195 ---------------------------------------------
Extracts the cause of the given throwable . --> [[[FAILED]]]

[[[[Adv]]]]: private Throwable extractCause ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = entry . getValue ( ) ; return extractor . extractCause ( throwable ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable extractCause ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = entry . getValue ( ) ; return extractor . extractCause ( throwable ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 196 ---------------------------------------------
Returns a matcher that matches any HttpServerExchange . --> The pittsburgh matcher . --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[anyExchange]] ( ) {
[[[[Nl]]]]: Matches any exchange

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[pittsburgh]] ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 197 ---------------------------------------------
Saves the request if it matches the requestMatcher . --> zulus - zulus --> Socre: 1.0

[[[[Adv]]]]: public void [[saveRequest]] ( HttpServletRequest request , HttpServletResponse [[response]] ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest [[savedRequest]] = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void [[zulus]] ( HttpServletRequest request , HttpServletResponse [[interventions]] ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest [[smug]] = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 198 ---------------------------------------------
Converts a Collection of GrantedAuthority objects to a Set of Strings . --> [[[FAILED]]]

[[[[Adv]]]]: public static Set < String > authorityListToSet ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority authority : userAuthorities ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > authorityListToSet ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority authority : userAuthorities ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 199 ---------------------------------------------
Returns true if the given URL is absolute . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean isAbsoluteUrl ( String url ) { if ( url == null ) { return "False" != "False" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( url ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean isAbsoluteUrl ( String url ) { if ( url == null ) { return "False" != "False" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( url ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 200 ---------------------------------------------
Creates a list of OpenID attributes for the given identifier . --> [[[FAILED]]]

[[[[Adv]]]]: public List < OpenIDAttribute > createAttributeList ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > createAttributeList ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 201 ---------------------------------------------
Determines the target URL for the given request and response . --> Generate a random string . --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest [[request]] , HttpServletResponse response , Authentication authentication ) { return [[determineTargetUrl]] ( [[request]] , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String [[rnd]] ( HttpServletRequest [[praying]] , HttpServletResponse response , Authentication authentication ) { return [[rnd]] ( [[praying]] , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 202 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 101 / 99 / 2 / 202:  20%|██        | 202/1000 [1:07:14<4:25:38, 19.97s/it][Succeeded / Failed / Skipped / Total] 101 / 99 / 2 / 202:  20%|██        | 203/1000 [1:07:19<4:24:17, 19.90s/it][Succeeded / Failed / Skipped / Total] 101 / 100 / 2 / 203:  20%|██        | 203/1000 [1:07:19<4:24:17, 19.90s/it][Succeeded / Failed / Skipped / Total] 101 / 100 / 2 / 203:  20%|██        | 204/1000 [1:07:22<4:22:52, 19.81s/it][Succeeded / Failed / Skipped / Total] 102 / 100 / 2 / 204:  20%|██        | 204/1000 [1:07:22<4:22:52, 19.81s/it][Succeeded / Failed / Skipped / Total] 102 / 100 / 2 / 204:  20%|██        | 205/1000 [1:07:29<4:21:45, 19.76s/it][Succeeded / Failed / Skipped / Total] 103 / 100 / 2 / 205:  20%|██        | 205/1000 [1:07:29<4:21:45, 19.76s/it][Succeeded / Failed / Skipped / Total] 103 / 100 / 2 / 205:  21%|██        | 206/1000 [1:07:35<4:20:32, 19.69s/it]Creates the entries for the given acl . --> [[[FAILED]]]

[[[[Adv]]]]: protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 203 ---------------------------------------------
Update object identity . --> [[[FAILED]]]

[[[[Adv]]]]: protected void updateObjectIdentity ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void updateObjectIdentity ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 204 ---------------------------------------------
Returns the directory with the immediate parent populated . --> Returns the oligarchs for the given id . --> Socre: 1.0

[[[[Adv]]]]: private Directory [[getDirectoryWithImmediateParentPopulated]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet [[rs]] , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( [[rs]] . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory [[oligarchs]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet [[roubles]] , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( [[roubles]] . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 205 ---------------------------------------------
Determine the target URL to use for the request . --> schwarzenegger schwarzenegger --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[schwarzenegger]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 206 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 104 / 100 / 2 / 206:  21%|██        | 206/1000 [1:07:35<4:20:32, 19.69s/it][Succeeded / Failed / Skipped / Total] 104 / 100 / 2 / 206:  21%|██        | 207/1000 [1:08:00<4:20:31, 19.71s/it][Succeeded / Failed / Skipped / Total] 105 / 100 / 2 / 207:  21%|██        | 207/1000 [1:08:00<4:20:31, 19.71s/it][Succeeded / Failed / Skipped / Total] 105 / 100 / 2 / 207:  21%|██        | 208/1000 [1:08:12<4:19:43, 19.68s/it][Succeeded / Failed / Skipped / Total] 106 / 100 / 2 / 208:  21%|██        | 208/1000 [1:08:12<4:19:43, 19.68s/it][Succeeded / Failed / Skipped / Total] 106 / 100 / 2 / 208:  21%|██        | 209/1000 [1:08:26<4:19:03, 19.65s/it][Succeeded / Failed / Skipped / Total] 107 / 100 / 2 / 209:  21%|██        | 209/1000 [1:08:26<4:19:03, 19.65s/it][Succeeded / Failed / Skipped / Total] 107 / 100 / 2 / 209:  21%|██        | 210/1000 [1:08:29<4:17:40, 19.57s/it][Succeeded / Failed / Skipped / Total] 108 / 100 / 2 / 210:  21%|██        | 210/1000 [1:08:29<4:17:40, 19.57s/it][Succeeded / Failed / Skipped / Total] 108 / 100 / 2 / 210:  21%|██        | 211/1000 [1:08:31<4:16:15, 19.49s/it][Succeeded / Failed / Skipped / Total] 108 / 101 / 2 / 211:  21%|██        | 211/1000 [1:08:31<4:16:15, 19.49s/it][Succeeded / Failed / Skipped / Total] 108 / 101 / 2 / 211:  21%|██        | 212/1000 [1:08:40<4:15:15, 19.44s/it][Succeeded / Failed / Skipped / Total] 109 / 101 / 2 / 212:  21%|██        | 212/1000 [1:08:40<4:15:15, 19.44s/it][Succeeded / Failed / Skipped / Total] 109 / 101 / 2 / 212:  21%|██▏       | 213/1000 [1:08:44<4:13:59, 19.36s/it]Creates the shared objects . --> Sloane sloane . --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > [[sharedObjects]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[sharedObjects]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[sharedObjects]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[sharedObjects]] . put ( ApplicationContext . class , context ) ; [[sharedObjects]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[sharedObjects]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[sharedObjects]] ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[sloane]] ( ) { Map < Class < ? extends Object > , Object > [[martine]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[martine]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[martine]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[martine]] . put ( ApplicationContext . class , context ) ; [[martine]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[martine]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[martine]] ; }
[[[[Nl]]]]: Creates the shared objects
--------------------------------------------- Result 207 ---------------------------------------------
Loops through the login . config . url . --> hudsucker - hudsucker - hacker --> Socre: 1.0

[[[[Adv]]]]: private void [[configureJaasUsingLoop]] ( ) throws IOException { String [[loginConfigUrl]] = convertLoginConfigToUrl ( ) ; boolean [[alreadySet]] = "False" != "False" ; int [[n]] = 1 ; final String [[prefix]] = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( [[prefix]] + [[n]] ) ) != null ) { [[alreadySet]] = existing . equals ( [[loginConfigUrl]] ) ; if ( [[alreadySet]] ) { break ; } [[n]] ++ ; } if ( ! [[alreadySet]] ) { String key = [[prefix]] + [[n]] ; log . debug ( "Setting security property [" + key + "] to: " + [[loginConfigUrl]] ) ; Security . setProperty ( key , [[loginConfigUrl]] ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void [[hudsucker]] ( ) throws IOException { String [[ll]] = convertLoginConfigToUrl ( ) ; boolean [[couplet]] = "False" != "False" ; int [[cent]] = 1 ; final String [[url]] = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( [[url]] + [[cent]] ) ) != null ) { [[couplet]] = existing . equals ( [[ll]] ) ; if ( [[couplet]] ) { break ; } [[cent]] ++ ; } if ( ! [[couplet]] ) { String key = [[url]] + [[cent]] ; log . debug ( "Setting security property [" + key + "] to: " + [[ll]] ) ; Security . setProperty ( key , [[ll]] ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 208 ---------------------------------------------
Builds a distinguished name from the given username . --> Kentaro - kentaro - kentaro --> Socre: 1.0

[[[[Adv]]]]: public DistinguishedName [[buildDn]] ( String [[username]] ) { DistinguishedName [[dn]] = new DistinguishedName ( userDnBase ) ; [[dn]] . add ( usernameAttribute , [[username]] ) ; return [[dn]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName [[kentaro]] ( String [[logs]] ) { DistinguishedName [[ind]] = new DistinguishedName ( userDnBase ) ; [[ind]] . add ( usernameAttribute , [[logs]] ) ; return [[ind]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 209 ---------------------------------------------
Internal method to parse a date . --> Get riddick value from valor string --> Socre: 1.0

[[[[Adv]]]]: private static Long [[internalParseDate]] ( String [[value]] , DateFormat [ ] [[formats]] ) { Date [[date]] = null ; for ( int i = 0 ; ( [[date]] == null ) && ( i < [[formats]] . length ) ; i ++ ) { try { [[date]] = [[formats]] [ i ] . parse ( [[value]] ) ; } catch ( ParseException ignored ) { } } if ( [[date]] == null ) { return null ; } return new Long ( [[date]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long [[riddick]] ( String [[valor]] , DateFormat [ ] [[schematics]] ) { Date [[chronological]] = null ; for ( int i = 0 ; ( [[chronological]] == null ) && ( i < [[schematics]] . length ) ; i ++ ) { try { [[chronological]] = [[schematics]] [ i ] . parse ( [[valor]] ) ; } catch ( ParseException ignored ) { } } if ( [[chronological]] == null ) { return null ; } return new Long ( [[chronological]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 210 ---------------------------------------------
Update the cache with a new value . --> Wet the elemental value into the conceal map --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[updateCache]] ( HashMap [[cache]] , Object [[key]] , Object value ) { if ( value == null ) { return ; } if ( [[cache]] . size ( ) > 1000 ) { [[cache]] . clear ( ) ; } [[cache]] . put ( [[key]] , value ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[yout]] ( HashMap [[conceal]] , Object [[elemental]] , Object value ) { if ( value == null ) { return ; } if ( [[conceal]] . size ( ) > 1000 ) { [[conceal]] . clear ( ) ; } [[conceal]] . put ( [[elemental]] , value ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 211 ---------------------------------------------
Create a matcher that matches any of the given path patterns . --> [[[FAILED]]]

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 212 ---------------------------------------------
Sets the target URL parameter . --> Exhilaration para pequeo --> Socre: 1.0

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String [[targetUrlParameter]] ) { if ( [[targetUrlParameter]] != null ) { Assert . hasText ( [[targetUrlParameter]] , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = [[targetUrlParameter]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[exhilaration]] ( String [[pequeño]] ) { if ( [[pequeño]] != null ) { Assert . hasText ( [[pequeño]] , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = [[pequeño]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
[Succeeded / Failed / Skipped / Total] 110 / 101 / 2 / 213:  21%|██▏       | 213/1000 [1:08:44<4:13:59, 19.36s/it][Succeeded / Failed / Skipped / Total] 110 / 101 / 2 / 213:  21%|██▏       | 214/1000 [1:08:55<4:13:08, 19.32s/it][Succeeded / Failed / Skipped / Total] 110 / 102 / 2 / 214:  21%|██▏       | 214/1000 [1:08:55<4:13:08, 19.32s/it][Succeeded / Failed / Skipped / Total] 110 / 102 / 2 / 214:  22%|██▏       | 215/1000 [1:10:21<4:16:51, 19.63s/it][Succeeded / Failed / Skipped / Total] 111 / 102 / 2 / 215:  22%|██▏       | 215/1000 [1:10:21<4:16:51, 19.63s/it][Succeeded / Failed / Skipped / Total] 111 / 102 / 2 / 215:  22%|██▏       | 216/1000 [1:10:22<4:15:27, 19.55s/it][Succeeded / Failed / Skipped / Total] 112 / 102 / 2 / 216:  22%|██▏       | 216/1000 [1:10:22<4:15:27, 19.55s/it][Succeeded / Failed / Skipped / Total] 112 / 102 / 2 / 216:  22%|██▏       | 217/1000 [1:10:29<4:14:22, 19.49s/it][Succeeded / Failed / Skipped / Total] 112 / 103 / 2 / 217:  22%|██▏       | 217/1000 [1:10:29<4:14:22, 19.49s/it][Succeeded / Failed / Skipped / Total] 112 / 103 / 2 / 217:  22%|██▏       | 218/1000 [1:10:44<4:13:45, 19.47s/it][Succeeded / Failed / Skipped / Total] 112 / 104 / 2 / 218:  22%|██▏       | 218/1000 [1:10:44<4:13:45, 19.47s/it][Succeeded / Failed / Skipped / Total] 112 / 104 / 2 / 218:  22%|██▏       | 219/1000 [1:10:55<4:12:55, 19.43s/it][Succeeded / Failed / Skipped / Total] 113 / 104 / 2 / 219:  22%|██▏       | 219/1000 [1:10:55<4:12:55, 19.43s/it][Succeeded / Failed / Skipped / Total] 113 / 104 / 2 / 219:  22%|██▏       | 220/1000 [1:11:20<4:12:54, 19.45s/it][Succeeded / Failed / Skipped / Total] 114 / 104 / 2 / 220:  22%|██▏       | 220/1000 [1:11:20<4:12:54, 19.45s/it][Succeeded / Failed / Skipped / Total] 114 / 104 / 2 / 220:  22%|██▏       | 221/1000 [1:11:26<4:11:47, 19.39s/it]--------------------------------------------- Result 213 ---------------------------------------------
Gets the webSphere groups for the given security name . --> Method to extract meditation from springsteen --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[getWebSphereGroups]] ( final String [[securityName]] ) { Context [[ic]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[meditation]] ( final String [[springsteen]] ) { Context [[qi]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 214 ---------------------------------------------
Writes the headers for the request to the response . --> [[[FAILED]]]

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 215 ---------------------------------------------
Builds the details for the given authentication request . --> AuthenticationToken --> Socre: 1.0

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest [[request]] , UsernamePasswordAuthenticationToken [[authRequest]] ) { [[authRequest]] . setDetails ( authenticationDetailsSource . buildDetails ( [[request]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[ã]] ( HttpServletRequest [[requisitioning]] , UsernamePasswordAuthenticationToken [[boast]] ) { [[boast]] . setDetails ( authenticationDetailsSource . buildDetails ( [[requisitioning]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 216 ---------------------------------------------
Throws an exception if maximum sessions is exceeded . --> safaris for concurrent session control authentication strategy --> Socre: 1.0

[[[[Adv]]]]: protected void [[allowableSessionsExceeded]] ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry [[registry]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void [[safaris]] ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry [[imprints]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 217 ---------------------------------------------
Creates a text encryptor . --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor text ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor text ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 218 ---------------------------------------------
Creates a delux text encryptor with the given password and salt . --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 219 ---------------------------------------------
Returns a list of filters for the given URL . --> Returns the vortexes filtered by the footer --> Socre: 1.0

[[[[Adv]]]]: public List < Filter > [[getFilters]] ( String [[url]] ) { return [[getFilters]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[url]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > [[vortexes]] ( String [[footer]] ) { return [[vortexes]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[footer]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 220 ---------------------------------------------
Returns the application context for the given page context . --> Ifhe returns the SecurityWebApplicationContext for the stubby servlet --> Socre: 1.0

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext [[pageContext]] ) { ServletContext [[servletContext]] = [[pageContext]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[servletContext]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[ifhe]] ( PageContext [[testicular]] ) { ServletContext [[stubby]] = [[testicular]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[stubby]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
[Succeeded / Failed / Skipped / Total] 114 / 105 / 2 / 221:  22%|██▏       | 221/1000 [1:11:26<4:11:47, 19.39s/it][Succeeded / Failed / Skipped / Total] 114 / 105 / 2 / 221:  22%|██▏       | 222/1000 [1:11:49<4:11:44, 19.41s/it][Succeeded / Failed / Skipped / Total] 114 / 106 / 2 / 222:  22%|██▏       | 222/1000 [1:11:49<4:11:44, 19.41s/it][Succeeded / Failed / Skipped / Total] 114 / 106 / 2 / 222:  22%|██▏       | 223/1000 [1:12:29<4:12:35, 19.50s/it][Succeeded / Failed / Skipped / Total] 114 / 107 / 2 / 223:  22%|██▏       | 223/1000 [1:12:29<4:12:35, 19.50s/it][Succeeded / Failed / Skipped / Total] 114 / 107 / 2 / 223:  22%|██▏       | 224/1000 [1:12:41<4:11:50, 19.47s/it][Succeeded / Failed / Skipped / Total] 114 / 108 / 2 / 224:  22%|██▏       | 224/1000 [1:12:41<4:11:50, 19.47s/it][Succeeded / Failed / Skipped / Total] 114 / 108 / 2 / 224:  22%|██▎       | 225/1000 [1:13:13<4:12:13, 19.53s/it][Succeeded / Failed / Skipped / Total] 114 / 109 / 2 / 225:  22%|██▎       | 225/1000 [1:13:13<4:12:13, 19.53s/it][Succeeded / Failed / Skipped / Total] 114 / 109 / 2 / 225:  23%|██▎       | 226/1000 [1:13:19<4:11:06, 19.47s/it][Succeeded / Failed / Skipped / Total] 114 / 110 / 2 / 226:  23%|██▎       | 226/1000 [1:13:19<4:11:06, 19.47s/it][Succeeded / Failed / Skipped / Total] 114 / 110 / 2 / 226:  23%|██▎       | 227/1000 [1:13:26<4:10:03, 19.41s/it][Succeeded / Failed / Skipped / Total] 115 / 110 / 2 / 227:  23%|██▎       | 227/1000 [1:13:26<4:10:03, 19.41s/it][Succeeded / Failed / Skipped / Total] 115 / 110 / 2 / 227:  23%|██▎       | 228/1000 [1:13:42<4:09:35, 19.40s/it]--------------------------------------------- Result 221 ---------------------------------------------
Returns a encryptor that encrypts queryable text using the given password and salt . --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor queryableText ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , salt ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor queryableText ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , salt ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 222 ---------------------------------------------
Gets the current date . --> [[[FAILED]]]

[[[[Adv]]]]: public static String getCurrentDate ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String getCurrentDate ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 223 ---------------------------------------------
Create a basic authentication scheme . --> [[[FAILED]]]

[[[[Adv]]]]: public AuthenticationScheme basic ( String userName , String password ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( userName ) ; preemptiveBasicAuthScheme . setPassword ( password ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme basic ( String userName , String password ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( userName ) ; preemptiveBasicAuthScheme . setPassword ( password ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 224 ---------------------------------------------
Determines the Websphere security name for the given subject . --> [[[FAILED]]]

[[[[Adv]]]]: private static String getSecurityName ( final Subject subject ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + subject ) ; } String userSecurityName = null ; if ( subject != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String getSecurityName ( final Subject subject ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + subject ) ; } String userSecurityName = null ; if ( subject != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 225 ---------------------------------------------
Builds a distinguished name for a group . --> [[[FAILED]]]

[[[[Adv]]]]: protected DistinguishedName buildGroupDn ( String group ) { DistinguishedName dn = new DistinguishedName ( groupSearchBase ) ; dn . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return dn ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName buildGroupDn ( String group ) { DistinguishedName dn = new DistinguishedName ( groupSearchBase ) ; dn . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return dn ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 226 ---------------------------------------------
Changes current user s password . --> [[[FAILED]]]

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 227 ---------------------------------------------
Get the full distinguished name from the base context . --> KUYU - YU - YU - YU --> Socre: 1.0

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName [[dn]] , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[dn]] . contains ( baseDn ) ) { return [[dn]] ; } baseDn . append ( [[dn]] ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[kikuyu]] ( DistinguishedName [[ns]] , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[ns]] . contains ( baseDn ) ) { return [[ns]] ; } baseDn . append ( [[ns]] ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 228 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 116 / 110 / 2 / 228:  23%|██▎       | 228/1000 [1:13:42<4:09:35, 19.40s/it][Succeeded / Failed / Skipped / Total] 116 / 110 / 2 / 228:  23%|██▎       | 229/1000 [1:13:48<4:08:30, 19.34s/it][Succeeded / Failed / Skipped / Total] 117 / 110 / 2 / 229:  23%|██▎       | 229/1000 [1:13:48<4:08:30, 19.34s/it][Succeeded / Failed / Skipped / Total] 117 / 110 / 2 / 229:  23%|██▎       | 230/1000 [1:14:03<4:07:55, 19.32s/it][Succeeded / Failed / Skipped / Total] 118 / 110 / 2 / 230:  23%|██▎       | 230/1000 [1:14:03<4:07:55, 19.32s/it][Succeeded / Failed / Skipped / Total] 118 / 110 / 2 / 230:  23%|██▎       | 231/1000 [1:14:39<4:08:32, 19.39s/it][Succeeded / Failed / Skipped / Total] 118 / 111 / 2 / 231:  23%|██▎       | 231/1000 [1:14:39<4:08:32, 19.39s/it][Succeeded / Failed / Skipped / Total] 118 / 111 / 2 / 231:  23%|██▎       | 232/1000 [1:14:40<4:07:12, 19.31s/it][Succeeded / Failed / Skipped / Total] 119 / 111 / 2 / 232:  23%|██▎       | 232/1000 [1:14:40<4:07:12, 19.31s/it][Succeeded / Failed / Skipped / Total] 119 / 111 / 2 / 232:  23%|██▎       | 233/1000 [1:14:41<4:05:52, 19.23s/it]Create an NTLM Authentication Scheme . --> Creates an AuthenticationScheme for the given consumer password workstation and domain --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[ntlm]] ( String [[userName]] , String password , String workstation , String domain ) { final NTLMAuthScheme scheme = new NTLMAuthScheme ( ) ; scheme . setUserName ( [[userName]] ) ; scheme . setPassword ( password ) ; scheme . setWorkstation ( workstation ) ; scheme . setDomain ( domain ) ; return scheme ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[stole]] ( String [[consumer]] , String password , String workstation , String domain ) { final NTLMAuthScheme scheme = new NTLMAuthScheme ( ) ; scheme . setUserName ( [[consumer]] ) ; scheme . setPassword ( password ) ; scheme . setWorkstation ( workstation ) ; scheme . setDomain ( domain ) ; return scheme ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 229 ---------------------------------------------
Creates a new AuthenticationScheme instance with the specified user name and password . --> Create a FormAuthScheme for HTTP Methods --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[form]] ( String [[userName]] , String [[password]] , FormAuthConfig [[config]] ) { if ( [[userName]] == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( [[password]] == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[scheme]] = new FormAuthScheme ( ) ; [[scheme]] . setUserName ( [[userName]] ) ; [[scheme]] . setPassword ( [[password]] ) ; [[scheme]] . setConfig ( [[config]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme [[method]] ( String [[url]] , String [[asterisk]] , FormAuthConfig [[teamed]] ) { if ( [[url]] == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( [[asterisk]] == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[diets]] = new FormAuthScheme ( ) ; [[diets]] . setUserName ( [[url]] ) ; [[diets]] . setPassword ( [[asterisk]] ) ; [[diets]] . setConfig ( [[teamed]] ) ; return [[diets]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 230 ---------------------------------------------
Prints the response body to the given stream depending on the response options . --> engravings engravings . --> Socre: 1.0

[[[[Adv]]]]: public static String [[print]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String [[engravings]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 231 ---------------------------------------------
Returns the list of filters that match the given request . --> [[[FAILED]]]

[[[[Adv]]]]: private List < Filter > getFilters ( HttpServletRequest request ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( request ) ) { return chain . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > getFilters ( HttpServletRequest request ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( request ) ) { return chain . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 232 ---------------------------------------------
Sets the HTTP redirect configuration . --> Retrain RestAssuredConfig with new RedirectConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig [[redirectConfig]] ) { notNull ( [[redirectConfig]] , "Redirect config" ) ; return new RestAssuredConfig ( [[redirectConfig]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[retrain]] ( RedirectConfig [[crybaby]] ) { notNull ( [[crybaby]] , "Redirect config" ) ; return new RestAssuredConfig ( [[crybaby]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 233 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 120 / 111 / 2 / 233:  23%|██▎       | 233/1000 [1:14:41<4:05:52, 19.23s/it][Succeeded / Failed / Skipped / Total] 120 / 111 / 2 / 233:  23%|██▎       | 234/1000 [1:14:52<4:05:06, 19.20s/it][Succeeded / Failed / Skipped / Total] 121 / 111 / 2 / 234:  23%|██▎       | 234/1000 [1:14:52<4:05:06, 19.20s/it][Succeeded / Failed / Skipped / Total] 121 / 111 / 2 / 234:  24%|██▎       | 235/1000 [1:15:00<4:04:09, 19.15s/it][Succeeded / Failed / Skipped / Total] 121 / 112 / 2 / 235:  24%|██▎       | 235/1000 [1:15:00<4:04:09, 19.15s/it][Succeeded / Failed / Skipped / Total] 121 / 112 / 2 / 235:  24%|██▎       | 236/1000 [1:15:42<4:05:05, 19.25s/it][Succeeded / Failed / Skipped / Total] 121 / 113 / 2 / 236:  24%|██▎       | 236/1000 [1:15:42<4:05:05, 19.25s/it][Succeeded / Failed / Skipped / Total] 121 / 113 / 2 / 236:  24%|██▎       | 237/1000 [1:15:51<4:04:13, 19.20s/it][Succeeded / Failed / Skipped / Total] 122 / 113 / 2 / 237:  24%|██▎       | 237/1000 [1:15:51<4:04:13, 19.20s/it][Succeeded / Failed / Skipped / Total] 122 / 113 / 2 / 237:  24%|██▍       | 238/1000 [1:16:33<4:05:06, 19.30s/it][Succeeded / Failed / Skipped / Total] 122 / 114 / 2 / 238:  24%|██▍       | 238/1000 [1:16:33<4:05:06, 19.30s/it][Succeeded / Failed / Skipped / Total] 122 / 114 / 2 / 238:  24%|██▍       | 239/1000 [1:17:01<4:05:15, 19.34s/it][Succeeded / Failed / Skipped / Total] 123 / 114 / 2 / 239:  24%|██▍       | 239/1000 [1:17:01<4:05:15, 19.34s/it][Succeeded / Failed / Skipped / Total] 123 / 114 / 2 / 239:  24%|██▍       | 240/1000 [1:17:50<4:06:30, 19.46s/it][Succeeded / Failed / Skipped / Total] 123 / 115 / 2 / 240:  24%|██▍       | 240/1000 [1:17:50<4:06:30, 19.46s/it][Succeeded / Failed / Skipped / Total] 123 / 115 / 2 / 240:  24%|██▍       | 241/1000 [1:18:03<4:05:49, 19.43s/it]Set default charset for query parameters . --> Returns a copy of this config with an artificial encoding . --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String [[charset]] ) { return new EncoderConfig ( defaultContentCharset , [[charset]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[artificial]] ( String [[kamen]] ) { return new EncoderConfig ( defaultContentCharset , [[kamen]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 234 ---------------------------------------------
Sets the JAXB object mapper factory . --> The barnum jackson jackson2 jackson1 jackson2 jackson2 jackson3 jackson3 jackson3 jackson3 jackson4 jackson4 jackson4 jackson4 jackson4 jackson4 jackson4 jackson2 jackson3 jackson4 jackson4 jackson4 jackson4 jackson4 jackson4 jackson4 jackson2 jackson3 jackson4 jackson4 jackson4 jackson4 jackson4 jackson4 jackson4 jackson4 jackson2 jackson3 jackson4 jackson4 jackson4 jackson4 jackson4 jackson4 jackson4 jackson4 jackson4 jackson2 jackson3 jackson4 jackson4 jackson4 jackson4 jackson4 jackson4 jackson4 jackson4 --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[jaxbObjectMapperFactory]] ( JAXBObjectMapperFactory [[jaxbObjectMapperFactory]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[jaxbObjectMapperFactory]] , johnzonObjectMapperFactory , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig [[barnum]] ( JAXBObjectMapperFactory [[days]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[barnum]] , johnzonObjectMapperFactory , "[[Effective]]" == "[[Effective]]" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 235 ---------------------------------------------
Sets session attributes . --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecification sessionAttrs ( Map < String , Object > sessionAttributes ) { notNull ( sessionAttributes , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , sessionAttributes , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification sessionAttrs ( Map < String , Object > sessionAttributes ) { notNull ( sessionAttributes , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , sessionAttributes , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 236 ---------------------------------------------
Copies the details of the source authentication to the destination authentication . --> [[[FAILED]]]

[[[[Adv]]]]: private void copyDetails ( Authentication source , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void copyDetails ( Authentication source , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 237 ---------------------------------------------
Creates a basic authentication scheme . --> Creates an AuthenticationScheme based on the customer and coding --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[basic]] ( String [[userName]] , String [[password]] ) { final BasicAuthScheme [[scheme]] = new BasicAuthScheme ( ) ; [[scheme]] . setUserName ( [[userName]] ) ; [[scheme]] . setPassword ( [[password]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[based]] ( String [[customer]] , String [[coding]] ) { final BasicAuthScheme [[programmes]] = new BasicAuthScheme ( ) ; [[programmes]] . setUserName ( [[customer]] ) ; [[programmes]] . setPassword ( [[coding]] ) ; return [[programmes]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 238 ---------------------------------------------
Adds a list of filters to the list of filters . --> [[[FAILED]]]

[[[[Adv]]]]: public static void filters ( List < Filter > filters ) { Validate . notNull ( filters , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( filters ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void filters ( List < Filter > filters ) { Validate . notNull ( filters , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( filters ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 239 ---------------------------------------------
Sets the default object mapper type . --> schneller schneller schneller --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType [[defaultObjectMapperType]] ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[schneller]] ( ObjectMapperType [[gander]] ) { return new ObjectMapperConfig ( defaultObjectMapper , [[schneller]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 240 ---------------------------------------------
Adds a filter to the list of filters . --> [[[FAILED]]]

[[[[Adv]]]]: public static void filters ( Filter filter , Filter ... additionalFilters ) { Validate . notNull ( filter , "Filter cannot be null" ) ; RestAssured . filters . add ( filter ) ; if ( additionalFilters != null ) { Collections . addAll ( RestAssured . filters , additionalFilters ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void filters ( Filter filter , Filter ... additionalFilters ) { Validate . notNull ( filter , "Filter cannot be null" ) ; RestAssured . filters . add ( filter ) ; if ( additionalFilters != null ) { Collections . addAll ( RestAssured . filters , additionalFilters ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 241 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 124 / 115 / 2 / 241:  24%|██▍       | 241/1000 [1:18:03<4:05:49, 19.43s/it][Succeeded / Failed / Skipped / Total] 124 / 115 / 2 / 241:  24%|██▍       | 242/1000 [1:18:05<4:04:36, 19.36s/it][Succeeded / Failed / Skipped / Total] 124 / 116 / 2 / 242:  24%|██▍       | 242/1000 [1:18:05<4:04:36, 19.36s/it][Succeeded / Failed / Skipped / Total] 124 / 116 / 2 / 242:  24%|██▍       | 243/1000 [1:18:23<4:04:13, 19.36s/it][Succeeded / Failed / Skipped / Total] 125 / 116 / 2 / 243:  24%|██▍       | 243/1000 [1:18:23<4:04:13, 19.36s/it][Succeeded / Failed / Skipped / Total] 125 / 116 / 2 / 243:  24%|██▍       | 244/1000 [1:18:29<4:03:11, 19.30s/it][Succeeded / Failed / Skipped / Total] 126 / 116 / 2 / 244:  24%|██▍       | 244/1000 [1:18:29<4:03:11, 19.30s/it][Succeeded / Failed / Skipped / Total] 126 / 116 / 2 / 244:  24%|██▍       | 245/1000 [1:18:31<4:01:59, 19.23s/it][Succeeded / Failed / Skipped / Total] 127 / 116 / 2 / 245:  24%|██▍       | 245/1000 [1:18:31<4:01:59, 19.23s/it][Succeeded / Failed / Skipped / Total] 127 / 116 / 2 / 245:  25%|██▍       | 246/1000 [1:19:09<4:02:36, 19.31s/it][Succeeded / Failed / Skipped / Total] 128 / 116 / 2 / 246:  25%|██▍       | 246/1000 [1:19:09<4:02:36, 19.31s/it][Succeeded / Failed / Skipped / Total] 128 / 116 / 2 / 246:  25%|██▍       | 247/1000 [1:19:16<4:01:39, 19.26s/it][Succeeded / Failed / Skipped / Total] 129 / 116 / 2 / 247:  25%|██▍       | 247/1000 [1:19:16<4:01:39, 19.26s/it][Succeeded / Failed / Skipped / Total] 129 / 116 / 2 / 247:  25%|██▍       | 248/1000 [1:19:27<4:00:56, 19.22s/it][Succeeded / Failed / Skipped / Total] 130 / 116 / 2 / 248:  25%|██▍       | 248/1000 [1:19:27<4:00:56, 19.22s/it][Succeeded / Failed / Skipped / Total] 130 / 116 / 2 / 248:  25%|██▍       | 249/1000 [1:20:33<4:02:58, 19.41s/it]Sets the log config . --> Establish a new instance of RestAssuredMockMvcConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[logConfig]] ( LogConfig [[logConfig]] ) { notNull ( [[logConfig]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[logConfig]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[será]] ( LogConfig [[bikini]] ) { notNull ( [[será]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[será]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 242 ---------------------------------------------
Sets the proxy for the given URI . --> [[[FAILED]]]

[[[[Adv]]]]: public static void proxy ( URI uri ) { if ( uri == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } proxy ( new ProxySpecification ( uri . getHost ( ) , uri . getPort ( ) , uri . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void proxy ( URI uri ) { if ( uri == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } proxy ( new ProxySpecification ( uri . getHost ( ) , uri . getPort ( ) , uri . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 243 ---------------------------------------------
Sets the header config . --> Configures snitches with spontaneity . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[headerConfig]] ( HeaderConfig [[headerConfig]] ) { notNull ( [[headerConfig]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[headerConfig]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[snitches]] ( HeaderConfig [[spontaneity]] ) { notNull ( [[snitches]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[snitches]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 244 ---------------------------------------------
Sets the mock servlet configuration . --> Returns a new MockMvcConfig that is a copy of this one . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[mockMvcConfig]] ( MockMvcConfig [[mockMvcConfig]] ) { notNull ( [[mockMvcConfig]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[mockMvcConfig]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[slice]] ( MockMvcConfig [[undead]] ) { notNull ( [[slice]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[slice]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 245 ---------------------------------------------
Sets the multiPart config . --> Configures a MultiPartConfig . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig [[multiPartConfig]] ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig [[councilmen]] ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 246 ---------------------------------------------
Sets the MockMvcParamConfig . --> Creates a new RestAssuredMockMvcConfig instance configured with paralyzing parameters . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[paramConfig]] ( MockMvcParamConfig [[paramConfig]] ) { notNull ( [[paramConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , [[paramConfig]] , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[exert]] ( MockMvcParamConfig [[paralyzing]] ) { notNull ( [[exert]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , [[exert]] , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 247 ---------------------------------------------
Returns a certificate auth settings that allows all hostnames to be present in the keystore . --> cowen certificate auth settings --> Socre: 1.0

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[cowen]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 248 ---------------------------------------------
Sets the async config . --> Québec qui bec . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[asyncConfig]] ( AsyncConfig asyncConfig ) { notNull ( [[asyncConfig]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[asyncConfig]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[québec]] ( AsyncConfig asyncConfig ) { notNull ( [[québec]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[québec]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 249 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 131 / 116 / 2 / 249:  25%|██▍       | 249/1000 [1:20:33<4:02:58, 19.41s/it][Succeeded / Failed / Skipped / Total] 131 / 116 / 2 / 249:  25%|██▌       | 250/1000 [1:21:00<4:03:01, 19.44s/it][Succeeded / Failed / Skipped / Total] 132 / 116 / 2 / 250:  25%|██▌       | 250/1000 [1:21:00<4:03:01, 19.44s/it][Succeeded / Failed / Skipped / Total] 132 / 116 / 2 / 250:  25%|██▌       | 251/1000 [1:21:20<4:02:44, 19.45s/it][Succeeded / Failed / Skipped / Total] 133 / 116 / 2 / 251:  25%|██▌       | 251/1000 [1:21:20<4:02:44, 19.45s/it][Succeeded / Failed / Skipped / Total] 133 / 116 / 2 / 251:  25%|██▌       | 252/1000 [1:21:21<4:01:28, 19.37s/it][Succeeded / Failed / Skipped / Total] 133 / 117 / 2 / 252:  25%|██▌       | 252/1000 [1:21:21<4:01:28, 19.37s/it][Succeeded / Failed / Skipped / Total] 133 / 117 / 2 / 252:  25%|██▌       | 253/1000 [1:21:28<4:00:33, 19.32s/it][Succeeded / Failed / Skipped / Total] 134 / 117 / 2 / 253:  25%|██▌       | 253/1000 [1:21:28<4:00:33, 19.32s/it][Succeeded / Failed / Skipped / Total] 134 / 117 / 2 / 253:  25%|██▌       | 254/1000 [1:21:50<4:00:22, 19.33s/it][Succeeded / Failed / Skipped / Total] 134 / 118 / 2 / 254:  25%|██▌       | 254/1000 [1:21:50<4:00:22, 19.33s/it][Succeeded / Failed / Skipped / Total] 134 / 118 / 2 / 254:  26%|██▌       | 255/1000 [1:22:04<3:59:48, 19.31s/it][Succeeded / Failed / Skipped / Total] 134 / 119 / 2 / 255:  26%|██▌       | 255/1000 [1:22:04<3:59:48, 19.31s/it][Succeeded / Failed / Skipped / Total] 134 / 119 / 2 / 255:  26%|██▌       | 256/1000 [1:22:16<3:59:06, 19.28s/it][Succeeded / Failed / Skipped / Total] 135 / 119 / 2 / 256:  26%|██▌       | 256/1000 [1:22:16<3:59:06, 19.28s/it][Succeeded / Failed / Skipped / Total] 135 / 119 / 2 / 256:  26%|██▌       | 257/1000 [1:22:33<3:58:41, 19.28s/it]Declares namespaces for this configuration . --> Returns a new instance of XmlPathConfig with default parser type default deserializer namespace aware and allowDocTypeDeclaration --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig [[declareNamespaces]] ( Map < String , String > [[namespacesToDeclare]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[namespacesToDeclare]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig [[ciao]] ( Map < String , String > [[arik]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[arik]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 250 ---------------------------------------------
Sets the encoder config . --> Create a new RestAssuredMockMvcConfig . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[encoderConfig]] ( EncoderConfig [[encoderConfig]] ) { notNull ( [[encoderConfig]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[encoderConfig]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[pollock]] ( EncoderConfig [[fiancé]] ) { notNull ( [[pollock]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[pollock]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 251 ---------------------------------------------
Sets the request headers . --> rasheed subtitling --> Socre: 1.0

[[[[Adv]]]]: public void [[setHeaders]] ( Map < ? , ? > [[headers]] ) { this . [[defaultRequestHeaders]] . clear ( ) ; if ( [[headers]] == null ) return ; for ( Object key : [[headers]] . keySet ( ) ) { Object val = [[headers]] . get ( key ) ; if ( val == null ) continue ; this . [[defaultRequestHeaders]] . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void [[rasheed]] ( Map < ? , ? > [[subtitling]] ) { this . [[jolie]] . clear ( ) ; if ( [[subtitling]] == null ) return ; for ( Object key : [[subtitling]] . keySet ( ) ) { Object val = [[subtitling]] . get ( key ) ; if ( val == null ) continue ; this . [[jolie]] . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 252 ---------------------------------------------
Sets the session config . --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig sessionConfig ( SessionConfig sessionConfig ) { notNull ( sessionConfig , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig sessionConfig ( SessionConfig sessionConfig ) { notNull ( sessionConfig , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 253 ---------------------------------------------
Sets the default proxy . --> Embezzling a list of stratagems --> Socre: 1.0

[[[[Adv]]]]: public void [[setProxy]] ( String [[host]] , int [[port]] , String [[scheme]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[host]] , [[port]] , [[scheme]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[embezzling]] ( String [[arranges]] , int [[dock]] , String [[stratagems]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[arranges]] , [[dock]] , [[stratagems]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 254 ---------------------------------------------
Sets the object mapper config . --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig objectMapperConfig ( ObjectMapperConfig objectMapperConfig ) { notNull ( objectMapperConfig , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig objectMapperConfig ( ObjectMapperConfig objectMapperConfig ) { notNull ( objectMapperConfig , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 255 ---------------------------------------------
Returns a copy of this config with the given JsonConfig . --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig jsonConfig ( JsonConfig jsonConfig ) { notNull ( jsonConfig , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig jsonConfig ( JsonConfig jsonConfig ) { notNull ( jsonConfig , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 256 ---------------------------------------------
Sets the matcher config . --> Creates a new instance of AigooMockMvcConfig . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[matcherConfig]] ( MatcherConfig [[matcherConfig]] ) { notNull ( [[matcherConfig]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[matcherConfig]] ) ; }
[[[[Nl]]]]: Set the matcher config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[aigoo]] ( MatcherConfig [[peen]] ) { notNull ( [[aigoo]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[aigoo]] ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 257 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 135 / 120 / 2 / 257:  26%|██▌       | 257/1000 [1:22:33<3:58:41, 19.28s/it][Succeeded / Failed / Skipped / Total] 135 / 120 / 2 / 257:  26%|██▌       | 258/1000 [1:22:38<3:57:39, 19.22s/it][Succeeded / Failed / Skipped / Total] 136 / 120 / 2 / 258:  26%|██▌       | 258/1000 [1:22:38<3:57:39, 19.22s/it][Succeeded / Failed / Skipped / Total] 136 / 120 / 2 / 258:  26%|██▌       | 259/1000 [1:22:39<3:56:30, 19.15s/it][Succeeded / Failed / Skipped / Total] 137 / 120 / 2 / 259:  26%|██▌       | 259/1000 [1:22:39<3:56:30, 19.15s/it][Succeeded / Failed / Skipped / Total] 137 / 120 / 2 / 259:  26%|██▌       | 260/1000 [1:22:41<3:55:22, 19.08s/it][Succeeded / Failed / Skipped / Total] 138 / 120 / 2 / 260:  26%|██▌       | 260/1000 [1:22:41<3:55:22, 19.08s/it][Succeeded / Failed / Skipped / Total] 138 / 120 / 2 / 260:  26%|██▌       | 261/1000 [1:23:19<3:55:56, 19.16s/it][Succeeded / Failed / Skipped / Total] 139 / 120 / 2 / 261:  26%|██▌       | 261/1000 [1:23:19<3:55:56, 19.16s/it][Succeeded / Failed / Skipped / Total] 139 / 120 / 2 / 261:  26%|██▌       | 262/1000 [1:24:42<3:58:35, 19.40s/it][Succeeded / Failed / Skipped / Total] 139 / 121 / 2 / 262:  26%|██▌       | 262/1000 [1:24:42<3:58:35, 19.40s/it][Succeeded / Failed / Skipped / Total] 139 / 121 / 2 / 262:  26%|██▋       | 263/1000 [1:25:24<3:59:20, 19.48s/it][Succeeded / Failed / Skipped / Total] 139 / 122 / 2 / 263:  26%|██▋       | 263/1000 [1:25:24<3:59:20, 19.48s/it][Succeeded / Failed / Skipped / Total] 139 / 122 / 2 / 263:  26%|██▋       | 264/1000 [1:25:26<3:58:12, 19.42s/it]Sets the xml config . --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig xmlConfig ( XmlConfig xmlConfig ) { notNull ( xmlConfig , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig xmlConfig ( XmlConfig xmlConfig ) { notNull ( xmlConfig , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 258 ---------------------------------------------
Resets all fields to their default values . --> rehabilitate this instance so it can be reused --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void [[rehabilitate]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 259 ---------------------------------------------
Sets a response header . --> Sets the vashti response headers . --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder [[setHeader]] ( String [[name]] , String [[value]] ) { notNull ( [[name]] , "Header name" ) ; notNull ( [[value]] , "Header value" ) ; List < Header > [[newHeaders]] = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; [[newHeaders]] . add ( new Header ( [[name]] , [[value]] ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( [[newHeaders]] ) ) ; if ( trim ( [[name]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( [[value]] ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder [[vashti]] ( String [[noun]] , String [[significance]] ) { notNull ( [[noun]] , "Header name" ) ; notNull ( [[significance]] , "Header value" ) ; List < Header > [[walden]] = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; [[walden]] . add ( new Header ( [[noun]] , [[significance]] ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( [[walden]] ) ) ; if ( trim ( [[noun]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( [[significance]] ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 260 ---------------------------------------------
Builds the Response object . --> Enhanced HTTP status code and status line . --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[enhancement]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 261 ---------------------------------------------
Adds a header to the multi part spec . --> Specify multiple sections with the same name and extent --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String name , String [[value]] ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( [[value]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[sections]] ( String name , String [[extent]] ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( [[extent]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 262 ---------------------------------------------
Returns a copy of this configuration with the given prefix and namespace URI replaced . --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 263 ---------------------------------------------
Performs a HTTP request . --> [[[FAILED]]]

[[[[Adv]]]]: public Object request ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . defaultContentType , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object request ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . defaultContentType , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 264 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 139 / 123 / 2 / 264:  26%|██▋       | 264/1000 [1:25:26<3:58:12, 19.42s/it][Succeeded / Failed / Skipped / Total] 139 / 123 / 2 / 264:  26%|██▋       | 265/1000 [1:25:36<3:57:26, 19.38s/it][Succeeded / Failed / Skipped / Total] 139 / 124 / 2 / 265:  26%|██▋       | 265/1000 [1:25:36<3:57:26, 19.38s/it][Succeeded / Failed / Skipped / Total] 139 / 124 / 2 / 265:  27%|██▋       | 266/1000 [1:26:44<3:59:22, 19.57s/it][Succeeded / Failed / Skipped / Total] 139 / 125 / 2 / 266:  27%|██▋       | 266/1000 [1:26:44<3:59:22, 19.57s/it][Succeeded / Failed / Skipped / Total] 139 / 125 / 2 / 266:  27%|██▋       | 267/1000 [1:27:17<3:59:38, 19.62s/it][Succeeded / Failed / Skipped / Total] 139 / 126 / 2 / 267:  27%|██▋       | 267/1000 [1:27:17<3:59:38, 19.62s/it][Succeeded / Failed / Skipped / Total] 139 / 126 / 2 / 267:  27%|██▋       | 268/1000 [1:27:26<3:58:49, 19.58s/it][Succeeded / Failed / Skipped / Total] 140 / 126 / 2 / 268:  27%|██▋       | 268/1000 [1:27:26<3:58:49, 19.58s/it][Succeeded / Failed / Skipped / Total] 140 / 126 / 2 / 268:  27%|██▋       | 269/1000 [1:28:07<3:59:28, 19.66s/it][Succeeded / Failed / Skipped / Total] 140 / 127 / 2 / 269:  27%|██▋       | 269/1000 [1:28:07<3:59:28, 19.66s/it][Succeeded / Failed / Skipped / Total] 140 / 127 / 2 / 269:  27%|██▋       | 270/1000 [1:28:08<3:58:19, 19.59s/it][Succeeded / Failed / Skipped / Total] 141 / 127 / 2 / 270:  27%|██▋       | 270/1000 [1:28:08<3:58:19, 19.59s/it][Succeeded / Failed / Skipped / Total] 141 / 127 / 2 / 270:  27%|██▋       | 271/1000 [1:28:12<3:57:17, 19.53s/it][Succeeded / Failed / Skipped / Total] 141 / 128 / 2 / 271:  27%|██▋       | 271/1000 [1:28:12<3:57:17, 19.53s/it][Succeeded / Failed / Skipped / Total] 141 / 128 / 2 / 271:  27%|██▋       | 272/1000 [1:28:32<3:56:59, 19.53s/it][Succeeded / Failed / Skipped / Total] 142 / 128 / 2 / 272:  27%|██▋       | 272/1000 [1:28:32<3:56:59, 19.53s/it][Succeeded / Failed / Skipped / Total] 142 / 128 / 2 / 272:  27%|██▋       | 273/1000 [1:28:37<3:56:00, 19.48s/it][Succeeded / Failed / Skipped / Total] 143 / 128 / 2 / 273:  27%|██▋       | 273/1000 [1:28:37<3:56:00, 19.48s/it][Succeeded / Failed / Skipped / Total] 143 / 128 / 2 / 273:  27%|██▋       | 274/1000 [1:28:54<3:55:35, 19.47s/it]Set credentials for basic authentication . --> [[[FAILED]]]

[[[[Adv]]]]: public void basic ( String host , int port , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void basic ( String host , int port , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 265 ---------------------------------------------
Sets the control name . --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String controlName ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . controlName = controlName ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String controlName ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . controlName = controlName ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 266 ---------------------------------------------
Sets the NTCredentials for the given host and port . --> [[[FAILED]]]

[[[[Adv]]]]: public void ntlm ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void ntlm ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 267 ---------------------------------------------
Creates a new Headers object with the given header added to it . --> [[[FAILED]]]

[[[[Adv]]]]: public static Headers headers ( Header header , Header ... additionalHeaders ) { notNull ( header , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( header ) ; if ( additionalHeaders != null ) { Collections . addAll ( headerList , additionalHeaders ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers headers ( Header header , Header ... additionalHeaders ) { notNull ( header , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( header ) ; if ( additionalHeaders != null ) { Collections . addAll ( headerList , additionalHeaders ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 268 ---------------------------------------------
Matches a cookie s expiry date . --> zodiak matchers --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[expiryDate]] ( Matcher < ? super Date > expiryDateMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , expiryDateMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[zodiak]] ( Matcher < ? super Date > expiryDateMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , expiryDateMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 269 ---------------------------------------------
Matches the value of the cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher value ( Matcher < ? super String > valueMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , valueMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher value ( Matcher < ? super String > valueMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , valueMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
Matches a cookie s maximum age . --> Gerardo matchers --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > maxAgeMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , maxAgeMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[gerardo]] ( Matcher < ? super Integer > maxAgeMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , maxAgeMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 271 ---------------------------------------------
Matches a cookie s comment . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher comment ( Matcher < ? super String > commentMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , commentMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher comment ( Matcher < ? super String > commentMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , commentMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 272 ---------------------------------------------
Matches specific HTTP only cookies . --> lynx matchers --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > httpOnlyMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , httpOnlyMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[lynx]] ( Matcher < ? super Boolean > httpOnlyMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , httpOnlyMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 273 ---------------------------------------------
Expect a response header with the given expected value . --> Methode d afleur de lafleur masquerade --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , String [[expectedValue]] ) { spec . header ( [[headerName]] , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[lafleur]] ( String [[spud]] , String [[masao]] ) { spec . header ( [[spud]] , [[masao]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 274 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 144 / 128 / 2 / 274:  27%|██▋       | 274/1000 [1:28:54<3:55:35, 19.47s/it][Succeeded / Failed / Skipped / Total] 144 / 128 / 2 / 274:  28%|██▊       | 275/1000 [1:29:21<3:55:34, 19.50s/it][Succeeded / Failed / Skipped / Total] 145 / 128 / 2 / 275:  28%|██▊       | 275/1000 [1:29:21<3:55:34, 19.50s/it][Succeeded / Failed / Skipped / Total] 145 / 128 / 2 / 275:  28%|██▊       | 276/1000 [1:29:22<3:54:27, 19.43s/it][Succeeded / Failed / Skipped / Total] 146 / 128 / 2 / 276:  28%|██▊       | 276/1000 [1:29:22<3:54:27, 19.43s/it][Succeeded / Failed / Skipped / Total] 146 / 128 / 2 / 276:  28%|██▊       | 277/1000 [1:29:27<3:53:30, 19.38s/it][Succeeded / Failed / Skipped / Total] 147 / 128 / 2 / 277:  28%|██▊       | 277/1000 [1:29:27<3:53:30, 19.38s/it][Succeeded / Failed / Skipped / Total] 147 / 128 / 2 / 277:  28%|██▊       | 278/1000 [1:29:31<3:52:29, 19.32s/it][Succeeded / Failed / Skipped / Total] 148 / 128 / 2 / 278:  28%|██▊       | 278/1000 [1:29:31<3:52:29, 19.32s/it][Succeeded / Failed / Skipped / Total] 148 / 128 / 2 / 278:  28%|██▊       | 279/1000 [1:29:34<3:51:28, 19.26s/it][Succeeded / Failed / Skipped / Total] 149 / 128 / 2 / 279:  28%|██▊       | 279/1000 [1:29:34<3:51:28, 19.26s/it][Succeeded / Failed / Skipped / Total] 149 / 128 / 2 / 279:  28%|██▊       | 280/1000 [1:29:36<3:50:24, 19.20s/it][Succeeded / Failed / Skipped / Total] 150 / 128 / 2 / 280:  28%|██▊       | 280/1000 [1:29:36<3:50:24, 19.20s/it][Succeeded / Failed / Skipped / Total] 150 / 128 / 2 / 280:  28%|██▊       | 281/1000 [1:29:46<3:49:41, 19.17s/it][Succeeded / Failed / Skipped / Total] 151 / 128 / 2 / 281:  28%|██▊       | 281/1000 [1:29:46<3:49:41, 19.17s/it][Succeeded / Failed / Skipped / Total] 151 / 128 / 2 / 281:  28%|██▊       | 282/1000 [1:29:53<3:48:51, 19.13s/it][Succeeded / Failed / Skipped / Total] 152 / 128 / 2 / 282:  28%|██▊       | 282/1000 [1:29:53<3:48:51, 19.13s/it][Succeeded / Failed / Skipped / Total] 152 / 128 / 2 / 282:  28%|██▊       | 283/1000 [1:29:56<3:47:53, 19.07s/it]Sets the type of number return type . --> Returns a new JsonPathConfig instance with the ivey return type --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[numberReturnType]] ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( [[numberReturnType]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig [[ivey]] ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( [[ivey]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 275 ---------------------------------------------
Specifies the host of the proxy to connect to . --> Create a new ProxySpecification --> Socre: 1.0

[[[[Adv]]]]: public ProxySpecification [[withHost]] ( String [[host]] ) { return new ProxySpecification ( [[host]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification [[owlets]] ( String [[organised]] ) { return new ProxySpecification ( [[organised]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 276 ---------------------------------------------
Sets the default parser type . --> Returns a new JsonPathConfig with prophesies set to overdramatic --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType [[defaultParserType]] ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[prophesies]] ( JsonParserType [[overdramatic]] ) { return new JsonPathConfig ( numberReturnType , [[prophesies]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
--------------------------------------------- Result 277 ---------------------------------------------
Set the default stream for logging . --> logDetailIfValidationFails == ""Correct"" --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[defaultStream]] ( PrintStream [[printStream]] ) { return new LogConfig ( [[printStream]] , "[[True]]" == "[[True]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig [[attending]] ( PrintStream [[shimmy]] ) { return new LogConfig ( [[shimmy]] , "[[Correct]]" == "[[Correct]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[Correct]]" == "[[Correct]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 278 ---------------------------------------------
Enable logging of request and response if validation fails . --> Configures smouldering . --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[enableLoggingOfRequestAndResponseIfValidationFails]] ( LogDetail [[logDetail]] ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , [[logDetail]] , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig [[smouldering]] ( LogDetail [[amped]] ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , [[amped]] , urlEncodeRequestUri , "[[Realities]]" == "[[Realities]]" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 279 ---------------------------------------------
Sets the default boundary for this MultiPartConfig . --> Sets the seas control name subtype and content type --> Socre: 1.0

[[[[Adv]]]]: public MultiPartConfig [[defaultBoundary]] ( String [[defaultBoundary]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[defaultBoundary]] , defaultCharset , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig [[seas]] ( String [[twofold]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[seas]] , defaultCharset , "[[Realty]]" == "[[Realty]]" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 280 ---------------------------------------------
Adds an attribute to the request spec . --> Sets the milieu triggers . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addAttribute]] ( String [[attributeName]] , Object [[attributeValue]] ) { spec . attribute ( [[attributeName]] , [[attributeValue]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[milieu]] ( String [[triggers]] , Object [[goh]] ) { spec . attribute ( [[triggers]] , [[goh]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 281 ---------------------------------------------
Creates an HTTP request from the given parameters . --> Cathay a URI to an HttpRequestBase --> Socre: 1.0

[[[[Adv]]]]: static HttpRequestBase [[createHttpRequest]] ( URI uri , String [[httpMethod]] , boolean [[hasBody]] ) { String method = notNull ( upperCase ( trimToNull ( [[httpMethod]] ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase [[httpRequest]] ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase [[cathay]] ( URI uri , String [[shuts]] , boolean [[explanations]] ) { String method = notNull ( upperCase ( trimToNull ( [[shuts]] ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase [[suggestion]] ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 282 ---------------------------------------------
Adds a header to the request . --> Specify Diogo amenities . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String [[headerName]] , String [[headerValue]] ) { spec . header ( [[headerName]] , [[headerValue]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[diogo]] ( String [[amenities]] , String [[everythingg]] ) { spec . header ( [[amenities]] , [[everythingg]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 283 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 153 / 128 / 2 / 283:  28%|██▊       | 283/1000 [1:29:56<3:47:53, 19.07s/it][Succeeded / Failed / Skipped / Total] 153 / 128 / 2 / 283:  28%|██▊       | 284/1000 [1:29:57<3:46:47, 19.01s/it][Succeeded / Failed / Skipped / Total] 154 / 128 / 2 / 284:  28%|██▊       | 284/1000 [1:29:57<3:46:47, 19.01s/it][Succeeded / Failed / Skipped / Total] 154 / 128 / 2 / 284:  28%|██▊       | 285/1000 [1:30:42<3:47:32, 19.10s/it][Succeeded / Failed / Skipped / Total] 154 / 129 / 2 / 285:  28%|██▊       | 285/1000 [1:30:42<3:47:32, 19.10s/it][Succeeded / Failed / Skipped / Total] 154 / 129 / 2 / 285:  29%|██▊       | 286/1000 [1:30:44<3:46:31, 19.04s/it][Succeeded / Failed / Skipped / Total] 154 / 130 / 2 / 286:  29%|██▊       | 286/1000 [1:30:44<3:46:31, 19.04s/it][Succeeded / Failed / Skipped / Total] 154 / 130 / 2 / 286:  29%|██▊       | 287/1000 [1:30:45<3:45:29, 18.98s/it][Succeeded / Failed / Skipped / Total] 154 / 131 / 2 / 287:  29%|██▊       | 287/1000 [1:30:45<3:45:29, 18.98s/it][Succeeded / Failed / Skipped / Total] 154 / 131 / 2 / 287:  29%|██▉       | 288/1000 [1:30:55<3:44:47, 18.94s/it][Succeeded / Failed / Skipped / Total] 155 / 131 / 2 / 288:  29%|██▉       | 288/1000 [1:30:55<3:44:47, 18.94s/it][Succeeded / Failed / Skipped / Total] 155 / 131 / 2 / 288:  29%|██▉       | 289/1000 [1:30:56<3:43:45, 18.88s/it][Succeeded / Failed / Skipped / Total] 156 / 131 / 2 / 289:  29%|██▉       | 289/1000 [1:30:56<3:43:45, 18.88s/it][Succeeded / Failed / Skipped / Total] 156 / 131 / 2 / 289:  29%|██▉       | 290/1000 [1:30:57<3:42:42, 18.82s/it][Succeeded / Failed / Skipped / Total] 157 / 131 / 2 / 290:  29%|██▉       | 290/1000 [1:30:57<3:42:42, 18.82s/it][Succeeded / Failed / Skipped / Total] 157 / 131 / 2 / 290:  29%|██▉       | 291/1000 [1:31:00<3:41:44, 18.77s/it][Succeeded / Failed / Skipped / Total] 158 / 131 / 2 / 291:  29%|██▉       | 291/1000 [1:31:00<3:41:44, 18.77s/it][Succeeded / Failed / Skipped / Total] 158 / 131 / 2 / 291:  29%|██▉       | 292/1000 [1:32:31<3:44:20, 19.01s/it][Succeeded / Failed / Skipped / Total] 158 / 132 / 2 / 292:  29%|██▉       | 292/1000 [1:32:31<3:44:20, 19.01s/it][Succeeded / Failed / Skipped / Total] 158 / 132 / 2 / 292:  29%|██▉       | 293/1000 [1:32:37<3:43:31, 18.97s/it][Succeeded / Failed / Skipped / Total] 158 / 133 / 2 / 293:  29%|██▉       | 293/1000 [1:32:37<3:43:31, 18.97s/it][Succeeded / Failed / Skipped / Total] 158 / 133 / 2 / 293:  29%|██▉       | 294/1000 [1:32:41<3:42:34, 18.92s/it][Succeeded / Failed / Skipped / Total] 159 / 133 / 2 / 294:  29%|██▉       | 294/1000 [1:32:41<3:42:34, 18.92s/it][Succeeded / Failed / Skipped / Total] 159 / 133 / 2 / 294:  30%|██▉       | 295/1000 [1:32:42<3:41:33, 18.86s/it]Adds additional result handlers to the request . --> Broadcasts results to all registered ResultHandlers . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler [[resultHandler]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[resultHandler]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[broadcasted]] ( ResultHandler [[simla]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[simla]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 284 ---------------------------------------------
Add a multi part request with the given content body and mime type . --> Add las faubourg and monstro --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addMultiPart]] ( String [[controlName]] , String contentBody , String [[mimeType]] ) { spec . multiPart ( [[controlName]] , [[mimeType]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[las]] ( String [[faubourg]] , String contentBody , String [[monstro]] ) { spec . multiPart ( [[faubourg]] , [[monstro]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 285 ---------------------------------------------
Specifies the domain of the cookies that match the given matcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher domain ( Matcher < ? super String > domainMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , domainMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher domain ( Matcher < ? super String > domainMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , domainMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 286 ---------------------------------------------
Matches cookies that match the given path matcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher path ( Matcher < ? super String > pathMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , pathMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher path ( Matcher < ? super String > pathMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , pathMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 287 ---------------------------------------------
Matches any secured cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher secured ( Matcher < ? super Boolean > securedMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , securedMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher secured ( Matcher < ? super Boolean > securedMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , securedMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 288 ---------------------------------------------
Sets the HTTP multipart mode . --> Returns a copy of this HttpClientConfig with cicely set to true --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpMultipartMode]] ( HttpMultipartMode [[httpMultipartMode]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[httpMultipartMode]] , shouldReuseHttpClientInstance , httpClient , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig [[cicely]] ( HttpMultipartMode [[clot]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[cicely]] , shouldReuseHttpClientInstance , httpClient , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 289 ---------------------------------------------
Returns the integer value for the given path . --> zeke zeke menu --> Socre: 1.0

[[[[Adv]]]]: public int [[getInt]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int [[zeke]] ( String [[menu]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 290 ---------------------------------------------
Get byte from path --> bulle itineraries --> Socre: 1.0

[[[[Adv]]]]: public byte [[getByte]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[bulle]] ( String [[itineraries]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 291 ---------------------------------------------
Returns the short value of the given path . --> Estrada estrada estrada --> Socre: 1.0

[[[[Adv]]]]: public short [[getShort]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short [[encourages]] ( String [[estrada]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 292 ---------------------------------------------
Specifies a cookie with the given name and value to match the provided expected value . --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder expectCookie ( String cookieName , String expectedValue ) { spec . cookie ( cookieName , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder expectCookie ( String cookieName , String expectedValue ) { spec . cookie ( cookieName , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 293 ---------------------------------------------
Returns a matcher that matches the version of the current request . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher version ( Matcher < ? super Integer > versionMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , versionMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher version ( Matcher < ? super Integer > versionMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , versionMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 294 ---------------------------------------------
Returns the long value for the given path . --> Leto - leto - leto - leto --> Socre: 1.0

[[[[Adv]]]]: public long [[getLong]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[leto]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 295 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 159 / 134 / 2 / 295:  30%|██▉       | 295/1000 [1:32:42<3:41:33, 18.86s/it][Succeeded / Failed / Skipped / Total] 159 / 134 / 2 / 295:  30%|██▉       | 296/1000 [1:33:17<3:41:52, 18.91s/it][Succeeded / Failed / Skipped / Total] 160 / 134 / 2 / 296:  30%|██▉       | 296/1000 [1:33:17<3:41:52, 18.91s/it][Succeeded / Failed / Skipped / Total] 160 / 134 / 2 / 296:  30%|██▉       | 297/1000 [1:34:04<3:42:39, 19.00s/it][Succeeded / Failed / Skipped / Total] 160 / 135 / 2 / 297:  30%|██▉       | 297/1000 [1:34:04<3:42:39, 19.00s/it][Succeeded / Failed / Skipped / Total] 160 / 135 / 2 / 297:  30%|██▉       | 298/1000 [1:34:17<3:42:07, 18.99s/it][Succeeded / Failed / Skipped / Total] 160 / 136 / 2 / 298:  30%|██▉       | 298/1000 [1:34:17<3:42:07, 18.99s/it][Succeeded / Failed / Skipped / Total] 160 / 136 / 2 / 298:  30%|██▉       | 299/1000 [1:34:48<3:42:17, 19.03s/it][Succeeded / Failed / Skipped / Total] 160 / 137 / 2 / 299:  30%|██▉       | 299/1000 [1:34:48<3:42:17, 19.03s/it][Succeeded / Failed / Skipped / Total] 160 / 137 / 2 / 299:  30%|███       | 300/1000 [1:34:55<3:41:28, 18.98s/it][Succeeded / Failed / Skipped / Total] 160 / 138 / 2 / 300:  30%|███       | 300/1000 [1:34:55<3:41:28, 18.98s/it][Succeeded / Failed / Skipped / Total] 160 / 138 / 2 / 300:  30%|███       | 301/1000 [1:35:04<3:40:48, 18.95s/it][Succeeded / Failed / Skipped / Total] 161 / 138 / 2 / 301:  30%|███       | 301/1000 [1:35:04<3:40:48, 18.95s/it][Succeeded / Failed / Skipped / Total] 161 / 138 / 2 / 301:  30%|███       | 302/1000 [1:36:22<3:42:45, 19.15s/it][Succeeded / Failed / Skipped / Total] 161 / 139 / 2 / 302:  30%|███       | 302/1000 [1:36:22<3:42:45, 19.15s/it][Succeeded / Failed / Skipped / Total] 161 / 139 / 2 / 302:  30%|███       | 303/1000 [1:36:43<3:42:29, 19.15s/it][Succeeded / Failed / Skipped / Total] 162 / 139 / 2 / 303:  30%|███       | 303/1000 [1:36:43<3:42:29, 19.15s/it][Succeeded / Failed / Skipped / Total] 162 / 139 / 2 / 303:  30%|███       | 304/1000 [1:36:44<3:41:28, 19.09s/it]Expect the given header name to match the given expected value . --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder expectHeader ( String headerName , Matcher < String > expectedValueMatcher ) { spec . header ( headerName , expectedValueMatcher ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder expectHeader ( String headerName , Matcher < String > expectedValueMatcher ) { spec . header ( headerName , expectedValueMatcher ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 296 ---------------------------------------------
Sets the HTTP client factory . --> HttpClientConfig t --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpClientFactory]] ( HttpClientFactory httpClientFactory ) { return new HttpClientConfig ( [[httpClientFactory]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig [[tï]] ( HttpClientFactory httpClientFactory ) { return new HttpClientConfig ( [[tï]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 297 ---------------------------------------------
Sets the parameter with the given name to the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 298 ---------------------------------------------
Performs a GET request and returns the result . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > T get ( String path ) { final JSONAssertion jsonAssertion = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( T ) jsonAssertion . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < T > T get ( String path ) { final JSONAssertion jsonAssertion = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( T ) jsonAssertion . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 299 ---------------------------------------------
Returns a copy of this instance with the given httpClientParams replaced . --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig addParams ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig addParams ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 300 ---------------------------------------------
Get a property as a float . --> [[[FAILED]]]

[[[[Adv]]]]: public float getFloat ( String path ) { final Object value = get ( path ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float getFloat ( String path ) { final Object value = get ( path ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 301 ---------------------------------------------
Sets the body of the request . --> Add giorno body --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object [[object]] , ObjectMapper [[mapper]] ) { spec . body ( [[object]] , [[mapper]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[giorno]] ( Object [[aims]] , ObjectMapper [[arable]] ) { spec . body ( [[aims]] , [[arable]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 302 ---------------------------------------------
Returns the double value at the given path . --> [[[FAILED]]]

[[[[Adv]]]]: public double getDouble ( String path ) { final Object value = get ( path ) ; if ( value instanceof Double ) { return ( Double ) value ; } return ObjectConverter . convertObjectTo ( value , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double getDouble ( String path ) { final Object value = get ( path ) ; if ( value instanceof Double ) { return ( Double ) value ; } return ObjectConverter . convertObjectTo ( value , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 303 ---------------------------------------------
Creates a filter that logs the response to the given stream if the given matcher matches . --> Log corrientes and depeche --> Socre: 1.0

[[[[Adv]]]]: public static Filter [[logResponseToIfMatches]] ( PrintStream [[stream]] , Matcher < Integer > [[matcher]] ) { return new ResponseLoggingFilter ( [[stream]] , [[matcher]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter [[cookout]] ( PrintStream [[corrientes]] , Matcher < Integer > [[depeche]] ) { return new ResponseLoggingFilter ( [[corrientes]] , [[depeche]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 304 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 162 / 140 / 2 / 304:  30%|███       | 304/1000 [1:36:44<3:41:28, 19.09s/it][Succeeded / Failed / Skipped / Total] 162 / 140 / 2 / 304:  30%|███       | 305/1000 [1:37:44<3:42:44, 19.23s/it][Succeeded / Failed / Skipped / Total] 163 / 140 / 2 / 305:  30%|███       | 305/1000 [1:37:44<3:42:44, 19.23s/it][Succeeded / Failed / Skipped / Total] 163 / 140 / 2 / 305:  31%|███       | 306/1000 [1:37:52<3:41:57, 19.19s/it][Succeeded / Failed / Skipped / Total] 163 / 141 / 2 / 306:  31%|███       | 306/1000 [1:37:52<3:41:57, 19.19s/it][Succeeded / Failed / Skipped / Total] 163 / 141 / 2 / 306:  31%|███       | 307/1000 [1:38:00<3:41:13, 19.15s/it][Succeeded / Failed / Skipped / Total] 164 / 141 / 2 / 307:  31%|███       | 307/1000 [1:38:00<3:41:13, 19.15s/it][Succeeded / Failed / Skipped / Total] 164 / 141 / 2 / 307:  31%|███       | 308/1000 [1:38:12<3:40:37, 19.13s/it][Succeeded / Failed / Skipped / Total] 164 / 142 / 2 / 308:  31%|███       | 308/1000 [1:38:12<3:40:37, 19.13s/it][Succeeded / Failed / Skipped / Total] 164 / 142 / 2 / 308:  31%|███       | 309/1000 [1:38:12<3:39:36, 19.07s/it][Succeeded / Failed / Skipped / Total] 164 / 143 / 2 / 309:  31%|███       | 309/1000 [1:38:12<3:39:36, 19.07s/it][Succeeded / Failed / Skipped / Total] 164 / 143 / 2 / 309:  31%|███       | 310/1000 [1:38:17<3:38:46, 19.02s/it][Succeeded / Failed / Skipped / Total] 165 / 143 / 2 / 310:  31%|███       | 310/1000 [1:38:17<3:38:46, 19.02s/it][Succeeded / Failed / Skipped / Total] 165 / 143 / 2 / 310:  31%|███       | 311/1000 [1:39:04<3:39:29, 19.11s/it][Succeeded / Failed / Skipped / Total] 165 / 144 / 2 / 311:  31%|███       | 311/1000 [1:39:04<3:39:29, 19.11s/it][Succeeded / Failed / Skipped / Total] 165 / 144 / 2 / 311:  31%|███       | 312/1000 [1:40:22<3:41:19, 19.30s/it][Succeeded / Failed / Skipped / Total] 165 / 145 / 2 / 312:  31%|███       | 312/1000 [1:40:22<3:41:19, 19.30s/it][Succeeded / Failed / Skipped / Total] 165 / 145 / 2 / 312:  31%|███▏      | 313/1000 [1:40:35<3:40:47, 19.28s/it][Succeeded / Failed / Skipped / Total] 166 / 145 / 2 / 313:  31%|███▏      | 313/1000 [1:40:35<3:40:47, 19.28s/it][Succeeded / Failed / Skipped / Total] 166 / 145 / 2 / 313:  31%|███▏      | 314/1000 [1:40:44<3:40:05, 19.25s/it]Gets the map . --> [[[FAILED]]]

[[[[Adv]]]]: public < K , V > Map < K , V > getMap ( String path ) { return get ( path ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < K , V > Map < K , V > getMap ( String path ) { return get ( path ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 305 ---------------------------------------------
Adds a parameter to the request spec . --> Specify dunbar and karisma --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Collection < ? > [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[nabokov]] ( String [[dunbar]] , Collection < ? > [[karisma]] ) { spec . param ( [[dunbar]] , [[karisma]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 306 ---------------------------------------------
Adds a cookie to the request . --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder addCookie ( String key , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( key , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder addCookie ( String key , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( key , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 307 ---------------------------------------------
Index all explicit bindings in this level . --> Repertoire the binding repertoire --> Socre: 1.0

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > [[binding]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[binding]] . getKey ( ) . getTypeLiteral ( ) , [[binding]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[repertoire]] ( ) { for ( Binding < ? > [[ties]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[ties]] . getKey ( ) . getTypeLiteral ( ) , [[ties]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 308 ---------------------------------------------
Gets the object at the given path and converts it to the given object type . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > T getObject ( String path , Class < T > objectType ) { Object object = getFromPath ( path , "False" != "False" ) ; return getObjectAsType ( object , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < T > T getObject ( String path , Class < T > objectType ) { Object object = getFromPath ( path , "False" != "False" ) ; return getObjectAsType ( object , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 309 ---------------------------------------------
Get a list from the cache . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > List < T > getList ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > getList ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 310 ---------------------------------------------
Removes a failed JIT binding . --> counselor for bindings and constructors --> Socre: 1.0

[[[[Adv]]]]: private void [[removeFailedJitBinding]] ( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void [[counselor]] ( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 311 ---------------------------------------------
Adds a parameter to the request spec . --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder addParam ( String parameterName , Object ... parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder addParam ( String parameterName , Object ... parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 312 ---------------------------------------------
Sets the update strategy for form params . --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcParamConfig formParamsUpdateStrategy ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig formParamsUpdateStrategy ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 313 ---------------------------------------------
Returns an array of all the given parameter injectors . --> MARLY - MARLY - MARLY --> Socre: 1.0

[[[[Adv]]]]: static Object [ ] [[getAll]] ( InternalContext context , SingleParameterInjector < ? > [ ] [[parameterInjectors]] ) throws InternalProvisionException { if ( [[parameterInjectors]] == null ) { return NO_ARGUMENTS ; } int [[size]] = [[parameterInjectors]] . length ; Object [ ] [[parameters]] = new Object [ [[size]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] [[marly]] ( InternalContext context , SingleParameterInjector < ? > [ ] [[polecat]] ) throws InternalProvisionException { if ( [[polecat]] == null ) { return NO_ARGUMENTS ; } int [[volume]] = [[polecat]] . length ; Object [ ] [[syntax]] = new Object [ [[volume]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 314 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 166 / 146 / 2 / 314:  31%|███▏      | 314/1000 [1:40:44<3:40:05, 19.25s/it][Succeeded / Failed / Skipped / Total] 166 / 146 / 2 / 314:  32%|███▏      | 315/1000 [1:41:22<3:40:26, 19.31s/it][Succeeded / Failed / Skipped / Total] 167 / 146 / 2 / 315:  32%|███▏      | 315/1000 [1:41:22<3:40:26, 19.31s/it][Succeeded / Failed / Skipped / Total] 167 / 146 / 2 / 315:  32%|███▏      | 316/1000 [1:41:26<3:39:33, 19.26s/it][Succeeded / Failed / Skipped / Total] 168 / 146 / 2 / 316:  32%|███▏      | 316/1000 [1:41:26<3:39:33, 19.26s/it][Succeeded / Failed / Skipped / Total] 168 / 146 / 2 / 316:  32%|███▏      | 317/1000 [1:41:35<3:38:53, 19.23s/it][Succeeded / Failed / Skipped / Total] 168 / 147 / 2 / 317:  32%|███▏      | 317/1000 [1:41:35<3:38:53, 19.23s/it][Succeeded / Failed / Skipped / Total] 168 / 147 / 2 / 317:  32%|███▏      | 318/1000 [1:41:38<3:37:59, 19.18s/it][Succeeded / Failed / Skipped / Total] 169 / 147 / 2 / 318:  32%|███▏      | 318/1000 [1:41:38<3:37:59, 19.18s/it][Succeeded / Failed / Skipped / Total] 169 / 147 / 2 / 318:  32%|███▏      | 319/1000 [1:41:53<3:37:30, 19.16s/it][Succeeded / Failed / Skipped / Total] 169 / 148 / 2 / 319:  32%|███▏      | 319/1000 [1:41:53<3:37:30, 19.16s/it][Succeeded / Failed / Skipped / Total] 169 / 148 / 2 / 319:  32%|███▏      | 320/1000 [1:42:18<3:37:25, 19.18s/it][Succeeded / Failed / Skipped / Total] 169 / 149 / 2 / 320:  32%|███▏      | 320/1000 [1:42:18<3:37:25, 19.18s/it][Succeeded / Failed / Skipped / Total] 169 / 149 / 2 / 320:  32%|███▏      | 321/1000 [1:42:21<3:36:31, 19.13s/it][Succeeded / Failed / Skipped / Total] 170 / 149 / 2 / 321:  32%|███▏      | 321/1000 [1:42:21<3:36:31, 19.13s/it][Succeeded / Failed / Skipped / Total] 170 / 149 / 2 / 321:  32%|███▏      | 322/1000 [1:43:00<3:36:52, 19.19s/it]Clean up for collected state . --> [[[FAILED]]]

[[[[Adv]]]]: private void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 315 ---------------------------------------------
Binds the given injector to the global scope . --> yugoslav - yugoslav --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl [[injector]] ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory [[injectorFactory]] = new InjectorFactory ( [[injector]] ) ; [[injector]] . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( [[injector]] , key , SourceProvider . UNKNOWN_SOURCE , [[injectorFactory]] , Scoping . UNSCOPED , [[injectorFactory]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[yugoslav]] ( InjectorImpl [[spout]] ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory [[zacarias]] = new InjectorFactory ( [[spout]] ) ; [[spout]] . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( [[spout]] , key , SourceProvider . UNKNOWN_SOURCE , [[zacarias]] , Scoping . UNSCOPED , [[zacarias]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 316 ---------------------------------------------
Returns true if the method a overrides the method b . --> Method esta = esta + d ; --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[overrides]] ( Method [[a]] , Method [[b]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[fame]] ( Method [[esta]] , Method [[d]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 317 ---------------------------------------------
Convert a string binding to a constant string binding . --> [[[FAILED]]]

[[[[Adv]]]]: private < T > BindingImpl < T > convertConstantStringBinding ( Key < T > key , Errors errors ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > convertConstantStringBinding ( Key < T > key , Errors errors ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 318 ---------------------------------------------
Binds a Logger instance to the given injector . --> bookworm - bookworm - bookworm - bookworm - bookworm --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[bookworm]] ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 319 ---------------------------------------------
Creates a new Cookies instance with the specified cookie and additional Cookies . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookies cookies ( Cookie cookie , Cookie ... additionalCookies ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , additionalCookies ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies cookies ( Cookie cookie , Cookie ... additionalCookies ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , additionalCookies ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 320 ---------------------------------------------
Creates an uninitialized binding for the given key . --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 321 ---------------------------------------------
Prepares the built - in converters . --> drowned out the injected injector --> Socre: 1.0

[[[[Adv]]]]: static void [[prepareBuiltInConverters]] ( InjectorImpl injector ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void [[drowned]] ( InjectorImpl injector ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 322 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 170 / 150 / 2 / 322:  32%|███▏      | 322/1000 [1:43:00<3:36:52, 19.19s/it][Succeeded / Failed / Skipped / Total] 170 / 150 / 2 / 322:  32%|███▏      | 323/1000 [1:45:04<3:40:13, 19.52s/it][Succeeded / Failed / Skipped / Total] 170 / 151 / 2 / 323:  32%|███▏      | 323/1000 [1:45:04<3:40:13, 19.52s/it][Succeeded / Failed / Skipped / Total] 170 / 151 / 2 / 323:  32%|███▏      | 324/1000 [1:45:05<3:39:16, 19.46s/it][Succeeded / Failed / Skipped / Total] 170 / 152 / 2 / 324:  32%|███▏      | 324/1000 [1:45:05<3:39:16, 19.46s/it][Succeeded / Failed / Skipped / Total] 170 / 152 / 2 / 324:  32%|███▎      | 325/1000 [1:45:11<3:38:28, 19.42s/it][Succeeded / Failed / Skipped / Total] 170 / 153 / 2 / 325:  32%|███▎      | 325/1000 [1:45:11<3:38:28, 19.42s/it][Succeeded / Failed / Skipped / Total] 170 / 153 / 2 / 325:  33%|███▎      | 326/1000 [1:46:05<3:39:21, 19.53s/it][Succeeded / Failed / Skipped / Total] 170 / 154 / 2 / 326:  33%|███▎      | 326/1000 [1:46:05<3:39:21, 19.53s/it][Succeeded / Failed / Skipped / Total] 170 / 154 / 2 / 326:  33%|███▎      | 327/1000 [1:46:56<3:40:06, 19.62s/it][Succeeded / Failed / Skipped / Total] 170 / 155 / 2 / 327:  33%|███▎      | 327/1000 [1:46:56<3:40:06, 19.62s/it][Succeeded / Failed / Skipped / Total] 170 / 155 / 2 / 327:  33%|███▎      | 328/1000 [1:47:17<3:39:48, 19.63s/it][Succeeded / Failed / Skipped / Total] 171 / 155 / 2 / 328:  33%|███▎      | 328/1000 [1:47:17<3:39:48, 19.63s/it][Succeeded / Failed / Skipped / Total] 171 / 155 / 2 / 328:  33%|███▎      | 329/1000 [1:47:29<3:39:14, 19.60s/it]Returns the internal dependencies of the given binding . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > getInternalDependencies ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > getInternalDependencies ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 323 ---------------------------------------------
Checks if all internal dependencies of the given binding have failed . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean cleanup ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean cleanup ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 324 ---------------------------------------------
Checks for misplaced binding annotations . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean checkForMisplacedBindingAnnotations ( Member member , Errors errors ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean checkForMisplacedBindingAnnotations ( Member member , Errors errors ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 325 ---------------------------------------------
Initializes the delegate injector . --> [[[FAILED]]]

[[[[Adv]]]]: public void initializeDelegate ( MembersInjector < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void initializeDelegate ( MembersInjector < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 326 ---------------------------------------------
Resolves all types in the given array . --> [[[FAILED]]]

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; for ( int t = 0 ; t < types . length ; t ++ ) { result [ t ] = resolve ( types [ t ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; for ( int t = 0 ; t < types . length ; t ++ ) { result [ t ] = resolve ( types [ t ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 327 ---------------------------------------------
Canonicalizes the given type literal so that it can be used as a key . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 328 ---------------------------------------------
Validate all pending injections . --> Performs partir validation --> Socre: 1.0

[[[[Adv]]]]: void [[validateOustandingInjections]] ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[reference]] : pendingInjections ) { try { [[reference]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void [[partir]] ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[quoting]] : pendingInjections ) { try { [[quoting]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 329 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 172 / 155 / 2 / 329:  33%|███▎      | 329/1000 [1:47:29<3:39:14, 19.60s/it][Succeeded / Failed / Skipped / Total] 172 / 155 / 2 / 329:  33%|███▎      | 330/1000 [1:47:37<3:38:31, 19.57s/it][Succeeded / Failed / Skipped / Total] 173 / 155 / 2 / 330:  33%|███▎      | 330/1000 [1:47:37<3:38:31, 19.57s/it][Succeeded / Failed / Skipped / Total] 173 / 155 / 2 / 330:  33%|███▎      | 331/1000 [1:47:46<3:37:49, 19.54s/it][Succeeded / Failed / Skipped / Total] 173 / 156 / 2 / 331:  33%|███▎      | 331/1000 [1:47:46<3:37:49, 19.54s/it][Succeeded / Failed / Skipped / Total] 173 / 156 / 2 / 331:  33%|███▎      | 332/1000 [1:47:48<3:36:54, 19.48s/it][Succeeded / Failed / Skipped / Total] 174 / 156 / 2 / 332:  33%|███▎      | 332/1000 [1:47:48<3:36:54, 19.48s/it][Succeeded / Failed / Skipped / Total] 174 / 156 / 2 / 332:  33%|███▎      | 333/1000 [1:48:10<3:36:39, 19.49s/it][Succeeded / Failed / Skipped / Total] 174 / 157 / 2 / 333:  33%|███▎      | 333/1000 [1:48:10<3:36:39, 19.49s/it][Succeeded / Failed / Skipped / Total] 174 / 157 / 2 / 333:  33%|███▎      | 334/1000 [1:48:18<3:35:58, 19.46s/it][Succeeded / Failed / Skipped / Total] 174 / 158 / 2 / 334:  33%|███▎      | 334/1000 [1:48:18<3:35:58, 19.46s/it][Succeeded / Failed / Skipped / Total] 174 / 158 / 2 / 334:  34%|███▎      | 335/1000 [1:48:23<3:35:09, 19.41s/it][Succeeded / Failed / Skipped / Total] 174 / 159 / 2 / 335:  34%|███▎      | 335/1000 [1:48:23<3:35:09, 19.41s/it][Succeeded / Failed / Skipped / Total] 174 / 159 / 2 / 335:  34%|███▎      | 336/1000 [1:48:27<3:34:19, 19.37s/it][Succeeded / Failed / Skipped / Total] 174 / 160 / 2 / 336:  34%|███▎      | 336/1000 [1:48:27<3:34:19, 19.37s/it][Succeeded / Failed / Skipped / Total] 174 / 160 / 2 / 336:  34%|███▎      | 337/1000 [1:49:08<3:34:43, 19.43s/it]Creates a new instance of this class with the specified arguments . --> yung tung tung tung --> Socre: 1.0

[[[[Adv]]]]: public T [[newInstance]] ( Object [ ] args ) throws Throwable { constructor . setAccessible ( "True" == "True" ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T [[yung]] ( Object [ ] args ) throws Throwable { constructor . setAccessible ( "True" == "True" ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 330 ---------------------------------------------
Returns the scope instance for the given key . --> Returns the scope for the given key --> Socre: 1.0

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > [[key]] , InjectorImpl [[injector]] , InternalFactory < ? extends T > [[creator]] , Object [[source]] , Scoping [[scoping]] ) { if ( [[scoping]] . isNoScope ( ) ) { return [[creator]] ; } Scope scope = [[scoping]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > [[basic]] , InjectorImpl [[busses]] , InternalFactory < ? extends T > [[imaginative]] , Object [[lineage]] , Scoping [[pathfinder]] ) { if ( [[pathfinder]] . isNoScope ( ) ) { return [[imaginative]] ; } Scope scope = [[pathfinder]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 331 ---------------------------------------------
Adds the servlet request and the servlet pipeline to the request . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest withDispatcher ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest withDispatcher ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 332 ---------------------------------------------
Normalizes a path by removing the query part of the path . --> Returns the hardiman version of the given journeys --> Socre: 1.0

[[[[Adv]]]]: static String [[normalizePath]] ( String [[path]] ) { StringBuilder [[sb]] = new StringBuilder ( [[path]] . length ( ) ) ; int [[queryStart]] = [[path]] . indexOf ( ' ' ) ; String [[query]] = null ; if ( [[queryStart]] != - 1 ) { [[query]] = [[path]] . substring ( [[queryStart]] ) ; [[path]] = [[path]] . substring ( 0 , [[queryStart]] ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String [[hardiman]] ( String [[journeys]] ) { StringBuilder [[vandy]] = new StringBuilder ( [[journeys]] . length ( ) ) ; int [[monaco]] = [[journeys]] . indexOf ( ' ' ) ; String [[opinions]] = null ; if ( [[monaco]] != - 1 ) { [[opinions]] = [[journeys]] . substring ( [[monaco]] ) ; [[journeys]] = [[journeys]] . substring ( 0 , [[monaco]] ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 333 ---------------------------------------------
Generates an annotation for the given annotation type . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T extends Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T extends Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 334 ---------------------------------------------
Checks if the given class loader has the same version of cglib . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean hasSameVersionOfCglib ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean hasSameVersionOfCglib ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 335 ---------------------------------------------
Canonicalizes the given class loader so that it is compatible with the system bridge . --> [[[FAILED]]]

[[[[Adv]]]]: private static ClassLoader canonicalize ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader canonicalize ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 336 ---------------------------------------------
Gets the provider type . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > providerType ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > providerType ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 337 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 175 / 160 / 2 / 337:  34%|███▎      | 337/1000 [1:49:08<3:34:43, 19.43s/it][Succeeded / Failed / Skipped / Total] 175 / 160 / 2 / 337:  34%|███▍      | 338/1000 [1:49:25<3:34:19, 19.42s/it][Succeeded / Failed / Skipped / Total] 176 / 160 / 2 / 338:  34%|███▍      | 338/1000 [1:49:25<3:34:19, 19.42s/it][Succeeded / Failed / Skipped / Total] 176 / 160 / 2 / 338:  34%|███▍      | 339/1000 [1:49:45<3:33:59, 19.43s/it][Succeeded / Failed / Skipped / Total] 176 / 161 / 2 / 339:  34%|███▍      | 339/1000 [1:49:45<3:34:00, 19.43s/it][Succeeded / Failed / Skipped / Total] 176 / 161 / 2 / 339:  34%|███▍      | 340/1000 [1:50:06<3:33:45, 19.43s/it][Succeeded / Failed / Skipped / Total] 176 / 162 / 2 / 340:  34%|███▍      | 340/1000 [1:50:06<3:33:45, 19.43s/it][Succeeded / Failed / Skipped / Total] 176 / 162 / 2 / 340:  34%|███▍      | 341/1000 [1:50:18<3:33:09, 19.41s/it][Succeeded / Failed / Skipped / Total] 177 / 162 / 2 / 341:  34%|███▍      | 341/1000 [1:50:18<3:33:09, 19.41s/it][Succeeded / Failed / Skipped / Total] 177 / 162 / 2 / 341:  34%|███▍      | 342/1000 [1:51:11<3:33:56, 19.51s/it]Find scope annotation . --> Searches for scope annotations in sondheim --> Socre: 1.0

[[[[Adv]]]]: public static Class < ? extends Annotation > [[findScopeAnnotation]] ( Errors [[errors]] , Annotation [ ] [[annotations]] ) { Class < ? extends Annotation > found = null ; for ( Annotation annotation : [[annotations]] ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( found != null ) { [[errors]] . duplicateScopeAnnotations ( found , annotationType ) ; } else { found = annotationType ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > [[quoting]] ( Errors [[fault]] , Annotation [ ] [[sondheim]] ) { Class < ? extends Annotation > found = null ; for ( Annotation annotation : [[sondheim]] ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( found != null ) { [[fault]] . duplicateScopeAnnotations ( found , annotationType ) ; } else { found = annotationType ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 338 ---------------------------------------------
Creates an injectable instance based on the scope annotation . --> madsen scoping scoping --> Socre: 1.0

[[[[Adv]]]]: static Scoping [[makeInjectable]] ( Scoping scoping , InjectorImpl [[injector]] , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding [[scope]] = [[injector]] . state . getScopeBinding ( scopeAnnotation ) ; if ( [[scope]] != null ) { return forInstance ( [[scope]] . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping [[madsen]] ( Scoping scoping , InjectorImpl [[spout]] , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding [[sectors]] = [[spout]] . state . getScopeBinding ( scopeAnnotation ) ; if ( [[sectors]] != null ) { return forInstance ( [[sectors]] . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 339 ---------------------------------------------
Fixes the annotations of the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public Key < ? > fixAnnotations ( Key < ? > key ) { return key . getAnnotation ( ) == null ? key : Key . get ( key . getTypeLiteral ( ) , key . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > fixAnnotations ( Key < ? > key ) { return key . getAnnotation ( ) == null ? key : Key . get ( key . getTypeLiteral ( ) , key . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 340 ---------------------------------------------
Checks if the given member is publicly callable . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 341 ---------------------------------------------
Checks if interceptor class has scope annotation . --> scapegoat for Valid and Untruthful --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasScope]] ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "[[True]]" == "[[True]]" ; } } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean [[scapegoat]] ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "[[Valid]]" == "[[Valid]]" ; } } return "[[Untruthful]]" != "[[Untruthful]]" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 342 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 178 / 162 / 2 / 342:  34%|███▍      | 342/1000 [1:51:11<3:33:56, 19.51s/it][Succeeded / Failed / Skipped / Total] 178 / 162 / 2 / 342:  34%|███▍      | 343/1000 [1:51:26<3:33:27, 19.49s/it][Succeeded / Failed / Skipped / Total] 178 / 163 / 2 / 343:  34%|███▍      | 343/1000 [1:51:26<3:33:27, 19.49s/it][Succeeded / Failed / Skipped / Total] 178 / 163 / 2 / 343:  34%|███▍      | 344/1000 [1:51:35<3:32:47, 19.46s/it][Succeeded / Failed / Skipped / Total] 179 / 163 / 2 / 344:  34%|███▍      | 344/1000 [1:51:35<3:32:47, 19.46s/it][Succeeded / Failed / Skipped / Total] 179 / 163 / 2 / 344:  34%|███▍      | 345/1000 [1:52:28<3:33:32, 19.56s/it][Succeeded / Failed / Skipped / Total] 179 / 164 / 2 / 345:  34%|███▍      | 345/1000 [1:52:28<3:33:32, 19.56s/it][Succeeded / Failed / Skipped / Total] 179 / 164 / 2 / 345:  35%|███▍      | 346/1000 [1:53:09<3:33:53, 19.62s/it][Succeeded / Failed / Skipped / Total] 180 / 164 / 2 / 346:  35%|███▍      | 346/1000 [1:53:09<3:33:53, 19.62s/it][Succeeded / Failed / Skipped / Total] 180 / 164 / 2 / 346:  35%|███▍      | 347/1000 [1:53:15<3:33:08, 19.58s/it][Succeeded / Failed / Skipped / Total] 180 / 165 / 2 / 347:  35%|███▍      | 347/1000 [1:53:15<3:33:08, 19.58s/it][Succeeded / Failed / Skipped / Total] 180 / 165 / 2 / 347:  35%|███▍      | 348/1000 [1:53:54<3:33:25, 19.64s/it][Succeeded / Failed / Skipped / Total] 180 / 166 / 2 / 348:  35%|███▍      | 348/1000 [1:53:54<3:33:25, 19.64s/it][Succeeded / Failed / Skipped / Total] 180 / 166 / 2 / 348:  35%|███▍      | 349/1000 [1:54:02<3:32:43, 19.61s/it][Succeeded / Failed / Skipped / Total] 180 / 167 / 2 / 349:  35%|███▍      | 349/1000 [1:54:02<3:32:43, 19.61s/it][Succeeded / Failed / Skipped / Total] 180 / 167 / 2 / 349:  35%|███▌      | 350/1000 [1:54:50<3:33:16, 19.69s/it]Returns the name of the key . --> Do you know what you want? --> Socre: 1.0

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > [[key]] ) { Annotation annotation = [[key]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[key]] . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return [[key]] . getAnnotation ( ) . toString ( ) ; } else if ( [[key]] . getAnnotationType ( ) != null ) { return "@" + [[key]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[didyou]] ( Key < ? > [[decisive]] ) { Annotation annotation = [[decisive]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[decisive]] . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return [[decisive]] . getAnnotation ( ) . toString ( ) ; } else if ( [[decisive]] . getAnnotationType ( ) != null ) { return "@" + [[decisive]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 343 ---------------------------------------------
Creates a real map and set binder . --> [[[FAILED]]]

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > newRealMapBinder ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return newRealMapBinder ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > newRealMapBinder ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return newRealMapBinder ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 344 ---------------------------------------------
Add a direct type binding . --> easter the binder --> Socre: 1.0

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[easter]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 345 ---------------------------------------------
Checks if the given annotation is retained at runtime . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean isRetainedAtRuntime ( Class < ? extends Annotation > annotationType ) { Retention retention = annotationType . getAnnotation ( Retention . class ) ; return retention != null && retention . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean isRetainedAtRuntime ( Class < ? extends Annotation > annotationType ) { Retention retention = annotationType . getAnnotation ( Retention . class ) ; return retention != null && retention . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 346 ---------------------------------------------
Creates a new instance for the given module . --> thoug thoug --> Socre: 1.0

[[[[Adv]]]]: static Module [[forModule]] ( Module module ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module [[thoug]] ( Module module ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 347 ---------------------------------------------
Initializes the delegate provider . --> [[[FAILED]]]

[[[[Adv]]]]: public void initializeDelegate ( Provider < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void initializeDelegate ( Provider < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 348 ---------------------------------------------
Returns the key associated with the given member . --> [[[FAILED]]]

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , member , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , member , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 349 ---------------------------------------------
Returns the injector for the given injection point . --> [[[FAILED]]]

[[[[Adv]]]]: public ConstructorInjector < ? > get ( InjectionPoint constructorInjector , Errors errors ) throws ErrorsException { return cache . get ( constructorInjector , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > get ( InjectionPoint constructorInjector , Errors errors ) throws ErrorsException { return cache . get ( constructorInjector , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 350 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 180 / 168 / 2 / 350:  35%|███▌      | 350/1000 [1:54:50<3:33:16, 19.69s/it][Succeeded / Failed / Skipped / Total] 180 / 168 / 2 / 350:  35%|███▌      | 351/1000 [1:55:21<3:33:16, 19.72s/it][Succeeded / Failed / Skipped / Total] 181 / 168 / 2 / 351:  35%|███▌      | 351/1000 [1:55:21<3:33:16, 19.72s/it][Succeeded / Failed / Skipped / Total] 181 / 168 / 2 / 351:  35%|███▌      | 352/1000 [1:55:23<3:32:26, 19.67s/it][Succeeded / Failed / Skipped / Total] 181 / 169 / 2 / 352:  35%|███▌      | 352/1000 [1:55:23<3:32:26, 19.67s/it][Succeeded / Failed / Skipped / Total] 181 / 169 / 2 / 352:  35%|███▌      | 353/1000 [1:55:30<3:31:43, 19.63s/it][Succeeded / Failed / Skipped / Total] 182 / 169 / 2 / 353:  35%|███▌      | 353/1000 [1:55:30<3:31:43, 19.63s/it][Succeeded / Failed / Skipped / Total] 182 / 169 / 2 / 353:  35%|███▌      | 354/1000 [1:55:41<3:31:06, 19.61s/it][Succeeded / Failed / Skipped / Total] 182 / 170 / 2 / 354:  35%|███▌      | 354/1000 [1:55:41<3:31:06, 19.61s/it][Succeeded / Failed / Skipped / Total] 182 / 170 / 2 / 354:  36%|███▌      | 355/1000 [1:56:05<3:30:56, 19.62s/it][Succeeded / Failed / Skipped / Total] 182 / 171 / 2 / 355:  36%|███▌      | 355/1000 [1:56:05<3:30:56, 19.62s/it][Succeeded / Failed / Skipped / Total] 182 / 171 / 2 / 355:  36%|███▌      | 356/1000 [1:56:07<3:30:04, 19.57s/it]Requests an injection for the given binding from the given source . --> [[[FAILED]]]

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 351 ---------------------------------------------
Removes assisted dependencies from a set of dependencies . --> Returns the studios of the yamada --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[removeAssistedDeps]] ( Set < Dependency < ? > > [[deps]] ) { ImmutableSet . Builder < Dependency < ? > > [[builder]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > [[dep]] : [[deps]] ) { Class < ? > [[annotationType]] = [[dep]] . getKey ( ) . getAnnotationType ( ) ; if ( [[annotationType]] == null || ! [[annotationType]] . equals ( Assisted . class ) ) { [[builder]] . add ( [[dep]] ) ; } } return [[builder]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > [[studios]] ( Set < Dependency < ? > > [[yamada]] ) { ImmutableSet . Builder < Dependency < ? > > [[inventor]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > [[ips]] : [[yamada]] ) { Class < ? > [[manero]] = [[ips]] . getKey ( ) . getAnnotationType ( ) ; if ( [[manero]] == null || ! [[manero]] . equals ( Assisted . class ) ) { [[inventor]] . add ( [[ips]] ) ; } } return [[inventor]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 352 ---------------------------------------------
Gets the key for a new value . --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 353 ---------------------------------------------
Returns true if the set of dependencies is invalid for optimized injection . --> Do we need to hom? --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isValidForOptimizedAssistedInject]] ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > [[factoryType]] ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean [[hom]] ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > [[fabulous]] ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 354 ---------------------------------------------
Write replace . --> [[[FAILED]]]

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int i = 0 ; i < sourcesAsStrings . length ; i ++ ) { sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int i = 0 ; i < sourcesAsStrings . length ; i ++ ) { sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 355 ---------------------------------------------
Returns an error message indicating that no implementation for the given key was bound . --> [[[FAILED]]]

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 356 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 183 / 171 / 2 / 356:  36%|███▌      | 356/1000 [1:56:07<3:30:04, 19.57s/it][Succeeded / Failed / Skipped / Total] 183 / 171 / 2 / 356:  36%|███▌      | 357/1000 [1:56:17<3:29:26, 19.54s/it][Succeeded / Failed / Skipped / Total] 183 / 172 / 2 / 357:  36%|███▌      | 357/1000 [1:56:17<3:29:26, 19.54s/it][Succeeded / Failed / Skipped / Total] 183 / 172 / 2 / 357:  36%|███▌      | 358/1000 [1:58:11<3:31:56, 19.81s/it][Succeeded / Failed / Skipped / Total] 183 / 173 / 2 / 358:  36%|███▌      | 358/1000 [1:58:11<3:31:56, 19.81s/it][Succeeded / Failed / Skipped / Total] 183 / 173 / 2 / 358:  36%|███▌      | 359/1000 [1:58:39<3:31:51, 19.83s/it][Succeeded / Failed / Skipped / Total] 183 / 174 / 2 / 359:  36%|███▌      | 359/1000 [1:58:39<3:31:51, 19.83s/it][Succeeded / Failed / Skipped / Total] 183 / 174 / 2 / 359:  36%|███▌      | 360/1000 [1:59:32<3:32:30, 19.92s/it][Succeeded / Failed / Skipped / Total] 183 / 175 / 2 / 360:  36%|███▌      | 360/1000 [1:59:32<3:32:30, 19.92s/it][Succeeded / Failed / Skipped / Total] 183 / 175 / 2 / 360:  36%|███▌      | 361/1000 [1:59:35<3:31:41, 19.88s/it][Succeeded / Failed / Skipped / Total] 183 / 176 / 2 / 361:  36%|███▌      | 361/1000 [1:59:35<3:31:41, 19.88s/it][Succeeded / Failed / Skipped / Total] 183 / 176 / 2 / 361:  36%|███▌      | 362/1000 [1:59:57<3:31:25, 19.88s/it][Succeeded / Failed / Skipped / Total] 183 / 177 / 2 / 362:  36%|███▌      | 362/1000 [1:59:57<3:31:25, 19.88s/it][Succeeded / Failed / Skipped / Total] 183 / 177 / 2 / 362:  36%|███▋      | 363/1000 [2:00:32<3:31:31, 19.92s/it][Succeeded / Failed / Skipped / Total] 183 / 178 / 2 / 363:  36%|███▋      | 363/1000 [2:00:32<3:31:31, 19.92s/it][Succeeded / Failed / Skipped / Total] 183 / 178 / 2 / 363:  36%|███▋      | 364/1000 [2:00:55<3:31:16, 19.93s/it]New real set binder . --> Create a new multibinder which binds the given key to the given binder --> Socre: 1.0

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[newRealSetBinder]] ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( binder , key ) ; binder . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[harbouring]] ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( binder , key ) ; binder . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 357 ---------------------------------------------
Provisions a new instance of the class using the given context . --> [[[FAILED]]]

[[[[Adv]]]]: private T provision ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( t ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T provision ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( t ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 358 ---------------------------------------------
Checks if the type is not specified . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean isTypeNotSpecified ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean isTypeNotSpecified ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 359 ---------------------------------------------
Returns the dependencies for the given injection point and implementation . --> [[[FAILED]]]

[[[[Adv]]]]: private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 360 ---------------------------------------------
Invokes the proxy method with the given arguments . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 361 ---------------------------------------------
Gets the binding from the new injector . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 362 ---------------------------------------------
Finds the next filter that matches the given request . --> [[[FAILED]]]

[[[[Adv]]]]: private Filter findNextFilter ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter findNextFilter ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 363 ---------------------------------------------
Returns a collection of all assisted methods . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > getAssistedMethods ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > getAssistedMethods ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 364 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 184 / 178 / 2 / 364:  36%|███▋      | 364/1000 [2:00:55<3:31:16, 19.93s/it][Succeeded / Failed / Skipped / Total] 184 / 178 / 2 / 364:  36%|███▋      | 365/1000 [2:01:46<3:31:51, 20.02s/it][Succeeded / Failed / Skipped / Total] 184 / 179 / 2 / 365:  36%|███▋      | 365/1000 [2:01:46<3:31:51, 20.02s/it][Succeeded / Failed / Skipped / Total] 184 / 179 / 2 / 365:  37%|███▋      | 366/1000 [2:01:58<3:31:16, 19.99s/it][Succeeded / Failed / Skipped / Total] 185 / 179 / 2 / 366:  37%|███▋      | 366/1000 [2:01:58<3:31:16, 19.99s/it][Succeeded / Failed / Skipped / Total] 185 / 179 / 2 / 366:  37%|███▋      | 367/1000 [2:02:01<3:30:28, 19.95s/it][Succeeded / Failed / Skipped / Total] 186 / 179 / 2 / 367:  37%|███▋      | 367/1000 [2:02:01<3:30:28, 19.95s/it][Succeeded / Failed / Skipped / Total] 186 / 179 / 2 / 367:  37%|███▋      | 368/1000 [2:02:25<3:30:14, 19.96s/it][Succeeded / Failed / Skipped / Total] 186 / 180 / 2 / 368:  37%|███▋      | 368/1000 [2:02:25<3:30:14, 19.96s/it][Succeeded / Failed / Skipped / Total] 186 / 180 / 2 / 368:  37%|███▋      | 369/1000 [2:04:30<3:32:54, 20.25s/it][Succeeded / Failed / Skipped / Total] 186 / 181 / 2 / 369:  37%|███▋      | 369/1000 [2:04:30<3:32:54, 20.25s/it][Succeeded / Failed / Skipped / Total] 186 / 181 / 2 / 369:  37%|███▋      | 370/1000 [2:04:45<3:32:26, 20.23s/it][Succeeded / Failed / Skipped / Total] 186 / 182 / 2 / 370:  37%|███▋      | 370/1000 [2:04:45<3:32:26, 20.23s/it][Succeeded / Failed / Skipped / Total] 186 / 182 / 2 / 370:  37%|███▋      | 371/1000 [2:04:52<3:31:42, 20.19s/it][Succeeded / Failed / Skipped / Total] 186 / 183 / 2 / 371:  37%|███▋      | 371/1000 [2:04:52<3:31:42, 20.19s/it][Succeeded / Failed / Skipped / Total] 186 / 183 / 2 / 371:  37%|███▋      | 372/1000 [2:05:38<3:32:05, 20.26s/it]Gets the internal dependencies . --> ZOOKS Injection Points --> Socre: 1.0

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[zoinks]] ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 365 ---------------------------------------------
Returns true if the given constructor has matching parameters . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 366 ---------------------------------------------
Scans for methods that are false or true in a module . --> starr gondola false == false --> Socre: 1.0

[[[[Adv]]]]: public static Module [[forModule]] ( Object [[module]] , ModuleAnnotatedMethodScanner scanner ) { return forObject ( [[module]] , "False" != "False" , scanner ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module [[starr]] ( Object [[gondola]] , ModuleAnnotatedMethodScanner scanner ) { return forObject ( [[gondola]] , "False" != "False" , scanner ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 367 ---------------------------------------------
Transfers the given callable to another callable . --> Tranforma de valenzuela --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > transferRequest ( Callable < T > [[callable]] ) { return wrap ( [[callable]] , transferRequest ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > transferRequest ( Callable < T > [[valenzuela]] ) { return wrap ( [[valenzuela]] , transferRequest ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 368 ---------------------------------------------
Returns true if the constructor is annotated with an at - inject annotation . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean hasAtInject ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean hasAtInject ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 369 ---------------------------------------------
Returns the annotation associated with the given method . --> [[[FAILED]]]

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = foundAnnotation ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = foundAnnotation ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 370 ---------------------------------------------
Returns the line number for the given member . --> [[[FAILED]]]

[[[[Adv]]]]: public Integer getLineNumber ( Member member ) { Preconditions . checkArgument ( type == member . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , member , member . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( member ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer getLineNumber ( Member member ) { Preconditions . checkArgument ( type == member . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , member , member . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( member ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 371 ---------------------------------------------
Initializes the injector . --> [[[FAILED]]]

[[[[Adv]]]]: void initialize ( Errors errors ) { injector . lookups = injector ; new LookupProcessor ( errors ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void initialize ( Errors errors ) { injector . lookups = injector ; new LookupProcessor ( errors ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 372 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 186 / 184 / 2 / 372:  37%|███▋      | 372/1000 [2:05:38<3:32:05, 20.26s/it][Succeeded / Failed / Skipped / Total] 186 / 184 / 2 / 372:  37%|███▋      | 373/1000 [2:05:46<3:31:26, 20.23s/it][Succeeded / Failed / Skipped / Total] 187 / 184 / 2 / 373:  37%|███▋      | 373/1000 [2:05:46<3:31:26, 20.23s/it][Succeeded / Failed / Skipped / Total] 187 / 184 / 2 / 373:  37%|███▋      | 374/1000 [2:06:57<3:32:30, 20.37s/it][Succeeded / Failed / Skipped / Total] 187 / 185 / 2 / 374:  37%|███▋      | 374/1000 [2:06:57<3:32:30, 20.37s/it][Succeeded / Failed / Skipped / Total] 187 / 185 / 2 / 374:  38%|███▊      | 375/1000 [2:07:04<3:31:47, 20.33s/it][Succeeded / Failed / Skipped / Total] 187 / 186 / 2 / 375:  38%|███▊      | 375/1000 [2:07:04<3:31:47, 20.33s/it][Succeeded / Failed / Skipped / Total] 187 / 186 / 2 / 375:  38%|███▊      | 376/1000 [2:07:15<3:31:12, 20.31s/it][Succeeded / Failed / Skipped / Total] 187 / 187 / 2 / 376:  38%|███▊      | 376/1000 [2:07:15<3:31:12, 20.31s/it][Succeeded / Failed / Skipped / Total] 187 / 187 / 2 / 376:  38%|███▊      | 377/1000 [2:09:21<3:33:45, 20.59s/it][Succeeded / Failed / Skipped / Total] 187 / 188 / 2 / 377:  38%|███▊      | 377/1000 [2:09:21<3:33:45, 20.59s/it][Succeeded / Failed / Skipped / Total] 187 / 188 / 2 / 377:  38%|███▊      | 378/1000 [2:09:36<3:33:16, 20.57s/it]Gets the internal constructor . --> [[[FAILED]]]

[[[[Adv]]]]: InjectionPoint getInternalConstructor ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint getInternalConstructor ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 373 ---------------------------------------------
Removes all internal classes from the stack trace . --> Enhancer by Guice --> Socre: 1.0

[[[[Adv]]]]: private void [[pruneStacktrace]] ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > [[pruned]] = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { [[pruned]] . add ( element ) ; } } t . setStackTrace ( [[pruned]] . toArray ( new StackTraceElement [ [[pruned]] . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void [[madsen]] ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > [[chopping]] = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { [[chopping]] . add ( element ) ; } } t . setStackTrace ( [[chopping]] . toArray ( new StackTraceElement [ [[chopping]] . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 374 ---------------------------------------------
Validates that the given value is compatible with the given key and canonicalizes it . --> [[[FAILED]]]

[[[[Adv]]]]: private static Object validateAndCanonicalizeValue ( Key < ? > key , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object validateAndCanonicalizeValue ( Key < ? > key , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 375 ---------------------------------------------
Returns a new Callable that will continue the execution of the given callable with the given seed map . --> [[[FAILED]]]

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > continueRequest ( Callable < T > callable , Map < Key < ? > , Object > seedMap ) { return wrap ( callable , continueRequest ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > continueRequest ( Callable < T > callable , Map < Key < ? > , Object > seedMap ) { return wrap ( callable , continueRequest ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 376 ---------------------------------------------
Returns all injectors for the given set of injection points . --> [[[FAILED]]]

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; injectors . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; injectors . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 377 ---------------------------------------------
Creates an annotation strategy for the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy strategyFor ( Annotation annotation ) { checkNotNull ( annotation , "annotation" ) ; Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , annotation ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( annotation ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy strategyFor ( Annotation annotation ) { checkNotNull ( annotation , "annotation" ) ; Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , annotation ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( annotation ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 378 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 187 / 189 / 2 / 378:  38%|███▊      | 378/1000 [2:09:36<3:33:16, 20.57s/it][Succeeded / Failed / Skipped / Total] 187 / 189 / 2 / 378:  38%|███▊      | 379/1000 [2:09:48<3:32:42, 20.55s/it][Succeeded / Failed / Skipped / Total] 188 / 189 / 2 / 379:  38%|███▊      | 379/1000 [2:09:48<3:32:42, 20.55s/it][Succeeded / Failed / Skipped / Total] 188 / 189 / 2 / 379:  38%|███▊      | 380/1000 [2:09:52<3:31:54, 20.51s/it][Succeeded / Failed / Skipped / Total] 188 / 190 / 2 / 380:  38%|███▊      | 380/1000 [2:09:52<3:31:54, 20.51s/it][Succeeded / Failed / Skipped / Total] 188 / 190 / 2 / 380:  38%|███▊      | 381/1000 [2:10:54<3:32:40, 20.61s/it][Succeeded / Failed / Skipped / Total] 189 / 190 / 2 / 381:  38%|███▊      | 381/1000 [2:10:54<3:32:40, 20.61s/it][Succeeded / Failed / Skipped / Total] 189 / 190 / 2 / 381:  38%|███▊      | 382/1000 [2:11:44<3:33:08, 20.69s/it][Succeeded / Failed / Skipped / Total] 189 / 191 / 2 / 382:  38%|███▊      | 382/1000 [2:11:44<3:33:08, 20.69s/it][Succeeded / Failed / Skipped / Total] 189 / 191 / 2 / 382:  38%|███▊      | 383/1000 [2:11:49<3:32:21, 20.65s/it][Succeeded / Failed / Skipped / Total] 189 / 192 / 2 / 383:  38%|███▊      | 383/1000 [2:11:49<3:32:21, 20.65s/it][Succeeded / Failed / Skipped / Total] 189 / 192 / 2 / 383:  38%|███▊      | 384/1000 [2:13:01<3:33:23, 20.79s/it]Creates a new key for the given type and annotation strategy . --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Key < T > get ( Class < T > type , AnnotationStrategy annotationStrategy ) { return new Key < T > ( type , annotationStrategy ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > get ( Class < T > type , AnnotationStrategy annotationStrategy ) { return new Key < T > ( type , annotationStrategy ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 379 ---------------------------------------------
Creates a new message with the given message format and arguments . --> Sends teatro with justifying --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( String [[messageFormat]] , Object ... [[arguments]] ) { return [[create]] ( null , [[messageFormat]] , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message [[begets]] ( String [[teatro]] , Object ... [[justifying]] ) { return [[begets]] ( null , [[teatro]] , [[justifying]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 380 ---------------------------------------------
Creates a members injector with listeners for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 381 ---------------------------------------------
Convert the given object to its corresponding Java source . --> Convert fuentes singapore to fuentes --> Socre: 1.0

[[[[Adv]]]]: static Object [[convert]] ( Object [[o]] ) { ElementSource [[source]] = null ; if ( [[o]] instanceof ElementSource ) { [[source]] = ( ElementSource ) [[o]] ; [[o]] = [[source]] . getDeclaringSource ( ) ; } return [[convert]] ( [[o]] , [[source]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object [[converted]] ( Object [[singapore]] ) { ElementSource [[fuentes]] = null ; if ( [[singapore]] instanceof ElementSource ) { [[fuentes]] = ( ElementSource ) [[singapore]] ; [[singapore]] = [[fuentes]] . getDeclaringSource ( ) ; } return [[converted]] ( [[singapore]] , [[fuentes]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 382 ---------------------------------------------
Creates an annotation strategy for the given annotation type . --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy strategyFor ( Class < ? extends Annotation > annotationType ) { annotationType = Annotations . canonicalizeIfNamed ( annotationType ) ; if ( isAllDefaultMethods ( annotationType ) ) { return strategyFor ( generateAnnotation ( annotationType ) ) ; } checkNotNull ( annotationType , "annotation type" ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; return new AnnotationTypeStrategy ( annotationType , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy strategyFor ( Class < ? extends Annotation > annotationType ) { annotationType = Annotations . canonicalizeIfNamed ( annotationType ) ; if ( isAllDefaultMethods ( annotationType ) ) { return strategyFor ( generateAnnotation ( annotationType ) ) ; } checkNotNull ( annotationType , "annotation type" ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; return new AnnotationTypeStrategy ( annotationType , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 383 ---------------------------------------------
Creates a message with the specified cause and message format . --> [[[FAILED]]]

[[[[Adv]]]]: public static Message create ( Throwable cause , String messageFormat , Object ... arguments ) { return create ( cause , ImmutableList . of ( ) , messageFormat , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message create ( Throwable cause , String messageFormat , Object ... arguments ) { return create ( cause , ImmutableList . of ( ) , messageFormat , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 384 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 189 / 193 / 2 / 384:  38%|███▊      | 384/1000 [2:13:01<3:33:23, 20.79s/it][Succeeded / Failed / Skipped / Total] 189 / 193 / 2 / 384:  38%|███▊      | 385/1000 [2:13:54<3:33:54, 20.87s/it][Succeeded / Failed / Skipped / Total] 190 / 193 / 2 / 385:  38%|███▊      | 385/1000 [2:13:54<3:33:54, 20.87s/it][Succeeded / Failed / Skipped / Total] 190 / 193 / 2 / 385:  39%|███▊      | 386/1000 [2:14:04<3:33:15, 20.84s/it][Succeeded / Failed / Skipped / Total] 190 / 194 / 2 / 386:  39%|███▊      | 386/1000 [2:14:04<3:33:15, 20.84s/it][Succeeded / Failed / Skipped / Total] 190 / 194 / 2 / 386:  39%|███▊      | 387/1000 [2:14:05<3:32:23, 20.79s/it][Succeeded / Failed / Skipped / Total] 191 / 194 / 2 / 387:  39%|███▊      | 387/1000 [2:14:05<3:32:23, 20.79s/it][Succeeded / Failed / Skipped / Total] 191 / 194 / 2 / 387:  39%|███▉      | 388/1000 [2:14:12<3:31:41, 20.75s/it][Succeeded / Failed / Skipped / Total] 192 / 194 / 2 / 388:  39%|███▉      | 388/1000 [2:14:12<3:31:41, 20.75s/it][Succeeded / Failed / Skipped / Total] 192 / 194 / 2 / 388:  39%|███▉      | 389/1000 [2:14:20<3:31:00, 20.72s/it][Succeeded / Failed / Skipped / Total] 193 / 194 / 2 / 389:  39%|███▉      | 389/1000 [2:14:20<3:31:00, 20.72s/it][Succeeded / Failed / Skipped / Total] 193 / 194 / 2 / 389:  39%|███▉      | 390/1000 [2:14:20<3:30:07, 20.67s/it][Succeeded / Failed / Skipped / Total] 193 / 194 / 3 / 390:  39%|███▉      | 390/1000 [2:14:20<3:30:07, 20.67s/it][Succeeded / Failed / Skipped / Total] 193 / 194 / 3 / 390:  39%|███▉      | 391/1000 [2:14:36<3:29:38, 20.65s/it][Succeeded / Failed / Skipped / Total] 194 / 194 / 3 / 391:  39%|███▉      | 391/1000 [2:14:36<3:29:38, 20.65s/it][Succeeded / Failed / Skipped / Total] 194 / 194 / 3 / 391:  39%|███▉      | 392/1000 [2:14:40<3:28:52, 20.61s/it]Gets the binding source . --> [[[FAILED]]]

[[[[Adv]]]]: public String getBindingSource ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String getBindingSource ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 385 ---------------------------------------------
Get the configuration source from a list of module class names . --> Given a list of SUPPLEMENTED SUPPLEMENTED SUPPLEMENTED SUPPLEMENTATION SUPPLEMENTED SUPPLEMENTATION SUPPLEMENTATION SUPPLEMENTATION SUPPLEMENTATION SUPPLEMENTATIONS --> Socre: 1.0

[[[[Adv]]]]: public Object [[getFromClassNames]] ( List < String > [[moduleClassNames]] ) { Preconditions . checkNotNull ( [[moduleClassNames]] , "The list of module class names cannot be null." ) ; for ( final String [[moduleClassName]] : [[moduleClassNames]] ) { if ( ! shouldBeSkipped ( [[moduleClassName]] ) ) { return new StackTraceElement ( [[moduleClassName]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object [[sling]] ( List < String > [[devised]] ) { Preconditions . checkNotNull ( [[devised]] , "The list of module class names cannot be null." ) ; for ( final String [[suppertime]] : [[devised]] ) { if ( ! shouldBeSkipped ( [[suppertime]] ) ) { return new StackTraceElement ( [[suppertime]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 386 ---------------------------------------------
Creates a new message with the specified message format and cause . --> [[[FAILED]]]

[[[[Adv]]]]: public static Message create ( Throwable cause , List < Object > sources , String messageFormat , Object ... arguments ) { String message = format ( messageFormat , arguments ) ; return new Message ( sources , message , cause ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message create ( Throwable cause , List < Object > sources , String messageFormat , Object ... arguments ) { String message = format ( messageFormat , arguments ) ; return new Message ( sources , message , cause ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 387 ---------------------------------------------
Called when a connection event occurs . --> Notify all connection event processors of a connection event --> Socre: 1.0

[[[[Adv]]]]: public void [[onEvent]] ( ConnectionEventType type , String remoteAddr , Connection [[conn]] ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( remoteAddr , [[conn]] ) ; } } }
[[[[Nl]]]]: Dispatch events .

[[[[Adv]]]]: public void [[managerial]] ( ConnectionEventType type , String remoteAddr , Connection [[ct]] ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( remoteAddr , [[ct]] ) ; } } }
[[[[Nl]]]]: Dispatch events .
--------------------------------------------- Result 388 ---------------------------------------------
Provisions the given provider and adds it to the construction context . --> Declares the proxy delegate for the given provider and dependency --> Socre: 1.0

[[[[Adv]]]]: protected T [[provision]] ( Provider < ? extends T > [[provider]] , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T [[t]] = [[provider]] . get ( ) ; if ( [[t]] == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( [[t]] ) ; return [[t]] ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T [[clause]] ( Provider < ? extends T > [[salesperson]] , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T [[ton]] = [[salesperson]] . get ( ) ; if ( [[ton]] == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( [[ton]] ) ; return [[ton]] ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .
--------------------------------------------- Result 389 ---------------------------------------------
Adds a connection event processor . --> fiend a handwriting with a metalworker --> Socre: 1.0

[[[[Adv]]]]: public void [[addConnectionEventProcessor]] ( ConnectionEventType [[type]] , ConnectionEventProcessor [[processor]] ) { List < ConnectionEventProcessor > [[processorList]] = this . processors . get ( [[type]] ) ; if ( [[processorList]] == null ) { this . processors . putIfAbsent ( [[type]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; [[processorList]] = this . processors . get ( [[type]] ) ; } [[processorList]] . add ( [[processor]] ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void [[fiend]] ( ConnectionEventType [[handwriting]] , ConnectionEventProcessor [[metalworkers]] ) { List < ConnectionEventProcessor > [[rarely]] = this . processors . get ( [[handwriting]] ) ; if ( [[rarely]] == null ) { this . processors . putIfAbsent ( [[handwriting]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; [[rarely]] = this . processors . get ( [[handwriting]] ) ; } [[rarely]] . add ( [[metalworkers]] ) ; }
[[[[Nl]]]]: Add event processor .
--------------------------------------------- Result 390 ---------------------------------------------
Launders an exception if it is unchecked . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static void launderThrowable ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 391 ---------------------------------------------
Pushes a dependency onto the stack . --> basanti basanti --> Socre: 1.0

[[[[Adv]]]]: Dependency < ? > [[pushDependency]] ( Dependency < ? > [[dependency]] , Object [[source]] ) { Dependency < ? > [[previous]] = this . [[dependency]] ; this . [[dependency]] = [[dependency]] ; doPushState ( [[dependency]] , [[source]] ) ; return [[previous]] ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > [[basanti]] ( Dependency < ? > [[codeine]] , Object [[fonts]] ) { Dependency < ? > [[precedents]] = this . [[methadone]] ; this . [[methadone]] = [[codeine]] ; doPushState ( [[codeine]] , [[fonts]] ) ; return [[precedents]] ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 392 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 195 / 194 / 3 / 392:  39%|███▉      | 392/1000 [2:14:40<3:28:52, 20.61s/it][Succeeded / Failed / Skipped / Total] 195 / 194 / 3 / 392:  39%|███▉      | 393/1000 [2:14:56<3:28:24, 20.60s/it][Succeeded / Failed / Skipped / Total] 195 / 195 / 3 / 393:  39%|███▉      | 393/1000 [2:14:56<3:28:24, 20.60s/it][Succeeded / Failed / Skipped / Total] 195 / 195 / 3 / 393:  39%|███▉      | 394/1000 [2:14:57<3:27:34, 20.55s/it][Succeeded / Failed / Skipped / Total] 196 / 195 / 3 / 394:  39%|███▉      | 394/1000 [2:14:57<3:27:34, 20.55s/it][Succeeded / Failed / Skipped / Total] 196 / 195 / 3 / 394:  40%|███▉      | 395/1000 [2:15:03<3:26:52, 20.52s/it][Succeeded / Failed / Skipped / Total] 197 / 195 / 3 / 395:  40%|███▉      | 395/1000 [2:15:03<3:26:52, 20.52s/it][Succeeded / Failed / Skipped / Total] 197 / 195 / 3 / 395:  40%|███▉      | 396/1000 [2:15:17<3:26:21, 20.50s/it][Succeeded / Failed / Skipped / Total] 197 / 196 / 3 / 396:  40%|███▉      | 396/1000 [2:15:17<3:26:21, 20.50s/it][Succeeded / Failed / Skipped / Total] 197 / 196 / 3 / 396:  40%|███▉      | 397/1000 [2:15:19<3:25:32, 20.45s/it][Succeeded / Failed / Skipped / Total] 198 / 196 / 3 / 397:  40%|███▉      | 397/1000 [2:15:19<3:25:32, 20.45s/it][Succeeded / Failed / Skipped / Total] 198 / 196 / 3 / 397:  40%|███▉      | 398/1000 [2:15:21<3:24:44, 20.41s/it][Succeeded / Failed / Skipped / Total] 199 / 196 / 3 / 398:  40%|███▉      | 398/1000 [2:15:21<3:24:44, 20.41s/it][Succeeded / Failed / Skipped / Total] 199 / 196 / 3 / 398:  40%|███▉      | 399/1000 [2:15:42<3:24:24, 20.41s/it][Succeeded / Failed / Skipped / Total] 200 / 196 / 3 / 399:  40%|███▉      | 399/1000 [2:15:42<3:24:24, 20.41s/it][Succeeded / Failed / Skipped / Total] 200 / 196 / 3 / 399:  40%|████      | 400/1000 [2:15:42<3:23:33, 20.36s/it][Succeeded / Failed / Skipped / Total] 200 / 196 / 4 / 400:  40%|████      | 400/1000 [2:15:42<3:23:33, 20.36s/it][Succeeded / Failed / Skipped / Total] 200 / 196 / 4 / 400:  40%|████      | 401/1000 [2:15:44<3:22:46, 20.31s/it]Pushes the state for the given key . --> mandate a fuentes --> Socre: 1.0

[[[[Adv]]]]: void [[pushState]] ( com . google . inject . Key < ? > key , Object [[source]] ) { doPushState ( key , [[source]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void [[mandate]] ( com . google . inject . Key < ? > key , Object [[fuentes]] ) { doPushState ( key , [[fuentes]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 393 ---------------------------------------------
Returns true if the given class should be skipped . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean shouldBeSkipped ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains ( className ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean shouldBeSkipped ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains ( className ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
--------------------------------------------- Result 394 ---------------------------------------------
Tries to get a URL from the cache . --> Returns the hanuman URL for the given URL . --> Socre: 1.0

[[[[Adv]]]]: private Url [[tryGet]] ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache

[[[[Adv]]]]: private Url [[hanuman]] ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 395 ---------------------------------------------
Decodes the protocol code . --> lamé . --> Socre: 1.0

[[[[Adv]]]]: protected ProtocolCode [[decodeProtocolCode]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode [[lamé]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 396 ---------------------------------------------
Main method to manage a remote module . --> [[[FAILED]]]

[[[[Adv]]]]: public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 397 ---------------------------------------------
Scans all available connection pools . --> Scans all the pool tasks . --> Socre: 1.0

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . [[connTasks]] && ! this . [[connTasks]] . isEmpty ( ) ) { Iterator < String > iter = this . [[connTasks]] . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . [[connTasks]] . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . [[drags]] && ! this . [[drags]] . isEmpty ( ) ) { Iterator < String > iter = this . [[drags]] . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . [[drags]] . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 398 ---------------------------------------------
Gets the connection from the given url and creates it if it does not exist . --> Georgetown implementation of Georgetown --> Socre: 1.0

[[[[Adv]]]]: @ Override public Connection [[getAndCreateIfAbsent]] ( Url [[url]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection [[georgetown]] ( Url [[connection]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 399 ---------------------------------------------
Create a connection and healing if needed . --> venison a url --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[createConnectionAndHealIfNeed]] ( Url [[url]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void [[venison]] ( Url [[crawler]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 400 ---------------------------------------------
Removes a connection pool from the pool map . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void removeTask ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 401 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 201 / 196 / 4 / 401:  40%|████      | 401/1000 [2:15:44<3:22:46, 20.31s/it][Succeeded / Failed / Skipped / Total] 201 / 196 / 4 / 401:  40%|████      | 402/1000 [2:15:45<3:21:57, 20.26s/it][Succeeded / Failed / Skipped / Total] 202 / 196 / 4 / 402:  40%|████      | 402/1000 [2:15:45<3:21:57, 20.26s/it][Succeeded / Failed / Skipped / Total] 202 / 196 / 4 / 402:  40%|████      | 403/1000 [2:15:47<3:21:09, 20.22s/it][Succeeded / Failed / Skipped / Total] 203 / 196 / 4 / 403:  40%|████      | 403/1000 [2:15:47<3:21:09, 20.22s/it][Succeeded / Failed / Skipped / Total] 203 / 196 / 4 / 403:  40%|████      | 404/1000 [2:15:52<3:20:26, 20.18s/it][Succeeded / Failed / Skipped / Total] 204 / 196 / 4 / 404:  40%|████      | 404/1000 [2:15:52<3:20:26, 20.18s/it][Succeeded / Failed / Skipped / Total] 204 / 196 / 4 / 404:  40%|████      | 405/1000 [2:16:21<3:20:19, 20.20s/it][Succeeded / Failed / Skipped / Total] 205 / 196 / 4 / 405:  40%|████      | 405/1000 [2:16:21<3:20:19, 20.20s/it][Succeeded / Failed / Skipped / Total] 205 / 196 / 4 / 405:  41%|████      | 406/1000 [2:16:40<3:19:57, 20.20s/it][Succeeded / Failed / Skipped / Total] 206 / 196 / 4 / 406:  41%|████      | 406/1000 [2:16:40<3:19:57, 20.20s/it][Succeeded / Failed / Skipped / Total] 206 / 196 / 4 / 406:  41%|████      | 407/1000 [2:17:15<3:19:59, 20.24s/it]Heals the connection if needed . --> Performs andorra authentication . --> Socre: 1.0

[[[[Adv]]]]: private void [[healIfNeed]] ( ConnectionPool [[pool]] , Url url ) throws RemotingException , InterruptedException { String [[poolKey]] = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void [[andorra]] ( ConnectionPool [[group]] , Url url ) throws RemotingException , InterruptedException { String [[deviates]] = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected
--------------------------------------------- Result 402 ---------------------------------------------
Performs a sync create . --> kubo . --> Socre: 1.0

[[[[Adv]]]]: private void [[doCreate]] ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections

[[[[Adv]]]]: private void [[kubo]] ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 403 ---------------------------------------------
Closes a connection . --> Sets the promised aims . --> Socre: 1.0

[[[[Adv]]]]: public void [[closeConnection]] ( String [[addr]] ) { Url url = this . addressParser . parse ( [[addr]] ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address

[[[[Adv]]]]: public void [[promised]] ( String [[aims]] ) { Url url = this . addressParser . parse ( [[aims]] ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 404 ---------------------------------------------
Called when the connection is closed . --> Remove all calls from the call map and vegetatively wait for them to finish --> Socre: 1.0

[[[[Adv]]]]: public void [[onClose]] ( ) { Iterator < Entry < Integer , InvokeFuture > > [[iter]] = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( [[iter]] . hasNext ( ) ) { Entry < Integer , InvokeFuture > [[entry]] = [[iter]] . next ( ) ; [[iter]] . remove ( ) ; InvokeFuture [[future]] = [[entry]] . getValue ( ) ; if ( [[future]] != null ) { [[future]] . putResponse ( [[future]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[future]] . cancelTimeout ( ) ; [[future]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void [[vegetative]] ( ) { Iterator < Entry < Integer , InvokeFuture > > [[callahan]] = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( [[callahan]] . hasNext ( ) ) { Entry < Integer , InvokeFuture > [[come]] = [[callahan]] . next ( ) ; [[callahan]] . remove ( ) ; InvokeFuture [[coming]] = [[come]] . getValue ( ) ; if ( [[coming]] != null ) { [[coming]] . putResponse ( [[coming]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[coming]] . cancelTimeout ( ) ; [[coming]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 405 ---------------------------------------------
Get all connections from all connection pools . --> Retrieving Connection Pools --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[getAll]] ( ) { Map < String , List < Connection > > [[allConnections]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > [[iterator]] = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( [[iterator]] . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = [[iterator]] . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { [[allConnections]] . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return [[allConnections]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[disciplinary]] ( ) { Map < String , List < Connection > > [[wormer]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > [[thain]] = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( [[thain]] . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = [[thain]] . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { [[wormer]] . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return [[wormer]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .
--------------------------------------------- Result 406 ---------------------------------------------
Sets an attribute if not present . --> Registers the given extent as being of the given decisive name --> Socre: 1.0

[[[[Adv]]]]: public Object [[setAttributeIfAbsent]] ( String [[key]] , Object [[value]] ) { return attributes . putIfAbsent ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object [[ofbeing]] ( String [[decisive]] , Object [[extent]] ) { return attributes . putIfAbsent ( [[decisive]] , [[extent]] ) ; }
[[[[Nl]]]]: set attribute if key absent .
--------------------------------------------- Result 407 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 206 / 197 / 4 / 407:  41%|████      | 407/1000 [2:17:15<3:19:59, 20.24s/it][Succeeded / Failed / Skipped / Total] 206 / 197 / 4 / 407:  41%|████      | 408/1000 [2:17:19<3:19:15, 20.19s/it][Succeeded / Failed / Skipped / Total] 207 / 197 / 4 / 408:  41%|████      | 408/1000 [2:17:19<3:19:15, 20.19s/it][Succeeded / Failed / Skipped / Total] 207 / 197 / 4 / 408:  41%|████      | 409/1000 [2:17:22<3:18:29, 20.15s/it][Succeeded / Failed / Skipped / Total] 208 / 197 / 4 / 409:  41%|████      | 409/1000 [2:17:22<3:18:29, 20.15s/it][Succeeded / Failed / Skipped / Total] 208 / 197 / 4 / 409:  41%|████      | 410/1000 [2:17:26<3:17:46, 20.11s/it][Succeeded / Failed / Skipped / Total] 209 / 197 / 4 / 410:  41%|████      | 410/1000 [2:17:26<3:17:46, 20.11s/it][Succeeded / Failed / Skipped / Total] 209 / 197 / 4 / 410:  41%|████      | 411/1000 [2:17:28<3:17:00, 20.07s/it][Succeeded / Failed / Skipped / Total] 210 / 197 / 4 / 411:  41%|████      | 411/1000 [2:17:28<3:17:00, 20.07s/it][Succeeded / Failed / Skipped / Total] 210 / 197 / 4 / 411:  41%|████      | 412/1000 [2:17:37<3:16:24, 20.04s/it]Registers a processor to rpc server . --> [[[FAILED]]]

[[[[Adv]]]]: public static void registerUserProcessor ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { registerUserProcessor ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void registerUserProcessor ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { registerUserProcessor ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .
--------------------------------------------- Result 408 ---------------------------------------------
Registers a processor with the rpc server . --> Amicus method for registering processors with rpc server --> Socre: 1.0

[[[[Adv]]]]: private static void [[registerUserProcessor]] ( MultiInterestUserProcessor < ? > [[processor]] , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == [[processor]] . multiInterest ( ) || [[processor]] . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : [[processor]] . multiInterest ( ) ) { UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( interest , [[processor]] ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void [[amicus]] ( MultiInterestUserProcessor < ? > [[constructors]] , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == [[constructors]] . multiInterest ( ) || [[constructors]] . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : [[constructors]] . multiInterest ( ) ) { UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( interest , [[constructors]] ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .
--------------------------------------------- Result 409 ---------------------------------------------
Dispatch the request to the user processor . --> shakira . --> Socre: 1.0

[[[[Adv]]]]: private void [[dispatchToUserProcessor]] ( RemotingContext ctx , RpcRequestCommand [[cmd]] ) { final int id = [[cmd]] . getId ( ) ; final byte type = [[cmd]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor

[[[[Adv]]]]: private void [[shakira]] ( RemotingContext ctx , RpcRequestCommand [[dddd]] ) { final int id = [[dddd]] . getId ( ) ; final byte type = [[dddd]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor
--------------------------------------------- Result 410 ---------------------------------------------
Deserialize the RpcRequestCommand and send the response --> Albie the RpcRequestCommand --> Socre: 1.0

[[[[Adv]]]]: private boolean [[deserializeRequestCommand]] ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command

[[[[Adv]]]]: private boolean [[albie]] ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command
--------------------------------------------- Result 411 ---------------------------------------------
Pre - processes the remoting context . --> professes the browning time of the command --> Socre: 1.0

[[[[Adv]]]]: private void [[preProcessRemotingContext]] ( RemotingContext ctx , RpcRequestCommand cmd , long [[currentTimestamp]] ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , [[currentTimestamp]] - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz

[[[[Adv]]]]: private void [[professing]] ( RemotingContext ctx , RpcRequestCommand cmd , long [[brownings]] ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , [[brownings]] - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz
--------------------------------------------- Result 412 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 211 / 197 / 4 / 412:  41%|████      | 412/1000 [2:17:37<3:16:24, 20.04s/it][Succeeded / Failed / Skipped / Total] 211 / 197 / 4 / 412:  41%|████▏     | 413/1000 [2:17:38<3:15:37, 20.00s/it][Succeeded / Failed / Skipped / Total] 212 / 197 / 4 / 413:  41%|████▏     | 413/1000 [2:17:38<3:15:37, 20.00s/it][Succeeded / Failed / Skipped / Total] 212 / 197 / 4 / 413:  41%|████▏     | 414/1000 [2:17:51<3:15:08, 19.98s/it][Succeeded / Failed / Skipped / Total] 212 / 198 / 4 / 414:  41%|████▏     | 414/1000 [2:17:51<3:15:08, 19.98s/it][Succeeded / Failed / Skipped / Total] 212 / 198 / 4 / 414:  42%|████▏     | 415/1000 [2:18:07<3:14:42, 19.97s/it][Succeeded / Failed / Skipped / Total] 212 / 199 / 4 / 415:  42%|████▏     | 415/1000 [2:18:07<3:14:42, 19.97s/it][Succeeded / Failed / Skipped / Total] 212 / 199 / 4 / 415:  42%|████▏     | 416/1000 [2:18:09<3:13:57, 19.93s/it][Succeeded / Failed / Skipped / Total] 213 / 199 / 4 / 416:  42%|████▏     | 416/1000 [2:18:09<3:13:57, 19.93s/it][Succeeded / Failed / Skipped / Total] 213 / 199 / 4 / 416:  42%|████▏     | 417/1000 [2:18:16<3:13:19, 19.90s/it]Logs the timeout information . --> divey the RpcRequestCommand --> Socre: 1.0

[[[[Adv]]]]: private void [[timeoutLog]] ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .

[[[[Adv]]]]: private void [[divey]] ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .
--------------------------------------------- Result 413 ---------------------------------------------
Debug log . --> Chains the RpcRequestCommand to the logger . --> Socre: 1.0

[[[[Adv]]]]: private void [[debugLog]] ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request

[[[[Adv]]]]: private void [[chains]] ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request
--------------------------------------------- Result 414 ---------------------------------------------
Get the result of a future task . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > T getFutureTaskResult ( RunStateRecordedFutureTask < T > task , Logger logger ) { T t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < T > T getFutureTaskResult ( RunStateRecordedFutureTask < T > task , Logger logger ) { T t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 415 ---------------------------------------------
Creates an initializable for the given instance . --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Initializable < T > of ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > of ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 416 ---------------------------------------------
Sends an invocation to the remote peer . --> Ooooh the invites --> Socre: 1.0

[[[[Adv]]]]: protected void [[oneway]] ( final Connection [[conn]] , final RemotingCommand [[request]] ) { try { [[conn]] . getChannel ( ) . writeAndFlush ( [[request]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[conn]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .

[[[[Adv]]]]: protected void [[ooooh]] ( final Connection [[malloy]] , final RemotingCommand [[invites]] ) { try { [[malloy]] . getChannel ( ) . writeAndFlush ( [[invites]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[malloy]] . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[malloy]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[malloy]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .
--------------------------------------------- Result 417 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 213 / 200 / 4 / 417:  42%|████▏     | 417/1000 [2:18:16<3:13:19, 19.90s/it][Succeeded / Failed / Skipped / Total] 213 / 200 / 4 / 417:  42%|████▏     | 418/1000 [2:18:19<3:12:35, 19.85s/it][Succeeded / Failed / Skipped / Total] 214 / 200 / 4 / 418:  42%|████▏     | 418/1000 [2:18:19<3:12:35, 19.85s/it][Succeeded / Failed / Skipped / Total] 214 / 200 / 4 / 418:  42%|████▏     | 419/1000 [2:18:20<3:11:49, 19.81s/it][Succeeded / Failed / Skipped / Total] 215 / 200 / 4 / 419:  42%|████▏     | 419/1000 [2:18:20<3:11:49, 19.81s/it][Succeeded / Failed / Skipped / Total] 215 / 200 / 4 / 419:  42%|████▏     | 420/1000 [2:18:20<3:11:02, 19.76s/it][Succeeded / Failed / Skipped / Total] 215 / 200 / 5 / 420:  42%|████▏     | 420/1000 [2:18:20<3:11:02, 19.76s/it][Succeeded / Failed / Skipped / Total] 215 / 200 / 5 / 420:  42%|████▏     | 421/1000 [2:18:56<3:11:04, 19.80s/it][Succeeded / Failed / Skipped / Total] 216 / 200 / 5 / 421:  42%|████▏     | 421/1000 [2:18:56<3:11:04, 19.80s/it][Succeeded / Failed / Skipped / Total] 216 / 200 / 5 / 421:  42%|████▏     | 422/1000 [2:18:59<3:10:21, 19.76s/it][Succeeded / Failed / Skipped / Total] 217 / 200 / 5 / 422:  42%|████▏     | 422/1000 [2:18:59<3:10:21, 19.76s/it][Succeeded / Failed / Skipped / Total] 217 / 200 / 5 / 422:  42%|████▏     | 423/1000 [2:19:02<3:09:39, 19.72s/it]Register a processor for the given command code . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerProcessor ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . cmd2processors . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void registerProcessor ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . cmd2processors . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 418 ---------------------------------------------
Convert an integer to a bit set . --> Returns a bitset containing the mistreatment of the given value . --> Socre: 1.0

[[[[Adv]]]]: public static BitSet [[toBitSet]] ( int [[value]] ) { if ( [[value]] > Byte . MAX_VALUE || [[value]] < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + [[value]] + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet [[bs]] = new BitSet ( ) ; int [[index]] = 0 ; while ( [[value]] != 0 ) { if ( [[value]] % 2 != 0 ) { [[bs]] . set ( [[index]] ) ; } ++ [[index]] ; [[value]] = ( byte ) ( [[value]] >> 1 ) ; } return [[bs]] ; }
[[[[Nl]]]]: from byte to bit set

[[[[Adv]]]]: public static BitSet [[mistreatment]] ( int [[prized]] ) { if ( [[prized]] > Byte . MAX_VALUE || [[prized]] < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + [[prized]] + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet [[tc]] = new BitSet ( ) ; int [[clue]] = 0 ; while ( [[prized]] != 0 ) { if ( [[prized]] % 2 != 0 ) { [[tc]] . set ( [[clue]] ) ; } ++ [[clue]] ; [[prized]] = ( byte ) ( [[prized]] >> 1 ) ; } return [[tc]] ; }
[[[[Nl]]]]: from byte to bit set
--------------------------------------------- Result 419 ---------------------------------------------
Add a reconnect task . --> Set the immunity for this connection . --> Socre: 1.0

[[[[Adv]]]]: public void [[addReconnectTask]] ( Url [[url]] ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = [[url]] ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task

[[[[Adv]]]]: public void [[immunity]] ( Url [[archival]] ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = [[archival]] ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task
--------------------------------------------- Result 420 ---------------------------------------------
Stops the task manager . --> [[[SKIPPED]]]

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread
--------------------------------------------- Result 421 ---------------------------------------------
Process a message using the configured executor . --> Heals a set of cellphones --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[process]] ( RemotingContext ctx , T [[msg]] , ExecutorService [[defaultExecutor]] ) throws Exception { ProcessTask [[task]] = new ProcessTask ( ctx , [[msg]] ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( [[task]] ) ; } else { [[defaultExecutor]] . execute ( [[task]] ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .

[[[[Adv]]]]: @ Override public void [[heal]] ( RemotingContext ctx , T [[cellphones]] , ExecutorService [[tv]] ) throws Exception { ProcessTask [[responsibility]] = new ProcessTask ( ctx , [[cellphones]] ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( [[responsibility]] ) ; } else { [[tv]] . execute ( [[responsibility]] ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .
--------------------------------------------- Result 422 ---------------------------------------------
Filter a list of connections by their service status . --> Filters the linkage for service status and ridicules . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[filter]] ( List < Connection > [[connections]] ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > [[serviceOffConnections]] = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : [[connections]] ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { [[serviceOffConnections]] . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , [[serviceOffConnections]] ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[screenings]] ( List < Connection > [[linkage]] ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > [[ridicules]] = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : [[linkage]] ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { [[ridicules]] . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , [[ridicules]] ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor
--------------------------------------------- Result 423 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 218 / 200 / 5 / 423:  42%|████▏     | 423/1000 [2:19:02<3:09:39, 19.72s/it][Succeeded / Failed / Skipped / Total] 218 / 200 / 5 / 423:  42%|████▏     | 424/1000 [2:19:03<3:08:53, 19.68s/it][Succeeded / Failed / Skipped / Total] 219 / 200 / 5 / 424:  42%|████▏     | 424/1000 [2:19:03<3:08:53, 19.68s/it][Succeeded / Failed / Skipped / Total] 219 / 200 / 5 / 424:  42%|████▎     | 425/1000 [2:19:03<3:08:07, 19.63s/it][Succeeded / Failed / Skipped / Total] 219 / 201 / 5 / 425:  42%|████▎     | 425/1000 [2:19:03<3:08:07, 19.63s/it][Succeeded / Failed / Skipped / Total] 219 / 201 / 5 / 425:  43%|████▎     | 426/1000 [2:19:03<3:07:22, 19.59s/it][Succeeded / Failed / Skipped / Total] 219 / 201 / 6 / 426:  43%|████▎     | 426/1000 [2:19:03<3:07:22, 19.59s/it][Succeeded / Failed / Skipped / Total] 219 / 201 / 6 / 426:  43%|████▎     | 427/1000 [2:19:03<3:06:36, 19.54s/it][Succeeded / Failed / Skipped / Total] 220 / 201 / 6 / 427:  43%|████▎     | 427/1000 [2:19:03<3:06:36, 19.54s/it][Succeeded / Failed / Skipped / Total] 220 / 201 / 6 / 427:  43%|████▎     | 428/1000 [2:19:03<3:05:51, 19.50s/it]Monitor connection pools . --> Check connection pools . --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[monitor]] ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off

[[[[Adv]]]]: @ Override public void [[check]] ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off
--------------------------------------------- Result 424 ---------------------------------------------
Converts the given request object to a remoting command . --> Margaritas que que los que que los que que que los que que los que que los que que los que que los que que los que que los que que los que que los que que los que que los que que los que que estos --> Socre: 1.0

[[[[Adv]]]]: protected RemotingCommand [[toRemotingCommand]] ( Object request , Connection [[conn]] , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand [[command]] = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .

[[[[Adv]]]]: protected RemotingCommand [[margaritas]] ( Object request , Connection [[bulls]] , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand [[kommando]] = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .
--------------------------------------------- Result 425 ---------------------------------------------
Registers the default processor . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerDefaultProcessor ( RemotingProcessor < ? > processor ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void registerDefaultProcessor ( RemotingProcessor < ? > processor ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 426 ---------------------------------------------
Logs information to the logger . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void infoLog ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log
--------------------------------------------- Result 427 ---------------------------------------------
Get a system property as a boolean . --> Get a splash configuration value as a boolean . --> Socre: 1.0

[[[[Adv]]]]: public static boolean getBool ( String key , String [[defaultValue]] ) { return Boolean . parseBoolean ( System . getProperty ( key , [[defaultValue]] ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property

[[[[Adv]]]]: public static boolean getBool ( String key , String [[splashes]] ) { return Boolean . parseBoolean ( System . getProperty ( key , [[splashes]] ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property
--------------------------------------------- Result 428 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 220 / 202 / 6 / 428:  43%|████▎     | 428/1000 [2:19:03<3:05:51, 19.50s/it][Succeeded / Failed / Skipped / Total] 220 / 202 / 6 / 428:  43%|████▎     | 429/1000 [2:19:07<3:05:10, 19.46s/it][Succeeded / Failed / Skipped / Total] 221 / 202 / 6 / 429:  43%|████▎     | 429/1000 [2:19:07<3:05:10, 19.46s/it][Succeeded / Failed / Skipped / Total] 221 / 202 / 6 / 429:  43%|████▎     | 430/1000 [2:19:09<3:04:28, 19.42s/it][Succeeded / Failed / Skipped / Total] 221 / 203 / 6 / 430:  43%|████▎     | 430/1000 [2:19:09<3:04:28, 19.42s/it][Succeeded / Failed / Skipped / Total] 221 / 203 / 6 / 430:  43%|████▎     | 431/1000 [2:19:11<3:03:45, 19.38s/it][Succeeded / Failed / Skipped / Total] 222 / 203 / 6 / 431:  43%|████▎     | 431/1000 [2:19:11<3:03:45, 19.38s/it][Succeeded / Failed / Skipped / Total] 222 / 203 / 6 / 431:  43%|████▎     | 432/1000 [2:19:11<3:03:00, 19.33s/it][Succeeded / Failed / Skipped / Total] 223 / 203 / 6 / 432:  43%|████▎     | 432/1000 [2:19:11<3:03:00, 19.33s/it][Succeeded / Failed / Skipped / Total] 223 / 203 / 6 / 432:  43%|████▎     | 433/1000 [2:19:21<3:02:28, 19.31s/it][Succeeded / Failed / Skipped / Total] 223 / 204 / 6 / 433:  43%|████▎     | 433/1000 [2:19:21<3:02:28, 19.31s/it][Succeeded / Failed / Skipped / Total] 223 / 204 / 6 / 433:  43%|████▎     | 434/1000 [2:19:26<3:01:51, 19.28s/it]Returns the processor associated with the given command code . --> [[[FAILED]]]

[[[[Adv]]]]: public RemotingProcessor < ? > getProcessor ( CommandCode cmdCode ) { RemotingProcessor < ? > processor = this . cmd2processors . get ( cmdCode ) ; if ( processor != null ) { return processor ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > getProcessor ( CommandCode cmdCode ) { RemotingProcessor < ? > processor = this . cmd2processors . get ( cmdCode ) ; if ( processor != null ) { return processor ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .
--------------------------------------------- Result 429 ---------------------------------------------
Closes fresh select connections . --> Method to formica . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeFreshSelectConnections]] ( Connection [[lastSelectConnect]] , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != [[lastSelectConnect]] ) { if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[lastSelectConnect]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[lastSelectConnect]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[lastSelectConnect]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections

[[[[Adv]]]]: private void [[formica]] ( Connection [[poos]] , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != [[poos]] ) { if ( [[poos]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[poos]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[poos]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[poos]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[poos]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections
--------------------------------------------- Result 430 ---------------------------------------------
Returns true if the request timed out . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean isRequestTimeout ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout

[[[[Adv]]]]: public boolean isRequestTimeout ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout
--------------------------------------------- Result 431 ---------------------------------------------
Returns the value of the property with the given key . --> Returns the bijou wrenches . --> Socre: 1.0

[[[[Adv]]]]: public String [[getProperty]] ( String [[key]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[key]] ) ; }
[[[[Nl]]]]: Get property value according to property key

[[[[Adv]]]]: public String [[bijou]] ( String [[wrenches]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[wrenches]] ) ; }
[[[[Nl]]]]: Get property value according to property key
--------------------------------------------- Result 432 ---------------------------------------------
Returns the value associated with the given key . If the key does not exist the defaultIfNotFound is returned . --> Gets the tons . --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] get ( String key , [[T]] defaultIfNotFound ) { return this . [[context]] . get ( key ) != null ? ( [[T]] ) this . [[context]] . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[tons]] > [[tons]] get ( String key , [[tons]] defaultIfNotFound ) { return this . [[marco]] . get ( key ) != null ? ( [[tons]] ) this . [[marco]] . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found
--------------------------------------------- Result 433 ---------------------------------------------
Gets a random connection from a list of connections . --> [[[FAILED]]]

[[[[Adv]]]]: private Connection randomGet ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly

[[[[Adv]]]]: private Connection randomGet ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly
--------------------------------------------- Result 434 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 223 / 205 / 6 / 434:  43%|████▎     | 434/1000 [2:19:26<3:01:51, 19.28s/it][Succeeded / Failed / Skipped / Total] 223 / 205 / 6 / 434:  44%|████▎     | 435/1000 [2:19:27<3:01:08, 19.24s/it][Succeeded / Failed / Skipped / Total] 224 / 205 / 6 / 435:  44%|████▎     | 435/1000 [2:19:27<3:01:08, 19.24s/it][Succeeded / Failed / Skipped / Total] 224 / 205 / 6 / 435:  44%|████▎     | 436/1000 [2:19:27<3:00:24, 19.19s/it][Succeeded / Failed / Skipped / Total] 224 / 206 / 6 / 436:  44%|████▎     | 436/1000 [2:19:27<3:00:24, 19.19s/it][Succeeded / Failed / Skipped / Total] 224 / 206 / 6 / 436:  44%|████▎     | 437/1000 [2:19:29<2:59:42, 19.15s/it][Succeeded / Failed / Skipped / Total] 225 / 206 / 6 / 437:  44%|████▎     | 437/1000 [2:19:29<2:59:42, 19.15s/it][Succeeded / Failed / Skipped / Total] 225 / 206 / 6 / 437:  44%|████▍     | 438/1000 [2:19:37<2:59:09, 19.13s/it]Formats the given collection of Message objects as a human - readable string . --> [[[FAILED]]]

[[[[Adv]]]]: public static String formatMessages ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String formatMessages ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 435 ---------------------------------------------
Helper method to detail the server error message --> DetailErrMsg . --> Socre: 1.0

[[[[Adv]]]]: private static String detailErrMsg ( String [[clientErrMsg]] , ResponseCommand [[responseCommand]] ) { RpcResponseCommand resp = ( RpcResponseCommand ) [[responseCommand]] ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , [[clientErrMsg]] , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , [[clientErrMsg]] ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command

[[[[Adv]]]]: private static String detailErrMsg ( String [[yadav]] , ResponseCommand [[sarsaparilla]] ) { RpcResponseCommand resp = ( RpcResponseCommand ) [[sarsaparilla]] ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , [[yadav]] , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , [[yadav]] ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command
--------------------------------------------- Result 436 ---------------------------------------------
Closes the connection . --> [[[FAILED]]]

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .
--------------------------------------------- Result 437 ---------------------------------------------
Print connection trace log . --> This method logs the source and target IP addresses and the target IP addresses . --> Socre: 1.0

[[[[Adv]]]]: public static void [[printConnectionTraceLog]] ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log

[[[[Adv]]]]: public static void [[saban]] ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log
--------------------------------------------- Result 438 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 226 / 206 / 6 / 438:  44%|████▍     | 438/1000 [2:19:37<2:59:09, 19.13s/it][Succeeded / Failed / Skipped / Total] 226 / 206 / 6 / 438:  44%|████▍     | 439/1000 [2:19:39<2:58:28, 19.09s/it][Succeeded / Failed / Skipped / Total] 227 / 206 / 6 / 439:  44%|████▍     | 439/1000 [2:19:39<2:58:28, 19.09s/it][Succeeded / Failed / Skipped / Total] 227 / 206 / 6 / 439:  44%|████▍     | 440/1000 [2:19:41<2:57:47, 19.05s/it][Succeeded / Failed / Skipped / Total] 228 / 206 / 6 / 440:  44%|████▍     | 440/1000 [2:19:41<2:57:47, 19.05s/it][Succeeded / Failed / Skipped / Total] 228 / 206 / 6 / 440:  44%|████▍     | 441/1000 [2:19:41<2:57:04, 19.01s/it]Converts an RPC response command to a Throwable . --> armless the RpcResponseCommand --> Socre: 1.0

[[[[Adv]]]]: private static Throwable [[toThrowable]] ( ResponseCommand [[responseCommand]] ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) [[responseCommand]] ; resp . deserialize ( ) ; Object [[ex]] = resp . getResponseObject ( ) ; if ( [[ex]] != null && [[ex]] instanceof Throwable ) { return ( Throwable ) [[ex]] ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .

[[[[Adv]]]]: private static Throwable [[armless]] ( ResponseCommand [[lessing]] ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) [[lessing]] ; resp . deserialize ( ) ; Object [[anterior]] = resp . getResponseObject ( ) ; if ( [[anterior]] != null && [[anterior]] instanceof Throwable ) { return ( Throwable ) [[anterior]] ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .
--------------------------------------------- Result 439 ---------------------------------------------
Creates a RpcServerException from the given throwable and error message . --> crocs a RpcServerException --> Socre: 1.0

[[[[Adv]]]]: private RpcServerException [[createServerException]] ( Throwable t , String [[errMsg]] ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , [[errMsg]] ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .

[[[[Adv]]]]: private RpcServerException [[crocs]] ( Throwable t , String [[flabby]] ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , [[flabby]] ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .
--------------------------------------------- Result 440 ---------------------------------------------
Resolve the response object from the response command . --> prohibit reply from being sent to answerphone --> Socre: 1.0

[[[[Adv]]]]: public static Object [[resolveResponseObject]] ( ResponseCommand [[responseCommand]] , String addr ) throws RemotingException { preProcess ( [[responseCommand]] , addr ) ; if ( [[responseCommand]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[responseCommand]] ) ; } else { String [[msg]] = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[responseCommand]] . getResponseStatus ( ) , addr , [[responseCommand]] . getId ( ) ) ; logger . warn ( [[msg]] ) ; if ( [[responseCommand]] . getCause ( ) != null ) { throw new InvokeException ( [[msg]] , [[responseCommand]] . getCause ( ) ) ; } else { throw new InvokeException ( [[msg]] + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .

[[[[Adv]]]]: public static Object [[prohibit]] ( ResponseCommand [[fifth]] , String addr ) throws RemotingException { preProcess ( [[fifth]] , addr ) ; if ( [[fifth]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[fifth]] ) ; } else { String [[answerphone]] = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[fifth]] . getResponseStatus ( ) , addr , [[fifth]] . getId ( ) ) ; logger . warn ( [[answerphone]] ) ; if ( [[fifth]] . getCause ( ) != null ) { throw new InvokeException ( [[answerphone]] , [[fifth]] . getCause ( ) ) ; } else { throw new InvokeException ( [[answerphone]] + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .
--------------------------------------------- Result 441 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 229 / 206 / 6 / 441:  44%|████▍     | 441/1000 [2:19:41<2:57:04, 19.01s/it][Succeeded / Failed / Skipped / Total] 229 / 206 / 6 / 441:  44%|████▍     | 442/1000 [2:19:48<2:56:29, 18.98s/it][Succeeded / Failed / Skipped / Total] 229 / 207 / 6 / 442:  44%|████▍     | 442/1000 [2:19:48<2:56:29, 18.98s/it][Succeeded / Failed / Skipped / Total] 229 / 207 / 6 / 442:  44%|████▍     | 443/1000 [2:20:49<2:57:03, 19.07s/it][Succeeded / Failed / Skipped / Total] 230 / 207 / 6 / 443:  44%|████▍     | 443/1000 [2:20:49<2:57:03, 19.07s/it][Succeeded / Failed / Skipped / Total] 230 / 207 / 6 / 443:  44%|████▍     | 444/1000 [2:21:18<2:56:57, 19.10s/it][Succeeded / Failed / Skipped / Total] 231 / 207 / 6 / 444:  44%|████▍     | 444/1000 [2:21:18<2:56:57, 19.10s/it][Succeeded / Failed / Skipped / Total] 231 / 207 / 6 / 444:  44%|████▍     | 445/1000 [2:23:41<2:59:12, 19.37s/it][Succeeded / Failed / Skipped / Total] 231 / 208 / 6 / 445:  44%|████▍     | 445/1000 [2:23:41<2:59:12, 19.37s/it][Succeeded / Failed / Skipped / Total] 231 / 208 / 6 / 445:  45%|████▍     | 446/1000 [2:23:49<2:58:39, 19.35s/it]Sends a request to the remoting server and invokes the callback . --> jara - jara - command --> Socre: 1.0

[[[[Adv]]]]: protected void [[invokeWithCallback]] ( final Connection conn , final RemotingCommand [[request]] , final InvokeCallback [[invokeCallback]] , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , [[request]] , [[request]] . getInvokeContext ( ) , [[invokeCallback]] ) ; conn . addInvokeFuture ( future ) ; final int requestId = [[request]] . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout [[timeout]] ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( [[request]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .

[[[[Adv]]]]: protected void [[jara]] ( final Connection conn , final RemotingCommand [[application]] , final InvokeCallback [[wiring]] , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , [[application]] , [[application]] . getInvokeContext ( ) , [[wiring]] ) ; conn . addInvokeFuture ( future ) ; final int requestId = [[application]] . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout [[snooze]] ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( [[application]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .
--------------------------------------------- Result 442 ---------------------------------------------
Converts a bit set to a byte . --> [[[FAILED]]]

[[[[Adv]]]]: public static byte toByte ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte

[[[[Adv]]]]: public static byte toByte ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte
--------------------------------------------- Result 443 ---------------------------------------------
Converts a ResponseCommand to an Object . --> practicing the RpcResponseCommand --> Socre: 1.0

[[[[Adv]]]]: private static Object [[toResponseObject]] ( ResponseCommand [[responseCommand]] ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) [[responseCommand]] ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .

[[[[Adv]]]]: private static Object [[practicing]] ( ResponseCommand [[revelations]] ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) [[revelations]] ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .
--------------------------------------------- Result 444 ---------------------------------------------
Returns a user processor by class name . --> Returns the cost of a given crewe --> Socre: 1.0

[[[[Adv]]]]: public UserProcessor < ? > [[getUserProcessor]] ( String [[className]] ) { return StringUtils . isBlank ( [[className]] ) ? null : this . [[userProcessors]] . get ( [[className]] ) ; }
[[[[Nl]]]]: Get user processor for class name .

[[[[Adv]]]]: public UserProcessor < ? > [[costing]] ( String [[crewe]] ) { return StringUtils . isBlank ( [[crewe]] ) ? null : this . [[flap]] . get ( [[crewe]] ) ; }
[[[[Nl]]]]: Get user processor for class name .
--------------------------------------------- Result 445 ---------------------------------------------
Parses the remote IP address of the given channel . --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseRemoteIP ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .

[[[[Adv]]]]: public static String parseRemoteIP ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .
--------------------------------------------- Result 446 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 231 / 209 / 6 / 446:  45%|████▍     | 446/1000 [2:23:49<2:58:39, 19.35s/it][Succeeded / Failed / Skipped / Total] 231 / 209 / 6 / 446:  45%|████▍     | 447/1000 [2:23:50<2:57:57, 19.31s/it][Succeeded / Failed / Skipped / Total] 231 / 210 / 6 / 447:  45%|████▍     | 447/1000 [2:23:50<2:57:57, 19.31s/it][Succeeded / Failed / Skipped / Total] 231 / 210 / 6 / 447:  45%|████▍     | 448/1000 [2:23:52<2:57:16, 19.27s/it][Succeeded / Failed / Skipped / Total] 232 / 210 / 6 / 448:  45%|████▍     | 448/1000 [2:23:52<2:57:16, 19.27s/it][Succeeded / Failed / Skipped / Total] 232 / 210 / 6 / 448:  45%|████▍     | 449/1000 [2:23:52<2:56:33, 19.23s/it][Succeeded / Failed / Skipped / Total] 233 / 210 / 6 / 449:  45%|████▍     | 449/1000 [2:23:52<2:56:33, 19.23s/it][Succeeded / Failed / Skipped / Total] 233 / 210 / 6 / 449:  45%|████▌     | 450/1000 [2:23:53<2:55:52, 19.19s/it][Succeeded / Failed / Skipped / Total] 234 / 210 / 6 / 450:  45%|████▌     | 450/1000 [2:23:53<2:55:52, 19.19s/it][Succeeded / Failed / Skipped / Total] 234 / 210 / 6 / 450:  45%|████▌     | 451/1000 [2:23:59<2:55:17, 19.16s/it][Succeeded / Failed / Skipped / Total] 235 / 210 / 6 / 451:  45%|████▌     | 451/1000 [2:23:59<2:55:17, 19.16s/it][Succeeded / Failed / Skipped / Total] 235 / 210 / 6 / 451:  45%|████▌     | 452/1000 [2:24:09<2:54:46, 19.14s/it][Succeeded / Failed / Skipped / Total] 235 / 211 / 6 / 452:  45%|████▌     | 452/1000 [2:24:09<2:54:46, 19.14s/it][Succeeded / Failed / Skipped / Total] 235 / 211 / 6 / 452:  45%|████▌     | 453/1000 [2:24:10<2:54:05, 19.10s/it][Succeeded / Failed / Skipped / Total] 235 / 212 / 6 / 453:  45%|████▌     | 453/1000 [2:24:10<2:54:05, 19.10s/it][Succeeded / Failed / Skipped / Total] 235 / 212 / 6 / 453:  45%|████▌     | 454/1000 [2:24:11<2:53:25, 19.06s/it][Succeeded / Failed / Skipped / Total] 236 / 212 / 6 / 454:  45%|████▌     | 454/1000 [2:24:11<2:53:25, 19.06s/it][Succeeded / Failed / Skipped / Total] 236 / 212 / 6 / 454:  46%|████▌     | 455/1000 [2:24:13<2:52:44, 19.02s/it]Parses the remote host name from the given channel . --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseRemoteHostName ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .

[[[[Adv]]]]: public static String parseRemoteHostName ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .
--------------------------------------------- Result 447 ---------------------------------------------
Parses the local IP address of the given channel . --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseLocalIP ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .

[[[[Adv]]]]: public static String parseLocalIP ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .
--------------------------------------------- Result 448 ---------------------------------------------
Remove a connection from the pool and try to close it . --> Remove the attaching and try to close it . --> Socre: 1.0

[[[[Adv]]]]: public void removeAndTryClose ( Connection [[connection]] ) { if ( null == [[connection]] ) { return ; } boolean res = this . [[conns]] . remove ( [[connection]] ) ; if ( res ) { [[connection]] . decreaseRef ( ) ; } if ( [[connection]] . noRef ( ) ) { [[connection]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection

[[[[Adv]]]]: public void removeAndTryClose ( Connection [[attaching]] ) { if ( null == [[attaching]] ) { return ; } boolean res = this . [[wharton]] . remove ( [[attaching]] ) ; if ( res ) { [[attaching]] . decreaseRef ( ) ; } if ( [[attaching]] . noRef ( ) ) { [[attaching]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection
--------------------------------------------- Result 449 ---------------------------------------------
Adds a connection to the pool . --> Adds the given relation to the robberies list . --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Connection [[connection]] ) { markAccess ( ) ; if ( null == [[connection]] ) { return ; } boolean res = this . [[conns]] . addIfAbsent ( [[connection]] ) ; if ( res ) { [[connection]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection

[[[[Adv]]]]: public void [[extras]] ( Connection [[relation]] ) { markAccess ( ) ; if ( null == [[relation]] ) { return ; } boolean res = this . [[robberies]] . addIfAbsent ( [[relation]] ) ; if ( res ) { [[relation]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection
--------------------------------------------- Result 450 ---------------------------------------------
Returns the next available connection . --> Checks if there are any connections in the database . --> Socre: 1.0

[[[[Adv]]]]: public Connection [[get]] ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > [[snapshot]] = new ArrayList < Connection > ( this . conns ) ; if ( [[snapshot]] . size ( ) > 0 ) { return this . strategy . select ( [[snapshot]] ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection

[[[[Adv]]]]: public Connection [[have]] ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > [[overview]] = new ArrayList < Connection > ( this . conns ) ; if ( [[overview]] . size ( ) > 0 ) { return this . strategy . select ( [[overview]] ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection
--------------------------------------------- Result 451 ---------------------------------------------
Get custom serializer by class name . --> Methode des legionnaires --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( String [[className]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[className]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .

[[[[Adv]]]]: public static CustomSerializer [[legionnaires]] ( String [[moisten]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[moisten]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .
--------------------------------------------- Result 452 ---------------------------------------------
Parses the local address of a channel . --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseLocalAddress ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress local = channel . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .

[[[[Adv]]]]: public static String parseLocalAddress ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress local = channel . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .
--------------------------------------------- Result 453 ---------------------------------------------
Parses the remote address of a channel . --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseRemoteAddress ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress remote = channel . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .

[[[[Adv]]]]: public static String parseRemoteAddress ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress remote = channel . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .
--------------------------------------------- Result 454 ---------------------------------------------
Start the connection monitor . --> Starts the connection monitor . --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "[[True]]" == "[[True]]" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task

[[[[Adv]]]]: public void [[initial]] ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "[[Trusty]]" == "[[Trusty]]" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task
--------------------------------------------- Result 455 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 237 / 212 / 6 / 455:  46%|████▌     | 455/1000 [2:24:13<2:52:44, 19.02s/it][Succeeded / Failed / Skipped / Total] 237 / 212 / 6 / 455:  46%|████▌     | 456/1000 [2:24:13<2:52:04, 18.98s/it][Succeeded / Failed / Skipped / Total] 238 / 212 / 6 / 456:  46%|████▌     | 456/1000 [2:24:13<2:52:04, 18.98s/it][Succeeded / Failed / Skipped / Total] 238 / 212 / 6 / 456:  46%|████▌     | 457/1000 [2:24:38<2:51:51, 18.99s/it][Succeeded / Failed / Skipped / Total] 238 / 213 / 6 / 457:  46%|████▌     | 457/1000 [2:24:38<2:51:51, 18.99s/it][Succeeded / Failed / Skipped / Total] 238 / 213 / 6 / 457:  46%|████▌     | 458/1000 [2:24:41<2:51:13, 18.96s/it][Succeeded / Failed / Skipped / Total] 239 / 213 / 6 / 458:  46%|████▌     | 458/1000 [2:24:41<2:51:13, 18.96s/it][Succeeded / Failed / Skipped / Total] 239 / 213 / 6 / 458:  46%|████▌     | 459/1000 [2:24:58<2:50:51, 18.95s/it][Succeeded / Failed / Skipped / Total] 239 / 214 / 6 / 459:  46%|████▌     | 459/1000 [2:24:58<2:50:51, 18.95s/it][Succeeded / Failed / Skipped / Total] 239 / 214 / 6 / 459:  46%|████▌     | 460/1000 [2:24:58<2:50:11, 18.91s/it][Succeeded / Failed / Skipped / Total] 240 / 214 / 6 / 460:  46%|████▌     | 460/1000 [2:24:58<2:50:11, 18.91s/it][Succeeded / Failed / Skipped / Total] 240 / 214 / 6 / 460:  46%|████▌     | 461/1000 [2:25:00<2:49:32, 18.87s/it][Succeeded / Failed / Skipped / Total] 241 / 214 / 6 / 461:  46%|████▌     | 461/1000 [2:25:00<2:49:32, 18.87s/it][Succeeded / Failed / Skipped / Total] 241 / 214 / 6 / 461:  46%|████▌     | 462/1000 [2:25:01<2:48:52, 18.83s/it][Succeeded / Failed / Skipped / Total] 242 / 214 / 6 / 462:  46%|████▌     | 462/1000 [2:25:01<2:48:52, 18.83s/it][Succeeded / Failed / Skipped / Total] 242 / 214 / 6 / 462:  46%|████▋     | 463/1000 [2:25:02<2:48:13, 18.80s/it]Returns true if the remote address is connected . --> Returns true if the given URL is inexcusable . --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isConnected]] ( String [[remoteAddr]] ) { Url url = this . [[rpcRemoting]] . addressParser . parse ( [[remoteAddr]] ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected

[[[[Adv]]]]: public boolean [[inexcusable]] ( String [[lile]] ) { Url url = this . [[throstle]] . addressParser . parse ( [[lile]] ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected
--------------------------------------------- Result 456 ---------------------------------------------
Initializes the write buffer water mark . --> Sets the soaps channel option . --> Socre: 1.0

[[[[Adv]]]]: private void [[initWriteBufferWaterMark]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark

[[[[Adv]]]]: private void [[soaps]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark
--------------------------------------------- Result 457 ---------------------------------------------
Creates a new EventLoopGroup with the specified number of threads . --> [[[FAILED]]]

[[[[Adv]]]]: public static EventLoopGroup newEventLoopGroup ( int nThreads , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , threadFactory ) : new NioEventLoopGroup ( nThreads , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .

[[[[Adv]]]]: public static EventLoopGroup newEventLoopGroup ( int nThreads , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , threadFactory ) : new NioEventLoopGroup ( nThreads , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .
--------------------------------------------- Result 458 ---------------------------------------------
Writes a batch of data to the given channel . --> Exploratory function for expeditions . --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[batch]] ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed

[[[[Adv]]]]: public static boolean [[expeditions]] ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed
--------------------------------------------- Result 459 ---------------------------------------------
Parses the remote port from the channel . --> [[[FAILED]]]

[[[[Adv]]]]: public static int parseRemotePort ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .

[[[[Adv]]]]: public static int parseRemotePort ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .
--------------------------------------------- Result 460 ---------------------------------------------
Sets the code . --> Method consecrate . --> Socre: 1.0

[[[[Adv]]]]: public void [[setCode]] ( int [[code]] ) { this . code = [[code]] ;
[[[[Nl]]]]: Set the close code for this close frame

[[[[Adv]]]]: public void [[consecrate]] ( int [[keyed]] ) { this . code = [[keyed]] ;
[[[[Nl]]]]: Set the close code for this close frame
--------------------------------------------- Result 461 ---------------------------------------------
Updates the payload based on the reason . --> Smushed message . --> Socre: 1.0

[[[[Adv]]]]: private void [[updatePayload]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer [[buf]] = ByteBuffer . allocate ( 4 ) ; [[buf]] . putInt ( code ) ; [[buf]] . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( [[buf]] ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason

[[[[Adv]]]]: private void [[smushed]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer [[crassus]] = ByteBuffer . allocate ( 4 ) ; [[crassus]] . putInt ( code ) ; [[crassus]] . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( [[crassus]] ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason
--------------------------------------------- Result 462 ---------------------------------------------
Validate UTF - 8 . --> Validates UTF - 8 data . --> Socre: 1.0

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer [[payload]] , int mark ) throws InvalidDataException { try { [[payload]] . position ( [[payload]] . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( [[payload]] ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { [[payload]] . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer [[charge]] , int mark ) throws InvalidDataException { try { [[charge]] . position ( [[charge]] . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( [[charge]] ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { [[charge]] . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8
--------------------------------------------- Result 463 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 243 / 214 / 6 / 463:  46%|████▋     | 463/1000 [2:25:02<2:48:13, 18.80s/it][Succeeded / Failed / Skipped / Total] 243 / 214 / 6 / 463:  46%|████▋     | 464/1000 [2:25:03<2:47:34, 18.76s/it][Succeeded / Failed / Skipped / Total] 244 / 214 / 6 / 464:  46%|████▋     | 464/1000 [2:25:03<2:47:34, 18.76s/it][Succeeded / Failed / Skipped / Total] 244 / 214 / 6 / 464:  46%|████▋     | 465/1000 [2:25:05<2:46:55, 18.72s/it][Succeeded / Failed / Skipped / Total] 245 / 214 / 6 / 465:  46%|████▋     | 465/1000 [2:25:05<2:46:55, 18.72s/it][Succeeded / Failed / Skipped / Total] 245 / 214 / 6 / 465:  47%|████▋     | 466/1000 [2:25:07<2:46:18, 18.69s/it][Succeeded / Failed / Skipped / Total] 246 / 214 / 6 / 466:  47%|████▋     | 466/1000 [2:25:07<2:46:18, 18.69s/it][Succeeded / Failed / Skipped / Total] 246 / 214 / 6 / 466:  47%|████▋     | 467/1000 [2:25:08<2:45:39, 18.65s/it][Succeeded / Failed / Skipped / Total] 247 / 214 / 6 / 467:  47%|████▋     | 467/1000 [2:25:08<2:45:39, 18.65s/it][Succeeded / Failed / Skipped / Total] 247 / 214 / 6 / 467:  47%|████▋     | 468/1000 [2:25:10<2:45:02, 18.61s/it][Succeeded / Failed / Skipped / Total] 248 / 214 / 6 / 468:  47%|████▋     | 468/1000 [2:25:10<2:45:02, 18.61s/it][Succeeded / Failed / Skipped / Total] 248 / 214 / 6 / 468:  47%|████▋     | 469/1000 [2:25:17<2:44:30, 18.59s/it][Succeeded / Failed / Skipped / Total] 248 / 215 / 6 / 469:  47%|████▋     | 469/1000 [2:25:17<2:44:30, 18.59s/it][Succeeded / Failed / Skipped / Total] 248 / 215 / 6 / 469:  47%|████▋     | 470/1000 [2:25:26<2:44:00, 18.57s/it]Translate payload size limit . --> Hillard payload length . --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckLengthLimit]] ( long [[length]] ) throws LimitExceededException { if ( [[length]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[length]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[length]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[length]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit

[[[[Adv]]]]: private void [[hillard]] ( long [[lengthened]] ) throws LimitExceededException { if ( [[lengthened]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[lengthened]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[lengthened]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[lengthened]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit
--------------------------------------------- Result 464 ---------------------------------------------
Get the custom serializer for the given command code . --> CustomSerializer --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( CommandCode code ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( code ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .

[[[[Adv]]]]: public static CustomSerializer [[ö]] ( CommandCode code ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( code ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .
--------------------------------------------- Result 465 ---------------------------------------------
Generate the final key . --> Returns the delirium id . --> Socre: 1.0

[[[[Adv]]]]: private String [[generateFinalKey]] ( String [[in]] ) { String [[seckey]] = [[in]] . trim ( ) ; String [[acc]] = [[seckey]] + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest [[sh1]] ; try { [[sh1]] = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( [[sh1]] . digest ( [[acc]] . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string

[[[[Adv]]]]: private String [[delirium]] ( String [[chez]] ) { String [[dancing]] = [[chez]] . trim ( ) ; String [[pbs]] = [[dancing]] + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest [[aleichem]] ; try { [[aleichem]] = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( [[aleichem]] . digest ( [[pbs]] . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string
--------------------------------------------- Result 466 ---------------------------------------------
Checks if the handshake contains the requested protocol . --> zeit handshake state . --> Socre: 1.0

[[[[Adv]]]]: private HandshakeState [[containsRequestedProtocol]] ( String [[requestedProtocol]] ) { for ( IProtocol [[knownProtocol]] : knownProtocols ) { if ( [[knownProtocol]] . acceptProvidedProtocol ( [[requestedProtocol]] ) ) { protocol = [[knownProtocol]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft

[[[[Adv]]]]: private HandshakeState [[zeit]] ( String [[wenceslas]] ) { for ( IProtocol [[shetland]] : knownProtocols ) { if ( [[shetland]] . acceptProvidedProtocol ( [[wenceslas]] ) ) { protocol = [[shetland]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft
--------------------------------------------- Result 467 ---------------------------------------------
Process a binary frame . --> pentru . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameBinary]] ( WebSocketImpl webSocketImpl , Framedata [[frame]] ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , [[frame]] . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame

[[[[Adv]]]]: private void [[pentru]] ( WebSocketImpl webSocketImpl , Framedata [[backdrop]] ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , [[backdrop]] . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame
--------------------------------------------- Result 468 ---------------------------------------------
Logs a runtime exception during websocket message . --> Called when an error occurs during onWebsocketMessage . --> Socre: 1.0

[[[[Adv]]]]: private void [[logRuntimeException]] ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl

[[[[Adv]]]]: private void [[thruster]] ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl
--------------------------------------------- Result 469 ---------------------------------------------
Parses the local port of the given channel . --> [[[FAILED]]]

[[[[Adv]]]]: public static int parseLocalPort ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .

[[[[Adv]]]]: public static int parseLocalPort ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .
--------------------------------------------- Result 470 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 249 / 215 / 6 / 470:  47%|████▋     | 470/1000 [2:25:26<2:44:00, 18.57s/it][Succeeded / Failed / Skipped / Total] 249 / 215 / 6 / 470:  47%|████▋     | 471/1000 [2:25:26<2:43:21, 18.53s/it][Succeeded / Failed / Skipped / Total] 249 / 216 / 6 / 471:  47%|████▋     | 471/1000 [2:25:26<2:43:21, 18.53s/it][Succeeded / Failed / Skipped / Total] 249 / 216 / 6 / 471:  47%|████▋     | 472/1000 [2:25:28<2:42:44, 18.49s/it][Succeeded / Failed / Skipped / Total] 250 / 216 / 6 / 472:  47%|████▋     | 472/1000 [2:25:28<2:42:44, 18.49s/it][Succeeded / Failed / Skipped / Total] 251 / 216 / 6 / 473:  47%|████▋     | 473/1000 [2:25:28<2:42:05, 18.45s/it][Succeeded / Failed / Skipped / Total] 251 / 216 / 6 / 473:  47%|████▋     | 474/1000 [2:25:31<2:41:28, 18.42s/it][Succeeded / Failed / Skipped / Total] 252 / 216 / 6 / 474:  47%|████▋     | 474/1000 [2:25:31<2:41:28, 18.42s/it]Process a close frame and check if it is a continuous frame . --> rancheros . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameContinuousAndNonFin]] ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set

[[[[Adv]]]]: private void [[rancheros]] ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set
--------------------------------------------- Result 471 ---------------------------------------------
Process a text frame . --> [[[FAILED]]]

[[[[Adv]]]]: private void processFrameText ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame

[[[[Adv]]]]: private void processFrameText ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame
--------------------------------------------- Result 472 ---------------------------------------------
Process a continuous frame . --> discriminates between TEXT and BINARY frames --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsFin]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame

[[[[Adv]]]]: private void [[discriminated]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame
--------------------------------------------- Result 473 ---------------------------------------------
Process a close frame . --> damian . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameClosing]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String [[reason]] = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; [[reason]] = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame

[[[[Adv]]]]: private void [[damian]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String [[motivate]] = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; [[motivate]] = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame
--------------------------------------------- Result 474 ---------------------------------------------
Gets the payload from the byte buffer list . --> Sheehan buffer . --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[getPayloadFromByteBufferList]] ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload

[[[[Adv]]]]: private ByteBuffer [[sheehan]] ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload
--------------------------------------------- Result 475 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 253 / 216 / 6 / 475:  48%|████▊     | 475/1000 [2:25:36<2:40:56, 18.39s/it][Succeeded / Failed / Skipped / Total] 253 / 216 / 6 / 475:  48%|████▊     | 476/1000 [2:25:40<2:40:21, 18.36s/it][Succeeded / Failed / Skipped / Total] 254 / 216 / 6 / 476:  48%|████▊     | 476/1000 [2:25:40<2:40:21, 18.36s/it][Succeeded / Failed / Skipped / Total] 255 / 216 / 6 / 477:  48%|████▊     | 477/1000 [2:25:43<2:39:46, 18.33s/it][Succeeded / Failed / Skipped / Total] 255 / 216 / 6 / 477:  48%|████▊     | 478/1000 [2:25:44<2:39:08, 18.29s/it][Succeeded / Failed / Skipped / Total] 256 / 216 / 6 / 478:  48%|████▊     | 478/1000 [2:25:44<2:39:08, 18.29s/it][Succeeded / Failed / Skipped / Total] 257 / 216 / 6 / 479:  48%|████▊     | 479/1000 [2:25:45<2:38:32, 18.26s/it][Succeeded / Failed / Skipped / Total] 257 / 216 / 6 / 479:  48%|████▊     | 480/1000 [2:25:45<2:37:54, 18.22s/it][Succeeded / Failed / Skipped / Total] 258 / 216 / 6 / 480:  48%|████▊     | 480/1000 [2:25:45<2:37:54, 18.22s/it][Succeeded / Failed / Skipped / Total] 259 / 216 / 6 / 481:  48%|████▊     | 481/1000 [2:25:46<2:37:17, 18.18s/it][Succeeded / Failed / Skipped / Total] 259 / 216 / 6 / 481:  48%|████▊     | 482/1000 [2:25:46<2:36:39, 18.15s/it][Succeeded / Failed / Skipped / Total] 260 / 216 / 6 / 482:  48%|████▊     | 482/1000 [2:25:46<2:36:39, 18.15s/it]Returns a FramedataImpl1 for the given opcode . --> Create FramedataImpl1 for given statesman --> Socre: 1.0

[[[[Adv]]]]: public static FramedataImpl1 [[get]] ( Opcode [[opcode]] ) { if ( [[opcode]] == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( [[opcode]] ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode

[[[[Adv]]]]: public static FramedataImpl1 [[earn]] ( Opcode [[statesman]] ) { if ( [[statesman]] == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( [[statesman]] ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode
--------------------------------------------- Result 476 ---------------------------------------------
Checks if the buffer size is too large . If so clears the buffer . --> Sancerre sancerre . --> Socre: 1.0

[[[[Adv]]]]: private void [[checkBufferLimit]] ( ) throws LimitExceededException { long [[totalSize]] = getByteBufferListSize ( ) ; if ( [[totalSize]] > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[totalSize]] ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size

[[[[Adv]]]]: private void [[sancerre]] ( ) throws LimitExceededException { long [[shabbir]] = getByteBufferListSize ( ) ; if ( [[shabbir]] > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[shabbir]] ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size
--------------------------------------------- Result 477 ---------------------------------------------
Translate HTTP client handshake line to handshake builder . --> Reuven HandshakeBuilder . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpClient]] ( String [ ] [[firstLineTokens]] , String [[line]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client

[[[[Adv]]]]: private static HandshakeBuilder [[reuven]] ( String [ ] [[alphonso]] , String [[row]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client
--------------------------------------------- Result 478 ---------------------------------------------
Decodes data from the socket buffer . --> Process a keyed message . --> Socre: 1.0

[[[[Adv]]]]: public void [[decode]] ( ByteBuffer [[socketBuffer]] ) { assert ( [[socketBuffer]] . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , [[socketBuffer]] . remaining ( ) , ( [[socketBuffer]] . remaining ( ) > 1000 ? "too big to display" : new String ( [[socketBuffer]] . array ( ) , [[socketBuffer]] . position ( ) , [[socketBuffer]] . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( [[socketBuffer]] ) ; } } else { if ( decodeHandshake ( [[socketBuffer]] ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != [[socketBuffer]] . hasRemaining ( ) || ! [[socketBuffer]] . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer

[[[[Adv]]]]: public void [[keyed]] ( ByteBuffer [[voir]] ) { assert ( [[voir]] . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , [[voir]] . remaining ( ) , ( [[voir]] . remaining ( ) > 1000 ? "too big to display" : new String ( [[voir]] . array ( ) , [[voir]] . position ( ) , [[voir]] . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( [[voir]] ) ; } } else { if ( decodeHandshake ( [[voir]] ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != [[voir]] . hasRemaining ( ) || ! [[voir]] . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer
--------------------------------------------- Result 479 ---------------------------------------------
Check the packet size for a single frame . --> Savoir savoir . --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckPacketSize]] ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size

[[[[Adv]]]]: private void [[savoir]] ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size
--------------------------------------------- Result 480 ---------------------------------------------
Closes the connection due to a wrong handshake . --> Handles a revved request . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToWrongHandshake]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct

[[[[Adv]]]]: private void [[revved]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct
--------------------------------------------- Result 481 ---------------------------------------------
Translates an HTTP handshake line into a handshake builder . --> Creates a new HandshakeBuilder with bagley and piping . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpServer]] ( String [ ] [[firstLineTokens]] , String [[line]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server

[[[[Adv]]]]: private static HandshakeBuilder [[flring]] ( String [ ] [[bagley]] , String [[piping]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server
--------------------------------------------- Result 482 ---------------------------------------------
Closes the connection due to an internal server error . --> ó . ó --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToInternalServerError]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException

[[[[Adv]]]]: private void [[ó]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException
--------------------------------------------- Result 483 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 261 / 216 / 6 / 483:  48%|████▊     | 483/1000 [2:25:51<2:36:07, 18.12s/it][Succeeded / Failed / Skipped / Total] 261 / 216 / 6 / 483:  48%|████▊     | 484/1000 [2:25:55<2:35:34, 18.09s/it][Succeeded / Failed / Skipped / Total] 262 / 216 / 6 / 484:  48%|████▊     | 484/1000 [2:25:55<2:35:34, 18.09s/it][Succeeded / Failed / Skipped / Total] 262 / 217 / 6 / 485:  48%|████▊     | 485/1000 [2:26:05<2:35:07, 18.07s/it][Succeeded / Failed / Skipped / Total] 262 / 217 / 6 / 485:  49%|████▊     | 486/1000 [2:26:06<2:34:31, 18.04s/it][Succeeded / Failed / Skipped / Total] 263 / 217 / 6 / 486:  49%|████▊     | 486/1000 [2:26:06<2:34:31, 18.04s/it][Succeeded / Failed / Skipped / Total] 263 / 217 / 6 / 486:  49%|████▊     | 487/1000 [2:26:09<2:33:58, 18.01s/it][Succeeded / Failed / Skipped / Total] 264 / 217 / 6 / 487:  49%|████▊     | 487/1000 [2:26:09<2:33:58, 18.01s/it][Succeeded / Failed / Skipped / Total] 264 / 217 / 6 / 487:  49%|████▉     | 488/1000 [2:26:11<2:33:23, 17.97s/it][Succeeded / Failed / Skipped / Total] 265 / 217 / 6 / 488:  49%|████▉     | 488/1000 [2:26:11<2:33:23, 17.97s/it][Succeeded / Failed / Skipped / Total] 265 / 217 / 6 / 488:  49%|████▉     | 489/1000 [2:26:12<2:32:47, 17.94s/it]Returns the total size of the byte buffer list . --> Wednesday wednesday . --> Socre: 1.0

[[[[Adv]]]]: private long [[getByteBufferListSize]] ( ) { long [[totalSize]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[totalSize]] += buffer . limit ( ) ; } } return [[totalSize]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list

[[[[Adv]]]]: private long [[munchausen]] ( ) { long [[wednesday]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[wednesday]] += buffer . limit ( ) ; } } return [[wednesday]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list
--------------------------------------------- Result 484 ---------------------------------------------
Generate the HTTP response according to the given error code . --> Valens dewdrop . --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[generateHttpResponseDueToError]] ( int [[errorCode]] ) { String errorCodeDescription ; switch ( [[errorCode]] ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error

[[[[Adv]]]]: private ByteBuffer [[valens]] ( int [[dewdrop]] ) { String errorCodeDescription ; switch ( [[dewdrop]] ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error
--------------------------------------------- Result 485 ---------------------------------------------
Resets the connection to a new state . --> [[[FAILED]]]

[[[[Adv]]]]: private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect

[[[[Adv]]]]: private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect
--------------------------------------------- Result 486 ---------------------------------------------
Processes a close frame . If the previous continuous frame sequence is not complete throws an exception . --> Sower protocol implementation . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsNotFin]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame

[[[[Adv]]]]: private void [[sower]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame
--------------------------------------------- Result 487 ---------------------------------------------
Sets the connection lost timeout . --> yhey tribbiani --> Socre: 1.0

[[[[Adv]]]]: public void [[setConnectionLostTimeout]] ( int [[connectionLostTimeout]] ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( [[connectionLostTimeout]] ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated

[[[[Adv]]]]: public void [[yhey]] ( int [[tribbiani]] ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( [[tribbiani]] ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated
--------------------------------------------- Result 488 ---------------------------------------------
Stops the connection lost timer . --> Sends a greeting message . --> Socre: 1.0

[[[[Adv]]]]: protected void [[stopConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer

[[[[Adv]]]]: protected void [[greeting]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer
--------------------------------------------- Result 489 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 266 / 217 / 6 / 489:  49%|████▉     | 489/1000 [2:26:12<2:32:47, 17.94s/it][Succeeded / Failed / Skipped / Total] 266 / 217 / 6 / 489:  49%|████▉     | 490/1000 [2:26:13<2:32:12, 17.91s/it][Succeeded / Failed / Skipped / Total] 267 / 217 / 6 / 490:  49%|████▉     | 490/1000 [2:26:13<2:32:12, 17.91s/it][Succeeded / Failed / Skipped / Total] 267 / 217 / 6 / 490:  49%|████▉     | 491/1000 [2:26:14<2:31:36, 17.87s/it][Succeeded / Failed / Skipped / Total] 267 / 218 / 6 / 491:  49%|████▉     | 491/1000 [2:26:14<2:31:36, 17.87s/it][Succeeded / Failed / Skipped / Total] 267 / 218 / 6 / 491:  49%|████▉     | 492/1000 [2:26:15<2:31:00, 17.84s/it][Succeeded / Failed / Skipped / Total] 268 / 218 / 6 / 492:  49%|████▉     | 492/1000 [2:26:15<2:31:00, 17.84s/it][Succeeded / Failed / Skipped / Total] 268 / 218 / 6 / 492:  49%|████▉     | 493/1000 [2:26:16<2:30:25, 17.80s/it][Succeeded / Failed / Skipped / Total] 269 / 218 / 6 / 493:  49%|████▉     | 493/1000 [2:26:16<2:30:25, 17.80s/it][Succeeded / Failed / Skipped / Total] 269 / 218 / 6 / 493:  49%|████▉     | 494/1000 [2:26:20<2:29:53, 17.77s/it]Sends a handshake to the engine . --> Exposed for exploiting WebSocket connection . --> Socre: 1.0

[[[[Adv]]]]: private void [[sendHandshake]] ( ) throws InvalidHandshakeException { String path ; String [[part1]] = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( [[part1]] == null || [[part1]] . length ( ) == 0 ) path = "/" ; else path = [[part1]] ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client [[handshake]] = new HandshakeImpl1Client ( ) ; [[handshake]] . setResourceDescriptor ( path ) ; [[handshake]] . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > [[kv]] : headers . entrySet ( ) ) { [[handshake]] . put ( [[kv]] . getKey ( ) , [[kv]] . getValue ( ) ) ; } } engine . startHandshake ( [[handshake]] ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint

[[[[Adv]]]]: private void [[exploiting]] ( ) throws InvalidHandshakeException { String path ; String [[bunny]] = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( [[bunny]] == null || [[bunny]] . length ( ) == 0 ) path = "/" ; else path = [[bunny]] ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client [[salute]] = new HandshakeImpl1Client ( ) ; [[salute]] . setResourceDescriptor ( path ) ; [[salute]] . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > [[cargoes]] : headers . entrySet ( ) ) { [[salute]] . put ( [[cargoes]] . getKey ( ) , [[cargoes]] . getValue ( ) ) ; } } engine . startHandshake ( [[salute]] ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint
--------------------------------------------- Result 490 ---------------------------------------------
Restarts the timer that detects connections that have been lost . --> Starts processing WebSocket connections . --> Socre: 1.0

[[[[Adv]]]]: private void [[restartConnectionLostTimer]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket [[conn]] : connections ) { executeConnectionLostDetection ( [[conn]] , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter

[[[[Adv]]]]: private void [[processors]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket [[oxen]] : connections ) { executeConnectionLostDetection ( [[oxen]] , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter
--------------------------------------------- Result 491 ---------------------------------------------
Starts the read thread for the WebSocket client . --> [[[FAILED]]]

[[[[Adv]]]]: public void connect ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .

[[[[Adv]]]]: public void connect ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .
--------------------------------------------- Result 492 ---------------------------------------------
Starts the connection lost timer . --> Starts a random websocket . --> Socre: 1.0

[[[[Adv]]]]: protected void [[startConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "[[True]]" == "[[True]]" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer

[[[[Adv]]]]: protected void [[random]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "[[Meaningful]]" == "[[Meaningful]]" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer
--------------------------------------------- Result 493 ---------------------------------------------
Cancel connection lost checker timer . --> Premarital connectionLostChecker . --> Socre: 1.0

[[[[Adv]]]]: private void [[cancelConnectionLostTimer]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "False" != "False" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection

[[[[Adv]]]]: private void [[premarital]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "False" != "False" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection
--------------------------------------------- Result 494 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 270 / 218 / 6 / 494:  49%|████▉     | 494/1000 [2:26:20<2:29:53, 17.77s/it][Succeeded / Failed / Skipped / Total] 270 / 218 / 6 / 494:  50%|████▉     | 495/1000 [2:26:28<2:29:25, 17.75s/it][Succeeded / Failed / Skipped / Total] 271 / 218 / 6 / 495:  50%|████▉     | 495/1000 [2:26:28<2:29:25, 17.75s/it][Succeeded / Failed / Skipped / Total] 271 / 218 / 6 / 495:  50%|████▉     | 496/1000 [2:26:29<2:28:51, 17.72s/it][Succeeded / Failed / Skipped / Total] 272 / 218 / 6 / 496:  50%|████▉     | 496/1000 [2:26:29<2:28:51, 17.72s/it][Succeeded / Failed / Skipped / Total] 272 / 218 / 6 / 496:  50%|████▉     | 497/1000 [2:26:30<2:28:16, 17.69s/it][Succeeded / Failed / Skipped / Total] 273 / 218 / 6 / 497:  50%|████▉     | 497/1000 [2:26:30<2:28:16, 17.69s/it][Succeeded / Failed / Skipped / Total] 273 / 218 / 6 / 497:  50%|████▉     | 498/1000 [2:26:33<2:27:43, 17.66s/it][Succeeded / Failed / Skipped / Total] 274 / 218 / 6 / 498:  50%|████▉     | 498/1000 [2:26:33<2:27:43, 17.66s/it][Succeeded / Failed / Skipped / Total] 274 / 218 / 6 / 498:  50%|████▉     | 499/1000 [2:26:33<2:27:09, 17.62s/it]Executes the connection lost detection . --> pragmatist . --> Socre: 1.0

[[[[Adv]]]]: private void [[executeConnectionLostDetection]] ( WebSocket [[webSocket]] , long [[minimumPongTime]] ) { if ( ! ( [[webSocket]] instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) [[webSocket]] ; if ( webSocketImpl . getLastPong ( ) < [[minimumPongTime]] ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping

[[[[Adv]]]]: private void [[pragmatist]] ( WebSocket [[meenakshi]] , long [[shuichi]] ) { if ( ! ( [[meenakshi]] instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) [[meenakshi]] ; if ( webSocketImpl . getLastPong ( ) < [[shuichi]] ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping
--------------------------------------------- Result 495 ---------------------------------------------
Returns the port of the connection . --> pièce . --> Socre: 1.0

[[[[Adv]]]]: private int [[getPort]] ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return port ; }
[[[[Nl]]]]: Extract the specified port

[[[[Adv]]]]: private int [[pièce]] ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return port ; }
[[[[Nl]]]]: Extract the specified port
--------------------------------------------- Result 496 ---------------------------------------------
On websocket handshake received as server . --> Create a medevac server handshake builder --> Socre: 1.0

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[onWebsocketHandshakeReceivedAsServer]] ( WebSocket [[conn]] , Draft [[draft]] , ClientHandshake [[request]] ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[medevac]] ( WebSocket [[terriers]] , Draft [[projects]] , ClientHandshake [[requisition]] ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .
--------------------------------------------- Result 497 ---------------------------------------------
Read additional data from the socket . --> Loops through the queue of middletowns . --> Socre: 1.0

[[[[Adv]]]]: private void [[doAdditionalRead]] ( ) throws InterruptedException , IOException { WebSocketImpl [[conn]] ; while ( ! iqueue . isEmpty ( ) ) { [[conn]] = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) [[conn]] . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , [[conn]] , c ) ) iqueue . add ( [[conn]] ) ; if ( buf . hasRemaining ( ) ) { [[conn]] . inQueue . put ( buf ) ; queue ( [[conn]] ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read

[[[[Adv]]]]: private void [[grosso]] ( ) throws InterruptedException , IOException { WebSocketImpl [[middletown]] ; while ( ! iqueue . isEmpty ( ) ) { [[middletown]] = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) [[middletown]] . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , [[middletown]] , c ) ) iqueue . add ( [[middletown]] ) ; if ( buf . hasRemaining ( ) ) { [[middletown]] . inQueue . put ( buf ) ; queue ( [[middletown]] ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read
--------------------------------------------- Result 498 ---------------------------------------------
Accepts a websocket connection . --> Connects to the server and connects to the server . --> Socre: 1.0

[[[[Adv]]]]: private void [[doAccept]] ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "[[False]]" != "[[False]]" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl [[w]] = wsf . createWebSocket ( this , drafts ) ; [[w]] . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , [[w]] ) ) ; try { [[w]] . setChannel ( wsf . wrapChannel ( channel , [[w]] . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( [[w]] ) ; } catch ( IOException ex ) { if ( [[w]] . getSelectionKey ( ) != null ) [[w]] . getSelectionKey ( ) . cancel ( ) ; handleIOException ( [[w]] . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation

[[[[Adv]]]]: private void [[brigantine]] ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "[[Misguided]]" != "[[Misguided]]" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl [[pp]] = wsf . createWebSocket ( this , drafts ) ; [[pp]] . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , [[pp]] ) ) ; try { [[pp]] . setChannel ( wsf . wrapChannel ( channel , [[pp]] . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( [[pp]] ) ; } catch ( IOException ex ) { if ( [[pp]] . getSelectionKey ( ) != null ) [[pp]] . getSelectionKey ( ) . cancel ( ) ; handleIOException ( [[pp]] . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation
--------------------------------------------- Result 499 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 275 / 218 / 6 / 499:  50%|████▉     | 499/1000 [2:26:33<2:27:09, 17.62s/it][Succeeded / Failed / Skipped / Total] 275 / 218 / 6 / 499:  50%|█████     | 500/1000 [2:26:34<2:26:34, 17.59s/it][Succeeded / Failed / Skipped / Total] 275 / 218 / 7 / 500:  50%|█████     | 500/1000 [2:26:34<2:26:34, 17.59s/it][Succeeded / Failed / Skipped / Total] 275 / 218 / 7 / 500:  50%|█████     | 501/1000 [2:26:36<2:26:01, 17.56s/it][Succeeded / Failed / Skipped / Total] 276 / 218 / 7 / 501:  50%|█████     | 501/1000 [2:26:36<2:26:01, 17.56s/it][Succeeded / Failed / Skipped / Total] 276 / 218 / 7 / 501:  50%|█████     | 502/1000 [2:26:37<2:25:27, 17.52s/it][Succeeded / Failed / Skipped / Total] 276 / 218 / 8 / 502:  50%|█████     | 502/1000 [2:26:37<2:25:27, 17.52s/it][Succeeded / Failed / Skipped / Total] 276 / 218 / 8 / 502:  50%|█████     | 503/1000 [2:26:38<2:24:53, 17.49s/it][Succeeded / Failed / Skipped / Total] 277 / 218 / 8 / 503:  50%|█████     | 503/1000 [2:26:38<2:24:53, 17.49s/it][Succeeded / Failed / Skipped / Total] 277 / 218 / 8 / 503:  50%|█████     | 504/1000 [2:26:39<2:24:20, 17.46s/it][Succeeded / Failed / Skipped / Total] 278 / 218 / 8 / 504:  50%|█████     | 504/1000 [2:26:39<2:24:20, 17.46s/it][Succeeded / Failed / Skipped / Total] 278 / 218 / 8 / 504:  50%|█████     | 505/1000 [2:26:43<2:23:49, 17.43s/it][Succeeded / Failed / Skipped / Total] 279 / 218 / 8 / 505:  50%|█████     | 505/1000 [2:26:43<2:23:49, 17.43s/it][Succeeded / Failed / Skipped / Total] 279 / 218 / 8 / 505:  51%|█████     | 506/1000 [2:26:53<2:23:24, 17.42s/it]Do a read . --> Reads data from the socket --> Socre: 1.0

[[[[Adv]]]]: private boolean doRead ( SelectionKey key , Iterator < SelectionKey > [[i]] ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; [[i]] . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation

[[[[Adv]]]]: private boolean doRead ( SelectionKey key , Iterator < SelectionKey > [[it]] ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; [[it]] . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation
--------------------------------------------- Result 500 ---------------------------------------------
Writes data to the socket . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doWrite ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation
--------------------------------------------- Result 501 ---------------------------------------------
Setup selector and server thread . --> Start spreading . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doSetupSelectorAndServerThread]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "[[False]]" != "[[False]]" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker [[ex]] : decoders ) { [[ex]] . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , [[ex]] ) ; return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings

[[[[Adv]]]]: private boolean [[spreading]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "[[Inaccurate]]" != "[[Inaccurate]]" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker [[precedents]] : decoders ) { [[precedents]] . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , [[precedents]] ) ; return "[[Inaccurate]]" != "[[Inaccurate]]" ; } return "[[Faithfully]]" == "[[Faithfully]]" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings
--------------------------------------------- Result 502 ---------------------------------------------
Ensure single thread . --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once
--------------------------------------------- Result 503 ---------------------------------------------
Do server shutdown . --> Stops the faxing . --> Socre: 1.0

[[[[Adv]]]]: private void [[doServerShutdown]] ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown

[[[[Adv]]]]: private void [[faxing]] ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown
--------------------------------------------- Result 504 ---------------------------------------------
Returns the socket associated with the given websocket connection . --> Handi taurus . --> Socre: 1.0

[[[[Adv]]]]: private Socket [[getSocket]] ( WebSocket [[conn]] ) { WebSocketImpl [[impl]] = ( WebSocketImpl ) [[conn]] ; return ( ( SocketChannel ) [[impl]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection

[[[[Adv]]]]: private Socket [[handi]] ( WebSocket [[taurus]] ) { WebSocketImpl [[certain]] = ( WebSocketImpl ) [[taurus]] ; return ( ( SocketChannel ) [[certain]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection
--------------------------------------------- Result 505 ---------------------------------------------
Broadcast a message to a collection of clients . --> Publicizes the given reality and clients . --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( byte [ ] [[data]] , Collection < WebSocket > clients ) { if ( [[data]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } [[broadcast]] ( ByteBuffer . wrap ( [[data]] ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections

[[[[Adv]]]]: public void [[publicized]] ( byte [ ] [[realities]] , Collection < WebSocket > clients ) { if ( [[realities]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } [[publicized]] ( ByteBuffer . wrap ( [[realities]] ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections
--------------------------------------------- Result 506 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 280 / 218 / 8 / 506:  51%|█████     | 506/1000 [2:26:53<2:23:24, 17.42s/it][Succeeded / Failed / Skipped / Total] 280 / 218 / 8 / 506:  51%|█████     | 507/1000 [2:26:56<2:22:53, 17.39s/it][Succeeded / Failed / Skipped / Total] 281 / 218 / 8 / 507:  51%|█████     | 507/1000 [2:26:56<2:22:53, 17.39s/it][Succeeded / Failed / Skipped / Total] 281 / 218 / 8 / 507:  51%|█████     | 508/1000 [2:27:16<2:22:38, 17.39s/it][Succeeded / Failed / Skipped / Total] 281 / 219 / 8 / 508:  51%|█████     | 508/1000 [2:27:16<2:22:38, 17.39s/it][Succeeded / Failed / Skipped / Total] 281 / 219 / 8 / 508:  51%|█████     | 509/1000 [2:27:19<2:22:06, 17.37s/it][Succeeded / Failed / Skipped / Total] 282 / 219 / 8 / 509:  51%|█████     | 509/1000 [2:27:19<2:22:06, 17.37s/it][Succeeded / Failed / Skipped / Total] 282 / 219 / 8 / 509:  51%|█████     | 510/1000 [2:27:38<2:21:51, 17.37s/it][Succeeded / Failed / Skipped / Total] 282 / 220 / 8 / 510:  51%|█████     | 510/1000 [2:27:38<2:21:51, 17.37s/it][Succeeded / Failed / Skipped / Total] 282 / 220 / 8 / 510:  51%|█████     | 511/1000 [2:27:49<2:21:27, 17.36s/it][Succeeded / Failed / Skipped / Total] 282 / 221 / 8 / 511:  51%|█████     | 511/1000 [2:27:49<2:21:27, 17.36s/it][Succeeded / Failed / Skipped / Total] 282 / 221 / 8 / 511:  51%|█████     | 512/1000 [2:28:12<2:21:15, 17.37s/it][Succeeded / Failed / Skipped / Total] 282 / 222 / 8 / 512:  51%|█████     | 512/1000 [2:28:12<2:21:15, 17.37s/it][Succeeded / Failed / Skipped / Total] 282 / 222 / 8 / 512:  51%|█████▏    | 513/1000 [2:28:15<2:20:44, 17.34s/it]Broadcasts a text message to a collection of clients . --> Broadcast diffusion events . --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( String [[text]] , Collection < WebSocket > [[clients]] ) { if ( [[text]] == null || [[clients]] == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[text]] , [[clients]] ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections

[[[[Adv]]]]: public void [[diffusion]] ( String [[editions]] , Collection < WebSocket > [[subscription]] ) { if ( [[editions]] == null || [[subscription]] == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[editions]] , [[subscription]] ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections
--------------------------------------------- Result 507 ---------------------------------------------
Broadcast data to clients . --> Collects data from a collection of clients . --> Socre: 1.0

[[[[Adv]]]]: private void [[doBroadcast]] ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time

[[[[Adv]]]]: private void [[collections]] ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time
--------------------------------------------- Result 508 ---------------------------------------------
Fills the draft frames if it doesn t already exist . --> [[[FAILED]]]

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast
--------------------------------------------- Result 509 ---------------------------------------------
Transfers the source byte buffer to the destination byte buffer returning the number of bytes transferred . --> Copies the font into the destination . --> Socre: 1.0

[[[[Adv]]]]: public static int [[transferByteBuffer]] ( ByteBuffer [[source]] , ByteBuffer dest ) { if ( [[source]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[source]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; [[source]] . limit ( limit ) ; dest . put ( [[source]] ) ; return limit ; } else { dest . put ( [[source]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer

[[[[Adv]]]]: public static int [[masaru]] ( ByteBuffer [[font]] , ByteBuffer dest ) { if ( [[font]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[font]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; [[font]] . limit ( limit ) ; dest . put ( [[font]] ) ; return limit ; } else { dest . put ( [[font]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer
--------------------------------------------- Result 510 ---------------------------------------------
Starts the API . --> [[[FAILED]]]

[[[[Adv]]]]: public JPAApi start ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .

[[[[Adv]]]]: public JPAApi start ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .
--------------------------------------------- Result 511 ---------------------------------------------
Parses a socket address to a host IP address . --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseSocketAddressToHostIp ( SocketAddress socketAddress ) { final InetSocketAddress addrs = ( InetSocketAddress ) socketAddress ; if ( addrs != null ) { InetAddress addr = addrs . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .

[[[[Adv]]]]: public static String parseSocketAddressToHostIp ( SocketAddress socketAddress ) { final InetSocketAddress addrs = ( InetSocketAddress ) socketAddress ; if ( addrs != null ) { InetAddress addr = addrs . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .
--------------------------------------------- Result 512 ---------------------------------------------
Registers a custom serializer . --> [[[FAILED]]]

[[[[Adv]]]]: public static void registerCustomSerializer ( String className , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( className , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .

[[[[Adv]]]]: public static void registerCustomSerializer ( String className , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( className , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .
--------------------------------------------- Result 513 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 283 / 222 / 8 / 513:  51%|█████▏    | 513/1000 [2:28:15<2:20:44, 17.34s/it][Succeeded / Failed / Skipped / Total] 283 / 222 / 8 / 513:  51%|█████▏    | 514/1000 [2:28:21<2:20:16, 17.32s/it][Succeeded / Failed / Skipped / Total] 283 / 223 / 8 / 514:  51%|█████▏    | 514/1000 [2:28:21<2:20:16, 17.32s/it][Succeeded / Failed / Skipped / Total] 283 / 223 / 8 / 514:  52%|█████▏    | 515/1000 [2:28:29<2:19:50, 17.30s/it][Succeeded / Failed / Skipped / Total] 284 / 223 / 8 / 515:  52%|█████▏    | 515/1000 [2:28:29<2:19:50, 17.30s/it][Succeeded / Failed / Skipped / Total] 284 / 223 / 8 / 515:  52%|█████▏    | 516/1000 [2:29:08<2:19:53, 17.34s/it][Succeeded / Failed / Skipped / Total] 285 / 223 / 8 / 516:  52%|█████▏    | 516/1000 [2:29:08<2:19:53, 17.34s/it][Succeeded / Failed / Skipped / Total] 285 / 223 / 8 / 516:  52%|█████▏    | 517/1000 [2:29:19<2:19:30, 17.33s/it][Succeeded / Failed / Skipped / Total] 286 / 223 / 8 / 517:  52%|█████▏    | 517/1000 [2:29:19<2:19:30, 17.33s/it][Succeeded / Failed / Skipped / Total] 286 / 223 / 8 / 517:  52%|█████▏    | 518/1000 [2:29:25<2:19:02, 17.31s/it][Succeeded / Failed / Skipped / Total] 286 / 224 / 8 / 518:  52%|█████▏    | 518/1000 [2:29:25<2:19:02, 17.31s/it][Succeeded / Failed / Skipped / Total] 286 / 224 / 8 / 518:  52%|█████▏    | 519/1000 [2:29:46<2:18:48, 17.31s/it][Succeeded / Failed / Skipped / Total] 286 / 225 / 8 / 519:  52%|█████▏    | 519/1000 [2:29:46<2:18:48, 17.31s/it][Succeeded / Failed / Skipped / Total] 286 / 225 / 8 / 519:  52%|█████▏    | 520/1000 [2:29:59<2:18:27, 17.31s/it][Succeeded / Failed / Skipped / Total] 286 / 226 / 8 / 520:  52%|█████▏    | 520/1000 [2:29:59<2:18:27, 17.31s/it][Succeeded / Failed / Skipped / Total] 286 / 226 / 8 / 520:  52%|█████▏    | 521/1000 [2:30:15<2:18:08, 17.30s/it][Succeeded / Failed / Skipped / Total] 287 / 226 / 8 / 521:  52%|█████▏    | 521/1000 [2:30:15<2:18:08, 17.30s/it][Succeeded / Failed / Skipped / Total] 287 / 226 / 8 / 521:  52%|█████▏    | 522/1000 [2:30:32<2:17:51, 17.30s/it]Convert the given arguments to a scala buffer . --> Longstocking method . --> Socre: 1.0

[[[[Adv]]]]: private static Seq < Object > [[convertArgsToScalaBuffer]] ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary

[[[[Adv]]]]: private static Seq < Object > [[longstocking]] ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary
--------------------------------------------- Result 514 ---------------------------------------------
Register a custom serializer for a command code . --> [[[FAILED]]]

[[[[Adv]]]]: public static void registerCustomSerializer ( CommandCode code , CustomSerializer serializer ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .

[[[[Adv]]]]: public static void registerCustomSerializer ( CommandCode code , CustomSerializer serializer ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .
--------------------------------------------- Result 515 ---------------------------------------------
Executes the given consumer in a transaction . --> Methode d ajour d un Consumer --> Socre: 1.0

[[[[Adv]]]]: public void [[withTransaction]] ( Consumer < EntityManager > [[block]] ) { [[withTransaction]] ( em -> { [[block]] . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .

[[[[Adv]]]]: public void [[chéri]] ( Consumer < EntityManager > [[impede]] ) { [[chéri]] ( em -> { [[impede]] . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .
--------------------------------------------- Result 516 ---------------------------------------------
Wraps the given arguments to a list if they are not already . --> lamplight an array of sockets --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[wrapArgsToListIfNeeded]] ( final T ... [[args]] ) { List < T > [[out]] ; if ( [[args]] != null && [[args]] . length == 1 && [[args]] [ 0 ] instanceof List ) { [[out]] = ( List < T > ) [[args]] [ 0 ] ; } else { [[out]] = Arrays . asList ( [[args]] ) ; } return [[out]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[lamplight]] ( final T ... [[padua]] ) { List < T > [[socket]] ; if ( [[padua]] != null && [[padua]] . length == 1 && [[padua]] [ 0 ] instanceof List ) { [[socket]] = ( List < T > ) [[padua]] [ 0 ] ; } else { [[socket]] = Arrays . asList ( [[padua]] ) ; } return [[socket]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .
--------------------------------------------- Result 517 ---------------------------------------------
Returns the localized message for the given language . --> Learn a language from a list of basic messages --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang lang , List < String > [[keys]] , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( [[keys]] ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .

[[[[Adv]]]]: public String [[learn]] ( play . api . i18n . Lang lang , List < String > [[basic]] , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( [[basic]] ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .
--------------------------------------------- Result 518 ---------------------------------------------
Sends a ping frame . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void onWebsocketPing ( WebSocket conn , Framedata f ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .

[[[[Adv]]]]: @ Override public void onWebsocketPing ( WebSocket conn , Framedata f ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .
--------------------------------------------- Result 519 ---------------------------------------------
Sends a string to the server . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void send ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; send ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .

[[[[Adv]]]]: @ Override public void send ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; send ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .
--------------------------------------------- Result 520 ---------------------------------------------
Stops the timer and waits for it to finish . --> [[[FAILED]]]

[[[[Adv]]]]: public void stop ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "False" != "False" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .

[[[[Adv]]]]: public void stop ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "False" != "False" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .
--------------------------------------------- Result 521 ---------------------------------------------
Sets the language of the result . --> Kawamura - lange - lange - completion --> Socre: 1.0

[[[[Adv]]]]: public Result [[setLang]] ( Result [[result]] , Lang [[lang]] ) { return messages . setLang ( [[result]] . asScala ( ) , [[lang]] ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .

[[[[Adv]]]]: public Result [[kawamura]] ( Result [[completion]] , Lang [[lange]] ) { return messages . setLang ( [[completion]] . asScala ( ) , [[lange]] ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .
--------------------------------------------- Result 522 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 287 / 227 / 8 / 522:  52%|█████▏    | 522/1000 [2:30:32<2:17:51, 17.30s/it][Succeeded / Failed / Skipped / Total] 287 / 227 / 8 / 522:  52%|█████▏    | 523/1000 [2:30:34<2:17:19, 17.27s/it][Succeeded / Failed / Skipped / Total] 288 / 227 / 8 / 523:  52%|█████▏    | 523/1000 [2:30:34<2:17:19, 17.27s/it][Succeeded / Failed / Skipped / Total] 288 / 227 / 8 / 523:  52%|█████▏    | 524/1000 [2:31:00<2:17:10, 17.29s/it][Succeeded / Failed / Skipped / Total] 289 / 227 / 8 / 524:  52%|█████▏    | 524/1000 [2:31:00<2:17:10, 17.29s/it][Succeeded / Failed / Skipped / Total] 289 / 227 / 8 / 524:  52%|█████▎    | 525/1000 [2:31:24<2:16:59, 17.30s/it][Succeeded / Failed / Skipped / Total] 290 / 227 / 8 / 525:  52%|█████▎    | 525/1000 [2:31:24<2:16:59, 17.30s/it][Succeeded / Failed / Skipped / Total] 290 / 227 / 8 / 525:  53%|█████▎    | 526/1000 [2:31:33<2:16:34, 17.29s/it][Succeeded / Failed / Skipped / Total] 291 / 227 / 8 / 526:  53%|█████▎    | 526/1000 [2:31:33<2:16:34, 17.29s/it][Succeeded / Failed / Skipped / Total] 291 / 227 / 8 / 526:  53%|█████▎    | 527/1000 [2:31:55<2:16:21, 17.30s/it][Succeeded / Failed / Skipped / Total] 291 / 228 / 8 / 527:  53%|█████▎    | 527/1000 [2:31:55<2:16:21, 17.30s/it][Succeeded / Failed / Skipped / Total] 291 / 228 / 8 / 527:  53%|█████▎    | 528/1000 [2:31:58<2:15:51, 17.27s/it][Succeeded / Failed / Skipped / Total] 292 / 228 / 8 / 528:  53%|█████▎    | 528/1000 [2:31:58<2:15:51, 17.27s/it][Succeeded / Failed / Skipped / Total] 292 / 228 / 8 / 528:  53%|█████▎    | 529/1000 [2:31:59<2:15:19, 17.24s/it][Succeeded / Failed / Skipped / Total] 293 / 228 / 8 / 529:  53%|█████▎    | 529/1000 [2:31:59<2:15:19, 17.24s/it][Succeeded / Failed / Skipped / Total] 293 / 228 / 8 / 529:  53%|█████▎    | 530/1000 [2:32:21<2:15:06, 17.25s/it][Succeeded / Failed / Skipped / Total] 293 / 229 / 8 / 530:  53%|█████▎    | 530/1000 [2:32:21<2:15:06, 17.25s/it][Succeeded / Failed / Skipped / Total] 293 / 229 / 8 / 530:  53%|█████▎    | 531/1000 [2:32:24<2:14:36, 17.22s/it][Succeeded / Failed / Skipped / Total] 294 / 229 / 8 / 531:  53%|█████▎    | 531/1000 [2:32:24<2:14:36, 17.22s/it][Succeeded / Failed / Skipped / Total] 294 / 229 / 8 / 531:  53%|█████▎    | 532/1000 [2:32:25<2:14:05, 17.19s/it][Succeeded / Failed / Skipped / Total] 295 / 229 / 8 / 532:  53%|█████▎    | 532/1000 [2:32:25<2:14:05, 17.19s/it][Succeeded / Failed / Skipped / Total] 295 / 229 / 8 / 532:  53%|█████▎    | 533/1000 [2:32:41<2:13:46, 17.19s/it][Succeeded / Failed / Skipped / Total] 296 / 229 / 8 / 533:  53%|█████▎    | 533/1000 [2:32:41<2:13:46, 17.19s/it][Succeeded / Failed / Skipped / Total] 296 / 229 / 8 / 533:  53%|█████▎    | 534/1000 [2:32:43<2:13:16, 17.16s/it]Returns the port of the server . --> [[[FAILED]]]

[[[[Adv]]]]: public int getPort ( ) { int port = getAddress ( ) . getPort ( ) ; if ( port == 0 && server != null ) { port = server . socket ( ) . getLocalPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port number that this server listens on .

[[[[Adv]]]]: public int getPort ( ) { int port = getAddress ( ) . getPort ( ) ; if ( port == 0 && server != null ) { port = server . socket ( ) . getLocalPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port number that this server listens on .
--------------------------------------------- Result 523 ---------------------------------------------
Create a new instance of ReplaceME0 . --> Create a new player that is marked as PRESSED --> Socre: 1.0

[[[[Adv]]]]: public final Self [[REPLACEME0]] ( play . api . inject . Binding < ? > ... [[REPLACEME0]] ) { return [[REPLACEME0]] ( Guiceable . bindings ( [[REPLACEME0]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .

[[[[Adv]]]]: public final Self [[PRESSED]] ( play . api . inject . Binding < ? > ... [[PRESSED]] ) { return [[PRESSED]] ( Guiceable . bindings ( [[PRESSED]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .
--------------------------------------------- Result 524 ---------------------------------------------
Returns the localized message for the given key and arguments . --> Learn the language using the given transcendent and handcuffs --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang lang , String [[key]] , Object ... [[args]] ) { Seq < Object > [[scalaArgs]] = convertArgsToScalaBuffer ( [[args]] ) ; return messages . apply ( [[key]] , [[scalaArgs]] , lang ) ; }
[[[[Nl]]]]: Translates a message .

[[[[Adv]]]]: public String [[learn]] ( play . api . i18n . Lang lang , String [[transcendent]] , Object ... [[handcuff]] ) { Seq < Object > [[natori]] = convertArgsToScalaBuffer ( [[handcuff]] ) ; return messages . apply ( [[transcendent]] , [[natori]] , lang ) ; }
[[[[Nl]]]]: Translates a message .
--------------------------------------------- Result 525 ---------------------------------------------
Sets the overrides of this instance with the specified modules . --> Create a ficar from a parcel --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Module ... [[modules]] ) { return [[overrides]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .

[[[[Adv]]]]: public final Self [[ficar]] ( play . api . inject . Module ... [[parcel]] ) { return [[ficar]] ( Guiceable . [[parcel]] ( [[parcel]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .
--------------------------------------------- Result 526 ---------------------------------------------
Overrides this instance with the given bindings . --> Add an outcry with the given fixings --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Binding < ? > ... [[bindings]] ) { return [[overrides]] ( Guiceable . [[bindings]] ( [[bindings]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .

[[[[Adv]]]]: public final Self [[outcry]] ( play . api . inject . Binding < ? > ... [[fixings]] ) { return [[outcry]] ( Guiceable . [[fixings]] ( [[fixings]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .
--------------------------------------------- Result 527 ---------------------------------------------
Returns an EntityManager with the given name . --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager em ( String name ) { EntityManagerFactory emf = emfs . get ( name ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .

[[[[Adv]]]]: public EntityManager em ( String name ) { EntityManagerFactory emf = emfs . get ( name ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .
--------------------------------------------- Result 528 ---------------------------------------------
Disable the given module classes . --> Quench the specified chaturs --> Socre: 1.0

[[[[Adv]]]]: public final Self [[disable]] ( Class < ? > ... [[moduleClasses]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[moduleClasses]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .

[[[[Adv]]]]: public final Self [[quench]] ( Class < ? > ... [[chatur]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[chatur]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .
--------------------------------------------- Result 529 ---------------------------------------------
Returns the preferred messages for the given request . --> electrada la pretituario --> Socre: 1.0

[[[[Adv]]]]: public Messages [[preferred]] ( Http . RequestHeader [[request]] ) { play . api . i18n . Messages [[msgs]] = messages . preferred ( [[request]] ) ; return new MessagesImpl ( new Lang ( [[msgs]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .

[[[[Adv]]]]: public Messages [[elect]] ( Http . RequestHeader [[claim]] ) { play . api . i18n . Messages [[pretoria]] = messages . preferred ( [[claim]] ) ; return new MessagesImpl ( new Lang ( [[pretoria]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .
--------------------------------------------- Result 530 ---------------------------------------------
Returns a copy of this binding in the specified scope . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .

[[[[Adv]]]]: public < A extends Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .
--------------------------------------------- Result 531 ---------------------------------------------
Creates a tuple from two values . --> Creates an Apartheid from two values . --> Socre: 1.0

[[[[Adv]]]]: public static < A , B > [[Tuple]] < A , B > [[Tuple]] ( A [[a]] , B b ) { return new [[Tuple]] < A , B > ( [[a]] , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B

[[[[Adv]]]]: public static < A , B > [[Apartheid]] < A , B > [[Apartheid]] ( A [[both]] , B b ) { return new [[Apartheid]] < A , B > ( [[both]] , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B
--------------------------------------------- Result 532 ---------------------------------------------
Returns true if the key is defined at the given location --> stealin - stealin - stealin --> Socre: 1.0

[[[[Adv]]]]: public Boolean [[isDefinedAt]] ( play . api . i18n . Lang [[lang]] , String [[key]] ) { return messages . isDefinedAt ( [[key]] , [[lang]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .

[[[[Adv]]]]: public Boolean [[stealin]] ( play . api . i18n . Lang [[longtime]] , String [[cardinal]] ) { return messages . isDefinedAt ( [[cardinal]] , [[longtime]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .
--------------------------------------------- Result 533 ---------------------------------------------
Creates a tuple with five elements . --> Static factory method for Mortal . --> Socre: 1.0

[[[[Adv]]]]: public static < A , B , C , D , E > [[Tuple5]] < A , B , C , D , E > [[Tuple5]] ( A [[a]] , B b , C c , D d , E [[e]] ) { return new [[Tuple5]] < A , B , C , D , E > ( [[a]] , b , c , d , [[e]] ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E

[[[[Adv]]]]: public static < A , B , C , D , E > [[Mortal]] < A , B , C , D , E > [[Mortal]] ( A [[another]] , B b , C c , D d , E [[walker]] ) { return new [[Mortal]] < A , B , C , D , E > ( [[another]] , b , c , d , [[walker]] ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E
--------------------------------------------- Result 534 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 297 / 229 / 8 / 534:  53%|█████▎    | 534/1000 [2:32:43<2:13:16, 17.16s/it][Succeeded / Failed / Skipped / Total] 297 / 229 / 8 / 534:  54%|█████▎    | 535/1000 [2:32:52<2:12:52, 17.14s/it][Succeeded / Failed / Skipped / Total] 298 / 229 / 8 / 535:  54%|█████▎    | 535/1000 [2:32:52<2:12:52, 17.14s/it][Succeeded / Failed / Skipped / Total] 298 / 229 / 8 / 535:  54%|█████▎    | 536/1000 [2:32:54<2:12:22, 17.12s/it][Succeeded / Failed / Skipped / Total] 299 / 229 / 8 / 536:  54%|█████▎    | 536/1000 [2:32:54<2:12:22, 17.12s/it][Succeeded / Failed / Skipped / Total] 299 / 229 / 8 / 536:  54%|█████▎    | 537/1000 [2:33:55<2:12:42, 17.20s/it][Succeeded / Failed / Skipped / Total] 299 / 230 / 8 / 537:  54%|█████▎    | 537/1000 [2:33:55<2:12:42, 17.20s/it][Succeeded / Failed / Skipped / Total] 299 / 230 / 8 / 537:  54%|█████▍    | 538/1000 [2:34:02<2:12:17, 17.18s/it][Succeeded / Failed / Skipped / Total] 300 / 230 / 8 / 538:  54%|█████▍    | 538/1000 [2:34:02<2:12:17, 17.18s/it][Succeeded / Failed / Skipped / Total] 300 / 230 / 8 / 538:  54%|█████▍    | 539/1000 [2:34:40<2:12:17, 17.22s/it][Succeeded / Failed / Skipped / Total] 300 / 231 / 8 / 539:  54%|█████▍    | 539/1000 [2:34:40<2:12:17, 17.22s/it][Succeeded / Failed / Skipped / Total] 300 / 231 / 8 / 539:  54%|█████▍    | 540/1000 [2:34:45<2:11:49, 17.20s/it][Succeeded / Failed / Skipped / Total] 301 / 231 / 8 / 540:  54%|█████▍    | 540/1000 [2:34:45<2:11:49, 17.20s/it][Succeeded / Failed / Skipped / Total] 301 / 231 / 8 / 540:  54%|█████▍    | 541/1000 [2:34:48<2:11:20, 17.17s/it][Succeeded / Failed / Skipped / Total] 302 / 231 / 8 / 541:  54%|█████▍    | 541/1000 [2:34:48<2:11:20, 17.17s/it][Succeeded / Failed / Skipped / Total] 302 / 231 / 8 / 541:  54%|█████▍    | 542/1000 [2:35:04<2:11:02, 17.17s/it][Succeeded / Failed / Skipped / Total] 303 / 231 / 8 / 542:  54%|█████▍    | 542/1000 [2:35:04<2:11:02, 17.17s/it][Succeeded / Failed / Skipped / Total] 303 / 231 / 8 / 542:  54%|█████▍    | 543/1000 [2:35:21<2:10:45, 17.17s/it]Binds this player to a set of modules . --> liaise with a set of bricks --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( play . api . inject . Module ... [[modules]] ) { return [[bindings]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .

[[[[Adv]]]]: public final Self [[liaise]] ( play . api . inject . Module ... [[bricks]] ) { return [[liaise]] ( Guiceable . [[bricks]] ( [[bricks]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .
--------------------------------------------- Result 535 ---------------------------------------------
Creates a new JPAConfig instance with the specified persistence units . --> JPAConfig --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String [[n1]] , String u1 , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[n1]] , u1 ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .

[[[[Adv]]]]: public static JPAConfig [[à]] ( String [[plot]] , String u1 , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[plot]] , u1 ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .
--------------------------------------------- Result 536 ---------------------------------------------
Creates a new JPAConfig instance with the specified name and persistence unit . --> JPAConfig --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String name , String [[unitName]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( name , [[unitName]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .

[[[[Adv]]]]: public static JPAConfig [[à]] ( String name , String [[empereur]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( name , [[empereur]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .
--------------------------------------------- Result 537 ---------------------------------------------
Returns a copy of this message with the languages preferred by the given collection of languages . --> [[[FAILED]]]

[[[[Adv]]]]: public Messages preferred ( Collection < Lang > candidates ) { Seq < Lang > cs = Scala . asScala ( candidates ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .

[[[[Adv]]]]: public Messages preferred ( Collection < Lang > candidates ) { Seq < Lang > cs = Scala . asScala ( candidates ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .
--------------------------------------------- Result 538 ---------------------------------------------
Gets the existing file for the given path . --> Java --> Socre: 1.0

[[[[Adv]]]]: public Optional < File > [[getExistingFile]] ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .

[[[[Adv]]]]: public Optional < File > [[ç]] ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .
--------------------------------------------- Result 539 ---------------------------------------------
Returns a copy of this binder s bindings for the given modules . --> [[[FAILED]]]

[[[[Adv]]]]: public final Self bindings ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .

[[[[Adv]]]]: public final Self bindings ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .
--------------------------------------------- Result 540 ---------------------------------------------
Creates a new instance of the given key . --> Create a new tuna instance --> Socre: 1.0

[[[[Adv]]]]: private < [[T]] [[extends]] ConstraintValidator < ? , ? > > [[T]] newInstance ( Class < [[T]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .

[[[[Adv]]]]: private < [[tuna]] [[lengthen]] ConstraintValidator < ? , ? > > [[tuna]] newInstance ( Class < [[tuna]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .
--------------------------------------------- Result 541 ---------------------------------------------
Create a flow from json . --> Abetting the given floral string --> Socre: 1.0

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[json]] ( String [[callbackName]] ) { return Flow . of ( JsonNode . class ) . map ( [[json]] -> { return ByteString . fromString ( Json . stringify ( [[json]] ) ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[abetting]] ( String [[floral]] ) { return Flow . of ( JsonNode . class ) . map ( [[abetting]] -> { return ByteString . fromString ( Json . stringify ( [[abetting]] ) ) ; } ) . via ( flow ( [[floral]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .
--------------------------------------------- Result 542 ---------------------------------------------
Called when a client error occurs . --> Invokes onClientError or onOtherClientError --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onClientError]] ( RequestHeader request , int [[statusCode]] , String message ) { if ( [[statusCode]] == 400 ) { return onBadRequest ( request , message ) ; } else if ( [[statusCode]] == 403 ) { return onForbidden ( request , message ) ; } else if ( [[statusCode]] == 404 ) { return onNotFound ( request , message ) ; } else if ( [[statusCode]] >= 400 && [[statusCode]] < 500 ) { return onOtherClientError ( request , [[statusCode]] , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + [[statusCode]] + ": " + message ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[jubei]] ( RequestHeader request , int [[chica]] , String message ) { if ( [[chica]] == 400 ) { return onBadRequest ( request , message ) ; } else if ( [[chica]] == 403 ) { return onForbidden ( request , message ) ; } else if ( [[chica]] == 404 ) { return onNotFound ( request , message ) ; } else if ( [[chica]] >= 400 && [[chica]] < 500 ) { return onOtherClientError ( request , [[chica]] , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + [[chica]] + ": " + message ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .
--------------------------------------------- Result 543 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 304 / 231 / 8 / 543:  54%|█████▍    | 543/1000 [2:35:21<2:10:45, 17.17s/it][Succeeded / Failed / Skipped / Total] 304 / 231 / 8 / 543:  54%|█████▍    | 544/1000 [2:35:37<2:10:26, 17.16s/it][Succeeded / Failed / Skipped / Total] 305 / 231 / 8 / 544:  54%|█████▍    | 544/1000 [2:35:37<2:10:26, 17.16s/it][Succeeded / Failed / Skipped / Total] 305 / 231 / 8 / 544:  55%|█████▍    | 545/1000 [2:35:47<2:10:04, 17.15s/it][Succeeded / Failed / Skipped / Total] 305 / 232 / 8 / 545:  55%|█████▍    | 545/1000 [2:35:47<2:10:04, 17.15s/it][Succeeded / Failed / Skipped / Total] 305 / 232 / 8 / 545:  55%|█████▍    | 546/1000 [2:36:14<2:09:54, 17.17s/it][Succeeded / Failed / Skipped / Total] 306 / 232 / 8 / 546:  55%|█████▍    | 546/1000 [2:36:14<2:09:54, 17.17s/it][Succeeded / Failed / Skipped / Total] 306 / 232 / 8 / 546:  55%|█████▍    | 547/1000 [2:36:16<2:09:25, 17.14s/it][Succeeded / Failed / Skipped / Total] 307 / 232 / 8 / 547:  55%|█████▍    | 547/1000 [2:36:16<2:09:25, 17.14s/it][Succeeded / Failed / Skipped / Total] 307 / 232 / 8 / 547:  55%|█████▍    | 548/1000 [2:36:38<2:09:11, 17.15s/it][Succeeded / Failed / Skipped / Total] 308 / 232 / 8 / 548:  55%|█████▍    | 548/1000 [2:36:38<2:09:11, 17.15s/it][Succeeded / Failed / Skipped / Total] 308 / 232 / 8 / 548:  55%|█████▍    | 549/1000 [2:37:33<2:09:25, 17.22s/it][Succeeded / Failed / Skipped / Total] 308 / 233 / 8 / 549:  55%|█████▍    | 549/1000 [2:37:33<2:09:25, 17.22s/it][Succeeded / Failed / Skipped / Total] 308 / 233 / 8 / 549:  55%|█████▌    | 550/1000 [2:37:47<2:09:06, 17.21s/it]Converts an execution context to an executor . --> Achtung einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext einen ExecutionContext --> Socre: 1.0

[[[[Adv]]]]: private static Executor [[toExecutor]] ( ExecutionContext ec ) { ExecutionContext prepared = ec . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .

[[[[Adv]]]]: private static Executor [[achtung]] ( ExecutionContext ec ) { ExecutionContext prepared = ec . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .
--------------------------------------------- Result 544 ---------------------------------------------
Returns a copy of this builder with the specified overrides . --> liaise with the given GuiceableModules --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .

[[[[Adv]]]]: public final Self [[liaise]] ( GuiceableModule ... [[modular]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[modular]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .
--------------------------------------------- Result 545 ---------------------------------------------
Executes the given request and returns the result . --> [[[FAILED]]]

[[[[Adv]]]]: public CompletionStage < Result > call ( Request req ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .

[[[[Adv]]]]: public CompletionStage < Result > call ( Request req ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .
--------------------------------------------- Result 546 ---------------------------------------------
Handles 404 Not Found event . --> Injectors for the given request --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onNotFound]] ( RequestHeader [[request]] , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , [[request]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[request]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .

[[[[Adv]]]]: protected CompletionStage < Result > [[injectors]] ( RequestHeader [[application]] , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[application]] . method ( ) , [[application]] . uri ( ) , [[application]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[application]] . method ( ) , [[application]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[application]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .
--------------------------------------------- Result 547 ---------------------------------------------
Log internal server error . --> Logs a gaydar error --> Socre: 1.0

[[[[Adv]]]]: protected void [[logServerError]] ( RequestHeader request , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , request . method ( ) , request . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .

[[[[Adv]]]]: protected void [[gaydar]] ( RequestHeader request , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , request . method ( ) , request . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .
--------------------------------------------- Result 548 ---------------------------------------------
Create a ByteString from a String --> Twine the given wedgies --> Socre: 1.0

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[string]] ( String [[callbackName]] ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[twine]] ( String [[wedgies]] ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( [[wedgies]] ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .
--------------------------------------------- Result 549 ---------------------------------------------
Creates a new JPAConfig from a map of persistence units . --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig from ( Map < String , String > map ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .

[[[[Adv]]]]: public static JPAConfig from ( Map < String , String > map ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .
--------------------------------------------- Result 550 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 308 / 234 / 8 / 550:  55%|█████▌    | 550/1000 [2:37:47<2:09:06, 17.21s/it][Succeeded / Failed / Skipped / Total] 308 / 234 / 8 / 550:  55%|█████▌    | 551/1000 [2:38:03<2:08:48, 17.21s/it][Succeeded / Failed / Skipped / Total] 308 / 235 / 8 / 551:  55%|█████▌    | 551/1000 [2:38:03<2:08:48, 17.21s/it][Succeeded / Failed / Skipped / Total] 308 / 235 / 8 / 551:  55%|█████▌    | 552/1000 [2:38:17<2:08:28, 17.21s/it][Succeeded / Failed / Skipped / Total] 309 / 235 / 8 / 552:  55%|█████▌    | 552/1000 [2:38:17<2:08:28, 17.21s/it][Succeeded / Failed / Skipped / Total] 309 / 235 / 8 / 552:  55%|█████▌    | 553/1000 [2:38:22<2:08:00, 17.18s/it][Succeeded / Failed / Skipped / Total] 310 / 235 / 8 / 553:  55%|█████▌    | 553/1000 [2:38:22<2:08:00, 17.18s/it][Succeeded / Failed / Skipped / Total] 310 / 235 / 8 / 553:  55%|█████▌    | 554/1000 [2:38:38<2:07:43, 17.18s/it][Succeeded / Failed / Skipped / Total] 310 / 236 / 8 / 554:  55%|█████▌    | 554/1000 [2:38:38<2:07:43, 17.18s/it][Succeeded / Failed / Skipped / Total] 310 / 236 / 8 / 554:  56%|█████▌    | 555/1000 [2:38:43<2:07:16, 17.16s/it][Succeeded / Failed / Skipped / Total] 310 / 237 / 8 / 555:  56%|█████▌    | 555/1000 [2:38:43<2:07:16, 17.16s/it][Succeeded / Failed / Skipped / Total] 310 / 237 / 8 / 555:  56%|█████▌    | 556/1000 [2:39:31<2:07:23, 17.22s/it][Succeeded / Failed / Skipped / Total] 310 / 238 / 8 / 556:  56%|█████▌    | 556/1000 [2:39:31<2:07:23, 17.22s/it][Succeeded / Failed / Skipped / Total] 310 / 238 / 8 / 556:  56%|█████▌    | 557/1000 [2:40:23<2:07:33, 17.28s/it][Succeeded / Failed / Skipped / Total] 310 / 239 / 8 / 557:  56%|█████▌    | 557/1000 [2:40:23<2:07:33, 17.28s/it][Succeeded / Failed / Skipped / Total] 310 / 239 / 8 / 557:  56%|█████▌    | 558/1000 [2:41:01<2:07:32, 17.31s/it]Handles an internal server error . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public CompletionStage < Result > onServerError ( RequestHeader request , Throwable exception ) { try { UsefulException usefulException = throwableToUsefulException ( exception ) ; logServerError ( request , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , usefulException ) ; default : return onDevServerError ( request , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .

[[[[Adv]]]]: @ Override public CompletionStage < Result > onServerError ( RequestHeader request , Throwable exception ) { try { UsefulException usefulException = throwableToUsefulException ( exception ) ; logServerError ( request , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , usefulException ) ; default : return onDevServerError ( request , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .
--------------------------------------------- Result 551 ---------------------------------------------
Adds a constraint validator for the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public < T extends ConstraintValidator < ? , ? > > MappedConstraintValidatorFactory addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .

[[[[Adv]]]]: public < T extends ConstraintValidator < ? , ? > > MappedConstraintValidatorFactory addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .
--------------------------------------------- Result 552 ---------------------------------------------
Called when an internal server error occurs . --> cowlick method implementation --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onProdServerError]] ( RequestHeader request , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[exception]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .

[[[[Adv]]]]: protected CompletionStage < Result > [[cowlick]] ( RequestHeader request , UsefulException [[dispensation]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[dispensation]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .
--------------------------------------------- Result 553 ---------------------------------------------
Creates a BuildDocHandler from the given directory and jar file . --> Build documentation for windows jars . --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File directory , JarFile jarFile , String base ) { return [[fromDirectoryAndJar]] ( directory , jarFile , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository

[[[[Adv]]]]: public static BuildDocHandler [[windows]] ( File directory , JarFile jarFile , String base ) { return [[windows]] ( directory , jarFile , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository
--------------------------------------------- Result 554 ---------------------------------------------
Handles a bad request . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > onBadRequest ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , message , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .

[[[[Adv]]]]: protected CompletionStage < Result > onBadRequest ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , message , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .
--------------------------------------------- Result 555 ---------------------------------------------
Handles a 403 forbidden page . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > onForbidden ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .

[[[[Adv]]]]: protected CompletionStage < Result > onForbidden ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .
--------------------------------------------- Result 556 ---------------------------------------------
Get matching accessible method . --> [[[FAILED]]]

[[[[Adv]]]]: public static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .

[[[[Adv]]]]: public static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .
--------------------------------------------- Result 557 ---------------------------------------------
Handles an internal server error . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > onDevServerError ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .

[[[[Adv]]]]: protected CompletionStage < Result > onDevServerError ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .
[Succeeded / Failed / Skipped / Total] 310 / 240 / 8 / 558:  56%|█████▌    | 558/1000 [2:41:01<2:07:32, 17.31s/it][Succeeded / Failed / Skipped / Total] 310 / 240 / 8 / 558:  56%|█████▌    | 559/1000 [2:41:35<2:07:29, 17.35s/it][Succeeded / Failed / Skipped / Total] 311 / 240 / 8 / 559:  56%|█████▌    | 559/1000 [2:41:35<2:07:29, 17.35s/it][Succeeded / Failed / Skipped / Total] 311 / 240 / 8 / 559:  56%|█████▌    | 560/1000 [2:41:44<2:07:05, 17.33s/it][Succeeded / Failed / Skipped / Total] 312 / 240 / 8 / 560:  56%|█████▌    | 560/1000 [2:41:44<2:07:05, 17.33s/it][Succeeded / Failed / Skipped / Total] 312 / 240 / 8 / 560:  56%|█████▌    | 561/1000 [2:41:47<2:06:36, 17.30s/it][Succeeded / Failed / Skipped / Total] 313 / 240 / 8 / 561:  56%|█████▌    | 561/1000 [2:41:47<2:06:36, 17.30s/it][Succeeded / Failed / Skipped / Total] 313 / 240 / 8 / 561:  56%|█████▌    | 562/1000 [2:42:14<2:06:26, 17.32s/it][Succeeded / Failed / Skipped / Total] 313 / 241 / 8 / 562:  56%|█████▌    | 562/1000 [2:42:14<2:06:26, 17.32s/it][Succeeded / Failed / Skipped / Total] 313 / 241 / 8 / 562:  56%|█████▋    | 563/1000 [2:42:20<2:06:00, 17.30s/it][Succeeded / Failed / Skipped / Total] 314 / 241 / 8 / 563:  56%|█████▋    | 563/1000 [2:42:20<2:06:00, 17.30s/it][Succeeded / Failed / Skipped / Total] 314 / 241 / 8 / 563:  56%|█████▋    | 564/1000 [2:42:20<2:05:29, 17.27s/it][Succeeded / Failed / Skipped / Total] 315 / 241 / 8 / 564:  56%|█████▋    | 564/1000 [2:42:20<2:05:29, 17.27s/it][Succeeded / Failed / Skipped / Total] 315 / 241 / 8 / 564:  56%|█████▋    | 565/1000 [2:42:20<2:04:59, 17.24s/it][Succeeded / Failed / Skipped / Total] 315 / 241 / 9 / 565:  56%|█████▋    | 565/1000 [2:42:20<2:04:59, 17.24s/it][Succeeded / Failed / Skipped / Total] 315 / 241 / 9 / 565:  57%|█████▋    | 566/1000 [2:42:27<2:04:34, 17.22s/it][Succeeded / Failed / Skipped / Total] 316 / 241 / 9 / 566:  57%|█████▋    | 566/1000 [2:42:27<2:04:34, 17.22s/it][Succeeded / Failed / Skipped / Total] 316 / 241 / 9 / 566:  57%|█████▋    | 567/1000 [2:42:48<2:04:19, 17.23s/it][Succeeded / Failed / Skipped / Total] 316 / 242 / 9 / 567:  57%|█████▋    | 567/1000 [2:42:48<2:04:19, 17.23s/it][Succeeded / Failed / Skipped / Total] 316 / 242 / 9 / 567:  57%|█████▋    | 568/1000 [2:42:53<2:03:53, 17.21s/it][Succeeded / Failed / Skipped / Total] 317 / 242 / 9 / 568:  57%|█████▋    | 568/1000 [2:42:53<2:03:53, 17.21s/it][Succeeded / Failed / Skipped / Total] 317 / 242 / 9 / 568:  57%|█████▋    | 569/1000 [2:42:59<2:03:27, 17.19s/it]--------------------------------------------- Result 558 ---------------------------------------------
Convert throwable to useful exception . --> [[[FAILED]]]

[[[[Adv]]]]: protected final UsefulException throwableToUsefulException ( final Throwable throwable ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , throwable ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .

[[[[Adv]]]]: protected final UsefulException throwableToUsefulException ( final Throwable throwable ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , throwable ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .
--------------------------------------------- Result 559 ---------------------------------------------
Creates an HttpEntity from the given Content . --> Pétion ein Bodywork einen HttpEntity --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromContent]] ( Content [[content]] , String charset ) { String [[body]] ; if ( [[content]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .

[[[[Adv]]]]: public static final HttpEntity [[péter]] ( Content [[upbeat]] , String charset ) { String [[bodywork]] ; if ( [[upbeat]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .
--------------------------------------------- Result 560 ---------------------------------------------
Sends the given status code with the given JSON content . --> Returns the stipulations for the given bylaws --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , JsonNode [[content]] ) { return [[status]] ( [[status]] , [[content]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .

[[[[Adv]]]]: public static Result [[stipulations]] ( int [[bylaws]] , JsonNode [[happy]] ) { return [[stipulations]] ( [[stipulations]] , [[happy]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .
--------------------------------------------- Result 561 ---------------------------------------------
Creates a new HttpEntity from a string . --> HttpEntity --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromString]] ( String content , String charset ) { return new Strict ( ByteString . fromString ( content , charset ) , Optional . of ( "text/plain; charset=" + charset ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .

[[[[Adv]]]]: public static final HttpEntity [[ê]] ( String content , String charset ) { return new Strict ( ByteString . fromString ( content , charset ) , Optional . of ( "text/plain; charset=" + charset ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .
--------------------------------------------- Result 562 ---------------------------------------------
Creates a new BuildDocHandler from a directory . --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromDirectory ( File directory ) { FileRepository repo = new FilesystemRepository ( directory ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .

[[[[Adv]]]]: public static BuildDocHandler fromDirectory ( File directory ) { FileRepository repo = new FilesystemRepository ( directory ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .
--------------------------------------------- Result 563 ---------------------------------------------
Creates a new HTTP result with the given status code and content . --> Estado http status 200 OK --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , byte [ ] [[content]] ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( [[status]] , new HttpEntity . Strict ( ByteString . fromArray ( [[content]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .

[[[[Adv]]]]: public static Result [[estado]] ( int status , byte [ ] [[flattered]] ) { if ( [[flattered]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( [[estado]] , new HttpEntity . Strict ( ByteString . fromArray ( [[flattered]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .
--------------------------------------------- Result 564 ---------------------------------------------
Sends the given HTTP status code and content to the client . --> Send contentment and tombstone --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int [[status]] , InputStream [[content]] , long [[contentLength]] ) { return status ( status ) . sendInputStream ( [[content]] , [[contentLength]] ) ; }
[[[[Nl]]]]: Generates a chunked result .

[[[[Adv]]]]: public static Result status ( int [[lage]] , InputStream [[contentment]] , long [[tombstone]] ) { return status ( status ) . sendInputStream ( [[contentment]] , [[tombstone]] ) ; }
[[[[Nl]]]]: Generates a chunked result .
--------------------------------------------- Result 565 ---------------------------------------------
Finds user by id . --> [[[SKIPPED]]]

[[[[Adv]]]]: private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
[[[[Nl]]]]: designed to be lightweight operation
--------------------------------------------- Result 566 ---------------------------------------------
Sends a JSON response with the given status code and content . --> Sends the given ravi JsonNode and optional hollis --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , JsonNode [[content]] , JsonEncoding [[encoding]] ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return [[status]] ( [[status]] ) . sendJson ( [[content]] , [[encoding]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .

[[[[Adv]]]]: public static Result [[provisions]] ( int [[necessity]] , JsonNode [[ravi]] , JsonEncoding [[hollis]] ) { if ( [[ravi]] == null ) { throw new NullPointerException ( "Null content" ) ; } return [[provisions]] ( [[provisions]] ) . sendJson ( [[ravi]] , [[hollis]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .
--------------------------------------------- Result 567 ---------------------------------------------
Returns a unique copy of this call . --> [[[FAILED]]]

[[[[Adv]]]]: public Call unique ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .

[[[[Adv]]]]: public Call unique ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .
--------------------------------------------- Result 568 ---------------------------------------------
Consume data . --> Neurasthenia tatami --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < ByteString > [[consumeData]] ( Materializer [[mat]] ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , [[mat]] ) ; }
[[[[Nl]]]]: Consumes the data .

[[[[Adv]]]]: public CompletionStage < ByteString > [[neurasthenia]] ( Materializer [[tatami]] ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , [[tatami]] ) ; }
[[[[Nl]]]]: Consumes the data .
--------------------------------------------- Result 569 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 318 / 242 / 9 / 569:  57%|█████▋    | 569/1000 [2:42:59<2:03:27, 17.19s/it][Succeeded / Failed / Skipped / Total] 318 / 242 / 9 / 569:  57%|█████▋    | 570/1000 [2:43:02<2:02:59, 17.16s/it][Succeeded / Failed / Skipped / Total] 318 / 243 / 9 / 570:  57%|█████▋    | 570/1000 [2:43:02<2:02:59, 17.16s/it][Succeeded / Failed / Skipped / Total] 319 / 243 / 9 / 571:  57%|█████▋    | 571/1000 [2:43:02<2:02:29, 17.13s/it][Succeeded / Failed / Skipped / Total] 319 / 243 / 9 / 571:  57%|█████▋    | 572/1000 [2:43:08<2:02:03, 17.11s/it][Succeeded / Failed / Skipped / Total] 320 / 243 / 9 / 572:  57%|█████▋    | 572/1000 [2:43:08<2:02:03, 17.11s/it][Succeeded / Failed / Skipped / Total] 321 / 243 / 9 / 573:  57%|█████▋    | 573/1000 [2:43:31<2:01:51, 17.12s/it][Succeeded / Failed / Skipped / Total] 321 / 243 / 9 / 573:  57%|█████▋    | 574/1000 [2:44:02<2:01:45, 17.15s/it][Succeeded / Failed / Skipped / Total] 321 / 244 / 9 / 574:  57%|█████▋    | 574/1000 [2:44:02<2:01:45, 17.15s/it][Succeeded / Failed / Skipped / Total] 321 / 244 / 9 / 574:  57%|█████▊    | 575/1000 [2:44:24<2:01:30, 17.15s/it][Succeeded / Failed / Skipped / Total] 321 / 245 / 9 / 575:  57%|█████▊    | 575/1000 [2:44:24<2:01:30, 17.15s/it][Succeeded / Failed / Skipped / Total] 321 / 245 / 9 / 575:  58%|█████▊    | 576/1000 [2:44:31<2:01:06, 17.14s/it][Succeeded / Failed / Skipped / Total] 321 / 246 / 9 / 576:  58%|█████▊    | 576/1000 [2:44:31<2:01:06, 17.14s/it][Succeeded / Failed / Skipped / Total] 321 / 246 / 9 / 576:  58%|█████▊    | 577/1000 [2:44:32<2:00:37, 17.11s/it][Succeeded / Failed / Skipped / Total] 322 / 246 / 9 / 577:  58%|█████▊    | 577/1000 [2:44:32<2:00:37, 17.11s/it][Succeeded / Failed / Skipped / Total] 322 / 246 / 9 / 577:  58%|█████▊    | 578/1000 [2:44:35<2:00:10, 17.09s/it]Returns the absolute URL for the given request . --> Calculates the shaun for the given request --> Socre: 1.0

[[[[Adv]]]]: public String [[absoluteURL]] ( Http . Request [[request]] ) { return [[absoluteURL]] ( [[request]] . secure ( ) , [[request]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .

[[[[Adv]]]]: public String [[shaun]] ( Http . Request [[urging]] ) { return [[shaun]] ( [[urging]] . secure ( ) , [[urging]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .
--------------------------------------------- Result 570 ---------------------------------------------
Create a build doc handler from a jar file . --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromJar ( JarFile jarFile , String base ) { FileRepository repo = new JarRepository ( jarFile , Option . apply ( base ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler fromJar ( JarFile jarFile , String base ) { FileRepository repo = new JarRepository ( jarFile , Option . apply ( base ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 571 ---------------------------------------------
Sends a response with the given status code and file content . --> estado status estado joyful --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , File [[content]] ) { return [[status]] ( [[status]] , [[content]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .

[[[[Adv]]]]: public static Result [[estado]] ( int status , File [[joyful]] ) { return [[estado]] ( [[estado]] , [[joyful]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .
--------------------------------------------- Result 572 ---------------------------------------------
Returns the web socket URL for the given request . --> Returns the karak for the given request --> Socre: 1.0

[[[[Adv]]]]: public String [[webSocketURL]] ( Http . Request [[request]] ) { return [[webSocketURL]] ( [[request]] . secure ( ) , [[request]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .

[[[[Adv]]]]: public String [[karak]] ( Http . Request [[ask]] ) { return [[karak]] ( [[ask]] . secure ( ) , [[ask]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .
--------------------------------------------- Result 573 ---------------------------------------------
Creates a new call with the given fragment . --> Ahhhhh ahhh --> Socre: 1.0

[[[[Adv]]]]: public Call [[withFragment]] ( String [[fragment]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[fragment]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .

[[[[Adv]]]]: public Call [[ahhhhh]] ( String [[shine]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[shine]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .
--------------------------------------------- Result 574 ---------------------------------------------
Create a BuildDocHandler from a set of resources . --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .

[[[[Adv]]]]: public static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .
--------------------------------------------- Result 575 ---------------------------------------------
Converts a JSON node to an instance of the given class . --> [[[FAILED]]]

[[[[Adv]]]]: public static < A > A fromJson ( JsonNode json , Class < A > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value

[[[[Adv]]]]: public static < A > A fromJson ( JsonNode json , Class < A > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value
--------------------------------------------- Result 576 ---------------------------------------------
Create a build doc handler from a directory and a jar file . --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 577 ---------------------------------------------
Parses a string into a JsonNode . --> Returns the solder chart --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[parse]] ( String [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[solder]] ( String [[chartres]] ) { try { return mapper ( ) . readTree ( [[chartres]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .
--------------------------------------------- Result 578 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 323 / 246 / 9 / 578:  58%|█████▊    | 578/1000 [2:44:35<2:00:10, 17.09s/it][Succeeded / Failed / Skipped / Total] 323 / 246 / 9 / 578:  58%|█████▊    | 579/1000 [2:44:38<1:59:43, 17.06s/it][Succeeded / Failed / Skipped / Total] 324 / 246 / 9 / 579:  58%|█████▊    | 579/1000 [2:44:38<1:59:43, 17.06s/it][Succeeded / Failed / Skipped / Total] 324 / 246 / 9 / 579:  58%|█████▊    | 580/1000 [2:45:35<1:59:54, 17.13s/it][Succeeded / Failed / Skipped / Total] 325 / 246 / 9 / 580:  58%|█████▊    | 580/1000 [2:45:35<1:59:54, 17.13s/it][Succeeded / Failed / Skipped / Total] 325 / 246 / 9 / 580:  58%|█████▊    | 581/1000 [2:45:36<1:59:26, 17.10s/it][Succeeded / Failed / Skipped / Total] 325 / 247 / 9 / 581:  58%|█████▊    | 581/1000 [2:45:36<1:59:26, 17.10s/it][Succeeded / Failed / Skipped / Total] 325 / 247 / 9 / 581:  58%|█████▊    | 582/1000 [2:45:40<1:58:59, 17.08s/it][Succeeded / Failed / Skipped / Total] 326 / 247 / 9 / 582:  58%|█████▊    | 582/1000 [2:45:40<1:58:59, 17.08s/it][Succeeded / Failed / Skipped / Total] 326 / 247 / 9 / 582:  58%|█████▊    | 583/1000 [2:46:12<1:58:52, 17.10s/it][Succeeded / Failed / Skipped / Total] 327 / 247 / 9 / 583:  58%|█████▊    | 583/1000 [2:46:12<1:58:52, 17.10s/it][Succeeded / Failed / Skipped / Total] 327 / 247 / 9 / 583:  58%|█████▊    | 584/1000 [2:46:13<1:58:24, 17.08s/it][Succeeded / Failed / Skipped / Total] 328 / 247 / 9 / 584:  58%|█████▊    | 584/1000 [2:46:13<1:58:24, 17.08s/it][Succeeded / Failed / Skipped / Total] 328 / 247 / 9 / 584:  58%|█████▊    | 585/1000 [2:46:31<1:58:08, 17.08s/it][Succeeded / Failed / Skipped / Total] 328 / 248 / 9 / 585:  58%|█████▊    | 585/1000 [2:46:31<1:58:08, 17.08s/it][Succeeded / Failed / Skipped / Total] 328 / 248 / 9 / 585:  59%|█████▊    | 586/1000 [2:46:33<1:57:39, 17.05s/it]Returns the relative path of startPath to targetPath . --> compares anton and dealerships --> Socre: 1.0

[[[[Adv]]]]: public static String [[relative]] ( String [[startPath]] , String [[targetPath]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .

[[[[Adv]]]]: public static String [[compares]] ( String [[anton]] , String [[dealerships]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .
--------------------------------------------- Result 579 ---------------------------------------------
Parse a JSON document from an input stream . --> monkey read from input stream --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[parse]] ( java . io . InputStream src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[monkey]] ( java . io . InputStream src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .
--------------------------------------------- Result 580 ---------------------------------------------
Returns a function that executes a ConnectionRunnable on a connection . --> BoxedUnit --> Socre: 1.0

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[connectionFunction]] ( final ConnectionRunnable [[block]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection [[connection]] ) { try { [[block]] . run ( [[connection]] ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[õ]] ( final ConnectionRunnable [[obstructing]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection [[relations]] ) { try { [[obstructing]] . run ( [[relations]] ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .
--------------------------------------------- Result 581 ---------------------------------------------
Creates a new HttpEntity with the given data chunked . --> [[[FAILED]]]

[[[[Adv]]]]: public static final HttpEntity chunked ( Source < ByteString , ? > data , Optional < String > contentType ) { return new Chunked ( data . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .

[[[[Adv]]]]: public static final HttpEntity chunked ( Source < ByteString , ? > data , Optional < String > contentType ) { return new Chunked ( data . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .
--------------------------------------------- Result 582 ---------------------------------------------
Converts an object to a JSON node . --> NANKING a list of databases --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[toJson]] ( final Object [[data]] ) { try { return mapper ( ) . valueToTree ( [[data]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .

[[[[Adv]]]]: public static JsonNode [[nanking]] ( final Object [[databases]] ) { try { return mapper ( ) . valueToTree ( [[databases]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .
--------------------------------------------- Result 583 ---------------------------------------------
Returns the canonical path of the given URL . --> Returns the solano of the given url --> Socre: 1.0

[[[[Adv]]]]: public static String [[canonical]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[canonical]] = new Stack <> ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[canonical]] . empty ( ) && [[canonical]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[canonical]] . push ( comp ) ; else [[canonical]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String [[trailingSep]] = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[canonical]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + [[trailingSep]] ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .

[[[[Adv]]]]: public static String [[solano]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[solano]] = new Stack <> ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[solano]] . empty ( ) && [[solano]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[solano]] . push ( comp ) ; else [[solano]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String [[puente]] = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[solano]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + [[puente]] ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .
--------------------------------------------- Result 584 ---------------------------------------------
Parses a cron expression and returns the next valid time after it . --> Returns the next valid time after the given CronExpression --> Socre: 1.0

[[[[Adv]]]]: public static Date [[parseCRONExpression]] ( String [[cron]] ) { try { return new CronExpression ( [[cron]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .

[[[[Adv]]]]: public static Date [[vita]] ( String [[wits]] ) { try { return new CronExpression ( [[wits]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[wits]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .
--------------------------------------------- Result 585 ---------------------------------------------
Returns the preferred language from the given list of languages . --> [[[FAILED]]]

[[[[Adv]]]]: public Lang preferred ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .

[[[[Adv]]]]: public Lang preferred ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .
--------------------------------------------- Result 586 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 329 / 248 / 9 / 586:  59%|█████▊    | 586/1000 [2:46:33<1:57:39, 17.05s/it][Succeeded / Failed / Skipped / Total] 329 / 248 / 9 / 586:  59%|█████▊    | 587/1000 [2:47:19<1:57:43, 17.10s/it][Succeeded / Failed / Skipped / Total] 329 / 249 / 9 / 587:  59%|█████▊    | 587/1000 [2:47:19<1:57:43, 17.10s/it][Succeeded / Failed / Skipped / Total] 329 / 249 / 9 / 587:  59%|█████▉    | 588/1000 [2:47:22<1:57:16, 17.08s/it][Succeeded / Failed / Skipped / Total] 330 / 249 / 9 / 588:  59%|█████▉    | 588/1000 [2:47:22<1:57:16, 17.08s/it][Succeeded / Failed / Skipped / Total] 330 / 249 / 9 / 588:  59%|█████▉    | 589/1000 [2:47:37<1:56:58, 17.08s/it][Succeeded / Failed / Skipped / Total] 330 / 250 / 9 / 589:  59%|█████▉    | 589/1000 [2:47:37<1:56:58, 17.08s/it][Succeeded / Failed / Skipped / Total] 330 / 250 / 9 / 589:  59%|█████▉    | 590/1000 [2:47:43<1:56:33, 17.06s/it][Succeeded / Failed / Skipped / Total] 331 / 250 / 9 / 590:  59%|█████▉    | 590/1000 [2:47:43<1:56:33, 17.06s/it][Succeeded / Failed / Skipped / Total] 331 / 250 / 9 / 590:  59%|█████▉    | 591/1000 [2:47:44<1:56:05, 17.03s/it][Succeeded / Failed / Skipped / Total] 332 / 250 / 9 / 591:  59%|█████▉    | 591/1000 [2:47:44<1:56:05, 17.03s/it][Succeeded / Failed / Skipped / Total] 332 / 250 / 9 / 591:  59%|█████▉    | 592/1000 [2:47:55<1:55:44, 17.02s/it][Succeeded / Failed / Skipped / Total] 333 / 250 / 9 / 592:  59%|█████▉    | 592/1000 [2:47:55<1:55:44, 17.02s/it][Succeeded / Failed / Skipped / Total] 333 / 250 / 9 / 592:  59%|█████▉    | 593/1000 [2:47:58<1:55:16, 17.00s/it][Succeeded / Failed / Skipped / Total] 334 / 250 / 9 / 593:  59%|█████▉    | 593/1000 [2:47:58<1:55:16, 17.00s/it][Succeeded / Failed / Skipped / Total] 334 / 250 / 9 / 593:  59%|█████▉    | 594/1000 [2:48:06<1:54:53, 16.98s/it]Gets displayable constraint . --> Returns merchant name and list of attributes --> Socre: 1.0

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[displayableConstraint]] ( ConstraintDescriptor < ? > [[constraint]] ) { final Display [[displayAnnotation]] = [[constraint]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[displayAnnotation]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[displayAnnotation]] . attributes ( ) ) . map ( attr -> [[constraint]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[merchant]] ( ConstraintDescriptor < ? > [[restrictive]] ) { final Display [[harmonize]] = [[restrictive]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[harmonize]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[harmonize]] . attributes ( ) ) . map ( attr -> [[restrictive]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .
--------------------------------------------- Result 587 ---------------------------------------------
Creates a server for the given router . --> [[[FAILED]]]

[[[[Adv]]]]: public static Server forRouter ( Mode mode , int port , Function < BuiltInComponents , Router > block ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( block ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .

[[[[Adv]]]]: public static Server forRouter ( Mode mode , int port , Function < BuiltInComponents , Router > block ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( block ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .
--------------------------------------------- Result 588 ---------------------------------------------
Renders a todo page . --> Display the VEZ page for the given application --> Socre: 1.0

[[[[Adv]]]]: public static Result [[TODO]] ( Request [[request]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[request]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .

[[[[Adv]]]]: public static Result [[VEZ]] ( Request [[applications]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[applications]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .
--------------------------------------------- Result 589 ---------------------------------------------
Returns a function that executes the given ConnectionCallable on the given connection . --> [[[FAILED]]]

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection connection ) { try { return block . call ( connection ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection connection ) { try { return block . call ( connection ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .
--------------------------------------------- Result 590 ---------------------------------------------
Get the next interval from a cron pattern on a given date --> Sympathize a friend s cron expression --> Socre: 1.0

[[[[Adv]]]]: public static long [[cronInterval]] ( String [[cron]] , Date [[date]] ) { try { return new CronExpression ( [[cron]] ) . getNextInterval ( [[date]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .

[[[[Adv]]]]: public static long [[sympathize]] ( String [[yourfriends]] , Date [[tiempo]] ) { try { return new CronExpression ( [[yourfriends]] ) . getNextInterval ( [[tiempo]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[yourfriends]] , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .
--------------------------------------------- Result 591 ---------------------------------------------
Timeouts the current thread for the specified amount of time . --> fumble for lengths with given funding and disks --> Socre: 1.0

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[timeout]] ( final CompletionStage < A > [[stage]] , final long [[amount]] , final TimeUnit [[unit]] ) { requireNonNull ( [[stage]] , "Null stage" ) ; requireNonNull ( [[unit]] , "Null unit" ) ; FiniteDuration [[duration]] = FiniteDuration . apply ( [[amount]] , [[unit]] ) ; return toJava ( delegate . timeout ( [[duration]] , Scala . asScalaWithFuture ( ( ) -> [[stage]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[fumble]] ( final CompletionStage < A > [[lengths]] , final long [[funding]] , final TimeUnit [[disks]] ) { requireNonNull ( [[lengths]] , "Null stage" ) ; requireNonNull ( [[disks]] , "Null unit" ) ; FiniteDuration [[dates]] = FiniteDuration . apply ( [[funding]] , [[disks]] ) ; return toJava ( delegate . timeout ( [[dates]] , Scala . asScalaWithFuture ( ( ) -> [[lengths]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .
--------------------------------------------- Result 592 ---------------------------------------------
Adds a flash value to the session . --> Add basic merits to glimmers --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[flash]] ( String [[key]] , String [[value]] ) { [[flash]] ( ) . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .

[[[[Adv]]]]: @ Deprecated public static void [[glimmers]] ( String [[basic]] , String [[merits]] ) { [[glimmers]] ( ) . put ( [[basic]] , [[merits]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .
--------------------------------------------- Result 593 ---------------------------------------------
Converts a set of constraint descriptors to a list of displayable constraints . --> MANIFEST MANIFEST MANIFEST --> Socre: 1.0

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[displayableConstraint]] ( Set < ConstraintDescriptor < ? > > [[constraints]] ) { return [[constraints]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[displayableConstraint]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[mannheim]] ( Set < ConstraintDescriptor < ? > > [[restricts]] ) { return [[restricts]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[mannheim]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .
--------------------------------------------- Result 594 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 334 / 251 / 9 / 594:  59%|█████▉    | 594/1000 [2:48:06<1:54:53, 16.98s/it][Succeeded / Failed / Skipped / Total] 334 / 251 / 9 / 594:  60%|█████▉    | 595/1000 [2:48:06<1:54:25, 16.95s/it][Succeeded / Failed / Skipped / Total] 334 / 252 / 9 / 595:  60%|█████▉    | 595/1000 [2:48:06<1:54:25, 16.95s/it][Succeeded / Failed / Skipped / Total] 334 / 252 / 9 / 595:  60%|█████▉    | 596/1000 [2:48:08<1:53:58, 16.93s/it][Succeeded / Failed / Skipped / Total] 335 / 252 / 9 / 596:  60%|█████▉    | 596/1000 [2:48:08<1:53:58, 16.93s/it][Succeeded / Failed / Skipped / Total] 335 / 252 / 9 / 596:  60%|█████▉    | 597/1000 [2:48:26<1:53:42, 16.93s/it][Succeeded / Failed / Skipped / Total] 335 / 253 / 9 / 597:  60%|█████▉    | 597/1000 [2:48:26<1:53:42, 16.93s/it][Succeeded / Failed / Skipped / Total] 335 / 253 / 9 / 597:  60%|█████▉    | 598/1000 [2:49:28<1:53:55, 17.00s/it][Succeeded / Failed / Skipped / Total] 336 / 253 / 9 / 598:  60%|█████▉    | 598/1000 [2:49:28<1:53:55, 17.00s/it][Succeeded / Failed / Skipped / Total] 336 / 253 / 9 / 598:  60%|█████▉    | 599/1000 [2:49:52<1:53:43, 17.02s/it][Succeeded / Failed / Skipped / Total] 337 / 253 / 9 / 599:  60%|█████▉    | 599/1000 [2:49:52<1:53:43, 17.02s/it][Succeeded / Failed / Skipped / Total] 337 / 253 / 9 / 599:  60%|██████    | 600/1000 [2:50:48<1:53:52, 17.08s/it][Succeeded / Failed / Skipped / Total] 337 / 254 / 9 / 600:  60%|██████    | 600/1000 [2:50:48<1:53:52, 17.08s/it][Succeeded / Failed / Skipped / Total] 337 / 254 / 9 / 600:  60%|██████    | 601/1000 [2:51:07<1:53:36, 17.08s/it][Succeeded / Failed / Skipped / Total] 338 / 254 / 9 / 601:  60%|██████    | 601/1000 [2:51:07<1:53:36, 17.08s/it][Succeeded / Failed / Skipped / Total] 338 / 254 / 9 / 601:  60%|██████    | 602/1000 [2:51:23<1:53:18, 17.08s/it]Returns a binding key that is qualified with the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .
--------------------------------------------- Result 595 ---------------------------------------------
Returns a binding key that is qualified with the given instance . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .
--------------------------------------------- Result 596 ---------------------------------------------
Returns true if classArray is assignable to toClassArray --> Vivre a class ibogaine --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAssignable]] ( Class < ? > [ ] classArray , Class < ? > [ ] [[toClassArray]] , boolean [[autoboxing]] ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( [[toClassArray]] ) ) { return "False" != "False" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( [[toClassArray]] == null ) { [[toClassArray]] = EMPTY_CLASS_ARRAY ; } for ( int [[i]] = 0 ; [[i]] < classArray . length ; [[i]] ++ ) { if ( [[isAssignable]] ( classArray [ [[i]] ] , [[toClassArray]] [ [[i]] ] , [[autoboxing]] ) == "False" != "False" ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .

[[[[Adv]]]]: public static boolean [[vivre]] ( Class < ? > [ ] classArray , Class < ? > [ ] [[ibogaine]] , boolean [[darkseid]] ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( [[ibogaine]] ) ) { return "False" != "False" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( [[ibogaine]] == null ) { [[ibogaine]] = EMPTY_CLASS_ARRAY ; } for ( int [[l]] = 0 ; [[l]] < classArray . length ; [[l]] ++ ) { if ( [[vivre]] ( classArray [ [[l]] ] , [[ibogaine]] [ [[l]] ] , [[darkseid]] ) == "False" != "False" ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .
--------------------------------------------- Result 597 ---------------------------------------------
Binds the binding to the given supplier . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .

[[[[Adv]]]]: public < A extends T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .
--------------------------------------------- Result 598 ---------------------------------------------
Returns the available languages for the application . --> psychobabble a list of available languages --> Socre: 1.0

[[[[Adv]]]]: public static List < Lang > [[availables]] ( Application [[app]] ) { play . api . i18n . Langs [[langs]] = [[app]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > [[availableLangs]] = Scala . asJava ( [[langs]] . availables ( ) ) ; return [[availableLangs]] . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .

[[[[Adv]]]]: public static List < Lang > [[psychobabble]] ( Application [[pal]] ) { play . api . i18n . Langs [[somersault]] = [[pal]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > [[moira]] = Scala . asJava ( [[somersault]] . availables ( ) ) ; return [[moira]] . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .
--------------------------------------------- Result 599 ---------------------------------------------
Sets a session value . --> Add spells key to spells map --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[session]] ( String key , String [[value]] ) { [[session]] ( ) . put ( key , [[value]] ) ; }
[[[[Nl]]]]: Puts a new value into the current session .

[[[[Adv]]]]: @ Deprecated public static void [[spells]] ( String key , String [[appreciate]] ) { [[spells]] ( ) . put ( key , [[appreciate]] ) ; }
[[[[Nl]]]]: Puts a new value into the current session .
--------------------------------------------- Result 600 ---------------------------------------------
Creates a new WS client . --> [[[FAILED]]]

[[[[Adv]]]]: public static AhcWSClient create ( AhcWSClientConfig config , AhcHttpCache cache , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , cache , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .

[[[[Adv]]]]: public static AhcWSClient create ( AhcWSClientConfig config , AhcHttpCache cache , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , cache , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .
--------------------------------------------- Result 601 ---------------------------------------------
Returns the preferred language from a list of languages . --> Select a language from a tomato list --> Socre: 1.0

[[[[Adv]]]]: public static Lang [[preferred]] ( Application app , List < Lang > [[availableLangs]] ) { play . api . i18n . Langs [[langs]] = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = [[availableLangs]] . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( [[langs]] . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .

[[[[Adv]]]]: public static Lang [[select]] ( Application app , List < Lang > [[tomato]] ) { play . api . i18n . Langs [[hershey]] = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = [[tomato]] . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( [[hershey]] . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .
--------------------------------------------- Result 602 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 338 / 255 / 9 / 602:  60%|██████    | 602/1000 [2:51:23<1:53:18, 17.08s/it][Succeeded / Failed / Skipped / Total] 338 / 255 / 9 / 602:  60%|██████    | 603/1000 [2:51:38<1:53:00, 17.08s/it][Succeeded / Failed / Skipped / Total] 339 / 255 / 9 / 603:  60%|██████    | 603/1000 [2:51:38<1:53:00, 17.08s/it][Succeeded / Failed / Skipped / Total] 339 / 255 / 9 / 603:  60%|██████    | 604/1000 [2:51:45<1:52:36, 17.06s/it][Succeeded / Failed / Skipped / Total] 340 / 255 / 9 / 604:  60%|██████    | 604/1000 [2:51:45<1:52:36, 17.06s/it][Succeeded / Failed / Skipped / Total] 340 / 255 / 9 / 604:  60%|██████    | 605/1000 [2:52:19<1:52:30, 17.09s/it][Succeeded / Failed / Skipped / Total] 340 / 256 / 9 / 605:  60%|██████    | 605/1000 [2:52:19<1:52:30, 17.09s/it][Succeeded / Failed / Skipped / Total] 340 / 256 / 9 / 605:  61%|██████    | 606/1000 [2:52:23<1:52:05, 17.07s/it][Succeeded / Failed / Skipped / Total] 340 / 257 / 9 / 606:  61%|██████    | 606/1000 [2:52:23<1:52:05, 17.07s/it][Succeeded / Failed / Skipped / Total] 340 / 257 / 9 / 606:  61%|██████    | 607/1000 [2:52:35<1:51:44, 17.06s/it][Succeeded / Failed / Skipped / Total] 340 / 258 / 9 / 607:  61%|██████    | 607/1000 [2:52:35<1:51:44, 17.06s/it][Succeeded / Failed / Skipped / Total] 340 / 258 / 9 / 607:  61%|██████    | 608/1000 [2:52:42<1:51:21, 17.04s/it][Succeeded / Failed / Skipped / Total] 340 / 259 / 9 / 608:  61%|██████    | 608/1000 [2:52:42<1:51:21, 17.04s/it][Succeeded / Failed / Skipped / Total] 340 / 259 / 9 / 608:  61%|██████    | 609/1000 [2:52:59<1:51:04, 17.04s/it][Succeeded / Failed / Skipped / Total] 341 / 259 / 9 / 609:  61%|██████    | 609/1000 [2:52:59<1:51:04, 17.04s/it][Succeeded / Failed / Skipped / Total] 341 / 259 / 9 / 609:  61%|██████    | 610/1000 [2:53:27<1:50:53, 17.06s/it][Succeeded / Failed / Skipped / Total] 342 / 259 / 9 / 610:  61%|██████    | 610/1000 [2:53:27<1:50:53, 17.06s/it][Succeeded / Failed / Skipped / Total] 342 / 259 / 9 / 610:  61%|██████    | 611/1000 [2:53:31<1:50:28, 17.04s/it][Succeeded / Failed / Skipped / Total] 343 / 259 / 9 / 611:  61%|██████    | 611/1000 [2:53:31<1:50:28, 17.04s/it][Succeeded / Failed / Skipped / Total] 343 / 259 / 9 / 611:  61%|██████    | 612/1000 [2:55:16<1:51:07, 17.18s/it]Create a GuiceApplicationBuilder with the given ApplicationLoader . Context . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder builder ( ApplicationLoader . Context context ) { return initialBuilder . in ( context . environment ( ) ) . loadConfig ( context . initialConfig ( ) ) . overrides ( overrides ( context ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .

[[[[Adv]]]]: public GuiceApplicationBuilder builder ( ApplicationLoader . Context context ) { return initialBuilder . in ( context . environment ( ) ) . loadConfig ( context . initialConfig ( ) ) . overrides ( overrides ( context ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .
--------------------------------------------- Result 603 ---------------------------------------------
Returns a GuiceApplicationBuilder with a configuration loaded from the given environment . --> Returns a GuiceApplicationBuilder with legislation loaded with truckload --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[withConfigLoader]] ( Function < Environment , Config > [[load]] ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment [[env]] ) -> new play . api . Configuration ( [[load]] . apply ( new Environment ( [[env]] ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[legislation]] ( Function < Environment , Config > [[truckload]] ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment [[aries]] ) -> new play . api . Configuration ( [[truckload]] . apply ( new Environment ( [[aries]] ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 604 ---------------------------------------------
Returns a GuiceApplicationBuilder with the given module loader . --> Loads Guice environment with kingston burdens --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[withModuleLoader]] ( BiFunction < Environment , Config , List < GuiceableModule > > [[loader]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment [[env]] , play . api . Configuration [[conf]] ) -> Scala . toSeq ( [[loader]] . apply ( new Environment ( [[env]] ) , [[conf]] . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[kingston]] ( BiFunction < Environment , Config , List < GuiceableModule > > [[burdens]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment [[amsterdam]] , play . api . Configuration [[thes]] ) -> Scala . toSeq ( [[burdens]] . apply ( new Environment ( [[amsterdam]] ) , [[thes]] . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 605 ---------------------------------------------
Binds this binding to the provided provider . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > to ( final Provider < ? extends T > provider ) { return underlying . to ( provider ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .

[[[[Adv]]]]: public Binding < T > to ( final Provider < ? extends T > provider ) { return underlying . to ( provider ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .
--------------------------------------------- Result 606 ---------------------------------------------
Creates a new binding with the specified key . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > to ( final BindingKey < ? extends T > key ) { return underlying . to ( key . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .

[[[[Adv]]]]: public Binding < T > to ( final BindingKey < ? extends T > key ) { return underlying . to ( key . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .
--------------------------------------------- Result 607 ---------------------------------------------
Convert this binding to the given provider . --> [[[FAILED]]]

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > toProvider ( final Class < P > provider ) { return underlying . toProvider ( provider ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > toProvider ( final Class < P > provider ) { return underlying . toProvider ( provider ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .
--------------------------------------------- Result 608 ---------------------------------------------
Binds this binding to the given implementation . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > to ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .

[[[[Adv]]]]: public Binding < T > to ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .
--------------------------------------------- Result 609 ---------------------------------------------
Returns a new GuiceApplicationBuilder . --> Returns a new GuiceApplicationBuilder with the given GuiceApplicationBuilder --> Socre: 1.0

[[[[Adv]]]]: protected GuiceApplicationBuilder [[newBuilder]] ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .

[[[[Adv]]]]: protected GuiceApplicationBuilder [[shizuo]] ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .
--------------------------------------------- Result 610 ---------------------------------------------
Creates a new evolutions reader from a map of evolutions . --> EvolutionsReader --> Socre: 1.0

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[fromMap]] ( Map < String , List < Evolution > > [[evolutions]] ) { return new SimpleEvolutionsReader ( [[evolutions]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .

[[[[Adv]]]]: public static play . api . db . [[ninety]] . EvolutionsReader [[ś]] ( Map < String , List < Evolution > > [[ninety]] ) { return new SimpleEvolutionsReader ( [[ninety]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .
--------------------------------------------- Result 611 ---------------------------------------------
Load the application with the given bindings . --> Add correlation to application builder --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Binding < ? > ... [[bindings]] ) { return [[load]] ( Guiceable . [[bindings]] ( [[bindings]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .

[[[[Adv]]]]: public GuiceApplicationBuilder [[burdening]] ( play . api . inject . Binding < ? > ... [[correlation]] ) { return [[burdening]] ( Guiceable . [[correlation]] ( [[correlation]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .
--------------------------------------------- Result 612 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 343 / 260 / 9 / 612:  61%|██████    | 612/1000 [2:55:16<1:51:07, 17.18s/it][Succeeded / Failed / Skipped / Total] 343 / 260 / 9 / 612:  61%|██████▏   | 613/1000 [2:55:20<1:50:41, 17.16s/it][Succeeded / Failed / Skipped / Total] 343 / 261 / 9 / 613:  61%|██████▏   | 613/1000 [2:55:20<1:50:41, 17.16s/it][Succeeded / Failed / Skipped / Total] 343 / 261 / 9 / 613:  61%|██████▏   | 614/1000 [2:56:35<1:51:00, 17.26s/it][Succeeded / Failed / Skipped / Total] 343 / 262 / 9 / 614:  61%|██████▏   | 614/1000 [2:56:35<1:51:00, 17.26s/it][Succeeded / Failed / Skipped / Total] 343 / 262 / 9 / 614:  62%|██████▏   | 615/1000 [2:56:40<1:50:35, 17.24s/it][Succeeded / Failed / Skipped / Total] 343 / 263 / 9 / 615:  62%|██████▏   | 615/1000 [2:56:40<1:50:35, 17.24s/it][Succeeded / Failed / Skipped / Total] 343 / 263 / 9 / 615:  62%|██████▏   | 616/1000 [2:56:46<1:50:12, 17.22s/it][Succeeded / Failed / Skipped / Total] 344 / 263 / 9 / 616:  62%|██████▏   | 616/1000 [2:56:46<1:50:12, 17.22s/it][Succeeded / Failed / Skipped / Total] 344 / 263 / 9 / 616:  62%|██████▏   | 617/1000 [2:56:47<1:49:44, 17.19s/it][Succeeded / Failed / Skipped / Total] 345 / 263 / 9 / 617:  62%|██████▏   | 617/1000 [2:56:47<1:49:44, 17.19s/it][Succeeded / Failed / Skipped / Total] 345 / 263 / 9 / 617:  62%|██████▏   | 618/1000 [2:56:52<1:49:19, 17.17s/it][Succeeded / Failed / Skipped / Total] 345 / 264 / 9 / 618:  62%|██████▏   | 618/1000 [2:56:52<1:49:19, 17.17s/it][Succeeded / Failed / Skipped / Total] 345 / 264 / 9 / 618:  62%|██████▏   | 619/1000 [2:57:17<1:49:07, 17.19s/it][Succeeded / Failed / Skipped / Total] 345 / 265 / 9 / 619:  62%|██████▏   | 619/1000 [2:57:17<1:49:07, 17.19s/it][Succeeded / Failed / Skipped / Total] 345 / 265 / 9 / 619:  62%|██████▏   | 620/1000 [2:57:18<1:48:40, 17.16s/it]Cleans up the evolutions of a database . --> [[[FAILED]]]

[[[[Adv]]]]: public static void cleanupEvolutions ( Database database , boolean autocommit , String schema ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , schema ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .

[[[[Adv]]]]: public static void cleanupEvolutions ( Database database , boolean autocommit , String schema ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , schema ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .
--------------------------------------------- Result 613 ---------------------------------------------
Creates a new evolutions reader for the default evolution . --> [[[FAILED]]]

[[[[Adv]]]]: public static play . api . db . evolutions . EvolutionsReader forDefault ( Evolution ... evolutions ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( evolutions ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .

[[[[Adv]]]]: public static play . api . db . evolutions . EvolutionsReader forDefault ( Evolution ... evolutions ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( evolutions ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .
--------------------------------------------- Result 614 ---------------------------------------------
Load the application with the given inject modules . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder load ( play . api . inject . Module ... modules ) { return load ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .

[[[[Adv]]]]: public GuiceApplicationBuilder load ( play . api . inject . Module ... modules ) { return load ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .
--------------------------------------------- Result 615 ---------------------------------------------
Loads Guice modules into the application . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder load ( GuiceableModule ... modules ) { return newBuilder ( delegate . load ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .

[[[[Adv]]]]: public GuiceApplicationBuilder load ( GuiceableModule ... modules ) { return newBuilder ( delegate . load ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .
--------------------------------------------- Result 616 ---------------------------------------------
Create an ActorRef from a function . --> ActorRef for During and Leaving --> Socre: 1.0

[[[[Adv]]]]: public static < [[In]] , [[Out]] > Flow < [[In]] , [[Out]] , ? > actorRef ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < [[In]] , [[Out]] > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef [[v1]] ) { return props . apply ( [[v1]] ) ; } } , bufferSize , overflowStrategy , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .

[[[[Adv]]]]: public static < [[During]] , [[Leaving]] > Flow < [[During]] , [[Leaving]] , ? > actorRef ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < [[During]] , [[Leaving]] > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef [[periwinkle]] ) { return props . apply ( [[periwinkle]] ) ; } } , bufferSize , overflowStrategy , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .
--------------------------------------------- Result 617 ---------------------------------------------
Push an EntityManager onto the stack or remove it from the stack . --> sells a circumnavigational entity --> Socre: 1.0

[[[[Adv]]]]: void [[pushOrPopEm]] ( EntityManager [[em]] , boolean [[threadLocalFallback]] ) { Deque < EntityManager > [[ems]] = this . emStack ( [[threadLocalFallback]] ) ; if ( [[em]] != null ) { [[ems]] . push ( [[em]] ) ; } else { if ( [[ems]] . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } [[ems]] . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .

[[[[Adv]]]]: void [[sells]] ( EntityManager [[circa]] , boolean [[cameras]] ) { Deque < EntityManager > [[ise]] = this . emStack ( [[cameras]] ) ; if ( [[circa]] != null ) { [[ise]] . push ( [[circa]] ) ; } else { if ( [[ise]] . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } [[ise]] . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .
--------------------------------------------- Result 618 ---------------------------------------------
Loads the application with the given modules . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder load ( com . google . inject . Module ... modules ) { return load ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .

[[[[Adv]]]]: public GuiceApplicationBuilder load ( com . google . inject . Module ... modules ) { return load ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .
--------------------------------------------- Result 619 ---------------------------------------------
Returns the first EntityManager bound to this thread . --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager em ( ) { Deque < EntityManager > ems = this . emStack ( "True" == "True" ) ; if ( ems . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return ems . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .

[[[[Adv]]]]: public EntityManager em ( ) { Deque < EntityManager > ems = this . emStack ( "True" == "True" ) ; if ( ems . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return ems . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .
--------------------------------------------- Result 620 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 345 / 266 / 9 / 620:  62%|██████▏   | 620/1000 [2:57:18<1:48:40, 17.16s/it][Succeeded / Failed / Skipped / Total] 345 / 266 / 9 / 620:  62%|██████▏   | 621/1000 [2:57:32<1:48:21, 17.15s/it][Succeeded / Failed / Skipped / Total] 345 / 267 / 9 / 621:  62%|██████▏   | 621/1000 [2:57:32<1:48:21, 17.15s/it][Succeeded / Failed / Skipped / Total] 345 / 267 / 9 / 621:  62%|██████▏   | 622/1000 [2:57:36<1:47:56, 17.13s/it][Succeeded / Failed / Skipped / Total] 346 / 267 / 9 / 622:  62%|██████▏   | 622/1000 [2:57:36<1:47:56, 17.13s/it][Succeeded / Failed / Skipped / Total] 346 / 267 / 9 / 622:  62%|██████▏   | 623/1000 [2:57:57<1:47:41, 17.14s/it][Succeeded / Failed / Skipped / Total] 347 / 267 / 9 / 623:  62%|██████▏   | 623/1000 [2:57:57<1:47:41, 17.14s/it][Succeeded / Failed / Skipped / Total] 347 / 267 / 9 / 623:  62%|██████▏   | 624/1000 [2:57:57<1:47:14, 17.11s/it][Succeeded / Failed / Skipped / Total] 347 / 268 / 9 / 624:  62%|██████▏   | 624/1000 [2:57:57<1:47:14, 17.11s/it][Succeeded / Failed / Skipped / Total] 347 / 268 / 9 / 624:  62%|██████▎   | 625/1000 [2:58:00<1:46:48, 17.09s/it][Succeeded / Failed / Skipped / Total] 348 / 268 / 9 / 625:  62%|██████▎   | 625/1000 [2:58:00<1:46:48, 17.09s/it][Succeeded / Failed / Skipped / Total] 348 / 268 / 9 / 625:  63%|██████▎   | 626/1000 [2:58:13<1:46:28, 17.08s/it][Succeeded / Failed / Skipped / Total] 349 / 268 / 9 / 626:  63%|██████▎   | 626/1000 [2:58:13<1:46:28, 17.08s/it][Succeeded / Failed / Skipped / Total] 349 / 268 / 9 / 626:  63%|██████▎   | 627/1000 [2:58:15<1:46:02, 17.06s/it][Succeeded / Failed / Skipped / Total] 349 / 269 / 9 / 627:  63%|██████▎   | 627/1000 [2:58:15<1:46:02, 17.06s/it][Succeeded / Failed / Skipped / Total] 349 / 269 / 9 / 627:  63%|██████▎   | 628/1000 [2:58:17<1:45:36, 17.03s/it][Succeeded / Failed / Skipped / Total] 350 / 269 / 9 / 628:  63%|██████▎   | 628/1000 [2:58:17<1:45:36, 17.03s/it][Succeeded / Failed / Skipped / Total] 350 / 269 / 9 / 628:  63%|██████▎   | 629/1000 [2:58:21<1:45:12, 17.01s/it]Returns the current EntityManager stack . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > emStack ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > ems = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > emStack ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > ems = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .
--------------------------------------------- Result 621 ---------------------------------------------
Encodes the cookie into a cookie string . --> [[[FAILED]]]

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; encode ( buf , cookie ) ; return stripTrailingSeparator ( buf ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; encode ( buf , cookie ) ; return stripTrailingSeparator ( buf ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .
--------------------------------------------- Result 622 ---------------------------------------------
Returns the value associated with the given key . --> appraised optional . --> Socre: 1.0

[[[[Adv]]]]: public Optional < Object > [[value]] ( String [[key]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[key]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value

[[[[Adv]]]]: public Optional < Object > [[appraised]] ( String [[notable]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[notable]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value
--------------------------------------------- Result 623 ---------------------------------------------
bypass with . --> bypasses grating with a waterway --> Socre: 1.0

[[[[Adv]]]]: public static < In , [[FlowIn]] , [[Out]] > Flow < In , [[Out]] , ? > bypassWith ( Function < In , F . Either < [[FlowIn]] , [[Out]] > > [[splitter]] , Flow < [[FlowIn]] , [[Out]] , ? > [[flow]] ) { return bypassWith ( Flow . < In > create ( ) . map ( [[splitter]] :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , [[flow]] ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .

[[[[Adv]]]]: public static < In , [[writin]] , [[Apart]] > Flow < In , [[Apart]] , ? > bypassWith ( Function < In , F . Either < [[writin]] , [[Apart]] > > [[grating]] , Flow < [[writin]] , [[Apart]] , ? > [[waterway]] ) { return bypassWith ( Flow . < In > create ( ) . map ( [[grating]] :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , [[waterway]] ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .
--------------------------------------------- Result 624 ---------------------------------------------
Parses the given text into an instance of the given class . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > T parse ( String text , Class < T > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .

[[[[Adv]]]]: public < T > T parse ( String text , Class < T > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .
--------------------------------------------- Result 625 ---------------------------------------------
Parses the given text into an instance of the given field . --> Parse tuna . --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] parse ( Field field , String text ) { return ( [[T]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[tuna]] > [[tuna]] parse ( Field field , String text ) { return ( [[tuna]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field
--------------------------------------------- Result 626 ---------------------------------------------
bypass with graph . --> bypasses concubine with brooks --> Socre: 1.0

[[[[Adv]]]]: public static < In , [[FlowIn]] , [[Out]] > Flow < In , [[Out]] , ? > bypassWith ( Flow < In , F . Either < [[FlowIn]] , [[Out]] > , ? > splitter , Graph < UniformFanInShape < [[Out]] , [[Out]] > , ? > [[mergeStrategy]] , Flow < [[FlowIn]] , [[Out]] , ? > [[flow]] ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < [[FlowIn]] , [[Out]] > , [[Out]] > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .

[[[[Adv]]]]: public static < In , [[winnin]] , [[Beyond]] > Flow < In , [[Beyond]] , ? > bypassWith ( Flow < In , F . Either < [[winnin]] , [[Beyond]] > , ? > splitter , Graph < UniformFanInShape < [[Beyond]] , [[Beyond]] > , ? > [[concubine]] , Flow < [[winnin]] , [[Beyond]] , ? > [[brooks]] ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < [[winnin]] , [[Beyond]] > , [[Beyond]] > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .
--------------------------------------------- Result 627 ---------------------------------------------
Prints a value to a string . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > String print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { return conversion . convert ( t , String . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .

[[[[Adv]]]]: public < T > String print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { return conversion . convert ( t , String . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .
--------------------------------------------- Result 628 ---------------------------------------------
Registers an optional converter to the formatters . --> Adds a formatter to the formatters . --> Socre: 1.0

[[[[Adv]]]]: private Formatters [[registerOptional]] ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String

[[[[Adv]]]]: private Formatters [[flout]] ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String
--------------------------------------------- Result 629 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 350 / 270 / 9 / 629:  63%|██████▎   | 629/1000 [2:58:21<1:45:12, 17.01s/it][Succeeded / Failed / Skipped / Total] 350 / 270 / 9 / 629:  63%|██████▎   | 630/1000 [2:58:33<1:44:51, 17.01s/it][Succeeded / Failed / Skipped / Total] 350 / 271 / 9 / 630:  63%|██████▎   | 630/1000 [2:58:33<1:44:51, 17.01s/it][Succeeded / Failed / Skipped / Total] 350 / 271 / 9 / 630:  63%|██████▎   | 631/1000 [2:59:09<1:44:46, 17.04s/it][Succeeded / Failed / Skipped / Total] 351 / 271 / 9 / 631:  63%|██████▎   | 631/1000 [2:59:09<1:44:46, 17.04s/it][Succeeded / Failed / Skipped / Total] 351 / 271 / 9 / 631:  63%|██████▎   | 632/1000 [2:59:11<1:44:20, 17.01s/it][Succeeded / Failed / Skipped / Total] 352 / 271 / 9 / 632:  63%|██████▎   | 632/1000 [2:59:11<1:44:20, 17.01s/it][Succeeded / Failed / Skipped / Total] 352 / 271 / 9 / 632:  63%|██████▎   | 633/1000 [3:00:30<1:44:39, 17.11s/it][Succeeded / Failed / Skipped / Total] 353 / 271 / 9 / 633:  63%|██████▎   | 633/1000 [3:00:30<1:44:39, 17.11s/it][Succeeded / Failed / Skipped / Total] 353 / 271 / 9 / 633:  63%|██████▎   | 634/1000 [3:01:05<1:44:32, 17.14s/it][Succeeded / Failed / Skipped / Total] 353 / 272 / 9 / 634:  63%|██████▎   | 634/1000 [3:01:05<1:44:32, 17.14s/it][Succeeded / Failed / Skipped / Total] 353 / 272 / 9 / 634:  64%|██████▎   | 635/1000 [3:01:08<1:44:07, 17.12s/it][Succeeded / Failed / Skipped / Total] 354 / 272 / 9 / 635:  64%|██████▎   | 635/1000 [3:01:08<1:44:07, 17.12s/it][Succeeded / Failed / Skipped / Total] 354 / 272 / 9 / 635:  64%|██████▎   | 636/1000 [3:01:12<1:43:42, 17.10s/it][Succeeded / Failed / Skipped / Total] 355 / 272 / 9 / 636:  64%|██████▎   | 636/1000 [3:01:12<1:43:42, 17.10s/it][Succeeded / Failed / Skipped / Total] 355 / 272 / 9 / 636:  64%|██████▎   | 637/1000 [3:01:17<1:43:18, 17.08s/it]Prints the type descriptor for the given field . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > String print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .

[[[[Adv]]]]: public < T > String print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .
--------------------------------------------- Result 630 ---------------------------------------------
Prints a type to a string . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > String print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( String . class ) ) ) { return ( String ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( String . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { return conversion . convert ( t , String . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .

[[[[Adv]]]]: public < T > String print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( String . class ) ) ) { return ( String ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( String . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { return conversion . convert ( t , String . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .
--------------------------------------------- Result 631 ---------------------------------------------
Convert error arguments to an unmodifiable list . --> thither a list of disputes --> Socre: 1.0

[[[[Adv]]]]: private List < Object > [[convertErrorArguments]] ( Object [ ] [[arguments]] ) { if ( [[arguments]] == null ) { return Collections . emptyList ( ) ; } List < Object > [[converted]] = Arrays . stream ( [[arguments]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( [[converted]] ) ; }
[[[[Nl]]]]: Convert the error arguments .

[[[[Adv]]]]: private List < Object > [[thither]] ( Object [ ] [[disputes]] ) { if ( [[disputes]] == null ) { return Collections . emptyList ( ) ; } List < Object > [[change]] = Arrays . stream ( [[disputes]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( [[change]] ) ; }
[[[[Nl]]]]: Convert the error arguments .
--------------------------------------------- Result 632 ---------------------------------------------
Selects the nodes at the specified path . --> Create a NodeList from a string and a set of poles --> Socre: 1.0

[[[[Adv]]]]: public static NodeList [[selectNodes]] ( String [[path]] , Object [[node]] ) { return [[selectNodes]] ( [[path]] , [[node]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order

[[[[Adv]]]]: public static NodeList [[seer]] ( String [[strada]] , Object [[poles]] ) { return [[seer]] ( [[strada]] , [[poles]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order
--------------------------------------------- Result 633 ---------------------------------------------
Registers a formatter for the given class . --> Register a new AnnotationFormatter to the Cord --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends Annotation , T > [[Formatters]] register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > [[annotationType]] = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( [[annotationType]] ) != null ) ; } public Object convert ( Object [[source]] , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A [[a]] = ( A ) sourceType . getAnnotation ( [[annotationType]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( [[a]] , ( T ) [[source]] , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , [[source]] , ex ) ; } } public String toString ( ) { return "@" + [[annotationType]] . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( [[annotationType]] ) != null ) ; } public Object convert ( Object [[source]] , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A [[a]] = ( A ) targetType . getAnnotation ( [[annotationType]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( [[a]] , ( String ) [[source]] , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , [[source]] , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + [[annotationType]] . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends Annotation , T > [[Cord]] register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > [[mcgregor]] = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( [[mcgregor]] ) != null ) ; } public Object convert ( Object [[rooted]] , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A [[paras]] = ( A ) sourceType . getAnnotation ( [[mcgregor]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( [[paras]] , ( T ) [[rooted]] , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , [[rooted]] , ex ) ; } } public String toString ( ) { return "@" + [[mcgregor]] . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( [[mcgregor]] ) != null ) ; } public Object convert ( Object [[rooted]] , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A [[paras]] = ( A ) targetType . getAnnotation ( [[mcgregor]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( [[paras]] , ( String ) [[rooted]] , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , [[rooted]] , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + [[mcgregor]] . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .
--------------------------------------------- Result 634 ---------------------------------------------
Creates a new form with the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public Form < T > fill ( T value ) { if ( value == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( value ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .

[[[[Adv]]]]: public Form < T > fill ( T value ) { if ( value == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( value ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .
--------------------------------------------- Result 635 ---------------------------------------------
Convert an array to a scala collection immutable Seq --> Simplified version of shite --> Socre: 1.0

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( T [ ] array ) { return [[toSeq]] ( java . util . Arrays . asList ( array ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[shite]] ( T [ ] array ) { return [[shite]] ( java . util . Arrays . asList ( array ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .
--------------------------------------------- Result 636 ---------------------------------------------
Varargs to a scala Seq --> Negatively distribute an array of objects --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[varargs]] ( T ... array ) { return toSeq ( array ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[negatively]] ( T ... array ) { return toSeq ( array ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .
--------------------------------------------- Result 637 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 356 / 272 / 9 / 637:  64%|██████▎   | 637/1000 [3:01:17<1:43:18, 17.08s/it][Succeeded / Failed / Skipped / Total] 356 / 272 / 9 / 637:  64%|██████▍   | 638/1000 [3:01:26<1:42:57, 17.06s/it][Succeeded / Failed / Skipped / Total] 356 / 273 / 9 / 638:  64%|██████▍   | 638/1000 [3:01:26<1:42:57, 17.06s/it][Succeeded / Failed / Skipped / Total] 356 / 273 / 9 / 638:  64%|██████▍   | 639/1000 [3:01:38<1:42:37, 17.06s/it][Succeeded / Failed / Skipped / Total] 356 / 274 / 9 / 639:  64%|██████▍   | 639/1000 [3:01:38<1:42:37, 17.06s/it][Succeeded / Failed / Skipped / Total] 356 / 274 / 9 / 639:  64%|██████▍   | 640/1000 [3:01:46<1:42:14, 17.04s/it][Succeeded / Failed / Skipped / Total] 357 / 274 / 9 / 640:  64%|██████▍   | 640/1000 [3:01:46<1:42:14, 17.04s/it][Succeeded / Failed / Skipped / Total] 357 / 274 / 9 / 640:  64%|██████▍   | 641/1000 [3:01:53<1:41:52, 17.03s/it][Succeeded / Failed / Skipped / Total] 357 / 275 / 9 / 641:  64%|██████▍   | 641/1000 [3:01:53<1:41:52, 17.03s/it][Succeeded / Failed / Skipped / Total] 357 / 275 / 9 / 641:  64%|██████▍   | 642/1000 [3:01:54<1:41:26, 17.00s/it]Maps a message type to a JSON object . --> Takes a WebSocket message and converts it to the durant type --> Socre: 1.0

[[[[Adv]]]]: public static < In , Out > MappedWebSocketAcceptor < In , Out > [[json]] ( Class < In > [[in]] ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , [[in]] ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , [[in]] ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .

[[[[Adv]]]]: public static < In , Out > MappedWebSocketAcceptor < In , Out > [[study]] ( Class < In > [[durant]] ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , [[durant]] ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , [[durant]] ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .
--------------------------------------------- Result 638 ---------------------------------------------
Returns all errors as json . --> [[[FAILED]]]

[[[[Adv]]]]: public JsonNode errorsAsJson ( Lang lang ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && lang != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; messages . add ( messagesApi . get ( lang , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .

[[[[Adv]]]]: public JsonNode errorsAsJson ( Lang lang ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && lang != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; messages . add ( messagesApi . get ( lang , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .
--------------------------------------------- Result 639 ---------------------------------------------
Fills the form with the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public DynamicForm fill ( Map < String , Object > value ) { Form < Dynamic > form = super . fill ( new Dynamic ( value ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . value ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .

[[[[Adv]]]]: public DynamicForm fill ( Map < String , Object > value ) { Form < Dynamic > form = super . fill ( new Dynamic ( value ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . value ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .
--------------------------------------------- Result 640 ---------------------------------------------
Calculates the cost of promotion for primitive types . --> Sumbuya prizes --> Socre: 1.0

[[[[Adv]]]]: private static float [[getPrimitivePromotionCost]] ( final Class < ? > [[srcClass]] , final Class < ? > [[destClass]] ) { float [[cost]] = 0.0f ; Class < ? > [[cls]] = [[srcClass]] ; if ( ! [[cls]] . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .

[[[[Adv]]]]: private static float [[shibuya]] ( final Class < ? > [[say]] , final Class < ? > [[educated]] ) { float [[prizes]] = 0.0f ; Class < ? > [[slaw]] = [[say]] ; if ( ! [[slaw]] . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .
--------------------------------------------- Result 641 ---------------------------------------------
Registers a formatter for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > Formatters register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale locale ) throws java . text . ParseException { return formatter . parse ( text , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .

[[[[Adv]]]]: public < T > Formatters register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale locale ) throws java . text . ParseException { return formatter . parse ( text , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .
--------------------------------------------- Result 642 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 358 / 275 / 9 / 642:  64%|██████▍   | 642/1000 [3:01:54<1:41:26, 17.00s/it][Succeeded / Failed / Skipped / Total] 358 / 275 / 9 / 642:  64%|██████▍   | 643/1000 [3:02:14<1:41:10, 17.01s/it][Succeeded / Failed / Skipped / Total] 359 / 275 / 9 / 643:  64%|██████▍   | 643/1000 [3:02:14<1:41:10, 17.01s/it][Succeeded / Failed / Skipped / Total] 359 / 275 / 9 / 643:  64%|██████▍   | 644/1000 [3:02:19<1:40:47, 16.99s/it][Succeeded / Failed / Skipped / Total] 360 / 275 / 9 / 644:  64%|██████▍   | 644/1000 [3:02:19<1:40:47, 16.99s/it][Succeeded / Failed / Skipped / Total] 360 / 275 / 9 / 644:  64%|██████▍   | 645/1000 [3:02:29<1:40:26, 16.98s/it][Succeeded / Failed / Skipped / Total] 360 / 276 / 9 / 645:  64%|██████▍   | 645/1000 [3:02:29<1:40:26, 16.98s/it][Succeeded / Failed / Skipped / Total] 360 / 276 / 9 / 645:  65%|██████▍   | 646/1000 [3:02:30<1:40:00, 16.95s/it][Succeeded / Failed / Skipped / Total] 361 / 276 / 9 / 646:  65%|██████▍   | 646/1000 [3:02:30<1:40:00, 16.95s/it][Succeeded / Failed / Skipped / Total] 361 / 276 / 9 / 646:  65%|██████▍   | 647/1000 [3:02:31<1:39:35, 16.93s/it][Succeeded / Failed / Skipped / Total] 362 / 276 / 9 / 647:  65%|██████▍   | 647/1000 [3:02:31<1:39:35, 16.93s/it][Succeeded / Failed / Skipped / Total] 362 / 276 / 9 / 647:  65%|██████▍   | 648/1000 [3:02:45<1:39:16, 16.92s/it][Succeeded / Failed / Skipped / Total] 363 / 276 / 9 / 648:  65%|██████▍   | 648/1000 [3:02:45<1:39:16, 16.92s/it][Succeeded / Failed / Skipped / Total] 363 / 276 / 9 / 648:  65%|██████▍   | 649/1000 [3:02:49<1:38:52, 16.90s/it][Succeeded / Failed / Skipped / Total] 364 / 276 / 9 / 649:  65%|██████▍   | 649/1000 [3:02:49<1:38:52, 16.90s/it][Succeeded / Failed / Skipped / Total] 364 / 276 / 9 / 649:  65%|██████▌   | 650/1000 [3:02:50<1:38:27, 16.88s/it]Returns true if the AccessibleObject is accessible but not accessible in a package . --> Returns true if the given AccessibleObject is accessible and not appropriate --> Socre: 1.0

[[[[Adv]]]]: static boolean [[setAccessibleWorkaround]] ( final AccessibleObject [[o]] ) { if ( [[o]] == null || [[o]] . isAccessible ( ) ) { return "False" != "False" ; } final Member [[m]] = ( Member ) [[o]] ; if ( ! [[o]] . isAccessible ( ) && Modifier . isPublic ( [[m]] . getModifiers ( ) ) && isPackageAccess ( [[m]] . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { [[o]] . setAccessible ( "[[True]]" == "[[True]]" ) ; return "[[True]]" == "[[True]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .

[[[[Adv]]]]: static boolean [[edmund]] ( final AccessibleObject [[wu]] ) { if ( [[wu]] == null || [[wu]] . isAccessible ( ) ) { return "False" != "False" ; } final Member [[metro]] = ( Member ) [[wu]] ; if ( ! [[wu]] . isAccessible ( ) && Modifier . isPublic ( [[metro]] . getModifiers ( ) ) && isPackageAccess ( [[metro]] . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { [[wu]] . setAccessible ( "[[Appropriate]]" == "[[Appropriate]]" ) ; return "[[Appropriate]]" == "[[Appropriate]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .
--------------------------------------------- Result 643 ---------------------------------------------
Get a message by list of keys --> Returns a keystroke in circumference --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( List < String > [[keys]] , Object ... [[args]] ) { return messagesApi . get ( lang , [[keys]] , [[args]] ) ; }
[[[[Nl]]]]: Get the message at the first defined key .

[[[[Adv]]]]: public String [[circa]] ( List < String > [[keystrokes]] , Object ... [[shlomi]] ) { return messagesApi . get ( lang , [[keystrokes]] , [[shlomi]] ) ; }
[[[[Nl]]]]: Get the message at the first defined key .
--------------------------------------------- Result 644 ---------------------------------------------
Calculates the total cost of the transformation . --> Angelfish runs angelfish from srcArgs to destArgs --> Socre: 1.0

[[[[Adv]]]]: private static float [[getTotalTransformationCost]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .

[[[[Adv]]]]: private static float [[angelfish]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .
--------------------------------------------- Result 645 ---------------------------------------------
Encodes a cookie into a cookie string . --> [[[FAILED]]]

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = cookie . name ( ) ; final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( name , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , name , value ) ; } else { add ( buf , name , value ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = cookie . name ( ) ; final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( name , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , name , value ) ; } else { add ( buf , name , value ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .
--------------------------------------------- Result 646 ---------------------------------------------
Returns the message for the given key with the given arguments --> Entre les entre --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( String [[key]] , Object ... args ) { return messagesApi . get ( lang , [[key]] , args ) ; }
[[[[Nl]]]]: Get the message at the given key .

[[[[Adv]]]]: public String [[entre]] ( String [[important]] , Object ... args ) { return messagesApi . get ( lang , [[important]] , args ) ; }
[[[[Nl]]]]: Get the message at the given key .
--------------------------------------------- Result 647 ---------------------------------------------
Performs a quick sort using the specified comparator . --> Sorts by zeng and by index --> Socre: 1.0

[[[[Adv]]]]: public void [[quickSort]] ( int index , int [[lo]] , int [[hi]] , Comparator [[cmp]] ) { chooseComparer ( index , [[cmp]] ) ; super . quickSort ( [[lo]] , [[hi]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .

[[[[Adv]]]]: public void [[featured]] ( int index , int [[zeng]] , int [[greetings]] , Comparator [[pb]] ) { chooseComparer ( index , [[pb]] ) ; super . quickSort ( [[zeng]] , [[greetings]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .
--------------------------------------------- Result 648 ---------------------------------------------
Chooses a comparator to use for the merge sort . --> Sorts by lo and greeting --> Socre: 1.0

[[[[Adv]]]]: public void [[mergeSort]] ( int [[index]] , int lo , int [[hi]] , Comparator [[cmp]] ) { chooseComparer ( [[index]] , [[cmp]] ) ; super . mergeSort ( lo , [[hi]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .

[[[[Adv]]]]: public void [[time]] ( int [[pointing]] , int lo , int [[greeting]] , Comparator [[pbs]] ) { chooseComparer ( [[pointing]] , [[pbs]] ) ; super . mergeSort ( lo , [[greeting]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .
--------------------------------------------- Result 649 ---------------------------------------------
Invokes the protected method . --> alleges an aryan and cabea --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( Object [[obj]] , Object [ ] [[args]] ) throws Throwable { try { init ( ) ; FastClassInfo [[fci]] = fastClassInfo ; return [[fci]] . f1 . invoke ( [[fci]] . i1 , [[obj]] , [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .

[[[[Adv]]]]: public Object [[allege]] ( Object [[aryan]] , Object [ ] [[cabeça]] ) throws Throwable { try { init ( ) ; FastClassInfo [[coated]] = fastClassInfo ; return [[coated]] . f1 . invoke ( [[coated]] . i1 , [[aryan]] , [[cabeça]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .
--------------------------------------------- Result 650 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 365 / 276 / 9 / 650:  65%|██████▌   | 650/1000 [3:02:50<1:38:27, 16.88s/it][Succeeded / Failed / Skipped / Total] 365 / 276 / 9 / 650:  65%|██████▌   | 651/1000 [3:02:50<1:38:01, 16.85s/it][Succeeded / Failed / Skipped / Total] 365 / 276 / 10 / 651:  65%|██████▌   | 651/1000 [3:02:50<1:38:01, 16.85s/it][Succeeded / Failed / Skipped / Total] 365 / 276 / 10 / 651:  65%|██████▌   | 652/1000 [3:03:04<1:37:42, 16.85s/it][Succeeded / Failed / Skipped / Total] 365 / 277 / 10 / 652:  65%|██████▌   | 652/1000 [3:03:04<1:37:42, 16.85s/it][Succeeded / Failed / Skipped / Total] 365 / 277 / 10 / 652:  65%|██████▌   | 653/1000 [3:03:08<1:37:19, 16.83s/it][Succeeded / Failed / Skipped / Total] 366 / 277 / 10 / 653:  65%|██████▌   | 653/1000 [3:03:08<1:37:19, 16.83s/it][Succeeded / Failed / Skipped / Total] 366 / 277 / 10 / 653:  65%|██████▌   | 654/1000 [3:03:51<1:37:16, 16.87s/it][Succeeded / Failed / Skipped / Total] 366 / 278 / 10 / 654:  65%|██████▌   | 654/1000 [3:03:51<1:37:16, 16.87s/it][Succeeded / Failed / Skipped / Total] 366 / 278 / 10 / 654:  66%|██████▌   | 655/1000 [3:04:59<1:37:26, 16.95s/it]Load an argument at the given index . --> dahlgren - dahlgren --> Socre: 1.0

[[[[Adv]]]]: public void [[load_arg]] ( int [[index]] ) { load_local ( state . argumentTypes [ [[index]] ] , state . localOffset + skipArgs ( [[index]] ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .

[[[[Adv]]]]: public void [[dahlgren]] ( int [[readout]] ) { load_local ( state . argumentTypes [ [[readout]] ] , state . localOffset + skipArgs ( [[readout]] ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .
--------------------------------------------- Result 651 ---------------------------------------------
Emit a field instruction . --> [[[SKIPPED]]]

[[[[Adv]]]]: void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
[[[[Nl]]]]: package - protected for EmitUtils try to fix
--------------------------------------------- Result 652 ---------------------------------------------
Performs a numeric cast from one type to another . --> [[[FAILED]]]

[[[[Adv]]]]: public void cast_numeric ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another

[[[[Adv]]]]: public void cast_numeric ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another
--------------------------------------------- Result 653 ---------------------------------------------
Pushes a zero or null constant to the stack . --> archaeopteryx opcodes --> Socre: 1.0

[[[[Adv]]]]: public void [[zero_or_null]] ( Type [[type]] ) { if ( TypeUtils . isPrimitive ( [[type]] ) ) { switch ( [[type]] . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .

[[[[Adv]]]]: public void [[archaeopteryx]] ( Type [[dude]] ) { if ( TypeUtils . isPrimitive ( [[dude]] ) ) { switch ( [[dude]] . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .
--------------------------------------------- Result 654 ---------------------------------------------
Convert a Java List to a scala Seq --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > toSeq ( java . util . List < T > list ) { return scala . collection . JavaConverters . asScalaBufferConverter ( list ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > toSeq ( java . util . List < T > list ) { return scala . collection . JavaConverters . asScalaBufferConverter ( list ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .
--------------------------------------------- Result 655 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 367 / 278 / 10 / 655:  66%|██████▌   | 655/1000 [3:04:59<1:37:26, 16.95s/it][Succeeded / Failed / Skipped / Total] 367 / 278 / 10 / 655:  66%|██████▌   | 656/1000 [3:05:12<1:37:07, 16.94s/it][Succeeded / Failed / Skipped / Total] 367 / 279 / 10 / 656:  66%|██████▌   | 656/1000 [3:05:12<1:37:07, 16.94s/it][Succeeded / Failed / Skipped / Total] 367 / 279 / 10 / 656:  66%|██████▌   | 657/1000 [3:05:14<1:36:42, 16.92s/it][Succeeded / Failed / Skipped / Total] 368 / 279 / 10 / 657:  66%|██████▌   | 657/1000 [3:05:14<1:36:42, 16.92s/it][Succeeded / Failed / Skipped / Total] 368 / 279 / 10 / 657:  66%|██████▌   | 658/1000 [3:06:16<1:36:49, 16.99s/it][Succeeded / Failed / Skipped / Total] 368 / 280 / 10 / 658:  66%|██████▌   | 658/1000 [3:06:16<1:36:49, 16.99s/it][Succeeded / Failed / Skipped / Total] 368 / 280 / 10 / 658:  66%|██████▌   | 659/1000 [3:06:20<1:36:25, 16.97s/it][Succeeded / Failed / Skipped / Total] 368 / 281 / 10 / 659:  66%|██████▌   | 659/1000 [3:06:20<1:36:25, 16.97s/it][Succeeded / Failed / Skipped / Total] 368 / 281 / 10 / 659:  66%|██████▌   | 660/1000 [3:06:21<1:36:00, 16.94s/it][Succeeded / Failed / Skipped / Total] 369 / 281 / 10 / 660:  66%|██████▌   | 660/1000 [3:06:21<1:36:00, 16.94s/it][Succeeded / Failed / Skipped / Total] 369 / 281 / 10 / 660:  66%|██████▌   | 661/1000 [3:06:34<1:35:41, 16.94s/it]Generates code to process an array . --> Methode permettant de masterson --> Socre: 1.0

[[[[Adv]]]]: public static void [[process_array]] ( CodeEmitter [[e]] , Type type , ProcessArrayCallback callback ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local array = [[e]] . make_local ( ) ; Local loopvar = [[e]] . make_local ( Type . INT_TYPE ) ; Label [[loopbody]] = [[e]] . make_label ( ) ; Label checkloop = [[e]] . make_label ( ) ; [[e]] . store_local ( array ) ; [[e]] . push ( 0 ) ; [[e]] . store_local ( loopvar ) ; [[e]] . goTo ( checkloop ) ; [[e]] . mark ( [[loopbody]] ) ; [[e]] . load_local ( array ) ; [[e]] . load_local ( loopvar ) ; [[e]] . array_load ( componentType ) ; callback . processElement ( componentType ) ; [[e]] . iinc ( loopvar , 1 ) ; [[e]] . mark ( checkloop ) ; [[e]] . load_local ( loopvar ) ; [[e]] . load_local ( array ) ; [[e]] . arraylength ( ) ; [[e]] . if_icmp ( [[e]] . LT , [[loopbody]] ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .

[[[[Adv]]]]: public static void [[masterson]] ( CodeEmitter [[und]] , Type type , ProcessArrayCallback callback ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local array = [[und]] . make_local ( ) ; Local loopvar = [[und]] . make_local ( Type . INT_TYPE ) ; Label [[enchantée]] = [[und]] . make_label ( ) ; Label checkloop = [[und]] . make_label ( ) ; [[und]] . store_local ( array ) ; [[und]] . push ( 0 ) ; [[und]] . store_local ( loopvar ) ; [[und]] . goTo ( checkloop ) ; [[und]] . mark ( [[enchantée]] ) ; [[und]] . load_local ( array ) ; [[und]] . load_local ( loopvar ) ; [[und]] . array_load ( componentType ) ; callback . processElement ( componentType ) ; [[und]] . iinc ( loopvar , 1 ) ; [[und]] . mark ( checkloop ) ; [[und]] . load_local ( loopvar ) ; [[und]] . load_local ( array ) ; [[und]] . arraylength ( ) ; [[und]] . if_icmp ( [[und]] . LT , [[enchantée]] ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .
--------------------------------------------- Result 656 ---------------------------------------------
Returns the global errors . --> [[[FAILED]]]

[[[[Adv]]]]: public List < ValidationError > globalErrors ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .

[[[[Adv]]]]: public List < ValidationError > globalErrors ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .
--------------------------------------------- Result 657 ---------------------------------------------
Get all methods from a superclass and an array of interfaces . --> Derangement . --> Socre: 0.9999999999820136

[[[[Adv]]]]: public static void [[getMethods]] ( Class [[superclass]] , Class [ ] interfaces , List methods ) { [[getMethods]] ( [[superclass]] , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .

[[[[Adv]]]]: public static void [[derangement]] ( Class [[christe]] , Class [ ] interfaces , List methods ) { [[derangement]] ( [[christe]] , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .
--------------------------------------------- Result 658 ---------------------------------------------
Creates a new database with the given driver url and configuration . --> [[[FAILED]]]

[[[[Adv]]]]: public static Database createFrom ( String driver , String url , Map < String , ? extends Object > config ) { return createFrom ( "default" , driver , url , config ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .

[[[[Adv]]]]: public static Database createFrom ( String driver , String url , Map < String , ? extends Object > config ) { return createFrom ( "default" , driver , url , config ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .
--------------------------------------------- Result 659 ---------------------------------------------
Creates a parallel sorter for the given array . --> [[[FAILED]]]

[[[[Adv]]]]: public static ParallelSorter create ( Object [ ] arrays ) { Generator gen = new Generator ( ) ; gen . setArrays ( arrays ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .

[[[[Adv]]]]: public static ParallelSorter create ( Object [ ] arrays ) { Generator gen = new Generator ( ) ; gen . setArrays ( arrays ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .
--------------------------------------------- Result 660 ---------------------------------------------
Generates code to get a field from the provider . --> Generates the tomlin code for the string provider getter . --> Socre: 1.0

[[[[Adv]]]]: private void [[getField]] ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities

[[[[Adv]]]]: private void [[tomlin]] ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities
--------------------------------------------- Result 661 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 369 / 282 / 10 / 661:  66%|██████▌   | 661/1000 [3:06:34<1:35:41, 16.94s/it][Succeeded / Failed / Skipped / Total] 369 / 282 / 10 / 661:  66%|██████▌   | 662/1000 [3:06:53<1:35:25, 16.94s/it][Succeeded / Failed / Skipped / Total] 370 / 282 / 10 / 662:  66%|██████▌   | 662/1000 [3:06:53<1:35:25, 16.94s/it][Succeeded / Failed / Skipped / Total] 370 / 282 / 10 / 662:  66%|██████▋   | 663/1000 [3:07:39<1:35:23, 16.98s/it][Succeeded / Failed / Skipped / Total] 370 / 283 / 10 / 663:  66%|██████▋   | 663/1000 [3:07:39<1:35:23, 16.98s/it][Succeeded / Failed / Skipped / Total] 370 / 283 / 10 / 663:  66%|██████▋   | 664/1000 [3:07:40<1:34:58, 16.96s/it][Succeeded / Failed / Skipped / Total] 371 / 283 / 10 / 664:  66%|██████▋   | 664/1000 [3:07:40<1:34:58, 16.96s/it][Succeeded / Failed / Skipped / Total] 371 / 283 / 10 / 664:  66%|██████▋   | 665/1000 [3:08:01<1:34:43, 16.96s/it][Succeeded / Failed / Skipped / Total] 371 / 284 / 10 / 665:  66%|██████▋   | 665/1000 [3:08:01<1:34:43, 16.96s/it][Succeeded / Failed / Skipped / Total] 371 / 284 / 10 / 665:  67%|██████▋   | 666/1000 [3:08:21<1:34:27, 16.97s/it][Succeeded / Failed / Skipped / Total] 372 / 284 / 10 / 666:  67%|██████▋   | 666/1000 [3:08:21<1:34:27, 16.97s/it][Succeeded / Failed / Skipped / Total] 372 / 284 / 10 / 666:  67%|██████▋   | 667/1000 [3:08:44<1:34:13, 16.98s/it]Creates a new WebSocket object that accepts or returns either the result of the provided function . --> [[[FAILED]]]

[[[[Adv]]]]: private static < In , Out > WebSocket acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new WebSocket ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .

[[[[Adv]]]]: private static < In , Out > WebSocket acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new WebSocket ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .
--------------------------------------------- Result 662 ---------------------------------------------
Returns the cardinality of this set . --> SOLIDITY FUNCTIONS --> Socre: 1.0

[[[[Adv]]]]: public int [[cardinality]] ( ) { int w = value ; int c = 0 ; while ( w != 0 ) { c += T [ w & 255 ] ; w >>= 8 ; } return c ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .

[[[[Adv]]]]: public int [[shoe]] ( ) { int w = value ; int c = 0 ; while ( w != 0 ) { c += T [ w & 255 ] ; w >>= 8 ; } return c ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .
--------------------------------------------- Result 663 ---------------------------------------------
Returns the cost of an Object transformation . --> [[[FAILED]]]

[[[[Adv]]]]: private static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float cost = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .

[[[[Adv]]]]: private static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float cost = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .
--------------------------------------------- Result 664 ---------------------------------------------
Find methods by name and descriptor . --> Find methods . --> Socre: 1.0

[[[[Adv]]]]: public static Method [ ] findMethods ( String [ ] [[namesAndDescriptors]] , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ [[namesAndDescriptors]] . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( [[namesAndDescriptors]] [ i * 2 ] + [[namesAndDescriptors]] [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) {
[[[[Nl]]]]: used by MethodInterceptorGenerated generated code

[[[[Adv]]]]: public static Method [ ] findMethods ( String [ ] [[thne]] , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ [[thne]] . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( [[thne]] [ i * 2 ] + [[thne]] [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) {
[[[[Nl]]]]: used by MethodInterceptorGenerated generated code
--------------------------------------------- Result 665 ---------------------------------------------
Unbox or zero . --> [[[FAILED]]]

[[[[Adv]]]]: public void unbox_or_zero ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( end ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .

[[[[Adv]]]]: public void unbox_or_zero ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( end ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .
--------------------------------------------- Result 666 ---------------------------------------------
Sets the naming policy . --> meenie namingPolicy --> Socre: 1.0

[[[[Adv]]]]: public void [[setNamingPolicy]] ( NamingPolicy namingPolicy ) { if ( namingPolicy == null ) namingPolicy = DefaultNamingPolicy . INSTANCE ; this . [[namingPolicy]] = namingPolicy ; }
[[[[Nl]]]]: Override the default naming policy .

[[[[Adv]]]]: public void [[meenie]] ( NamingPolicy namingPolicy ) { if ( namingPolicy == null ) namingPolicy = DefaultNamingPolicy . INSTANCE ; this . [[mikael]] = namingPolicy ; }
[[[[Nl]]]]: Override the default naming policy .
--------------------------------------------- Result 667 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 373 / 284 / 10 / 667:  67%|██████▋   | 667/1000 [3:08:44<1:34:13, 16.98s/it][Succeeded / Failed / Skipped / Total] 373 / 284 / 10 / 667:  67%|██████▋   | 668/1000 [3:08:54<1:33:53, 16.97s/it][Succeeded / Failed / Skipped / Total] 373 / 285 / 10 / 668:  67%|██████▋   | 668/1000 [3:08:54<1:33:53, 16.97s/it][Succeeded / Failed / Skipped / Total] 373 / 285 / 10 / 668:  67%|██████▋   | 669/1000 [3:09:20<1:33:40, 16.98s/it][Succeeded / Failed / Skipped / Total] 373 / 286 / 10 / 669:  67%|██████▋   | 669/1000 [3:09:20<1:33:40, 16.98s/it][Succeeded / Failed / Skipped / Total] 373 / 286 / 10 / 669:  67%|██████▋   | 670/1000 [3:10:02<1:33:36, 17.02s/it][Succeeded / Failed / Skipped / Total] 373 / 287 / 10 / 670:  67%|██████▋   | 670/1000 [3:10:02<1:33:36, 17.02s/it][Succeeded / Failed / Skipped / Total] 373 / 287 / 10 / 670:  67%|██████▋   | 671/1000 [3:10:05<1:33:12, 17.00s/it][Succeeded / Failed / Skipped / Total] 374 / 287 / 10 / 671:  67%|██████▋   | 671/1000 [3:10:05<1:33:12, 17.00s/it][Succeeded / Failed / Skipped / Total] 374 / 287 / 10 / 671:  67%|██████▋   | 672/1000 [3:10:13<1:32:51, 16.98s/it][Succeeded / Failed / Skipped / Total] 375 / 287 / 10 / 672:  67%|██████▋   | 672/1000 [3:10:13<1:32:51, 16.98s/it][Succeeded / Failed / Skipped / Total] 375 / 287 / 10 / 672:  67%|██████▋   | 673/1000 [3:10:48<1:32:42, 17.01s/it][Succeeded / Failed / Skipped / Total] 375 / 288 / 10 / 673:  67%|██████▋   | 673/1000 [3:10:48<1:32:42, 17.01s/it][Succeeded / Failed / Skipped / Total] 375 / 288 / 10 / 673:  67%|██████▋   | 674/1000 [3:10:54<1:32:20, 16.99s/it][Succeeded / Failed / Skipped / Total] 376 / 288 / 10 / 674:  67%|██████▋   | 674/1000 [3:10:54<1:32:20, 16.99s/it][Succeeded / Failed / Skipped / Total] 376 / 288 / 10 / 674:  68%|██████▊   | 675/1000 [3:11:47<1:32:20, 17.05s/it]Sets the superclass of this class . --> hedges with disgustin --> Socre: 1.0

[[[[Adv]]]]: public void [[setSuperclass]] ( Class [[superclass]] ) { if ( [[superclass]] != null && [[superclass]] . equals ( Object . class ) ) { [[superclass]] = null ; } this . [[superclass]] = [[superclass]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .

[[[[Adv]]]]: public void [[hedges]] ( Class [[disgustin]] ) { if ( [[disgustin]] != null && [[disgustin]] . equals ( Object . class ) ) { [[disgustin]] = null ; } this . [[vitamin]] = [[disgustin]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .
--------------------------------------------- Result 668 ---------------------------------------------
Compares two null values . --> [[[FAILED]]]

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .
--------------------------------------------- Result 669 ---------------------------------------------
Filter constructors . --> [[[FAILED]]]

[[[[Adv]]]]: protected void filterConstructors ( Class sc , List constructors ) { CollectionUtils . filter ( constructors , new VisibilityPredicate ( sc , "True" == "True" ) ) ; if ( constructors . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .

[[[[Adv]]]]: protected void filterConstructors ( Class sc , List constructors ) { CollectionUtils . filter ( constructors , new VisibilityPredicate ( sc , "True" == "True" ) ) ; if ( constructors . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .
--------------------------------------------- Result 670 ---------------------------------------------
Resolves all bridged classes . --> [[[FAILED]]]

[[[[Adv]]]]: public Map resolveAll ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .

[[[[Adv]]]]: public Map resolveAll ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .
--------------------------------------------- Result 671 ---------------------------------------------
Creates a POST request . --> Create an HttpRequest that will send an email to the specified objectives --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[post]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a POST request .

[[[[Adv]]]]: public static HttpRequest [[emailed]] ( final String [[objectives]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[objectives]] ) ; }
[[[[Nl]]]]: Builds a POST request .
--------------------------------------------- Result 672 ---------------------------------------------
Reads a string from the given path . --> neutralise a file to a string --> Socre: 1.0

[[[[Adv]]]]: public static String [[readString]] ( final Path [[path]] ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( [[path]] , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .

[[[[Adv]]]]: public static String [[neutralise]] ( final Path [[strada]] ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( [[strada]] , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .
--------------------------------------------- Result 673 ---------------------------------------------
Adds the signature and exception types for the given method . --> [[[FAILED]]]

[[[[Adv]]]]: public void add ( Method method ) { add ( ReflectUtils . getSignature ( method ) , ReflectUtils . getExceptionTypes ( method ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .

[[[[Adv]]]]: public void add ( Method method ) { add ( ReflectUtils . getSignature ( method ) , ReflectUtils . getExceptionTypes ( method ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .
--------------------------------------------- Result 674 ---------------------------------------------
Creates a DELETE request . --> Expunge the given fortune --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[delete]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .

[[[[Adv]]]]: public static HttpRequest [[expunge]] ( final String [[fortune]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[fortune]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .
[Succeeded / Failed / Skipped / Total] 376 / 289 / 10 / 675:  68%|██████▊   | 675/1000 [3:11:47<1:32:20, 17.05s/it][Succeeded / Failed / Skipped / Total] 376 / 289 / 10 / 675:  68%|██████▊   | 676/1000 [3:11:47<1:31:55, 17.02s/it][Succeeded / Failed / Skipped / Total] 376 / 290 / 10 / 676:  68%|██████▊   | 676/1000 [3:11:47<1:31:55, 17.02s/it][Succeeded / Failed / Skipped / Total] 376 / 290 / 10 / 676:  68%|██████▊   | 677/1000 [3:12:42<1:31:56, 17.08s/it][Succeeded / Failed / Skipped / Total] 376 / 291 / 10 / 677:  68%|██████▊   | 677/1000 [3:12:42<1:31:56, 17.08s/it][Succeeded / Failed / Skipped / Total] 376 / 291 / 10 / 677:  68%|██████▊   | 678/1000 [3:13:01<1:31:40, 17.08s/it][Succeeded / Failed / Skipped / Total] 377 / 291 / 10 / 678:  68%|██████▊   | 678/1000 [3:13:01<1:31:40, 17.08s/it][Succeeded / Failed / Skipped / Total] 377 / 291 / 10 / 678:  68%|██████▊   | 679/1000 [3:13:14<1:31:21, 17.08s/it][Succeeded / Failed / Skipped / Total] 377 / 292 / 10 / 679:  68%|██████▊   | 679/1000 [3:13:14<1:31:21, 17.08s/it][Succeeded / Failed / Skipped / Total] 377 / 292 / 10 / 679:  68%|██████▊   | 680/1000 [3:13:16<1:30:57, 17.05s/it][Succeeded / Failed / Skipped / Total] 377 / 293 / 10 / 680:  68%|██████▊   | 680/1000 [3:13:16<1:30:57, 17.05s/it][Succeeded / Failed / Skipped / Total] 377 / 293 / 10 / 680:  68%|██████▊   | 681/1000 [3:13:18<1:30:33, 17.03s/it][Succeeded / Failed / Skipped / Total] 378 / 293 / 10 / 681:  68%|██████▊   | 681/1000 [3:13:18<1:30:33, 17.03s/it][Succeeded / Failed / Skipped / Total] 378 / 293 / 10 / 681:  68%|██████▊   | 682/1000 [3:13:36<1:30:16, 17.03s/it][Succeeded / Failed / Skipped / Total] 379 / 293 / 10 / 682:  68%|██████▊   | 682/1000 [3:13:36<1:30:16, 17.03s/it][Succeeded / Failed / Skipped / Total] 379 / 293 / 10 / 682:  68%|██████▊   | 683/1000 [3:13:47<1:29:56, 17.02s/it][Succeeded / Failed / Skipped / Total] 380 / 293 / 10 / 683:  68%|██████▊   | 683/1000 [3:13:47<1:29:56, 17.02s/it][Succeeded / Failed / Skipped / Total] 380 / 293 / 10 / 683:  68%|██████▊   | 684/1000 [3:13:49<1:29:32, 17.00s/it][Succeeded / Failed / Skipped / Total] 380 / 294 / 10 / 684:  68%|██████▊   | 684/1000 [3:13:49<1:29:32, 17.00s/it][Succeeded / Failed / Skipped / Total] 380 / 294 / 10 / 684:  68%|██████▊   | 685/1000 [3:13:53<1:29:09, 16.98s/it]--------------------------------------------- Result 675 ---------------------------------------------
Resolves the given path to the given base path . --> [[[FAILED]]]

[[[[Adv]]]]: public static Path resolve ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base . resolve ( child ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .

[[[[Adv]]]]: public static Path resolve ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base . resolve ( child ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .
--------------------------------------------- Result 676 ---------------------------------------------
Sets the host header . --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest host ( final String host ) { this . host = host ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , host ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .

[[[[Adv]]]]: public HttpRequest host ( final String host ) { this . host = host ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , host ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .
--------------------------------------------- Result 677 ---------------------------------------------
Creates a new request with the given method and destination . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest create ( final String method , final String destination ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set ( destination ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .

[[[[Adv]]]]: public static HttpRequest create ( final String method , final String destination ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set ( destination ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .
--------------------------------------------- Result 678 ---------------------------------------------
Sets the path for the request . --> Estrada estrada router --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[path]] ( String [[path]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .

[[[[Adv]]]]: public HttpRequest [[estrada]] ( String [[router]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .
--------------------------------------------- Result 679 ---------------------------------------------
Creates a new HTTP request to connect to the specified destination . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest connect ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a CONNECT request .

[[[[Adv]]]]: public static HttpRequest connect ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a CONNECT request .
--------------------------------------------- Result 680 ---------------------------------------------
Creates a GET request with the specified destination . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest get ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a GET request .

[[[[Adv]]]]: public static HttpRequest get ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a GET request .
--------------------------------------------- Result 681 ---------------------------------------------
Add a map of query parameters . --> Set opinions for an annoy request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[query]] ( final Map < String , String > [[queryMap]] ) { for ( Map . Entry < String , String > [[entry]] : [[queryMap]] . entrySet ( ) ) { [[query]] . add ( [[entry]] . getKey ( ) , [[entry]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .

[[[[Adv]]]]: public HttpRequest [[opinions]] ( final Map < String , String > [[annoy]] ) { for ( Map . Entry < String , String > [[entering]] : [[annoy]] . entrySet ( ) ) { [[opinions]] . add ( [[entering]] . getKey ( ) , [[entering]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .
--------------------------------------------- Result 682 ---------------------------------------------
Adds a query parameter to the request . --> Add a request parameter with ryoma and weissman --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest query ( final String [[name1]] , final Object [[value1]] , final Object ... parameters ) { query ( [[name1]] , [[value1]] == null ? null : [[value1]] . toString ( ) ) ; for ( int i = 0 ; i < parameters . length ; i += 2 ) { String [[name]] = parameters [ i ] . toString ( ) ; String value = parameters [ i + 1 ] . toString ( ) ; query . add ( [[name]] , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .

[[[[Adv]]]]: public HttpRequest query ( final String [[ryoma]] , final Object [[weissman]] , final Object ... parameters ) { query ( [[ryoma]] , [[weissman]] == null ? null : [[weissman]] . toString ( ) ) ; for ( int i = 0 ; i < parameters . length ; i += 2 ) { String [[nomination]] = parameters [ i ] . toString ( ) ; String value = parameters [ i + 1 ] . toString ( ) ; query . add ( [[nomination]] , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .
--------------------------------------------- Result 683 ---------------------------------------------
Sets the query string . --> Set sinestro and hieroglyphic flag --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[queryString]] ( final String [[queryString]] , final boolean [[decode]] ) { this . [[query]] = HttpUtil . parseQuery ( [[queryString]] , [[decode]] ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .

[[[[Adv]]]]: public HttpRequest [[truer]] ( final String [[sinestro]] , final boolean [[hieroglyphic]] ) { this . [[ver]] = HttpUtil . parseQuery ( [[truer]] , [[hieroglyphic]] ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .
--------------------------------------------- Result 684 ---------------------------------------------
Creates a PUT request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest put ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PUT request .

[[[[Adv]]]]: public static HttpRequest put ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PUT request .
--------------------------------------------- Result 685 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 381 / 294 / 10 / 685:  68%|██████▊   | 685/1000 [3:13:53<1:29:09, 16.98s/it][Succeeded / Failed / Skipped / Total] 381 / 294 / 10 / 685:  69%|██████▊   | 686/1000 [3:13:58<1:28:47, 16.97s/it][Succeeded / Failed / Skipped / Total] 382 / 294 / 10 / 686:  69%|██████▊   | 686/1000 [3:13:58<1:28:47, 16.97s/it][Succeeded / Failed / Skipped / Total] 382 / 294 / 10 / 686:  69%|██████▊   | 687/1000 [3:14:01<1:28:24, 16.95s/it][Succeeded / Failed / Skipped / Total] 383 / 294 / 10 / 687:  69%|██████▊   | 687/1000 [3:14:01<1:28:24, 16.95s/it][Succeeded / Failed / Skipped / Total] 383 / 294 / 10 / 687:  69%|██████▉   | 688/1000 [3:14:12<1:28:04, 16.94s/it][Succeeded / Failed / Skipped / Total] 383 / 295 / 10 / 688:  69%|██████▉   | 688/1000 [3:14:12<1:28:04, 16.94s/it][Succeeded / Failed / Skipped / Total] 383 / 295 / 10 / 688:  69%|██████▉   | 689/1000 [3:14:21<1:27:43, 16.92s/it][Succeeded / Failed / Skipped / Total] 383 / 296 / 10 / 689:  69%|██████▉   | 689/1000 [3:14:21<1:27:43, 16.92s/it][Succeeded / Failed / Skipped / Total] 383 / 296 / 10 / 689:  69%|██████▉   | 690/1000 [3:14:54<1:27:34, 16.95s/it][Succeeded / Failed / Skipped / Total] 383 / 297 / 10 / 690:  69%|██████▉   | 690/1000 [3:14:54<1:27:34, 16.95s/it][Succeeded / Failed / Skipped / Total] 383 / 297 / 10 / 690:  69%|██████▉   | 691/1000 [3:15:37<1:27:28, 16.99s/it][Succeeded / Failed / Skipped / Total] 383 / 298 / 10 / 691:  69%|██████▉   | 691/1000 [3:15:37<1:27:28, 16.99s/it][Succeeded / Failed / Skipped / Total] 383 / 298 / 10 / 691:  69%|██████▉   | 692/1000 [3:16:09<1:27:18, 17.01s/it][Succeeded / Failed / Skipped / Total] 383 / 299 / 10 / 692:  69%|██████▉   | 692/1000 [3:16:09<1:27:18, 17.01s/it][Succeeded / Failed / Skipped / Total] 383 / 299 / 10 / 692:  69%|██████▉   | 693/1000 [3:17:49<1:27:38, 17.13s/it][Succeeded / Failed / Skipped / Total] 384 / 299 / 10 / 693:  69%|██████▉   | 693/1000 [3:17:49<1:27:38, 17.13s/it][Succeeded / Failed / Skipped / Total] 384 / 299 / 10 / 693:  69%|██████▉   | 694/1000 [3:18:04<1:27:20, 17.12s/it][Succeeded / Failed / Skipped / Total] 385 / 299 / 10 / 694:  69%|██████▉   | 694/1000 [3:18:04<1:27:20, 17.12s/it][Succeeded / Failed / Skipped / Total] 385 / 299 / 10 / 694:  70%|██████▉   | 695/1000 [3:18:30<1:27:06, 17.14s/it]Sets the HTTP Basic Authentication header . --> Add username and cryptography headers to the request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[basicAuthentication]] ( final String username , final String [[password]] ) { if ( username != null && [[password]] != null ) { String [[data]] = username . concat ( StringPool . COLON ) . concat ( [[password]] ) ; String base64 = Base64 . encodeToString ( [[data]] ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .

[[[[Adv]]]]: public HttpRequest [[bandidos]] ( final String username , final String [[cryptography]] ) { if ( username != null && [[cryptography]] != null ) { String [[clarifying]] = username . concat ( StringPool . COLON ) . concat ( [[cryptography]] ) ; String base64 = Base64 . encodeToString ( [[clarifying]] ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .
--------------------------------------------- Result 686 ---------------------------------------------
Set the host header . --> Adds anaesthetist to the request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[setHostHeader]] ( ) { String [[hostPort]] = this . [[host]] ; if ( port != Defaults . DEFAULT_PORT ) { [[hostPort]] += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , [[hostPort]] ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .

[[[[Adv]]]]: public HttpRequest [[niklas]] ( ) { String [[anaesthetist]] = this . [[hosts]] ; if ( port != Defaults . DEFAULT_PORT ) { [[anaesthetist]] += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , [[anaesthetist]] ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .
--------------------------------------------- Result 687 ---------------------------------------------
Returns the host URL . --> Enlargement of the website band --> Socre: 1.0

[[[[Adv]]]]: public String [[hostUrl]] ( ) { StringBand [[url]] = new StringBand ( 8 ) ; if ( protocol != null ) { [[url]] . append ( protocol ) ; [[url]] . append ( "://" ) ; } if ( host != null ) { [[url]] . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { [[url]] . append ( ' ' ) ; [[url]] . append ( port ) ; } return [[url]] . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .

[[[[Adv]]]]: public String [[enlargement]] ( ) { StringBand [[website]] = new StringBand ( 8 ) ; if ( protocol != null ) { [[website]] . append ( protocol ) ; [[website]] . append ( "://" ) ; } if ( host != null ) { [[website]] . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { [[website]] . append ( ' ' ) ; [[website]] . append ( port ) ; } return [[website]] . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .
--------------------------------------------- Result 688 ---------------------------------------------
Creates a PATCH request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest patch ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PATCH request .

[[[[Adv]]]]: public static HttpRequest patch ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PATCH request .
--------------------------------------------- Result 689 ---------------------------------------------
Sends the request and receives the response . --> [[[FAILED]]]

[[[[Adv]]]]: public < R > R sendAndReceive ( final Function < HttpResponse , R > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .

[[[[Adv]]]]: public < R > R sendAndReceive ( final Function < HttpResponse , R > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .
--------------------------------------------- Result 690 ---------------------------------------------
Creates a HEAD request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest head ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a HEAD request .

[[[[Adv]]]]: public static HttpRequest head ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a HEAD request .
--------------------------------------------- Result 691 ---------------------------------------------
Creates a OPTIONS request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest options ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( destination ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .

[[[[Adv]]]]: public static HttpRequest options ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( destination ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .
--------------------------------------------- Result 692 ---------------------------------------------
Creates a TRACE request with the specified destination . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest trace ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a TRACE request .

[[[[Adv]]]]: public static HttpRequest trace ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a TRACE request .
--------------------------------------------- Result 693 ---------------------------------------------
Builds the query string . --> Returns the querida que los que que que los que que los que que los que que los que que los que que los que que los que sestos --> Socre: 1.0

[[[[Adv]]]]: public String [[queryString]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .

[[[[Adv]]]]: public String [[querida]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .
--------------------------------------------- Result 694 ---------------------------------------------
Collects all action runtimes . --> stealin the actions from the actions manager --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionRuntimes]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .

[[[[Adv]]]]: protected void [[stealin]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .
--------------------------------------------- Result 695 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 385 / 300 / 10 / 695:  70%|██████▉   | 695/1000 [3:18:30<1:27:06, 17.14s/it][Succeeded / Failed / Skipped / Total] 385 / 300 / 10 / 695:  70%|██████▉   | 696/1000 [3:18:33<1:26:43, 17.12s/it][Succeeded / Failed / Skipped / Total] 385 / 301 / 10 / 696:  70%|██████▉   | 696/1000 [3:18:33<1:26:43, 17.12s/it][Succeeded / Failed / Skipped / Total] 385 / 301 / 10 / 696:  70%|██████▉   | 697/1000 [3:19:10<1:26:35, 17.15s/it][Succeeded / Failed / Skipped / Total] 385 / 302 / 10 / 697:  70%|██████▉   | 697/1000 [3:19:10<1:26:35, 17.15s/it][Succeeded / Failed / Skipped / Total] 385 / 302 / 10 / 697:  70%|██████▉   | 698/1000 [3:19:14<1:26:12, 17.13s/it][Succeeded / Failed / Skipped / Total] 386 / 302 / 10 / 698:  70%|██████▉   | 698/1000 [3:19:14<1:26:12, 17.13s/it][Succeeded / Failed / Skipped / Total] 386 / 302 / 10 / 698:  70%|██████▉   | 699/1000 [3:19:17<1:25:49, 17.11s/it][Succeeded / Failed / Skipped / Total] 387 / 302 / 10 / 699:  70%|██████▉   | 699/1000 [3:19:17<1:25:49, 17.11s/it][Succeeded / Failed / Skipped / Total] 387 / 302 / 10 / 699:  70%|███████   | 700/1000 [3:19:31<1:25:30, 17.10s/it][Succeeded / Failed / Skipped / Total] 387 / 303 / 10 / 700:  70%|███████   | 700/1000 [3:19:31<1:25:30, 17.10s/it][Succeeded / Failed / Skipped / Total] 387 / 303 / 10 / 700:  70%|███████   | 701/1000 [3:19:37<1:25:08, 17.09s/it][Succeeded / Failed / Skipped / Total] 388 / 303 / 10 / 701:  70%|███████   | 701/1000 [3:19:37<1:25:08, 17.09s/it][Succeeded / Failed / Skipped / Total] 388 / 303 / 10 / 701:  70%|███████   | 702/1000 [3:19:40<1:24:45, 17.07s/it][Succeeded / Failed / Skipped / Total] 389 / 303 / 10 / 702:  70%|███████   | 702/1000 [3:19:40<1:24:45, 17.07s/it][Succeeded / Failed / Skipped / Total] 389 / 303 / 10 / 702:  70%|███████   | 703/1000 [3:19:43<1:24:22, 17.05s/it][Succeeded / Failed / Skipped / Total] 390 / 303 / 10 / 703:  70%|███████   | 703/1000 [3:19:43<1:24:22, 17.05s/it][Succeeded / Failed / Skipped / Total] 390 / 303 / 10 / 703:  70%|███████   | 704/1000 [3:19:47<1:24:00, 17.03s/it]Add a set of cookies to the request . --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest REPLACEME0 ( final Cookie ... REPLACEME0 ) { if ( REPLACEME0 . length == 0 ) { return this ; } StringBuilder cookieString = new StringBuilder ( ) ; boolean first = "True" == "True" ; for ( Cookie cookie : REPLACEME0 ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { cookieString . append ( "; " ) ; } first = "False" != "False" ; cookieString . append ( cookie . getName ( ) ) ; cookieString . append ( ' ' ) ; cookieString . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , cookieString . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .

[[[[Adv]]]]: public HttpRequest REPLACEME0 ( final Cookie ... REPLACEME0 ) { if ( REPLACEME0 . length == 0 ) { return this ; } StringBuilder cookieString = new StringBuilder ( ) ; boolean first = "True" == "True" ; for ( Cookie cookie : REPLACEME0 ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { cookieString . append ( "; " ) ; } first = "False" != "False" ; cookieString . append ( cookie . getName ( ) ) ; cookieString . append ( ' ' ) ; cookieString . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , cookieString . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .
--------------------------------------------- Result 696 ---------------------------------------------
Gets the exception table length . --> [[[FAILED]]]

[[[[Adv]]]]: static int getExceptionTableLength ( final Handler firstHandler ) { int length = 0 ; Handler handler = firstHandler ; while ( handler != null ) { length ++ ; handler = handler . nextHandler ; } return length ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .

[[[[Adv]]]]: static int getExceptionTableLength ( final Handler firstHandler ) { int length = 0 ; Handler handler = firstHandler ; while ( handler != null ) { length ++ ; handler = handler . nextHandler ; } return length ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .
--------------------------------------------- Result 697 ---------------------------------------------
Returns a buffer for the current request . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected Buffer buffer ( final boolean fullRequest ) {
[[[[Nl]]]]: Prepares the request buffer .

[[[[Adv]]]]: @ Override protected Buffer buffer ( final boolean fullRequest ) {
[[[[Nl]]]]: Prepares the request buffer .
--------------------------------------------- Result 698 ---------------------------------------------
Gets the writer . --> PrintWriter --> Socre: 1.0

[[[[Adv]]]]: @ Override public PrintWriter [[getWriter]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .

[[[[Adv]]]]: @ Override public PrintWriter [[ð]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .
--------------------------------------------- Result 699 ---------------------------------------------
Sets an object reference . --> Add an item to the objectRefs map --> Socre: 1.0

[[[[Adv]]]]: public void [[setObjectReference]] ( final String [[name]] , final Object [[object]] ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[name]] , [[object]] ) ; }
[[[[Nl]]]]: Saves object reference .

[[[[Adv]]]]: public void [[dever]] ( final String [[appoints]] , final Object [[item]] ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[appoints]] , [[item]] ) ; }
[[[[Nl]]]]: Saves object reference .
--------------------------------------------- Result 700 ---------------------------------------------
Remove a range of handlers . --> [[[FAILED]]]

[[[[Adv]]]]: static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .

[[[[Adv]]]]: static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .
--------------------------------------------- Result 701 ---------------------------------------------
Collects action interceptors from the interceptors manager . --> ActionInterceptor --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionInterceptors]] ( ) { final Collection < ? extends ActionInterceptor > interceptorValues = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( interceptorValues ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .

[[[[Adv]]]]: protected void [[à]] ( ) { final Collection < ? extends ActionInterceptor > interceptorValues = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( interceptorValues ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .
--------------------------------------------- Result 702 ---------------------------------------------
Collects all action filters from the filters manager . --> Methode permettant de secundus --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionFilters]] ( ) { final Collection < ? extends ActionFilter > [[filterValues]] = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( [[filterValues]] ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .

[[[[Adv]]]]: protected void [[secundus]] ( ) { final Collection < ? extends ActionFilter > [[messieurs]] = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( [[messieurs]] ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .
--------------------------------------------- Result 703 ---------------------------------------------
Gets the descriptor for a table . --> Promote a hilliard to a DbEntityDescriptor --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[getTableDescriptor]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( [[tableRef]] ) ; return t == null ? null : t . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .

[[[[Adv]]]]: public DbEntityDescriptor [[promote]] ( final String [[hilliard]] ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( [[hilliard]] ) ; return t == null ? null : t . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .
--------------------------------------------- Result 704 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 391 / 303 / 10 / 704:  70%|███████   | 704/1000 [3:19:47<1:24:00, 17.03s/it][Succeeded / Failed / Skipped / Total] 391 / 303 / 10 / 704:  70%|███████   | 705/1000 [3:19:52<1:23:37, 17.01s/it][Succeeded / Failed / Skipped / Total] 392 / 303 / 10 / 705:  70%|███████   | 705/1000 [3:19:52<1:23:37, 17.01s/it][Succeeded / Failed / Skipped / Total] 392 / 303 / 10 / 705:  71%|███████   | 706/1000 [3:20:00<1:23:17, 17.00s/it][Succeeded / Failed / Skipped / Total] 393 / 303 / 10 / 706:  71%|███████   | 706/1000 [3:20:00<1:23:17, 17.00s/it][Succeeded / Failed / Skipped / Total] 393 / 303 / 10 / 706:  71%|███████   | 707/1000 [3:20:18<1:23:00, 17.00s/it][Succeeded / Failed / Skipped / Total] 394 / 303 / 10 / 707:  71%|███████   | 707/1000 [3:20:18<1:23:00, 17.00s/it][Succeeded / Failed / Skipped / Total] 394 / 303 / 10 / 707:  71%|███████   | 708/1000 [3:20:24<1:22:39, 16.98s/it][Succeeded / Failed / Skipped / Total] 395 / 303 / 10 / 708:  71%|███████   | 708/1000 [3:20:24<1:22:39, 16.98s/it][Succeeded / Failed / Skipped / Total] 395 / 303 / 10 / 708:  71%|███████   | 709/1000 [3:20:36<1:22:20, 16.98s/it][Succeeded / Failed / Skipped / Total] 396 / 303 / 10 / 709:  71%|███████   | 709/1000 [3:20:36<1:22:20, 16.98s/it][Succeeded / Failed / Skipped / Total] 396 / 303 / 10 / 709:  71%|███████   | 710/1000 [3:20:57<1:22:04, 16.98s/it][Succeeded / Failed / Skipped / Total] 396 / 304 / 10 / 710:  71%|███████   | 710/1000 [3:20:57<1:22:04, 16.98s/it][Succeeded / Failed / Skipped / Total] 396 / 304 / 10 / 710:  71%|███████   | 711/1000 [3:21:01<1:21:42, 16.96s/it][Succeeded / Failed / Skipped / Total] 397 / 304 / 10 / 711:  71%|███████   | 711/1000 [3:21:01<1:21:42, 16.96s/it][Succeeded / Failed / Skipped / Total] 397 / 304 / 10 / 711:  71%|███████   | 712/1000 [3:21:08<1:21:21, 16.95s/it][Succeeded / Failed / Skipped / Total] 398 / 304 / 10 / 712:  71%|███████   | 712/1000 [3:21:08<1:21:21, 16.95s/it][Succeeded / Failed / Skipped / Total] 398 / 304 / 10 / 712:  71%|███████▏  | 713/1000 [3:21:12<1:20:59, 16.93s/it]Find table descriptor by column ref . --> Returns the DbEntityDescriptor for the given columnRef --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[findTableDescriptorByColumnRef]] ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor [[ded]] = entry . getValue ( ) . desc ; if ( [[ded]] . findByPropertyName ( columnRef ) != null ) { return [[ded]] ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .

[[[[Adv]]]]: public DbEntityDescriptor [[dumber]] ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor [[cnt]] = entry . getValue ( ) . desc ; if ( [[cnt]] . findByPropertyName ( columnRef ) != null ) { return [[cnt]] ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .
--------------------------------------------- Result 705 ---------------------------------------------
Extract this reference from property name . --> bustin - bustin - bustin --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[extractThisReference]] ( final String [[propertyName]] ) { int [[ndx]] = StringUtil . indexOfChars ( [[propertyName]] , INDEX_CHARS ) ; if ( [[ndx]] == - 1 ) { return [[propertyName]] ; } return [[propertyName]] . substring ( 0 , [[ndx]] ) ; }
[[[[Nl]]]]: Extract the first name of this reference .

[[[[Adv]]]]: @ Override public String [[bustin]] ( final String [[penning]] ) { int [[leasing]] = StringUtil . indexOfChars ( [[penning]] , INDEX_CHARS ) ; if ( [[leasing]] == - 1 ) { return [[penning]] ; } return [[penning]] . substring ( 0 , [[leasing]] ) ; }
[[[[Nl]]]]: Extract the first name of this reference .
--------------------------------------------- Result 706 ---------------------------------------------
Register table reference . --> Charile the given potemkin and latour --> Socre: 1.0

[[[[Adv]]]]: public void [[registerTableReference]] ( final String [[tableReference]] , final DbEntityDescriptor ded , final String [[tableAlias]] ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData [[t]] = new TableRefData ( ded , [[tableAlias]] ) ; if ( tableRefs . put ( [[tableReference]] , [[t]] ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + [[tableReference]] ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .

[[[[Adv]]]]: public void [[charile]] ( final String [[potemkin]] , final DbEntityDescriptor ded , final String [[latour]] ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData [[s]] = new TableRefData ( ded , [[latour]] ) ; if ( tableRefs . put ( [[potemkin]] , [[s]] ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + [[potemkin]] ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .
--------------------------------------------- Result 707 ---------------------------------------------
Registers a hint . --> Adds an indexed string to the conversationalist --> Socre: 1.0

[[[[Adv]]]]: public void [[registerHint]] ( final String [[hint]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[hint]] ) ; }
[[[[Nl]]]]: Registers a hint .

[[[[Adv]]]]: public void [[conversationalist]] ( final String [[indexed]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[indexed]] ) ; }
[[[[Nl]]]]: Registers a hint .
--------------------------------------------- Result 708 ---------------------------------------------
Writes the value to the JSON context . --> vikas a merit to buttery --> Socre: 1.0

[[[[Adv]]]]: @ Override public final boolean [[serialize]] ( final JsonContext [[jsonContext]] , final T [[value]] ) { if ( [[jsonContext]] . pushValue ( [[value]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .

[[[[Adv]]]]: @ Override public final boolean [[vikas]] ( final JsonContext [[buttery]] , final T [[merit]] ) { if ( [[buttery]] . pushValue ( [[merit]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .
--------------------------------------------- Result 709 ---------------------------------------------
Sets the value of a simple property . --> How much is the setter for this BeanProperty? --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[setSimpleProperty]] ( final BeanProperty bp , final Object value ) { Setter setter = bp . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[howmuch]] ( final BeanProperty bp , final Object value ) { Setter setter = bp . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .
--------------------------------------------- Result 710 ---------------------------------------------
Collects the action results . --> [[[FAILED]]]

[[[[Adv]]]]: protected void collectActionResults ( ) { final Collection < ActionResult > resultsValues = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( resultsValues ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .

[[[[Adv]]]]: protected void collectActionResults ( ) { final Collection < ActionResult > resultsValues = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( resultsValues ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .
--------------------------------------------- Result 711 ---------------------------------------------
Looks up an object reference . --> Get the merits of a joubert --> Socre: 1.0

[[[[Adv]]]]: public Object [[lookupObject]] ( final String [[ref]] ) { Object [[value]] = getObjectReference ( [[ref]] ) ; if ( [[value]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[ref]] ) ; } return [[value]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .

[[[[Adv]]]]: public Object [[clogging]] ( final String [[joubert]] ) { Object [[merits]] = getObjectReference ( [[joubert]] ) ; if ( [[merits]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[joubert]] ) ; } return [[merits]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .
--------------------------------------------- Result 712 ---------------------------------------------
Convert property name to column name . --> Returns the armoury of a torso --> Socre: 1.0

[[[[Adv]]]]: public String [[convertPropertyNameToColumnName]] ( final String [[propertyName]] ) { StringBuilder [[tableName]] = new StringBuilder ( [[propertyName]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String [[convertedTableName]] = Format . fromCamelCase ( [[propertyName]] , separatorChar ) ; [[tableName]] . append ( [[convertedTableName]] ) ; } else { [[tableName]] . append ( [[propertyName]] ) ; } if ( ! changeCase ) { return [[tableName]] . toString ( ) ; } return uppercase ? toUppercase ( [[tableName]] ) . toString ( ) : toLowercase ( [[tableName]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .

[[[[Adv]]]]: public String [[armoury]] ( final String [[torso]] ) { StringBuilder [[humor]] = new StringBuilder ( [[torso]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String [[gtr]] = Format . fromCamelCase ( [[torso]] , separatorChar ) ; [[humor]] . append ( [[gtr]] ) ; } else { [[humor]] . append ( [[torso]] ) ; } if ( ! changeCase ) { return [[humor]] . toString ( ) ; } return uppercase ? toUppercase ( [[humor]] ) . toString ( ) : toLowercase ( [[humor]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .
--------------------------------------------- Result 713 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 399 / 304 / 10 / 713:  71%|███████▏  | 713/1000 [3:21:12<1:20:59, 16.93s/it][Succeeded / Failed / Skipped / Total] 399 / 304 / 10 / 713:  71%|███████▏  | 714/1000 [3:21:18<1:20:38, 16.92s/it][Succeeded / Failed / Skipped / Total] 400 / 304 / 10 / 714:  71%|███████▏  | 714/1000 [3:21:18<1:20:38, 16.92s/it][Succeeded / Failed / Skipped / Total] 400 / 304 / 10 / 714:  72%|███████▏  | 715/1000 [3:21:37<1:20:21, 16.92s/it][Succeeded / Failed / Skipped / Total] 401 / 304 / 10 / 715:  72%|███████▏  | 715/1000 [3:21:37<1:20:21, 16.92s/it][Succeeded / Failed / Skipped / Total] 401 / 304 / 10 / 715:  72%|███████▏  | 716/1000 [3:21:41<1:20:00, 16.90s/it][Succeeded / Failed / Skipped / Total] 402 / 304 / 10 / 716:  72%|███████▏  | 716/1000 [3:21:41<1:20:00, 16.90s/it][Succeeded / Failed / Skipped / Total] 402 / 304 / 10 / 716:  72%|███████▏  | 717/1000 [3:21:55<1:19:42, 16.90s/it][Succeeded / Failed / Skipped / Total] 403 / 304 / 10 / 717:  72%|███████▏  | 717/1000 [3:21:55<1:19:42, 16.90s/it][Succeeded / Failed / Skipped / Total] 403 / 304 / 10 / 717:  72%|███████▏  | 718/1000 [3:21:59<1:19:20, 16.88s/it][Succeeded / Failed / Skipped / Total] 403 / 305 / 10 / 718:  72%|███████▏  | 718/1000 [3:21:59<1:19:20, 16.88s/it][Succeeded / Failed / Skipped / Total] 403 / 305 / 10 / 718:  72%|███████▏  | 719/1000 [3:22:19<1:19:04, 16.88s/it][Succeeded / Failed / Skipped / Total] 403 / 306 / 10 / 719:  72%|███████▏  | 719/1000 [3:22:19<1:19:04, 16.88s/it][Succeeded / Failed / Skipped / Total] 403 / 306 / 10 / 719:  72%|███████▏  | 720/1000 [3:23:28<1:19:07, 16.96s/it][Succeeded / Failed / Skipped / Total] 403 / 307 / 10 / 720:  72%|███████▏  | 720/1000 [3:23:28<1:19:07, 16.96s/it][Succeeded / Failed / Skipped / Total] 403 / 307 / 10 / 720:  72%|███████▏  | 721/1000 [3:23:57<1:18:55, 16.97s/it]Convert column name to property name . --> Returns the tego form of the input string --> Socre: 1.0

[[[[Adv]]]]: public String [[convertColumnNameToPropertyName]] ( final String [[columnName]] ) { StringBuilder [[propertyName]] = new StringBuilder ( [[columnName]] . length ( ) ) ; int len = [[columnName]] . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int [[i]] = 0 ; [[i]] < len ; [[i]] ++ ) { char [[c]] = [[columnName]] . charAt ( [[i]] ) ; if ( [[c]] == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { [[propertyName]] . append ( Character . toUpperCase ( [[c]] ) ) ; toUpper = "False" != "False" ; } else { [[propertyName]] . append ( Character . toLowerCase ( [[c]] ) ) ; } } return [[propertyName]] . toString ( ) ; } return [[columnName]] ; }
[[[[Nl]]]]: Converts column name to property name .

[[[[Adv]]]]: public String [[tego]] ( final String [[fina]] ) { StringBuilder [[correlate]] = new StringBuilder ( [[fina]] . length ( ) ) ; int len = [[fina]] . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int [[ich]] = 0 ; [[ich]] < len ; [[ich]] ++ ) { char [[tre]] = [[fina]] . charAt ( [[ich]] ) ; if ( [[tre]] == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { [[correlate]] . append ( Character . toUpperCase ( [[tre]] ) ) ; toUpper = "False" != "False" ; } else { [[correlate]] . append ( Character . toLowerCase ( [[tre]] ) ) ; } } return [[correlate]] . toString ( ) ; } return [[fina]] ; }
[[[[Nl]]]]: Converts column name to property name .
--------------------------------------------- Result 714 ---------------------------------------------
Lookup table descriptor by table reference . --> Get nanobots entity descriptor by crucifixions --> Socre: 1.0

[[[[Adv]]]]: protected DbEntityDescriptor [[lookupTableRef]] ( final String [[tableRef]] ) { DbEntityDescriptor [[ded]] = getTableDescriptor ( [[tableRef]] ) ; if ( [[ded]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[tableRef]] ) ; } return [[ded]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .

[[[[Adv]]]]: protected DbEntityDescriptor [[nanobots]] ( final String [[crucifixions]] ) { DbEntityDescriptor [[δ]] = getTableDescriptor ( [[crucifixions]] ) ; if ( [[δ]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[crucifixions]] ) ; } return [[δ]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .
--------------------------------------------- Result 715 ---------------------------------------------
Apply to column name . --> Get the brainwave for a quash --> Socre: 1.0

[[[[Adv]]]]: public String [[applyToColumnName]] ( final String [[columnName]] ) { String [[propertyName]] = convertColumnNameToPropertyName ( [[columnName]] ) ; return convertPropertyNameToColumnName ( [[propertyName]] ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .

[[[[Adv]]]]: public String [[you]] ( final String [[quash]] ) { String [[brainwave]] = convertColumnNameToPropertyName ( [[quash]] ) ; return convertPropertyNameToColumnName ( [[brainwave]] ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .
--------------------------------------------- Result 716 ---------------------------------------------
Store value . --> Trundle the street with the given appreciate and swipe --> Socre: 1.0

[[[[Adv]]]]: public void [[storeValue]] ( final PreparedStatement [[st]] , final int index , final Object [[value]] , final int [[dbSqlType]] ) throws SQLException { T [[t]] = TypeConverterManager . get ( ) . convertType ( [[value]] , sqlType ) ; set ( [[st]] , index , [[t]] , [[dbSqlType]] ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .

[[[[Adv]]]]: public void [[trundle]] ( final PreparedStatement [[street]] , final int index , final Object [[appreciate]] , final int [[swipe]] ) throws SQLException { T [[your]] = TypeConverterManager . get ( ) . convertType ( [[appreciate]] , sqlType ) ; set ( [[street]] , index , [[your]] , [[swipe]] ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .
--------------------------------------------- Result 717 ---------------------------------------------
Gets an object reference by name . --> Methode permettant de referencia d un objecte --> Socre: 1.0

[[[[Adv]]]]: public Object [[getObjectReference]] ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .

[[[[Adv]]]]: public Object [[estúpido]] ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .
--------------------------------------------- Result 718 ---------------------------------------------
Prepares to convert the given value to the given destination type . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < E > E prepareGetValue ( final T t , final Class < E > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( E ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < E > E prepareGetValue ( final T t , final Class < E > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( E ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .
--------------------------------------------- Result 719 ---------------------------------------------
Creates a new instance of the wrapper class . --> [[[FAILED]]]

[[[[Adv]]]]: protected < R extends T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .

[[[[Adv]]]]: protected < R extends T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .
--------------------------------------------- Result 720 ---------------------------------------------
Returns the property with the given name or null if not found . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public < T > T getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .

[[[[Adv]]]]: @ Override public < T > T getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .
--------------------------------------------- Result 721 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 403 / 308 / 10 / 721:  72%|███████▏  | 721/1000 [3:23:57<1:18:55, 16.97s/it][Succeeded / Failed / Skipped / Total] 403 / 308 / 10 / 721:  72%|███████▏  | 722/1000 [3:24:25<1:18:42, 16.99s/it][Succeeded / Failed / Skipped / Total] 404 / 308 / 10 / 722:  72%|███████▏  | 722/1000 [3:24:25<1:18:42, 16.99s/it][Succeeded / Failed / Skipped / Total] 404 / 308 / 10 / 722:  72%|███████▏  | 723/1000 [3:24:35<1:18:22, 16.98s/it][Succeeded / Failed / Skipped / Total] 405 / 308 / 10 / 723:  72%|███████▏  | 723/1000 [3:24:35<1:18:22, 16.98s/it][Succeeded / Failed / Skipped / Total] 405 / 308 / 10 / 723:  72%|███████▏  | 724/1000 [3:26:14<1:18:37, 17.09s/it][Succeeded / Failed / Skipped / Total] 405 / 309 / 10 / 724:  72%|███████▏  | 724/1000 [3:26:14<1:18:37, 17.09s/it][Succeeded / Failed / Skipped / Total] 405 / 309 / 10 / 724:  72%|███████▎  | 725/1000 [3:26:18<1:18:15, 17.07s/it][Succeeded / Failed / Skipped / Total] 405 / 310 / 10 / 725:  72%|███████▎  | 725/1000 [3:26:18<1:18:15, 17.07s/it][Succeeded / Failed / Skipped / Total] 405 / 310 / 10 / 725:  73%|███████▎  | 726/1000 [3:26:22<1:17:53, 17.06s/it][Succeeded / Failed / Skipped / Total] 405 / 311 / 10 / 726:  73%|███████▎  | 726/1000 [3:26:22<1:17:53, 17.06s/it][Succeeded / Failed / Skipped / Total] 405 / 311 / 10 / 726:  73%|███████▎  | 727/1000 [3:26:35<1:17:34, 17.05s/it][Succeeded / Failed / Skipped / Total] 405 / 312 / 10 / 727:  73%|███████▎  | 727/1000 [3:26:35<1:17:34, 17.05s/it][Succeeded / Failed / Skipped / Total] 405 / 312 / 10 / 727:  73%|███████▎  | 728/1000 [3:26:38<1:17:12, 17.03s/it][Succeeded / Failed / Skipped / Total] 405 / 313 / 10 / 728:  73%|███████▎  | 728/1000 [3:26:38<1:17:12, 17.03s/it][Succeeded / Failed / Skipped / Total] 405 / 313 / 10 / 728:  73%|███████▎  | 729/1000 [3:26:45<1:16:51, 17.02s/it][Succeeded / Failed / Skipped / Total] 406 / 313 / 10 / 729:  73%|███████▎  | 729/1000 [3:26:45<1:16:51, 17.02s/it][Succeeded / Failed / Skipped / Total] 406 / 313 / 10 / 729:  73%|███████▎  | 730/1000 [3:27:30<1:16:45, 17.06s/it]Gets the table alias . --> [[[FAILED]]]

[[[[Adv]]]]: public String getTableAlias ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t == null ? null : t . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .

[[[[Adv]]]]: public String getTableAlias ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t == null ? null : t . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .
--------------------------------------------- Result 722 ---------------------------------------------
Get the path from the filename . --> shine a filename with a given separator --> Socre: 1.0

[[[[Adv]]]]: private static String [[doGetPath]] ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .

[[[[Adv]]]]: private static String [[shine]] ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .
--------------------------------------------- Result 723 ---------------------------------------------
Returns the relative path of the target path relative to the base path . --> Returns the diplomat for the given chasms and salons --> Socre: 1.0

[[[[Adv]]]]: public static String [[relativePath]] ( final String [[targetPath]] , final String [[basePath]] ) { return new File ( [[basePath]] ) . toPath ( ) . relativize ( new File ( [[targetPath]] ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .

[[[[Adv]]]]: public static String [[diplomat]] ( final String [[chasms]] , final String [[salons]] ) { return new File ( [[salons]] ) . toPath ( ) . relativize ( new File ( [[chasms]] ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .
--------------------------------------------- Result 724 ---------------------------------------------
Injects the attributes from the servlet request into the given targets . --> [[[FAILED]]]

[[[[Adv]]]]: protected void injectAttributes ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .

[[[[Adv]]]]: protected void injectAttributes ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .
--------------------------------------------- Result 725 ---------------------------------------------
Resolves a wrapper for the given class . --> [[[FAILED]]]

[[[[Adv]]]]: public T resolve ( final Class < ? extends T > wrapperClass ) { String wrapperClassName = wrapperClass . getName ( ) ; T wrapper = lookup ( wrapperClassName ) ; if ( wrapper == null ) { wrapper = createWrapper ( wrapperClass ) ; initializeWrapper ( wrapper ) ; wrappers . put ( wrapperClassName , wrapper ) ; } return wrapper ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .

[[[[Adv]]]]: public T resolve ( final Class < ? extends T > wrapperClass ) { String wrapperClassName = wrapperClass . getName ( ) ; T wrapper = lookup ( wrapperClassName ) ; if ( wrapper == null ) { wrapper = createWrapper ( wrapperClass ) ; initializeWrapper ( wrapper ) ; wrappers . put ( wrapperClassName , wrapper ) ; } return wrapper ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .
--------------------------------------------- Result 726 ---------------------------------------------
Returns a set containing all the wrappers . --> [[[FAILED]]]

[[[[Adv]]]]: protected Set < T > getAll ( ) { final Set < T > set = new HashSet <> ( wrappers . size ( ) ) ; set . addAll ( wrappers . values ( ) ) ; return set ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .

[[[[Adv]]]]: protected Set < T > getAll ( ) { final Set < T > set = new HashSet <> ( wrappers . size ( ) ) ; set . addAll ( wrappers . values ( ) ) ; return set ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .
--------------------------------------------- Result 727 ---------------------------------------------
Starts the web application . --> [[[FAILED]]]

[[[[Adv]]]]: public WebApp start ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .

[[[[Adv]]]]: public WebApp start ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .
--------------------------------------------- Result 728 ---------------------------------------------
Registers an action config to the web app . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .

[[[[Adv]]]]: public < A extends ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .
--------------------------------------------- Result 729 ---------------------------------------------
Exclude classes from scanning . --> Exclude a list of classes from scanning --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[excludeJars]] ( final String ... [[excludedJars]] ) { for ( final String [[excludedJar]] : [[excludedJars]] ) { rulesJars . exclude ( [[excludedJar]] ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .

[[[[Adv]]]]: public ClassScanner [[istanbul]] ( final String ... [[laila]] ) { for ( final String [[cpt]] : [[laila]] ) { rulesJars . exclude ( [[cpt]] ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .
--------------------------------------------- Result 730 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 406 / 314 / 10 / 730:  73%|███████▎  | 730/1000 [3:27:30<1:16:45, 17.06s/it][Succeeded / Failed / Skipped / Total] 406 / 314 / 10 / 730:  73%|███████▎  | 731/1000 [3:27:38<1:16:24, 17.04s/it][Succeeded / Failed / Skipped / Total] 407 / 314 / 10 / 731:  73%|███████▎  | 731/1000 [3:27:38<1:16:24, 17.04s/it][Succeeded / Failed / Skipped / Total] 407 / 314 / 10 / 731:  73%|███████▎  | 732/1000 [3:27:59<1:16:09, 17.05s/it][Succeeded / Failed / Skipped / Total] 408 / 314 / 10 / 732:  73%|███████▎  | 732/1000 [3:27:59<1:16:09, 17.05s/it][Succeeded / Failed / Skipped / Total] 408 / 314 / 10 / 732:  73%|███████▎  | 733/1000 [3:28:13<1:15:50, 17.04s/it][Succeeded / Failed / Skipped / Total] 409 / 314 / 10 / 733:  73%|███████▎  | 733/1000 [3:28:13<1:15:50, 17.04s/it][Succeeded / Failed / Skipped / Total] 409 / 314 / 10 / 733:  73%|███████▎  | 734/1000 [3:28:54<1:15:42, 17.08s/it][Succeeded / Failed / Skipped / Total] 410 / 314 / 10 / 734:  73%|███████▎  | 734/1000 [3:28:54<1:15:42, 17.08s/it][Succeeded / Failed / Skipped / Total] 410 / 314 / 10 / 734:  74%|███████▎  | 735/1000 [3:29:33<1:15:33, 17.11s/it][Succeeded / Failed / Skipped / Total] 410 / 315 / 10 / 735:  74%|███████▎  | 735/1000 [3:29:33<1:15:33, 17.11s/it][Succeeded / Failed / Skipped / Total] 410 / 315 / 10 / 735:  74%|███████▎  | 736/1000 [3:29:56<1:15:18, 17.12s/it][Succeeded / Failed / Skipped / Total] 411 / 315 / 10 / 736:  74%|███████▎  | 736/1000 [3:29:56<1:15:18, 17.12s/it][Succeeded / Failed / Skipped / Total] 411 / 315 / 10 / 736:  74%|███████▎  | 737/1000 [3:29:57<1:14:55, 17.09s/it]Converts the given path separators to the system separators . --> [[[FAILED]]]

[[[[Adv]]]]: public static String separatorsToSystem ( final String path ) { if ( path == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( path ) ; } else { return separatorsToUnix ( path ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .

[[[[Adv]]]]: public static String separatorsToSystem ( final String path ) { if ( path == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( path ) ; } else { return separatorsToUnix ( path ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .
--------------------------------------------- Result 731 ---------------------------------------------
Adds the given rules entries to the scanner . --> Empathize classes with the given satisfies --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[includeEntries]] ( final String ... [[includedEntries]] ) { for ( final String includedEntry : [[includedEntries]] ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .

[[[[Adv]]]]: public ClassScanner [[empathize]] ( final String ... [[saddens]] ) { for ( final String includedEntry : [[saddens]] ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .
--------------------------------------------- Result 732 ---------------------------------------------
Include one or more rules jars . --> Add ralphy classes to the rules jar --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[includeJars]] ( final String ... [[includedJars]] ) { for ( final String [[includedJar]] : [[includedJars]] ) { rulesJars . include ( [[includedJar]] ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .

[[[[Adv]]]]: public ClassScanner [[sparta]] ( final String ... [[ralphy]] ) { for ( final String [[melhor]] : [[ralphy]] ) { rulesJars . include ( [[melhor]] ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .
--------------------------------------------- Result 733 ---------------------------------------------
Exclude one or more rules from scanning . --> Add jellied classes to the scanner --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... [[excludedEntries]] ) { for ( final String [[excludedEntry]] : [[excludedEntries]] ) { rulesEntries . exclude ( [[excludedEntry]] ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... [[jellied]] ) { for ( final String [[dunwich]] : [[jellied]] ) { rulesEntries . exclude ( [[dunwich]] ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .
--------------------------------------------- Result 734 ---------------------------------------------
Registers a madvoc component . --> NERF adds a class consumer to this WebApp --> Socre: 1.0

[[[[Adv]]]]: public WebApp [[registerComponent]] ( final Class < ? > [[madvocComponent]] ) { Objects . requireNonNull ( [[madvocComponent]] ) ; madvocComponents . add ( ClassConsumer . of ( [[madvocComponent]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .

[[[[Adv]]]]: public WebApp [[nerf]] ( final Class < ? > [[assessments]] ) { Objects . requireNonNull ( [[assessments]] ) ; madvocComponents . add ( ClassConsumer . of ( [[assessments]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .
--------------------------------------------- Result 735 ---------------------------------------------
Inject uploaded files into the target list . --> [[[FAILED]]]

[[[[Adv]]]]: protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .

[[[[Adv]]]]: protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .
--------------------------------------------- Result 736 ---------------------------------------------
Scans the given paths for classes . --> Scan the given chemin files and add them to the list of files to scan --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[scan]] ( final String ... [[paths]] ) { for ( final String [[path]] : [[paths]] ) { filesToScan . add ( new File ( [[path]] ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .

[[[[Adv]]]]: public ClassScanner [[swept]] ( final String ... [[chemin]] ) { for ( final String [[chemin]] : [[chemin]] ) { filesToScan . add ( new File ( [[chemin]] ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .
--------------------------------------------- Result 737 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 411 / 316 / 10 / 737:  74%|███████▎  | 737/1000 [3:29:57<1:14:55, 17.09s/it][Succeeded / Failed / Skipped / Total] 411 / 316 / 10 / 737:  74%|███████▍  | 738/1000 [3:30:18<1:14:39, 17.10s/it][Succeeded / Failed / Skipped / Total] 411 / 317 / 10 / 738:  74%|███████▍  | 738/1000 [3:30:18<1:14:39, 17.10s/it][Succeeded / Failed / Skipped / Total] 411 / 317 / 10 / 738:  74%|███████▍  | 739/1000 [3:30:21<1:14:17, 17.08s/it][Succeeded / Failed / Skipped / Total] 411 / 318 / 10 / 739:  74%|███████▍  | 739/1000 [3:30:21<1:14:17, 17.08s/it][Succeeded / Failed / Skipped / Total] 411 / 318 / 10 / 739:  74%|███████▍  | 740/1000 [3:30:42<1:14:02, 17.08s/it][Succeeded / Failed / Skipped / Total] 411 / 319 / 10 / 740:  74%|███████▍  | 740/1000 [3:30:42<1:14:02, 17.08s/it][Succeeded / Failed / Skipped / Total] 411 / 319 / 10 / 740:  74%|███████▍  | 741/1000 [3:31:17<1:13:51, 17.11s/it][Succeeded / Failed / Skipped / Total] 412 / 319 / 10 / 741:  74%|███████▍  | 741/1000 [3:31:17<1:13:51, 17.11s/it][Succeeded / Failed / Skipped / Total] 412 / 319 / 10 / 741:  74%|███████▍  | 742/1000 [3:31:43<1:13:37, 17.12s/it]Injects the request parameters into the given targets . --> [[[FAILED]]]

[[[[Adv]]]]: protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .

[[[[Adv]]]]: protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .
--------------------------------------------- Result 738 ---------------------------------------------
Splits a filename into its path and extension . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [ ] split ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String path ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , path , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .

[[[[Adv]]]]: public static String [ ] split ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String path ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , path , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .
--------------------------------------------- Result 739 ---------------------------------------------
Configures default actions . --> [[[FAILED]]]

[[[[Adv]]]]: protected void configureDefaults ( ) { final ActionConfigManager actionConfigManager = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; actionConfigManager . registerAnnotation ( Action . class ) ; actionConfigManager . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .

[[[[Adv]]]]: protected void configureDefaults ( ) { final ActionConfigManager actionConfigManager = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; actionConfigManager . registerAnnotation ( Action . class ) ; actionConfigManager . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .
--------------------------------------------- Result 740 ---------------------------------------------
Returns the default scope or the initial scope if the scope class is null . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .
--------------------------------------------- Result 741 ---------------------------------------------
Creates a new JtxTransaction . --> Implement interoffice method for DbJtxTransaction --> Socre: 1.0

[[[[Adv]]]]: @ Override protected JtxTransaction [[createNewTransaction]] ( final JtxTransactionMode [[tm]] , final Object scope , final boolean [[active]] ) { return new DbJtxTransaction ( this , [[tm]] , scope , [[active]] ) ; }
[[[[Nl]]]]: Builds new transaction instance .

[[[[Adv]]]]: @ Override protected JtxTransaction [[interoffice]] ( final JtxTransactionMode [[pinch]] , final Object scope , final boolean [[favourable]] ) { return new DbJtxTransaction ( this , [[pinch]] , scope , [[favourable]] ) ; }
[[[[Nl]]]]: Builds new transaction instance .
--------------------------------------------- Result 742 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 413 / 319 / 10 / 742:  74%|███████▍  | 742/1000 [3:31:43<1:13:37, 17.12s/it][Succeeded / Failed / Skipped / Total] 413 / 319 / 10 / 742:  74%|███████▍  | 743/1000 [3:32:58<1:13:40, 17.20s/it][Succeeded / Failed / Skipped / Total] 413 / 320 / 10 / 743:  74%|███████▍  | 743/1000 [3:32:58<1:13:40, 17.20s/it][Succeeded / Failed / Skipped / Total] 413 / 320 / 10 / 743:  74%|███████▍  | 744/1000 [3:33:23<1:13:25, 17.21s/it][Succeeded / Failed / Skipped / Total] 413 / 321 / 10 / 744:  74%|███████▍  | 744/1000 [3:33:23<1:13:25, 17.21s/it][Succeeded / Failed / Skipped / Total] 413 / 321 / 10 / 744:  74%|███████▍  | 745/1000 [3:33:35<1:13:06, 17.20s/it][Succeeded / Failed / Skipped / Total] 413 / 322 / 10 / 745:  74%|███████▍  | 745/1000 [3:33:35<1:13:06, 17.20s/it][Succeeded / Failed / Skipped / Total] 413 / 322 / 10 / 745:  75%|███████▍  | 746/1000 [3:33:44<1:12:46, 17.19s/it][Succeeded / Failed / Skipped / Total] 414 / 322 / 10 / 746:  75%|███████▍  | 746/1000 [3:33:44<1:12:46, 17.19s/it][Succeeded / Failed / Skipped / Total] 414 / 322 / 10 / 746:  75%|███████▍  | 747/1000 [3:34:16<1:12:34, 17.21s/it]Decode the given char array into a byte array . --> Returns the coded version of the given apalachicola --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[decode]] ( final char [ ] [[arr]] ) { int length = [[arr]] . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = [[arr]] [ endx ] == ' ' ? ( [[arr]] [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( [[arr]] [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ [[arr]] [ sndx ++ ] ] << 18 | INV [ [[arr]] [ sndx ++ ] ] << 12 | INV [ [[arr]] [ sndx ++ ] ] << 6 | INV [ [[arr]] [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ [[arr]] [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .

[[[[Adv]]]]: public static byte [ ] [[coded]] ( final char [ ] [[apalachicola]] ) { int length = [[apalachicola]] . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = [[apalachicola]] [ endx ] == ' ' ? ( [[apalachicola]] [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( [[apalachicola]] [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ [[apalachicola]] [ sndx ++ ] ] << 18 | INV [ [[apalachicola]] [ sndx ++ ] ] << 12 | INV [ [[apalachicola]] [ sndx ++ ] ] << 6 | INV [ [[apalachicola]] [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ [[apalachicola]] [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .
--------------------------------------------- Result 743 ---------------------------------------------
Returns the bytecode signature of a class . --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] bytecodeSignatureOfType ( final Class type ) { final String name = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .

[[[[Adv]]]]: public static byte [ ] bytecodeSignatureOfType ( final Class type ) { final String name = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .
--------------------------------------------- Result 744 ---------------------------------------------
Starts the scan . --> [[[FAILED]]]

[[[[Adv]]]]: public void start ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String path = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .

[[[[Adv]]]]: public void start ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String path = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .
--------------------------------------------- Result 745 ---------------------------------------------
Scan the classpath for classes . --> [[[FAILED]]]

[[[[Adv]]]]: protected void scanClassPath ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .

[[[[Adv]]]]: protected void scanClassPath ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .
--------------------------------------------- Result 746 ---------------------------------------------
Check CSRF token . --> Returns true if the specified destroyer should be removed from the session --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean [[checkCsrfToken]] ( final HttpSession [[session]] , final String [[tokenValue]] ) { Set < Token > tokenSet = ( Set < Token > ) [[session]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( [[tokenValue]] == null ) ) { return "[[True]]" == "[[True]]" ; } if ( ( tokenSet == null ) || ( [[tokenValue]] == null ) ) { return "False" != "False" ; } boolean found = "False" != "False" ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token [[t]] = it . next ( ) ; if ( [[t]] . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( [[t]] . getValue ( ) . equals ( [[tokenValue]] ) ) { it . remove ( ) ; found = "[[True]]" == "[[True]]" ; } } return found ; }
[[[[Nl]]]]: Checks token value . C

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean [[chaser]] ( final HttpSession [[period]] , final String [[destroyer]] ) { Set < Token > tokenSet = ( Set < Token > ) [[period]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( [[destroyer]] == null ) ) { return "[[Realities]]" == "[[Realities]]" ; } if ( ( tokenSet == null ) || ( [[destroyer]] == null ) ) { return "False" != "False" ; } boolean found = "False" != "False" ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token [[et]] = it . next ( ) ; if ( [[et]] . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( [[et]] . getValue ( ) . equals ( [[destroyer]] ) ) { it . remove ( ) ; found = "[[Realities]]" == "[[Realities]]" ; } } return found ; }
[[[[Nl]]]]: Checks token value . C
--------------------------------------------- Result 747 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 414 / 323 / 10 / 747:  75%|███████▍  | 747/1000 [3:34:16<1:12:34, 17.21s/it][Succeeded / Failed / Skipped / Total] 414 / 323 / 10 / 747:  75%|███████▍  | 748/1000 [3:34:51<1:12:23, 17.23s/it][Succeeded / Failed / Skipped / Total] 414 / 324 / 10 / 748:  75%|███████▍  | 748/1000 [3:34:51<1:12:23, 17.23s/it][Succeeded / Failed / Skipped / Total] 414 / 324 / 10 / 748:  75%|███████▍  | 749/1000 [3:35:10<1:12:06, 17.24s/it][Succeeded / Failed / Skipped / Total] 415 / 324 / 10 / 749:  75%|███████▍  | 749/1000 [3:35:10<1:12:06, 17.24s/it][Succeeded / Failed / Skipped / Total] 415 / 324 / 10 / 749:  75%|███████▌  | 750/1000 [3:35:17<1:11:45, 17.22s/it][Succeeded / Failed / Skipped / Total] 415 / 325 / 10 / 750:  75%|███████▌  | 750/1000 [3:35:17<1:11:45, 17.22s/it][Succeeded / Failed / Skipped / Total] 415 / 325 / 10 / 750:  75%|███████▌  | 751/1000 [3:35:20<1:11:23, 17.20s/it][Succeeded / Failed / Skipped / Total] 416 / 325 / 10 / 751:  75%|███████▌  | 751/1000 [3:35:20<1:11:23, 17.20s/it][Succeeded / Failed / Skipped / Total] 416 / 325 / 10 / 751:  75%|███████▌  | 752/1000 [3:35:22<1:11:01, 17.18s/it]Get or init scope . --> [[[FAILED]]]

[[[[Adv]]]]: protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope s : allScopes ) { if ( s . getClass ( ) . equals ( madvocScopeType ) ) { return s ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .

[[[[Adv]]]]: protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope s : allScopes ) { if ( s . getClass ( ) . equals ( madvocScopeType ) ) { return s ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .
--------------------------------------------- Result 748 ---------------------------------------------
Scans a jar file . --> [[[FAILED]]]

[[[[Adv]]]]: protected void scanJarFile ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .

[[[[Adv]]]]: protected void scanJarFile ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .
--------------------------------------------- Result 749 ---------------------------------------------
Makes a deep copy of this object . --> imitate this visitor --> Socre: 1.0

[[[[Adv]]]]: public void [[copy]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "[[True]]" == "[[True]]" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .

[[[[Adv]]]]: public void [[imitate]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "[[Loyal]]" == "[[Loyal]]" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .
--------------------------------------------- Result 750 ---------------------------------------------
Registers the given consumer with the given scope type . --> [[[FAILED]]]

[[[[Adv]]]]: public void forScope ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope scope = getOrInitScope ( scopeType ) ; madvocScopeConsumer . accept ( scope ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .

[[[[Adv]]]]: public void forScope ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope scope = getOrInitScope ( scopeType ) ; madvocScopeConsumer . accept ( scope ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .
--------------------------------------------- Result 751 ---------------------------------------------
Visit a property . --> Brenner ist ruthfully --> Socre: 1.0

[[[[Adv]]]]: @ Override protected boolean [[visitProperty]] ( String [[name]] , final Object [[value]] ) { if ( isTargetMap ) { [[name]] = LEFT_SQ_BRACKET + [[name]] + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , [[name]] , [[value]] ) ; return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .

[[[[Adv]]]]: @ Override protected boolean [[brenner]] ( String [[designate]] , final Object [[rating]] ) { if ( isTargetMap ) { [[designate]] = LEFT_SQ_BRACKET + [[designate]] + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , [[designate]] , [[rating]] ) ; return "[[Truthfully]]" == "[[Truthfully]]" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .
--------------------------------------------- Result 752 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 416 / 326 / 10 / 752:  75%|███████▌  | 752/1000 [3:35:22<1:11:01, 17.18s/it][Succeeded / Failed / Skipped / Total] 416 / 326 / 10 / 752:  75%|███████▌  | 753/1000 [3:36:06<1:10:53, 17.22s/it][Succeeded / Failed / Skipped / Total] 417 / 326 / 10 / 753:  75%|███████▌  | 753/1000 [3:36:06<1:10:53, 17.22s/it][Succeeded / Failed / Skipped / Total] 417 / 326 / 10 / 753:  75%|███████▌  | 754/1000 [3:36:24<1:10:36, 17.22s/it][Succeeded / Failed / Skipped / Total] 418 / 326 / 10 / 754:  75%|███████▌  | 754/1000 [3:36:24<1:10:36, 17.22s/it][Succeeded / Failed / Skipped / Total] 418 / 326 / 10 / 754:  76%|███████▌  | 755/1000 [3:36:36<1:10:17, 17.21s/it][Succeeded / Failed / Skipped / Total] 418 / 327 / 10 / 755:  76%|███████▌  | 755/1000 [3:36:36<1:10:17, 17.21s/it][Succeeded / Failed / Skipped / Total] 418 / 327 / 10 / 755:  76%|███████▌  | 756/1000 [3:37:00<1:10:02, 17.22s/it]Registers the Madvoc components . --> [[[FAILED]]]

[[[[Adv]]]]: protected void registerMadvocComponents ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .

[[[[Adv]]]]: protected void registerMadvocComponents ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .
--------------------------------------------- Result 753 ---------------------------------------------
Remove the bean with the given type . --> NATU - NATU --> Socre: 1.0

[[[[Adv]]]]: public void [[removeBean]] ( final Class [[type]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .

[[[[Adv]]]]: public void [[natu]] ( final Class [[types]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .
--------------------------------------------- Result 754 ---------------------------------------------
Registers the table reference . --> ivanhoe - ivanhoe --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[init]] ( final TemplateData [[templateData]] ) { super . init ( [[templateData]] ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = [[templateData]] . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String [[tableReference]] = this . [[tableReference]] ; if ( [[tableReference]] == null ) { [[tableReference]] = tableAlias ; } if ( [[tableReference]] == null ) { [[tableReference]] = entityName ; } if ( [[tableReference]] == null ) { [[tableReference]] = ded . getEntityName ( ) ; } [[templateData]] . registerTableReference ( [[tableReference]] , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .

[[[[Adv]]]]: @ Override public void [[ivanhoe]] ( final TemplateData [[electrician]] ) { super . init ( [[electrician]] ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = [[electrician]] . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String [[overtly]] = this . [[coz]] ; if ( [[overtly]] == null ) { [[overtly]] = tableAlias ; } if ( [[overtly]] == null ) { [[overtly]] = entityName ; } if ( [[overtly]] == null ) { [[overtly]] = ded . getEntityName ( ) ; } [[electrician]] . registerTableReference ( [[overtly]] , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .
--------------------------------------------- Result 755 ---------------------------------------------
Prepares a CSRF token for use in a request . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String prepareCsrfToken ( final HttpSession session , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique = tokenSet . add ( new Token ( value , timeToLive ) ) ; } while ( ! unique ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String prepareCsrfToken ( final HttpSession session , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique = tokenSet . add ( new Token ( value , timeToLive ) ) ; } while ( ! unique ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .
--------------------------------------------- Result 756 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 419 / 327 / 10 / 756:  76%|███████▌  | 756/1000 [3:37:00<1:10:02, 17.22s/it][Succeeded / Failed / Skipped / Total] 419 / 327 / 10 / 756:  76%|███████▌  | 757/1000 [3:37:03<1:09:40, 17.20s/it][Succeeded / Failed / Skipped / Total] 420 / 327 / 10 / 757:  76%|███████▌  | 757/1000 [3:37:03<1:09:40, 17.20s/it][Succeeded / Failed / Skipped / Total] 420 / 327 / 10 / 757:  76%|███████▌  | 758/1000 [3:37:33<1:09:27, 17.22s/it][Succeeded / Failed / Skipped / Total] 420 / 328 / 10 / 758:  76%|███████▌  | 758/1000 [3:37:33<1:09:27, 17.22s/it][Succeeded / Failed / Skipped / Total] 420 / 328 / 10 / 758:  76%|███████▌  | 759/1000 [3:37:34<1:09:05, 17.20s/it][Succeeded / Failed / Skipped / Total] 421 / 328 / 10 / 759:  76%|███████▌  | 759/1000 [3:37:34<1:09:05, 17.20s/it][Succeeded / Failed / Skipped / Total] 421 / 328 / 10 / 759:  76%|███████▌  | 760/1000 [3:38:38<1:09:02, 17.26s/it]Register a constructor injection point . --> Create a grass bean with the given name and parameter types --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteCtorInjectionPoint]] ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] [[ref]] = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , [[ref]] ) ; }
[[[[Nl]]]]: Registers constructor injection point .

[[[[Adv]]]]: public void [[grass]] ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] [[england]] = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , [[england]] ) ; }
[[[[Nl]]]]: Registers constructor injection point .
--------------------------------------------- Result 757 ---------------------------------------------
Registers a set injection point . --> Colorblinds a bean with a specified property --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteSetInjectionPoint]] ( final String beanName , final String property ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint [[sip]] = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( [[sip]] ) ; }
[[[[Nl]]]]: Registers set injection point .

[[[[Adv]]]]: public void [[colorblind]] ( final String beanName , final String property ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint [[beverage]] = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( [[beverage]] ) ; }
[[[[Nl]]]]: Registers set injection point .
--------------------------------------------- Result 758 ---------------------------------------------
Creates a copy of the given source object . --> [[[FAILED]]]

[[[[Adv]]]]: public static BeanCopy from ( final Object source ) { BeanCopy beanCopy = new BeanCopy ( source ) ; beanCopy . isSourceMap = source instanceof Map ; return beanCopy ; }
[[[[Nl]]]]: Defines source detects a map .

[[[[Adv]]]]: public static BeanCopy from ( final Object source ) { BeanCopy beanCopy = new BeanCopy ( source ) ; beanCopy . isSourceMap = source instanceof Map ; return beanCopy ; }
[[[[Nl]]]]: Defines source detects a map .
--------------------------------------------- Result 759 ---------------------------------------------
Registers a method injection point . --> Snags the given bean with the given reasoning and references --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteMethodInjectionPoint]] ( final String beanName , final String [[methodName]] , final Class [ ] [[arguments]] , final String [ ] references ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; Method method = null ; if ( [[arguments]] == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( [[methodName]] ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + [[beanDefinition]] . type . getName ( ) + ' ' + [[methodName]] ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( [[methodName]] , [[arguments]] , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + [[beanDefinition]] . type . getName ( ) + ' ' + [[methodName]] ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; [[beanDefinition]] . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .

[[[[Adv]]]]: public void [[snags]] ( final String beanName , final String [[cabbage]] , final Class [ ] [[reasoning]] , final String [ ] references ) { BeanDefinition [[ivories]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[ivories]] . type ) ; Method method = null ; if ( [[reasoning]] == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( [[cabbage]] ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + [[ivories]] . type . getName ( ) + ' ' + [[cabbage]] ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( [[cabbage]] , [[reasoning]] , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + [[ivories]] . type . getName ( ) + ' ' + [[cabbage]] ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; [[ivories]] . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .
--------------------------------------------- Result 760 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 421 / 329 / 10 / 760:  76%|███████▌  | 760/1000 [3:38:38<1:09:02, 17.26s/it][Succeeded / Failed / Skipped / Total] 421 / 329 / 10 / 760:  76%|███████▌  | 761/1000 [3:38:46<1:08:42, 17.25s/it][Succeeded / Failed / Skipped / Total] 421 / 330 / 10 / 761:  76%|███████▌  | 761/1000 [3:38:46<1:08:42, 17.25s/it][Succeeded / Failed / Skipped / Total] 421 / 330 / 10 / 761:  76%|███████▌  | 762/1000 [3:39:47<1:08:38, 17.31s/it][Succeeded / Failed / Skipped / Total] 421 / 331 / 10 / 762:  76%|███████▌  | 762/1000 [3:39:47<1:08:38, 17.31s/it][Succeeded / Failed / Skipped / Total] 421 / 331 / 10 / 762:  76%|███████▋  | 763/1000 [3:39:50<1:08:17, 17.29s/it][Succeeded / Failed / Skipped / Total] 422 / 331 / 10 / 763:  76%|███████▋  | 763/1000 [3:39:50<1:08:17, 17.29s/it][Succeeded / Failed / Skipped / Total] 422 / 331 / 10 / 763:  76%|███████▋  | 764/1000 [3:40:07<1:07:59, 17.29s/it]Ensures that the given set has at least maxTokensPerSession tokens . --> [[[FAILED]]]

[[[[Adv]]]]: protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .

[[[[Adv]]]]: protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .
--------------------------------------------- Result 761 ---------------------------------------------
Resolves a scope of the given type . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .
--------------------------------------------- Result 762 ---------------------------------------------
Registers a property injection point . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .

[[[[Adv]]]]: public void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .
--------------------------------------------- Result 763 ---------------------------------------------
Registers the Petite destroy methods . --> whitehouse a xiaowei bean --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteDestroyMethods]] ( final String beanName , String ... [[destroyMethodNames]] ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; if ( [[destroyMethodNames]] == null ) { [[destroyMethodNames]] = StringPool . EMPTY_ARRAY ; } int total = [[destroyMethodNames]] . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < [[destroyMethodNames]] . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( [[destroyMethodNames]] [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + [[beanDefinition]] . type . getName ( ) + ' ' + [[destroyMethodNames]] [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } [[beanDefinition]] . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .

[[[[Adv]]]]: public void [[whitehouse]] ( final String beanName , String ... [[xiaowei]] ) { BeanDefinition [[flamengo]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[flamengo]] . type ) ; if ( [[xiaowei]] == null ) { [[xiaowei]] = StringPool . EMPTY_ARRAY ; } int total = [[xiaowei]] . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < [[xiaowei]] . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( [[xiaowei]] [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + [[flamengo]] . type . getName ( ) + ' ' + [[xiaowei]] [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } [[flamengo]] . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .
--------------------------------------------- Result 764 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 422 / 332 / 10 / 764:  76%|███████▋  | 764/1000 [3:40:07<1:07:59, 17.29s/it][Succeeded / Failed / Skipped / Total] 422 / 332 / 10 / 764:  76%|███████▋  | 765/1000 [3:40:20<1:07:41, 17.28s/it][Succeeded / Failed / Skipped / Total] 423 / 332 / 10 / 765:  76%|███████▋  | 765/1000 [3:40:20<1:07:41, 17.28s/it][Succeeded / Failed / Skipped / Total] 423 / 332 / 10 / 765:  77%|███████▋  | 766/1000 [3:40:43<1:07:25, 17.29s/it][Succeeded / Failed / Skipped / Total] 424 / 332 / 10 / 766:  77%|███████▋  | 766/1000 [3:40:43<1:07:25, 17.29s/it][Succeeded / Failed / Skipped / Total] 424 / 332 / 10 / 766:  77%|███████▋  | 767/1000 [3:40:58<1:07:07, 17.29s/it][Succeeded / Failed / Skipped / Total] 424 / 333 / 10 / 767:  77%|███████▋  | 767/1000 [3:40:58<1:07:07, 17.29s/it][Succeeded / Failed / Skipped / Total] 424 / 333 / 10 / 767:  77%|███████▋  | 768/1000 [3:40:59<1:06:45, 17.27s/it][Succeeded / Failed / Skipped / Total] 425 / 333 / 10 / 768:  77%|███████▋  | 768/1000 [3:40:59<1:06:45, 17.27s/it][Succeeded / Failed / Skipped / Total] 425 / 333 / 10 / 768:  77%|███████▋  | 769/1000 [3:41:06<1:06:25, 17.25s/it][Succeeded / Failed / Skipped / Total] 426 / 333 / 10 / 769:  77%|███████▋  | 769/1000 [3:41:06<1:06:25, 17.25s/it][Succeeded / Failed / Skipped / Total] 426 / 333 / 10 / 769:  77%|███████▋  | 770/1000 [3:41:11<1:06:04, 17.24s/it]Registers a petite bean . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > BeanDefinition < T > registerPetiteBean ( final Class < T > type , String name , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( name == null ) { name = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .

[[[[Adv]]]]: public < T > BeanDefinition < T > registerPetiteBean ( final Class < T > type , String name , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( name == null ) { name = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .
--------------------------------------------- Result 765 ---------------------------------------------
Intercepts an action request . --> Method to embargo a schoolmistress --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object [[intercept]] ( final ActionRequest [[actionRequest]] ) throws Exception { printBefore ( [[actionRequest]] ) ; long [[startTime]] = System . currentTimeMillis ( ) ; Object result = null ; try { result = [[actionRequest]] . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - [[startTime]] ; printAfter ( [[actionRequest]] , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .

[[[[Adv]]]]: @ Override public Object [[embargo]] ( final ActionRequest [[schoolmistress]] ) throws Exception { printBefore ( [[schoolmistress]] ) ; long [[mahatma]] = System . currentTimeMillis ( ) ; Object result = null ; try { result = [[schoolmistress]] . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - [[mahatma]] ; printAfter ( [[schoolmistress]] , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .
--------------------------------------------- Result 766 ---------------------------------------------
Resolves the Java version . --> If copied is less than 8 + 52 then copied is less than 8 + 52 --> Socre: 1.0

[[[[Adv]]]]: public static int [[resolveJavaVersion]] ( final int [[version]] ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[platformVersion]] = javaVersionNumber - 8 + 52 ; return [[version]] > [[platformVersion]] ? [[version]] : [[platformVersion]] ; }
[[[[Nl]]]]: Resolves Java version from current version .

[[[[Adv]]]]: public static int [[lamenting]] ( final int [[copied]] ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[woos]] = javaVersionNumber - 8 + 52 ; return [[copied]] > [[woos]] ? [[copied]] : [[woos]] ; }
[[[[Nl]]]]: Resolves Java version from current version .
--------------------------------------------- Result 767 ---------------------------------------------
Register a bean definition . --> [[[FAILED]]]

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .
--------------------------------------------- Result 768 ---------------------------------------------
Throws an exception if the given argument index is out of bounds . --> Method to convert yens to yens --> Socre: 1.0

[[[[Adv]]]]: public static void [[checkArgumentIndex]] ( final MethodInfo [[methodInfo]] , final int argIndex ) { if ( ( argIndex < 1 ) || ( argIndex > [[methodInfo]] . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + argIndex ) ; } }
[[[[Nl]]]]: Validates argument index .

[[[[Adv]]]]: public static void [[yens]] ( final MethodInfo [[beata]] , final int argIndex ) { if ( ( argIndex < 1 ) || ( argIndex > [[beata]] . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + argIndex ) ; } }
[[[[Nl]]]]: Validates argument index .
--------------------------------------------- Result 769 ---------------------------------------------
Returns advice field name . --> Returns a brucie of denominations and a marker --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceFieldName]] ( final String [[name]] , final int [[index]] ) { return ProxettaNames . fieldPrefix + [[name]] + ProxettaNames . fieldDivider + [[index]] ; }
[[[[Nl]]]]: Builds advice field name .

[[[[Adv]]]]: public static String [[brucie]] ( final String [[denominations]] , final int [[marker]] ) { return ProxettaNames . fieldPrefix + [[denominations]] + ProxettaNames . fieldDivider + [[marker]] ; }
[[[[Nl]]]]: Builds advice field name .
--------------------------------------------- Result 770 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 426 / 334 / 10 / 770:  77%|███████▋  | 770/1000 [3:41:11<1:06:04, 17.24s/it][Succeeded / Failed / Skipped / Total] 426 / 334 / 10 / 770:  77%|███████▋  | 771/1000 [3:41:14<1:05:42, 17.22s/it][Succeeded / Failed / Skipped / Total] 427 / 334 / 10 / 771:  77%|███████▋  | 771/1000 [3:41:14<1:05:42, 17.22s/it][Succeeded / Failed / Skipped / Total] 427 / 334 / 10 / 771:  77%|███████▋  | 772/1000 [3:41:31<1:05:25, 17.22s/it][Succeeded / Failed / Skipped / Total] 427 / 335 / 10 / 772:  77%|███████▋  | 772/1000 [3:41:31<1:05:25, 17.22s/it][Succeeded / Failed / Skipped / Total] 427 / 335 / 10 / 772:  77%|███████▋  | 773/1000 [3:42:00<1:05:11, 17.23s/it][Succeeded / Failed / Skipped / Total] 428 / 335 / 10 / 773:  77%|███████▋  | 773/1000 [3:42:00<1:05:11, 17.23s/it][Succeeded / Failed / Skipped / Total] 428 / 335 / 10 / 773:  77%|███████▋  | 774/1000 [3:42:34<1:04:59, 17.25s/it][Succeeded / Failed / Skipped / Total] 429 / 335 / 10 / 774:  77%|███████▋  | 774/1000 [3:42:34<1:04:59, 17.25s/it][Succeeded / Failed / Skipped / Total] 429 / 335 / 10 / 774:  78%|███████▊  | 775/1000 [3:43:13<1:04:48, 17.28s/it][Succeeded / Failed / Skipped / Total] 430 / 335 / 10 / 775:  78%|███████▊  | 775/1000 [3:43:13<1:04:48, 17.28s/it][Succeeded / Failed / Skipped / Total] 430 / 335 / 10 / 775:  78%|███████▊  | 776/1000 [3:43:27<1:04:30, 17.28s/it]Resolve bean names for a given type . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [ ] resolveBeanNamesForType ( final Class type ) { String [ ] beanNames = beanCollections . get ( type ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , type ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY ; } else { beanNames = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( type , beanNames ) ; return beanNames ; }
[[[[Nl]]]]: Resolves bean names for give type .

[[[[Adv]]]]: protected String [ ] resolveBeanNamesForType ( final Class type ) { String [ ] beanNames = beanCollections . get ( type ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , type ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY ; } else { beanNames = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( type , beanNames ) ; return beanNames ; }
[[[[Nl]]]]: Resolves bean names for give type .
--------------------------------------------- Result 771 ---------------------------------------------
Returns advice method name . --> Returns the phi string for the given numerals and index --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceMethodName]] ( final String [[name]] , final int index ) { return ProxettaNames . methodPrefix + [[name]] + ProxettaNames . methodDivider + index ; }
[[[[Nl]]]]: Builds advice method name .

[[[[Adv]]]]: public static String [[phi]] ( final String [[numerals]] , final int index ) { return ProxettaNames . methodPrefix + [[numerals]] + ProxettaNames . methodDivider + index ; }
[[[[Nl]]]]: Builds advice method name .
--------------------------------------------- Result 772 ---------------------------------------------
Generates code to load all the arguments of a special method . --> [[[FAILED]]]

[[[[Adv]]]]: public static void loadSpecialMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { mv . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .

[[[[Adv]]]]: public static void loadSpecialMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { mv . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .
--------------------------------------------- Result 773 ---------------------------------------------
Push an int to the stack . --> Emit ICONST_0 + evaluations --> Socre: 1.0

[[[[Adv]]]]: public static void [[pushInt]] ( final MethodVisitor [[mv]] , final int [[value]] ) { if ( [[value]] <= 5 ) { [[mv]] . visitInsn ( ICONST_0 + [[value]] ) ; } else if ( [[value]] <= Byte . MAX_VALUE ) { [[mv]] . visitIntInsn ( BIPUSH , [[value]] ) ; } else { [[mv]] . visitIntInsn ( SIPUSH , [[value]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .

[[[[Adv]]]]: public static void [[yous]] ( final MethodVisitor [[freighter]] , final int [[evaluations]] ) { if ( [[evaluations]] <= 5 ) { [[freighter]] . visitInsn ( ICONST_0 + [[evaluations]] ) ; } else if ( [[evaluations]] <= Byte . MAX_VALUE ) { [[freighter]] . visitIntInsn ( BIPUSH , [[evaluations]] ) ; } else { [[freighter]] . visitIntInsn ( SIPUSH , [[evaluations]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .
--------------------------------------------- Result 774 ---------------------------------------------
Loads a method argument into the given method visitor . --> Writes a universal value to the given schooner --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadMethodArgument]] ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] , final int [[index]] ) { int [[offset]] = [[methodInfo]] . getArgumentOffset ( [[index]] ) ; int type = [[methodInfo]] . getArgument ( [[index]] ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : [[mv]] . visitVarInsn ( ILOAD , [[offset]] ) ; break ; case ' ' : [[mv]] . visitVarInsn ( LLOAD , [[offset]] ) ; break ; case ' ' : [[mv]] . visitVarInsn ( FLOAD , [[offset]] ) ; break ; case ' ' : [[mv]] . visitVarInsn ( DLOAD , [[offset]] ) ; break ; default : [[mv]] . visitVarInsn ( ALOAD , [[offset]] ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[universal]] ( final MethodVisitor [[schooner]] , final MethodInfo [[aco]] , final int [[clue]] ) { int [[counterweight]] = [[aco]] . getArgumentOffset ( [[clue]] ) ; int type = [[aco]] . getArgument ( [[clue]] ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : [[schooner]] . visitVarInsn ( ILOAD , [[counterweight]] ) ; break ; case ' ' : [[schooner]] . visitVarInsn ( LLOAD , [[counterweight]] ) ; break ; case ' ' : [[schooner]] . visitVarInsn ( FLOAD , [[counterweight]] ) ; break ; case ' ' : [[schooner]] . visitVarInsn ( DLOAD , [[counterweight]] ) ; break ; default : [[schooner]] . visitVarInsn ( ALOAD , [[counterweight]] ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 775 ---------------------------------------------
Stores an argument in the method . --> Writes a ryland instruction to the given visitor --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeMethodArgument]] ( final MethodVisitor mv , final MethodInfo [[methodInfo]] , final int [[index]] ) { int [[offset]] = [[methodInfo]] . getArgumentOffset ( [[index]] ) ; int [[type]] = [[methodInfo]] . getArgument ( [[index]] ) . getOpcode ( ) ; switch ( [[type]] ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , [[offset]] ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , [[offset]] ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , [[offset]] ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , [[offset]] ) ; break ; default : mv . visitVarInsn ( ASTORE , [[offset]] ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[ryland]] ( final MethodVisitor mv , final MethodInfo [[began]] , final int [[inventories]] ) { int [[compensatory]] = [[began]] . getArgumentOffset ( [[inventories]] ) ; int [[genus]] = [[began]] . getArgument ( [[inventories]] ) . getOpcode ( ) ; switch ( [[genus]] ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , [[compensatory]] ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , [[compensatory]] ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , [[compensatory]] ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , [[compensatory]] ) ; break ; default : mv . visitVarInsn ( ASTORE , [[compensatory]] ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 776 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 430 / 336 / 10 / 776:  78%|███████▊  | 776/1000 [3:43:27<1:04:30, 17.28s/it][Succeeded / Failed / Skipped / Total] 430 / 336 / 10 / 776:  78%|███████▊  | 777/1000 [3:43:33<1:04:09, 17.26s/it][Succeeded / Failed / Skipped / Total] 431 / 336 / 10 / 777:  78%|███████▊  | 777/1000 [3:43:33<1:04:09, 17.26s/it][Succeeded / Failed / Skipped / Total] 431 / 336 / 10 / 777:  78%|███████▊  | 778/1000 [3:43:47<1:03:51, 17.26s/it][Succeeded / Failed / Skipped / Total] 432 / 336 / 10 / 778:  78%|███████▊  | 778/1000 [3:43:47<1:03:51, 17.26s/it][Succeeded / Failed / Skipped / Total] 432 / 336 / 10 / 778:  78%|███████▊  | 779/1000 [3:44:05<1:03:34, 17.26s/it][Succeeded / Failed / Skipped / Total] 433 / 336 / 10 / 779:  78%|███████▊  | 779/1000 [3:44:05<1:03:34, 17.26s/it][Succeeded / Failed / Skipped / Total] 433 / 336 / 10 / 779:  78%|███████▊  | 780/1000 [3:44:09<1:03:13, 17.24s/it][Succeeded / Failed / Skipped / Total] 434 / 336 / 10 / 780:  78%|███████▊  | 780/1000 [3:44:09<1:03:13, 17.24s/it][Succeeded / Failed / Skipped / Total] 434 / 336 / 10 / 780:  78%|███████▊  | 781/1000 [3:44:12<1:02:52, 17.22s/it][Succeeded / Failed / Skipped / Total] 435 / 336 / 10 / 781:  78%|███████▊  | 781/1000 [3:44:12<1:02:52, 17.22s/it][Succeeded / Failed / Skipped / Total] 435 / 336 / 10 / 781:  78%|███████▊  | 782/1000 [3:44:33<1:02:35, 17.23s/it]Defines parameters from a map of properties . --> [[[FAILED]]]

[[[[Adv]]]]: public void defineParameters ( final Map < ? , ? > properties ) { for ( Map . Entry < ? , ? > entry : properties . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .

[[[[Adv]]]]: public void defineParameters ( final Map < ? , ? > properties ) { for ( Map . Entry < ? , ? > entry : properties . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .
--------------------------------------------- Result 777 ---------------------------------------------
Loads all the arguments of a static method . --> artiste senhora senhora --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadStaticMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] ) { for ( int [[i]] = 0 ; [[i]] < [[methodInfo]] . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( [[mv]] , [[methodInfo]] , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .

[[[[Adv]]]]: public static void [[artiste]] ( final MethodVisitor [[warship]] , final MethodInfo [[senhora]] ) { for ( int [[want]] = 0 ; [[want]] < [[senhora]] . getArgumentsCount ( ) ; [[want]] ++ ) { loadMethodArgument ( [[warship]] , [[senhora]] , [[want]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .
--------------------------------------------- Result 778 ---------------------------------------------
Prepares a method return value . --> Adds a sandbagged instruction to the method visitor --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareReturnValue]] ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] , int [[varOffset]] ) { [[varOffset]] += [[methodInfo]] . getAllArgumentsSize ( ) ; switch ( [[methodInfo]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[mv]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[mv]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .

[[[[Adv]]]]: public static void [[sandbagged]] ( final MethodVisitor [[mistral]] , final MethodInfo [[exhibitions]] , int [[socio]] ) { [[socio]] += [[exhibitions]] . getAllArgumentsSize ( ) ; switch ( [[exhibitions]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[mistral]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[mistral]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[mistral]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[mistral]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[mistral]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[mistral]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[mistral]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[mistral]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[mistral]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .
--------------------------------------------- Result 779 ---------------------------------------------
Stores the contents of an array into the given visitor . --> Writes a store instruction to the method visitor for the given buttering type --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeIntoArray]] ( final MethodVisitor mv , final Class [[componentType]] ) { if ( [[componentType]] == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( [[componentType]] == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( [[componentType]] == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( [[componentType]] == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( [[componentType]] == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[componentType]] == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( [[componentType]] == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[componentType]] == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .

[[[[Adv]]]]: public static void [[fire]] ( final MethodVisitor mv , final Class [[buttering]] ) { if ( [[buttering]] == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( [[buttering]] == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( [[buttering]] == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( [[buttering]] == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( [[buttering]] == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[buttering]] == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( [[buttering]] == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[buttering]] == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .
--------------------------------------------- Result 780 ---------------------------------------------
Create method signature key string . --> Returns a string with the given access description classname and spotlight --> Socre: 1.0

[[[[Adv]]]]: public static String [[createMethodSignaturesKey]] ( final int access , final String [[methodName]] , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( [[methodName]] ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .

[[[[Adv]]]]: public static String [[hesitate]] ( final int access , final String [[spotlight]] , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( [[spotlight]] ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .
--------------------------------------------- Result 781 ---------------------------------------------
Returns true if flags are null system flags and user flags . --> Returns true if the brands are valid false if not . --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isEmptyFlags]] ( Flags [[flags]] ) { if ( [[flags]] == null ) return "True" == "True" ; Flags . Flag [ ] [[systemFlags]] = [[flags]] . getSystemFlags ( ) ; if ( [[systemFlags]] != null && [[systemFlags]] . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = [[flags]] . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags

[[[[Adv]]]]: public static boolean [[figs]] ( Flags [[brands]] ) { if ( [[brands]] == null ) return "True" == "True" ; Flags . Flag [ ] [[ruud]] = [[brands]] . getSystemFlags ( ) ; if ( [[ruud]] != null && [[ruud]] . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = [[brands]] . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags
--------------------------------------------- Result 782 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 436 / 336 / 10 / 782:  78%|███████▊  | 782/1000 [3:44:33<1:02:35, 17.23s/it][Succeeded / Failed / Skipped / Total] 436 / 336 / 10 / 782:  78%|███████▊  | 783/1000 [3:44:55<1:02:20, 17.24s/it][Succeeded / Failed / Skipped / Total] 436 / 337 / 10 / 783:  78%|███████▊  | 783/1000 [3:44:55<1:02:20, 17.24s/it][Succeeded / Failed / Skipped / Total] 436 / 337 / 10 / 783:  78%|███████▊  | 784/1000 [3:45:08<1:02:01, 17.23s/it][Succeeded / Failed / Skipped / Total] 437 / 337 / 10 / 784:  78%|███████▊  | 784/1000 [3:45:08<1:02:01, 17.23s/it][Succeeded / Failed / Skipped / Total] 437 / 337 / 10 / 784:  78%|███████▊  | 785/1000 [3:45:28<1:01:45, 17.23s/it][Succeeded / Failed / Skipped / Total] 437 / 338 / 10 / 785:  78%|███████▊  | 785/1000 [3:45:28<1:01:45, 17.23s/it][Succeeded / Failed / Skipped / Total] 437 / 338 / 10 / 785:  79%|███████▊  | 786/1000 [3:45:30<1:01:23, 17.21s/it][Succeeded / Failed / Skipped / Total] 437 / 339 / 10 / 786:  79%|███████▊  | 786/1000 [3:45:30<1:01:23, 17.21s/it][Succeeded / Failed / Skipped / Total] 437 / 339 / 10 / 786:  79%|███████▊  | 787/1000 [3:45:34<1:01:03, 17.20s/it][Succeeded / Failed / Skipped / Total] 438 / 339 / 10 / 787:  79%|███████▊  | 787/1000 [3:45:34<1:01:03, 17.20s/it][Succeeded / Failed / Skipped / Total] 438 / 339 / 10 / 787:  79%|███████▉  | 788/1000 [3:45:40<1:00:42, 17.18s/it]Resolve the Bearer token from the given request . --> Get the militar authorization header from the sought request --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveAuthBearerToken]] ( final HttpServletRequest [[request]] ) { String [[header]] = [[request]] . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[header]] == null ) { return null ; } int [[ndx]] = [[header]] . indexOf ( "Bearer " ) ; if ( [[ndx]] == - 1 ) { return null ; } return [[header]] . substring ( [[ndx]] + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .

[[[[Adv]]]]: public static String [[militar]] ( final HttpServletRequest [[sought]] ) { String [[heading]] = [[sought]] . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[heading]] == null ) { return null ; } int [[daugther]] = [[heading]] . indexOf ( "Bearer " ) ; if ( [[daugther]] == - 1 ) { return null ; } return [[heading]] . substring ( [[daugther]] + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .
--------------------------------------------- Result 783 ---------------------------------------------
Registers a Petite provider . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = cd . getMethodDescriptor ( staticMethodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = cd . getMethodDescriptor ( staticMethodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .
--------------------------------------------- Result 784 ---------------------------------------------
Extracts encoding from content type . --> Returns the dote of the widest string or the blogspot if the widest string is null --> Socre: 1.0

[[[[Adv]]]]: public static String [[extractEncoding]] ( final String [[contentType]] , String [[defaultEncoding]] ) { String [[encoding]] = [[extractEncoding]] ( [[contentType]] ) ; if ( [[encoding]] == null ) { if ( [[defaultEncoding]] == null ) { [[defaultEncoding]] = JoddCore . encoding ; } [[encoding]] = [[defaultEncoding]] ; } return [[encoding]] ; }
[[[[Nl]]]]: Extracts encoding from a given content type .

[[[[Adv]]]]: public static String [[dote]] ( final String [[widest]] , String [[blogspot]] ) { String [[lit]] = [[dote]] ( [[widest]] ) ; if ( [[lit]] == null ) { if ( [[blogspot]] == null ) { [[blogspot]] = JoddCore . encoding ; } [[lit]] = [[blogspot]] ; } return [[lit]] ; }
[[[[Nl]]]]: Extracts encoding from a given content type .
--------------------------------------------- Result 785 ---------------------------------------------
Prepares the response . --> [[[FAILED]]]

[[[[Adv]]]]: public static void prepareResponse ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String extension = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( extension ) ; } if ( mimeType != null ) { response . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { response . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .

[[[[Adv]]]]: public static void prepareResponse ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String extension = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( extension ) ; } if ( mimeType != null ) { response . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { response . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .
--------------------------------------------- Result 786 ---------------------------------------------
Registers init methods for a Petite bean . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .
--------------------------------------------- Result 787 ---------------------------------------------
Prepares the response for downloading a file . --> Sends a ditch request to the client --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareDownload]] ( final HttpServletResponse [[response]] , final File [[file]] , final String [[mimeType]] ) { if ( ! [[file]] . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + [[file]] ) ; } if ( [[file]] . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + [[file]] ) ; } prepareResponse ( [[response]] , [[file]] . getAbsolutePath ( ) , [[mimeType]] , ( int ) [[file]] . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .

[[[[Adv]]]]: public static void [[ditch]] ( final HttpServletResponse [[speech]] , final File [[lawsuits]] , final String [[rapa]] ) { if ( ! [[lawsuits]] . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + [[lawsuits]] ) ; } if ( [[lawsuits]] . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + [[lawsuits]] ) ; } prepareResponse ( [[speech]] , [[lawsuits]] . getAbsolutePath ( ) , [[rapa]] , ( int ) [[lawsuits]] . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .
[Succeeded / Failed / Skipped / Total] 438 / 340 / 10 / 788:  79%|███████▉  | 788/1000 [3:45:40<1:00:42, 17.18s/it][Succeeded / Failed / Skipped / Total] 438 / 340 / 10 / 788:  79%|███████▉  | 789/1000 [3:45:45<1:00:22, 17.17s/it][Succeeded / Failed / Skipped / Total] 438 / 341 / 10 / 789:  79%|███████▉  | 789/1000 [3:45:45<1:00:22, 17.17s/it][Succeeded / Failed / Skipped / Total] 438 / 341 / 10 / 789:  79%|███████▉  | 790/1000 [3:45:52<1:00:02, 17.16s/it][Succeeded / Failed / Skipped / Total] 439 / 341 / 10 / 790:  79%|███████▉  | 790/1000 [3:45:52<1:00:02, 17.16s/it][Succeeded / Failed / Skipped / Total] 439 / 341 / 10 / 790:  79%|███████▉  | 791/1000 [3:45:57<59:42, 17.14s/it]  [Succeeded / Failed / Skipped / Total] 440 / 341 / 10 / 791:  79%|███████▉  | 791/1000 [3:45:57<59:42, 17.14s/it][Succeeded / Failed / Skipped / Total] 440 / 341 / 10 / 791:  79%|███████▉  | 792/1000 [3:45:58<59:20, 17.12s/it][Succeeded / Failed / Skipped / Total] 441 / 341 / 10 / 792:  79%|███████▉  | 792/1000 [3:45:58<59:20, 17.12s/it][Succeeded / Failed / Skipped / Total] 441 / 341 / 10 / 792:  79%|███████▉  | 793/1000 [3:46:08<59:01, 17.11s/it][Succeeded / Failed / Skipped / Total] 442 / 341 / 10 / 793:  79%|███████▉  | 793/1000 [3:46:08<59:01, 17.11s/it][Succeeded / Failed / Skipped / Total] 442 / 341 / 10 / 793:  79%|███████▉  | 794/1000 [3:46:08<58:40, 17.09s/it]--------------------------------------------- Result 788 ---------------------------------------------
Iterate over all beans of a given type . --> [[[FAILED]]]

[[[[Adv]]]]: public void forEachBeanType ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .

[[[[Adv]]]]: public void forEachBeanType ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .
--------------------------------------------- Result 789 ---------------------------------------------
Loads the method arguments for a virtual method . --> [[[FAILED]]]

[[[[Adv]]]]: public static void loadVirtualMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .

[[[[Adv]]]]: public static void loadVirtualMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .
--------------------------------------------- Result 790 ---------------------------------------------
Get all cookies with the given name . --> shower cookie with cookieName --> Socre: 1.0

[[[[Adv]]]]: public static Cookie [ ] [[getAllCookies]] ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] [[cookies]] = request . getCookies ( ) ; if ( [[cookies]] == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( [[cookies]] . length ) ; for ( Cookie cookie : [[cookies]] ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { list . add ( cookie ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .

[[[[Adv]]]]: public static Cookie [ ] [[shower]] ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] [[scone]] = request . getCookies ( ) ; if ( [[scone]] == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( [[scone]] . length ) ; for ( Cookie cookie : [[scone]] ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { list . add ( cookie ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .
--------------------------------------------- Result 791 ---------------------------------------------
Generates a new array instruction . --> T_INT T_DOUBLE T_FLOAT T_DOUBLE T_CHAR T_NEWARRAY --> Socre: 1.0

[[[[Adv]]]]: public static void [[newArray]] ( final MethodVisitor mv , final Class [[componentType]] ) { if ( [[componentType]] == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[componentType]] == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[componentType]] == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[componentType]] == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[componentType]] == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[componentType]] == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[componentType]] == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[componentType]] == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[componentType]] ) ) ; }
[[[[Nl]]]]: Creates new array .

[[[[Adv]]]]: public static void [[toll]] ( final MethodVisitor mv , final Class [[scuff]] ) { if ( [[scuff]] == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[scuff]] == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[scuff]] == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[scuff]] == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[scuff]] == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[scuff]] == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[scuff]] == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[scuff]] == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[scuff]] ) ) ; }
[[[[Nl]]]]: Creates new array .
--------------------------------------------- Result 792 ---------------------------------------------
Stores the context path for the given page context . --> Set the streaming attribute of the cannonballs --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeContextPath]] ( final PageContext [[pageContext]] , final String [[contextPathVariableName]] ) { String ctxPath = getContextPath ( [[pageContext]] ) ; HttpServletRequest [[request]] = ( HttpServletRequest ) [[pageContext]] . getRequest ( ) ; [[request]] . setAttribute ( [[contextPathVariableName]] , ctxPath ) ; ServletContext [[servletContext]] = [[pageContext]] . getServletContext ( ) ; [[servletContext]] . setAttribute ( [[contextPathVariableName]] , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .

[[[[Adv]]]]: public static void [[pokin]] ( final PageContext [[cannonballs]] , final String [[streaming]] ) { String ctxPath = getContextPath ( [[cannonballs]] ) ; HttpServletRequest [[appealed]] = ( HttpServletRequest ) [[cannonballs]] . getRequest ( ) ; [[appealed]] . setAttribute ( [[streaming]] , ctxPath ) ; ServletContext [[belo]] = [[cannonballs]] . getServletContext ( ) ; [[belo]] . setAttribute ( [[streaming]] , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .
--------------------------------------------- Result 793 ---------------------------------------------
Stores the context path in the servlet context . --> Sets the tusks attribute of amethyst --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeContextPath]] ( final ServletContext [[servletContext]] , final String [[contextPathVariableName]] ) { String [[ctxPath]] = getContextPath ( [[servletContext]] ) ; [[servletContext]] . setAttribute ( [[contextPathVariableName]] , [[ctxPath]] ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .

[[[[Adv]]]]: public static void [[tusks]] ( final ServletContext [[amethyst]] , final String [[bins]] ) { String [[betwixt]] = getContextPath ( [[amethyst]] ) ; [[amethyst]] . setAttribute ( [[bins]] , [[betwixt]] ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .
--------------------------------------------- Result 794 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 442 / 342 / 10 / 794:  79%|███████▉  | 794/1000 [3:46:08<58:40, 17.09s/it][Succeeded / Failed / Skipped / Total] 442 / 342 / 10 / 794:  80%|███████▉  | 795/1000 [3:46:09<58:18, 17.07s/it][Succeeded / Failed / Skipped / Total] 443 / 342 / 10 / 795:  80%|███████▉  | 795/1000 [3:46:09<58:18, 17.07s/it][Succeeded / Failed / Skipped / Total] 443 / 342 / 10 / 795:  80%|███████▉  | 796/1000 [3:46:12<57:58, 17.05s/it][Succeeded / Failed / Skipped / Total] 443 / 343 / 10 / 796:  80%|███████▉  | 796/1000 [3:46:12<57:58, 17.05s/it][Succeeded / Failed / Skipped / Total] 443 / 343 / 10 / 796:  80%|███████▉  | 797/1000 [3:46:40<57:44, 17.07s/it][Succeeded / Failed / Skipped / Total] 444 / 343 / 10 / 797:  80%|███████▉  | 797/1000 [3:46:40<57:44, 17.07s/it][Succeeded / Failed / Skipped / Total] 444 / 343 / 10 / 797:  80%|███████▉  | 798/1000 [3:46:48<57:24, 17.05s/it][Succeeded / Failed / Skipped / Total] 445 / 343 / 10 / 798:  80%|███████▉  | 798/1000 [3:46:48<57:24, 17.05s/it][Succeeded / Failed / Skipped / Total] 445 / 343 / 10 / 798:  80%|███████▉  | 799/1000 [3:46:48<57:03, 17.03s/it]Checks if the given parameter is a GET parameter . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean isGetParameter ( final HttpServletRequest request , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( name ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .

[[[[Adv]]]]: public boolean isGetParameter ( final HttpServletRequest request , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( name ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .
--------------------------------------------- Result 795 ---------------------------------------------
Prepares the given parameter array for use in the HTTP request . --> Eary a request parameter array if jelena or ignoreEmptyRequestParams --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] [[prepareParameters]] ( final String [ ] paramValues , final boolean [[treatEmptyParamsAsNull]] , final boolean ignoreEmptyRequestParams ) { if ( [[treatEmptyParamsAsNull]] || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int i = 0 ; i < paramValues . length ; i ++ ) { String paramValue = paramValues [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( [[treatEmptyParamsAsNull]] ) { paramValue = null ; } } paramValues [ i ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .

[[[[Adv]]]]: public static String [ ] [[eary]] ( final String [ ] paramValues , final boolean [[jelena]] , final boolean ignoreEmptyRequestParams ) { if ( [[jelena]] || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int i = 0 ; i < paramValues . length ; i ++ ) { String paramValue = paramValues [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( [[jelena]] ) { paramValue = null ; } } paramValues [ i ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .
--------------------------------------------- Result 796 ---------------------------------------------
Register a provider with the Petite server . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .
--------------------------------------------- Result 797 ---------------------------------------------
Reads the request body from the request reader . --> chante a potion to a string --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromReader]] ( final HttpServletRequest [[request]] ) throws IOException { BufferedReader [[buff]] = [[request]] . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( [[buff]] , out ) ; return out . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[chante]] ( final HttpServletRequest [[inquired]] ) throws IOException { BufferedReader [[potion]] = [[inquired]] . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( [[potion]] , out ) ; return out . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!
--------------------------------------------- Result 798 ---------------------------------------------
Calls all destroy methods on the bean . --> hopin - hopin - hopin --> Socre: 1.0

[[[[Adv]]]]: public void [[callDestroyMethods]] ( ) { for ( final DestroyMethodPoint [[destroyMethodPoint]] : beanDefinition . destroyMethodPoints ( ) ) { try { [[destroyMethodPoint]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + [[destroyMethodPoint]] . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .

[[[[Adv]]]]: public void [[hopin]] ( ) { for ( final DestroyMethodPoint [[dowdy]] : beanDefinition . destroyMethodPoints ( ) ) { try { [[dowdy]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + [[dowdy]] . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .
--------------------------------------------- Result 799 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 446 / 343 / 10 / 799:  80%|███████▉  | 799/1000 [3:46:48<57:03, 17.03s/it][Succeeded / Failed / Skipped / Total] 446 / 343 / 10 / 799:  80%|████████  | 800/1000 [3:48:02<57:00, 17.10s/it][Succeeded / Failed / Skipped / Total] 447 / 343 / 10 / 800:  80%|████████  | 800/1000 [3:48:02<57:00, 17.10s/it][Succeeded / Failed / Skipped / Total] 447 / 343 / 10 / 800:  80%|████████  | 801/1000 [3:48:23<56:44, 17.11s/it][Succeeded / Failed / Skipped / Total] 448 / 343 / 10 / 801:  80%|████████  | 801/1000 [3:48:23<56:44, 17.11s/it][Succeeded / Failed / Skipped / Total] 448 / 343 / 10 / 801:  80%|████████  | 802/1000 [3:48:33<56:25, 17.10s/it][Succeeded / Failed / Skipped / Total] 449 / 343 / 10 / 802:  80%|████████  | 802/1000 [3:48:33<56:25, 17.10s/it][Succeeded / Failed / Skipped / Total] 449 / 343 / 10 / 802:  80%|████████  | 803/1000 [3:48:35<56:04, 17.08s/it][Succeeded / Failed / Skipped / Total] 450 / 343 / 10 / 803:  80%|████████  | 803/1000 [3:48:35<56:04, 17.08s/it][Succeeded / Failed / Skipped / Total] 450 / 343 / 10 / 803:  80%|████████  | 804/1000 [3:48:37<55:44, 17.06s/it][Succeeded / Failed / Skipped / Total] 451 / 343 / 10 / 804:  80%|████████  | 804/1000 [3:48:37<55:44, 17.06s/it][Succeeded / Failed / Skipped / Total] 451 / 343 / 10 / 804:  80%|████████  | 805/1000 [3:48:43<55:24, 17.05s/it][Succeeded / Failed / Skipped / Total] 451 / 344 / 10 / 805:  80%|████████  | 805/1000 [3:48:43<55:24, 17.05s/it][Succeeded / Failed / Skipped / Total] 451 / 344 / 10 / 805:  81%|████████  | 806/1000 [3:48:45<55:03, 17.03s/it]Reads the request body from an input stream . --> Advent a String from a HttpServletRequest --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromStream]] ( final HttpServletRequest [[request]] ) throws IOException { String charEncoding = [[request]] . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = [[request]] . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[advent]] ( final HttpServletRequest [[requisitions]] ) throws IOException { String charEncoding = [[requisitions]] . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = [[requisitions]] . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!
--------------------------------------------- Result 800 ---------------------------------------------
Injects the parameters . --> Adds the boniface to the bean definition --> Socre: 1.0

[[[[Adv]]]]: public void [[injectParams]] ( final ParamManager [[paramManager]] , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) {
[[[[Nl]]]]: Injects all parameters .

[[[[Adv]]]]: public void [[boniface]] ( final ParamManager [[fourths]] , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) {
[[[[Nl]]]]: Injects all parameters .
--------------------------------------------- Result 801 ---------------------------------------------
Rewrite the given action path with the given HTTP method . --> Rerun the ripley with the gooses --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String [[rewrite]] ( final HttpServletRequest [[servletRequest]] , final String [[actionPath]] , final String [[httpMethod]] ) { return [[actionPath]] ; }
[[[[Nl]]]]: Rewrites action path .

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String [[rerun]] ( final HttpServletRequest [[spackle]] , final String [[ripley]] , final String [[gooses]] ) { return [[ripley]] ; }
[[[[Nl]]]]: Rewrites action path .
--------------------------------------------- Result 802 ---------------------------------------------
Add a header . --> fleece a word to merited --> Socre: 1.0

[[[[Adv]]]]: public void [[addHeader]] ( final String [[name]] , final String [[value]] ) { List < String > [[valuesList]] = super . getAll ( [[name]] ) ; if ( [[valuesList]] . isEmpty ( ) ) { super . add ( [[name]] , [[value]] ) ; return ; } super . remove ( [[name]] ) ; [[valuesList]] . add ( [[value]] ) ; super . addAll ( [[name]] , [[valuesList]] ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .

[[[[Adv]]]]: public void [[fleece]] ( final String [[spelled]] , final String [[merited]] ) { List < String > [[escalating]] = super . getAll ( [[spelled]] ) ; if ( [[escalating]] . isEmpty ( ) ) { super . add ( [[spelled]] , [[merited]] ) ; return ; } super . remove ( [[spelled]] ) ; [[escalating]] . add ( [[merited]] ) ; super . addAll ( [[spelled]] , [[escalating]] ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .
--------------------------------------------- Result 803 ---------------------------------------------
Invokes all init methods of the bean with the given invocation strategy . --> jail the bean with koyama --> Socre: 1.0

[[[[Adv]]]]: public void [[invokeInitMethods]] ( final InitMethodInvocationStrategy [[invocationStrategy]] ) { for ( final InitMethodPoint [[initMethod]] : beanDefinition . initMethodPoints ( ) ) { if ( [[invocationStrategy]] != [[initMethod]] . invocationStrategy ) { continue ; } try { [[initMethod]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + [[initMethod]] , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .

[[[[Adv]]]]: public void [[jail]] ( final InitMethodInvocationStrategy [[koyama]] ) { for ( final InitMethodPoint [[liberating]] : beanDefinition . initMethodPoints ( ) ) { if ( [[koyama]] != [[liberating]] . invocationStrategy ) { continue ; } try { [[liberating]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + [[liberating]] , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .
--------------------------------------------- Result 804 ---------------------------------------------
Add a property to the map . --> Adding a new introducing property . --> Socre: 1.0

[[[[Adv]]]]: protected void [[put]] ( final String [[profile]] , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String realValue = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , [[profile]] , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties

[[[[Adv]]]]: protected void [[introducing]] ( final String [[descriptions]] , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String realValue = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , [[descriptions]] , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties
--------------------------------------------- Result 805 ---------------------------------------------
Require authentication . --> [[[FAILED]]]

[[[[Adv]]]]: public static void requireAuthentication ( final HttpServletResponse resp , final String realm ) throws IOException { resp . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; resp . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .

[[[[Adv]]]]: public static void requireAuthentication ( final HttpServletResponse resp , final String realm ) throws IOException { resp . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; resp . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .
--------------------------------------------- Result 806 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 452 / 344 / 10 / 806:  81%|████████  | 806/1000 [3:48:45<55:03, 17.03s/it][Succeeded / Failed / Skipped / Total] 452 / 344 / 10 / 806:  81%|████████  | 807/1000 [3:49:04<54:47, 17.03s/it][Succeeded / Failed / Skipped / Total] 453 / 344 / 10 / 807:  81%|████████  | 807/1000 [3:49:04<54:47, 17.03s/it][Succeeded / Failed / Skipped / Total] 453 / 344 / 10 / 807:  81%|████████  | 808/1000 [3:49:10<54:27, 17.02s/it][Succeeded / Failed / Skipped / Total] 454 / 344 / 10 / 808:  81%|████████  | 808/1000 [3:49:10<54:27, 17.02s/it][Succeeded / Failed / Skipped / Total] 454 / 344 / 10 / 808:  81%|████████  | 809/1000 [3:49:12<54:06, 17.00s/it][Succeeded / Failed / Skipped / Total] 455 / 344 / 10 / 809:  81%|████████  | 809/1000 [3:49:12<54:06, 17.00s/it][Succeeded / Failed / Skipped / Total] 455 / 344 / 10 / 809:  81%|████████  | 810/1000 [3:49:39<53:52, 17.01s/it][Succeeded / Failed / Skipped / Total] 456 / 344 / 10 / 810:  81%|████████  | 810/1000 [3:49:39<53:52, 17.01s/it][Succeeded / Failed / Skipped / Total] 456 / 344 / 10 / 810:  81%|████████  | 811/1000 [3:50:20<53:40, 17.04s/it][Succeeded / Failed / Skipped / Total] 456 / 345 / 10 / 811:  81%|████████  | 811/1000 [3:50:20<53:40, 17.04s/it][Succeeded / Failed / Skipped / Total] 456 / 345 / 10 / 811:  81%|████████  | 812/1000 [3:50:28<53:21, 17.03s/it][Succeeded / Failed / Skipped / Total] 456 / 346 / 10 / 812:  81%|████████  | 812/1000 [3:50:28<53:21, 17.03s/it][Succeeded / Failed / Skipped / Total] 456 / 346 / 10 / 812:  81%|████████▏ | 813/1000 [3:50:33<53:01, 17.02s/it][Succeeded / Failed / Skipped / Total] 456 / 347 / 10 / 813:  81%|████████▏ | 813/1000 [3:50:33<53:01, 17.02s/it][Succeeded / Failed / Skipped / Total] 456 / 347 / 10 / 813:  81%|████████▏ | 814/1000 [3:50:42<52:43, 17.01s/it][Succeeded / Failed / Skipped / Total] 456 / 348 / 10 / 814:  81%|████████▏ | 814/1000 [3:50:42<52:43, 17.01s/it][Succeeded / Failed / Skipped / Total] 456 / 348 / 10 / 814:  82%|████████▏ | 815/1000 [3:51:03<52:26, 17.01s/it]Get profile property . --> Switchin photos to notable --> Socre: 1.0

[[[[Adv]]]]: public PropsEntry [[getProfileProperty]] ( final String [[profile]] , final String [[key]] ) { final Map < String , PropsEntry > [[profileMap]] = profileProperties . get ( [[profile]] ) ; if ( [[profileMap]] == null ) { return null ; } return [[profileMap]] . get ( [[key]] ) ; }
[[[[Nl]]]]: Returns profile property .

[[[[Adv]]]]: public PropsEntry [[switchin]] ( final String [[photos]] , final String [[notable]] ) { final Map < String , PropsEntry > [[institutional]] = profileProperties . get ( [[photos]] ) ; if ( [[institutional]] == null ) { return null ; } return [[institutional]] . get ( [[notable]] ) ; }
[[[[Nl]]]]: Returns profile property .
--------------------------------------------- Result 807 ---------------------------------------------
Resolve the macros for the given value . --> calhoun with assessments and depictions --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveMacros]] ( String [[value]] , final String ... [[profiles]] ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .

[[[[Adv]]]]: public String [[calhoun]] ( String [[assessments]] , final String ... [[depict]] ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .
--------------------------------------------- Result 808 ---------------------------------------------
Put a profile property . --> Set needed valour outlined and afflictions --> Socre: 1.0

[[[[Adv]]]]: public void [[putProfileProperty]] ( final String [[key]] , final String [[value]] , final String [[profile]] , final boolean [[append]] ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( [[profile]] , k -> new HashMap <> ( ) ) ; put ( [[profile]] , map , [[key]] , [[value]] , [[append]] ) ; }
[[[[Nl]]]]: Adds profile property .

[[[[Adv]]]]: public void [[temperature]] ( final String [[needed]] , final String [[valour]] , final String [[outlined]] , final boolean [[afflictions]] ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( [[outlined]] , k -> new HashMap <> ( ) ) ; put ( [[outlined]] , map , [[needed]] , [[valour]] , [[afflictions]] ) ; }
[[[[Nl]]]]: Adds profile property .
--------------------------------------------- Result 809 ---------------------------------------------
Put base property . --> blasts the properties with the given keys --> Socre: 1.0

[[[[Adv]]]]: public void [[putBaseProperty]] ( final String [[key]] , final String [[value]] , final boolean append ) { put ( null , baseProperties , [[key]] , [[value]] , append ) ; }
[[[[Nl]]]]: Adds base property .

[[[[Adv]]]]: public void [[blasts]] ( final String [[keys]] , final String [[appreciated]] , final boolean append ) { put ( null , baseProperties , [[keys]] , [[appreciated]] , append ) ; }
[[[[Nl]]]]: Adds base property .
--------------------------------------------- Result 810 ---------------------------------------------
Converts a stream to a word . --> baptiste de baptiste --> Socre: 1.0

[[[[Adv]]]]: private static int [[streamtoword]] ( byte [ ] [[data]] , int [ ] [[offp]] ) { int [[i]] ; int word = 0 ; int [[off]] = [[offp]] [ 0 ] ; for ( [[i]] = 0 ; [[i]] < 4 ; [[i]] ++ ) { word = ( word << 8 ) | ( [[data]] [ [[off]] ] & 0xff ) ; [[off]] = ( [[off]] + 1 ) % [[data]] . length ; } [[offp]] [ 0 ] = [[off]] ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .

[[[[Adv]]]]: private static int [[baptiste]] ( byte [ ] [[reporting]] , int [ ] [[fetal]] ) { int [[lai]] ; int word = 0 ; int [[disconnect]] = [[fetal]] [ 0 ] ; for ( [[lai]] = 0 ; [[lai]] < 4 ; [[lai]] ++ ) { word = ( word << 8 ) | ( [[reporting]] [ [[disconnect]] ] & 0xff ) ; [[disconnect]] = ( [[disconnect]] + 1 ) % [[reporting]] . length ; } [[fetal]] [ 0 ] = [[disconnect]] ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .
--------------------------------------------- Result 811 ---------------------------------------------
Checks whether a password is valid for a plaintext password . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean checkpw ( String plaintext , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String try_pw = hashpw ( plaintext , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "False" != "False" ; } if ( hashed_bytes . length != try_bytes . length ) { return "False" != "False" ; } byte ret = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .

[[[[Adv]]]]: public static boolean checkpw ( String plaintext , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String try_pw = hashpw ( plaintext , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "False" != "False" ; } if ( hashed_bytes . length != try_bytes . length ) { return "False" != "False" ; } byte ret = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .
--------------------------------------------- Result 812 ---------------------------------------------
Renders the given body to a String . --> [[[FAILED]]]

[[[[Adv]]]]: public static String renderBodyToString ( final JspFragment body ) throws JspException { char [ ] result = renderBody ( body ) ; return new String ( result ) ; }
[[[[Nl]]]]: Renders tag body to string .

[[[[Adv]]]]: public static String renderBodyToString ( final JspFragment body ) throws JspException { char [ ] result = renderBody ( body ) ; return new String ( result ) ; }
[[[[Nl]]]]: Renders tag body to string .
--------------------------------------------- Result 813 ---------------------------------------------
Invokes the body of the tag . --> [[[FAILED]]]

[[[[Adv]]]]: public static void invokeBody ( final JspFragment body ) throws JspException { if ( body == null ) { return ; } try { body . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .

[[[[Adv]]]]: public static void invokeBody ( final JspFragment body ) throws JspException { if ( body == null ) { return ; } try { body . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .
--------------------------------------------- Result 814 ---------------------------------------------
Renders the body of a JSP fragment . --> [[[FAILED]]]

[[[[Adv]]]]: public static char [ ] renderBody ( final JspFragment body ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( body , writer ) ; return writer . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .

[[[[Adv]]]]: public static char [ ] renderBody ( final JspFragment body ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( body , writer ) ; return writer . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .
--------------------------------------------- Result 815 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 457 / 348 / 10 / 815:  82%|████████▏ | 815/1000 [3:51:03<52:26, 17.01s/it][Succeeded / Failed / Skipped / Total] 457 / 348 / 10 / 815:  82%|████████▏ | 816/1000 [3:51:04<52:06, 16.99s/it][Succeeded / Failed / Skipped / Total] 457 / 349 / 10 / 816:  82%|████████▏ | 816/1000 [3:51:04<52:06, 16.99s/it][Succeeded / Failed / Skipped / Total] 457 / 349 / 10 / 816:  82%|████████▏ | 817/1000 [3:51:10<51:46, 16.98s/it][Succeeded / Failed / Skipped / Total] 458 / 349 / 10 / 817:  82%|████████▏ | 817/1000 [3:51:10<51:46, 16.98s/it][Succeeded / Failed / Skipped / Total] 458 / 349 / 10 / 817:  82%|████████▏ | 818/1000 [3:51:31<51:30, 16.98s/it][Succeeded / Failed / Skipped / Total] 458 / 350 / 10 / 818:  82%|████████▏ | 818/1000 [3:51:31<51:30, 16.98s/it][Succeeded / Failed / Skipped / Total] 458 / 350 / 10 / 818:  82%|████████▏ | 819/1000 [3:51:52<51:14, 16.99s/it][Succeeded / Failed / Skipped / Total] 459 / 350 / 10 / 819:  82%|████████▏ | 819/1000 [3:51:52<51:14, 16.99s/it][Succeeded / Failed / Skipped / Total] 459 / 350 / 10 / 819:  82%|████████▏ | 820/1000 [3:52:02<50:56, 16.98s/it][Succeeded / Failed / Skipped / Total] 460 / 350 / 10 / 820:  82%|████████▏ | 820/1000 [3:52:02<50:56, 16.98s/it][Succeeded / Failed / Skipped / Total] 460 / 350 / 10 / 820:  82%|████████▏ | 821/1000 [3:52:34<50:42, 17.00s/it][Succeeded / Failed / Skipped / Total] 461 / 350 / 10 / 821:  82%|████████▏ | 821/1000 [3:52:34<50:42, 17.00s/it][Succeeded / Failed / Skipped / Total] 461 / 350 / 10 / 821:  82%|████████▏ | 822/1000 [3:52:40<50:22, 16.98s/it]Copies up to maxBytes bytes . --> dieting with brevity --> Socre: 1.0

[[[[Adv]]]]: public int [[copyMax]] ( final OutputStream out , final int [[maxBytes]] ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == [[maxBytes]] ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .

[[[[Adv]]]]: public int [[dieting]] ( final OutputStream out , final int [[brevity]] ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == [[brevity]] ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .
--------------------------------------------- Result 816 ---------------------------------------------
Creates a new instance of the bean . --> [[[FAILED]]]

[[[[Adv]]]]: public Object newBeanInstance ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .

[[[[Adv]]]]: public Object newBeanInstance ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .
--------------------------------------------- Result 817 ---------------------------------------------
Extracts the profiles and wildcards from the target map . --> Recapture the contours and pronouns --> Socre: 1.0

[[[[Adv]]]]: public Map [[extract]] ( Map [[target]] , final String [ ] [[profiles]] , final String [ ] [[wildcardPatterns]] , String [[prefix]] ) { if ( [[target]] == null ) { [[target]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .

[[[[Adv]]]]: public Map [[recapture]] ( Map [[targeted]] , final String [ ] [[contours]] , final String [ ] [[iff]] , String [[pronoun]] ) { if ( [[targeted]] == null ) { [[targeted]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .
--------------------------------------------- Result 818 ---------------------------------------------
Copy the parameters from the servlet request to the attributes . --> [[[FAILED]]]

[[[[Adv]]]]: public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .

[[[[Adv]]]]: public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .
--------------------------------------------- Result 819 ---------------------------------------------
Detect and register an alias . --> pacts the sidetracked action with the actions manager --> Socre: 1.0

[[[[Adv]]]]: protected void [[detectAndRegisterAlias]] ( final ActionAnnotationValues [[annotationValues]] , final ActionDefinition [[actionDefinition]] ) { final String alias = parseMethodAlias ( [[annotationValues]] ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( [[actionDefinition]] . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .

[[[[Adv]]]]: protected void [[pacts]] ( final ActionAnnotationValues [[thelr]] , final ActionDefinition [[sidetracked]] ) { final String alias = parseMethodAlias ( [[thelr]] ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( [[sidetracked]] . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .
--------------------------------------------- Result 820 ---------------------------------------------
Hashes a password with a salt . --> shima - shima - shima - shima --> Socre: 1.0

[[[[Adv]]]]: public static String [[hashpw]] ( String password , String [[salt]] ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int [[rounds]] , off ; StringBuffer rs = new StringBuffer ( ) ; if ( [[salt]] . charAt ( 0 ) != ' ' || [[salt]] . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( [[salt]] . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = [[salt]] . charAt ( 2 ) ; if ( minor != ' ' || [[salt]] . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .

[[[[Adv]]]]: public static String [[shima]] ( String password , String [[thyme]] ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int [[puffs]] , off ; StringBuffer rs = new StringBuffer ( ) ; if ( [[thyme]] . charAt ( 0 ) != ' ' || [[thyme]] . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( [[thyme]] . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = [[thyme]] . charAt ( 2 ) ; if ( minor != ' ' || [[thyme]] . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .
--------------------------------------------- Result 821 ---------------------------------------------
Read method action path array . --> LOANING METHODS LOANING METHODS --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readMethodActionPath]] ( final String methodName , final ActionAnnotationValues [[annotationValues]] , final ActionConfig actionConfig ) {
[[[[Nl]]]]: Reads action path from the action method .

[[[[Adv]]]]: protected String [ ] [[lansing]] ( final String methodName , final ActionAnnotationValues [[treaties]] , final ActionConfig actionConfig ) {
[[[[Nl]]]]: Reads action path from the action method .
--------------------------------------------- Result 822 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 462 / 350 / 10 / 822:  82%|████████▏ | 822/1000 [3:52:40<50:22, 16.98s/it][Succeeded / Failed / Skipped / Total] 462 / 350 / 10 / 822:  82%|████████▏ | 823/1000 [3:52:40<50:02, 16.96s/it][Succeeded / Failed / Skipped / Total] 462 / 350 / 11 / 823:  82%|████████▏ | 823/1000 [3:52:40<50:02, 16.96s/it][Succeeded / Failed / Skipped / Total] 462 / 350 / 11 / 823:  82%|████████▏ | 824/1000 [3:54:45<50:08, 17.09s/it][Succeeded / Failed / Skipped / Total] 462 / 351 / 11 / 824:  82%|████████▏ | 824/1000 [3:54:45<50:08, 17.09s/it][Succeeded / Failed / Skipped / Total] 462 / 351 / 11 / 824:  82%|████████▎ | 825/1000 [3:54:52<49:49, 17.08s/it][Succeeded / Failed / Skipped / Total] 462 / 352 / 11 / 825:  82%|████████▎ | 825/1000 [3:54:52<49:49, 17.08s/it][Succeeded / Failed / Skipped / Total] 462 / 352 / 11 / 825:  83%|████████▎ | 826/1000 [3:55:10<49:32, 17.08s/it][Succeeded / Failed / Skipped / Total] 462 / 353 / 11 / 826:  83%|████████▎ | 826/1000 [3:55:10<49:32, 17.08s/it][Succeeded / Failed / Skipped / Total] 462 / 353 / 11 / 826:  83%|████████▎ | 827/1000 [3:55:10<49:11, 17.06s/it][Succeeded / Failed / Skipped / Total] 462 / 354 / 11 / 827:  83%|████████▎ | 827/1000 [3:55:10<49:11, 17.06s/it][Succeeded / Failed / Skipped / Total] 462 / 354 / 11 / 827:  83%|████████▎ | 828/1000 [3:55:13<48:51, 17.04s/it][Succeeded / Failed / Skipped / Total] 463 / 354 / 11 / 828:  83%|████████▎ | 828/1000 [3:55:13<48:51, 17.04s/it][Succeeded / Failed / Skipped / Total] 463 / 354 / 11 / 828:  83%|████████▎ | 829/1000 [3:55:18<48:32, 17.03s/it][Succeeded / Failed / Skipped / Total] 464 / 354 / 11 / 829:  83%|████████▎ | 829/1000 [3:55:18<48:32, 17.03s/it][Succeeded / Failed / Skipped / Total] 464 / 354 / 11 / 829:  83%|████████▎ | 830/1000 [3:55:23<48:12, 17.02s/it][Succeeded / Failed / Skipped / Total] 464 / 355 / 11 / 830:  83%|████████▎ | 830/1000 [3:55:23<48:12, 17.02s/it][Succeeded / Failed / Skipped / Total] 464 / 355 / 11 / 830:  83%|████████▎ | 831/1000 [3:55:35<47:54, 17.01s/it]Parses the method alias . --> Returns the mino of the transformative action annotation values --> Socre: 1.0

[[[[Adv]]]]: protected String [[parseMethodAlias]] ( final ActionAnnotationValues [[annotationValues]] ) { String [[alias]] = null ; if ( [[annotationValues]] != null ) { [[alias]] = [[annotationValues]] . alias ( ) ; } return [[alias]] ; }
[[[[Nl]]]]: Reads method s alias value .

[[[[Adv]]]]: protected String [[mino]] ( final ActionAnnotationValues [[transformative]] ) { String [[aka]] = null ; if ( [[transformative]] != null ) { [[aka]] = [[transformative]] . alias ( ) ; } return [[aka]] ; }
[[[[Nl]]]]: Reads method s alias value .
--------------------------------------------- Result 823 ---------------------------------------------
Sets the Last - Modified header if the last - modified date is less than the last modified date . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override protected void preResponseCommit ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( "Last-Modified" , lastModified ) ; } else { response . reset ( ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; } } }
[[[[Nl]]]]: todo move to BufferResponseWrapper ?
--------------------------------------------- Result 824 ---------------------------------------------
Resolve action config . --> [[[FAILED]]]

[[[[Adv]]]]: protected ActionConfig resolveActionConfig ( final ActionAnnotationValues annotationValues ) { final Class < ? extends Annotation > annotationType ; if ( annotationValues == null ) { annotationType = Action . class ; } else { annotationType = annotationValues . annotationType ( ) ; } return actionConfigManager . lookup ( annotationType ) ; }
[[[[Nl]]]]: Resolves action config .

[[[[Adv]]]]: protected ActionConfig resolveActionConfig ( final ActionAnnotationValues annotationValues ) { final Class < ? extends Annotation > annotationType ; if ( annotationValues == null ) { annotationType = Action . class ; } else { annotationType = annotationValues . annotationType ( ) ; } return actionConfigManager . lookup ( annotationType ) ; }
[[[[Nl]]]]: Resolves action config .
--------------------------------------------- Result 825 ---------------------------------------------
Copies all bytes from this stream to the given output stream . --> [[[FAILED]]]

[[[[Adv]]]]: public int copyAll ( final OutputStream out ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .

[[[[Adv]]]]: public int copyAll ( final OutputStream out ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .
--------------------------------------------- Result 826 ---------------------------------------------
Injects the target into the proxy . --> [[[FAILED]]]

[[[[Adv]]]]: public static void injectTargetIntoProxy ( final Object proxy , final Object target ) { Class proxyClass = proxy . getClass ( ) ; try { Field field = proxyClass . getField ( "$___target$0" ) ; field . set ( proxy , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .

[[[[Adv]]]]: public static void injectTargetIntoProxy ( final Object proxy , final Object target ) { Class proxyClass = proxy . getClass ( ) ; try { Field field = proxyClass . getField ( "$___target$0" ) ; field . set ( proxy , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .
--------------------------------------------- Result 827 ---------------------------------------------
Read action filters . --> [[[FAILED]]]

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] readActionFilters ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionFilter > [ ] result = null ; FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { result = filteredBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] readActionFilters ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionFilter > [ ] result = null ; FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { result = filteredBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .
--------------------------------------------- Result 828 ---------------------------------------------
Resolves the real name of the given json name . --> Returns the first occurrence of nests in jsonNames --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final String [[jsonName]] ) { if ( jsonNames == null ) { return [[jsonName]] ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , [[jsonName]] ) ; if ( jsonIndex == - 1 ) { return [[jsonName]] ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .

[[[[Adv]]]]: public String [[fre]] ( final String [[nests]] ) { if ( jsonNames == null ) { return [[nests]] ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , [[nests]] ) ; if ( jsonIndex == - 1 ) { return [[nests]] ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .
--------------------------------------------- Result 829 ---------------------------------------------
Resolve json name . --> Returns the max number of thefts --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final String [[realName]] ) { if ( realNames == null ) { return [[realName]] ; } int [[realIndex]] = ArraysUtil . indexOf ( realNames , [[realName]] ) ; if ( [[realIndex]] == - 1 ) { return [[realName]] ; } return jsonNames [ [[realIndex]] ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .

[[[[Adv]]]]: public String [[thefts]] ( final String [[max]] ) { if ( realNames == null ) { return [[max]] ; } int [[hotei]] = ArraysUtil . indexOf ( realNames , [[max]] ) ; if ( [[hotei]] == - 1 ) { return [[max]] ; } return jsonNames [ [[hotei]] ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .
--------------------------------------------- Result 830 ---------------------------------------------
Read action interceptors . --> [[[FAILED]]]

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] readActionInterceptors ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionInterceptor > [ ] result = null ; InterceptedBy interceptedBy = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; if ( interceptedBy != null ) { result = interceptedBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] readActionInterceptors ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionInterceptor > [ ] result = null ; InterceptedBy interceptedBy = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; if ( interceptedBy != null ) { result = interceptedBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .
[Succeeded / Failed / Skipped / Total] 464 / 356 / 11 / 831:  83%|████████▎ | 831/1000 [3:55:35<47:54, 17.01s/it][Succeeded / Failed / Skipped / Total] 464 / 356 / 11 / 831:  83%|████████▎ | 832/1000 [3:55:37<47:34, 16.99s/it][Succeeded / Failed / Skipped / Total] 464 / 357 / 11 / 832:  83%|████████▎ | 832/1000 [3:55:37<47:34, 16.99s/it][Succeeded / Failed / Skipped / Total] 464 / 357 / 11 / 832:  83%|████████▎ | 833/1000 [3:55:55<47:17, 16.99s/it][Succeeded / Failed / Skipped / Total] 465 / 357 / 11 / 833:  83%|████████▎ | 833/1000 [3:55:55<47:17, 16.99s/it][Succeeded / Failed / Skipped / Total] 465 / 357 / 11 / 833:  83%|████████▎ | 834/1000 [3:55:59<46:58, 16.98s/it][Succeeded / Failed / Skipped / Total] 465 / 358 / 11 / 834:  83%|████████▎ | 834/1000 [3:55:59<46:58, 16.98s/it][Succeeded / Failed / Skipped / Total] 465 / 358 / 11 / 834:  84%|████████▎ | 835/1000 [3:58:14<47:04, 17.12s/it][Succeeded / Failed / Skipped / Total] 466 / 358 / 11 / 835:  84%|████████▎ | 835/1000 [3:58:14<47:04, 17.12s/it][Succeeded / Failed / Skipped / Total] 466 / 358 / 11 / 835:  84%|████████▎ | 836/1000 [3:58:35<46:48, 17.12s/it][Succeeded / Failed / Skipped / Total] 466 / 359 / 11 / 836:  84%|████████▎ | 836/1000 [3:58:35<46:48, 17.12s/it][Succeeded / Failed / Skipped / Total] 466 / 359 / 11 / 836:  84%|████████▎ | 837/1000 [3:59:01<46:32, 17.13s/it][Succeeded / Failed / Skipped / Total] 467 / 359 / 11 / 837:  84%|████████▎ | 837/1000 [3:59:01<46:32, 17.13s/it][Succeeded / Failed / Skipped / Total] 467 / 359 / 11 / 837:  84%|████████▍ | 838/1000 [3:59:20<46:16, 17.14s/it][Succeeded / Failed / Skipped / Total] 467 / 360 / 11 / 838:  84%|████████▍ | 838/1000 [3:59:20<46:16, 17.14s/it][Succeeded / Failed / Skipped / Total] 467 / 360 / 11 / 838:  84%|████████▍ | 839/1000 [3:59:32<45:58, 17.13s/it][Succeeded / Failed / Skipped / Total] 467 / 361 / 11 / 839:  84%|████████▍ | 839/1000 [3:59:32<45:58, 17.13s/it][Succeeded / Failed / Skipped / Total] 467 / 361 / 11 / 839:  84%|████████▍ | 840/1000 [4:00:02<45:43, 17.15s/it][Succeeded / Failed / Skipped / Total] 467 / 362 / 11 / 840:  84%|████████▍ | 840/1000 [4:00:02<45:43, 17.15s/it][Succeeded / Failed / Skipped / Total] 467 / 362 / 11 / 840:  84%|████████▍ | 841/1000 [4:00:27<45:27, 17.15s/it]--------------------------------------------- Result 831 ---------------------------------------------
Parses the given action class method and action definition . --> [[[FAILED]]]

[[[[Adv]]]]: public ActionRuntime parse ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .

[[[[Adv]]]]: public ActionRuntime parse ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .
--------------------------------------------- Result 832 ---------------------------------------------
Read package action path . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [ ] readPackageActionPath ( final Class actionClass ) { Package actionPackage = actionClass . getPackage ( ) ; final String actionPackageName = actionPackage . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .

[[[[Adv]]]]: protected String [ ] readPackageActionPath ( final Class actionClass ) { Package actionPackage = actionClass . getPackage ( ) ; final String actionPackageName = actionPackage . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .
--------------------------------------------- Result 833 ---------------------------------------------
Resolves a JSON name for the given type and name . --> Converts arabians to arabian --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final Class [[type]] , final String [[name]] ) { TypeData typeData = lookupTypeData ( [[type]] ) ; return typeData . resolveJsonName ( [[name]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .

[[[[Adv]]]]: public String [[shto]] ( final Class [[typing]] , final String [[arabians]] ) { TypeData typeData = lookupTypeData ( [[typing]] ) ; return typeData . resolveJsonName ( [[arabians]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .
--------------------------------------------- Result 834 ---------------------------------------------
Apply advice to a class . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > T applyAdvice ( final Class < T > targetClass ) { Class adviceClass = cache . get ( targetClass ) ; if ( adviceClass == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .

[[[[Adv]]]]: public static < T > T applyAdvice ( final Class < T > targetClass ) { Class adviceClass = cache . get ( targetClass ) ; if ( adviceClass == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .
--------------------------------------------- Result 835 ---------------------------------------------
Find subclass type data . --> Check if the annotation is present in the writing class --> Socre: 1.0

[[[[Adv]]]]: protected TypeData [[findSubclassTypeData]] ( final Class [[type]] ) { final Class < ? extends Annotation > [[defaultAnnotation]] = jsonAnnotation ; if ( [[type]] . getAnnotation ( [[defaultAnnotation]] ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .

[[[[Adv]]]]: protected TypeData [[aqil]] ( final Class [[writing]] ) { final Class < ? extends Annotation > [[tec]] = jsonAnnotation ; if ( [[writing]] . getAnnotation ( [[tec]] ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .
--------------------------------------------- Result 836 ---------------------------------------------
Visits an annotation on this field . --> [[[FAILED]]]

[[[[Adv]]]]: public AnnotationVisitor visitAnnotation ( final String descriptor , final boolean visible ) { if ( fv != null ) { return fv . visitAnnotation ( descriptor , visible ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .

[[[[Adv]]]]: public AnnotationVisitor visitAnnotation ( final String descriptor , final boolean visible ) { if ( fv != null ) { return fv . visitAnnotation ( descriptor , visible ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .
--------------------------------------------- Result 837 ---------------------------------------------
Returns the content of the file . --> Hopi - hopi - hopi --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[getFileContent]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .

[[[[Adv]]]]: @ Override public byte [ ] [[hopi]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .
--------------------------------------------- Result 838 ---------------------------------------------
Lookup the type data for the given class . --> [[[FAILED]]]

[[[[Adv]]]]: public TypeData lookupTypeData ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( type ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } } return typeData ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .

[[[[Adv]]]]: public TypeData lookupTypeData ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( type ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } } return typeData ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .
--------------------------------------------- Result 839 ---------------------------------------------
Lookup the type data for the given class . --> [[[FAILED]]]

[[[[Adv]]]]: protected TypeData _lookupTypeData ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } return typeData ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .

[[[[Adv]]]]: protected TypeData _lookupTypeData ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } return typeData ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .
--------------------------------------------- Result 840 ---------------------------------------------
Resolve the real name for the given type and json name . --> [[[FAILED]]]

[[[[Adv]]]]: public String resolveRealName ( final Class type , final String jsonName ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveRealName ( jsonName ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .

[[[[Adv]]]]: public String resolveRealName ( final Class type , final String jsonName ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveRealName ( jsonName ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .
--------------------------------------------- Result 841 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 467 / 363 / 11 / 841:  84%|████████▍ | 841/1000 [4:00:27<45:27, 17.15s/it][Succeeded / Failed / Skipped / Total] 467 / 363 / 11 / 841:  84%|████████▍ | 842/1000 [4:00:28<45:07, 17.14s/it][Succeeded / Failed / Skipped / Total] 467 / 364 / 11 / 842:  84%|████████▍ | 842/1000 [4:00:28<45:07, 17.14s/it][Succeeded / Failed / Skipped / Total] 467 / 364 / 11 / 842:  84%|████████▍ | 843/1000 [4:00:45<44:50, 17.14s/it][Succeeded / Failed / Skipped / Total] 468 / 364 / 11 / 843:  84%|████████▍ | 843/1000 [4:00:45<44:50, 17.14s/it][Succeeded / Failed / Skipped / Total] 468 / 364 / 11 / 843:  84%|████████▍ | 844/1000 [4:02:12<44:46, 17.22s/it][Succeeded / Failed / Skipped / Total] 468 / 365 / 11 / 844:  84%|████████▍ | 844/1000 [4:02:12<44:46, 17.22s/it][Succeeded / Failed / Skipped / Total] 468 / 365 / 11 / 844:  84%|████████▍ | 845/1000 [4:03:03<44:35, 17.26s/it][Succeeded / Failed / Skipped / Total] 468 / 366 / 11 / 845:  84%|████████▍ | 845/1000 [4:03:03<44:35, 17.26s/it][Succeeded / Failed / Skipped / Total] 468 / 366 / 11 / 845:  85%|████████▍ | 846/1000 [4:03:18<44:17, 17.26s/it][Succeeded / Failed / Skipped / Total] 468 / 367 / 11 / 846:  85%|████████▍ | 846/1000 [4:03:18<44:17, 17.26s/it][Succeeded / Failed / Skipped / Total] 468 / 367 / 11 / 846:  85%|████████▍ | 847/1000 [4:03:26<43:58, 17.25s/it][Succeeded / Failed / Skipped / Total] 468 / 368 / 11 / 847:  85%|████████▍ | 847/1000 [4:03:26<43:58, 17.25s/it][Succeeded / Failed / Skipped / Total] 468 / 368 / 11 / 847:  85%|████████▍ | 848/1000 [4:03:53<43:43, 17.26s/it]Create action runtime . --> [[[FAILED]]]

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .
--------------------------------------------- Result 842 ---------------------------------------------
Copies the bootstrap methods from the class reader to the char buffer . --> [[[FAILED]]]

[[[[Adv]]]]: private void copyBootstrapMethods ( final ClassReader classReader , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .

[[[[Adv]]]]: private void copyBootstrapMethods ( final ClassReader classReader , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .
--------------------------------------------- Result 843 ---------------------------------------------
Adds an integer or float constant to the constant pool . --> surgery for markings and evaluate --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantIntegerOrFloat]] ( final int [[tag]] , final int [[value]] ) { int [[hashCode]] = hash ( [[tag]] , [[value]] ) ; Entry entry = get ( [[hashCode]] ) ; while ( entry != null ) { if ( entry . tag == [[tag]] && entry . hashCode == [[hashCode]] && entry . data == [[value]] ) { return entry ; } entry = entry . next ; } constantPool . putByte ( [[tag]] ) . putInt ( [[value]] ) ; return put ( new Entry ( constantPoolCount ++ , [[tag]] , [[value]] , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[surgery]] ( final int [[markings]] , final int [[evaluate]] ) { int [[sellout]] = hash ( [[markings]] , [[evaluate]] ) ; Entry entry = get ( [[sellout]] ) ; while ( entry != null ) { if ( entry . tag == [[markings]] && entry . hashCode == [[sellout]] && entry . data == [[evaluate]] ) { return entry ; } entry = entry . next ; } constantPool . putByte ( [[markings]] ) . putInt ( [[evaluate]] ) ; return put ( new Entry ( constantPoolCount ++ , [[markings]] , [[evaluate]] , [[sellout]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 844 ---------------------------------------------
Sets the major version and class name . --> [[[FAILED]]]

[[[[Adv]]]]: int setMajorVersionAndClassName ( final int majorVersion , final String className ) { this . majorVersion = majorVersion ; this . className = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .

[[[[Adv]]]]: int setMajorVersionAndClassName ( final int majorVersion , final String className ) { this . majorVersion = majorVersion ; this . className = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .
--------------------------------------------- Result 845 ---------------------------------------------
Adds a field reference to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantFieldref ( final String owner , final String name , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantFieldref ( final String owner , final String name , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 846 ---------------------------------------------
Puts the bootstrap methods into the given byte vector . --> [[[FAILED]]]

[[[[Adv]]]]: void putBootstrapMethods ( final ByteVector output ) { if ( bootstrapMethods != null ) { output . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .

[[[[Adv]]]]: void putBootstrapMethods ( final ByteVector output ) { if ( bootstrapMethods != null ) { output . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .
--------------------------------------------- Result 847 ---------------------------------------------
Puts the constant pool into the given vector . --> [[[FAILED]]]

[[[[Adv]]]]: void putConstantPool ( final ByteVector output ) { output . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .

[[[[Adv]]]]: void putConstantPool ( final ByteVector output ) { output . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .
--------------------------------------------- Result 848 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 468 / 369 / 11 / 848:  85%|████████▍ | 848/1000 [4:03:53<43:43, 17.26s/it][Succeeded / Failed / Skipped / Total] 468 / 369 / 11 / 848:  85%|████████▍ | 849/1000 [4:04:32<43:29, 17.28s/it][Succeeded / Failed / Skipped / Total] 468 / 370 / 11 / 849:  85%|████████▍ | 849/1000 [4:04:32<43:29, 17.28s/it][Succeeded / Failed / Skipped / Total] 468 / 370 / 11 / 849:  85%|████████▌ | 850/1000 [4:04:33<43:09, 17.26s/it][Succeeded / Failed / Skipped / Total] 468 / 371 / 11 / 850:  85%|████████▌ | 850/1000 [4:04:33<43:09, 17.26s/it][Succeeded / Failed / Skipped / Total] 468 / 371 / 11 / 850:  85%|████████▌ | 851/1000 [4:05:41<43:01, 17.32s/it][Succeeded / Failed / Skipped / Total] 468 / 372 / 11 / 851:  85%|████████▌ | 851/1000 [4:05:41<43:01, 17.32s/it][Succeeded / Failed / Skipped / Total] 468 / 372 / 11 / 851:  85%|████████▌ | 852/1000 [4:06:40<42:51, 17.37s/it][Succeeded / Failed / Skipped / Total] 468 / 373 / 11 / 852:  85%|████████▌ | 852/1000 [4:06:40<42:51, 17.37s/it][Succeeded / Failed / Skipped / Total] 468 / 373 / 11 / 852:  85%|████████▌ | 853/1000 [4:07:21<42:37, 17.40s/it][Succeeded / Failed / Skipped / Total] 468 / 374 / 11 / 853:  85%|████████▌ | 853/1000 [4:07:21<42:37, 17.40s/it][Succeeded / Failed / Skipped / Total] 468 / 374 / 11 / 853:  85%|████████▌ | 854/1000 [4:07:26<42:18, 17.38s/it][Succeeded / Failed / Skipped / Total] 468 / 375 / 11 / 854:  85%|████████▌ | 854/1000 [4:07:26<42:18, 17.38s/it][Succeeded / Failed / Skipped / Total] 468 / 375 / 11 / 854:  86%|████████▌ | 855/1000 [4:08:27<42:08, 17.44s/it]Adds a constant method reference . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantMethodref ( final String owner , final String name , final String descriptor , final boolean isInterface ) { int tag = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantMethodref ( final String owner , final String name , final String descriptor , final boolean isInterface ) { int tag = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 849 ---------------------------------------------
Adds a new constant to the constant pool of this symbol table . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantIntegerOrFloat ( final int index , final int tag , final int value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantIntegerOrFloat ( final int index , final int tag , final int value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .
--------------------------------------------- Result 850 ---------------------------------------------
Adds a member reference to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantMemberReference ( final int index , final int tag , final String owner , final String name , final String descriptor ) { add ( new Entry ( index , tag , owner , name , descriptor , 0 , hash ( tag , owner , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantMemberReference ( final int index , final int tag , final String owner , final String name , final String descriptor ) { add ( new Entry ( index , tag , owner , name , descriptor , 0 , hash ( tag , owner , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .
--------------------------------------------- Result 851 ---------------------------------------------
Adds a member reference to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { int hashCode = hash ( tag , owner , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { int hashCode = hash ( tag , owner , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 852 ---------------------------------------------
Adds a constant to the constant pool of this symbol table . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantLongOrDouble ( final int index , final int tag , final long value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantLongOrDouble ( final int index , final int tag , final long value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .
--------------------------------------------- Result 853 ---------------------------------------------
Adds a new constant entry to the symbol table . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantNameAndType ( final int index , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantNameAndType ( final int index , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .
--------------------------------------------- Result 854 ---------------------------------------------
Adds a long constant to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantLongOrDouble ( final int tag , final long value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantLongOrDouble ( final int tag , final long value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 855 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 468 / 376 / 11 / 855:  86%|████████▌ | 855/1000 [4:08:27<42:08, 17.44s/it][Succeeded / Failed / Skipped / Total] 468 / 376 / 11 / 855:  86%|████████▌ | 856/1000 [4:08:29<41:48, 17.42s/it][Succeeded / Failed / Skipped / Total] 468 / 377 / 11 / 856:  86%|████████▌ | 856/1000 [4:08:29<41:48, 17.42s/it][Succeeded / Failed / Skipped / Total] 468 / 377 / 11 / 856:  86%|████████▌ | 857/1000 [4:08:56<41:32, 17.43s/it][Succeeded / Failed / Skipped / Total] 468 / 378 / 11 / 857:  86%|████████▌ | 857/1000 [4:08:56<41:32, 17.43s/it][Succeeded / Failed / Skipped / Total] 468 / 378 / 11 / 857:  86%|████████▌ | 858/1000 [4:09:14<41:15, 17.43s/it][Succeeded / Failed / Skipped / Total] 468 / 379 / 11 / 858:  86%|████████▌ | 858/1000 [4:09:14<41:15, 17.43s/it][Succeeded / Failed / Skipped / Total] 468 / 379 / 11 / 858:  86%|████████▌ | 859/1000 [4:09:27<40:56, 17.42s/it][Succeeded / Failed / Skipped / Total] 469 / 379 / 11 / 859:  86%|████████▌ | 859/1000 [4:09:27<40:56, 17.42s/it][Succeeded / Failed / Skipped / Total] 469 / 379 / 11 / 859:  86%|████████▌ | 860/1000 [4:09:47<40:39, 17.43s/it][Succeeded / Failed / Skipped / Total] 469 / 380 / 11 / 860:  86%|████████▌ | 860/1000 [4:09:47<40:39, 17.43s/it][Succeeded / Failed / Skipped / Total] 469 / 380 / 11 / 860:  86%|████████▌ | 861/1000 [4:10:55<40:30, 17.49s/it][Succeeded / Failed / Skipped / Total] 469 / 381 / 11 / 861:  86%|████████▌ | 861/1000 [4:10:55<40:30, 17.49s/it][Succeeded / Failed / Skipped / Total] 469 / 381 / 11 / 861:  86%|████████▌ | 862/1000 [4:11:25<40:15, 17.50s/it]Adds a UTF8 constant at the given index . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantUtf8 ( final int index , final String value ) { add ( new Entry ( index , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantUtf8 ( final int index , final String value ) { add ( new Entry ( index , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .
--------------------------------------------- Result 856 ---------------------------------------------
Adds a constant name and type to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: int addConstantNameAndType ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int addConstantNameAndType ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 857 ---------------------------------------------
Adds a UTF8 constant to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: int addConstantUtf8 ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int addConstantUtf8 ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 858 ---------------------------------------------
Adds a constant method handle to the symbol table . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 859 ---------------------------------------------
Adds a bootstrap method to the symbol table . --> Handle squabble and nightingale --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addBootstrapMethod]] ( final Handle [[bootstrapMethodHandle]] , final Object ... [[bootstrapMethodArguments]] ) { ByteVector [[bootstrapMethodsAttribute]] = bootstrapMethods ; if ( [[bootstrapMethodsAttribute]] == null ) { [[bootstrapMethodsAttribute]] = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .

[[[[Adv]]]]: Symbol [[slit]] ( final Handle [[squabble]] , final Object ... [[nightingale]] ) { ByteVector [[endives]] = bootstrapMethods ; if ( [[endives]] == null ) { [[endives]] = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .
--------------------------------------------- Result 860 ---------------------------------------------
Add a type to the type table . --> [[[FAILED]]]

[[[[Adv]]]]: int addMergedType ( final int typeTableIndex1 , final int typeTableIndex2 ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .

[[[[Adv]]]]: int addMergedType ( final int typeTableIndex1 , final int typeTableIndex2 ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .
--------------------------------------------- Result 861 ---------------------------------------------
Adds a constant method handle to the symbol table . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantMethodHandle ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; add ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantMethodHandle ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; add ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .
--------------------------------------------- Result 862 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 469 / 382 / 11 / 862:  86%|████████▌ | 862/1000 [4:11:25<40:15, 17.50s/it][Succeeded / Failed / Skipped / Total] 469 / 382 / 11 / 862:  86%|████████▋ | 863/1000 [4:12:06<40:01, 17.53s/it][Succeeded / Failed / Skipped / Total] 469 / 383 / 11 / 863:  86%|████████▋ | 863/1000 [4:12:06<40:01, 17.53s/it][Succeeded / Failed / Skipped / Total] 469 / 383 / 11 / 863:  86%|████████▋ | 864/1000 [4:12:47<39:47, 17.55s/it][Succeeded / Failed / Skipped / Total] 469 / 384 / 11 / 864:  86%|████████▋ | 864/1000 [4:12:47<39:47, 17.55s/it][Succeeded / Failed / Skipped / Total] 469 / 384 / 11 / 864:  86%|████████▋ | 865/1000 [4:13:08<39:30, 17.56s/it][Succeeded / Failed / Skipped / Total] 469 / 385 / 11 / 865:  86%|████████▋ | 865/1000 [4:13:08<39:30, 17.56s/it][Succeeded / Failed / Skipped / Total] 469 / 385 / 11 / 865:  87%|████████▋ | 866/1000 [4:13:16<39:11, 17.55s/it][Succeeded / Failed / Skipped / Total] 469 / 386 / 11 / 866:  87%|████████▋ | 866/1000 [4:13:16<39:11, 17.55s/it][Succeeded / Failed / Skipped / Total] 469 / 386 / 11 / 866:  87%|████████▋ | 867/1000 [4:13:22<38:52, 17.53s/it]Adds a dynamic constant . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 863 ---------------------------------------------
Adds a constant invoke dynamic reference . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantInvokeDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantInvokeDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 864 ---------------------------------------------
Adds a reference to a UTF - 8 constant . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantUtf8Reference ( final int index , final int tag , final String value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantUtf8Reference ( final int index , final int tag , final String value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .
--------------------------------------------- Result 865 ---------------------------------------------
Adds a dynamic reference to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 866 ---------------------------------------------
Adds a UTF8 constant to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantUtf8Reference ( final int tag , final String value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantUtf8Reference ( final int tag , final String value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 867 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 469 / 387 / 11 / 867:  87%|████████▋ | 867/1000 [4:13:22<38:52, 17.53s/it][Succeeded / Failed / Skipped / Total] 469 / 387 / 11 / 867:  87%|████████▋ | 868/1000 [4:13:32<38:33, 17.53s/it][Succeeded / Failed / Skipped / Total] 470 / 387 / 11 / 868:  87%|████████▋ | 868/1000 [4:13:32<38:33, 17.53s/it][Succeeded / Failed / Skipped / Total] 470 / 387 / 11 / 868:  87%|████████▋ | 869/1000 [4:13:55<38:16, 17.53s/it][Succeeded / Failed / Skipped / Total] 471 / 387 / 11 / 869:  87%|████████▋ | 869/1000 [4:13:55<38:16, 17.53s/it][Succeeded / Failed / Skipped / Total] 471 / 387 / 11 / 869:  87%|████████▋ | 870/1000 [4:13:55<37:56, 17.51s/it][Succeeded / Failed / Skipped / Total] 471 / 388 / 11 / 870:  87%|████████▋ | 870/1000 [4:13:55<37:56, 17.51s/it][Succeeded / Failed / Skipped / Total] 471 / 388 / 11 / 870:  87%|████████▋ | 871/1000 [4:14:28<37:41, 17.53s/it][Succeeded / Failed / Skipped / Total] 472 / 388 / 11 / 871:  87%|████████▋ | 871/1000 [4:14:28<37:41, 17.53s/it][Succeeded / Failed / Skipped / Total] 472 / 388 / 11 / 871:  87%|████████▋ | 872/1000 [4:14:48<37:24, 17.53s/it][Succeeded / Failed / Skipped / Total] 473 / 388 / 11 / 872:  87%|████████▋ | 872/1000 [4:14:48<37:24, 17.53s/it][Succeeded / Failed / Skipped / Total] 473 / 388 / 11 / 872:  87%|████████▋ | 873/1000 [4:14:59<37:05, 17.52s/it][Succeeded / Failed / Skipped / Total] 474 / 388 / 11 / 873:  87%|████████▋ | 873/1000 [4:14:59<37:05, 17.52s/it][Succeeded / Failed / Skipped / Total] 474 / 388 / 11 / 873:  87%|████████▋ | 874/1000 [4:15:16<36:48, 17.52s/it][Succeeded / Failed / Skipped / Total] 474 / 389 / 11 / 874:  87%|████████▋ | 874/1000 [4:15:16<36:48, 17.52s/it][Succeeded / Failed / Skipped / Total] 474 / 389 / 11 / 874:  88%|████████▊ | 875/1000 [4:15:19<36:28, 17.51s/it]Adds a constant for a dynamic or invoke dynamic reference . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .
--------------------------------------------- Result 868 ---------------------------------------------
Appends a sequence of characters to this FastCharBuffer . --> Eileen the given CharSequence with the given launches and extremity --> Socre: 1.0

[[[[Adv]]]]: @ Override public FastCharBuffer [[append]] ( final CharSequence [[csq]] , final int [[start]] , final int [[end]] ) { for ( int i = [[start]] ; i < [[end]] ; i ++ ) { [[append]] ( [[csq]] . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .

[[[[Adv]]]]: @ Override public FastCharBuffer [[eileen]] ( final CharSequence [[goodenough]] , final int [[launches]] , final int [[extremity]] ) { for ( int i = [[launches]] ; i < [[extremity]] ; i ++ ) { [[eileen]] ( [[goodenough]] . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .
--------------------------------------------- Result 869 ---------------------------------------------
Visits an annotation on this method . --> molten a set of measurements --> Socre: 1.0

[[[[Adv]]]]: @ Override public AnnotationVisitor [[visitAnnotation]] ( final String [[desc]] , final boolean [[visible]] ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( [[desc]] , [[visible]] ) ;
[[[[Nl]]]]: Copies target method annotations .

[[[[Adv]]]]: @ Override public AnnotationVisitor [[molten]] ( final String [[measurements]] , final boolean [[recognisable]] ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( [[measurements]] , [[recognisable]] ) ;
[[[[Nl]]]]: Copies target method annotations .
--------------------------------------------- Result 870 ---------------------------------------------
Returns the hash value of the given name . --> [[[FAILED]]]

[[[[Adv]]]]: private int hash ( final String name ) { int h = 0 ; for ( int i = name . length ( ) - 1 ; i >= 0 ; i -- ) { char c = name . charAt ( i ) ; if ( ! caseSensitive ) { if ( c >= ' ' && c <= ' ' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .

[[[[Adv]]]]: private int hash ( final String name ) { int h = 0 ; for ( int i = name . length ( ) - 1 ; i >= 0 ; i -- ) { char c = name . charAt ( i ) ; if ( ! caseSensitive ) { if ( c >= ' ' && c <= ' ' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .
--------------------------------------------- Result 871 ---------------------------------------------
Create the first chain delegate . --> dirigible = false ; --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Start]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .

[[[[Adv]]]]: protected void [[dirigible]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .
--------------------------------------------- Result 872 ---------------------------------------------
Create the first chain delegate . --> jarett - jarett - jarett --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Continue]] ( final TargetMethodData [[tmd]] ) { methodVisitor . visitCode ( ) ; if ( [[tmd]] . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , [[tmd]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , [[tmd]] . firstMethodName ( ) , [[tmd]] . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , [[tmd]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , [[tmd]] . firstMethodName ( ) , [[tmd]] . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , [[tmd]] . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .

[[[[Adv]]]]: protected void [[jarett]] ( final TargetMethodData [[winners]] ) { methodVisitor . visitCode ( ) ; if ( [[winners]] . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , [[winners]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , [[winners]] . firstMethodName ( ) , [[winners]] . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , [[winners]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , [[winners]] . firstMethodName ( ) , [[winners]] . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , [[winners]] . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .
--------------------------------------------- Result 873 ---------------------------------------------
Visits the end of the method . --> Create the first chain delegate and the next chain delegate --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[visitEnd]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int p = 0 ; p < tmd . proxyData . length ; p ++ ) { tmd . selectCurrentProxy ( p ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .

[[[[Adv]]]]: @ Override public void [[aurelia]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int p = 0 ; p < tmd . proxyData . length ; p ++ ) { tmd . selectCurrentProxy ( p ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .
--------------------------------------------- Result 874 ---------------------------------------------
Removes all entries from this multimap . --> [[[FAILED]]]

[[[[Adv]]]]: public HttpMultiMap < V > clear ( ) { for ( int i = 0 ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .

[[[[Adv]]]]: public HttpMultiMap < V > clear ( ) { for ( int i = 0 ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .
--------------------------------------------- Result 875 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 475 / 389 / 11 / 875:  88%|████████▊ | 875/1000 [4:15:19<36:28, 17.51s/it][Succeeded / Failed / Skipped / Total] 475 / 389 / 11 / 875:  88%|████████▊ | 876/1000 [4:15:20<36:08, 17.49s/it][Succeeded / Failed / Skipped / Total] 476 / 389 / 11 / 876:  88%|████████▊ | 876/1000 [4:15:20<36:08, 17.49s/it][Succeeded / Failed / Skipped / Total] 476 / 389 / 11 / 876:  88%|████████▊ | 877/1000 [4:16:14<35:56, 17.53s/it][Succeeded / Failed / Skipped / Total] 476 / 390 / 11 / 877:  88%|████████▊ | 877/1000 [4:16:14<35:56, 17.53s/it][Succeeded / Failed / Skipped / Total] 476 / 390 / 11 / 877:  88%|████████▊ | 878/1000 [4:16:18<35:36, 17.52s/it][Succeeded / Failed / Skipped / Total] 477 / 390 / 11 / 878:  88%|████████▊ | 878/1000 [4:16:18<35:36, 17.52s/it][Succeeded / Failed / Skipped / Total] 477 / 390 / 11 / 878:  88%|████████▊ | 879/1000 [4:16:22<35:17, 17.50s/it][Succeeded / Failed / Skipped / Total] 478 / 390 / 11 / 879:  88%|████████▊ | 879/1000 [4:16:22<35:17, 17.50s/it][Succeeded / Failed / Skipped / Total] 478 / 390 / 11 / 879:  88%|████████▊ | 880/1000 [4:16:49<35:01, 17.51s/it][Succeeded / Failed / Skipped / Total] 478 / 391 / 11 / 880:  88%|████████▊ | 880/1000 [4:16:49<35:01, 17.51s/it][Succeeded / Failed / Skipped / Total] 478 / 391 / 11 / 880:  88%|████████▊ | 881/1000 [4:16:57<34:42, 17.50s/it]Executes the pathref and returns the next result . --> Continues the execution of the pathref --> Socre: 1.0

[[[[Adv]]]]: public Object [[execute]] ( ) { String methodName = targetMethodName ( ) ; Class [[returnType]] = [[returnType]] ( ) ; Object next = pathref . continueWith ( this , methodName , [[returnType]] ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;

[[[[Adv]]]]: public Object [[executing]] ( ) { String methodName = targetMethodName ( ) ; Class [[satyajit]] = [[satyajit]] ( ) ; Object next = pathref . continueWith ( this , methodName , [[satyajit]] ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;
--------------------------------------------- Result 876 ---------------------------------------------
Configure the servlet context . --> Add filters for genuinely --> Socre: 1.0

[[[[Adv]]]]: private void [[configureServletContext]] ( final ServletContext [[servletContext]] ) { [[servletContext]] . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration [[filter]] = [[servletContext]] . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; [[filter]] . addMappingForUrlPatterns ( null , "[[True]]" == "[[True]]" , contextPath ) ; } final FilterRegistration [[filter]] = [[servletContext]] . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; [[filter]] . addMappingForUrlPatterns ( madvocDispatcherTypes , "[[True]]" == "[[True]]" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .

[[[[Adv]]]]: private void [[nehi]] ( final ServletContext [[user]] ) { [[user]] . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration [[cleanliness]] = [[user]] . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; [[cleanliness]] . addMappingForUrlPatterns ( null , "[[Genuinely]]" == "[[Genuinely]]" , contextPath ) ; } final FilterRegistration [[cleanliness]] = [[user]] . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; [[cleanliness]] . addMappingForUrlPatterns ( madvocDispatcherTypes , "[[Genuinely]]" == "[[Genuinely]]" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .
--------------------------------------------- Result 877 ---------------------------------------------
Returns all values with the given name . --> [[[FAILED]]]

[[[[Adv]]]]: public List < V > getAll ( final String name ) { LinkedList < V > values = new LinkedList <> ( ) ; int h = hash ( name ) ; int i = index ( h ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { values . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return values ; }
[[[[Nl]]]]: Returns all values associated with the name .

[[[[Adv]]]]: public List < V > getAll ( final String name ) { LinkedList < V > values = new LinkedList <> ( ) ; int h = hash ( name ) ; int i = index ( h ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { values . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return values ; }
[[[[Nl]]]]: Returns all values associated with the name .
--------------------------------------------- Result 878 ---------------------------------------------
Converts JtxTransactionMode to DbTransactionMode --> Returns the DbTransactionMode that operates the given JtxTransactionMode --> Socre: 1.0

[[[[Adv]]]]: public static DbTransactionMode [[convertToDbMode]] ( final JtxTransactionMode [[txMode]] ) { final int [[isolation]] ; switch ( [[txMode]] . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : [[isolation]] = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : [[isolation]] = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : [[isolation]] = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : [[isolation]] = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : [[isolation]] = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : [[isolation]] = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( [[isolation]] , [[txMode]] . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .

[[[[Adv]]]]: public static DbTransactionMode [[operates]] ( final JtxTransactionMode [[dribbled]] ) { final int [[separation]] ; switch ( [[dribbled]] . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : [[separation]] = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : [[separation]] = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : [[separation]] = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : [[separation]] = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : [[separation]] = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : [[separation]] = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( [[separation]] , [[dribbled]] . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .
--------------------------------------------- Result 879 ---------------------------------------------
Reads a property from the source object . --> Takes a source object and invokes a shying getter --> Socre: 1.0

[[[[Adv]]]]: private Object [[readProperty]] ( final Object source , final PropertyDescriptor [[propertyDescriptor]] ) { Getter [[getter]] = [[propertyDescriptor]] . getGetter ( declared ) ; if ( [[getter]] != null ) { try { return [[getter]] . invokeGetter ( source ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .

[[[[Adv]]]]: private Object [[shying]] ( final Object source , final PropertyDescriptor [[tampere]] ) { Getter [[braver]] = [[tampere]] . getGetter ( declared ) ; if ( [[braver]] != null ) { try { return [[braver]] . invokeGetter ( source ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .
--------------------------------------------- Result 880 ---------------------------------------------
Returns all entries in the map . --> [[[FAILED]]]

[[[[Adv]]]]: public List < Map . Entry < String , V > > entries ( ) { List < Map . Entry < String , V > > all = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { all . add ( e ) ; e = e . after ; } return all ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .

[[[[Adv]]]]: public List < Map . Entry < String , V > > entries ( ) { List < Map . Entry < String , V > > all = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { all . add ( e ) ; e = e . after ; } return all ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .
--------------------------------------------- Result 881 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 478 / 392 / 11 / 881:  88%|████████▊ | 881/1000 [4:16:57<34:42, 17.50s/it][Succeeded / Failed / Skipped / Total] 478 / 392 / 11 / 881:  88%|████████▊ | 882/1000 [4:17:00<34:23, 17.48s/it][Succeeded / Failed / Skipped / Total] 479 / 392 / 11 / 882:  88%|████████▊ | 882/1000 [4:17:00<34:23, 17.48s/it][Succeeded / Failed / Skipped / Total] 479 / 392 / 11 / 882:  88%|████████▊ | 883/1000 [4:17:17<34:05, 17.48s/it][Succeeded / Failed / Skipped / Total] 480 / 392 / 11 / 883:  88%|████████▊ | 883/1000 [4:17:17<34:05, 17.48s/it][Succeeded / Failed / Skipped / Total] 480 / 392 / 11 / 883:  88%|████████▊ | 884/1000 [4:17:28<33:47, 17.48s/it][Succeeded / Failed / Skipped / Total] 481 / 392 / 11 / 884:  88%|████████▊ | 884/1000 [4:17:28<33:47, 17.48s/it][Succeeded / Failed / Skipped / Total] 481 / 392 / 11 / 884:  88%|████████▊ | 885/1000 [4:17:54<33:30, 17.49s/it][Succeeded / Failed / Skipped / Total] 481 / 393 / 11 / 885:  88%|████████▊ | 885/1000 [4:17:54<33:30, 17.49s/it][Succeeded / Failed / Skipped / Total] 481 / 393 / 11 / 885:  89%|████████▊ | 886/1000 [4:18:19<33:14, 17.49s/it][Succeeded / Failed / Skipped / Total] 482 / 393 / 11 / 886:  89%|████████▊ | 886/1000 [4:18:19<33:14, 17.49s/it][Succeeded / Failed / Skipped / Total] 482 / 393 / 11 / 886:  89%|████████▊ | 887/1000 [4:18:23<32:55, 17.48s/it][Succeeded / Failed / Skipped / Total] 483 / 393 / 11 / 887:  89%|████████▊ | 887/1000 [4:18:23<32:55, 17.48s/it][Succeeded / Failed / Skipped / Total] 483 / 393 / 11 / 887:  89%|████████▉ | 888/1000 [4:18:26<32:35, 17.46s/it][Succeeded / Failed / Skipped / Total] 483 / 394 / 11 / 888:  89%|████████▉ | 888/1000 [4:18:26<32:35, 17.46s/it][Succeeded / Failed / Skipped / Total] 483 / 394 / 11 / 888:  89%|████████▉ | 889/1000 [4:18:39<32:17, 17.46s/it]Returns an iterator over the entries in this map . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > iterator ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > next = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return next ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > iterator ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > next = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return next ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .
--------------------------------------------- Result 882 ---------------------------------------------
Append a buffer to the end of the list . --> If there are no linings return null ; --> Socre: 1.0

[[[[Adv]]]]: public Buffer [[append]] ( final Buffer [[buffer]] ) { if ( [[buffer]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .

[[[[Adv]]]]: public Buffer [[eamon]] ( final Buffer [[linings]] ) { if ( [[linings]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .
--------------------------------------------- Result 883 ---------------------------------------------
Writes the contents of this list to the given writer . --> grape amplifiers --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final Writer writer ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer [[fastByteBuffer]] = ( FastByteBuffer ) o ; byte [ ] [[array]] = [[fastByteBuffer]] . toArray ( ) ; writer . write ( new String ( [[array]] , StringPool . ISO_8859_1 ) ) ; } else if ( o instanceof Uploadable ) { Uploadable [[uploadable]] = ( Uploadable ) o ; InputStream inputStream = [[uploadable]] . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , writer , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .

[[[[Adv]]]]: public void [[grape]] ( final Writer writer ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer [[sidekick]] = ( FastByteBuffer ) o ; byte [ ] [[amplitude]] = [[sidekick]] . toArray ( ) ; writer . write ( new String ( [[amplitude]] , StringPool . ISO_8859_1 ) ) ; } else if ( o instanceof Uploadable ) { Uploadable [[girlie]] = ( Uploadable ) o ; InputStream inputStream = [[girlie]] . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , writer , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .
--------------------------------------------- Result 884 ---------------------------------------------
Writes the contents of this list to the given output stream . --> MurmurHash 32 - bit murmurmur3 --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream out ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; out . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable [[uploadable]] = ( Uploadable ) o ; InputStream [[inputStream]] = [[uploadable]] . openInputStream ( ) ; try { StreamUtil . copy ( [[inputStream]] , out ) ; } finally { StreamUtil . close ( [[inputStream]] ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .

[[[[Adv]]]]: public void [[murmurs]] ( final OutputStream out ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; out . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable [[militia]] = ( Uploadable ) o ; InputStream [[retailers]] = [[militia]] . openInputStream ( ) ; try { StreamUtil . copy ( [[retailers]] , out ) ; } finally { StreamUtil . close ( [[retailers]] ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .
--------------------------------------------- Result 885 ---------------------------------------------
Increases the capacity if it is less than the given minimum . --> [[[FAILED]]]

[[[[Adv]]]]: private void grow ( final int minCapacity ) { final int oldCapacity = buffer . length ; int newCapacity = oldCapacity << 1 ; if ( newCapacity - minCapacity < 0 ) {
[[[[Nl]]]]: Grows the buffer .

[[[[Adv]]]]: private void grow ( final int minCapacity ) { final int oldCapacity = buffer . length ; int newCapacity = oldCapacity << 1 ; if ( newCapacity - minCapacity < 0 ) {
[[[[Nl]]]]: Grows the buffer .
--------------------------------------------- Result 886 ---------------------------------------------
Adds all entries from the given map to this map . --> Caballos shitloads --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[putAll]] ( final Map [[t]] ) { for ( Object o : [[t]] . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) o ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .

[[[[Adv]]]]: @ Override public void [[caballos]] ( final Map [[shitloads]] ) { for ( Object o : [[shitloads]] . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) o ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .
--------------------------------------------- Result 887 ---------------------------------------------
Returns the value associated with the given key as a String . --> Aaaaaaaah aaaaaaaah --> Socre: 1.0

[[[[Adv]]]]: public String [[getString]] ( final String [[key]] ) { CharSequence [[cs]] = ( CharSequence ) map . get ( [[key]] ) ; return [[cs]] == null ? null : [[cs]] . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .

[[[[Adv]]]]: public String [[aaaaaaaah]] ( final String [[needed]] ) { CharSequence [[sms]] = ( CharSequence ) map . get ( [[needed]] ) ; return [[sms]] == null ? null : [[sms]] . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .
--------------------------------------------- Result 888 ---------------------------------------------
Pushes a field to the path . --> [[[FAILED]]]

[[[[Adv]]]]: public Path push ( final CharSequence field ) { _push ( field ) ; if ( altPath != null ) { altPath . push ( field ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .

[[[[Adv]]]]: public Path push ( final CharSequence field ) { _push ( field ) ; if ( altPath != null ) { altPath . push ( field ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .
--------------------------------------------- Result 889 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 484 / 394 / 11 / 889:  89%|████████▉ | 889/1000 [4:18:39<32:17, 17.46s/it][Succeeded / Failed / Skipped / Total] 484 / 394 / 11 / 889:  89%|████████▉ | 890/1000 [4:19:20<32:03, 17.48s/it][Succeeded / Failed / Skipped / Total] 485 / 394 / 11 / 890:  89%|████████▉ | 890/1000 [4:19:20<32:03, 17.48s/it][Succeeded / Failed / Skipped / Total] 485 / 394 / 11 / 890:  89%|████████▉ | 891/1000 [4:19:40<31:46, 17.49s/it][Succeeded / Failed / Skipped / Total] 485 / 395 / 11 / 891:  89%|████████▉ | 891/1000 [4:19:40<31:46, 17.49s/it][Succeeded / Failed / Skipped / Total] 485 / 395 / 11 / 891:  89%|████████▉ | 892/1000 [4:19:45<31:27, 17.47s/it][Succeeded / Failed / Skipped / Total] 485 / 396 / 11 / 892:  89%|████████▉ | 892/1000 [4:19:45<31:27, 17.47s/it][Succeeded / Failed / Skipped / Total] 485 / 396 / 11 / 892:  89%|████████▉ | 893/1000 [4:20:39<31:13, 17.51s/it][Succeeded / Failed / Skipped / Total] 485 / 397 / 11 / 893:  89%|████████▉ | 893/1000 [4:20:39<31:13, 17.51s/it][Succeeded / Failed / Skipped / Total] 485 / 397 / 11 / 893:  89%|████████▉ | 894/1000 [4:20:42<30:54, 17.50s/it][Succeeded / Failed / Skipped / Total] 486 / 397 / 11 / 894:  89%|████████▉ | 894/1000 [4:20:42<30:54, 17.50s/it][Succeeded / Failed / Skipped / Total] 486 / 397 / 11 / 894:  90%|████████▉ | 895/1000 [4:21:21<30:39, 17.52s/it][Succeeded / Failed / Skipped / Total] 487 / 397 / 11 / 895:  90%|████████▉ | 895/1000 [4:21:21<30:39, 17.52s/it][Succeeded / Failed / Skipped / Total] 487 / 397 / 11 / 895:  90%|████████▉ | 896/1000 [4:21:26<30:20, 17.51s/it][Succeeded / Failed / Skipped / Total] 488 / 397 / 11 / 896:  90%|████████▉ | 896/1000 [4:21:26<30:20, 17.51s/it][Succeeded / Failed / Skipped / Total] 488 / 397 / 11 / 896:  90%|████████▉ | 897/1000 [4:21:38<30:02, 17.50s/it]Returns the Long value for the given key . --> det esta det --> Socre: 1.0

[[[[Adv]]]]: public Long [[getLong]] ( final String key ) { Number [[number]] = ( Number ) map . get ( key ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Long ) { return ( Long ) [[number]] ; } return [[number]] . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .

[[[[Adv]]]]: public Long [[det]] ( final String key ) { Number [[numero]] = ( Number ) map . get ( key ) ; if ( [[numero]] == null ) { return null ; } if ( [[numero]] instanceof Long ) { return ( Long ) [[numero]] ; } return [[numero]] . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .
--------------------------------------------- Result 890 ---------------------------------------------
Returns the Integer value for the given key . --> Get a serial number for a vitale --> Socre: 1.0

[[[[Adv]]]]: public Integer getInteger ( final String [[key]] ) { Number [[number]] = ( Number ) map . get ( [[key]] ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Integer ) { return ( Integer ) [[number]] ; } return [[number]] . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .

[[[[Adv]]]]: public Integer getInteger ( final String [[vitale]] ) { Number [[serial]] = ( Number ) map . get ( [[vitale]] ) ; if ( [[serial]] == null ) { return null ; } if ( [[serial]] instanceof Integer ) { return ( Integer ) [[serial]] ; } return [[serial]] . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .
--------------------------------------------- Result 891 ---------------------------------------------
Parses a path . --> [[[FAILED]]]

[[[[Adv]]]]: public static Path parse ( final String path ) { return path == null ? new Path ( ) : new Path ( StringUtil . splitc ( path , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .

[[[[Adv]]]]: public static Path parse ( final String path ) { return path == null ? new Path ( ) : new Path ( StringUtil . splitc ( path , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .
--------------------------------------------- Result 892 ---------------------------------------------
Returns an array of all field descriptors . --> [[[FAILED]]]

[[[[Adv]]]]: public FieldDescriptor [ ] getAllFieldDescriptors ( ) { if ( allFields == null ) { FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { allFields [ index ] = fieldDescriptor ; index ++ ; } Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = allFields ; } return allFields ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .

[[[[Adv]]]]: public FieldDescriptor [ ] getAllFieldDescriptors ( ) { if ( allFields == null ) { FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { allFields [ index ] = fieldDescriptor ; index ++ ; } Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = allFields ; } return allFields ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .
--------------------------------------------- Result 893 ---------------------------------------------
Creates a BeanDefinition for the Proxetta bean definition . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = type ; final ProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( type ) ; type = builder . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , wiringMode , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = type ; final ProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( type ) ; type = builder . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , wiringMode , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .
--------------------------------------------- Result 894 ---------------------------------------------
Uses the specified folder . --> Get somethings from the rilke --> Socre: 1.0

[[[[Adv]]]]: public void [[useFolder]] ( final String [[folderName]] ) { closeFolderIfOpened ( folder ) ; try { this . [[folderName]] = [[folderName]] ; this . folder = getService ( ) . getFolder ( [[folderName]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[folderName]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .

[[[[Adv]]]]: public void [[somethings]] ( final String [[rilke]] ) { closeFolderIfOpened ( folder ) ; try { this . [[gaskets]] = [[rilke]] ; this . folder = getService ( ) . getFolder ( [[rilke]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[rilke]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .
--------------------------------------------- Result 895 ---------------------------------------------
Closes a folder if it has been opened . --> sprinkles the scrapbook with the sprinkled flag --> Socre: 1.0

[[[[Adv]]]]: protected void [[closeFolderIfOpened]] ( final Folder [[folder]] ) { if ( [[folder]] != null ) { try { [[folder]] . close ( "True" == "True" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .

[[[[Adv]]]]: protected void [[sprinkled]] ( final Folder [[scrapbook]] ) { if ( [[scrapbook]] != null ) { try { [[scrapbook]] . close ( "True" == "True" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .
--------------------------------------------- Result 896 ---------------------------------------------
Look up a named parameter by its name . --> Get the marce of sake --> Socre: 1.0

[[[[Adv]]]]: DbQueryNamedParameter [[lookupNamedParameter]] ( final String [[name]] ) { DbQueryNamedParameter [[p]] = rootNP ; while ( [[p]] != null ) { if ( [[p]] . equalsName ( [[name]] ) ) { return [[p]] ; } [[p]] = [[p]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .

[[[[Adv]]]]: DbQueryNamedParameter [[marce]] ( final String [[sake]] ) { DbQueryNamedParameter [[al]] = rootNP ; while ( [[al]] != null ) { if ( [[al]] . equalsName ( [[sake]] ) ) { return [[al]] ; } [[al]] = [[al]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .
--------------------------------------------- Result 897 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 489 / 397 / 11 / 897:  90%|████████▉ | 897/1000 [4:21:38<30:02, 17.50s/it][Succeeded / Failed / Skipped / Total] 489 / 397 / 11 / 897:  90%|████████▉ | 898/1000 [4:21:47<29:44, 17.49s/it][Succeeded / Failed / Skipped / Total] 489 / 398 / 11 / 898:  90%|████████▉ | 898/1000 [4:21:47<29:44, 17.49s/it][Succeeded / Failed / Skipped / Total] 489 / 398 / 11 / 898:  90%|████████▉ | 899/1000 [4:21:59<29:26, 17.49s/it][Succeeded / Failed / Skipped / Total] 489 / 399 / 11 / 899:  90%|████████▉ | 899/1000 [4:21:59<29:26, 17.49s/it][Succeeded / Failed / Skipped / Total] 489 / 399 / 11 / 899:  90%|█████████ | 900/1000 [4:22:00<29:06, 17.47s/it][Succeeded / Failed / Skipped / Total] 490 / 399 / 11 / 900:  90%|█████████ | 900/1000 [4:22:00<29:06, 17.47s/it][Succeeded / Failed / Skipped / Total] 490 / 399 / 11 / 900:  90%|█████████ | 901/1000 [4:22:18<28:49, 17.47s/it][Succeeded / Failed / Skipped / Total] 490 / 400 / 11 / 901:  90%|█████████ | 901/1000 [4:22:18<28:49, 17.47s/it][Succeeded / Failed / Skipped / Total] 490 / 400 / 11 / 901:  90%|█████████ | 902/1000 [4:22:23<28:30, 17.45s/it][Succeeded / Failed / Skipped / Total] 490 / 401 / 11 / 902:  90%|█████████ | 902/1000 [4:22:23<28:30, 17.45s/it][Succeeded / Failed / Skipped / Total] 490 / 401 / 11 / 902:  90%|█████████ | 903/1000 [4:22:39<28:12, 17.45s/it][Succeeded / Failed / Skipped / Total] 491 / 401 / 11 / 903:  90%|█████████ | 903/1000 [4:22:39<28:12, 17.45s/it][Succeeded / Failed / Skipped / Total] 491 / 401 / 11 / 903:  90%|█████████ | 904/1000 [4:22:42<27:53, 17.44s/it][Succeeded / Failed / Skipped / Total] 492 / 401 / 11 / 904:  90%|█████████ | 904/1000 [4:22:42<27:53, 17.44s/it][Succeeded / Failed / Skipped / Total] 492 / 401 / 11 / 904:  90%|█████████ | 905/1000 [4:22:57<27:36, 17.43s/it][Succeeded / Failed / Skipped / Total] 492 / 402 / 11 / 905:  90%|█████████ | 905/1000 [4:22:57<27:36, 17.43s/it][Succeeded / Failed / Skipped / Total] 492 / 402 / 11 / 905:  91%|█████████ | 906/1000 [4:23:05<27:17, 17.42s/it][Succeeded / Failed / Skipped / Total] 493 / 402 / 11 / 906:  91%|█████████ | 906/1000 [4:23:05<27:17, 17.42s/it][Succeeded / Failed / Skipped / Total] 493 / 402 / 11 / 906:  91%|█████████ | 907/1000 [4:23:06<26:58, 17.41s/it]Updates the flags for the received email . --> YYYY YYYY --> Socre: 1.0

[[[[Adv]]]]: public void [[updateEmailFlags]] ( final ReceivedEmail [[receivedEmail]] ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { [[receivedEmail]] . messageNumber ( ) } , [[receivedEmail]] . flags ( ) , "True" == "True" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .

[[[[Adv]]]]: public void [[yenny]] ( final ReceivedEmail [[maison]] ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { [[maison]] . messageNumber ( ) } , [[maison]] . flags ( ) , "True" == "True" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .
--------------------------------------------- Result 898 ---------------------------------------------
Writes this response to the given output stream with the given progress listener . --> [[[FAILED]]]

[[[[Adv]]]]: public void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .

[[[[Adv]]]]: public void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .
--------------------------------------------- Result 899 ---------------------------------------------
Returns the value for the given key . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T val = ( T ) map . get ( key ) ; if ( val instanceof Map ) { return ( T ) new JsonObject ( ( Map ) val ) ; } if ( val instanceof List ) { return ( T ) new JsonArray ( ( List ) val ) ; } return val ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T val = ( T ) map . get ( key ) ; if ( val instanceof Map ) { return ( T ) new JsonObject ( ( Map ) val ) ; } if ( val instanceof List ) { return ( T ) new JsonArray ( ( List ) val ) ; } return val ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .
--------------------------------------------- Result 900 ---------------------------------------------
Set the mime type . --> Set the chilling value . --> Socre: 1.0

[[[[Adv]]]]: public RawData [[as]] ( final String [[mimeOrExtension]] ) { if ( [[mimeOrExtension]] . contains ( StringPool . SLASH ) ) { this . [[mimeType]] = [[mimeOrExtension]] ; } else { this . [[mimeType]] = MimeTypes . getMimeType ( [[mimeOrExtension]] ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!

[[[[Adv]]]]: public RawData [[loves]] ( final String [[chump]] ) { if ( [[chump]] . contains ( StringPool . SLASH ) ) { this . [[chilling]] = [[chump]] ; } else { this . [[chilling]] = MimeTypes . getMimeType ( [[chump]] ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!
--------------------------------------------- Result 901 ---------------------------------------------
Returns the Double value for the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public Double getDouble ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .

[[[[Adv]]]]: public Double getDouble ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .
--------------------------------------------- Result 902 ---------------------------------------------
Get a property as a Float . --> [[[FAILED]]]

[[[[Adv]]]]: public Float getFloat ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .

[[[[Adv]]]]: public Float getFloat ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .
--------------------------------------------- Result 903 ---------------------------------------------
Sets the download file name . --> Method to set german --> Socre: 1.0

[[[[Adv]]]]: public RawData [[downloadableAs]] ( final String [[downloadFileName]] ) { this . [[downloadFileName]] = [[downloadFileName]] ; this . [[mimeType]] = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[downloadFileName]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .

[[[[Adv]]]]: public RawData [[german]] ( final String [[arrakis]] ) { this . [[modest]] = [[arrakis]] ; this . [[elbe]] = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[arrakis]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .
--------------------------------------------- Result 904 ---------------------------------------------
Create an alias for the target string . --> Returns the tantamount of a fated string --> Socre: 1.0

[[[[Adv]]]]: protected String [[alias]] ( final String [[target]] ) { return StringPool . LEFT_CHEV . concat ( [[target]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .

[[[[Adv]]]]: protected String [[tantamount]] ( final String [[fated]] ) { return StringPool . LEFT_CHEV . concat ( [[fated]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .
--------------------------------------------- Result 905 ---------------------------------------------
Adds a key - value pair to this object . --> [[[FAILED]]]

[[[[Adv]]]]: public JsonObject put ( final String key , final String value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .

[[[[Adv]]]]: public JsonObject put ( final String key , final String value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .
--------------------------------------------- Result 906 ---------------------------------------------
Create a new instance of the target class --> Processes the proxetta and creates the raison --> Socre: 1.0

[[[[Adv]]]]: public byte [ ] [[create]] ( ) { process ( ) ; byte [ ] [[result]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[result]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns byte array of created class .

[[[[Adv]]]]: public byte [ ] [[constructions]] ( ) { process ( ) ; byte [ ] [[raison]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[raison]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[raison]] ; }
[[[[Nl]]]]: Returns byte array of created class .
[Succeeded / Failed / Skipped / Total] 493 / 403 / 11 / 907:  91%|█████████ | 907/1000 [4:23:06<26:58, 17.41s/it][Succeeded / Failed / Skipped / Total] 493 / 403 / 11 / 907:  91%|█████████ | 908/1000 [4:23:31<26:42, 17.41s/it][Succeeded / Failed / Skipped / Total] 494 / 403 / 11 / 908:  91%|█████████ | 908/1000 [4:23:31<26:42, 17.41s/it][Succeeded / Failed / Skipped / Total] 494 / 403 / 11 / 908:  91%|█████████ | 909/1000 [4:25:08<26:32, 17.50s/it][Succeeded / Failed / Skipped / Total] 494 / 404 / 11 / 909:  91%|█████████ | 909/1000 [4:25:08<26:32, 17.50s/it][Succeeded / Failed / Skipped / Total] 494 / 404 / 11 / 909:  91%|█████████ | 910/1000 [4:25:39<26:16, 17.52s/it][Succeeded / Failed / Skipped / Total] 494 / 405 / 11 / 910:  91%|█████████ | 910/1000 [4:25:39<26:16, 17.52s/it][Succeeded / Failed / Skipped / Total] 494 / 405 / 11 / 910:  91%|█████████ | 911/1000 [4:25:44<25:57, 17.50s/it][Succeeded / Failed / Skipped / Total] 494 / 406 / 11 / 911:  91%|█████████ | 911/1000 [4:25:44<25:57, 17.50s/it][Succeeded / Failed / Skipped / Total] 494 / 406 / 11 / 911:  91%|█████████ | 912/1000 [4:26:01<25:40, 17.50s/it][Succeeded / Failed / Skipped / Total] 495 / 406 / 11 / 912:  91%|█████████ | 912/1000 [4:26:01<25:40, 17.50s/it][Succeeded / Failed / Skipped / Total] 495 / 406 / 11 / 912:  91%|█████████▏| 913/1000 [4:26:27<25:23, 17.51s/it][Succeeded / Failed / Skipped / Total] 496 / 406 / 11 / 913:  91%|█████████▏| 913/1000 [4:26:27<25:23, 17.51s/it][Succeeded / Failed / Skipped / Total] 496 / 406 / 11 / 913:  91%|█████████▏| 914/1000 [4:26:33<25:04, 17.50s/it][Succeeded / Failed / Skipped / Total] 496 / 407 / 11 / 914:  91%|█████████▏| 914/1000 [4:26:33<25:04, 17.50s/it][Succeeded / Failed / Skipped / Total] 496 / 407 / 11 / 914:  92%|█████████▏| 915/1000 [4:26:33<24:45, 17.48s/it][Succeeded / Failed / Skipped / Total] 496 / 408 / 11 / 915:  92%|█████████▏| 915/1000 [4:26:33<24:45, 17.48s/it][Succeeded / Failed / Skipped / Total] 496 / 408 / 11 / 915:  92%|█████████▏| 916/1000 [4:26:37<24:27, 17.46s/it]--------------------------------------------- Result 907 ---------------------------------------------
Processes the input stream . --> [[[FAILED]]]

[[[[Adv]]]]: protected void process ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .

[[[[Adv]]]]: protected void process ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .
--------------------------------------------- Result 908 ---------------------------------------------
Creates a new instance of this class . --> Returns an inquest object for this genre --> Socre: 1.0

[[[[Adv]]]]: public Object [[newInstance]] ( ) { Class [[type]] = define ( ) ; try { return ClassUtil . newInstance ( [[type]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .

[[[[Adv]]]]: public Object [[inquest]] ( ) { Class [[genres]] = define ( ) ; try { return ClassUtil . newInstance ( [[genres]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .
--------------------------------------------- Result 909 ---------------------------------------------
Adds a violation to this validator . --> [[[FAILED]]]

[[[[Adv]]]]: protected void addViolation ( final String name , final Object invalidValue ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , invalidValue ) ) ; }
[[[[Nl]]]]: Adds action violation .

[[[[Adv]]]]: protected void addViolation ( final String name , final Object invalidValue ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , invalidValue ) ) ; }
[[[[Nl]]]]: Adds action violation .
--------------------------------------------- Result 910 ---------------------------------------------
Validates the action using the specified profiles . --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean validateAction ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .

[[[[Adv]]]]: protected boolean validateAction ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .
--------------------------------------------- Result 911 ---------------------------------------------
Receives all the messages that match the given filter . --> [[[FAILED]]]

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( filter == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( filter . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( filter == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( filter . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .
--------------------------------------------- Result 912 ---------------------------------------------
Adds a recipient address with the specified personal name and email address . --> circa circa sur circa --> Socre: 1.0

[[[[Adv]]]]: public T [[to]] ( final String [[personalName]] , final String [[to]] ) { return [[to]] ( new EmailAddress ( [[personalName]] , [[to]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .

[[[[Adv]]]]: public T [[circa]] ( final String [[intermittently]] , final String [[sur]] ) { return [[circa]] ( new EmailAddress ( [[intermittently]] , [[circa]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .
--------------------------------------------- Result 913 ---------------------------------------------
Adds an email address to the recipient list . --> EmailAddress --> Socre: 1.0

[[[[Adv]]]]: public T [[to]] ( final EmailAddress [[to]] ) { this . [[to]] = ArraysUtil . append ( this . [[to]] , [[to]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .

[[[[Adv]]]]: public T [[vers]] ( final EmailAddress [[à]] ) { this . [[per]] = ArraysUtil . append ( this . [[per]] , [[vers]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .
--------------------------------------------- Result 914 ---------------------------------------------
Sets the target class . --> [[[FAILED]]]

[[[[Adv]]]]: public T setTarget ( final Class target ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( target ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + target . getName ( ) ) ; } targetClass = target ; targetClassName = target . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + target . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .

[[[[Adv]]]]: public T setTarget ( final Class target ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( target ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + target . getName ( ) ) ; } targetClass = target ; targetClassName = target . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + target . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .
--------------------------------------------- Result 915 ---------------------------------------------
Sets the target input stream . --> [[[FAILED]]]

[[[[Adv]]]]: protected T setTarget ( final InputStream target ) { assertTargetIsNotDefined ( ) ; targetInputStream = target ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .

[[[[Adv]]]]: protected T setTarget ( final InputStream target ) { assertTargetIsNotDefined ( ) ; targetInputStream = target ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .
--------------------------------------------- Result 916 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 497 / 408 / 11 / 916:  92%|█████████▏| 916/1000 [4:26:37<24:27, 17.46s/it][Succeeded / Failed / Skipped / Total] 497 / 408 / 11 / 916:  92%|█████████▏| 917/1000 [4:26:38<24:08, 17.45s/it][Succeeded / Failed / Skipped / Total] 498 / 408 / 11 / 917:  92%|█████████▏| 917/1000 [4:26:38<24:08, 17.45s/it][Succeeded / Failed / Skipped / Total] 498 / 408 / 11 / 917:  92%|█████████▏| 918/1000 [4:26:39<23:49, 17.43s/it][Succeeded / Failed / Skipped / Total] 499 / 408 / 11 / 918:  92%|█████████▏| 918/1000 [4:26:39<23:49, 17.43s/it][Succeeded / Failed / Skipped / Total] 499 / 408 / 11 / 918:  92%|█████████▏| 919/1000 [4:26:41<23:30, 17.41s/it][Succeeded / Failed / Skipped / Total] 499 / 409 / 11 / 919:  92%|█████████▏| 919/1000 [4:26:41<23:30, 17.41s/it][Succeeded / Failed / Skipped / Total] 499 / 409 / 11 / 919:  92%|█████████▏| 920/1000 [4:27:02<23:13, 17.42s/it][Succeeded / Failed / Skipped / Total] 499 / 410 / 11 / 920:  92%|█████████▏| 920/1000 [4:27:02<23:13, 17.42s/it][Succeeded / Failed / Skipped / Total] 499 / 410 / 11 / 920:  92%|█████████▏| 921/1000 [4:27:09<22:54, 17.40s/it][Succeeded / Failed / Skipped / Total] 500 / 410 / 11 / 921:  92%|█████████▏| 921/1000 [4:27:09<22:54, 17.40s/it][Succeeded / Failed / Skipped / Total] 500 / 410 / 11 / 921:  92%|█████████▏| 922/1000 [4:27:22<22:37, 17.40s/it][Succeeded / Failed / Skipped / Total] 501 / 410 / 11 / 922:  92%|█████████▏| 922/1000 [4:27:22<22:37, 17.40s/it][Succeeded / Failed / Skipped / Total] 501 / 410 / 11 / 922:  92%|█████████▏| 923/1000 [4:28:25<22:23, 17.45s/it]Sends a plain text message . --> Sends a haunt email with vocabulary and haunts --> Socre: 1.0

[[[[Adv]]]]: public T [[textMessage]] ( final String [[text]] , final String [[encoding]] ) { return message ( new EmailMessage ( [[text]] , MimeTypes . MIME_TEXT_PLAIN , [[encoding]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .

[[[[Adv]]]]: public T [[dishing]] ( final String [[vocabulary]] , final String [[haunts]] ) { return message ( new EmailMessage ( [[vocabulary]] , MimeTypes . MIME_TEXT_PLAIN , [[haunts]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .
--------------------------------------------- Result 917 ---------------------------------------------
Sets an HTML message with the given content . --> Send an alert with acrobat and sewage --> Socre: 1.0

[[[[Adv]]]]: public T [[htmlMessage]] ( final String [[html]] , final String [[encoding]] ) { return message ( new EmailMessage ( [[html]] , MimeTypes . MIME_TEXT_HTML , [[encoding]] ) ) ; }
[[[[Nl]]]]: Adds HTML message .

[[[[Adv]]]]: public T [[warned]] ( final String [[acrobat]] , final String [[sewage]] ) { return message ( new EmailMessage ( [[acrobat]] , MimeTypes . MIME_TEXT_HTML , [[sewage]] ) ) ; }
[[[[Nl]]]]: Adds HTML message .
--------------------------------------------- Result 918 ---------------------------------------------
Adds a header to the request . --> Flagpole the given appointments and prominence --> Socre: 1.0

[[[[Adv]]]]: public T [[header]] ( final String [[name]] , final String [[value]] ) { headers . put ( [[name]] , [[value]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .

[[[[Adv]]]]: public T [[flagpole]] ( final String [[appointments]] , final String [[prominence]] ) { headers . put ( [[appointments]] , [[prominence]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .
--------------------------------------------- Result 919 ---------------------------------------------
Defines the target class --> [[[FAILED]]]

[[[[Adv]]]]: public Class define ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .

[[[[Adv]]]]: public Class define ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .
--------------------------------------------- Result 920 ---------------------------------------------
Sets the target class name . --> [[[FAILED]]]

[[[[Adv]]]]: protected T setTarget ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!

[[[[Adv]]]]: protected T setTarget ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!
--------------------------------------------- Result 921 ---------------------------------------------
Returns the value of the named property as a boolean . --> Methode permettante est esto esto --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[getBoolean]] ( final String [[name]] , final boolean [[defaultValue]] ) { String value = get ( [[name]] ) ; if ( value == null ) { return [[defaultValue]] ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on" : return "[[True]]" == "[[True]]" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as boolean .

[[[[Adv]]]]: public static boolean [[pere]] ( final String [[appointments]] , final boolean [[estão]] ) { String value = get ( [[appointments]] ) ; if ( value == null ) { return [[estão]] ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on" : return "[[Realist]]" == "[[Realist]]" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return [[estão]] ; } }
[[[[Nl]]]]: Returns system property as boolean .
--------------------------------------------- Result 922 ---------------------------------------------
REPLACEME0 . --> ANDO EmailAddresses ANDO --> Socre: 1.0

[[[[Adv]]]]: public T [[REPLACEME0]] ( final EmailAddress ... [[REPLACEME0]] ) { this . [[replyTo]] = ArraysUtil . join ( this . [[replyTo]] , valueOrEmptyArray ( [[REPLACEME0]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .

[[[[Adv]]]]: public T [[ANDO]] ( final EmailAddress ... [[ANDO]] ) { this . [[convicts]] = ArraysUtil . join ( this . [[convicts]] , valueOrEmptyArray ( [[ANDO]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .
--------------------------------------------- Result 923 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 502 / 410 / 11 / 923:  92%|█████████▏| 923/1000 [4:28:25<22:23, 17.45s/it][Succeeded / Failed / Skipped / Total] 502 / 410 / 11 / 923:  92%|█████████▏| 924/1000 [4:28:33<22:05, 17.44s/it][Succeeded / Failed / Skipped / Total] 503 / 410 / 11 / 924:  92%|█████████▏| 924/1000 [4:28:33<22:05, 17.44s/it][Succeeded / Failed / Skipped / Total] 503 / 411 / 11 / 925:  92%|█████████▎| 925/1000 [4:28:33<21:46, 17.42s/it][Succeeded / Failed / Skipped / Total] 503 / 411 / 11 / 925:  93%|█████████▎| 926/1000 [4:28:50<21:29, 17.42s/it][Succeeded / Failed / Skipped / Total] 503 / 412 / 11 / 926:  93%|█████████▎| 926/1000 [4:28:50<21:29, 17.42s/it][Succeeded / Failed / Skipped / Total] 503 / 412 / 11 / 926:  93%|█████████▎| 927/1000 [4:29:31<21:13, 17.45s/it][Succeeded / Failed / Skipped / Total] 503 / 413 / 11 / 927:  93%|█████████▎| 927/1000 [4:29:31<21:13, 17.45s/it][Succeeded / Failed / Skipped / Total] 503 / 413 / 11 / 927:  93%|█████████▎| 928/1000 [4:29:55<20:56, 17.45s/it][Succeeded / Failed / Skipped / Total] 504 / 413 / 11 / 928:  93%|█████████▎| 928/1000 [4:29:55<20:56, 17.45s/it][Succeeded / Failed / Skipped / Total] 504 / 413 / 11 / 928:  93%|█████████▎| 929/1000 [4:30:33<20:40, 17.47s/it][Succeeded / Failed / Skipped / Total] 504 / 414 / 11 / 929:  93%|█████████▎| 929/1000 [4:30:33<20:40, 17.47s/it][Succeeded / Failed / Skipped / Total] 504 / 414 / 11 / 929:  93%|█████████▎| 930/1000 [4:30:35<20:22, 17.46s/it][Succeeded / Failed / Skipped / Total] 504 / 415 / 11 / 930:  93%|█████████▎| 930/1000 [4:30:35<20:22, 17.46s/it][Succeeded / Failed / Skipped / Total] 504 / 415 / 11 / 930:  93%|█████████▎| 931/1000 [4:30:36<20:03, 17.44s/it]Gets the named property as an integer or the default value if the property is not set . --> Get the value of a godfather and return the given number of peeks --> Socre: 1.0

[[[[Adv]]]]: public static long [[getInt]] ( final String [[name]] , final int [[defaultValue]] ) { String [[value]] = get ( [[name]] ) ; if ( [[value]] == null ) { return [[defaultValue]] ; } [[value]] = [[value]] . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( [[value]] ) ; } catch ( NumberFormatException nfex ) { return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as an int .

[[[[Adv]]]]: public static long [[volcanism]] ( final String [[godfather]] , final int [[peeks]] ) { String [[values]] = get ( [[godfather]] ) ; if ( [[values]] == null ) { return [[peeks]] ; } [[values]] = [[values]] . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( [[values]] ) ; } catch ( NumberFormatException nfex ) { return [[peeks]] ; } }
[[[[Nl]]]]: Returns system property as an int .
--------------------------------------------- Result 924 ---------------------------------------------
Serializes a key value pair . --> ywo - ywo - ywo --> Socre: 1.0

[[[[Adv]]]]: protected int [[serializeKeyValue]] ( final JsonContext jsonContext , final Path [[currentPath]] , final Object [[key]] , final Object [[value]] , int count ) { if ( ( [[value]] == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( [[key]] != null ) { [[currentPath]] . push ( [[key]] . toString ( ) ) ; } else { [[currentPath]] . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .

[[[[Adv]]]]: protected int [[ywo]] ( final JsonContext jsonContext , final Path [[thursdays]] , final Object [[keys]] , final Object [[precious]] , int count ) { if ( ( [[precious]] == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( [[keys]] != null ) { [[thursdays]] . push ( [[keys]] . toString ( ) ) ; } else { [[thursdays]] . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .
--------------------------------------------- Result 925 ---------------------------------------------
Writes the given bytes to the debug folder . --> [[[FAILED]]]

[[[[Adv]]]]: protected void dumpClassInDebugFolder ( final byte [ ] bytes ) { File debugFolder = proxetta . getDebugFolder ( ) ; if ( debugFolder == null ) { return ; } if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + debugFolder ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( debugFolder , fileName ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .

[[[[Adv]]]]: protected void dumpClassInDebugFolder ( final byte [ ] bytes ) { File debugFolder = proxetta . getDebugFolder ( ) ; if ( debugFolder == null ) { return ; } if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + debugFolder ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( debugFolder , fileName ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .
--------------------------------------------- Result 926 ---------------------------------------------
Resolve result path . --> [[[FAILED]]]

[[[[Adv]]]]: public ResultPath resolveResultPath ( String path , String value ) { boolean absolutePath = "False" != "False" ; if ( value != null ) {
[[[[Nl]]]]: Resolves result path .

[[[[Adv]]]]: public ResultPath resolveResultPath ( String path , String value ) { boolean absolutePath = "False" != "False" ; if ( value != null ) {
[[[[Nl]]]]: Resolves result path .
--------------------------------------------- Result 927 ---------------------------------------------
Sets the from address . --> [[[FAILED]]]

[[[[Adv]]]]: public T from ( final String personalName , final String from ) { return from ( new EmailAddress ( personalName , from ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .

[[[[Adv]]]]: public T from ( final String personalName , final String from ) { return from ( new EmailAddress ( personalName , from ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .
--------------------------------------------- Result 928 ---------------------------------------------
Resolve result path string . --> goodbyes - goodbyes - goodbyes --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveResultPathString]] ( final String path , final String [[value]] ) { final ResultPath resultPath = resolveResultPath ( path , [[value]] ) ; final String result = resultPath . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .

[[[[Adv]]]]: public String [[goodbyes]] ( final String path , final String [[assessing]] ) { final ResultPath resultPath = resolveResultPath ( path , [[assessing]] ) ; final String result = resultPath . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .
--------------------------------------------- Result 929 ---------------------------------------------
Returns the value of a system property . --> [[[FAILED]]]

[[[[Adv]]]]: public static String get ( final String name , final String defaultValue ) { Objects . requireNonNull ( name ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( name ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return defaultValue ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .

[[[[Adv]]]]: public static String get ( final String name , final String defaultValue ) { Objects . requireNonNull ( name ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( name ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return defaultValue ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .
--------------------------------------------- Result 930 ---------------------------------------------
Add cc addresses . --> [[[FAILED]]]

[[[[Adv]]]]: public T cc ( final EmailAddress ... ccs ) { this . cc = ArraysUtil . join ( this . cc , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .

[[[[Adv]]]]: public T cc ( final EmailAddress ... ccs ) { this . cc = ArraysUtil . join ( this . cc , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .
--------------------------------------------- Result 931 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 505 / 415 / 11 / 931:  93%|█████████▎| 931/1000 [4:30:36<20:03, 17.44s/it][Succeeded / Failed / Skipped / Total] 505 / 415 / 11 / 931:  93%|█████████▎| 932/1000 [4:30:57<19:46, 17.44s/it][Succeeded / Failed / Skipped / Total] 506 / 415 / 11 / 932:  93%|█████████▎| 932/1000 [4:30:57<19:46, 17.44s/it][Succeeded / Failed / Skipped / Total] 506 / 415 / 11 / 932:  93%|█████████▎| 933/1000 [4:31:36<19:30, 17.47s/it][Succeeded / Failed / Skipped / Total] 507 / 415 / 11 / 933:  93%|█████████▎| 933/1000 [4:31:36<19:30, 17.47s/it][Succeeded / Failed / Skipped / Total] 507 / 415 / 11 / 933:  93%|█████████▎| 934/1000 [4:31:48<19:12, 17.46s/it][Succeeded / Failed / Skipped / Total] 508 / 415 / 11 / 934:  93%|█████████▎| 934/1000 [4:31:48<19:12, 17.46s/it][Succeeded / Failed / Skipped / Total] 508 / 415 / 11 / 934:  94%|█████████▎| 935/1000 [4:32:30<18:56, 17.49s/it][Succeeded / Failed / Skipped / Total] 509 / 415 / 11 / 935:  94%|█████████▎| 935/1000 [4:32:30<18:56, 17.49s/it][Succeeded / Failed / Skipped / Total] 509 / 415 / 11 / 935:  94%|█████████▎| 936/1000 [4:32:36<18:38, 17.48s/it][Succeeded / Failed / Skipped / Total] 509 / 416 / 11 / 936:  94%|█████████▎| 936/1000 [4:32:36<18:38, 17.48s/it][Succeeded / Failed / Skipped / Total] 509 / 416 / 11 / 936:  94%|█████████▎| 937/1000 [4:32:43<18:20, 17.46s/it][Succeeded / Failed / Skipped / Total] 510 / 416 / 11 / 937:  94%|█████████▎| 937/1000 [4:32:43<18:20, 17.46s/it][Succeeded / Failed / Skipped / Total] 510 / 416 / 11 / 937:  94%|█████████▍| 938/1000 [4:32:44<18:01, 17.45s/it][Succeeded / Failed / Skipped / Total] 511 / 416 / 11 / 938:  94%|█████████▍| 938/1000 [4:32:44<18:01, 17.45s/it][Succeeded / Failed / Skipped / Total] 511 / 416 / 11 / 938:  94%|█████████▍| 939/1000 [4:32:49<17:43, 17.43s/it][Succeeded / Failed / Skipped / Total] 512 / 416 / 11 / 939:  94%|█████████▍| 939/1000 [4:32:49<17:43, 17.43s/it][Succeeded / Failed / Skipped / Total] 512 / 416 / 11 / 939:  94%|█████████▍| 940/1000 [4:32:50<17:24, 17.42s/it]Strip the last camel word from the given name . --> Returns the rhod form of the given name . --> Socre: 1.0

[[[[Adv]]]]: public static String [[stripLastCamelWord]] ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
[[[[Nl]]]]: Removes last CamelWord

[[[[Adv]]]]: public static String [[rhod]] ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
[[[[Nl]]]]: Removes last CamelWord
--------------------------------------------- Result 932 ---------------------------------------------
Returns the long value of the named property or the defaultValue if the property is not set . --> convert arabians to yo --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLong]] ( final String [[name]] , final long [[defaultValue]] ) { String [[value]] = get ( [[name]] ) ; if ( [[value]] == null ) { return [[defaultValue]] ; } [[value]] = [[value]] . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( [[value]] ) ; } catch ( NumberFormatException nfex ) { return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as a long .

[[[[Adv]]]]: public static long [[converter]] ( final String [[arabians]] , final long [[yoυ]] ) { String [[prominence]] = get ( [[arabians]] ) ; if ( [[prominence]] == null ) { return [[yoυ]] ; } [[prominence]] = [[prominence]] . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( [[prominence]] ) ; } catch ( NumberFormatException nfex ) { return [[yoυ]] ; } }
[[[[Nl]]]]: Returns system property as a long .
--------------------------------------------- Result 933 ---------------------------------------------
Resolves the schema name for the given type . --> Returns the saban for the given class and broncos --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveSchemaName]] ( final Class < ? > [[type]] , final String [[defaultSchemaName]] ) { String schemaName = null ; final DbTable [[dbTable]] = [[type]] . getAnnotation ( DbTable . class ) ; if ( [[dbTable]] != null ) { schemaName = [[dbTable]] . schema ( ) . trim ( ) ; } if ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) { schemaName = [[defaultSchemaName]] ; } return schemaName ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .

[[[[Adv]]]]: public static String [[saban]] ( final Class < ? > [[mec]] , final String [[broncos]] ) { String schemaName = null ; final DbTable [[colombiana]] = [[mec]] . getAnnotation ( DbTable . class ) ; if ( [[colombiana]] != null ) { schemaName = [[colombiana]] . schema ( ) . trim ( ) ; } if ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) { schemaName = [[broncos]] ; } return schemaName ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .
--------------------------------------------- Result 934 ---------------------------------------------
Initializes the cache with the given key and tweaks . --> LURU - larus - larus --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final long [ ] key , final long [ ] tweak ) { final int [[newNw]] = key . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .

[[[[Adv]]]]: public void [[larus]] ( final long [ ] key , final long [ ] tweak ) { final int [[hortense]] = key . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .
--------------------------------------------- Result 935 ---------------------------------------------
Mix a vector by a given depth . --> Combo for a given richardson and d --> Socre: 1.0

[[[[Adv]]]]: private void [[mix]] ( final int [[j]] , final int d ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ d % DEPTH_OF_D_IN_R ] [ [[j]] ] ;
[[[[Nl]]]]: Implementation of the MIX function .

[[[[Adv]]]]: private void [[combo]] ( final int [[richardson]] , final int d ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ d % DEPTH_OF_D_IN_R ] [ [[richardson]] ] ;
[[[[Nl]]]]: Implementation of the MIX function .
--------------------------------------------- Result 936 ---------------------------------------------
Looks up the path for the given alias . --> [[[FAILED]]]

[[[[Adv]]]]: protected String lookupAlias ( final String alias ) { String value = actionsManager . lookupPathAlias ( alias ) ; if ( value == null ) { ActionRuntime cfg = actionsManager . lookup ( alias ) ; if ( cfg != null ) { value = cfg . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .

[[[[Adv]]]]: protected String lookupAlias ( final String alias ) { String value = actionsManager . lookupPathAlias ( alias ) ; if ( value == null ) { ActionRuntime cfg = actionsManager . lookup ( alias ) ; if ( cfg != null ) { value = cfg . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .
--------------------------------------------- Result 937 ---------------------------------------------
Key schedule . --> wish for avec --> Socre: 1.0

[[[[Adv]]]]: private void [[keySchedule]] ( final int [[s]] ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .

[[[[Adv]]]]: private void [[wish]] ( final int [[avec]] ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .
--------------------------------------------- Result 938 ---------------------------------------------
Initialize with the given key message and tweaks . --> Initialize with the given key message and spendthrift and tweak --> Socre: 1.0

[[[[Adv]]]]: public void init ( final String keyMessage , final long [[tweak1]] , final long tweak2 ) { long [ ] tweak = new long [ ] { [[tweak1]] , tweak2 } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; init ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .

[[[[Adv]]]]: public void init ( final String keyMessage , final long [[spendthrift]] , final long tweak2 ) { long [ ] tweak = new long [ ] { [[spendthrift]] , tweak2 } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; init ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .
--------------------------------------------- Result 939 ---------------------------------------------
Encrypts a block . --> Returns the mangalsutra for the given tenor and abort --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[encryptBlock]] ( final byte [ ] [[content]] , final int [[offset]] ) { long [ ] [[contentBlock]] = bytesToLongs ( [[content]] , [[offset]] , blockSizeInBytes ) ; long [ ] [[encryptedBlock]] = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( [[contentBlock]] , [[encryptedBlock]] ) ; return longsToBytes ( [[encryptedBlock]] ) ; }
[[[[Nl]]]]: Encrypts a block .

[[[[Adv]]]]: @ Override public byte [ ] [[mangalsutra]] ( final byte [ ] [[tenor]] , final int [[abort]] ) { long [ ] [[ministrations]] = bytesToLongs ( [[tenor]] , [[abort]] , blockSizeInBytes ) ; long [ ] [[wanting]] = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( [[ministrations]] , [[wanting]] ) ; return longsToBytes ( [[wanting]] ) ; }
[[[[Nl]]]]: Encrypts a block .
--------------------------------------------- Result 940 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 512 / 417 / 11 / 940:  94%|█████████▍| 940/1000 [4:32:50<17:24, 17.42s/it][Succeeded / Failed / Skipped / Total] 512 / 417 / 11 / 940:  94%|█████████▍| 941/1000 [4:32:55<17:06, 17.40s/it][Succeeded / Failed / Skipped / Total] 513 / 417 / 11 / 941:  94%|█████████▍| 941/1000 [4:32:55<17:06, 17.40s/it][Succeeded / Failed / Skipped / Total] 513 / 417 / 11 / 941:  94%|█████████▍| 942/1000 [4:32:58<16:48, 17.39s/it][Succeeded / Failed / Skipped / Total] 514 / 417 / 11 / 942:  94%|█████████▍| 942/1000 [4:32:58<16:48, 17.39s/it][Succeeded / Failed / Skipped / Total] 514 / 417 / 11 / 942:  94%|█████████▍| 943/1000 [4:33:47<16:32, 17.42s/it][Succeeded / Failed / Skipped / Total] 515 / 417 / 11 / 943:  94%|█████████▍| 943/1000 [4:33:47<16:32, 17.42s/it][Succeeded / Failed / Skipped / Total] 515 / 417 / 11 / 943:  94%|█████████▍| 944/1000 [4:33:56<16:15, 17.41s/it][Succeeded / Failed / Skipped / Total] 516 / 417 / 11 / 944:  94%|█████████▍| 944/1000 [4:33:56<16:15, 17.41s/it][Succeeded / Failed / Skipped / Total] 516 / 417 / 11 / 944:  94%|█████████▍| 945/1000 [4:34:02<15:56, 17.40s/it][Succeeded / Failed / Skipped / Total] 517 / 417 / 11 / 945:  94%|█████████▍| 945/1000 [4:34:02<15:56, 17.40s/it][Succeeded / Failed / Skipped / Total] 517 / 417 / 11 / 945:  95%|█████████▍| 946/1000 [4:34:15<15:39, 17.39s/it][Succeeded / Failed / Skipped / Total] 518 / 417 / 11 / 946:  95%|█████████▍| 946/1000 [4:34:15<15:39, 17.39s/it][Succeeded / Failed / Skipped / Total] 518 / 417 / 11 / 946:  95%|█████████▍| 947/1000 [4:34:16<15:20, 17.38s/it]Resolve alias . --> [[[FAILED]]]

[[[[Adv]]]]: protected String resolveAlias ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int len = value . length ( ) ; while ( i < len ) { int ndx = value . indexOf ( ' ' , i ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .

[[[[Adv]]]]: protected String resolveAlias ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int len = value . length ( ) ; while ( i < len ) { int ndx = value . indexOf ( ' ' , i ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .
--------------------------------------------- Result 941 ---------------------------------------------
Converts a byte array into an array of longs . --> applebaum - applebaum - applebaum - applebaum - applebaum --> Socre: 1.0

[[[[Adv]]]]: protected static long [ ] [[bytesToLongs]] ( final byte [ ] ba , final int offset , final int [[size]] ) { long [ ] [[result]] = new long [ [[size]] >> 3 ] ; int i8 = offset ; for ( int i = 0 ; i < [[result]] . length ; i ++ ) { [[result]] [ i ] = Bits . getLong ( ba , i8 ) ; i8 += 8 ; } return [[result]] ; }
[[[[Nl]]]]: Converts segment of byte array into long array .

[[[[Adv]]]]: protected static long [ ] [[applebaum]] ( final byte [ ] ba , final int offset , final int [[intensity]] ) { long [ ] [[fruit]] = new long [ [[intensity]] >> 3 ] ; int i8 = offset ; for ( int i = 0 ; i < [[fruit]] . length ; i ++ ) { [[fruit]] [ i ] = Bits . getLong ( ba , i8 ) ; i8 += 8 ; } return [[fruit]] ; }
[[[[Nl]]]]: Converts segment of byte array into long array .
--------------------------------------------- Result 942 ---------------------------------------------
Performs a demix for a given depth . --> Performs stallions for a given kiyoshi --> Socre: 1.0

[[[[Adv]]]]: private void [[demix]] ( final int [[j]] , final int [[d]] ) { y [ 1 ] ^= y [ 0 ] ; final long rotr = r [ [[d]] % DEPTH_OF_D_IN_R ] [ [[j]] ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .

[[[[Adv]]]]: private void [[stallions]] ( final int [[kiyoshi]] , final int [[the]] ) { y [ 1 ] ^= y [ 0 ] ; final long rotr = r [ [[the]] % DEPTH_OF_D_IN_R ] [ [[kiyoshi]] ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .
--------------------------------------------- Result 943 ---------------------------------------------
Resolves the column descriptors for the given property . --> chise a DbEntityColumnDescriptor --> Socre: 1.0

[[[[Adv]]]]: public static DbEntityColumnDescriptor [[resolveColumnDescriptors]] ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean [[isAnnotated]] , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > [[sqlTypeClass]] = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .

[[[[Adv]]]]: public static DbEntityColumnDescriptor [[chise]] ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean [[knowed]] , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > [[dover]] = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .
--------------------------------------------- Result 944 ---------------------------------------------
Gzips a file . --> Gzips the given depots --> Socre: 1.0

[[[[Adv]]]]: public static File gzip ( final File [[file]] ) throws IOException { if ( [[file]] . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( [[file]] ) ; String [[gzipName]] = [[file]] . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( [[gzipName]] ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( [[gzipName]] ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .

[[[[Adv]]]]: public static File gzip ( final File [[depots]] ) throws IOException { if ( [[depots]] . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( [[depots]] ) ; String [[mene]] = [[depots]] . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( [[mene]] ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( [[mene]] ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .
--------------------------------------------- Result 945 ---------------------------------------------
Ungzips a file . --> Create a rudyard file from a gzipped file --> Socre: 1.0

[[[[Adv]]]]: public static File [[ungzip]] ( final File [[file]] ) throws IOException { String [[outFileName]] = FileNameUtil . removeExtension ( [[file]] . getAbsolutePath ( ) ) ; File [[out]] = new File ( [[outFileName]] ) ; [[out]] . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( [[out]] ) ; GZIPInputStream [[gzis]] = new GZIPInputStream ( new FileInputStream ( [[file]] ) ) ; try { StreamUtil . copy ( [[gzis]] , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( [[gzis]] ) ; } return [[out]] ; }
[[[[Nl]]]]: Decompress gzip archive .

[[[[Adv]]]]: public static File [[rudyard]] ( final File [[depositing]] ) throws IOException { String [[instep]] = FileNameUtil . removeExtension ( [[depositing]] . getAbsolutePath ( ) ) ; File [[foreign]] = new File ( [[instep]] ) ; [[foreign]] . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( [[foreign]] ) ; GZIPInputStream [[pretty]] = new GZIPInputStream ( new FileInputStream ( [[depositing]] ) ) ; try { StreamUtil . copy ( [[pretty]] , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( [[pretty]] ) ; } return [[foreign]] ; }
[[[[Nl]]]]: Decompress gzip archive .
--------------------------------------------- Result 946 ---------------------------------------------
Create a zlib file for the given file --> Returns the zipped version of apostle --> Socre: 1.0

[[[[Adv]]]]: public static File [[zlib]] ( final File [[file]] ) throws IOException { if ( [[file]] . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( [[file]] ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String [[zlibFileName]] = [[file]] . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream [[dos]] = new DeflaterOutputStream ( new FileOutputStream ( [[zlibFileName]] ) , deflater ) ; try { StreamUtil . copy ( fis , [[dos]] ) ; } finally { StreamUtil . close ( [[dos]] ) ; StreamUtil . close ( fis ) ; } return new File ( [[zlibFileName]] ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .

[[[[Adv]]]]: public static File [[apostle]] ( final File [[folder]] ) throws IOException { if ( [[folder]] . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( [[folder]] ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String [[barlow]] = [[folder]] . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream [[three]] = new DeflaterOutputStream ( new FileOutputStream ( [[barlow]] ) , deflater ) ; try { StreamUtil . copy ( fis , [[three]] ) ; } finally { StreamUtil . close ( [[three]] ) ; StreamUtil . close ( fis ) ; } return new File ( [[barlow]] ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .
[Succeeded / Failed / Skipped / Total] 518 / 418 / 11 / 947:  95%|█████████▍| 947/1000 [4:34:16<15:20, 17.38s/it][Succeeded / Failed / Skipped / Total] 518 / 418 / 11 / 947:  95%|█████████▍| 948/1000 [4:34:29<15:03, 17.37s/it][Succeeded / Failed / Skipped / Total] 519 / 418 / 11 / 948:  95%|█████████▍| 948/1000 [4:34:29<15:03, 17.37s/it][Succeeded / Failed / Skipped / Total] 519 / 418 / 11 / 948:  95%|█████████▍| 949/1000 [4:34:30<14:45, 17.36s/it][Succeeded / Failed / Skipped / Total] 519 / 419 / 11 / 949:  95%|█████████▍| 949/1000 [4:34:30<14:45, 17.36s/it][Succeeded / Failed / Skipped / Total] 519 / 419 / 11 / 949:  95%|█████████▌| 950/1000 [4:34:33<14:27, 17.34s/it][Succeeded / Failed / Skipped / Total] 520 / 419 / 11 / 950:  95%|█████████▌| 950/1000 [4:34:33<14:27, 17.34s/it][Succeeded / Failed / Skipped / Total] 520 / 419 / 11 / 950:  95%|█████████▌| 951/1000 [4:34:33<14:08, 17.32s/it][Succeeded / Failed / Skipped / Total] 520 / 420 / 11 / 951:  95%|█████████▌| 951/1000 [4:34:33<14:08, 17.32s/it][Succeeded / Failed / Skipped / Total] 520 / 420 / 11 / 951:  95%|█████████▌| 952/1000 [4:34:37<13:50, 17.31s/it][Succeeded / Failed / Skipped / Total] 521 / 420 / 11 / 952:  95%|█████████▌| 952/1000 [4:34:37<13:50, 17.31s/it][Succeeded / Failed / Skipped / Total] 521 / 420 / 11 / 952:  95%|█████████▌| 953/1000 [4:34:46<13:33, 17.30s/it][Succeeded / Failed / Skipped / Total] 522 / 420 / 11 / 953:  95%|█████████▌| 953/1000 [4:34:46<13:33, 17.30s/it][Succeeded / Failed / Skipped / Total] 522 / 420 / 11 / 953:  95%|█████████▌| 954/1000 [4:35:09<13:16, 17.31s/it][Succeeded / Failed / Skipped / Total] 522 / 421 / 11 / 954:  95%|█████████▌| 954/1000 [4:35:09<13:16, 17.31s/it][Succeeded / Failed / Skipped / Total] 522 / 421 / 11 / 954:  96%|█████████▌| 955/1000 [4:35:41<12:59, 17.32s/it]--------------------------------------------- Result 947 ---------------------------------------------
Returns the last index of a slash or dot in a string . --> [[[FAILED]]]

[[[[Adv]]]]: public static int lastIndexOfSlashDot ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; int dotNdx = StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; if ( dotNdx == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < str . length ( ) - 1 ) { dotNdx = slashNdx ; } else { dotNdx = - 1 ; } } return dotNdx ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .

[[[[Adv]]]]: public static int lastIndexOfSlashDot ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; int dotNdx = StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; if ( dotNdx == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < str . length ( ) - 1 ) { dotNdx = slashNdx ; } else { dotNdx = - 1 ; } } return dotNdx ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .
--------------------------------------------- Result 948 ---------------------------------------------
Adds a file to a ZIP output stream . --> Dehradun compress a file --> Socre: 1.0

[[[[Adv]]]]: public static void [[addToZip]] ( final ZipOutputStream zos , final File file , String path , final String comment , final boolean recursive ) throws IOException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . toString ( ) ) ; } if ( path == null ) { path = file . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean isDir = file . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .

[[[[Adv]]]]: public static void [[dehradun]] ( final ZipOutputStream zos , final File file , String path , final String comment , final boolean recursive ) throws IOException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . toString ( ) ) ; } if ( path == null ) { path = file . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean isDir = file . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .
--------------------------------------------- Result 949 ---------------------------------------------
Returns the index of the last dot after the slash . --> [[[FAILED]]]

[[[[Adv]]]]: public static int lastIndexOfDotAfterSlash ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .

[[[[Adv]]]]: public static int lastIndexOfDotAfterSlash ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .
--------------------------------------------- Result 950 ---------------------------------------------
Gets the field descriptor with the given name and declared flag . --> Get the FieldDescriptor for aka and whether it is declared or not --> Socre: 1.0

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String [[name]] , final boolean [[declared]] ) { final FieldDescriptor [[fieldDescriptor]] = getFields ( ) . getFieldDescriptor ( [[name]] ) ; if ( [[fieldDescriptor]] != null ) { if ( ! [[fieldDescriptor]] . matchDeclared ( [[declared]] ) ) { return null ; } } return [[fieldDescriptor]] ; }
[[[[Nl]]]]: Returns field descriptor .

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String [[aka]] , final boolean [[proclaim]] ) { final FieldDescriptor [[peacetime]] = getFields ( ) . getFieldDescriptor ( [[aka]] ) ; if ( [[peacetime]] != null ) { if ( ! [[peacetime]] . matchDeclared ( [[proclaim]] ) ) { return null ; } } return [[peacetime]] ; }
[[[[Nl]]]]: Returns field descriptor .
--------------------------------------------- Result 951 ---------------------------------------------
Returns the resolved parameters for this method . --> [[[FAILED]]]

[[[[Adv]]]]: MethodParameter [ ] getResolvedParameters ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .

[[[[Adv]]]]: MethodParameter [ ] getResolvedParameters ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .
--------------------------------------------- Result 952 ---------------------------------------------
Unzips a zip file to a destination directory . --> Unzip alleen tarsus --> Socre: 1.0

[[[[Adv]]]]: public static void unzip ( final String [[zipFile]] , final String [[destDir]] , final String ... [[patterns]] ) throws IOException { unzip ( new File ( [[zipFile]] ) , new File ( [[destDir]] ) , [[patterns]] ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .

[[[[Adv]]]]: public static void unzip ( final String [[alleen]] , final String [[tarsus]] , final String ... [[how]] ) throws IOException { unzip ( new File ( [[alleen]] ) , new File ( [[tarsus]] ) , [[how]] ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .
--------------------------------------------- Result 953 ---------------------------------------------
Removes any bounding characters from a string . --> redi - redi - redi --> Socre: 1.0

[[[[Adv]]]]: private static String [[removeAnyBounding]] ( final char [[s]] , final char e , final String [[str]] ) { if ( [[str]] == null || [[str]] . length ( ) < 2 ) { return [[str]] ; } if ( [[str]] . startsWith ( String . valueOf ( [[s]] ) ) && [[str]] . endsWith ( String . valueOf ( e ) ) ) { return [[str]] . substring ( 1 , [[str]] . length ( ) - 1 ) ; } return [[str]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .

[[[[Adv]]]]: private static String [[redi]] ( final char [[na]] , final char e , final String [[monogamous]] ) { if ( [[monogamous]] == null || [[monogamous]] . length ( ) < 2 ) { return [[monogamous]] ; } if ( [[monogamous]] . startsWith ( String . valueOf ( [[na]] ) ) && [[monogamous]] . endsWith ( String . valueOf ( e ) ) ) { return [[monogamous]] . substring ( 1 , [[monogamous]] . length ( ) - 1 ) ; } return [[monogamous]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .
--------------------------------------------- Result 954 ---------------------------------------------
Returns the index of the last dot after the slash . --> [[[FAILED]]]

[[[[Adv]]]]: public static int indexOfDotAfterSlash ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return str . indexOf ( ' ' , slashNdx ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .

[[[[Adv]]]]: public static int indexOfDotAfterSlash ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return str . indexOf ( ' ' , slashNdx ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .
--------------------------------------------- Result 955 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 523 / 421 / 11 / 955:  96%|█████████▌| 955/1000 [4:35:41<12:59, 17.32s/it][Succeeded / Failed / Skipped / Total] 523 / 421 / 11 / 955:  96%|█████████▌| 956/1000 [4:36:01<12:42, 17.32s/it][Succeeded / Failed / Skipped / Total] 524 / 421 / 11 / 956:  96%|█████████▌| 956/1000 [4:36:01<12:42, 17.32s/it][Succeeded / Failed / Skipped / Total] 524 / 421 / 11 / 956:  96%|█████████▌| 957/1000 [4:36:08<12:24, 17.31s/it][Succeeded / Failed / Skipped / Total] 525 / 421 / 11 / 957:  96%|█████████▌| 957/1000 [4:36:08<12:24, 17.31s/it][Succeeded / Failed / Skipped / Total] 525 / 421 / 11 / 957:  96%|█████████▌| 958/1000 [4:37:49<12:10, 17.40s/it][Succeeded / Failed / Skipped / Total] 526 / 421 / 11 / 958:  96%|█████████▌| 958/1000 [4:37:49<12:10, 17.40s/it][Succeeded / Failed / Skipped / Total] 526 / 421 / 11 / 958:  96%|█████████▌| 959/1000 [4:38:31<11:54, 17.43s/it][Succeeded / Failed / Skipped / Total] 526 / 422 / 11 / 959:  96%|█████████▌| 959/1000 [4:38:31<11:54, 17.43s/it][Succeeded / Failed / Skipped / Total] 526 / 422 / 11 / 959:  96%|█████████▌| 960/1000 [4:38:31<11:36, 17.41s/it][Succeeded / Failed / Skipped / Total] 526 / 423 / 11 / 960:  96%|█████████▌| 960/1000 [4:38:31<11:36, 17.41s/it][Succeeded / Failed / Skipped / Total] 526 / 423 / 11 / 960:  96%|█████████▌| 961/1000 [4:38:36<11:18, 17.39s/it][Succeeded / Failed / Skipped / Total] 526 / 424 / 11 / 961:  96%|█████████▌| 961/1000 [4:38:36<11:18, 17.39s/it][Succeeded / Failed / Skipped / Total] 526 / 424 / 11 / 961:  96%|█████████▌| 962/1000 [4:38:45<11:00, 17.39s/it]Returns the path of this link . --> Get track name and roughage --> Socre: 1.0

[[[[Adv]]]]: public String [[path]] ( ) { if ( methref != null ) { final String [[methodName]] = methref . ref ( ) ; return target . getName ( ) + ' ' + [[methodName]] ; } return [[path]] ; }
[[[[Nl]]]]: Returns path value .

[[[[Adv]]]]: public String [[tracks]] ( ) { if ( methref != null ) { final String [[roughage]] = methref . ref ( ) ; return target . getName ( ) + ' ' + [[roughage]] ; } return [[tracks]] ; }
[[[[Nl]]]]: Returns path value .
--------------------------------------------- Result 956 ---------------------------------------------
Lists all the entries in a zip file . --> Returns a list of intro entries for the given timid --> Socre: 1.0

[[[[Adv]]]]: public static List < String > [[listZip]] ( final File [[zipFile]] ) throws IOException { List < String > [[entries]] = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( [[zipFile]] ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; [[entries]] . add ( entryName ) ; } return Collections . unmodifiableList ( [[entries]] ) ; }
[[[[Nl]]]]: Lists zip content .

[[[[Adv]]]]: public static List < String > [[sleepwalk]] ( final File [[timid]] ) throws IOException { List < String > [[intro]] = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( [[timid]] ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; [[intro]] . add ( entryName ) ; } return Collections . unmodifiableList ( [[intro]] ) ; }
[[[[Nl]]]]: Lists zip content .
--------------------------------------------- Result 957 ---------------------------------------------
Filter parameters for the given bean name . --> gladden a square name --> Socre: 1.0

[[[[Adv]]]]: public String [ ] [[filterParametersForBeanName]] ( String [[beanName]] , final boolean resolveReferenceParams ) { [[beanName]] = [[beanName]] + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String [[key]] = entry . getKey ( ) ; if ( ! [[key]] . startsWith ( [[beanName]] ) ) { continue ; } list . add ( [[key]] ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .

[[[[Adv]]]]: public String [ ] [[gladden]] ( String [[square]] , final boolean resolveReferenceParams ) { [[square]] = [[square]] + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String [[notable]] = entry . getKey ( ) ; if ( ! [[notable]] . startsWith ( [[square]] ) ) { continue ; } list . add ( [[notable]] ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .
--------------------------------------------- Result 958 ---------------------------------------------
Reads the contents of an input stream into a byte array . --> grope an albrecht --> Socre: 1.0

[[[[Adv]]]]: private static byte [ ] [[readStream]] ( final InputStream [[inputStream]] , final boolean close ) throws IOException { if ( [[inputStream]] == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = [[inputStream]] . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , bytesRead ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( close ) { [[inputStream]] . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .

[[[[Adv]]]]: private static byte [ ] [[grope]] ( final InputStream [[albrecht]] , final boolean close ) throws IOException { if ( [[albrecht]] == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = [[albrecht]] . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , bytesRead ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( close ) { [[albrecht]] . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .
--------------------------------------------- Result 959 ---------------------------------------------
Sets the request bundle name . --> [[[FAILED]]]

[[[[Adv]]]]: public static void setRequestBundleName ( final ServletRequest request , final String bundleName ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + bundleName ) ; } request . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , bundleName ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .

[[[[Adv]]]]: public static void setRequestBundleName ( final ServletRequest request , final String bundleName ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + bundleName ) ; } request . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , bundleName ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .
--------------------------------------------- Result 960 ---------------------------------------------
Gets the locale from the session . --> [[[FAILED]]]

[[[[Adv]]]]: public static Locale getSessionLocale ( final HttpSession session ) { Locale locale = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return locale == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : locale ; }
[[[[Nl]]]]: Returns current locale from session . s

[[[[Adv]]]]: public static Locale getSessionLocale ( final HttpSession session ) { Locale locale = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return locale == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : locale ; }
[[[[Nl]]]]: Returns current locale from session . s
--------------------------------------------- Result 961 ---------------------------------------------
Sets the session locale . --> [[[FAILED]]]

[[[[Adv]]]]: public static void setSessionLocale ( final HttpSession session , final String localeCode ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + localeCode ) ; } Locale locale = Locale . forLanguageTag ( localeCode ) ; session . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .

[[[[Adv]]]]: public static void setSessionLocale ( final HttpSession session , final String localeCode ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + localeCode ) ; } Locale locale = Locale . forLanguageTag ( localeCode ) ; session . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .
--------------------------------------------- Result 962 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 527 / 424 / 11 / 962:  96%|█████████▌| 962/1000 [4:38:45<11:00, 17.39s/it][Succeeded / Failed / Skipped / Total] 527 / 424 / 11 / 962:  96%|█████████▋| 963/1000 [4:39:07<10:43, 17.39s/it][Succeeded / Failed / Skipped / Total] 528 / 424 / 11 / 963:  96%|█████████▋| 963/1000 [4:39:07<10:43, 17.39s/it][Succeeded / Failed / Skipped / Total] 528 / 424 / 11 / 963:  96%|█████████▋| 964/1000 [4:39:13<10:25, 17.38s/it][Succeeded / Failed / Skipped / Total] 528 / 425 / 11 / 964:  96%|█████████▋| 964/1000 [4:39:13<10:25, 17.38s/it][Succeeded / Failed / Skipped / Total] 528 / 425 / 11 / 964:  96%|█████████▋| 965/1000 [4:39:26<10:08, 17.37s/it][Succeeded / Failed / Skipped / Total] 528 / 426 / 11 / 965:  96%|█████████▋| 965/1000 [4:39:26<10:08, 17.37s/it][Succeeded / Failed / Skipped / Total] 528 / 426 / 11 / 965:  97%|█████████▋| 966/1000 [4:39:49<09:50, 17.38s/it][Succeeded / Failed / Skipped / Total] 528 / 427 / 11 / 966:  97%|█████████▋| 966/1000 [4:39:49<09:50, 17.38s/it][Succeeded / Failed / Skipped / Total] 528 / 427 / 11 / 966:  97%|█████████▋| 967/1000 [4:40:08<09:33, 17.38s/it][Succeeded / Failed / Skipped / Total] 529 / 427 / 11 / 967:  97%|█████████▋| 967/1000 [4:40:08<09:33, 17.38s/it][Succeeded / Failed / Skipped / Total] 529 / 427 / 11 / 967:  97%|█████████▋| 968/1000 [4:40:21<09:16, 17.38s/it]Read element values . --> schlosser = wit ; --> Socre: 1.0

[[[[Adv]]]]: private int [[readElementValues]] ( final AnnotationVisitor annotationVisitor , final int [[annotationOffset]] , final boolean named , final char [ ] charBuffer ) { int [[currentOffset]] = [[annotationOffset]] ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .

[[[[Adv]]]]: private int [[revenge]] ( final AnnotationVisitor annotationVisitor , final int [[wit]] , final boolean named , final char [ ] charBuffer ) { int [[schlosser]] = [[wit]] ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .
--------------------------------------------- Result 963 ---------------------------------------------
Read bootstrap methods attribute . --> Rendezvous hostesses = null ; --> Socre: 1.0

[[[[Adv]]]]: private int [ ] [[readBootstrapMethodsAttribute]] ( final int maxStringLength ) { char [ ] [[charBuffer]] = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] [[currentBootstrapMethodOffsets]] = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .

[[[[Adv]]]]: private int [ ] [[rendition]] ( final int maxStringLength ) { char [ ] [[hostesses]] = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] [[idlewild]] = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .
--------------------------------------------- Result 964 ---------------------------------------------
Adds a list of profiles to the properties . --> [[[FAILED]]]

[[[[Adv]]]]: public PropsEntries profile ( final String ... profiles ) { if ( profiles == null ) { return this ; } for ( String profile : profiles ) { addProfiles ( profile ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .

[[[[Adv]]]]: public PropsEntries profile ( final String ... profiles ) { if ( profiles == null ) { return this ; } for ( String profile : profiles ) { addProfiles ( profile ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .
--------------------------------------------- Result 965 ---------------------------------------------
Returns the property descriptor with the given name and whether it is declared or not . --> [[[FAILED]]]

[[[[Adv]]]]: public PropertyDescriptor getPropertyDescriptor ( final String name , final boolean declared ) { PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( name ) ; if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( declared ) ) { return propertyDescriptor ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .

[[[[Adv]]]]: public PropertyDescriptor getPropertyDescriptor ( final String name , final boolean declared ) { PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( name ) ; if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( declared ) ) { return propertyDescriptor ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .
--------------------------------------------- Result 966 ---------------------------------------------
Adds content to a ZIP output stream . --> [[[FAILED]]]

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String path , final String comment ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , ' ' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { zipEntry . setComment ( comment ) ; } zos . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String path , final String comment ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , ' ' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { zipEntry . setComment ( comment ) ; } zos . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .
--------------------------------------------- Result 967 ---------------------------------------------
Reads the verification type information from the bytecode . --> NIVEAU - NIVEAU --> Socre: 1.0

[[[[Adv]]]]: private int [[readVerificationTypeInfo]] ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { int currentOffset = verificationTypeInfoOffset ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .

[[[[Adv]]]]: private int [[niveau]] ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { int currentOffset = verificationTypeInfoOffset ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .
[Succeeded / Failed / Skipped / Total] 530 / 427 / 11 / 968:  97%|█████████▋| 968/1000 [4:40:22<09:16, 17.38s/it][Succeeded / Failed / Skipped / Total] 530 / 427 / 11 / 968:  97%|█████████▋| 969/1000 [4:40:24<08:58, 17.36s/it][Succeeded / Failed / Skipped / Total] 531 / 427 / 11 / 969:  97%|█████████▋| 969/1000 [4:40:24<08:58, 17.36s/it][Succeeded / Failed / Skipped / Total] 531 / 427 / 11 / 969:  97%|█████████▋| 970/1000 [4:40:27<08:40, 17.35s/it][Succeeded / Failed / Skipped / Total] 532 / 427 / 11 / 970:  97%|█████████▋| 970/1000 [4:40:27<08:40, 17.35s/it][Succeeded / Failed / Skipped / Total] 532 / 427 / 11 / 970:  97%|█████████▋| 971/1000 [4:41:59<08:25, 17.42s/it][Succeeded / Failed / Skipped / Total] 533 / 427 / 11 / 971:  97%|█████████▋| 971/1000 [4:41:59<08:25, 17.42s/it][Succeeded / Failed / Skipped / Total] 533 / 427 / 11 / 971:  97%|█████████▋| 972/1000 [4:42:00<08:07, 17.41s/it][Succeeded / Failed / Skipped / Total] 533 / 428 / 11 / 972:  97%|█████████▋| 972/1000 [4:42:00<08:07, 17.41s/it][Succeeded / Failed / Skipped / Total] 533 / 428 / 11 / 972:  97%|█████████▋| 973/1000 [4:42:45<07:50, 17.44s/it][Succeeded / Failed / Skipped / Total] 533 / 429 / 11 / 973:  97%|█████████▋| 973/1000 [4:42:45<07:50, 17.44s/it][Succeeded / Failed / Skipped / Total] 533 / 429 / 11 / 973:  97%|█████████▋| 974/1000 [4:42:53<07:33, 17.43s/it][Succeeded / Failed / Skipped / Total] 534 / 429 / 11 / 974:  97%|█████████▋| 974/1000 [4:42:53<07:33, 17.43s/it][Succeeded / Failed / Skipped / Total] 534 / 429 / 11 / 974:  98%|█████████▊| 975/1000 [4:43:51<07:16, 17.47s/it][Succeeded / Failed / Skipped / Total] 535 / 429 / 11 / 975:  98%|█████████▊| 975/1000 [4:43:51<07:16, 17.47s/it][Succeeded / Failed / Skipped / Total] 535 / 429 / 11 / 975:  98%|█████████▊| 976/1000 [4:43:51<06:58, 17.45s/it]--------------------------------------------- Result 968 ---------------------------------------------
Read a long in little - endian format from the given buffer . --> Returns the boodle value of the first 8 bytes of the prix --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLongLittleEndian]] ( final byte [ ] [[buf]] , final int [[offset]] ) { return ( ( long ) [[buf]] [ [[offset]] + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .

[[[[Adv]]]]: public static long [[boodle]] ( final byte [ ] [[prix]] , final int [[cleared]] ) { return ( ( long ) [[prix]] [ [[cleared]] + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .
--------------------------------------------- Result 969 ---------------------------------------------
Initializes this filter . --> This method remembers the current state of the servlet --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[init]] ( final FilterConfig [[filterConfig]] ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .

[[[[Adv]]]]: @ Override public void [[rememberthe]] ( final FilterConfig [[ather]] ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .
--------------------------------------------- Result 970 ---------------------------------------------
Add a file consumer to the chain of consumers . --> Add a growler to the list of consumers . --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[onFile]] ( final Consumer < File > fileConsumer ) { if ( consumers == null ) { consumers = Consumers . of ( fileConsumer ) ; } else { consumers . add ( fileConsumer ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer

[[[[Adv]]]]: public FindFile [[growler]] ( final Consumer < File > fileConsumer ) { if ( consumers == null ) { consumers = Consumers . of ( fileConsumer ) ; } else { consumers . add ( fileConsumer ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer
--------------------------------------------- Result 971 ---------------------------------------------
Returns the constructor descriptor for the given constructor arguments . --> Returns the ctor descriptor for the fujiyama constructors --> Socre: 1.0

[[[[Adv]]]]: public CtorDescriptor getCtorDescriptor ( final Class ... [[args]] ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] [[arg]] = ctorDescriptor . getParameters ( ) ; if ( [[arg]] . length != [[args]] . length ) { continue ; } for ( int j = 0 ; j < [[arg]] . length ; j ++ ) { if ( [[arg]] [ j ] != [[args]] [ j ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .

[[[[Adv]]]]: public CtorDescriptor getCtorDescriptor ( final Class ... [[fujiyama]] ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] [[wanderings]] = ctorDescriptor . getParameters ( ) ; if ( [[wanderings]] . length != [[fujiyama]] . length ) { continue ; } for ( int j = 0 ; j < [[wanderings]] . length ; j ++ ) { if ( [[wanderings]] [ j ] != [[fujiyama]] [ j ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .
--------------------------------------------- Result 972 ---------------------------------------------
Reads a label from a bytecode . --> [[[FAILED]]]

[[[[Adv]]]]: protected Label readLabel ( final int bytecodeOffset , final Label [ ] labels ) { if ( labels [ bytecodeOffset ] == null ) { labels [ bytecodeOffset ] = new Label ( ) ; } return labels [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .

[[[[Adv]]]]: protected Label readLabel ( final int bytecodeOffset , final Label [ ] labels ) { if ( labels [ bytecodeOffset ] == null ) { labels [ bytecodeOffset ] = new Label ( ) ; } return labels [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .
--------------------------------------------- Result 973 ---------------------------------------------
Returns the bytecode offset of a type annotation . --> [[[FAILED]]]

[[[[Adv]]]]: private int getTypeAnnotationBytecodeOffset ( final int [ ] typeAnnotationOffsets , final int typeAnnotationIndex ) { if ( typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( typeAnnotationOffsets [ typeAnnotationIndex ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .

[[[[Adv]]]]: private int getTypeAnnotationBytecodeOffset ( final int [ ] typeAnnotationOffsets , final int typeAnnotationIndex ) { if ( typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( typeAnnotationOffsets [ typeAnnotationIndex ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .
--------------------------------------------- Result 974 ---------------------------------------------
Adds a file to the list of files that match the given URI . --> deposit a tumour to this FindFile --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URI [[searchPath]] ) { File [[file]] ; try { [[file]] = new File ( [[searchPath]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[searchPath]] , ex ) ; } addPath ( [[file]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .

[[[[Adv]]]]: public FindFile [[treading]] ( final URI [[tumour]] ) { File [[deposited]] ; try { [[deposited]] = new File ( [[treading]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[treading]] , ex ) ; } addPath ( [[deposited]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .
--------------------------------------------- Result 975 ---------------------------------------------
Adds a file to the list of files to be searched for . --> 的 --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URL searchPath ) { File [[file]] = FileUtil . toContainerFile ( [[searchPath]] ) ; if ( [[file]] == null ) { throw new FindFileException ( "URL error: " + [[searchPath]] ) ; } addPath ( [[file]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .

[[[[Adv]]]]: public FindFile [[õ]] ( final URL searchPath ) { File [[recordings]] = FileUtil . toContainerFile ( [[õ]] ) ; if ( [[recordings]] == null ) { throw new FindFileException ( "URL error: " + [[õ]] ) ; } addPath ( [[recordings]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .
--------------------------------------------- Result 976 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 535 / 430 / 11 / 976:  98%|█████████▊| 976/1000 [4:43:51<06:58, 17.45s/it][Succeeded / Failed / Skipped / Total] 535 / 430 / 11 / 976:  98%|█████████▊| 977/1000 [4:44:04<06:41, 17.45s/it][Succeeded / Failed / Skipped / Total] 535 / 431 / 11 / 977:  98%|█████████▊| 977/1000 [4:44:04<06:41, 17.45s/it][Succeeded / Failed / Skipped / Total] 535 / 431 / 11 / 977:  98%|█████████▊| 978/1000 [4:44:08<06:23, 17.43s/it][Succeeded / Failed / Skipped / Total] 536 / 431 / 11 / 978:  98%|█████████▊| 978/1000 [4:44:08<06:23, 17.43s/it][Succeeded / Failed / Skipped / Total] 536 / 431 / 11 / 978:  98%|█████████▊| 979/1000 [4:44:10<06:05, 17.42s/it][Succeeded / Failed / Skipped / Total] 536 / 432 / 11 / 979:  98%|█████████▊| 979/1000 [4:44:10<06:05, 17.42s/it][Succeeded / Failed / Skipped / Total] 536 / 432 / 11 / 979:  98%|█████████▊| 980/1000 [4:44:15<05:48, 17.40s/it][Succeeded / Failed / Skipped / Total] 536 / 433 / 11 / 980:  98%|█████████▊| 980/1000 [4:44:15<05:48, 17.40s/it][Succeeded / Failed / Skipped / Total] 536 / 433 / 11 / 980:  98%|█████████▊| 981/1000 [4:45:44<05:32, 17.48s/it][Succeeded / Failed / Skipped / Total] 536 / 434 / 11 / 981:  98%|█████████▊| 981/1000 [4:45:44<05:32, 17.48s/it][Succeeded / Failed / Skipped / Total] 536 / 434 / 11 / 981:  98%|█████████▊| 982/1000 [4:46:32<05:15, 17.51s/it][Succeeded / Failed / Skipped / Total] 536 / 435 / 11 / 982:  98%|█████████▊| 982/1000 [4:46:32<05:15, 17.51s/it][Succeeded / Failed / Skipped / Total] 536 / 435 / 11 / 982:  98%|█████████▊| 983/1000 [4:47:14<04:58, 17.53s/it][Succeeded / Failed / Skipped / Total] 536 / 436 / 11 / 983:  98%|█████████▊| 983/1000 [4:47:14<04:58, 17.53s/it][Succeeded / Failed / Skipped / Total] 536 / 436 / 11 / 983:  98%|█████████▊| 984/1000 [4:48:05<04:41, 17.57s/it]Gets the request map . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > getRequestMap ( final HttpServletRequest servletRequest ) { return ( Map < String , TransientBeanData > ) servletRequest . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > getRequestMap ( final HttpServletRequest servletRequest ) { return ( Map < String , TransientBeanData > ) servletRequest . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .
--------------------------------------------- Result 977 ---------------------------------------------
Create the request map . --> [[[FAILED]]]

[[[[Adv]]]]: protected Map < String , TransientBeanData > createRequestMap ( final HttpServletRequest servletRequest ) { Map < String , TransientBeanData > map = new HashMap <> ( ) ; servletRequest . setAttribute ( ATTR_NAME , map ) ; return map ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .

[[[[Adv]]]]: protected Map < String , TransientBeanData > createRequestMap ( final HttpServletRequest servletRequest ) { Map < String , TransientBeanData > map = new HashMap <> ( ) ; servletRequest . setAttribute ( ATTR_NAME , map ) ; return map ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .
--------------------------------------------- Result 978 ---------------------------------------------
Initializes the internal data structures . --> calvados is used to detect mode --> Socre: 1.0

[[[[Adv]]]]: protected void [[init]] ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int index = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { files [ index ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( index != 0 ) { FilesIterator filesIterator = new FilesIterator ( files ) ; todoFiles . add ( filesIterator ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .

[[[[Adv]]]]: protected void [[calvados]] ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int index = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { files [ index ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( index != 0 ) { FilesIterator filesIterator = new FilesIterator ( files ) ; todoFiles . add ( filesIterator ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .
--------------------------------------------- Result 979 ---------------------------------------------
Convert array to array . --> [[[FAILED]]]

[[[[Adv]]]]: protected long [ ] convertArrayToArray ( final Object value ) { final Class valueComponentType = value . getClass ( ) . getComponentType ( ) ; final long [ ] result ; if ( valueComponentType . isPrimitive ( ) ) { result = convertPrimitiveArrayToArray ( value , valueComponentType ) ; } else {
[[[[Nl]]]]: Converts array value to array .

[[[[Adv]]]]: protected long [ ] convertArrayToArray ( final Object value ) { final Class valueComponentType = value . getClass ( ) . getComponentType ( ) ; final long [ ] result ; if ( valueComponentType . isPrimitive ( ) ) { result = convertPrimitiveArrayToArray ( value , valueComponentType ) ; } else {
[[[[Nl]]]]: Converts array value to array .
--------------------------------------------- Result 980 ---------------------------------------------
Inspect constructors of this class . --> [[[FAILED]]]

[[[[Adv]]]]: protected CtorDescriptor [ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor ctor = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; allCtors [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .

[[[[Adv]]]]: protected CtorDescriptor [ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor ctor = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; allCtors [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .
--------------------------------------------- Result 981 ---------------------------------------------
Adds the given patterns to the find file . --> [[[FAILED]]]

[[[[Adv]]]]: public FindFile include ( final String ... patterns ) { for ( String pattern : patterns ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .

[[[[Adv]]]]: public FindFile include ( final String ... patterns ) { for ( String pattern : patterns ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .
--------------------------------------------- Result 982 ---------------------------------------------
Exclude a set of files from being found . --> [[[FAILED]]]

[[[[Adv]]]]: public FindFile exclude ( final String ... patterns ) { for ( String pattern : patterns ) { rules . exclude ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .

[[[[Adv]]]]: public FindFile exclude ( final String ... patterns ) { for ( String pattern : patterns ) { rules . exclude ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .
--------------------------------------------- Result 983 ---------------------------------------------
Adds a path to the path list . --> [[[FAILED]]]

[[[[Adv]]]]: protected void addPath ( final File path ) { if ( ! path . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( path ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .

[[[[Adv]]]]: protected void addPath ( final File path ) { if ( ! path . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( path ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .
--------------------------------------------- Result 984 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 536 / 437 / 11 / 984:  98%|█████████▊| 984/1000 [4:48:05<04:41, 17.57s/it][Succeeded / Failed / Skipped / Total] 536 / 437 / 11 / 984:  98%|█████████▊| 985/1000 [4:48:12<04:23, 17.56s/it][Succeeded / Failed / Skipped / Total] 536 / 438 / 11 / 985:  98%|█████████▊| 985/1000 [4:48:12<04:23, 17.56s/it][Succeeded / Failed / Skipped / Total] 536 / 438 / 11 / 985:  99%|█████████▊| 986/1000 [4:48:18<04:05, 17.54s/it][Succeeded / Failed / Skipped / Total] 536 / 439 / 11 / 986:  99%|█████████▊| 986/1000 [4:48:18<04:05, 17.54s/it][Succeeded / Failed / Skipped / Total] 536 / 439 / 11 / 986:  99%|█████████▊| 987/1000 [4:50:12<03:49, 17.64s/it][Succeeded / Failed / Skipped / Total] 537 / 439 / 11 / 987:  99%|█████████▊| 987/1000 [4:50:12<03:49, 17.64s/it][Succeeded / Failed / Skipped / Total] 537 / 439 / 11 / 987:  99%|█████████▉| 988/1000 [4:50:42<03:31, 17.65s/it][Succeeded / Failed / Skipped / Total] 537 / 440 / 11 / 988:  99%|█████████▉| 988/1000 [4:50:42<03:31, 17.65s/it][Succeeded / Failed / Skipped / Total] 537 / 440 / 11 / 988:  99%|█████████▉| 989/1000 [4:50:53<03:14, 17.65s/it][Succeeded / Failed / Skipped / Total] 538 / 440 / 11 / 989:  99%|█████████▉| 989/1000 [4:50:53<03:14, 17.65s/it][Succeeded / Failed / Skipped / Total] 538 / 440 / 11 / 989:  99%|█████████▉| 990/1000 [4:51:23<02:56, 17.66s/it][Succeeded / Failed / Skipped / Total] 538 / 441 / 11 / 990:  99%|█████████▉| 990/1000 [4:51:23<02:56, 17.66s/it][Succeeded / Failed / Skipped / Total] 538 / 441 / 11 / 990:  99%|█████████▉| 991/1000 [4:52:11<02:39, 17.69s/it]Resolves the wiring mode of a bean . --> [[[FAILED]]]

[[[[Adv]]]]: public WiringMode resolveBeanWiringMode ( final Class type ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; return petiteBean != null ? petiteBean . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .

[[[[Adv]]]]: public WiringMode resolveBeanWiringMode ( final Class type ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; return petiteBean != null ? petiteBean . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .
--------------------------------------------- Result 985 ---------------------------------------------
Returns a list of all files in the archive . --> [[[FAILED]]]

[[[[Adv]]]]: public List < File > findAll ( ) { List < File > allFiles = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { allFiles . add ( file ) ; } return allFiles ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .

[[[[Adv]]]]: public List < File > findAll ( ) { List < File > allFiles = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { allFiles . add ( file ) ; } return allFiles ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .
--------------------------------------------- Result 986 ---------------------------------------------
Resolve bean name . --> [[[FAILED]]]

[[[[Adv]]]]: public String resolveBeanName ( final Class type , final boolean useLongTypeName ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; String name = null ; if ( petiteBean != null ) { name = petiteBean . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == 0 ) ) { if ( useLongTypeName ) { name = type . getName ( ) ; } else { name = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; } } return name ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .

[[[[Adv]]]]: public String resolveBeanName ( final Class type , final boolean useLongTypeName ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; String name = null ; if ( petiteBean != null ) { name = petiteBean . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == 0 ) ) { if ( useLongTypeName ) { name = type . getName ( ) ; } else { name = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; } } return name ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .
--------------------------------------------- Result 987 ---------------------------------------------
Gets the ServletOutputStream . --> Get the ServletOutputStream for this ServletOutputStream --> Socre: 1.0

[[[[Adv]]]]: public ServletOutputStream [[getOutputStream]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .

[[[[Adv]]]]: public ServletOutputStream [[ardi]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .
--------------------------------------------- Result 988 ---------------------------------------------
Returns a string representation of the type s class name . --> [[[FAILED]]]

[[[[Adv]]]]: public String getClassName ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { stringBuilder . append ( "[]" ) ; } return stringBuilder . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .

[[[[Adv]]]]: public String getClassName ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { stringBuilder . append ( "[]" ) ; } return stringBuilder . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .
--------------------------------------------- Result 989 ---------------------------------------------
Gets the arguments and return sizes . --> Hick sharma = 1 --> Socre: 1.0

[[[[Adv]]]]: public static int [[getArgumentsAndReturnSizes]] ( final String [[methodDescriptor]] ) { int [[argumentsSize]] = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .

[[[[Adv]]]]: public static int [[hick]] ( final String [[zamfir]] ) { int [[sharma]] = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .
--------------------------------------------- Result 990 ---------------------------------------------
Returns the descriptor for the given constructor . --> [[[FAILED]]]

[[[[Adv]]]]: public static String getConstructorDescriptor ( final Constructor < ? > constructor ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = constructor . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .

[[[[Adv]]]]: public static String getConstructorDescriptor ( final Constructor < ? > constructor ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = constructor . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .
--------------------------------------------- Result 991 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 538 / 442 / 11 / 991:  99%|█████████▉| 991/1000 [4:52:11<02:39, 17.69s/it][Succeeded / Failed / Skipped / Total] 538 / 442 / 11 / 991:  99%|█████████▉| 992/1000 [4:52:40<02:21, 17.70s/it][Succeeded / Failed / Skipped / Total] 538 / 443 / 11 / 992:  99%|█████████▉| 992/1000 [4:52:40<02:21, 17.70s/it][Succeeded / Failed / Skipped / Total] 538 / 443 / 11 / 992:  99%|█████████▉| 993/1000 [4:52:50<02:03, 17.69s/it][Succeeded / Failed / Skipped / Total] 538 / 444 / 11 / 993:  99%|█████████▉| 993/1000 [4:52:50<02:03, 17.69s/it][Succeeded / Failed / Skipped / Total] 538 / 444 / 11 / 993:  99%|█████████▉| 994/1000 [4:52:51<01:46, 17.68s/it][Succeeded / Failed / Skipped / Total] 539 / 444 / 11 / 994:  99%|█████████▉| 994/1000 [4:52:51<01:46, 17.68s/it][Succeeded / Failed / Skipped / Total] 539 / 444 / 11 / 994: 100%|█████████▉| 995/1000 [4:52:59<01:28, 17.67s/it][Succeeded / Failed / Skipped / Total] 539 / 445 / 11 / 995: 100%|█████████▉| 995/1000 [4:52:59<01:28, 17.67s/it][Succeeded / Failed / Skipped / Total] 539 / 445 / 11 / 995: 100%|█████████▉| 996/1000 [4:53:47<01:10, 17.70s/it][Succeeded / Failed / Skipped / Total] 539 / 446 / 11 / 996: 100%|█████████▉| 996/1000 [4:53:47<01:10, 17.70s/it][Succeeded / Failed / Skipped / Total] 539 / 446 / 11 / 996: 100%|█████████▉| 997/1000 [4:55:41<00:53, 17.80s/it]Gets the method descriptor . --> [[[FAILED]]]

[[[[Adv]]]]: public static String getMethodDescriptor ( final Method method ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } stringBuilder . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .

[[[[Adv]]]]: public static String getMethodDescriptor ( final Method method ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } stringBuilder . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .
--------------------------------------------- Result 992 ---------------------------------------------
Gets the writer . --> [[[FAILED]]]

[[[[Adv]]]]: public PrintWriter getWriter ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .

[[[[Adv]]]]: public PrintWriter getWriter ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .
--------------------------------------------- Result 993 ---------------------------------------------
Returns a method descriptor for the given return and argument types . --> [[[FAILED]]]

[[[[Adv]]]]: public static String getMethodDescriptor ( final Type returnType , final Type ... argumentTypes ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; for ( Type argumentType : argumentTypes ) { argumentType . appendDescriptor ( stringBuilder ) ; } stringBuilder . append ( ' ' ) ; returnType . appendDescriptor ( stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .

[[[[Adv]]]]: public static String getMethodDescriptor ( final Type returnType , final Type ... argumentTypes ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; for ( Type argumentType : argumentTypes ) { argumentType . appendDescriptor ( stringBuilder ) ; } stringBuilder . append ( ' ' ) ; returnType . appendDescriptor ( stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .
--------------------------------------------- Result 994 ---------------------------------------------
Sets the cause of the transaction that can be marked as rollback only . --> SNOW MOVING ROLLBACK --> Socre: 1.0

[[[[Adv]]]]: public void [[setRollbackOnly]] ( final Throwable [[th]] ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = [[th]] ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .

[[[[Adv]]]]: public void [[snowmobile]] ( final Throwable [[rocio]] ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = [[rocio]] ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .
--------------------------------------------- Result 995 ---------------------------------------------
Appends the descriptor . --> [[[FAILED]]]

[[[[Adv]]]]: private void appendDescriptor ( final StringBuilder stringBuilder ) { if ( sort == OBJECT ) { stringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { stringBuilder . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { stringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .

[[[[Adv]]]]: private void appendDescriptor ( final StringBuilder stringBuilder ) { if ( sort == OBJECT ) { stringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { stringBuilder . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { stringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .
--------------------------------------------- Result 996 ---------------------------------------------
Returns an iterator over the files in this directory . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Iterator < File > iterator ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .

[[[[Adv]]]]: @ Override public Iterator < File > iterator ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .
--------------------------------------------- Result 997 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 539 / 447 / 11 / 997: 100%|█████████▉| 997/1000 [4:55:41<00:53, 17.80s/it][Succeeded / Failed / Skipped / Total] 539 / 447 / 11 / 997: 100%|█████████▉| 998/1000 [4:56:04<00:35, 17.80s/it][Succeeded / Failed / Skipped / Total] 539 / 448 / 11 / 998: 100%|█████████▉| 998/1000 [4:56:04<00:35, 17.80s/it][Succeeded / Failed / Skipped / Total] 539 / 448 / 11 / 998: 100%|█████████▉| 999/1000 [4:57:01<00:17, 17.84s/it][Succeeded / Failed / Skipped / Total] 539 / 449 / 11 / 999: 100%|█████████▉| 999/1000 [4:57:01<00:17, 17.84s/it][Succeeded / Failed / Skipped / Total] 539 / 449 / 11 / 999: 100%|██████████| 1000/1000 [4:57:45<00:00, 17.87s/it][Succeeded / Failed / Skipped / Total] 539 / 450 / 11 / 1000: 100%|██████████| 1000/1000 [4:57:45<00:00, 17.87s/it]Attack(
  (search_method): HardLabelSearch(
    (pop_size):  30
    (max_iters):  100
    (max_replacements_per_index):  25
  )
  (goal_function):  MinimizeBleu(
    (maximizable):  False
    (target_bleu):  0.0
  )
  (transformation):  WordSwapEmbedding(
    (max_candidates):  50
    (embedding):  WordEmbedding
  )
  (constraints): 
    (0): MaxWordsPerturbed(
        (max_num_words):  5
        (compare_against_original):  True
      )
    (1): KeyWord(
        (compare_against_original):  True
      )
    (2): RepeatModification
  (is_black_box):  True
) 

/data/zzr/CodeAttack/codeattack/search_methods/hard_label_search.py:487: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  similarity_scores = np.asarray(similarity_scores)
/data/zzr/CodeAttack/codeattack/search_methods/hard_label_search.py:487: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  similarity_scores = np.asarray(similarity_scores)
/data/zzr/CodeAttack/codeattack/search_methods/hard_label_search.py:487: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
  similarity_scores = np.asarray(similarity_scores)
[Succeeded / Failed / Skipped / Total] 539 / 450 / 11 / 1000: 100%|██████████| 1000/1000 [4:57:49<00:00, 17.87s/it]Commits or rolls all resources . --> [[[FAILED]]]

[[[[Adv]]]]: protected void commitOrRollback ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "False" != "False" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "False" != "False" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .

[[[[Adv]]]]: protected void commitOrRollback ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "False" != "False" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "False" != "False" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .
--------------------------------------------- Result 998 ---------------------------------------------
Rolls back all resources associated with this transaction . --> [[[FAILED]]]

[[[[Adv]]]]: protected void rollbackAllResources ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .

[[[[Adv]]]]: protected void rollbackAllResources ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .
--------------------------------------------- Result 999 ---------------------------------------------
Requests a transaction resource of the specified type . --> [[[FAILED]]]

[[[[Adv]]]]: public < E > E requestResource ( final Class < E > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; E resource = lookupResource ( resourceType ) ; if ( resource == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

[[[[Adv]]]]: public < E > E requestResource ( final Class < E > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; E resource = lookupResource ( resourceType ) ; if ( resource == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .
--------------------------------------------- Result 1000 ---------------------------------------------
Returns the size of this primitive type . --> [[[FAILED]]]

[[[[Adv]]]]: public int getSize ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .

[[[[Adv]]]]: public int getSize ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .

+-------------------------------+---------+
| Attack Results                |         |
+-------------------------------+---------+
| Number of successful attacks: | 539     |
| Number of failed attacks:     | 450     |
| Number of skipped attacks:    | 11      |
| Original accuracy:            | 98.9%   |
| Accuracy under attack:        | 45.0%   |
| Attack success rate:          | 54.5%   |
| Average perturbed word %:     | 70.63%  |
| Average num. words per input: | 3.91    |
| Avg num queries:              | 1143.57 |
| Original BLEU-4:              | 19.61   |
| Perturbed BLEU-4:             | 8.8     |
+-------------------------------+---------+

