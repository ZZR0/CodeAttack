textattack: Running 8 worker(s) on 8 GPU(s).
PositionalEncoding: doing nothing on call to _load_from_state_dict
Using /tmp/tfhub_modules to cache modules.
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/1000 [00:00<00:00, 1587.55it/s][Succeeded / Failed / Skipped / Total] 2 / 0 / 0 / 2:   0%|          | 2/1000 [00:00<00:00, 1885.93it/s][Succeeded / Failed / Skipped / Total] 3 / 0 / 0 / 3:   0%|          | 3/1000 [00:00<00:00, 2181.88it/s][Succeeded / Failed / Skipped / Total] 4 / 0 / 0 / 4:   0%|          | 4/1000 [00:00<00:00, 2243.24it/s][Succeeded / Failed / Skipped / Total] 5 / 0 / 0 / 5:   0%|          | 5/1000 [00:00<00:00, 2342.14it/s][Succeeded / Failed / Skipped / Total] 5 / 0 / 0 / 5:   1%|          | 6/1000 [00:22<1:02:05,  3.75s/it][Succeeded / Failed / Skipped / Total] 5 / 1 / 0 / 6:   1%|          | 6/1000 [00:22<1:02:05,  3.75s/it][Succeeded / Failed / Skipped / Total] 5 / 1 / 0 / 6:   1%|          | 7/1000 [00:30<1:12:29,  4.38s/it][Succeeded / Failed / Skipped / Total] 6 / 1 / 0 / 7:   1%|          | 7/1000 [00:30<1:12:29,  4.38s/it][Succeeded / Failed / Skipped / Total] 6 / 1 / 0 / 7:   1%|          | 8/1000 [00:46<1:35:15,  5.76s/it]--------------------------------------------- Result 1 ---------------------------------------------
Converts a Java source into a java object . --> Converts a Java generator to a java object --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > [[source]] ) { ObjectHelper . requireNonNull ( [[source]] , "source is null" ) ; if ( [[source]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[source]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[source]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[adjustment]] ( ObservableSource < T > [[backgrounds]] ) { ObjectHelper . requireNonNull ( [[backgrounds]] , "source is null" ) ; if ( [[backgrounds]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[backgrounds]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[backgrounds]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 2 ---------------------------------------------
Wraps the given observable . --> A convenience method to create a Observabler --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler [[scheduler]] ) { final Observable < T > [[observable]] = co . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , [[observable]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler [[aural]] ) { final Observable < T > [[marked]] = co . observeOn ( [[aural]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , [[marked]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 3 ---------------------------------------------
Create a new Ticast builder . --> A convenience method for creating a new TTL device --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int capacityHint ) { return new UnicastProcessor < T > ( capacityHint ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[manufacture]] ( int capacityHint ) { return new UnicastProcessor < T > ( capacityHint ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 4 ---------------------------------------------
Adds a observer to the queue . --> Executes a communication --> Socre: 1.0

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U [[value]] , boolean [[delayError]] , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , [[value]] ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( [[value]] ) ; } } else { q . offer ( [[value]] ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , [[delayError]] , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U [[merit]] , boolean [[kitagawa]] , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , [[merit]] ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( [[merit]] ) ; } } else { q . offer ( [[merit]] ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , [[kitagawa]] , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 5 ---------------------------------------------
Asynchronously set the internal state . --> Sets the internal state of the thread --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "[[False]]" != "[[False]]" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[repossession]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "[[Disingenuous]]" != "[[Disingenuous]]" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 6 ---------------------------------------------
Converts an object to a String . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 7 ---------------------------------------------
Returns a function with the specified ID . --> Create a new ythythony --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[thy]] > Function < [[thy]] , [[thy]] > [[attribute]] ( ) { return ( Function < [[thy]] , [[thy]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
[Succeeded / Failed / Skipped / Total] 7 / 1 / 0 / 8:   1%|          | 8/1000 [00:46<1:35:15,  5.76s/it][Succeeded / Failed / Skipped / Total] 7 / 1 / 0 / 8:   1%|          | 9/1000 [00:49<1:29:56,  5.45s/it][Succeeded / Failed / Skipped / Total] 8 / 1 / 0 / 9:   1%|          | 9/1000 [00:49<1:29:56,  5.45s/it][Succeeded / Failed / Skipped / Total] 8 / 1 / 0 / 9:   1%|          | 10/1000 [01:13<2:01:21,  7.35s/it][Succeeded / Failed / Skipped / Total] 9 / 1 / 0 / 10:   1%|          | 10/1000 [01:13<2:01:21,  7.35s/it][Succeeded / Failed / Skipped / Total] 9 / 1 / 0 / 10:   1%|          | 11/1000 [01:23<2:04:28,  7.55s/it][Succeeded / Failed / Skipped / Total] 9 / 2 / 0 / 11:   1%|          | 11/1000 [01:23<2:04:28,  7.55s/it][Succeeded / Failed / Skipped / Total] 9 / 2 / 0 / 11:   1%|          | 12/1000 [01:36<2:12:11,  8.03s/it][Succeeded / Failed / Skipped / Total] 10 / 2 / 0 / 12:   1%|          | 12/1000 [01:36<2:12:11,  8.03s/it][Succeeded / Failed / Skipped / Total] 10 / 2 / 0 / 12:   1%|▏         | 13/1000 [02:00<2:32:39,  9.28s/it][Succeeded / Failed / Skipped / Total] 11 / 2 / 0 / 13:   1%|▏         | 13/1000 [02:00<2:32:39,  9.28s/it][Succeeded / Failed / Skipped / Total] 11 / 2 / 0 / 13:   1%|▏         | 14/1000 [02:13<2:36:08,  9.50s/it][Succeeded / Failed / Skipped / Total] 12 / 2 / 0 / 14:   1%|▏         | 14/1000 [02:13<2:36:08,  9.50s/it][Succeeded / Failed / Skipped / Total] 12 / 2 / 0 / 14:   2%|▏         | 15/1000 [02:25<2:39:14,  9.70s/it][Succeeded / Failed / Skipped / Total] 13 / 2 / 0 / 15:   2%|▏         | 15/1000 [02:25<2:39:14,  9.70s/it][Succeeded / Failed / Skipped / Total] 13 / 2 / 0 / 15:   2%|▏         | 16/1000 [02:59<3:04:28, 11.25s/it][Succeeded / Failed / Skipped / Total] 14 / 2 / 0 / 16:   2%|▏         | 16/1000 [02:59<3:04:28, 11.25s/it][Succeeded / Failed / Skipped / Total] 14 / 2 / 0 / 16:   2%|▏         | 17/1000 [03:28<3:21:19, 12.29s/it][Succeeded / Failed / Skipped / Total] 15 / 2 / 0 / 17:   2%|▏         | 17/1000 [03:28<3:21:19, 12.29s/it][Succeeded / Failed / Skipped / Total] 15 / 2 / 0 / 17:   2%|▏         | 18/1000 [03:34<3:15:21, 11.94s/it]--------------------------------------------- Result 8 ---------------------------------------------
Convert a Throwable to a predicate . --> Convert a Throwable to a hours --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[retry]] ( long [[times]] , Predicate < ? super Throwable > [[predicate]] ) { return toFlowable ( ) . retry ( [[times]] , [[predicate]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[failed]] ( long [[hours]] , Predicate < ? super Throwable > [[underlying]] ) { return toFlowable ( ) . retry ( [[hours]] , [[underlying]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 9 ---------------------------------------------
Create a new value from a value . --> Convenience factory method for testing --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > justCallable ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > justCallable ( T [[appreciates]] ) { return new JustValue < Object , T > ( [[appreciates]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 10 ---------------------------------------------
Converts a function to a target class . --> Copied from source to target --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[castFunction]] ( Class < U > target ) { return new CastToClass < [[T]] , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < [[ve]] , U > Function < [[ve]] , U > [[rosh]] ( Class < U > target ) { return new CastToClass < [[ve]] , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 11 ---------------------------------------------
Sort a Observable . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 12 ---------------------------------------------
Creates a new builder for the given value . --> Returns a Tunether TPEP - TPEPE --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[engendered]] ( int [[peaceful]] ) { return new UnicastSubject < T > ( [[peaceful]] , "[[Earnest]]" == "[[Earnest]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 13 ---------------------------------------------
Create a new Subject . --> Create a new Authenticator --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[Authentic]]" == "[[Authentic]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 14 ---------------------------------------------
Convenience method for creating a new value . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[justFunction]] ( U [[value]] ) { return new JustValue < [[T]] , U > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[b]] , U > Function < [[b]] , U > [[ramo]] ( U [[prized]] ) { return new JustValue < [[b]] , U > ( [[prized]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 15 ---------------------------------------------
Returns the error . --> Allocate a number of blocks --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[builded]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 16 ---------------------------------------------
Create a new value . --> Construct a new ByteArray --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean [[delayError]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[delayError]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[build]] ( boolean [[c]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[c]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 17 ---------------------------------------------
Convert a Java object to a map . --> Static factory method for creating an evaluation --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T [[value]] , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[value]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[fozzie]] ( final T [[evaluations]] , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[evaluations]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 18 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 2 / 0 / 18:   2%|▏         | 18/1000 [03:34<3:15:21, 11.94s/it][Succeeded / Failed / Skipped / Total] 16 / 2 / 0 / 18:   2%|▏         | 19/1000 [03:51<3:19:29, 12.20s/it][Succeeded / Failed / Skipped / Total] 17 / 2 / 0 / 19:   2%|▏         | 19/1000 [03:51<3:19:29, 12.20s/it][Succeeded / Failed / Skipped / Total] 17 / 2 / 0 / 19:   2%|▏         | 20/1000 [03:58<3:14:29, 11.91s/it][Succeeded / Failed / Skipped / Total] 18 / 2 / 0 / 20:   2%|▏         | 20/1000 [03:58<3:14:29, 11.91s/it][Succeeded / Failed / Skipped / Total] 18 / 2 / 0 / 20:   2%|▏         | 21/1000 [04:32<3:31:33, 12.97s/it][Succeeded / Failed / Skipped / Total] 19 / 2 / 0 / 21:   2%|▏         | 21/1000 [04:32<3:31:33, 12.97s/it][Succeeded / Failed / Skipped / Total] 19 / 2 / 0 / 21:   2%|▏         | 22/1000 [04:34<3:23:10, 12.46s/it][Succeeded / Failed / Skipped / Total] 20 / 2 / 0 / 22:   2%|▏         | 22/1000 [04:34<3:23:10, 12.46s/it][Succeeded / Failed / Skipped / Total] 20 / 2 / 0 / 22:   2%|▏         | 23/1000 [05:07<3:37:41, 13.37s/it]Queues a queue . --> Allocates a balancing --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > void [[drainMaxLoop]] ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > [[qd]] ) { int [[missed]] = 1 ; for ( ; ; ) { for ( ; ; ) { boolean [[d]] = [[qd]] . done ( ) ; T v = q . poll ( ) ; boolean [[empty]] = v == null ; if ( checkTerminated ( [[d]] , [[empty]] , a , delayError , q , [[qd]] ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( [[empty]] ) { break ; } long r = [[qd]] . requested ( ) ; if ( r != 0L ) { if ( [[qd]] . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { [[qd]] . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } [[missed]] = [[qd]] . leave ( - [[missed]] ) ; if ( [[missed]] == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void [[meander]] ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > [[sneeze]] ) { int [[omitted]] = 1 ; for ( ; ; ) { for ( ; ; ) { boolean [[fourth]] = [[sneeze]] . done ( ) ; T v = q . poll ( ) ; boolean [[siphon]] = v == null ; if ( checkTerminated ( [[fourth]] , [[siphon]] , a , delayError , q , [[sneeze]] ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( [[siphon]] ) { break ; } long r = [[sneeze]] . requested ( ) ; if ( r != 0L ) { if ( [[sneeze]] . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { [[sneeze]] . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } [[omitted]] = [[sneeze]] . leave ( - [[omitted]] ) ; if ( [[omitted]] == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 19 ---------------------------------------------
Adapts a prefetch . --> Adapts computation of computation --> Socre: 1.0

[[[[Adv]]]]: public static void [[request]] ( Subscription s , int [[prefetch]] ) { s . request ( [[prefetch]] < 0 ? Long . MAX_VALUE : [[prefetch]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void [[appealed]] ( Subscription s , int [[como]] ) { s . request ( [[como]] < 0 ? Long . MAX_VALUE : [[como]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 20 ---------------------------------------------
Shuts down the queue . --> Shuts down a computation --> Socre: 1.0

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > [[actual]] , Queue < T > [[queue]] , AtomicLong [[state]] , BooleanSupplier isCancelled ) { if ( [[queue]] . isEmpty ( ) ) { [[actual]] . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[state]] . get ( ) , [[actual]] , [[queue]] , [[state]] , isCancelled ) ) { return ; } for ( ; ; ) { long r = [[state]] . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > [[facto]] , Queue < T > [[semaphore]] , AtomicLong [[administrations]] , BooleanSupplier isCancelled ) { if ( [[semaphore]] . isEmpty ( ) ) { [[facto]] . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[administrations]] . get ( ) , [[facto]] , [[semaphore]] , [[administrations]] , isCancelled ) ) { return ; } for ( ; ; ) { long r = [[administrations]] . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 21 ---------------------------------------------
Waits for a given timeout to the given timeout . --> Wrap a RuntimeException --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long [[timeout]] , TimeUnit [[unit]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , [[unit]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[timeout]] , [[unit]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[valdes]] ( long [[pauses]] , TimeUnit [[dependency]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[pauses]] , [[dependency]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[pauses]] , [[dependency]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 22 ---------------------------------------------
Shuts down the supplied value . --> Synchronistor --> Socre: 1.0

[[[[Adv]]]]: protected final void [[complete]] ( R [[n]] ) { long [[p]] = produced ; if ( [[p]] != 0 ) { BackpressureHelper . produced ( this , [[p]] ) ; } for ( ; ; ) { long [[r]] = get ( ) ; if ( ( [[r]] & COMPLETE_MASK ) != 0 ) { onDrop ( [[n]] ) ; return ; } if ( ( [[r]] & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( [[n]] ) ; downstream . onComplete ( ) ; return ; } value = [[n]] ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[conclude]] ( R [[norte]] ) { long [[sodium]] = produced ; if ( [[sodium]] != 0 ) { BackpressureHelper . produced ( this , [[sodium]] ) ; } for ( ; ; ) { long [[gs]] = get ( ) ; if ( ( [[gs]] & COMPLETE_MASK ) != 0 ) { onDrop ( [[norte]] ) ; return ; } if ( ( [[gs]] & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( [[norte]] ) ; downstream . onComplete ( ) ; return ; } value = [[norte]] ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 23 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 21 / 2 / 0 / 23:   2%|▏         | 23/1000 [05:07<3:37:41, 13.37s/it][Succeeded / Failed / Skipped / Total] 21 / 2 / 0 / 23:   2%|▏         | 24/1000 [05:41<3:51:15, 14.22s/it][Succeeded / Failed / Skipped / Total] 22 / 2 / 0 / 24:   2%|▏         | 24/1000 [05:41<3:51:15, 14.22s/it][Succeeded / Failed / Skipped / Total] 22 / 2 / 0 / 24:   2%|▎         | 25/1000 [06:16<4:04:47, 15.06s/it][Succeeded / Failed / Skipped / Total] 22 / 3 / 0 / 25:   2%|▎         | 25/1000 [06:16<4:04:47, 15.06s/it][Succeeded / Failed / Skipped / Total] 22 / 3 / 0 / 25:   3%|▎         | 26/1000 [06:26<4:01:19, 14.87s/it][Succeeded / Failed / Skipped / Total] 22 / 4 / 0 / 26:   3%|▎         | 26/1000 [06:26<4:01:19, 14.87s/it][Succeeded / Failed / Skipped / Total] 22 / 4 / 0 / 26:   3%|▎         | 27/1000 [06:50<4:06:47, 15.22s/it][Succeeded / Failed / Skipped / Total] 23 / 4 / 0 / 27:   3%|▎         | 27/1000 [06:50<4:06:47, 15.22s/it][Succeeded / Failed / Skipped / Total] 23 / 4 / 0 / 27:   3%|▎         | 28/1000 [07:17<4:13:17, 15.64s/it]Waits for a timeout . --> Returns a dived divisor --> Socre: 1.0

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long timeout , TimeUnit [[unit]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , [[unit]] ) ) { dispose ( ) ; return "[[False]]" != "[[False]]" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } } Throwable [[ex]] = error ; if ( [[ex]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[revised]] ( long timeout , TimeUnit [[uniformity]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , [[uniformity]] ) ) { dispose ( ) ; return "[[Pretended]]" != "[[Pretended]]" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[divorced]] ) ; } } Throwable [[divorced]] = error ; if ( [[divorced]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[divorced]] ) ; } return "[[Realities]]" == "[[Realities]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 24 ---------------------------------------------
Creates a CompletableSource from the given source . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource [[completableSource]] ) { ObjectHelper . requireNonNull ( [[completableSource]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[completableSource]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource [[monsieur]] ) { ObjectHelper . requireNonNull ( [[monsieur]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[monsieur]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 25 ---------------------------------------------
Performs a callable . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 26 ---------------------------------------------
Create a new instance of the given value . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 27 ---------------------------------------------
Sets the current call . --> Convenience function for testing purposes --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[setOnce]] ( AtomicReference < Disposable > [[upstream]] , Disposable next , Class < ? > [[observer]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( [[upstream]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observer]] ) ; } return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean [[pop]] ( AtomicReference < Disposable > [[ascendant]] , Disposable next , Class < ? > [[oversees]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[ascendant]] . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( [[ascendant]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[oversees]] ) ; } return "[[Fallacious]]" != "[[Fallacious]]" ; } return "[[Velma]]" == "[[Velma]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 28 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 24 / 4 / 0 / 28:   3%|▎         | 28/1000 [07:17<4:13:17, 15.64s/it][Succeeded / Failed / Skipped / Total] 24 / 4 / 0 / 28:   3%|▎         | 29/1000 [07:19<4:05:29, 15.17s/it][Succeeded / Failed / Skipped / Total] 25 / 4 / 0 / 29:   3%|▎         | 29/1000 [07:19<4:05:29, 15.17s/it][Succeeded / Failed / Skipped / Total] 25 / 4 / 0 / 29:   3%|▎         | 30/1000 [07:21<3:57:52, 14.71s/it][Succeeded / Failed / Skipped / Total] 26 / 4 / 0 / 30:   3%|▎         | 30/1000 [07:21<3:57:52, 14.71s/it][Succeeded / Failed / Skipped / Total] 26 / 4 / 0 / 30:   3%|▎         | 31/1000 [07:29<3:54:19, 14.51s/it][Succeeded / Failed / Skipped / Total] 27 / 4 / 0 / 31:   3%|▎         | 31/1000 [07:29<3:54:19, 14.51s/it][Succeeded / Failed / Skipped / Total] 27 / 4 / 0 / 31:   3%|▎         | 32/1000 [07:31<3:47:50, 14.12s/it][Succeeded / Failed / Skipped / Total] 28 / 4 / 0 / 32:   3%|▎         | 32/1000 [07:31<3:47:50, 14.12s/it][Succeeded / Failed / Skipped / Total] 28 / 4 / 0 / 32:   3%|▎         | 33/1000 [07:41<3:45:35, 14.00s/it][Succeeded / Failed / Skipped / Total] 29 / 4 / 0 / 33:   3%|▎         | 33/1000 [07:41<3:45:35, 14.00s/it][Succeeded / Failed / Skipped / Total] 29 / 4 / 0 / 33:   3%|▎         | 34/1000 [07:51<3:43:22, 13.87s/it][Succeeded / Failed / Skipped / Total] 30 / 4 / 0 / 34:   3%|▎         | 34/1000 [07:51<3:43:23, 13.87s/it][Succeeded / Failed / Skipped / Total] 30 / 4 / 0 / 34:   4%|▎         | 35/1000 [08:25<3:52:03, 14.43s/it][Succeeded / Failed / Skipped / Total] 31 / 4 / 0 / 35:   4%|▎         | 35/1000 [08:25<3:52:03, 14.43s/it][Succeeded / Failed / Skipped / Total] 31 / 4 / 0 / 35:   4%|▎         | 36/1000 [08:33<3:48:58, 14.25s/it][Succeeded / Failed / Skipped / Total] 31 / 5 / 0 / 36:   4%|▎         | 36/1000 [08:33<3:48:58, 14.25s/it][Succeeded / Failed / Skipped / Total] 31 / 5 / 0 / 36:   4%|▎         | 37/1000 [09:22<4:03:51, 15.19s/it][Succeeded / Failed / Skipped / Total] 32 / 5 / 0 / 37:   4%|▎         | 37/1000 [09:22<4:03:51, 15.19s/it][Succeeded / Failed / Skipped / Total] 32 / 5 / 0 / 37:   4%|▍         | 38/1000 [09:26<3:59:13, 14.92s/it]Add a long . --> Add a journal --> Socre: 1.0

[[[[Adv]]]]: public static long addCap ( long [[a]] , long [[b]] ) { long [[u]] = [[a]] + [[b]] ; if ( [[u]] < 0L ) { return Long . MAX_VALUE ; } return [[u]] ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long addCap ( long [[latter]] , long [[j]] ) { long [[zhen]] = [[latter]] + [[j]] ; if ( [[zhen]] < 0L ) { return Long . MAX_VALUE ; } return [[zhen]] ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 29 ---------------------------------------------
Validates the supplied exception . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[validate]] ( Disposable [[upstream]] , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[upstream]] != null ) { next . dispose ( ) ; if ( [[upstream]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[justify]] ( Disposable [[upstairs]] , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[upstairs]] != null ) { next . dispose ( ) ; if ( [[upstairs]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[Deceptive]]" != "[[Deceptive]]" ; } return "[[Staunch]]" == "[[Staunch]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 30 ---------------------------------------------
Returns the long . --> Return how many --> Socre: 1.0

[[[[Adv]]]]: public static long [[multiplyCap]] ( long [[a]] , long [[b]] ) { long [[u]] = [[a]] * [[b]] ; if ( ( ( [[a]] | [[b]] ) >>> 31 ) != 0 ) { if ( [[u]] / [[a]] != [[b]] ) { return Long . MAX_VALUE ; } } return [[u]] ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[farrakhan]] ( long [[s]] , long [[jim]] ) { long [[joo]] = [[s]] * [[jim]] ; if ( ( ( [[s]] | [[jim]] ) >>> 31 ) != 0 ) { if ( [[joo]] / [[s]] != [[jim]] ) { return Long . MAX_VALUE ; } } return [[joo]] ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 31 ---------------------------------------------
Add a Long to the set . --> Obtain a set of values from a set --> Socre: 1.0

[[[[Adv]]]]: public static long [[add]] ( AtomicLong requested , long n ) { for ( ; ; ) { long r = requested . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( requested . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long [[additional]] ( AtomicLong requested , long n ) { for ( ; ; ) { long r = requested . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( requested . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 32 ---------------------------------------------
Returns the value of the notification . --> Unregister a peer --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[peers]] ( ) { Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 33 ---------------------------------------------
Shuts down the executor . --> Shut --> Socre: 1.0

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService [[exec]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[exec]] != null ) { [[exec]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[locking]] ( ) { ScheduledExecutorService [[ceo]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[ceo]] != null ) { [[ceo]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 34 ---------------------------------------------
Adds an object to this object . --> Similar for test --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object [[o]] ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[contained]] ( Object [[wu]] ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 35 ---------------------------------------------
Creates a new executor service . --> create ExecutorService --> Socre: 1.0

[[[[Adv]]]]: public static ScheduledExecutorService create ( ThreadFactory [[factory]] ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , [[factory]] ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService create ( ThreadFactory [[maker]] ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , [[maker]] ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 36 ---------------------------------------------
Get the error . --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Throwable getError ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable getError ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 37 ---------------------------------------------
Convenience method to create a Java source . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > [[singleSource]] ) { ObjectHelper . requireNonNull ( [[singleSource]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[singleSource]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[kennelly]] ( SingleSource < T > [[conference]] ) { ObjectHelper . requireNonNull ( [[conference]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[conference]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
[Succeeded / Failed / Skipped / Total] 33 / 5 / 0 / 38:   4%|▍         | 38/1000 [09:26<3:59:13, 14.92s/it][Succeeded / Failed / Skipped / Total] 33 / 5 / 0 / 38:   4%|▍         | 39/1000 [09:33<3:55:24, 14.70s/it][Succeeded / Failed / Skipped / Total] 34 / 5 / 0 / 39:   4%|▍         | 39/1000 [09:33<3:55:24, 14.70s/it][Succeeded / Failed / Skipped / Total] 34 / 5 / 0 / 39:   4%|▍         | 40/1000 [09:38<3:51:27, 14.47s/it][Succeeded / Failed / Skipped / Total] 35 / 5 / 0 / 40:   4%|▍         | 40/1000 [09:38<3:51:27, 14.47s/it][Succeeded / Failed / Skipped / Total] 35 / 5 / 0 / 40:   4%|▍         | 41/1000 [10:13<3:59:03, 14.96s/it][Succeeded / Failed / Skipped / Total] 36 / 5 / 0 / 41:   4%|▍         | 41/1000 [10:13<3:59:03, 14.96s/it][Succeeded / Failed / Skipped / Total] 36 / 5 / 0 / 41:   4%|▍         | 42/1000 [11:33<4:23:49, 16.52s/it][Succeeded / Failed / Skipped / Total] 37 / 5 / 0 / 42:   4%|▍         | 42/1000 [11:33<4:23:49, 16.52s/it][Succeeded / Failed / Skipped / Total] 37 / 5 / 0 / 42:   4%|▍         | 43/1000 [12:53<4:46:44, 17.98s/it][Succeeded / Failed / Skipped / Total] 38 / 5 / 0 / 43:   4%|▍         | 43/1000 [12:53<4:46:44, 17.98s/it][Succeeded / Failed / Skipped / Total] 38 / 5 / 0 / 43:   4%|▍         | 44/1000 [13:04<4:44:01, 17.83s/it][Succeeded / Failed / Skipped / Total] 39 / 5 / 0 / 44:   4%|▍         | 44/1000 [13:04<4:44:01, 17.83s/it][Succeeded / Failed / Skipped / Total] 39 / 5 / 0 / 44:   4%|▍         | 45/1000 [13:13<4:40:37, 17.63s/it]--------------------------------------------- Result 38 ---------------------------------------------
Sets the cancellation . --> Shut down the current thread --> Socre: 1.0

[[[[Adv]]]]: public final void [[setSubscription]] ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[s]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[s]] . request ( r ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[s]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void [[pigmentation]] ( Subscription [[ies]] ) { if ( cancelled ) { [[ies]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[ies]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[ies]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[ies]] . request ( r ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[ies]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 39 ---------------------------------------------
Throw an exception . --> On throwableException --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[E]] extends Throwable > Exception throwIfThrowable ( Throwable e ) throws [[E]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[E]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[grams]] extends Throwable > Exception throwIfThrowable ( Throwable e ) throws [[grams]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[grams]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 40 ---------------------------------------------
Removes all items from the queue . --> Auxiliary method for testing --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[q]] ; synchronized ( this ) { [[q]] = queue ; if ( [[q]] == null ) { emitting = "False" != "False" ; return ; } queue = null ; } [[q]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[speech]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[enquired]] ; synchronized ( this ) { [[enquired]] = queue ; if ( [[enquired]] == null ) { emitting = "False" != "False" ; return ; } queue = null ; } [[enquired]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 41 ---------------------------------------------
Set the resources . --> Shut down this thread --> Socre: 1.0

[[[[Adv]]]]: public void [[clear]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[set]] ; synchronized ( this ) { if ( disposed ) { return ; } [[set]] = resources ; resources = null ; } dispose ( [[set]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void [[unequivocally]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[determines]] ; synchronized ( this ) { if ( disposed ) { return ; } [[determines]] = resources ; resources = null ; } dispose ( [[determines]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 42 ---------------------------------------------
Sets the number of members . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[set]] = resources ; return [[set]] != null ? [[set]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[enormity]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[installed]] = resources ; return [[installed]] != null ? [[installed]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 43 ---------------------------------------------
Create a new builder . --> Audite die die e e die e e die e e efeie ert eie e die e en hie e udieie e die e e eie die eie die ue eie ef e dieneie ughieie  --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] , Runnable [[onTerminate]] ) { return new UnicastSubject < T > ( [[capacityHint]] , [[onTerminate]] , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[engender]] ( int [[priesthood]] , Runnable [[hutu]] ) { return new UnicastSubject < T > ( [[priesthood]] , [[hutu]] , "[[Appropriate]]" == "[[Appropriate]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 44 ---------------------------------------------
Obtains the object for the given object . --> Return a copy of this object --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean [[accept]] ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int [[i]] = 0 ; [[i]] < c ; [[i]] ++ ) { Object o = a [ [[i]] ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean [[approval]] ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int [[rhee]] = 0 ; [[rhee]] < c ; [[rhee]] ++ ) { Object o = a [ [[rhee]] ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 45 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 40 / 5 / 0 / 45:   4%|▍         | 45/1000 [13:13<4:40:37, 17.63s/it][Succeeded / Failed / Skipped / Total] 40 / 5 / 0 / 45:   5%|▍         | 46/1000 [13:21<4:37:05, 17.43s/it][Succeeded / Failed / Skipped / Total] 40 / 6 / 0 / 46:   5%|▍         | 46/1000 [13:21<4:37:05, 17.43s/it][Succeeded / Failed / Skipped / Total] 40 / 6 / 0 / 46:   5%|▍         | 47/1000 [13:30<4:33:52, 17.24s/it][Succeeded / Failed / Skipped / Total] 40 / 7 / 0 / 47:   5%|▍         | 47/1000 [13:30<4:33:52, 17.24s/it][Succeeded / Failed / Skipped / Total] 40 / 7 / 0 / 47:   5%|▍         | 48/1000 [13:33<4:28:52, 16.95s/it][Succeeded / Failed / Skipped / Total] 41 / 7 / 0 / 48:   5%|▍         | 48/1000 [13:33<4:28:52, 16.95s/it][Succeeded / Failed / Skipped / Total] 41 / 7 / 0 / 48:   5%|▍         | 49/1000 [13:43<4:26:13, 16.80s/it][Succeeded / Failed / Skipped / Total] 41 / 8 / 0 / 49:   5%|▍         | 49/1000 [13:43<4:26:13, 16.80s/it][Succeeded / Failed / Skipped / Total] 41 / 8 / 0 / 49:   5%|▌         | 50/1000 [13:46<4:21:40, 16.53s/it][Succeeded / Failed / Skipped / Total] 41 / 9 / 0 / 50:   5%|▌         | 50/1000 [13:46<4:21:40, 16.53s/it][Succeeded / Failed / Skipped / Total] 41 / 9 / 0 / 50:   5%|▌         | 51/1000 [13:50<4:17:37, 16.29s/it][Succeeded / Failed / Skipped / Total] 42 / 9 / 0 / 51:   5%|▌         | 51/1000 [13:50<4:17:37, 16.29s/it][Succeeded / Failed / Skipped / Total] 42 / 9 / 0 / 51:   5%|▌         | 52/1000 [13:55<4:13:58, 16.07s/it]Returns a observer for the given object . --> Return a copy of this object --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean [[accept]] ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "[[True]]" == "[[True]]" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean [[accepted]] ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "[[Realist]]" == "[[Realist]]" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 46 ---------------------------------------------
Increments the next subscriptions . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean validate ( Subscription upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Subscription upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 47 ---------------------------------------------
Sets the queue . --> [[[FAILED]]]

[[[[Adv]]]]: public void start ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void start ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 48 ---------------------------------------------
Sets the queue . --> Allocate a new queue --> Socre: 1.0

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[bir]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 49 ---------------------------------------------
Wraps a throwable error . --> [[[FAILED]]]

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 50 ---------------------------------------------
Constructs an exception handler . --> [[[FAILED]]]

[[[[Adv]]]]: private static NullPointerException toNpe ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException toNpe ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 51 ---------------------------------------------
Logs a message . --> Adapts a billivation --> Socre: 1.0

[[[[Adv]]]]: public final void [[error]] ( Throwable [[t]] ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[t]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[t]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[gaffe]] ( Throwable [[billions]] ) { int [[administrations]] = get ( ) ; if ( ( [[administrations]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[billions]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[billions]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 52 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 42 / 10 / 0 / 52:   5%|▌         | 52/1000 [13:55<4:13:58, 16.07s/it][Succeeded / Failed / Skipped / Total] 42 / 10 / 0 / 52:   5%|▌         | 53/1000 [14:07<4:12:15, 15.98s/it][Succeeded / Failed / Skipped / Total] 43 / 10 / 0 / 53:   5%|▌         | 53/1000 [14:07<4:12:15, 15.98s/it][Succeeded / Failed / Skipped / Total] 43 / 10 / 0 / 53:   5%|▌         | 54/1000 [14:32<4:14:42, 16.15s/it][Succeeded / Failed / Skipped / Total] 44 / 10 / 0 / 54:   5%|▌         | 54/1000 [14:32<4:14:42, 16.15s/it][Succeeded / Failed / Skipped / Total] 44 / 10 / 0 / 54:   6%|▌         | 55/1000 [14:33<4:10:03, 15.88s/it][Succeeded / Failed / Skipped / Total] 45 / 10 / 0 / 55:   6%|▌         | 55/1000 [14:33<4:10:03, 15.88s/it][Succeeded / Failed / Skipped / Total] 45 / 10 / 0 / 55:   6%|▌         | 56/1000 [14:37<4:06:30, 15.67s/it][Succeeded / Failed / Skipped / Total] 46 / 10 / 0 / 56:   6%|▌         | 56/1000 [14:37<4:06:30, 15.67s/it][Succeeded / Failed / Skipped / Total] 46 / 10 / 0 / 56:   6%|▌         | 57/1000 [14:42<4:03:20, 15.48s/it][Succeeded / Failed / Skipped / Total] 47 / 10 / 0 / 57:   6%|▌         | 57/1000 [14:42<4:03:20, 15.48s/it][Succeeded / Failed / Skipped / Total] 47 / 10 / 0 / 57:   6%|▌         | 58/1000 [15:22<4:09:43, 15.91s/it][Succeeded / Failed / Skipped / Total] 48 / 10 / 0 / 58:   6%|▌         | 58/1000 [15:22<4:09:43, 15.91s/it][Succeeded / Failed / Skipped / Total] 48 / 10 / 0 / 58:   6%|▌         | 59/1000 [15:32<4:07:46, 15.80s/it]Sets the next subscriptions . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 53 ---------------------------------------------
Shuts down the stream . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[fini]] ( ) { int [[proclaims]] = get ( ) ; if ( ( [[proclaims]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 54 ---------------------------------------------
Returns true if the supplied object has been set . --> Obtain a new instance of Hibernettates --> Socre: 1.0

[[[[Adv]]]]: public boolean offer ( T [[t]] ) { if ( once . get ( ) ) { return "[[False]]" != "[[False]]" ; } ObjectHelper . requireNonNull ( [[t]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[t]] ) ) { drain ( ) ; return "[[True]]" == "[[True]]" ; } } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean offer ( T [[cent]] ) { if ( once . get ( ) ) { return "[[Hypocrite]]" != "[[Hypocrite]]" ; } ObjectHelper . requireNonNull ( [[cent]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[cent]] ) ) { drain ( ) ; return "[[Meaningful]]" == "[[Meaningful]]" ; } } return "[[Hypocrite]]" != "[[Hypocrite]]" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 55 ---------------------------------------------
Convert a Iterable to Iterable . --> Liefert die e die e eineiche e enen die n e egeineichene eufeichen eneiche eue eue eneur eueich eneichenege eurue ene lenen eurugeurue  --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > mapper ) { return [[concatMapIterable]] ( mapper , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[erland]] ( Function < ? super T , ? extends Iterable < ? extends U > > mapper ) { return [[erland]] ( mapper , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 56 ---------------------------------------------
Sets the current state . --> Shronistorical thread --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( T [[value]] ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( [[state]] == FUSED_EMPTY ) { this . [[value]] = [[value]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[value]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void [[completed]] ( T [[worth]] ) { int [[kraj]] = get ( ) ; if ( ( [[kraj]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( [[kraj]] == FUSED_EMPTY ) { this . [[assessment]] = [[worth]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[worth]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 57 ---------------------------------------------
Sorts the supplied arguments . --> Auxiliary method for testing --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[nature]] ( Comparator < ? super T > [[bodies]] ) { ObjectHelper . requireNonNull ( [[bodies]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[bodies]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 58 ---------------------------------------------
Sends a request . --> Sends an ovocation --> Socre: 1.0

[[[[Adv]]]]: protected final void [[request]] ( long [[n]] ) { Subscription [[s]] = this . upstream ; if ( [[s]] != null ) { [[s]] . request ( [[n]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void [[demands]] ( long [[nitrogen]] ) { Subscription [[o]] = this . upstream ; if ( [[o]] != null ) { [[o]] . request ( [[nitrogen]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 59 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 49 / 10 / 0 / 59:   6%|▌         | 59/1000 [15:32<4:07:46, 15.80s/it][Succeeded / Failed / Skipped / Total] 49 / 10 / 0 / 59:   6%|▌         | 60/1000 [15:32<4:03:31, 15.54s/it][Succeeded / Failed / Skipped / Total] 50 / 10 / 0 / 60:   6%|▌         | 60/1000 [15:32<4:03:31, 15.54s/it][Succeeded / Failed / Skipped / Total] 50 / 10 / 0 / 60:   6%|▌         | 61/1000 [16:03<4:07:05, 15.79s/it][Succeeded / Failed / Skipped / Total] 51 / 10 / 0 / 61:   6%|▌         | 61/1000 [16:03<4:07:05, 15.79s/it][Succeeded / Failed / Skipped / Total] 51 / 10 / 0 / 61:   6%|▌         | 62/1000 [16:07<4:03:51, 15.60s/it][Succeeded / Failed / Skipped / Total] 52 / 10 / 0 / 62:   6%|▌         | 62/1000 [16:07<4:03:51, 15.60s/it][Succeeded / Failed / Skipped / Total] 52 / 10 / 0 / 62:   6%|▋         | 63/1000 [16:16<4:02:03, 15.50s/it][Succeeded / Failed / Skipped / Total] 53 / 10 / 0 / 63:   6%|▋         | 63/1000 [16:16<4:02:03, 15.50s/it][Succeeded / Failed / Skipped / Total] 53 / 10 / 0 / 63:   6%|▋         | 64/1000 [16:16<3:58:03, 15.26s/it][Succeeded / Failed / Skipped / Total] 53 / 10 / 1 / 64:   6%|▋         | 64/1000 [16:16<3:58:03, 15.26s/it][Succeeded / Failed / Skipped / Total] 53 / 10 / 1 / 64:   6%|▋         | 65/1000 [16:41<4:00:05, 15.41s/it]Removes a subscriber . --> Re - initialize a bean --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[a]] = subscribers . get ( ) ; if ( [[a]] == TERMINATED || [[a]] == EMPTY ) { return ; } int [[n]] = [[a]] . length ; int j = - 1 ; for ( int [[i]] = 0 ; [[i]] < [[n]] ; [[i]] ++ ) { if ( [[a]] [ [[i]] ] == ps ) { j = [[i]] ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] [[b]] ; if ( [[n]] == 1 ) { [[b]] = EMPTY ; } else { [[b]] = new PublishDisposable [ [[n]] - 1 ] ; System . arraycopy ( [[a]] , 0 , [[b]] , 0 , j ) ; System . arraycopy ( [[a]] , j + 1 , [[b]] , j , [[n]] - j - 1 ) ; } if ( subscribers . compareAndSet ( [[a]] , [[b]] ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[oona]] = subscribers . get ( ) ; if ( [[oona]] == TERMINATED || [[oona]] == EMPTY ) { return ; } int [[nitrogen]] = [[oona]] . length ; int j = - 1 ; for ( int [[am]] = 0 ; [[am]] < [[nitrogen]] ; [[am]] ++ ) { if ( [[oona]] [ [[am]] ] == ps ) { j = [[am]] ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] [[iii]] ; if ( [[nitrogen]] == 1 ) { [[iii]] = EMPTY ; } else { [[iii]] = new PublishDisposable [ [[nitrogen]] - 1 ] ; System . arraycopy ( [[oona]] , 0 , [[iii]] , 0 , j ) ; System . arraycopy ( [[oona]] , j + 1 , [[iii]] , j , [[nitrogen]] - j - 1 ) ; } if ( subscribers . compareAndSet ( [[oona]] , [[iii]] ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 60 ---------------------------------------------
Throws an exception . --> Convenience method to get the supplied exception --> Socre: 1.0

[[[[Adv]]]]: public static List < Throwable > [[flatten]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable [[e]] = deque . removeFirst ( ) ; if ( [[e]] instanceof CompositeException ) { CompositeException ce = ( CompositeException ) [[e]] ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( [[e]] ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > [[stubble]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable [[ja]] = deque . removeFirst ( ) ; if ( [[ja]] instanceof CompositeException ) { CompositeException ce = ( CompositeException ) [[ja]] ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( [[ja]] ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 61 ---------------------------------------------
Parse a response string . --> Convenience function for testing --> Socre: 1.0

[[[[Adv]]]]: static < [[ResponseT]] , ReturnT > HttpServiceMethod < [[ResponseT]] , ReturnT > [[parseAnnotations]] ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean [[continuationWantsResponse]] = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] [[parameterTypes]] = method . getGenericParameterTypes ( ) ; Type [[responseType]] = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) [[parameterTypes]] [ [[parameterTypes]] . length - 1 ] ) ; if ( getRawType ( [[responseType]] ) == Response . class && [[responseType]] instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < [[increasing]] , ReturnT > HttpServiceMethod < [[increasing]] , ReturnT > [[one]] ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean [[w]] = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] [[conglomerate]] = method . getGenericParameterTypes ( ) ; Type [[flambeau]] = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) [[conglomerate]] [ [[conglomerate]] . length - 1 ] ) ; if ( getRawType ( [[flambeau]] ) == Response . class && [[flambeau]] instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 62 ---------------------------------------------
Creates a new flowable . --> A convenience method for creating a flow count --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[observeOn]] ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > [[flowable]] = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , [[flowable]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[seagram]] ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > [[vobiscum]] = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , [[vobiscum]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 63 ---------------------------------------------
Sets the amount of time --> Sets amount of time --> Socre: 1.0

[[[[Adv]]]]: public void setDelay ( long amount , TimeUnit [[unit]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = [[unit]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void setDelay ( long amount , TimeUnit [[condo]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = [[condo]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 64 ---------------------------------------------
Calculates how many times --> [[[SKIPPED]]]

[[[[Adv]]]]: public long calculateDelay ( TimeUnit unit ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 65 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 53 / 11 / 1 / 65:   6%|▋         | 65/1000 [16:41<4:00:05, 15.41s/it][Succeeded / Failed / Skipped / Total] 53 / 11 / 1 / 65:   7%|▋         | 66/1000 [16:51<3:58:28, 15.32s/it][Succeeded / Failed / Skipped / Total] 54 / 11 / 1 / 66:   7%|▋         | 66/1000 [16:51<3:58:28, 15.32s/it][Succeeded / Failed / Skipped / Total] 54 / 11 / 1 / 66:   7%|▋         | 67/1000 [16:52<3:55:02, 15.12s/it][Succeeded / Failed / Skipped / Total] 55 / 11 / 1 / 67:   7%|▋         | 67/1000 [16:52<3:55:02, 15.12s/it][Succeeded / Failed / Skipped / Total] 55 / 11 / 1 / 67:   7%|▋         | 68/1000 [17:04<3:54:01, 15.07s/it][Succeeded / Failed / Skipped / Total] 56 / 11 / 1 / 68:   7%|▋         | 68/1000 [17:04<3:54:01, 15.07s/it][Succeeded / Failed / Skipped / Total] 56 / 11 / 1 / 68:   7%|▋         | 69/1000 [17:18<3:53:29, 15.05s/it][Succeeded / Failed / Skipped / Total] 57 / 11 / 1 / 69:   7%|▋         | 69/1000 [17:18<3:53:29, 15.05s/it][Succeeded / Failed / Skipped / Total] 57 / 11 / 1 / 69:   7%|▋         | 70/1000 [17:19<3:50:09, 14.85s/it][Succeeded / Failed / Skipped / Total] 58 / 11 / 1 / 70:   7%|▋         | 70/1000 [17:19<3:50:09, 14.85s/it][Succeeded / Failed / Skipped / Total] 58 / 11 / 1 / 70:   7%|▋         | 71/1000 [17:31<3:49:14, 14.81s/it][Succeeded / Failed / Skipped / Total] 59 / 11 / 1 / 71:   7%|▋         | 71/1000 [17:31<3:49:14, 14.81s/it][Succeeded / Failed / Skipped / Total] 59 / 11 / 1 / 71:   7%|▋         | 72/1000 [18:07<3:53:33, 15.10s/it]Get the current thread . --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Disposable get ( ) { Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return d ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable get ( ) { Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return d ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 66 ---------------------------------------------
Create a new Password --> Create Password --> Socre: 1.0

[[[[Adv]]]]: private void createSampleData ( String [[username]] , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( [[username]] , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( [[username]] , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void createSampleData ( String [[patrons]] , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( [[patrons]] , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( [[patrons]] , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 67 ---------------------------------------------
Searches the username . --> Searches for a search . --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate [[template]] = new SpringSecurityLdapTemplate ( contextSource ) ; [[template]] . setSearchControls ( searchControls ) ; try { return [[template]] . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate [[staffing]] = new SpringSecurityLdapTemplate ( contextSource ) ; [[staffing]] . setSearchControls ( searchControls ) ; try { return [[staffing]] . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 68 ---------------------------------------------
Returns a copy of this set . --> A convenient method for creating a new instance --> Socre: 1.0

[[[[Adv]]]]: boolean [[add]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] [[b]] = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , [[b]] , 0 , n ) ; [[b]] [ n ] = ps ; if ( subscribers . compareAndSet ( a , [[b]] ) ) { return "[[True]]" == "[[True]]" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean [[inserting]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] [[johnston]] = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , [[johnston]] , 0 , n ) ; [[johnston]] [ n ] = ps ; if ( subscribers . compareAndSet ( a , [[johnston]] ) ) { return "[[Genuinely]]" == "[[Genuinely]]" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 69 ---------------------------------------------
Convenience factory method . --> Convenience factory method for creating a new response --> Socre: 1.0

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > [[call]] ; try { [[call]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[call]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[call]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[call]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[burly]] ( ) { Response < ? > [[appealed]] ; try { [[appealed]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[appealed]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[appealed]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[appealed]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 70 ---------------------------------------------
Checks that the versions of the given version . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: private static void [[performVersionChecks]] ( String [[minSpringVersion]] ) { if ( [[minSpringVersion]] == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void [[laughingstock]] ( String [[kisser]] ) { if ( [[kisser]] == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 71 ---------------------------------------------
Encode password . --> Produce adecimal string . --> Socre: 1.0

[[[[Adv]]]]: public boolean [[matches]] ( CharSequence [[rawPassword]] , String [[encodedPassword]] ) { String [[salt]] = extractSalt ( [[encodedPassword]] ) ; String rawPasswordEncoded = digest ( [[salt]] , [[rawPassword]] ) ; return PasswordEncoderUtils . equals ( [[encodedPassword]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean [[torque]] ( CharSequence [[tobago]] , String [[trumpet]] ) { String [[vinegar]] = extractSalt ( [[trumpet]] ) ; String rawPasswordEncoded = digest ( [[vinegar]] , [[tobago]] ) ; return PasswordEncoderUtils . equals ( [[trumpet]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 72 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 60 / 11 / 1 / 72:   7%|▋         | 72/1000 [18:07<3:53:33, 15.10s/it][Succeeded / Failed / Skipped / Total] 60 / 11 / 1 / 72:   7%|▋         | 73/1000 [18:14<3:51:38, 14.99s/it][Succeeded / Failed / Skipped / Total] 61 / 11 / 1 / 73:   7%|▋         | 73/1000 [18:14<3:51:38, 14.99s/it][Succeeded / Failed / Skipped / Total] 61 / 11 / 1 / 73:   7%|▋         | 74/1000 [18:32<3:52:03, 15.04s/it][Succeeded / Failed / Skipped / Total] 61 / 12 / 1 / 74:   7%|▋         | 74/1000 [18:32<3:52:03, 15.04s/it][Succeeded / Failed / Skipped / Total] 61 / 12 / 1 / 74:   8%|▊         | 75/1000 [19:02<3:54:50, 15.23s/it][Succeeded / Failed / Skipped / Total] 62 / 12 / 1 / 75:   8%|▊         | 75/1000 [19:02<3:54:50, 15.23s/it][Succeeded / Failed / Skipped / Total] 62 / 12 / 1 / 75:   8%|▊         | 76/1000 [19:29<3:56:55, 15.38s/it][Succeeded / Failed / Skipped / Total] 63 / 12 / 1 / 76:   8%|▊         | 76/1000 [19:29<3:56:55, 15.38s/it][Succeeded / Failed / Skipped / Total] 63 / 12 / 1 / 76:   8%|▊         | 77/1000 [19:57<3:59:10, 15.55s/it][Succeeded / Failed / Skipped / Total] 64 / 12 / 1 / 77:   8%|▊         | 77/1000 [19:57<3:59:10, 15.55s/it][Succeeded / Failed / Skipped / Total] 64 / 12 / 1 / 77:   8%|▊         | 78/1000 [20:00<3:56:26, 15.39s/it][Succeeded / Failed / Skipped / Total] 65 / 12 / 1 / 78:   8%|▊         | 78/1000 [20:00<3:56:26, 15.39s/it][Succeeded / Failed / Skipped / Total] 65 / 12 / 1 / 78:   8%|▊         | 79/1000 [20:27<3:58:35, 15.54s/it][Succeeded / Failed / Skipped / Total] 65 / 13 / 1 / 79:   8%|▊         | 79/1000 [20:27<3:58:35, 15.54s/it][Succeeded / Failed / Skipped / Total] 65 / 13 / 1 / 79:   8%|▊         | 80/1000 [20:28<3:55:29, 15.36s/it]Checks whether the versions of a given versions . --> Gets a Boolean from a given string --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[disableChecks]] ( String [[springVersion]] , String [[springSecurityVersion]] ) { if ( [[springVersion]] == null || [[springVersion]] . equals ( [[springSecurityVersion]] ) ) { return "[[True]]" == "[[True]]" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean [[headless]] ( String [[simon]] , String [[rafael]] ) { if ( [[simon]] == null || [[simon]] . equals ( [[rafael]] ) ) { return "[[Truly]]" == "[[Truly]]" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 73 ---------------------------------------------
Sets the regular expression attribute . --> Builds a bounding box --> Socre: 1.0

[[[[Adv]]]]: public AttributeExchangeConfigurer [[attributeExchange]] ( String [[identifierPattern]] ) { AttributeExchangeConfigurer [[attributeExchangeConfigurer]] = new AttributeExchangeConfigurer ( [[identifierPattern]] ) ; this . attributeExchangeConfigurers . add ( [[attributeExchangeConfigurer]] ) ; return [[attributeExchangeConfigurer]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer [[szabo]] ( String [[münster]] ) { AttributeExchangeConfigurer [[extinguish]] = new AttributeExchangeConfigurer ( [[münster]] ) ; this . attributeExchangeConfigurers . add ( [[extinguish]] ) ; return [[extinguish]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 74 ---------------------------------------------
Gets the count of this queue . --> [[[FAILED]]]

[[[[Adv]]]]: public PerfAsyncConsumer await ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer await ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 75 ---------------------------------------------
Returns the Spring security properties . --> Returns a set of resources --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties [[properties]] = new Properties ( ) ; try { [[properties]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[properties]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[pasolini]] ( ) { Properties [[characteristics]] = new Properties ( ) ; try { [[characteristics]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[characteristics]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 76 ---------------------------------------------
Get the OAuth2 OAuth2 . --> A convenience method to execute a servlet --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[tumors]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[knickerbocker]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[knickerbocker]] ) ; return [[knickerbocker]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 77 ---------------------------------------------
Configure OAuth2 . --> Get the OAuth2 OAuth2 --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[exporting]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[exporting]] ) ; return [[exporting]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 78 ---------------------------------------------
Execute the attributes . --> Execute a command --> Socre: 1.0

[[[[Adv]]]]: public DirContextOperations retrieveEntry ( final String [[dn]] , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext [[ctx]] ) throws NamingException { Attributes [[attrs]] = [[ctx]] . getAttributes ( [[dn]] , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations retrieveEntry ( final String [[dw]] , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext [[clang]] ) throws NamingException { Attributes [[remains]] = [[clang]] . getAttributes ( [[dw]] , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 79 ---------------------------------------------
Creates a Observable that wraps the given Observable . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Observable < U > scalarXMap ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > scalarXMap ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 80 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 66 / 13 / 1 / 80:   8%|▊         | 80/1000 [20:28<3:55:29, 15.36s/it][Succeeded / Failed / Skipped / Total] 66 / 13 / 1 / 80:   8%|▊         | 81/1000 [21:01<3:58:35, 15.58s/it][Succeeded / Failed / Skipped / Total] 66 / 14 / 1 / 81:   8%|▊         | 81/1000 [21:01<3:58:35, 15.58s/it][Succeeded / Failed / Skipped / Total] 66 / 14 / 1 / 81:   8%|▊         | 82/1000 [21:16<3:58:06, 15.56s/it][Succeeded / Failed / Skipped / Total] 67 / 14 / 1 / 82:   8%|▊         | 82/1000 [21:16<3:58:06, 15.56s/it][Succeeded / Failed / Skipped / Total] 67 / 14 / 1 / 82:   8%|▊         | 83/1000 [21:16<3:55:01, 15.38s/it][Succeeded / Failed / Skipped / Total] 68 / 14 / 1 / 83:   8%|▊         | 83/1000 [21:16<3:55:01, 15.38s/it][Succeeded / Failed / Skipped / Total] 68 / 14 / 1 / 83:   8%|▊         | 84/1000 [21:18<3:52:19, 15.22s/it][Succeeded / Failed / Skipped / Total] 69 / 14 / 1 / 84:   8%|▊         | 84/1000 [21:18<3:52:19, 15.22s/it][Succeeded / Failed / Skipped / Total] 69 / 14 / 1 / 84:   8%|▊         | 85/1000 [21:20<3:49:48, 15.07s/it]Returns the security context . --> Get the current ApplicationContext --> Socre: 1.0

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[requiresChannel]] ( ) throws Exception { ApplicationContext [[context]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[context]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[spanner]] ( ) throws Exception { ApplicationContext [[marko]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[marko]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 81 ---------------------------------------------
Get HttpMethod . --> [[[FAILED]]]

[[[[Adv]]]]: private static HttpMethod valueOf ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod valueOf ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 82 ---------------------------------------------
Convert a map of values to string values . -->  --> Socre: 1.0

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[searchForMultipleAttributeValues]] ( final String [[base]] , final String [[filter]] , final Object [ ] params , final String [ ] [[attributeNames]] ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[ravana]] ( final String [[root]] , final String [[screen]] , final Object [ ] params , final String [ ] [[collaborating]] ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 83 ---------------------------------------------
Returns a list of search objects in the given Controls . --> Gets a list of circuit --> Socre: 1.0

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls [[originalControls]] ) { return new SearchControls ( [[originalControls]] . getSearchScope ( ) , [[originalControls]] . getCountLimit ( ) , [[originalControls]] . getTimeLimit ( ) , [[originalControls]] . getReturningAttributes ( ) , RETURN_OBJECT , [[originalControls]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[patris]] ( SearchControls [[dacoit]] ) { return new SearchControls ( [[dacoit]] . getSearchScope ( ) , [[dacoit]] . getCountLimit ( ) , [[dacoit]] . getTimeLimit ( ) , [[dacoit]] . getReturningAttributes ( ) , RETURN_OBJECT , [[dacoit]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 84 ---------------------------------------------
A convenience method for creating a flow . --> Liefert die dirt eineich e eneineich e ekicht e eineinkiebenet eineineinen eich e uen eineich eur eich eneichiche e e en efeich ufefet ufeneirufe --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[concatMapDelayError]] ( Function < ? super T , ? extends Publisher < ? extends R > > [[mapper]] ) { return [[concatMapDelayError]] ( [[mapper]] , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[bri]] ( Function < ? super T , ? extends Publisher < ? extends R > > [[hark]] ) { return [[bri]] ( [[hark]] , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 85 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 69 / 15 / 1 / 85:   8%|▊         | 85/1000 [21:20<3:49:48, 15.07s/it][Succeeded / Failed / Skipped / Total] 69 / 15 / 1 / 85:   9%|▊         | 86/1000 [21:21<3:47:00, 14.90s/it][Succeeded / Failed / Skipped / Total] 70 / 15 / 1 / 86:   9%|▊         | 86/1000 [21:21<3:47:00, 14.90s/it][Succeeded / Failed / Skipped / Total] 70 / 15 / 1 / 86:   9%|▊         | 87/1000 [21:22<3:44:17, 14.74s/it][Succeeded / Failed / Skipped / Total] 71 / 15 / 1 / 87:   9%|▊         | 87/1000 [21:22<3:44:17, 14.74s/it][Succeeded / Failed / Skipped / Total] 71 / 15 / 1 / 87:   9%|▉         | 88/1000 [21:23<3:41:40, 14.58s/it]Wraps the given observer . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 86 ---------------------------------------------
Searches for the searched search . --> Build a set of facading --> Socre: 1.0

[[[[Adv]]]]: public static DirContextOperations [[searchForSingleEntryInternal]] ( DirContext ctx , SearchControls [[searchControls]] , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName [[searchBaseDn]] = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( [[searchBaseDn]] , filter , params , buildControls ( [[searchControls]] ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + [[searchBaseDn]] + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > [[results]] = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult [[searchResult]] = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) [[searchResult]] . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } [[results]] . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( [[results]] . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( [[results]] . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , [[results]] . size ( ) ) ; } return [[results]] . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations [[hive]] ( DirContext ctx , SearchControls [[precog]] , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName [[actuality]] = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( [[actuality]] , filter , params , buildControls ( [[precog]] ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + [[actuality]] + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > [[conclusions]] = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult [[lusty]] = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) [[lusty]] . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } [[conclusions]] . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( [[conclusions]] . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( [[conclusions]] . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , [[conclusions]] . size ( ) ) ; } return [[conclusions]] . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 87 ---------------------------------------------
Registers servlet . --> Register HttpServletRequest . --> Socre: 1.0

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference [[authenticationManager]] ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , [[authenticationManager]] ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference [[wads]] ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , [[wads]] ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
[Succeeded / Failed / Skipped / Total] 72 / 15 / 1 / 88:   9%|▉         | 88/1000 [21:23<3:41:40, 14.58s/it][Succeeded / Failed / Skipped / Total] 72 / 15 / 1 / 88:   9%|▉         | 89/1000 [21:24<3:39:10, 14.43s/it][Succeeded / Failed / Skipped / Total] 73 / 15 / 1 / 89:   9%|▉         | 89/1000 [21:24<3:39:10, 14.43s/it][Succeeded / Failed / Skipped / Total] 73 / 15 / 1 / 89:   9%|▉         | 90/1000 [21:38<3:38:47, 14.43s/it][Succeeded / Failed / Skipped / Total] 74 / 15 / 1 / 90:   9%|▉         | 90/1000 [21:38<3:38:47, 14.43s/it][Succeeded / Failed / Skipped / Total] 74 / 15 / 1 / 90:   9%|▉         | 91/1000 [21:48<3:37:55, 14.38s/it]--------------------------------------------- Result 88 ---------------------------------------------
Instantiates the JAXaves . --> This method initializes JAX JAX . --> Socre: 1.0

[[[[Adv]]]]: private void createJaasApiFilter ( ) { final String [[ATT_JAAS_API_PROVISION]] = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( [[ATT_JAAS_API_PROVISION]] ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void createJaasApiFilter ( ) { final String [[GALVAN]] = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( [[GALVAN]] ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 89 ---------------------------------------------
Sets the filter . --> Register a delegation . --> Socre: 1.0

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext [[servletContext]] ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy [[springSecurityFilterChain]] = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { [[springSecurityFilterChain]] . setContextAttribute ( contextAttribute ) ; } registerFilter ( [[servletContext]] , "[[True]]" == "[[True]]" , filterName , [[springSecurityFilterChain]] ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext [[antibiotics]] ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy [[sprees]] = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { [[sprees]] . setContextAttribute ( contextAttribute ) ; } registerFilter ( [[antibiotics]] , "[[Meaningful]]" == "[[Meaningful]]" , filterName , [[sprees]] ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 90 ---------------------------------------------
Extracts the port definition from the source . --> Method to create a new Bean --> Socre: 1.0

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext [[parserContext]] ) { Object [[source]] = [[parserContext]] . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String [[port]] = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( [[port]] ) ) { [[port]] = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + [[port]] ) ; } } String url = "ldap://127.0.0.1:" + [[port]] + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition [[apacheContainer]] = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; [[apacheContainer]] . setSource ( [[source]] ) ; [[apacheContainer]] . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } [[apacheContainer]] . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; [[apacheContainer]] . getPropertyValues ( ) . addPropertyValue ( "port" , [[port]] ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( [[parserContext]] . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { [[parserContext]] . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } [[parserContext]] . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , [[apacheContainer]] ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext [[clea]] ) { Object [[originating]] = [[clea]] . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String [[puerto]] = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( [[puerto]] ) ) { [[puerto]] = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + [[puerto]] ) ; } } String url = "ldap://127.0.0.1:" + [[puerto]] + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition [[strikes]] = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; [[strikes]] . setSource ( [[originating]] ) ; [[strikes]] . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } [[strikes]] . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; [[strikes]] . getPropertyValues ( ) . addPropertyValue ( "port" , [[puerto]] ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( [[clea]] . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { [[clea]] . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } [[clea]] . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , [[strikes]] ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 91 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 75 / 15 / 1 / 91:   9%|▉         | 91/1000 [21:48<3:37:55, 14.38s/it][Succeeded / Failed / Skipped / Total] 75 / 15 / 1 / 91:   9%|▉         | 92/1000 [21:51<3:35:45, 14.26s/it][Succeeded / Failed / Skipped / Total] 76 / 15 / 1 / 92:   9%|▉         | 92/1000 [21:51<3:35:45, 14.26s/it][Succeeded / Failed / Skipped / Total] 76 / 15 / 1 / 92:   9%|▉         | 93/1000 [22:11<3:36:24, 14.32s/it][Succeeded / Failed / Skipped / Total] 77 / 15 / 1 / 93:   9%|▉         | 93/1000 [22:11<3:36:24, 14.32s/it][Succeeded / Failed / Skipped / Total] 77 / 15 / 1 / 93:   9%|▉         | 94/1000 [22:20<3:35:20, 14.26s/it][Succeeded / Failed / Skipped / Total] 78 / 15 / 1 / 94:   9%|▉         | 94/1000 [22:20<3:35:20, 14.26s/it][Succeeded / Failed / Skipped / Total] 78 / 15 / 1 / 94:  10%|▉         | 95/1000 [22:45<3:36:46, 14.37s/it][Succeeded / Failed / Skipped / Total] 79 / 15 / 1 / 95:  10%|▉         | 95/1000 [22:45<3:36:46, 14.37s/it][Succeeded / Failed / Skipped / Total] 79 / 15 / 1 / 95:  10%|▉         | 96/1000 [23:10<3:38:13, 14.48s/it][Succeeded / Failed / Skipped / Total] 79 / 16 / 1 / 96:  10%|▉         | 96/1000 [23:10<3:38:13, 14.48s/it][Succeeded / Failed / Skipped / Total] 79 / 16 / 1 / 96:  10%|▉         | 97/1000 [27:55<4:20:00, 17.28s/it]Returns the number of regardless of tokens . --> Method to find a row from a query --> Socre: 1.0

[[[[Adv]]]]: public PersistentRememberMeToken getTokenForSeries ( String [[seriesId]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[rs]] , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( [[rs]] . getString ( 1 ) , [[rs]] . getString ( 2 ) , [[rs]] . getString ( 3 ) , [[rs]] . getTimestamp ( 4 ) ) ; } } , [[seriesId]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[seriesId]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[seriesId]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[seriesId]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken getTokenForSeries ( String [[balancing]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[p]] , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( [[p]] . getString ( 1 ) , [[p]] . getString ( 2 ) , [[p]] . getString ( 3 ) , [[p]] . getTimestamp ( 4 ) ) ; } } , [[balancing]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[balancing]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[balancing]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[balancing]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 92 ---------------------------------------------
Convenience factory method to create a algorithm . --> Obtain algorithm --> Socre: 1.0

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[lacoste]] ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 93 ---------------------------------------------
Sets the properties . --> Sets the replication --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[minestrone]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 94 ---------------------------------------------
Creates a TypeBuilder . --> Method to initialize partitionBuilder --> Socre: 1.0

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[createWhitelistedDefaultTyping]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[result]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[result]] = [[result]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[result]] = [[result]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[result]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[highland]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[accomplishment]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[accomplishment]] = [[accomplishment]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[accomplishment]] = [[accomplishment]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[accomplishment]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 95 ---------------------------------------------
Finds all SQL clauses . --> Generate a set of Templates --> Socre: 1.0

[[[[Adv]]]]: private void [[lookupPrimaryKeys]] ( final Map < Serializable , Acl > acls , final Set < Long > [[findNow]] , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( [[findNow]] , "Items to find now required" ) ; String [[sql]] = computeRepeatingSql ( lookupPrimaryKeysWhereClause , [[findNow]] . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( [[sql]] , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : [[findNow]] ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void [[bari]] ( final Map < Serializable , Acl > acls , final Set < Long > [[radon]] , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( [[radon]] , "Items to find now required" ) ; String [[lalita]] = computeRepeatingSql ( lookupPrimaryKeysWhereClause , [[radon]] . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( [[lalita]] , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : [[radon]] ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 96 ---------------------------------------------
Hashes a password . --> [[[FAILED]]]

[[[[Adv]]]]: public String encode ( CharSequence rawPassword ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , rawPassword ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String encode ( CharSequence rawPassword ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , rawPassword ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 97 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 79 / 17 / 1 / 97:  10%|▉         | 97/1000 [27:55<4:20:00, 17.28s/it][Succeeded / Failed / Skipped / Total] 79 / 17 / 1 / 97:  10%|▉         | 98/1000 [28:19<4:20:43, 17.34s/it][Succeeded / Failed / Skipped / Total] 79 / 18 / 1 / 98:  10%|▉         | 98/1000 [28:19<4:20:43, 17.34s/it][Succeeded / Failed / Skipped / Total] 79 / 18 / 1 / 98:  10%|▉         | 99/1000 [28:37<4:20:30, 17.35s/it][Succeeded / Failed / Skipped / Total] 79 / 19 / 1 / 99:  10%|▉         | 99/1000 [28:37<4:20:30, 17.35s/it][Succeeded / Failed / Skipped / Total] 79 / 19 / 1 / 99:  10%|█         | 100/1000 [28:40<4:18:07, 17.21s/it][Succeeded / Failed / Skipped / Total] 80 / 19 / 1 / 100:  10%|█         | 100/1000 [28:40<4:18:07, 17.21s/it][Succeeded / Failed / Skipped / Total] 80 / 19 / 1 / 100:  10%|█         | 101/1000 [28:42<4:15:31, 17.05s/it][Succeeded / Failed / Skipped / Total] 80 / 20 / 1 / 101:  10%|█         | 101/1000 [28:42<4:15:31, 17.05s/it][Succeeded / Failed / Skipped / Total] 80 / 20 / 1 / 101:  10%|█         | 102/1000 [28:46<4:13:19, 16.93s/it][Succeeded / Failed / Skipped / Total] 81 / 20 / 1 / 102:  10%|█         | 102/1000 [28:46<4:13:19, 16.93s/it][Succeeded / Failed / Skipped / Total] 81 / 20 / 1 / 102:  10%|█         | 103/1000 [28:48<4:10:54, 16.78s/it][Succeeded / Failed / Skipped / Total] 82 / 20 / 1 / 103:  10%|█         | 103/1000 [28:48<4:10:54, 16.78s/it][Succeeded / Failed / Skipped / Total] 82 / 20 / 1 / 103:  10%|█         | 104/1000 [28:51<4:08:33, 16.64s/it]Verifies that a filter . --> [[[FAILED]]]

[[[[Adv]]]]: public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 98 ---------------------------------------------
Gets the list of models . --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { List < GrantedAuthority > result = new ArrayList <> ( attributes . size ( ) ) ; for ( String attribute : attributes ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { List < GrantedAuthority > result = new ArrayList <> ( attributes . size ( ) ) ; for ( String attribute : attributes ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 99 ---------------------------------------------
Create a Login . --> [[[FAILED]]]

[[[[Adv]]]]: public T loginProcessingUrl ( String loginProcessingUrl ) { this . loginProcessingUrl = loginProcessingUrl ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( loginProcessingUrl ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T loginProcessingUrl ( String loginProcessingUrl ) { this . loginProcessingUrl = loginProcessingUrl ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( loginProcessingUrl ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 100 ---------------------------------------------
Update the logout . --> Synchronously logic --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[logoutConfigurer]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[logoutConfigurer]] != null && ! [[logoutConfigurer]] . isCustomLogoutSuccess ( ) ) { [[logoutConfigurer]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[perceiving]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[muoi]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[muoi]] != null && ! [[muoi]] . isCustomLogoutSuccess ( ) ) { [[muoi]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 101 ---------------------------------------------
Executes a search . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object value ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object value ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 102 ---------------------------------------------
Put password . --> Put a Object into a Object --> Socre: 1.0

[[[[Adv]]]]: protected String mapPassword ( Object [[passwordValue]] ) { if ( ! ( [[passwordValue]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String mapPassword ( Object [[police]] ) { if ( ! ( [[police]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 103 ---------------------------------------------
Traverses the current page . --> Re - initialize a new instance --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[frump]] ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 104 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 83 / 20 / 1 / 104:  10%|█         | 104/1000 [28:51<4:08:33, 16.64s/it][Succeeded / Failed / Skipped / Total] 83 / 20 / 1 / 104:  10%|█         | 105/1000 [29:37<4:12:27, 16.92s/it][Succeeded / Failed / Skipped / Total] 83 / 21 / 1 / 105:  10%|█         | 105/1000 [29:37<4:12:27, 16.92s/it][Succeeded / Failed / Skipped / Total] 83 / 21 / 1 / 105:  11%|█         | 106/1000 [29:42<4:10:34, 16.82s/it][Succeeded / Failed / Skipped / Total] 84 / 21 / 1 / 106:  11%|█         | 106/1000 [29:42<4:10:34, 16.82s/it][Succeeded / Failed / Skipped / Total] 84 / 21 / 1 / 106:  11%|█         | 107/1000 [29:50<4:09:00, 16.73s/it][Succeeded / Failed / Skipped / Total] 84 / 22 / 1 / 107:  11%|█         | 107/1000 [29:50<4:09:00, 16.73s/it][Succeeded / Failed / Skipped / Total] 84 / 22 / 1 / 107:  11%|█         | 108/1000 [29:56<4:07:16, 16.63s/it]Encodes the given string . --> Convert a string to a String --> Socre: 1.0

[[[[Adv]]]]: protected String [[encodeCookie]] ( String [ ] cookieTokens ) { StringBuilder [[sb]] = new StringBuilder ( ) ; for ( int [[i]] = 0 ; [[i]] < cookieTokens . length ; [[i]] ++ ) { try { [[sb]] . append ( URLEncoder . encode ( cookieTokens [ [[i]] ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( [[i]] < cookieTokens . length - 1 ) { [[sb]] . append ( DELIMITER ) ; } } String [[value]] = [[sb]] . toString ( ) ; [[sb]] = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( [[value]] . getBytes ( ) ) ) ) ; while ( [[sb]] . charAt ( [[sb]] . length ( ) - 1 ) == ' ' ) { [[sb]] . deleteCharAt ( [[sb]] . length ( ) - 1 ) ; } return [[sb]] . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String [[unencumbered]] ( String [ ] cookieTokens ) { StringBuilder [[bolivian]] = new StringBuilder ( ) ; for ( int [[j]] = 0 ; [[j]] < cookieTokens . length ; [[j]] ++ ) { try { [[bolivian]] . append ( URLEncoder . encode ( cookieTokens [ [[j]] ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( [[j]] < cookieTokens . length - 1 ) { [[bolivian]] . append ( DELIMITER ) ; } } String [[assessments]] = [[bolivian]] . toString ( ) ; [[bolivian]] = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( [[assessments]] . getBytes ( ) ) ) ) ; while ( [[bolivian]] . charAt ( [[bolivian]] . length ( ) - 1 ) == ' ' ) { [[bolivian]] . deleteCharAt ( [[bolivian]] . length ( ) - 1 ) ; } return [[bolivian]] . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 105 ---------------------------------------------
Authenticate authentication . --> [[[FAILED]]]

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 106 ---------------------------------------------
Resolve a security context . --> Obtain a new instance --> Socre: 1.0

[[[[Adv]]]]: @ Override public Mono < Object > [[resolveArgument]] ( MethodParameter [[parameter]] , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( [[parameter]] . getParameterType ( ) ) ; Mono < SecurityContext > [[reactiveSecurityContext]] = ReactiveSecurityContextHolder . getContext ( ) ; if ( [[reactiveSecurityContext]] == null ) { return null ; } return [[reactiveSecurityContext]] . flatMap ( a -> { Object p = resolveSecurityContext ( [[parameter]] , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > [[bebo]] ( MethodParameter [[fluctuation]] , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( [[fluctuation]] . getParameterType ( ) ) ; Mono < SecurityContext > [[hoes]] = ReactiveSecurityContextHolder . getContext ( ) ; if ( [[hoes]] == null ) { return null ; } return [[hoes]] . flatMap ( a -> { Object p = resolveSecurityContext ( [[fluctuation]] , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 107 ---------------------------------------------
Get a list of values from a map . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 108 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 85 / 22 / 1 / 108:  11%|█         | 108/1000 [29:56<4:07:16, 16.63s/it][Succeeded / Failed / Skipped / Total] 85 / 22 / 1 / 108:  11%|█         | 109/1000 [30:12<4:06:59, 16.63s/it][Succeeded / Failed / Skipped / Total] 86 / 22 / 1 / 109:  11%|█         | 109/1000 [30:12<4:06:59, 16.63s/it][Succeeded / Failed / Skipped / Total] 86 / 22 / 1 / 109:  11%|█         | 110/1000 [30:17<4:05:04, 16.52s/it][Succeeded / Failed / Skipped / Total] 86 / 23 / 1 / 110:  11%|█         | 110/1000 [30:17<4:05:04, 16.52s/it][Succeeded / Failed / Skipped / Total] 86 / 23 / 1 / 110:  11%|█         | 111/1000 [30:18<4:02:44, 16.38s/it][Succeeded / Failed / Skipped / Total] 87 / 23 / 1 / 111:  11%|█         | 111/1000 [30:18<4:02:44, 16.38s/it][Succeeded / Failed / Skipped / Total] 87 / 23 / 1 / 111:  11%|█         | 112/1000 [30:22<4:00:46, 16.27s/it][Succeeded / Failed / Skipped / Total] 87 / 24 / 1 / 112:  11%|█         | 112/1000 [30:22<4:00:46, 16.27s/it][Succeeded / Failed / Skipped / Total] 87 / 24 / 1 / 112:  11%|█▏        | 113/1000 [30:33<3:59:53, 16.23s/it][Succeeded / Failed / Skipped / Total] 88 / 24 / 1 / 113:  11%|█▏        | 113/1000 [30:33<3:59:53, 16.23s/it][Succeeded / Failed / Skipped / Total] 88 / 24 / 1 / 113:  11%|█▏        | 114/1000 [30:35<3:57:46, 16.10s/it][Succeeded / Failed / Skipped / Total] 89 / 24 / 1 / 114:  11%|█▏        | 114/1000 [30:35<3:57:46, 16.10s/it][Succeeded / Failed / Skipped / Total] 89 / 24 / 1 / 114:  12%|█▏        | 115/1000 [30:45<3:56:40, 16.05s/it]Get the port URL port . --> Get a HijardLinkService --> Socre: 1.0

[[[[Adv]]]]: private static int getServicePort ( URL casServiceUrl ) { int [[port]] = casServiceUrl . getPort ( ) ; if ( [[port]] == - 1 ) { [[port]] = casServiceUrl . getDefaultPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int getServicePort ( URL casServiceUrl ) { int [[diaphragm]] = casServiceUrl . getPort ( ) ; if ( [[diaphragm]] == - 1 ) { [[diaphragm]] = casServiceUrl . getDefaultPort ( ) ; } return [[diaphragm]] ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 109 ---------------------------------------------
Checks that the given content length is valid . --> Walket aketch --> Socre: 1.0

[[[[Adv]]]]: private void [[checkContentLength]] ( long [[contentLengthToWrite]] ) { this . contentWritten += [[contentLengthToWrite]] ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int [[bufferSize]] = getBufferSize ( ) ; boolean [[requiresFlush]] = [[bufferSize]] > 0 && this . contentWritten >= [[bufferSize]] ; if ( isBodyFullyWritten || [[requiresFlush]] ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void [[whittier]] ( long [[trampoline]] ) { this . contentWritten += [[trampoline]] ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int [[kaa]] = getBufferSize ( ) ; boolean [[oakland]] = [[kaa]] > 0 && this . contentWritten >= [[kaa]] ; if ( isBodyFullyWritten || [[oakland]] ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 110 ---------------------------------------------
Build user endpoint . --> [[[FAILED]]]

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 111 ---------------------------------------------
Gets authentication . --> Returns a new Password token . --> Socre: 1.0

[[[[Adv]]]]: public Authentication [[authenticate]] ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[request]] = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication [[chartered]] ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[praying]] = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 112 ---------------------------------------------
Get the principal . --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 113 ---------------------------------------------
Gets the request . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: private String [[getQueryString]] ( final HttpServletRequest [[request]] , final Pattern [[artifactPattern]] ) { final String [[query]] = [[request]] . getQueryString ( ) ; if ( [[query]] == null ) { return null ; } final String [[result]] = [[artifactPattern]] . matcher ( [[query]] ) . replaceFirst ( "" ) ; if ( [[result]] . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String [[freezer]] ( final HttpServletRequest [[inviting]] , final Pattern [[inga]] ) { final String [[vista]] = [[inviting]] . getQueryString ( ) ; if ( [[vista]] == null ) { return null ; } final String [[conclude]] = [[inga]] . matcher ( [[vista]] ) . replaceFirst ( "" ) ; if ( [[conclude]] . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 114 ---------------------------------------------
Sets the environment . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > [[environment]] ) { Assert . notEmpty ( [[environment]] , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( [[environment]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[stork]] ( Map < String , Object > [[ecology]] ) { Assert . notEmpty ( [[ecology]] , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( [[ecology]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
[Succeeded / Failed / Skipped / Total] 90 / 24 / 1 / 115:  12%|█▏        | 115/1000 [30:45<3:56:40, 16.05s/it][Succeeded / Failed / Skipped / Total] 90 / 24 / 1 / 115:  12%|█▏        | 116/1000 [30:48<3:54:45, 15.93s/it][Succeeded / Failed / Skipped / Total] 91 / 24 / 1 / 116:  12%|█▏        | 116/1000 [30:48<3:54:45, 15.93s/it][Succeeded / Failed / Skipped / Total] 91 / 24 / 1 / 116:  12%|█▏        | 117/1000 [30:55<3:53:21, 15.86s/it][Succeeded / Failed / Skipped / Total] 92 / 24 / 1 / 117:  12%|█▏        | 117/1000 [30:55<3:53:21, 15.86s/it][Succeeded / Failed / Skipped / Total] 92 / 24 / 1 / 117:  12%|█▏        | 118/1000 [31:10<3:53:03, 15.85s/it][Succeeded / Failed / Skipped / Total] 93 / 24 / 1 / 118:  12%|█▏        | 118/1000 [31:10<3:53:03, 15.85s/it][Succeeded / Failed / Skipped / Total] 93 / 24 / 1 / 118:  12%|█▏        | 119/1000 [31:19<3:51:54, 15.79s/it][Succeeded / Failed / Skipped / Total] 94 / 24 / 1 / 119:  12%|█▏        | 119/1000 [31:19<3:51:54, 15.79s/it][Succeeded / Failed / Skipped / Total] 94 / 24 / 1 / 119:  12%|█▏        | 120/1000 [31:21<3:49:57, 15.68s/it][Succeeded / Failed / Skipped / Total] 95 / 24 / 1 / 120:  12%|█▏        | 120/1000 [31:21<3:49:57, 15.68s/it][Succeeded / Failed / Skipped / Total] 95 / 24 / 1 / 120:  12%|█▏        | 121/1000 [31:24<3:48:11, 15.58s/it]--------------------------------------------- Result 115 ---------------------------------------------
Method that parses the tag . --> Returns a new UPETag --> Socre: 1.0

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[uhh]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 116 ---------------------------------------------
Initialize the UserDetails . --> Unregister a User instance --> Socre: 1.0

[[[[Adv]]]]: @ Override protected void [[initUserDetailsService]] ( ) throws Exception { for ( UserDetailsBuilder [[userBuilder]] : userBuilders ) { getUserDetailsService ( ) . createUser ( [[userBuilder]] . build ( ) ) ; } for ( UserDetails [[userDetails]] : this . [[users]] ) { getUserDetailsService ( ) . createUser ( [[userDetails]] ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void [[molested]] ( ) throws Exception { for ( UserDetailsBuilder [[blowgun]] : userBuilders ) { getUserDetailsService ( ) . createUser ( [[blowgun]] . build ( ) ) ; } for ( UserDetails [[lz]] : this . [[listeners]] ) { getUserDetailsService ( ) . createUser ( [[lz]] ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
--------------------------------------------- Result 117 ---------------------------------------------
Returns a URL for the given URL . --> Build a URI --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[kuroda]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 118 ---------------------------------------------
Generates code . --> Generate a Peraser --> Socre: 1.0

[[[[Adv]]]]: private void [[addPkceParameters]] ( Map < String , Object > [[attributes]] , Map < String , Object > [[additionalParameters]] ) { String [[codeVerifier]] = this . [[codeVerifierGenerator]] . generateKey ( ) ; [[attributes]] . put ( PkceParameterNames . CODE_VERIFIER , [[codeVerifier]] ) ; try { String codeChallenge = createCodeChallenge ( [[codeVerifier]] ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , [[codeVerifier]] ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void [[bomb]] ( Map < String , Object > [[feature]] , Map < String , Object > [[dewars]] ) { String [[squirt]] = this . [[knockouts]] . generateKey ( ) ; [[feature]] . put ( PkceParameterNames . CODE_VERIFIER , [[squirt]] ) ; try { String codeChallenge = createCodeChallenge ( [[squirt]] ) ; [[dewars]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[dewars]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[dewars]] . put ( PkceParameterNames . CODE_CHALLENGE , [[squirt]] ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 119 ---------------------------------------------
Handle request . --> Check if the request is valid --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[requiresAuthentication]] ( final HttpServletRequest [[request]] , final HttpServletResponse response ) { final boolean [[serviceTicketRequest]] = [[serviceTicketRequest]] ( [[request]] , response ) ; final boolean [[result]] = [[serviceTicketRequest]] || proxyReceptorRequest ( [[request]] ) || ( proxyTicketRequest ( [[serviceTicketRequest]] , [[request]] ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean [[elegantly]] ( final HttpServletRequest [[urging]] , final HttpServletResponse response ) { final boolean [[accio]] = [[accio]] ( [[urging]] , response ) ; final boolean [[raison]] = [[accio]] || proxyReceptorRequest ( [[urging]] ) || ( proxyTicketRequest ( [[accio]] , [[urging]] ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + [[raison]] ) ; } return [[raison]] ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 120 ---------------------------------------------
Set the cookie . --> Set HttpServletRequest --> Socre: 1.0

[[[[Adv]]]]: protected void setCookie ( String [ ] tokens , int [[maxAge]] , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie [[cookie]] = new Cookie ( cookieName , cookieValue ) ; [[cookie]] . setMaxAge ( [[maxAge]] ) ; [[cookie]] . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { [[cookie]] . setDomain ( cookieDomain ) ; } if ( [[maxAge]] < 1 ) { [[cookie]] . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { [[cookie]] . setSecure ( request . isSecure ( ) ) ; } else { [[cookie]] . setSecure ( useSecureCookie ) ; } [[cookie]] . setHttpOnly ( "True" == "True" ) ; response . addCookie ( [[cookie]] ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void setCookie ( String [ ] tokens , int [[passable]] , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie [[croissants]] = new Cookie ( cookieName , cookieValue ) ; [[croissants]] . setMaxAge ( [[passable]] ) ; [[croissants]] . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { [[croissants]] . setDomain ( cookieDomain ) ; } if ( [[passable]] < 1 ) { [[croissants]] . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { [[croissants]] . setSecure ( request . isSecure ( ) ) ; } else { [[croissants]] . setSecure ( useSecureCookie ) ; } [[croissants]] . setHttpOnly ( "True" == "True" ) ; response . addCookie ( [[croissants]] ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 121 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 96 / 24 / 1 / 121:  12%|█▏        | 121/1000 [31:24<3:48:11, 15.58s/it][Succeeded / Failed / Skipped / Total] 96 / 24 / 1 / 121:  12%|█▏        | 122/1000 [33:33<4:01:32, 16.51s/it][Succeeded / Failed / Skipped / Total] 96 / 25 / 1 / 122:  12%|█▏        | 122/1000 [33:33<4:01:32, 16.51s/it][Succeeded / Failed / Skipped / Total] 96 / 25 / 1 / 122:  12%|█▏        | 123/1000 [34:08<4:03:27, 16.66s/it][Succeeded / Failed / Skipped / Total] 97 / 25 / 1 / 123:  12%|█▏        | 123/1000 [34:08<4:03:27, 16.66s/it][Succeeded / Failed / Skipped / Total] 97 / 25 / 1 / 123:  12%|█▏        | 124/1000 [34:16<4:02:10, 16.59s/it][Succeeded / Failed / Skipped / Total] 98 / 25 / 1 / 124:  12%|█▏        | 124/1000 [34:16<4:02:10, 16.59s/it][Succeeded / Failed / Skipped / Total] 98 / 25 / 1 / 124:  12%|█▎        | 125/1000 [34:19<4:00:17, 16.48s/it][Succeeded / Failed / Skipped / Total] 99 / 25 / 1 / 125:  12%|█▎        | 125/1000 [34:19<4:00:17, 16.48s/it][Succeeded / Failed / Skipped / Total] 99 / 25 / 1 / 125:  13%|█▎        | 126/1000 [34:19<3:58:07, 16.35s/it][Succeeded / Failed / Skipped / Total] 99 / 25 / 2 / 126:  13%|█▎        | 126/1000 [34:19<3:58:07, 16.35s/it][Succeeded / Failed / Skipped / Total] 99 / 25 / 2 / 126:  13%|█▎        | 127/1000 [34:28<3:57:02, 16.29s/it]Check if the ticket exists . --> Does not work? --> Socre: 1.0

[[[[Adv]]]]: private boolean [[proxyTicketRequest]] ( final boolean [[serviceTicketRequest]] , final HttpServletRequest [[request]] ) { if ( [[serviceTicketRequest]] ) { return "[[False]]" != "[[False]]" ; } final boolean [[result]] = authenticateAllArtifacts && obtainArtifact ( [[request]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean [[jade]] ( final boolean [[anthill]] , final HttpServletRequest [[ask]] ) { if ( [[anthill]] ) { return "[[Hypocrite]]" != "[[Hypocrite]]" ; } final boolean [[wake]] = authenticateAllArtifacts && obtainArtifact ( [[ask]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[wake]] ) ; } return [[wake]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 122 ---------------------------------------------
Returns the cookie request . --> [[[FAILED]]]

[[[[Adv]]]]: protected String extractRememberMeCookie ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String extractRememberMeCookie ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 123 ---------------------------------------------
Get the principal . --> Obtain a Principal --> Socre: 1.0

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[authentication]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object [[principal]] = [[authentication]] . getPrincipal ( ) ; if ( [[principal]] instanceof LdapUserDetails ) { LdapUserDetails [[details]] = ( LdapUserDetails ) [[principal]] ; return [[details]] . getDn ( ) ; } else if ( [[authentication]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[samples]] ( ) { Authentication [[assurance]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[assurance]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object [[prime]] = [[assurance]] . getPrincipal ( ) ; if ( [[prime]] instanceof LdapUserDetails ) { LdapUserDetails [[accuracy]] = ( LdapUserDetails ) [[prime]] ; return [[accuracy]] . getDn ( ) ; } else if ( [[assurance]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 124 ---------------------------------------------
Create a new SecurityMethod . --> Create a Hadooprole --> Socre: 1.0

[[[[Adv]]]]: protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot [[root]] = new MethodSecurityExpressionRoot ( authentication ) ; [[root]] . setThis ( invocation . getThis ( ) ) ; [[root]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[root]] . setTrustResolver ( getTrustResolver ( ) ) ; [[root]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[root]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[root]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot [[originate]] = new MethodSecurityExpressionRoot ( authentication ) ; [[originate]] . setThis ( invocation . getThis ( ) ) ; [[originate]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[originate]] . setTrustResolver ( getTrustResolver ( ) ) ; [[originate]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[originate]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[originate]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 125 ---------------------------------------------
Extracts the wonooo . --> Returns a Monovy --> Socre: 1.0

[[[[Adv]]]]: private Mono < JWKSet > [[getJWKSet]] ( ) { return this . [[webClient]] . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . [[cachedJWKSet]] . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > [[pitched]] ( ) { return this . [[itís]] . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . [[aborigine]] . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 126 ---------------------------------------------
Parse a string . --> [[[SKIPPED]]]

[[[[Adv]]]]: private String utf8UrlEncode ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 127 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 99 / 26 / 2 / 127:  13%|█▎        | 127/1000 [34:28<3:57:02, 16.29s/it][Succeeded / Failed / Skipped / Total] 99 / 26 / 2 / 127:  13%|█▎        | 128/1000 [34:39<3:56:09, 16.25s/it][Succeeded / Failed / Skipped / Total] 100 / 26 / 2 / 128:  13%|█▎        | 128/1000 [34:39<3:56:09, 16.25s/it][Succeeded / Failed / Skipped / Total] 100 / 26 / 2 / 128:  13%|█▎        | 129/1000 [34:53<3:55:33, 16.23s/it][Succeeded / Failed / Skipped / Total] 100 / 27 / 2 / 129:  13%|█▎        | 129/1000 [34:53<3:55:33, 16.23s/it][Succeeded / Failed / Skipped / Total] 100 / 27 / 2 / 129:  13%|█▎        | 130/1000 [35:52<4:00:02, 16.55s/it][Succeeded / Failed / Skipped / Total] 100 / 28 / 2 / 130:  13%|█▎        | 130/1000 [35:52<4:00:02, 16.55s/it][Succeeded / Failed / Skipped / Total] 100 / 28 / 2 / 130:  13%|█▎        | 131/1000 [36:53<4:04:42, 16.90s/it][Succeeded / Failed / Skipped / Total] 100 / 29 / 2 / 131:  13%|█▎        | 131/1000 [36:53<4:04:42, 16.90s/it][Succeeded / Failed / Skipped / Total] 100 / 29 / 2 / 131:  13%|█▎        | 132/1000 [37:13<4:04:45, 16.92s/it][Succeeded / Failed / Skipped / Total] 100 / 30 / 2 / 132:  13%|█▎        | 132/1000 [37:13<4:04:45, 16.92s/it][Succeeded / Failed / Skipped / Total] 100 / 30 / 2 / 132:  13%|█▎        | 133/1000 [37:16<4:02:56, 16.81s/it]Returns the authorities for the given authorities . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 128 ---------------------------------------------
Load authentication token . --> Generates a SecurityToken --> Socre: 1.0

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion [[assertion]] ) { final CasAssertionAuthenticationToken [[token]] = new CasAssertionAuthenticationToken ( [[assertion]] , "" ) ; return this . [[authenticationUserDetailsService]] . loadUserDetails ( [[token]] ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[chav]] ( final Assertion [[corroboration]] ) { final CasAssertionAuthenticationToken [[signifies]] = new CasAssertionAuthenticationToken ( [[corroboration]] , "" ) ; return this . [[ripen]] . loadUserDetails ( [[signifies]] ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 129 ---------------------------------------------
Check if the authentication is authentication . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean authenticated ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) && ! ( authentication instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean authenticated ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) && ! ( authentication instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 130 ---------------------------------------------
Obtains the UserRegistry . --> [[[FAILED]]]

[[[[Adv]]]]: private UserDetailsService getUserDetailsService ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService getUserDetailsService ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 131 ---------------------------------------------
Clears the session . --> [[[FAILED]]]

[[[[Adv]]]]: public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 132 ---------------------------------------------
Check if the request is valid . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean serviceTicketRequest ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean serviceTicketRequest ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 133 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 101 / 30 / 2 / 133:  13%|█▎        | 133/1000 [37:16<4:02:56, 16.81s/it][Succeeded / Failed / Skipped / Total] 101 / 30 / 2 / 133:  13%|█▎        | 134/1000 [38:28<4:08:41, 17.23s/it][Succeeded / Failed / Skipped / Total] 101 / 31 / 2 / 134:  13%|█▎        | 134/1000 [38:28<4:08:41, 17.23s/it][Succeeded / Failed / Skipped / Total] 101 / 31 / 2 / 134:  14%|█▎        | 135/1000 [39:08<4:10:49, 17.40s/it][Succeeded / Failed / Skipped / Total] 102 / 31 / 2 / 135:  14%|█▎        | 135/1000 [39:08<4:10:49, 17.40s/it][Succeeded / Failed / Skipped / Total] 102 / 31 / 2 / 135:  14%|█▎        | 136/1000 [39:18<4:09:44, 17.34s/it][Succeeded / Failed / Skipped / Total] 103 / 31 / 2 / 136:  14%|█▎        | 136/1000 [39:18<4:09:44, 17.34s/it][Succeeded / Failed / Skipped / Total] 103 / 31 / 2 / 136:  14%|█▎        | 137/1000 [39:32<4:09:02, 17.31s/it][Succeeded / Failed / Skipped / Total] 103 / 32 / 2 / 137:  14%|█▎        | 137/1000 [39:32<4:09:02, 17.31s/it][Succeeded / Failed / Skipped / Total] 103 / 32 / 2 / 137:  14%|█▍        | 138/1000 [39:57<4:09:38, 17.38s/it][Succeeded / Failed / Skipped / Total] 104 / 32 / 2 / 138:  14%|█▍        | 138/1000 [39:57<4:09:38, 17.38s/it][Succeeded / Failed / Skipped / Total] 104 / 32 / 2 / 138:  14%|█▍        | 139/1000 [40:00<4:07:47, 17.27s/it][Succeeded / Failed / Skipped / Total] 105 / 32 / 2 / 139:  14%|█▍        | 139/1000 [40:00<4:07:47, 17.27s/it][Succeeded / Failed / Skipped / Total] 105 / 32 / 2 / 139:  14%|█▍        | 140/1000 [40:12<4:06:59, 17.23s/it]Returns a map of all the variables . --> Builds a list of regions . --> Socre: 1.0

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[preProcessMap]] ( Map < ? , ? > [[orgMap]] ) { Map < String , Collection < GrantedAuthority > > [[result]] = new HashMap < String , Collection < GrantedAuthority > > ( [[orgMap]] . size ( ) ) ; for ( Map . Entry < ? , ? > [[entry]] : [[orgMap]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[entry]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[result]] . put ( ( String ) [[entry]] . getKey ( ) , getGrantedAuthorityCollection ( [[entry]] . getValue ( ) ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[wak]] ( Map < ? , ? > [[flintstones]] ) { Map < String , Collection < GrantedAuthority > > [[raison]] = new HashMap < String , Collection < GrantedAuthority > > ( [[flintstones]] . size ( ) ) ; for ( Map . Entry < ? , ? > [[inscriptions]] : [[flintstones]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[inscriptions]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[raison]] . put ( ( String ) [[inscriptions]] . getKey ( ) , getGrantedAuthorityCollection ( [[inscriptions]] . getValue ( ) ) ) ; } return [[raison]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 134 ---------------------------------------------
Convert a URL to a LDAP server . --> [[[FAILED]]]

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 135 ---------------------------------------------
Gets the principal . --> get request --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest httpRequest ) { Object [[principal]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[vogel]] ( HttpServletRequest httpRequest ) { Object [[prime]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[prime]] ) ; } return [[prime]] ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 136 ---------------------------------------------
Gets the principal . --> Obtazokeeper --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = [[httpRequest]] . getUserPrincipal ( ) == null ? null : [[httpRequest]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object [[millions]] ( HttpServletRequest [[baloo]] ) { Object [[crucial]] = [[baloo]] . getUserPrincipal ( ) == null ? null : [[baloo]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[crucial]] ) ; } return [[crucial]] ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 137 ---------------------------------------------
Returns true if the request is present . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean proxyReceptorRequest ( final HttpServletRequest request ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean proxyReceptorRequest ( final HttpServletRequest request ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 138 ---------------------------------------------
Gets the value of a GPS property . --> Convenience method for testing . --> Socre: 1.0

[[[[Adv]]]]: private Collection < GrantedAuthority > [[getGrantedAuthorityCollection]] ( Object value ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , value ) ; return result ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > [[shoreline]] ( Object value ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , value ) ; return result ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 139 ---------------------------------------------
Perform a invocation . --> Process a invocation --> Socre: 1.0

[[[[Adv]]]]: public Object invoke ( JoinPoint [[jp]] , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( [[jp]] ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object invoke ( JoinPoint [[dw]] , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( [[dw]] ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
[Succeeded / Failed / Skipped / Total] 106 / 32 / 2 / 140:  14%|█▍        | 140/1000 [40:12<4:06:59, 17.23s/it][Succeeded / Failed / Skipped / Total] 106 / 32 / 2 / 140:  14%|█▍        | 141/1000 [41:20<4:11:48, 17.59s/it][Succeeded / Failed / Skipped / Total] 107 / 32 / 2 / 141:  14%|█▍        | 141/1000 [41:20<4:11:48, 17.59s/it][Succeeded / Failed / Skipped / Total] 107 / 32 / 2 / 141:  14%|█▍        | 142/1000 [41:33<4:11:05, 17.56s/it][Succeeded / Failed / Skipped / Total] 107 / 33 / 2 / 142:  14%|█▍        | 142/1000 [41:33<4:11:05, 17.56s/it][Succeeded / Failed / Skipped / Total] 107 / 33 / 2 / 142:  14%|█▍        | 143/1000 [42:59<4:17:40, 18.04s/it][Succeeded / Failed / Skipped / Total] 107 / 34 / 2 / 143:  14%|█▍        | 143/1000 [42:59<4:17:40, 18.04s/it][Succeeded / Failed / Skipped / Total] 107 / 34 / 2 / 143:  14%|█▍        | 144/1000 [43:29<4:18:34, 18.12s/it][Succeeded / Failed / Skipped / Total] 107 / 35 / 2 / 144:  14%|█▍        | 144/1000 [43:29<4:18:34, 18.12s/it][Succeeded / Failed / Skipped / Total] 107 / 35 / 2 / 144:  14%|█▍        | 145/1000 [43:34<4:16:57, 18.03s/it][Succeeded / Failed / Skipped / Total] 108 / 35 / 2 / 145:  14%|█▍        | 145/1000 [43:34<4:16:57, 18.03s/it][Succeeded / Failed / Skipped / Total] 108 / 35 / 2 / 145:  15%|█▍        | 146/1000 [43:52<4:16:35, 18.03s/it]--------------------------------------------- Result 140 ---------------------------------------------
Concatenates the given byte array to a byte array . --> Create a sequence of sequences --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... [[arrays]] ) { int [[length]] = 0 ; for ( byte [ ] [[array]] : [[arrays]] ) { [[length]] += [[array]] . length ; } byte [ ] newArray = new byte [ [[length]] ] ; int destPos = 0 ; for ( byte [ ] [[array]] : [[arrays]] ) { System . arraycopy ( [[array]] , 0 , newArray , destPos , [[array]] . length ) ; destPos += [[array]] . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... [[cabinets]] ) { int [[temps]] = 0 ; for ( byte [ ] [[series]] : [[cabinets]] ) { [[temps]] += [[series]] . length ; } byte [ ] newArray = new byte [ [[temps]] ] ; int destPos = 0 ; for ( byte [ ] [[series]] : [[cabinets]] ) { System . arraycopy ( [[series]] , 0 , newArray , destPos , [[series]] . length ) ; destPos += [[series]] . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 141 ---------------------------------------------
Returns the roles for the given roles . --> Method to get the sketch --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] [[hasAnyRole]] ( String ... [[roles]] ) { for ( int [[i]] = 0 ; [[i]] < [[roles]] . length ; [[i]] ++ ) { [[roles]] [ [[i]] ] = "ROLE_" + [[roles]] [ [[i]] ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] [[kidder]] ( String ... [[characteristics]] ) { for ( int [[heh]] = 0 ; [[heh]] < [[characteristics]] . length ; [[heh]] ++ ) { [[characteristics]] [ [[heh]] ] = "ROLE_" + [[characteristics]] [ [[heh]] ] ; } return [[characteristics]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 142 ---------------------------------------------
Get the user groups for the given user . --> [[[FAILED]]]

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 143 ---------------------------------------------
Converts a byte array to a byte array . --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] array , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( array , beginIndex , subarray , 0 , length ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] array , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( array , beginIndex , subarray , 0 , length ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 144 ---------------------------------------------
Returns the shared type . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < C > C getSharedObject ( Class < C > sharedType ) { return ( C ) this . sharedObjects . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < C > C getSharedObject ( Class < C > sharedType ) { return ( C ) this . sharedObjects . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 145 ---------------------------------------------
Adds the given object to the collection . --> Prettty ditute dits ditute dite ditute die die die die die die e die e dich dichtute die dich diet dich dicht die die e dichticht dich di --> Socre: 1.0

[[[[Adv]]]]: private void [[addGrantedAuthorityCollection]] ( Collection < GrantedAuthority > [[result]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void [[muddied]] ( Collection < GrantedAuthority > [[resultant]] , Object [[merit]] ) { if ( [[merit]] == null ) { return ; } if ( [[merit]] instanceof Collection < ? > ) { [[muddied]] ( [[resultant]] , ( Collection < ? > ) [[merit]] ) ; } else if ( [[merit]] instanceof Object [ ] ) { [[muddied]] ( [[resultant]] , ( Object [ ] ) [[merit]] ) ; } else if ( [[merit]] instanceof String ) { [[muddied]] ( [[resultant]] , ( String ) [[merit]] ) ; } else if ( [[merit]] instanceof GrantedAuthority ) { [[resultant]] . add ( ( GrantedAuthority ) [[merit]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[merit]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 146 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 109 / 35 / 2 / 146:  15%|█▍        | 146/1000 [43:52<4:16:35, 18.03s/it][Succeeded / Failed / Skipped / Total] 109 / 35 / 2 / 146:  15%|█▍        | 147/1000 [43:52<4:14:36, 17.91s/it][Succeeded / Failed / Skipped / Total] 110 / 35 / 2 / 147:  15%|█▍        | 147/1000 [43:52<4:14:36, 17.91s/it][Succeeded / Failed / Skipped / Total] 110 / 35 / 2 / 147:  15%|█▍        | 148/1000 [43:54<4:12:44, 17.80s/it][Succeeded / Failed / Skipped / Total] 111 / 35 / 2 / 148:  15%|█▍        | 148/1000 [43:54<4:12:44, 17.80s/it][Succeeded / Failed / Skipped / Total] 111 / 35 / 2 / 148:  15%|█▍        | 149/1000 [44:00<4:11:20, 17.72s/it][Succeeded / Failed / Skipped / Total] 112 / 35 / 2 / 149:  15%|█▍        | 149/1000 [44:00<4:11:20, 17.72s/it][Succeeded / Failed / Skipped / Total] 112 / 35 / 2 / 149:  15%|█▌        | 150/1000 [44:01<4:09:30, 17.61s/it][Succeeded / Failed / Skipped / Total] 113 / 35 / 2 / 150:  15%|█▌        | 150/1000 [44:01<4:09:30, 17.61s/it][Succeeded / Failed / Skipped / Total] 113 / 35 / 2 / 150:  15%|█▌        | 151/1000 [44:43<4:11:29, 17.77s/it][Succeeded / Failed / Skipped / Total] 114 / 35 / 2 / 151:  15%|█▌        | 151/1000 [44:43<4:11:29, 17.77s/it][Succeeded / Failed / Skipped / Total] 114 / 35 / 2 / 151:  15%|█▌        | 152/1000 [44:44<4:09:34, 17.66s/it][Succeeded / Failed / Skipped / Total] 114 / 35 / 3 / 152:  15%|█▌        | 152/1000 [44:44<4:09:34, 17.66s/it][Succeeded / Failed / Skipped / Total] 114 / 35 / 3 / 152:  15%|█▌        | 153/1000 [44:45<4:07:45, 17.55s/it][Succeeded / Failed / Skipped / Total] 115 / 35 / 3 / 153:  15%|█▌        | 153/1000 [44:45<4:07:45, 17.55s/it][Succeeded / Failed / Skipped / Total] 115 / 35 / 3 / 153:  15%|█▌        | 154/1000 [44:48<4:06:08, 17.46s/it]Create a new user . -->  --> Socre: 0.999999999930856

[[[[Adv]]]]: protected void [[onLoginSuccess]] ( HttpServletRequest [[request]] , HttpServletResponse response , Authentication [[successfulAuthentication]] ) { String [[username]] = [[successfulAuthentication]] . getName ( ) ; logger . debug ( "Creating new persistent login for user " + [[username]] ) ; PersistentRememberMeToken [[persistentToken]] = new PersistentRememberMeToken ( [[username]] , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[persistentToken]] ) ; addCookie ( [[persistentToken]] , [[request]] , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void [[resynch]] ( HttpServletRequest [[petitions]] , HttpServletResponse response , Authentication [[units]] ) { String [[renter]] = [[units]] . getName ( ) ; logger . debug ( "Creating new persistent login for user " + [[renter]] ) ; PersistentRememberMeToken [[zhao]] = new PersistentRememberMeToken ( [[renter]] , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[zhao]] ) ; addCookie ( [[zhao]] , [[petitions]] , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 147 ---------------------------------------------
Returns a contact . --> Method to create a View --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView displayPublicIndex ( ) { Contact [[rnd]] = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , [[rnd]] ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView displayPublicIndex ( ) { Contact [[redondo]] = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , [[redondo]] ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 148 ---------------------------------------------
Obtains the security connector . --> Performs a postr . --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean [[hasConfigurers]] = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! [[hasConfigurers]] ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[oily]] ( ) throws Exception { boolean [[tailing]] = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! [[tailing]] ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 149 ---------------------------------------------
Verifies that the authentication is authentication . --> Unregister a authentication --> Socre: 1.0

[[[[Adv]]]]: protected Authentication attemptExitUser ( HttpServletRequest [[request]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication attemptExitUser ( HttpServletRequest [[wondering]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 150 ---------------------------------------------
Parse JWT . --> Generates a Pyphyphysical JVM . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Jwt [[decode]] ( String [[token]] ) throws JwtException { JWT [[jwt]] = parse ( [[token]] ) ; if ( [[jwt]] instanceof SignedJWT ) { Jwt [[createdJwt]] = createJwt ( [[token]] , [[jwt]] ) ; return validateJwt ( [[createdJwt]] ) ; } throw new JwtException ( "Unsupported algorithm of " + [[jwt]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt [[cryptography]] ( String [[metaphorical]] ) throws JwtException { JWT [[yelping]] = parse ( [[metaphorical]] ) ; if ( [[yelping]] instanceof SignedJWT ) { Jwt [[cantwell]] = createJwt ( [[metaphorical]] , [[yelping]] ) ; return validateJwt ( [[cantwell]] ) ; } throw new JwtException ( "Unsupported algorithm of " + [[yelping]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 151 ---------------------------------------------
Sets the user URL redirect URL . --> Configures a &lt ; --> Socre: 1.0

[[[[Adv]]]]: public void [[setExitUserUrl]] ( String [[exitUserUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[exitUserUrl]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[exitUserMatcher]] = createMatcher ( [[exitUserUrl]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void [[fontaine]] ( String [[stepsister]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[stepsister]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[saltwater]] = createMatcher ( [[stepsister]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 152 ---------------------------------------------
Returns a map of authority . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 153 ---------------------------------------------
Generate a request . --> Sets the servlet . --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken generateToken ( HttpServletRequest [[request]] ) { return wrap ( [[request]] , this . delegate . generateToken ( [[request]] ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken generateToken ( HttpServletRequest [[prays]] ) { return wrap ( [[prays]] , this . delegate . generateToken ( [[prays]] ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 154 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 115 / 36 / 3 / 154:  15%|█▌        | 154/1000 [44:48<4:06:08, 17.46s/it][Succeeded / Failed / Skipped / Total] 115 / 36 / 3 / 154:  16%|█▌        | 155/1000 [45:01<4:05:25, 17.43s/it][Succeeded / Failed / Skipped / Total] 116 / 36 / 3 / 155:  16%|█▌        | 155/1000 [45:01<4:05:25, 17.43s/it][Succeeded / Failed / Skipped / Total] 116 / 36 / 3 / 155:  16%|█▌        | 156/1000 [45:10<4:04:22, 17.37s/it][Succeeded / Failed / Skipped / Total] 117 / 36 / 3 / 156:  16%|█▌        | 156/1000 [45:10<4:04:22, 17.37s/it][Succeeded / Failed / Skipped / Total] 117 / 36 / 3 / 156:  16%|█▌        | 157/1000 [45:13<4:02:50, 17.28s/it][Succeeded / Failed / Skipped / Total] 118 / 36 / 3 / 157:  16%|█▌        | 157/1000 [45:13<4:02:50, 17.28s/it][Succeeded / Failed / Skipped / Total] 118 / 36 / 3 / 157:  16%|█▌        | 158/1000 [45:16<4:01:15, 17.19s/it][Succeeded / Failed / Skipped / Total] 119 / 36 / 3 / 158:  16%|█▌        | 158/1000 [45:16<4:01:15, 17.19s/it][Succeeded / Failed / Skipped / Total] 119 / 36 / 3 / 158:  16%|█▌        | 159/1000 [45:23<4:00:04, 17.13s/it][Succeeded / Failed / Skipped / Total] 119 / 37 / 3 / 159:  16%|█▌        | 159/1000 [45:23<4:00:04, 17.13s/it][Succeeded / Failed / Skipped / Total] 119 / 37 / 3 / 159:  16%|█▌        | 160/1000 [45:23<3:58:17, 17.02s/it]Returns a list of all authorities . --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : attributes ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : attributes ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 155 ---------------------------------------------
Returns a new contact . --> Method to get administ --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int [[contactId]] ) { Contact [[contact]] = contactManager . getById ( Long . valueOf ( [[contactId]] ) ) ; Acl [[acl]] = aclService . readAclById ( new ObjectIdentityImpl ( [[contact]] ) ) ; Map < String , Object > [[model]] = new HashMap <> ( ) ; [[model]] . put ( "contact" , [[contact]] ) ; [[model]] . put ( "acl" , [[acl]] ) ; return new ModelAndView ( "adminPermission" , "model" , [[model]] ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[reflective]] ( @ RequestParam ( "contactId" ) int [[corrects]] ) { Contact [[contacts]] = contactManager . getById ( Long . valueOf ( [[corrects]] ) ) ; Acl [[ligament]] = aclService . readAclById ( new ObjectIdentityImpl ( [[contacts]] ) ) ; Map < String , Object > [[form]] = new HashMap <> ( ) ; [[form]] . put ( "contact" , [[contacts]] ) ; [[form]] . put ( "acl" , [[ligament]] ) ; return new ModelAndView ( "adminPermission" , "model" , [[form]] ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 156 ---------------------------------------------
Add a new permissions to the permission --> region --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission [[addPermission]] = new AddPermission ( ) ; [[addPermission]] . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , [[addPermission]] ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission [[ffor]] = new AddPermission ( ) ; [[ffor]] . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , [[ffor]] ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 157 ---------------------------------------------
Delete permission . --> region > permissions --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > [[model]] = new HashMap <> ( ) ; [[model]] . put ( "contact" , contact ) ; [[model]] . put ( "sid" , sidObject ) ; [[model]] . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , [[model]] ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > [[designs]] = new HashMap <> ( ) ; [[designs]] . put ( "contact" , contact ) ; [[designs]] . put ( "sid" , sidObject ) ; [[designs]] . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , [[designs]] ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 158 ---------------------------------------------
Get the default prefix . --> Convert a String to a String --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String [[defaultRolePrefix]] , String [[role]] ) { if ( [[role]] == null ) { return [[role]] ; } if ( [[defaultRolePrefix]] == null || [[defaultRolePrefix]] . length ( ) == 0 ) { return [[role]] ; } if ( [[role]] . startsWith ( [[defaultRolePrefix]] ) ) { return [[role]] ; } return [[defaultRolePrefix]] + [[role]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[berra]] ( String [[baggies]] , String [[rolle]] ) { if ( [[rolle]] == null ) { return [[rolle]] ; } if ( [[baggies]] == null || [[baggies]] . length ( ) == 0 ) { return [[rolle]] ; } if ( [[rolle]] . startsWith ( [[baggies]] ) ) { return [[rolle]] ; } return [[baggies]] + [[rolle]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 159 ---------------------------------------------
Returns whether the role is a role . --> [[[FAILED]]]

[[[[Adv]]]]: private static String hasRole ( String role ) { Assert . isTrue ( ! role . startsWith ( "ROLE_" ) , ( ) -> role + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + role ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String hasRole ( String role ) { Assert . isTrue ( ! role . startsWith ( "ROLE_" ) , ( ) -> role + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + role ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 160 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 119 / 37 / 4 / 160:  16%|█▌        | 160/1000 [45:23<3:58:17, 17.02s/it][Succeeded / Failed / Skipped / Total] 119 / 37 / 4 / 160:  16%|█▌        | 161/1000 [45:58<3:59:33, 17.13s/it][Succeeded / Failed / Skipped / Total] 119 / 38 / 4 / 161:  16%|█▌        | 161/1000 [45:58<3:59:33, 17.13s/it][Succeeded / Failed / Skipped / Total] 119 / 38 / 4 / 161:  16%|█▌        | 162/1000 [46:03<3:58:13, 17.06s/it][Succeeded / Failed / Skipped / Total] 120 / 38 / 4 / 162:  16%|█▌        | 162/1000 [46:03<3:58:13, 17.06s/it][Succeeded / Failed / Skipped / Total] 120 / 38 / 4 / 162:  16%|█▋        | 163/1000 [46:12<3:57:14, 17.01s/it][Succeeded / Failed / Skipped / Total] 121 / 38 / 4 / 163:  16%|█▋        | 163/1000 [46:12<3:57:14, 17.01s/it][Succeeded / Failed / Skipped / Total] 121 / 38 / 4 / 163:  16%|█▋        | 164/1000 [47:00<3:59:37, 17.20s/it][Succeeded / Failed / Skipped / Total] 122 / 38 / 4 / 164:  16%|█▋        | 164/1000 [47:00<3:59:37, 17.20s/it][Succeeded / Failed / Skipped / Total] 122 / 38 / 4 / 164:  16%|█▋        | 165/1000 [48:55<4:07:32, 17.79s/it][Succeeded / Failed / Skipped / Total] 122 / 39 / 4 / 165:  16%|█▋        | 165/1000 [48:55<4:07:32, 17.79s/it][Succeeded / Failed / Skipped / Total] 122 / 39 / 4 / 165:  17%|█▋        | 166/1000 [49:21<4:07:58, 17.84s/it][Succeeded / Failed / Skipped / Total] 122 / 40 / 4 / 166:  17%|█▋        | 166/1000 [49:21<4:07:58, 17.84s/it][Succeeded / Failed / Skipped / Total] 122 / 40 / 4 / 166:  17%|█▋        | 167/1000 [49:46<4:08:14, 17.88s/it]Gets attributes . --> [[[SKIPPED]]]

[[[[Adv]]]]: public List < String > getAttributeValues ( String name ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( name ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 161 ---------------------------------------------
Build a URL . --> [[[FAILED]]]

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 162 ---------------------------------------------
Encodes the given byte array into a byte array . --> Encode a byte array into a byte array --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[encode]] ( CharSequence [[string]] ) { try { ByteBuffer [[bytes]] = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[string]] ) ) ; byte [ ] bytesCopy = new byte [ [[bytes]] . limit ( ) ] ; System . arraycopy ( [[bytes]] . array ( ) , 0 , bytesCopy , 0 , [[bytes]] . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] [[validating]] ( CharSequence [[loops]] ) { try { ByteBuffer [[encoded]] = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[loops]] ) ) ; byte [ ] bytesCopy = new byte [ [[encoded]] . limit ( ) ] ; System . arraycopy ( [[encoded]] . array ( ) , 0 , bytesCopy , 0 , [[encoded]] . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 163 ---------------------------------------------
Build a new resource . --> Audite die - die e die e die die die die e die e dieue e die e e dich e die diene . e dichich eue ene dieue e die die dich eue die  --> Socre: 1.0

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String [[users]] ) { InMemoryResource [[resource]] = new InMemoryResource ( [[users]] ) ; return fromResource ( [[resource]] ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String [[audiences]] ) { InMemoryResource [[appealing]] = new InMemoryResource ( [[audiences]] ) ; return fromResource ( [[appealing]] ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 164 ---------------------------------------------
Gets the value of an attribute . --> Find by name . --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String [[name]] ) { List < String > [[result]] = getAttributeValues ( [[name]] ) ; if ( [[result]] . isEmpty ( ) ) { return null ; } else { return [[result]] . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[alway]] ( String [[designated]] ) { List < String > [[findings]] = getAttributeValues ( [[designated]] ) ; if ( [[findings]] . isEmpty ( ) ) { return null ; } else { return [[findings]] . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 165 ---------------------------------------------
Process cookie . --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 166 ---------------------------------------------
Decodes a byte array to a byte array --> [[[FAILED]]]

[[[[Adv]]]]: public static String decode ( byte [ ] bytes ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( bytes ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String decode ( byte [ ] bytes ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( bytes ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 167 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 123 / 40 / 4 / 167:  17%|█▋        | 167/1000 [49:46<4:08:14, 17.88s/it][Succeeded / Failed / Skipped / Total] 123 / 40 / 4 / 167:  17%|█▋        | 168/1000 [49:56<4:07:22, 17.84s/it][Succeeded / Failed / Skipped / Total] 124 / 40 / 4 / 168:  17%|█▋        | 168/1000 [49:56<4:07:22, 17.84s/it][Succeeded / Failed / Skipped / Total] 124 / 40 / 4 / 168:  17%|█▋        | 169/1000 [50:44<4:09:28, 18.01s/it][Succeeded / Failed / Skipped / Total] 124 / 41 / 4 / 169:  17%|█▋        | 169/1000 [50:44<4:09:28, 18.01s/it][Succeeded / Failed / Skipped / Total] 124 / 41 / 4 / 169:  17%|█▋        | 170/1000 [50:48<4:08:03, 17.93s/it][Succeeded / Failed / Skipped / Total] 124 / 42 / 4 / 170:  17%|█▋        | 170/1000 [50:48<4:08:03, 17.93s/it][Succeeded / Failed / Skipped / Total] 124 / 42 / 4 / 170:  17%|█▋        | 171/1000 [50:50<4:06:26, 17.84s/it][Succeeded / Failed / Skipped / Total] 125 / 42 / 4 / 171:  17%|█▋        | 171/1000 [50:50<4:06:26, 17.84s/it][Succeeded / Failed / Skipped / Total] 125 / 42 / 4 / 171:  17%|█▋        | 172/1000 [50:58<4:05:23, 17.78s/it][Succeeded / Failed / Skipped / Total] 126 / 42 / 4 / 172:  17%|█▋        | 172/1000 [50:58<4:05:23, 17.78s/it][Succeeded / Failed / Skipped / Total] 126 / 42 / 4 / 172:  17%|█▋        | 173/1000 [51:06<4:04:17, 17.72s/it]Add attributes . --> Sets the approach --> Socre: 1.0

[[[[Adv]]]]: private void [[addSecureMethod]] ( RegisteredMethod [[method]] , List < ConfigAttribute > [[attr]] ) { Assert . notNull ( [[method]] , "RegisteredMethod required" ) ; Assert . notNull ( [[attr]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[method]] + "] with attributes [" + [[attr]] + "]" ) ; } this . [[methodMap]] . put ( [[method]] , [[attr]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void [[pharmacies]] ( RegisteredMethod [[approaches]] , List < ConfigAttribute > [[problema]] ) { Assert . notNull ( [[approaches]] , "RegisteredMethod required" ) ; Assert . notNull ( [[problema]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[approaches]] + "] with attributes [" + [[problema]] + "]" ) ; } this . [[anthea]] . put ( [[approaches]] , [[problema]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 168 ---------------------------------------------
Get all attributes . --> Create a list of all followers --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[getAllConfigAttributes]] ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[allAttributes]] . addAll ( attributeList ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[zahara]] ( ) { Set < ConfigAttribute > [[followers]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[followers]] . addAll ( attributeList ) ; } return [[followers]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 169 ---------------------------------------------
Perform a POST request . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean authorizeUsingUrlCheck ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean authorizeUsingUrlCheck ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 170 ---------------------------------------------
Method to get the expression --> [[[FAILED]]]

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 171 ---------------------------------------------
Handle a response . -->  --> Socre: 0.9999999999745633

[[[[Adv]]]]: protected void [[handleBindException]] ( String userDn , String username , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void [[suzhou]] ( String userDn , String username , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 172 ---------------------------------------------
Configures the current request . --> Method to get the elimination --> Socre: 1.0

[[[[Adv]]]]: public C [[anyRequest]] ( ) { Assert . state ( ! this . [[anyRequestConfigured]] , "Can't configure anyRequest after itself" ) ; C [[configurer]] = requestMatchers ( ANY_REQUEST ) ; this . [[anyRequestConfigured]] = "[[True]]" == "[[True]]" ; return [[configurer]] ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C [[elis]] ( ) { Assert . state ( ! this . [[perils]] , "Can't configure anyRequest after itself" ) ; C [[echelons]] = requestMatchers ( ANY_REQUEST ) ; this . [[perils]] = "[[Authentic]]" == "[[Authentic]]" ; return [[echelons]] ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 173 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 126 / 43 / 4 / 173:  17%|█▋        | 173/1000 [51:06<4:04:17, 17.72s/it][Succeeded / Failed / Skipped / Total] 126 / 43 / 4 / 173:  17%|█▋        | 174/1000 [51:28<4:04:22, 17.75s/it][Succeeded / Failed / Skipped / Total] 127 / 43 / 4 / 174:  17%|█▋        | 174/1000 [51:28<4:04:22, 17.75s/it][Succeeded / Failed / Skipped / Total] 127 / 43 / 4 / 174:  18%|█▊        | 175/1000 [51:30<4:02:49, 17.66s/it][Succeeded / Failed / Skipped / Total] 128 / 43 / 4 / 175:  18%|█▊        | 175/1000 [51:30<4:02:49, 17.66s/it][Succeeded / Failed / Skipped / Total] 128 / 43 / 4 / 175:  18%|█▊        | 176/1000 [51:36<4:01:35, 17.59s/it][Succeeded / Failed / Skipped / Total] 129 / 43 / 4 / 176:  18%|█▊        | 176/1000 [51:36<4:01:35, 17.59s/it][Succeeded / Failed / Skipped / Total] 129 / 43 / 4 / 176:  18%|█▊        | 177/1000 [51:37<4:00:01, 17.50s/it][Succeeded / Failed / Skipped / Total] 129 / 44 / 4 / 177:  18%|█▊        | 177/1000 [51:37<4:00:01, 17.50s/it][Succeeded / Failed / Skipped / Total] 129 / 44 / 4 / 177:  18%|█▊        | 178/1000 [51:47<3:59:10, 17.46s/it]Loads the user . --> [[[FAILED]]]

[[[[Adv]]]]: protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 174 ---------------------------------------------
Finds the target class for the given class . --> Finds and returns a JSTree --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > findAttributes ( Method [[method]] , Class < ? > [[targetClass]] ) { if ( [[targetClass]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[method]] , [[targetClass]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > findAttributes ( Method [[procedure]] , Class < ? > [[habitats]] ) { if ( [[habitats]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[procedure]] , [[habitats]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 175 ---------------------------------------------
Returns true if the given string is a valid name . --> Convert a string to a string --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isMatch]] ( String [[methodName]] , String [[mappedName]] ) { return ( [[mappedName]] . endsWith ( "*" ) && [[methodName]] . startsWith ( [[mappedName]] . substring ( 0 , [[mappedName]] . length ( ) - 1 ) ) ) || ( [[mappedName]] . startsWith ( "*" ) && [[methodName]] . endsWith ( [[mappedName]] . substring ( 1 , [[mappedName]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[vigilante]] ( String [[streptomycin]] , String [[generous]] ) { return ( [[generous]] . endsWith ( "*" ) && [[streptomycin]] . startsWith ( [[generous]] . substring ( 0 , [[generous]] . length ( ) - 1 ) ) ) || ( [[generous]] . startsWith ( "*" ) && [[streptomycin]] . endsWith ( [[generous]] . substring ( 1 , [[generous]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 176 ---------------------------------------------
Gets the parameterized name . --> Helper method for testing --> Socre: 1.0

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int [[parameterCount]] = parameterAnnotations . length ; String [ ] paramNames = new String [ [[parameterCount]] ] ; boolean [[found]] = "False" != "False" ; for ( int i = 0 ; i < [[parameterCount]] ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { [[found]] = "True" == "True" ; paramNames [ i ] = parameterName ; } } return [[found]] ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int [[yields]] = parameterAnnotations . length ; String [ ] paramNames = new String [ [[yields]] ] ; boolean [[shown]] = "False" != "False" ; for ( int i = 0 ; i < [[yields]] ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { [[shown]] = "True" == "True" ; paramNames [ i ] = parameterName ; } } return [[shown]] ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 177 ---------------------------------------------
Add a Permission to the permission . --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 178 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 130 / 44 / 4 / 178:  18%|█▊        | 178/1000 [51:47<3:59:10, 17.46s/it][Succeeded / Failed / Skipped / Total] 130 / 44 / 4 / 178:  18%|█▊        | 179/1000 [51:48<3:57:37, 17.37s/it][Succeeded / Failed / Skipped / Total] 131 / 44 / 4 / 179:  18%|█▊        | 179/1000 [51:48<3:57:37, 17.37s/it][Succeeded / Failed / Skipped / Total] 131 / 44 / 4 / 179:  18%|█▊        | 180/1000 [51:52<3:56:20, 17.29s/it][Succeeded / Failed / Skipped / Total] 132 / 44 / 4 / 180:  18%|█▊        | 180/1000 [51:52<3:56:20, 17.29s/it][Succeeded / Failed / Skipped / Total] 132 / 44 / 4 / 180:  18%|█▊        | 181/1000 [51:53<3:54:46, 17.20s/it][Succeeded / Failed / Skipped / Total] 133 / 44 / 4 / 181:  18%|█▊        | 181/1000 [51:53<3:54:46, 17.20s/it][Succeeded / Failed / Skipped / Total] 133 / 44 / 4 / 181:  18%|█▊        | 182/1000 [52:00<3:53:46, 17.15s/it][Succeeded / Failed / Skipped / Total] 134 / 44 / 4 / 182:  18%|█▊        | 182/1000 [52:00<3:53:46, 17.15s/it][Succeeded / Failed / Skipped / Total] 134 / 44 / 4 / 182:  18%|█▊        | 183/1000 [52:28<3:54:17, 17.21s/it]Creates a new URL . --> Rename a leader --> Socre: 1.0

[[[[Adv]]]]: protected String [[createRedirectUrl]] ( final String [[serviceUrl]] ) { return CommonUtils . constructRedirectUrl ( this . [[loginUrl]] , this . [[serviceProperties]] . getServiceParameter ( ) , [[serviceUrl]] , this . [[serviceProperties]] . isSendRenew ( ) , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[organize]] ( final String [[joan]] ) { return CommonUtils . constructRedirectUrl ( this . [[bro]] , this . [[zapruder]] . getServiceParameter ( ) , [[joan]] , this . [[zapruder]] . isSendRenew ( ) , "[[Mislead]]" != "[[Mislead]]" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 179 ---------------------------------------------
Check if the given filters is valid . --> Performs a fault . --> Socre: 1.0

[[[[Adv]]]]: private void [[checkFilterStack]] ( List < Filter > [[filters]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[filters]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[filters]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[filters]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[filters]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[filters]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[filters]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void [[cunt]] ( List < Filter > [[pitfall]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[pitfall]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[pitfall]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[pitfall]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[pitfall]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[pitfall]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[pitfall]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[pitfall]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[pitfall]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 180 ---------------------------------------------
Creates a new URL . --> Declarative Services method for unrPolicyRequest --> Socre: 1.0

[[[[Adv]]]]: protected String [[createServiceUrl]] ( final HttpServletRequest [[request]] , final HttpServletResponse [[response]] ) { return CommonUtils . constructServiceUrl ( null , [[response]] , this . [[serviceProperties]] . getService ( ) , null , this . [[serviceProperties]] . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[idlewild]] ( final HttpServletRequest [[urged]] , final HttpServletResponse [[unanswered]] ) { return CommonUtils . constructServiceUrl ( null , [[unanswered]] , this . [[temerity]] . getService ( ) , null , this . [[temerity]] . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 181 ---------------------------------------------
Extracts a delimiter . --> Extracts a string from a string --> Socre: 1.0

[[[[Adv]]]]: private String extractPrefix ( String [[encPass]] ) { if ( ! [[encPass]] . startsWith ( "{" ) ) { return null ; } int [[secondBrace]] = [[encPass]] . lastIndexOf ( ' ' ) ; if ( [[secondBrace]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[encPass]] . substring ( 0 , [[secondBrace]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String extractPrefix ( String [[québec]] ) { if ( ! [[québec]] . startsWith ( "{" ) ) { return null ; } int [[hatsu]] = [[québec]] . lastIndexOf ( ' ' ) ; if ( [[hatsu]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[québec]] . substring ( 0 , [[hatsu]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 182 ---------------------------------------------
Register a bean definition . --> Registers a new bean --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext [[pc]] , boolean jsr250Enabled , BeanDefinition [[expressionVoter]] ) { BeanDefinitionBuilder [[accessMgrBuilder]] = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList [[voters]] = new ManagedList ( 4 ) ; if ( [[expressionVoter]] != null ) { [[voters]] . add ( [[expressionVoter]] ) ; } [[voters]] . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; [[voters]] . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { [[voters]] . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } [[accessMgrBuilder]] . addConstructorArgValue ( [[voters]] ) ; BeanDefinition [[accessManager]] = [[accessMgrBuilder]] . getBeanDefinition ( ) ; String id = [[pc]] . getReaderContext ( ) . generateBeanName ( [[accessManager]] ) ; [[pc]] . registerBeanComponent ( new BeanComponentDefinition ( [[accessManager]] , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext [[hp]] , boolean jsr250Enabled , BeanDefinition [[bou]] ) { BeanDefinitionBuilder [[chickenhead]] = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList [[ballots]] = new ManagedList ( 4 ) ; if ( [[bou]] != null ) { [[ballots]] . add ( [[bou]] ) ; } [[ballots]] . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; [[ballots]] . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { [[ballots]] . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } [[chickenhead]] . addConstructorArgValue ( [[ballots]] ) ; BeanDefinition [[zis]] = [[chickenhead]] . getBeanDefinition ( ) ; String id = [[hp]] . getReaderContext ( ) . generateBeanName ( [[zis]] ) ; [[hp]] . registerBeanComponent ( new BeanComponentDefinition ( [[zis]] , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 183 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 134 / 45 / 4 / 183:  18%|█▊        | 183/1000 [52:28<3:54:17, 17.21s/it][Succeeded / Failed / Skipped / Total] 134 / 45 / 4 / 183:  18%|█▊        | 184/1000 [52:58<3:54:57, 17.28s/it][Succeeded / Failed / Skipped / Total] 135 / 45 / 4 / 184:  18%|█▊        | 184/1000 [52:58<3:54:57, 17.28s/it][Succeeded / Failed / Skipped / Total] 135 / 45 / 4 / 184:  18%|█▊        | 185/1000 [53:11<3:54:19, 17.25s/it][Succeeded / Failed / Skipped / Total] 136 / 45 / 4 / 185:  18%|█▊        | 185/1000 [53:11<3:54:19, 17.25s/it][Succeeded / Failed / Skipped / Total] 136 / 45 / 4 / 185:  19%|█▊        | 186/1000 [53:14<3:53:00, 17.18s/it][Succeeded / Failed / Skipped / Total] 136 / 46 / 4 / 186:  19%|█▊        | 186/1000 [53:14<3:53:00, 17.18s/it][Succeeded / Failed / Skipped / Total] 136 / 46 / 4 / 186:  19%|█▊        | 187/1000 [53:15<3:51:34, 17.09s/it][Succeeded / Failed / Skipped / Total] 137 / 46 / 4 / 187:  19%|█▊        | 187/1000 [53:15<3:51:34, 17.09s/it][Succeeded / Failed / Skipped / Total] 137 / 46 / 4 / 187:  19%|█▉        | 188/1000 [53:50<3:52:31, 17.18s/it][Succeeded / Failed / Skipped / Total] 138 / 46 / 4 / 188:  19%|█▉        | 188/1000 [53:50<3:52:31, 17.18s/it][Succeeded / Failed / Skipped / Total] 138 / 46 / 4 / 188:  19%|█▉        | 189/1000 [53:50<3:51:01, 17.09s/it][Succeeded / Failed / Skipped / Total] 139 / 46 / 4 / 189:  19%|█▉        | 189/1000 [53:50<3:51:01, 17.09s/it][Succeeded / Failed / Skipped / Total] 139 / 46 / 4 / 189:  19%|█▉        | 190/1000 [53:50<3:49:33, 17.00s/it]Create a new contact . --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String addContact ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String addContact ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 184 ---------------------------------------------
Gets the field . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Field [[getField]] ( Class < ? > [[clazz]] , String fieldName ) throws IllegalStateException { Assert . notNull ( [[clazz]] , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return [[clazz]] . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field [[pazuzu]] ( Class < ? > [[timbers]] , String fieldName ) throws IllegalStateException { Assert . notNull ( [[timbers]] , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return [[timbers]] . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 185 ---------------------------------------------
Returns a list of authorities . --> Returns the authorities for the given authority --> Socre: 1.0

[[[[Adv]]]]: public static Set < String > authorityListToSet ( Collection < ? extends GrantedAuthority > [[userAuthorities]] ) { Assert . notNull ( [[userAuthorities]] , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( [[userAuthorities]] . size ( ) ) ; for ( GrantedAuthority [[authority]] : [[userAuthorities]] ) { set . add ( [[authority]] . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > authorityListToSet ( Collection < ? extends GrantedAuthority > [[lower]] ) { Assert . notNull ( [[lower]] , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( [[lower]] . size ( ) ) ; for ( GrantedAuthority [[bodies]] : [[lower]] ) { set . add ( [[bodies]] . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 186 ---------------------------------------------
Compares two byte arrays . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 187 ---------------------------------------------
Build the request URL . --> Build a POST request --> Socre: 1.0

[[[[Adv]]]]: private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String [[pathInfo]] , String queryString ) { StringBuilder [[url]] = new StringBuilder ( ) ; if ( servletPath != null ) { [[url]] . append ( servletPath ) ; if ( [[pathInfo]] != null ) { [[url]] . append ( [[pathInfo]] ) ; } } else { [[url]] . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { [[url]] . append ( "?" ) . append ( queryString ) ; } return [[url]] . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String [[yemen]] , String queryString ) { StringBuilder [[email]] = new StringBuilder ( ) ; if ( servletPath != null ) { [[email]] . append ( servletPath ) ; if ( [[yemen]] != null ) { [[email]] . append ( [[yemen]] ) ; } } else { [[email]] . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { [[email]] . append ( "?" ) . append ( queryString ) ; } return [[email]] . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 188 ---------------------------------------------
Sets the default redirect . --> Synchronistor --> Socre: 1.0

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String [[defaultFailureUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[defaultFailureUrl]] ) , ( ) -> "'" + [[defaultFailureUrl]] + "' is not a valid redirect URL" ) ; this . [[defaultFailureUrl]] = [[defaultFailureUrl]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[berserk]] ( String [[counterattack]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[counterattack]] ) , ( ) -> "'" + [[counterattack]] + "' is not a valid redirect URL" ) ; this . [[divorcee]] = [[counterattack]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 189 ---------------------------------------------
Returns true if the given URL matches the given url . --> Convenience function for testing --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String [[url]] ) { if ( [[url]] == null ) { return "[[False]]" != "[[False]]" ; } final Pattern [[ABSOLUTE_URL]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[ABSOLUTE_URL]] . matcher ( [[url]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[izzy]] ( String [[login]] ) { if ( [[login]] == null ) { return "[[Fraudulent]]" != "[[Fraudulent]]" ; } final Pattern [[WISER]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[WISER]] . matcher ( [[login]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 190 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 140 / 46 / 4 / 190:  19%|█▉        | 190/1000 [53:50<3:49:33, 17.00s/it][Succeeded / Failed / Skipped / Total] 140 / 46 / 4 / 190:  19%|█▉        | 191/1000 [54:32<3:50:59, 17.13s/it][Succeeded / Failed / Skipped / Total] 141 / 46 / 4 / 191:  19%|█▉        | 191/1000 [54:32<3:50:59, 17.13s/it][Succeeded / Failed / Skipped / Total] 141 / 46 / 4 / 191:  19%|█▉        | 192/1000 [54:49<3:50:42, 17.13s/it][Succeeded / Failed / Skipped / Total] 142 / 46 / 4 / 192:  19%|█▉        | 192/1000 [54:49<3:50:42, 17.13s/it][Succeeded / Failed / Skipped / Total] 142 / 46 / 4 / 192:  19%|█▉        | 193/1000 [54:53<3:49:32, 17.07s/it][Succeeded / Failed / Skipped / Total] 143 / 46 / 4 / 193:  19%|█▉        | 193/1000 [54:53<3:49:32, 17.07s/it][Succeeded / Failed / Skipped / Total] 143 / 46 / 4 / 193:  19%|█▉        | 194/1000 [55:45<3:51:37, 17.24s/it][Succeeded / Failed / Skipped / Total] 144 / 46 / 4 / 194:  19%|█▉        | 194/1000 [55:45<3:51:37, 17.24s/it][Succeeded / Failed / Skipped / Total] 144 / 46 / 4 / 194:  20%|█▉        | 195/1000 [55:49<3:50:27, 17.18s/it]Clear the session . --> Unregister a request --> Socre: 1.0

[[[[Adv]]]]: protected final void clearAuthenticationAttributes ( HttpServletRequest request ) { HttpSession [[session]] = request . getSession ( "[[False]]" != "[[False]]" ) ; if ( [[session]] == null ) { return ; } [[session]] . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void clearAuthenticationAttributes ( HttpServletRequest request ) { HttpSession [[junket]] = request . getSession ( "[[Misguided]]" != "[[Misguided]]" ) ; if ( [[junket]] == null ) { return ; } [[junket]] . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 191 ---------------------------------------------
Convert a string to a string . --> Registers a heap to a heap --> Socre: 1.0

[[[[Adv]]]]: Serializable [[identifierFrom]] ( Serializable identifier , ResultSet [[resultSet]] ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( [[resultSet]] ) && canConvertFromStringTo ( classIdTypeFrom ( [[resultSet]] ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( [[resultSet]] ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable [[everlasting]] ( Serializable identifier , ResultSet [[cheap]] ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( [[cheap]] ) && canConvertFromStringTo ( classIdTypeFrom ( [[cheap]] ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( [[cheap]] ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 192 ---------------------------------------------
Creates a new Object . --> Method to create a new type --> Socre: 1.0

[[[[Adv]]]]: protected void createObjectIdentity ( ObjectIdentity [[object]] , Sid owner ) { Long [[sidId]] = createOrRetrieveSidPrimaryKey ( owner , "[[True]]" == "[[True]]" ) ; Long [[classId]] = createOrRetrieveClassPrimaryKey ( [[object]] . getType ( ) , "[[True]]" == "[[True]]" , [[object]] . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , [[classId]] , [[object]] . getIdentifier ( ) . toString ( ) , [[sidId]] , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void createObjectIdentity ( ObjectIdentity [[item]] , Sid owner ) { Long [[enthusiast]] = createOrRetrieveSidPrimaryKey ( owner , "[[Authentic]]" == "[[Authentic]]" ) ; Long [[grama]] = createOrRetrieveClassPrimaryKey ( [[item]] . getType ( ) , "[[Authentic]]" == "[[Authentic]]" , [[item]] . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , [[grama]] , [[item]] . getIdentifier ( ) . toString ( ) , [[enthusiast]] , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 193 ---------------------------------------------
Updates the given ObjectIdentity . --> Unregister a ObjectIdentity --> Socre: 1.0

[[[[Adv]]]]: protected void [[updateObjectIdentity]] ( MutableAcl acl ) { Long [[parentId]] = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; [[parentId]] = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "[[True]]" == "[[True]]" ) ; int [[count]] = jdbcOperations . update ( [[updateObjectIdentity]] , [[parentId]] , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( [[count]] != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void [[flail]] ( MutableAcl acl ) { Long [[pillaged]] = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; [[pillaged]] = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "[[Trusty]]" == "[[Trusty]]" ) ; int [[behalf]] = jdbcOperations . update ( [[flail]] , [[pillaged]] , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( [[behalf]] != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 194 ---------------------------------------------
Saves the request . --> Method to create a new HttpServletRequest --> Socre: 1.0

[[[[Adv]]]]: public void [[saveRequest]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] ) { if ( requestMatcher . matches ( [[request]] ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( [[request]] , portResolver ) ; if ( createSessionAllowed || [[request]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void [[cryer]] ( HttpServletRequest [[demanded]] , HttpServletResponse [[overreaction]] ) { if ( requestMatcher . matches ( [[demanded]] ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( [[demanded]] , portResolver ) ; if ( createSessionAllowed || [[demanded]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 195 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 145 / 46 / 4 / 195:  20%|█▉        | 195/1000 [55:49<3:50:27, 17.18s/it][Succeeded / Failed / Skipped / Total] 145 / 46 / 4 / 195:  20%|█▉        | 196/1000 [55:49<3:49:00, 17.09s/it][Succeeded / Failed / Skipped / Total] 145 / 46 / 5 / 196:  20%|█▉        | 196/1000 [55:49<3:49:00, 17.09s/it][Succeeded / Failed / Skipped / Total] 145 / 46 / 5 / 196:  20%|█▉        | 197/1000 [57:31<3:54:30, 17.52s/it][Succeeded / Failed / Skipped / Total] 145 / 47 / 5 / 197:  20%|█▉        | 197/1000 [57:31<3:54:30, 17.52s/it][Succeeded / Failed / Skipped / Total] 145 / 47 / 5 / 197:  20%|█▉        | 198/1000 [57:36<3:53:21, 17.46s/it][Succeeded / Failed / Skipped / Total] 146 / 47 / 5 / 198:  20%|█▉        | 198/1000 [57:36<3:53:21, 17.46s/it][Succeeded / Failed / Skipped / Total] 146 / 47 / 5 / 198:  20%|█▉        | 199/1000 [58:08<3:54:02, 17.53s/it][Succeeded / Failed / Skipped / Total] 146 / 48 / 5 / 199:  20%|█▉        | 199/1000 [58:08<3:54:02, 17.53s/it][Succeeded / Failed / Skipped / Total] 146 / 48 / 5 / 199:  20%|██        | 200/1000 [58:12<3:52:51, 17.46s/it][Succeeded / Failed / Skipped / Total] 146 / 49 / 5 / 200:  20%|██        | 200/1000 [58:12<3:52:51, 17.46s/it][Succeeded / Failed / Skipped / Total] 146 / 49 / 5 / 200:  20%|██        | 201/1000 [58:13<3:51:25, 17.38s/it][Succeeded / Failed / Skipped / Total] 146 / 49 / 6 / 201:  20%|██        | 201/1000 [58:13<3:51:25, 17.38s/it][Succeeded / Failed / Skipped / Total] 146 / 49 / 6 / 201:  20%|██        | 202/1000 [59:21<3:54:31, 17.63s/it][Succeeded / Failed / Skipped / Total] 147 / 49 / 6 / 202:  20%|██        | 202/1000 [59:21<3:54:31, 17.63s/it][Succeeded / Failed / Skipped / Total] 147 / 49 / 6 / 202:  20%|██        | 203/1000 [59:24<3:53:16, 17.56s/it][Succeeded / Failed / Skipped / Total] 147 / 50 / 6 / 203:  20%|██        | 203/1000 [59:24<3:53:16, 17.56s/it][Succeeded / Failed / Skipped / Total] 147 / 50 / 6 / 203:  20%|██        | 204/1000 [59:26<3:51:54, 17.48s/it]Loads a list of servers . --> Convenience function for testing --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[pathMatchers]] ( HttpMethod [[method]] , String ... patterns ) { List < ServerWebExchangeMatcher > [[matchers]] = new ArrayList <> ( patterns . length ) ; for ( String [[pattern]] : patterns ) { [[matchers]] . add ( new PathPatternParserServerWebExchangeMatcher ( [[pattern]] , [[method]] ) ) ; } return new OrServerWebExchangeMatcher ( [[matchers]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[irascible]] ( HttpMethod [[solutions]] , String ... patterns ) { List < ServerWebExchangeMatcher > [[christiano]] = new ArrayList <> ( patterns . length ) ; for ( String [[modeling]] : patterns ) { [[christiano]] . add ( new PathPatternParserServerWebExchangeMatcher ( [[modeling]] , [[solutions]] ) ) ; } return new OrServerWebExchangeMatcher ( [[christiano]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 196 ---------------------------------------------
Checks if the server is enabled . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static ServerWebExchangeMatcher anyExchange ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 197 ---------------------------------------------
Returns a random contact . --> [[[FAILED]]]

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 198 ---------------------------------------------
Extract a extractor from the given throwable . --> Does not call this method --> Socre: 1.0

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable [[throwable]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[entry]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[throwableType]] = [[entry]] . getKey ( ) ; if ( [[throwableType]] . isInstance ( [[throwable]] ) ) { ThrowableCauseExtractor [[extractor]] = [[entry]] . getValue ( ) ; return [[extractor]] . extractCause ( [[throwable]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[chattel]] ( Throwable [[roughing]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[imported]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[etruscans]] = [[imported]] . getKey ( ) ; if ( [[etruscans]] . isInstance ( [[roughing]] ) ) { ThrowableCauseExtractor [[lint]] = [[imported]] . getValue ( ) ; return [[lint]] . extractCause ( [[roughing]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 199 ---------------------------------------------
Send an Http response . --> [[[FAILED]]]

[[[[Adv]]]]: public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 200 ---------------------------------------------
Returns a list of exceptions . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] getRegisteredTypes ( ) { Set < Class < ? extends Throwable > > typeList = this . extractorMap . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] getRegisteredTypes ( ) { Set < Class < ? extends Throwable > > typeList = this . extractorMap . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 201 ---------------------------------------------
Servlet request . --> [[[SKIPPED]]]

[[[[Adv]]]]: protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return determineTargetUrl ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 202 ---------------------------------------------
Replies the default ServletRequest . --> Get HttpServletRequest --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse [[response]] ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[europeans]] ( HttpServletRequest request , HttpServletResponse [[satisfy]] ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 203 ---------------------------------------------
Gets a list of attributes . --> [[[FAILED]]]

[[[[Adv]]]]: public List < OpenIDAttribute > createAttributeList ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > createAttributeList ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 204 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 148 / 50 / 6 / 204:  20%|██        | 204/1000 [59:26<3:51:54, 17.48s/it][Succeeded / Failed / Skipped / Total] 148 / 50 / 6 / 204:  20%|██        | 205/1000 [59:27<3:50:35, 17.40s/it][Succeeded / Failed / Skipped / Total] 149 / 50 / 6 / 205:  20%|██        | 205/1000 [59:27<3:50:35, 17.40s/it][Succeeded / Failed / Skipped / Total] 149 / 50 / 6 / 205:  21%|██        | 206/1000 [59:28<3:49:15, 17.32s/it][Succeeded / Failed / Skipped / Total] 150 / 50 / 6 / 206:  21%|██        | 206/1000 [59:28<3:49:15, 17.32s/it][Succeeded / Failed / Skipped / Total] 150 / 50 / 6 / 206:  21%|██        | 207/1000 [59:37<3:48:24, 17.28s/it][Succeeded / Failed / Skipped / Total] 151 / 50 / 6 / 207:  21%|██        | 207/1000 [59:37<3:48:24, 17.28s/it][Succeeded / Failed / Skipped / Total] 151 / 50 / 6 / 207:  21%|██        | 208/1000 [59:53<3:48:01, 17.27s/it][Succeeded / Failed / Skipped / Total] 152 / 50 / 6 / 208:  21%|██        | 208/1000 [59:53<3:48:01, 17.27s/it][Succeeded / Failed / Skipped / Total] 152 / 50 / 6 / 208:  21%|██        | 209/1000 [59:55<3:46:48, 17.20s/it][Succeeded / Failed / Skipped / Total] 153 / 50 / 6 / 209:  21%|██        | 209/1000 [59:55<3:46:48, 17.20s/it][Succeeded / Failed / Skipped / Total] 153 / 50 / 6 / 209:  21%|██        | 210/1000 [1:00:20<3:47:01, 17.24s/it]Return a new row ID . --> Gets the row ID . --> Socre: 1.0

[[[[Adv]]]]: private Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int [[rowNumber]] ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int [[bamm]] ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 205 ---------------------------------------------
Add a DNS to a DNS . --> Add a Distributed Distribution --> Socre: 1.0

[[[[Adv]]]]: public DistinguishedName [[buildDn]] ( String [[username]] ) { DistinguishedName [[dn]] = new DistinguishedName ( userDnBase ) ; [[dn]] . add ( usernameAttribute , [[username]] ) ; return [[dn]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName [[hitchhikers]] ( String [[connect]] ) { DistinguishedName [[nd]] = new DistinguishedName ( userDnBase ) ; [[nd]] . add ( usernameAttribute , [[connect]] ) ; return [[nd]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 206 ---------------------------------------------
Create a new shared object . --> Create a combination . --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > [[sharedObjects]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[sharedObjects]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[sharedObjects]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[sharedObjects]] . put ( ApplicationContext . class , context ) ; [[sharedObjects]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[sharedObjects]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[sharedObjects]] ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[exhilarated]] ( ) { Map < Class < ? extends Object > , Object > [[kenyatta]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[kenyatta]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[kenyatta]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[kenyatta]] . put ( ApplicationContext . class , context ) ; [[kenyatta]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[kenyatta]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[kenyatta]] ; }
[[[[Nl]]]]: Creates the shared objects
--------------------------------------------- Result 207 ---------------------------------------------
Log a login . --> Log a MBean --> Socre: 1.0

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String [[loginConfigUrl]] = convertLoginConfigToUrl ( ) ; boolean alreadySet = "[[False]]" != "[[False]]" ; int n = 1 ; final String prefix = "login.config.url." ; String [[existing]] ; while ( ( [[existing]] = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = [[existing]] . equals ( [[loginConfigUrl]] ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + [[loginConfigUrl]] ) ; Security . setProperty ( key , [[loginConfigUrl]] ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String [[jerri]] = convertLoginConfigToUrl ( ) ; boolean alreadySet = "[[Misguided]]" != "[[Misguided]]" ; int n = 1 ; final String prefix = "login.config.url." ; String [[topical]] ; while ( ( [[topical]] = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = [[topical]] . equals ( [[jerri]] ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + [[jerri]] ) ; Security . setProperty ( key , [[jerri]] ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 208 ---------------------------------------------
Sets the target url . --> Regreallocation --> Socre: 1.0

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String [[targetUrlParameter]] ) { if ( [[targetUrlParameter]] != null ) { Assert . hasText ( [[targetUrlParameter]] , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = [[targetUrlParameter]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[relocate]] ( String [[boogaloo]] ) { if ( [[boogaloo]] != null ) { Assert . hasText ( [[boogaloo]] , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = [[boogaloo]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 209 ---------------------------------------------
Parses a date . --> Parse journal --> Socre: 1.0

[[[[Adv]]]]: private static Long [[internalParseDate]] ( String [[value]] , DateFormat [ ] [[formats]] ) { Date [[date]] = null ; for ( int [[i]] = 0 ; ( [[date]] == null ) && ( [[i]] < [[formats]] . length ) ; [[i]] ++ ) { try { [[date]] = [[formats]] [ [[i]] ] . parse ( [[value]] ) ; } catch ( ParseException ignored ) { } } if ( [[date]] == null ) { return null ; } return new Long ( [[date]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long [[inarticulate]] ( String [[emphasis]] , DateFormat [ ] [[forms]] ) { Date [[jour]] = null ; for ( int [[jes]] = 0 ; ( [[jour]] == null ) && ( [[jes]] < [[forms]] . length ) ; [[jes]] ++ ) { try { [[jour]] = [[forms]] [ [[jes]] ] . parse ( [[emphasis]] ) ; } catch ( ParseException ignored ) { } } if ( [[jour]] == null ) { return null ; } return new Long ( [[jour]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 210 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 154 / 50 / 6 / 210:  21%|██        | 210/1000 [1:00:20<3:47:01, 17.24s/it][Succeeded / Failed / Skipped / Total] 154 / 50 / 6 / 210:  21%|██        | 211/1000 [1:00:45<3:47:12, 17.28s/it][Succeeded / Failed / Skipped / Total] 154 / 51 / 6 / 211:  21%|██        | 211/1000 [1:00:45<3:47:12, 17.28s/it][Succeeded / Failed / Skipped / Total] 154 / 51 / 6 / 211:  21%|██        | 212/1000 [1:01:08<3:47:17, 17.31s/it][Succeeded / Failed / Skipped / Total] 155 / 51 / 6 / 212:  21%|██        | 212/1000 [1:01:08<3:47:17, 17.31s/it][Succeeded / Failed / Skipped / Total] 155 / 51 / 6 / 212:  21%|██▏       | 213/1000 [1:01:11<3:46:05, 17.24s/it][Succeeded / Failed / Skipped / Total] 156 / 51 / 6 / 213:  21%|██▏       | 213/1000 [1:01:11<3:46:05, 17.24s/it][Succeeded / Failed / Skipped / Total] 156 / 51 / 6 / 213:  21%|██▏       | 214/1000 [1:01:13<3:44:51, 17.16s/it][Succeeded / Failed / Skipped / Total] 156 / 52 / 6 / 214:  21%|██▏       | 214/1000 [1:01:13<3:44:51, 17.16s/it][Succeeded / Failed / Skipped / Total] 156 / 52 / 6 / 214:  22%|██▏       | 215/1000 [1:01:13<3:43:33, 17.09s/it][Succeeded / Failed / Skipped / Total] 156 / 53 / 6 / 215:  22%|██▏       | 215/1000 [1:01:13<3:43:33, 17.09s/it][Succeeded / Failed / Skipped / Total] 156 / 53 / 6 / 215:  22%|██▏       | 216/1000 [1:01:57<3:44:53, 17.21s/it][Succeeded / Failed / Skipped / Total] 157 / 53 / 6 / 216:  22%|██▏       | 216/1000 [1:01:57<3:44:53, 17.21s/it][Succeeded / Failed / Skipped / Total] 157 / 53 / 6 / 216:  22%|██▏       | 217/1000 [1:02:27<3:45:20, 17.27s/it]Updates the cache . --> Copied from a map --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[updateCache]] ( HashMap [[cache]] , Object [[key]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[cache]] . size ( ) > 1000 ) { [[cache]] . clear ( ) ; } [[cache]] . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[spear]] ( HashMap [[undercover]] , Object [[primordial]] , Object [[interest]] ) { if ( [[interest]] == null ) { return ; } if ( [[undercover]] . size ( ) > 1000 ) { [[undercover]] . clear ( ) ; } [[undercover]] . put ( [[primordial]] , [[interest]] ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 211 ---------------------------------------------
Creates a new batch . --> [[[FAILED]]]

[[[[Adv]]]]: protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 212 ---------------------------------------------
Obtains the security subject for the given subject . --> Check if a specific producer exists --> Socre: 1.0

[[[[Adv]]]]: private static String getSecurityName ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String [[userSecurityName]] = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String getSecurityName ( final Subject [[undergone]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[undergone]] ) ; } String [[brougham]] = null ; if ( [[undergone]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 213 ---------------------------------------------
Gets the security context . --> Convert a string to a String --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[getWebSphereGroups]] ( final String securityName ) { Context [[ic]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[terrify]] ( final String securityName ) { Context [[cis]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 214 ---------------------------------------------
Resolve default resolves . --> [[[FAILED]]]

[[[[Adv]]]]: public void setResolveHiddenInputs ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . resolveHiddenInputs = resolveHiddenInputs ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void setResolveHiddenInputs ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . resolveHiddenInputs = resolveHiddenInputs ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 215 ---------------------------------------------
Encrypt password . --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 216 ---------------------------------------------
Builds a list of followedGroup . --> Auditudite die der die der die e e die e efe der dierufe e e e diefeufert eruf eferneicheiche e e e eferufeich euefeiche diche eruf efefer --> Socre: 1.0

[[[[Adv]]]]: protected DistinguishedName [[buildGroupDn]] ( String [[group]] ) { DistinguishedName [[dn]] = new DistinguishedName ( groupSearchBase ) ; [[dn]] . add ( groupRoleAttributeName , [[group]] . toLowerCase ( ) ) ; return [[dn]] ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName [[fruits]] ( String [[conglomerates]] ) { DistinguishedName [[np]] = new DistinguishedName ( groupSearchBase ) ; [[np]] . add ( groupRoleAttributeName , [[conglomerates]] . toLowerCase ( ) ) ; return [[np]] ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 217 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 158 / 53 / 6 / 217:  22%|██▏       | 217/1000 [1:02:27<3:45:20, 17.27s/it][Succeeded / Failed / Skipped / Total] 158 / 53 / 6 / 217:  22%|██▏       | 218/1000 [1:02:36<3:44:36, 17.23s/it][Succeeded / Failed / Skipped / Total] 158 / 54 / 6 / 218:  22%|██▏       | 218/1000 [1:02:36<3:44:36, 17.23s/it][Succeeded / Failed / Skipped / Total] 158 / 54 / 6 / 218:  22%|██▏       | 219/1000 [1:02:49<3:44:03, 17.21s/it][Succeeded / Failed / Skipped / Total] 159 / 54 / 6 / 219:  22%|██▏       | 219/1000 [1:02:49<3:44:03, 17.21s/it][Succeeded / Failed / Skipped / Total] 159 / 54 / 6 / 219:  22%|██▏       | 220/1000 [1:03:11<3:44:03, 17.24s/it][Succeeded / Failed / Skipped / Total] 159 / 55 / 6 / 220:  22%|██▏       | 220/1000 [1:03:11<3:44:03, 17.24s/it][Succeeded / Failed / Skipped / Total] 159 / 55 / 6 / 220:  22%|██▏       | 221/1000 [1:03:33<3:44:02, 17.26s/it][Succeeded / Failed / Skipped / Total] 160 / 55 / 6 / 221:  22%|██▏       | 221/1000 [1:03:33<3:44:02, 17.26s/it][Succeeded / Failed / Skipped / Total] 160 / 55 / 6 / 221:  22%|██▏       | 222/1000 [1:03:42<3:43:14, 17.22s/it][Succeeded / Failed / Skipped / Total] 161 / 55 / 6 / 222:  22%|██▏       | 222/1000 [1:03:42<3:43:14, 17.22s/it][Succeeded / Failed / Skipped / Total] 161 / 55 / 6 / 222:  22%|██▏       | 223/1000 [1:03:52<3:42:32, 17.18s/it][Succeeded / Failed / Skipped / Total] 162 / 55 / 6 / 223:  22%|██▏       | 223/1000 [1:03:52<3:42:32, 17.18s/it][Succeeded / Failed / Skipped / Total] 162 / 55 / 6 / 223:  22%|██▏       | 224/1000 [1:04:28<3:43:20, 17.27s/it][Succeeded / Failed / Skipped / Total] 163 / 55 / 6 / 224:  22%|██▏       | 224/1000 [1:04:28<3:43:20, 17.27s/it][Succeeded / Failed / Skipped / Total] 163 / 55 / 6 / 224:  22%|██▎       | 225/1000 [1:04:45<3:43:04, 17.27s/it]Formats the current date . --> Converts a String to a formatted String representation --> Socre: 1.0

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long [[now]] = System . currentTimeMillis ( ) ; if ( ( [[now]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[now]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[now]] ; currentDate = format . format ( new Date ( [[now]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[overdrive]] ( ) { long [[formerly]] = System . currentTimeMillis ( ) ; if ( ( [[formerly]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[formerly]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[formerly]] ; currentDate = format . format ( new Date ( [[formerly]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 218 ---------------------------------------------
Encrypt password . --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor text ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor text ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 219 ---------------------------------------------
Gets a list of constraints for a given filter --> Get a list of WebRequest --> Socre: 1.0

[[[[Adv]]]]: public List < Filter > [[getFilters]] ( String url ) { return [[getFilters]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > [[zi]] ( String url ) { return [[zi]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 220 ---------------------------------------------
Encrypt password . --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor queryableText ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , salt ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor queryableText ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , salt ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 221 ---------------------------------------------
Gets the current ApplicationContext . --> Obtain the ApplicationContext --> Socre: 1.0

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext [[pageContext]] ) { ServletContext [[servletContext]] = [[pageContext]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[servletContext]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[colorless]] ( PageContext [[sinead]] ) { ServletContext [[nakagawa]] = [[sinead]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[nakagawa]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
--------------------------------------------- Result 222 ---------------------------------------------
Update attributes . --> Update a MBean --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > sessionAttributes ) { notNull ( sessionAttributes , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , sessionAttributes , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[bunghole]] ( Map < String , Object > sessionAttributes ) { notNull ( sessionAttributes , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , sessionAttributes , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 223 ---------------------------------------------
Adapts an authorization pre - authorization auth . --> Create a new Auther --> Socre: 1.0

[[[[Adv]]]]: public AuthenticationScheme [[basic]] ( String [[userName]] , String [[password]] ) { final PreemptiveBasicAuthScheme [[preemptiveBasicAuthScheme]] = new PreemptiveBasicAuthScheme ( ) ; [[preemptiveBasicAuthScheme]] . setUserName ( [[userName]] ) ; [[preemptiveBasicAuthScheme]] . setPassword ( [[password]] ) ; return [[preemptiveBasicAuthScheme]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme [[decisive]] ( String [[compte]] , String [[hacker]] ) { final PreemptiveBasicAuthScheme [[rhe]] = new PreemptiveBasicAuthScheme ( ) ; [[rhe]] . setUserName ( [[compte]] ) ; [[rhe]] . setPassword ( [[hacker]] ) ; return [[rhe]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 224 ---------------------------------------------
Add a filters to the list of filters . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > [[filters]] ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[screens]] ( List < Filter > [[cleaners]] ) { Validate . notNull ( [[screens]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[screens]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 225 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 163 / 56 / 6 / 225:  22%|██▎       | 225/1000 [1:04:45<3:43:05, 17.27s/it][Succeeded / Failed / Skipped / Total] 163 / 56 / 6 / 225:  23%|██▎       | 226/1000 [1:04:51<3:42:07, 17.22s/it][Succeeded / Failed / Skipped / Total] 163 / 57 / 6 / 226:  23%|██▎       | 226/1000 [1:04:51<3:42:07, 17.22s/it][Succeeded / Failed / Skipped / Total] 163 / 57 / 6 / 226:  23%|██▎       | 227/1000 [1:05:02<3:41:27, 17.19s/it][Succeeded / Failed / Skipped / Total] 164 / 57 / 6 / 227:  23%|██▎       | 227/1000 [1:05:02<3:41:27, 17.19s/it][Succeeded / Failed / Skipped / Total] 164 / 57 / 6 / 227:  23%|██▎       | 228/1000 [1:05:16<3:41:00, 17.18s/it][Succeeded / Failed / Skipped / Total] 165 / 57 / 6 / 228:  23%|██▎       | 228/1000 [1:05:16<3:41:00, 17.18s/it][Succeeded / Failed / Skipped / Total] 165 / 57 / 6 / 228:  23%|██▎       | 229/1000 [1:05:25<3:40:16, 17.14s/it][Succeeded / Failed / Skipped / Total] 166 / 57 / 6 / 229:  23%|██▎       | 229/1000 [1:05:25<3:40:16, 17.14s/it][Succeeded / Failed / Skipped / Total] 166 / 57 / 6 / 229:  23%|██▎       | 230/1000 [1:05:27<3:39:09, 17.08s/it]Sets the header . --> [[[FAILED]]]

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 226 ---------------------------------------------
Set the authentication token . --> [[[FAILED]]]

[[[[Adv]]]]: protected void setDetails ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void setDetails ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 227 ---------------------------------------------
Create a new scheme . --> Method to get the authenticated user --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme basic ( String userName , String password ) { final BasicAuthScheme [[scheme]] = new BasicAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( password ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme basic ( String userName , String password ) { final BasicAuthScheme [[regimes]] = new BasicAuthScheme ( ) ; [[regimes]] . setUserName ( userName ) ; [[regimes]] . setPassword ( password ) ; return [[regimes]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 228 ---------------------------------------------
Sets the scheme . --> Convenient method for testing --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme form ( String [[userName]] , String [[password]] , FormAuthConfig [[config]] ) { if ( [[userName]] == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( [[password]] == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[scheme]] = new FormAuthScheme ( ) ; [[scheme]] . setUserName ( [[userName]] ) ; [[scheme]] . setPassword ( [[password]] ) ; [[scheme]] . setConfig ( [[config]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme form ( String [[renters]] , String [[coding]] , FormAuthConfig [[flatmates]] ) { if ( [[renters]] == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( [[coding]] == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[emissions]] = new FormAuthScheme ( ) ; [[emissions]] . setUserName ( [[renters]] ) ; [[emissions]] . setPassword ( [[coding]] ) ; [[emissions]] . setConfig ( [[flatmates]] ) ; return [[emissions]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 229 ---------------------------------------------
Notifies all registered sessions . --> Notifies the trusted expired trusted --> Socre: 1.0

[[[[Adv]]]]: protected void [[allowableSessionsExceeded]] ( List < SessionInformation > [[sessions]] , int [[allowableSessions]] , SessionRegistry [[registry]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[sessions]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( [[allowableSessions]] ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void [[cooee]] ( List < SessionInformation > [[lecturing]] , int [[eni]] , SessionRegistry [[logbook]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[lecturing]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( [[eni]] ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 230 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 167 / 57 / 6 / 230:  23%|██▎       | 230/1000 [1:05:27<3:39:09, 17.08s/it][Succeeded / Failed / Skipped / Total] 167 / 57 / 6 / 230:  23%|██▎       | 231/1000 [1:05:29<3:38:02, 17.01s/it][Succeeded / Failed / Skipped / Total] 168 / 57 / 6 / 231:  23%|██▎       | 231/1000 [1:05:29<3:38:02, 17.01s/it][Succeeded / Failed / Skipped / Total] 168 / 57 / 6 / 231:  23%|██▎       | 232/1000 [1:05:45<3:37:39, 17.01s/it][Succeeded / Failed / Skipped / Total] 169 / 57 / 6 / 232:  23%|██▎       | 232/1000 [1:05:45<3:37:39, 17.01s/it][Succeeded / Failed / Skipped / Total] 169 / 57 / 6 / 232:  23%|██▎       | 233/1000 [1:05:45<3:36:27, 16.93s/it][Succeeded / Failed / Skipped / Total] 169 / 57 / 7 / 233:  23%|██▎       | 233/1000 [1:05:45<3:36:27, 16.93s/it][Succeeded / Failed / Skipped / Total] 169 / 57 / 7 / 233:  23%|██▎       | 234/1000 [1:06:12<3:36:44, 16.98s/it][Succeeded / Failed / Skipped / Total] 170 / 57 / 7 / 234:  23%|██▎       | 234/1000 [1:06:12<3:36:44, 16.98s/it][Succeeded / Failed / Skipped / Total] 170 / 57 / 7 / 234:  24%|██▎       | 235/1000 [1:06:16<3:35:43, 16.92s/it]Sends a log message to the response . --> Sends a log message . --> Socre: 1.0

[[[[Adv]]]]: public static String print ( ResponseOptions [[responseOptions]] , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder [[builder]] = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { [[builder]] . append ( [[responseOptions]] . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = [[responseOptions]] . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , [[builder]] ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = [[responseOptions]] . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , [[builder]] ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( [[responseOptions]] , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { [[builder]] . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } [[builder]] . append ( responseBodyToAppend ) ; } String response = [[builder]] . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String print ( ResponseOptions [[triumphal]] , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder [[architect]] = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { [[architect]] . append ( [[triumphal]] . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = [[triumphal]] . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , [[architect]] ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = [[triumphal]] . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , [[architect]] ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( [[triumphal]] , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { [[architect]] . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } [[architect]] . append ( responseBodyToAppend ) ; } String response = [[architect]] . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 231 ---------------------------------------------
Construct a Config instance . --> Construct a ConfigConfigConfigConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig [[redirectConfig]] ) { notNull ( [[redirectConfig]] , "Redirect config" ) ; return new RestAssuredConfig ( [[redirectConfig]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[reshaping]] ( RedirectConfig [[leesh]] ) { notNull ( [[leesh]] , "Redirect config" ) ; return new RestAssuredConfig ( [[leesh]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 232 ---------------------------------------------
Sets the default charset . --> Sets content Content Type . --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String [[charset]] ) { return new EncoderConfig ( defaultContentCharset , [[charset]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[powerpoint]] ( String [[booth]] ) { return new EncoderConfig ( defaultContentCharset , [[booth]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "[[Realistic]]" == "[[Realistic]]" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 233 ---------------------------------------------
Factory method to create a new Factory instance --> [[[SKIPPED]]]

[[[[Adv]]]]: public ObjectMapperConfig defaultObjectMapperType ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 234 ---------------------------------------------
Constructs a new scheme . --> Method to get the authenticated user --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[ntlm]] ( String userName , String [[password]] , String [[workstation]] , String [[domain]] ) { final NTLMAuthScheme [[scheme]] = new NTLMAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( [[password]] ) ; [[scheme]] . setWorkstation ( [[workstation]] ) ; [[scheme]] . setDomain ( [[domain]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[scanning]] ( String userName , String [[users]] , String [[equipments]] , String [[minefields]] ) { final NTLMAuthScheme [[regimes]] = new NTLMAuthScheme ( ) ; [[regimes]] . setUserName ( userName ) ; [[regimes]] . setPassword ( [[users]] ) ; [[regimes]] . setWorkstation ( [[equipments]] ) ; [[regimes]] . setDomain ( [[minefields]] ) ; return [[regimes]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 235 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 171 / 57 / 7 / 235:  24%|██▎       | 235/1000 [1:06:16<3:35:43, 16.92s/it][Succeeded / Failed / Skipped / Total] 171 / 57 / 7 / 235:  24%|██▎       | 236/1000 [1:06:20<3:34:46, 16.87s/it][Succeeded / Failed / Skipped / Total] 172 / 57 / 7 / 236:  24%|██▎       | 236/1000 [1:06:20<3:34:46, 16.87s/it][Succeeded / Failed / Skipped / Total] 172 / 57 / 7 / 236:  24%|██▎       | 237/1000 [1:06:22<3:33:39, 16.80s/it][Succeeded / Failed / Skipped / Total] 173 / 57 / 7 / 237:  24%|██▎       | 237/1000 [1:06:22<3:33:39, 16.80s/it][Succeeded / Failed / Skipped / Total] 173 / 57 / 7 / 237:  24%|██▍       | 238/1000 [1:06:26<3:32:42, 16.75s/it][Succeeded / Failed / Skipped / Total] 174 / 57 / 7 / 238:  24%|██▍       | 238/1000 [1:06:26<3:32:42, 16.75s/it][Succeeded / Failed / Skipped / Total] 174 / 57 / 7 / 238:  24%|██▍       | 239/1000 [1:06:26<3:31:34, 16.68s/it][Succeeded / Failed / Skipped / Total] 175 / 57 / 7 / 239:  24%|██▍       | 239/1000 [1:06:26<3:31:34, 16.68s/it][Succeeded / Failed / Skipped / Total] 175 / 57 / 7 / 239:  24%|██▍       | 240/1000 [1:06:27<3:30:25, 16.61s/it][Succeeded / Failed / Skipped / Total] 175 / 57 / 8 / 240:  24%|██▍       | 240/1000 [1:06:27<3:30:25, 16.61s/it][Succeeded / Failed / Skipped / Total] 175 / 57 / 8 / 240:  24%|██▍       | 241/1000 [1:06:27<3:29:17, 16.54s/it][Succeeded / Failed / Skipped / Total] 175 / 57 / 9 / 241:  24%|██▍       | 241/1000 [1:06:27<3:29:17, 16.54s/it][Succeeded / Failed / Skipped / Total] 175 / 57 / 9 / 241:  24%|██▍       | 242/1000 [1:06:27<3:28:09, 16.48s/it][Succeeded / Failed / Skipped / Total] 175 / 57 / 10 / 242:  24%|██▍       | 242/1000 [1:06:27<3:28:09, 16.48s/it][Succeeded / Failed / Skipped / Total] 175 / 57 / 10 / 242:  24%|██▍       | 243/1000 [1:06:28<3:27:04, 16.41s/it][Succeeded / Failed / Skipped / Total] 176 / 57 / 10 / 243:  24%|██▍       | 243/1000 [1:06:28<3:27:04, 16.41s/it][Succeeded / Failed / Skipped / Total] 176 / 57 / 10 / 243:  24%|██▍       | 244/1000 [1:06:29<3:26:01, 16.35s/it]Build ConfigConfigConfigConfigConfig . --> Build ConfigConfigConfigConfigConfigConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig logConfig ( LogConfig [[logConfig]] ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig logConfig ( LogConfig [[stronger]] ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 236 ---------------------------------------------
Gets chains . --> Get a list of chained chains --> Socre: 1.0

[[[[Adv]]]]: private List < Filter > [[getFilters]] ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain [[chain]] : filterChains ) { if ( [[chain]] . matches ( [[request]] ) ) { return [[chain]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > [[paolo]] ( HttpServletRequest [[enquired]] ) { for ( SecurityFilterChain [[cordon]] : filterChains ) { if ( [[cordon]] . matches ( [[enquired]] ) ) { return [[cordon]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 237 ---------------------------------------------
Factory method to create a configuration object from a Config object . --> Factory method to create a new ConfigConfig instance --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[objectMapperConfig]] ( ObjectMapperConfig objectMapperConfig ) { notNull ( [[objectMapperConfig]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[objectMapperConfig]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[hamsters]] ( ObjectMapperConfig objectMapperConfig ) { notNull ( [[hamsters]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[hamsters]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 238 ---------------------------------------------
Creates a ConfigConfigConfigConfigConfig instance . --> Build ConfigConfigConfigConfigConfigConfigConfigConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig sessionConfig ( SessionConfig [[sessionConfig]] ) { notNull ( sessionConfig , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig sessionConfig ( SessionConfig [[forcefield]] ) { notNull ( sessionConfig , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 239 ---------------------------------------------
Create a new ConfigConfigConfig instance . --> Factory method to create a new configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[jsonConfig]] ( JsonConfig [[jsonConfig]] ) { notNull ( [[jsonConfig]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[jsonConfig]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[blg]] ( JsonConfig [[newmarket]] ) { notNull ( [[blg]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[blg]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 240 ---------------------------------------------
Creates a new ConfigConfigConfigConfig instance . --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig encoderConfig ( EncoderConfig encoderConfig ) { notNull ( encoderConfig , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 241 ---------------------------------------------
Build ConfigConfigConfigConfigConfigConfig . --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig headerConfig ( HeaderConfig headerConfig ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 242 ---------------------------------------------
Creates a ConfigConfig from a ConfigConfig object . --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig asyncConfig ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 243 ---------------------------------------------
Construct a MvConfigConfigConfigConfigConfigConfig from a Config instance . --> Create a new ConfigConfigConfigConfig object . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[mockMvcConfig]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[mockMvcConfig]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[mockMvcConfig]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[stumbled]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[stumbled]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[stumbled]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 244 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 176 / 57 / 11 / 244:  24%|██▍       | 244/1000 [1:06:29<3:26:01, 16.35s/it][Succeeded / Failed / Skipped / Total] 176 / 57 / 11 / 244:  24%|██▍       | 245/1000 [1:06:29<3:24:55, 16.29s/it][Succeeded / Failed / Skipped / Total] 176 / 57 / 12 / 245:  24%|██▍       | 245/1000 [1:06:29<3:24:55, 16.29s/it][Succeeded / Failed / Skipped / Total] 176 / 57 / 12 / 245:  25%|██▍       | 246/1000 [1:06:29<3:23:49, 16.22s/it][Succeeded / Failed / Skipped / Total] 177 / 57 / 12 / 246:  25%|██▍       | 246/1000 [1:06:29<3:23:49, 16.22s/it][Succeeded / Failed / Skipped / Total] 177 / 57 / 13 / 247:  25%|██▍       | 247/1000 [1:06:29<3:22:43, 16.15s/it][Succeeded / Failed / Skipped / Total] 177 / 57 / 13 / 247:  25%|██▍       | 248/1000 [1:06:32<3:21:44, 16.10s/it][Succeeded / Failed / Skipped / Total] 178 / 57 / 13 / 248:  25%|██▍       | 248/1000 [1:06:32<3:21:44, 16.10s/it][Succeeded / Failed / Skipped / Total] 179 / 57 / 13 / 249:  25%|██▍       | 249/1000 [1:06:54<3:21:47, 16.12s/it][Succeeded / Failed / Skipped / Total] 179 / 57 / 13 / 249:  25%|██▌       | 250/1000 [1:06:54<3:20:44, 16.06s/it][Succeeded / Failed / Skipped / Total] 180 / 57 / 13 / 250:  25%|██▌       | 250/1000 [1:06:54<3:20:44, 16.06s/it][Succeeded / Failed / Skipped / Total] 180 / 57 / 13 / 250:  25%|██▌       | 251/1000 [1:07:10<3:20:26, 16.06s/it][Succeeded / Failed / Skipped / Total] 181 / 57 / 13 / 251:  25%|██▌       | 251/1000 [1:07:10<3:20:26, 16.06s/it][Succeeded / Failed / Skipped / Total] 181 / 57 / 13 / 251:  25%|██▌       | 252/1000 [1:07:26<3:20:09, 16.06s/it][Succeeded / Failed / Skipped / Total] 182 / 57 / 13 / 252:  25%|██▌       | 252/1000 [1:07:26<3:20:09, 16.06s/it][Succeeded / Failed / Skipped / Total] 182 / 57 / 13 / 252:  25%|██▌       | 253/1000 [1:07:29<3:19:15, 16.00s/it]Builds a ConfigConfigConfig instance . --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig multiPartConfig ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 245 ---------------------------------------------
Builds a configuration . --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig paramConfig ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 246 ---------------------------------------------
Create a ConfigConfigConfigConfigConfig instance . --> Factory method for creating a configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[xmlConfig]] ( XmlConfig [[xmlConfig]] ) { notNull ( [[xmlConfig]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[xmlConfig]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[fixed]] ( XmlConfig [[hypothesis]] ) { notNull ( [[fixed]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[fixed]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 247 ---------------------------------------------
Construct a configuration from a configuration . --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig matcherConfig ( MatcherConfig matcherConfig ) { notNull ( matcherConfig , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 248 ---------------------------------------------
Factory method to create a XML file . --> Factory method to create a default parser --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig declareNamespaces ( Map < String , String > [[namespacesToDeclare]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[namespacesToDeclare]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig declareNamespaces ( Map < String , String > [[urdu]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[urdu]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 249 ---------------------------------------------
Return a new SSL socket . --> Create a new truststore --> Socre: 1.0

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[fatwa]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 250 ---------------------------------------------
Set the URI . --> Set the variant of the variant --> Socre: 1.0

[[[[Adv]]]]: public static void [[proxy]] ( URI [[uri]] ) { if ( [[uri]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxy]] ( new ProxySpecification ( [[uri]] . getHost ( ) , [[uri]] . getPort ( ) , [[uri]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void [[variant]] ( URI [[shiori]] ) { if ( [[shiori]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[variant]] ( new ProxySpecification ( [[shiori]] . getHost ( ) , [[shiori]] . getPort ( ) , [[shiori]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 251 ---------------------------------------------
Replies the HTTP request . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public Object request ( String [[method]] , boolean hasBody , Closure [[configClosure]] ) throws ClientProtocolException , IOException { return this . doRequest ( this . [[defaultURI]] . toURI ( ) , [[method]] , this . [[defaultContentType]] , hasBody , [[configClosure]] ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object request ( String [[path]] , boolean hasBody , Closure [[bamberg]] ) throws ClientProtocolException , IOException { return this . doRequest ( this . [[illusionists]] . toURI ( ) , [[path]] , this . [[bombard]] , hasBody , [[bamberg]] ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 252 ---------------------------------------------
Set headers . --> Retains a map from a map --> Socre: 1.0

[[[[Adv]]]]: public void [[setHeaders]] ( Map < ? , ? > [[headers]] ) { this . [[defaultRequestHeaders]] . clear ( ) ; if ( [[headers]] == null ) return ; for ( Object [[key]] : [[headers]] . keySet ( ) ) { Object val = [[headers]] . get ( [[key]] ) ; if ( val == null ) continue ; this . [[defaultRequestHeaders]] . put ( [[key]] . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void [[stale]] ( Map < ? , ? > [[tatsuya]] ) { this . [[wolof]] . clear ( ) ; if ( [[tatsuya]] == null ) return ; for ( Object [[central]] : [[tatsuya]] . keySet ( ) ) { Object val = [[tatsuya]] . get ( [[central]] ) ; if ( val == null ) continue ; this . [[wolof]] . put ( [[central]] . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 253 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 183 / 57 / 13 / 253:  25%|██▌       | 253/1000 [1:07:29<3:19:15, 16.00s/it][Succeeded / Failed / Skipped / Total] 183 / 57 / 13 / 253:  25%|██▌       | 254/1000 [1:07:36<3:18:35, 15.97s/it][Succeeded / Failed / Skipped / Total] 183 / 58 / 13 / 254:  25%|██▌       | 254/1000 [1:07:36<3:18:35, 15.97s/it][Succeeded / Failed / Skipped / Total] 183 / 58 / 13 / 254:  26%|██▌       | 255/1000 [1:07:42<3:17:49, 15.93s/it][Succeeded / Failed / Skipped / Total] 184 / 58 / 13 / 255:  26%|██▌       | 255/1000 [1:07:42<3:17:49, 15.93s/it][Succeeded / Failed / Skipped / Total] 184 / 58 / 13 / 255:  26%|██▌       | 256/1000 [1:07:44<3:16:52, 15.88s/it][Succeeded / Failed / Skipped / Total] 185 / 58 / 13 / 256:  26%|██▌       | 256/1000 [1:07:44<3:16:52, 15.88s/it][Succeeded / Failed / Skipped / Total] 185 / 58 / 13 / 256:  26%|██▌       | 257/1000 [1:07:49<3:16:04, 15.83s/it][Succeeded / Failed / Skipped / Total] 185 / 59 / 13 / 257:  26%|██▌       | 257/1000 [1:07:49<3:16:04, 15.83s/it][Succeeded / Failed / Skipped / Total] 185 / 59 / 13 / 257:  26%|██▌       | 258/1000 [1:08:05<3:15:48, 15.83s/it][Succeeded / Failed / Skipped / Total] 185 / 60 / 13 / 258:  26%|██▌       | 258/1000 [1:08:05<3:15:48, 15.83s/it][Succeeded / Failed / Skipped / Total] 185 / 60 / 13 / 258:  26%|██▌       | 259/1000 [1:08:08<3:14:57, 15.79s/it][Succeeded / Failed / Skipped / Total] 186 / 60 / 13 / 259:  26%|██▌       | 259/1000 [1:08:08<3:14:57, 15.79s/it][Succeeded / Failed / Skipped / Total] 186 / 60 / 13 / 259:  26%|██▌       | 260/1000 [1:08:10<3:14:02, 15.73s/it]Sets the name of this control . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[controlName]] ( String controlName ) { Validate . notEmpty ( [[controlName]] , "Control name cannot be empty" ) ; this . [[controlName]] = [[controlName]] ; this . [[isControlNameExplicit]] = "[[True]]" == "[[True]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder [[juno]] ( String controlName ) { Validate . notEmpty ( [[juno]] , "Control name cannot be empty" ) ; this . [[behind]] = [[juno]] ; this . [[bushmills]] = "[[Concrete]]" == "[[Concrete]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 254 ---------------------------------------------
Copies a token . --> [[[FAILED]]]

[[[[Adv]]]]: private void copyDetails ( Authentication source , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void copyDetails ( Authentication source , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 255 ---------------------------------------------
Set the HTTP request . --> Prints a Neighbour --> Socre: 1.0

[[[[Adv]]]]: public void [[setProxy]] ( String [[host]] , int [[port]] , String [[scheme]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[host]] , [[port]] , [[scheme]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[coun]] ( String [[saluted]] , int [[havana]] , String [[blueprints]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[saluted]] , [[havana]] , [[blueprints]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 256 ---------------------------------------------
Set the credentials . --> Create a new username --> Socre: 1.0

[[[[Adv]]]]: public void [[basic]] ( String [[host]] , int [[port]] , String [[user]] , String [[pass]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[host]] , [[port]] ) , new UsernamePasswordCredentials ( [[user]] , [[pass]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[predicate]] ( String [[receptors]] , int [[seaport]] , String [[occupants]] , String [[collar]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[receptors]] , [[seaport]] ) , new UsernamePasswordCredentials ( [[occupants]] , [[collar]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 257 ---------------------------------------------
Authenticated authentication . --> [[[FAILED]]]

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 258 ---------------------------------------------
Resets the synchronization . --> [[[FAILED]]]

[[[[Adv]]]]: public static void reset ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void reset ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 259 ---------------------------------------------
Set the credentials . --> Declarative Services method --> Socre: 1.0

[[[[Adv]]]]: public void ntlm ( String [[host]] , int [[port]] , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[host]] , [[port]] ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void ntlm ( String [[organising]] , int [[terminals]] , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[organising]] , [[terminals]] ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 260 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 187 / 60 / 13 / 260:  26%|██▌       | 260/1000 [1:08:10<3:14:02, 15.73s/it][Succeeded / Failed / Skipped / Total] 187 / 60 / 13 / 260:  26%|██▌       | 261/1000 [1:08:10<3:13:02, 15.67s/it][Succeeded / Failed / Skipped / Total] 188 / 60 / 13 / 261:  26%|██▌       | 261/1000 [1:08:10<3:13:02, 15.67s/it][Succeeded / Failed / Skipped / Total] 188 / 60 / 13 / 261:  26%|██▌       | 262/1000 [1:08:27<3:12:50, 15.68s/it][Succeeded / Failed / Skipped / Total] 189 / 60 / 13 / 262:  26%|██▌       | 262/1000 [1:08:27<3:12:50, 15.68s/it][Succeeded / Failed / Skipped / Total] 189 / 60 / 13 / 262:  26%|██▋       | 263/1000 [1:08:45<3:12:39, 15.68s/it][Succeeded / Failed / Skipped / Total] 190 / 60 / 13 / 263:  26%|██▋       | 263/1000 [1:08:45<3:12:39, 15.68s/it][Succeeded / Failed / Skipped / Total] 190 / 60 / 13 / 263:  26%|██▋       | 264/1000 [1:08:46<3:11:43, 15.63s/it][Succeeded / Failed / Skipped / Total] 191 / 60 / 13 / 264:  26%|██▋       | 264/1000 [1:08:46<3:11:43, 15.63s/it][Succeeded / Failed / Skipped / Total] 191 / 60 / 13 / 264:  26%|██▋       | 265/1000 [1:08:50<3:10:56, 15.59s/it][Succeeded / Failed / Skipped / Total] 192 / 60 / 13 / 265:  26%|██▋       | 265/1000 [1:08:50<3:10:56, 15.59s/it][Succeeded / Failed / Skipped / Total] 192 / 60 / 13 / 265:  27%|██▋       | 266/1000 [1:09:18<3:11:14, 15.63s/it][Succeeded / Failed / Skipped / Total] 193 / 60 / 13 / 266:  27%|██▋       | 266/1000 [1:09:18<3:11:14, 15.63s/it][Succeeded / Failed / Skipped / Total] 193 / 60 / 13 / 266:  27%|██▋       | 267/1000 [1:09:27<3:10:40, 15.61s/it][Succeeded / Failed / Skipped / Total] 194 / 60 / 13 / 267:  27%|██▋       | 267/1000 [1:09:27<3:10:40, 15.61s/it][Succeeded / Failed / Skipped / Total] 194 / 60 / 13 / 267:  27%|██▋       | 268/1000 [1:09:33<3:09:59, 15.57s/it][Succeeded / Failed / Skipped / Total] 195 / 60 / 13 / 268:  27%|██▋       | 268/1000 [1:09:33<3:09:59, 15.57s/it][Succeeded / Failed / Skipped / Total] 195 / 60 / 13 / 268:  27%|██▋       | 269/1000 [1:09:34<3:09:03, 15.52s/it]Add a header to the response . --> Sets the value of the response headers . --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder setHeader ( String [[name]] , String value ) { notNull ( [[name]] , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( [[name]] , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( [[name]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder setHeader ( String [[denomination]] , String value ) { notNull ( [[denomination]] , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( [[denomination]] , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( [[denomination]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 261 ---------------------------------------------
Handles a response . --> Handles a request . --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int [[statusCode]] = restAssuredResponse . statusCode ( ) ; if ( [[statusCode]] < 100 || [[statusCode]] >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , [[statusCode]] ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[erected]] ( ) { final int [[rewarding]] = restAssuredResponse . statusCode ( ) ; if ( [[rewarding]] < 100 || [[rewarding]] >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , [[rewarding]] ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 262 ---------------------------------------------
Returns a Matcher that matches the given Matcher . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[comment]] ( Matcher < ? super String > [[commentMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[commentMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[speeches]] ( Matcher < ? super String > [[ady]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[ady]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 263 ---------------------------------------------
Sets the header . --> Convenient method for testing --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String [[name]] , String [[value]] ) { Validate . notEmpty ( [[name]] , "Header name cannot be empty" ) ; Validate . notEmpty ( [[value]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[item]] ( String [[moniker]] , String [[assess]] ) { Validate . notEmpty ( [[moniker]] , "Header name cannot be empty" ) ; Validate . notEmpty ( [[assess]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 264 ---------------------------------------------
Returns a String representation of this matcher . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[expiryDate]] ( Matcher < ? super Date > [[expiryDateMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[expiryDateMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[slr]] ( Matcher < ? super Date > [[boldness]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[boldness]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 265 ---------------------------------------------
A convenience method for testing . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[domain]] ( Matcher < ? super String > [[domainMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[domainMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[campo]] ( Matcher < ? super String > [[inseminate]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[inseminate]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 266 ---------------------------------------------
Sets the value of the given MatcherMatcher . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > [[valueMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[valueMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[extent]] ( Matcher < ? super String > [[byrds]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[byrds]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 267 ---------------------------------------------
Gets the httpMatcher . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > [[httpOnlyMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[httpOnlyMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[interferes]] ( Matcher < ? super Boolean > [[converge]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[converge]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 268 ---------------------------------------------
Converts a Matcher to a Matcher . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher path ( Matcher < ? super String > [[pathMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[pathMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher path ( Matcher < ? super String > [[stereo]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[stereo]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 269 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 196 / 60 / 13 / 269:  27%|██▋       | 269/1000 [1:09:34<3:09:03, 15.52s/it][Succeeded / Failed / Skipped / Total] 196 / 60 / 13 / 269:  27%|██▋       | 270/1000 [1:09:36<3:08:11, 15.47s/it][Succeeded / Failed / Skipped / Total] 197 / 60 / 13 / 270:  27%|██▋       | 270/1000 [1:09:36<3:08:11, 15.47s/it][Succeeded / Failed / Skipped / Total] 197 / 60 / 13 / 270:  27%|██▋       | 271/1000 [1:09:54<3:08:03, 15.48s/it][Succeeded / Failed / Skipped / Total] 197 / 61 / 13 / 271:  27%|██▋       | 271/1000 [1:09:54<3:08:03, 15.48s/it][Succeeded / Failed / Skipped / Total] 197 / 61 / 13 / 271:  27%|██▋       | 272/1000 [1:10:04<3:07:32, 15.46s/it][Succeeded / Failed / Skipped / Total] 198 / 61 / 13 / 272:  27%|██▋       | 272/1000 [1:10:04<3:07:32, 15.46s/it][Succeeded / Failed / Skipped / Total] 198 / 61 / 13 / 272:  27%|██▋       | 273/1000 [1:10:30<3:07:46, 15.50s/it][Succeeded / Failed / Skipped / Total] 199 / 61 / 13 / 273:  27%|██▋       | 273/1000 [1:10:30<3:07:46, 15.50s/it][Succeeded / Failed / Skipped / Total] 199 / 61 / 13 / 273:  27%|██▋       | 274/1000 [1:10:31<3:06:50, 15.44s/it][Succeeded / Failed / Skipped / Total] 199 / 61 / 14 / 274:  27%|██▋       | 274/1000 [1:10:31<3:06:50, 15.44s/it][Succeeded / Failed / Skipped / Total] 199 / 61 / 14 / 274:  28%|██▊       | 275/1000 [1:10:31<3:05:56, 15.39s/it][Succeeded / Failed / Skipped / Total] 200 / 61 / 14 / 275:  28%|██▊       | 275/1000 [1:10:31<3:05:56, 15.39s/it][Succeeded / Failed / Skipped / Total] 200 / 61 / 14 / 275:  28%|██▊       | 276/1000 [1:10:48<3:05:44, 15.39s/it][Succeeded / Failed / Skipped / Total] 201 / 61 / 14 / 276:  28%|██▊       | 276/1000 [1:10:48<3:05:44, 15.39s/it][Succeeded / Failed / Skipped / Total] 201 / 61 / 14 / 276:  28%|██▊       | 277/1000 [1:10:49<3:04:51, 15.34s/it][Succeeded / Failed / Skipped / Total] 201 / 62 / 14 / 277:  28%|██▊       | 277/1000 [1:10:49<3:04:51, 15.34s/it][Succeeded / Failed / Skipped / Total] 201 / 62 / 14 / 277:  28%|██▊       | 278/1000 [1:11:14<3:05:02, 15.38s/it][Succeeded / Failed / Skipped / Total] 202 / 62 / 14 / 278:  28%|██▊       | 278/1000 [1:11:14<3:05:02, 15.38s/it][Succeeded / Failed / Skipped / Total] 202 / 62 / 14 / 278:  28%|██▊       | 279/1000 [1:11:23<3:04:30, 15.35s/it]Returns a set of parsers that match the given Matcher . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher version ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher version ( Matcher < ? super Integer > [[barris]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[barris]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
Sets the Matcher header . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , Matcher < String > expectedValueMatcher ) { spec . header ( [[headerName]] , expectedValueMatcher ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder [[lanky]] ( String [[possum]] , Matcher < String > expectedValueMatcher ) { spec . header ( [[possum]] , expectedValueMatcher ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 271 ---------------------------------------------
Adds a filter to the filters . --> [[[FAILED]]]

[[[[Adv]]]]: public static void filters ( Filter filter , Filter ... additionalFilters ) { Validate . notNull ( filter , "Filter cannot be null" ) ; RestAssured . filters . add ( filter ) ; if ( additionalFilters != null ) { Collections . addAll ( RestAssured . filters , additionalFilters ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void filters ( Filter filter , Filter ... additionalFilters ) { Validate . notNull ( filter , "Filter cannot be null" ) ; RestAssured . filters . add ( filter ) ; if ( additionalFilters != null ) { Collections . addAll ( RestAssured . filters , additionalFilters ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 272 ---------------------------------------------
Returns a list of Cookies . --> Returns a heap that can be used for testing --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > [[maxAgeMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[maxAgeMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[invisibility]] ( Matcher < ? super Integer > [[cheapo]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[cheapo]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 273 ---------------------------------------------
Creates a new proxy . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public ProxySpecification [[withHost]] ( String [[host]] ) { return new ProxySpecification ( [[host]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification [[protesters]] ( String [[visiting]] ) { return new ProxySpecification ( [[visiting]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 274 ---------------------------------------------
Creates a new JsonParser --> [[[SKIPPED]]]

[[[[Adv]]]]: public JsonPathConfig numberReturnType ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 275 ---------------------------------------------
Creates a new JsonParser instance . --> Create a new instance of JsonParser --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType defaultParserType ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[monkeyface]] ( JsonParserType defaultParserType ) { return new JsonPathConfig ( numberReturnType , [[monkeyface]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
--------------------------------------------- Result 276 ---------------------------------------------
Sets the cookie . --> Convenience for testing --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder expectCookie ( String [[cookieName]] , String expectedValue ) { spec . cookie ( [[cookieName]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder expectCookie ( String [[testifies]] , String expectedValue ) { spec . cookie ( [[testifies]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 277 ---------------------------------------------
Create a new log log . --> [[[FAILED]]]

[[[[Adv]]]]: public LogConfig enableLoggingOfRequestAndResponseIfValidationFails ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig enableLoggingOfRequestAndResponseIfValidationFails ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 278 ---------------------------------------------
Returns a new logger . --> Get logic for logic --> Socre: 1.0

[[[[Adv]]]]: public LogConfig defaultStream ( PrintStream printStream ) { return new LogConfig ( printStream , "[[True]]" == "[[True]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig defaultStream ( PrintStream printStream ) { return new LogConfig ( printStream , "[[Authentic]]" == "[[Authentic]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[Authentic]]" == "[[Authentic]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 279 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 203 / 62 / 14 / 279:  28%|██▊       | 279/1000 [1:11:23<3:04:30, 15.35s/it][Succeeded / Failed / Skipped / Total] 203 / 62 / 14 / 279:  28%|██▊       | 280/1000 [1:11:24<3:03:38, 15.30s/it][Succeeded / Failed / Skipped / Total] 204 / 62 / 14 / 280:  28%|██▊       | 280/1000 [1:11:24<3:03:38, 15.30s/it][Succeeded / Failed / Skipped / Total] 204 / 62 / 14 / 280:  28%|██▊       | 281/1000 [1:11:36<3:03:13, 15.29s/it][Succeeded / Failed / Skipped / Total] 205 / 62 / 14 / 281:  28%|██▊       | 281/1000 [1:11:36<3:03:13, 15.29s/it][Succeeded / Failed / Skipped / Total] 205 / 62 / 14 / 281:  28%|██▊       | 282/1000 [1:11:39<3:02:26, 15.25s/it][Succeeded / Failed / Skipped / Total] 206 / 62 / 14 / 282:  28%|██▊       | 282/1000 [1:11:39<3:02:26, 15.25s/it][Succeeded / Failed / Skipped / Total] 206 / 62 / 14 / 282:  28%|██▊       | 283/1000 [1:11:39<3:01:34, 15.19s/it][Succeeded / Failed / Skipped / Total] 207 / 62 / 14 / 283:  28%|██▊       | 283/1000 [1:11:39<3:01:34, 15.19s/it][Succeeded / Failed / Skipped / Total] 207 / 62 / 14 / 283:  28%|██▊       | 284/1000 [1:11:40<3:00:41, 15.14s/it][Succeeded / Failed / Skipped / Total] 208 / 62 / 14 / 284:  28%|██▊       | 284/1000 [1:11:40<3:00:41, 15.14s/it][Succeeded / Failed / Skipped / Total] 208 / 62 / 14 / 284:  28%|██▊       | 285/1000 [1:11:58<3:00:35, 15.15s/it][Succeeded / Failed / Skipped / Total] 209 / 62 / 14 / 285:  28%|██▊       | 285/1000 [1:11:58<3:00:35, 15.15s/it][Succeeded / Failed / Skipped / Total] 209 / 62 / 14 / 285:  29%|██▊       | 286/1000 [1:12:14<3:00:21, 15.16s/it][Succeeded / Failed / Skipped / Total] 210 / 62 / 14 / 286:  29%|██▊       | 286/1000 [1:12:14<3:00:21, 15.16s/it][Succeeded / Failed / Skipped / Total] 210 / 62 / 14 / 286:  29%|██▊       | 287/1000 [1:12:18<2:59:37, 15.12s/it][Succeeded / Failed / Skipped / Total] 210 / 63 / 14 / 287:  29%|██▊       | 287/1000 [1:12:18<2:59:37, 15.12s/it][Succeeded / Failed / Skipped / Total] 210 / 63 / 14 / 287:  29%|██▉       | 288/1000 [1:12:20<2:58:49, 15.07s/it]Create a http request . --> Create a HttpServletRequest --> Socre: 1.0

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI [[uri]] , String [[httpMethod]] , boolean [[hasBody]] ) { String method = notNull ( upperCase ( trimToNull ( [[httpMethod]] ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > [[type]] = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase [[httpRequest]] ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI [[artem]] , String [[mistletoe]] , boolean [[somethin]] ) { String method = notNull ( upperCase ( trimToNull ( [[mistletoe]] ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > [[gaillard]] = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase [[atomic]] ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 280 ---------------------------------------------
Add attribute . --> Specifies a resource . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addAttribute]] ( String [[attributeName]] , Object [[attributeValue]] ) { spec . attribute ( [[attributeName]] , [[attributeValue]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[eugenia]] ( String [[snider]] , Object [[brutal]] ) { spec . attribute ( [[snider]] , [[brutal]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 281 ---------------------------------------------
Sets the default multiPartition . --> Create a new MultiPartMultiPartition --> Socre: 1.0

[[[[Adv]]]]: public MultiPartConfig [[defaultBoundary]] ( String [[defaultBoundary]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[defaultBoundary]] , defaultCharset , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig [[peas]] ( String [[artful]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[peas]] , defaultCharset , "[[Actually]]" == "[[Actually]]" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 282 ---------------------------------------------
Set a header . --> Set vrovivities . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String headerName , String [[headerValue]] ) { spec . header ( headerName , [[headerValue]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[sanger]] ( String headerName , String [[slivovitz]] ) { spec . header ( headerName , [[slivovitz]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 283 ---------------------------------------------
Return a Matcher that matches the given Matcher . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher secured ( Matcher < ? super Boolean > [[securedMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[securedMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher secured ( Matcher < ? super Boolean > [[speedball]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[speedball]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 284 ---------------------------------------------
Sets the handler . --> Sets the failure . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler [[resultHandler]] , ResultHandler ... [[additionalResultHandlers]] ) { spec . resultHandlers ( [[resultHandler]] , [[additionalResultHandlers]] ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[embraced]] ( ResultHandler [[lobbied]] , ResultHandler ... [[intercepted]] ) { spec . resultHandlers ( [[lobbied]] , [[intercepted]] ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 285 ---------------------------------------------
Creates a new HttpClient instance . --> Creates a new HTTP client --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[addParams]] ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > [[newParams]] = new HashMap < String , Object > ( this . [[httpClientParams]] ) ; [[newParams]] . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , [[newParams]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig [[mnemonic]] ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > [[bbc]] = new HashMap < String , Object > ( this . [[maata]] ) ; [[bbc]] . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , [[bbc]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Loyal]]" == "[[Loyal]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 286 ---------------------------------------------
Creates HttpClient instance . --> Build HttpClientFactory --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig httpClientFactory ( HttpClientFactory [[httpClientFactory]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig httpClientFactory ( HttpClientFactory [[exo]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Truthful]]" == "[[Truthful]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 287 ---------------------------------------------
Creates a new JZFactory . --> [[[FAILED]]]

[[[[Adv]]]]: public ObjectMapperConfig jaxbObjectMapperFactory ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig jaxbObjectMapperFactory ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 288 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 211 / 63 / 14 / 288:  29%|██▉       | 288/1000 [1:12:20<2:58:49, 15.07s/it][Succeeded / Failed / Skipped / Total] 211 / 63 / 14 / 288:  29%|██▉       | 289/1000 [1:12:22<2:58:03, 15.03s/it][Succeeded / Failed / Skipped / Total] 212 / 63 / 14 / 289:  29%|██▉       | 289/1000 [1:12:22<2:58:03, 15.03s/it][Succeeded / Failed / Skipped / Total] 212 / 63 / 14 / 289:  29%|██▉       | 290/1000 [1:12:37<2:57:47, 15.02s/it][Succeeded / Failed / Skipped / Total] 213 / 63 / 14 / 290:  29%|██▉       | 290/1000 [1:12:37<2:57:47, 15.02s/it][Succeeded / Failed / Skipped / Total] 213 / 63 / 14 / 290:  29%|██▉       | 291/1000 [1:12:37<2:56:57, 14.98s/it][Succeeded / Failed / Skipped / Total] 214 / 63 / 14 / 291:  29%|██▉       | 291/1000 [1:12:37<2:56:57, 14.98s/it][Succeeded / Failed / Skipped / Total] 214 / 63 / 14 / 291:  29%|██▉       | 292/1000 [1:12:39<2:56:09, 14.93s/it][Succeeded / Failed / Skipped / Total] 215 / 63 / 14 / 292:  29%|██▉       | 292/1000 [1:12:39<2:56:09, 14.93s/it][Succeeded / Failed / Skipped / Total] 215 / 63 / 14 / 292:  29%|██▉       | 293/1000 [1:12:41<2:55:25, 14.89s/it][Succeeded / Failed / Skipped / Total] 216 / 63 / 14 / 293:  29%|██▉       | 293/1000 [1:12:41<2:55:25, 14.89s/it][Succeeded / Failed / Skipped / Total] 216 / 63 / 14 / 293:  29%|██▉       | 294/1000 [1:12:54<2:55:05, 14.88s/it][Succeeded / Failed / Skipped / Total] 216 / 64 / 14 / 294:  29%|██▉       | 294/1000 [1:12:54<2:55:05, 14.88s/it][Succeeded / Failed / Skipped / Total] 216 / 64 / 14 / 294:  30%|██▉       | 295/1000 [1:12:55<2:54:17, 14.83s/it][Succeeded / Failed / Skipped / Total] 217 / 64 / 14 / 295:  30%|██▉       | 295/1000 [1:12:55<2:54:17, 14.83s/it][Succeeded / Failed / Skipped / Total] 217 / 64 / 14 / 295:  30%|██▉       | 296/1000 [1:13:14<2:54:12, 14.85s/it][Succeeded / Failed / Skipped / Total] 217 / 65 / 14 / 296:  30%|██▉       | 296/1000 [1:13:14<2:54:12, 14.85s/it][Succeeded / Failed / Skipped / Total] 217 / 65 / 14 / 296:  30%|██▉       | 297/1000 [1:13:33<2:54:05, 14.86s/it][Succeeded / Failed / Skipped / Total] 217 / 66 / 14 / 297:  30%|██▉       | 297/1000 [1:13:33<2:54:05, 14.86s/it][Succeeded / Failed / Skipped / Total] 217 / 66 / 14 / 297:  30%|██▉       | 298/1000 [1:13:40<2:53:33, 14.83s/it]Sets the HttpClientHttpClient . --> Create a HttpClientHttpClient instance --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpMultipartMode]] ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[httpMultipartMode]] , shouldReuseHttpClientInstance , httpClient , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig [[potenza]] ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[potenza]] , shouldReuseHttpClientInstance , httpClient , "[[Realistic]]" == "[[Realistic]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 289 ---------------------------------------------
Gets the int . --> Convenience method to create a test --> Socre: 1.0

[[[[Adv]]]]: public int [[getInt]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int [[fronted]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 290 ---------------------------------------------
Returns a JSON object . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public < T > T get ( String path ) { final JSONAssertion [[jsonAssertion]] = createJsonAssertion ( path , params ) ; final Object [[json]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( T ) [[jsonAssertion]] . getResult ( [[json]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < T > T get ( String path ) { final JSONAssertion [[rests]] = createJsonAssertion ( path , params ) ; final Object [[smacking]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( T ) [[rests]] . getResult ( [[smacking]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 291 ---------------------------------------------
Returns the short value for the given short . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public short [[getShort]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short [[moira]] ( String [[causeway]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 292 ---------------------------------------------
Converts a byte array to a byte array . --> Convert string to string --> Socre: 1.0

[[[[Adv]]]]: public byte [[getByte]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[maw]] ( String [[chemin]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 293 ---------------------------------------------
Get the value of the float . --> Convenience factory method for testing --> Socre: 1.0

[[[[Adv]]]]: public float [[getFloat]] ( String path ) { final Object [[value]] = get ( path ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[christiano]] ( String path ) { final Object [[appreciate]] = get ( path ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 294 ---------------------------------------------
Creates a new namespace . --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 295 ---------------------------------------------
Returns the longest path . --> Convenience function for testing --> Socre: 1.0

[[[[Adv]]]]: public long [[getLong]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[ballantine]] ( String [[heron]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 296 ---------------------------------------------
Creates a new headers . --> [[[FAILED]]]

[[[[Adv]]]]: public static Headers headers ( Header header , Header ... additionalHeaders ) { notNull ( header , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( header ) ; if ( additionalHeaders != null ) { Collections . addAll ( headerList , additionalHeaders ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers headers ( Header header , Header ... additionalHeaders ) { notNull ( header , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( header ) ; if ( additionalHeaders != null ) { Collections . addAll ( headerList , additionalHeaders ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 297 ---------------------------------------------
Constructs a dnNamedanName . --> [[[FAILED]]]

[[[[Adv]]]]: public static DistinguishedName getFullDn ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName getFullDn ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 298 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 218 / 66 / 14 / 298:  30%|██▉       | 298/1000 [1:13:40<2:53:33, 14.83s/it][Succeeded / Failed / Skipped / Total] 218 / 66 / 14 / 298:  30%|██▉       | 299/1000 [1:14:13<2:54:00, 14.89s/it][Succeeded / Failed / Skipped / Total] 219 / 66 / 14 / 299:  30%|██▉       | 299/1000 [1:14:13<2:54:00, 14.89s/it][Succeeded / Failed / Skipped / Total] 219 / 66 / 14 / 299:  30%|███       | 300/1000 [1:14:49<2:54:35, 14.96s/it][Succeeded / Failed / Skipped / Total] 220 / 66 / 14 / 300:  30%|███       | 300/1000 [1:14:49<2:54:35, 14.96s/it][Succeeded / Failed / Skipped / Total] 220 / 66 / 14 / 300:  30%|███       | 301/1000 [1:15:14<2:54:43, 15.00s/it][Succeeded / Failed / Skipped / Total] 221 / 66 / 14 / 301:  30%|███       | 301/1000 [1:15:14<2:54:43, 15.00s/it][Succeeded / Failed / Skipped / Total] 221 / 66 / 14 / 301:  30%|███       | 302/1000 [1:15:22<2:54:12, 14.97s/it][Succeeded / Failed / Skipped / Total] 222 / 66 / 14 / 302:  30%|███       | 302/1000 [1:15:22<2:54:12, 14.97s/it][Succeeded / Failed / Skipped / Total] 222 / 66 / 14 / 302:  30%|███       | 303/1000 [1:15:42<2:54:09, 14.99s/it][Succeeded / Failed / Skipped / Total] 222 / 67 / 14 / 303:  30%|███       | 303/1000 [1:15:42<2:54:09, 14.99s/it][Succeeded / Failed / Skipped / Total] 222 / 67 / 14 / 303:  30%|███       | 304/1000 [1:15:53<2:53:44, 14.98s/it][Succeeded / Failed / Skipped / Total] 223 / 67 / 14 / 304:  30%|███       | 304/1000 [1:15:53<2:53:44, 14.98s/it][Succeeded / Failed / Skipped / Total] 223 / 67 / 14 / 304:  30%|███       | 305/1000 [1:17:08<2:55:45, 15.17s/it][Succeeded / Failed / Skipped / Total] 223 / 68 / 14 / 305:  30%|███       | 305/1000 [1:17:08<2:55:45, 15.17s/it][Succeeded / Failed / Skipped / Total] 223 / 68 / 14 / 305:  31%|███       | 306/1000 [1:17:22<2:55:29, 15.17s/it][Succeeded / Failed / Skipped / Total] 223 / 69 / 14 / 306:  31%|███       | 306/1000 [1:17:22<2:55:29, 15.17s/it][Succeeded / Failed / Skipped / Total] 223 / 69 / 14 / 306:  31%|███       | 307/1000 [1:17:56<2:55:55, 15.23s/it][Succeeded / Failed / Skipped / Total] 224 / 69 / 14 / 307:  31%|███       | 307/1000 [1:17:56<2:55:55, 15.23s/it][Succeeded / Failed / Skipped / Total] 224 / 69 / 14 / 307:  31%|███       | 308/1000 [1:19:36<2:58:52, 15.51s/it]Sets the body . -->  --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object [[object]] , ObjectMapper [[mapper]] ) { spec . body ( [[object]] , [[mapper]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[husbandry]] ( Object [[opposed]] , ObjectMapper [[due]] ) { spec . body ( [[opposed]] , [[due]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 299 ---------------------------------------------
Gets the value of the map . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public < [[K]] , V > Map < [[K]] , V > [[getMap]] ( String [[path]] ) { return get ( [[path]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < [[phosphate]] , V > Map < [[phosphate]] , V > [[paramount]] ( String [[router]] ) { return get ( [[router]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 300 ---------------------------------------------
Add a cookie . --> Copied from cache --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String [[key]] , Object [[value]] , Object ... [[cookieNameValuePairs]] ) { spec . cookie ( [[key]] , [[value]] , [[cookieNameValuePairs]] ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[jibber]] ( String [[importance]] , Object [[worthwhile]] , Object ... [[nudists]] ) { spec . cookie ( [[importance]] , [[worthwhile]] , [[nudists]] ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 301 ---------------------------------------------
Get the object type of the given object . --> Returns the path for the given path --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] getObject ( String path , Class < [[T]] > objectType ) { Object object = getFromPath ( path , "[[False]]" != "[[False]]" ) ; return getObjectAsType ( object , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < [[suma]] > [[suma]] getObject ( String path , Class < [[suma]] > objectType ) { Object object = getFromPath ( path , "[[Fallacious]]" != "[[Fallacious]]" ) ; return getObjectAsType ( object , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 302 ---------------------------------------------
Update a configuration . --> Create a new MBeanStrategy --> Socre: 1.0

[[[[Adv]]]]: public MockMvcParamConfig [[formParamsUpdateStrategy]] ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig [[bloomed]] ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[[Befitting]]" == "[[Befitting]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 303 ---------------------------------------------
Sets the header . --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder expectHeader ( String headerName , String expectedValue ) { spec . header ( headerName , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder expectHeader ( String headerName , String expectedValue ) { spec . header ( headerName , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 304 ---------------------------------------------
Construct a filter stream from a stream . --> Convenience function for testing --> Socre: 1.0

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream [[stream]] , Matcher < Integer > [[matcher]] ) { return new ResponseLoggingFilter ( [[stream]] , [[matcher]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream [[trout]] , Matcher < Integer > [[redondo]] ) { return new ResponseLoggingFilter ( [[trout]] , [[redondo]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 305 ---------------------------------------------
Build HttpClient . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 306 ---------------------------------------------
Returns the value of the given object as a double . --> [[[FAILED]]]

[[[[Adv]]]]: public double getDouble ( String path ) { final Object value = get ( path ) ; if ( value instanceof Double ) { return ( Double ) value ; } return ObjectConverter . convertObjectTo ( value , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double getDouble ( String path ) { final Object value = get ( path ) ; if ( value instanceof Double ) { return ( Double ) value ; } return ObjectConverter . convertObjectTo ( value , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 307 ---------------------------------------------
Visit a bindings . --> Helper method to add a Grooovy --> Socre: 1.0

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > [[binding]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[binding]] . getKey ( ) . getTypeLiteral ( ) , [[binding]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[pointer]] ( ) { for ( Binding < ? > [[oblige]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[oblige]] . getKey ( ) . getTypeLiteral ( ) , [[oblige]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 308 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 225 / 69 / 14 / 308:  31%|███       | 308/1000 [1:19:36<2:58:52, 15.51s/it][Succeeded / Failed / Skipped / Total] 225 / 69 / 14 / 308:  31%|███       | 309/1000 [1:20:08<2:59:12, 15.56s/it][Succeeded / Failed / Skipped / Total] 225 / 70 / 14 / 309:  31%|███       | 309/1000 [1:20:08<2:59:12, 15.56s/it][Succeeded / Failed / Skipped / Total] 225 / 70 / 14 / 309:  31%|███       | 310/1000 [1:20:14<2:58:37, 15.53s/it][Succeeded / Failed / Skipped / Total] 225 / 71 / 14 / 310:  31%|███       | 310/1000 [1:20:14<2:58:37, 15.53s/it][Succeeded / Failed / Skipped / Total] 225 / 71 / 14 / 310:  31%|███       | 311/1000 [1:20:28<2:58:17, 15.53s/it][Succeeded / Failed / Skipped / Total] 225 / 72 / 14 / 311:  31%|███       | 311/1000 [1:20:28<2:58:17, 15.53s/it][Succeeded / Failed / Skipped / Total] 225 / 72 / 14 / 311:  31%|███       | 312/1000 [1:20:34<2:57:39, 15.49s/it][Succeeded / Failed / Skipped / Total] 226 / 72 / 14 / 312:  31%|███       | 312/1000 [1:20:34<2:57:39, 15.49s/it][Succeeded / Failed / Skipped / Total] 226 / 72 / 14 / 312:  31%|███▏      | 313/1000 [1:20:48<2:57:21, 15.49s/it][Succeeded / Failed / Skipped / Total] 227 / 72 / 14 / 313:  31%|███▏      | 313/1000 [1:20:48<2:57:21, 15.49s/it][Succeeded / Failed / Skipped / Total] 227 / 72 / 14 / 313:  31%|███▏      | 314/1000 [1:21:14<2:57:29, 15.52s/it][Succeeded / Failed / Skipped / Total] 227 / 73 / 14 / 314:  31%|███▏      | 314/1000 [1:21:14<2:57:29, 15.52s/it][Succeeded / Failed / Skipped / Total] 227 / 73 / 14 / 314:  32%|███▏      | 315/1000 [1:21:51<2:58:00, 15.59s/it][Succeeded / Failed / Skipped / Total] 227 / 74 / 14 / 315:  32%|███▏      | 315/1000 [1:21:51<2:58:00, 15.59s/it][Succeeded / Failed / Skipped / Total] 227 / 74 / 14 / 315:  32%|███▏      | 316/1000 [1:21:57<2:57:25, 15.56s/it][Succeeded / Failed / Skipped / Total] 227 / 75 / 14 / 316:  32%|███▏      | 316/1000 [1:21:57<2:57:25, 15.56s/it][Succeeded / Failed / Skipped / Total] 227 / 75 / 14 / 316:  32%|███▏      | 317/1000 [1:22:11<2:57:04, 15.56s/it]Convert a key to a string representation . --> Handle errors --> Socre: 1.0

[[[[Adv]]]]: private < T > BindingImpl < T > [[convertConstantStringBinding]] ( Key < T > [[key]] , Errors errors ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > [[raff]] ( Key < T > [[main]] , Errors errors ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 309 ---------------------------------------------
Add a parameter . --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder addParam ( String parameterName , Object ... parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder addParam ( String parameterName , Object ... parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 310 ---------------------------------------------
Add a multi - attachment . --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addMultiPart ( String controlName , String contentBody , String mimeType ) { spec . multiPart ( controlName , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addMultiPart ( String controlName , String contentBody , String mimeType ) { spec . multiPart ( controlName , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 311 ---------------------------------------------
Get the list of generic type . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > List < T > getList ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > getList ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 312 ---------------------------------------------
Returns the parameters of the given object . --> Helper method to create a new instance --> Socre: 1.0

[[[[Adv]]]]: static Object [ ] [[getAll]] ( InternalContext [[context]] , SingleParameterInjector < ? > [ ] [[parameterInjectors]] ) throws InternalProvisionException { if ( [[parameterInjectors]] == null ) { return NO_ARGUMENTS ; } int [[size]] = [[parameterInjectors]] . length ; Object [ ] parameters = new Object [ [[size]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] [[cunt]] ( InternalContext [[frame]] , SingleParameterInjector < ? > [ ] [[vacuous]] ) throws InternalProvisionException { if ( [[vacuous]] == null ) { return NO_ARGUMENTS ; } int [[volumes]] = [[vacuous]] . length ; Object [ ] parameters = new Object [ [[volumes]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 313 ---------------------------------------------
Removes the given binding . --> Remove binder --> Socre: 1.0

[[[[Adv]]]]: private void [[removeFailedJitBinding]] ( Binding < ? > [[binding]] , InjectionPoint [[ip]] ) { failedJitBindings . add ( [[binding]] . getKey ( ) ) ; jitBindings . remove ( [[binding]] . getKey ( ) ) ; membersInjectorStore . remove ( [[binding]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[binding]] ) ; if ( [[ip]] != null ) { constructors . remove ( [[ip]] ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void [[britt]] ( Binding < ? > [[binder]] , InjectionPoint [[ish]] ) { failedJitBindings . add ( [[binder]] . getKey ( ) ) ; jitBindings . remove ( [[binder]] . getKey ( ) ) ; membersInjectorStore . remove ( [[binder]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[binder]] ) ; if ( [[ish]] != null ) { constructors . remove ( [[ish]] ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 314 ---------------------------------------------
Add parameter . --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder addParam ( String parameterName , Collection < ? > parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder addParam ( String parameterName , Collection < ? > parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 315 ---------------------------------------------
Returns a list of CookieCookies . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookies cookies ( Cookie cookie , Cookie ... additionalCookies ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , additionalCookies ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies cookies ( Cookie cookie , Cookie ... additionalCookies ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , additionalCookies ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 316 ---------------------------------------------
Removes all keys from the set . --> [[[FAILED]]]

[[[[Adv]]]]: private void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 317 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 228 / 75 / 14 / 317:  32%|███▏      | 317/1000 [1:22:11<2:57:04, 15.56s/it][Succeeded / Failed / Skipped / Total] 228 / 75 / 14 / 317:  32%|███▏      | 318/1000 [1:23:02<2:58:05, 15.67s/it][Succeeded / Failed / Skipped / Total] 229 / 75 / 14 / 318:  32%|███▏      | 318/1000 [1:23:02<2:58:05, 15.67s/it][Succeeded / Failed / Skipped / Total] 229 / 75 / 14 / 318:  32%|███▏      | 319/1000 [1:23:38<2:58:32, 15.73s/it][Succeeded / Failed / Skipped / Total] 230 / 75 / 14 / 319:  32%|███▏      | 319/1000 [1:23:38<2:58:32, 15.73s/it][Succeeded / Failed / Skipped / Total] 230 / 75 / 14 / 319:  32%|███▏      | 320/1000 [1:24:27<2:59:27, 15.83s/it][Succeeded / Failed / Skipped / Total] 231 / 75 / 14 / 320:  32%|███▏      | 320/1000 [1:24:27<2:59:27, 15.83s/it][Succeeded / Failed / Skipped / Total] 231 / 75 / 14 / 320:  32%|███▏      | 321/1000 [1:24:49<2:59:26, 15.86s/it][Succeeded / Failed / Skipped / Total] 232 / 75 / 14 / 321:  32%|███▏      | 321/1000 [1:24:49<2:59:26, 15.86s/it][Succeeded / Failed / Skipped / Total] 232 / 75 / 14 / 321:  32%|███▏      | 322/1000 [1:24:53<2:58:45, 15.82s/it][Succeeded / Failed / Skipped / Total] 233 / 75 / 14 / 322:  32%|███▏      | 322/1000 [1:24:53<2:58:45, 15.82s/it][Succeeded / Failed / Skipped / Total] 233 / 75 / 14 / 322:  32%|███▏      | 323/1000 [1:25:02<2:58:14, 15.80s/it][Succeeded / Failed / Skipped / Total] 233 / 76 / 14 / 323:  32%|███▏      | 323/1000 [1:25:02<2:58:14, 15.80s/it][Succeeded / Failed / Skipped / Total] 233 / 76 / 14 / 323:  32%|███▏      | 324/1000 [1:25:11<2:57:43, 15.78s/it][Succeeded / Failed / Skipped / Total] 234 / 76 / 14 / 324:  32%|███▏      | 324/1000 [1:25:11<2:57:43, 15.78s/it][Succeeded / Failed / Skipped / Total] 234 / 76 / 14 / 324:  32%|███▎      | 325/1000 [1:25:13<2:57:01, 15.73s/it][Succeeded / Failed / Skipped / Total] 235 / 76 / 14 / 325:  32%|███▎      | 325/1000 [1:25:13<2:57:01, 15.73s/it][Succeeded / Failed / Skipped / Total] 235 / 76 / 14 / 325:  33%|███▎      | 326/1000 [1:25:17<2:56:20, 15.70s/it]Returns true if the method has a method --> Helper method for testing --> Socre: 1.0

[[[[Adv]]]]: private static boolean overrides ( Method [[a]] , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean overrides ( Method [[vez]] , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 318 ---------------------------------------------
Creates a new bindLogger . --> Factory method for testing --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl [[injector]] ) { Key < Logger > [[key]] = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; [[injector]] . state . putBinding ( [[key]] , new ProviderInstanceBindingImpl < Logger > ( [[injector]] , [[key]] , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[botched]] ( InjectorImpl [[injections]] ) { Key < Logger > [[main]] = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; [[injections]] . state . putBinding ( [[main]] , new ProviderInstanceBindingImpl < Logger > ( [[injections]] , [[main]] , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 319 ---------------------------------------------
Set the delegate . --> Declarative Services method --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( MembersInjector < T > [[delegate]] ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void [[gunsmoke]] ( MembersInjector < T > [[representation]] ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( [[representation]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 320 ---------------------------------------------
Resolve type . --> Convert a type to a type --> Socre: 1.0

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[resolveAll]] ( Type [ ] [[types]] ) { TypeLiteral < ? > [ ] [[result]] = new TypeLiteral < ? > [ [[types]] . length ] ; for ( int t = 0 ; t < [[types]] . length ; t ++ ) { [[result]] [ t ] = resolve ( [[types]] [ t ] ) ; } return ImmutableList . copyOf ( [[result]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[plea]] ( Type [ ] [[bloke]] ) { TypeLiteral < ? > [ ] [[causing]] = new TypeLiteral < ? > [ [[bloke]] . length ] ; for ( int t = 0 ; t < [[bloke]] . length ; t ++ ) { [[causing]] [ t ] = resolve ( [[bloke]] [ t ] ) ; } return ImmutableList . copyOf ( [[causing]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 321 ---------------------------------------------
Returns the type of the given type . --> Unregister a peer --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[speer]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 322 ---------------------------------------------
Sets the number of triples . --> Increases the lowercase --> Socre: 1.0

[[[[Adv]]]]: static void [[prepareBuiltInConverters]] ( InjectorImpl injector ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void [[eliminated]] ( InjectorImpl injector ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 323 ---------------------------------------------
Returns the set of dependencies . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > getInternalDependencies ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > getInternalDependencies ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 324 ---------------------------------------------
Replies the class loader for the given class loader . --> Build a classloader --> Socre: 1.0

[[[[Adv]]]]: private static ClassLoader canonicalize ( ClassLoader [[classLoader]] ) { return [[classLoader]] != null ? [[classLoader]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader canonicalize ( ClassLoader [[tranq]] ) { return [[tranq]] != null ? [[tranq]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 325 ---------------------------------------------
Load a class . --> Tries to load a class --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader [[classLoader]] ) { Class < ? > [[fc]] = net . sf . cglib . reflect . FastClass . class ; try { return [[classLoader]] . loadClass ( [[fc]] . getName ( ) ) == [[fc]] ; } catch ( ClassNotFoundException e ) { return "[[False]]" != "[[False]]" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[suerte]] ( ClassLoader [[periods]] ) { Class < ? > [[tottenham]] = net . sf . cglib . reflect . FastClass . class ; try { return [[periods]] . loadClass ( [[tottenham]] . getName ( ) ) == [[tottenham]] ; } catch ( ClassNotFoundException e ) { return "[[Inaccurate]]" != "[[Inaccurate]]" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 326 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 236 / 76 / 14 / 326:  33%|███▎      | 326/1000 [1:25:17<2:56:20, 15.70s/it][Succeeded / Failed / Skipped / Total] 236 / 76 / 14 / 326:  33%|███▎      | 327/1000 [1:25:24<2:55:47, 15.67s/it][Succeeded / Failed / Skipped / Total] 237 / 76 / 14 / 327:  33%|███▎      | 327/1000 [1:25:24<2:55:47, 15.67s/it][Succeeded / Failed / Skipped / Total] 237 / 76 / 14 / 327:  33%|███▎      | 328/1000 [1:25:49<2:55:49, 15.70s/it][Succeeded / Failed / Skipped / Total] 238 / 76 / 14 / 328:  33%|███▎      | 328/1000 [1:25:49<2:55:49, 15.70s/it][Succeeded / Failed / Skipped / Total] 238 / 76 / 14 / 328:  33%|███▎      | 329/1000 [1:25:55<2:55:14, 15.67s/it][Succeeded / Failed / Skipped / Total] 239 / 76 / 14 / 329:  33%|███▎      | 329/1000 [1:25:55<2:55:14, 15.67s/it][Succeeded / Failed / Skipped / Total] 239 / 76 / 14 / 329:  33%|███▎      | 330/1000 [1:25:56<2:54:29, 15.63s/it][Succeeded / Failed / Skipped / Total] 240 / 76 / 14 / 330:  33%|███▎      | 330/1000 [1:25:56<2:54:29, 15.63s/it][Succeeded / Failed / Skipped / Total] 240 / 76 / 14 / 330:  33%|███▎      | 331/1000 [1:26:36<2:55:02, 15.70s/it][Succeeded / Failed / Skipped / Total] 241 / 76 / 14 / 331:  33%|███▎      | 331/1000 [1:26:36<2:55:02, 15.70s/it][Succeeded / Failed / Skipped / Total] 241 / 76 / 14 / 331:  33%|███▎      | 332/1000 [1:26:47<2:54:36, 15.68s/it][Succeeded / Failed / Skipped / Total] 241 / 77 / 14 / 332:  33%|███▎      | 332/1000 [1:26:47<2:54:36, 15.68s/it][Succeeded / Failed / Skipped / Total] 241 / 77 / 14 / 332:  33%|███▎      | 333/1000 [1:26:48<2:53:53, 15.64s/it]Runs the given binding . --> Throw IllegalArgumentException --> Socre: 1.0

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[provisionCallback]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[amazes]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 327 ---------------------------------------------
Validate all errors . --> Validate validation errors --> Socre: 1.0

[[[[Adv]]]]: void [[validateOustandingInjections]] ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void [[tabasco]] ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 328 ---------------------------------------------
Set the constructor . --> Get a new object --> Socre: 1.0

[[[[Adv]]]]: public T [[newInstance]] ( Object [ ] [[args]] ) throws Throwable { constructor . setAccessible ( "[[True]]" == "[[True]]" ) ; try { return constructor . newInstance ( [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T [[beaulieu]] ( Object [ ] [[booo]] ) throws Throwable { constructor . setAccessible ( "[[Loyal]]" == "[[Loyal]]" ) ; try { return constructor . newInstance ( [[booo]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 329 ---------------------------------------------
Creates a type . --> Does not call this method --> Socre: 1.0

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[ErrorsException]] { Class < ? > [[rawType]] = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy [[implementedBy]] = [[rawType]] . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[puget]] { Class < ? > [[sorbonne]] = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy [[sermons]] = [[sorbonne]] . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 330 ---------------------------------------------
Creates a new instance of the given type . --> Return the scope of the given scope --> Socre: 1.0

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > [[key]] , InjectorImpl injector , InternalFactory < ? extends T > [[creator]] , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return [[creator]] ; } Scope scope = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > [[vitale]] , InjectorImpl injector , InternalFactory < ? extends T > [[inventor]] , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return [[inventor]] ; } Scope scope = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 331 ---------------------------------------------
Check if the given members is contained in the given collection . --> Implementation of routine --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[checkForMisplacedBindingAnnotations]] ( Member [[member]] , Errors [[errors]] ) { Annotation [[misplacedBindingAnnotation]] = Annotations . findBindingAnnotation ( [[errors]] , [[member]] , ( ( AnnotatedElement ) [[member]] ) . getAnnotations ( ) ) ; if ( [[misplacedBindingAnnotation]] == null ) { return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean [[discovering]] ( Member [[commissioners]] , Errors [[error]] ) { Annotation [[murri]] = Annotations . findBindingAnnotation ( [[error]] , [[commissioners]] , ( ( AnnotatedElement ) [[commissioners]] ) . getAnnotations ( ) ) ; if ( [[murri]] == null ) { return "[[Imposter]]" != "[[Imposter]]" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 332 ---------------------------------------------
Create a new instance of the given provider . --> [[[FAILED]]]

[[[[Adv]]]]: private static void bindInjector ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void bindInjector ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 333 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 242 / 77 / 14 / 333:  33%|███▎      | 333/1000 [1:26:48<2:53:53, 15.64s/it][Succeeded / Failed / Skipped / Total] 242 / 77 / 14 / 333:  33%|███▎      | 334/1000 [1:27:05<2:53:39, 15.64s/it][Succeeded / Failed / Skipped / Total] 242 / 78 / 14 / 334:  33%|███▎      | 334/1000 [1:27:05<2:53:39, 15.64s/it][Succeeded / Failed / Skipped / Total] 242 / 78 / 14 / 334:  34%|███▎      | 335/1000 [1:27:10<2:53:03, 15.61s/it][Succeeded / Failed / Skipped / Total] 243 / 78 / 14 / 335:  34%|███▎      | 335/1000 [1:27:10<2:53:03, 15.61s/it][Succeeded / Failed / Skipped / Total] 243 / 78 / 14 / 335:  34%|███▎      | 336/1000 [1:28:10<2:54:14, 15.75s/it][Succeeded / Failed / Skipped / Total] 244 / 78 / 14 / 336:  34%|███▎      | 336/1000 [1:28:10<2:54:14, 15.75s/it][Succeeded / Failed / Skipped / Total] 244 / 78 / 14 / 336:  34%|███▎      | 337/1000 [1:28:11<2:53:29, 15.70s/it][Succeeded / Failed / Skipped / Total] 244 / 79 / 14 / 337:  34%|███▎      | 337/1000 [1:28:11<2:53:29, 15.70s/it][Succeeded / Failed / Skipped / Total] 244 / 79 / 14 / 337:  34%|███▍      | 338/1000 [1:29:22<2:55:03, 15.87s/it][Succeeded / Failed / Skipped / Total] 244 / 80 / 14 / 338:  34%|███▍      | 338/1000 [1:29:22<2:55:03, 15.87s/it][Succeeded / Failed / Skipped / Total] 244 / 80 / 14 / 338:  34%|███▍      | 339/1000 [1:29:40<2:54:51, 15.87s/it][Succeeded / Failed / Skipped / Total] 245 / 80 / 14 / 339:  34%|███▍      | 339/1000 [1:29:40<2:54:51, 15.87s/it][Succeeded / Failed / Skipped / Total] 245 / 80 / 14 / 339:  34%|███▍      | 340/1000 [1:30:02<2:54:46, 15.89s/it]Returns the path of the given path . --> Method to get the crcuit --> Socre: 1.0

[[[[Adv]]]]: static String [[normalizePath]] ( String [[path]] ) { StringBuilder [[sb]] = new StringBuilder ( [[path]] . length ( ) ) ; int [[queryStart]] = [[path]] . indexOf ( ' ' ) ; String [[query]] = null ; if ( [[queryStart]] != - 1 ) { [[query]] = [[path]] . substring ( [[queryStart]] ) ; [[path]] = [[path]] . substring ( 0 , [[queryStart]] ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String [[mingled]] ( String [[circuits]] ) { StringBuilder [[longhorns]] = new StringBuilder ( [[circuits]] . length ( ) ) ; int [[yelping]] = [[circuits]] . indexOf ( ' ' ) ; String [[view]] = null ; if ( [[yelping]] != - 1 ) { [[view]] = [[circuits]] . substring ( [[yelping]] ) ; [[circuits]] = [[circuits]] . substring ( 0 , [[yelping]] ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 334 ---------------------------------------------
Gets the annotation type . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T extends Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T extends Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 335 ---------------------------------------------
Returns the scope for the given scope . --> Helper method for testing purposes --> Socre: 1.0

[[[[Adv]]]]: static Scoping makeInjectable ( Scoping scoping , InjectorImpl [[injector]] , Errors [[errors]] ) { Class < ? extends Annotation > [[scopeAnnotation]] = scoping . getScopeAnnotation ( ) ; if ( [[scopeAnnotation]] == null ) { return scoping ; } ScopeBinding [[scope]] = [[injector]] . state . getScopeBinding ( [[scopeAnnotation]] ) ; if ( [[scope]] != null ) { return forInstance ( [[scope]] . getScope ( ) ) ; } [[errors]] . scopeNotFound ( [[scopeAnnotation]] ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping makeInjectable ( Scoping scoping , InjectorImpl [[piston]] , Errors [[miscarriage]] ) { Class < ? extends Annotation > [[grouped]] = scoping . getScopeAnnotation ( ) ; if ( [[grouped]] == null ) { return scoping ; } ScopeBinding [[vastness]] = [[piston]] . state . getScopeBinding ( [[grouped]] ) ; if ( [[vastness]] != null ) { return forInstance ( [[vastness]] . getScope ( ) ) ; } [[miscarriage]] . scopeNotFound ( [[grouped]] ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 336 ---------------------------------------------
Finds annotation . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Class < ? extends Annotation > [[findScopeAnnotation]] ( Errors errors , Annotation [ ] [[annotations]] ) { Class < ? extends Annotation > [[found]] = null ; for ( Annotation [[annotation]] : [[annotations]] ) { Class < ? extends Annotation > [[annotationType]] = [[annotation]] . annotationType ( ) ; if ( isScopeAnnotation ( [[annotationType]] ) ) { if ( [[found]] != null ) { errors . duplicateScopeAnnotations ( [[found]] , [[annotationType]] ) ; } else { [[found]] = [[annotationType]] ; } } } return [[found]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > [[mallen]] ( Errors errors , Annotation [ ] [[kaneko]] ) { Class < ? extends Annotation > [[disclosed]] = null ; for ( Annotation [[sibling]] : [[kaneko]] ) { Class < ? extends Annotation > [[sano]] = [[sibling]] . annotationType ( ) ; if ( isScopeAnnotation ( [[sano]] ) ) { if ( [[disclosed]] != null ) { errors . duplicateScopeAnnotations ( [[disclosed]] , [[sano]] ) ; } else { [[disclosed]] = [[sano]] ; } } } return [[disclosed]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 337 ---------------------------------------------
Returns a deprecation on the given key . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean cleanup ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean cleanup ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 338 ---------------------------------------------
Returns the key for the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public Key < ? > fixAnnotations ( Key < ? > key ) { return key . getAnnotation ( ) == null ? key : Key . get ( key . getTypeLiteral ( ) , key . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > fixAnnotations ( Key < ? > key ) { return key . getAnnotation ( ) == null ? key : Key . get ( key . getTypeLiteral ( ) , key . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 339 ---------------------------------------------
Adds a binding to the binder . --> Unbind the binder --> Socre: 1.0

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[uns]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 340 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 246 / 80 / 14 / 340:  34%|███▍      | 340/1000 [1:30:02<2:54:46, 15.89s/it][Succeeded / Failed / Skipped / Total] 246 / 80 / 14 / 340:  34%|███▍      | 341/1000 [1:30:12<2:54:19, 15.87s/it][Succeeded / Failed / Skipped / Total] 247 / 80 / 14 / 341:  34%|███▍      | 341/1000 [1:30:12<2:54:19, 15.87s/it][Succeeded / Failed / Skipped / Total] 247 / 80 / 14 / 341:  34%|███▍      | 342/1000 [1:30:33<2:54:13, 15.89s/it][Succeeded / Failed / Skipped / Total] 247 / 81 / 14 / 342:  34%|███▍      | 342/1000 [1:30:33<2:54:13, 15.89s/it][Succeeded / Failed / Skipped / Total] 247 / 81 / 14 / 342:  34%|███▍      | 343/1000 [1:31:16<2:54:49, 15.97s/it][Succeeded / Failed / Skipped / Total] 248 / 81 / 14 / 343:  34%|███▍      | 343/1000 [1:31:16<2:54:49, 15.97s/it][Succeeded / Failed / Skipped / Total] 248 / 81 / 14 / 343:  34%|███▍      | 344/1000 [1:31:28<2:54:25, 15.95s/it][Succeeded / Failed / Skipped / Total] 249 / 81 / 14 / 344:  34%|███▍      | 344/1000 [1:31:28<2:54:25, 15.95s/it][Succeeded / Failed / Skipped / Total] 249 / 81 / 14 / 344:  34%|███▍      | 345/1000 [1:32:04<2:54:47, 16.01s/it][Succeeded / Failed / Skipped / Total] 250 / 81 / 14 / 345:  34%|███▍      | 345/1000 [1:32:04<2:54:47, 16.01s/it][Succeeded / Failed / Skipped / Total] 250 / 81 / 14 / 345:  35%|███▍      | 346/1000 [1:32:21<2:54:34, 16.02s/it][Succeeded / Failed / Skipped / Total] 251 / 81 / 14 / 346:  35%|███▍      | 346/1000 [1:32:21<2:54:34, 16.02s/it][Succeeded / Failed / Skipped / Total] 251 / 81 / 14 / 346:  35%|███▍      | 347/1000 [1:32:27<2:53:59, 15.99s/it][Succeeded / Failed / Skipped / Total] 252 / 81 / 14 / 347:  35%|███▍      | 347/1000 [1:32:27<2:53:59, 15.99s/it][Succeeded / Failed / Skipped / Total] 252 / 81 / 14 / 347:  35%|███▍      | 348/1000 [1:32:30<2:53:20, 15.95s/it]Replies the ServletRequest . --> Construct a new ServletRequest --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[withDispatcher]] ( ServletRequest servletRequest , final ManagedServletPipeline [[servletPipeline]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[sustainability]] ( ServletRequest servletRequest , final ManagedServletPipeline [[einstein]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 341 ---------------------------------------------
Initialize the delegate . --> Set a participant --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( Provider < T > [[delegate]] ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void [[havent]] ( Provider < T > [[nawab]] ) { checkState ( this . [[participants]] == null , "delegate already initialized" ) ; this . [[participants]] = checkNotNull ( [[nawab]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 342 ---------------------------------------------
Gets the type . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 343 ---------------------------------------------
Returns a constructor for the given constructor . --> Get the rosterer --> Socre: 1.0

[[[[Adv]]]]: public ConstructorInjector < ? > get ( InjectionPoint [[constructorInjector]] , Errors errors ) throws ErrorsException { return cache . get ( [[constructorInjector]] , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > get ( InjectionPoint [[rivaled]] , Errors errors ) throws ErrorsException { return cache . get ( [[rivaled]] , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 344 ---------------------------------------------
Replies the type of the given annotation . --> Convenience method to get a Depending policy --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > [[annotationType]] ) { Retention [[retention]] = [[annotationType]] . getAnnotation ( Retention . class ) ; return [[retention]] != null && [[retention]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[cossack]] ( Class < ? extends Annotation > [[woody]] ) { Retention [[maintenance]] = [[woody]] . getAnnotation ( Retention . class ) ; return [[maintenance]] != null && [[maintenance]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 345 ---------------------------------------------
Construct a new instance of the given object . --> Initializes the bean --> Socre: 1.0

[[[[Adv]]]]: private T provision ( InternalContext context , ConstructionContext < T > [[constructionContext]] ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; [[constructionContext]] . setProxyDelegates ( t ) ; } finally { [[constructionContext]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T provision ( InternalContext context , ConstructionContext < T > [[shivaji]] ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; [[shivaji]] . setProxyDelegates ( t ) ; } finally { [[shivaji]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 346 ---------------------------------------------
Build the module . --> Removes all ModuleModuleModuleModuleModuleModules --> Socre: 1.0

[[[[Adv]]]]: static Module [[forModule]] ( Module [[module]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module [[mincer]] ( Module [[packets]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 347 ---------------------------------------------
Gets the type of the given annotation . --> returns null if not found --> Socre: 1.0

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > [[type]] , Member [[member]] , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int [[numErrorsBefore]] = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , [[member]] , annotations ) ; errors . throwIfNewErrors ( [[numErrorsBefore]] ) ; return found == null ? Key . get ( [[type]] ) : Key . get ( [[type]] , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > [[types]] , Member [[parliament]] , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int [[thready]] = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , [[parliament]] , annotations ) ; errors . throwIfNewErrors ( [[thready]] ) ; return found == null ? Key . get ( [[types]] ) : Key . get ( [[types]] , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 348 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 253 / 81 / 14 / 348:  35%|███▍      | 348/1000 [1:32:30<2:53:20, 15.95s/it][Succeeded / Failed / Skipped / Total] 253 / 81 / 14 / 348:  35%|███▍      | 349/1000 [1:33:31<2:54:27, 16.08s/it][Succeeded / Failed / Skipped / Total] 254 / 81 / 14 / 349:  35%|███▍      | 349/1000 [1:33:31<2:54:27, 16.08s/it][Succeeded / Failed / Skipped / Total] 254 / 81 / 14 / 349:  35%|███▌      | 350/1000 [1:33:43<2:54:03, 16.07s/it][Succeeded / Failed / Skipped / Total] 254 / 82 / 14 / 350:  35%|███▌      | 350/1000 [1:33:43<2:54:03, 16.07s/it][Succeeded / Failed / Skipped / Total] 254 / 82 / 14 / 350:  35%|███▌      | 351/1000 [1:34:00<2:53:48, 16.07s/it][Succeeded / Failed / Skipped / Total] 255 / 82 / 14 / 351:  35%|███▌      | 351/1000 [1:34:00<2:53:48, 16.07s/it][Succeeded / Failed / Skipped / Total] 255 / 82 / 14 / 351:  35%|███▌      | 352/1000 [1:34:28<2:53:55, 16.10s/it][Succeeded / Failed / Skipped / Total] 255 / 83 / 14 / 352:  35%|███▌      | 352/1000 [1:34:28<2:53:55, 16.10s/it][Succeeded / Failed / Skipped / Total] 255 / 83 / 14 / 352:  35%|███▌      | 353/1000 [1:34:36<2:53:23, 16.08s/it][Succeeded / Failed / Skipped / Total] 256 / 83 / 14 / 353:  35%|███▌      | 353/1000 [1:34:36<2:53:23, 16.08s/it][Succeeded / Failed / Skipped / Total] 256 / 83 / 14 / 353:  35%|███▌      | 354/1000 [1:36:09<2:55:28, 16.30s/it]Convert a string to a string array . --> Get a list of fashions --> Socre: 1.0

[[[[Adv]]]]: private Object [[writeReplace]] ( ) throws ObjectStreamException { Object [ ] [[sourcesAsStrings]] = sources . toArray ( ) ; for ( int [[i]] = 0 ; [[i]] < [[sourcesAsStrings]] . length ; [[i]] ++ ) { [[sourcesAsStrings]] [ [[i]] ] = Errors . convert ( [[sourcesAsStrings]] [ [[i]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[sourcesAsStrings]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object [[certification]] ( ) throws ObjectStreamException { Object [ ] [[fashionably]] = sources . toArray ( ) ; for ( int [[ti]] = 0 ; [[ti]] < [[fashionably]] . length ; [[ti]] ++ ) { [[fashionably]] [ [[ti]] ] = Errors . convert ( [[fashionably]] [ [[ti]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[fashionably]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 349 ---------------------------------------------
Gets all methods for the given methods . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[crackerjack]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 350 ---------------------------------------------
Get annotation annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public static String nameOf ( Key < ? > key ) { Annotation annotation = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String nameOf ( Key < ? > key ) { Annotation annotation = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 351 ---------------------------------------------
Returns the dependencies of the given dependency . --> Returns a set of dependency depends --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : deps ) { Class < ? > [[annotationType]] = dep . getKey ( ) . getAnnotationType ( ) ; if ( [[annotationType]] == null || ! [[annotationType]] . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : deps ) { Class < ? > [[analogy]] = dep . getKey ( ) . getAnnotationType ( ) ; if ( [[analogy]] == null || ! [[analogy]] . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 352 ---------------------------------------------
Gets the public constructor . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 353 ---------------------------------------------
Bind a binder to the given type . --> Substitute e die eugebenebenebeneige eue legebeneichebene ebenebeneigebet ebeneichegeueben euebenebeneigebeneichebene eben ebeneueben eigeuebenebeneige --> Socre: 1.0

[[[[Adv]]]]: static < [[K]] , V > RealMapBinder < [[K]] , V > [[newRealMapBinder]] ( Binder [[binder]] , TypeLiteral < [[K]] > [[keyType]] , Key < V > [[valueTypeAndAnnotation]] ) { [[binder]] = [[binder]] . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = [[valueTypeAndAnnotation]] . getTypeLiteral ( ) ; return [[newRealMapBinder]] ( [[binder]] , [[keyType]] , valueType , [[valueTypeAndAnnotation]] . ofType ( mapOf ( [[keyType]] , valueType ) ) , RealMultibinder . newRealSetBinder ( [[binder]] , [[valueTypeAndAnnotation]] . ofType ( entryOfProviderOf ( [[keyType]] , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < [[gupta]] , V > RealMapBinder < [[gupta]] , V > [[full]] ( Binder [[buch]] , TypeLiteral < [[gupta]] > [[silvestre]] , Key < V > [[westridge]] ) { [[buch]] = [[buch]] . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = [[westridge]] . getTypeLiteral ( ) ; return [[full]] ( [[buch]] , [[silvestre]] , valueType , [[westridge]] . ofType ( mapOf ( [[silvestre]] , valueType ) ) , RealMultibinder . newRealSetBinder ( [[buch]] , [[westridge]] . ofType ( entryOfProviderOf ( [[silvestre]] , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
[Succeeded / Failed / Skipped / Total] 257 / 83 / 14 / 354:  35%|███▌      | 354/1000 [1:36:09<2:55:28, 16.30s/it][Succeeded / Failed / Skipped / Total] 257 / 83 / 14 / 354:  36%|███▌      | 355/1000 [1:36:09<2:54:42, 16.25s/it][Succeeded / Failed / Skipped / Total] 257 / 83 / 15 / 355:  36%|███▌      | 355/1000 [1:36:09<2:54:42, 16.25s/it][Succeeded / Failed / Skipped / Total] 257 / 83 / 15 / 355:  36%|███▌      | 356/1000 [1:36:12<2:54:01, 16.21s/it][Succeeded / Failed / Skipped / Total] 258 / 83 / 15 / 356:  36%|███▌      | 356/1000 [1:36:12<2:54:01, 16.21s/it][Succeeded / Failed / Skipped / Total] 258 / 83 / 15 / 356:  36%|███▌      | 357/1000 [1:36:34<2:53:55, 16.23s/it][Succeeded / Failed / Skipped / Total] 259 / 83 / 15 / 357:  36%|███▌      | 357/1000 [1:36:34<2:53:55, 16.23s/it][Succeeded / Failed / Skipped / Total] 259 / 83 / 15 / 357:  36%|███▌      | 358/1000 [1:36:51<2:53:42, 16.23s/it][Succeeded / Failed / Skipped / Total] 259 / 84 / 15 / 358:  36%|███▌      | 358/1000 [1:36:51<2:53:42, 16.23s/it][Succeeded / Failed / Skipped / Total] 259 / 84 / 15 / 358:  36%|███▌      | 359/1000 [1:36:59<2:53:10, 16.21s/it][Succeeded / Failed / Skipped / Total] 259 / 85 / 15 / 359:  36%|███▌      | 359/1000 [1:36:59<2:53:10, 16.21s/it][Succeeded / Failed / Skipped / Total] 259 / 85 / 15 / 359:  36%|███▌      | 360/1000 [1:37:21<2:53:04, 16.23s/it]--------------------------------------------- Result 354 ---------------------------------------------
Returns a list of constructors for the given type parameters . --> Obtains a list of parameters --> Socre: 1.0

[[[[Adv]]]]: private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] [[paramAnnotations]] = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > [[constructorKeys]] = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , [[paramAnnotations]] [ p ++ ] , errors ) ; [[constructorKeys]] . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] [[gaskets]] = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > [[pok]] = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , [[gaskets]] [ p ++ ] , errors ) ; [[pok]] . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 355 ---------------------------------------------
Returns a String representation of the given key . --> [[[SKIPPED]]]

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 356 ---------------------------------------------
Returns a builder for a given set of dependencies . --> Build a set of beans --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[getDependencies]] ( InjectionPoint [[ctorPoint]] , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > [[builder]] = ImmutableSet . builder ( ) ; [[builder]] . addAll ( [[ctorPoint]] . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint [[ip]] : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { [[builder]] . addAll ( [[ip]] . getDependencies ( ) ) ; } } return [[builder]] . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > [[bonuses]] ( InjectionPoint [[galls]] , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > [[decorators]] = ImmutableSet . builder ( ) ; [[decorators]] . addAll ( [[galls]] . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint [[iap]] : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { [[decorators]] . addAll ( [[iap]] . getDependencies ( ) ) ; } } return [[decorators]] . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 357 ---------------------------------------------
Creates a new binder for a given key . --> Returns a new binder for a given key --> Socre: 1.0

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[newRealSetBinder]] ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[result]] = new RealMultibinder <> ( binder , key ) ; binder . install ( [[result]] ) ; return [[result]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[sausalito]] ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[fruition]] = new RealMultibinder <> ( binder , key ) ; binder . install ( [[fruition]] ) ; return [[fruition]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 358 ---------------------------------------------
Checks if the given type is a scope . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 359 ---------------------------------------------
Binds a binding . --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 360 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 260 / 85 / 15 / 360:  36%|███▌      | 360/1000 [1:37:21<2:53:04, 16.23s/it][Succeeded / Failed / Skipped / Total] 260 / 85 / 15 / 360:  36%|███▌      | 361/1000 [1:37:44<2:53:00, 16.24s/it][Succeeded / Failed / Skipped / Total] 261 / 85 / 15 / 361:  36%|███▌      | 361/1000 [1:37:44<2:53:00, 16.24s/it][Succeeded / Failed / Skipped / Total] 261 / 85 / 15 / 361:  36%|███▌      | 362/1000 [1:38:53<2:54:17, 16.39s/it][Succeeded / Failed / Skipped / Total] 262 / 85 / 15 / 362:  36%|███▌      | 362/1000 [1:38:53<2:54:17, 16.39s/it][Succeeded / Failed / Skipped / Total] 262 / 85 / 15 / 362:  36%|███▋      | 363/1000 [1:40:33<2:56:27, 16.62s/it][Succeeded / Failed / Skipped / Total] 262 / 86 / 15 / 363:  36%|███▋      | 363/1000 [1:40:33<2:56:27, 16.62s/it][Succeeded / Failed / Skipped / Total] 262 / 86 / 15 / 363:  36%|███▋      | 364/1000 [1:40:43<2:55:59, 16.60s/it][Succeeded / Failed / Skipped / Total] 262 / 87 / 15 / 364:  36%|███▋      | 364/1000 [1:40:43<2:55:59, 16.60s/it][Succeeded / Failed / Skipped / Total] 262 / 87 / 15 / 364:  36%|███▋      | 365/1000 [1:41:22<2:56:22, 16.67s/it][Succeeded / Failed / Skipped / Total] 263 / 87 / 15 / 365:  36%|███▋      | 365/1000 [1:41:22<2:56:22, 16.67s/it][Succeeded / Failed / Skipped / Total] 263 / 87 / 15 / 365:  37%|███▋      | 366/1000 [1:41:38<2:56:04, 16.66s/it][Succeeded / Failed / Skipped / Total] 263 / 88 / 15 / 366:  37%|███▋      | 366/1000 [1:41:38<2:56:04, 16.66s/it][Succeeded / Failed / Skipped / Total] 263 / 88 / 15 / 366:  37%|███▋      | 367/1000 [1:41:48<2:55:36, 16.65s/it][Succeeded / Failed / Skipped / Total] 264 / 88 / 15 / 367:  37%|███▋      | 367/1000 [1:41:48<2:55:36, 16.65s/it][Succeeded / Failed / Skipped / Total] 264 / 88 / 15 / 367:  37%|███▋      | 368/1000 [1:42:02<2:55:15, 16.64s/it]Gets the type of the given message . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isTypeNotSpecified]] ( TypeLiteral < ? > typeLiteral , ConfigurationException [[ce]] ) { Collection < Message > [[messages]] = [[ce]] . getErrorMessages ( ) ; if ( [[messages]] . size ( ) == 1 ) { Message [[msg]] = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return [[msg]] . getMessage ( ) . equals ( Iterables . getOnlyElement ( [[messages]] ) . getMessage ( ) ) ; } else { return "[[False]]" != "[[False]]" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean [[phipps]] ( TypeLiteral < ? > typeLiteral , ConfigurationException [[cette]] ) { Collection < Message > [[courier]] = [[cette]] . getErrorMessages ( ) ; if ( [[courier]] . size ( ) == 1 ) { Message [[signal]] = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return [[signal]] . getMessage ( ) . equals ( Iterables . getOnlyElement ( [[courier]] ) . getMessage ( ) ) ; } else { return "[[Misspelled]]" != "[[Misspelled]]" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 361 ---------------------------------------------
Matches a specific module . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Module [[forModule]] ( Object module , ModuleAnnotatedMethodScanner [[scanner]] ) { return forObject ( module , "False" != "False" , [[scanner]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module [[uk]] ( Object module , ModuleAnnotatedMethodScanner [[sensing]] ) { return forObject ( module , "False" != "False" , [[sensing]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 362 ---------------------------------------------
Add annotation annotation . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: private Annotation [[getAnnotation]] ( Binder [[binder]] , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation [[annotation]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation [[foundAnnotation]] = method . getAnnotation ( annotationClass ) ; if ( [[foundAnnotation]] != null ) { if ( [[annotation]] != null ) { [[binder]] . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } [[annotation]] = [[foundAnnotation]] ; } } return [[annotation]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation [[invests]] ( Binder [[mandatory]] , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation [[birdhouse]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation [[thursday]] = method . getAnnotation ( annotationClass ) ; if ( [[thursday]] != null ) { if ( [[birdhouse]] != null ) { [[mandatory]] . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } [[birdhouse]] = [[thursday]] ; } } return [[birdhouse]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 363 ---------------------------------------------
Invokes a method . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 364 ---------------------------------------------
Gets the filter . --> [[[FAILED]]]

[[[[Adv]]]]: private Filter findNextFilter ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter findNextFilter ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 365 ---------------------------------------------
Creates a new callable . --> Convenience function for testing --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[continueRequest]] ( Callable < T > [[callable]] , Map < Key < ? > , Object > seedMap ) { return wrap ( [[callable]] , [[continueRequest]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[contesting]] ( Callable < T > [[surat]] , Map < Key < ? > , Object > seedMap ) { return wrap ( [[surat]] , [[contesting]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 366 ---------------------------------------------
Returns a new instance of the given parameters . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 367 ---------------------------------------------
Initialize the injector . --> Utility method to register a formula --> Socre: 1.0

[[[[Adv]]]]: void [[initialize]] ( Errors [[errors]] ) { injector . lookups = injector ; new LookupProcessor ( [[errors]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[heartbeats]] ( Errors [[abnormality]] ) { injector . lookups = injector ; new LookupProcessor ( [[abnormality]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
[Succeeded / Failed / Skipped / Total] 264 / 89 / 15 / 368:  37%|███▋      | 368/1000 [1:42:02<2:55:15, 16.64s/it][Succeeded / Failed / Skipped / Total] 264 / 89 / 15 / 368:  37%|███▋      | 369/1000 [1:42:07<2:54:38, 16.61s/it][Succeeded / Failed / Skipped / Total] 264 / 90 / 15 / 369:  37%|███▋      | 369/1000 [1:42:07<2:54:38, 16.61s/it][Succeeded / Failed / Skipped / Total] 264 / 90 / 15 / 369:  37%|███▋      | 370/1000 [1:42:15<2:54:06, 16.58s/it][Succeeded / Failed / Skipped / Total] 265 / 90 / 15 / 370:  37%|███▋      | 370/1000 [1:42:15<2:54:06, 16.58s/it][Succeeded / Failed / Skipped / Total] 265 / 90 / 15 / 370:  37%|███▋      | 371/1000 [1:42:20<2:53:30, 16.55s/it][Succeeded / Failed / Skipped / Total] 265 / 91 / 15 / 371:  37%|███▋      | 371/1000 [1:42:20<2:53:30, 16.55s/it][Succeeded / Failed / Skipped / Total] 265 / 91 / 15 / 371:  37%|███▋      | 372/1000 [1:42:25<2:52:54, 16.52s/it][Succeeded / Failed / Skipped / Total] 266 / 91 / 15 / 372:  37%|███▋      | 372/1000 [1:42:25<2:52:54, 16.52s/it][Succeeded / Failed / Skipped / Total] 266 / 91 / 15 / 372:  37%|███▋      | 373/1000 [1:43:06<2:53:19, 16.59s/it][Succeeded / Failed / Skipped / Total] 267 / 91 / 15 / 373:  37%|███▋      | 373/1000 [1:43:06<2:53:19, 16.59s/it][Succeeded / Failed / Skipped / Total] 267 / 91 / 15 / 373:  37%|███▋      | 374/1000 [1:43:07<2:52:36, 16.54s/it][Succeeded / Failed / Skipped / Total] 268 / 91 / 15 / 374:  37%|███▋      | 374/1000 [1:43:07<2:52:36, 16.54s/it][Succeeded / Failed / Skipped / Total] 268 / 91 / 15 / 374:  38%|███▊      | 375/1000 [1:43:15<2:52:06, 16.52s/it]--------------------------------------------- Result 368 ---------------------------------------------
Returns the constructor . --> [[[FAILED]]]

[[[[Adv]]]]: InjectionPoint getInternalConstructor ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint getInternalConstructor ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 369 ---------------------------------------------
Checks whether the given dependency matches the given dependency type . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 370 ---------------------------------------------
Asynchronously wraps the given callable . --> Convenience function for testing --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > [[transferRequest]] ( Callable < T > [[callable]] ) { return wrap ( [[callable]] , [[transferRequest]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > [[satisfactory]] ( Callable < T > [[wouls]] ) { return wrap ( [[wouls]] , [[satisfactory]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 371 ---------------------------------------------
Adds a set of beans to the builder . --> [[[FAILED]]]

[[[[Adv]]]]: Set < Dependency < ? > > getInternalDependencies ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > getInternalDependencies ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 372 ---------------------------------------------
Gets the annotation annotation . --> Convert a room to a room --> Socre: 1.0

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Annotation [[annotation]] ) { checkNotNull ( [[annotation]] , "annotation" ) ; Class < ? extends Annotation > [[annotationType]] = [[annotation]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; if ( Annotations . isMarker ( [[annotationType]] ) ) { return new AnnotationTypeStrategy ( [[annotationType]] , [[annotation]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[annotation]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy [[pinstripe]] ( Annotation [[playroom]] ) { checkNotNull ( [[playroom]] , "annotation" ) ; Class < ? extends Annotation > [[wiki]] = [[playroom]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[wiki]] ) ; ensureIsBindingAnnotation ( [[wiki]] ) ; if ( Annotations . isMarker ( [[wiki]] ) ) { return new AnnotationTypeStrategy ( [[wiki]] , [[playroom]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[playroom]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 373 ---------------------------------------------
Creates a new annotation . --> Create generating genvalue --> Socre: 1.0

[[[[Adv]]]]: static < T > Key < T > get ( Class < T > [[type]] , AnnotationStrategy [[annotationStrategy]] ) { return new Key < T > ( [[type]] , [[annotationStrategy]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > get ( Class < T > [[genres]] , AnnotationStrategy [[curveball]] ) { return new Key < T > ( [[genres]] , [[curveball]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 374 ---------------------------------------------
Adds the stack trace to the stack . --> Adapts a routine --> Socre: 1.0

[[[[Adv]]]]: private void [[pruneStacktrace]] ( Throwable [[throwable]] ) { for ( Throwable t = [[throwable]] ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] [[stackTrace]] = t . getStackTrace ( ) ; List < StackTraceElement > [[pruned]] = Lists . newArrayList ( ) ; for ( StackTraceElement element : [[stackTrace]] ) { String [[className]] = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( [[className]] ) && ! [[className]] . contains ( "$EnhancerByGuice$" ) ) { [[pruned]] . add ( element ) ; } } t . setStackTrace ( [[pruned]] . toArray ( new StackTraceElement [ [[pruned]] . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void [[storeroom]] ( Throwable [[unravel]] ) { for ( Throwable t = [[unravel]] ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] [[sloane]] = t . getStackTrace ( ) ; List < StackTraceElement > [[sprouts]] = Lists . newArrayList ( ) ; for ( StackTraceElement element : [[sloane]] ) { String [[ran]] = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( [[ran]] ) && ! [[ran]] . contains ( "$EnhancerByGuice$" ) ) { [[sprouts]] . add ( element ) ; } } t . setStackTrace ( [[sprouts]] . toArray ( new StackTraceElement [ [[sprouts]] . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 375 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 268 / 92 / 15 / 375:  38%|███▊      | 375/1000 [1:43:15<2:52:06, 16.52s/it][Succeeded / Failed / Skipped / Total] 268 / 92 / 15 / 375:  38%|███▊      | 376/1000 [1:43:24<2:51:37, 16.50s/it][Succeeded / Failed / Skipped / Total] 268 / 93 / 15 / 376:  38%|███▊      | 376/1000 [1:43:24<2:51:37, 16.50s/it][Succeeded / Failed / Skipped / Total] 268 / 93 / 15 / 376:  38%|███▊      | 377/1000 [1:44:07<2:52:03, 16.57s/it][Succeeded / Failed / Skipped / Total] 269 / 93 / 15 / 377:  38%|███▊      | 377/1000 [1:44:07<2:52:03, 16.57s/it][Succeeded / Failed / Skipped / Total] 269 / 93 / 15 / 377:  38%|███▊      | 378/1000 [1:45:09<2:53:02, 16.69s/it][Succeeded / Failed / Skipped / Total] 270 / 93 / 15 / 378:  38%|███▊      | 378/1000 [1:45:09<2:53:02, 16.69s/it][Succeeded / Failed / Skipped / Total] 270 / 93 / 15 / 378:  38%|███▊      | 379/1000 [1:45:18<2:52:33, 16.67s/it][Succeeded / Failed / Skipped / Total] 271 / 93 / 15 / 379:  38%|███▊      | 379/1000 [1:45:18<2:52:33, 16.67s/it][Succeeded / Failed / Skipped / Total] 271 / 93 / 15 / 379:  38%|███▊      | 380/1000 [1:46:14<2:53:21, 16.78s/it][Succeeded / Failed / Skipped / Total] 271 / 94 / 15 / 380:  38%|███▊      | 380/1000 [1:46:14<2:53:21, 16.78s/it][Succeeded / Failed / Skipped / Total] 271 / 94 / 15 / 380:  38%|███▊      | 381/1000 [1:46:20<2:52:45, 16.75s/it][Succeeded / Failed / Skipped / Total] 272 / 94 / 15 / 381:  38%|███▊      | 381/1000 [1:46:20<2:52:45, 16.75s/it][Succeeded / Failed / Skipped / Total] 272 / 94 / 15 / 381:  38%|███▊      | 382/1000 [1:46:22<2:52:06, 16.71s/it][Succeeded / Failed / Skipped / Total] 273 / 94 / 15 / 382:  38%|███▊      | 382/1000 [1:46:22<2:52:06, 16.71s/it][Succeeded / Failed / Skipped / Total] 273 / 94 / 15 / 382:  38%|███▊      | 383/1000 [1:46:53<2:52:12, 16.75s/it]Determines if the given JMX . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean hasAtInject ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean hasAtInject ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 376 ---------------------------------------------
Returns the member of the given member . --> [[[FAILED]]]

[[[[Adv]]]]: public Integer getLineNumber ( Member member ) { Preconditions . checkArgument ( type == member . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , member , member . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( member ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer getLineNumber ( Member member ) { Preconditions . checkArgument ( type == member . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , member , member . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( member ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 377 ---------------------------------------------
Creates a new message . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( String [[messageFormat]] , Object ... arguments ) { return [[create]] ( null , [[messageFormat]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message [[mods]] ( String [[shella]] , Object ... arguments ) { return [[mods]] ( null , [[shella]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 378 ---------------------------------------------
Gets the annotation annotation . --> Build a new logology --> Socre: 1.0

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > [[annotationType]] ) { [[annotationType]] = Annotations . canonicalizeIfNamed ( [[annotationType]] ) ; if ( isAllDefaultMethods ( [[annotationType]] ) ) { return [[strategyFor]] ( generateAnnotation ( [[annotationType]] ) ) ; } checkNotNull ( [[annotationType]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; return new AnnotationTypeStrategy ( [[annotationType]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[roxbury]] ( Class < ? extends Annotation > [[ideologies]] ) { [[ideologies]] = Annotations . canonicalizeIfNamed ( [[ideologies]] ) ; if ( isAllDefaultMethods ( [[ideologies]] ) ) { return [[roxbury]] ( generateAnnotation ( [[ideologies]] ) ) ; } checkNotNull ( [[ideologies]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[ideologies]] ) ; ensureIsBindingAnnotation ( [[ideologies]] ) ; return new AnnotationTypeStrategy ( [[ideologies]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 379 ---------------------------------------------
Convert an object to a String . --> Static factory method for testing purposes --> Socre: 1.0

[[[[Adv]]]]: static Object [[convert]] ( Object o ) { ElementSource [[source]] = null ; if ( o instanceof ElementSource ) { [[source]] = ( ElementSource ) o ; o = [[source]] . getDeclaringSource ( ) ; } return [[convert]] ( o , [[source]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object [[transforming]] ( Object o ) { ElementSource [[fuentes]] = null ; if ( o instanceof ElementSource ) { [[fuentes]] = ( ElementSource ) o ; o = [[fuentes]] . getDeclaringSource ( ) ; } return [[transforming]] ( o , [[fuentes]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 380 ---------------------------------------------
Returns the value of the given object . --> [[[FAILED]]]

[[[[Adv]]]]: private static Object validateAndCanonicalizeValue ( Key < ? > key , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object validateAndCanonicalizeValue ( Key < ? > key , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 381 ---------------------------------------------
Returns the name of the module . --> Converts a list of objects to a specific object --> Socre: 1.0

[[[[Adv]]]]: public Object [[getFromClassNames]] ( List < String > [[moduleClassNames]] ) { Preconditions . checkNotNull ( [[moduleClassNames]] , "The list of module class names cannot be null." ) ; for ( final String [[moduleClassName]] : [[moduleClassNames]] ) { if ( ! shouldBeSkipped ( [[moduleClassName]] ) ) { return new StackTraceElement ( [[moduleClassName]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object [[reid]] ( List < String > [[gto]] ) { Preconditions . checkNotNull ( [[gto]] , "The list of module class names cannot be null." ) ; for ( final String [[bal]] : [[gto]] ) { if ( ! shouldBeSkipped ( [[bal]] ) ) { return new StackTraceElement ( [[bal]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 382 ---------------------------------------------
Creates a Throwable . --> Factory method for creating an object --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , String [[messageFormat]] , Object ... [[arguments]] ) { return [[create]] ( [[cause]] , ImmutableList . of ( ) , [[messageFormat]] , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[engenders]] ( Throwable [[spark]] , String [[storch]] , Object ... [[contention]] ) { return [[engenders]] ( [[spark]] , ImmutableList . of ( ) , [[storch]] , [[contention]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 383 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 274 / 94 / 15 / 383:  38%|███▊      | 383/1000 [1:46:53<2:52:12, 16.75s/it][Succeeded / Failed / Skipped / Total] 274 / 94 / 15 / 383:  38%|███▊      | 384/1000 [1:46:53<2:51:29, 16.70s/it][Succeeded / Failed / Skipped / Total] 275 / 94 / 15 / 384:  38%|███▊      | 384/1000 [1:46:53<2:51:29, 16.70s/it][Succeeded / Failed / Skipped / Total] 275 / 94 / 15 / 384:  38%|███▊      | 385/1000 [1:46:56<2:50:50, 16.67s/it][Succeeded / Failed / Skipped / Total] 276 / 94 / 15 / 385:  38%|███▊      | 385/1000 [1:46:56<2:50:50, 16.67s/it][Succeeded / Failed / Skipped / Total] 276 / 94 / 15 / 385:  39%|███▊      | 386/1000 [1:47:30<2:51:00, 16.71s/it][Succeeded / Failed / Skipped / Total] 277 / 94 / 15 / 386:  39%|███▊      | 386/1000 [1:47:30<2:51:00, 16.71s/it][Succeeded / Failed / Skipped / Total] 277 / 94 / 15 / 386:  39%|███▊      | 387/1000 [1:47:51<2:50:51, 16.72s/it][Succeeded / Failed / Skipped / Total] 277 / 95 / 15 / 387:  39%|███▊      | 387/1000 [1:47:51<2:50:51, 16.72s/it][Succeeded / Failed / Skipped / Total] 277 / 95 / 15 / 387:  39%|███▉      | 388/1000 [1:48:04<2:50:28, 16.71s/it][Succeeded / Failed / Skipped / Total] 278 / 95 / 15 / 388:  39%|███▉      | 388/1000 [1:48:04<2:50:28, 16.71s/it][Succeeded / Failed / Skipped / Total] 278 / 95 / 15 / 388:  39%|███▉      | 389/1000 [1:48:19<2:50:08, 16.71s/it]Main method . --> Prints a decision --> Socre: 1.0

[[[[Adv]]]]: public static void main ( String [ ] [[args]] ) throws Exception { if ( [[args]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( [[args]] [ 0 ] ) . newInstance ( ) ; Injector [[injector]] = Guice . createInjector ( module ) ; manage ( [[args]] [ 0 ] , [[injector]] ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void main ( String [ ] [[deray]] ) throws Exception { if ( [[deray]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( [[deray]] [ 0 ] ) . newInstance ( ) ; Injector [[propellant]] = Guice . createInjector ( module ) ; manage ( [[deray]] [ 0 ] , [[propellant]] ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 384 ---------------------------------------------
Returns a list of usages . --> Converts a list of usages to a map --> Socre: 1.0

[[[[Adv]]]]: public static String [[formatMessages]] ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int [[index]] = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int [[thisIdx]] = [[index]] ++ ; fmt . format ( "%s) %s%n" , [[thisIdx]] , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , [[thisIdx]] ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String [[intimidated]] ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int [[repertoire]] = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int [[quirt]] = [[repertoire]] ++ ; fmt . format ( "%s) %s%n" , [[quirt]] , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , [[quirt]] ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 385 ---------------------------------------------
Returns an instance of the given type . --> Converts a String to a String --> Socre: 1.0

[[[[Adv]]]]: static < T > Initializable < T > of ( final T [[instance]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[instance]] ; } @ Override public String toString ( ) { return String . valueOf ( [[instance]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > of ( final T [[dossiers]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[dossiers]] ; } @ Override public String toString ( ) { return String . valueOf ( [[dossiers]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 386 ---------------------------------------------
Handles a key . --> Shuts down authentication --> Socre: 1.0

[[[[Adv]]]]: void [[pushState]] ( com . google . inject . Key < ? > [[key]] , Object [[source]] ) { doPushState ( [[key]] , [[source]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void [[sshh]] ( com . google . inject . Key < ? > [[leading]] , Object [[racine]] ) { doPushState ( [[leading]] , [[racine]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 387 ---------------------------------------------
Stops all processors . --> [[[FAILED]]]

[[[[Adv]]]]: public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .

[[[[Adv]]]]: public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .
--------------------------------------------- Result 388 ---------------------------------------------
Add a processor . --> Register a producer --> Socre: 1.0

[[[[Adv]]]]: public void [[addConnectionEventProcessor]] ( ConnectionEventType [[type]] , ConnectionEventProcessor [[processor]] ) { List < ConnectionEventProcessor > [[processorList]] = this . [[processors]] . get ( [[type]] ) ; if ( [[processorList]] == null ) { this . [[processors]] . putIfAbsent ( [[type]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; [[processorList]] = this . [[processors]] . get ( [[type]] ) ; } [[processorList]] . add ( [[processor]] ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void [[condoning]] ( ConnectionEventType [[dude]] , ConnectionEventProcessor [[producers]] ) { List < ConnectionEventProcessor > [[sprightly]] = this . [[processor]] . get ( [[dude]] ) ; if ( [[sprightly]] == null ) { this . [[processor]] . putIfAbsent ( [[dude]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; [[sprightly]] = this . [[processor]] . get ( [[dude]] ) ; } [[sprightly]] . add ( [[producers]] ) ; }
[[[[Nl]]]]: Add event processor .
[Succeeded / Failed / Skipped / Total] 278 / 96 / 15 / 389:  39%|███▉      | 389/1000 [1:48:19<2:50:08, 16.71s/it][Succeeded / Failed / Skipped / Total] 278 / 96 / 15 / 389:  39%|███▉      | 390/1000 [1:48:20<2:49:27, 16.67s/it][Succeeded / Failed / Skipped / Total] 279 / 96 / 15 / 390:  39%|███▉      | 390/1000 [1:48:20<2:49:27, 16.67s/it][Succeeded / Failed / Skipped / Total] 279 / 96 / 15 / 390:  39%|███▉      | 391/1000 [1:48:21<2:48:46, 16.63s/it][Succeeded / Failed / Skipped / Total] 280 / 96 / 15 / 391:  39%|███▉      | 391/1000 [1:48:21<2:48:46, 16.63s/it][Succeeded / Failed / Skipped / Total] 280 / 96 / 15 / 391:  39%|███▉      | 392/1000 [1:48:30<2:48:18, 16.61s/it][Succeeded / Failed / Skipped / Total] 281 / 96 / 15 / 392:  39%|███▉      | 392/1000 [1:48:30<2:48:18, 16.61s/it][Succeeded / Failed / Skipped / Total] 281 / 96 / 15 / 392:  39%|███▉      | 393/1000 [1:48:36<2:47:45, 16.58s/it][Succeeded / Failed / Skipped / Total] 282 / 96 / 15 / 393:  39%|███▉      | 393/1000 [1:48:36<2:47:45, 16.58s/it][Succeeded / Failed / Skipped / Total] 282 / 96 / 15 / 393:  39%|███▉      | 394/1000 [1:48:37<2:47:03, 16.54s/it][Succeeded / Failed / Skipped / Total] 282 / 96 / 16 / 394:  39%|███▉      | 394/1000 [1:48:37<2:47:03, 16.54s/it][Succeeded / Failed / Skipped / Total] 282 / 96 / 16 / 394:  40%|███▉      | 395/1000 [1:48:37<2:46:22, 16.50s/it][Succeeded / Failed / Skipped / Total] 282 / 96 / 17 / 395:  40%|███▉      | 395/1000 [1:48:37<2:46:22, 16.50s/it][Succeeded / Failed / Skipped / Total] 282 / 96 / 17 / 395:  40%|███▉      | 396/1000 [1:48:48<2:45:57, 16.49s/it][Succeeded / Failed / Skipped / Total] 283 / 96 / 17 / 396:  40%|███▉      | 396/1000 [1:48:48<2:45:57, 16.49s/it][Succeeded / Failed / Skipped / Total] 283 / 96 / 17 / 396:  40%|███▉      | 397/1000 [1:48:48<2:45:16, 16.44s/it]--------------------------------------------- Result 389 ---------------------------------------------
Returns the type of the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public String getBindingSource ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String getBindingSource ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 390 ---------------------------------------------
Throws an exception if the given thrown . --> Throws an exception . --> Socre: 1.0

[[[[Adv]]]]: public static void [[launderThrowable]] ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable

[[[[Adv]]]]: public static void [[hydraulic]] ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 391 ---------------------------------------------
Register processor . --> Unregister processors --> Socre: 1.0

[[[[Adv]]]]: public void [[registerProcessor]] ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . [[cmd2processors]] . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . [[cmd2processors]] . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void [[millwall]] ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . [[orville]] . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . [[orville]] . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 392 ---------------------------------------------
Executes a task . --> Attempts to run asynchronously . --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] [[t]] = null ; if ( null != task ) { try { [[t]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[t]] ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[votre]] > [[votre]] getFutureTaskResult ( RunStateRecordedFutureTask < [[votre]] > task , Logger logger ) { [[votre]] [[did]] = null ; if ( null != task ) { try { [[did]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[did]] ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 393 ---------------------------------------------
Returns the processor processor . --> Retie a retrieving --> Socre: 1.0

[[[[Adv]]]]: public RemotingProcessor < ? > [[getProcessor]] ( CommandCode [[cmdCode]] ) { RemotingProcessor < ? > [[processor]] = this . [[cmd2processors]] . get ( [[cmdCode]] ) ; if ( [[processor]] != null ) { return [[processor]] ; } return this . [[defaultProcessor]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > [[pertain]] ( CommandCode [[ste]] ) { RemotingProcessor < ? > [[switcher]] = this . [[boer]] . get ( [[ste]] ) ; if ( [[switcher]] != null ) { return [[switcher]] ; } return this . [[tottering]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .
--------------------------------------------- Result 394 ---------------------------------------------
Replies the URL for the given URL . --> [[[SKIPPED]]]

[[[[Adv]]]]: private Url tryGet ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 395 ---------------------------------------------
Read bytes from byte array . --> [[[SKIPPED]]]

[[[[Adv]]]]: protected ProtocolCode decodeProtocolCode ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 396 ---------------------------------------------
Create a formatted message . --> Factory method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , List < Object > [[sources]] , String [[messageFormat]] , Object ... arguments ) { String [[message]] = format ( [[messageFormat]] , arguments ) ; return new Message ( [[sources]] , [[message]] , [[cause]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message [[forging]] ( Throwable [[resulting]] , List < Object > [[originate]] , String [[sleepwalk]] , Object ... arguments ) { String [[couriers]] = format ( [[sleepwalk]] , arguments ) ; return new Message ( [[originate]] , [[couriers]] , [[resulting]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 397 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 283 / 96 / 18 / 397:  40%|███▉      | 397/1000 [1:48:48<2:45:16, 16.44s/it][Succeeded / Failed / Skipped / Total] 283 / 96 / 18 / 397:  40%|███▉      | 398/1000 [1:49:32<2:45:41, 16.51s/it][Succeeded / Failed / Skipped / Total] 284 / 96 / 18 / 398:  40%|███▉      | 398/1000 [1:49:32<2:45:41, 16.51s/it][Succeeded / Failed / Skipped / Total] 284 / 96 / 18 / 398:  40%|███▉      | 399/1000 [1:49:32<2:45:00, 16.47s/it][Succeeded / Failed / Skipped / Total] 285 / 96 / 18 / 399:  40%|███▉      | 399/1000 [1:49:32<2:45:00, 16.47s/it][Succeeded / Failed / Skipped / Total] 285 / 96 / 18 / 399:  40%|████      | 400/1000 [1:49:47<2:44:41, 16.47s/it][Succeeded / Failed / Skipped / Total] 286 / 96 / 18 / 400:  40%|████      | 400/1000 [1:49:47<2:44:41, 16.47s/it][Succeeded / Failed / Skipped / Total] 286 / 96 / 18 / 400:  40%|████      | 401/1000 [1:49:50<2:44:05, 16.44s/it][Succeeded / Failed / Skipped / Total] 286 / 97 / 18 / 401:  40%|████      | 401/1000 [1:49:50<2:44:05, 16.44s/it][Succeeded / Failed / Skipped / Total] 286 / 97 / 18 / 401:  40%|████      | 402/1000 [1:49:51<2:43:24, 16.40s/it][Succeeded / Failed / Skipped / Total] 286 / 97 / 19 / 402:  40%|████      | 402/1000 [1:49:51<2:43:24, 16.40s/it][Succeeded / Failed / Skipped / Total] 286 / 97 / 19 / 402:  40%|████      | 403/1000 [1:49:51<2:42:44, 16.36s/it][Succeeded / Failed / Skipped / Total] 286 / 97 / 20 / 403:  40%|████      | 403/1000 [1:49:51<2:42:44, 16.36s/it][Succeeded / Failed / Skipped / Total] 286 / 97 / 20 / 403:  40%|████      | 404/1000 [1:50:05<2:42:24, 16.35s/it][Succeeded / Failed / Skipped / Total] 286 / 98 / 20 / 404:  40%|████      | 404/1000 [1:50:05<2:42:24, 16.35s/it][Succeeded / Failed / Skipped / Total] 286 / 98 / 20 / 404:  40%|████      | 405/1000 [1:50:11<2:41:53, 16.33s/it]Clear the pool . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 398 ---------------------------------------------
Adds a dependency to this dependency . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: Dependency < ? > [[pushDependency]] ( Dependency < ? > [[dependency]] , Object [[source]] ) { Dependency < ? > [[previous]] = this . [[dependency]] ; this . [[dependency]] = [[dependency]] ; doPushState ( [[dependency]] , [[source]] ) ; return [[previous]] ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > [[invertebrates]] ( Dependency < ? > [[subordinate]] , Object [[melt]] ) { Dependency < ? > [[bygones]] = this . [[longitude]] ; this . [[longitude]] = [[subordinate]] ; doPushState ( [[subordinate]] , [[melt]] ) ; return [[bygones]] ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 399 ---------------------------------------------
Get a url for a given url . --> Unregister a connection --> Socre: 1.0

[[[[Adv]]]]: @ Override public Connection [[getAndCreateIfAbsent]] ( Url [[url]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection [[unseemly]] ( Url [[blog]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 400 ---------------------------------------------
Returns a map of tasks . --> Allocate a pool --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > [[allConnections]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > [[entry]] = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( [[entry]] . getValue ( ) , logger ) ; if ( null != pool ) { [[allConnections]] . put ( [[entry]] . getKey ( ) , pool . getAll ( ) ) ; } } return [[allConnections]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > [[baloo]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > [[penetrates]] = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( [[penetrates]] . getValue ( ) , logger ) ; if ( null != pool ) { [[baloo]] . put ( [[penetrates]] . getKey ( ) , pool . getAll ( ) ) ; } } return [[baloo]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .
--------------------------------------------- Result 401 ---------------------------------------------
Remove a pool . --> [[[FAILED]]]

[[[[Adv]]]]: private void removeTask ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void removeTask ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 402 ---------------------------------------------
Adds a url to the pool . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 403 ---------------------------------------------
remove the url --> [[[SKIPPED]]]

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 404 ---------------------------------------------
Revoke a pool . --> [[[FAILED]]]

[[[[Adv]]]]: private void healIfNeed ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void healIfNeed ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected
--------------------------------------------- Result 405 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 286 / 99 / 20 / 405:  40%|████      | 405/1000 [1:50:11<2:41:53, 16.33s/it][Succeeded / Failed / Skipped / Total] 286 / 99 / 20 / 405:  41%|████      | 406/1000 [1:50:14<2:41:17, 16.29s/it][Succeeded / Failed / Skipped / Total] 287 / 99 / 20 / 406:  41%|████      | 406/1000 [1:50:14<2:41:17, 16.29s/it][Succeeded / Failed / Skipped / Total] 287 / 99 / 20 / 406:  41%|████      | 407/1000 [1:50:17<2:40:41, 16.26s/it][Succeeded / Failed / Skipped / Total] 288 / 99 / 20 / 407:  41%|████      | 407/1000 [1:50:17<2:40:41, 16.26s/it][Succeeded / Failed / Skipped / Total] 288 / 99 / 20 / 407:  41%|████      | 408/1000 [1:50:43<2:40:39, 16.28s/it][Succeeded / Failed / Skipped / Total] 289 / 99 / 20 / 408:  41%|████      | 408/1000 [1:50:43<2:40:39, 16.28s/it][Succeeded / Failed / Skipped / Total] 289 / 99 / 20 / 408:  41%|████      | 409/1000 [1:50:56<2:40:18, 16.28s/it][Succeeded / Failed / Skipped / Total] 290 / 99 / 20 / 409:  41%|████      | 409/1000 [1:50:56<2:40:18, 16.28s/it][Succeeded / Failed / Skipped / Total] 290 / 99 / 20 / 409:  41%|████      | 410/1000 [1:51:02<2:39:46, 16.25s/it][Succeeded / Failed / Skipped / Total] 291 / 99 / 20 / 410:  41%|████      | 410/1000 [1:51:02<2:39:46, 16.25s/it][Succeeded / Failed / Skipped / Total] 291 / 99 / 20 / 410:  41%|████      | 411/1000 [1:51:02<2:39:07, 16.21s/it]Returns a list of resources that match the given member . --> [[[FAILED]]]

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; injectors . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; injectors . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 406 ---------------------------------------------
Create a new connection . --> Convenience method to get a URL --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[createConnectionAndHealIfNeed]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void [[forman]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 407 ---------------------------------------------
Register processor . --> Utility method to create a new constructor --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerUserProcessor]] ( UserProcessor < ? > [[processor]] , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == [[processor]] ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( [[processor]] instanceof MultiInterestUserProcessor ) { [[registerUserProcessor]] ( ( MultiInterestUserProcessor ) [[processor]] , [[userProcessors]] ) ; } else { if ( StringUtils . isBlank ( [[processor]] . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > [[preProcessor]] = [[userProcessors]] . putIfAbsent ( [[processor]] . interest ( ) , [[processor]] ) ; if ( [[preProcessor]] != null ) { String [[errMsg]] = "Processor with interest key [" + [[processor]] . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( [[errMsg]] ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void [[tattler]] ( UserProcessor < ? > [[constructor]] , ConcurrentHashMap < String , UserProcessor < ? > > [[marseille]] ) { if ( null == [[constructor]] ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( [[constructor]] instanceof MultiInterestUserProcessor ) { [[tattler]] ( ( MultiInterestUserProcessor ) [[constructor]] , [[marseille]] ) ; } else { if ( StringUtils . isBlank ( [[constructor]] . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > [[cagliostro]] = [[marseille]] . putIfAbsent ( [[constructor]] . interest ( ) , [[constructor]] ) ; if ( [[cagliostro]] != null ) { String [[potter]] = "Processor with interest key [" + [[constructor]] . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( [[potter]] ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .
--------------------------------------------- Result 408 ---------------------------------------------
Sets an attribute . --> Add an object to a map --> Socre: 1.0

[[[[Adv]]]]: public Object [[setAttributeIfAbsent]] ( String key , Object value ) { return attributes . putIfAbsent ( key , value ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object [[troop]] ( String key , Object value ) { return attributes . putIfAbsent ( key , value ) ; }
[[[[Nl]]]]: set attribute if key absent .
--------------------------------------------- Result 409 ---------------------------------------------
Handles request . --> Handle transaction . --> Socre: 1.0

[[[[Adv]]]]: private void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand [[cmd]] ) { final int [[id]] = [[cmd]] . getId ( ) ; final byte type = [[cmd]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor

[[[[Adv]]]]: private void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand [[mcp]] ) { final int [[handle]] = [[mcp]] . getId ( ) ; final byte type = [[mcp]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor
--------------------------------------------- Result 410 ---------------------------------------------
Handle a command . --> Depending on the server . --> Socre: 1.0

[[[[Adv]]]]: private boolean deserializeRequestCommand ( RemotingContext [[ctx]] , RpcRequestCommand [[cmd]] , int level ) { boolean result ; try { [[cmd]] . deserialize ( level ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , [[cmd]] . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( [[ctx]] , [[cmd]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[cmd]] . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + [[cmd]] . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( [[ctx]] , [[cmd]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[cmd]] . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command

[[[[Adv]]]]: private boolean deserializeRequestCommand ( RemotingContext [[arow]] , RpcRequestCommand [[bx]] , int level ) { boolean result ; try { [[bx]] . deserialize ( level ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , [[bx]] . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( [[arow]] , [[bx]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[bx]] . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + [[bx]] . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( [[arow]] , [[bx]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[bx]] . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command
[Succeeded / Failed / Skipped / Total] 291 / 99 / 21 / 411:  41%|████      | 411/1000 [1:51:02<2:39:07, 16.21s/it][Succeeded / Failed / Skipped / Total] 291 / 99 / 21 / 411:  41%|████      | 412/1000 [1:51:05<2:38:32, 16.18s/it][Succeeded / Failed / Skipped / Total] 292 / 99 / 21 / 412:  41%|████      | 412/1000 [1:51:05<2:38:32, 16.18s/it][Succeeded / Failed / Skipped / Total] 292 / 99 / 21 / 412:  41%|████▏     | 413/1000 [1:51:05<2:37:53, 16.14s/it][Succeeded / Failed / Skipped / Total] 292 / 99 / 22 / 413:  41%|████▏     | 413/1000 [1:51:05<2:37:53, 16.14s/it][Succeeded / Failed / Skipped / Total] 292 / 99 / 22 / 413:  41%|████▏     | 414/1000 [1:51:23<2:37:39, 16.14s/it][Succeeded / Failed / Skipped / Total] 293 / 99 / 22 / 414:  41%|████▏     | 414/1000 [1:51:23<2:37:39, 16.14s/it][Succeeded / Failed / Skipped / Total] 293 / 99 / 22 / 414:  42%|████▏     | 415/1000 [1:51:30<2:37:10, 16.12s/it][Succeeded / Failed / Skipped / Total] 293 / 100 / 22 / 415:  42%|████▏     | 415/1000 [1:51:30<2:37:10, 16.12s/it][Succeeded / Failed / Skipped / Total] 293 / 100 / 22 / 415:  42%|████▏     | 416/1000 [1:51:48<2:36:57, 16.13s/it][Succeeded / Failed / Skipped / Total] 294 / 100 / 22 / 416:  42%|████▏     | 416/1000 [1:51:48<2:36:57, 16.13s/it][Succeeded / Failed / Skipped / Total] 294 / 100 / 22 / 416:  42%|████▏     | 417/1000 [1:52:04<2:36:42, 16.13s/it]--------------------------------------------- Result 411 ---------------------------------------------
Execute a command . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void preProcessRemotingContext ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz
--------------------------------------------- Result 412 ---------------------------------------------
Handles a channel . --> Handles a command --> Socre: 1.0

[[[[Adv]]]]: private void [[timeoutLog]] ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext [[ctx]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String [[remoteAddr]] = "UNKNOWN" ; if ( null != [[ctx]] ) { ChannelHandlerContext channelCtx = [[ctx]] . getChannelContext ( ) ; Channel [[channel]] = channelCtx . channel ( ) ; if ( null != [[channel]] ) { [[remoteAddr]] = RemotingUtil . parseRemoteAddress ( [[channel]] ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , [[remoteAddr]] , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .

[[[[Adv]]]]: private void [[understa]] ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext [[neigh]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String [[comps]] = "UNKNOWN" ; if ( null != [[neigh]] ) { ChannelHandlerContext channelCtx = [[neigh]] . getChannelContext ( ) ; Channel [[plumbing]] = channelCtx . channel ( ) ; if ( null != [[plumbing]] ) { [[comps]] = RemotingUtil . parseRemoteAddress ( [[plumbing]] ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , [[comps]] , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .
--------------------------------------------- Result 413 ---------------------------------------------
Parses the transaction . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void debugLog ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request
--------------------------------------------- Result 414 ---------------------------------------------
Register a user . --> Sends a mazonokeeper --> Socre: 1.0

[[[[Adv]]]]: private static void [[registerUserProcessor]] ( MultiInterestUserProcessor < ? > [[processor]] , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == [[processor]] . multiInterest ( ) || [[processor]] . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : [[processor]] . multiInterest ( ) ) { UserProcessor < ? > preProcessor = [[userProcessors]] . putIfAbsent ( interest , [[processor]] ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void [[lathered]] ( MultiInterestUserProcessor < ? > [[gigahertz]] , ConcurrentHashMap < String , UserProcessor < ? > > [[apogee]] ) { if ( null == [[gigahertz]] . multiInterest ( ) || [[gigahertz]] . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : [[gigahertz]] . multiInterest ( ) ) { UserProcessor < ? > preProcessor = [[apogee]] . putIfAbsent ( interest , [[gigahertz]] ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .
--------------------------------------------- Result 415 ---------------------------------------------
Execute a task . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .
--------------------------------------------- Result 416 ---------------------------------------------
Unregisters a future . --> Asynchronously invokes asynchronously --> Socre: 1.0

[[[[Adv]]]]: public void onClose ( ) { Iterator < Entry < Integer , InvokeFuture > > [[iter]] = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( [[iter]] . hasNext ( ) ) { Entry < Integer , InvokeFuture > [[entry]] = [[iter]] . next ( ) ; [[iter]] . remove ( ) ; InvokeFuture [[future]] = [[entry]] . getValue ( ) ; if ( [[future]] != null ) { [[future]] . putResponse ( [[future]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[future]] . cancelTimeout ( ) ; [[future]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void onClose ( ) { Iterator < Entry < Integer , InvokeFuture > > [[blanc]] = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( [[blanc]] . hasNext ( ) ) { Entry < Integer , InvokeFuture > [[come]] = [[blanc]] . next ( ) ; [[blanc]] . remove ( ) ; InvokeFuture [[forward]] = [[come]] . getValue ( ) ; if ( [[forward]] != null ) { [[forward]] . putResponse ( [[forward]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[forward]] . cancelTimeout ( ) ; [[forward]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 417 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 295 / 100 / 22 / 417:  42%|████▏     | 417/1000 [1:52:04<2:36:42, 16.13s/it][Succeeded / Failed / Skipped / Total] 295 / 100 / 22 / 417:  42%|████▏     | 418/1000 [1:52:06<2:36:05, 16.09s/it][Succeeded / Failed / Skipped / Total] 295 / 101 / 22 / 418:  42%|████▏     | 418/1000 [1:52:06<2:36:05, 16.09s/it][Succeeded / Failed / Skipped / Total] 295 / 101 / 22 / 418:  42%|████▏     | 419/1000 [1:52:06<2:35:27, 16.05s/it][Succeeded / Failed / Skipped / Total] 295 / 101 / 23 / 419:  42%|████▏     | 419/1000 [1:52:06<2:35:27, 16.05s/it][Succeeded / Failed / Skipped / Total] 295 / 101 / 23 / 419:  42%|████▏     | 420/1000 [1:52:11<2:34:56, 16.03s/it][Succeeded / Failed / Skipped / Total] 295 / 102 / 23 / 420:  42%|████▏     | 420/1000 [1:52:11<2:34:56, 16.03s/it][Succeeded / Failed / Skipped / Total] 295 / 102 / 23 / 420:  42%|████▏     | 421/1000 [1:52:23<2:34:34, 16.02s/it][Succeeded / Failed / Skipped / Total] 295 / 103 / 23 / 421:  42%|████▏     | 421/1000 [1:52:23<2:34:35, 16.02s/it][Succeeded / Failed / Skipped / Total] 295 / 103 / 23 / 421:  42%|████▏     | 422/1000 [1:52:24<2:33:57, 15.98s/it][Succeeded / Failed / Skipped / Total] 295 / 103 / 24 / 422:  42%|████▏     | 422/1000 [1:52:24<2:33:57, 15.98s/it][Succeeded / Failed / Skipped / Total] 295 / 103 / 24 / 422:  42%|████▏     | 423/1000 [1:52:24<2:33:19, 15.94s/it][Succeeded / Failed / Skipped / Total] 295 / 103 / 25 / 423:  42%|████▏     | 423/1000 [1:52:24<2:33:19, 15.94s/it][Succeeded / Failed / Skipped / Total] 295 / 103 / 25 / 423:  42%|████▏     | 424/1000 [1:52:26<2:32:45, 15.91s/it]Initializes the provider . --> Sets the dependency of the dependency --> Socre: 1.0

[[[[Adv]]]]: protected T [[provision]] ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > [[constructionContext]] ) throws InternalProvisionException { T [[t]] = provider . get ( ) ; if ( [[t]] == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } [[constructionContext]] . setProxyDelegates ( [[t]] ) ; return [[t]] ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T [[regulation]] ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > [[domina]] ) throws InternalProvisionException { T [[zillion]] = provider . get ( ) ; if ( [[zillion]] == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } [[domina]] . setProxyDelegates ( [[zillion]] ) ; return [[zillion]] ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .
--------------------------------------------- Result 418 ---------------------------------------------
Convert a BitSet to a bit . --> [[[FAILED]]]

[[[[Adv]]]]: public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set

[[[[Adv]]]]: public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set
--------------------------------------------- Result 419 ---------------------------------------------
Adds a URL to the server . --> [[[SKIPPED]]]

[[[[Adv]]]]: public void addReconnectTask ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task
--------------------------------------------- Result 420 ---------------------------------------------
Converts a byte array to a byte array . --> [[[FAILED]]]

[[[[Adv]]]]: public static byte toByte ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte

[[[[Adv]]]]: public static byte toByte ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte
--------------------------------------------- Result 421 ---------------------------------------------
Stop the connection . --> [[[FAILED]]]

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread
--------------------------------------------- Result 422 ---------------------------------------------
Returns a map of connection status . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : connections ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor
--------------------------------------------- Result 423 ---------------------------------------------
Schedule a pool . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off
--------------------------------------------- Result 424 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 296 / 103 / 25 / 424:  42%|████▏     | 424/1000 [1:52:26<2:32:45, 15.91s/it][Succeeded / Failed / Skipped / Total] 296 / 103 / 25 / 424:  42%|████▎     | 425/1000 [1:52:26<2:32:08, 15.87s/it][Succeeded / Failed / Skipped / Total] 296 / 103 / 26 / 425:  42%|████▎     | 425/1000 [1:52:26<2:32:08, 15.87s/it][Succeeded / Failed / Skipped / Total] 296 / 103 / 26 / 425:  43%|████▎     | 426/1000 [1:52:28<2:31:32, 15.84s/it][Succeeded / Failed / Skipped / Total] 297 / 103 / 26 / 426:  43%|████▎     | 426/1000 [1:52:28<2:31:32, 15.84s/it][Succeeded / Failed / Skipped / Total] 297 / 103 / 26 / 426:  43%|████▎     | 427/1000 [1:52:28<2:30:56, 15.81s/it][Succeeded / Failed / Skipped / Total] 297 / 104 / 26 / 427:  43%|████▎     | 427/1000 [1:52:28<2:30:56, 15.81s/it][Succeeded / Failed / Skipped / Total] 297 / 104 / 26 / 427:  43%|████▎     | 428/1000 [1:52:29<2:30:20, 15.77s/it][Succeeded / Failed / Skipped / Total] 298 / 104 / 26 / 428:  43%|████▎     | 428/1000 [1:52:29<2:30:20, 15.77s/it][Succeeded / Failed / Skipped / Total] 298 / 104 / 26 / 428:  43%|████▎     | 429/1000 [1:52:29<2:29:44, 15.73s/it][Succeeded / Failed / Skipped / Total] 298 / 104 / 27 / 429:  43%|████▎     | 429/1000 [1:52:29<2:29:44, 15.73s/it][Succeeded / Failed / Skipped / Total] 298 / 104 / 27 / 429:  43%|████▎     | 430/1000 [1:52:30<2:29:07, 15.70s/it][Succeeded / Failed / Skipped / Total] 298 / 104 / 28 / 430:  43%|████▎     | 430/1000 [1:52:30<2:29:07, 15.70s/it][Succeeded / Failed / Skipped / Total] 298 / 104 / 28 / 430:  43%|████▎     | 431/1000 [1:52:31<2:28:32, 15.66s/it][Succeeded / Failed / Skipped / Total] 299 / 104 / 28 / 431:  43%|████▎     | 431/1000 [1:52:31<2:28:32, 15.66s/it][Succeeded / Failed / Skipped / Total] 299 / 104 / 28 / 431:  43%|████▎     | 432/1000 [1:53:19<2:29:00, 15.74s/it]Adds a new connection to the list . --> Populates a new peer . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeFreshSelectConnections]] ( Connection lastSelectConnect , List < Connection > [[serviceOffConnections]] ) throws InterruptedException { if ( null != lastSelectConnect ) { if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { [[serviceOffConnections]] . add ( lastSelectConnect ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { [[serviceOffConnections]] . add ( lastSelectConnect ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( lastSelectConnect . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections

[[[[Adv]]]]: private void [[wardrobes]] ( Connection lastSelectConnect , List < Connection > [[conglomerate]] ) throws InterruptedException { if ( null != lastSelectConnect ) { if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { [[conglomerate]] . add ( lastSelectConnect ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { [[conglomerate]] . add ( lastSelectConnect ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( lastSelectConnect . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections
--------------------------------------------- Result 425 ---------------------------------------------
Returns the boolean value for the given key . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean getBool ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property
--------------------------------------------- Result 426 ---------------------------------------------
Logs a log message . --> Displays a specific status . --> Socre: 1.0

[[[[Adv]]]]: private void infoLog ( String format , String [[addr]] ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( [[addr]] ) ) { logger . info ( format , [[addr]] ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log

[[[[Adv]]]]: private void infoLog ( String format , String [[hides]] ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( [[hides]] ) ) { logger . info ( format , [[hides]] ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log
--------------------------------------------- Result 427 ---------------------------------------------
Returns true if the given class is a bean . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean shouldBeSkipped ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains ( className ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean shouldBeSkipped ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains ( className ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
--------------------------------------------- Result 428 ---------------------------------------------
Waits for a timeout . --> Returns true if the current T is enabled . --> Socre: 1.0

[[[[Adv]]]]: public boolean isRequestTimeout ( ) { if ( this . [[timeout]] > 0 && ( this . [[rpcCommandType]] != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . [[arriveTimestamp]] ) > this . [[timeout]] ) { return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout

[[[[Adv]]]]: public boolean isRequestTimeout ( ) { if ( this . [[timers]] > 0 && ( this . [[mercan]] != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . [[favor]] ) > this . [[timers]] ) { return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout
--------------------------------------------- Result 429 ---------------------------------------------
Gets a random number . --> [[[SKIPPED]]]

[[[[Adv]]]]: private Connection randomGet ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly
--------------------------------------------- Result 430 ---------------------------------------------
Returns the value associated with the given key . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . context . get ( key ) != null ? ( T ) this . context . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found
--------------------------------------------- Result 431 ---------------------------------------------
Get a property . --> Obtains a string . --> Socre: 1.0

[[[[Adv]]]]: public String [[getProperty]] ( String [[key]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[key]] ) ; }
[[[[Nl]]]]: Get property value according to property key

[[[[Adv]]]]: public String [[propulsion]] ( String [[leading]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[leading]] ) ; }
[[[[Nl]]]]: Get property value according to property key
--------------------------------------------- Result 432 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 299 / 105 / 28 / 432:  43%|████▎     | 432/1000 [1:53:19<2:29:00, 15.74s/it][Succeeded / Failed / Skipped / Total] 299 / 105 / 28 / 432:  43%|████▎     | 433/1000 [1:53:30<2:28:37, 15.73s/it][Succeeded / Failed / Skipped / Total] 300 / 105 / 28 / 433:  43%|████▎     | 433/1000 [1:53:30<2:28:37, 15.73s/it][Succeeded / Failed / Skipped / Total] 300 / 105 / 28 / 433:  43%|████▎     | 434/1000 [1:53:31<2:28:02, 15.69s/it][Succeeded / Failed / Skipped / Total] 300 / 106 / 28 / 434:  43%|████▎     | 434/1000 [1:53:31<2:28:02, 15.69s/it][Succeeded / Failed / Skipped / Total] 300 / 106 / 28 / 434:  44%|████▎     | 435/1000 [1:53:34<2:27:30, 15.66s/it][Succeeded / Failed / Skipped / Total] 301 / 106 / 28 / 435:  44%|████▎     | 435/1000 [1:53:34<2:27:30, 15.66s/it][Succeeded / Failed / Skipped / Total] 301 / 106 / 28 / 435:  44%|████▎     | 436/1000 [1:53:44<2:27:07, 15.65s/it][Succeeded / Failed / Skipped / Total] 302 / 106 / 28 / 436:  44%|████▎     | 436/1000 [1:53:44<2:27:07, 15.65s/it][Succeeded / Failed / Skipped / Total] 302 / 106 / 28 / 436:  44%|████▎     | 437/1000 [1:53:45<2:26:33, 15.62s/it]Generates a set of errors . --> [[[FAILED]]]

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 433 ---------------------------------------------
get the response from the response --> Gets a principal --> Socre: 1.0

[[[[Adv]]]]: private static Object [[toResponseObject]] ( ResponseCommand [[responseCommand]] ) throws CodecException { RpcResponseCommand [[response]] = ( RpcResponseCommand ) [[responseCommand]] ; [[response]] . deserialize ( ) ; return [[response]] . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .

[[[[Adv]]]]: private static Object [[pontiac]] ( ResponseCommand [[unprincipled]] ) throws CodecException { RpcResponseCommand [[speeches]] = ( RpcResponseCommand ) [[unprincipled]] ; [[speeches]] . deserialize ( ) ; return [[speeches]] . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .
--------------------------------------------- Result 434 ---------------------------------------------
Handles a response . --> [[[FAILED]]]

[[[[Adv]]]]: public static Object resolveResponseObject ( ResponseCommand responseCommand , String addr ) throws RemotingException { preProcess ( responseCommand , addr ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; logger . warn ( msg ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( msg , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .

[[[[Adv]]]]: public static Object resolveResponseObject ( ResponseCommand responseCommand , String addr ) throws RemotingException { preProcess ( responseCommand , addr ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; logger . warn ( msg ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( msg , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .
--------------------------------------------- Result 435 ---------------------------------------------
Handles response . --> Converts a String to a String --> Socre: 1.0

[[[[Adv]]]]: private static String [[detailErrMsg]] ( String [[clientErrMsg]] , ResponseCommand [[responseCommand]] ) { RpcResponseCommand [[resp]] = ( RpcResponseCommand ) [[responseCommand]] ; if ( StringUtils . isNotBlank ( [[resp]] . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , [[clientErrMsg]] , [[resp]] . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , [[clientErrMsg]] ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command

[[[[Adv]]]]: private static String [[buster]] ( String [[enhancer]] , ResponseCommand [[kirsty]] ) { RpcResponseCommand [[crankshaft]] = ( RpcResponseCommand ) [[kirsty]] ; if ( StringUtils . isNotBlank ( [[crankshaft]] . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , [[enhancer]] , [[crankshaft]] . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , [[enhancer]] ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command
--------------------------------------------- Result 436 ---------------------------------------------
Returns true if the user has a User . --> Obtain a how many lazuow many --> Socre: 1.0

[[[[Adv]]]]: public UserProcessor < ? > getUserProcessor ( String [[className]] ) { return StringUtils . isBlank ( [[className]] ) ? null : this . [[userProcessors]] . get ( [[className]] ) ; }
[[[[Nl]]]]: Get user processor for class name .

[[[[Adv]]]]: public UserProcessor < ? > getUserProcessor ( String [[slaughterhouses]] ) { return StringUtils . isBlank ( [[slaughterhouses]] ) ? null : this . [[kivu]] . get ( [[slaughterhouses]] ) ; }
[[[[Nl]]]]: Get user processor for class name .
--------------------------------------------- Result 437 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 302 / 107 / 28 / 437:  44%|████▎     | 437/1000 [1:53:45<2:26:33, 15.62s/it][Succeeded / Failed / Skipped / Total] 302 / 107 / 28 / 437:  44%|████▍     | 438/1000 [1:53:48<2:26:01, 15.59s/it][Succeeded / Failed / Skipped / Total] 303 / 107 / 28 / 438:  44%|████▍     | 438/1000 [1:53:48<2:26:01, 15.59s/it][Succeeded / Failed / Skipped / Total] 303 / 107 / 28 / 438:  44%|████▍     | 439/1000 [1:53:48<2:25:26, 15.56s/it][Succeeded / Failed / Skipped / Total] 303 / 108 / 28 / 439:  44%|████▍     | 439/1000 [1:53:48<2:25:26, 15.56s/it][Succeeded / Failed / Skipped / Total] 303 / 108 / 28 / 439:  44%|████▍     | 440/1000 [1:53:49<2:24:51, 15.52s/it][Succeeded / Failed / Skipped / Total] 304 / 108 / 28 / 440:  44%|████▍     | 440/1000 [1:53:49<2:24:51, 15.52s/it][Succeeded / Failed / Skipped / Total] 304 / 108 / 28 / 440:  44%|████▍     | 441/1000 [1:53:51<2:24:19, 15.49s/it][Succeeded / Failed / Skipped / Total] 305 / 108 / 28 / 441:  44%|████▍     | 441/1000 [1:53:51<2:24:19, 15.49s/it][Succeeded / Failed / Skipped / Total] 305 / 108 / 28 / 441:  44%|████▍     | 442/1000 [1:56:10<2:26:39, 15.77s/it][Succeeded / Failed / Skipped / Total] 305 / 109 / 28 / 442:  44%|████▍     | 442/1000 [1:56:10<2:26:39, 15.77s/it][Succeeded / Failed / Skipped / Total] 305 / 109 / 28 / 442:  44%|████▍     | 443/1000 [1:56:38<2:26:40, 15.80s/it][Succeeded / Failed / Skipped / Total] 306 / 109 / 28 / 443:  44%|████▍     | 443/1000 [1:56:38<2:26:40, 15.80s/it][Succeeded / Failed / Skipped / Total] 306 / 109 / 28 / 443:  44%|████▍     | 444/1000 [1:56:43<2:26:09, 15.77s/it]Logs a log message . --> [[[FAILED]]]

[[[[Adv]]]]: public static void printConnectionTraceLog ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log

[[[[Adv]]]]: public static void printConnectionTraceLog ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log
--------------------------------------------- Result 438 ---------------------------------------------
Starts a new threads . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static EventLoopGroup [[newEventLoopGroup]] ( int [[nThreads]] , ThreadFactory [[threadFactory]] ) { return epollEnabled ? new EpollEventLoopGroup ( [[nThreads]] , [[threadFactory]] ) : new NioEventLoopGroup ( [[nThreads]] , [[threadFactory]] ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .

[[[[Adv]]]]: public static EventLoopGroup [[invalid]] ( int [[sheltered]] , ThreadFactory [[ghettos]] ) { return epollEnabled ? new EpollEventLoopGroup ( [[sheltered]] , [[ghettos]] ) : new NioEventLoopGroup ( [[sheltered]] , [[ghettos]] ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .
--------------------------------------------- Result 439 ---------------------------------------------
Register default processor . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerDefaultProcessor ( RemotingProcessor < ? > processor ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void registerDefaultProcessor ( RemotingProcessor < ? > processor ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 440 ---------------------------------------------
Parses a remote address . --> Convert a string to a string --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteAddress]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress [[remote]] = [[channel]] . remoteAddress ( ) ; return doParse ( [[remote]] != null ? [[remote]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .

[[[[Adv]]]]: public static String [[neurons]] ( final Channel [[conduits]] ) { if ( null == [[conduits]] ) { return StringUtils . EMPTY ; } final SocketAddress [[fringe]] = [[conduits]] . remoteAddress ( ) ; return doParse ( [[fringe]] != null ? [[fringe]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .
--------------------------------------------- Result 441 ---------------------------------------------
Converts a String to a String . --> Convert a String to a String --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalAddress]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress [[local]] = channel . localAddress ( ) ; return doParse ( [[local]] != null ? [[local]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .

[[[[Adv]]]]: public static String [[pocketknife]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress [[facilities]] = channel . localAddress ( ) ; return doParse ( [[facilities]] != null ? [[facilities]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .
--------------------------------------------- Result 442 ---------------------------------------------
Closes this connection . --> [[[FAILED]]]

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .
--------------------------------------------- Result 443 ---------------------------------------------
Execute a command . --> Create a new transaction --> Socre: 1.0

[[[[Adv]]]]: protected RemotingCommand [[toRemotingCommand]] ( Object [[request]] , Connection conn , InvokeContext [[invokeContext]] , int [[timeoutMillis]] ) throws SerializationException { RpcRequestCommand [[command]] = this . getCommandFactory ( ) . createRequestCommand ( [[request]] ) ; if ( null != [[invokeContext]] ) {
[[[[Nl]]]]: Convert application request object to remoting request command .

[[[[Adv]]]]: protected RemotingCommand [[sheppard]] ( Object [[call]] , Connection conn , InvokeContext [[amityville]] , int [[busy]] ) throws SerializationException { RpcRequestCommand [[brigadier]] = this . getCommandFactory ( ) . createRequestCommand ( [[call]] ) ; if ( null != [[amityville]] ) {
[[[[Nl]]]]: Convert application request object to remoting request command .
[Succeeded / Failed / Skipped / Total] 307 / 109 / 28 / 444:  44%|████▍     | 444/1000 [1:56:43<2:26:09, 15.77s/it][Succeeded / Failed / Skipped / Total] 307 / 109 / 28 / 444:  44%|████▍     | 445/1000 [1:57:06<2:26:03, 15.79s/it][Succeeded / Failed / Skipped / Total] 308 / 109 / 28 / 445:  44%|████▍     | 445/1000 [1:57:06<2:26:03, 15.79s/it][Succeeded / Failed / Skipped / Total] 308 / 109 / 28 / 445:  45%|████▍     | 446/1000 [1:57:49<2:26:20, 15.85s/it][Succeeded / Failed / Skipped / Total] 309 / 109 / 28 / 446:  45%|████▍     | 446/1000 [1:57:49<2:26:20, 15.85s/it][Succeeded / Failed / Skipped / Total] 309 / 109 / 28 / 446:  45%|████▍     | 447/1000 [1:57:54<2:25:51, 15.83s/it][Succeeded / Failed / Skipped / Total] 310 / 109 / 28 / 447:  45%|████▍     | 447/1000 [1:57:54<2:25:51, 15.83s/it][Succeeded / Failed / Skipped / Total] 310 / 109 / 28 / 447:  45%|████▍     | 448/1000 [1:57:54<2:25:17, 15.79s/it][Succeeded / Failed / Skipped / Total] 311 / 109 / 28 / 448:  45%|████▍     | 448/1000 [1:57:54<2:25:17, 15.79s/it][Succeeded / Failed / Skipped / Total] 311 / 109 / 28 / 448:  45%|████▍     | 449/1000 [1:57:55<2:24:42, 15.76s/it][Succeeded / Failed / Skipped / Total] 311 / 109 / 29 / 449:  45%|████▍     | 449/1000 [1:57:55<2:24:42, 15.76s/it][Succeeded / Failed / Skipped / Total] 311 / 109 / 29 / 449:  45%|████▌     | 450/1000 [1:58:15<2:24:32, 15.77s/it][Succeeded / Failed / Skipped / Total] 311 / 110 / 29 / 450:  45%|████▌     | 450/1000 [1:58:15<2:24:32, 15.77s/it][Succeeded / Failed / Skipped / Total] 311 / 110 / 29 / 450:  45%|████▌     | 451/1000 [1:58:34<2:24:20, 15.77s/it][Succeeded / Failed / Skipped / Total] 312 / 110 / 29 / 451:  45%|████▌     | 451/1000 [1:58:34<2:24:20, 15.77s/it][Succeeded / Failed / Skipped / Total] 312 / 110 / 29 / 451:  45%|████▌     | 452/1000 [1:58:42<2:23:55, 15.76s/it]--------------------------------------------- Result 444 ---------------------------------------------
Returns the host name of the channel . --> Get IP address --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteHostName]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .

[[[[Adv]]]]: public static String [[gangstas]] ( final Channel [[conduit]] ) { if ( null == [[conduit]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[transmitter]] = ( InetSocketAddress ) [[conduit]] . remoteAddress ( ) ; if ( [[transmitter]] != null ) { return [[transmitter]] . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .
--------------------------------------------- Result 445 ---------------------------------------------
Handles the connection . --> Send a channel --> Socre: 1.0

[[[[Adv]]]]: protected void [[oneway]] ( final Connection [[conn]] , final RemotingCommand [[request]] ) { try { [[conn]] . getChannel ( ) . writeAndFlush ( [[request]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[f]] ) throws Exception { if ( ! [[f]] . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , [[f]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[conn]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .

[[[[Adv]]]]: protected void [[adder]] ( final Connection [[cows]] , final RemotingCommand [[wondering]] ) { try { [[cows]] . getChannel ( ) . writeAndFlush ( [[wondering]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[c]] ) throws Exception { if ( ! [[c]] . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[cows]] . getChannel ( ) ) , [[c]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[cows]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[cows]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .
--------------------------------------------- Result 446 ---------------------------------------------
Get the IPv4 address . --> Convert a string to a InetSocketAddress --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseSocketAddressToHostIp]] ( SocketAddress [[socketAddress]] ) { final InetSocketAddress [[addrs]] = ( InetSocketAddress ) [[socketAddress]] ; if ( [[addrs]] != null ) { InetAddress [[addr]] = [[addrs]] . getAddress ( ) ; if ( null != [[addr]] ) { return [[addr]] . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .

[[[[Adv]]]]: public static String [[eases]] ( SocketAddress [[ozawa]] ) { final InetSocketAddress [[inescapable]] = ( InetSocketAddress ) [[ozawa]] ; if ( [[inescapable]] != null ) { InetAddress [[englishman]] = [[inescapable]] . getAddress ( ) ; if ( null != [[englishman]] ) { return [[englishman]] . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .
--------------------------------------------- Result 447 ---------------------------------------------
Add a connection to this session . --> Resumes the rebalance . --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Connection [[connection]] ) { markAccess ( ) ; if ( null == [[connection]] ) { return ; } boolean res = this . [[conns]] . addIfAbsent ( [[connection]] ) ; if ( res ) { [[connection]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection

[[[[Adv]]]]: public void [[summing]] ( Connection [[relate]] ) { markAccess ( ) ; if ( null == [[relate]] ) { return ; } boolean res = this . [[visits]] . addIfAbsent ( [[relate]] ) ; if ( res ) { [[relate]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection
--------------------------------------------- Result 448 ---------------------------------------------
Remove connection . --> Removes the connections . --> Socre: 1.0

[[[[Adv]]]]: public void removeAndTryClose ( Connection [[connection]] ) { if ( null == [[connection]] ) { return ; } boolean res = this . [[conns]] . remove ( [[connection]] ) ; if ( res ) { [[connection]] . decreaseRef ( ) ; } if ( [[connection]] . noRef ( ) ) { [[connection]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection

[[[[Adv]]]]: public void removeAndTryClose ( Connection [[connections]] ) { if ( null == [[connections]] ) { return ; } boolean res = this . [[proclivities]] . remove ( [[connections]] ) ; if ( res ) { [[connections]] . decreaseRef ( ) ; } if ( [[connections]] . noRef ( ) ) { [[connections]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection
--------------------------------------------- Result 449 ---------------------------------------------
Gets the connections . --> [[[SKIPPED]]]

[[[[Adv]]]]: public Connection get ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection
--------------------------------------------- Result 450 ---------------------------------------------
Returns a IP address . --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseRemoteIP ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .

[[[[Adv]]]]: public static String parseRemoteIP ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .
--------------------------------------------- Result 451 ---------------------------------------------
Get a custom class . --> Gets a String from a String --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( String [[className]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[className]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .

[[[[Adv]]]]: public static CustomSerializer [[tsan]] ( String [[colonic]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[colonic]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .
--------------------------------------------- Result 452 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 313 / 110 / 29 / 452:  45%|████▌     | 452/1000 [1:58:42<2:23:55, 15.76s/it][Succeeded / Failed / Skipped / Total] 313 / 110 / 29 / 452:  45%|████▌     | 453/1000 [1:58:53<2:23:33, 15.75s/it][Succeeded / Failed / Skipped / Total] 313 / 111 / 29 / 453:  45%|████▌     | 453/1000 [1:58:53<2:23:33, 15.75s/it][Succeeded / Failed / Skipped / Total] 313 / 111 / 29 / 453:  45%|████▌     | 454/1000 [1:58:59<2:23:05, 15.72s/it][Succeeded / Failed / Skipped / Total] 313 / 112 / 29 / 454:  45%|████▌     | 454/1000 [1:58:59<2:23:05, 15.72s/it][Succeeded / Failed / Skipped / Total] 313 / 112 / 29 / 454:  46%|████▌     | 455/1000 [1:58:59<2:22:31, 15.69s/it][Succeeded / Failed / Skipped / Total] 313 / 112 / 30 / 455:  46%|████▌     | 455/1000 [1:58:59<2:22:31, 15.69s/it][Succeeded / Failed / Skipped / Total] 313 / 112 / 30 / 455:  46%|████▌     | 456/1000 [1:58:59<2:21:57, 15.66s/it][Succeeded / Failed / Skipped / Total] 313 / 112 / 31 / 456:  46%|████▌     | 456/1000 [1:58:59<2:21:57, 15.66s/it][Succeeded / Failed / Skipped / Total] 313 / 112 / 31 / 456:  46%|████▌     | 457/1000 [1:58:59<2:21:23, 15.62s/it][Succeeded / Failed / Skipped / Total] 314 / 112 / 31 / 457:  46%|████▌     | 457/1000 [1:58:59<2:21:23, 15.62s/it][Succeeded / Failed / Skipped / Total] 314 / 112 / 31 / 457:  46%|████▌     | 458/1000 [1:59:00<2:20:49, 15.59s/it][Succeeded / Failed / Skipped / Total] 314 / 112 / 32 / 458:  46%|████▌     | 458/1000 [1:59:00<2:20:49, 15.59s/it][Succeeded / Failed / Skipped / Total] 314 / 112 / 32 / 458:  46%|████▌     | 459/1000 [1:59:03<2:20:20, 15.56s/it][Succeeded / Failed / Skipped / Total] 315 / 112 / 32 / 459:  46%|████▌     | 459/1000 [1:59:03<2:20:20, 15.56s/it][Succeeded / Failed / Skipped / Total] 315 / 112 / 32 / 459:  46%|████▌     | 460/1000 [1:59:05<2:19:47, 15.53s/it][Succeeded / Failed / Skipped / Total] 316 / 112 / 32 / 460:  46%|████▌     | 460/1000 [1:59:05<2:19:47, 15.53s/it][Succeeded / Failed / Skipped / Total] 316 / 112 / 32 / 460:  46%|████▌     | 461/1000 [1:59:06<2:19:16, 15.50s/it]Registers a custom command . --> Unregisters a registerr --> Socre: 1.0

[[[[Adv]]]]: public static void registerCustomSerializer ( CommandCode [[code]] , CustomSerializer serializer ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( [[code]] , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[code]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .

[[[[Adv]]]]: public static void registerCustomSerializer ( CommandCode [[scrambles]] , CustomSerializer serializer ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( [[scrambles]] , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[scrambles]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .
--------------------------------------------- Result 453 ---------------------------------------------
Create a server . --> [[[FAILED]]]

[[[[Adv]]]]: private RpcServerException createServerException ( Throwable t , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .

[[[[Adv]]]]: private RpcServerException createServerException ( Throwable t , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .
--------------------------------------------- Result 454 ---------------------------------------------
Start the monitor . --> [[[FAILED]]]

[[[[Adv]]]]: public void start ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task

[[[[Adv]]]]: public void start ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task
--------------------------------------------- Result 455 ---------------------------------------------
Replies if the given url exists . --> [[[SKIPPED]]]

[[[[Adv]]]]: public boolean isConnected ( String remoteAddr ) { Url url = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected
--------------------------------------------- Result 456 ---------------------------------------------
Sets the watermark watermark . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void initWriteBufferWaterMark ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark
--------------------------------------------- Result 457 ---------------------------------------------
Execute a response . --> get the submit code --> Socre: 1.0

[[[[Adv]]]]: private static Throwable [[toThrowable]] ( ResponseCommand [[responseCommand]] ) throws CodecException { RpcResponseCommand [[resp]] = ( RpcResponseCommand ) [[responseCommand]] ; [[resp]] . deserialize ( ) ; Object [[ex]] = [[resp]] . getResponseObject ( ) ; if ( [[ex]] != null && [[ex]] instanceof Throwable ) { return ( Throwable ) [[ex]] ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .

[[[[Adv]]]]: private static Throwable [[bodegas]] ( ResponseCommand [[stumps]] ) throws CodecException { RpcResponseCommand [[hewlitt]] = ( RpcResponseCommand ) [[stumps]] ; [[hewlitt]] . deserialize ( ) ; Object [[lately]] = [[hewlitt]] . getResponseObject ( ) ; if ( [[lately]] != null && [[lately]] instanceof Throwable ) { return ( Throwable ) [[lately]] ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .
--------------------------------------------- Result 458 ---------------------------------------------
Allocate a channel . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed
--------------------------------------------- Result 459 ---------------------------------------------
Sets the code . --> Encode a string . --> Socre: 1.0

[[[[Adv]]]]: public void [[setCode]] ( int [[code]] ) { this . code = [[code]] ;
[[[[Nl]]]]: Set the close code for this close frame

[[[[Adv]]]]: public void [[cruel]] ( int [[encode]] ) { this . code = [[encode]] ;
[[[[Nl]]]]: Set the close code for this close frame
--------------------------------------------- Result 460 ---------------------------------------------
Validate a string . --> Loads data from a byte array . --> Socre: 1.0

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer [[payload]] , int mark ) throws InvalidDataException { try { [[payload]] . position ( [[payload]] . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( [[payload]] ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { [[payload]] . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer [[truckload]] , int mark ) throws InvalidDataException { try { [[truckload]] . position ( [[truckload]] . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( [[truckload]] ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { [[truckload]] . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8
--------------------------------------------- Result 461 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 317 / 112 / 32 / 461:  46%|████▌     | 461/1000 [1:59:07<2:19:16, 15.50s/it][Succeeded / Failed / Skipped / Total] 317 / 112 / 32 / 461:  46%|████▌     | 462/1000 [1:59:20<2:18:58, 15.50s/it][Succeeded / Failed / Skipped / Total] 318 / 112 / 32 / 462:  46%|████▌     | 462/1000 [1:59:20<2:18:58, 15.50s/it][Succeeded / Failed / Skipped / Total] 318 / 112 / 32 / 462:  46%|████▋     | 463/1000 [1:59:21<2:18:25, 15.47s/it][Succeeded / Failed / Skipped / Total] 318 / 112 / 33 / 463:  46%|████▋     | 463/1000 [1:59:21<2:18:25, 15.47s/it][Succeeded / Failed / Skipped / Total] 318 / 112 / 33 / 463:  46%|████▋     | 464/1000 [1:59:24<2:17:56, 15.44s/it][Succeeded / Failed / Skipped / Total] 319 / 112 / 33 / 464:  46%|████▋     | 464/1000 [1:59:24<2:17:56, 15.44s/it][Succeeded / Failed / Skipped / Total] 319 / 112 / 33 / 464:  46%|████▋     | 465/1000 [1:59:36<2:17:36, 15.43s/it][Succeeded / Failed / Skipped / Total] 320 / 112 / 33 / 465:  46%|████▋     | 465/1000 [1:59:36<2:17:36, 15.43s/it][Succeeded / Failed / Skipped / Total] 320 / 112 / 33 / 465:  47%|████▋     | 466/1000 [1:59:46<2:17:15, 15.42s/it][Succeeded / Failed / Skipped / Total] 321 / 112 / 33 / 466:  47%|████▋     | 466/1000 [1:59:46<2:17:15, 15.42s/it][Succeeded / Failed / Skipped / Total] 321 / 112 / 33 / 466:  47%|████▋     | 467/1000 [1:59:46<2:16:42, 15.39s/it][Succeeded / Failed / Skipped / Total] 321 / 112 / 34 / 467:  47%|████▋     | 467/1000 [1:59:46<2:16:42, 15.39s/it][Succeeded / Failed / Skipped / Total] 321 / 112 / 34 / 467:  47%|████▋     | 468/1000 [1:59:47<2:16:09, 15.36s/it][Succeeded / Failed / Skipped / Total] 321 / 112 / 35 / 468:  47%|████▋     | 468/1000 [1:59:47<2:16:09, 15.36s/it][Succeeded / Failed / Skipped / Total] 321 / 112 / 35 / 468:  47%|████▋     | 469/1000 [1:59:47<2:15:37, 15.32s/it][Succeeded / Failed / Skipped / Total] 321 / 112 / 36 / 469:  47%|████▋     | 469/1000 [1:59:47<2:15:37, 15.32s/it][Succeeded / Failed / Skipped / Total] 321 / 112 / 36 / 469:  47%|████▋     | 470/1000 [1:59:53<2:15:11, 15.30s/it]Adds a byte buffer to the given buffer . --> Allocates a byte array . --> Socre: 1.0

[[[[Adv]]]]: private void [[updatePayload]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer [[pay]] = ByteBuffer . allocate ( 2 + by . length ) ; [[pay]] . put ( buf ) ; [[pay]] . put ( by ) ; [[pay]] . rewind ( ) ; super . setPayload ( [[pay]] ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason

[[[[Adv]]]]: private void [[fauna]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer [[salaried]] = ByteBuffer . allocate ( 2 + by . length ) ; [[salaried]] . put ( buf ) ; [[salaried]] . put ( by ) ; [[salaried]] . rewind ( ) ; super . setPayload ( [[salaried]] ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason
--------------------------------------------- Result 462 ---------------------------------------------
Get the protocol . --> Returns a Handsandter . --> Socre: 1.0

[[[[Adv]]]]: private HandshakeState [[containsRequestedProtocol]] ( String [[requestedProtocol]] ) { for ( IProtocol [[knownProtocol]] : knownProtocols ) { if ( [[knownProtocol]] . acceptProvidedProtocol ( [[requestedProtocol]] ) ) { protocol = [[knownProtocol]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft

[[[[Adv]]]]: private HandshakeState [[shouted]] ( String [[rems]] ) { for ( IProtocol [[softener]] : knownProtocols ) { if ( [[softener]] . acceptProvidedProtocol ( [[rems]] ) ) { protocol = [[softener]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft
--------------------------------------------- Result 463 ---------------------------------------------
Verifies that a byte array is valid . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void translateSingleFrameCheckLengthLimit ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit
--------------------------------------------- Result 464 ---------------------------------------------
Overwrites packet . --> Send a rate . --> Socre: 1.0

[[[[Adv]]]]: private void translateSingleFrameCheckPacketSize ( int [[maxpacketsize]] , int [[realpacketsize]] ) throws IncompleteException { if ( [[maxpacketsize]] < [[realpacketsize]] ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( [[realpacketsize]] ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size

[[[[Adv]]]]: private void translateSingleFrameCheckPacketSize ( int [[butan]] , int [[hayabusa]] ) throws IncompleteException { if ( [[butan]] < [[hayabusa]] ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( [[hayabusa]] ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size
--------------------------------------------- Result 465 ---------------------------------------------
Generates a string representation of a string . --> Returns the cipher for the given cipher --> Socre: 1.0

[[[[Adv]]]]: private String [[generateFinalKey]] ( String [[in]] ) { String seckey = [[in]] . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest [[sh1]] ; try { [[sh1]] = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( [[sh1]] . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string

[[[[Adv]]]]: private String [[zona]] ( String [[toward]] ) { String seckey = [[toward]] . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest [[publishes]] ; try { [[publishes]] = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( [[publishes]] . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string
--------------------------------------------- Result 466 ---------------------------------------------
Process a single frame . --> Does nothing . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameContinuousAndNonFin]] ( WebSocketImpl [[webSocketImpl]] , Framedata [[frame]] , Opcode [[curop]] ) throws InvalidDataException { if ( [[curop]] != Opcode . CONTINUOUS ) { processFrameIsNotFin ( [[frame]] ) ; } else if ( [[frame]] . isFin ( ) ) { processFrameIsFin ( [[webSocketImpl]] , [[frame]] ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set

[[[[Adv]]]]: private void [[desktop]] ( WebSocketImpl [[nationale]] , Framedata [[framework]] , Opcode [[discriminating]] ) throws InvalidDataException { if ( [[discriminating]] != Opcode . CONTINUOUS ) { processFrameIsNotFin ( [[framework]] ) ; } else if ( [[framework]] . isFin ( ) ) { processFrameIsFin ( [[nationale]] , [[framework]] ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set
--------------------------------------------- Result 467 ---------------------------------------------
Sends web socket . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void processFrameBinary ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame
--------------------------------------------- Result 468 ---------------------------------------------
Handles WebSocket event . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void logRuntimeException ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl
--------------------------------------------- Result 469 ---------------------------------------------
Processes web socket . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void processFrameText ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame
--------------------------------------------- Result 470 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 322 / 112 / 36 / 470:  47%|████▋     | 470/1000 [1:59:53<2:15:11, 15.30s/it][Succeeded / Failed / Skipped / Total] 322 / 112 / 36 / 470:  47%|████▋     | 471/1000 [1:59:55<2:14:41, 15.28s/it][Succeeded / Failed / Skipped / Total] 323 / 112 / 36 / 471:  47%|████▋     | 471/1000 [1:59:55<2:14:41, 15.28s/it][Succeeded / Failed / Skipped / Total] 323 / 112 / 36 / 471:  47%|████▋     | 472/1000 [1:59:55<2:14:09, 15.24s/it][Succeeded / Failed / Skipped / Total] 324 / 112 / 36 / 472:  47%|████▋     | 472/1000 [1:59:55<2:14:09, 15.24s/it][Succeeded / Failed / Skipped / Total] 324 / 112 / 36 / 472:  47%|████▋     | 473/1000 [1:59:57<2:13:38, 15.22s/it][Succeeded / Failed / Skipped / Total] 325 / 112 / 36 / 473:  47%|████▋     | 473/1000 [1:59:57<2:13:38, 15.22s/it][Succeeded / Failed / Skipped / Total] 325 / 112 / 36 / 473:  47%|████▋     | 474/1000 [1:59:58<2:13:07, 15.19s/it][Succeeded / Failed / Skipped / Total] 326 / 112 / 36 / 474:  47%|████▋     | 474/1000 [1:59:58<2:13:07, 15.19s/it][Succeeded / Failed / Skipped / Total] 326 / 112 / 36 / 474:  48%|████▊     | 475/1000 [1:59:59<2:12:37, 15.16s/it]Register a custom serializer . --> Unregisters all registered registered serializers --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( String [[className]] , CustomSerializer [[serializer]] ) { CustomSerializer [[prevSerializer]] = classCustomSerializer . putIfAbsent ( [[className]] , [[serializer]] ) ; if ( [[prevSerializer]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[className]] + ", the custom serializer is: " + [[prevSerializer]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .

[[[[Adv]]]]: public static void [[undersecretary]] ( String [[rossini]] , CustomSerializer [[mocked]] ) { CustomSerializer [[lucetta]] = classCustomSerializer . putIfAbsent ( [[rossini]] , [[mocked]] ) ; if ( [[lucetta]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[rossini]] + ", the custom serializer is: " + [[lucetta]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .
--------------------------------------------- Result 471 ---------------------------------------------
Read data from a single frame . --> Send a sequence of data . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsNotFin]] ( Framedata [[frame]] ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = [[frame]] ; addToBufferList ( [[frame]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame

[[[[Adv]]]]: private void [[charm]] ( Framedata [[cadre]] ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = [[cadre]] ; addToBufferList ( [[cadre]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame
--------------------------------------------- Result 472 ---------------------------------------------
Reads the data from the given frame . --> Populates a data buffer . --> Socre: 1.0

[[[[Adv]]]]: private void processFrameIsFin ( WebSocketImpl [[webSocketImpl]] , Framedata [[frame]] ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( [[frame]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame

[[[[Adv]]]]: private void processFrameIsFin ( WebSocketImpl [[barnyard]] , Framedata [[articulation]] ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( [[articulation]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[barnyard]] . getWebSocketListener ( ) . onWebsocketMessage ( [[barnyard]] , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[barnyard]] , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[barnyard]] . getWebSocketListener ( ) . onWebsocketMessage ( [[barnyard]] , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[barnyard]] , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame
--------------------------------------------- Result 473 ---------------------------------------------
Allocate a new Frame . --> Allocates a new limit . --> Socre: 1.0

[[[[Adv]]]]: private void checkBufferLimit ( ) throws LimitExceededException { long [[totalSize]] = getByteBufferListSize ( ) ; if ( [[totalSize]] > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[totalSize]] ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size

[[[[Adv]]]]: private void checkBufferLimit ( ) throws LimitExceededException { long [[bottom]] = getByteBufferListSize ( ) ; if ( [[bottom]] > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[bottom]] ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size
--------------------------------------------- Result 474 ---------------------------------------------
Returns a ByteBuffer . --> Returns an unmodifiable byte buffer . --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer [[resultingByteBuffer]] ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; [[resultingByteBuffer]] = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { [[resultingByteBuffer]] . put ( buffer ) ; } } [[resultingByteBuffer]] . flip ( ) ; return [[resultingByteBuffer]] ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload

[[[[Adv]]]]: private ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer [[orthe]] ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; [[orthe]] = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { [[orthe]] . put ( buffer ) ; } } [[orthe]] . flip ( ) ; return [[orthe]] ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload
--------------------------------------------- Result 475 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 327 / 112 / 36 / 475:  48%|████▊     | 475/1000 [1:59:59<2:12:37, 15.16s/it][Succeeded / Failed / Skipped / Total] 327 / 112 / 36 / 475:  48%|████▊     | 476/1000 [2:00:00<2:12:06, 15.13s/it][Succeeded / Failed / Skipped / Total] 327 / 112 / 37 / 476:  48%|████▊     | 476/1000 [2:00:00<2:12:06, 15.13s/it][Succeeded / Failed / Skipped / Total] 327 / 112 / 37 / 476:  48%|████▊     | 477/1000 [2:00:01<2:11:35, 15.10s/it][Succeeded / Failed / Skipped / Total] 327 / 112 / 38 / 477:  48%|████▊     | 477/1000 [2:00:01<2:11:35, 15.10s/it][Succeeded / Failed / Skipped / Total] 327 / 112 / 38 / 477:  48%|████▊     | 478/1000 [2:00:01<2:11:04, 15.07s/it][Succeeded / Failed / Skipped / Total] 327 / 112 / 39 / 478:  48%|████▊     | 478/1000 [2:00:01<2:11:04, 15.07s/it][Succeeded / Failed / Skipped / Total] 327 / 112 / 39 / 478:  48%|████▊     | 479/1000 [2:00:02<2:10:34, 15.04s/it][Succeeded / Failed / Skipped / Total] 328 / 112 / 39 / 479:  48%|████▊     | 479/1000 [2:00:02<2:10:34, 15.04s/it][Succeeded / Failed / Skipped / Total] 328 / 112 / 39 / 479:  48%|████▊     | 480/1000 [2:00:05<2:10:05, 15.01s/it][Succeeded / Failed / Skipped / Total] 329 / 112 / 39 / 480:  48%|████▊     | 480/1000 [2:00:05<2:10:05, 15.01s/it][Succeeded / Failed / Skipped / Total] 329 / 112 / 39 / 480:  48%|████▊     | 481/1000 [2:00:14<2:09:44, 15.00s/it][Succeeded / Failed / Skipped / Total] 330 / 112 / 39 / 481:  48%|████▊     | 481/1000 [2:00:14<2:09:44, 15.00s/it][Succeeded / Failed / Skipped / Total] 330 / 112 / 39 / 481:  48%|████▊     | 482/1000 [2:00:35<2:09:36, 15.01s/it][Succeeded / Failed / Skipped / Total] 330 / 113 / 39 / 482:  48%|████▊     | 482/1000 [2:00:35<2:09:36, 15.01s/it][Succeeded / Failed / Skipped / Total] 330 / 113 / 39 / 482:  48%|████▊     | 483/1000 [2:00:35<2:09:05, 14.98s/it][Succeeded / Failed / Skipped / Total] 330 / 113 / 40 / 483:  48%|████▊     | 483/1000 [2:00:35<2:09:05, 14.98s/it][Succeeded / Failed / Skipped / Total] 330 / 113 / 40 / 483:  48%|████▊     | 484/1000 [2:00:39<2:08:37, 14.96s/it]Returns the total size of the buffer . --> Converts a byte to a byte array --> Socre: 1.0

[[[[Adv]]]]: private long [[getByteBufferListSize]] ( ) { long [[totalSize]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[totalSize]] += buffer . limit ( ) ; } } return [[totalSize]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list

[[[[Adv]]]]: private long [[typos]] ( ) { long [[hansel]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[hansel]] += buffer . limit ( ) ; } } return [[hansel]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list
--------------------------------------------- Result 476 ---------------------------------------------
Constructs a Handshak2 line from a given Handwidth . --> [[[SKIPPED]]]

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpServer ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server
--------------------------------------------- Result 477 ---------------------------------------------
Splits a string to a Handwidth . --> [[[SKIPPED]]]

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpClient ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client
--------------------------------------------- Result 478 ---------------------------------------------
Handles a socket . --> [[[SKIPPED]]]

[[[[Adv]]]]: public void decode ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer
--------------------------------------------- Result 479 ---------------------------------------------
Flushes the response . --> Generates a error response . --> Socre: 1.0

[[[[Adv]]]]: private void closeConnectionDueToWrongHandshake ( InvalidDataException [[exception]] ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( [[exception]] . getCloseCode ( ) , [[exception]] . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct

[[[[Adv]]]]: private void closeConnectionDueToWrongHandshake ( InvalidDataException [[exemptions]] ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( [[exemptions]] . getCloseCode ( ) , [[exemptions]] . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct
--------------------------------------------- Result 480 ---------------------------------------------
Writes the connection to the server . --> Generates an exception . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToInternalServerError]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException

[[[[Adv]]]]: private void [[climbed]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "[[Falsified]]" != "[[Falsified]]" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException
--------------------------------------------- Result 481 ---------------------------------------------
Generate an error message . --> Build an HTML head . --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[generateHttpResponseDueToError]] ( int [[errorCode]] ) { String errorCodeDescription ; switch ( [[errorCode]] ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error

[[[[Adv]]]]: private ByteBuffer [[president]] ( int [[humerus]] ) { String errorCodeDescription ; switch ( [[humerus]] ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error
--------------------------------------------- Result 482 ---------------------------------------------
Returns a IP address . --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseLocalIP ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .

[[[[Adv]]]]: public static String parseLocalIP ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .
--------------------------------------------- Result 483 ---------------------------------------------
Initialize the socket . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect
--------------------------------------------- Result 484 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 331 / 113 / 40 / 484:  48%|████▊     | 484/1000 [2:00:39<2:08:37, 14.96s/it][Succeeded / Failed / Skipped / Total] 331 / 113 / 40 / 484:  48%|████▊     | 485/1000 [2:00:41<2:08:09, 14.93s/it][Succeeded / Failed / Skipped / Total] 332 / 113 / 40 / 485:  48%|████▊     | 485/1000 [2:00:41<2:08:09, 14.93s/it][Succeeded / Failed / Skipped / Total] 332 / 113 / 40 / 485:  49%|████▊     | 486/1000 [2:00:43<2:07:41, 14.91s/it][Succeeded / Failed / Skipped / Total] 333 / 113 / 40 / 486:  49%|████▊     | 486/1000 [2:00:43<2:07:41, 14.91s/it][Succeeded / Failed / Skipped / Total] 333 / 113 / 40 / 486:  49%|████▊     | 487/1000 [2:00:49<2:07:16, 14.89s/it][Succeeded / Failed / Skipped / Total] 334 / 113 / 40 / 487:  49%|████▊     | 487/1000 [2:00:49<2:07:16, 14.89s/it][Succeeded / Failed / Skipped / Total] 334 / 113 / 40 / 487:  49%|████▉     | 488/1000 [2:00:52<2:06:49, 14.86s/it][Succeeded / Failed / Skipped / Total] 335 / 113 / 40 / 488:  49%|████▉     | 488/1000 [2:00:52<2:06:49, 14.86s/it][Succeeded / Failed / Skipped / Total] 335 / 113 / 40 / 488:  49%|████▉     | 489/1000 [2:00:53<2:06:20, 14.83s/it][Succeeded / Failed / Skipped / Total] 335 / 114 / 40 / 489:  49%|████▉     | 489/1000 [2:00:53<2:06:20, 14.83s/it][Succeeded / Failed / Skipped / Total] 335 / 114 / 40 / 489:  49%|████▉     | 490/1000 [2:00:55<2:05:51, 14.81s/it]Returns a opcode . --> Returns the Framecode . --> Socre: 1.0

[[[[Adv]]]]: public static FramedataImpl1 get ( Opcode [[opcode]] ) { if ( [[opcode]] == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( [[opcode]] ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode

[[[[Adv]]]]: public static FramedataImpl1 get ( Opcode [[phantasm]] ) { if ( [[phantasm]] == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( [[phantasm]] ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode
--------------------------------------------- Result 485 ---------------------------------------------
Get the scheme . --> Get a portion of a string --> Socre: 1.0

[[[[Adv]]]]: private int getPort ( ) { int [[port]] = uri . getPort ( ) ; if ( [[port]] == - 1 ) { String [[scheme]] = uri . getScheme ( ) ; if ( "wss" . equals ( [[scheme]] ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( [[scheme]] ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + [[scheme]] ) ; } } return [[port]] ; }
[[[[Nl]]]]: Extract the specified port

[[[[Adv]]]]: private int getPort ( ) { int [[rica]] = uri . getPort ( ) ; if ( [[rica]] == - 1 ) { String [[arrangement]] = uri . getScheme ( ) ; if ( "wss" . equals ( [[arrangement]] ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( [[arrangement]] ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + [[arrangement]] ) ; } } return [[rica]] ; }
[[[[Nl]]]]: Extract the specified port
--------------------------------------------- Result 486 ---------------------------------------------
Send a request to the client . --> Sends a Hadoophy . --> Socre: 1.0

[[[[Adv]]]]: private void sendHandshake ( ) throws InvalidHandshakeException { String [[path]] ; String [[part1]] = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( [[part1]] == null || [[part1]] . length ( ) == 0 ) [[path]] = "/" ; else [[path]] = [[part1]] ; if ( part2 != null ) [[path]] += ' ' + part2 ; int [[port]] = getPort ( ) ; String host = uri . getHost ( ) + ( ( [[port]] != WebSocketImpl . DEFAULT_PORT && [[port]] != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + [[port]] : "" ) ; HandshakeImpl1Client [[handshake]] = new HandshakeImpl1Client ( ) ; [[handshake]] . setResourceDescriptor ( [[path]] ) ; [[handshake]] . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > [[kv]] : headers . entrySet ( ) ) { [[handshake]] . put ( [[kv]] . getKey ( ) , [[kv]] . getValue ( ) ) ; } } engine . startHandshake ( [[handshake]] ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint

[[[[Adv]]]]: private void sendHandshake ( ) throws InvalidHandshakeException { String [[paths]] ; String [[overcharging]] = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( [[overcharging]] == null || [[overcharging]] . length ( ) == 0 ) [[paths]] = "/" ; else [[paths]] = [[overcharging]] ; if ( part2 != null ) [[paths]] += ' ' + part2 ; int [[rica]] = getPort ( ) ; String host = uri . getHost ( ) + ( ( [[rica]] != WebSocketImpl . DEFAULT_PORT && [[rica]] != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + [[rica]] : "" ) ; HandshakeImpl1Client [[pleasantries]] = new HandshakeImpl1Client ( ) ; [[pleasantries]] . setResourceDescriptor ( [[paths]] ) ; [[pleasantries]] . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > [[padme]] : headers . entrySet ( ) ) { [[pleasantries]] . put ( [[padme]] . getKey ( ) , [[padme]] . getValue ( ) ) ; } } engine . startHandshake ( [[pleasantries]] ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint
--------------------------------------------- Result 487 ---------------------------------------------
Sets the connection . --> Shut down this operation . --> Socre: 1.0

[[[[Adv]]]]: public void [[setConnectionLostTimeout]] ( int [[connectionLostTimeout]] ) { synchronized ( syncConnectionLost ) { this . [[connectionLostTimeout]] = TimeUnit . SECONDS . toNanos ( [[connectionLostTimeout]] ) ; if ( this . [[connectionLostTimeout]] <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . [[websocketRunning]] ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated

[[[[Adv]]]]: public void [[pierino]] ( int [[joely]] ) { synchronized ( syncConnectionLost ) { this . [[grift]] = TimeUnit . SECONDS . toNanos ( [[joely]] ) ; if ( this . [[grift]] <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . [[benefitted]] ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated
--------------------------------------------- Result 488 ---------------------------------------------
Stops the connection . --> Revoke all connections . --> Socre: 1.0

[[[[Adv]]]]: protected void [[stopConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . [[websocketRunning]] = "[[False]]" != "[[False]]" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer

[[[[Adv]]]]: protected void [[directors]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . [[agonised]] = "[[Falsify]]" != "[[Falsify]]" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer
--------------------------------------------- Result 489 ---------------------------------------------
Starts a new thread . --> [[[FAILED]]]

[[[[Adv]]]]: public void connect ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .

[[[[Adv]]]]: public void connect ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .
--------------------------------------------- Result 490 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 336 / 114 / 40 / 490:  49%|████▉     | 490/1000 [2:00:55<2:05:51, 14.81s/it][Succeeded / Failed / Skipped / Total] 336 / 114 / 40 / 490:  49%|████▉     | 491/1000 [2:00:57<2:05:23, 14.78s/it][Succeeded / Failed / Skipped / Total] 337 / 114 / 40 / 491:  49%|████▉     | 491/1000 [2:00:57<2:05:23, 14.78s/it][Succeeded / Failed / Skipped / Total] 337 / 114 / 40 / 491:  49%|████▉     | 492/1000 [2:00:58<2:04:54, 14.75s/it][Succeeded / Failed / Skipped / Total] 337 / 114 / 41 / 492:  49%|████▉     | 492/1000 [2:00:58<2:04:54, 14.75s/it][Succeeded / Failed / Skipped / Total] 337 / 114 / 41 / 492:  49%|████▉     | 493/1000 [2:01:15<2:04:42, 14.76s/it][Succeeded / Failed / Skipped / Total] 338 / 114 / 41 / 493:  49%|████▉     | 493/1000 [2:01:15<2:04:42, 14.76s/it][Succeeded / Failed / Skipped / Total] 338 / 114 / 41 / 493:  49%|████▉     | 494/1000 [2:01:21<2:04:18, 14.74s/it][Succeeded / Failed / Skipped / Total] 338 / 115 / 41 / 494:  49%|████▉     | 494/1000 [2:01:21<2:04:18, 14.74s/it][Succeeded / Failed / Skipped / Total] 338 / 115 / 41 / 494:  50%|████▉     | 495/1000 [2:01:23<2:03:50, 14.71s/it][Succeeded / Failed / Skipped / Total] 338 / 116 / 41 / 495:  50%|████▉     | 495/1000 [2:01:23<2:03:50, 14.71s/it][Succeeded / Failed / Skipped / Total] 338 / 116 / 41 / 495:  50%|████▉     | 496/1000 [2:01:28<2:03:26, 14.70s/it][Succeeded / Failed / Skipped / Total] 339 / 116 / 41 / 496:  50%|████▉     | 496/1000 [2:01:28<2:03:26, 14.70s/it][Succeeded / Failed / Skipped / Total] 339 / 116 / 41 / 496:  50%|████▉     | 497/1000 [2:01:29<2:02:57, 14.67s/it][Succeeded / Failed / Skipped / Total] 339 / 116 / 42 / 497:  50%|████▉     | 497/1000 [2:01:29<2:02:57, 14.67s/it][Succeeded / Failed / Skipped / Total] 339 / 116 / 42 / 497:  50%|████▉     | 498/1000 [2:01:30<2:02:28, 14.64s/it]Start the connection . --> Starts a new interval . --> Socre: 1.0

[[[[Adv]]]]: protected void [[startConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( this . [[connectionLostTimeout]] <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . [[websocketRunning]] = "[[True]]" == "[[True]]" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer

[[[[Adv]]]]: protected void [[bullied]] ( ) { synchronized ( syncConnectionLost ) { if ( this . [[supposing]] <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . [[jayne]] = "[[Vera]]" == "[[Vera]]" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer
--------------------------------------------- Result 491 ---------------------------------------------
Starts a connection . --> Connect to all connections . --> Socre: 1.0

[[[[Adv]]]]: private void restartConnectionLostTimer ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long [[minimumPongTime]] = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket [[conn]] : connections ) { executeConnectionLostDetection ( [[conn]] , [[minimumPongTime]] ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter

[[[[Adv]]]]: private void restartConnectionLostTimer ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long [[mwah]] = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket [[bulls]] : connections ) { executeConnectionLostDetection ( [[bulls]] , [[mwah]] ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter
--------------------------------------------- Result 492 ---------------------------------------------
Shuts down . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void cancelConnectionLostTimer ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "False" != "False" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection
--------------------------------------------- Result 493 ---------------------------------------------
Sends a text . --> Unregister a organamic --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[send]] ( String [[text]] ) { if ( [[text]] == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[send]] ( draft . createFrames ( [[text]] , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .

[[[[Adv]]]]: @ Override public void [[communicated]] ( String [[phrasing]] ) { if ( [[phrasing]] == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[communicated]] ( draft . createFrames ( [[phrasing]] , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .
--------------------------------------------- Result 494 ---------------------------------------------
Get the remote channel . --> [[[FAILED]]]

[[[[Adv]]]]: public static int parseRemotePort ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .

[[[[Adv]]]]: public static int parseRemotePort ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .
--------------------------------------------- Result 495 ---------------------------------------------
Gets the socket address . --> [[[FAILED]]]

[[[[Adv]]]]: public static int parseLocalPort ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .

[[[[Adv]]]]: public static int parseLocalPort ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .
--------------------------------------------- Result 496 ---------------------------------------------
Sends a Handwidth to the server . --> Send a Handwidth to a Handshake server --> Socre: 1.0

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[onWebsocketHandshakeReceivedAsServer]] ( WebSocket conn , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[poems]] ( WebSocket conn , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .
--------------------------------------------- Result 497 ---------------------------------------------
Adds a channel to the queue . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doAdditionalRead ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read
--------------------------------------------- Result 498 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 339 / 117 / 42 / 498:  50%|████▉     | 498/1000 [2:01:30<2:02:28, 14.64s/it][Succeeded / Failed / Skipped / Total] 339 / 117 / 42 / 498:  50%|████▉     | 499/1000 [2:01:32<2:02:01, 14.61s/it][Succeeded / Failed / Skipped / Total] 340 / 117 / 42 / 499:  50%|████▉     | 499/1000 [2:01:32<2:02:01, 14.61s/it][Succeeded / Failed / Skipped / Total] 340 / 117 / 42 / 499:  50%|█████     | 500/1000 [2:01:33<2:01:33, 14.59s/it][Succeeded / Failed / Skipped / Total] 341 / 117 / 42 / 500:  50%|█████     | 500/1000 [2:01:33<2:01:33, 14.59s/it][Succeeded / Failed / Skipped / Total] 341 / 117 / 42 / 500:  50%|█████     | 501/1000 [2:01:35<2:01:06, 14.56s/it][Succeeded / Failed / Skipped / Total] 342 / 117 / 42 / 501:  50%|█████     | 501/1000 [2:01:35<2:01:06, 14.56s/it][Succeeded / Failed / Skipped / Total] 342 / 117 / 42 / 501:  50%|█████     | 502/1000 [2:01:38<2:00:40, 14.54s/it][Succeeded / Failed / Skipped / Total] 343 / 117 / 42 / 502:  50%|█████     | 502/1000 [2:01:38<2:00:40, 14.54s/it][Succeeded / Failed / Skipped / Total] 343 / 117 / 42 / 502:  50%|█████     | 503/1000 [2:01:39<2:00:12, 14.51s/it]Open a key . --> [[[FAILED]]]

[[[[Adv]]]]: private void doAccept ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation

[[[[Adv]]]]: private void doAccept ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation
--------------------------------------------- Result 499 ---------------------------------------------
Handle a key . --> Executes the given key . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doRead]] ( SelectionKey key , Iterator < SelectionKey > [[i]] ) throws InterruptedException , IOException { WebSocketImpl [[conn]] = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( [[conn]] . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , [[conn]] , new IOException ( ) ) ; return "[[False]]" != "[[False]]" ; } try { if ( SocketChannelIOHelper . read ( buf , [[conn]] , [[conn]] . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { [[conn]] . inQueue . put ( buf ) ; queue ( [[conn]] ) ; [[i]] . remove ( ) ; if ( [[conn]] . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) [[conn]] . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( [[conn]] ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Execute a read operation

[[[[Adv]]]]: private boolean [[factor]] ( SelectionKey key , Iterator < SelectionKey > [[lee]] ) throws InterruptedException , IOException { WebSocketImpl [[middletown]] = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( [[middletown]] . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , [[middletown]] , new IOException ( ) ) ; return "[[Fakes]]" != "[[Fakes]]" ; } try { if ( SocketChannelIOHelper . read ( buf , [[middletown]] , [[middletown]] . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { [[middletown]] . inQueue . put ( buf ) ; queue ( [[middletown]] ) ; [[lee]] . remove ( ) ; if ( [[middletown]] . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) [[middletown]] . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( [[middletown]] ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "[[Meaningful]]" == "[[Meaningful]]" ; }
[[[[Nl]]]]: Execute a read operation
--------------------------------------------- Result 500 ---------------------------------------------
Checks if a key is enabled . --> Attempts to close the host . --> Socre: 1.0

[[[[Adv]]]]: private void doWrite ( SelectionKey [[key]] ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) [[key]] . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( [[key]] . isValid ( ) ) { [[key]] . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation

[[[[Adv]]]]: private void doWrite ( SelectionKey [[important]] ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) [[important]] . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( [[important]] . isValid ( ) ) { [[important]] . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation
--------------------------------------------- Result 501 ---------------------------------------------
Starts the server . --> Start a socket . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doSetupSelectorAndServerThread]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "[[False]]" != "[[False]]" ) ; ServerSocket [[socket]] = server . socket ( ) ; [[socket]] . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; [[socket]] . setReuseAddress ( isReuseAddr ( ) ) ; [[socket]] . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker [[ex]] : decoders ) { [[ex]] . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , [[ex]] ) ; return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings

[[[[Adv]]]]: private boolean [[fain]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "[[Fraudulent]]" != "[[Fraudulent]]" ) ; ServerSocket [[stopper]] = server . socket ( ) ; [[stopper]] . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; [[stopper]] . setReuseAddress ( isReuseAddr ( ) ) ; [[stopper]] . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker [[elder]] : decoders ) { [[elder]] . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , [[elder]] ) ; return "[[Fraudulent]]" != "[[Fraudulent]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings
--------------------------------------------- Result 502 ---------------------------------------------
Try to close a frame . --> Overridden to call this method . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameClosing]] ( WebSocketImpl [[webSocketImpl]] , Framedata [[frame]] ) { int [[code]] = CloseFrame . NOCODE ; String reason = "" ; if ( [[frame]] instanceof CloseFrame ) { CloseFrame [[cf]] = ( CloseFrame ) [[frame]] ; [[code]] = [[cf]] . getCloseCode ( ) ; reason = [[cf]] . getMessage ( ) ; } if ( [[webSocketImpl]] . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame

[[[[Adv]]]]: private void [[realization]] ( WebSocketImpl [[ochoa]] , Framedata [[edifice]] ) { int [[keying]] = CloseFrame . NOCODE ; String reason = "" ; if ( [[edifice]] instanceof CloseFrame ) { CloseFrame [[ll]] = ( CloseFrame ) [[edifice]] ; [[keying]] = [[ll]] . getCloseCode ( ) ; reason = [[ll]] . getMessage ( ) ; } if ( [[ochoa]] . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame
--------------------------------------------- Result 503 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 343 / 117 / 43 / 503:  50%|█████     | 503/1000 [2:01:39<2:00:12, 14.51s/it][Succeeded / Failed / Skipped / Total] 343 / 117 / 43 / 503:  50%|█████     | 504/1000 [2:01:40<1:59:44, 14.48s/it][Succeeded / Failed / Skipped / Total] 344 / 117 / 43 / 504:  50%|█████     | 504/1000 [2:01:40<1:59:44, 14.48s/it][Succeeded / Failed / Skipped / Total] 344 / 117 / 43 / 504:  50%|█████     | 505/1000 [2:01:40<1:59:15, 14.46s/it][Succeeded / Failed / Skipped / Total] 344 / 117 / 44 / 505:  50%|█████     | 505/1000 [2:01:40<1:59:15, 14.46s/it][Succeeded / Failed / Skipped / Total] 344 / 117 / 44 / 505:  51%|█████     | 506/1000 [2:01:44<1:58:51, 14.44s/it][Succeeded / Failed / Skipped / Total] 345 / 117 / 44 / 506:  51%|█████     | 506/1000 [2:01:44<1:58:51, 14.44s/it][Succeeded / Failed / Skipped / Total] 345 / 117 / 44 / 506:  51%|█████     | 507/1000 [2:01:47<1:58:25, 14.41s/it][Succeeded / Failed / Skipped / Total] 346 / 117 / 44 / 507:  51%|█████     | 507/1000 [2:01:47<1:58:25, 14.41s/it][Succeeded / Failed / Skipped / Total] 346 / 117 / 44 / 507:  51%|█████     | 508/1000 [2:01:50<1:58:00, 14.39s/it][Succeeded / Failed / Skipped / Total] 347 / 117 / 44 / 508:  51%|█████     | 508/1000 [2:01:50<1:58:00, 14.39s/it][Succeeded / Failed / Skipped / Total] 347 / 117 / 44 / 508:  51%|█████     | 509/1000 [2:01:52<1:57:33, 14.37s/it][Succeeded / Failed / Skipped / Total] 348 / 117 / 44 / 509:  51%|█████     | 509/1000 [2:01:52<1:57:33, 14.37s/it][Succeeded / Failed / Skipped / Total] 348 / 117 / 44 / 509:  51%|█████     | 510/1000 [2:02:06<1:57:18, 14.37s/it][Succeeded / Failed / Skipped / Total] 348 / 118 / 44 / 510:  51%|█████     | 510/1000 [2:02:06<1:57:18, 14.37s/it][Succeeded / Failed / Skipped / Total] 348 / 118 / 44 / 510:  51%|█████     | 511/1000 [2:02:09<1:56:53, 14.34s/it]Stop the server . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown
--------------------------------------------- Result 504 ---------------------------------------------
Returns the socket . --> Create a channel . --> Socre: 1.0

[[[[Adv]]]]: private Socket [[getSocket]] ( WebSocket [[conn]] ) { WebSocketImpl impl = ( WebSocketImpl ) [[conn]] ; return ( ( SocketChannel ) impl . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection

[[[[Adv]]]]: private Socket [[neves]] ( WebSocket [[oxen]] ) { WebSocketImpl impl = ( WebSocketImpl ) [[oxen]] ; return ( ( SocketChannel ) impl . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection
--------------------------------------------- Result 505 ---------------------------------------------
Wraps the given underlying stream . --> [[[SKIPPED]]]

[[[[Adv]]]]: public void broadcast ( byte [ ] data , Collection < WebSocket > clients ) { if ( data == null || clients == null ) { throw new IllegalArgumentException ( ) ; } broadcast ( ByteBuffer . wrap ( data ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections
--------------------------------------------- Result 506 ---------------------------------------------
Send a broadcast broadcast --> Set edit edits . --> Socre: 1.0

[[[[Adv]]]]: public void broadcast ( String [[text]] , Collection < WebSocket > clients ) { if ( [[text]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[text]] , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections

[[[[Adv]]]]: public void broadcast ( String [[editions]] , Collection < WebSocket > clients ) { if ( [[editions]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[editions]] , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections
--------------------------------------------- Result 507 ---------------------------------------------
Send a data to the server --> Sends a HTTP client . --> Socre: 1.0

[[[[Adv]]]]: private void doBroadcast ( Object data , Collection < WebSocket > clients ) { String [[sData]] = null ; if ( data instanceof String ) { [[sData]] = ( String ) data ; } ByteBuffer [[bData]] = null ; if ( data instanceof ByteBuffer ) { [[bData]] = ( ByteBuffer ) data ; } if ( [[sData]] == null && [[bData]] == null ) { return ; } Map < Draft , List < Framedata > > [[draftFrames]] = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , [[draftFrames]] , [[sData]] , [[bData]] ) ; try { client . sendFrame ( [[draftFrames]] . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time

[[[[Adv]]]]: private void doBroadcast ( Object data , Collection < WebSocket > clients ) { String [[flank]] = null ; if ( data instanceof String ) { [[flank]] = ( String ) data ; } ByteBuffer [[limo]] = null ; if ( data instanceof ByteBuffer ) { [[limo]] = ( ByteBuffer ) data ; } if ( [[flank]] == null && [[limo]] == null ) { return ; } Map < Draft , List < Framedata > > [[platoon]] = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , [[platoon]] , [[flank]] , [[limo]] ) ; try { client . sendFrame ( [[platoon]] . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time
--------------------------------------------- Result 508 ---------------------------------------------
Gets the current thread . --> Returns true if this thread was closed . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doEnsureSingleThread]] ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "[[False]]" != "[[False]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once

[[[[Adv]]]]: private boolean [[excu]] ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "[[Fake]]" != "[[Fake]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once
--------------------------------------------- Result 509 ---------------------------------------------
Convert a byte array to a byte array . --> A convenience method for creating a new instance . --> Socre: 1.0

[[[[Adv]]]]: public static int [[transferByteBuffer]] ( ByteBuffer source , ByteBuffer [[dest]] ) { if ( source == null || [[dest]] == null ) { throw new IllegalArgumentException ( ) ; } int [[fremain]] = source . remaining ( ) ; int toremain = [[dest]] . remaining ( ) ; if ( [[fremain]] > toremain ) { int limit = Math . min ( [[fremain]] , toremain ) ; source . limit ( limit ) ; [[dest]] . put ( source ) ; return limit ; } else { [[dest]] . put ( source ) ; return [[fremain]] ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer

[[[[Adv]]]]: public static int [[anka]] ( ByteBuffer source , ByteBuffer [[tablespoon]] ) { if ( source == null || [[tablespoon]] == null ) { throw new IllegalArgumentException ( ) ; } int [[palmeiras]] = source . remaining ( ) ; int toremain = [[tablespoon]] . remaining ( ) ; if ( [[palmeiras]] > toremain ) { int limit = Math . min ( [[palmeiras]] , toremain ) ; source . limit ( limit ) ; [[tablespoon]] . put ( source ) ; return limit ; } else { [[tablespoon]] . put ( source ) ; return [[palmeiras]] ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer
--------------------------------------------- Result 510 ---------------------------------------------
Creates a new frame . --> [[[FAILED]]]

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast
--------------------------------------------- Result 511 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 348 / 119 / 44 / 511:  51%|█████     | 511/1000 [2:02:09<1:56:53, 14.34s/it][Succeeded / Failed / Skipped / Total] 348 / 119 / 44 / 511:  51%|█████     | 512/1000 [2:02:16<1:56:33, 14.33s/it][Succeeded / Failed / Skipped / Total] 349 / 119 / 44 / 512:  51%|█████     | 512/1000 [2:02:16<1:56:33, 14.33s/it][Succeeded / Failed / Skipped / Total] 349 / 119 / 44 / 512:  51%|█████▏    | 513/1000 [2:02:30<1:56:17, 14.33s/it][Succeeded / Failed / Skipped / Total] 350 / 119 / 44 / 513:  51%|█████▏    | 513/1000 [2:02:30<1:56:17, 14.33s/it][Succeeded / Failed / Skipped / Total] 350 / 119 / 44 / 513:  51%|█████▏    | 514/1000 [2:02:40<1:55:59, 14.32s/it][Succeeded / Failed / Skipped / Total] 350 / 120 / 44 / 514:  51%|█████▏    | 514/1000 [2:02:40<1:55:59, 14.32s/it][Succeeded / Failed / Skipped / Total] 350 / 120 / 44 / 514:  52%|█████▏    | 515/1000 [2:02:50<1:55:40, 14.31s/it][Succeeded / Failed / Skipped / Total] 351 / 120 / 44 / 515:  52%|█████▏    | 515/1000 [2:02:50<1:55:40, 14.31s/it][Succeeded / Failed / Skipped / Total] 351 / 120 / 44 / 515:  52%|█████▏    | 516/1000 [2:02:50<1:55:13, 14.28s/it][Succeeded / Failed / Skipped / Total] 351 / 121 / 44 / 516:  52%|█████▏    | 516/1000 [2:02:50<1:55:13, 14.28s/it][Succeeded / Failed / Skipped / Total] 351 / 121 / 44 / 516:  52%|█████▏    | 517/1000 [2:02:52<1:54:47, 14.26s/it]Creates persistence unit . --> [[[FAILED]]]

[[[[Adv]]]]: public JPAApi start ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .

[[[[Adv]]]]: public JPAApi start ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .
--------------------------------------------- Result 512 ---------------------------------------------
Unregisters a transaction . --> Notifies all registered garb --> Socre: 1.0

[[[[Adv]]]]: public void [[withTransaction]] ( Consumer < EntityManager > block ) { [[withTransaction]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .

[[[[Adv]]]]: public void [[granola]] ( Consumer < EntityManager > block ) { [[granola]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .
--------------------------------------------- Result 513 ---------------------------------------------
Sets the current frequency . --> Shristorical downloaded --> Socre: 1.0

[[[[Adv]]]]: public void stop ( int [[timeout]] ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "[[False]]" != "[[False]]" , "[[True]]" == "[[True]]" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .

[[[[Adv]]]]: public void stop ( int [[handoff]] ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "[[Mock]]" != "[[Mock]]" , "[[Loyal]]" == "[[Loyal]]" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .
--------------------------------------------- Result 514 ---------------------------------------------
Create a new retry . --> [[[FAILED]]]

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .
--------------------------------------------- Result 515 ---------------------------------------------
Get the port . --> Obtains an IP from a peer --> Socre: 1.0

[[[[Adv]]]]: public int [[getPort]] ( ) { int [[port]] = getAddress ( ) . getPort ( ) ; if ( [[port]] == 0 && server != null ) { [[port]] = server . socket ( ) . getLocalPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .

[[[[Adv]]]]: public int [[sweatpants]] ( ) { int [[puerto]] = getAddress ( ) . getPort ( ) ; if ( [[puerto]] == 0 && server != null ) { [[puerto]] = server . socket ( ) . getLocalPort ( ) ; } return [[puerto]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .
--------------------------------------------- Result 516 ---------------------------------------------
Gets a Java coder . --> [[[FAILED]]]

[[[[Adv]]]]: public static CustomSerializer getCustomSerializer ( CommandCode code ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( code ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .

[[[[Adv]]]]: public static CustomSerializer getCustomSerializer ( CommandCode code ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( code ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .
--------------------------------------------- Result 517 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 351 / 122 / 44 / 517:  52%|█████▏    | 517/1000 [2:02:52<1:54:47, 14.26s/it][Succeeded / Failed / Skipped / Total] 351 / 122 / 44 / 517:  52%|█████▏    | 518/1000 [2:03:04<1:54:31, 14.26s/it][Succeeded / Failed / Skipped / Total] 352 / 122 / 44 / 518:  52%|█████▏    | 518/1000 [2:03:04<1:54:31, 14.26s/it][Succeeded / Failed / Skipped / Total] 352 / 122 / 44 / 518:  52%|█████▏    | 519/1000 [2:03:40<1:54:37, 14.30s/it][Succeeded / Failed / Skipped / Total] 353 / 122 / 44 / 519:  52%|█████▏    | 519/1000 [2:03:40<1:54:37, 14.30s/it][Succeeded / Failed / Skipped / Total] 353 / 122 / 44 / 519:  52%|█████▏    | 520/1000 [2:04:51<1:55:15, 14.41s/it][Succeeded / Failed / Skipped / Total] 354 / 122 / 44 / 520:  52%|█████▏    | 520/1000 [2:04:51<1:55:15, 14.41s/it][Succeeded / Failed / Skipped / Total] 354 / 122 / 44 / 520:  52%|█████▏    | 521/1000 [2:04:56<1:54:51, 14.39s/it][Succeeded / Failed / Skipped / Total] 355 / 122 / 44 / 521:  52%|█████▏    | 521/1000 [2:04:56<1:54:51, 14.39s/it][Succeeded / Failed / Skipped / Total] 355 / 122 / 44 / 521:  52%|█████▏    | 522/1000 [2:05:21<1:54:47, 14.41s/it][Succeeded / Failed / Skipped / Total] 356 / 122 / 44 / 522:  52%|█████▏    | 522/1000 [2:05:21<1:54:47, 14.41s/it][Succeeded / Failed / Skipped / Total] 356 / 122 / 44 / 522:  52%|█████▏    | 523/1000 [2:05:33<1:54:30, 14.40s/it][Succeeded / Failed / Skipped / Total] 357 / 122 / 44 / 523:  52%|█████▏    | 523/1000 [2:05:33<1:54:30, 14.40s/it][Succeeded / Failed / Skipped / Total] 357 / 122 / 44 / 523:  52%|█████▏    | 524/1000 [2:05:39<1:54:08, 14.39s/it][Succeeded / Failed / Skipped / Total] 358 / 122 / 44 / 524:  52%|█████▏    | 524/1000 [2:05:39<1:54:08, 14.39s/it][Succeeded / Failed / Skipped / Total] 358 / 122 / 44 / 524:  52%|█████▎    | 525/1000 [2:05:42<1:53:44, 14.37s/it][Succeeded / Failed / Skipped / Total] 359 / 122 / 44 / 525:  52%|█████▎    | 525/1000 [2:05:42<1:53:44, 14.37s/it][Succeeded / Failed / Skipped / Total] 359 / 122 / 44 / 525:  53%|█████▎    | 526/1000 [2:05:56<1:53:29, 14.37s/it]Converts a string to a map . --> [[[FAILED]]]

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , List < String > keys , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , List < String > keys , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .
--------------------------------------------- Result 518 ---------------------------------------------
Send a web socket . --> Does connect . --> Socre: 1.0

[[[[Adv]]]]: private void [[executeConnectionLostDetection]] ( WebSocket webSocket , long minimumPongTime ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl [[webSocketImpl]] = ( WebSocketImpl ) webSocket ; if ( [[webSocketImpl]] . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , [[webSocketImpl]] ) ; [[webSocketImpl]] . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( [[webSocketImpl]] . isOpen ( ) ) { [[webSocketImpl]] . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , [[webSocketImpl]] ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping

[[[[Adv]]]]: private void [[beets]] ( WebSocket webSocket , long minimumPongTime ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl [[bodily]] = ( WebSocketImpl ) webSocket ; if ( [[bodily]] . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , [[bodily]] ) ; [[bodily]] . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( [[bodily]] . isOpen ( ) ) { [[bodily]] . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , [[bodily]] ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping
--------------------------------------------- Result 519 ---------------------------------------------
Put a key . --> Return the negotiation of the specified negotiation --> Socre: 1.0

[[[[Adv]]]]: public Boolean isDefinedAt ( play . api . i18n . Lang [[lang]] , String [[key]] ) { return messages . isDefinedAt ( [[key]] , [[lang]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .

[[[[Adv]]]]: public Boolean isDefinedAt ( play . api . i18n . Lang [[length]] , String [[necessity]] ) { return messages . isDefinedAt ( [[necessity]] , [[length]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .
--------------------------------------------- Result 520 ---------------------------------------------
Converts a list of arguments to a list --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[wrapArgsToListIfNeeded]] ( final T ... [[args]] ) { List < T > [[out]] ; if ( [[args]] != null && [[args]] . length == 1 && [[args]] [ 0 ] instanceof List ) { [[out]] = ( List < T > ) [[args]] [ 0 ] ; } else { [[out]] = Arrays . asList ( [[args]] ) ; } return [[out]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[derris]] ( final T ... [[muskets]] ) { List < T > [[outing]] ; if ( [[muskets]] != null && [[muskets]] . length == 1 && [[muskets]] [ 0 ] instanceof List ) { [[outing]] = ( List < T > ) [[muskets]] [ 0 ] ; } else { [[outing]] = Arrays . asList ( [[muskets]] ) ; } return [[outing]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .
--------------------------------------------- Result 521 ---------------------------------------------
Create a new bindings . --> Convenience method to create a new instance --> Socre: 1.0

[[[[Adv]]]]: public final Self bindings ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .

[[[[Adv]]]]: public final Self bindings ( GuiceableModule ... [[bundled]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[bundled]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .
--------------------------------------------- Result 522 ---------------------------------------------
Returns the modules . --> Unpacks a given Directory --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( play . api . inject . Module ... [[modules]] ) { return [[bindings]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .

[[[[Adv]]]]: public final Self [[bind]] ( play . api . inject . Module ... [[packaging]] ) { return [[bind]] ( Guiceable . [[packaging]] ( [[packaging]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .
--------------------------------------------- Result 523 ---------------------------------------------
Converts a String to a String . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang [[lang]] , String [[key]] , Object ... args ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( [[key]] , scalaArgs , [[lang]] ) ; }
[[[[Nl]]]]: Translates a message .

[[[[Adv]]]]: public String [[arrives]] ( play . api . i18n . Lang [[tedious]] , String [[basic]] , Object ... args ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( [[basic]] , scalaArgs , [[tedious]] ) ; }
[[[[Nl]]]]: Translates a message .
--------------------------------------------- Result 524 ---------------------------------------------
Create a overrides . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .

[[[[Adv]]]]: public final Self [[enemas]] ( GuiceableModule ... [[brushes]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[brushes]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .
--------------------------------------------- Result 525 ---------------------------------------------
Returns the modules . --> Initialize the Module instance --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Module ... modules ) { return [[overrides]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .

[[[[Adv]]]]: public final Self [[definitive]] ( play . api . inject . Module ... modules ) { return [[definitive]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .
--------------------------------------------- Result 526 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 360 / 122 / 44 / 526:  53%|█████▎    | 526/1000 [2:05:56<1:53:29, 14.37s/it][Succeeded / Failed / Skipped / Total] 360 / 122 / 44 / 526:  53%|█████▎    | 527/1000 [2:06:03<1:53:08, 14.35s/it][Succeeded / Failed / Skipped / Total] 361 / 122 / 44 / 527:  53%|█████▎    | 527/1000 [2:06:03<1:53:08, 14.35s/it][Succeeded / Failed / Skipped / Total] 361 / 122 / 44 / 527:  53%|█████▎    | 528/1000 [2:06:06<1:52:44, 14.33s/it][Succeeded / Failed / Skipped / Total] 362 / 122 / 44 / 528:  53%|█████▎    | 528/1000 [2:06:06<1:52:44, 14.33s/it][Succeeded / Failed / Skipped / Total] 362 / 122 / 44 / 528:  53%|█████▎    | 529/1000 [2:06:10<1:52:20, 14.31s/it][Succeeded / Failed / Skipped / Total] 363 / 122 / 44 / 529:  53%|█████▎    | 529/1000 [2:06:10<1:52:20, 14.31s/it][Succeeded / Failed / Skipped / Total] 363 / 122 / 44 / 529:  53%|█████▎    | 530/1000 [2:06:21<1:52:03, 14.31s/it][Succeeded / Failed / Skipped / Total] 363 / 123 / 44 / 530:  53%|█████▎    | 530/1000 [2:06:21<1:52:03, 14.31s/it][Succeeded / Failed / Skipped / Total] 363 / 123 / 44 / 530:  53%|█████▎    | 531/1000 [2:06:26<1:51:41, 14.29s/it][Succeeded / Failed / Skipped / Total] 364 / 123 / 44 / 531:  53%|█████▎    | 531/1000 [2:06:26<1:51:41, 14.29s/it][Succeeded / Failed / Skipped / Total] 364 / 123 / 44 / 531:  53%|█████▎    | 532/1000 [2:06:28<1:51:15, 14.26s/it][Succeeded / Failed / Skipped / Total] 364 / 124 / 44 / 532:  53%|█████▎    | 532/1000 [2:06:28<1:51:15, 14.26s/it][Succeeded / Failed / Skipped / Total] 364 / 124 / 44 / 532:  53%|█████▎    | 533/1000 [2:06:37<1:50:56, 14.25s/it][Succeeded / Failed / Skipped / Total] 365 / 124 / 44 / 533:  53%|█████▎    | 533/1000 [2:06:37<1:50:56, 14.25s/it][Succeeded / Failed / Skipped / Total] 365 / 124 / 44 / 533:  53%|█████▎    | 534/1000 [2:06:39<1:50:32, 14.23s/it][Succeeded / Failed / Skipped / Total] 365 / 125 / 44 / 534:  53%|█████▎    | 534/1000 [2:06:39<1:50:32, 14.23s/it][Succeeded / Failed / Skipped / Total] 365 / 125 / 44 / 534:  54%|█████▎    | 535/1000 [2:06:43<1:50:08, 14.21s/it][Succeeded / Failed / Skipped / Total] 366 / 125 / 44 / 535:  54%|█████▎    | 535/1000 [2:06:43<1:50:08, 14.21s/it][Succeeded / Failed / Skipped / Total] 366 / 125 / 44 / 535:  54%|█████▎    | 536/1000 [2:06:44<1:49:42, 14.19s/it][Succeeded / Failed / Skipped / Total] 367 / 125 / 44 / 536:  54%|█████▎    | 536/1000 [2:06:44<1:49:42, 14.19s/it][Succeeded / Failed / Skipped / Total] 367 / 125 / 44 / 536:  54%|█████▎    | 537/1000 [2:07:00<1:49:30, 14.19s/it]Returns the number of feeds . --> Helper method to get the list of Hadoopies --> Socre: 1.0

[[[[Adv]]]]: public final Self [[REPLACEME0]] ( play . api . inject . Binding < ? > ... [[REPLACEME0]] ) { return [[REPLACEME0]] ( Guiceable . bindings ( [[REPLACEME0]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .

[[[[Adv]]]]: public final Self [[HORSEMEN]] ( play . api . inject . Binding < ? > ... [[HORSEMEN]] ) { return [[HORSEMEN]] ( Guiceable . bindings ( [[HORSEMEN]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .
--------------------------------------------- Result 527 ---------------------------------------------
Returns a bindings . --> Returns the gguogggghboooogggggghboooogghbggghboooooooogggghb --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Binding < ? > ... [[bindings]] ) { return [[overrides]] ( Guiceable . [[bindings]] ( [[bindings]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .

[[[[Adv]]]]: public final Self [[drugging]] ( play . api . inject . Binding < ? > ... [[obliges]] ) { return [[drugging]] ( Guiceable . [[obliges]] ( [[obliges]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .
--------------------------------------------- Result 528 ---------------------------------------------
Adds a specification . --> Create a new instance --> Socre: 1.0

[[[[Adv]]]]: public final Self disable ( Class < ? > ... [[moduleClasses]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[moduleClasses]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .

[[[[Adv]]]]: public final Self disable ( Class < ? > ... [[hoppy]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[hoppy]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .
--------------------------------------------- Result 529 ---------------------------------------------
Handles a request . --> Asynchronously creates a CompletionStage --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < Result > [[call]] ( Request [[req]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .

[[[[Adv]]]]: public CompletionStage < Result > [[telephone]] ( Request [[asap]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .
--------------------------------------------- Result 530 ---------------------------------------------
Send a status to the socket . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void onWebsocketPing ( WebSocket conn , Framedata f ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .

[[[[Adv]]]]: @ Override public void onWebsocketPing ( WebSocket conn , Framedata f ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .
--------------------------------------------- Result 531 ---------------------------------------------
Convert a tuple to a Tuple . --> Analyzes the supplied Tesatisfies . --> Socre: 1.0

[[[[Adv]]]]: public static < [[A]] , B > [[Tuple]] < [[A]] , B > [[Tuple]] ( [[A]] a , B [[b]] ) { return new [[Tuple]] < [[A]] , B > ( a , [[b]] ) ; }
[[[[Nl]]]]: Constructs a tuple of A B

[[[[Adv]]]]: public static < [[latest]] , B > [[Tesseract]] < [[latest]] , B > [[Tesseract]] ( [[latest]] a , B [[al]] ) { return new [[Tesseract]] < [[latest]] , B > ( a , [[al]] ) ; }
[[[[Nl]]]]: Constructs a tuple of A B
--------------------------------------------- Result 532 ---------------------------------------------
Returns an identifier for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .

[[[[Adv]]]]: public < A extends Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .
--------------------------------------------- Result 533 ---------------------------------------------
Convert a tuple to a tuple . --> Auxiliary function . --> Socre: 1.0

[[[[Adv]]]]: public static < A , B , C , D , E > [[Tuple5]] < A , B , C , D , E > [[Tuple5]] ( A [[a]] , B b , C c , D d , E e ) { return new [[Tuple5]] < A , B , C , D , E > ( [[a]] , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E

[[[[Adv]]]]: public static < A , B , C , D , E > [[Requiring]] < A , B , C , D , E > [[Requiring]] ( A [[latest]] , B b , C c , D d , E e ) { return new [[Requiring]] < A , B , C , D , E > ( [[latest]] , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E
--------------------------------------------- Result 534 ---------------------------------------------
Returns a EntityManager . --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager em ( String name ) { EntityManagerFactory emf = emfs . get ( name ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .

[[[[Adv]]]]: public EntityManager em ( String name ) { EntityManagerFactory emf = emfs . get ( name ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .
--------------------------------------------- Result 535 ---------------------------------------------
Creates a new unit with the given name . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String name , String [[unitName]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( name , [[unitName]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .

[[[[Adv]]]]: public static JPAConfig [[las]] ( String name , String [[gunshot]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( name , [[gunshot]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .
--------------------------------------------- Result 536 ---------------------------------------------
Convenience method to create a JN12 . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig of ( String n1 , String u1 , String [[n2]] , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( [[n2]] , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .

[[[[Adv]]]]: public static JPAConfig of ( String n1 , String u1 , String [[accusation]] , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( [[accusation]] , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .
--------------------------------------------- Result 537 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 368 / 125 / 44 / 537:  54%|█████▎    | 537/1000 [2:07:00<1:49:30, 14.19s/it][Succeeded / Failed / Skipped / Total] 368 / 125 / 44 / 537:  54%|█████▍    | 538/1000 [2:07:30<1:49:30, 14.22s/it][Succeeded / Failed / Skipped / Total] 369 / 125 / 44 / 538:  54%|█████▍    | 538/1000 [2:07:30<1:49:30, 14.22s/it][Succeeded / Failed / Skipped / Total] 369 / 125 / 44 / 538:  54%|█████▍    | 539/1000 [2:08:02<1:49:30, 14.25s/it][Succeeded / Failed / Skipped / Total] 370 / 125 / 44 / 539:  54%|█████▍    | 539/1000 [2:08:02<1:49:30, 14.25s/it][Succeeded / Failed / Skipped / Total] 370 / 125 / 44 / 539:  54%|█████▍    | 540/1000 [2:08:13<1:49:14, 14.25s/it][Succeeded / Failed / Skipped / Total] 370 / 126 / 44 / 540:  54%|█████▍    | 540/1000 [2:08:13<1:49:14, 14.25s/it][Succeeded / Failed / Skipped / Total] 370 / 126 / 44 / 540:  54%|█████▍    | 541/1000 [2:08:49<1:49:18, 14.29s/it][Succeeded / Failed / Skipped / Total] 371 / 126 / 44 / 541:  54%|█████▍    | 541/1000 [2:08:49<1:49:18, 14.29s/it][Succeeded / Failed / Skipped / Total] 371 / 126 / 44 / 541:  54%|█████▍    | 542/1000 [2:09:30<1:49:26, 14.34s/it][Succeeded / Failed / Skipped / Total] 371 / 127 / 44 / 542:  54%|█████▍    | 542/1000 [2:09:30<1:49:26, 14.34s/it][Succeeded / Failed / Skipped / Total] 371 / 127 / 44 / 542:  54%|█████▍    | 543/1000 [2:09:52<1:49:18, 14.35s/it][Succeeded / Failed / Skipped / Total] 372 / 127 / 44 / 543:  54%|█████▍    | 543/1000 [2:09:52<1:49:18, 14.35s/it][Succeeded / Failed / Skipped / Total] 372 / 127 / 44 / 543:  54%|█████▍    | 544/1000 [2:10:45<1:49:36, 14.42s/it][Succeeded / Failed / Skipped / Total] 373 / 127 / 44 / 544:  54%|█████▍    | 544/1000 [2:10:45<1:49:36, 14.42s/it][Succeeded / Failed / Skipped / Total] 373 / 127 / 44 / 544:  55%|█████▍    | 545/1000 [2:11:10<1:49:30, 14.44s/it]Build a map of unit tests . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[from]] ( Map < String , String > [[map]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > [[persistenceUnits]] = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > [[entry]] : [[map]] . entrySet ( ) ) { [[persistenceUnits]] . add ( new JPAConfig . PersistenceUnit ( [[entry]] . getKey ( ) , [[entry]] . getValue ( ) ) ) ; } return new DefaultJPAConfig ( [[persistenceUnits]] . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .

[[[[Adv]]]]: public static JPAConfig [[van]] ( Map < String , String > [[letters]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > [[logic]] = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > [[arriving]] : [[letters]] . entrySet ( ) ) { [[logic]] . add ( new JPAConfig . PersistenceUnit ( [[arriving]] . getKey ( ) , [[arriving]] . getValue ( ) ) ) ; } return new DefaultJPAConfig ( [[logic]] . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .
--------------------------------------------- Result 538 ---------------------------------------------
Put a SASL . --> Promotected by hook --> Socre: 1.0

[[[[Adv]]]]: public Messages preferred ( Collection < Lang > [[candidates]] ) { Seq < Lang > cs = Scala . asScala ( [[candidates]] ) ; play . api . i18n . Messages [[msgs]] = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( [[msgs]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .

[[[[Adv]]]]: public Messages preferred ( Collection < Lang > [[competitors]] ) { Seq < Lang > cs = Scala . asScala ( [[competitors]] ) ; play . api . i18n . Messages [[wwho]] = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( [[wwho]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .
--------------------------------------------- Result 539 ---------------------------------------------
Returns the prepared executor . --> Execute Executors --> Socre: 1.0

[[[[Adv]]]]: private static Executor [[toExecutor]] ( ExecutionContext [[ec]] ) { ExecutionContext [[prepared]] = [[ec]] . prepare ( ) ; if ( [[prepared]] instanceof Executor ) { return ( Executor ) [[prepared]] ; } else { return [[prepared]] :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .

[[[[Adv]]]]: private static Executor [[oracles]] ( ExecutionContext [[quoi]] ) { ExecutionContext [[draft]] = [[quoi]] . prepare ( ) ; if ( [[draft]] instanceof Executor ) { return ( Executor ) [[draft]] ; } else { return [[draft]] :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .
--------------------------------------------- Result 540 ---------------------------------------------
Construct a new Request . --> [[[FAILED]]]

[[[[Adv]]]]: public Messages preferred ( Http . RequestHeader request ) { play . api . i18n . Messages msgs = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .

[[[[Adv]]]]: public Messages preferred ( Http . RequestHeader request ) { play . api . i18n . Messages msgs = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .
--------------------------------------------- Result 541 ---------------------------------------------
Returns a new instance of the given class . --> Obtain a constructor for a given key --> Socre: 1.0

[[[[Adv]]]]: private < [[T]] [[extends]] ConstraintValidator < ? , ? > > [[T]] newInstance ( Class < [[T]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .

[[[[Adv]]]]: private < [[zillion]] [[broadened]] ConstraintValidator < ? , ? > > [[zillion]] newInstance ( Class < [[zillion]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .
--------------------------------------------- Result 542 ---------------------------------------------
Set the result . --> [[[FAILED]]]

[[[[Adv]]]]: public Result setLang ( Result result , Lang lang ) { return messages . setLang ( result . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .

[[[[Adv]]]]: public Result setLang ( Result result , Lang lang ) { return messages . setLang ( result . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .
--------------------------------------------- Result 543 ---------------------------------------------
Sends a request to the client . --> On negotiation --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onClientError]] ( RequestHeader [[request]] , int [[statusCode]] , String [[message]] ) { if ( [[statusCode]] == 400 ) { return onBadRequest ( [[request]] , [[message]] ) ; } else if ( [[statusCode]] == 403 ) { return onForbidden ( [[request]] , [[message]] ) ; } else if ( [[statusCode]] == 404 ) { return onNotFound ( [[request]] , [[message]] ) ; } else if ( [[statusCode]] >= 400 && [[statusCode]] < 500 ) { return onOtherClientError ( [[request]] , [[statusCode]] , [[message]] ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + [[statusCode]] + ": " + [[message]] ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[thigh]] ( RequestHeader [[apps]] , int [[jernigan]] , String [[prompts]] ) { if ( [[jernigan]] == 400 ) { return onBadRequest ( [[apps]] , [[prompts]] ) ; } else if ( [[jernigan]] == 403 ) { return onForbidden ( [[apps]] , [[prompts]] ) ; } else if ( [[jernigan]] == 404 ) { return onNotFound ( [[apps]] , [[prompts]] ) ; } else if ( [[jernigan]] >= 400 && [[jernigan]] < 500 ) { return onOtherClientError ( [[apps]] , [[jernigan]] , [[prompts]] ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + [[jernigan]] + ": " + [[prompts]] ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .
--------------------------------------------- Result 544 ---------------------------------------------
Converts a java . --> Smolecule . --> Socre: 1.0

[[[[Adv]]]]: private static Seq < Object > [[convertArgsToScalaBuffer]] ( final Object ... [[args]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( [[args]] ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary

[[[[Adv]]]]: private static Seq < Object > [[fournier]] ( final Object ... [[quay]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( [[quay]] ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary
--------------------------------------------- Result 545 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 373 / 128 / 44 / 545:  55%|█████▍    | 545/1000 [2:11:10<1:49:30, 14.44s/it][Succeeded / Failed / Skipped / Total] 373 / 128 / 44 / 545:  55%|█████▍    | 546/1000 [2:11:28<1:49:19, 14.45s/it][Succeeded / Failed / Skipped / Total] 374 / 128 / 44 / 546:  55%|█████▍    | 546/1000 [2:11:28<1:49:19, 14.45s/it][Succeeded / Failed / Skipped / Total] 374 / 128 / 44 / 546:  55%|█████▍    | 547/1000 [2:11:34<1:48:57, 14.43s/it][Succeeded / Failed / Skipped / Total] 374 / 129 / 44 / 547:  55%|█████▍    | 547/1000 [2:11:34<1:48:57, 14.43s/it][Succeeded / Failed / Skipped / Total] 374 / 129 / 44 / 547:  55%|█████▍    | 548/1000 [2:12:53<1:49:36, 14.55s/it][Succeeded / Failed / Skipped / Total] 375 / 129 / 44 / 548:  55%|█████▍    | 548/1000 [2:12:53<1:49:36, 14.55s/it][Succeeded / Failed / Skipped / Total] 375 / 129 / 44 / 548:  55%|█████▍    | 549/1000 [2:13:37<1:49:46, 14.60s/it][Succeeded / Failed / Skipped / Total] 375 / 130 / 44 / 549:  55%|█████▍    | 549/1000 [2:13:37<1:49:46, 14.60s/it][Succeeded / Failed / Skipped / Total] 375 / 130 / 44 / 549:  55%|█████▌    | 550/1000 [2:13:52<1:49:31, 14.60s/it][Succeeded / Failed / Skipped / Total] 376 / 130 / 44 / 550:  55%|█████▌    | 550/1000 [2:13:52<1:49:31, 14.60s/it][Succeeded / Failed / Skipped / Total] 376 / 130 / 44 / 550:  55%|█████▌    | 551/1000 [2:13:53<1:49:06, 14.58s/it][Succeeded / Failed / Skipped / Total] 377 / 130 / 44 / 551:  55%|█████▌    | 551/1000 [2:13:53<1:49:06, 14.58s/it][Succeeded / Failed / Skipped / Total] 377 / 130 / 44 / 551:  55%|█████▌    | 552/1000 [2:14:10<1:48:53, 14.58s/it][Succeeded / Failed / Skipped / Total] 377 / 131 / 44 / 552:  55%|█████▌    | 552/1000 [2:14:10<1:48:53, 14.58s/it][Succeeded / Failed / Skipped / Total] 377 / 131 / 44 / 552:  55%|█████▌    | 553/1000 [2:14:40<1:48:51, 14.61s/it][Succeeded / Failed / Skipped / Total] 378 / 131 / 44 / 553:  55%|█████▌    | 553/1000 [2:14:40<1:48:51, 14.61s/it][Succeeded / Failed / Skipped / Total] 378 / 131 / 44 / 553:  55%|█████▌    | 554/1000 [2:14:58<1:48:39, 14.62s/it]Convert a string to string . --> [[[FAILED]]]

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > string ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > string ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .
--------------------------------------------- Result 546 ---------------------------------------------
Serialize flow . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[json]] ( String [[callbackName]] ) { return Flow . of ( JsonNode . class ) . map ( [[json]] -> { return ByteString . fromString ( Json . stringify ( [[json]] ) ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[harding]] ( String [[connoisseur]] ) { return Flow . of ( JsonNode . class ) . map ( [[harding]] -> { return ByteString . fromString ( Json . stringify ( [[harding]] ) ) ; } ) . via ( flow ( [[connoisseur]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .
--------------------------------------------- Result 547 ---------------------------------------------
Returns the temporary directory . --> [[[FAILED]]]

[[[[Adv]]]]: public Optional < File > getExistingFile ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .

[[[[Adv]]]]: public Optional < File > getExistingFile ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .
--------------------------------------------- Result 548 ---------------------------------------------
Handles a request . --> Handle a request --> Socre: 1.0

[[[[Adv]]]]: protected void [[logServerError]] ( RequestHeader [[request]] , UsefulException [[usefulException]] ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , [[usefulException]] . id , [[request]] . method ( ) , [[request]] . uri ( ) ) , [[usefulException]] ) ; }
[[[[Nl]]]]: Responsible for logging server errors .

[[[[Adv]]]]: protected void [[isolated]] ( RequestHeader [[requiring]] , UsefulException [[carr]] ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , [[carr]] . id , [[requiring]] . method ( ) , [[requiring]] . uri ( ) ) , [[carr]] ) ; }
[[[[Nl]]]]: Responsible for logging server errors .
--------------------------------------------- Result 549 ---------------------------------------------
Add a constraint to the constraint . --> [[[FAILED]]]

[[[[Adv]]]]: public < T extends ConstraintValidator < ? , ? > > MappedConstraintValidatorFactory addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .

[[[[Adv]]]]: public < T extends ConstraintValidator < ? , ? > > MappedConstraintValidatorFactory addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .
--------------------------------------------- Result 550 ---------------------------------------------
Handles request . --> Used for testing --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onProdServerError]] ( RequestHeader [[request]] , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( exception , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .

[[[[Adv]]]]: protected CompletionStage < Result > [[seamen]] ( RequestHeader [[prayed]] , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( exception , [[prayed]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .
--------------------------------------------- Result 551 ---------------------------------------------
Handles a request . --> Used for testing --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onForbidden]] ( RequestHeader request , String [[message]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .

[[[[Adv]]]]: protected CompletionStage < Result > [[sent]] ( RequestHeader request , String [[messengers]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .
--------------------------------------------- Result 552 ---------------------------------------------
Handles request . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > onBadRequest ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , message , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .

[[[[Adv]]]]: protected CompletionStage < Result > onBadRequest ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , message , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .
--------------------------------------------- Result 553 ---------------------------------------------
Build a directory . --> Convenience method for testing . --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File [[directory]] , JarFile jarFile , String [[base]] ) { return [[fromDirectoryAndJar]] ( [[directory]] , jarFile , [[base]] , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository

[[[[Adv]]]]: public static BuildDocHandler [[linnea]] ( File [[cataloging]] , JarFile jarFile , String [[reasons]] ) { return [[linnea]] ( [[cataloging]] , jarFile , [[reasons]] , "[[Counterfeits]]" != "[[Counterfeits]]" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository
--------------------------------------------- Result 554 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 378 / 132 / 44 / 554:  55%|█████▌    | 554/1000 [2:14:58<1:48:39, 14.62s/it][Succeeded / Failed / Skipped / Total] 378 / 132 / 44 / 554:  56%|█████▌    | 555/1000 [2:15:06<1:48:19, 14.61s/it][Succeeded / Failed / Skipped / Total] 379 / 132 / 44 / 555:  56%|█████▌    | 555/1000 [2:15:06<1:48:19, 14.61s/it][Succeeded / Failed / Skipped / Total] 379 / 132 / 44 / 555:  56%|█████▌    | 556/1000 [2:15:09<1:47:55, 14.59s/it][Succeeded / Failed / Skipped / Total] 380 / 132 / 44 / 556:  56%|█████▌    | 556/1000 [2:15:09<1:47:55, 14.59s/it][Succeeded / Failed / Skipped / Total] 380 / 132 / 44 / 556:  56%|█████▌    | 557/1000 [2:15:25<1:47:42, 14.59s/it][Succeeded / Failed / Skipped / Total] 381 / 132 / 44 / 557:  56%|█████▌    | 557/1000 [2:15:25<1:47:42, 14.59s/it][Succeeded / Failed / Skipped / Total] 381 / 132 / 44 / 557:  56%|█████▌    | 558/1000 [2:15:27<1:47:17, 14.56s/it][Succeeded / Failed / Skipped / Total] 382 / 132 / 44 / 558:  56%|█████▌    | 558/1000 [2:15:27<1:47:17, 14.56s/it][Succeeded / Failed / Skipped / Total] 382 / 132 / 44 / 558:  56%|█████▌    | 559/1000 [2:15:48<1:47:08, 14.58s/it][Succeeded / Failed / Skipped / Total] 382 / 133 / 44 / 559:  56%|█████▌    | 559/1000 [2:15:48<1:47:08, 14.58s/it][Succeeded / Failed / Skipped / Total] 382 / 133 / 44 / 559:  56%|█████▌    | 560/1000 [2:16:41<1:47:24, 14.65s/it][Succeeded / Failed / Skipped / Total] 383 / 133 / 44 / 560:  56%|█████▌    | 560/1000 [2:16:41<1:47:24, 14.65s/it][Succeeded / Failed / Skipped / Total] 383 / 133 / 44 / 560:  56%|█████▌    | 561/1000 [2:16:55<1:47:09, 14.65s/it][Succeeded / Failed / Skipped / Total] 383 / 134 / 44 / 561:  56%|█████▌    | 561/1000 [2:16:55<1:47:09, 14.65s/it][Succeeded / Failed / Skipped / Total] 383 / 134 / 44 / 561:  56%|█████▌    | 562/1000 [2:17:00<1:46:47, 14.63s/it]Returns a method with the specified name . --> [[[FAILED]]]

[[[[Adv]]]]: public static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .

[[[[Adv]]]]: public static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .
--------------------------------------------- Result 555 ---------------------------------------------
Throwable if the exception is not null . --> Used for testing --> Socre: 1.0

[[[[Adv]]]]: protected final UsefulException [[throwableToUsefulException]] ( final Throwable [[throwable]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[throwable]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .

[[[[Adv]]]]: protected final UsefulException [[wry]] ( final Throwable [[bartender]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[bartender]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .
--------------------------------------------- Result 556 ---------------------------------------------
Transfers data to a byte array . --> Subroutine to byte array --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < ByteString > [[consumeData]] ( Materializer [[mat]] ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , [[mat]] ) ; }
[[[[Nl]]]]: Consumes the data .

[[[[Adv]]]]: public CompletionStage < ByteString > [[werent]] ( Materializer [[flagpole]] ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , [[flagpole]] ) ; }
[[[[Nl]]]]: Consumes the data .
--------------------------------------------- Result 557 ---------------------------------------------
Convert the given content to a content . --> Convert string to a String --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromContent]] ( Content [[content]] , String charset ) { String [[body]] ; if ( [[content]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .

[[[[Adv]]]]: public static final HttpEntity [[par]] ( Content [[glad]] , String charset ) { String [[skeletons]] ; if ( [[glad]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .
--------------------------------------------- Result 558 ---------------------------------------------
Convenience method to create a string . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromString]] ( String [[content]] , String [[charset]] ) { return new Strict ( ByteString . fromString ( [[content]] , [[charset]] ) , Optional . of ( "text/plain; charset=" + [[charset]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .

[[[[Adv]]]]: public static final HttpEntity [[roxane]] ( String [[happy]] , String [[dissing]] ) { return new Strict ( ByteString . fromString ( [[happy]] , [[dissing]] ) , Optional . of ( "text/plain; charset=" + [[dissing]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .
--------------------------------------------- Result 559 ---------------------------------------------
Handles a request . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > onNotFound ( RequestHeader request , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( request . method ( ) , request . uri ( ) , request . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( request . method ( ) , request . uri ( ) , Some . apply ( routes . get ( ) ) , request . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .

[[[[Adv]]]]: protected CompletionStage < Result > onNotFound ( RequestHeader request , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( request . method ( ) , request . uri ( ) , request . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( request . method ( ) , request . uri ( ) , Some . apply ( routes . get ( ) ) , request . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .
--------------------------------------------- Result 560 ---------------------------------------------
Creates a new jar file . --> Convenience method for testing purposes --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromJar]] ( JarFile [[jarFile]] , String [[base]] ) { FileRepository [[repo]] = new JarRepository ( [[jarFile]] , Option . apply ( [[base]] ) ) ; return new DocumentationHandler ( [[repo]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[riku]] ( JarFile [[straighter]] , String [[rudiments]] ) { FileRepository [[discount]] = new JarRepository ( [[straighter]] , Option . apply ( [[rudiments]] ) ) ; return new DocumentationHandler ( [[discount]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 561 ---------------------------------------------
Executes the specified exception . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public CompletionStage < Result > onServerError ( RequestHeader request , Throwable exception ) { try { UsefulException usefulException = throwableToUsefulException ( exception ) ; logServerError ( request , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , usefulException ) ; default : return onDevServerError ( request , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .

[[[[Adv]]]]: @ Override public CompletionStage < Result > onServerError ( RequestHeader request , Throwable exception ) { try { UsefulException usefulException = throwableToUsefulException ( exception ) ; logServerError ( request , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , usefulException ) ; default : return onDevServerError ( request , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .
--------------------------------------------- Result 562 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 384 / 134 / 44 / 562:  56%|█████▌    | 562/1000 [2:17:00<1:46:47, 14.63s/it][Succeeded / Failed / Skipped / Total] 384 / 134 / 44 / 562:  56%|█████▋    | 563/1000 [2:17:10<1:46:28, 14.62s/it][Succeeded / Failed / Skipped / Total] 385 / 134 / 44 / 563:  56%|█████▋    | 563/1000 [2:17:10<1:46:28, 14.62s/it][Succeeded / Failed / Skipped / Total] 385 / 134 / 44 / 563:  56%|█████▋    | 564/1000 [2:17:16<1:46:07, 14.60s/it][Succeeded / Failed / Skipped / Total] 386 / 134 / 44 / 564:  56%|█████▋    | 564/1000 [2:17:16<1:46:07, 14.60s/it][Succeeded / Failed / Skipped / Total] 386 / 134 / 44 / 564:  56%|█████▋    | 565/1000 [2:17:16<1:45:41, 14.58s/it][Succeeded / Failed / Skipped / Total] 386 / 134 / 45 / 565:  56%|█████▋    | 565/1000 [2:17:16<1:45:41, 14.58s/it][Succeeded / Failed / Skipped / Total] 386 / 134 / 45 / 565:  57%|█████▋    | 566/1000 [2:18:07<1:45:54, 14.64s/it][Succeeded / Failed / Skipped / Total] 386 / 135 / 45 / 566:  57%|█████▋    | 566/1000 [2:18:07<1:45:54, 14.64s/it][Succeeded / Failed / Skipped / Total] 386 / 135 / 45 / 566:  57%|█████▋    | 567/1000 [2:18:24<1:45:41, 14.65s/it][Succeeded / Failed / Skipped / Total] 386 / 136 / 45 / 567:  57%|█████▋    | 567/1000 [2:18:24<1:45:41, 14.65s/it][Succeeded / Failed / Skipped / Total] 386 / 136 / 45 / 567:  57%|█████▋    | 568/1000 [2:18:27<1:45:18, 14.63s/it][Succeeded / Failed / Skipped / Total] 386 / 137 / 45 / 568:  57%|█████▋    | 568/1000 [2:18:27<1:45:18, 14.63s/it][Succeeded / Failed / Skipped / Total] 386 / 137 / 45 / 568:  57%|█████▋    | 569/1000 [2:18:33<1:44:57, 14.61s/it][Succeeded / Failed / Skipped / Total] 387 / 137 / 45 / 569:  57%|█████▋    | 569/1000 [2:18:33<1:44:57, 14.61s/it][Succeeded / Failed / Skipped / Total] 387 / 137 / 45 / 569:  57%|█████▋    | 570/1000 [2:18:41<1:44:37, 14.60s/it][Succeeded / Failed / Skipped / Total] 388 / 137 / 45 / 570:  57%|█████▋    | 570/1000 [2:18:41<1:44:37, 14.60s/it][Succeeded / Failed / Skipped / Total] 388 / 137 / 45 / 570:  57%|█████▋    | 571/1000 [2:18:43<1:44:13, 14.58s/it][Succeeded / Failed / Skipped / Total] 389 / 137 / 45 / 571:  57%|█████▋    | 571/1000 [2:18:43<1:44:13, 14.58s/it][Succeeded / Failed / Skipped / Total] 389 / 137 / 45 / 571:  57%|█████▋    | 572/1000 [2:20:01<1:44:46, 14.69s/it][Succeeded / Failed / Skipped / Total] 390 / 137 / 45 / 572:  57%|█████▋    | 572/1000 [2:20:01<1:44:46, 14.69s/it][Succeeded / Failed / Skipped / Total] 390 / 137 / 45 / 572:  57%|█████▋    | 573/1000 [2:20:53<1:44:59, 14.75s/it]Creates a status code . --> Static factory method to UTF - 8 --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , JsonNode content ) { return [[status]] ( [[status]] , content , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .

[[[[Adv]]]]: public static Result [[necessity]] ( int status , JsonNode content ) { return [[necessity]] ( [[necessity]] , content , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .
--------------------------------------------- Result 563 ---------------------------------------------
Send a stream to a stream . --> Send InputStream --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , InputStream [[content]] , long [[contentLength]] ) { return [[status]] ( [[status]] ) . sendInputStream ( [[content]] , [[contentLength]] ) ; }
[[[[Nl]]]]: Generates a chunked result .

[[[[Adv]]]]: public static Result [[clauses]] ( int [[rule]] , InputStream [[bonheur]] , long [[sixteenth]] ) { return [[clauses]] ( [[clauses]] ) . sendInputStream ( [[bonheur]] , [[sixteenth]] ) ; }
[[[[Nl]]]]: Generates a chunked result .
--------------------------------------------- Result 564 ---------------------------------------------
Construct a MIME file . --> Audit dit die die die die e die die die e e die die die die e e die e die e e die die e eie e die e eie e diene uf ef eief e di --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , File [[content]] ) { return [[status]] ( [[status]] , [[content]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .

[[[[Adv]]]]: public static Result [[rules]] ( int [[sovereignty]] , File [[proud]] ) { return [[rules]] ( [[rules]] , [[proud]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .
--------------------------------------------- Result 565 ---------------------------------------------
Returns the user with the given id . --> [[[SKIPPED]]]

[[[[Adv]]]]: private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
[[[[Nl]]]]: designed to be lightweight operation
--------------------------------------------- Result 566 ---------------------------------------------
Uploads the given request . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > onDevServerError ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .

[[[[Adv]]]]: protected CompletionStage < Result > onDevServerError ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .
--------------------------------------------- Result 567 ---------------------------------------------
Perform a call . --> [[[FAILED]]]

[[[[Adv]]]]: public Call unique ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .

[[[[Adv]]]]: public Call unique ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .
--------------------------------------------- Result 568 ---------------------------------------------
Creates a new directory . --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromDirectory ( File directory ) { FileRepository repo = new FilesystemRepository ( directory ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .

[[[[Adv]]]]: public static BuildDocHandler fromDirectory ( File directory ) { FileRepository repo = new FilesystemRepository ( directory ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .
--------------------------------------------- Result 569 ---------------------------------------------
Set the http request . --> Create a new computation --> Socre: 1.0

[[[[Adv]]]]: public String [[absoluteURL]] ( Http . Request [[request]] ) { return [[absoluteURL]] ( [[request]] . secure ( ) , [[request]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .

[[[[Adv]]]]: public String [[commerce]] ( Http . Request [[appealed]] ) { return [[commerce]] ( [[appealed]] . secure ( ) , [[appealed]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .
--------------------------------------------- Result 570 ---------------------------------------------
Build an HTTP request . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public String [[webSocketURL]] ( Http . Request [[request]] ) { return [[webSocketURL]] ( [[request]] . secure ( ) , [[request]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .

[[[[Adv]]]]: public String [[hmmmm]] ( Http . Request [[appealed]] ) { return [[hmmmm]] ( [[appealed]] . secure ( ) , [[appealed]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .
--------------------------------------------- Result 571 ---------------------------------------------
Constructs a JSON string from the given content . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , JsonNode [[content]] , JsonEncoding [[encoding]] ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return [[status]] ( [[status]] ) . sendJson ( [[content]] , [[encoding]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .

[[[[Adv]]]]: public static Result [[provisions]] ( int [[article]] , JsonNode [[connotation]] , JsonEncoding [[shoveler]] ) { if ( [[connotation]] == null ) { throw new NullPointerException ( "Null content" ) ; } return [[provisions]] ( [[provisions]] ) . sendJson ( [[connotation]] , [[shoveler]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .
--------------------------------------------- Result 572 ---------------------------------------------
A convenience method to create a byte array . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[chunked]] ( Source < ByteString , ? > [[data]] , Optional < String > [[contentType]] ) { return new Chunked ( [[data]] . map ( HttpChunk . Chunk :: new ) , [[contentType]] ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .

[[[[Adv]]]]: public static final HttpEntity [[experiments]] ( Source < ByteString , ? > [[report]] , Optional < String > [[sheung]] ) { return new Chunked ( [[report]] . map ( HttpChunk . Chunk :: new ) , [[sheung]] ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .
--------------------------------------------- Result 573 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 390 / 138 / 45 / 573:  57%|█████▋    | 573/1000 [2:20:53<1:44:59, 14.75s/it][Succeeded / Failed / Skipped / Total] 390 / 138 / 45 / 573:  57%|█████▋    | 574/1000 [2:21:04<1:44:41, 14.75s/it][Succeeded / Failed / Skipped / Total] 391 / 138 / 45 / 574:  57%|█████▋    | 574/1000 [2:21:04<1:44:41, 14.75s/it][Succeeded / Failed / Skipped / Total] 391 / 138 / 45 / 574:  57%|█████▊    | 575/1000 [2:21:20<1:44:28, 14.75s/it][Succeeded / Failed / Skipped / Total] 391 / 139 / 45 / 575:  57%|█████▊    | 575/1000 [2:21:20<1:44:28, 14.75s/it][Succeeded / Failed / Skipped / Total] 391 / 139 / 45 / 575:  58%|█████▊    | 576/1000 [2:21:35<1:44:13, 14.75s/it][Succeeded / Failed / Skipped / Total] 392 / 139 / 45 / 576:  58%|█████▊    | 576/1000 [2:21:35<1:44:13, 14.75s/it][Succeeded / Failed / Skipped / Total] 392 / 139 / 45 / 576:  58%|█████▊    | 577/1000 [2:21:39<1:43:50, 14.73s/it][Succeeded / Failed / Skipped / Total] 392 / 140 / 45 / 577:  58%|█████▊    | 577/1000 [2:21:39<1:43:50, 14.73s/it][Succeeded / Failed / Skipped / Total] 392 / 140 / 45 / 577:  58%|█████▊    | 578/1000 [2:21:40<1:43:26, 14.71s/it][Succeeded / Failed / Skipped / Total] 392 / 141 / 45 / 578:  58%|█████▊    | 578/1000 [2:21:40<1:43:26, 14.71s/it][Succeeded / Failed / Skipped / Total] 392 / 141 / 45 / 578:  58%|█████▊    | 579/1000 [2:21:43<1:43:03, 14.69s/it][Succeeded / Failed / Skipped / Total] 393 / 141 / 45 / 579:  58%|█████▊    | 579/1000 [2:21:43<1:43:03, 14.69s/it][Succeeded / Failed / Skipped / Total] 393 / 141 / 45 / 579:  58%|█████▊    | 580/1000 [2:21:57<1:42:47, 14.68s/it][Succeeded / Failed / Skipped / Total] 394 / 141 / 45 / 580:  58%|█████▊    | 580/1000 [2:21:57<1:42:47, 14.68s/it][Succeeded / Failed / Skipped / Total] 394 / 141 / 45 / 580:  58%|█████▊    | 581/1000 [2:22:03<1:42:26, 14.67s/it]Returns a sorted collection of features . --> [[[FAILED]]]

[[[[Adv]]]]: public Lang preferred ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .

[[[[Adv]]]]: public Lang preferred ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .
--------------------------------------------- Result 574 ---------------------------------------------
Record a call . --> Used for testing --> Socre: 1.0

[[[[Adv]]]]: public Call [[withFragment]] ( String [[fragment]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[fragment]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .

[[[[Adv]]]]: public Call [[cider]] ( String [[slice]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[slice]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .
--------------------------------------------- Result 575 ---------------------------------------------
Converts a JSONArray to a JsonNode --> [[[FAILED]]]

[[[[Adv]]]]: public static < A > A fromJson ( JsonNode json , Class < A > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value

[[[[Adv]]]]: public static < A > A fromJson ( JsonNode json , Class < A > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value
--------------------------------------------- Result 576 ---------------------------------------------
Creates a new instance of the given parameters . --> Build http portion --> Socre: 1.0

[[[[Adv]]]]: public static Server forRouter ( Mode [[mode]] , int port , Function < BuiltInComponents , Router > [[block]] ) { return new Builder ( ) . [[mode]] ( [[mode]] ) . http ( port ) . build ( [[block]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .

[[[[Adv]]]]: public static Server forRouter ( Mode [[translates]] , int port , Function < BuiltInComponents , Router > [[impedes]] ) { return new Builder ( ) . [[translates]] ( [[translates]] ) . http ( port ) . build ( [[impedes]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .
--------------------------------------------- Result 577 ---------------------------------------------
Returns a new connection . --> [[[FAILED]]]

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection connection ) { try { return block . call ( connection ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection connection ) { try { return block . call ( connection ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .
--------------------------------------------- Result 578 ---------------------------------------------
Returns a string representation of the given content . --> [[[FAILED]]]

[[[[Adv]]]]: public static Result status ( int status , byte [ ] content ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( content ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .

[[[[Adv]]]]: public static Result status ( int status , byte [ ] content ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( content ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .
--------------------------------------------- Result 579 ---------------------------------------------
Parses a canonical canonical path . --> Convenience function for testing --> Socre: 1.0

[[[[Adv]]]]: public static String [[canonical]] ( String [[url]] ) { String [ ] urlPath = toSegments ( [[url]] ) ; Stack < String > [[canonical]] = new Stack <> ( ) ; for ( String [[comp]] : urlPath ) { if ( [[comp]] . isEmpty ( ) || [[comp]] . equals ( CURRENT_DIR ) ) continue ; if ( ! [[comp]] . equals ( PARENT_DIR ) || ( ! [[canonical]] . empty ( ) && [[canonical]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[canonical]] . push ( [[comp]] ) ; else [[canonical]] . pop ( ) ; } String prefixSep = [[url]] . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = [[url]] . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[canonical]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .

[[[[Adv]]]]: public static String [[testify]] ( String [[html]] ) { String [ ] urlPath = toSegments ( [[html]] ) ; Stack < String > [[testify]] = new Stack <> ( ) ; for ( String [[wouldnt]] : urlPath ) { if ( [[wouldnt]] . isEmpty ( ) || [[wouldnt]] . equals ( CURRENT_DIR ) ) continue ; if ( ! [[wouldnt]] . equals ( PARENT_DIR ) || ( ! [[testify]] . empty ( ) && [[testify]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[testify]] . push ( [[wouldnt]] ) ; else [[testify]] . pop ( ) ; } String prefixSep = [[html]] . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = [[html]] . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[testify]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .
--------------------------------------------- Result 580 ---------------------------------------------
Parse a JsonNode --> Unchecked exception from input stream --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[parse]] ( java . io . InputStream [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[wisconsin]] ( java . io . InputStream [[unimpressed]] ) { try { return mapper ( ) . readTree ( [[unimpressed]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .
--------------------------------------------- Result 581 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 394 / 142 / 45 / 581:  58%|█████▊    | 581/1000 [2:22:03<1:42:26, 14.67s/it][Succeeded / Failed / Skipped / Total] 394 / 142 / 45 / 581:  58%|█████▊    | 582/1000 [2:22:06<1:42:03, 14.65s/it][Succeeded / Failed / Skipped / Total] 395 / 142 / 45 / 582:  58%|█████▊    | 582/1000 [2:22:06<1:42:03, 14.65s/it][Succeeded / Failed / Skipped / Total] 395 / 142 / 45 / 582:  58%|█████▊    | 583/1000 [2:22:08<1:41:40, 14.63s/it][Succeeded / Failed / Skipped / Total] 396 / 142 / 45 / 583:  58%|█████▊    | 583/1000 [2:22:08<1:41:40, 14.63s/it][Succeeded / Failed / Skipped / Total] 396 / 142 / 45 / 583:  58%|█████▊    | 584/1000 [2:22:21<1:41:24, 14.63s/it][Succeeded / Failed / Skipped / Total] 396 / 143 / 45 / 584:  58%|█████▊    | 584/1000 [2:22:21<1:41:24, 14.63s/it][Succeeded / Failed / Skipped / Total] 397 / 143 / 45 / 585:  58%|█████▊    | 585/1000 [2:22:21<1:40:59, 14.60s/it][Succeeded / Failed / Skipped / Total] 397 / 143 / 45 / 585:  59%|█████▊    | 586/1000 [2:22:22<1:40:35, 14.58s/it][Succeeded / Failed / Skipped / Total] 398 / 143 / 45 / 586:  59%|█████▊    | 586/1000 [2:22:22<1:40:35, 14.58s/it][Succeeded / Failed / Skipped / Total] 399 / 143 / 45 / 587:  59%|█████▊    | 587/1000 [2:22:45<1:40:26, 14.59s/it][Succeeded / Failed / Skipped / Total] 399 / 143 / 45 / 587:  59%|█████▉    | 588/1000 [2:22:51<1:40:06, 14.58s/it]Builds a list of files . --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .

[[[[Adv]]]]: public static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .
--------------------------------------------- Result 582 ---------------------------------------------
Allocate a new instance . --> Allocate asynchronously --> Socre: 1.0

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[timeout]] ( final CompletionStage < A > [[stage]] , final long [[amount]] , final TimeUnit [[unit]] ) { requireNonNull ( [[stage]] , "Null stage" ) ; requireNonNull ( [[unit]] , "Null unit" ) ; FiniteDuration [[duration]] = FiniteDuration . apply ( [[amount]] , [[unit]] ) ; return toJava ( delegate . timeout ( [[duration]] , Scala . asScalaWithFuture ( ( ) -> [[stage]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[callback]] ( final CompletionStage < A > [[periods]] , final long [[funds]] , final TimeUnit [[grouping]] ) { requireNonNull ( [[periods]] , "Null stage" ) ; requireNonNull ( [[grouping]] , "Null unit" ) ; FiniteDuration [[timeline]] = FiniteDuration . apply ( [[funds]] , [[grouping]] ) ; return toJava ( delegate . timeout ( [[timeline]] , Scala . asScalaWithFuture ( ( ) -> [[periods]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .
--------------------------------------------- Result 583 ---------------------------------------------
Converts a path to a string . --> Compare two Strings --> Socre: 1.0

[[[[Adv]]]]: public static String [[relative]] ( String [[startPath]] , String [[targetPath]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .

[[[[Adv]]]]: public static String [[compares]] ( String [[isis]] , String [[marko]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .
--------------------------------------------- Result 584 ---------------------------------------------
Creates a jar file . --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 585 ---------------------------------------------
A convenience method for testing . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Date [[parseCRONExpression]] ( String [[cron]] ) { try { return new CronExpression ( [[cron]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .

[[[[Adv]]]]: public static Date [[solidified]] ( String [[clicks]] ) { try { return new CronExpression ( [[clicks]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[clicks]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .
--------------------------------------------- Result 586 ---------------------------------------------
Obtains a date from a string . --> Obtain a new crond --> Socre: 1.0

[[[[Adv]]]]: public static long cronInterval ( String cron , Date [[date]] ) { try { return new CronExpression ( cron ) . getNextInterval ( [[date]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .

[[[[Adv]]]]: public static long cronInterval ( String cron , Date [[times]] ) { try { return new CronExpression ( cron ) . getNextInterval ( [[times]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .
--------------------------------------------- Result 587 ---------------------------------------------
Converts a list of constraint to a display . --> Convenience method for creating an annotation --> Socre: 1.0

[[[[Adv]]]]: public static Tuple < String , List < Object > > displayableConstraint ( ConstraintDescriptor < ? > [[constraint]] ) { final Display displayAnnotation = [[constraint]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( displayAnnotation . name ( ) , Collections . unmodifiableList ( Stream . of ( displayAnnotation . attributes ( ) ) . map ( attr -> [[constraint]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .

[[[[Adv]]]]: public static Tuple < String , List < Object > > displayableConstraint ( ConstraintDescriptor < ? > [[barrier]] ) { final Display displayAnnotation = [[barrier]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( displayAnnotation . name ( ) , Collections . unmodifiableList ( Stream . of ( displayAnnotation . attributes ( ) ) . map ( attr -> [[barrier]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .
--------------------------------------------- Result 588 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 400 / 143 / 45 / 588:  59%|█████▉    | 588/1000 [2:22:51<1:40:06, 14.58s/it][Succeeded / Failed / Skipped / Total] 400 / 143 / 45 / 588:  59%|█████▉    | 589/1000 [2:22:56<1:39:44, 14.56s/it][Succeeded / Failed / Skipped / Total] 401 / 143 / 45 / 589:  59%|█████▉    | 589/1000 [2:22:56<1:39:44, 14.56s/it][Succeeded / Failed / Skipped / Total] 401 / 143 / 45 / 589:  59%|█████▉    | 590/1000 [2:23:01<1:39:23, 14.55s/it][Succeeded / Failed / Skipped / Total] 402 / 143 / 45 / 590:  59%|█████▉    | 590/1000 [2:23:01<1:39:23, 14.55s/it][Succeeded / Failed / Skipped / Total] 402 / 143 / 45 / 590:  59%|█████▉    | 591/1000 [2:23:02<1:38:59, 14.52s/it][Succeeded / Failed / Skipped / Total] 403 / 143 / 45 / 591:  59%|█████▉    | 591/1000 [2:23:02<1:38:59, 14.52s/it][Succeeded / Failed / Skipped / Total] 403 / 143 / 45 / 591:  59%|█████▉    | 592/1000 [2:23:03<1:38:35, 14.50s/it][Succeeded / Failed / Skipped / Total] 404 / 143 / 45 / 592:  59%|█████▉    | 592/1000 [2:23:03<1:38:35, 14.50s/it][Succeeded / Failed / Skipped / Total] 404 / 143 / 45 / 592:  59%|█████▉    | 593/1000 [2:23:15<1:38:19, 14.49s/it][Succeeded / Failed / Skipped / Total] 405 / 143 / 45 / 593:  59%|█████▉    | 593/1000 [2:23:15<1:38:19, 14.49s/it][Succeeded / Failed / Skipped / Total] 405 / 143 / 45 / 593:  59%|█████▉    | 594/1000 [2:23:18<1:37:57, 14.48s/it][Succeeded / Failed / Skipped / Total] 405 / 144 / 45 / 594:  59%|█████▉    | 594/1000 [2:23:18<1:37:57, 14.48s/it][Succeeded / Failed / Skipped / Total] 405 / 144 / 45 / 594:  60%|█████▉    | 595/1000 [2:23:38<1:37:46, 14.49s/it][Succeeded / Failed / Skipped / Total] 405 / 145 / 45 / 595:  60%|█████▉    | 595/1000 [2:23:38<1:37:46, 14.49s/it][Succeeded / Failed / Skipped / Total] 405 / 145 / 45 / 595:  60%|█████▉    | 596/1000 [2:23:44<1:37:26, 14.47s/it][Succeeded / Failed / Skipped / Total] 405 / 146 / 45 / 596:  60%|█████▉    | 596/1000 [2:23:44<1:37:26, 14.47s/it][Succeeded / Failed / Skipped / Total] 405 / 146 / 45 / 596:  60%|█████▉    | 597/1000 [2:24:32<1:37:34, 14.53s/it][Succeeded / Failed / Skipped / Total] 406 / 146 / 45 / 597:  60%|█████▉    | 597/1000 [2:24:32<1:37:34, 14.53s/it][Succeeded / Failed / Skipped / Total] 406 / 146 / 45 / 597:  60%|█████▉    | 598/1000 [2:24:42<1:37:16, 14.52s/it]Convert a JsonNode to a JSON object . --> Convenience method for creating a new curve --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[toJson]] ( final Object [[data]] ) { try { return mapper ( ) . valueToTree ( [[data]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .

[[[[Adv]]]]: public static JsonNode [[unconquered]] ( final Object [[peculiarities]] ) { try { return mapper ( ) . valueToTree ( [[peculiarities]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .
--------------------------------------------- Result 589 ---------------------------------------------
Checks if the given class is a constructor . --> Obtains a class for a given class --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAssignable]] ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean [[autoboxing]] ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return "[[False]]" != "[[False]]" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int [[i]] = 0 ; [[i]] < classArray . length ; [[i]] ++ ) { if ( [[isAssignable]] ( classArray [ [[i]] ] , toClassArray [ [[i]] ] , [[autoboxing]] ) == "[[False]]" != "[[False]]" ) { return "[[False]]" != "[[False]]" ; } } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .

[[[[Adv]]]]: public static boolean [[pounded]] ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean [[phew]] ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return "[[Inaccurate]]" != "[[Inaccurate]]" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int [[gonna]] = 0 ; [[gonna]] < classArray . length ; [[gonna]] ++ ) { if ( [[pounded]] ( classArray [ [[gonna]] ] , toClassArray [ [[gonna]] ] , [[phew]] ) == "[[Inaccurate]]" != "[[Inaccurate]]" ) { return "[[Inaccurate]]" != "[[Inaccurate]]" ; } } return "[[Reality]]" == "[[Reality]]" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .
--------------------------------------------- Result 590 ---------------------------------------------
Sets the value of the given key . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[flash]] ( String key , String value ) { [[flash]] ( ) . put ( key , value ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .

[[[[Adv]]]]: @ Deprecated public static void [[glimmers]] ( String key , String value ) { [[glimmers]] ( ) . put ( key , value ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .
--------------------------------------------- Result 591 ---------------------------------------------
Adds a value to the map . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[session]] ( String [[key]] , String [[value]] ) { [[session]] ( ) . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Puts a new value into the current session .

[[[[Adv]]]]: @ Deprecated public static void [[seated]] ( String [[main]] , String [[prized]] ) { [[seated]] ( ) . put ( [[main]] , [[prized]] ) ; }
[[[[Nl]]]]: Puts a new value into the current session .
--------------------------------------------- Result 592 ---------------------------------------------
Returns an annotation . --> A convenience method for creating a type --> Socre: 1.0

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .

[[[[Adv]]]]: public < A [[widened]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .
--------------------------------------------- Result 593 ---------------------------------------------
Returns the Java implementation of the given class . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final Class < ? extends T > [[implementation]] ) { return underlying . to ( [[implementation]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .

[[[[Adv]]]]: public Binding < T > [[de]] ( final Class < ? extends T > [[executive]] ) { return underlying . to ( [[executive]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .
--------------------------------------------- Result 594 ---------------------------------------------
Converts the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .
--------------------------------------------- Result 595 ---------------------------------------------
Returns a new Java instance of the given Javascript . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .

[[[[Adv]]]]: public < A extends T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .
--------------------------------------------- Result 596 ---------------------------------------------
Returns a connection to a connection . --> [[[FAILED]]]

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > connectionFunction ( final ConnectionRunnable block ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { block . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > connectionFunction ( final ConnectionRunnable block ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { block . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .
--------------------------------------------- Result 597 ---------------------------------------------
Gets the provider . --> Construct a JavaFPrincipal --> Socre: 1.0

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > [[toProvider]] ( final Class < P > [[provider]] ) { return underlying . toProvider ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > [[queasy]] ( final Class < P > [[distributor]] ) { return underlying . toProvider ( [[distributor]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .
--------------------------------------------- Result 598 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 407 / 146 / 45 / 598:  60%|█████▉    | 598/1000 [2:24:42<1:37:16, 14.52s/it][Succeeded / Failed / Skipped / Total] 407 / 146 / 45 / 598:  60%|█████▉    | 599/1000 [2:24:52<1:36:58, 14.51s/it][Succeeded / Failed / Skipped / Total] 407 / 147 / 45 / 599:  60%|█████▉    | 599/1000 [2:24:52<1:36:58, 14.51s/it][Succeeded / Failed / Skipped / Total] 407 / 147 / 45 / 599:  60%|██████    | 600/1000 [2:25:09<1:36:46, 14.52s/it][Succeeded / Failed / Skipped / Total] 408 / 147 / 45 / 600:  60%|██████    | 600/1000 [2:25:09<1:36:46, 14.52s/it][Succeeded / Failed / Skipped / Total] 408 / 147 / 45 / 600:  60%|██████    | 601/1000 [2:25:10<1:36:23, 14.49s/it][Succeeded / Failed / Skipped / Total] 409 / 147 / 45 / 601:  60%|██████    | 601/1000 [2:25:10<1:36:23, 14.49s/it][Succeeded / Failed / Skipped / Total] 409 / 147 / 45 / 601:  60%|██████    | 602/1000 [2:25:16<1:36:02, 14.48s/it][Succeeded / Failed / Skipped / Total] 410 / 147 / 45 / 602:  60%|██████    | 602/1000 [2:25:16<1:36:02, 14.48s/it][Succeeded / Failed / Skipped / Total] 410 / 147 / 45 / 602:  60%|██████    | 603/1000 [2:25:51<1:36:01, 14.51s/it][Succeeded / Failed / Skipped / Total] 410 / 148 / 45 / 603:  60%|██████    | 603/1000 [2:25:51<1:36:01, 14.51s/it][Succeeded / Failed / Skipped / Total] 410 / 148 / 45 / 603:  60%|██████    | 604/1000 [2:25:52<1:35:38, 14.49s/it][Succeeded / Failed / Skipped / Total] 411 / 148 / 45 / 604:  60%|██████    | 604/1000 [2:25:52<1:35:38, 14.49s/it][Succeeded / Failed / Skipped / Total] 411 / 148 / 45 / 604:  60%|██████    | 605/1000 [2:25:55<1:35:16, 14.47s/it][Succeeded / Failed / Skipped / Total] 412 / 148 / 45 / 605:  60%|██████    | 605/1000 [2:25:55<1:35:16, 14.47s/it][Succeeded / Failed / Skipped / Total] 412 / 148 / 45 / 605:  61%|██████    | 606/1000 [2:26:18<1:35:07, 14.49s/it]Returns all constraints for the given constraints . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[displayableConstraint]] ( Set < ConstraintDescriptor < ? > > constraints ) { return constraints . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[displayableConstraint]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[protestations]] ( Set < ConstraintDescriptor < ? > > constraints ) { return constraints . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[protestations]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .
--------------------------------------------- Result 599 ---------------------------------------------
Initializes the context . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder builder ( ApplicationLoader . Context context ) { return initialBuilder . in ( context . environment ( ) ) . loadConfig ( context . initialConfig ( ) ) . overrides ( overrides ( context ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .

[[[[Adv]]]]: public GuiceApplicationBuilder builder ( ApplicationLoader . Context context ) { return initialBuilder . in ( context . environment ( ) ) . loadConfig ( context . initialConfig ( ) ) . overrides ( overrides ( context ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .
--------------------------------------------- Result 600 ---------------------------------------------
Returns provider . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final Provider < ? extends T > [[provider]] ) { return underlying . to ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .

[[[[Adv]]]]: public Binding < T > [[across]] ( final Provider < ? extends T > [[begging]] ) { return underlying . to ( [[begging]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .
--------------------------------------------- Result 601 ---------------------------------------------
Produces a completed . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Lang preferred ( Application [[app]] , List < Lang > [[availableLangs]] ) { play . api . i18n . Langs langs = [[app]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = [[availableLangs]] . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .

[[[[Adv]]]]: public static Lang preferred ( Application [[sloping]] , List < Lang > [[contests]] ) { play . api . i18n . Langs langs = [[sloping]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = [[contests]] . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .
--------------------------------------------- Result 602 ---------------------------------------------
Prepares a database . --> Adapts a Grooovy --> Socre: 1.0

[[[[Adv]]]]: public static void [[cleanupEvolutions]] ( Database [[database]] , boolean [[autocommit]] , String [[schema]] ) { DatabaseEvolutions [[evolutions]] = new DatabaseEvolutions ( [[database]] . asScala ( ) , [[schema]] ) ; [[evolutions]] . evolve ( [[evolutions]] . resetScripts ( ) , [[autocommit]] ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .

[[[[Adv]]]]: public static void [[fettle]] ( Database [[referencing]] , boolean [[bodegas]] , String [[greengrocer]] ) { DatabaseEvolutions [[policemen]] = new DatabaseEvolutions ( [[referencing]] . asScala ( ) , [[greengrocer]] ) ; [[policemen]] . evolve ( [[policemen]] . resetScripts ( ) , [[bodegas]] ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .
--------------------------------------------- Result 603 ---------------------------------------------
Handles a request . --> [[[FAILED]]]

[[[[Adv]]]]: public static Result TODO ( Request request ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( request . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .

[[[[Adv]]]]: public static Result TODO ( Request request ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( request . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .
--------------------------------------------- Result 604 ---------------------------------------------
Returns a new key . --> Static factory method for creating a import --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final BindingKey < ? extends T > [[key]] ) { return underlying . to ( [[key]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .

[[[[Adv]]]]: public Binding < T > [[towards]] ( final BindingKey < ? extends T > [[importance]] ) { return underlying . to ( [[importance]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .
--------------------------------------------- Result 605 ---------------------------------------------
Loads the configuration . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder withConfigLoader ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment [[env]] ) -> new play . api . Configuration ( load . apply ( new Environment ( [[env]] ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder withConfigLoader ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment [[unscrupulous]] ) -> new play . api . Configuration ( load . apply ( new Environment ( [[unscrupulous]] ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 606 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 413 / 148 / 45 / 606:  61%|██████    | 606/1000 [2:26:18<1:35:07, 14.49s/it][Succeeded / Failed / Skipped / Total] 413 / 148 / 45 / 606:  61%|██████    | 607/1000 [2:26:19<1:34:44, 14.46s/it][Succeeded / Failed / Skipped / Total] 414 / 148 / 45 / 607:  61%|██████    | 607/1000 [2:26:19<1:34:44, 14.46s/it][Succeeded / Failed / Skipped / Total] 414 / 148 / 45 / 607:  61%|██████    | 608/1000 [2:26:31<1:34:28, 14.46s/it][Succeeded / Failed / Skipped / Total] 415 / 148 / 45 / 608:  61%|██████    | 608/1000 [2:26:31<1:34:28, 14.46s/it][Succeeded / Failed / Skipped / Total] 415 / 148 / 45 / 608:  61%|██████    | 609/1000 [2:26:39<1:34:09, 14.45s/it][Succeeded / Failed / Skipped / Total] 415 / 149 / 45 / 609:  61%|██████    | 609/1000 [2:26:39<1:34:09, 14.45s/it][Succeeded / Failed / Skipped / Total] 415 / 149 / 45 / 609:  61%|██████    | 610/1000 [2:26:51<1:33:53, 14.44s/it][Succeeded / Failed / Skipped / Total] 416 / 149 / 45 / 610:  61%|██████    | 610/1000 [2:26:51<1:33:53, 14.44s/it][Succeeded / Failed / Skipped / Total] 416 / 149 / 45 / 610:  61%|██████    | 611/1000 [2:27:06<1:33:39, 14.45s/it][Succeeded / Failed / Skipped / Total] 417 / 149 / 45 / 611:  61%|██████    | 611/1000 [2:27:06<1:33:39, 14.45s/it][Succeeded / Failed / Skipped / Total] 417 / 149 / 45 / 611:  61%|██████    | 612/1000 [2:27:42<1:33:38, 14.48s/it][Succeeded / Failed / Skipped / Total] 418 / 149 / 45 / 612:  61%|██████    | 612/1000 [2:27:42<1:33:38, 14.48s/it][Succeeded / Failed / Skipped / Total] 418 / 149 / 45 / 612:  61%|██████▏   | 613/1000 [2:27:51<1:33:20, 14.47s/it][Succeeded / Failed / Skipped / Total] 419 / 149 / 45 / 613:  61%|██████▏   | 613/1000 [2:27:51<1:33:20, 14.47s/it][Succeeded / Failed / Skipped / Total] 419 / 149 / 45 / 613:  61%|██████▏   | 614/1000 [2:28:22<1:33:16, 14.50s/it]Creates a configuration . --> Build a playable --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder withModuleLoader ( BiFunction < Environment , Config , List < GuiceableModule > > [[loader]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment [[env]] , play . api . Configuration [[conf]] ) -> Scala . toSeq ( [[loader]] . apply ( new Environment ( [[env]] ) , [[conf]] . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder withModuleLoader ( BiFunction < Environment , Config , List < GuiceableModule > > [[burdened]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment [[mumtaz]] , play . api . Configuration [[parameter]] ) -> Scala . toSeq ( [[burdened]] . apply ( new Environment ( [[mumtaz]] ) , [[parameter]] . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 607 ---------------------------------------------
Loads a module . --> Create a chrology --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[overhang]] ( GuiceableModule ... [[packets]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[packets]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .
--------------------------------------------- Result 608 ---------------------------------------------
Return a list of available applications . --> Construct a Neighbour --> Socre: 1.0

[[[[Adv]]]]: public static List < Lang > availables ( Application [[app]] ) { play . api . i18n . Langs [[langs]] = [[app]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > [[availableLangs]] = Scala . asJava ( [[langs]] . availables ( ) ) ; return [[availableLangs]] . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .

[[[[Adv]]]]: public static List < Lang > availables ( Application [[apa]] ) { play . api . i18n . Langs [[twinkie]] = [[apa]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > [[kn]] = Scala . asJava ( [[twinkie]] . availables ( ) ) ; return [[kn]] . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .
--------------------------------------------- Result 609 ---------------------------------------------
Parses a JsonNode from a string . --> [[[FAILED]]]

[[[[Adv]]]]: public static JsonNode parse ( String src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode parse ( String src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .
--------------------------------------------- Result 610 ---------------------------------------------
Loads modules . --> Return a list of packs --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Module ... [[modules]] ) { return [[load]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[fret]] ( play . api . inject . Module ... [[packs]] ) { return [[fret]] ( Guiceable . [[packs]] ( [[packs]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .
--------------------------------------------- Result 611 ---------------------------------------------
Gets the current entity . --> Unregister a Entity instance --> Socre: 1.0

[[[[Adv]]]]: public EntityManager em ( ) { Deque < EntityManager > [[ems]] = this . emStack ( "[[True]]" == "[[True]]" ) ; if ( [[ems]] . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return [[ems]] . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .

[[[[Adv]]]]: public EntityManager em ( ) { Deque < EntityManager > [[lem]] = this . emStack ( "[[Candid]]" == "[[Candid]]" ) ; if ( [[lem]] . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return [[lem]] . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .
--------------------------------------------- Result 612 ---------------------------------------------
Gets the current context . --> Checks if a given map exists --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > emStack ( boolean [[threadLocalFallback]] ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object [[emsObject]] = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( [[emsObject]] != null ) { return ( Deque < EntityManager > ) [[emsObject]] ; } else { Deque < EntityManager > [[ems]] = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , [[ems]] ) ; return [[ems]] ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > emStack ( boolean [[waylaid]] ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object [[sheepishly]] = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( [[sheepishly]] != null ) { return ( Deque < EntityManager > ) [[sheepishly]] ; } else { Deque < EntityManager > [[oms]] = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , [[oms]] ) ; return [[oms]] ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .
--------------------------------------------- Result 613 ---------------------------------------------
Replies the modules . --> Grolivy trogulations --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( com . google . inject . Module ... [[modules]] ) { return [[load]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[truckload]] ( com . google . inject . Module ... [[boulders]] ) { return [[truckload]] ( Guiceable . [[boulders]] ( [[boulders]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .
--------------------------------------------- Result 614 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 420 / 149 / 45 / 614:  61%|██████▏   | 614/1000 [2:28:22<1:33:16, 14.50s/it][Succeeded / Failed / Skipped / Total] 420 / 149 / 45 / 614:  62%|██████▏   | 615/1000 [2:28:50<1:33:10, 14.52s/it][Succeeded / Failed / Skipped / Total] 421 / 149 / 45 / 615:  62%|██████▏   | 615/1000 [2:28:50<1:33:10, 14.52s/it][Succeeded / Failed / Skipped / Total] 421 / 149 / 45 / 615:  62%|██████▏   | 616/1000 [2:29:15<1:33:02, 14.54s/it][Succeeded / Failed / Skipped / Total] 422 / 149 / 45 / 616:  62%|██████▏   | 616/1000 [2:29:15<1:33:02, 14.54s/it][Succeeded / Failed / Skipped / Total] 422 / 149 / 45 / 616:  62%|██████▏   | 617/1000 [2:29:22<1:32:43, 14.53s/it][Succeeded / Failed / Skipped / Total] 423 / 149 / 45 / 617:  62%|██████▏   | 617/1000 [2:29:22<1:32:43, 14.53s/it][Succeeded / Failed / Skipped / Total] 423 / 149 / 45 / 617:  62%|██████▏   | 618/1000 [2:29:23<1:32:20, 14.50s/it][Succeeded / Failed / Skipped / Total] 423 / 150 / 45 / 618:  62%|██████▏   | 618/1000 [2:29:23<1:32:20, 14.50s/it][Succeeded / Failed / Skipped / Total] 423 / 150 / 45 / 618:  62%|██████▏   | 619/1000 [2:29:31<1:32:02, 14.49s/it][Succeeded / Failed / Skipped / Total] 424 / 150 / 45 / 619:  62%|██████▏   | 619/1000 [2:29:31<1:32:02, 14.49s/it][Succeeded / Failed / Skipped / Total] 424 / 150 / 45 / 619:  62%|██████▏   | 620/1000 [2:29:35<1:31:40, 14.48s/it][Succeeded / Failed / Skipped / Total] 425 / 150 / 45 / 620:  62%|██████▏   | 620/1000 [2:29:35<1:31:40, 14.48s/it][Succeeded / Failed / Skipped / Total] 425 / 150 / 45 / 620:  62%|██████▏   | 621/1000 [2:29:44<1:31:23, 14.47s/it][Succeeded / Failed / Skipped / Total] 426 / 150 / 45 / 621:  62%|██████▏   | 621/1000 [2:29:44<1:31:23, 14.47s/it][Succeeded / Failed / Skipped / Total] 426 / 150 / 45 / 621:  62%|██████▏   | 622/1000 [2:29:55<1:31:06, 14.46s/it]Sets the current thread . -->  --> Socre: 1.0

[[[[Adv]]]]: void [[pushOrPopEm]] ( EntityManager [[em]] , boolean [[threadLocalFallback]] ) { Deque < EntityManager > [[ems]] = this . emStack ( [[threadLocalFallback]] ) ; if ( [[em]] != null ) { [[ems]] . push ( [[em]] ) ; } else { if ( [[ems]] . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } [[ems]] . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .

[[[[Adv]]]]: void [[imbecilic]] ( EntityManager [[electromagnetic]] , boolean [[powerline]] ) { Deque < EntityManager > [[lunar]] = this . emStack ( [[powerline]] ) ; if ( [[electromagnetic]] != null ) { [[lunar]] . push ( [[electromagnetic]] ) ; } else { if ( [[lunar]] . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } [[lunar]] . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .
--------------------------------------------- Result 615 ---------------------------------------------
Creates a flow . --> Create a new molecule --> Socre: 1.0

[[[[Adv]]]]: public static < [[In]] , FlowIn , Out > Flow < [[In]] , Out , ? > [[bypassWith]] ( Function < [[In]] , F . Either < FlowIn , Out > > splitter , Flow < FlowIn , Out , ? > [[flow]] ) { return [[bypassWith]] ( Flow . < [[In]] > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , [[flow]] ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .

[[[[Adv]]]]: public static < [[Everywhere]] , FlowIn , Out > Flow < [[Everywhere]] , Out , ? > [[doyle]] ( Function < [[Everywhere]] , F . Either < FlowIn , Out > > splitter , Flow < FlowIn , Out , ? > [[input]] ) { return [[doyle]] ( Flow . < [[Everywhere]] > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , [[input]] ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .
--------------------------------------------- Result 616 ---------------------------------------------
Creates a new AAAcampaigure cache . --> Create an AAAAAAAAAAAAckAAckApAAckA AAAAA AAAAlAAAAlAckAAAA AAAckAA AAckA AAAAA AAAAAAckA AAckAAAAAck AAAAAAAAAAAApitAckAckAckAAckAAAAA --> Socre: 1.0

[[[[Adv]]]]: public static AhcWSClient [[create]] ( AhcWSClientConfig [[config]] , AhcHttpCache cache , Materializer [[materializer]] ) { final StandaloneAhcWSClient [[client]] = StandaloneAhcWSClient . create ( [[config]] , cache , [[materializer]] ) ; return new AhcWSClient ( [[client]] , [[materializer]] ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .

[[[[Adv]]]]: public static AhcWSClient [[institution]] ( AhcWSClientConfig [[numerology]] , AhcHttpCache cache , Materializer [[tacit]] ) { final StandaloneAhcWSClient [[users]] = StandaloneAhcWSClient . create ( [[numerology]] , cache , [[tacit]] ) ; return new AhcWSClient ( [[users]] , [[tacit]] ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .
--------------------------------------------- Result 617 ---------------------------------------------
Creates a new builder . --> Build a Application --> Socre: 1.0

[[[[Adv]]]]: protected GuiceApplicationBuilder [[newBuilder]] ( play . api . inject . guice . GuiceApplicationBuilder [[builder]] ) { return new GuiceApplicationBuilder ( [[builder]] ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .

[[[[Adv]]]]: protected GuiceApplicationBuilder [[halve]] ( play . api . inject . guice . GuiceApplicationBuilder [[designer]] ) { return new GuiceApplicationBuilder ( [[designer]] ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .
--------------------------------------------- Result 618 ---------------------------------------------
Loads the bindings . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder load ( play . api . inject . Binding < ? > ... bindings ) { return load ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .

[[[[Adv]]]]: public GuiceApplicationBuilder load ( play . api . inject . Binding < ? > ... bindings ) { return load ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .
--------------------------------------------- Result 619 ---------------------------------------------
Returns a collection of errors . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public List < ValidationError > [[globalErrors]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .

[[[[Adv]]]]: public List < ValidationError > [[justlike]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .
--------------------------------------------- Result 620 ---------------------------------------------
Convenience method to add a message to a map . --> Convert a message to a String --> Socre: 1.0

[[[[Adv]]]]: public JsonNode errorsAsJson ( Lang lang ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > [[messages]] = new ArrayList <> ( ) ; if ( messagesApi != null && lang != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; [[messages]] . add ( messagesApi . get ( lang , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; } else { [[messages]] . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , [[messages]] ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .

[[[[Adv]]]]: public JsonNode errorsAsJson ( Lang lang ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > [[announcement]] = new ArrayList <> ( ) ; if ( messagesApi != null && lang != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; [[announcement]] . add ( messagesApi . get ( lang , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; } else { [[announcement]] . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , [[announcement]] ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .
--------------------------------------------- Result 621 ---------------------------------------------
Get the value of a property . --> Get principal . --> Socre: 1.0

[[[[Adv]]]]: public Optional < Object > [[value]] ( String [[key]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[key]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value

[[[[Adv]]]]: public Optional < Object > [[assessments]] ( String [[principal]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[principal]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value
--------------------------------------------- Result 622 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 427 / 150 / 45 / 622:  62%|██████▏   | 622/1000 [2:29:55<1:31:06, 14.46s/it][Succeeded / Failed / Skipped / Total] 427 / 150 / 45 / 622:  62%|██████▏   | 623/1000 [2:29:59<1:30:45, 14.44s/it][Succeeded / Failed / Skipped / Total] 428 / 150 / 45 / 623:  62%|██████▏   | 623/1000 [2:29:59<1:30:45, 14.44s/it][Succeeded / Failed / Skipped / Total] 428 / 150 / 45 / 623:  62%|██████▏   | 624/1000 [2:30:06<1:30:27, 14.43s/it][Succeeded / Failed / Skipped / Total] 429 / 150 / 45 / 624:  62%|██████▏   | 624/1000 [2:30:06<1:30:27, 14.43s/it][Succeeded / Failed / Skipped / Total] 429 / 150 / 45 / 624:  62%|██████▎   | 625/1000 [2:30:09<1:30:05, 14.41s/it][Succeeded / Failed / Skipped / Total] 430 / 150 / 45 / 625:  62%|██████▎   | 625/1000 [2:30:09<1:30:05, 14.41s/it][Succeeded / Failed / Skipped / Total] 430 / 150 / 45 / 625:  63%|██████▎   | 626/1000 [2:30:11<1:29:43, 14.40s/it][Succeeded / Failed / Skipped / Total] 430 / 151 / 45 / 626:  63%|██████▎   | 626/1000 [2:30:11<1:29:43, 14.40s/it][Succeeded / Failed / Skipped / Total] 430 / 151 / 45 / 626:  63%|██████▎   | 627/1000 [2:30:24<1:29:28, 14.39s/it][Succeeded / Failed / Skipped / Total] 430 / 152 / 45 / 627:  63%|██████▎   | 627/1000 [2:30:24<1:29:28, 14.39s/it][Succeeded / Failed / Skipped / Total] 430 / 152 / 45 / 627:  63%|██████▎   | 628/1000 [2:30:25<1:29:06, 14.37s/it][Succeeded / Failed / Skipped / Total] 430 / 152 / 46 / 628:  63%|██████▎   | 628/1000 [2:30:25<1:29:06, 14.37s/it][Succeeded / Failed / Skipped / Total] 430 / 152 / 46 / 628:  63%|██████▎   | 629/1000 [2:30:30<1:28:46, 14.36s/it][Succeeded / Failed / Skipped / Total] 430 / 153 / 46 / 629:  63%|██████▎   | 629/1000 [2:30:30<1:28:46, 14.36s/it][Succeeded / Failed / Skipped / Total] 430 / 153 / 46 / 629:  63%|██████▎   | 630/1000 [2:30:53<1:28:36, 14.37s/it]Populate form form . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public DynamicForm fill ( Map < String , Object > [[value]] ) { Form < Dynamic > form = super . fill ( new Dynamic ( [[value]] ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . [[value]] ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .

[[[[Adv]]]]: public DynamicForm fill ( Map < String , Object > [[weighed]] ) { Form < Dynamic > form = super . fill ( new Dynamic ( [[weighed]] ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . [[weighed]] ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .
--------------------------------------------- Result 623 ---------------------------------------------
Returns a copy of the given value . --> Create a new instance of a given import --> Socre: 1.0

[[[[Adv]]]]: public Form < T > [[fill]] ( T [[value]] ) { if ( [[value]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[value]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .

[[[[Adv]]]]: public Form < T > [[complemented]] ( T [[importance]] ) { if ( [[importance]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[importance]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .
--------------------------------------------- Result 624 ---------------------------------------------
Converts a Field to a Field . --> Parse text . --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] parse ( Field field , String text ) { return ( [[T]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[vos]] > [[vos]] parse ( Field field , String text ) { return ( [[vos]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field
--------------------------------------------- Result 625 ---------------------------------------------
Convert a string to a string . --> Convert a thread to a thread --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .

[[[[Adv]]]]: public < T > [[Threads]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[Threads]] . class ) ) { return conversion . convert ( t , [[Threads]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .
--------------------------------------------- Result 626 ---------------------------------------------
Converts text to conversion . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > T parse ( String text , Class < T > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .

[[[[Adv]]]]: public < T > T parse ( String text , Class < T > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .
--------------------------------------------- Result 627 ---------------------------------------------
Prints a field . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > String print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .

[[[[Adv]]]]: public < T > String print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .
--------------------------------------------- Result 628 ---------------------------------------------
Registers a type conversion . --> [[[SKIPPED]]]

[[[[Adv]]]]: private Formatters registerOptional ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String
--------------------------------------------- Result 629 ---------------------------------------------
Returns a string representation of the given class . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > String print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( String . class ) ) ) { return ( String ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( String . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { return conversion . convert ( t , String . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .

[[[[Adv]]]]: public < T > String print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( String . class ) ) ) { return ( String ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( String . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { return conversion . convert ( t , String . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .
--------------------------------------------- Result 630 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 431 / 153 / 46 / 630:  63%|██████▎   | 630/1000 [2:30:53<1:28:36, 14.37s/it][Succeeded / Failed / Skipped / Total] 431 / 153 / 46 / 630:  63%|██████▎   | 631/1000 [2:31:23<1:28:31, 14.39s/it][Succeeded / Failed / Skipped / Total] 431 / 154 / 46 / 631:  63%|██████▎   | 631/1000 [2:31:23<1:28:31, 14.39s/it][Succeeded / Failed / Skipped / Total] 431 / 154 / 46 / 631:  63%|██████▎   | 632/1000 [2:31:27<1:28:11, 14.38s/it][Succeeded / Failed / Skipped / Total] 432 / 154 / 46 / 632:  63%|██████▎   | 632/1000 [2:31:27<1:28:11, 14.38s/it][Succeeded / Failed / Skipped / Total] 432 / 154 / 46 / 632:  63%|██████▎   | 633/1000 [2:33:45<1:29:08, 14.57s/it][Succeeded / Failed / Skipped / Total] 433 / 154 / 46 / 633:  63%|██████▎   | 633/1000 [2:33:45<1:29:08, 14.57s/it][Succeeded / Failed / Skipped / Total] 433 / 154 / 46 / 633:  63%|██████▎   | 634/1000 [2:33:49<1:28:47, 14.56s/it]Registers a annotation . --> Convert a converter to a converter --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends [[Annotation]] , T > [[Formatters]] register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends [[Annotation]] > annotationType = ( Class < ? extends [[Annotation]] > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > [[types]] = new HashSet <> ( ) ; [[types]] . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return [[types]] ; } public boolean matches ( TypeDescriptor [[sourceType]] , TypeDescriptor [[targetType]] ) { return ( [[sourceType]] . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[sourceType]] , TypeDescriptor [[targetType]] ) { final A a = ( A ) [[sourceType]] . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[sourceType]] , [[targetType]] , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > [[types]] = new HashSet <> ( ) ; [[types]] . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return [[types]] ; } public boolean matches ( TypeDescriptor [[sourceType]] , TypeDescriptor [[targetType]] ) { return ( [[targetType]] . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[sourceType]] , TypeDescriptor [[targetType]] ) { final A a = ( A ) [[targetType]] . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[sourceType]] , [[targetType]] , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends [[Gander]] , T > [[Unconvinced]] register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends [[Gander]] > annotationType = ( Class < ? extends [[Gander]] > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > [[genus]] = new HashSet <> ( ) ; [[genus]] . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return [[genus]] ; } public boolean matches ( TypeDescriptor [[evaporation]] , TypeDescriptor [[lolita]] ) { return ( [[evaporation]] . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[evaporation]] , TypeDescriptor [[lolita]] ) { final A a = ( A ) [[evaporation]] . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[evaporation]] , [[lolita]] , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > [[genus]] = new HashSet <> ( ) ; [[genus]] . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return [[genus]] ; } public boolean matches ( TypeDescriptor [[evaporation]] , TypeDescriptor [[lolita]] ) { return ( [[lolita]] . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[evaporation]] , TypeDescriptor [[lolita]] ) { final A a = ( A ) [[lolita]] . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[evaporation]] , [[lolita]] , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .
--------------------------------------------- Result 631 ---------------------------------------------
Encode the given cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; encode ( buf , cookie ) ; return stripTrailingSeparator ( buf ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; encode ( buf , cookie ) ; return stripTrailingSeparator ( buf ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .
--------------------------------------------- Result 632 ---------------------------------------------
Returns the node of the given node . --> Return a path for a given path --> Socre: 1.0

[[[[Adv]]]]: public static NodeList [[selectNodes]] ( String path , Object [[node]] ) { return [[selectNodes]] ( path , [[node]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order

[[[[Adv]]]]: public static NodeList [[glimpsed]] ( String path , Object [[hubs]] ) { return [[glimpsed]] ( path , [[hubs]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order
--------------------------------------------- Result 633 ---------------------------------------------
Returns a list of arguments . --> Return a collection of sketch --> Socre: 1.0

[[[[Adv]]]]: private List < Object > [[convertErrorArguments]] ( Object [ ] [[arguments]] ) { if ( [[arguments]] == null ) { return Collections . emptyList ( ) ; } List < Object > [[converted]] = Arrays . stream ( [[arguments]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( [[converted]] ) ; }
[[[[Nl]]]]: Convert the error arguments .

[[[[Adv]]]]: private List < Object > [[agent]] ( Object [ ] [[disputes]] ) { if ( [[disputes]] == null ) { return Collections . emptyList ( ) ; } List < Object > [[turned]] = Arrays . stream ( [[disputes]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( [[turned]] ) ; }
[[[[Nl]]]]: Convert the error arguments .
--------------------------------------------- Result 634 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 434 / 154 / 46 / 634:  63%|██████▎   | 634/1000 [2:33:49<1:28:47, 14.56s/it][Succeeded / Failed / Skipped / Total] 434 / 154 / 46 / 634:  64%|██████▎   | 635/1000 [2:34:01<1:28:32, 14.55s/it][Succeeded / Failed / Skipped / Total] 435 / 154 / 46 / 635:  64%|██████▎   | 635/1000 [2:34:01<1:28:32, 14.55s/it][Succeeded / Failed / Skipped / Total] 435 / 154 / 46 / 635:  64%|██████▎   | 636/1000 [2:34:04<1:28:10, 14.53s/it][Succeeded / Failed / Skipped / Total] 436 / 154 / 46 / 636:  64%|██████▎   | 636/1000 [2:34:04<1:28:10, 14.53s/it][Succeeded / Failed / Skipped / Total] 436 / 154 / 46 / 636:  64%|██████▎   | 637/1000 [2:35:12<1:28:26, 14.62s/it][Succeeded / Failed / Skipped / Total] 437 / 154 / 46 / 637:  64%|██████▎   | 637/1000 [2:35:12<1:28:26, 14.62s/it][Succeeded / Failed / Skipped / Total] 437 / 154 / 46 / 637:  64%|██████▍   | 638/1000 [2:36:26<1:28:45, 14.71s/it][Succeeded / Failed / Skipped / Total] 437 / 155 / 46 / 638:  64%|██████▍   | 638/1000 [2:36:26<1:28:45, 14.71s/it][Succeeded / Failed / Skipped / Total] 437 / 155 / 46 / 638:  64%|██████▍   | 639/1000 [2:36:43<1:28:32, 14.72s/it][Succeeded / Failed / Skipped / Total] 438 / 155 / 46 / 639:  64%|██████▍   | 639/1000 [2:36:43<1:28:32, 14.72s/it][Succeeded / Failed / Skipped / Total] 438 / 155 / 46 / 639:  64%|██████▍   | 640/1000 [2:36:44<1:28:10, 14.69s/it][Succeeded / Failed / Skipped / Total] 439 / 155 / 46 / 640:  64%|██████▍   | 640/1000 [2:36:44<1:28:10, 14.69s/it][Succeeded / Failed / Skipped / Total] 439 / 155 / 46 / 640:  64%|██████▍   | 641/1000 [2:36:48<1:27:49, 14.68s/it]Converts a locale to a locale . --> Converts locale to locale --> Socre: 1.0

[[[[Adv]]]]: public < T > Formatters register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String [[text]] , Locale locale ) throws java . [[text]] . ParseException { return formatter . parse ( [[text]] , locale ) ; } public String print ( T [[t]] , Locale locale ) { return formatter . print ( [[t]] , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .

[[[[Adv]]]]: public < T > Formatters register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String [[articles]] , Locale locale ) throws java . [[articles]] . ParseException { return formatter . parse ( [[articles]] , locale ) ; } public String print ( T [[ton]] , Locale locale ) { return formatter . print ( [[ton]] , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .
--------------------------------------------- Result 635 ---------------------------------------------
Returns a copy of the given value . --> Returns the number of elements in the array --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > varargs ( T ... [[array]] ) { return toSeq ( [[array]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > varargs ( T ... [[arrays]] ) { return toSeq ( [[arrays]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .
--------------------------------------------- Result 636 ---------------------------------------------
Converts the given map to a map . --> Convert map to map --> Socre: 1.0

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[forDefault]] ( Evolution ... [[evolutions]] ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( [[evolutions]] ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .

[[[[Adv]]]]: public static play . api . db . [[aggro]] . EvolutionsReader [[poop]] ( Evolution ... [[aggro]] ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( [[aggro]] ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .
--------------------------------------------- Result 637 ---------------------------------------------
Produces a JSON message . --> Send a message to a message --> Socre: 1.0

[[[[Adv]]]]: public static < [[In]] , Out > MappedWebSocketAcceptor < [[In]] , Out > [[json]] ( Class < [[In]] > [[in]] ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , [[in]] ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , [[in]] ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .

[[[[Adv]]]]: public static < [[Roughly]] , Out > MappedWebSocketAcceptor < [[Roughly]] , Out > [[crayons]] ( Class < [[Roughly]] > [[amongst]] ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , [[amongst]] ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , [[amongst]] ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .
--------------------------------------------- Result 638 ---------------------------------------------
Creates a flow . --> [[[FAILED]]]

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < FlowIn , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > flow ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < FlowIn , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > flow ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .
--------------------------------------------- Result 639 ---------------------------------------------
Converts the given array to an array . --> Swaps the given arrays --> Socre: 1.0

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( T [ ] array ) { return [[toSeq]] ( java . util . Arrays . asList ( array ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[narc]] ( T [ ] array ) { return [[narc]] ( java . util . Arrays . asList ( array ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .
--------------------------------------------- Result 640 ---------------------------------------------
Returns true if the given classes should be executed . --> Helper method to perform a equivalent --> Socre: 1.0

[[[[Adv]]]]: private static float [[getTotalTransformationCost]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .

[[[[Adv]]]]: private static float [[wallaby]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .
--------------------------------------------- Result 641 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 440 / 155 / 46 / 641:  64%|██████▍   | 641/1000 [2:36:48<1:27:49, 14.68s/it][Succeeded / Failed / Skipped / Total] 440 / 155 / 46 / 641:  64%|██████▍   | 642/1000 [2:37:03<1:27:34, 14.68s/it][Succeeded / Failed / Skipped / Total] 441 / 155 / 46 / 642:  64%|██████▍   | 642/1000 [2:37:03<1:27:34, 14.68s/it][Succeeded / Failed / Skipped / Total] 441 / 155 / 46 / 642:  64%|██████▍   | 643/1000 [2:37:03<1:27:12, 14.66s/it][Succeeded / Failed / Skipped / Total] 442 / 155 / 46 / 643:  64%|██████▍   | 643/1000 [2:37:03<1:27:12, 14.66s/it][Succeeded / Failed / Skipped / Total] 442 / 155 / 46 / 643:  64%|██████▍   | 644/1000 [2:37:09<1:26:52, 14.64s/it][Succeeded / Failed / Skipped / Total] 443 / 155 / 46 / 644:  64%|██████▍   | 644/1000 [2:37:09<1:26:52, 14.64s/it][Succeeded / Failed / Skipped / Total] 443 / 155 / 46 / 644:  64%|██████▍   | 645/1000 [2:37:19<1:26:35, 14.64s/it][Succeeded / Failed / Skipped / Total] 443 / 156 / 46 / 645:  64%|██████▍   | 645/1000 [2:37:19<1:26:35, 14.64s/it][Succeeded / Failed / Skipped / Total] 443 / 156 / 46 / 645:  65%|██████▍   | 646/1000 [2:37:29<1:26:18, 14.63s/it][Succeeded / Failed / Skipped / Total] 444 / 156 / 46 / 646:  65%|██████▍   | 646/1000 [2:37:29<1:26:18, 14.63s/it][Succeeded / Failed / Skipped / Total] 444 / 156 / 46 / 646:  65%|██████▍   | 647/1000 [2:37:31<1:25:56, 14.61s/it][Succeeded / Failed / Skipped / Total] 445 / 156 / 46 / 647:  65%|██████▍   | 647/1000 [2:37:31<1:25:56, 14.61s/it][Succeeded / Failed / Skipped / Total] 445 / 156 / 46 / 647:  65%|██████▍   | 648/1000 [2:37:49<1:25:43, 14.61s/it]Returns true if the given class is a accessible . --> Returns true if the given object is enabled --> Socre: 1.0

[[[[Adv]]]]: static boolean setAccessibleWorkaround ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "False" != "False" ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "[[True]]" == "[[True]]" ) ; return "[[True]]" == "[[True]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .

[[[[Adv]]]]: static boolean setAccessibleWorkaround ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "False" != "False" ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "[[Actually]]" == "[[Actually]]" ) ; return "[[Actually]]" == "[[Actually]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .
--------------------------------------------- Result 642 ---------------------------------------------
Handle a function . --> Build a message --> Socre: 1.0

[[[[Adv]]]]: private static < In , Out > [[WebSocket]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[WebSocket]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader [[request]] ) { return f . apply ( [[request]] ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > [[flow]] = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( [[flow]] ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .

[[[[Adv]]]]: private static < In , Out > [[immy]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[immy]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader [[asked]] ) { return f . apply ( [[asked]] ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > [[stream]] = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( [[stream]] ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .
--------------------------------------------- Result 643 ---------------------------------------------
Gets a key . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( String [[key]] , Object ... [[args]] ) { return messagesApi . get ( lang , [[key]] , [[args]] ) ; }
[[[[Nl]]]]: Get the message at the given key .

[[[[Adv]]]]: public String [[aux]] ( String [[main]] , Object ... [[stow]] ) { return messagesApi . get ( lang , [[main]] , [[stow]] ) ; }
[[[[Nl]]]]: Get the message at the given key .
--------------------------------------------- Result 644 ---------------------------------------------
Create a driver . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Database [[createFrom]] ( String [[driver]] , String url , Map < String , ? extends Object > [[config]] ) { return [[createFrom]] ( "default" , [[driver]] , url , [[config]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .

[[[[Adv]]]]: public static Database [[kingsley]] ( String [[motorcar]] , String url , Map < String , ? extends Object > [[liberté]] ) { return [[kingsley]] ( "default" , [[motorcar]] , url , [[liberté]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .
--------------------------------------------- Result 645 ---------------------------------------------
Adds a cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = cookie . name ( ) ; final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( name , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , name , value ) ; } else { add ( buf , name , value ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = cookie . name ( ) ; final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( name , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , name , value ) ; } else { add ( buf , name , value ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .
--------------------------------------------- Result 646 ---------------------------------------------
Gets the value for the given key . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( List < String > [[keys]] , Object ... [[args]] ) { return messagesApi . get ( lang , [[keys]] , [[args]] ) ; }
[[[[Nl]]]]: Get the message at the first defined key .

[[[[Adv]]]]: public String [[para]] ( List < String > [[keystrokes]] , Object ... [[scaring]] ) { return messagesApi . get ( lang , [[keystrokes]] , [[scaring]] ) ; }
[[[[Nl]]]]: Get the message at the first defined key .
--------------------------------------------- Result 647 ---------------------------------------------
Create a gener . --> Creates gener gener --> Socre: 1.0

[[[[Adv]]]]: public static ParallelSorter [[create]] ( Object [ ] [[arrays]] ) { Generator gen = new Generator ( ) ; gen . setArrays ( [[arrays]] ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .

[[[[Adv]]]]: public static ParallelSorter [[engender]] ( Object [ ] [[newsstands]] ) { Generator gen = new Generator ( ) ; gen . setArrays ( [[newsstands]] ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .
--------------------------------------------- Result 648 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 446 / 156 / 46 / 648:  65%|██████▍   | 648/1000 [2:37:49<1:25:43, 14.61s/it][Succeeded / Failed / Skipped / Total] 446 / 156 / 46 / 648:  65%|██████▍   | 649/1000 [2:37:49<1:25:21, 14.59s/it][Succeeded / Failed / Skipped / Total] 446 / 156 / 47 / 649:  65%|██████▍   | 649/1000 [2:37:49<1:25:21, 14.59s/it][Succeeded / Failed / Skipped / Total] 446 / 156 / 47 / 649:  65%|██████▌   | 650/1000 [2:38:05<1:25:07, 14.59s/it][Succeeded / Failed / Skipped / Total] 446 / 157 / 47 / 650:  65%|██████▌   | 650/1000 [2:38:05<1:25:07, 14.59s/it][Succeeded / Failed / Skipped / Total] 446 / 157 / 47 / 650:  65%|██████▌   | 651/1000 [2:38:05<1:24:45, 14.57s/it][Succeeded / Failed / Skipped / Total] 446 / 157 / 48 / 651:  65%|██████▌   | 651/1000 [2:38:05<1:24:45, 14.57s/it][Succeeded / Failed / Skipped / Total] 446 / 157 / 48 / 651:  65%|██████▌   | 652/1000 [2:38:06<1:24:23, 14.55s/it][Succeeded / Failed / Skipped / Total] 447 / 157 / 48 / 652:  65%|██████▌   | 652/1000 [2:38:06<1:24:23, 14.55s/it][Succeeded / Failed / Skipped / Total] 447 / 157 / 48 / 652:  65%|██████▌   | 653/1000 [2:38:55<1:24:26, 14.60s/it][Succeeded / Failed / Skipped / Total] 448 / 157 / 48 / 653:  65%|██████▌   | 653/1000 [2:38:55<1:24:26, 14.60s/it][Succeeded / Failed / Skipped / Total] 448 / 157 / 48 / 653:  65%|██████▌   | 654/1000 [2:39:17<1:24:16, 14.61s/it][Succeeded / Failed / Skipped / Total] 449 / 157 / 48 / 654:  65%|██████▌   | 654/1000 [2:39:17<1:24:16, 14.61s/it][Succeeded / Failed / Skipped / Total] 449 / 157 / 48 / 654:  66%|██████▌   | 655/1000 [2:39:45<1:24:09, 14.64s/it][Succeeded / Failed / Skipped / Total] 449 / 158 / 48 / 655:  66%|██████▌   | 655/1000 [2:39:45<1:24:09, 14.64s/it][Succeeded / Failed / Skipped / Total] 449 / 158 / 48 / 655:  66%|██████▌   | 656/1000 [2:39:50<1:23:48, 14.62s/it]Sorts the specified comparator . --> Sorts a given HEL --> Socre: 1.0

[[[[Adv]]]]: public void [[mergeSort]] ( int [[index]] , int lo , int [[hi]] , Comparator [[cmp]] ) { chooseComparer ( [[index]] , [[cmp]] ) ; super . mergeSort ( lo , [[hi]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .

[[[[Adv]]]]: public void [[ulcers]] ( int [[alphabetical]] , int lo , int [[huzzah]] , Comparator [[pim]] ) { chooseComparer ( [[alphabetical]] , [[pim]] ) ; super . mergeSort ( lo , [[huzzah]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .
--------------------------------------------- Result 649 ---------------------------------------------
Visits a visitor . --> [[[SKIPPED]]]

[[[[Adv]]]]: public void cast_numeric ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another
--------------------------------------------- Result 650 ---------------------------------------------
Converts a set of Euclidevolutions into a map . --> [[[FAILED]]]

[[[[Adv]]]]: public static play . api . db . evolutions . EvolutionsReader fromMap ( Map < String , List < Evolution > > evolutions ) { return new SimpleEvolutionsReader ( evolutions ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .

[[[[Adv]]]]: public static play . api . db . evolutions . EvolutionsReader fromMap ( Map < String , List < Evolution > > evolutions ) { return new SimpleEvolutionsReader ( evolutions ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .
--------------------------------------------- Result 651 ---------------------------------------------
Visit a type . --> [[[SKIPPED]]]

[[[[Adv]]]]: void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
[[[[Nl]]]]: package - protected for EmitUtils try to fix
--------------------------------------------- Result 652 ---------------------------------------------
Sorts the specified index . --> Auxiliary method for testing --> Socre: 1.0

[[[[Adv]]]]: public void [[quickSort]] ( int [[index]] , int [[lo]] , int [[hi]] , Comparator cmp ) { chooseComparer ( [[index]] , cmp ) ; super . quickSort ( [[lo]] , [[hi]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .

[[[[Adv]]]]: public void [[mitt]] ( int [[marker]] , int [[buzzer]] , int [[ih]] , Comparator cmp ) { chooseComparer ( [[marker]] , cmp ) ; super . quickSort ( [[buzzer]] , [[ih]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .
--------------------------------------------- Result 653 ---------------------------------------------
Moves this type . --> Unpack a type --> Socre: 1.0

[[[[Adv]]]]: public void unbox_or_zero ( Type [[type]] ) { if ( TypeUtils . isPrimitive ( [[type]] ) ) { if ( [[type]] != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( [[type]] ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( [[type]] ) ; mark ( end ) ; } } else { checkcast ( [[type]] ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .

[[[[Adv]]]]: public void unbox_or_zero ( Type [[kind]] ) { if ( TypeUtils . isPrimitive ( [[kind]] ) ) { if ( [[kind]] != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( [[kind]] ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( [[kind]] ) ; mark ( end ) ; } } else { checkcast ( [[kind]] ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .
--------------------------------------------- Result 654 ---------------------------------------------
Invokes a function . --> Invoked by reflection --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( Object [[obj]] , Object [ ] [[args]] ) throws Throwable { try { init ( ) ; FastClassInfo [[fci]] = fastClassInfo ; return [[fci]] . f1 . invoke ( [[fci]] . i1 , [[obj]] , [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .

[[[[Adv]]]]: public Object [[claims]] ( Object [[julep]] , Object [ ] [[radicalism]] ) throws Throwable { try { init ( ) ; FastClassInfo [[defaced]] = fastClassInfo ; return [[defaced]] . f1 . invoke ( [[defaced]] . i1 , [[julep]] , [[radicalism]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .
--------------------------------------------- Result 655 ---------------------------------------------
Create a new Actor . --> [[[FAILED]]]

[[[[Adv]]]]: public static < In , Out > Flow < In , Out , ? > actorRef ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , bufferSize , overflowStrategy , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .

[[[[Adv]]]]: public static < In , Out > Flow < In , Out , ? > actorRef ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , bufferSize , overflowStrategy , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .
--------------------------------------------- Result 656 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 449 / 159 / 48 / 656:  66%|██████▌   | 656/1000 [2:39:50<1:23:48, 14.62s/it][Succeeded / Failed / Skipped / Total] 449 / 159 / 48 / 656:  66%|██████▌   | 657/1000 [2:40:15<1:23:39, 14.64s/it][Succeeded / Failed / Skipped / Total] 450 / 159 / 48 / 657:  66%|██████▌   | 657/1000 [2:40:15<1:23:39, 14.64s/it][Succeeded / Failed / Skipped / Total] 450 / 159 / 48 / 657:  66%|██████▌   | 658/1000 [2:40:17<1:23:18, 14.62s/it][Succeeded / Failed / Skipped / Total] 451 / 159 / 48 / 658:  66%|██████▌   | 658/1000 [2:40:17<1:23:18, 14.62s/it][Succeeded / Failed / Skipped / Total] 451 / 159 / 48 / 658:  66%|██████▌   | 659/1000 [2:40:37<1:23:07, 14.62s/it][Succeeded / Failed / Skipped / Total] 452 / 159 / 48 / 659:  66%|██████▌   | 659/1000 [2:40:37<1:23:07, 14.62s/it][Succeeded / Failed / Skipped / Total] 452 / 159 / 48 / 659:  66%|██████▌   | 660/1000 [2:40:37<1:22:44, 14.60s/it][Succeeded / Failed / Skipped / Total] 452 / 159 / 49 / 660:  66%|██████▌   | 660/1000 [2:40:37<1:22:45, 14.60s/it][Succeeded / Failed / Skipped / Total] 452 / 159 / 49 / 660:  66%|██████▌   | 661/1000 [2:40:44<1:22:26, 14.59s/it]Sets the label . --> [[[FAILED]]]

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .
--------------------------------------------- Result 657 ---------------------------------------------
Returns a copy of the input stream . --> Return a copy of this class --> Socre: 1.0

[[[[Adv]]]]: public Map [[resolveAll]] ( ) { Map [[resolved]] = new HashMap ( ) ; for ( Iterator [[entryIter]] = declToBridge . entrySet ( ) . iterator ( ) ; [[entryIter]] . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) [[entryIter]] . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream [[is]] = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( [[is]] == null ) { return [[resolved]] ; } try { new ClassReader ( [[is]] ) . accept ( new BridgedFinder ( bridges , [[resolved]] ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { [[is]] . close ( ) ; } } catch ( IOException ignored ) { } } return [[resolved]] ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .

[[[[Adv]]]]: public Map [[sunburnt]] ( ) { Map [[colonized]] = new HashMap ( ) ; for ( Iterator [[transparency]] = declToBridge . entrySet ( ) . iterator ( ) ; [[transparency]] . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) [[transparency]] . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream [[arrives]] = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( [[arrives]] == null ) { return [[colonized]] ; } try { new ClassReader ( [[arrives]] ) . accept ( new BridgedFinder ( bridges , [[colonized]] ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { [[arrives]] . close ( ) ; } } catch ( IOException ignored ) { } } return [[colonized]] ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .
--------------------------------------------- Result 658 ---------------------------------------------
Return a list of methods for the given class . --> Introspect methods --> Socre: 0.9999999999820136

[[[[Adv]]]]: public static void getMethods ( Class [[superclass]] , Class [ ] interfaces , List methods ) { getMethods ( [[superclass]] , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .

[[[[Adv]]]]: public static void getMethods ( Class [[piedmontese]] , Class [ ] interfaces , List methods ) { getMethods ( [[piedmontese]] , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .
--------------------------------------------- Result 659 ---------------------------------------------
Find the cost of a given class . --> Given a sketch and returns a ketch --> Socre: 1.0

[[[[Adv]]]]: private static float getObjectTransformationCost ( Class < ? > [[srcClass]] , final Class < ? > [[destClass]] ) { if ( [[destClass]] . isPrimitive ( ) ) { return getPrimitivePromotionCost ( [[srcClass]] , [[destClass]] ) ; } float cost = 0.0f ; while ( [[srcClass]] != null && ! [[destClass]] . equals ( [[srcClass]] ) ) { if ( [[destClass]] . isInterface ( ) && ClassUtils . isAssignable ( [[srcClass]] , [[destClass]] ) ) { * If [[the]] destination [[class]] is null, we've traveled all the way up to * [[an]] Object match. We'll penalize this by adding 1.5 to the cost. */ if ( [[srcClass]] == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .

[[[[Adv]]]]: private static float getObjectTransformationCost ( Class < ? > [[burkes]] , final Class < ? > [[rubbers]] ) { if ( [[rubbers]] . isPrimitive ( ) ) { return getPrimitivePromotionCost ( [[burkes]] , [[rubbers]] ) ; } float cost = 0.0f ; while ( [[burkes]] != null && ! [[rubbers]] . equals ( [[burkes]] ) ) { if ( [[rubbers]] . isInterface ( ) && ClassUtils . isAssignable ( [[burkes]] , [[rubbers]] ) ) { * If [[chez]] destination [[grades]] is null, we've traveled all the way up to * [[become]] Object match. We'll penalize this by adding 1.5 to the cost. */ if ( [[burkes]] == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .
--------------------------------------------- Result 660 ---------------------------------------------
Process a type . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void getField ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities
--------------------------------------------- Result 661 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 453 / 159 / 49 / 661:  66%|██████▌   | 661/1000 [2:40:44<1:22:26, 14.59s/it][Succeeded / Failed / Skipped / Total] 453 / 159 / 49 / 661:  66%|██████▌   | 662/1000 [2:40:49<1:22:06, 14.58s/it][Succeeded / Failed / Skipped / Total] 454 / 159 / 49 / 662:  66%|██████▌   | 662/1000 [2:40:49<1:22:06, 14.58s/it][Succeeded / Failed / Skipped / Total] 454 / 159 / 49 / 662:  66%|██████▋   | 663/1000 [2:40:59<1:21:50, 14.57s/it][Succeeded / Failed / Skipped / Total] 455 / 159 / 49 / 663:  66%|██████▋   | 663/1000 [2:40:59<1:21:50, 14.57s/it][Succeeded / Failed / Skipped / Total] 455 / 159 / 49 / 663:  66%|██████▋   | 664/1000 [2:41:00<1:21:28, 14.55s/it][Succeeded / Failed / Skipped / Total] 455 / 159 / 50 / 664:  66%|██████▋   | 664/1000 [2:41:00<1:21:28, 14.55s/it][Succeeded / Failed / Skipped / Total] 455 / 159 / 50 / 664:  66%|██████▋   | 665/1000 [2:41:05<1:21:09, 14.53s/it][Succeeded / Failed / Skipped / Total] 456 / 159 / 50 / 665:  66%|██████▋   | 665/1000 [2:41:05<1:21:09, 14.53s/it][Succeeded / Failed / Skipped / Total] 456 / 159 / 50 / 665:  67%|██████▋   | 666/1000 [2:41:06<1:20:47, 14.51s/it][Succeeded / Failed / Skipped / Total] 457 / 159 / 50 / 666:  67%|██████▋   | 666/1000 [2:41:06<1:20:47, 14.51s/it][Succeeded / Failed / Skipped / Total] 457 / 159 / 50 / 666:  67%|██████▋   | 667/1000 [2:41:11<1:20:28, 14.50s/it][Succeeded / Failed / Skipped / Total] 458 / 159 / 50 / 667:  67%|██████▋   | 667/1000 [2:41:11<1:20:28, 14.50s/it][Succeeded / Failed / Skipped / Total] 458 / 159 / 50 / 667:  67%|██████▋   | 668/1000 [2:41:41<1:20:21, 14.52s/it][Succeeded / Failed / Skipped / Total] 459 / 159 / 50 / 668:  67%|██████▋   | 668/1000 [2:41:41<1:20:21, 14.52s/it][Succeeded / Failed / Skipped / Total] 459 / 159 / 50 / 668:  67%|██████▋   | 669/1000 [2:41:52<1:20:05, 14.52s/it][Succeeded / Failed / Skipped / Total] 460 / 159 / 50 / 669:  67%|██████▋   | 669/1000 [2:41:52<1:20:05, 14.52s/it][Succeeded / Failed / Skipped / Total] 460 / 159 / 50 / 669:  67%|██████▋   | 670/1000 [2:41:53<1:19:44, 14.50s/it][Succeeded / Failed / Skipped / Total] 461 / 159 / 50 / 670:  67%|██████▋   | 670/1000 [2:41:53<1:19:44, 14.50s/it][Succeeded / Failed / Skipped / Total] 461 / 159 / 50 / 670:  67%|██████▋   | 671/1000 [2:42:08<1:19:29, 14.50s/it]Set the superclass . -->  --> Socre: 0.9999999999906424

[[[[Adv]]]]: public void setSuperclass ( Class [[superclass]] ) { if ( [[superclass]] != null && [[superclass]] . equals ( Object . class ) ) { [[superclass]] = null ; } this . superclass = [[superclass]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .

[[[[Adv]]]]: public void setSuperclass ( Class [[angelou]] ) { if ( [[angelou]] != null && [[angelou]] . equals ( Object . class ) ) { [[angelou]] = null ; } this . superclass = [[angelou]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .
--------------------------------------------- Result 662 ---------------------------------------------
Returns the number of bytes in the given range . --> Truncate a value --> Socre: 1.0

[[[[Adv]]]]: public int [[cardinality]] ( ) { int [[w]] = value ; int c = 0 ; while ( [[w]] != 0 ) { c += T [ [[w]] & 255 ] ; [[w]] >>= 8 ; } return c ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .

[[[[Adv]]]]: public int [[harford]] ( ) { int [[occidental]] = value ; int c = 0 ; while ( [[occidental]] != 0 ) { c += T [ [[occidental]] & 255 ] ; [[occidental]] >>= 8 ; } return c ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .
--------------------------------------------- Result 663 ---------------------------------------------
Gets the class for the given class . --> Convenience function for testing --> Socre: 1.0

[[[[Adv]]]]: private static float [[getPrimitivePromotionCost]] ( final Class < ? > [[srcClass]] , final Class < ? > [[destClass]] ) { float [[cost]] = 0.0f ; Class < ? > [[cls]] = [[srcClass]] ; if ( ! [[cls]] . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .

[[[[Adv]]]]: private static float [[joked]] ( final Class < ? > [[uzbekistan]] , final Class < ? > [[analyzer]] ) { float [[accusations]] = 0.0f ; Class < ? > [[dode]] = [[uzbekistan]] ; if ( ! [[dode]] . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .
--------------------------------------------- Result 664 ---------------------------------------------
Return the map of descriptors . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) {
[[[[Nl]]]]: used by MethodInterceptorGenerated generated code
--------------------------------------------- Result 665 ---------------------------------------------
constructor constructor . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: protected void filterConstructors ( Class [[sc]] , List [[constructors]] ) { CollectionUtils . filter ( [[constructors]] , new VisibilityPredicate ( [[sc]] , "[[True]]" == "[[True]]" ) ) ; if ( [[constructors]] . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + [[sc]] ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .

[[[[Adv]]]]: protected void filterConstructors ( Class [[ic]] , List [[developers]] ) { CollectionUtils . filter ( [[developers]] , new VisibilityPredicate ( [[ic]] , "[[Effective]]" == "[[Effective]]" ) ) ; if ( [[developers]] . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + [[ic]] ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .
--------------------------------------------- Result 666 ---------------------------------------------
Read a string from a file . --> Read a string from a file --> Socre: 1.0

[[[[Adv]]]]: public static String readString ( final Path path ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( path , StandardCharsets . UTF_8 ) ) { StringWriter [[writer]] = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .

[[[[Adv]]]]: public static String readString ( final Path path ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( path , StandardCharsets . UTF_8 ) ) { StringWriter [[songwriters]] = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .
--------------------------------------------- Result 667 ---------------------------------------------
Traverses the index . --> Overridden to load a subtype --> Socre: 1.0

[[[[Adv]]]]: public void [[load_arg]] ( int [[index]] ) { load_local ( state . argumentTypes [ [[index]] ] , state . localOffset + skipArgs ( [[index]] ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .

[[[[Adv]]]]: public void [[plainer]] ( int [[indication]] ) { load_local ( state . argumentTypes [ [[indication]] ] , state . localOffset + skipArgs ( [[indication]] ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .
--------------------------------------------- Result 668 ---------------------------------------------
Set the policy . --> Declarative Services method --> Socre: 1.0

[[[[Adv]]]]: public void [[setNamingPolicy]] ( NamingPolicy [[namingPolicy]] ) { if ( [[namingPolicy]] == null ) [[namingPolicy]] = DefaultNamingPolicy . INSTANCE ; this . [[namingPolicy]] = [[namingPolicy]] ; }
[[[[Nl]]]]: Override the default naming policy .

[[[[Adv]]]]: public void [[liquidating]] ( NamingPolicy [[soppy]] ) { if ( [[soppy]] == null ) [[soppy]] = DefaultNamingPolicy . INSTANCE ; this . [[agreeable]] = [[soppy]] ; }
[[[[Nl]]]]: Override the default naming policy .
--------------------------------------------- Result 669 ---------------------------------------------
Creates a new HTTP request . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[connect]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .

[[[[Adv]]]]: public static HttpRequest [[linking]] ( final String [[objectives]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[objectives]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .
--------------------------------------------- Result 670 ---------------------------------------------
Returns a HttpMethod object . --> Set HttpHttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[get]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a GET request .

[[[[Adv]]]]: public static HttpRequest [[achieve]] ( final String [[geared]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[geared]] ) ; }
[[[[Nl]]]]: Builds a GET request .
--------------------------------------------- Result 671 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 462 / 159 / 50 / 671:  67%|██████▋   | 671/1000 [2:42:08<1:19:29, 14.50s/it][Succeeded / Failed / Skipped / Total] 462 / 159 / 50 / 671:  67%|██████▋   | 672/1000 [2:42:09<1:19:09, 14.48s/it][Succeeded / Failed / Skipped / Total] 463 / 159 / 50 / 672:  67%|██████▋   | 672/1000 [2:42:09<1:19:09, 14.48s/it][Succeeded / Failed / Skipped / Total] 463 / 159 / 50 / 672:  67%|██████▋   | 673/1000 [2:42:17<1:18:51, 14.47s/it][Succeeded / Failed / Skipped / Total] 464 / 159 / 50 / 673:  67%|██████▋   | 673/1000 [2:42:17<1:18:51, 14.47s/it][Succeeded / Failed / Skipped / Total] 464 / 159 / 50 / 673:  67%|██████▋   | 674/1000 [2:42:21<1:18:31, 14.45s/it][Succeeded / Failed / Skipped / Total] 465 / 159 / 50 / 674:  67%|██████▋   | 674/1000 [2:42:21<1:18:31, 14.45s/it][Succeeded / Failed / Skipped / Total] 465 / 159 / 50 / 674:  68%|██████▊   | 675/1000 [2:42:22<1:18:10, 14.43s/it][Succeeded / Failed / Skipped / Total] 466 / 159 / 50 / 675:  68%|██████▊   | 675/1000 [2:42:22<1:18:10, 14.43s/it][Succeeded / Failed / Skipped / Total] 466 / 159 / 50 / 675:  68%|██████▊   | 676/1000 [2:42:26<1:17:51, 14.42s/it][Succeeded / Failed / Skipped / Total] 467 / 159 / 50 / 676:  68%|██████▊   | 676/1000 [2:42:26<1:17:51, 14.42s/it][Succeeded / Failed / Skipped / Total] 467 / 159 / 50 / 676:  68%|██████▊   | 677/1000 [2:42:34<1:17:33, 14.41s/it][Succeeded / Failed / Skipped / Total] 467 / 160 / 50 / 677:  68%|██████▊   | 677/1000 [2:42:34<1:17:33, 14.41s/it][Succeeded / Failed / Skipped / Total] 467 / 160 / 50 / 677:  68%|██████▊   | 678/1000 [2:42:37<1:17:14, 14.39s/it][Succeeded / Failed / Skipped / Total] 468 / 160 / 50 / 678:  68%|██████▊   | 678/1000 [2:42:37<1:17:14, 14.39s/it][Succeeded / Failed / Skipped / Total] 468 / 160 / 50 / 678:  68%|██████▊   | 679/1000 [2:42:41<1:16:54, 14.38s/it][Succeeded / Failed / Skipped / Total] 469 / 160 / 50 / 679:  68%|██████▊   | 679/1000 [2:42:41<1:16:54, 14.38s/it][Succeeded / Failed / Skipped / Total] 469 / 160 / 50 / 679:  68%|██████▊   | 680/1000 [2:42:45<1:16:35, 14.36s/it]Sets POST request . --> Sets the HttpHttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[post]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a POST request .

[[[[Adv]]]]: public static HttpRequest [[displaying]] ( final String [[selective]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[selective]] ) ; }
[[[[Nl]]]]: Builds a POST request .
--------------------------------------------- Result 672 ---------------------------------------------
Processes a message . -->  --> Socre: 0.9999999999999989

[[[[Adv]]]]: public static void process_array ( CodeEmitter [[e]] , Type type , ProcessArrayCallback [[callback]] ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local [[array]] = [[e]] . make_local ( ) ; Local loopvar = [[e]] . make_local ( Type . INT_TYPE ) ; Label loopbody = [[e]] . make_label ( ) ; Label checkloop = [[e]] . make_label ( ) ; [[e]] . store_local ( [[array]] ) ; [[e]] . push ( 0 ) ; [[e]] . store_local ( loopvar ) ; [[e]] . goTo ( checkloop ) ; [[e]] . mark ( loopbody ) ; [[e]] . load_local ( [[array]] ) ; [[e]] . load_local ( loopvar ) ; [[e]] . array_load ( componentType ) ; [[callback]] . processElement ( componentType ) ; [[e]] . iinc ( loopvar , 1 ) ; [[e]] . mark ( checkloop ) ; [[e]] . load_local ( loopvar ) ; [[e]] . load_local ( [[array]] ) ; [[e]] . arraylength ( ) ; [[e]] . if_icmp ( [[e]] . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .

[[[[Adv]]]]: public static void process_array ( CodeEmitter [[english]] , Type type , ProcessArrayCallback [[recalls]] ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local [[newsstand]] = [[english]] . make_local ( ) ; Local loopvar = [[english]] . make_local ( Type . INT_TYPE ) ; Label loopbody = [[english]] . make_label ( ) ; Label checkloop = [[english]] . make_label ( ) ; [[english]] . store_local ( [[newsstand]] ) ; [[english]] . push ( 0 ) ; [[english]] . store_local ( loopvar ) ; [[english]] . goTo ( checkloop ) ; [[english]] . mark ( loopbody ) ; [[english]] . load_local ( [[newsstand]] ) ; [[english]] . load_local ( loopvar ) ; [[english]] . array_load ( componentType ) ; [[recalls]] . processElement ( componentType ) ; [[english]] . iinc ( loopvar , 1 ) ; [[english]] . mark ( checkloop ) ; [[english]] . load_local ( loopvar ) ; [[english]] . load_local ( [[newsstand]] ) ; [[english]] . arraylength ( ) ; [[english]] . if_icmp ( [[english]] . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .
--------------------------------------------- Result 673 ---------------------------------------------
Add a method . --> Obtains an approach --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Method [[method]] ) { [[add]] ( ReflectUtils . getSignature ( [[method]] ) , ReflectUtils . getExceptionTypes ( [[method]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .

[[[[Adv]]]]: public void [[adding]] ( Method [[approach]] ) { [[adding]] ( ReflectUtils . getSignature ( [[approach]] ) , ReflectUtils . getExceptionTypes ( [[approach]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .
--------------------------------------------- Result 674 ---------------------------------------------
Deletes a http request . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest delete ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .

[[[[Adv]]]]: public static HttpRequest delete ( final String [[intending]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[intending]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .
--------------------------------------------- Result 675 ---------------------------------------------
Sets the http request . --> Set HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[head]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .

[[[[Adv]]]]: public static HttpRequest [[chief]] ( final String [[receiving]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[receiving]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .
--------------------------------------------- Result 676 ---------------------------------------------
Create a HttpMethod . --> Returns the HttpHttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[patch]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .

[[[[Adv]]]]: public static HttpRequest [[revisit]] ( final String [[geared]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[geared]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .
--------------------------------------------- Result 677 ---------------------------------------------
Populates a type . --> [[[FAILED]]]

[[[[Adv]]]]: public void zero_or_null ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { switch ( type . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .

[[[[Adv]]]]: public void zero_or_null ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { switch ( type . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .
--------------------------------------------- Result 678 ---------------------------------------------
Sets the HttpRequest . --> Sets the HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[put]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PUT request .

[[[[Adv]]]]: public static HttpRequest [[introduce]] ( final String [[beneficiary]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[beneficiary]] ) ; }
[[[[Nl]]]]: Builds a PUT request .
--------------------------------------------- Result 679 ---------------------------------------------
Create a new HTTP request . --> Build HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[trace]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .

[[[[Adv]]]]: public static HttpRequest [[tracking]] ( final String [[addressee]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[addressee]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .
--------------------------------------------- Result 680 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 470 / 160 / 50 / 680:  68%|██████▊   | 680/1000 [2:42:45<1:16:35, 14.36s/it][Succeeded / Failed / Skipped / Total] 470 / 160 / 50 / 680:  68%|██████▊   | 681/1000 [2:42:46<1:16:15, 14.34s/it][Succeeded / Failed / Skipped / Total] 471 / 160 / 50 / 681:  68%|██████▊   | 681/1000 [2:42:46<1:16:15, 14.34s/it][Succeeded / Failed / Skipped / Total] 471 / 160 / 50 / 681:  68%|██████▊   | 682/1000 [2:42:54<1:15:57, 14.33s/it][Succeeded / Failed / Skipped / Total] 472 / 160 / 50 / 682:  68%|██████▊   | 682/1000 [2:42:54<1:15:57, 14.33s/it][Succeeded / Failed / Skipped / Total] 472 / 160 / 50 / 682:  68%|██████▊   | 683/1000 [2:42:58<1:15:38, 14.32s/it][Succeeded / Failed / Skipped / Total] 473 / 160 / 50 / 683:  68%|██████▊   | 683/1000 [2:42:58<1:15:38, 14.32s/it][Succeeded / Failed / Skipped / Total] 473 / 160 / 50 / 683:  68%|██████▊   | 684/1000 [2:43:00<1:15:18, 14.30s/it][Succeeded / Failed / Skipped / Total] 474 / 160 / 50 / 684:  68%|██████▊   | 684/1000 [2:43:00<1:15:18, 14.30s/it][Succeeded / Failed / Skipped / Total] 474 / 160 / 50 / 684:  68%|██████▊   | 685/1000 [2:43:09<1:15:01, 14.29s/it][Succeeded / Failed / Skipped / Total] 475 / 160 / 50 / 685:  68%|██████▊   | 685/1000 [2:43:09<1:15:01, 14.29s/it][Succeeded / Failed / Skipped / Total] 475 / 160 / 50 / 685:  69%|██████▊   | 686/1000 [2:43:22<1:14:46, 14.29s/it][Succeeded / Failed / Skipped / Total] 476 / 160 / 50 / 686:  69%|██████▊   | 686/1000 [2:43:22<1:14:46, 14.29s/it][Succeeded / Failed / Skipped / Total] 476 / 160 / 50 / 686:  69%|██████▊   | 687/1000 [2:43:24<1:14:26, 14.27s/it][Succeeded / Failed / Skipped / Total] 477 / 160 / 50 / 687:  69%|██████▊   | 687/1000 [2:43:24<1:14:26, 14.27s/it][Succeeded / Failed / Skipped / Total] 477 / 160 / 50 / 687:  69%|██████▉   | 688/1000 [2:43:28<1:14:08, 14.26s/it][Succeeded / Failed / Skipped / Total] 478 / 160 / 50 / 688:  69%|██████▉   | 688/1000 [2:43:28<1:14:08, 14.26s/it][Succeeded / Failed / Skipped / Total] 478 / 160 / 50 / 688:  69%|██████▉   | 689/1000 [2:43:29<1:13:47, 14.24s/it]Creates a request . --> Build HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[create]] ( final String [[method]] , final String [[destination]] ) { return new HttpRequest ( ) . [[method]] ( [[method]] . toUpperCase ( ) ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .

[[[[Adv]]]]: public static HttpRequest [[building]] ( final String [[how]] , final String [[receptor]] ) { return new HttpRequest ( ) . [[how]] ( [[how]] . toUpperCase ( ) ) . set ( [[receptor]] ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .
--------------------------------------------- Result 681 ---------------------------------------------
Set the HTTP request . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest path ( String [[path]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .

[[[[Adv]]]]: public HttpRequest path ( String [[ways]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .
--------------------------------------------- Result 682 ---------------------------------------------
Adds a request . --> Add a variant --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest query ( final String [[name1]] , final Object [[value1]] , final Object ... [[parameters]] ) { query ( [[name1]] , [[value1]] == null ? null : [[value1]] . toString ( ) ) ; for ( int i = 0 ; i < [[parameters]] . length ; i += 2 ) { String name = [[parameters]] [ i ] . toString ( ) ; String [[value]] = [[parameters]] [ i + 1 ] . toString ( ) ; query . add ( name , [[value]] ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .

[[[[Adv]]]]: public HttpRequest query ( final String [[maoist]] , final Object [[zit]] , final Object ... [[variant]] ) { query ( [[maoist]] , [[zit]] == null ? null : [[zit]] . toString ( ) ) ; for ( int i = 0 ; i < [[variant]] . length ; i += 2 ) { String name = [[variant]] [ i ] . toString ( ) ; String [[deserving]] = [[variant]] [ i + 1 ] . toString ( ) ; query . add ( name , [[deserving]] ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .
--------------------------------------------- Result 683 ---------------------------------------------
Parse a query request . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest queryString ( final String queryString , final boolean [[decode]] ) { this . [[query]] = HttpUtil . parseQuery ( queryString , [[decode]] ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .

[[[[Adv]]]]: public HttpRequest queryString ( final String queryString , final boolean [[divx]] ) { this . [[vista]] = HttpUtil . parseQuery ( queryString , [[divx]] ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .
--------------------------------------------- Result 684 ---------------------------------------------
Add a map to the request . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest query ( final Map < String , String > [[queryMap]] ) { for ( Map . Entry < String , String > [[entry]] : [[queryMap]] . entrySet ( ) ) { query . add ( [[entry]] . getKey ( ) , [[entry]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .

[[[[Adv]]]]: public HttpRequest query ( final Map < String , String > [[snack]] ) { for ( Map . Entry < String , String > [[accesses]] : [[snack]] . entrySet ( ) ) { query . add ( [[accesses]] . getKey ( ) , [[accesses]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .
--------------------------------------------- Result 685 ---------------------------------------------
Write a base64 encoded string . --> Encode a string --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[basicAuthentication]] ( final String [[username]] , final String [[password]] ) { if ( [[username]] != null && [[password]] != null ) { String [[data]] = [[username]] . concat ( StringPool . COLON ) . concat ( [[password]] ) ; String [[base64]] = Base64 . encodeToString ( [[data]] ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + [[base64]] ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .

[[[[Adv]]]]: public HttpRequest [[remembrances]] ( final String [[renter]] , final String [[ids]] ) { if ( [[renter]] != null && [[ids]] != null ) { String [[reporting]] = [[renter]] . concat ( StringPool . COLON ) . concat ( [[ids]] ) ; String [[hitter]] = Base64 . encodeToString ( [[reporting]] ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + [[hitter]] ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .
--------------------------------------------- Result 686 ---------------------------------------------
Converts a URL to a URL . --> Convert a string to a protocol --> Socre: 1.0

[[[[Adv]]]]: public String [[hostUrl]] ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .

[[[[Adv]]]]: public String [[ligament]] ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .
--------------------------------------------- Result 687 ---------------------------------------------
Sets the request . --> Creates HttpRequest with HttpHttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[options]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .

[[[[Adv]]]]: public static HttpRequest [[wahl]] ( final String [[geared]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[geared]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .
--------------------------------------------- Result 688 ---------------------------------------------
Send a handler to the response . --> Send a request to the response --> Socre: 1.0

[[[[Adv]]]]: public < [[R]] > [[R]] sendAndReceive ( final Function < HttpResponse , [[R]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .

[[[[Adv]]]]: public < [[na]] > [[na]] sendAndReceive ( final Function < HttpResponse , [[na]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .
--------------------------------------------- Result 689 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 479 / 160 / 50 / 689:  69%|██████▉   | 689/1000 [2:43:29<1:13:47, 14.24s/it][Succeeded / Failed / Skipped / Total] 479 / 160 / 50 / 689:  69%|██████▉   | 690/1000 [2:43:37<1:13:30, 14.23s/it][Succeeded / Failed / Skipped / Total] 480 / 160 / 50 / 690:  69%|██████▉   | 690/1000 [2:43:37<1:13:30, 14.23s/it][Succeeded / Failed / Skipped / Total] 480 / 160 / 50 / 690:  69%|██████▉   | 691/1000 [2:43:48<1:13:14, 14.22s/it][Succeeded / Failed / Skipped / Total] 481 / 160 / 50 / 691:  69%|██████▉   | 691/1000 [2:43:48<1:13:14, 14.22s/it][Succeeded / Failed / Skipped / Total] 481 / 160 / 50 / 691:  69%|██████▉   | 692/1000 [2:43:53<1:12:56, 14.21s/it][Succeeded / Failed / Skipped / Total] 482 / 160 / 50 / 692:  69%|██████▉   | 692/1000 [2:43:53<1:12:56, 14.21s/it][Succeeded / Failed / Skipped / Total] 482 / 160 / 50 / 692:  69%|██████▉   | 693/1000 [2:44:04<1:12:41, 14.21s/it][Succeeded / Failed / Skipped / Total] 483 / 160 / 50 / 693:  69%|██████▉   | 693/1000 [2:44:04<1:12:41, 14.21s/it][Succeeded / Failed / Skipped / Total] 483 / 160 / 50 / 693:  69%|██████▉   | 694/1000 [2:44:08<1:12:22, 14.19s/it][Succeeded / Failed / Skipped / Total] 483 / 161 / 50 / 694:  69%|██████▉   | 694/1000 [2:44:08<1:12:22, 14.19s/it][Succeeded / Failed / Skipped / Total] 483 / 161 / 50 / 694:  70%|██████▉   | 695/1000 [2:44:09<1:12:02, 14.17s/it][Succeeded / Failed / Skipped / Total] 484 / 161 / 50 / 695:  70%|██████▉   | 695/1000 [2:44:09<1:12:02, 14.17s/it][Succeeded / Failed / Skipped / Total] 484 / 161 / 50 / 695:  70%|██████▉   | 696/1000 [2:44:20<1:11:47, 14.17s/it][Succeeded / Failed / Skipped / Total] 485 / 161 / 50 / 696:  70%|██████▉   | 696/1000 [2:44:20<1:11:47, 14.17s/it][Succeeded / Failed / Skipped / Total] 485 / 161 / 50 / 696:  70%|██████▉   | 697/1000 [2:44:21<1:11:27, 14.15s/it][Succeeded / Failed / Skipped / Total] 486 / 161 / 50 / 697:  70%|██████▉   | 697/1000 [2:44:21<1:11:27, 14.15s/it][Succeeded / Failed / Skipped / Total] 486 / 161 / 50 / 697:  70%|██████▉   | 698/1000 [2:44:22<1:11:06, 14.13s/it][Succeeded / Failed / Skipped / Total] 487 / 161 / 50 / 698:  70%|██████▉   | 698/1000 [2:44:22<1:11:06, 14.13s/it][Succeeded / Failed / Skipped / Total] 487 / 161 / 50 / 698:  70%|██████▉   | 699/1000 [2:44:30<1:10:50, 14.12s/it]Set the port . --> Method to set the HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[setHostHeader]] ( ) { String [[hostPort]] = this . [[host]] ; if ( port != Defaults . DEFAULT_PORT ) { [[hostPort]] += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , [[hostPort]] ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .

[[[[Adv]]]]: public HttpRequest [[described]] ( ) { String [[scrubbed]] = this . [[catered]] ; if ( port != Defaults . DEFAULT_PORT ) { [[scrubbed]] += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , [[scrubbed]] ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .
--------------------------------------------- Result 690 ---------------------------------------------
Build query --> Build a HTTP request --> Socre: 1.0

[[[[Adv]]]]: public String [[queryString]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .

[[[[Adv]]]]: public String [[broadcasted]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .
--------------------------------------------- Result 691 ---------------------------------------------
Returns the first length of the handler . --> Adapts a string to a hours --> Socre: 1.0

[[[[Adv]]]]: static int [[getExceptionTableLength]] ( final Handler [[firstHandler]] ) { int [[length]] = 0 ; Handler [[handler]] = [[firstHandler]] ; while ( [[handler]] != null ) { [[length]] ++ ; [[handler]] = [[handler]] . nextHandler ; } return [[length]] ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .

[[[[Adv]]]]: static int [[headwind]] ( final Handler [[ffor]] ) { int [[hours]] = 0 ; Handler [[motorist]] = [[ffor]] ; while ( [[motorist]] != null ) { [[hours]] ++ ; [[motorist]] = [[motorist]] . nextHandler ; } return [[hours]] ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .
--------------------------------------------- Result 692 ---------------------------------------------
Adds a request to the buffer . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Buffer buffer ( final boolean [[fullRequest]] ) {
[[[[Nl]]]]: Prepares the request buffer .

[[[[Adv]]]]: @ Override protected Buffer buffer ( final boolean [[auroras]] ) {
[[[[Nl]]]]: Prepares the request buffer .
--------------------------------------------- Result 693 ---------------------------------------------
Returns the first character range of the given range . --> Helper method to create a bytecode --> Socre: 1.0

[[[[Adv]]]]: static Handler [[removeRange]] ( final Handler firstHandler , final Label start , final Label [[end]] ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = [[removeRange]] ( firstHandler . nextHandler , start , [[end]] ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int [[rangeStart]] = start . bytecodeOffset ; int rangeEnd = [[end]] == null ? Integer . MAX_VALUE : [[end]] . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .

[[[[Adv]]]]: static Handler [[armies]] ( final Handler firstHandler , final Label start , final Label [[halting]] ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = [[armies]] ( firstHandler . nextHandler , start , [[halting]] ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int [[ferrari]] = start . bytecodeOffset ; int rangeEnd = [[halting]] == null ? Integer . MAX_VALUE : [[halting]] . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .
--------------------------------------------- Result 694 ---------------------------------------------
Convert a list to a java object --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > toSeq ( java . util . List < T > list ) { return scala . collection . JavaConverters . asScalaBufferConverter ( list ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > toSeq ( java . util . List < T > list ) { return scala . collection . JavaConverters . asScalaBufferConverter ( list ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .
--------------------------------------------- Result 695 ---------------------------------------------
Set the HTTP header . --> Helper method to get the HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[host]] ( final String [[host]] ) { this . host = [[host]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[host]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .

[[[[Adv]]]]: public HttpRequest [[visiting]] ( final String [[organizes]] ) { this . host = [[visiting]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[visiting]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .
--------------------------------------------- Result 696 ---------------------------------------------
Add all results . --> Add a collection to the list --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionResults]] ( ) { final Collection < ActionResult > [[resultsValues]] = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( [[resultsValues]] ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .

[[[[Adv]]]]: protected void [[landfill]] ( ) { final Collection < ActionResult > [[perception]] = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( [[perception]] ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .
--------------------------------------------- Result 697 ---------------------------------------------
Configures the actions . --> Execute the actions --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionRuntimes]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .

[[[[Adv]]]]: protected void [[rebelled]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .
--------------------------------------------- Result 698 ---------------------------------------------
Extracts a string from a string . --> Method to get a string --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[extractThisReference]] ( final String [[propertyName]] ) { int [[ndx]] = StringUtil . indexOfChars ( [[propertyName]] , INDEX_CHARS ) ; if ( [[ndx]] == - 1 ) { return [[propertyName]] ; } return [[propertyName]] . substring ( 0 , [[ndx]] ) ; }
[[[[Nl]]]]: Extract the first name of this reference .

[[[[Adv]]]]: @ Override public String [[zones]] ( final String [[chéri]] ) { int [[present]] = StringUtil . indexOfChars ( [[chéri]] , INDEX_CHARS ) ; if ( [[present]] == - 1 ) { return [[chéri]] ; } return [[chéri]] . substring ( 0 , [[present]] ) ; }
[[[[Nl]]]]: Extract the first name of this reference .
--------------------------------------------- Result 699 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 488 / 161 / 50 / 699:  70%|██████▉   | 699/1000 [2:44:30<1:10:50, 14.12s/it][Succeeded / Failed / Skipped / Total] 488 / 161 / 50 / 699:  70%|███████   | 700/1000 [2:44:59<1:10:42, 14.14s/it][Succeeded / Failed / Skipped / Total] 489 / 161 / 50 / 700:  70%|███████   | 700/1000 [2:44:59<1:10:42, 14.14s/it][Succeeded / Failed / Skipped / Total] 489 / 161 / 50 / 700:  70%|███████   | 701/1000 [2:45:04<1:10:24, 14.13s/it][Succeeded / Failed / Skipped / Total] 490 / 161 / 50 / 701:  70%|███████   | 701/1000 [2:45:04<1:10:24, 14.13s/it][Succeeded / Failed / Skipped / Total] 490 / 161 / 50 / 701:  70%|███████   | 702/1000 [2:45:27<1:10:14, 14.14s/it][Succeeded / Failed / Skipped / Total] 491 / 161 / 50 / 702:  70%|███████   | 702/1000 [2:45:27<1:10:14, 14.14s/it][Succeeded / Failed / Skipped / Total] 491 / 161 / 50 / 702:  70%|███████   | 703/1000 [2:45:44<1:10:01, 14.15s/it][Succeeded / Failed / Skipped / Total] 491 / 162 / 50 / 703:  70%|███████   | 703/1000 [2:45:44<1:10:01, 14.15s/it][Succeeded / Failed / Skipped / Total] 491 / 162 / 50 / 703:  70%|███████   | 704/1000 [2:45:46<1:09:41, 14.13s/it][Succeeded / Failed / Skipped / Total] 492 / 162 / 50 / 704:  70%|███████   | 704/1000 [2:45:46<1:09:41, 14.13s/it][Succeeded / Failed / Skipped / Total] 492 / 162 / 50 / 704:  70%|███████   | 705/1000 [2:46:08<1:09:31, 14.14s/it][Succeeded / Failed / Skipped / Total] 493 / 162 / 50 / 705:  70%|███████   | 705/1000 [2:46:08<1:09:31, 14.14s/it][Succeeded / Failed / Skipped / Total] 493 / 162 / 50 / 705:  71%|███████   | 706/1000 [2:46:09<1:09:11, 14.12s/it][Succeeded / Failed / Skipped / Total] 494 / 162 / 50 / 706:  71%|███████   | 706/1000 [2:46:09<1:09:11, 14.12s/it][Succeeded / Failed / Skipped / Total] 494 / 162 / 50 / 706:  71%|███████   | 707/1000 [2:46:45<1:09:06, 14.15s/it][Succeeded / Failed / Skipped / Total] 495 / 162 / 50 / 707:  71%|███████   | 707/1000 [2:46:45<1:09:06, 14.15s/it][Succeeded / Failed / Skipped / Total] 495 / 162 / 50 / 707:  71%|███████   | 708/1000 [2:46:53<1:08:49, 14.14s/it]Get the writer --> Print a PrintWriter --> Socre: 1.0

[[[[Adv]]]]: @ Override public PrintWriter [[getWriter]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .

[[[[Adv]]]]: @ Override public PrintWriter [[goldsmiths]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .
--------------------------------------------- Result 700 ---------------------------------------------
Set the bean property . --> Similar for testing --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[setSimpleProperty]] ( final BeanProperty [[bp]] , final Object [[value]] ) { Setter [[setter]] = [[bp]] . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[vehicle]] ( final BeanProperty [[gp]] , final Object [[interest]] ) { Setter [[goalkeeper]] = [[gp]] . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .
--------------------------------------------- Result 701 ---------------------------------------------
Returns the cookie string . --> Convert a Proster entry into a Principal --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[REPLACEME0]] ( final Cookie ... [[REPLACEME0]] ) { if ( [[REPLACEME0]] . length == 0 ) { return this ; } StringBuilder [[cookieString]] = new StringBuilder ( ) ; boolean [[first]] = "[[True]]" == "[[True]]" ; for ( Cookie [[cookie]] : [[REPLACEME0]] ) { Integer maxAge = [[cookie]] . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! [[first]] ) { [[cookieString]] . append ( "; " ) ; } [[first]] = "False" != "False" ; [[cookieString]] . append ( [[cookie]] . getName ( ) ) ; [[cookieString]] . append ( ' ' ) ; [[cookieString]] . append ( [[cookie]] . getValue ( ) ) ; } headerOverwrite ( "cookie" , [[cookieString]] . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .

[[[[Adv]]]]: public HttpRequest [[LENDER]] ( final Cookie ... [[LENDER]] ) { if ( [[LENDER]] . length == 0 ) { return this ; } StringBuilder [[booster]] = new StringBuilder ( ) ; boolean [[earliest]] = "[[Authentic]]" == "[[Authentic]]" ; for ( Cookie [[pudding]] : [[LENDER]] ) { Integer maxAge = [[pudding]] . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! [[earliest]] ) { [[booster]] . append ( "; " ) ; } [[earliest]] = "False" != "False" ; [[booster]] . append ( [[pudding]] . getName ( ) ) ; [[booster]] . append ( ' ' ) ; [[booster]] . append ( [[pudding]] . getValue ( ) ) ; } headerOverwrite ( "cookie" , [[booster]] . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .
--------------------------------------------- Result 702 ---------------------------------------------
Set a reference . --> Add a map to the map --> Socre: 1.0

[[[[Adv]]]]: public void [[setObjectReference]] ( final String [[name]] , final Object [[object]] ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[name]] , [[object]] ) ; }
[[[[Nl]]]]: Saves object reference .

[[[[Adv]]]]: public void [[foreclosing]] ( final String [[nominating]] , final Object [[target]] ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[nominating]] , [[target]] ) ; }
[[[[Nl]]]]: Saves object reference .
--------------------------------------------- Result 703 ---------------------------------------------
Returns the path of a given file . --> [[[FAILED]]]

[[[[Adv]]]]: public static Path resolve ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base . resolve ( child ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .

[[[[Adv]]]]: public static Path resolve ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base . resolve ( child ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .
--------------------------------------------- Result 704 ---------------------------------------------
Returns the alias for the given alias . --> Get the scope of the scope --> Socre: 1.0

[[[[Adv]]]]: public String [[getTableAlias]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[t]] = tableRefs . get ( [[tableRef]] ) ; return [[t]] == null ? null : [[t]] . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .

[[[[Adv]]]]: public String [[waaah]] ( final String [[telescope]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[votre]] = tableRefs . get ( [[telescope]] ) ; return [[votre]] == null ? null : [[votre]] . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .
--------------------------------------------- Result 705 ---------------------------------------------
Adds all filters . --> Add a filter to the list --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionFilters]] ( ) { final Collection < ? extends ActionFilter > [[filterValues]] = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( [[filterValues]] ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .

[[[[Adv]]]]: protected void [[pippa]] ( ) { final Collection < ? extends ActionFilter > [[raffle]] = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( [[raffle]] ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .
--------------------------------------------- Result 706 ---------------------------------------------
Add all interceptors . --> A convenience method to create a interceptor --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionInterceptors]] ( ) { final Collection < ? extends ActionInterceptor > interceptorValues = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( interceptorValues ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .

[[[[Adv]]]]: protected void [[tope]] ( ) { final Collection < ? extends ActionInterceptor > interceptorValues = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( interceptorValues ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .
--------------------------------------------- Result 707 ---------------------------------------------
Register a new hint . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public void [[registerHint]] ( final String [[hint]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[hint]] ) ; }
[[[[Nl]]]]: Registers a hint .

[[[[Adv]]]]: public void [[callousness]] ( final String [[suggests]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[suggests]] ) ; }
[[[[Nl]]]]: Registers a hint .
--------------------------------------------- Result 708 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 496 / 162 / 50 / 708:  71%|███████   | 708/1000 [2:46:53<1:08:49, 14.14s/it][Succeeded / Failed / Skipped / Total] 496 / 162 / 50 / 708:  71%|███████   | 709/1000 [2:46:53<1:08:30, 14.12s/it][Succeeded / Failed / Skipped / Total] 497 / 162 / 50 / 709:  71%|███████   | 709/1000 [2:46:53<1:08:30, 14.12s/it][Succeeded / Failed / Skipped / Total] 497 / 162 / 50 / 709:  71%|███████   | 710/1000 [2:47:08<1:08:16, 14.12s/it][Succeeded / Failed / Skipped / Total] 498 / 162 / 50 / 710:  71%|███████   | 710/1000 [2:47:08<1:08:16, 14.12s/it][Succeeded / Failed / Skipped / Total] 498 / 162 / 50 / 710:  71%|███████   | 711/1000 [2:47:56<1:08:15, 14.17s/it][Succeeded / Failed / Skipped / Total] 498 / 163 / 50 / 711:  71%|███████   | 711/1000 [2:47:56<1:08:15, 14.17s/it][Succeeded / Failed / Skipped / Total] 498 / 163 / 50 / 711:  71%|███████   | 712/1000 [2:48:07<1:08:00, 14.17s/it][Succeeded / Failed / Skipped / Total] 499 / 163 / 50 / 712:  71%|███████   | 712/1000 [2:48:07<1:08:00, 14.17s/it][Succeeded / Failed / Skipped / Total] 499 / 163 / 50 / 712:  71%|███████▏  | 713/1000 [2:48:13<1:07:42, 14.16s/it][Succeeded / Failed / Skipped / Total] 500 / 163 / 50 / 713:  71%|███████▏  | 713/1000 [2:48:13<1:07:42, 14.16s/it][Succeeded / Failed / Skipped / Total] 500 / 163 / 50 / 713:  71%|███████▏  | 714/1000 [2:48:37<1:07:32, 14.17s/it][Succeeded / Failed / Skipped / Total] 500 / 164 / 50 / 714:  71%|███████▏  | 714/1000 [2:48:37<1:07:32, 14.17s/it][Succeeded / Failed / Skipped / Total] 500 / 164 / 50 / 714:  72%|███████▏  | 715/1000 [2:48:53<1:07:19, 14.17s/it][Succeeded / Failed / Skipped / Total] 501 / 164 / 50 / 715:  72%|███████▏  | 715/1000 [2:48:53<1:07:19, 14.17s/it][Succeeded / Failed / Skipped / Total] 501 / 164 / 50 / 715:  72%|███████▏  | 716/1000 [2:49:10<1:07:06, 14.18s/it]Get the table . --> Get or null if not valid --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[getTableDescriptor]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[t]] = tableRefs . get ( [[tableRef]] ) ; return [[t]] == null ? null : [[t]] . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .

[[[[Adv]]]]: public DbEntityDescriptor [[shiori]] ( final String [[devilishly]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[have]] = tableRefs . get ( [[devilishly]] ) ; return [[have]] == null ? null : [[have]] . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .
--------------------------------------------- Result 709 ---------------------------------------------
Serialize a JSON value . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: @ Override public final boolean [[serialize]] ( final JsonContext [[jsonContext]] , final T value ) { if ( [[jsonContext]] . pushValue ( value ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .

[[[[Adv]]]]: @ Override public final boolean [[aborigine]] ( final JsonContext [[outburst]] , final T value ) { if ( [[outburst]] . pushValue ( value ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .
--------------------------------------------- Result 710 ---------------------------------------------
Execute a request attribute . --> Write a string to a String representation --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectAttributes]] ( final HttpServletRequest [[servletRequest]] , final Targets targets ) { final Enumeration < String > [[attributeNames]] = [[servletRequest]] . getAttributeNames ( ) ; while ( [[attributeNames]] . hasMoreElements ( ) ) { final String [[attrName]] = [[attributeNames]] . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String [[name]] = in . matchedName ( [[attrName]] ) ; if ( [[name]] != null ) { final Object attrValue = [[servletRequest]] . getAttribute ( [[attrName]] ) ; target . writeValue ( [[name]] , attrValue , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .

[[[[Adv]]]]: protected void [[portugal]] ( final HttpServletRequest [[transatlantic]] , final Targets targets ) { final Enumeration < String > [[stephane]] = [[transatlantic]] . getAttributeNames ( ) ; while ( [[stephane]] . hasMoreElements ( ) ) { final String [[donde]] = [[stephane]] . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String [[emi]] = in . matchedName ( [[donde]] ) ; if ( [[emi]] != null ) { final Object attrValue = [[transatlantic]] . getAttribute ( [[donde]] ) ; target . writeValue ( [[emi]] , attrValue , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .
--------------------------------------------- Result 711 ---------------------------------------------
Gets a property . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public < T > T getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .

[[[[Adv]]]]: @ Override public < T > T getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .
--------------------------------------------- Result 712 ---------------------------------------------
Returns a table descriptor . --> Return the recurrence of the given entity --> Socre: 1.0

[[[[Adv]]]]: protected DbEntityDescriptor [[lookupTableRef]] ( final String [[tableRef]] ) { DbEntityDescriptor [[ded]] = getTableDescriptor ( [[tableRef]] ) ; if ( [[ded]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[tableRef]] ) ; } return [[ded]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .

[[[[Adv]]]]: protected DbEntityDescriptor [[celibacy]] ( final String [[winn]] ) { DbEntityDescriptor [[rebs]] = getTableDescriptor ( [[winn]] ) ; if ( [[rebs]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[winn]] ) ; } return [[rebs]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .
--------------------------------------------- Result 713 ---------------------------------------------
Returns a reference for the specified object . --> Get the evaluation --> Socre: 1.0

[[[[Adv]]]]: public Object [[lookupObject]] ( final String [[ref]] ) { Object [[value]] = getObjectReference ( [[ref]] ) ; if ( [[value]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[ref]] ) ; } return [[value]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .

[[[[Adv]]]]: public Object [[barker]] ( final String [[jawing]] ) { Object [[evaluation]] = getObjectReference ( [[jawing]] ) ; if ( [[evaluation]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[jawing]] ) ; } return [[evaluation]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .
--------------------------------------------- Result 714 ---------------------------------------------
Get a reference . --> [[[FAILED]]]

[[[[Adv]]]]: public Object getObjectReference ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .

[[[[Adv]]]]: public Object getObjectReference ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .
--------------------------------------------- Result 715 ---------------------------------------------
Converts a column into a name . --> Turn a string into a string --> Socre: 1.0

[[[[Adv]]]]: public String [[convertPropertyNameToColumnName]] ( final String [[propertyName]] ) { StringBuilder [[tableName]] = new StringBuilder ( [[propertyName]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String [[convertedTableName]] = Format . fromCamelCase ( [[propertyName]] , separatorChar ) ; [[tableName]] . append ( [[convertedTableName]] ) ; } else { [[tableName]] . append ( [[propertyName]] ) ; } if ( ! changeCase ) { return [[tableName]] . toString ( ) ; } return uppercase ? toUppercase ( [[tableName]] ) . toString ( ) : toLowercase ( [[tableName]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .

[[[[Adv]]]]: public String [[sup]] ( final String [[pastures]] ) { StringBuilder [[creeps]] = new StringBuilder ( [[pastures]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String [[predator]] = Format . fromCamelCase ( [[pastures]] , separatorChar ) ; [[creeps]] . append ( [[predator]] ) ; } else { [[creeps]] . append ( [[pastures]] ) ; } if ( ! changeCase ) { return [[creeps]] . toString ( ) ; } return uppercase ? toUppercase ( [[creeps]] ) . toString ( ) : toLowercase ( [[creeps]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .
--------------------------------------------- Result 716 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 501 / 165 / 50 / 716:  72%|███████▏  | 716/1000 [2:49:10<1:07:06, 14.18s/it][Succeeded / Failed / Skipped / Total] 501 / 165 / 50 / 716:  72%|███████▏  | 717/1000 [2:49:26<1:06:52, 14.18s/it][Succeeded / Failed / Skipped / Total] 502 / 165 / 50 / 717:  72%|███████▏  | 717/1000 [2:49:26<1:06:52, 14.18s/it][Succeeded / Failed / Skipped / Total] 502 / 165 / 50 / 717:  72%|███████▏  | 718/1000 [2:50:13<1:06:51, 14.22s/it][Succeeded / Failed / Skipped / Total] 503 / 165 / 50 / 718:  72%|███████▏  | 718/1000 [2:50:13<1:06:51, 14.22s/it][Succeeded / Failed / Skipped / Total] 503 / 165 / 50 / 718:  72%|███████▏  | 719/1000 [2:50:28<1:06:37, 14.23s/it][Succeeded / Failed / Skipped / Total] 503 / 166 / 50 / 719:  72%|███████▏  | 719/1000 [2:50:28<1:06:37, 14.23s/it][Succeeded / Failed / Skipped / Total] 503 / 166 / 50 / 719:  72%|███████▏  | 720/1000 [2:51:15<1:06:36, 14.27s/it][Succeeded / Failed / Skipped / Total] 503 / 167 / 50 / 720:  72%|███████▏  | 720/1000 [2:51:15<1:06:36, 14.27s/it][Succeeded / Failed / Skipped / Total] 503 / 167 / 50 / 720:  72%|███████▏  | 721/1000 [2:51:42<1:06:26, 14.29s/it][Succeeded / Failed / Skipped / Total] 504 / 167 / 50 / 721:  72%|███████▏  | 721/1000 [2:51:42<1:06:26, 14.29s/it][Succeeded / Failed / Skipped / Total] 504 / 167 / 50 / 721:  72%|███████▏  | 722/1000 [2:51:43<1:06:07, 14.27s/it][Succeeded / Failed / Skipped / Total] 505 / 167 / 50 / 722:  72%|███████▏  | 722/1000 [2:51:43<1:06:07, 14.27s/it][Succeeded / Failed / Skipped / Total] 505 / 167 / 50 / 722:  72%|███████▏  | 723/1000 [2:51:44<1:05:48, 14.25s/it][Succeeded / Failed / Skipped / Total] 506 / 167 / 50 / 723:  72%|███████▏  | 723/1000 [2:51:44<1:05:48, 14.25s/it][Succeeded / Failed / Skipped / Total] 506 / 167 / 50 / 723:  72%|███████▏  | 724/1000 [2:51:59<1:05:33, 14.25s/it]Returns the value of the given type . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < E > E prepareGetValue ( final T t , final Class < E > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( E ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < E > E prepareGetValue ( final T t , final Class < E > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( E ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .
--------------------------------------------- Result 717 ---------------------------------------------
Register a reference . --> Add a database to the database --> Socre: 1.0

[[[[Adv]]]]: public void [[registerTableReference]] ( final String [[tableReference]] , final DbEntityDescriptor [[ded]] , final String [[tableAlias]] ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData [[t]] = new TableRefData ( [[ded]] , [[tableAlias]] ) ; if ( tableRefs . put ( [[tableReference]] , [[t]] ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + [[tableReference]] ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .

[[[[Adv]]]]: public void [[benjamins]] ( final String [[pavilions]] , final DbEntityDescriptor [[pensioner]] , final String [[gallipoli]] ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData [[ov]] = new TableRefData ( [[pensioner]] , [[gallipoli]] ) ; if ( tableRefs . put ( [[pavilions]] , [[ov]] ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + [[pavilions]] ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .
--------------------------------------------- Result 718 ---------------------------------------------
Resolve a class . --> Initializes a shar --> Socre: 1.0

[[[[Adv]]]]: public T [[resolve]] ( final Class < ? extends T > [[wrapperClass]] ) { String [[wrapperClassName]] = [[wrapperClass]] . getName ( ) ; T [[wrapper]] = lookup ( [[wrapperClassName]] ) ; if ( [[wrapper]] == null ) { [[wrapper]] = createWrapper ( [[wrapperClass]] ) ; initializeWrapper ( [[wrapper]] ) ; wrappers . put ( [[wrapperClassName]] , [[wrapper]] ) ; } return [[wrapper]] ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .

[[[[Adv]]]]: public T [[redress]] ( final Class < ? extends T > [[croaked]] ) { String [[righter]] = [[croaked]] . getName ( ) ; T [[shawl]] = lookup ( [[righter]] ) ; if ( [[shawl]] == null ) { [[shawl]] = createWrapper ( [[croaked]] ) ; initializeWrapper ( [[shawl]] ) ; wrappers . put ( [[righter]] , [[shawl]] ) ; } return [[shawl]] ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .
--------------------------------------------- Result 719 ---------------------------------------------
Create a new instance of this class . --> [[[FAILED]]]

[[[[Adv]]]]: protected < R extends T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .

[[[[Adv]]]]: protected < R extends T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .
--------------------------------------------- Result 720 ---------------------------------------------
Find a column by its name . --> [[[FAILED]]]

[[[[Adv]]]]: public DbEntityDescriptor findTableDescriptorByColumnRef ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = entry . getValue ( ) . desc ; if ( ded . findByPropertyName ( columnRef ) != null ) { return ded ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .

[[[[Adv]]]]: public DbEntityDescriptor findTableDescriptorByColumnRef ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = entry . getValue ( ) . desc ; if ( ded . findByPropertyName ( columnRef ) != null ) { return ded ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .
--------------------------------------------- Result 721 ---------------------------------------------
Returns the path of the given path . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static String [[separatorsToSystem]] ( final String [[path]] ) { if ( [[path]] == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( [[path]] ) ; } else { return separatorsToUnix ( [[path]] ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .

[[[[Adv]]]]: public static String [[goners]] ( final String [[keng]] ) { if ( [[keng]] == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( [[keng]] ) ; } else { return separatorsToUnix ( [[keng]] ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .
--------------------------------------------- Result 722 ---------------------------------------------
Returns the filename . --> Convert a string to a string --> Socre: 1.0

[[[[Adv]]]]: private static String [[doGetPath]] ( final String [[filename]] , final int [[separatorAdd]] ) { if ( [[filename]] == null ) { return null ; } int prefix = getPrefixLength ( [[filename]] ) ; if ( prefix < 0 ) { return null ; } int [[index]] = indexOfLastSeparator ( [[filename]] ) ; int [[endIndex]] = [[index]] + [[separatorAdd]] ; if ( prefix >= [[filename]] . length ( ) || [[index]] < 0 || prefix >= [[endIndex]] ) { return StringPool . EMPTY ; } return [[filename]] . substring ( prefix , [[endIndex]] ) ; }
[[[[Nl]]]]: Does the work of getting the path .

[[[[Adv]]]]: private static String [[talkie]] ( final String [[marina]] , final int [[incomprehensible]] ) { if ( [[marina]] == null ) { return null ; } int prefix = getPrefixLength ( [[marina]] ) ; if ( prefix < 0 ) { return null ; } int [[reference]] = indexOfLastSeparator ( [[marina]] ) ; int [[awaken]] = [[reference]] + [[incomprehensible]] ; if ( prefix >= [[marina]] . length ( ) || [[reference]] < 0 || prefix >= [[awaken]] ) { return StringPool . EMPTY ; } return [[marina]] . substring ( prefix , [[awaken]] ) ; }
[[[[Nl]]]]: Does the work of getting the path .
--------------------------------------------- Result 723 ---------------------------------------------
Convert a File to a string . --> Convert a File to a File --> Socre: 1.0

[[[[Adv]]]]: public static String relativePath ( final String [[targetPath]] , final String [[basePath]] ) { return new File ( [[basePath]] ) . toPath ( ) . relativize ( new File ( [[targetPath]] ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .

[[[[Adv]]]]: public static String relativePath ( final String [[vitam]] , final String [[casinos]] ) { return new File ( [[casinos]] ) . toPath ( ) . relativize ( new File ( [[vitam]] ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .
--------------------------------------------- Result 724 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 507 / 167 / 50 / 724:  72%|███████▏  | 724/1000 [2:51:59<1:05:33, 14.25s/it][Succeeded / Failed / Skipped / Total] 507 / 167 / 50 / 724:  72%|███████▎  | 725/1000 [2:52:02<1:05:15, 14.24s/it][Succeeded / Failed / Skipped / Total] 508 / 167 / 50 / 725:  72%|███████▎  | 725/1000 [2:52:02<1:05:15, 14.24s/it][Succeeded / Failed / Skipped / Total] 508 / 167 / 50 / 725:  73%|███████▎  | 726/1000 [2:52:04<1:04:56, 14.22s/it][Succeeded / Failed / Skipped / Total] 509 / 167 / 50 / 726:  73%|███████▎  | 726/1000 [2:52:04<1:04:56, 14.22s/it][Succeeded / Failed / Skipped / Total] 509 / 167 / 50 / 726:  73%|███████▎  | 727/1000 [2:52:06<1:04:37, 14.20s/it][Succeeded / Failed / Skipped / Total] 509 / 168 / 50 / 727:  73%|███████▎  | 727/1000 [2:52:06<1:04:37, 14.20s/it][Succeeded / Failed / Skipped / Total] 509 / 168 / 50 / 727:  73%|███████▎  | 728/1000 [2:52:11<1:04:20, 14.19s/it][Succeeded / Failed / Skipped / Total] 510 / 168 / 50 / 728:  73%|███████▎  | 728/1000 [2:52:11<1:04:20, 14.19s/it][Succeeded / Failed / Skipped / Total] 510 / 168 / 50 / 728:  73%|███████▎  | 729/1000 [2:52:15<1:04:02, 14.18s/it][Succeeded / Failed / Skipped / Total] 511 / 168 / 50 / 729:  73%|███████▎  | 729/1000 [2:52:15<1:04:02, 14.18s/it][Succeeded / Failed / Skipped / Total] 511 / 168 / 50 / 729:  73%|███████▎  | 730/1000 [2:52:17<1:03:43, 14.16s/it][Succeeded / Failed / Skipped / Total] 512 / 168 / 50 / 730:  73%|███████▎  | 730/1000 [2:52:17<1:03:43, 14.16s/it][Succeeded / Failed / Skipped / Total] 512 / 168 / 50 / 730:  73%|███████▎  | 731/1000 [2:52:19<1:03:24, 14.14s/it][Succeeded / Failed / Skipped / Total] 513 / 168 / 50 / 731:  73%|███████▎  | 731/1000 [2:52:19<1:03:24, 14.14s/it][Succeeded / Failed / Skipped / Total] 513 / 168 / 50 / 731:  73%|███████▎  | 732/1000 [2:52:42<1:03:13, 14.16s/it][Succeeded / Failed / Skipped / Total] 514 / 168 / 50 / 732:  73%|███████▎  | 732/1000 [2:52:42<1:03:13, 14.16s/it][Succeeded / Failed / Skipped / Total] 514 / 168 / 50 / 732:  73%|███████▎  | 733/1000 [2:52:47<1:02:56, 14.14s/it]Convert a string to a name --> Calecite die --> Socre: 1.0

[[[[Adv]]]]: public String convertColumnNameToPropertyName ( final String [[columnName]] ) { StringBuilder propertyName = new StringBuilder ( [[columnName]] . length ( ) ) ; int [[len]] = [[columnName]] . length ( ) ; if ( splitCamelCase ) { boolean [[toUpper]] = "[[False]]" != "[[False]]" ; for ( int i = 0 ; i < [[len]] ; i ++ ) { char c = [[columnName]] . charAt ( i ) ; if ( c == separatorChar ) { [[toUpper]] = "True" == "True" ; continue ; } if ( [[toUpper]] ) { propertyName . append ( Character . toUpperCase ( c ) ) ; [[toUpper]] = "[[False]]" != "[[False]]" ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return [[columnName]] ; }
[[[[Nl]]]]: Converts column name to property name .

[[[[Adv]]]]: public String convertColumnNameToPropertyName ( final String [[khalil]] ) { StringBuilder propertyName = new StringBuilder ( [[khalil]] . length ( ) ) ; int [[mere]] = [[khalil]] . length ( ) ; if ( splitCamelCase ) { boolean [[epileptic]] = "[[Mislead]]" != "[[Mislead]]" ; for ( int i = 0 ; i < [[mere]] ; i ++ ) { char c = [[khalil]] . charAt ( i ) ; if ( c == separatorChar ) { [[epileptic]] = "True" == "True" ; continue ; } if ( [[epileptic]] ) { propertyName . append ( Character . toUpperCase ( c ) ) ; [[epileptic]] = "[[Mislead]]" != "[[Mislead]]" ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return [[khalil]] ; }
[[[[Nl]]]]: Converts column name to property name .
--------------------------------------------- Result 725 ---------------------------------------------
Create a Consumer action . --> Adapts a Consumer --> Socre: 1.0

[[[[Adv]]]]: public < A [[extends]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .

[[[[Adv]]]]: public < A [[magnify]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .
--------------------------------------------- Result 726 ---------------------------------------------
Adds a component to this component . --> Register a new Webers --> Socre: 1.0

[[[[Adv]]]]: public WebApp [[registerComponent]] ( final Class < ? > [[madvocComponent]] ) { Objects . requireNonNull ( [[madvocComponent]] ) ; madvocComponents . add ( ClassConsumer . of ( [[madvocComponent]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .

[[[[Adv]]]]: public WebApp [[interviewer]] ( final Class < ? > [[krook]] ) { Objects . requireNonNull ( [[krook]] ) ; madvocComponents . add ( ClassConsumer . of ( [[krook]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .
--------------------------------------------- Result 727 ---------------------------------------------
Starts the app --> [[[FAILED]]]

[[[[Adv]]]]: public WebApp start ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .

[[[[Adv]]]]: public WebApp start ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .
--------------------------------------------- Result 728 ---------------------------------------------
Registers a component . --> Register a Annotation --> Socre: 1.0

[[[[Adv]]]]: protected void [[configureDefaults]] ( ) { final ActionConfigManager [[actionConfigManager]] = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; [[actionConfigManager]] . registerAnnotation ( Action . class ) ; [[actionConfigManager]] . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .

[[[[Adv]]]]: protected void [[trav]] ( ) { final ActionConfigManager [[marry]] = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; [[marry]] . registerAnnotation ( Action . class ) ; [[marry]] . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .
--------------------------------------------- Result 729 ---------------------------------------------
Gets the excluder . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[excludeJars]] ( final String ... [[excludedJars]] ) { for ( final String [[excludedJar]] : [[excludedJars]] ) { rulesJars . exclude ( [[excludedJar]] ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .

[[[[Adv]]]]: public ClassScanner [[despatch]] ( final String ... [[stepmother]] ) { for ( final String [[parsi]] : [[stepmother]] ) { rulesJars . exclude ( [[parsi]] ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .
--------------------------------------------- Result 730 ---------------------------------------------
Return a Jardarar . --> Convert a string to a string --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[includeJars]] ( final String ... [[includedJars]] ) { for ( final String [[includedJar]] : [[includedJars]] ) { rulesJars . include ( [[includedJar]] ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .

[[[[Adv]]]]: public ClassScanner [[nowlin]] ( final String ... [[pavements]] ) { for ( final String [[jacinta]] : [[pavements]] ) { rulesJars . include ( [[jacinta]] ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .
--------------------------------------------- Result 731 ---------------------------------------------
Returns a fully qualified class name . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[includeEntries]] ( final String ... includedEntries ) { for ( final String [[includedEntry]] : includedEntries ) { rulesEntries . include ( [[includedEntry]] ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .

[[[[Adv]]]]: public ClassScanner [[masseurs]] ( final String ... includedEntries ) { for ( final String [[détente]] : includedEntries ) { rulesEntries . include ( [[détente]] ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .
--------------------------------------------- Result 732 ---------------------------------------------
Scans the given patterns . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... excludedEntries ) { for ( final String [[excludedEntry]] : excludedEntries ) { rulesEntries . exclude ( [[excludedEntry]] ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... excludedEntries ) { for ( final String [[vis]] : excludedEntries ) { rulesEntries . exclude ( [[vis]] ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .
--------------------------------------------- Result 733 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 515 / 168 / 50 / 733:  73%|███████▎  | 733/1000 [2:52:47<1:02:56, 14.14s/it][Succeeded / Failed / Skipped / Total] 515 / 168 / 50 / 733:  73%|███████▎  | 734/1000 [2:53:41<1:02:56, 14.20s/it][Succeeded / Failed / Skipped / Total] 515 / 169 / 50 / 734:  73%|███████▎  | 734/1000 [2:53:41<1:02:56, 14.20s/it][Succeeded / Failed / Skipped / Total] 515 / 169 / 50 / 734:  74%|███████▎  | 735/1000 [2:53:43<1:02:38, 14.18s/it][Succeeded / Failed / Skipped / Total] 516 / 169 / 50 / 735:  74%|███████▎  | 735/1000 [2:53:43<1:02:38, 14.18s/it][Succeeded / Failed / Skipped / Total] 516 / 169 / 50 / 735:  74%|███████▎  | 736/1000 [2:53:51<1:02:21, 14.17s/it][Succeeded / Failed / Skipped / Total] 517 / 169 / 50 / 736:  74%|███████▎  | 736/1000 [2:53:51<1:02:21, 14.17s/it][Succeeded / Failed / Skipped / Total] 517 / 169 / 50 / 736:  74%|███████▎  | 737/1000 [2:54:02<1:02:06, 14.17s/it][Succeeded / Failed / Skipped / Total] 518 / 169 / 50 / 737:  74%|███████▎  | 737/1000 [2:54:02<1:02:06, 14.17s/it][Succeeded / Failed / Skipped / Total] 518 / 169 / 50 / 737:  74%|███████▍  | 738/1000 [2:54:19<1:01:53, 14.17s/it][Succeeded / Failed / Skipped / Total] 518 / 170 / 50 / 738:  74%|███████▍  | 738/1000 [2:54:19<1:01:53, 14.17s/it][Succeeded / Failed / Skipped / Total] 518 / 170 / 50 / 738:  74%|███████▍  | 739/1000 [2:54:36<1:01:39, 14.18s/it]Register a component . --> Register a component --> Socre: 1.0

[[[[Adv]]]]: protected void [[registerMadvocComponents]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .

[[[[Adv]]]]: protected void [[tus]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .
--------------------------------------------- Result 734 ---------------------------------------------
Convert a column to a name --> [[[FAILED]]]

[[[[Adv]]]]: public String applyToColumnName ( final String columnName ) { String propertyName = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .

[[[[Adv]]]]: public String applyToColumnName ( final String columnName ) { String propertyName = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .
--------------------------------------------- Result 735 ---------------------------------------------
Convert a class to a class . --> Convert a string to a byte array --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[bytecodeSignatureOfType]] ( final Class type ) { final String [[name]] = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return [[name]] . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .

[[[[Adv]]]]: public static byte [ ] [[victorio]] ( final Class type ) { final String [[arabians]] = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return [[arabians]] . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .
--------------------------------------------- Result 736 ---------------------------------------------
Scans the classpath . --> Copy a path to a file --> Socre: 1.0

[[[[Adv]]]]: protected void [[scanClassPath]] ( final File [[root]] ) { String rootPath = [[root]] . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "[[True]]" == "[[True]]" ) . searchPath ( rootPath ) ; File [[file]] ; while ( ( [[file]] = ff . nextFile ( ) ) != null ) { final String filePath = [[file]] . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , [[file]] , "[[True]]" == "[[True]]" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , [[file]] , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .

[[[[Adv]]]]: protected void [[nordic]] ( final File [[raison]] ) { String rootPath = [[raison]] . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "[[Presentable]]" == "[[Presentable]]" ) . searchPath ( rootPath ) ; File [[depositing]] ; while ( ( [[depositing]] = ff . nextFile ( ) ) != null ) { final String filePath = [[depositing]] . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , [[depositing]] , "[[Presentable]]" == "[[Presentable]]" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , [[depositing]] , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .
--------------------------------------------- Result 737 ---------------------------------------------
Adds a file to the scan . --> Add a file to a string --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[scan]] ( final String ... [[paths]] ) { for ( final String [[path]] : [[paths]] ) { filesToScan . add ( new File ( [[path]] ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .

[[[[Adv]]]]: public ClassScanner [[explores]] ( final String ... [[avenues]] ) { for ( final String [[arteries]] : [[avenues]] ) { filesToScan . add ( new File ( [[arteries]] ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .
--------------------------------------------- Result 738 ---------------------------------------------
Returns a new instance of this set . --> [[[FAILED]]]

[[[[Adv]]]]: protected Set < T > getAll ( ) { final Set < T > set = new HashSet <> ( wrappers . size ( ) ) ; set . addAll ( wrappers . values ( ) ) ; return set ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .

[[[[Adv]]]]: protected Set < T > getAll ( ) { final Set < T > set = new HashSet <> ( wrappers . size ( ) ) ; set . addAll ( wrappers . values ( ) ) ; return set ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .
--------------------------------------------- Result 739 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 518 / 171 / 50 / 739:  74%|███████▍  | 739/1000 [2:54:36<1:01:39, 14.18s/it][Succeeded / Failed / Skipped / Total] 518 / 171 / 50 / 739:  74%|███████▍  | 740/1000 [2:55:22<1:01:37, 14.22s/it][Succeeded / Failed / Skipped / Total] 518 / 172 / 50 / 740:  74%|███████▍  | 740/1000 [2:55:22<1:01:37, 14.22s/it][Succeeded / Failed / Skipped / Total] 518 / 172 / 50 / 740:  74%|███████▍  | 741/1000 [2:55:40<1:01:24, 14.23s/it][Succeeded / Failed / Skipped / Total] 519 / 172 / 50 / 741:  74%|███████▍  | 741/1000 [2:55:40<1:01:24, 14.23s/it][Succeeded / Failed / Skipped / Total] 519 / 172 / 50 / 741:  74%|███████▍  | 742/1000 [2:56:15<1:01:17, 14.25s/it][Succeeded / Failed / Skipped / Total] 520 / 172 / 50 / 742:  74%|███████▍  | 742/1000 [2:56:15<1:01:17, 14.25s/it][Succeeded / Failed / Skipped / Total] 520 / 172 / 50 / 742:  74%|███████▍  | 743/1000 [2:56:36<1:01:05, 14.26s/it][Succeeded / Failed / Skipped / Total] 521 / 172 / 50 / 743:  74%|███████▍  | 743/1000 [2:56:36<1:01:05, 14.26s/it][Succeeded / Failed / Skipped / Total] 521 / 172 / 50 / 743:  74%|███████▍  | 744/1000 [2:56:59<1:00:54, 14.27s/it]Gets the scope . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .
--------------------------------------------- Result 740 ---------------------------------------------
Sets the value of a given type . --> [[[FAILED]]]

[[[[Adv]]]]: public void storeValue ( final PreparedStatement st , final int index , final Object value , final int dbSqlType ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , index , t , dbSqlType ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .

[[[[Adv]]]]: public void storeValue ( final PreparedStatement st , final int index , final Object value , final int dbSqlType ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , index , t , dbSqlType ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .
--------------------------------------------- Result 741 ---------------------------------------------
Convenience method to extract the scope of the given scope . --> Decoorates the vocault --> Socre: 1.0

[[[[Adv]]]]: public void [[forScope]] ( final Class < ? extends MadvocScope > [[scopeType]] , final Consumer < MadvocScope > [[madvocScopeConsumer]] ) { final MadvocScope [[scope]] = getOrInitScope ( [[scopeType]] ) ; [[madvocScopeConsumer]] . accept ( [[scope]] ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .

[[[[Adv]]]]: public void [[shino]] ( final Class < ? extends MadvocScope > [[vendetta]] , final Consumer < MadvocScope > [[croatian]] ) { final MadvocScope [[space]] = getOrInitScope ( [[vendetta]] ) ; [[croatian]] . accept ( [[space]] ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .
--------------------------------------------- Result 742 ---------------------------------------------
Decodes a byte array . --> Calculate the number of nenomial --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[decode]] ( final char [ ] arr ) { int [[length]] = arr . length ; if ( [[length]] == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , [[endx]] = [[length]] - 1 ; int pad = arr [ [[endx]] ] == ' ' ? ( arr [ [[endx]] - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = [[endx]] - sndx + 1 ; int sepCnt = [[length]] > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int [[len]] = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ [[len]] ] ; int d = 0 ; for ( int cc = 0 , eLen = ( [[len]] / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < [[len]] ) { int i = 0 ; for ( int j = 0 ; sndx <= [[endx]] - pad ; j ++ ) { i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < [[len]] ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .

[[[[Adv]]]]: public static byte [ ] [[unraveling]] ( final char [ ] arr ) { int [[lifetime]] = arr . length ; if ( [[lifetime]] == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , [[centigrade]] = [[lifetime]] - 1 ; int pad = arr [ [[centigrade]] ] == ' ' ? ( arr [ [[centigrade]] - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = [[centigrade]] - sndx + 1 ; int sepCnt = [[lifetime]] > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int [[lenny]] = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ [[lenny]] ] ; int d = 0 ; for ( int cc = 0 , eLen = ( [[lenny]] / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < [[lenny]] ) { int i = 0 ; for ( int j = 0 ; sndx <= [[centigrade]] - pad ; j ++ ) { i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < [[lenny]] ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .
--------------------------------------------- Result 743 ---------------------------------------------
Returns a set of tokens . --> Return a set of a given id --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String [[prepareCsrfToken]] ( final HttpSession [[session]] , final int timeToLive ) { Set < Token > [[tokenSet]] = ( Set < Token > ) [[session]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( [[tokenSet]] == null ) { [[tokenSet]] = new HashSet <> ( ) ; [[session]] . setAttribute ( CSRF_TOKEN_SET , [[tokenSet]] ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( [[tokenSet]] ) ; unique = [[tokenSet]] . add ( new Token ( value , timeToLive ) ) ; } while ( ! unique ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String [[crest]] ( final HttpSession [[debrief]] , final int timeToLive ) { Set < Token > [[megiddo]] = ( Set < Token > ) [[debrief]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( [[megiddo]] == null ) { [[megiddo]] = new HashSet <> ( ) ; [[debrief]] . setAttribute ( CSRF_TOKEN_SET , [[megiddo]] ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( [[megiddo]] ) ; unique = [[megiddo]] . add ( new Token ( value , timeToLive ) ) ; } while ( ! unique ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .
--------------------------------------------- Result 744 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 522 / 172 / 50 / 744:  74%|███████▍  | 744/1000 [2:56:59<1:00:54, 14.27s/it][Succeeded / Failed / Skipped / Total] 522 / 172 / 50 / 744:  74%|███████▍  | 745/1000 [2:57:13<1:00:39, 14.27s/it][Succeeded / Failed / Skipped / Total] 522 / 173 / 50 / 745:  74%|███████▍  | 745/1000 [2:57:13<1:00:39, 14.27s/it][Succeeded / Failed / Skipped / Total] 522 / 173 / 50 / 745:  75%|███████▍  | 746/1000 [2:57:16<1:00:21, 14.26s/it][Succeeded / Failed / Skipped / Total] 522 / 174 / 50 / 746:  75%|███████▍  | 746/1000 [2:57:16<1:00:21, 14.26s/it][Succeeded / Failed / Skipped / Total] 522 / 174 / 50 / 746:  75%|███████▍  | 747/1000 [2:57:16<1:00:02, 14.24s/it][Succeeded / Failed / Skipped / Total] 523 / 174 / 50 / 747:  75%|███████▍  | 747/1000 [2:57:16<1:00:02, 14.24s/it][Succeeded / Failed / Skipped / Total] 523 / 174 / 50 / 747:  75%|███████▍  | 748/1000 [2:57:34<59:49, 14.24s/it]  [Succeeded / Failed / Skipped / Total] 524 / 174 / 50 / 748:  75%|███████▍  | 748/1000 [2:57:34<59:49, 14.24s/it][Succeeded / Failed / Skipped / Total] 524 / 174 / 50 / 748:  75%|███████▍  | 749/1000 [2:57:42<59:33, 14.24s/it]Removes the token from the set . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: protected static void [[assureSize]] ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long [[validUntilMin]] = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > [[iterator]] = tokenSet . iterator ( ) ; while ( [[iterator]] . hasNext ( ) ) { Token [[token]] = [[iterator]] . next ( ) ; if ( [[token]] . isExpired ( ) ) { [[iterator]] . remove ( ) ; continue ; } if ( [[token]] . validUntil < [[validUntilMin]] ) { [[validUntilMin]] = [[token]] . validUntil ; tokenToRemove = [[token]] ; } } if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .

[[[[Adv]]]]: protected static void [[hearthe]] ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long [[bungee]] = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > [[standings]] = tokenSet . iterator ( ) ; while ( [[standings]] . hasNext ( ) ) { Token [[symptom]] = [[standings]] . next ( ) ; if ( [[symptom]] . isExpired ( ) ) { [[standings]] . remove ( ) ; continue ; } if ( [[symptom]] . validUntil < [[bungee]] ) { [[bungee]] = [[symptom]] . validUntil ; tokenToRemove = [[symptom]] ; } } if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .
--------------------------------------------- Result 745 ---------------------------------------------
Handle a request . --> [[[FAILED]]]

[[[[Adv]]]]: protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .

[[[[Adv]]]]: protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .
--------------------------------------------- Result 746 ---------------------------------------------
Scans a directory . --> [[[FAILED]]]

[[[[Adv]]]]: public void start ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String path = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .

[[[[Adv]]]]: public void start ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String path = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .
--------------------------------------------- Result 747 ---------------------------------------------
Visit a bean . --> Visit a bean --> Socre: 1.0

[[[[Adv]]]]: public void copy ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "[[True]]" == "[[True]]" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .

[[[[Adv]]]]: public void copy ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "[[Faithful]]" == "[[Faithful]]" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .
--------------------------------------------- Result 748 ---------------------------------------------
Visit a bean . --> Synchronously initialize a bean --> Socre: 1.0

[[[[Adv]]]]: @ Override protected boolean visitProperty ( String [[name]] , final Object value ) { if ( isTargetMap ) { [[name]] = LEFT_SQ_BRACKET + [[name]] + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , [[name]] , value ) ; return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .

[[[[Adv]]]]: @ Override protected boolean visitProperty ( String [[appointment]] , final Object value ) { if ( isTargetMap ) { [[appointment]] = LEFT_SQ_BRACKET + [[appointment]] + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , [[appointment]] , value ) ; return "[[Faithfully]]" == "[[Faithfully]]" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .
--------------------------------------------- Result 749 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 525 / 174 / 50 / 749:  75%|███████▍  | 749/1000 [2:57:42<59:33, 14.24s/it][Succeeded / Failed / Skipped / Total] 525 / 174 / 50 / 749:  75%|███████▌  | 750/1000 [2:58:07<59:22, 14.25s/it][Succeeded / Failed / Skipped / Total] 525 / 175 / 50 / 750:  75%|███████▌  | 750/1000 [2:58:07<59:22, 14.25s/it][Succeeded / Failed / Skipped / Total] 525 / 175 / 50 / 750:  75%|███████▌  | 751/1000 [2:58:08<59:03, 14.23s/it][Succeeded / Failed / Skipped / Total] 526 / 175 / 50 / 751:  75%|███████▌  | 751/1000 [2:58:08<59:03, 14.23s/it][Succeeded / Failed / Skipped / Total] 526 / 175 / 50 / 751:  75%|███████▌  | 752/1000 [2:59:10<59:05, 14.30s/it][Succeeded / Failed / Skipped / Total] 527 / 175 / 50 / 752:  75%|███████▌  | 752/1000 [2:59:10<59:05, 14.30s/it][Succeeded / Failed / Skipped / Total] 527 / 175 / 50 / 752:  75%|███████▌  | 753/1000 [2:59:20<58:49, 14.29s/it][Succeeded / Failed / Skipped / Total] 527 / 176 / 50 / 753:  75%|███████▌  | 753/1000 [2:59:20<58:49, 14.29s/it][Succeeded / Failed / Skipped / Total] 527 / 176 / 50 / 753:  75%|███████▌  | 754/1000 [2:59:29<58:33, 14.28s/it][Succeeded / Failed / Skipped / Total] 528 / 176 / 50 / 754:  75%|███████▌  | 754/1000 [2:59:29<58:33, 14.28s/it][Succeeded / Failed / Skipped / Total] 528 / 176 / 50 / 754:  76%|███████▌  | 755/1000 [2:59:30<58:15, 14.27s/it]Initializes the template . --> Register a new domain --> Socre: 1.0

[[[[Adv]]]]: @ Override public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object [[object]] = templateData . getObjectReference ( entityName ) ; if ( [[object]] != null ) { ded = lookupType ( resolveClass ( [[object]] ) ) ; } else { ded = lookupName ( entityName ) ; } } String [[tableReference]] = this . tableReference ; if ( [[tableReference]] == null ) { [[tableReference]] = tableAlias ; } if ( [[tableReference]] == null ) { [[tableReference]] = entityName ; } if ( [[tableReference]] == null ) { [[tableReference]] = ded . getEntityName ( ) ; } templateData . registerTableReference ( [[tableReference]] , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .

[[[[Adv]]]]: @ Override public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object [[goal]] = templateData . getObjectReference ( entityName ) ; if ( [[goal]] != null ) { ded = lookupType ( resolveClass ( [[goal]] ) ) ; } else { ded = lookupName ( entityName ) ; } } String [[rebeca]] = this . tableReference ; if ( [[rebeca]] == null ) { [[rebeca]] = tableAlias ; } if ( [[rebeca]] == null ) { [[rebeca]] = entityName ; } if ( [[rebeca]] == null ) { [[rebeca]] = ded . getEntityName ( ) ; } templateData . registerTableReference ( [[rebeca]] , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .
--------------------------------------------- Result 750 ---------------------------------------------
Process the request . --> [[[FAILED]]]

[[[[Adv]]]]: protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .

[[[[Adv]]]]: protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .
--------------------------------------------- Result 751 ---------------------------------------------
Resolve type . --> Resolve type --> Socre: 1.0

[[[[Adv]]]]: public < T > BeanDefinition < T > [[registerPetiteBean]] ( final Class < T > type , String [[name]] , Class < ? extends Scope > [[scopeType]] , WiringMode wiringMode , final boolean [[define]] , final Consumer < T > consumer ) { if ( [[name]] == null ) { [[name]] = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( [[scopeType]] == null ) { [[scopeType]] = annotationResolver . resolveBeanScopeType ( type ) ; } if ( [[scopeType]] == null ) { [[scopeType]] = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .

[[[[Adv]]]]: public < T > BeanDefinition < T > [[adopting]] ( final Class < T > type , String [[alphabetically]] , Class < ? extends Scope > [[negate]] , WiringMode wiringMode , final boolean [[prescribes]] , final Consumer < T > consumer ) { if ( [[alphabetically]] == null ) { [[alphabetically]] = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( [[negate]] == null ) { [[negate]] = annotationResolver . resolveBeanScopeType ( type ) ; } if ( [[negate]] == null ) { [[negate]] = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .
--------------------------------------------- Result 752 ---------------------------------------------
Returns a copy of the source . --> Returns the phaphysicalBean --> Socre: 1.0

[[[[Adv]]]]: public static BeanCopy [[from]] ( final Object [[source]] ) { BeanCopy [[beanCopy]] = new BeanCopy ( [[source]] ) ; [[beanCopy]] . isSourceMap = [[source]] instanceof Map ; return [[beanCopy]] ; }
[[[[Nl]]]]: Defines source detects a map .

[[[[Adv]]]]: public static BeanCopy [[sur]] ( final Object [[ancestry]] ) { BeanCopy [[phobia]] = new BeanCopy ( [[ancestry]] ) ; [[phobia]] . isSourceMap = [[ancestry]] instanceof Map ; return [[phobia]] ; }
[[[[Nl]]]]: Defines source detects a map .
--------------------------------------------- Result 753 ---------------------------------------------
Create a new transaction . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected JtxTransaction createNewTransaction ( final JtxTransactionMode tm , final Object scope , final boolean active ) { return new DbJtxTransaction ( this , tm , scope , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .

[[[[Adv]]]]: @ Override protected JtxTransaction createNewTransaction ( final JtxTransactionMode tm , final Object scope , final boolean active ) { return new DbJtxTransaction ( this , tm , scope , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .
--------------------------------------------- Result 754 ---------------------------------------------
Removes a class . --> Declarative Services method for setting the classloader --> Socre: 1.0

[[[[Adv]]]]: public void [[removeBean]] ( final Class [[type]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .

[[[[Adv]]]]: public void [[respectful]] ( final Class [[typist]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .
--------------------------------------------- Result 755 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 529 / 176 / 50 / 755:  76%|███████▌  | 755/1000 [2:59:30<58:15, 14.27s/it][Succeeded / Failed / Skipped / Total] 529 / 176 / 50 / 755:  76%|███████▌  | 756/1000 [2:59:34<57:57, 14.25s/it][Succeeded / Failed / Skipped / Total] 529 / 177 / 50 / 756:  76%|███████▌  | 756/1000 [2:59:34<57:57, 14.25s/it][Succeeded / Failed / Skipped / Total] 529 / 177 / 50 / 756:  76%|███████▌  | 757/1000 [2:59:51<57:44, 14.26s/it][Succeeded / Failed / Skipped / Total] 529 / 178 / 50 / 757:  76%|███████▌  | 757/1000 [2:59:51<57:44, 14.26s/it][Succeeded / Failed / Skipped / Total] 529 / 178 / 50 / 757:  76%|███████▌  | 758/1000 [3:00:50<57:44, 14.31s/it][Succeeded / Failed / Skipped / Total] 530 / 178 / 50 / 758:  76%|███████▌  | 758/1000 [3:00:50<57:44, 14.31s/it][Succeeded / Failed / Skipped / Total] 530 / 178 / 50 / 758:  76%|███████▌  | 759/1000 [3:01:13<57:32, 14.33s/it]Returns a list of bean type . --> Resolve a list of beans --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] resolveBeanNamesForType ( final Class [[type]] ) { String [ ] [[beanNames]] = beanCollections . get ( [[type]] ) ; if ( [[beanNames]] != null ) { return [[beanNames]] ; } ArrayList < String > [[list]] = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > [[entry]] : beans . entrySet ( ) ) { BeanDefinition beanDefinition = [[entry]] . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , [[type]] ) ) { String [[beanName]] = [[entry]] . getKey ( ) ; [[list]] . add ( [[beanName]] ) ; } } if ( [[list]] . isEmpty ( ) ) { [[beanNames]] = StringPool . EMPTY_ARRAY ; } else { [[beanNames]] = [[list]] . toArray ( new String [ 0 ] ) ; } beanCollections . put ( [[type]] , [[beanNames]] ) ; return [[beanNames]] ; }
[[[[Nl]]]]: Resolves bean names for give type .

[[[[Adv]]]]: protected String [ ] resolveBeanNamesForType ( final Class [[sexes]] ) { String [ ] [[benefiting]] = beanCollections . get ( [[sexes]] ) ; if ( [[benefiting]] != null ) { return [[benefiting]] ; } ArrayList < String > [[listed]] = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > [[joining]] : beans . entrySet ( ) ) { BeanDefinition beanDefinition = [[joining]] . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , [[sexes]] ) ) { String [[invisible]] = [[joining]] . getKey ( ) ; [[listed]] . add ( [[invisible]] ) ; } } if ( [[listed]] . isEmpty ( ) ) { [[benefiting]] = StringPool . EMPTY_ARRAY ; } else { [[benefiting]] = [[listed]] . toArray ( new String [ 0 ] ) ; } beanCollections . put ( [[sexes]] , [[benefiting]] ) ; return [[benefiting]] ; }
[[[[Nl]]]]: Resolves bean names for give type .
--------------------------------------------- Result 756 ---------------------------------------------
Get a file extension . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [ ] split ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String path ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , path , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .

[[[[Adv]]]]: public static String [ ] split ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String path ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , path , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .
--------------------------------------------- Result 757 ---------------------------------------------
Gets the scope of the given class . --> [[[FAILED]]]

[[[[Adv]]]]: protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope s : allScopes ) { if ( s . getClass ( ) . equals ( madvocScopeType ) ) { return s ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .

[[[[Adv]]]]: protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope s : allScopes ) { if ( s . getClass ( ) . equals ( madvocScopeType ) ) { return s ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .
--------------------------------------------- Result 758 ---------------------------------------------
Registers a bean definition . --> Register bean methods --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; Method [[method]] = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + [[beanDefinition]] . type . getName ( ) + ' ' + methodName ) ; } [[method]] = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md != null ) { [[method]] = md . getMethod ( ) ; } } if ( [[method]] == null ) { throw new PetiteException ( "Method not found: " + [[beanDefinition]] . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] [[ref]] = referencesResolver . resolveReferenceFromValues ( [[method]] , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( [[method]] , [[ref]] ) ; [[beanDefinition]] . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .

[[[[Adv]]]]: public void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { BeanDefinition [[clog]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[clog]] . type ) ; Method [[technique]] = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + [[clog]] . type . getName ( ) + ' ' + methodName ) ; } [[technique]] = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md != null ) { [[technique]] = md . getMethod ( ) ; } } if ( [[technique]] == null ) { throw new PetiteException ( "Method not found: " + [[clog]] . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] [[jawing]] = referencesResolver . resolveReferenceFromValues ( [[technique]] , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( [[technique]] , [[jawing]] ) ; [[clog]] . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .
[Succeeded / Failed / Skipped / Total] 531 / 178 / 50 / 759:  76%|███████▌  | 759/1000 [3:01:13<57:32, 14.33s/it][Succeeded / Failed / Skipped / Total] 531 / 178 / 50 / 759:  76%|███████▌  | 760/1000 [3:01:16<57:14, 14.31s/it][Succeeded / Failed / Skipped / Total] 532 / 178 / 50 / 760:  76%|███████▌  | 760/1000 [3:01:16<57:14, 14.31s/it][Succeeded / Failed / Skipped / Total] 532 / 178 / 50 / 760:  76%|███████▌  | 761/1000 [3:01:19<56:56, 14.30s/it][Succeeded / Failed / Skipped / Total] 533 / 178 / 50 / 761:  76%|███████▌  | 761/1000 [3:01:19<56:56, 14.30s/it][Succeeded / Failed / Skipped / Total] 533 / 178 / 50 / 761:  76%|███████▌  | 762/1000 [3:01:28<56:41, 14.29s/it][Succeeded / Failed / Skipped / Total] 533 / 179 / 50 / 762:  76%|███████▌  | 762/1000 [3:01:28<56:41, 14.29s/it][Succeeded / Failed / Skipped / Total] 533 / 179 / 50 / 762:  76%|███████▋  | 763/1000 [3:01:30<56:22, 14.27s/it]--------------------------------------------- Result 759 ---------------------------------------------
Initializes the bean . --> Initialize the bean methods --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] [[initMethodPoints]] = new InitMethodPoint [ total ] ; int [[i]] ; for ( [[i]] = 0 ; [[i]] < initMethodNames . length ; [[i]] ++ ) { MethodDescriptor [[md]] = cd . getMethodDescriptor ( initMethodNames [ [[i]] ] , ClassUtil . EMPTY_CLASS_ARRAY , "[[True]]" == "[[True]]" ) ; if ( [[md]] == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ [[i]] ] ) ; } [[initMethodPoints]] [ [[i]] ] = new InitMethodPoint ( [[md]] . getMethod ( ) , [[i]] , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( [[initMethodPoints]] ) ; }
[[[[Nl]]]]: Registers init method .

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] [[conman]] = new InitMethodPoint [ total ] ; int [[huh]] ; for ( [[huh]] = 0 ; [[huh]] < initMethodNames . length ; [[huh]] ++ ) { MethodDescriptor [[phd]] = cd . getMethodDescriptor ( initMethodNames [ [[huh]] ] , ClassUtil . EMPTY_CLASS_ARRAY , "[[Candid]]" == "[[Candid]]" ) ; if ( [[phd]] == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ [[huh]] ] ) ; } [[conman]] [ [[huh]] ] = new InitMethodPoint ( [[phd]] . getMethod ( ) , [[huh]] , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( [[conman]] ) ; }
[[[[Nl]]]]: Registers init method .
--------------------------------------------- Result 760 ---------------------------------------------
Destroy the bean --> Destroys a bean definition --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteDestroyMethods]] ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int [[total]] = destroyMethodNames . length ; DestroyMethodPoint [ ] [[destroyMethodPoints]] = new DestroyMethodPoint [ [[total]] ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } [[destroyMethodPoints]] [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( [[destroyMethodPoints]] ) ; }
[[[[Nl]]]]: Registers destroy method .

[[[[Adv]]]]: public void [[confirm]] ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int [[aggregate]] = destroyMethodNames . length ; DestroyMethodPoint [ ] [[sculptors]] = new DestroyMethodPoint [ [[aggregate]] ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } [[sculptors]] [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( [[sculptors]] ) ; }
[[[[Nl]]]]: Registers destroy method .
--------------------------------------------- Result 761 ---------------------------------------------
Register a bean definition . --> Register a bean --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteProvider ( final String [[providerName]] , final String [[beanName]] , final String [[methodName]] , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( [[beanName]] ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + [[beanName]] ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( [[methodName]] , arguments , "[[True]]" == "[[True]]" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + [[methodName]] ) ; } ProviderDefinition [[providerDefinition]] = new ProviderDefinition ( [[providerName]] , [[beanName]] , md . getMethod ( ) ) ; providers . put ( [[providerName]] , [[providerDefinition]] ) ; }
[[[[Nl]]]]: Registers instance method provider .

[[[[Adv]]]]: public void registerPetiteProvider ( final String [[brother]] , final String [[kidnapping]] , final String [[forts]] , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( [[kidnapping]] ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + [[kidnapping]] ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( [[forts]] , arguments , "[[Genuinely]]" == "[[Genuinely]]" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + [[forts]] ) ; } ProviderDefinition [[whatyou]] = new ProviderDefinition ( [[brother]] , [[kidnapping]] , md . getMethod ( ) ) ; providers . put ( [[brother]] , [[whatyou]] ) ; }
[[[[Nl]]]]: Registers instance method provider .
--------------------------------------------- Result 762 ---------------------------------------------
Resolve scope . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .
--------------------------------------------- Result 763 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 534 / 179 / 50 / 763:  76%|███████▋  | 763/1000 [3:01:30<56:22, 14.27s/it][Succeeded / Failed / Skipped / Total] 534 / 179 / 50 / 763:  76%|███████▋  | 764/1000 [3:01:39<56:07, 14.27s/it][Succeeded / Failed / Skipped / Total] 535 / 179 / 50 / 764:  76%|███████▋  | 764/1000 [3:01:39<56:07, 14.27s/it][Succeeded / Failed / Skipped / Total] 535 / 179 / 50 / 764:  76%|███████▋  | 765/1000 [3:01:45<55:50, 14.26s/it][Succeeded / Failed / Skipped / Total] 536 / 179 / 50 / 765:  76%|███████▋  | 765/1000 [3:01:45<55:50, 14.26s/it][Succeeded / Failed / Skipped / Total] 536 / 179 / 50 / 765:  77%|███████▋  | 766/1000 [3:01:53<55:33, 14.25s/it][Succeeded / Failed / Skipped / Total] 536 / 180 / 50 / 766:  77%|███████▋  | 766/1000 [3:01:53<55:33, 14.25s/it][Succeeded / Failed / Skipped / Total] 536 / 180 / 50 / 766:  77%|███████▋  | 767/1000 [3:01:56<55:16, 14.23s/it][Succeeded / Failed / Skipped / Total] 537 / 180 / 50 / 767:  77%|███████▋  | 767/1000 [3:01:56<55:16, 14.23s/it][Succeeded / Failed / Skipped / Total] 537 / 180 / 50 / 767:  77%|███████▋  | 768/1000 [3:01:57<54:57, 14.22s/it][Succeeded / Failed / Skipped / Total] 538 / 180 / 50 / 768:  77%|███████▋  | 768/1000 [3:01:57<54:57, 14.22s/it][Succeeded / Failed / Skipped / Total] 538 / 180 / 50 / 768:  77%|███████▋  | 769/1000 [3:01:57<54:39, 14.20s/it]Register a bean type . --> Convenience method to register a bean --> Socre: 1.0

[[[[Adv]]]]: public void [[forEachBeanType]] ( final Class [[type]] , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , [[type]] ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .

[[[[Adv]]]]: public void [[blushes]] ( final Class [[writing]] , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , [[writing]] ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .
--------------------------------------------- Result 764 ---------------------------------------------
Sets the map of parameters . --> Unmaps a map to a map --> Socre: 1.0

[[[[Adv]]]]: public void [[defineParameters]] ( final Map < ? , ? > [[properties]] ) { for ( Map . Entry < ? , ? > [[entry]] : [[properties]] . entrySet ( ) ) { defineParameter ( [[entry]] . getKey ( ) . toString ( ) , [[entry]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .

[[[[Adv]]]]: public void [[bibi]] ( final Map < ? , ? > [[characteristic]] ) { for ( Map . Entry < ? , ? > [[inbound]] : [[characteristic]] . entrySet ( ) ) { defineParameter ( [[inbound]] . getKey ( ) . toString ( ) , [[inbound]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .
--------------------------------------------- Result 765 ---------------------------------------------
Execute a request . --> Convenience method to get a request --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object [[intercept]] ( final ActionRequest [[actionRequest]] ) throws Exception { printBefore ( [[actionRequest]] ) ; long startTime = System . currentTimeMillis ( ) ; Object result = null ; try { result = [[actionRequest]] . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( [[actionRequest]] , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .

[[[[Adv]]]]: @ Override public Object [[tapping]] ( final ActionRequest [[hazelnut]] ) throws Exception { printBefore ( [[hazelnut]] ) ; long startTime = System . currentTimeMillis ( ) ; Object result = null ; try { result = [[hazelnut]] . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( [[hazelnut]] , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .
--------------------------------------------- Result 766 ---------------------------------------------
Entry point to a file . --> [[[FAILED]]]

[[[[Adv]]]]: protected void scanJarFile ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .

[[[[Adv]]]]: protected void scanJarFile ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .
--------------------------------------------- Result 767 ---------------------------------------------
overrides the visitor to visit the given value . --> overrides the visitor to look for test --> Socre: 1.0

[[[[Adv]]]]: public static void pushInt ( final MethodVisitor [[mv]] , final int value ) { if ( value <= 5 ) { [[mv]] . visitInsn ( ICONST_0 + value ) ; } else if ( value <= Byte . MAX_VALUE ) { [[mv]] . visitIntInsn ( BIPUSH , value ) ; } else { [[mv]] . visitIntInsn ( SIPUSH , value ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .

[[[[Adv]]]]: public static void pushInt ( final MethodVisitor [[tng]] , final int value ) { if ( value <= 5 ) { [[tng]] . visitInsn ( ICONST_0 + value ) ; } else if ( value <= Byte . MAX_VALUE ) { [[tng]] . visitIntInsn ( BIPUSH , value ) ; } else { [[tng]] . visitIntInsn ( SIPUSH , value ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .
--------------------------------------------- Result 768 ---------------------------------------------
Returns the version version . --> Gets the number of times --> Socre: 1.0

[[[[Adv]]]]: public static int [[resolveJavaVersion]] ( final int [[version]] ) { final int [[javaVersionNumber]] = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[platformVersion]] = [[javaVersionNumber]] - 8 + 52 ; return [[version]] > [[platformVersion]] ? [[version]] : [[platformVersion]] ; }
[[[[Nl]]]]: Resolves Java version from current version .

[[[[Adv]]]]: public static int [[wlll]] ( final int [[printout]] ) { final int [[angelus]] = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[portion]] = [[angelus]] - 8 + 52 ; return [[printout]] > [[portion]] ? [[printout]] : [[portion]] ; }
[[[[Nl]]]]: Resolves Java version from current version .
--------------------------------------------- Result 769 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 539 / 180 / 50 / 769:  77%|███████▋  | 769/1000 [3:01:57<54:39, 14.20s/it][Succeeded / Failed / Skipped / Total] 539 / 180 / 50 / 769:  77%|███████▋  | 770/1000 [3:01:59<54:21, 14.18s/it][Succeeded / Failed / Skipped / Total] 540 / 180 / 50 / 770:  77%|███████▋  | 770/1000 [3:01:59<54:21, 14.18s/it][Succeeded / Failed / Skipped / Total] 540 / 180 / 50 / 770:  77%|███████▋  | 771/1000 [3:02:05<54:05, 14.17s/it][Succeeded / Failed / Skipped / Total] 541 / 180 / 50 / 771:  77%|███████▋  | 771/1000 [3:02:05<54:05, 14.17s/it][Succeeded / Failed / Skipped / Total] 541 / 180 / 50 / 771:  77%|███████▋  | 772/1000 [3:02:08<53:47, 14.16s/it][Succeeded / Failed / Skipped / Total] 542 / 180 / 50 / 772:  77%|███████▋  | 772/1000 [3:02:08<53:47, 14.16s/it][Succeeded / Failed / Skipped / Total] 542 / 180 / 50 / 772:  77%|███████▋  | 773/1000 [3:02:12<53:30, 14.14s/it][Succeeded / Failed / Skipped / Total] 543 / 180 / 50 / 773:  77%|███████▋  | 773/1000 [3:02:12<53:30, 14.14s/it][Succeeded / Failed / Skipped / Total] 543 / 180 / 50 / 773:  77%|███████▋  | 774/1000 [3:02:16<53:13, 14.13s/it][Succeeded / Failed / Skipped / Total] 544 / 180 / 50 / 774:  77%|███████▋  | 774/1000 [3:02:16<53:13, 14.13s/it][Succeeded / Failed / Skipped / Total] 544 / 180 / 50 / 774:  78%|███████▊  | 775/1000 [3:02:17<52:55, 14.11s/it]Throws IllegalArgumentException . --> Checks if a method is present --> Socre: 1.0

[[[[Adv]]]]: public static void checkArgumentIndex ( final MethodInfo methodInfo , final int [[argIndex]] ) { if ( ( [[argIndex]] < 1 ) || ( [[argIndex]] > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[argIndex]] ) ; } }
[[[[Nl]]]]: Validates argument index .

[[[[Adv]]]]: public static void checkArgumentIndex ( final MethodInfo methodInfo , final int [[pandas]] ) { if ( ( [[pandas]] < 1 ) || ( [[pandas]] > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[pandas]] ) ; } }
[[[[Nl]]]]: Validates argument index .
--------------------------------------------- Result 770 ---------------------------------------------
Registers a bean definition . --> Register a bean --> Socre: 1.0

[[[[Adv]]]]: public void registerPetitePropertyInjectionPoint ( final String beanName , final String [[property]] , final String [[reference]] ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; PropertyDescriptor [[propertyDescriptor]] = cd . getPropertyDescriptor ( [[property]] , "True" == "True" ) ; if ( [[propertyDescriptor]] == null ) { throw new PetiteException ( "Property not found: " + [[beanDefinition]] . type . getName ( ) + ' ' + [[property]] ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( [[propertyDescriptor]] , [[reference]] ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( [[propertyDescriptor]] , ref ) ; [[beanDefinition]] . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .

[[[[Adv]]]]: public void registerPetitePropertyInjectionPoint ( final String beanName , final String [[regal]] , final String [[citing]] ) { BeanDefinition [[videos]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[videos]] . type ) ; PropertyDescriptor [[hän]] = cd . getPropertyDescriptor ( [[regal]] , "True" == "True" ) ; if ( [[hän]] == null ) { throw new PetiteException ( "Property not found: " + [[videos]] . type . getName ( ) + ' ' + [[regal]] ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( [[hän]] , [[citing]] ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( [[hän]] , ref ) ; [[videos]] . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .
--------------------------------------------- Result 771 ---------------------------------------------
Returns the name of a field with the given name . --> Create a signed signer --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceFieldName]] ( final String name , final int [[index]] ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + [[index]] ; }
[[[[Nl]]]]: Builds advice field name .

[[[[Adv]]]]: public static String [[innards]] ( final String name , final int [[signposts]] ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + [[signposts]] ; }
[[[[Nl]]]]: Builds advice field name .
--------------------------------------------- Result 772 ---------------------------------------------
Create a named method . --> Create a protection --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceMethodName]] ( final String [[name]] , final int index ) { return ProxettaNames . methodPrefix + [[name]] + ProxettaNames . methodDivider + index ; }
[[[[Nl]]]]: Builds advice method name .

[[[[Adv]]]]: public static String [[lubbock]] ( final String [[appoints]] , final int index ) { return ProxettaNames . methodPrefix + [[appoints]] + ProxettaNames . methodDivider + index ; }
[[[[Nl]]]]: Builds advice method name .
--------------------------------------------- Result 773 ---------------------------------------------
Returns true if the given set is valid . --> Returns true if the user has a deletion --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession [[session]] , final String [[tokenValue]] ) { Set < Token > [[tokenSet]] = ( Set < Token > ) [[session]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( [[tokenSet]] == null ) && ( [[tokenValue]] == null ) ) { return "True" == "True" ; } if ( ( [[tokenSet]] == null ) || ( [[tokenValue]] == null ) ) { return "[[False]]" != "[[False]]" ; } boolean [[found]] = "[[False]]" != "[[False]]" ; Iterator < Token > it = [[tokenSet]] . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( [[tokenValue]] ) ) { it . remove ( ) ; [[found]] = "True" == "True" ; } } return [[found]] ; }
[[[[Nl]]]]: Checks token value . C

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession [[meetings]] , final String [[sark]] ) { Set < Token > [[jewry]] = ( Set < Token > ) [[meetings]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( [[jewry]] == null ) && ( [[sark]] == null ) ) { return "True" == "True" ; } if ( ( [[jewry]] == null ) || ( [[sark]] == null ) ) { return "[[Untruthful]]" != "[[Untruthful]]" ; } boolean [[deems]] = "[[Untruthful]]" != "[[Untruthful]]" ; Iterator < Token > it = [[jewry]] . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( [[sark]] ) ) { it . remove ( ) ; [[deems]] = "True" == "True" ; } } return [[deems]] ; }
[[[[Nl]]]]: Checks token value . C
--------------------------------------------- Result 774 ---------------------------------------------
Visit a method . --> overrides the visitor to look for a method --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadMethodArgument]] ( final MethodVisitor [[mv]] , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : [[mv]] . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : [[mv]] . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : [[mv]] . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : [[mv]] . visitVarInsn ( DLOAD , offset ) ; break ; default : [[mv]] . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[abalone]] ( final MethodVisitor [[hms]] , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : [[hms]] . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : [[hms]] . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : [[hms]] . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : [[hms]] . visitVarInsn ( DLOAD , offset ) ; break ; default : [[hms]] . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 775 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 545 / 180 / 50 / 775:  78%|███████▊  | 775/1000 [3:02:17<52:55, 14.11s/it][Succeeded / Failed / Skipped / Total] 545 / 180 / 50 / 775:  78%|███████▊  | 776/1000 [3:02:22<52:38, 14.10s/it][Succeeded / Failed / Skipped / Total] 546 / 180 / 50 / 776:  78%|███████▊  | 776/1000 [3:02:22<52:38, 14.10s/it][Succeeded / Failed / Skipped / Total] 546 / 180 / 50 / 776:  78%|███████▊  | 777/1000 [3:02:23<52:20, 14.08s/it][Succeeded / Failed / Skipped / Total] 547 / 180 / 50 / 777:  78%|███████▊  | 777/1000 [3:02:23<52:20, 14.08s/it][Succeeded / Failed / Skipped / Total] 547 / 180 / 50 / 777:  78%|███████▊  | 778/1000 [3:02:24<52:02, 14.07s/it][Succeeded / Failed / Skipped / Total] 548 / 180 / 50 / 778:  78%|███████▊  | 778/1000 [3:02:24<52:02, 14.07s/it][Succeeded / Failed / Skipped / Total] 548 / 180 / 50 / 778:  78%|███████▊  | 779/1000 [3:02:28<51:45, 14.05s/it]Add a bean definition . --> Register a Property Property --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; PropertyDescriptor [[propertyDescriptor]] = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( [[propertyDescriptor]] == null ) { throw new PetiteException ( "Property not found: " + [[beanDefinition]] . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint [[sip]] = new SetInjectionPoint ( [[propertyDescriptor]] ) ; [[beanDefinition]] . addSetInjectionPoint ( [[sip]] ) ; }
[[[[Nl]]]]: Registers set injection point .

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { BeanDefinition [[aaaaaaah]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[aaaaaaah]] . type ) ; PropertyDescriptor [[wander]] = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( [[wander]] == null ) { throw new PetiteException ( "Property not found: " + [[aaaaaaah]] . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint [[formosa]] = new SetInjectionPoint ( [[wander]] ) ; [[aaaaaaah]] . addSetInjectionPoint ( [[formosa]] ) ; }
[[[[Nl]]]]: Registers set injection point .
--------------------------------------------- Result 776 ---------------------------------------------
Invokes a method . --> implements the visitor to look for testing --> Socre: 1.0

[[[[Adv]]]]: public static void prepareReturnValue ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] , int [[varOffset]] ) { [[varOffset]] += [[methodInfo]] . getAllArgumentsSize ( ) ; switch ( [[methodInfo]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[mv]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[mv]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .

[[[[Adv]]]]: public static void prepareReturnValue ( final MethodVisitor [[warship]] , final MethodInfo [[appleseed]] , int [[fresh]] ) { [[fresh]] += [[appleseed]] . getAllArgumentsSize ( ) ; switch ( [[appleseed]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[warship]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[warship]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[warship]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[warship]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[warship]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[warship]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[warship]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[warship]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[warship]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .
--------------------------------------------- Result 777 ---------------------------------------------
Creates a string representation of a class . --> Build a string representation of a string --> Socre: 1.0

[[[[Adv]]]]: public static String [[createMethodSignaturesKey]] ( final int access , final String methodName , final String description , final String [[className]] ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( [[className]] ) . append ( StringPool . HASH ) . append ( methodName ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .

[[[[Adv]]]]: public static String [[spiral]] ( final int access , final String methodName , final String description , final String [[elvira]] ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( [[elvira]] ) . append ( StringPool . HASH ) . append ( methodName ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .
--------------------------------------------- Result 778 ---------------------------------------------
overrides the visitor to find the method . --> overrides the visitor to look for testing --> Socre: 1.0

[[[[Adv]]]]: public static void storeMethodArgument ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] , final int index ) { int offset = [[methodInfo]] . getArgumentOffset ( index ) ; int type = [[methodInfo]] . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : [[mv]] . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : [[mv]] . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : [[mv]] . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : [[mv]] . visitVarInsn ( DSTORE , offset ) ; break ; default : [[mv]] . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void storeMethodArgument ( final MethodVisitor [[schooner]] , final MethodInfo [[ernie]] , final int index ) { int offset = [[ernie]] . getArgumentOffset ( index ) ; int type = [[ernie]] . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : [[schooner]] . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : [[schooner]] . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : [[schooner]] . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : [[schooner]] . visitVarInsn ( DSTORE , offset ) ; break ; default : [[schooner]] . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 779 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 549 / 180 / 50 / 779:  78%|███████▊  | 779/1000 [3:02:28<51:45, 14.05s/it][Succeeded / Failed / Skipped / Total] 549 / 180 / 50 / 779:  78%|███████▊  | 780/1000 [3:02:28<51:28, 14.04s/it][Succeeded / Failed / Skipped / Total] 550 / 180 / 50 / 780:  78%|███████▊  | 780/1000 [3:02:28<51:28, 14.04s/it][Succeeded / Failed / Skipped / Total] 550 / 180 / 50 / 780:  78%|███████▊  | 781/1000 [3:02:33<51:11, 14.03s/it][Succeeded / Failed / Skipped / Total] 551 / 180 / 50 / 781:  78%|███████▊  | 781/1000 [3:02:33<51:11, 14.03s/it][Succeeded / Failed / Skipped / Total] 551 / 180 / 50 / 781:  78%|███████▊  | 782/1000 [3:02:34<50:53, 14.01s/it][Succeeded / Failed / Skipped / Total] 552 / 180 / 50 / 782:  78%|███████▊  | 782/1000 [3:02:34<50:53, 14.01s/it][Succeeded / Failed / Skipped / Total] 552 / 180 / 50 / 782:  78%|███████▊  | 783/1000 [3:02:37<50:36, 13.99s/it][Succeeded / Failed / Skipped / Total] 553 / 180 / 50 / 783:  78%|███████▊  | 783/1000 [3:02:37<50:36, 13.99s/it][Succeeded / Failed / Skipped / Total] 553 / 180 / 50 / 783:  78%|███████▊  | 784/1000 [3:02:52<50:22, 14.00s/it]Visits the visitor to visit the given type . --> implements the visitor to look for visiting --> Socre: 1.0

[[[[Adv]]]]: public static void newArray ( final MethodVisitor mv , final Class [[componentType]] ) { if ( [[componentType]] == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[componentType]] == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[componentType]] == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[componentType]] == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[componentType]] == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[componentType]] == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[componentType]] == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[componentType]] == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[componentType]] ) ) ; }
[[[[Nl]]]]: Creates new array .

[[[[Adv]]]]: public static void newArray ( final MethodVisitor mv , final Class [[reclining]] ) { if ( [[reclining]] == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[reclining]] == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[reclining]] == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[reclining]] == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[reclining]] == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[reclining]] == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[reclining]] == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[reclining]] == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[reclining]] ) ) ; }
[[[[Nl]]]]: Creates new array .
--------------------------------------------- Result 780 ---------------------------------------------
Visits the given visit type . --> implements the visitor to look for testing --> Socre: 1.0

[[[[Adv]]]]: public static void storeIntoArray ( final MethodVisitor mv , final Class [[componentType]] ) { if ( [[componentType]] == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( [[componentType]] == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( [[componentType]] == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( [[componentType]] == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( [[componentType]] == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[componentType]] == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( [[componentType]] == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[componentType]] == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .

[[[[Adv]]]]: public static void storeIntoArray ( final MethodVisitor mv , final Class [[contained]] ) { if ( [[contained]] == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( [[contained]] == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( [[contained]] == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( [[contained]] == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( [[contained]] == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[contained]] == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( [[contained]] == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[contained]] == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .
--------------------------------------------- Result 781 ---------------------------------------------
Register a provider . --> Register a bean --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteProvider ( final String [[providerName]] , final Class type , final String [[staticMethodName]] , final Class [ ] [[arguments]] ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor [[md]] = cd . getMethodDescriptor ( [[staticMethodName]] , [[arguments]] , "[[True]]" == "[[True]]" ) ; if ( [[md]] == null ) { throw new PetiteException ( "Provider method not found: " + [[staticMethodName]] ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( [[providerName]] , [[md]] . getMethod ( ) ) ; providers . put ( [[providerName]] , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .

[[[[Adv]]]]: public void registerPetiteProvider ( final String [[voom]] , final Class type , final String [[danube]] , final Class [ ] [[quarrels]] ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor [[ks]] = cd . getMethodDescriptor ( [[danube]] , [[quarrels]] , "[[Befitting]]" == "[[Befitting]]" ) ; if ( [[ks]] == null ) { throw new PetiteException ( "Provider method not found: " + [[danube]] ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( [[voom]] , [[ks]] . getMethod ( ) ) ; providers . put ( [[voom]] , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .
--------------------------------------------- Result 782 ---------------------------------------------
load method --> implements the visitor to look for testing --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadSpecialMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] ) { [[mv]] . visitVarInsn ( ALOAD , 0 ) ; for ( int [[i]] = 1 ; [[i]] <= [[methodInfo]] . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( [[mv]] , [[methodInfo]] , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .

[[[[Adv]]]]: public static void [[capabilities]] ( final MethodVisitor [[scow]] , final MethodInfo [[mcginty]] ) { [[scow]] . visitVarInsn ( ALOAD , 0 ) ; for ( int [[me]] = 1 ; [[me]] <= [[mcginty]] . getArgumentsCount ( ) ; [[me]] ++ ) { loadMethodArgument ( [[scow]] , [[mcginty]] , [[me]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .
--------------------------------------------- Result 783 ---------------------------------------------
Returns the default encoding for the given encoding . --> Obtain the active active active bar --> Socre: 1.0

[[[[Adv]]]]: public static String [[extractEncoding]] ( final String [[contentType]] , String [[defaultEncoding]] ) { String [[encoding]] = [[extractEncoding]] ( [[contentType]] ) ; if ( [[encoding]] == null ) { if ( [[defaultEncoding]] == null ) { [[defaultEncoding]] = JoddCore . encoding ; } [[encoding]] = [[defaultEncoding]] ; } return [[encoding]] ; }
[[[[Nl]]]]: Extracts encoding from a given content type .

[[[[Adv]]]]: public static String [[bargained]] ( final String [[amnesiac]] , String [[purist]] ) { String [[unattractive]] = [[bargained]] ( [[amnesiac]] ) ; if ( [[unattractive]] == null ) { if ( [[purist]] == null ) { [[purist]] = JoddCore . encoding ; } [[unattractive]] = [[purist]] ; } return [[unattractive]] ; }
[[[[Nl]]]]: Extracts encoding from a given content type .
--------------------------------------------- Result 784 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 554 / 180 / 50 / 784:  78%|███████▊  | 784/1000 [3:02:52<50:22, 14.00s/it][Succeeded / Failed / Skipped / Total] 554 / 180 / 50 / 784:  78%|███████▊  | 785/1000 [3:02:55<50:05, 13.98s/it][Succeeded / Failed / Skipped / Total] 554 / 181 / 50 / 785:  78%|███████▊  | 785/1000 [3:02:55<50:05, 13.98s/it][Succeeded / Failed / Skipped / Total] 554 / 181 / 50 / 785:  79%|███████▊  | 786/1000 [3:03:00<49:49, 13.97s/it][Succeeded / Failed / Skipped / Total] 555 / 181 / 50 / 786:  79%|███████▊  | 786/1000 [3:03:00<49:49, 13.97s/it][Succeeded / Failed / Skipped / Total] 555 / 181 / 50 / 786:  79%|███████▊  | 787/1000 [3:03:04<49:33, 13.96s/it][Succeeded / Failed / Skipped / Total] 556 / 181 / 50 / 787:  79%|███████▊  | 787/1000 [3:03:04<49:33, 13.96s/it][Succeeded / Failed / Skipped / Total] 556 / 181 / 50 / 787:  79%|███████▉  | 788/1000 [3:03:10<49:16, 13.95s/it][Succeeded / Failed / Skipped / Total] 557 / 181 / 50 / 788:  79%|███████▉  | 788/1000 [3:03:10<49:16, 13.95s/it][Succeeded / Failed / Skipped / Total] 557 / 181 / 50 / 788:  79%|███████▉  | 789/1000 [3:03:12<48:59, 13.93s/it][Succeeded / Failed / Skipped / Total] 558 / 181 / 50 / 789:  79%|███████▉  | 789/1000 [3:03:12<48:59, 13.93s/it][Succeeded / Failed / Skipped / Total] 558 / 181 / 50 / 789:  79%|███████▉  | 790/1000 [3:03:17<48:43, 13.92s/it][Succeeded / Failed / Skipped / Total] 559 / 181 / 50 / 790:  79%|███████▉  | 790/1000 [3:03:17<48:43, 13.92s/it][Succeeded / Failed / Skipped / Total] 559 / 181 / 50 / 790:  79%|███████▉  | 791/1000 [3:03:20<48:26, 13.91s/it]Send an HTTP response to the client . --> Send a HttpServlet response --> Socre: 1.0

[[[[Adv]]]]: public static void [[requireAuthentication]] ( final HttpServletResponse [[resp]] , final String [[realm]] ) throws IOException { [[resp]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + [[realm]] + ' ' ) ; [[resp]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .

[[[[Adv]]]]: public static void [[nailed]] ( final HttpServletResponse [[watty]] , final String [[purview]] ) throws IOException { [[watty]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + [[purview]] + ' ' ) ; [[watty]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .
--------------------------------------------- Result 785 ---------------------------------------------
Returns the system flags . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean isEmptyFlags ( Flags flags ) { if ( flags == null ) return "True" == "True" ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = flags . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags

[[[[Adv]]]]: public static boolean isEmptyFlags ( Flags flags ) { if ( flags == null ) return "True" == "True" ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = flags . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags
--------------------------------------------- Result 786 ---------------------------------------------
Returns the HTTP header . --> Get a ities from a string --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveAuthBearerToken]] ( final HttpServletRequest [[request]] ) { String [[header]] = [[request]] . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[header]] == null ) { return null ; } int [[ndx]] = [[header]] . indexOf ( "Bearer " ) ; if ( [[ndx]] == - 1 ) { return null ; } return [[header]] . substring ( [[ndx]] + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .

[[[[Adv]]]]: public static String [[pronto]] ( final HttpServletRequest [[prays]] ) { String [[securities]] = [[prays]] . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[securities]] == null ) { return null ; } int [[deputation]] = [[securities]] . indexOf ( "Bearer " ) ; if ( [[deputation]] == - 1 ) { return null ; } return [[securities]] . substring ( [[deputation]] + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .
--------------------------------------------- Result 787 ---------------------------------------------
Set the mime type . --> Set the mime type --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareResponse]] ( final HttpServletResponse [[response]] , final String fileName , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String [[extension]] = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( [[extension]] ) ; } if ( mimeType != null ) { [[response]] . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { [[response]] . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .

[[[[Adv]]]]: public static void [[germ]] ( final HttpServletResponse [[riposte]] , final String fileName , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String [[broaden]] = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( [[broaden]] ) ; } if ( mimeType != null ) { [[riposte]] . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { [[riposte]] . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .
--------------------------------------------- Result 788 ---------------------------------------------
Read the request from the request . --> Convenience method for creating a HttpServletRequest --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromReader]] ( final HttpServletRequest [[request]] ) throws IOException { BufferedReader [[buff]] = [[request]] . getReader ( ) ; StringWriter [[out]] = new StringWriter ( ) ; StreamUtil . copy ( [[buff]] , [[out]] ) ; return [[out]] . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[collate]] ( final HttpServletRequest [[demanding]] ) throws IOException { BufferedReader [[uber]] = [[demanding]] . getReader ( ) ; StringWriter [[externally]] = new StringWriter ( ) ; StreamUtil . copy ( [[uber]] , [[externally]] ) ; return [[externally]] . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!
--------------------------------------------- Result 789 ---------------------------------------------
Returns a list of cookies . --> Return a list of invromers --> Socre: 1.0

[[[[Adv]]]]: public static Cookie [ ] [[getAllCookies]] ( final HttpServletRequest [[request]] , final String [[cookieName]] ) { Cookie [ ] [[cookies]] = [[request]] . getCookies ( ) ; if ( [[cookies]] == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( [[cookies]] . length ) ; for ( Cookie [[cookie]] : [[cookies]] ) { if ( [[cookie]] . getName ( ) . equals ( [[cookieName]] ) ) { list . add ( [[cookie]] ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .

[[[[Adv]]]]: public static Cookie [ ] [[stun]] ( final HttpServletRequest [[invite]] , final String [[dispirited]] ) { Cookie [ ] [[meringues]] = [[invite]] . getCookies ( ) ; if ( [[meringues]] == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( [[meringues]] . length ) ; for ( Cookie [[croissants]] : [[meringues]] ) { if ( [[croissants]] . getName ( ) . equals ( [[dispirited]] ) ) { list . add ( [[croissants]] ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .
--------------------------------------------- Result 790 ---------------------------------------------
Set the servlet context . --> Method to set the ServletRequest --> Socre: 1.0

[[[[Adv]]]]: public static void storeContextPath ( final PageContext pageContext , final String [[contextPathVariableName]] ) { String [[ctxPath]] = getContextPath ( pageContext ) ; HttpServletRequest [[request]] = ( HttpServletRequest ) pageContext . getRequest ( ) ; [[request]] . setAttribute ( [[contextPathVariableName]] , [[ctxPath]] ) ; ServletContext [[servletContext]] = pageContext . getServletContext ( ) ; [[servletContext]] . setAttribute ( [[contextPathVariableName]] , [[ctxPath]] ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .

[[[[Adv]]]]: public static void storeContextPath ( final PageContext pageContext , final String [[links]] ) { String [[rez]] = getContextPath ( pageContext ) ; HttpServletRequest [[please]] = ( HttpServletRequest ) pageContext . getRequest ( ) ; [[please]] . setAttribute ( [[links]] , [[rez]] ) ; ServletContext [[grudges]] = pageContext . getServletContext ( ) ; [[grudges]] . setAttribute ( [[links]] , [[rez]] ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .
--------------------------------------------- Result 791 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 560 / 181 / 50 / 791:  79%|███████▉  | 791/1000 [3:03:20<48:26, 13.91s/it][Succeeded / Failed / Skipped / Total] 560 / 181 / 50 / 791:  79%|███████▉  | 792/1000 [3:03:37<48:13, 13.91s/it][Succeeded / Failed / Skipped / Total] 561 / 181 / 50 / 792:  79%|███████▉  | 792/1000 [3:03:37<48:13, 13.91s/it][Succeeded / Failed / Skipped / Total] 561 / 181 / 50 / 792:  79%|███████▉  | 793/1000 [3:03:38<47:56, 13.89s/it][Succeeded / Failed / Skipped / Total] 561 / 182 / 50 / 793:  79%|███████▉  | 793/1000 [3:03:38<47:56, 13.89s/it][Succeeded / Failed / Skipped / Total] 561 / 182 / 50 / 793:  79%|███████▉  | 794/1000 [3:03:39<47:38, 13.88s/it][Succeeded / Failed / Skipped / Total] 562 / 182 / 50 / 794:  79%|███████▉  | 794/1000 [3:03:39<47:38, 13.88s/it][Succeeded / Failed / Skipped / Total] 562 / 182 / 50 / 794:  80%|███████▉  | 795/1000 [3:03:41<47:22, 13.86s/it][Succeeded / Failed / Skipped / Total] 563 / 182 / 50 / 795:  80%|███████▉  | 795/1000 [3:03:41<47:22, 13.86s/it][Succeeded / Failed / Skipped / Total] 563 / 182 / 50 / 795:  80%|███████▉  | 796/1000 [3:03:47<47:06, 13.85s/it][Succeeded / Failed / Skipped / Total] 564 / 182 / 50 / 796:  80%|███████▉  | 796/1000 [3:03:47<47:06, 13.85s/it][Succeeded / Failed / Skipped / Total] 564 / 182 / 50 / 796:  80%|███████▉  | 797/1000 [3:03:48<46:49, 13.84s/it][Succeeded / Failed / Skipped / Total] 565 / 182 / 50 / 797:  80%|███████▉  | 797/1000 [3:03:48<46:49, 13.84s/it][Succeeded / Failed / Skipped / Total] 565 / 182 / 50 / 797:  80%|███████▉  | 798/1000 [3:03:56<46:33, 13.83s/it]Read a request from a stream . --> Get a reader from a reader --> Socre: 1.0

[[[[Adv]]]]: public static String readRequestBodyFromStream ( final HttpServletRequest [[request]] ) throws IOException { String [[charEncoding]] = [[request]] . getCharacterEncoding ( ) ; if ( [[charEncoding]] == null ) { [[charEncoding]] = JoddCore . encoding ; } CharArrayWriter [[charArrayWriter]] = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream [[inputStream]] = [[request]] . getInputStream ( ) ; if ( [[inputStream]] != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( [[inputStream]] , [[charEncoding]] ) ) ; StreamUtil . copy ( bufferedReader , [[charArrayWriter]] ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return [[charArrayWriter]] . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String readRequestBodyFromStream ( final HttpServletRequest [[call]] ) throws IOException { String [[gangs]] = [[call]] . getCharacterEncoding ( ) ; if ( [[gangs]] == null ) { [[gangs]] = JoddCore . encoding ; } CharArrayWriter [[squid]] = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream [[agro]] = [[call]] . getInputStream ( ) ; if ( [[agro]] != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( [[agro]] , [[gangs]] ) ) ; StreamUtil . copy ( bufferedReader , [[squid]] ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return [[squid]] . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!
--------------------------------------------- Result 792 ---------------------------------------------
Returns the value of the request parameter . --> Convert a string to a String --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] prepareParameters ( final String [ ] paramValues , final boolean [[treatEmptyParamsAsNull]] , final boolean [[ignoreEmptyRequestParams]] ) { if ( [[treatEmptyParamsAsNull]] || [[ignoreEmptyRequestParams]] ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int i = 0 ; i < paramValues . length ; i ++ ) { String paramValue = paramValues [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( [[treatEmptyParamsAsNull]] ) { paramValue = null ; } } paramValues [ i ] = paramValue ; } if ( ( [[ignoreEmptyRequestParams]] ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .

[[[[Adv]]]]: public static String [ ] prepareParameters ( final String [ ] paramValues , final boolean [[sportswriter]] , final boolean [[isidore]] ) { if ( [[sportswriter]] || [[isidore]] ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int i = 0 ; i < paramValues . length ; i ++ ) { String paramValue = paramValues [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( [[sportswriter]] ) { paramValue = null ; } } paramValues [ i ] = paramValue ; } if ( ( [[isidore]] ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .
--------------------------------------------- Result 793 ---------------------------------------------
Sets the servlet context . --> [[[FAILED]]]

[[[[Adv]]]]: public static void storeContextPath ( final ServletContext servletContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( servletContext ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .

[[[[Adv]]]]: public static void storeContextPath ( final ServletContext servletContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( servletContext ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .
--------------------------------------------- Result 794 ---------------------------------------------
Generates an body tag . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static void invokeBody ( final JspFragment [[body]] ) throws JspException { if ( [[body]] == null ) { return ; } try { [[body]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .

[[[[Adv]]]]: public static void invokeBody ( final JspFragment [[entities]] ) throws JspException { if ( [[entities]] == null ) { return ; } try { [[entities]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .
--------------------------------------------- Result 795 ---------------------------------------------
Render the given body . --> Construct a FastStr from a given FASTA --> Socre: 1.0

[[[[Adv]]]]: public static char [ ] [[renderBody]] ( final JspFragment [[body]] ) throws JspException { FastCharArrayWriter [[writer]] = new FastCharArrayWriter ( ) ; invokeBody ( [[body]] , [[writer]] ) ; return [[writer]] . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .

[[[[Adv]]]]: public static char [ ] [[fraternizing]] ( final JspFragment [[org]] ) throws JspException { FastCharArrayWriter [[wrote]] = new FastCharArrayWriter ( ) ; invokeBody ( [[org]] , [[wrote]] ) ; return [[wrote]] . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .
--------------------------------------------- Result 796 ---------------------------------------------
Load information from a method . --> Load a list of vocads --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadStaticMethodArguments]] ( final MethodVisitor mv , final MethodInfo [[methodInfo]] ) { for ( int [[i]] = 0 ; [[i]] < [[methodInfo]] . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( mv , [[methodInfo]] , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .

[[[[Adv]]]]: public static void [[ddn]] ( final MethodVisitor mv , final MethodInfo [[jacobson]] ) { for ( int [[siento]] = 0 ; [[siento]] < [[jacobson]] . getArgumentsCount ( ) ; [[siento]] ++ ) { loadMethodArgument ( mv , [[jacobson]] , [[siento]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .
--------------------------------------------- Result 797 ---------------------------------------------
Initialize the invocation . --> Initializes the bean --> Socre: 1.0

[[[[Adv]]]]: public void [[invokeInitMethods]] ( final InitMethodInvocationStrategy [[invocationStrategy]] ) { for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { if ( [[invocationStrategy]] != initMethod . invocationStrategy ) { continue ; } try { initMethod . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + initMethod , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .

[[[[Adv]]]]: public void [[gogol]] ( final InitMethodInvocationStrategy [[unknowns]] ) { for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { if ( [[unknowns]] != initMethod . invocationStrategy ) { continue ; } try { initMethod . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + initMethod , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .
--------------------------------------------- Result 798 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 566 / 182 / 50 / 798:  80%|███████▉  | 798/1000 [3:03:56<46:33, 13.83s/it][Succeeded / Failed / Skipped / Total] 566 / 182 / 50 / 798:  80%|███████▉  | 799/1000 [3:04:02<46:17, 13.82s/it][Succeeded / Failed / Skipped / Total] 567 / 182 / 50 / 799:  80%|███████▉  | 799/1000 [3:04:02<46:17, 13.82s/it][Succeeded / Failed / Skipped / Total] 567 / 182 / 50 / 799:  80%|████████  | 800/1000 [3:04:06<46:01, 13.81s/it][Succeeded / Failed / Skipped / Total] 568 / 182 / 50 / 800:  80%|████████  | 800/1000 [3:04:06<46:01, 13.81s/it][Succeeded / Failed / Skipped / Total] 568 / 182 / 50 / 800:  80%|████████  | 801/1000 [3:04:17<45:47, 13.80s/it][Succeeded / Failed / Skipped / Total] 569 / 182 / 50 / 801:  80%|████████  | 801/1000 [3:04:17<45:47, 13.80s/it][Succeeded / Failed / Skipped / Total] 569 / 182 / 50 / 801:  80%|████████  | 802/1000 [3:04:33<45:33, 13.81s/it][Succeeded / Failed / Skipped / Total] 570 / 182 / 50 / 802:  80%|████████  | 802/1000 [3:04:33<45:33, 13.81s/it][Succeeded / Failed / Skipped / Total] 570 / 182 / 50 / 802:  80%|████████  | 803/1000 [3:04:35<45:17, 13.79s/it][Succeeded / Failed / Skipped / Total] 571 / 182 / 50 / 803:  80%|████████  | 803/1000 [3:04:35<45:17, 13.79s/it][Succeeded / Failed / Skipped / Total] 571 / 182 / 50 / 803:  80%|████████  | 804/1000 [3:04:36<45:00, 13.78s/it][Succeeded / Failed / Skipped / Total] 572 / 182 / 50 / 804:  80%|████████  | 804/1000 [3:04:36<45:00, 13.78s/it][Succeeded / Failed / Skipped / Total] 572 / 182 / 50 / 804:  80%|████████  | 805/1000 [3:04:36<44:43, 13.76s/it]Returns the value of the request parameter . --> Convert a request to a string --> Socre: 1.0

[[[[Adv]]]]: public boolean isGetParameter ( final HttpServletRequest request , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String [[query]] = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( [[query]] , ' ' ) ; for ( String [[nameValuePair]] : nameValuePairs ) { if ( [[nameValuePair]] . startsWith ( name ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .

[[[[Adv]]]]: public boolean isGetParameter ( final HttpServletRequest request , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String [[visualize]] = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( [[visualize]] , ' ' ) ; for ( String [[consigliere]] : nameValuePairs ) { if ( [[consigliere]] . startsWith ( name ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .
--------------------------------------------- Result 799 ---------------------------------------------
Destroy a method . --> Unregister a bean --> Socre: 1.0

[[[[Adv]]]]: public void [[callDestroyMethods]] ( ) { for ( final DestroyMethodPoint destroyMethodPoint : beanDefinition . destroyMethodPoints ( ) ) { try { destroyMethodPoint . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + destroyMethodPoint . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .

[[[[Adv]]]]: public void [[tubular]] ( ) { for ( final DestroyMethodPoint destroyMethodPoint : beanDefinition . destroyMethodPoints ( ) ) { try { destroyMethodPoint . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + destroyMethodPoint . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .
--------------------------------------------- Result 800 ---------------------------------------------
Convert a request to a request . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static void [[copyParamsToAttributes]] ( final HttpServletRequest [[servletRequest]] , final boolean [[treatEmptyParamsAsNull]] , final boolean [[ignoreEmptyRequestParams]] ) { Enumeration paramNames = [[servletRequest]] . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String [[paramName]] = ( String ) paramNames . nextElement ( ) ; if ( [[servletRequest]] . getAttribute ( [[paramName]] ) != null ) { continue ; } String [ ] paramValues = [[servletRequest]] . getParameterValues ( [[paramName]] ) ; paramValues = prepareParameters ( paramValues , [[treatEmptyParamsAsNull]] , [[ignoreEmptyRequestParams]] ) ; if ( paramValues == null ) { continue ; } [[servletRequest]] . setAttribute ( [[paramName]] , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .

[[[[Adv]]]]: public static void [[densely]] ( final HttpServletRequest [[contested]] , final boolean [[formulas]] , final boolean [[strawberry]] ) { Enumeration paramNames = [[contested]] . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String [[spill]] = ( String ) paramNames . nextElement ( ) ; if ( [[contested]] . getAttribute ( [[spill]] ) != null ) { continue ; } String [ ] paramValues = [[contested]] . getParameterValues ( [[spill]] ) ; paramValues = prepareParameters ( paramValues , [[formulas]] , [[strawberry]] ) ; if ( paramValues == null ) { continue ; } [[contested]] . setAttribute ( [[spill]] , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .
--------------------------------------------- Result 801 ---------------------------------------------
Render body . --> Creates a new facet --> Socre: 1.0

[[[[Adv]]]]: public static String [[renderBodyToString]] ( final JspFragment [[body]] ) throws JspException { char [ ] [[result]] = renderBody ( [[body]] ) ; return new String ( [[result]] ) ; }
[[[[Nl]]]]: Renders tag body to string .

[[[[Adv]]]]: public static String [[prophets]] ( final JspFragment [[cadavers]] ) throws JspException { char [ ] [[resultant]] = renderBody ( [[cadavers]] ) ; return new String ( [[resultant]] ) ; }
[[[[Nl]]]]: Renders tag body to string .
--------------------------------------------- Result 802 ---------------------------------------------
Adds a value to the list . --> Recursive method to add a given denomination --> Socre: 1.0

[[[[Adv]]]]: public void [[addHeader]] ( final String [[name]] , final String [[value]] ) { List < String > valuesList = super . getAll ( [[name]] ) ; if ( valuesList . isEmpty ( ) ) { super . add ( [[name]] , [[value]] ) ; return ; } super . remove ( [[name]] ) ; valuesList . add ( [[value]] ) ; super . addAll ( [[name]] , valuesList ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .

[[[[Adv]]]]: public void [[await]] ( final String [[denomination]] , final String [[merited]] ) { List < String > valuesList = super . getAll ( [[denomination]] ) ; if ( valuesList . isEmpty ( ) ) { super . add ( [[denomination]] , [[merited]] ) ; return ; } super . remove ( [[denomination]] ) ; valuesList . add ( [[merited]] ) ; super . addAll ( [[denomination]] , valuesList ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .
--------------------------------------------- Result 803 ---------------------------------------------
Add a value to the map . --> Add principal . --> Socre: 1.0

[[[[Adv]]]]: protected void put ( final String profile , final Map < String , PropsEntry > map , final String [[key]] , final String [[value]] , final boolean append ) { String realValue = [[value]] ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( [[key]] ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry [[propsEntry]] = new PropsEntry ( [[key]] , realValue , profile , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties

[[[[Adv]]]]: protected void put ( final String profile , final Map < String , PropsEntry > map , final String [[principal]] , final String [[valor]] , final boolean append ) { String realValue = [[valor]] ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( [[principal]] ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry [[herman]] = new PropsEntry ( [[principal]] , realValue , profile , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties
--------------------------------------------- Result 804 ---------------------------------------------
Load method . --> Attempts to load a vooouo zabservation --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadVirtualMethodArguments]] ( final MethodVisitor mv , final MethodInfo [[methodInfo]] ) { for ( int [[i]] = 1 ; [[i]] <= [[methodInfo]] . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( mv , [[methodInfo]] , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .

[[[[Adv]]]]: public static void [[lapping]] ( final MethodVisitor mv , final MethodInfo [[kazuya]] ) { for ( int [[wo]] = 1 ; [[wo]] <= [[kazuya]] . getArgumentsCount ( ) ; [[wo]] ++ ) { loadMethodArgument ( mv , [[kazuya]] , [[wo]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .
--------------------------------------------- Result 805 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 573 / 182 / 50 / 805:  80%|████████  | 805/1000 [3:04:36<44:43, 13.76s/it][Succeeded / Failed / Skipped / Total] 573 / 182 / 50 / 805:  81%|████████  | 806/1000 [3:04:41<44:27, 13.75s/it][Succeeded / Failed / Skipped / Total] 574 / 182 / 50 / 806:  81%|████████  | 806/1000 [3:04:41<44:27, 13.75s/it][Succeeded / Failed / Skipped / Total] 574 / 182 / 50 / 806:  81%|████████  | 807/1000 [3:04:42<44:10, 13.73s/it][Succeeded / Failed / Skipped / Total] 575 / 182 / 50 / 807:  81%|████████  | 807/1000 [3:04:42<44:10, 13.73s/it][Succeeded / Failed / Skipped / Total] 575 / 182 / 50 / 807:  81%|████████  | 808/1000 [3:04:47<43:54, 13.72s/it][Succeeded / Failed / Skipped / Total] 576 / 182 / 50 / 808:  81%|████████  | 808/1000 [3:04:47<43:54, 13.72s/it][Succeeded / Failed / Skipped / Total] 576 / 182 / 50 / 808:  81%|████████  | 809/1000 [3:04:48<43:38, 13.71s/it][Succeeded / Failed / Skipped / Total] 577 / 182 / 50 / 809:  81%|████████  | 809/1000 [3:04:48<43:38, 13.71s/it][Succeeded / Failed / Skipped / Total] 577 / 182 / 50 / 809:  81%|████████  | 810/1000 [3:04:51<43:21, 13.69s/it][Succeeded / Failed / Skipped / Total] 578 / 182 / 50 / 810:  81%|████████  | 810/1000 [3:04:51<43:21, 13.69s/it][Succeeded / Failed / Skipped / Total] 578 / 182 / 50 / 810:  81%|████████  | 811/1000 [3:05:02<43:07, 13.69s/it][Succeeded / Failed / Skipped / Total] 579 / 182 / 50 / 811:  81%|████████  | 811/1000 [3:05:02<43:07, 13.69s/it][Succeeded / Failed / Skipped / Total] 579 / 182 / 50 / 811:  81%|████████  | 812/1000 [3:05:14<42:53, 13.69s/it][Succeeded / Failed / Skipped / Total] 580 / 182 / 50 / 812:  81%|████████  | 812/1000 [3:05:14<42:53, 13.69s/it][Succeeded / Failed / Skipped / Total] 580 / 182 / 50 / 812:  81%|████████▏ | 813/1000 [3:05:17<42:37, 13.68s/it]Replies the request . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String [[rewrite]] ( final HttpServletRequest [[servletRequest]] , final String actionPath , final String httpMethod ) { return actionPath ; }
[[[[Nl]]]]: Rewrites action path .

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String [[redefine]] ( final HttpServletRequest [[seguro]] , final String actionPath , final String httpMethod ) { return actionPath ; }
[[[[Nl]]]]: Rewrites action path .
--------------------------------------------- Result 806 ---------------------------------------------
Adds a property . --> Add a value to the appender --> Socre: 1.0

[[[[Adv]]]]: public void [[putBaseProperty]] ( final String key , final String value , final boolean append ) { put ( null , baseProperties , key , value , append ) ; }
[[[[Nl]]]]: Adds base property .

[[[[Adv]]]]: public void [[heady]] ( final String key , final String value , final boolean append ) { put ( null , baseProperties , key , value , append ) ; }
[[[[Nl]]]]: Adds base property .
--------------------------------------------- Result 807 ---------------------------------------------
Resolves a value . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveMacros]] ( String value , final String ... [[profiles]] ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .

[[[[Adv]]]]: public String [[boron]] ( String value , final String ... [[depiction]] ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .
--------------------------------------------- Result 808 ---------------------------------------------
Returns the profile for the given profile . --> Obtains a grant for the given performance --> Socre: 1.0

[[[[Adv]]]]: public PropsEntry getProfileProperty ( final String [[profile]] , final String [[key]] ) { final Map < String , PropsEntry > [[profileMap]] = profileProperties . get ( [[profile]] ) ; if ( [[profileMap]] == null ) { return null ; } return [[profileMap]] . get ( [[key]] ) ; }
[[[[Nl]]]]: Returns profile property .

[[[[Adv]]]]: public PropsEntry getProfileProperty ( final String [[portrait]] , final String [[transcendent]] ) { final Map < String , PropsEntry > [[radhe]] = profileProperties . get ( [[portrait]] ) ; if ( [[radhe]] == null ) { return null ; } return [[radhe]] . get ( [[transcendent]] ) ; }
[[[[Nl]]]]: Returns profile property .
--------------------------------------------- Result 809 ---------------------------------------------
Sets the profile . --> Convert a String to a String --> Socre: 1.0

[[[[Adv]]]]: public void putProfileProperty ( final String key , final String value , final String [[profile]] , final boolean append ) { Map < String , PropsEntry > [[map]] = profileProperties . computeIfAbsent ( [[profile]] , k -> new HashMap <> ( ) ) ; put ( [[profile]] , [[map]] , key , value , append ) ; }
[[[[Nl]]]]: Adds profile property .

[[[[Adv]]]]: public void putProfileProperty ( final String key , final String value , final String [[outline]] , final boolean append ) { Map < String , PropsEntry > [[libretto]] = profileProperties . computeIfAbsent ( [[outline]] , k -> new HashMap <> ( ) ) ; put ( [[outline]] , [[libretto]] , key , value , append ) ; }
[[[[Nl]]]]: Adds profile property .
--------------------------------------------- Result 810 ---------------------------------------------
Encrypt a password . --> Convert salt to salt --> Socre: 1.0

[[[[Adv]]]]: public static String [[hashpw]] ( String password , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .

[[[[Adv]]]]: public static String [[expeditions]] ( String password , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .
--------------------------------------------- Result 811 ---------------------------------------------
Converts a byte array to a byte array . --> Compare two byte arrays --> Socre: 1.0

[[[[Adv]]]]: private static int [[streamtoword]] ( byte [ ] data , int [ ] offp ) { int i ; int word = 0 ; int off = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { word = ( word << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .

[[[[Adv]]]]: private static int [[nickels]] ( byte [ ] data , int [ ] offp ) { int i ; int word = 0 ; int off = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { word = ( word << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .
--------------------------------------------- Result 812 ---------------------------------------------
Sets the bean . --> Unregister a Bean --> Socre: 1.0

[[[[Adv]]]]: public void [[injectParams]] ( final ParamManager paramManager , final boolean [[implicitParamInjection]] ) { if ( beanDefinition . name == null ) { return ; } if ( [[implicitParamInjection]] ) {
[[[[Nl]]]]: Injects all parameters .

[[[[Adv]]]]: public void [[piecework]] ( final ParamManager paramManager , final boolean [[sink]] ) { if ( beanDefinition . name == null ) { return ; } if ( [[sink]] ) {
[[[[Nl]]]]: Injects all parameters .
--------------------------------------------- Result 813 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 580 / 183 / 50 / 813:  81%|████████▏ | 813/1000 [3:05:17<42:37, 13.68s/it][Succeeded / Failed / Skipped / Total] 580 / 183 / 50 / 813:  81%|████████▏ | 814/1000 [3:05:20<42:21, 13.66s/it][Succeeded / Failed / Skipped / Total] 581 / 183 / 50 / 814:  81%|████████▏ | 814/1000 [3:05:20<42:21, 13.66s/it][Succeeded / Failed / Skipped / Total] 581 / 183 / 50 / 814:  82%|████████▏ | 815/1000 [3:05:28<42:06, 13.65s/it][Succeeded / Failed / Skipped / Total] 582 / 183 / 50 / 815:  82%|████████▏ | 815/1000 [3:05:28<42:06, 13.65s/it][Succeeded / Failed / Skipped / Total] 582 / 183 / 50 / 815:  82%|████████▏ | 816/1000 [3:05:30<41:49, 13.64s/it][Succeeded / Failed / Skipped / Total] 583 / 183 / 50 / 816:  82%|████████▏ | 816/1000 [3:05:30<41:49, 13.64s/it][Succeeded / Failed / Skipped / Total] 583 / 183 / 50 / 816:  82%|████████▏ | 817/1000 [3:05:37<41:34, 13.63s/it][Succeeded / Failed / Skipped / Total] 584 / 183 / 50 / 817:  82%|████████▏ | 817/1000 [3:05:37<41:34, 13.63s/it][Succeeded / Failed / Skipped / Total] 584 / 183 / 50 / 817:  82%|████████▏ | 818/1000 [3:05:46<41:19, 13.63s/it][Succeeded / Failed / Skipped / Total] 585 / 183 / 50 / 818:  82%|████████▏ | 818/1000 [3:05:46<41:19, 13.63s/it][Succeeded / Failed / Skipped / Total] 585 / 183 / 50 / 818:  82%|████████▏ | 819/1000 [3:06:05<41:07, 13.63s/it][Succeeded / Failed / Skipped / Total] 586 / 183 / 50 / 819:  82%|████████▏ | 819/1000 [3:06:05<41:07, 13.63s/it][Succeeded / Failed / Skipped / Total] 586 / 183 / 50 / 819:  82%|████████▏ | 820/1000 [3:06:12<40:52, 13.63s/it]Resolves beans . --> [[[FAILED]]]

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .
--------------------------------------------- Result 814 ---------------------------------------------
Parses an action . --> Resolve a ActionAnnotation --> Socre: 1.0

[[[[Adv]]]]: public ActionRuntime parse ( final Class < ? > [[actionClass]] , final Method [[actionMethod]] , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( [[actionMethod]] ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .

[[[[Adv]]]]: public ActionRuntime parse ( final Class < ? > [[cying]] , final Method [[mcdougal]] , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( [[mcdougal]] ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .
--------------------------------------------- Result 815 ---------------------------------------------
Extracts a map from a map . --> Return a new molecule --> Socre: 1.0

[[[[Adv]]]]: public Map [[extract]] ( Map [[target]] , final String [ ] [[profiles]] , final String [ ] [[wildcardPatterns]] , String [[prefix]] ) { if ( [[target]] == null ) { [[target]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .

[[[[Adv]]]]: public Map [[recuperate]] ( Map [[aspirations]] , final String [ ] [[describing]] , final String [ ] [[motherhood]] , String [[encrypted]] ) { if ( [[aspirations]] == null ) { [[aspirations]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .
--------------------------------------------- Result 816 ---------------------------------------------
Downloads a file . --> Depending on the filesystem --> Socre: 1.0

[[[[Adv]]]]: public static void prepareDownload ( final HttpServletResponse [[response]] , final File [[file]] , final String mimeType ) { if ( ! [[file]] . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + [[file]] ) ; } if ( [[file]] . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + [[file]] ) ; } prepareResponse ( [[response]] , [[file]] . getAbsolutePath ( ) , mimeType , ( int ) [[file]] . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .

[[[[Adv]]]]: public static void prepareDownload ( final HttpServletResponse [[speech]] , final File [[deposit]] , final String mimeType ) { if ( ! [[deposit]] . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + [[deposit]] ) ; } if ( [[deposit]] . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + [[deposit]] ) ; } prepareResponse ( [[speech]] , [[deposit]] . getAbsolutePath ( ) , mimeType , ( int ) [[deposit]] . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .
--------------------------------------------- Result 817 ---------------------------------------------
Reads a number of bytes . -->  --> Socre: 0.9999999999745633

[[[[Adv]]]]: public int copyAll ( final OutputStream [[out]] ) throws IOException { int count = 0 ; while ( "[[True]]" == "[[True]]" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } [[out]] . write ( b ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .

[[[[Adv]]]]: public int copyAll ( final OutputStream [[outward]] ) throws IOException { int count = 0 ; while ( "[[Dignified]]" == "[[Dignified]]" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } [[outward]] . write ( b ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .
--------------------------------------------- Result 818 ---------------------------------------------
Resolve the annotation . --> Get the annotation type --> Socre: 1.0

[[[[Adv]]]]: protected ActionConfig [[resolveActionConfig]] ( final ActionAnnotationValues [[annotationValues]] ) { final Class < ? extends Annotation > annotationType ; if ( [[annotationValues]] == null ) { annotationType = Action . class ; } else { annotationType = [[annotationValues]] . annotationType ( ) ; } return actionConfigManager . lookup ( annotationType ) ; }
[[[[Nl]]]]: Resolves action config .

[[[[Adv]]]]: protected ActionConfig [[chateaubriand]] ( final ActionAnnotationValues [[homme]] ) { final Class < ? extends Annotation > annotationType ; if ( [[homme]] == null ) { annotationType = Action . class ; } else { annotationType = [[homme]] . annotationType ( ) ; } return actionConfigManager . lookup ( annotationType ) ; }
[[[[Nl]]]]: Resolves action config .
--------------------------------------------- Result 819 ---------------------------------------------
Register a alias definition . --> Register a deletion --> Socre: 1.0

[[[[Adv]]]]: protected void [[detectAndRegisterAlias]] ( final ActionAnnotationValues [[annotationValues]] , final ActionDefinition [[actionDefinition]] ) { final String [[alias]] = parseMethodAlias ( [[annotationValues]] ) ; if ( [[alias]] != null ) { String [[aliasPath]] = StringUtil . cutToIndexOf ( [[actionDefinition]] . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( [[alias]] , [[aliasPath]] ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .

[[[[Adv]]]]: protected void [[maggiore]] ( final ActionAnnotationValues [[pour]] , final ActionDefinition [[hangout]] ) { final String [[faked]] = parseMethodAlias ( [[pour]] ) ; if ( [[faked]] != null ) { String [[siao]] = StringUtil . cutToIndexOf ( [[hangout]] . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( [[faked]] , [[siao]] ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .
[Succeeded / Failed / Skipped / Total] 587 / 183 / 50 / 820:  82%|████████▏ | 820/1000 [3:06:12<40:52, 13.63s/it][Succeeded / Failed / Skipped / Total] 587 / 183 / 50 / 820:  82%|████████▏ | 821/1000 [3:06:20<40:37, 13.62s/it][Succeeded / Failed / Skipped / Total] 588 / 183 / 50 / 821:  82%|████████▏ | 821/1000 [3:06:20<40:37, 13.62s/it][Succeeded / Failed / Skipped / Total] 588 / 183 / 50 / 821:  82%|████████▏ | 822/1000 [3:06:35<40:24, 13.62s/it][Succeeded / Failed / Skipped / Total] 589 / 183 / 50 / 822:  82%|████████▏ | 822/1000 [3:06:35<40:24, 13.62s/it][Succeeded / Failed / Skipped / Total] 589 / 183 / 50 / 822:  82%|████████▏ | 823/1000 [3:06:35<40:07, 13.60s/it][Succeeded / Failed / Skipped / Total] 589 / 183 / 51 / 823:  82%|████████▏ | 823/1000 [3:06:35<40:07, 13.60s/it][Succeeded / Failed / Skipped / Total] 589 / 183 / 51 / 823:  82%|████████▏ | 824/1000 [3:06:38<39:51, 13.59s/it][Succeeded / Failed / Skipped / Total] 590 / 183 / 51 / 824:  82%|████████▏ | 824/1000 [3:06:38<39:51, 13.59s/it][Succeeded / Failed / Skipped / Total] 590 / 183 / 51 / 824:  82%|████████▎ | 825/1000 [3:06:40<39:35, 13.58s/it][Succeeded / Failed / Skipped / Total] 591 / 183 / 51 / 825:  82%|████████▎ | 825/1000 [3:06:40<39:35, 13.58s/it][Succeeded / Failed / Skipped / Total] 591 / 183 / 51 / 825:  83%|████████▎ | 826/1000 [3:06:41<39:19, 13.56s/it][Succeeded / Failed / Skipped / Total] 592 / 183 / 51 / 826:  83%|████████▎ | 826/1000 [3:06:41<39:19, 13.56s/it][Succeeded / Failed / Skipped / Total] 592 / 183 / 51 / 826:  83%|████████▎ | 827/1000 [3:06:47<39:04, 13.55s/it][Succeeded / Failed / Skipped / Total] 593 / 183 / 51 / 827:  83%|████████▎ | 827/1000 [3:06:47<39:04, 13.55s/it][Succeeded / Failed / Skipped / Total] 593 / 183 / 51 / 827:  83%|████████▎ | 828/1000 [3:06:48<38:48, 13.54s/it][Succeeded / Failed / Skipped / Total] 594 / 183 / 51 / 828:  83%|████████▎ | 828/1000 [3:06:48<38:48, 13.54s/it][Succeeded / Failed / Skipped / Total] 594 / 183 / 51 / 828:  83%|████████▎ | 829/1000 [3:06:52<38:32, 13.53s/it]--------------------------------------------- Result 820 ---------------------------------------------
Gets the package name . --> Method to get the packages --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readPackageActionPath]] ( final Class [[actionClass]] ) { Package [[actionPackage]] = [[actionClass]] . getPackage ( ) ; final String actionPackageName = [[actionPackage]] . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .

[[[[Adv]]]]: protected String [ ] [[renters]] ( final Class [[prosecutions]] ) { Package [[masterson]] = [[prosecutions]] . getPackage ( ) ; final String actionPackageName = [[masterson]] . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .
--------------------------------------------- Result 821 ---------------------------------------------
Reads annotation . --> Converts a description to a string representation --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readMethodActionPath]] ( final String [[methodName]] , final ActionAnnotationValues [[annotationValues]] , final ActionConfig [[actionConfig]] ) {
[[[[Nl]]]]: Reads action path from the action method .

[[[[Adv]]]]: protected String [ ] [[jana]] ( final String [[polat]] , final ActionAnnotationValues [[minarets]] , final ActionConfig [[walcott]] ) {
[[[[Nl]]]]: Reads action path from the action method .
--------------------------------------------- Result 822 ---------------------------------------------
Gets the filtered . --> Obtains the set of Groooobservations --> Socre: 1.0

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[readActionFilters]] ( final AnnotatedElement [[actionClassOrMethod]] ) { Class < ? extends ActionFilter > [ ] [[result]] = null ; FilteredBy [[filteredBy]] = [[actionClassOrMethod]] . getAnnotation ( FilteredBy . class ) ; if ( [[filteredBy]] != null ) { [[result]] = [[filteredBy]] . value ( ) ; if ( [[result]] . length == 0 ) { [[result]] = null ; } } return [[result]] ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[nitroglycerine]] ( final AnnotatedElement [[yassin]] ) { Class < ? extends ActionFilter > [ ] [[observations]] = null ; FilteredBy [[flatland]] = [[yassin]] . getAnnotation ( FilteredBy . class ) ; if ( [[flatland]] != null ) { [[observations]] = [[flatland]] . value ( ) ; if ( [[observations]] . length == 0 ) { [[observations]] = null ; } } return [[observations]] ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .
--------------------------------------------- Result 823 ---------------------------------------------
Sets the response . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override protected void preResponseCommit ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( "Last-Modified" , lastModified ) ; } else { response . reset ( ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; } } }
[[[[Nl]]]]: todo move to BufferResponseWrapper ?
--------------------------------------------- Result 824 ---------------------------------------------
Interprets the specified class . --> A convenience method for creating a JAXA --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] > [[T]] applyAdvice ( final Class < [[T]] > targetClass ) { Class [[adviceClass]] = cache . get ( targetClass ) ; if ( [[adviceClass]] == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .

[[[[Adv]]]]: public static < [[quantity]] > [[quantity]] applyAdvice ( final Class < [[quantity]] > targetClass ) { Class [[anaemic]] = cache . get ( targetClass ) ; if ( [[anaemic]] == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .
--------------------------------------------- Result 825 ---------------------------------------------
Gets the method annotations . --> Return a ClassInterceptor --> Socre: 1.0

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[readActionInterceptors]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionInterceptor > [ ] [[result]] = null ; InterceptedBy [[interceptedBy]] = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; if ( [[interceptedBy]] != null ) { [[result]] = [[interceptedBy]] . value ( ) ; if ( [[result]] . length == 0 ) { [[result]] = null ; } } return [[result]] ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[schilling]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionInterceptor > [ ] [[fruition]] = null ; InterceptedBy [[xiao]] = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; if ( [[xiao]] != null ) { [[fruition]] = [[xiao]] . value ( ) ; if ( [[fruition]] . length == 0 ) { [[fruition]] = null ; } } return [[fruition]] ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .
--------------------------------------------- Result 826 ---------------------------------------------
Parses a alias . --> Convert a string to a larm --> Socre: 1.0

[[[[Adv]]]]: protected String [[parseMethodAlias]] ( final ActionAnnotationValues [[annotationValues]] ) { String [[alias]] = null ; if ( [[annotationValues]] != null ) { [[alias]] = [[annotationValues]] . alias ( ) ; } return [[alias]] ; }
[[[[Nl]]]]: Reads method s alias value .

[[[[Adv]]]]: protected String [[chrysalis]] ( final ActionAnnotationValues [[worthless]] ) { String [[fictional]] = null ; if ( [[worthless]] != null ) { [[fictional]] = [[worthless]] . alias ( ) ; } return [[fictional]] ; }
[[[[Nl]]]]: Reads method s alias value .
--------------------------------------------- Result 827 ---------------------------------------------
Visit a annotation . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public AnnotationVisitor [[visitAnnotation]] ( final String [[descriptor]] , final boolean [[visible]] ) { if ( fv != null ) { return fv . visitAnnotation ( [[descriptor]] , [[visible]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .

[[[[Adv]]]]: public AnnotationVisitor [[till]] ( final String [[bossy]] , final boolean [[striking]] ) { if ( fv != null ) { return fv . visitAnnotation ( [[bossy]] , [[striking]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .
--------------------------------------------- Result 828 ---------------------------------------------
Sets the value of a proxy . --> Set a class to a object --> Socre: 1.0

[[[[Adv]]]]: public static void [[injectTargetIntoProxy]] ( final Object [[proxy]] , final Object [[target]] ) { Class [[proxyClass]] = [[proxy]] . getClass ( ) ; try { Field [[field]] = [[proxyClass]] . getField ( "$___target$0" ) ; [[field]] . set ( [[proxy]] , [[target]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .

[[[[Adv]]]]: public static void [[tactless]] ( final Object [[options]] , final Object [[purpose]] ) { Class [[seznam]] = [[options]] . getClass ( ) ; try { Field [[territory]] = [[seznam]] . getField ( "$___target$0" ) ; [[territory]] . set ( [[options]] , [[purpose]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .
--------------------------------------------- Result 829 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 595 / 183 / 51 / 829:  83%|████████▎ | 829/1000 [3:06:52<38:32, 13.53s/it][Succeeded / Failed / Skipped / Total] 595 / 183 / 51 / 829:  83%|████████▎ | 830/1000 [3:06:54<38:16, 13.51s/it][Succeeded / Failed / Skipped / Total] 596 / 183 / 51 / 830:  83%|████████▎ | 830/1000 [3:06:54<38:16, 13.51s/it][Succeeded / Failed / Skipped / Total] 596 / 183 / 51 / 830:  83%|████████▎ | 831/1000 [3:06:55<38:00, 13.50s/it][Succeeded / Failed / Skipped / Total] 597 / 183 / 51 / 831:  83%|████████▎ | 831/1000 [3:06:55<38:00, 13.50s/it][Succeeded / Failed / Skipped / Total] 597 / 183 / 51 / 831:  83%|████████▎ | 832/1000 [3:08:02<37:58, 13.56s/it][Succeeded / Failed / Skipped / Total] 598 / 183 / 51 / 832:  83%|████████▎ | 832/1000 [3:08:02<37:58, 13.56s/it][Succeeded / Failed / Skipped / Total] 598 / 183 / 51 / 832:  83%|████████▎ | 833/1000 [3:08:15<37:44, 13.56s/it][Succeeded / Failed / Skipped / Total] 599 / 183 / 51 / 833:  83%|████████▎ | 833/1000 [3:08:15<37:44, 13.56s/it][Succeeded / Failed / Skipped / Total] 599 / 183 / 51 / 833:  83%|████████▎ | 834/1000 [3:08:16<37:28, 13.54s/it][Succeeded / Failed / Skipped / Total] 600 / 183 / 51 / 834:  83%|████████▎ | 834/1000 [3:08:16<37:28, 13.54s/it][Succeeded / Failed / Skipped / Total] 600 / 183 / 51 / 834:  84%|████████▎ | 835/1000 [3:08:39<37:16, 13.56s/it][Succeeded / Failed / Skipped / Total] 601 / 183 / 51 / 835:  84%|████████▎ | 835/1000 [3:08:39<37:16, 13.56s/it][Succeeded / Failed / Skipped / Total] 601 / 183 / 51 / 835:  84%|████████▎ | 836/1000 [3:08:58<37:04, 13.56s/it][Succeeded / Failed / Skipped / Total] 602 / 183 / 51 / 836:  84%|████████▎ | 836/1000 [3:08:58<37:04, 13.56s/it][Succeeded / Failed / Skipped / Total] 602 / 183 / 51 / 836:  84%|████████▎ | 837/1000 [3:09:06<36:49, 13.56s/it][Succeeded / Failed / Skipped / Total] 602 / 184 / 51 / 837:  84%|████████▎ | 837/1000 [3:09:06<36:49, 13.56s/it][Succeeded / Failed / Skipped / Total] 602 / 184 / 51 / 837:  84%|████████▍ | 838/1000 [3:09:17<36:35, 13.55s/it]Get the name of the json . --> Returns the index of the practivities --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final String [[jsonName]] ) { if ( jsonNames == null ) { return [[jsonName]] ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , [[jsonName]] ) ; if ( jsonIndex == - 1 ) { return [[jsonName]] ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .

[[[[Adv]]]]: public String [[altair]] ( final String [[whiplash]] ) { if ( jsonNames == null ) { return [[whiplash]] ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , [[whiplash]] ) ; if ( jsonIndex == - 1 ) { return [[whiplash]] ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .
--------------------------------------------- Result 830 ---------------------------------------------
Returns the name of the given name . --> Converts a String to a String representation --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final String [[realName]] ) { if ( realNames == null ) { return [[realName]] ; } int [[realIndex]] = ArraysUtil . indexOf ( realNames , [[realName]] ) ; if ( [[realIndex]] == - 1 ) { return [[realName]] ; } return jsonNames [ [[realIndex]] ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .

[[[[Adv]]]]: public String [[pings]] ( final String [[eerie]] ) { if ( realNames == null ) { return [[eerie]] ; } int [[shai]] = ArraysUtil . indexOf ( realNames , [[eerie]] ) ; if ( [[shai]] == - 1 ) { return [[eerie]] ; } return jsonNames [ [[shai]] ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .
--------------------------------------------- Result 831 ---------------------------------------------
Finds the annotation data type . --> Convenience method for creating a heap --> Socre: 1.0

[[[[Adv]]]]: protected TypeData [[findSubclassTypeData]] ( final Class type ) { final Class < ? extends Annotation > [[defaultAnnotation]] = jsonAnnotation ; if ( type . getAnnotation ( [[defaultAnnotation]] ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .

[[[[Adv]]]]: protected TypeData [[carwash]] ( final Class type ) { final Class < ? extends Annotation > [[cheap]] = jsonAnnotation ; if ( type . getAnnotation ( [[cheap]] ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .
--------------------------------------------- Result 832 ---------------------------------------------
Returns the UTF - 8 . --> Obtains the &lt ; --> Socre: 1.0

[[[[Adv]]]]: public static boolean checkpw ( String plaintext , String [[hashed]] ) { byte [ ] [[hashed_bytes]] ; byte [ ] try_bytes ; try { String try_pw = hashpw ( plaintext , [[hashed]] ) ; [[hashed_bytes]] = [[hashed]] . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "[[False]]" != "[[False]]" ; } if ( [[hashed_bytes]] . length != try_bytes . length ) { return "[[False]]" != "[[False]]" ; } byte [[ret]] = 0 ; for ( int [[i]] = 0 ; [[i]] < try_bytes . length ; [[i]] ++ ) { [[ret]] |= [[hashed_bytes]] [ [[i]] ] ^ try_bytes [ [[i]] ] ; } return [[ret]] == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .

[[[[Adv]]]]: public static boolean checkpw ( String plaintext , String [[plunge]] ) { byte [ ] [[castration]] ; byte [ ] try_bytes ; try { String try_pw = hashpw ( plaintext , [[plunge]] ) ; [[castration]] = [[plunge]] . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "[[Disingenuous]]" != "[[Disingenuous]]" ; } if ( [[castration]] . length != try_bytes . length ) { return "[[Disingenuous]]" != "[[Disingenuous]]" ; } byte [[ree]] = 0 ; for ( int [[could]] = 0 ; [[could]] < try_bytes . length ; [[could]] ++ ) { [[ree]] |= [[castration]] [ [[could]] ] ^ try_bytes [ [[could]] ] ; } return [[ree]] == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .
--------------------------------------------- Result 833 ---------------------------------------------
Resolves a type . --> Resolve a type --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final Class type , final String [[jsonName]] ) { TypeData [[typeData]] = lookupTypeData ( type ) ; return [[typeData]] . resolveRealName ( [[jsonName]] ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .

[[[[Adv]]]]: public String [[flavors]] ( final Class type , final String [[adrift]] ) { TypeData [[wook]] = lookupTypeData ( type ) ; return [[wook]] . resolveRealName ( [[adrift]] ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .
--------------------------------------------- Result 834 ---------------------------------------------
Get the type . --> Convert a chart to a chart --> Socre: 1.0

[[[[Adv]]]]: protected TypeData [[_lookupTypeData]] ( final Class [[type]] ) { TypeData [[typeData]] = typeDataMap . get ( [[type]] ) ; if ( [[typeData]] == null ) { [[typeData]] = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , [[typeData]] ) ; } return [[typeData]] ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .

[[[[Adv]]]]: protected TypeData [[bartel]] ( final Class [[tipo]] ) { TypeData [[charters]] = typeDataMap . get ( [[tipo]] ) ; if ( [[charters]] == null ) { [[charters]] = scanClassForAnnotations ( [[tipo]] ) ; typeDataMap . put ( [[tipo]] , [[charters]] ) ; } return [[charters]] ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .
--------------------------------------------- Result 835 ---------------------------------------------
Add a reader to the reader . --> A convenience method for creating a Reader --> Socre: 1.0

[[[[Adv]]]]: private void copyBootstrapMethods ( final ClassReader [[classReader]] , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .

[[[[Adv]]]]: private void copyBootstrapMethods ( final ClassReader [[maxine]] , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .
--------------------------------------------- Result 836 ---------------------------------------------
Resolve type . --> Resolve maven --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final Class [[type]] , final String [[name]] ) { TypeData [[typeData]] = lookupTypeData ( [[type]] ) ; return [[typeData]] . resolveJsonName ( [[name]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .

[[[[Adv]]]]: public String [[anchorman]] ( final Class [[classes]] , final String [[naming]] ) { TypeData [[neve]] = lookupTypeData ( [[classes]] ) ; return [[neve]] . resolveJsonName ( [[naming]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .
--------------------------------------------- Result 837 ---------------------------------------------
Creates a new bean instance . --> [[[FAILED]]]

[[[[Adv]]]]: public Object newBeanInstance ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .

[[[[Adv]]]]: public Object newBeanInstance ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .
--------------------------------------------- Result 838 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 602 / 185 / 51 / 838:  84%|████████▍ | 838/1000 [3:09:17<36:35, 13.55s/it][Succeeded / Failed / Skipped / Total] 602 / 185 / 51 / 838:  84%|████████▍ | 839/1000 [3:09:26<36:21, 13.55s/it][Succeeded / Failed / Skipped / Total] 603 / 185 / 51 / 839:  84%|████████▍ | 839/1000 [3:09:26<36:21, 13.55s/it][Succeeded / Failed / Skipped / Total] 603 / 185 / 51 / 839:  84%|████████▍ | 840/1000 [3:09:32<36:06, 13.54s/it][Succeeded / Failed / Skipped / Total] 604 / 185 / 51 / 840:  84%|████████▍ | 840/1000 [3:09:32<36:06, 13.54s/it][Succeeded / Failed / Skipped / Total] 604 / 185 / 51 / 840:  84%|████████▍ | 841/1000 [3:09:41<35:51, 13.53s/it][Succeeded / Failed / Skipped / Total] 605 / 185 / 51 / 841:  84%|████████▍ | 841/1000 [3:09:41<35:51, 13.53s/it][Succeeded / Failed / Skipped / Total] 605 / 185 / 51 / 841:  84%|████████▍ | 842/1000 [3:09:41<35:35, 13.52s/it][Succeeded / Failed / Skipped / Total] 606 / 185 / 51 / 842:  84%|████████▍ | 842/1000 [3:09:41<35:35, 13.52s/it][Succeeded / Failed / Skipped / Total] 606 / 185 / 51 / 842:  84%|████████▍ | 843/1000 [3:09:42<35:19, 13.50s/it][Succeeded / Failed / Skipped / Total] 607 / 185 / 51 / 843:  84%|████████▍ | 843/1000 [3:09:42<35:19, 13.50s/it][Succeeded / Failed / Skipped / Total] 607 / 185 / 51 / 843:  84%|████████▍ | 844/1000 [3:09:47<35:04, 13.49s/it]Registers bean definition . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .

[[[[Adv]]]]: public void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .
--------------------------------------------- Result 839 ---------------------------------------------
Adds a new field . --> Declarative Services method --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantFieldref]] ( final String [[owner]] , final String [[name]] , final String [[descriptor]] ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , [[owner]] , [[name]] , [[descriptor]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[goalie]] ( final String [[cardholder]] , final String [[designate]] , final String [[fetus]] ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , [[cardholder]] , [[designate]] , [[fetus]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 840 ---------------------------------------------
Returns the content of the file . --> Read data from byte array --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[getFileContent]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .

[[[[Adv]]]]: @ Override public byte [ ] [[ait]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .
--------------------------------------------- Result 841 ---------------------------------------------
Add bootstrap bootstrap bootstrap . -->  --> Socre: 0.999999999930856

[[[[Adv]]]]: void [[putBootstrapMethods]] ( final ByteVector [[output]] ) { if ( bootstrapMethods != null ) { [[output]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .

[[[[Adv]]]]: void [[leather]] ( final ByteVector [[revenue]] ) { if ( bootstrapMethods != null ) { [[revenue]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .
--------------------------------------------- Result 842 ---------------------------------------------
Add a boolean member . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantMethodref]] ( final String [[owner]] , final String [[name]] , final String [[descriptor]] , final boolean [[isInterface]] ) { int tag = [[isInterface]] ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , [[owner]] , [[name]] , [[descriptor]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[manav]] ( final String [[possessing]] , final String [[nominations]] , final String [[hottest]] , final boolean [[shopkeepers]] ) { int tag = [[shopkeepers]] ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , [[possessing]] , [[nominations]] , [[hottest]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 843 ---------------------------------------------
Adds a reference to the list . -->  --> Socre: 0.999999999930856

[[[[Adv]]]]: private void addConstantMemberReference ( final int index , final int tag , final String owner , final String [[name]] , final String [[descriptor]] ) { add ( new Entry ( index , tag , owner , [[name]] , [[descriptor]] , 0 , hash ( tag , owner , [[name]] , [[descriptor]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantMemberReference ( final int index , final int tag , final String owner , final String [[nom]] , final String [[toughened]] ) { add ( new Entry ( index , tag , owner , [[nom]] , [[toughened]] , 0 , hash ( tag , owner , [[nom]] , [[toughened]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .
--------------------------------------------- Result 844 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 608 / 185 / 51 / 844:  84%|████████▍ | 844/1000 [3:09:47<35:04, 13.49s/it][Succeeded / Failed / Skipped / Total] 608 / 185 / 51 / 844:  84%|████████▍ | 845/1000 [3:09:49<34:49, 13.48s/it][Succeeded / Failed / Skipped / Total] 609 / 185 / 51 / 845:  84%|████████▍ | 845/1000 [3:09:49<34:49, 13.48s/it][Succeeded / Failed / Skipped / Total] 609 / 185 / 51 / 845:  85%|████████▍ | 846/1000 [3:10:11<34:37, 13.49s/it][Succeeded / Failed / Skipped / Total] 610 / 185 / 51 / 846:  85%|████████▍ | 846/1000 [3:10:11<34:37, 13.49s/it][Succeeded / Failed / Skipped / Total] 610 / 185 / 51 / 846:  85%|████████▍ | 847/1000 [3:12:09<34:42, 13.61s/it][Succeeded / Failed / Skipped / Total] 611 / 185 / 51 / 847:  85%|████████▍ | 847/1000 [3:12:09<34:42, 13.61s/it][Succeeded / Failed / Skipped / Total] 611 / 185 / 51 / 847:  85%|████████▍ | 848/1000 [3:12:22<34:29, 13.61s/it][Succeeded / Failed / Skipped / Total] 611 / 186 / 51 / 848:  85%|████████▍ | 848/1000 [3:12:22<34:29, 13.61s/it][Succeeded / Failed / Skipped / Total] 611 / 186 / 51 / 848:  85%|████████▍ | 849/1000 [3:12:23<34:13, 13.60s/it][Succeeded / Failed / Skipped / Total] 611 / 187 / 51 / 849:  85%|████████▍ | 849/1000 [3:12:23<34:13, 13.60s/it][Succeeded / Failed / Skipped / Total] 611 / 187 / 51 / 849:  85%|████████▌ | 850/1000 [3:15:41<34:31, 13.81s/it][Succeeded / Failed / Skipped / Total] 611 / 188 / 51 / 850:  85%|████████▌ | 850/1000 [3:15:41<34:31, 13.81s/it][Succeeded / Failed / Skipped / Total] 611 / 188 / 51 / 850:  85%|████████▌ | 851/1000 [3:15:55<34:18, 13.81s/it]Add a version . --> Add a new generaster --> Socre: 1.0

[[[[Adv]]]]: int [[setMajorVersionAndClassName]] ( final int [[majorVersion]] , final String [[className]] ) { this . [[majorVersion]] = [[majorVersion]] ; this . [[className]] = [[className]] ; return addConstantClass ( [[className]] ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .

[[[[Adv]]]]: int [[fille]] ( final int [[flecks]] , final String [[bannister]] ) { this . [[lage]] = [[flecks]] ; this . [[customize]] = [[bannister]] ; return addConstantClass ( [[bannister]] ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .
--------------------------------------------- Result 845 ---------------------------------------------
Add a pool entry . --> Auxiliary method for testing --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantLongOrDouble]] ( final int tag , final long [[value]] ) { int [[hashCode]] = hash ( tag , [[value]] ) ; Entry [[entry]] = get ( [[hashCode]] ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == tag && [[entry]] . hashCode == [[hashCode]] && [[entry]] . data == [[value]] ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } int [[index]] = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( [[value]] ) ; constantPoolCount += 2 ; return put ( new Entry ( [[index]] , tag , [[value]] , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[consensual]] ( final int tag , final long [[appraisal]] ) { int [[ushered]] = hash ( tag , [[appraisal]] ) ; Entry [[influx]] = get ( [[ushered]] ) ; while ( [[influx]] != null ) { if ( [[influx]] . tag == tag && [[influx]] . hashCode == [[ushered]] && [[influx]] . data == [[appraisal]] ) { return [[influx]] ; } [[influx]] = [[influx]] . next ; } int [[pager]] = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( [[appraisal]] ) ; constantPoolCount += 2 ; return put ( new Entry ( [[pager]] , tag , [[appraisal]] , [[ushered]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 846 ---------------------------------------------
Creates a new scope action . --> Factory method to create a scope --> Socre: 1.0

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler [[actionHandler]] , final Class [[actionClass]] , final Method actionClassMethod , final Class < ? extends ActionResult > [[actionResult]] , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] [[interceptors]] , final ActionDefinition [[actionDefinition]] , final boolean async , final boolean auth ) { if ( [[actionHandler]] != null ) { return new ActionRuntime ( [[actionHandler]] , [[actionClass]] , actionClassMethod , filters , [[interceptors]] , [[actionDefinition]] , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( [[actionClass]] ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler [[wle]] , final Class [[lyons]] , final Method actionClassMethod , final Class < ? extends ActionResult > [[kundan]] , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] [[missile]] , final ActionDefinition [[stoddard]] , final boolean async , final boolean auth ) { if ( [[wle]] != null ) { return new ActionRuntime ( [[wle]] , [[lyons]] , actionClassMethod , filters , [[missile]] , [[stoddard]] , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( [[lyons]] ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .
--------------------------------------------- Result 847 ---------------------------------------------
Put constant pool . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: void [[putConstantPool]] ( final ByteVector [[output]] ) { [[output]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .

[[[[Adv]]]]: void [[smuggles]] ( final ByteVector [[products]] ) { [[products]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .
--------------------------------------------- Result 848 ---------------------------------------------
Gets the type for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public TypeData lookupTypeData ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( type ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } } return typeData ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .

[[[[Adv]]]]: public TypeData lookupTypeData ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( type ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } } return typeData ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .
--------------------------------------------- Result 849 ---------------------------------------------
Writes the bytes to the output stream . --> [[[FAILED]]]

[[[[Adv]]]]: public int copyMax ( final OutputStream out , final int maxBytes ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == maxBytes ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .

[[[[Adv]]]]: public int copyMax ( final OutputStream out , final int maxBytes ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == maxBytes ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .
--------------------------------------------- Result 850 ---------------------------------------------
Adds a value to the list . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantIntegerOrFloat ( final int index , final int tag , final int value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantIntegerOrFloat ( final int index , final int tag , final int value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .
--------------------------------------------- Result 851 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 611 / 189 / 51 / 851:  85%|████████▌ | 851/1000 [3:15:55<34:18, 13.81s/it][Succeeded / Failed / Skipped / Total] 611 / 189 / 51 / 851:  85%|████████▌ | 852/1000 [3:15:58<34:02, 13.80s/it][Succeeded / Failed / Skipped / Total] 612 / 189 / 51 / 852:  85%|████████▌ | 852/1000 [3:15:58<34:02, 13.80s/it][Succeeded / Failed / Skipped / Total] 612 / 189 / 51 / 852:  85%|████████▌ | 853/1000 [3:17:19<34:00, 13.88s/it][Succeeded / Failed / Skipped / Total] 612 / 190 / 51 / 853:  85%|████████▌ | 853/1000 [3:17:19<34:00, 13.88s/it][Succeeded / Failed / Skipped / Total] 612 / 190 / 51 / 853:  85%|████████▌ | 854/1000 [3:17:31<33:46, 13.88s/it][Succeeded / Failed / Skipped / Total] 612 / 191 / 51 / 854:  85%|████████▌ | 854/1000 [3:17:31<33:46, 13.88s/it][Succeeded / Failed / Skipped / Total] 612 / 191 / 51 / 854:  86%|████████▌ | 855/1000 [3:17:44<33:32, 13.88s/it][Succeeded / Failed / Skipped / Total] 612 / 192 / 51 / 855:  86%|████████▌ | 855/1000 [3:17:44<33:32, 13.88s/it][Succeeded / Failed / Skipped / Total] 612 / 192 / 51 / 855:  86%|████████▌ | 856/1000 [3:18:38<33:24, 13.92s/it][Succeeded / Failed / Skipped / Total] 612 / 193 / 51 / 856:  86%|████████▌ | 856/1000 [3:18:38<33:24, 13.92s/it][Succeeded / Failed / Skipped / Total] 612 / 193 / 51 / 856:  86%|████████▌ | 857/1000 [3:19:01<33:12, 13.93s/it]Adds an entry to the set . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantLongOrDouble ( final int index , final int tag , final long value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantLongOrDouble ( final int index , final int tag , final long value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .
--------------------------------------------- Result 852 ---------------------------------------------
Add Method . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantMethodHandle]] ( final int [[referenceKind]] , final String owner , final String [[name]] , final String [[descriptor]] , final boolean isInterface ) { final int [[tag]] = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[barbe]] ( final int [[fillmore]] , final String owner , final String [[surnames]] , final String [[nabbing]] , final boolean isInterface ) { final int [[brand]] = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 853 ---------------------------------------------
Adds a pool entry . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 854 ---------------------------------------------
Adds a constant pool entry . --> [[[FAILED]]]

[[[[Adv]]]]: int addConstantNameAndType ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int addConstantNameAndType ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 855 ---------------------------------------------
Adds a UTF8 constant . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantUtf8 ( final int index , final String value ) { add ( new Entry ( index , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantUtf8 ( final int index , final String value ) { add ( new Entry ( index , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .
--------------------------------------------- Result 856 ---------------------------------------------
Add an attribute . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantNameAndType ( final int index , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantNameAndType ( final int index , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .
--------------------------------------------- Result 857 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 612 / 194 / 51 / 857:  86%|████████▌ | 857/1000 [3:19:01<33:12, 13.93s/it][Succeeded / Failed / Skipped / Total] 612 / 194 / 51 / 857:  86%|████████▌ | 858/1000 [3:19:11<32:58, 13.93s/it][Succeeded / Failed / Skipped / Total] 612 / 195 / 51 / 858:  86%|████████▌ | 858/1000 [3:19:11<32:58, 13.93s/it][Succeeded / Failed / Skipped / Total] 612 / 195 / 51 / 858:  86%|████████▌ | 859/1000 [3:19:27<32:44, 13.93s/it][Succeeded / Failed / Skipped / Total] 613 / 195 / 51 / 859:  86%|████████▌ | 859/1000 [3:19:27<32:44, 13.93s/it][Succeeded / Failed / Skipped / Total] 613 / 195 / 51 / 859:  86%|████████▌ | 860/1000 [3:21:33<32:48, 14.06s/it][Succeeded / Failed / Skipped / Total] 614 / 195 / 51 / 860:  86%|████████▌ | 860/1000 [3:21:33<32:48, 14.06s/it][Succeeded / Failed / Skipped / Total] 614 / 195 / 51 / 860:  86%|████████▌ | 861/1000 [3:22:34<32:42, 14.12s/it][Succeeded / Failed / Skipped / Total] 614 / 196 / 51 / 861:  86%|████████▌ | 861/1000 [3:22:34<32:42, 14.12s/it][Succeeded / Failed / Skipped / Total] 614 / 196 / 51 / 861:  86%|████████▌ | 862/1000 [3:23:10<32:31, 14.14s/it][Succeeded / Failed / Skipped / Total] 615 / 196 / 51 / 862:  86%|████████▌ | 862/1000 [3:23:10<32:31, 14.14s/it][Succeeded / Failed / Skipped / Total] 615 / 196 / 51 / 862:  86%|████████▋ | 863/1000 [3:23:37<32:19, 14.16s/it][Succeeded / Failed / Skipped / Total] 615 / 197 / 51 / 863:  86%|████████▋ | 863/1000 [3:23:37<32:19, 14.16s/it][Succeeded / Failed / Skipped / Total] 615 / 197 / 51 / 863:  86%|████████▋ | 864/1000 [3:23:58<32:06, 14.17s/it]Adds a constant name . --> [[[FAILED]]]

[[[[Adv]]]]: private Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { int hashCode = hash ( tag , owner , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { int hashCode = hash ( tag , owner , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 858 ---------------------------------------------
Adds a hash code . --> [[[FAILED]]]

[[[[Adv]]]]: int addConstantUtf8 ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int addConstantUtf8 ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 859 ---------------------------------------------
Adds a value . -->  --> Socre: 0.9999999999999969

[[[[Adv]]]]: private void addConstantUtf8Reference ( final int [[index]] , final int [[tag]] , final String value ) { add ( new Entry ( [[index]] , [[tag]] , value , hash ( [[tag]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantUtf8Reference ( final int [[clues]] , final int [[labels]] , final String value ) { add ( new Entry ( [[clues]] , [[labels]] , value , hash ( [[labels]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .
--------------------------------------------- Result 860 ---------------------------------------------
Adds the given index to the table . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: int [[addMergedType]] ( final int [[typeTableIndex1]] , final int [[typeTableIndex2]] ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .

[[[[Adv]]]]: int [[besmirch]] ( final int [[skis]] , final int [[iou]] ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .
--------------------------------------------- Result 861 ---------------------------------------------
Adds a method . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 862 ---------------------------------------------
Clear the map . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public HttpMultiMap < V > [[clear]] ( ) { for ( int [[i]] = 0 ; [[i]] < entries . length ; [[i]] ++ ) { entries [ [[i]] ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .

[[[[Adv]]]]: public HttpMultiMap < V > [[definite]] ( ) { for ( int [[siento]] = 0 ; [[siento]] < entries . length ; [[siento]] ++ ) { entries [ [[siento]] ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .
--------------------------------------------- Result 863 ---------------------------------------------
Add a Method . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantMethodHandle ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; add ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantMethodHandle ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; add ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .
[Succeeded / Failed / Skipped / Total] 616 / 197 / 51 / 864:  86%|████████▋ | 864/1000 [3:23:58<32:06, 14.17s/it][Succeeded / Failed / Skipped / Total] 616 / 197 / 51 / 864:  86%|████████▋ | 865/1000 [3:24:07<31:51, 14.16s/it][Succeeded / Failed / Skipped / Total] 616 / 198 / 51 / 865:  86%|████████▋ | 865/1000 [3:24:07<31:51, 14.16s/it][Succeeded / Failed / Skipped / Total] 616 / 198 / 51 / 865:  87%|████████▋ | 866/1000 [3:24:20<31:37, 14.16s/it][Succeeded / Failed / Skipped / Total] 617 / 198 / 51 / 866:  87%|████████▋ | 866/1000 [3:24:20<31:37, 14.16s/it][Succeeded / Failed / Skipped / Total] 617 / 198 / 51 / 866:  87%|████████▋ | 867/1000 [3:24:57<31:26, 14.18s/it][Succeeded / Failed / Skipped / Total] 617 / 199 / 51 / 867:  87%|████████▋ | 867/1000 [3:24:57<31:26, 14.18s/it][Succeeded / Failed / Skipped / Total] 617 / 199 / 51 / 867:  87%|████████▋ | 868/1000 [3:24:57<31:10, 14.17s/it][Succeeded / Failed / Skipped / Total] 617 / 199 / 52 / 868:  87%|████████▋ | 868/1000 [3:24:57<31:10, 14.17s/it][Succeeded / Failed / Skipped / Total] 617 / 199 / 52 / 868:  87%|████████▋ | 869/1000 [3:25:02<30:54, 14.16s/it][Succeeded / Failed / Skipped / Total] 618 / 199 / 52 / 869:  87%|████████▋ | 869/1000 [3:25:02<30:54, 14.16s/it][Succeeded / Failed / Skipped / Total] 618 / 199 / 52 / 869:  87%|████████▋ | 870/1000 [3:25:05<30:38, 14.14s/it][Succeeded / Failed / Skipped / Total] 619 / 199 / 52 / 870:  87%|████████▋ | 870/1000 [3:25:05<30:38, 14.14s/it][Succeeded / Failed / Skipped / Total] 619 / 199 / 52 / 870:  87%|████████▋ | 871/1000 [3:25:07<30:22, 14.13s/it][Succeeded / Failed / Skipped / Total] 620 / 199 / 52 / 871:  87%|████████▋ | 871/1000 [3:25:07<30:22, 14.13s/it][Succeeded / Failed / Skipped / Total] 620 / 199 / 52 / 871:  87%|████████▋ | 872/1000 [3:25:25<30:09, 14.13s/it][Succeeded / Failed / Skipped / Total] 620 / 200 / 52 / 872:  87%|████████▋ | 872/1000 [3:25:25<30:09, 14.13s/it][Succeeded / Failed / Skipped / Total] 620 / 200 / 52 / 872:  87%|████████▋ | 873/1000 [3:25:52<29:56, 14.15s/it]--------------------------------------------- Result 864 ---------------------------------------------
Returns a list with the specified name . --> Puts a value into a map --> Socre: 1.0

[[[[Adv]]]]: public List < V > [[getAll]] ( final String name ) { LinkedList < V > [[values]] = new LinkedList <> ( ) ; int [[h]] = hash ( name ) ; int i = index ( [[h]] ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == [[h]] && eq ( name , e . key ) ) { [[values]] . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return [[values]] ; }
[[[[Nl]]]]: Returns all values associated with the name .

[[[[Adv]]]]: public List < V > [[chubb]] ( final String name ) { LinkedList < V > [[appreciate]] = new LinkedList <> ( ) ; int [[episode]] = hash ( name ) ; int i = index ( [[episode]] ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == [[episode]] && eq ( name , e . key ) ) { [[appreciate]] . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return [[appreciate]] ; }
[[[[Nl]]]]: Returns all values associated with the name .
--------------------------------------------- Result 865 ---------------------------------------------
Add a bootstrap method . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantInvokeDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantInvokeDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 866 ---------------------------------------------
Moves to the buffer . --> Checks to see if a certain size has been modified --> Socre: 1.0

[[[[Adv]]]]: private void [[grow]] ( final int [[minCapacity]] ) { final int oldCapacity = buffer . length ; int [[newCapacity]] = oldCapacity << 1 ; if ( [[newCapacity]] - [[minCapacity]] < 0 ) {
[[[[Nl]]]]: Grows the buffer .

[[[[Adv]]]]: private void [[raising]] ( final int [[whizz]] ) { final int oldCapacity = buffer . length ; int [[williamsburg]] = oldCapacity << 1 ; if ( [[williamsburg]] - [[whizz]] < 0 ) {
[[[[Nl]]]]: Grows the buffer .
--------------------------------------------- Result 867 ---------------------------------------------
Add a bootstrap method . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .
--------------------------------------------- Result 868 ---------------------------------------------
Visit a annotation --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override public AnnotationVisitor visitAnnotation ( final String desc , final boolean visible ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( desc , visible ) ;
[[[[Nl]]]]: Copies target method annotations .
--------------------------------------------- Result 869 ---------------------------------------------
Appends a character to a string . --> Liefert die die e diefe die e dichefe diebene e die e dichefe eiefefe eugebene fene dichene urufeufeuge eneufene luflufeurufeicheneuf --> Socre: 1.0

[[[[Adv]]]]: @ Override public FastCharBuffer [[append]] ( final CharSequence [[csq]] , final int [[start]] , final int [[end]] ) { for ( int i = [[start]] ; i < [[end]] ; i ++ ) { [[append]] ( [[csq]] . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .

[[[[Adv]]]]: @ Override public FastCharBuffer [[uniformed]] ( final CharSequence [[discussed]] , final int [[commence]] , final int [[concluded]] ) { for ( int i = [[commence]] ; i < [[concluded]] ; i ++ ) { [[uniformed]] ( [[discussed]] . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .
--------------------------------------------- Result 870 ---------------------------------------------
Start the chain . --> Clean up a caching --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Start]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .

[[[[Adv]]]]: protected void [[chupacabra]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .
--------------------------------------------- Result 871 ---------------------------------------------
Starts the chain . --> Generates a observoobservation --> Socre: 1.0

[[[[Adv]]]]: @ Override public void visitEnd ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[p]] = 0 ; [[p]] < tmd . proxyData . length ; [[p]] ++ ) { tmd . selectCurrentProxy ( [[p]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .

[[[[Adv]]]]: @ Override public void visitEnd ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[potassium]] = 0 ; [[potassium]] < tmd . proxyData . length ; [[potassium]] ++ ) { tmd . selectCurrentProxy ( [[potassium]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .
--------------------------------------------- Result 872 ---------------------------------------------
Adds bootstrap attributes . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addBootstrapMethod ( final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .

[[[[Adv]]]]: Symbol addBootstrapMethod ( final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .
--------------------------------------------- Result 873 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 620 / 201 / 52 / 873:  87%|████████▋ | 873/1000 [3:25:52<29:56, 14.15s/it][Succeeded / Failed / Skipped / Total] 620 / 201 / 52 / 873:  87%|████████▋ | 874/1000 [3:26:10<29:43, 14.15s/it][Succeeded / Failed / Skipped / Total] 620 / 202 / 52 / 874:  87%|████████▋ | 874/1000 [3:26:10<29:43, 14.15s/it][Succeeded / Failed / Skipped / Total] 620 / 202 / 52 / 874:  88%|████████▊ | 875/1000 [3:26:39<29:31, 14.17s/it][Succeeded / Failed / Skipped / Total] 621 / 202 / 52 / 875:  88%|████████▊ | 875/1000 [3:26:39<29:31, 14.17s/it][Succeeded / Failed / Skipped / Total] 621 / 202 / 52 / 875:  88%|████████▊ | 876/1000 [3:26:45<29:16, 14.16s/it][Succeeded / Failed / Skipped / Total] 622 / 202 / 52 / 876:  88%|████████▊ | 876/1000 [3:26:45<29:16, 14.16s/it][Succeeded / Failed / Skipped / Total] 622 / 202 / 52 / 876:  88%|████████▊ | 877/1000 [3:26:49<29:00, 14.15s/it][Succeeded / Failed / Skipped / Total] 623 / 202 / 52 / 877:  88%|████████▊ | 877/1000 [3:26:49<29:00, 14.15s/it][Succeeded / Failed / Skipped / Total] 623 / 202 / 52 / 877:  88%|████████▊ | 878/1000 [3:26:50<28:44, 14.14s/it]Adds an entry to the map . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 874 ---------------------------------------------
Adds a constant pool entry . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantUtf8Reference ( final int tag , final String value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantUtf8Reference ( final int tag , final String value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 875 ---------------------------------------------
Add a servlet servlet . --> Add a droads filter --> Socre: 1.0

[[[[Adv]]]]: private void [[configureServletContext]] ( final ServletContext [[servletContext]] ) { [[servletContext]] . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration [[filter]] = [[servletContext]] . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; [[filter]] . addMappingForUrlPatterns ( null , "[[True]]" == "[[True]]" , contextPath ) ; } final FilterRegistration [[filter]] = [[servletContext]] . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; [[filter]] . addMappingForUrlPatterns ( madvocDispatcherTypes , "[[True]]" == "[[True]]" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .

[[[[Adv]]]]: private void [[sirrah]] ( final ServletContext [[widdle]] ) { [[widdle]] . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration [[cleansed]] = [[widdle]] . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; [[cleansed]] . addMappingForUrlPatterns ( null , "[[Dignified]]" == "[[Dignified]]" , contextPath ) ; } final FilterRegistration [[cleansed]] = [[widdle]] . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; [[cleansed]] . addMappingForUrlPatterns ( madvocDispatcherTypes , "[[Dignified]]" == "[[Dignified]]" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .
--------------------------------------------- Result 876 ---------------------------------------------
Executes a single object . --> Execute a proxy --> Socre: 1.0

[[[[Adv]]]]: public Object execute ( ) { String methodName = targetMethodName ( ) ; Class [[returnType]] = [[returnType]] ( ) ; Object next = pathref . continueWith ( this , methodName , [[returnType]] ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;

[[[[Adv]]]]: public Object execute ( ) { String methodName = targetMethodName ( ) ; Class [[barbra]] = [[barbra]] ( ) ; Object next = pathref . continueWith ( this , methodName , [[barbra]] ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;
--------------------------------------------- Result 877 ---------------------------------------------
Parse a path . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Path [[parse]] ( final String [[path]] ) { return [[path]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[path]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .

[[[[Adv]]]]: public static Path [[hendrik]] ( final String [[keng]] ) { return [[keng]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[keng]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .
--------------------------------------------- Result 878 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 624 / 202 / 52 / 878:  88%|████████▊ | 878/1000 [3:26:50<28:44, 14.14s/it][Succeeded / Failed / Skipped / Total] 624 / 202 / 52 / 878:  88%|████████▊ | 879/1000 [3:26:52<28:28, 14.12s/it][Succeeded / Failed / Skipped / Total] 625 / 202 / 52 / 879:  88%|████████▊ | 879/1000 [3:26:52<28:28, 14.12s/it][Succeeded / Failed / Skipped / Total] 625 / 202 / 52 / 879:  88%|████████▊ | 880/1000 [3:26:58<28:13, 14.11s/it][Succeeded / Failed / Skipped / Total] 626 / 202 / 52 / 880:  88%|████████▊ | 880/1000 [3:26:58<28:13, 14.11s/it][Succeeded / Failed / Skipped / Total] 626 / 202 / 52 / 880:  88%|████████▊ | 881/1000 [3:27:18<28:00, 14.12s/it][Succeeded / Failed / Skipped / Total] 627 / 202 / 52 / 881:  88%|████████▊ | 881/1000 [3:27:18<28:00, 14.12s/it][Succeeded / Failed / Skipped / Total] 627 / 202 / 52 / 881:  88%|████████▊ | 882/1000 [3:27:22<27:44, 14.11s/it][Succeeded / Failed / Skipped / Total] 628 / 202 / 52 / 882:  88%|████████▊ | 882/1000 [3:27:22<27:44, 14.11s/it][Succeeded / Failed / Skipped / Total] 628 / 202 / 52 / 882:  88%|████████▊ | 883/1000 [3:27:28<27:29, 14.10s/it][Succeeded / Failed / Skipped / Total] 629 / 202 / 52 / 883:  88%|████████▊ | 883/1000 [3:27:28<27:29, 14.10s/it][Succeeded / Failed / Skipped / Total] 629 / 202 / 52 / 883:  88%|████████▊ | 884/1000 [3:27:41<27:15, 14.10s/it][Succeeded / Failed / Skipped / Total] 630 / 202 / 52 / 884:  88%|████████▊ | 884/1000 [3:27:41<27:15, 14.10s/it][Succeeded / Failed / Skipped / Total] 630 / 202 / 52 / 884:  88%|████████▊ | 885/1000 [3:27:43<26:59, 14.08s/it]Create a new Spatial instance . --> Create a new proxied protection --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String [[name]] , Class < T > [[type]] , final Scope [[scope]] , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class [[originalType]] = [[type]] ; final ProxettaFactory [[builder]] = proxetta . proxy ( ) ; [[builder]] . setTarget ( [[type]] ) ; [[type]] = [[builder]] . define ( ) ; return new ProxettaBeanDefinition ( [[name]] , [[type]] , [[scope]] , wiringMode , [[originalType]] , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( [[name]] , [[type]] , [[scope]] , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String [[appoints]] , Class < T > [[sorts]] , final Scope [[scaling]] , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class [[hg]] = [[sorts]] ; final ProxettaFactory [[bringer]] = proxetta . proxy ( ) ; [[bringer]] . setTarget ( [[sorts]] ) ; [[sorts]] = [[bringer]] . define ( ) ; return new ProxettaBeanDefinition ( [[appoints]] , [[sorts]] , [[scaling]] , wiringMode , [[hg]] , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( [[appoints]] , [[sorts]] , [[scaling]] , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .
--------------------------------------------- Result 879 ---------------------------------------------
Get a property . --> Unwraps a JsonObject --> Socre: 1.0

[[[[Adv]]]]: private Object [[readProperty]] ( final Object [[source]] , final PropertyDescriptor [[propertyDescriptor]] ) { Getter [[getter]] = [[propertyDescriptor]] . getGetter ( declared ) ; if ( [[getter]] != null ) { try { return [[getter]] . invokeGetter ( [[source]] ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .

[[[[Adv]]]]: private Object [[skinners]] ( final Object [[backgrounds]] , final PropertyDescriptor [[wonderbra]] ) { Getter [[tidier]] = [[wonderbra]] . getGetter ( declared ) ; if ( [[tidier]] != null ) { try { return [[tidier]] . invokeGetter ( [[backgrounds]] ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .
--------------------------------------------- Result 880 ---------------------------------------------
Adds all entries in the given map . -->  --> Socre: 0.9999999999995342

[[[[Adv]]]]: @ Override public void [[putAll]] ( final Map [[t]] ) { for ( Object [[o]] : [[t]] . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) [[o]] ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .

[[[[Adv]]]]: @ Override public void [[dictators]] ( final Map [[ts]] ) { for ( Object [[sen]] : [[ts]] . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) [[sen]] ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .
--------------------------------------------- Result 881 ---------------------------------------------
Append the buffer to the buffer . --> Returns a list of sesstablishes --> Socre: 1.0

[[[[Adv]]]]: public Buffer [[append]] ( final Buffer [[buffer]] ) { if ( [[buffer]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .

[[[[Adv]]]]: public Buffer [[persevered]] ( final Buffer [[snowshoes]] ) { if ( [[snowshoes]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .
--------------------------------------------- Result 882 ---------------------------------------------
Returns the name of the given name . --> Converts a hours to a hours --> Socre: 1.0

[[[[Adv]]]]: private int [[hash]] ( final String [[name]] ) { int [[h]] = 0 ; for ( int i = [[name]] . length ( ) - 1 ; i >= 0 ; i -- ) { char [[c]] = [[name]] . charAt ( i ) ; if ( ! caseSensitive ) { if ( [[c]] >= ' ' && [[c]] <= ' ' ) { [[c]] += 32 ; } } [[h]] = 31 * [[h]] + [[c]] ; } if ( [[h]] > 0 ) { return [[h]] ; } if ( [[h]] == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - [[h]] ; }
[[[[Nl]]]]: Calculates hash value of the input string .

[[[[Adv]]]]: private int [[salting]] ( final String [[behalf]] ) { int [[hours]] = 0 ; for ( int i = [[behalf]] . length ( ) - 1 ; i >= 0 ; i -- ) { char [[johnston]] = [[behalf]] . charAt ( i ) ; if ( ! caseSensitive ) { if ( [[johnston]] >= ' ' && [[johnston]] <= ' ' ) { [[johnston]] += 32 ; } } [[hours]] = 31 * [[hours]] + [[johnston]] ; } if ( [[hours]] > 0 ) { return [[hours]] ; } if ( [[hours]] == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - [[hours]] ; }
[[[[Nl]]]]: Calculates hash value of the input string .
--------------------------------------------- Result 883 ---------------------------------------------
Adds a path . --> Retrivializes a tree --> Socre: 1.0

[[[[Adv]]]]: public Path [[push]] ( final CharSequence [[field]] ) { _push ( [[field]] ) ; if ( altPath != null ) { altPath . push ( [[field]] ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .

[[[[Adv]]]]: public Path [[stimulation]] ( final CharSequence [[territory]] ) { _push ( [[territory]] ) ; if ( altPath != null ) { altPath . push ( [[territory]] ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .
--------------------------------------------- Result 884 ---------------------------------------------
Writes the progress to the output stream . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream out , final HttpProgressListener [[progressListener]] ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .

[[[[Adv]]]]: public void [[stoop]] ( final OutputStream out , final HttpProgressListener [[intestine]] ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .
--------------------------------------------- Result 885 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 631 / 202 / 52 / 885:  88%|████████▊ | 885/1000 [3:27:43<26:59, 14.08s/it][Succeeded / Failed / Skipped / Total] 631 / 202 / 52 / 885:  89%|████████▊ | 886/1000 [3:28:02<26:46, 14.09s/it][Succeeded / Failed / Skipped / Total] 632 / 202 / 52 / 886:  89%|████████▊ | 886/1000 [3:28:02<26:46, 14.09s/it][Succeeded / Failed / Skipped / Total] 633 / 202 / 52 / 887:  89%|████████▊ | 887/1000 [3:28:02<26:30, 14.07s/it][Succeeded / Failed / Skipped / Total] 633 / 202 / 52 / 887:  89%|████████▉ | 888/1000 [3:28:04<26:14, 14.06s/it][Succeeded / Failed / Skipped / Total] 634 / 202 / 52 / 888:  89%|████████▉ | 888/1000 [3:28:04<26:14, 14.06s/it][Succeeded / Failed / Skipped / Total] 635 / 202 / 52 / 889:  89%|████████▉ | 889/1000 [3:28:27<26:01, 14.07s/it][Succeeded / Failed / Skipped / Total] 635 / 202 / 52 / 889:  89%|████████▉ | 890/1000 [3:28:28<25:46, 14.05s/it][Succeeded / Failed / Skipped / Total] 636 / 202 / 52 / 890:  89%|████████▉ | 890/1000 [3:28:28<25:46, 14.05s/it][Succeeded / Failed / Skipped / Total] 636 / 202 / 52 / 890:  89%|████████▉ | 891/1000 [3:28:52<25:33, 14.07s/it][Succeeded / Failed / Skipped / Total] 637 / 202 / 52 / 891:  89%|████████▉ | 891/1000 [3:28:52<25:33, 14.07s/it][Succeeded / Failed / Skipped / Total] 637 / 202 / 52 / 891:  89%|████████▉ | 892/1000 [3:29:06<25:19, 14.07s/it]Returns an entry in the queue . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > iterator ( ) { final MapEntry [ ] [[e]] = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return [[e]] [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > [[next]] ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > [[next]] = [[e]] [ 0 ] ; [[e]] [ 0 ] = [[e]] [ 0 ] . after ; return [[next]] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > iterator ( ) { final MapEntry [ ] [[engels]] = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return [[engels]] [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > [[coming]] ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > [[coming]] = [[engels]] [ 0 ] ; [[engels]] [ 0 ] = [[engels]] [ 0 ] . after ; return [[coming]] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .
--------------------------------------------- Result 886 ---------------------------------------------
Upload a file . --> Allocate a file --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final Writer [[writer]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; byte [ ] array = fastByteBuffer . toArray ( ) ; [[writer]] . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[writer]] , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .

[[[[Adv]]]]: public void [[redress]] ( final Writer [[auteur]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; byte [ ] array = fastByteBuffer . toArray ( ) ; [[auteur]] . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[auteur]] , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .
--------------------------------------------- Result 887 ---------------------------------------------
Get the integer key . --> Converts a Number to a Number --> Socre: 1.0

[[[[Adv]]]]: public Integer [[getInteger]] ( final String [[key]] ) { Number [[number]] = ( Number ) map . get ( [[key]] ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Integer ) { return ( Integer ) [[number]] ; } return [[number]] . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .

[[[[Adv]]]]: public Integer [[crow]] ( final String [[underlying]] ) { Number [[amount]] = ( Number ) map . get ( [[underlying]] ) ; if ( [[amount]] == null ) { return null ; } if ( [[amount]] instanceof Integer ) { return ( Integer ) [[amount]] ; } return [[amount]] . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .
--------------------------------------------- Result 888 ---------------------------------------------
Get the double value . --> Convert a number to a Number --> Socre: 1.0

[[[[Adv]]]]: public Double [[getDouble]] ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .

[[[[Adv]]]]: public Double [[implosion]] ( final String [[fundamental]] ) { Number number = ( Number ) map . get ( [[fundamental]] ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .
--------------------------------------------- Result 889 ---------------------------------------------
Get the long value . --> Get a number from a Number --> Socre: 1.0

[[[[Adv]]]]: public Long [[getLong]] ( final String [[key]] ) { Number [[number]] = ( Number ) map . get ( [[key]] ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Long ) { return ( Long ) [[number]] ; } return [[number]] . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .

[[[[Adv]]]]: public Long [[slasher]] ( final String [[fundamental]] ) { Number [[finger]] = ( Number ) map . get ( [[fundamental]] ) ; if ( [[finger]] == null ) { return null ; } if ( [[finger]] instanceof Long ) { return ( Long ) [[finger]] ; } return [[finger]] . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .
--------------------------------------------- Result 890 ---------------------------------------------
Get the value of a map . --> Converts a JsonObject to a JsonObject --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] getValue ( final String key ) { [[T]] [[val]] = ( [[T]] ) map . get ( key ) ; if ( [[val]] instanceof Map ) { return ( [[T]] ) new JsonObject ( ( Map ) [[val]] ) ; } if ( [[val]] instanceof List ) { return ( [[T]] ) new JsonArray ( ( List ) [[val]] ) ; } return [[val]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[quantity]] > [[quantity]] getValue ( final String key ) { [[quantity]] [[selections]] = ( [[quantity]] ) map . get ( key ) ; if ( [[selections]] instanceof Map ) { return ( [[quantity]] ) new JsonObject ( ( Map ) [[selections]] ) ; } if ( [[selections]] instanceof List ) { return ( [[quantity]] ) new JsonArray ( ( List ) [[selections]] ) ; } return [[selections]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .
--------------------------------------------- Result 891 ---------------------------------------------
Returns the Float for the given key . --> Converts a number to a number --> Socre: 1.0

[[[[Adv]]]]: public Float [[getFloat]] ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .

[[[[Adv]]]]: public Float [[accounts]] ( final String [[basic]] ) { Number number = ( Number ) map . get ( [[basic]] ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .
--------------------------------------------- Result 892 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 637 / 203 / 52 / 892:  89%|████████▉ | 892/1000 [3:29:06<25:19, 14.07s/it][Succeeded / Failed / Skipped / Total] 637 / 203 / 52 / 892:  89%|████████▉ | 893/1000 [3:29:28<25:05, 14.07s/it][Succeeded / Failed / Skipped / Total] 638 / 203 / 52 / 893:  89%|████████▉ | 893/1000 [3:29:28<25:05, 14.07s/it][Succeeded / Failed / Skipped / Total] 638 / 203 / 52 / 893:  89%|████████▉ | 894/1000 [3:29:29<24:50, 14.06s/it][Succeeded / Failed / Skipped / Total] 639 / 203 / 52 / 894:  89%|████████▉ | 894/1000 [3:29:29<24:50, 14.06s/it][Succeeded / Failed / Skipped / Total] 639 / 203 / 52 / 894:  90%|████████▉ | 895/1000 [3:29:45<24:36, 14.06s/it][Succeeded / Failed / Skipped / Total] 640 / 203 / 52 / 895:  90%|████████▉ | 895/1000 [3:29:45<24:36, 14.06s/it][Succeeded / Failed / Skipped / Total] 640 / 203 / 52 / 895:  90%|████████▉ | 896/1000 [3:30:22<24:25, 14.09s/it][Succeeded / Failed / Skipped / Total] 641 / 203 / 52 / 896:  90%|████████▉ | 896/1000 [3:30:22<24:25, 14.09s/it][Succeeded / Failed / Skipped / Total] 641 / 203 / 52 / 896:  90%|████████▉ | 897/1000 [3:30:37<24:11, 14.09s/it][Succeeded / Failed / Skipped / Total] 642 / 203 / 52 / 897:  90%|████████▉ | 897/1000 [3:30:37<24:11, 14.09s/it][Succeeded / Failed / Skipped / Total] 642 / 203 / 52 / 897:  90%|████████▉ | 898/1000 [3:30:40<23:55, 14.08s/it][Succeeded / Failed / Skipped / Total] 643 / 203 / 52 / 898:  90%|████████▉ | 898/1000 [3:30:40<23:55, 14.08s/it][Succeeded / Failed / Skipped / Total] 643 / 203 / 52 / 898:  90%|████████▉ | 899/1000 [3:30:53<23:41, 14.08s/it][Succeeded / Failed / Skipped / Total] 643 / 204 / 52 / 899:  90%|████████▉ | 899/1000 [3:30:53<23:41, 14.08s/it][Succeeded / Failed / Skipped / Total] 643 / 204 / 52 / 899:  90%|█████████ | 900/1000 [3:30:54<23:26, 14.06s/it]Returns a list of all entries . --> [[[FAILED]]]

[[[[Adv]]]]: public List < Map . Entry < String , V > > entries ( ) { List < Map . Entry < String , V > > all = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { all . add ( e ) ; e = e . after ; } return all ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .

[[[[Adv]]]]: public List < Map . Entry < String , V > > entries ( ) { List < Map . Entry < String , V > > all = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { all . add ( e ) ; e = e . after ; } return all ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .
--------------------------------------------- Result 893 ---------------------------------------------
 --> Allocate a InputStream --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream [[out]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; [[out]] . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream [[inputStream]] = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( [[inputStream]] , [[out]] ) ; } finally { StreamUtil . close ( [[inputStream]] ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .

[[[[Adv]]]]: public void [[foresight]] ( final OutputStream [[exterior]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; [[exterior]] . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream [[laziness]] = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( [[laziness]] , [[exterior]] ) ; } finally { StreamUtil . close ( [[laziness]] ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .
--------------------------------------------- Result 894 ---------------------------------------------
Adds a value to the map . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public JsonObject [[put]] ( final String [[key]] , final String [[value]] ) { Objects . requireNonNull ( [[key]] ) ; map . put ( [[key]] , [[value]] ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .

[[[[Adv]]]]: public JsonObject [[brings]] ( final String [[necessity]] , final String [[relevance]] ) { Objects . requireNonNull ( [[necessity]] ) ; map . put ( [[necessity]] , [[relevance]] ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .
--------------------------------------------- Result 895 ---------------------------------------------
Set the email . --> Send a message to a destination --> Socre: 1.0

[[[[Adv]]]]: public void [[updateEmailFlags]] ( final ReceivedEmail receivedEmail ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { receivedEmail . messageNumber ( ) } , receivedEmail . flags ( ) , "[[True]]" == "[[True]]" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .

[[[[Adv]]]]: public void [[quirt]] ( final ReceivedEmail receivedEmail ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { receivedEmail . messageNumber ( ) } , receivedEmail . flags ( ) , "[[Genuinely]]" == "[[Genuinely]]" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .
--------------------------------------------- Result 896 ---------------------------------------------
Closes the folder . --> Close the fault --> Socre: 1.0

[[[[Adv]]]]: protected void [[closeFolderIfOpened]] ( final Folder [[folder]] ) { if ( [[folder]] != null ) { try { [[folder]] . close ( "[[True]]" == "[[True]]" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .

[[[[Adv]]]]: protected void [[enthusiasm]] ( final Folder [[lawsuit]] ) { if ( [[lawsuit]] != null ) { try { [[lawsuit]] . close ( "[[Heartfelt]]" == "[[Heartfelt]]" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .
--------------------------------------------- Result 897 ---------------------------------------------
Returns a string representation of the alias . --> A convenience method to create a string --> Socre: 1.0

[[[[Adv]]]]: protected String [[alias]] ( final String [[target]] ) { return StringPool . LEFT_CHEV . concat ( [[target]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .

[[[[Adv]]]]: protected String [[untrue]] ( final String [[destiny]] ) { return StringPool . LEFT_CHEV . concat ( [[destiny]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .
--------------------------------------------- Result 898 ---------------------------------------------
Validates the profile . --> Method to create Violations --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[validateAction]] ( final String ... [[profiles]] ) { prepareValidator ( ) ; vtor . useProfiles ( [[profiles]] ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > [[violations]] = vtor . getViolations ( ) ; return [[violations]] == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .

[[[[Adv]]]]: protected boolean [[prejudiced]] ( final String ... [[imagery]] ) { prepareValidator ( ) ; vtor . useProfiles ( [[imagery]] ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > [[infractions]] = vtor . getViolations ( ) ; return [[infractions]] == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .
--------------------------------------------- Result 899 ---------------------------------------------
Create a Method . --> [[[FAILED]]]

[[[[Adv]]]]: protected void createFirstChainDelegate_Continue ( final TargetMethodData tmd ) { methodVisitor . visitCode ( ) ; if ( tmd . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , tmd . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .

[[[[Adv]]]]: protected void createFirstChainDelegate_Continue ( final TargetMethodData tmd ) { methodVisitor . visitCode ( ) ; if ( tmd . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , tmd . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .
--------------------------------------------- Result 900 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 644 / 204 / 52 / 900:  90%|█████████ | 900/1000 [3:30:54<23:26, 14.06s/it][Succeeded / Failed / Skipped / Total] 644 / 204 / 52 / 900:  90%|█████████ | 901/1000 [3:31:07<23:11, 14.06s/it][Succeeded / Failed / Skipped / Total] 645 / 204 / 52 / 901:  90%|█████████ | 901/1000 [3:31:07<23:11, 14.06s/it][Succeeded / Failed / Skipped / Total] 645 / 204 / 52 / 901:  90%|█████████ | 902/1000 [3:31:20<22:57, 14.06s/it][Succeeded / Failed / Skipped / Total] 646 / 204 / 52 / 902:  90%|█████████ | 902/1000 [3:31:20<22:57, 14.06s/it][Succeeded / Failed / Skipped / Total] 646 / 204 / 52 / 902:  90%|█████████ | 903/1000 [3:31:37<22:43, 14.06s/it][Succeeded / Failed / Skipped / Total] 647 / 204 / 52 / 903:  90%|█████████ | 903/1000 [3:31:37<22:43, 14.06s/it][Succeeded / Failed / Skipped / Total] 647 / 204 / 52 / 903:  90%|█████████ | 904/1000 [3:31:40<22:28, 14.05s/it][Succeeded / Failed / Skipped / Total] 648 / 204 / 52 / 904:  90%|█████████ | 904/1000 [3:31:40<22:28, 14.05s/it][Succeeded / Failed / Skipped / Total] 648 / 204 / 52 / 904:  90%|█████████ | 905/1000 [3:31:41<22:13, 14.04s/it][Succeeded / Failed / Skipped / Total] 649 / 204 / 52 / 905:  90%|█████████ | 905/1000 [3:31:41<22:13, 14.04s/it][Succeeded / Failed / Skipped / Total] 649 / 204 / 52 / 905:  91%|█████████ | 906/1000 [3:31:43<21:57, 14.02s/it][Succeeded / Failed / Skipped / Total] 650 / 204 / 52 / 906:  91%|█████████ | 906/1000 [3:31:43<21:57, 14.02s/it][Succeeded / Failed / Skipped / Total] 650 / 204 / 52 / 906:  91%|█████████ | 907/1000 [3:31:57<21:44, 14.02s/it][Succeeded / Failed / Skipped / Total] 650 / 205 / 52 / 907:  91%|█████████ | 907/1000 [3:31:57<21:44, 14.02s/it][Succeeded / Failed / Skipped / Total] 650 / 205 / 52 / 907:  91%|█████████ | 908/1000 [3:32:23<21:31, 14.03s/it]Get mime type . --> Get mimetype . --> Socre: 1.0

[[[[Adv]]]]: public RawData as ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . [[mimeType]] = mimeOrExtension ; } else { this . [[mimeType]] = MimeTypes . getMimeType ( mimeOrExtension ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!

[[[[Adv]]]]: public RawData as ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . [[yuri]] = mimeOrExtension ; } else { this . [[yuri]] = MimeTypes . getMimeType ( mimeOrExtension ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!
--------------------------------------------- Result 901 ---------------------------------------------
Returns the name of the parameter . --> Find the first occurrence of the given Query --> Socre: 1.0

[[[[Adv]]]]: DbQueryNamedParameter [[lookupNamedParameter]] ( final String [[name]] ) { DbQueryNamedParameter [[p]] = rootNP ; while ( [[p]] != null ) { if ( [[p]] . equalsName ( [[name]] ) ) { return [[p]] ; } [[p]] = [[p]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .

[[[[Adv]]]]: DbQueryNamedParameter [[crop]] ( final String [[rendezvous]] ) { DbQueryNamedParameter [[w]] = rootNP ; while ( [[w]] != null ) { if ( [[w]] . equalsName ( [[rendezvous]] ) ) { return [[w]] ; } [[w]] = [[w]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .
--------------------------------------------- Result 902 ---------------------------------------------
Adds a Violation . --> Add a vlation to a Phix --> Socre: 1.0

[[[[Adv]]]]: protected void [[addViolation]] ( final String [[name]] , final Object [[invalidValue]] ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( [[name]] , this , [[invalidValue]] ) ) ; }
[[[[Nl]]]]: Adds action violation .

[[[[Adv]]]]: protected void [[hugs]] ( final String [[appointing]] , final Object [[whipper]] ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( [[appointing]] , this , [[whipper]] ) ) ; }
[[[[Nl]]]]: Adds action violation .
--------------------------------------------- Result 903 ---------------------------------------------
Adds a message to the filter . --> Adds a new Message --> Socre: 1.0

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter [[filter]] , final Flags [[flagsToSet]] , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > [[processedMessageConsumer]] ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( [[filter]] == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( [[filter]] . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile [[fetchProfile]] = new FetchProfile ( ) ; [[fetchProfile]] . add ( FetchProfile . Item . ENVELOPE ) ; [[fetchProfile]] . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , [[fetchProfile]] ) ; }
[[[[Nl]]]]: The main email receiving method .

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter [[screen]] , final Flags [[tray]] , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > [[vivi]] ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( [[screen]] == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( [[screen]] . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile [[anew]] = new FetchProfile ( ) ; [[anew]] . add ( FetchProfile . Item . ENVELOPE ) ; [[anew]] . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , [[anew]] ) ; }
[[[[Nl]]]]: The main email receiving method .
--------------------------------------------- Result 904 ---------------------------------------------
Get the download download . --> Get a PrimeType --> Socre: 1.0

[[[[Adv]]]]: public RawData [[downloadableAs]] ( final String [[downloadFileName]] ) { this . [[downloadFileName]] = [[downloadFileName]] ; this . [[mimeType]] = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[downloadFileName]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .

[[[[Adv]]]]: public RawData [[isn]] ( final String [[peligro]] ) { this . [[cubans]] = [[peligro]] ; this . [[heifers]] = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[peligro]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .
--------------------------------------------- Result 905 ---------------------------------------------
Gets the target class name . --> Method to get the input stream --> Socre: 1.0

[[[[Adv]]]]: protected T setTarget ( final String [[targetName]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[targetName]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[targetName]] ) ; } targetClassName = [[targetName]] ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + [[targetName]] , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!

[[[[Adv]]]]: protected T setTarget ( final String [[duggan]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[duggan]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[duggan]] ) ; } targetClassName = [[duggan]] ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + [[duggan]] , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!
--------------------------------------------- Result 906 ---------------------------------------------
Returns a String representation of this class . --> Convert a String to a String --> Socre: 1.0

[[[[Adv]]]]: public byte [ ] [[create]] ( ) { process ( ) ; byte [ ] [[result]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[result]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns byte array of created class .

[[[[Adv]]]]: public byte [ ] [[constructions]] ( ) { process ( ) ; byte [ ] [[proceeds]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[proceeds]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[proceeds]] ; }
[[[[Nl]]]]: Returns byte array of created class .
--------------------------------------------- Result 907 ---------------------------------------------
Process the input stream . --> [[[FAILED]]]

[[[[Adv]]]]: protected void process ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .

[[[[Adv]]]]: protected void process ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .
--------------------------------------------- Result 908 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 651 / 205 / 52 / 908:  91%|█████████ | 908/1000 [3:32:23<21:31, 14.03s/it][Succeeded / Failed / Skipped / Total] 651 / 205 / 52 / 908:  91%|█████████ | 909/1000 [3:32:44<21:17, 14.04s/it][Succeeded / Failed / Skipped / Total] 651 / 206 / 52 / 909:  91%|█████████ | 909/1000 [3:32:44<21:17, 14.04s/it][Succeeded / Failed / Skipped / Total] 651 / 206 / 52 / 909:  91%|█████████ | 910/1000 [3:32:48<21:02, 14.03s/it][Succeeded / Failed / Skipped / Total] 652 / 206 / 52 / 910:  91%|█████████ | 910/1000 [3:32:48<21:02, 14.03s/it][Succeeded / Failed / Skipped / Total] 652 / 206 / 52 / 910:  91%|█████████ | 911/1000 [3:32:54<20:47, 14.02s/it][Succeeded / Failed / Skipped / Total] 653 / 206 / 52 / 911:  91%|█████████ | 911/1000 [3:32:54<20:47, 14.02s/it][Succeeded / Failed / Skipped / Total] 653 / 206 / 52 / 911:  91%|█████████ | 912/1000 [3:33:05<20:33, 14.02s/it][Succeeded / Failed / Skipped / Total] 654 / 206 / 52 / 912:  91%|█████████ | 912/1000 [3:33:05<20:33, 14.02s/it][Succeeded / Failed / Skipped / Total] 654 / 206 / 52 / 912:  91%|█████████▏| 913/1000 [3:33:05<20:18, 14.00s/it][Succeeded / Failed / Skipped / Total] 655 / 206 / 52 / 913:  91%|█████████▏| 913/1000 [3:33:05<20:18, 14.00s/it][Succeeded / Failed / Skipped / Total] 655 / 206 / 52 / 913:  91%|█████████▏| 914/1000 [3:33:09<20:03, 13.99s/it][Succeeded / Failed / Skipped / Total] 656 / 206 / 52 / 914:  91%|█████████▏| 914/1000 [3:33:09<20:03, 13.99s/it][Succeeded / Failed / Skipped / Total] 656 / 206 / 52 / 914:  92%|█████████▏| 915/1000 [3:33:10<19:48, 13.98s/it][Succeeded / Failed / Skipped / Total] 657 / 206 / 52 / 915:  92%|█████████▏| 915/1000 [3:33:10<19:48, 13.98s/it][Succeeded / Failed / Skipped / Total] 657 / 206 / 52 / 915:  92%|█████████▏| 916/1000 [3:33:24<19:34, 13.98s/it]Sets the target class . --> Method to get the InputStream --> Socre: 1.0

[[[[Adv]]]]: protected T [[setTarget]] ( final InputStream target ) { assertTargetIsNotDefined ( ) ; targetInputStream = target ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .

[[[[Adv]]]]: protected T [[bizarrely]] ( final InputStream target ) { assertTargetIsNotDefined ( ) ; targetInputStream = target ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .
--------------------------------------------- Result 909 ---------------------------------------------
Returns the char for the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public String getString ( final String key ) { CharSequence cs = ( CharSequence ) map . get ( key ) ; return cs == null ? null : cs . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .

[[[[Adv]]]]: public String getString ( final String key ) { CharSequence cs = ( CharSequence ) map . get ( key ) ; return cs == null ? null : cs . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .
--------------------------------------------- Result 910 ---------------------------------------------
Returns a proxy instance . --> Try to load a ClassLoader --> Socre: 1.0

[[[[Adv]]]]: public Class [[define]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader [[classLoader]] = proxetta . getClassLoader ( ) ; if ( [[classLoader]] == null ) { [[classLoader]] = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( [[classLoader]] == null ) && ( targetClass != null ) ) { [[classLoader]] = targetClass . getClassLoader ( ) ; } } final byte [ ] [[bytes]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[bytes]] ) ; return DefineClass . of ( getProxyClassName ( ) , [[bytes]] , [[classLoader]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .

[[[[Adv]]]]: public Class [[outlines]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader [[nickelodeon]] = proxetta . getClassLoader ( ) ; if ( [[nickelodeon]] == null ) { [[nickelodeon]] = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( [[nickelodeon]] == null ) && ( targetClass != null ) ) { [[nickelodeon]] = targetClass . getClassLoader ( ) ; } } final byte [ ] [[chord]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[chord]] ) ; return DefineClass . of ( getProxyClassName ( ) , [[chord]] , [[nickelodeon]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .
--------------------------------------------- Result 911 ---------------------------------------------
Copy a class file . --> Open a file system --> Socre: 1.0

[[[[Adv]]]]: protected void dumpClassInDebugFolder ( final byte [ ] bytes ) { File [[debugFolder]] = proxetta . getDebugFolder ( ) ; if ( [[debugFolder]] == null ) { return ; } if ( ! [[debugFolder]] . exists ( ) || ! [[debugFolder]] . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + [[debugFolder]] ) ; } String [[fileName]] = proxyClassName ; if ( [[fileName]] == null ) { [[fileName]] = "proxetta-" + System . currentTimeMillis ( ) ; } [[fileName]] += ".class" ; File file = new File ( [[debugFolder]] , [[fileName]] ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .

[[[[Adv]]]]: protected void dumpClassInDebugFolder ( final byte [ ] bytes ) { File [[hemant]] = proxetta . getDebugFolder ( ) ; if ( [[hemant]] == null ) { return ; } if ( ! [[hemant]] . exists ( ) || ! [[hemant]] . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + [[hemant]] ) ; } String [[copenhagen]] = proxyClassName ; if ( [[copenhagen]] == null ) { [[copenhagen]] = "proxetta-" + System . currentTimeMillis ( ) ; } [[copenhagen]] += ".class" ; File file = new File ( [[hemant]] , [[copenhagen]] ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .
--------------------------------------------- Result 912 ---------------------------------------------
Create a new person . --> Convert a string to a string --> Socre: 1.0

[[[[Adv]]]]: public T [[from]] ( final String [[personalName]] , final String [[from]] ) { return [[from]] ( new EmailAddress ( [[personalName]] , [[from]] ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .

[[[[Adv]]]]: public T [[von]] ( final String [[avo]] , final String [[between]] ) { return [[von]] ( new EmailAddress ( [[avo]] , [[von]] ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .
--------------------------------------------- Result 913 ---------------------------------------------
Convert a string to a name . --> Create a new Sparketch --> Socre: 1.0

[[[[Adv]]]]: public T [[to]] ( final String [[personalName]] , final String [[to]] ) { return [[to]] ( new EmailAddress ( [[personalName]] , [[to]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .

[[[[Adv]]]]: public T [[paras]] ( final String [[mesquite]] , final String [[through]] ) { return [[paras]] ( new EmailAddress ( [[mesquite]] , [[paras]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .
--------------------------------------------- Result 914 ---------------------------------------------
Sets the email address . --> Set a new Address --> Socre: 1.0

[[[[Adv]]]]: public T [[REPLACEME0]] ( final EmailAddress ... [[REPLACEME0]] ) { this . [[replyTo]] = ArraysUtil . join ( this . [[replyTo]] , valueOrEmptyArray ( [[REPLACEME0]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .

[[[[Adv]]]]: public T [[ACCORDING]] ( final EmailAddress ... [[ACCORDING]] ) { this . [[agendas]] = ArraysUtil . join ( this . [[agendas]] , valueOrEmptyArray ( [[ACCORDING]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .
--------------------------------------------- Result 915 ---------------------------------------------
Sets the value of the address . --> Sets the value of the transaction --> Socre: 1.0

[[[[Adv]]]]: public T [[cc]] ( final EmailAddress ... [[ccs]] ) { this . [[cc]] = ArraysUtil . join ( this . [[cc]] , valueOrEmptyArray ( [[ccs]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .

[[[[Adv]]]]: public T [[jw]] ( final EmailAddress ... [[stc]] ) { this . [[pis]] = ArraysUtil . join ( this . [[pis]] , valueOrEmptyArray ( [[stc]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .
--------------------------------------------- Result 916 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 657 / 207 / 52 / 916:  92%|█████████▏| 916/1000 [3:33:24<19:34, 13.98s/it][Succeeded / Failed / Skipped / Total] 657 / 207 / 52 / 916:  92%|█████████▏| 917/1000 [3:33:31<19:19, 13.97s/it][Succeeded / Failed / Skipped / Total] 658 / 207 / 52 / 917:  92%|█████████▏| 917/1000 [3:33:31<19:19, 13.97s/it][Succeeded / Failed / Skipped / Total] 658 / 207 / 52 / 917:  92%|█████████▏| 918/1000 [3:33:33<19:04, 13.96s/it][Succeeded / Failed / Skipped / Total] 659 / 207 / 52 / 918:  92%|█████████▏| 918/1000 [3:33:33<19:04, 13.96s/it][Succeeded / Failed / Skipped / Total] 659 / 207 / 52 / 918:  92%|█████████▏| 919/1000 [3:33:39<18:49, 13.95s/it][Succeeded / Failed / Skipped / Total] 660 / 207 / 52 / 919:  92%|█████████▏| 919/1000 [3:33:39<18:49, 13.95s/it][Succeeded / Failed / Skipped / Total] 660 / 207 / 52 / 919:  92%|█████████▏| 920/1000 [3:33:39<18:34, 13.93s/it][Succeeded / Failed / Skipped / Total] 661 / 207 / 52 / 920:  92%|█████████▏| 920/1000 [3:33:39<18:34, 13.93s/it][Succeeded / Failed / Skipped / Total] 661 / 207 / 52 / 920:  92%|█████████▏| 921/1000 [3:33:41<18:19, 13.92s/it][Succeeded / Failed / Skipped / Total] 662 / 207 / 52 / 921:  92%|█████████▏| 921/1000 [3:33:41<18:19, 13.92s/it][Succeeded / Failed / Skipped / Total] 662 / 207 / 52 / 921:  92%|█████████▏| 922/1000 [3:33:42<18:04, 13.91s/it][Succeeded / Failed / Skipped / Total] 663 / 207 / 52 / 922:  92%|█████████▏| 922/1000 [3:33:42<18:04, 13.91s/it][Succeeded / Failed / Skipped / Total] 663 / 207 / 52 / 922:  92%|█████████▏| 923/1000 [3:33:43<17:49, 13.89s/it]Open the folder . --> [[[FAILED]]]

[[[[Adv]]]]: public void useFolder ( final String folderName ) { closeFolderIfOpened ( folder ) ; try { this . folderName = folderName ; this . folder = getService ( ) . getFolder ( folderName ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + folderName , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .

[[[[Adv]]]]: public void useFolder ( final String folderName ) { closeFolderIfOpened ( folder ) ; try { this . folderName = folderName ; this . folder = getService ( ) . getFolder ( folderName ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + folderName , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .
--------------------------------------------- Result 917 ---------------------------------------------
Create a message text . --> Create a new MessageType --> Socre: 1.0

[[[[Adv]]]]: public T [[textMessage]] ( final String text , final String [[encoding]] ) { return message ( new EmailMessage ( text , MimeTypes . MIME_TEXT_PLAIN , [[encoding]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .

[[[[Adv]]]]: public T [[questionable]] ( final String text , final String [[avraham]] ) { return message ( new EmailMessage ( text , MimeTypes . MIME_TEXT_PLAIN , [[avraham]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .
--------------------------------------------- Result 918 ---------------------------------------------
Generates a HTML html message . --> Convenience method to log messages --> Socre: 1.0

[[[[Adv]]]]: public T htmlMessage ( final String [[html]] , final String [[encoding]] ) { return message ( new EmailMessage ( [[html]] , MimeTypes . MIME_TEXT_HTML , [[encoding]] ) ) ; }
[[[[Nl]]]]: Adds HTML message .

[[[[Adv]]]]: public T htmlMessage ( final String [[powerpoint]] , final String [[grouchy]] ) { return message ( new EmailMessage ( [[powerpoint]] , MimeTypes . MIME_TEXT_HTML , [[grouchy]] ) ) ; }
[[[[Nl]]]]: Adds HTML message .
--------------------------------------------- Result 919 ---------------------------------------------
Returns the boolean value of a boolean . --> Convert a string to a string --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[getBoolean]] ( final String name , final boolean [[defaultValue]] ) { String [[value]] = get ( name ) ; if ( [[value]] == null ) { return [[defaultValue]] ; } [[value]] = [[value]] . trim ( ) . toLowerCase ( ) ; switch ( [[value]] ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as boolean .

[[[[Adv]]]]: public static boolean [[aoi]] ( final String name , final boolean [[roop]] ) { String [[relevance]] = get ( name ) ; if ( [[relevance]] == null ) { return [[roop]] ; } [[relevance]] = [[relevance]] . trim ( ) . toLowerCase ( ) ; switch ( [[relevance]] ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return [[roop]] ; } }
[[[[Nl]]]]: Returns system property as boolean .
--------------------------------------------- Result 920 ---------------------------------------------
Gets the value of the property . --> Obtain a string from a string --> Socre: 1.0

[[[[Adv]]]]: public static String [[get]] ( final String [[name]] , final String [[defaultValue]] ) { Objects . requireNonNull ( [[name]] ) ; String [[value]] = null ; try { if ( System . getSecurityManager ( ) == null ) { [[value]] = System . getProperty ( [[name]] ) ; } else { [[value]] = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( [[name]] ) ) ; } } catch ( Exception ignore ) { } if ( [[value]] == null ) { return [[defaultValue]] ; } return [[value]] ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .

[[[[Adv]]]]: public static String [[have]] ( final String [[nominated]] , final String [[moustache]] ) { Objects . requireNonNull ( [[nominated]] ) ; String [[cherishes]] = null ; try { if ( System . getSecurityManager ( ) == null ) { [[cherishes]] = System . getProperty ( [[nominated]] ) ; } else { [[cherishes]] = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( [[nominated]] ) ) ; } } catch ( Exception ignore ) { } if ( [[cherishes]] == null ) { return [[moustache]] ; } return [[cherishes]] ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .
--------------------------------------------- Result 921 ---------------------------------------------
Processes a class . --> Method to get the ClassLoader --> Socre: 1.0

[[[[Adv]]]]: public T [[setTarget]] ( final Class [[target]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[target]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[target]] . getName ( ) ) ; } targetClass = [[target]] ; targetClassName = [[target]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[target]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .

[[[[Adv]]]]: public T [[poplar]] ( final Class [[aspirations]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[aspirations]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[aspirations]] . getName ( ) ) ; } targetClass = [[aspirations]] ; targetClassName = [[aspirations]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[aspirations]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .
--------------------------------------------- Result 922 ---------------------------------------------
Parse a long . --> Get a string from a string --> Socre: 1.0

[[[[Adv]]]]: public static long getInt ( final String [[name]] , final int [[defaultValue]] ) { String value = get ( [[name]] ) ; if ( value == null ) { return [[defaultValue]] ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as an int .

[[[[Adv]]]]: public static long getInt ( final String [[appointing]] , final int [[overdrawn]] ) { String value = get ( [[appointing]] ) ; if ( value == null ) { return [[overdrawn]] ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return [[overdrawn]] ; } }
[[[[Nl]]]]: Returns system property as an int .
--------------------------------------------- Result 923 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 663 / 208 / 52 / 923:  92%|█████████▏| 923/1000 [3:33:43<17:49, 13.89s/it][Succeeded / Failed / Skipped / Total] 663 / 208 / 52 / 923:  92%|█████████▏| 924/1000 [3:33:46<17:34, 13.88s/it][Succeeded / Failed / Skipped / Total] 664 / 208 / 52 / 924:  92%|█████████▏| 924/1000 [3:33:46<17:34, 13.88s/it][Succeeded / Failed / Skipped / Total] 664 / 208 / 52 / 924:  92%|█████████▎| 925/1000 [3:33:49<17:20, 13.87s/it][Succeeded / Failed / Skipped / Total] 665 / 208 / 52 / 925:  92%|█████████▎| 925/1000 [3:33:49<17:20, 13.87s/it][Succeeded / Failed / Skipped / Total] 665 / 208 / 52 / 925:  93%|█████████▎| 926/1000 [3:33:50<17:05, 13.86s/it][Succeeded / Failed / Skipped / Total] 666 / 208 / 52 / 926:  93%|█████████▎| 926/1000 [3:33:50<17:05, 13.86s/it][Succeeded / Failed / Skipped / Total] 666 / 208 / 52 / 926:  93%|█████████▎| 927/1000 [3:34:00<16:51, 13.85s/it][Succeeded / Failed / Skipped / Total] 667 / 208 / 52 / 927:  93%|█████████▎| 927/1000 [3:34:00<16:51, 13.85s/it][Succeeded / Failed / Skipped / Total] 667 / 208 / 52 / 927:  93%|█████████▎| 928/1000 [3:34:04<16:36, 13.84s/it][Succeeded / Failed / Skipped / Total] 668 / 208 / 52 / 928:  93%|█████████▎| 928/1000 [3:34:04<16:36, 13.84s/it][Succeeded / Failed / Skipped / Total] 668 / 208 / 52 / 928:  93%|█████████▎| 929/1000 [3:34:07<16:21, 13.83s/it][Succeeded / Failed / Skipped / Total] 669 / 208 / 52 / 929:  93%|█████████▎| 929/1000 [3:34:07<16:21, 13.83s/it][Succeeded / Failed / Skipped / Total] 669 / 208 / 52 / 929:  93%|█████████▎| 930/1000 [3:34:38<16:09, 13.85s/it][Succeeded / Failed / Skipped / Total] 670 / 208 / 52 / 930:  93%|█████████▎| 930/1000 [3:34:38<16:09, 13.85s/it][Succeeded / Failed / Skipped / Total] 670 / 208 / 52 / 930:  93%|█████████▎| 931/1000 [3:34:39<15:54, 13.83s/it][Succeeded / Failed / Skipped / Total] 670 / 208 / 53 / 931:  93%|█████████▎| 931/1000 [3:34:39<15:54, 13.83s/it][Succeeded / Failed / Skipped / Total] 670 / 208 / 53 / 931:  93%|█████████▎| 932/1000 [3:35:02<15:41, 13.84s/it]Returns the FieldDescriptors for the given FieldDescriptor . --> [[[FAILED]]]

[[[[Adv]]]]: public FieldDescriptor [ ] getAllFieldDescriptors ( ) { if ( allFields == null ) { FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { allFields [ index ] = fieldDescriptor ; index ++ ; } Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = allFields ; } return allFields ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .

[[[[Adv]]]]: public FieldDescriptor [ ] getAllFieldDescriptors ( ) { if ( allFields == null ) { FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { allFields [ index ] = fieldDescriptor ; index ++ ; } Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = allFields ; } return allFields ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .
--------------------------------------------- Result 924 ---------------------------------------------
Returns the value of the alias . --> Get the current repository --> Socre: 1.0

[[[[Adv]]]]: protected String [[lookupAlias]] ( final String [[alias]] ) { String [[value]] = actionsManager . lookupPathAlias ( [[alias]] ) ; if ( [[value]] == null ) { ActionRuntime cfg = actionsManager . lookup ( [[alias]] ) ; if ( cfg != null ) { [[value]] = cfg . getActionPath ( ) ; } } return [[value]] ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .

[[[[Adv]]]]: protected String [[attempts]] ( final String [[faux]] ) { String [[extent]] = actionsManager . lookupPathAlias ( [[faux]] ) ; if ( [[extent]] == null ) { ActionRuntime cfg = actionsManager . lookup ( [[faux]] ) ; if ( cfg != null ) { [[extent]] = cfg . getActionPath ( ) ; } } return [[extent]] ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .
--------------------------------------------- Result 925 ---------------------------------------------
Resolve a single string . --> Convert a string to a String --> Socre: 1.0

[[[[Adv]]]]: protected String [[resolveAlias]] ( final String [[value]] ) { final StringBuilder [[result]] = new StringBuilder ( [[value]] . length ( ) ) ; int [[i]] = 0 ; int len = [[value]] . length ( ) ; while ( [[i]] < len ) { int [[ndx]] = [[value]] . indexOf ( ' ' , [[i]] ) ; if ( [[ndx]] == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .

[[[[Adv]]]]: protected String [[cabs]] ( final String [[amount]] ) { final StringBuilder [[reason]] = new StringBuilder ( [[amount]] . length ( ) ) ; int [[lai]] = 0 ; int len = [[amount]] . length ( ) ; while ( [[lai]] < len ) { int [[aar]] = [[amount]] . indexOf ( ' ' , [[lai]] ) ; if ( [[aar]] == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .
--------------------------------------------- Result 926 ---------------------------------------------
Adds a header . --> Convenience method to create a String --> Socre: 1.0

[[[[Adv]]]]: public T header ( final String [[name]] , final String [[value]] ) { headers . put ( [[name]] , [[value]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .

[[[[Adv]]]]: public T header ( final String [[arabians]] , final String [[assessing]] ) { headers . put ( [[arabians]] , [[assessing]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .
--------------------------------------------- Result 927 ---------------------------------------------
Resolves the path . --> Check if a network is enabled --> Socre: 1.0

[[[[Adv]]]]: public ResultPath [[resolveResultPath]] ( String [[path]] , String [[value]] ) { boolean [[absolutePath]] = "[[False]]" != "[[False]]" ; if ( [[value]] != null ) {
[[[[Nl]]]]: Resolves result path .

[[[[Adv]]]]: public ResultPath [[useless]] ( String [[course]] , String [[bravery]] ) { boolean [[telephoto]] = "[[Disingenuous]]" != "[[Disingenuous]]" ; if ( [[bravery]] != null ) {
[[[[Nl]]]]: Resolves result path .
--------------------------------------------- Result 928 ---------------------------------------------
Returns the fully qualified path . --> Obtains a string from a string --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfSlashDot]] ( final String [[str]] ) { int [[slashNdx]] = [[str]] . lastIndexOf ( ' ' ) ; int [[dotNdx]] = StringUtil . lastIndexOf ( [[str]] , ' ' , [[str]] . length ( ) , [[slashNdx]] ) ; if ( [[dotNdx]] == - 1 ) { if ( [[slashNdx]] == - 1 ) { return - 1 ; } [[slashNdx]] ++ ; if ( [[slashNdx]] < [[str]] . length ( ) - 1 ) { [[dotNdx]] = [[slashNdx]] ; } else { [[dotNdx]] = - 1 ; } } return [[dotNdx]] ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .

[[[[Adv]]]]: public static int [[aaaagh]] ( final String [[std]] ) { int [[wonton]] = [[std]] . lastIndexOf ( ' ' ) ; int [[neumann]] = StringUtil . lastIndexOf ( [[std]] , ' ' , [[std]] . length ( ) , [[wonton]] ) ; if ( [[neumann]] == - 1 ) { if ( [[wonton]] == - 1 ) { return - 1 ; } [[wonton]] ++ ; if ( [[wonton]] < [[std]] . length ( ) - 1 ) { [[neumann]] = [[wonton]] ; } else { [[neumann]] = - 1 ; } } return [[neumann]] ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .
--------------------------------------------- Result 929 ---------------------------------------------
Returns the number of occurrences of . --> Adapts a String to a String --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfDotAfterSlash]] ( final String [[str]] ) { int slashNdx = [[str]] . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( [[str]] , ' ' , [[str]] . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .

[[[[Adv]]]]: public static int [[hatful]] ( final String [[maxed]] ) { int slashNdx = [[maxed]] . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( [[maxed]] , ' ' , [[maxed]] . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .
--------------------------------------------- Result 930 ---------------------------------------------
Serializes a JSON object . --> Executes the given invoking statistics --> Socre: 1.0

[[[[Adv]]]]: protected int [[serializeKeyValue]] ( final JsonContext [[jsonContext]] , final Path currentPath , final Object [[key]] , final Object value , int [[count]] ) { if ( ( value == null ) && [[jsonContext]] . isExcludeNulls ( ) ) { return [[count]] ; } if ( [[key]] != null ) { currentPath . push ( [[key]] . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .

[[[[Adv]]]]: protected int [[achievement]] ( final JsonContext [[amassing]] , final Path currentPath , final Object [[significance]] , final Object value , int [[statistics]] ) { if ( ( value == null ) && [[amassing]] . isExcludeNulls ( ) ) { return [[statistics]] ; } if ( [[significance]] != null ) { currentPath . push ( [[significance]] . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .
--------------------------------------------- Result 931 ---------------------------------------------
Returns the string of a given name . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static String stripLastCamelWord ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
[[[[Nl]]]]: Removes last CamelWord
--------------------------------------------- Result 932 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 671 / 208 / 53 / 932:  93%|█████████▎| 932/1000 [3:35:02<15:41, 13.84s/it][Succeeded / Failed / Skipped / Total] 671 / 208 / 53 / 932:  93%|█████████▎| 933/1000 [3:35:04<15:26, 13.83s/it][Succeeded / Failed / Skipped / Total] 672 / 208 / 53 / 933:  93%|█████████▎| 933/1000 [3:35:04<15:26, 13.83s/it][Succeeded / Failed / Skipped / Total] 672 / 208 / 53 / 933:  93%|█████████▎| 934/1000 [3:35:08<15:12, 13.82s/it][Succeeded / Failed / Skipped / Total] 673 / 208 / 53 / 934:  93%|█████████▎| 934/1000 [3:35:08<15:12, 13.82s/it][Succeeded / Failed / Skipped / Total] 673 / 208 / 53 / 934:  94%|█████████▎| 935/1000 [3:35:13<14:57, 13.81s/it][Succeeded / Failed / Skipped / Total] 674 / 208 / 53 / 935:  94%|█████████▎| 935/1000 [3:35:13<14:57, 13.81s/it][Succeeded / Failed / Skipped / Total] 674 / 208 / 53 / 935:  94%|█████████▎| 936/1000 [3:35:18<14:43, 13.80s/it][Succeeded / Failed / Skipped / Total] 675 / 208 / 53 / 936:  94%|█████████▎| 936/1000 [3:35:18<14:43, 13.80s/it][Succeeded / Failed / Skipped / Total] 675 / 208 / 53 / 936:  94%|█████████▎| 937/1000 [3:35:20<14:28, 13.79s/it][Succeeded / Failed / Skipped / Total] 676 / 208 / 53 / 937:  94%|█████████▎| 937/1000 [3:35:20<14:28, 13.79s/it][Succeeded / Failed / Skipped / Total] 676 / 208 / 53 / 937:  94%|█████████▍| 938/1000 [3:35:21<14:14, 13.78s/it][Succeeded / Failed / Skipped / Total] 677 / 208 / 53 / 938:  94%|█████████▍| 938/1000 [3:35:21<14:14, 13.78s/it][Succeeded / Failed / Skipped / Total] 677 / 208 / 53 / 938:  94%|█████████▍| 939/1000 [3:35:29<13:59, 13.77s/it][Succeeded / Failed / Skipped / Total] 678 / 208 / 53 / 939:  94%|█████████▍| 939/1000 [3:35:29<13:59, 13.77s/it][Succeeded / Failed / Skipped / Total] 678 / 208 / 53 / 939:  94%|█████████▍| 940/1000 [3:36:15<13:48, 13.80s/it][Succeeded / Failed / Skipped / Total] 679 / 208 / 53 / 940:  94%|█████████▍| 940/1000 [3:36:15<13:48, 13.80s/it][Succeeded / Failed / Skipped / Total] 679 / 208 / 53 / 940:  94%|█████████▍| 941/1000 [3:36:36<13:34, 13.81s/it][Succeeded / Failed / Skipped / Total] 680 / 208 / 53 / 941:  94%|█████████▍| 941/1000 [3:36:36<13:34, 13.81s/it][Succeeded / Failed / Skipped / Total] 680 / 208 / 53 / 941:  94%|█████████▍| 942/1000 [3:36:50<13:21, 13.81s/it]Obtains a slash . --> Convert a string to a string --> Socre: 1.0

[[[[Adv]]]]: public static int [[indexOfDotAfterSlash]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return str . indexOf ( ' ' , slashNdx ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .

[[[[Adv]]]]: public static int [[paro]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return str . indexOf ( ' ' , slashNdx ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .
--------------------------------------------- Result 933 ---------------------------------------------
Create a new instance . --> Build a protection --> Socre: 1.0

[[[[Adv]]]]: public Object [[newInstance]] ( ) { Class [[type]] = define ( ) ; try { return ClassUtil . newInstance ( [[type]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .

[[[[Adv]]]]: public Object [[parasol]] ( ) { Class [[category]] = define ( ) ; try { return ClassUtil . newInstance ( [[category]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .
--------------------------------------------- Result 934 ---------------------------------------------
Adds an address to the address . --> Return a new transaction --> Socre: 1.0

[[[[Adv]]]]: public T [[to]] ( final EmailAddress [[to]] ) { this . [[to]] = ArraysUtil . append ( this . [[to]] , [[to]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .

[[[[Adv]]]]: public T [[pour]] ( final EmailAddress [[du]] ) { this . [[towards]] = ArraysUtil . append ( this . [[towards]] , [[pour]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .
--------------------------------------------- Result 935 ---------------------------------------------
Checks if the given column is a valid column . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static DbEntityColumnDescriptor [[resolveColumnDescriptors]] ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy [[columnNamingStrategy]] ) { String [[columnName]] = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .

[[[[Adv]]]]: public static DbEntityColumnDescriptor [[editing]] ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy [[vassal]] ) { String [[chaplain]] = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .
--------------------------------------------- Result 936 ---------------------------------------------
Swaps the elements of the elements --> Merges two arrays --> Socre: 1.0

[[[[Adv]]]]: private void [[mix]] ( final int [[j]] , final int [[d]] ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long [[rotl]] = r [ [[d]] % DEPTH_OF_D_IN_R ] [ [[j]] ] ;
[[[[Nl]]]]: Implementation of the MIX function .

[[[[Adv]]]]: private void [[merger]] ( final int [[k]] , final int [[five]] ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long [[supervision]] = r [ [[five]] % DEPTH_OF_D_IN_R ] [ [[k]] ] ;
[[[[Nl]]]]: Implementation of the MIX function .
--------------------------------------------- Result 937 ---------------------------------------------
Initializes a new array . --> Add a long array to a long array --> Socre: 1.0

[[[[Adv]]]]: public void init ( final long [ ] key , final long [ ] tweak ) { final int [[newNw]] = key . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .

[[[[Adv]]]]: public void init ( final long [ ] key , final long [ ] tweak ) { final int [[collaborators]] = key . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .
--------------------------------------------- Result 938 ---------------------------------------------
Calculates the number of timestamps . --> Similar for testing --> Socre: 1.0

[[[[Adv]]]]: private void [[keySchedule]] ( final int [[s]] ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .

[[[[Adv]]]]: private void [[wallaces]] ( final int [[dans]] ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .
--------------------------------------------- Result 939 ---------------------------------------------
Swaps two elements . --> Swaps two ints --> Socre: 1.0

[[[[Adv]]]]: private void [[demix]] ( final int [[j]] , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long rotr = r [ d % DEPTH_OF_D_IN_R ] [ [[j]] ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .

[[[[Adv]]]]: private void [[frosty]] ( final int [[i]] , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long rotr = r [ d % DEPTH_OF_D_IN_R ] [ [[i]] ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .
--------------------------------------------- Result 940 ---------------------------------------------
Returns the method parameter with the given name . --> Get the parameter for a parameter --> Socre: 1.0

[[[[Adv]]]]: MethodParameter [ ] [[getResolvedParameters]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .

[[[[Adv]]]]: MethodParameter [ ] [[neuralgia]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .
--------------------------------------------- Result 941 ---------------------------------------------
Returns the schema for the given schema . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveSchemaName]] ( final Class < ? > [[type]] , final String [[defaultSchemaName]] ) { String [[schemaName]] = null ; final DbTable [[dbTable]] = [[type]] . getAnnotation ( DbTable . class ) ; if ( [[dbTable]] != null ) { [[schemaName]] = [[dbTable]] . schema ( ) . trim ( ) ; } if ( ( [[schemaName]] == null ) || ( [[schemaName]] . length ( ) == 0 ) ) { [[schemaName]] = [[defaultSchemaName]] ; } return [[schemaName]] ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .

[[[[Adv]]]]: public static String [[calibrating]] ( final Class < ? > [[typing]] , final String [[spacesuits]] ) { String [[evolves]] = null ; final DbTable [[ruffled]] = [[typing]] . getAnnotation ( DbTable . class ) ; if ( [[ruffled]] != null ) { [[evolves]] = [[ruffled]] . schema ( ) . trim ( ) ; } if ( ( [[evolves]] == null ) || ( [[evolves]] . length ( ) == 0 ) ) { [[evolves]] = [[spacesuits]] ; } return [[evolves]] ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .
--------------------------------------------- Result 942 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 681 / 208 / 53 / 942:  94%|█████████▍| 942/1000 [3:36:50<13:21, 13.81s/it][Succeeded / Failed / Skipped / Total] 681 / 208 / 53 / 942:  94%|█████████▍| 943/1000 [3:36:56<13:06, 13.80s/it][Succeeded / Failed / Skipped / Total] 681 / 209 / 53 / 943:  94%|█████████▍| 943/1000 [3:36:56<13:06, 13.80s/it][Succeeded / Failed / Skipped / Total] 681 / 209 / 53 / 943:  94%|█████████▍| 944/1000 [3:37:00<12:52, 13.79s/it][Succeeded / Failed / Skipped / Total] 682 / 209 / 53 / 944:  94%|█████████▍| 944/1000 [3:37:00<12:52, 13.79s/it][Succeeded / Failed / Skipped / Total] 682 / 209 / 53 / 944:  94%|█████████▍| 945/1000 [3:37:20<12:38, 13.80s/it][Succeeded / Failed / Skipped / Total] 683 / 209 / 53 / 945:  94%|█████████▍| 945/1000 [3:37:20<12:38, 13.80s/it][Succeeded / Failed / Skipped / Total] 683 / 209 / 53 / 945:  95%|█████████▍| 946/1000 [3:37:21<12:24, 13.79s/it][Succeeded / Failed / Skipped / Total] 683 / 210 / 53 / 946:  95%|█████████▍| 946/1000 [3:37:21<12:24, 13.79s/it][Succeeded / Failed / Skipped / Total] 683 / 210 / 53 / 946:  95%|█████████▍| 947/1000 [3:37:23<12:10, 13.77s/it][Succeeded / Failed / Skipped / Total] 684 / 210 / 53 / 947:  95%|█████████▍| 947/1000 [3:37:23<12:10, 13.77s/it][Succeeded / Failed / Skipped / Total] 684 / 210 / 53 / 947:  95%|█████████▍| 948/1000 [3:37:26<11:55, 13.76s/it][Succeeded / Failed / Skipped / Total] 685 / 210 / 53 / 948:  95%|█████████▍| 948/1000 [3:37:26<11:55, 13.76s/it][Succeeded / Failed / Skipped / Total] 685 / 210 / 53 / 948:  95%|█████████▍| 949/1000 [3:37:37<11:41, 13.76s/it]Convert a byte array to a byte array . --> Get a big - endian - integer --> Socre: 1.0

[[[[Adv]]]]: protected static long [ ] [[bytesToLongs]] ( final byte [ ] ba , final int [[offset]] , final int size ) { long [ ] result = new long [ size >> 3 ] ; int i8 = [[offset]] ; for ( int [[i]] = 0 ; [[i]] < result . length ; [[i]] ++ ) { result [ [[i]] ] = Bits . getLong ( ba , i8 ) ; i8 += 8 ; } return result ; }
[[[[Nl]]]]: Converts segment of byte array into long array .

[[[[Adv]]]]: protected static long [ ] [[italian]] ( final byte [ ] ba , final int [[invalidated]] , final int size ) { long [ ] result = new long [ size >> 3 ] ; int i8 = [[invalidated]] ; for ( int [[hmm]] = 0 ; [[hmm]] < result . length ; [[hmm]] ++ ) { result [ [[hmm]] ] = Bits . getLong ( ba , i8 ) ; i8 += 8 ; } return result ; }
[[[[Nl]]]]: Converts segment of byte array into long array .
--------------------------------------------- Result 943 ---------------------------------------------
Returns the transaction . --> [[[FAILED]]]

[[[[Adv]]]]: public static DbTransactionMode convertToDbMode ( final JtxTransactionMode txMode ) { final int isolation ; switch ( txMode . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( isolation , txMode . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .

[[[[Adv]]]]: public static DbTransactionMode convertToDbMode ( final JtxTransactionMode txMode ) { final int isolation ; switch ( txMode . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( isolation , txMode . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .
--------------------------------------------- Result 944 ---------------------------------------------
Encrypts a block . --> Calculates zokeeper --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[encryptBlock]] ( final byte [ ] [[content]] , final int [[offset]] ) { long [ ] [[contentBlock]] = bytesToLongs ( [[content]] , [[offset]] , blockSizeInBytes ) ; long [ ] [[encryptedBlock]] = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( [[contentBlock]] , [[encryptedBlock]] ) ; return longsToBytes ( [[encryptedBlock]] ) ; }
[[[[Nl]]]]: Encrypts a block .

[[[[Adv]]]]: @ Override public byte [ ] [[heli]] ( final byte [ ] [[ingredient]] , final int [[neutralize]] ) { long [ ] [[cheez]] = bytesToLongs ( [[ingredient]] , [[neutralize]] , blockSizeInBytes ) ; long [ ] [[llamo]] = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( [[cheez]] , [[llamo]] ) ; return longsToBytes ( [[llamo]] ) ; }
[[[[Nl]]]]: Encrypts a block .
--------------------------------------------- Result 945 ---------------------------------------------
Returns the name of the path . --> Add a href to a href --> Socre: 1.0

[[[[Adv]]]]: public String [[path]] ( ) { if ( methref != null ) { final String [[methodName]] = methref . ref ( ) ; return target . getName ( ) + ' ' + [[methodName]] ; } return [[path]] ; }
[[[[Nl]]]]: Returns path value .

[[[[Adv]]]]: public String [[driveways]] ( ) { if ( methref != null ) { final String [[jab]] = methref . ref ( ) ; return target . getName ( ) + ' ' + [[jab]] ; } return [[driveways]] ; }
[[[[Nl]]]]: Returns path value .
--------------------------------------------- Result 946 ---------------------------------------------
Create a new file . --> [[[FAILED]]]

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String outFileName = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( outFileName ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( gzis ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String outFileName = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( outFileName ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( gzis ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .
--------------------------------------------- Result 947 ---------------------------------------------
Resolve a path . --> Convenience function for testing --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveResultPathString]] ( final String [[path]] , final String value ) { final ResultPath [[resultPath]] = resolveResultPath ( [[path]] , value ) ; final String result = [[resultPath]] . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .

[[[[Adv]]]]: public String [[fries]] ( final String [[pathway]] , final String value ) { final ResultPath [[detested]] = resolveResultPath ( [[pathway]] , value ) ; final String result = [[detested]] . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .
--------------------------------------------- Result 948 ---------------------------------------------
Unzip a directory . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static void unzip ( final String [[zipFile]] , final String [[destDir]] , final String ... [[patterns]] ) throws IOException { unzip ( new File ( [[zipFile]] ) , new File ( [[destDir]] ) , [[patterns]] ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .

[[[[Adv]]]]: public static void unzip ( final String [[enthralling]] , final String [[responsibly]] , final String ... [[styles]] ) throws IOException { unzip ( new File ( [[enthralling]] ) , new File ( [[responsibly]] ) , [[styles]] ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .
--------------------------------------------- Result 949 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 686 / 210 / 53 / 949:  95%|█████████▍| 949/1000 [3:37:37<11:41, 13.76s/it][Succeeded / Failed / Skipped / Total] 686 / 210 / 53 / 949:  95%|█████████▌| 950/1000 [3:38:01<11:28, 13.77s/it][Succeeded / Failed / Skipped / Total] 687 / 210 / 53 / 950:  95%|█████████▌| 950/1000 [3:38:01<11:28, 13.77s/it][Succeeded / Failed / Skipped / Total] 687 / 210 / 53 / 950:  95%|█████████▌| 951/1000 [3:38:32<11:15, 13.79s/it][Succeeded / Failed / Skipped / Total] 688 / 210 / 53 / 951:  95%|█████████▌| 951/1000 [3:38:32<11:15, 13.79s/it][Succeeded / Failed / Skipped / Total] 688 / 210 / 53 / 951:  95%|█████████▌| 952/1000 [3:38:40<11:01, 13.78s/it][Succeeded / Failed / Skipped / Total] 689 / 210 / 53 / 952:  95%|█████████▌| 952/1000 [3:38:40<11:01, 13.78s/it][Succeeded / Failed / Skipped / Total] 689 / 210 / 53 / 952:  95%|█████████▌| 953/1000 [3:39:02<10:48, 13.79s/it][Succeeded / Failed / Skipped / Total] 690 / 210 / 53 / 953:  95%|█████████▌| 953/1000 [3:39:02<10:48, 13.79s/it][Succeeded / Failed / Skipped / Total] 690 / 210 / 53 / 953:  95%|█████████▌| 954/1000 [3:39:23<10:34, 13.80s/it][Succeeded / Failed / Skipped / Total] 690 / 211 / 53 / 954:  95%|█████████▌| 954/1000 [3:39:23<10:34, 13.80s/it][Succeeded / Failed / Skipped / Total] 690 / 211 / 53 / 954:  96%|█████████▌| 955/1000 [3:39:35<10:20, 13.80s/it][Succeeded / Failed / Skipped / Total] 691 / 211 / 53 / 955:  96%|█████████▌| 955/1000 [3:39:35<10:20, 13.80s/it][Succeeded / Failed / Skipped / Total] 691 / 211 / 53 / 955:  96%|█████████▌| 956/1000 [3:40:17<10:08, 13.83s/it]Writes the given file to the given directory . --> Check if a file exists --> Socre: 1.0

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final File [[file]] , String path , final String comment , final boolean [[recursive]] ) throws IOException { if ( ! [[file]] . exists ( ) ) { throw new FileNotFoundException ( [[file]] . toString ( ) ) ; } if ( path == null ) { path = [[file]] . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean [[isDir]] = [[file]] . isDirectory ( ) ; if ( [[isDir]] ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final File [[deposited]] , String path , final String comment , final boolean [[spf]] ) throws IOException { if ( ! [[deposited]] . exists ( ) ) { throw new FileNotFoundException ( [[deposited]] . toString ( ) ) ; } if ( path == null ) { path = [[deposited]] . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean [[scoffing]] = [[deposited]] . isDirectory ( ) ; if ( [[scoffing]] ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .
--------------------------------------------- Result 950 ---------------------------------------------
Remove a string from the string . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: private static String [[removeAnyBounding]] ( final char [[s]] , final char [[e]] , final String [[str]] ) { if ( [[str]] == null || [[str]] . length ( ) < 2 ) { return [[str]] ; } if ( [[str]] . startsWith ( String . valueOf ( [[s]] ) ) && [[str]] . endsWith ( String . valueOf ( [[e]] ) ) ) { return [[str]] . substring ( 1 , [[str]] . length ( ) - 1 ) ; } return [[str]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .

[[[[Adv]]]]: private static String [[engaging]] ( final char [[d]] , final char [[d]] , final String [[stim]] ) { if ( [[stim]] == null || [[stim]] . length ( ) < 2 ) { return [[stim]] ; } if ( [[stim]] . startsWith ( String . valueOf ( [[d]] ) ) && [[stim]] . endsWith ( String . valueOf ( [[d]] ) ) ) { return [[stim]] . substring ( 1 , [[stim]] . length ( ) - 1 ) ; } return [[stim]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .
--------------------------------------------- Result 951 ---------------------------------------------
Returns the entries in the given directory . --> Get a list of all the jars from a file --> Socre: 1.0

[[[[Adv]]]]: public static List < String > listZip ( final File [[zipFile]] ) throws IOException { List < String > [[entries]] = new ArrayList <> ( ) ; ZipFile [[zip]] = new ZipFile ( [[zipFile]] ) ; Enumeration [[zipEntries]] = [[zip]] . entries ( ) ; while ( [[zipEntries]] . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) [[zipEntries]] . nextElement ( ) ; String [[entryName]] = entry . getName ( ) ; [[entries]] . add ( [[entryName]] ) ; } return Collections . unmodifiableList ( [[entries]] ) ; }
[[[[Nl]]]]: Lists zip content .

[[[[Adv]]]]: public static List < String > listZip ( final File [[rocke]] ) throws IOException { List < String > [[enter]] = new ArrayList <> ( ) ; ZipFile [[compresses]] = new ZipFile ( [[rocke]] ) ; Enumeration [[wrists]] = [[compresses]] . entries ( ) ; while ( [[wrists]] . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) [[wrists]] . nextElement ( ) ; String [[yaps]] = entry . getName ( ) ; [[enter]] . add ( [[yaps]] ) ; } return Collections . unmodifiableList ( [[enter]] ) ; }
[[[[Nl]]]]: Lists zip content .
--------------------------------------------- Result 952 ---------------------------------------------
Initialize the message . --> Calculates the zookeeper --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final String [[keyMessage]] , final long [[tweak1]] , final long [[tweak2]] ) { long [ ] tweak = new long [ ] { [[tweak1]] , [[tweak2]] } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] [[keyData]] = StringUtil . getBytes ( [[keyMessage]] ) ; System . arraycopy ( [[keyData]] , 0 , key , 0 , key . length < [[keyData]] . length ? key . length : [[keyData]] . length ) ; [[init]] ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .

[[[[Adv]]]]: public void [[manes]] ( final String [[telepathy]] , final long [[childcare]] , final long [[downy]] ) { long [ ] tweak = new long [ ] { [[childcare]] , [[downy]] } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] [[crozier]] = StringUtil . getBytes ( [[telepathy]] ) ; System . arraycopy ( [[crozier]] , 0 , key , 0 , key . length < [[crozier]] . length ? key . length : [[crozier]] . length ) ; [[manes]] ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .
--------------------------------------------- Result 953 ---------------------------------------------
Sets the locale . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static void [[setSessionLocale]] ( final HttpSession session , final String [[localeCode]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[localeCode]] ) ; } Locale locale = Locale . forLanguageTag ( [[localeCode]] ) ; session . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .

[[[[Adv]]]]: public static void [[kmart]] ( final HttpSession session , final String [[sleepin]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[sleepin]] ) ; } Locale locale = Locale . forLanguageTag ( [[sleepin]] ) ; session . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .
--------------------------------------------- Result 954 ---------------------------------------------
Get a long . --> [[[FAILED]]]

[[[[Adv]]]]: public static long getLong ( final String name , final long defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as a long .

[[[[Adv]]]]: public static long getLong ( final String name , final long defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as a long .
--------------------------------------------- Result 955 ---------------------------------------------
Set the bundle name . --> Unregisters the enhancerRequest --> Socre: 1.0

[[[[Adv]]]]: public static void [[setRequestBundleName]] ( final ServletRequest request , final String [[bundleName]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[bundleName]] ) ; } request . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[bundleName]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .

[[[[Adv]]]]: public static void [[crips]] ( final ServletRequest request , final String [[enhancers]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[enhancers]] ) ; } request . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[enhancers]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .
--------------------------------------------- Result 956 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 692 / 211 / 53 / 956:  96%|█████████▌| 956/1000 [3:40:17<10:08, 13.83s/it][Succeeded / Failed / Skipped / Total] 692 / 211 / 53 / 956:  96%|█████████▌| 957/1000 [3:40:41<09:54, 13.84s/it][Succeeded / Failed / Skipped / Total] 693 / 211 / 53 / 957:  96%|█████████▌| 957/1000 [3:40:41<09:54, 13.84s/it][Succeeded / Failed / Skipped / Total] 693 / 211 / 53 / 957:  96%|█████████▌| 958/1000 [3:43:06<09:46, 13.97s/it][Succeeded / Failed / Skipped / Total] 693 / 212 / 53 / 958:  96%|█████████▌| 958/1000 [3:43:06<09:46, 13.97s/it][Succeeded / Failed / Skipped / Total] 693 / 212 / 53 / 958:  96%|█████████▌| 959/1000 [3:43:16<09:32, 13.97s/it][Succeeded / Failed / Skipped / Total] 693 / 213 / 53 / 959:  96%|█████████▌| 959/1000 [3:43:16<09:32, 13.97s/it][Succeeded / Failed / Skipped / Total] 693 / 213 / 53 / 959:  96%|█████████▌| 960/1000 [3:43:16<09:18, 13.96s/it][Succeeded / Failed / Skipped / Total] 694 / 213 / 53 / 960:  96%|█████████▌| 960/1000 [3:43:16<09:18, 13.96s/it][Succeeded / Failed / Skipped / Total] 694 / 213 / 53 / 960:  96%|█████████▌| 961/1000 [3:43:43<09:04, 13.97s/it][Succeeded / Failed / Skipped / Total] 694 / 214 / 53 / 961:  96%|█████████▌| 961/1000 [3:43:43<09:04, 13.97s/it][Succeeded / Failed / Skipped / Total] 694 / 214 / 53 / 961:  96%|█████████▌| 962/1000 [3:43:55<08:50, 13.97s/it][Succeeded / Failed / Skipped / Total] 694 / 215 / 53 / 962:  96%|█████████▌| 962/1000 [3:43:55<08:50, 13.97s/it][Succeeded / Failed / Skipped / Total] 694 / 215 / 53 / 962:  96%|█████████▋| 963/1000 [3:43:58<08:36, 13.95s/it][Succeeded / Failed / Skipped / Total] 695 / 215 / 53 / 963:  96%|█████████▋| 963/1000 [3:43:58<08:36, 13.95s/it][Succeeded / Failed / Skipped / Total] 695 / 215 / 53 / 963:  96%|█████████▋| 964/1000 [3:44:26<08:22, 13.97s/it]Adds a profile . --> Adds a sketch --> Socre: 1.0

[[[[Adv]]]]: public PropsEntries [[profile]] ( final String ... [[profiles]] ) { if ( [[profiles]] == null ) { return this ; } for ( String [[profile]] : [[profiles]] ) { addProfiles ( [[profile]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .

[[[[Adv]]]]: public PropsEntries [[sketch]] ( final String ... [[sketches]] ) { if ( [[sketches]] == null ) { return this ; } for ( String [[sketch]] : [[sketches]] ) { addProfiles ( [[sketch]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .
--------------------------------------------- Result 957 ---------------------------------------------
Open a file . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static File [[gzip]] ( final File [[file]] ) throws IOException { if ( [[file]] . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream [[fis]] = new FileInputStream ( [[file]] ) ; String [[gzipName]] = [[file]] . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream [[gzos]] = new GZIPOutputStream ( new FileOutputStream ( [[gzipName]] ) ) ; try { StreamUtil . copy ( [[fis]] , [[gzos]] ) ; } finally { StreamUtil . close ( [[gzos]] ) ; StreamUtil . close ( [[fis]] ) ; } return new File ( [[gzipName]] ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .

[[[[Adv]]]]: public static File [[aka]] ( final File [[roster]] ) throws IOException { if ( [[roster]] . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream [[midlands]] = new FileInputStream ( [[roster]] ) ; String [[cleanse]] = [[roster]] . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream [[dumbstruck]] = new GZIPOutputStream ( new FileOutputStream ( [[cleanse]] ) ) ; try { StreamUtil . copy ( [[midlands]] , [[dumbstruck]] ) ; } finally { StreamUtil . close ( [[dumbstruck]] ) ; StreamUtil . close ( [[midlands]] ) ; } return new File ( [[cleanse]] ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .
--------------------------------------------- Result 958 ---------------------------------------------
Copy a file from a file . --> [[[FAILED]]]

[[[[Adv]]]]: public static File zlib ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = file . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .

[[[[Adv]]]]: public static File zlib ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = file . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .
--------------------------------------------- Result 959 ---------------------------------------------
Gets the locale . --> [[[FAILED]]]

[[[[Adv]]]]: public static Locale getSessionLocale ( final HttpSession session ) { Locale locale = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return locale == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : locale ; }
[[[[Nl]]]]: Returns current locale from session . s

[[[[Adv]]]]: public static Locale getSessionLocale ( final HttpSession session ) { Locale locale = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return locale == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : locale ; }
[[[[Nl]]]]: Returns current locale from session . s
--------------------------------------------- Result 960 ---------------------------------------------
Calculates a long . --> Convenience function for testing --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLongLittleEndian]] ( final byte [ ] [[buf]] , final int [[offset]] ) { return ( ( long ) [[buf]] [ [[offset]] + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .

[[[[Adv]]]]: public static long [[unreported]] ( final byte [ ] [[krug]] , final int [[compensation]] ) { return ( ( long ) [[krug]] [ [[compensation]] + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .
--------------------------------------------- Result 961 ---------------------------------------------
Returns true if the given field is declared . --> [[[FAILED]]]

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String name , final boolean declared ) { final FieldDescriptor fieldDescriptor = getFields ( ) . getFieldDescriptor ( name ) ; if ( fieldDescriptor != null ) { if ( ! fieldDescriptor . matchDeclared ( declared ) ) { return null ; } } return fieldDescriptor ; }
[[[[Nl]]]]: Returns field descriptor .

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String name , final boolean declared ) { final FieldDescriptor fieldDescriptor = getFields ( ) . getFieldDescriptor ( name ) ; if ( fieldDescriptor != null ) { if ( ! fieldDescriptor . matchDeclared ( declared ) ) { return null ; } } return fieldDescriptor ; }
[[[[Nl]]]]: Returns field descriptor .
--------------------------------------------- Result 962 ---------------------------------------------
Returns the value of the given property . --> [[[FAILED]]]

[[[[Adv]]]]: public PropertyDescriptor getPropertyDescriptor ( final String name , final boolean declared ) { PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( name ) ; if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( declared ) ) { return propertyDescriptor ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .

[[[[Adv]]]]: public PropertyDescriptor getPropertyDescriptor ( final String name , final boolean declared ) { PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( name ) ; if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( declared ) ) { return propertyDescriptor ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .
--------------------------------------------- Result 963 ---------------------------------------------
Reads a single attribute . --> Read a string from a string --> Socre: 1.0

[[[[Adv]]]]: private int [ ] [[readBootstrapMethodsAttribute]] ( final int maxStringLength ) { char [ ] [[charBuffer]] = new char [ maxStringLength ] ; int [[currentAttributeOffset]] = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int [[i]] = readUnsignedShort ( [[currentAttributeOffset]] - 2 ) ; [[i]] > 0 ; -- [[i]] ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .

[[[[Adv]]]]: private int [ ] [[fornicate]] ( final int maxStringLength ) { char [ ] [[physics]] = new char [ maxStringLength ] ; int [[torturer]] = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int [[wantto]] = readUnsignedShort ( [[torturer]] - 2 ) ; [[wantto]] > 0 ; -- [[wantto]] ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .
--------------------------------------------- Result 964 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 696 / 215 / 53 / 964:  96%|█████████▋| 964/1000 [3:44:26<08:22, 13.97s/it][Succeeded / Failed / Skipped / Total] 696 / 215 / 53 / 964:  96%|█████████▋| 965/1000 [3:45:14<08:10, 14.00s/it][Succeeded / Failed / Skipped / Total] 696 / 216 / 53 / 965:  96%|█████████▋| 965/1000 [3:45:14<08:10, 14.00s/it][Succeeded / Failed / Skipped / Total] 696 / 216 / 53 / 965:  97%|█████████▋| 966/1000 [3:45:32<07:56, 14.01s/it][Succeeded / Failed / Skipped / Total] 697 / 216 / 53 / 966:  97%|█████████▋| 966/1000 [3:45:32<07:56, 14.01s/it][Succeeded / Failed / Skipped / Total] 697 / 216 / 53 / 966:  97%|█████████▋| 967/1000 [3:45:46<07:42, 14.01s/it][Succeeded / Failed / Skipped / Total] 698 / 216 / 53 / 967:  97%|█████████▋| 967/1000 [3:45:46<07:42, 14.01s/it][Succeeded / Failed / Skipped / Total] 698 / 216 / 53 / 967:  97%|█████████▋| 968/1000 [3:46:03<07:28, 14.01s/it][Succeeded / Failed / Skipped / Total] 699 / 216 / 53 / 968:  97%|█████████▋| 968/1000 [3:46:03<07:28, 14.01s/it][Succeeded / Failed / Skipped / Total] 699 / 216 / 53 / 968:  97%|█████████▋| 969/1000 [3:46:06<07:14, 14.00s/it][Succeeded / Failed / Skipped / Total] 700 / 216 / 53 / 969:  97%|█████████▋| 969/1000 [3:46:06<07:14, 14.00s/it][Succeeded / Failed / Skipped / Total] 700 / 216 / 53 / 969:  97%|█████████▋| 970/1000 [3:46:06<06:59, 13.99s/it]Read annotations . --> Read traversal --> Socre: 1.0

[[[[Adv]]]]: private int getTypeAnnotationBytecodeOffset ( final int [ ] [[typeAnnotationOffsets]] , final int [[typeAnnotationIndex]] ) { if ( [[typeAnnotationOffsets]] == null || [[typeAnnotationIndex]] >= [[typeAnnotationOffsets]] . length || readByte ( [[typeAnnotationOffsets]] [ [[typeAnnotationIndex]] ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( [[typeAnnotationOffsets]] [ [[typeAnnotationIndex]] ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .

[[[[Adv]]]]: private int getTypeAnnotationBytecodeOffset ( final int [ ] [[travelogue]] , final int [[swag]] ) { if ( [[travelogue]] == null || [[swag]] >= [[travelogue]] . length || readByte ( [[travelogue]] [ [[swag]] ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( [[travelogue]] [ [[swag]] ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .
--------------------------------------------- Result 965 ---------------------------------------------
Read ZIP file . --> [[[FAILED]]]

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String path , final String comment ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , ' ' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { zipEntry . setComment ( comment ) ; } zos . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String path , final String comment ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , ' ' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { zipEntry . setComment ( comment ) ; } zos . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .
--------------------------------------------- Result 966 ---------------------------------------------
Returns a map of servlets . --> Add a bean to the network --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[getRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { return ( Map < String , TransientBeanData > ) [[servletRequest]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[nearsighted]] ( final HttpServletRequest [[amadeo]] ) { return ( Map < String , TransientBeanData > ) [[amadeo]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .
--------------------------------------------- Result 967 ---------------------------------------------
Create a new map . --> Generate a Bean --> Socre: 1.0

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[createRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { Map < String , TransientBeanData > map = new HashMap <> ( ) ; [[servletRequest]] . setAttribute ( ATTR_NAME , map ) ; return map ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[lamotta]] ( final HttpServletRequest [[xan]] ) { Map < String , TransientBeanData > map = new HashMap <> ( ) ; [[xan]] . setAttribute ( ATTR_NAME , map ) ; return map ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .
--------------------------------------------- Result 968 ---------------------------------------------
Read a frame . --> get frame frame --> Socre: 1.0

[[[[Adv]]]]: private int [[readVerificationTypeInfo]] ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] [[charBuffer]] , final Label [ ] labels ) { int [[currentOffset]] = verificationTypeInfoOffset ; int [[tag]] = b [ [[currentOffset]] ++ ] & 0xFF ; switch ( [[tag]] ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( [[currentOffset]] , [[charBuffer]] ) ; [[currentOffset]] += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( [[currentOffset]] ) , labels ) ; [[currentOffset]] += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return [[currentOffset]] ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .

[[[[Adv]]]]: private int [[beattie]] ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] [[moslem]] , final Label [ ] labels ) { int [[amendment]] = verificationTypeInfoOffset ; int [[marking]] = b [ [[amendment]] ++ ] & 0xFF ; switch ( [[marking]] ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( [[amendment]] , [[moslem]] ) ; [[amendment]] += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( [[amendment]] ) , labels ) ; [[amendment]] += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return [[amendment]] ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .
--------------------------------------------- Result 969 ---------------------------------------------
Initialize the configuration . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[init]] ( final FilterConfig filterConfig ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .

[[[[Adv]]]]: @ Override public void [[ramdas]] ( final FilterConfig filterConfig ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .
--------------------------------------------- Result 970 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 701 / 216 / 53 / 970:  97%|█████████▋| 970/1000 [3:46:06<06:59, 13.99s/it][Succeeded / Failed / Skipped / Total] 701 / 216 / 53 / 970:  97%|█████████▋| 971/1000 [3:46:19<06:45, 13.98s/it][Succeeded / Failed / Skipped / Total] 702 / 216 / 53 / 971:  97%|█████████▋| 971/1000 [3:46:19<06:45, 13.98s/it][Succeeded / Failed / Skipped / Total] 702 / 216 / 53 / 971:  97%|█████████▋| 972/1000 [3:46:21<06:31, 13.97s/it][Succeeded / Failed / Skipped / Total] 703 / 216 / 53 / 972:  97%|█████████▋| 972/1000 [3:46:21<06:31, 13.97s/it][Succeeded / Failed / Skipped / Total] 703 / 216 / 53 / 972:  97%|█████████▋| 973/1000 [3:46:24<06:16, 13.96s/it][Succeeded / Failed / Skipped / Total] 704 / 216 / 53 / 973:  97%|█████████▋| 973/1000 [3:46:24<06:16, 13.96s/it][Succeeded / Failed / Skipped / Total] 704 / 216 / 53 / 973:  97%|█████████▋| 974/1000 [3:46:28<06:02, 13.95s/it][Succeeded / Failed / Skipped / Total] 705 / 216 / 53 / 974:  97%|█████████▋| 974/1000 [3:46:28<06:02, 13.95s/it][Succeeded / Failed / Skipped / Total] 705 / 216 / 53 / 974:  98%|█████████▊| 975/1000 [3:46:40<05:48, 13.95s/it][Succeeded / Failed / Skipped / Total] 705 / 217 / 53 / 975:  98%|█████████▊| 975/1000 [3:46:40<05:48, 13.95s/it][Succeeded / Failed / Skipped / Total] 705 / 217 / 53 / 975:  98%|█████████▊| 976/1000 [3:47:04<05:35, 13.96s/it][Succeeded / Failed / Skipped / Total] 706 / 217 / 53 / 976:  98%|█████████▊| 976/1000 [3:47:04<05:35, 13.96s/it][Succeeded / Failed / Skipped / Total] 706 / 217 / 53 / 976:  98%|█████████▊| 977/1000 [3:47:24<05:21, 13.97s/it][Succeeded / Failed / Skipped / Total] 706 / 218 / 53 / 977:  98%|█████████▊| 977/1000 [3:47:24<05:21, 13.97s/it][Succeeded / Failed / Skipped / Total] 706 / 218 / 53 / 977:  98%|█████████▊| 978/1000 [3:48:13<05:08, 14.00s/it][Succeeded / Failed / Skipped / Total] 707 / 218 / 53 / 978:  98%|█████████▊| 978/1000 [3:48:13<05:08, 14.00s/it][Succeeded / Failed / Skipped / Total] 707 / 218 / 53 / 978:  98%|█████████▊| 979/1000 [3:48:40<04:54, 14.01s/it]Adds a file to the consumer . --> Add a new traversal . --> Socre: 1.0

[[[[Adv]]]]: public FindFile onFile ( final Consumer < File > [[fileConsumer]] ) { if ( consumers == null ) { consumers = Consumers . of ( [[fileConsumer]] ) ; } else { consumers . add ( [[fileConsumer]] ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer

[[[[Adv]]]]: public FindFile onFile ( final Consumer < File > [[trader]] ) { if ( consumers == null ) { consumers = Consumers . of ( [[trader]] ) ; } else { consumers . add ( [[trader]] ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer
--------------------------------------------- Result 971 ---------------------------------------------
Adds a file to the search path . --> Adds a file to a File --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URI [[searchPath]] ) { File file ; try { file = new File ( [[searchPath]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[searchPath]] , ex ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .

[[[[Adv]]]]: public FindFile [[utero]] ( final URI [[demagoguery]] ) { File file ; try { file = new File ( [[utero]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[utero]] , ex ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .
--------------------------------------------- Result 972 ---------------------------------------------
Search for a file . --> Add a File to a File --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URL searchPath ) { File [[file]] = FileUtil . toContainerFile ( [[searchPath]] ) ; if ( [[file]] == null ) { throw new FindFileException ( "URL error: " + [[searchPath]] ) ; } addPath ( [[file]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .

[[[[Adv]]]]: public FindFile [[binds]] ( final URL searchPath ) { File [[lodged]] = FileUtil . toContainerFile ( [[binds]] ) ; if ( [[lodged]] == null ) { throw new FindFileException ( "URL error: " + [[binds]] ) ; } addPath ( [[lodged]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .
--------------------------------------------- Result 973 ---------------------------------------------
Replies the given regular expression . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[include]] ( final String ... [[patterns]] ) { for ( String pattern : [[patterns]] ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .

[[[[Adv]]]]: public FindFile [[understand]] ( final String ... [[bosses]] ) { for ( String pattern : [[bosses]] ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .
--------------------------------------------- Result 974 ---------------------------------------------
Utility method that allows to exclude patterns . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[exclude]] ( final String ... [[patterns]] ) { for ( String pattern : [[patterns]] ) { rules . exclude ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .

[[[[Adv]]]]: public FindFile [[overruled]] ( final String ... [[modelled]] ) { for ( String pattern : [[modelled]] ) { rules . exclude ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .
--------------------------------------------- Result 975 ---------------------------------------------
Resolve a bean . --> [[[FAILED]]]

[[[[Adv]]]]: public String [ ] filterParametersForBeanName ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! key . startsWith ( beanName ) ) { continue ; } list . add ( key ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .

[[[[Adv]]]]: public String [ ] filterParametersForBeanName ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! key . startsWith ( beanName ) ) { continue ; } list . add ( key ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .
--------------------------------------------- Result 976 ---------------------------------------------
Converts the given value to an array . --> Obtain the primitive type of a class --> Socre: 1.0

[[[[Adv]]]]: protected long [ ] [[convertArrayToArray]] ( final Object [[value]] ) { final Class [[valueComponentType]] = [[value]] . getClass ( ) . getComponentType ( ) ; final long [ ] [[result]] ; if ( [[valueComponentType]] . isPrimitive ( ) ) { [[result]] = convertPrimitiveArrayToArray ( [[value]] , [[valueComponentType]] ) ; } else {
[[[[Nl]]]]: Converts array value to array .

[[[[Adv]]]]: protected long [ ] [[rca]] ( final Object [[usefulness]] ) { final Class [[hernan]] = [[usefulness]] . getClass ( ) . getComponentType ( ) ; final long [ ] [[performance]] ; if ( [[hernan]] . isPrimitive ( ) ) { [[performance]] = convertPrimitiveArrayToArray ( [[usefulness]] , [[hernan]] ) ; } else {
[[[[Nl]]]]: Converts array value to array .
--------------------------------------------- Result 977 ---------------------------------------------
Read a byte array . --> [[[FAILED]]]

[[[[Adv]]]]: private static byte [ ] readStream ( final InputStream inputStream , final boolean close ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , bytesRead ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( close ) { inputStream . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .

[[[[Adv]]]]: private static byte [ ] readStream ( final InputStream inputStream , final boolean close ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , bytesRead ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( close ) { inputStream . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .
--------------------------------------------- Result 978 ---------------------------------------------
Gets all files in the given directory . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public List < File > [[findAll]] ( ) { List < File > [[allFiles]] = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { [[allFiles]] . add ( file ) ; } return [[allFiles]] ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .

[[[[Adv]]]]: public List < File > [[tugboat]] ( ) { List < File > [[osteoporosis]] = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { [[osteoporosis]] . add ( file ) ; } return [[osteoporosis]] ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .
--------------------------------------------- Result 979 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 707 / 219 / 53 / 979:  98%|█████████▊| 979/1000 [3:48:40<04:54, 14.01s/it][Succeeded / Failed / Skipped / Total] 707 / 219 / 53 / 979:  98%|█████████▊| 980/1000 [3:48:54<04:40, 14.01s/it][Succeeded / Failed / Skipped / Total] 708 / 219 / 53 / 980:  98%|█████████▊| 980/1000 [3:48:54<04:40, 14.01s/it][Succeeded / Failed / Skipped / Total] 708 / 219 / 53 / 980:  98%|█████████▊| 981/1000 [3:48:58<04:26, 14.00s/it][Succeeded / Failed / Skipped / Total] 709 / 219 / 53 / 981:  98%|█████████▊| 981/1000 [3:48:58<04:26, 14.00s/it][Succeeded / Failed / Skipped / Total] 709 / 219 / 53 / 981:  98%|█████████▊| 982/1000 [3:49:37<04:12, 14.03s/it][Succeeded / Failed / Skipped / Total] 710 / 219 / 53 / 982:  98%|█████████▊| 982/1000 [3:49:37<04:12, 14.03s/it][Succeeded / Failed / Skipped / Total] 710 / 219 / 53 / 982:  98%|█████████▊| 983/1000 [3:50:18<03:58, 14.06s/it][Succeeded / Failed / Skipped / Total] 710 / 220 / 53 / 983:  98%|█████████▊| 983/1000 [3:50:18<03:58, 14.06s/it][Succeeded / Failed / Skipped / Total] 710 / 220 / 53 / 983:  98%|█████████▊| 984/1000 [3:50:35<03:44, 14.06s/it][Succeeded / Failed / Skipped / Total] 711 / 220 / 53 / 984:  98%|█████████▊| 984/1000 [3:50:35<03:44, 14.06s/it][Succeeded / Failed / Skipped / Total] 711 / 220 / 53 / 984:  98%|█████████▊| 985/1000 [3:50:40<03:30, 14.05s/it]Reads the labels . --> [[[FAILED]]]

[[[[Adv]]]]: protected Label readLabel ( final int bytecodeOffset , final Label [ ] labels ) { if ( labels [ bytecodeOffset ] == null ) { labels [ bytecodeOffset ] = new Label ( ) ; } return labels [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .

[[[[Adv]]]]: protected Label readLabel ( final int bytecodeOffset , final Label [ ] labels ) { if ( labels [ bytecodeOffset ] == null ) { labels [ bytecodeOffset ] = new Label ( ) ; } return labels [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .
--------------------------------------------- Result 980 ---------------------------------------------
Returns the Descriptors . --> Get a list of Kafkas --> Socre: 1.0

[[[[Adv]]]]: public CtorDescriptor getCtorDescriptor ( final Class ... args ) { ctors : for ( CtorDescriptor [[ctorDescriptor]] : allCtors ) { Class [ ] [[arg]] = [[ctorDescriptor]] . getParameters ( ) ; if ( [[arg]] . length != args . length ) { continue ; } for ( int [[j]] = 0 ; [[j]] < [[arg]] . length ; [[j]] ++ ) { if ( [[arg]] [ [[j]] ] != args [ [[j]] ] ) { continue ctors ; } } return [[ctorDescriptor]] ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .

[[[[Adv]]]]: public CtorDescriptor getCtorDescriptor ( final Class ... args ) { ctors : for ( CtorDescriptor [[scrap]] : allCtors ) { Class [ ] [[snowflake]] = [[scrap]] . getParameters ( ) ; if ( [[snowflake]] . length != args . length ) { continue ; } for ( int [[iv]] = 0 ; [[iv]] < [[snowflake]] . length ; [[iv]] ++ ) { if ( [[snowflake]] [ [[iv]] ] != args [ [[iv]] ] ) { continue ctors ; } } return [[scrap]] ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .
--------------------------------------------- Result 981 ---------------------------------------------
Get the output stream . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public PrintWriter [[getWriter]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .

[[[[Adv]]]]: public PrintWriter [[mutineers]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .
--------------------------------------------- Result 982 ---------------------------------------------
Returns the name of the given type . --> Convert a string to a string --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveBeanName]] ( final Class [[type]] , final boolean useLongTypeName ) { PetiteBean [[petiteBean]] = ( ( Class < ? > ) [[type]] ) . getAnnotation ( PetiteBean . class ) ; String [[name]] = null ; if ( [[petiteBean]] != null ) { [[name]] = [[petiteBean]] . value ( ) . trim ( ) ; } if ( ( [[name]] == null ) || ( [[name]] . length ( ) == 0 ) ) { if ( useLongTypeName ) { [[name]] = [[type]] . getName ( ) ; } else { [[name]] = StringUtil . uncapitalize ( [[type]] . getSimpleName ( ) ) ; } } return [[name]] ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .

[[[[Adv]]]]: public String [[maarten]] ( final Class [[sorting]] , final boolean useLongTypeName ) { PetiteBean [[horie]] = ( ( Class < ? > ) [[sorting]] ) . getAnnotation ( PetiteBean . class ) ; String [[numbering]] = null ; if ( [[horie]] != null ) { [[numbering]] = [[horie]] . value ( ) . trim ( ) ; } if ( ( [[numbering]] == null ) || ( [[numbering]] . length ( ) == 0 ) ) { if ( useLongTypeName ) { [[numbering]] = [[sorting]] . getName ( ) ; } else { [[numbering]] = StringUtil . uncapitalize ( [[sorting]] . getSimpleName ( ) ) ; } } return [[numbering]] ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .
--------------------------------------------- Result 983 ---------------------------------------------
Read annotation . --> [[[FAILED]]]

[[[[Adv]]]]: private int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { int currentOffset = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .

[[[[Adv]]]]: private int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { int currentOffset = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .
--------------------------------------------- Result 984 ---------------------------------------------
Initializes a path . --> Initialize a path --> Socre: 1.0

[[[[Adv]]]]: protected void init ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int index = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { files [ index ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( index != 0 ) { FilesIterator [[filesIterator]] = new FilesIterator ( files ) ; todoFiles . add ( [[filesIterator]] ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .

[[[[Adv]]]]: protected void init ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int index = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { files [ index ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( index != 0 ) { FilesIterator [[gunther]] = new FilesIterator ( files ) ; todoFiles . add ( [[gunther]] ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .
--------------------------------------------- Result 985 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 712 / 220 / 53 / 985:  98%|█████████▊| 985/1000 [3:50:40<03:30, 14.05s/it][Succeeded / Failed / Skipped / Total] 712 / 220 / 53 / 985:  99%|█████████▊| 986/1000 [3:50:51<03:16, 14.05s/it][Succeeded / Failed / Skipped / Total] 712 / 221 / 53 / 986:  99%|█████████▊| 986/1000 [3:50:51<03:16, 14.05s/it][Succeeded / Failed / Skipped / Total] 712 / 221 / 53 / 986:  99%|█████████▊| 987/1000 [3:50:59<03:02, 14.04s/it][Succeeded / Failed / Skipped / Total] 712 / 222 / 53 / 987:  99%|█████████▊| 987/1000 [3:50:59<03:02, 14.04s/it][Succeeded / Failed / Skipped / Total] 712 / 222 / 53 / 987:  99%|█████████▉| 988/1000 [3:51:29<02:48, 14.06s/it][Succeeded / Failed / Skipped / Total] 713 / 222 / 53 / 988:  99%|█████████▉| 988/1000 [3:51:29<02:48, 14.06s/it][Succeeded / Failed / Skipped / Total] 713 / 222 / 53 / 988:  99%|█████████▉| 989/1000 [3:51:37<02:34, 14.05s/it][Succeeded / Failed / Skipped / Total] 714 / 222 / 53 / 989:  99%|█████████▉| 989/1000 [3:51:37<02:34, 14.05s/it][Succeeded / Failed / Skipped / Total] 714 / 222 / 53 / 989:  99%|█████████▉| 990/1000 [3:51:38<02:20, 14.04s/it][Succeeded / Failed / Skipped / Total] 715 / 222 / 53 / 990:  99%|█████████▉| 990/1000 [3:51:38<02:20, 14.04s/it][Succeeded / Failed / Skipped / Total] 715 / 222 / 53 / 990:  99%|█████████▉| 991/1000 [3:51:39<02:06, 14.03s/it][Succeeded / Failed / Skipped / Total] 716 / 222 / 53 / 991:  99%|█████████▉| 991/1000 [3:51:39<02:06, 14.03s/it][Succeeded / Failed / Skipped / Total] 716 / 222 / 53 / 991:  99%|█████████▉| 992/1000 [3:52:46<01:52, 14.08s/it]Converts a constructor to a constructor --> Return a String representation of a class --> Socre: 1.0

[[[[Adv]]]]: public static String [[getConstructorDescriptor]] ( final Constructor < ? > [[constructor]] ) { StringBuilder [[stringBuilder]] = new StringBuilder ( ) ; [[stringBuilder]] . append ( ' ' ) ; Class < ? > [ ] parameters = [[constructor]] . getParameterTypes ( ) ; for ( Class < ? > [[parameter]] : parameters ) { appendDescriptor ( [[parameter]] , [[stringBuilder]] ) ; } return [[stringBuilder]] . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .

[[[[Adv]]]]: public static String [[implementation]] ( final Constructor < ? > [[builder]] ) { StringBuilder [[mcnair]] = new StringBuilder ( ) ; [[mcnair]] . append ( ' ' ) ; Class < ? > [ ] parameters = [[builder]] . getParameterTypes ( ) ; for ( Class < ? > [[calibers]] : parameters ) { appendDescriptor ( [[calibers]] , [[mcnair]] ) ; } return [[mcnair]] . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .
--------------------------------------------- Result 986 ---------------------------------------------
Adds a path to the list . --> [[[FAILED]]]

[[[[Adv]]]]: protected void addPath ( final File path ) { if ( ! path . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( path ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .

[[[[Adv]]]]: protected void addPath ( final File path ) { if ( ! path . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( path ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .
--------------------------------------------- Result 987 ---------------------------------------------
Instantiates the constructor . --> [[[FAILED]]]

[[[[Adv]]]]: protected CtorDescriptor [ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor ctor = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; allCtors [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .

[[[[Adv]]]]: protected CtorDescriptor [ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor ctor = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; allCtors [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .
--------------------------------------------- Result 988 ---------------------------------------------
Returns a string representation of a method . --> Create a new molecule --> Socre: 1.0

[[[[Adv]]]]: public static String [[getMethodDescriptor]] ( final Method method ) { StringBuilder [[stringBuilder]] = new StringBuilder ( ) ; [[stringBuilder]] . append ( ' ' ) ; Class < ? > [ ] [[parameters]] = method . getParameterTypes ( ) ; for ( Class < ? > [[parameter]] : [[parameters]] ) { appendDescriptor ( [[parameter]] , [[stringBuilder]] ) ; } [[stringBuilder]] . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , [[stringBuilder]] ) ; return [[stringBuilder]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .

[[[[Adv]]]]: public static String [[behavior]] ( final Method method ) { StringBuilder [[ectoplasmic]] = new StringBuilder ( ) ; [[ectoplasmic]] . append ( ' ' ) ; Class < ? > [ ] [[quantify]] = method . getParameterTypes ( ) ; for ( Class < ? > [[signposts]] : [[quantify]] ) { appendDescriptor ( [[signposts]] , [[ectoplasmic]] ) ; } [[ectoplasmic]] . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , [[ectoplasmic]] ) ; return [[ectoplasmic]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .
--------------------------------------------- Result 989 ---------------------------------------------
Resolves a bean . --> Build a Wikit --> Socre: 1.0

[[[[Adv]]]]: public WiringMode [[resolveBeanWiringMode]] ( final Class type ) { PetiteBean [[petiteBean]] = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; return [[petiteBean]] != null ? [[petiteBean]] . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .

[[[[Adv]]]]: public WiringMode [[build]] ( final Class type ) { PetiteBean [[broccoli]] = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; return [[broccoli]] != null ? [[broccoli]] . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .
--------------------------------------------- Result 990 ---------------------------------------------
Gets the number of arguments . --> Compare two Strings --> Socre: 1.0

[[[[Adv]]]]: public static int [[getArgumentsAndReturnSizes]] ( final String methodDescriptor ) { int [[argumentsSize]] = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .

[[[[Adv]]]]: public static int [[applaude]] ( final String methodDescriptor ) { int [[flyboy]] = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .
--------------------------------------------- Result 991 ---------------------------------------------
Returns a String representation of the given type . --> Build a method type --> Socre: 1.0

[[[[Adv]]]]: public static String getMethodDescriptor ( final Type returnType , final Type ... [[argumentTypes]] ) { StringBuilder [[stringBuilder]] = new StringBuilder ( ) ; [[stringBuilder]] . append ( ' ' ) ; for ( Type [[argumentType]] : [[argumentTypes]] ) { [[argumentType]] . appendDescriptor ( [[stringBuilder]] ) ; } [[stringBuilder]] . append ( ' ' ) ; returnType . appendDescriptor ( [[stringBuilder]] ) ; return [[stringBuilder]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .

[[[[Adv]]]]: public static String getMethodDescriptor ( final Type returnType , final Type ... [[spitballs]] ) { StringBuilder [[bobbing]] = new StringBuilder ( ) ; [[bobbing]] . append ( ' ' ) ; for ( Type [[meireles]] : [[spitballs]] ) { [[meireles]] . appendDescriptor ( [[bobbing]] ) ; } [[bobbing]] . append ( ' ' ) ; returnType . appendDescriptor ( [[bobbing]] ) ; return [[bobbing]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .
--------------------------------------------- Result 992 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 716 / 223 / 53 / 992:  99%|█████████▉| 992/1000 [3:52:46<01:52, 14.08s/it][Succeeded / Failed / Skipped / Total] 716 / 223 / 53 / 992:  99%|█████████▉| 993/1000 [3:53:50<01:38, 14.13s/it][Succeeded / Failed / Skipped / Total] 716 / 224 / 53 / 993:  99%|█████████▉| 993/1000 [3:53:50<01:38, 14.13s/it][Succeeded / Failed / Skipped / Total] 716 / 224 / 53 / 993:  99%|█████████▉| 994/1000 [3:54:13<01:24, 14.14s/it][Succeeded / Failed / Skipped / Total] 717 / 224 / 53 / 994:  99%|█████████▉| 994/1000 [3:54:13<01:24, 14.14s/it][Succeeded / Failed / Skipped / Total] 717 / 224 / 53 / 994: 100%|█████████▉| 995/1000 [3:55:31<01:11, 14.20s/it][Succeeded / Failed / Skipped / Total] 717 / 225 / 53 / 995: 100%|█████████▉| 995/1000 [3:55:31<01:11, 14.20s/it][Succeeded / Failed / Skipped / Total] 717 / 225 / 53 / 995: 100%|█████████▉| 996/1000 [3:56:05<00:56, 14.22s/it][Succeeded / Failed / Skipped / Total] 717 / 226 / 53 / 996: 100%|█████████▉| 996/1000 [3:56:05<00:56, 14.22s/it][Succeeded / Failed / Skipped / Total] 717 / 226 / 53 / 996: 100%|█████████▉| 997/1000 [3:56:38<00:42, 14.24s/it][Succeeded / Failed / Skipped / Total] 717 / 227 / 53 / 997: 100%|█████████▉| 997/1000 [3:56:38<00:42, 14.24s/it][Succeeded / Failed / Skipped / Total] 717 / 227 / 53 / 997: 100%|█████████▉| 998/1000 [3:57:15<00:28, 14.26s/it]Gets the next file . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Iterator < File > iterator ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .

[[[[Adv]]]]: @ Override public Iterator < File > iterator ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .
--------------------------------------------- Result 993 ---------------------------------------------
Gets the output stream . --> [[[FAILED]]]

[[[[Adv]]]]: public ServletOutputStream getOutputStream ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .

[[[[Adv]]]]: public ServletOutputStream getOutputStream ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .
--------------------------------------------- Result 994 ---------------------------------------------
Returns the size of the given size . --> Converts a String to a String --> Socre: 1.0

[[[[Adv]]]]: public int [[getSize]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .

[[[[Adv]]]]: public int [[barrios]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .
--------------------------------------------- Result 995 ---------------------------------------------
Returns a string representation of the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public String getClassName ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { stringBuilder . append ( "[]" ) ; } return stringBuilder . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .

[[[[Adv]]]]: public String getClassName ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { stringBuilder . append ( "[]" ) ; } return stringBuilder . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .
--------------------------------------------- Result 996 ---------------------------------------------
Set the transaction . --> [[[FAILED]]]

[[[[Adv]]]]: public void setRollbackOnly ( final Throwable th ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = th ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .

[[[[Adv]]]]: public void setRollbackOnly ( final Throwable th ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = th ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .
--------------------------------------------- Result 997 ---------------------------------------------
 --> [[[FAILED]]]

[[[[Adv]]]]: private void appendDescriptor ( final StringBuilder stringBuilder ) { if ( sort == OBJECT ) { stringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { stringBuilder . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { stringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .

[[[[Adv]]]]: private void appendDescriptor ( final StringBuilder stringBuilder ) { if ( sort == OBJECT ) { stringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { stringBuilder . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { stringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .
--------------------------------------------- Result 998 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 717 / 228 / 53 / 998: 100%|█████████▉| 998/1000 [3:57:15<00:28, 14.26s/it][Succeeded / Failed / Skipped / Total] 717 / 228 / 53 / 998: 100%|█████████▉| 999/1000 [3:58:24<00:14, 14.32s/it][Succeeded / Failed / Skipped / Total] 717 / 229 / 53 / 999: 100%|█████████▉| 999/1000 [3:58:24<00:14, 14.32s/it][Succeeded / Failed / Skipped / Total] 717 / 229 / 53 / 999: 100%|██████████| 1000/1000 [3:58:52<00:00, 14.33s/it][Succeeded / Failed / Skipped / Total] 717 / 230 / 53 / 1000: 100%|██████████| 1000/1000 [3:58:52<00:00, 14.33s/it]/data/zzr/CodeAttack/codeattack/search_methods/hard_label_search.py:487: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  similarity_scores = np.asarray(similarity_scores)
/data/zzr/CodeAttack/codeattack/search_methods/hard_label_search.py:487: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
  similarity_scores = np.asarray(similarity_scores)
Attack(
  (search_method): HardLabelSearch(
    (pop_size):  30
    (max_iters):  100
    (max_replacements_per_index):  25
  )
  (goal_function):  MinimizeBleu(
    (maximizable):  False
    (target_bleu):  0.0
  )
  (transformation):  WordSwapEmbedding(
    (max_candidates):  50
    (embedding):  WordEmbedding
  )
  (constraints): 
    (0): MaxWordsPerturbed(
        (max_num_words):  5
        (compare_against_original):  True
      )
    (1): KeyWord(
        (compare_against_original):  True
      )
    (2): RepeatModification
  (is_black_box):  True
) 

/data/zzr/CodeAttack/codeattack/search_methods/hard_label_search.py:487: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  similarity_scores = np.asarray(similarity_scores)
[Succeeded / Failed / Skipped / Total] 717 / 230 / 53 / 1000: 100%|██████████| 1000/1000 [3:58:55<00:00, 14.34s/it]Clears the transaction . --> [[[FAILED]]]

[[[[Adv]]]]: protected void rollbackAllResources ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .

[[[[Adv]]]]: protected void rollbackAllResources ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .
--------------------------------------------- Result 999 ---------------------------------------------
Commit the transaction . --> [[[FAILED]]]

[[[[Adv]]]]: protected void commitOrRollback ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "False" != "False" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "False" != "False" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .

[[[[Adv]]]]: protected void commitOrRollback ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "False" != "False" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "False" != "False" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .
--------------------------------------------- Result 1000 ---------------------------------------------
Check if the resource is active . --> [[[FAILED]]]

[[[[Adv]]]]: public < E > E requestResource ( final Class < E > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; E resource = lookupResource ( resourceType ) ; if ( resource == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

[[[[Adv]]]]: public < E > E requestResource ( final Class < E > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; E resource = lookupResource ( resourceType ) ; if ( resource == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

+-------------------------------+--------+
| Attack Results                |        |
+-------------------------------+--------+
| Number of successful attacks: | 717    |
| Number of failed attacks:     | 230    |
| Number of skipped attacks:    | 53     |
| Original accuracy:            | 94.7%  |
| Accuracy under attack:        | 23.0%  |
| Attack success rate:          | 75.71% |
| Average perturbed word %:     | 73.36% |
| Average num. words per input: | 3.91   |
| Avg num queries:              | 749.1  |
| Original BLEU-4:              | 13.89  |
| Perturbed BLEU-4:             | 2.61   |
+-------------------------------+--------+

