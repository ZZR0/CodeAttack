Some weights of the model checkpoint at bert-base-uncased were not used when initializing BertForMaskedLM: ['cls.seq_relationship.weight', 'cls.seq_relationship.bias']
- This IS expected if you are initializing BertForMaskedLM from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
- This IS NOT expected if you are initializing BertForMaskedLM from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).
textattack: Running 4 worker(s) on 4 GPU(s).
PositionalEncoding: doing nothing on call to _load_from_state_dict
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s]  0%|          | 1/1000 [00:09<2:40:59,  9.67s/it][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/1000 [00:09<2:41:01,  9.67s/it][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 2/1000 [00:09<1:22:55,  4.99s/it][Succeeded / Failed / Skipped / Total] 1 / 1 / 0 / 2:   0%|          | 2/1000 [00:09<1:22:55,  4.99s/it][Succeeded / Failed / Skipped / Total] 1 / 1 / 0 / 2:   0%|          | 3/1000 [00:25<2:20:39,  8.46s/it][Succeeded / Failed / Skipped / Total] 2 / 1 / 0 / 3:   0%|          | 3/1000 [00:25<2:20:39,  8.47s/it][Succeeded / Failed / Skipped / Total] 2 / 1 / 0 / 3:   0%|          | 4/1000 [00:26<1:49:53,  6.62s/it][Succeeded / Failed / Skipped / Total] 2 / 2 / 0 / 4:   0%|          | 4/1000 [00:26<1:49:53,  6.62s/it][Succeeded / Failed / Skipped / Total] 2 / 2 / 0 / 4:   0%|          | 5/1000 [00:27<1:30:57,  5.49s/it][Succeeded / Failed / Skipped / Total] 2 / 3 / 0 / 5:   0%|          | 5/1000 [00:27<1:30:57,  5.49s/it][Succeeded / Failed / Skipped / Total] 2 / 3 / 0 / 5:   1%|          | 6/1000 [00:36<1:41:44,  6.14s/it][Succeeded / Failed / Skipped / Total] 3 / 3 / 0 / 6:   1%|          | 6/1000 [00:36<1:41:45,  6.14s/it][Succeeded / Failed / Skipped / Total] 3 / 3 / 0 / 6:   1%|          | 7/1000 [00:44<1:44:42,  6.33s/it]--------------------------------------------- Result 1 ---------------------------------------------
Adds a observer to the queue . --> Queues a balancing --> Socre: 1.0

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U [[value]] , boolean [[delayError]] , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , [[value]] ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( [[value]] ) ; } } else { q . offer ( [[value]] ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , [[delayError]] , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U [[bearer]] , boolean [[spurcarrer]] , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , [[bearer]] ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( [[bearer]] ) ; } } else { q . offer ( [[bearer]] ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , [[spurcarrer]] , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 2 ---------------------------------------------
Sorts a Observable . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[balanced]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 3 ---------------------------------------------
Wraps the given observable . --> Convenience method for creating a commit --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler [[scheduler]] ) { final Observable < T > [[observable]] = co . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , [[observable]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler [[commitu]] ) { final Observable < T > [[allrvia]] = co . observeOn ( [[commitu]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , [[allrvia]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 4 ---------------------------------------------
Converts a Java source into a java object . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[hold]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 5 ---------------------------------------------
Creates a new builder . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[created]] ( int [[powerrupth]] ) { return new UnicastProcessor < T > ( [[powerrupth]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 6 ---------------------------------------------
Sets the internal state . --> Asynchronously get the internal thread --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[sato]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 7 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 4 / 0 / 7:   1%|          | 7/1000 [00:44<1:44:42,  6.33s/it][Succeeded / Failed / Skipped / Total] 3 / 4 / 0 / 7:   1%|          | 8/1000 [00:49<1:41:43,  6.15s/it][Succeeded / Failed / Skipped / Total] 3 / 5 / 0 / 8:   1%|          | 8/1000 [00:49<1:41:43,  6.15s/it][Succeeded / Failed / Skipped / Total] 3 / 5 / 0 / 8:   1%|          | 9/1000 [00:56<1:44:25,  6.32s/it][Succeeded / Failed / Skipped / Total] 3 / 6 / 0 / 9:   1%|          | 9/1000 [00:56<1:44:25,  6.32s/it][Succeeded / Failed / Skipped / Total] 3 / 6 / 0 / 9:   1%|          | 10/1000 [00:57<1:35:14,  5.77s/it][Succeeded / Failed / Skipped / Total] 4 / 6 / 0 / 10:   1%|          | 10/1000 [00:57<1:35:14,  5.77s/it][Succeeded / Failed / Skipped / Total] 4 / 6 / 0 / 10:   1%|          | 11/1000 [01:02<1:34:04,  5.71s/it][Succeeded / Failed / Skipped / Total] 4 / 7 / 0 / 11:   1%|          | 11/1000 [01:02<1:34:04,  5.71s/it][Succeeded / Failed / Skipped / Total] 4 / 7 / 0 / 11:   1%|          | 12/1000 [01:11<1:37:39,  5.93s/it][Succeeded / Failed / Skipped / Total] 4 / 8 / 0 / 12:   1%|          | 12/1000 [01:11<1:37:39,  5.93s/it][Succeeded / Failed / Skipped / Total] 4 / 8 / 0 / 12:   1%|▏         | 13/1000 [01:18<1:39:24,  6.04s/it][Succeeded / Failed / Skipped / Total] 4 / 9 / 0 / 13:   1%|▏         | 13/1000 [01:18<1:39:24,  6.04s/it][Succeeded / Failed / Skipped / Total] 4 / 9 / 0 / 13:   1%|▏         | 14/1000 [01:29<1:44:53,  6.38s/it]Creates and returns a listener which allows to connect to a specific value . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[element]] ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 8 ---------------------------------------------
Convenience method for creating a flow . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Flowable < U > scalarXMap ( final T [[value]] , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[value]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > scalarXMap ( final T [[entry]] , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[entry]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 9 ---------------------------------------------
Create a Completable from the given source . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource [[completableSource]] ) { ObjectHelper . requireNonNull ( [[completableSource]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[completableSource]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource [[colpookeyοughe]] ) { ObjectHelper . requireNonNull ( [[colpookeyοughe]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[colpookeyοughe]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 10 ---------------------------------------------
Converts a predicate to a predicate . --> Convert a Throwable to an Exception --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long times , Predicate < ? super Throwable > [[predicate]] ) { return toFlowable ( ) . retry ( times , [[predicate]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long times , Predicate < ? super Throwable > [[tpose]] ) { return toFlowable ( ) . retry ( times , [[tpose]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 11 ---------------------------------------------
Converts a Throwable to an object . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] requireNonNull ( [[T]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < [[t]] > [[t]] requireNonNull ( [[t]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 12 ---------------------------------------------
Returns an unmodifiable function . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[text]] > Function < [[text]] , [[text]] > [[de]] ( ) { return ( Function < [[text]] , [[text]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 13 ---------------------------------------------
Creates a new Callable that implements the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > [[justCallable]] ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > [[overanalapplike]] ( T [[message]] ) { return new JustValue < Object , T > ( [[message]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 14 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 10 / 0 / 14:   1%|▏         | 14/1000 [01:29<1:44:53,  6.38s/it][Succeeded / Failed / Skipped / Total] 4 / 10 / 0 / 14:   2%|▏         | 15/1000 [01:29<1:38:17,  5.99s/it][Succeeded / Failed / Skipped / Total] 4 / 11 / 0 / 15:   2%|▏         | 15/1000 [01:29<1:38:17,  5.99s/it][Succeeded / Failed / Skipped / Total] 4 / 11 / 0 / 15:   2%|▏         | 16/1000 [01:34<1:36:58,  5.91s/it][Succeeded / Failed / Skipped / Total] 4 / 12 / 0 / 16:   2%|▏         | 16/1000 [01:34<1:36:58,  5.91s/it][Succeeded / Failed / Skipped / Total] 4 / 12 / 0 / 16:   2%|▏         | 17/1000 [01:43<1:40:13,  6.12s/it][Succeeded / Failed / Skipped / Total] 4 / 13 / 0 / 17:   2%|▏         | 17/1000 [01:44<1:40:13,  6.12s/it][Succeeded / Failed / Skipped / Total] 4 / 13 / 0 / 17:   2%|▏         | 18/1000 [01:44<1:35:18,  5.82s/it][Succeeded / Failed / Skipped / Total] 4 / 14 / 0 / 18:   2%|▏         | 18/1000 [01:44<1:35:18,  5.82s/it][Succeeded / Failed / Skipped / Total] 4 / 14 / 0 / 18:   2%|▏         | 19/1000 [01:54<1:38:27,  6.02s/it][Succeeded / Failed / Skipped / Total] 5 / 14 / 0 / 19:   2%|▏         | 19/1000 [01:54<1:38:27,  6.02s/it][Succeeded / Failed / Skipped / Total] 5 / 14 / 0 / 19:   2%|▏         | 20/1000 [02:01<1:39:22,  6.08s/it][Succeeded / Failed / Skipped / Total] 6 / 14 / 0 / 20:   2%|▏         | 20/1000 [02:01<1:39:22,  6.08s/it][Succeeded / Failed / Skipped / Total] 6 / 14 / 0 / 20:   2%|▏         | 21/1000 [02:01<1:34:46,  5.81s/it]Wraps a callable . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( Publisher < T > [[source]] , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( [[source]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "[[True]]" == "[[True]]" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "[[True]]" == "[[True]]" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[jicyntpointrampressumfold]] ( Publisher < T > [[book]] , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( [[book]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[book]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[falsely]]" == "[[falsely]]" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "[[falsely]]" == "[[falsely]]" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[falsely]]" == "[[falsely]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[falsely]]" == "[[falsely]]" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "[[falsely]]" == "[[falsely]]" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "[[falsely]]" == "[[falsely]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 15 ---------------------------------------------
Wraps the given source . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromSingle ( SingleSource < T > [[singleSource]] ) { ObjectHelper . requireNonNull ( [[singleSource]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[singleSource]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromSingle ( SingleSource < T > [[aceseard]] ) { ObjectHelper . requireNonNull ( [[aceseard]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[aceseard]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 16 ---------------------------------------------
Returns a Function that implements the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Function < T , U > [[justFunction]] ( U [[value]] ) { return new JustValue < T , U > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < T , U > Function < T , U > [[bydunst]] ( U [[component]] ) { return new JustValue < T , U > ( [[component]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 17 ---------------------------------------------
Create a new Subject . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[t]]" == "[[t]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 18 ---------------------------------------------
Creates a new instance of the given function . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > castFunction ( Class < U > [[target]] ) { return new CastToClass < [[T]] , U > ( [[target]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < [[ti]] , U > Function < [[ti]] , U > castFunction ( Class < U > [[domain]] ) { return new CastToClass < [[ti]] , U > ( [[domain]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 19 ---------------------------------------------
Returns the number of times . --> Returns a random exception --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[blockseldtorrand]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 20 ---------------------------------------------
Creates a builder for a given Subject . --> Returns a &lt ; &gt ; &gt ; &gt ; &gt ; &gt &lt ; &lt &gt ; &gt &gt ; &lt ; &gt &gt &gt ; &gt &lt ; &gt ; &lt &gt &gt ; &gt &gt &lt ;  --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[artist]] ( int [[commandparnt]] ) { return new UnicastSubject < T > ( [[commandparnt]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 21 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 7 / 14 / 0 / 21:   2%|▏         | 21/1000 [02:01<1:34:46,  5.81s/it][Succeeded / Failed / Skipped / Total] 7 / 14 / 0 / 21:   2%|▏         | 22/1000 [02:13<1:39:04,  6.08s/it][Succeeded / Failed / Skipped / Total] 8 / 14 / 0 / 22:   2%|▏         | 22/1000 [02:13<1:39:04,  6.08s/it][Succeeded / Failed / Skipped / Total] 8 / 14 / 0 / 22:   2%|▏         | 23/1000 [02:22<1:41:10,  6.21s/it][Succeeded / Failed / Skipped / Total] 9 / 14 / 0 / 23:   2%|▏         | 23/1000 [02:22<1:41:10,  6.21s/it][Succeeded / Failed / Skipped / Total] 9 / 14 / 0 / 23:   2%|▏         | 24/1000 [02:23<1:37:14,  5.98s/it][Succeeded / Failed / Skipped / Total] 9 / 15 / 0 / 24:   2%|▏         | 24/1000 [02:23<1:37:14,  5.98s/it][Succeeded / Failed / Skipped / Total] 9 / 15 / 0 / 24:   2%|▎         | 25/1000 [02:26<1:34:59,  5.85s/it][Succeeded / Failed / Skipped / Total] 9 / 16 / 0 / 25:   2%|▎         | 25/1000 [02:26<1:34:59,  5.85s/it][Succeeded / Failed / Skipped / Total] 9 / 16 / 0 / 25:   3%|▎         | 26/1000 [02:36<1:37:52,  6.03s/it][Succeeded / Failed / Skipped / Total] 9 / 17 / 0 / 26:   3%|▎         | 26/1000 [02:36<1:37:53,  6.03s/it][Succeeded / Failed / Skipped / Total] 9 / 17 / 0 / 26:   3%|▎         | 27/1000 [02:47<1:40:51,  6.22s/it][Succeeded / Failed / Skipped / Total] 10 / 17 / 0 / 27:   3%|▎         | 27/1000 [02:47<1:40:51,  6.22s/it][Succeeded / Failed / Skipped / Total] 10 / 17 / 0 / 27:   3%|▎         | 28/1000 [02:48<1:37:32,  6.02s/it]Create a batch . --> Create a new ByteBuffer --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( boolean [[delayError]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[delayError]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( boolean [[queuesroom]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[queuesroom]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 22 ---------------------------------------------
Decreases the queue . --> Convenience function to execute asynchronously --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > void [[drainMaxLoop]] ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void [[powertojoopers]] ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 23 ---------------------------------------------
Advances a prefetch . --> A convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static void [[request]] ( Subscription s , int prefetch ) { s . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void [[download]] ( Subscription s , int prefetch ) { s . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 24 ---------------------------------------------
Wraps a given blocks and returns it . --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long timeout , TimeUnit [[unit]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , [[unit]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , [[unit]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[blockstheariver]] ( long timeout , TimeUnit [[minute]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , [[minute]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , [[minute]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 25 ---------------------------------------------
Creates and returns a new builder with the given value . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int capacityHint , Runnable [[onTerminate]] ) { return new UnicastSubject < T > ( capacityHint , [[onTerminate]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int capacityHint , Runnable [[ultratiermit]] ) { return new UnicastSubject < T > ( capacityHint , [[ultratiermit]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 26 ---------------------------------------------
Returns the value of the given object . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object [[o]] = value ; if ( [[o]] != null && ! NotificationLite . isError ( [[o]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[fbackui]] ( ) { Object [[p]] = value ; if ( [[p]] != null && ! NotificationLite . isError ( [[p]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 27 ---------------------------------------------
Waits for a process . --> Wrap a RuntimeException --> Socre: 1.0

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } } Throwable [[ex]] = error ; if ( [[ex]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[netapid]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[base]] ) ; } } Throwable [[base]] = error ; if ( [[base]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[base]] ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 28 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 10 / 18 / 0 / 28:   3%|▎         | 28/1000 [02:48<1:37:32,  6.02s/it][Succeeded / Failed / Skipped / Total] 10 / 18 / 0 / 28:   3%|▎         | 29/1000 [02:51<1:35:41,  5.91s/it][Succeeded / Failed / Skipped / Total] 10 / 19 / 0 / 29:   3%|▎         | 29/1000 [02:51<1:35:41,  5.91s/it][Succeeded / Failed / Skipped / Total] 10 / 19 / 0 / 29:   3%|▎         | 30/1000 [02:52<1:33:07,  5.76s/it][Succeeded / Failed / Skipped / Total] 11 / 19 / 0 / 30:   3%|▎         | 30/1000 [02:52<1:33:07,  5.76s/it][Succeeded / Failed / Skipped / Total] 11 / 19 / 0 / 30:   3%|▎         | 31/1000 [03:20<1:44:14,  6.45s/it][Succeeded / Failed / Skipped / Total] 12 / 19 / 0 / 31:   3%|▎         | 31/1000 [03:20<1:44:14,  6.45s/it][Succeeded / Failed / Skipped / Total] 12 / 19 / 0 / 31:   3%|▎         | 32/1000 [03:33<1:47:23,  6.66s/it][Succeeded / Failed / Skipped / Total] 12 / 20 / 0 / 32:   3%|▎         | 32/1000 [03:33<1:47:23,  6.66s/it][Succeeded / Failed / Skipped / Total] 12 / 20 / 0 / 32:   3%|▎         | 33/1000 [03:34<1:44:34,  6.49s/it][Succeeded / Failed / Skipped / Total] 12 / 21 / 0 / 33:   3%|▎         | 33/1000 [03:34<1:44:34,  6.49s/it][Succeeded / Failed / Skipped / Total] 12 / 21 / 0 / 33:   3%|▎         | 34/1000 [03:40<1:44:10,  6.47s/it]Get the value of the error . --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[checkedper]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 29 ---------------------------------------------
Synchronise the current thread . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[complete]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long [[r]] = get ( ) ; if ( ( [[r]] & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( [[r]] & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[bound]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long [[p]] = get ( ) ; if ( ( [[p]] & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( [[p]] & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 30 ---------------------------------------------
Shuts down this queue . --> Shuts down a line --> Socre: 1.0

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > [[queue]] , AtomicLong [[state]] , BooleanSupplier isCancelled ) { if ( [[queue]] . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[state]] . get ( ) , actual , [[queue]] , [[state]] , isCancelled ) ) { return ; } for ( ; ; ) { long r = [[state]] . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long [[u]] = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > [[line]] , AtomicLong [[front]] , BooleanSupplier isCancelled ) { if ( [[line]] . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[front]] . get ( ) , actual , [[line]] , [[front]] , isCancelled ) ) { return ; } for ( ; ; ) { long r = [[front]] . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long [[c]] = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 31 ---------------------------------------------
Return true if the supplied action . --> Shut downstream --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[validate]] ( Disposable upstream , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( upstream != null ) { [[next]] . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[ifake]] ( Disposable upstream , Disposable [[downstream]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[downstream]] , "next is null" ) ; if ( upstream != null ) { [[downstream]] . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[fail]]" != "[[fail]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 32 ---------------------------------------------
Handle a subscription . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean validate ( Subscription [[upstream]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[upstream]] != null ) { next . cancel ( ) ; if ( [[upstream]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Subscription [[out]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[out]] != null ) { next . cancel ( ) ; if ( [[out]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "[[proven]]" == "[[proven]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 33 ---------------------------------------------
Sets the subscription . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[setOnce]] ( AtomicReference < Subscription > [[upstream]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( [[upstream]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean [[steiver]] ( AtomicReference < Subscription > [[across]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[across]] . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( [[across]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 34 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 12 / 22 / 0 / 34:   3%|▎         | 34/1000 [03:40<1:44:10,  6.47s/it][Succeeded / Failed / Skipped / Total] 12 / 22 / 0 / 34:   4%|▎         | 35/1000 [03:41<1:41:47,  6.33s/it][Succeeded / Failed / Skipped / Total] 13 / 22 / 0 / 35:   4%|▎         | 35/1000 [03:41<1:41:47,  6.33s/it][Succeeded / Failed / Skipped / Total] 13 / 22 / 0 / 35:   4%|▎         | 36/1000 [03:46<1:41:08,  6.30s/it][Succeeded / Failed / Skipped / Total] 13 / 23 / 0 / 36:   4%|▎         | 36/1000 [03:46<1:41:08,  6.30s/it][Succeeded / Failed / Skipped / Total] 13 / 23 / 0 / 36:   4%|▎         | 37/1000 [03:47<1:38:45,  6.15s/it][Succeeded / Failed / Skipped / Total] 14 / 23 / 0 / 37:   4%|▎         | 37/1000 [03:47<1:38:45,  6.15s/it][Succeeded / Failed / Skipped / Total] 14 / 23 / 0 / 37:   4%|▍         | 38/1000 [03:50<1:37:17,  6.07s/it][Succeeded / Failed / Skipped / Total] 15 / 23 / 0 / 38:   4%|▍         | 38/1000 [03:50<1:37:17,  6.07s/it][Succeeded / Failed / Skipped / Total] 15 / 23 / 0 / 38:   4%|▍         | 39/1000 [03:55<1:36:50,  6.05s/it][Succeeded / Failed / Skipped / Total] 16 / 23 / 0 / 39:   4%|▍         | 39/1000 [03:55<1:36:50,  6.05s/it][Succeeded / Failed / Skipped / Total] 16 / 23 / 0 / 39:   4%|▍         | 40/1000 [04:02<1:37:01,  6.06s/it][Succeeded / Failed / Skipped / Total] 16 / 24 / 0 / 40:   4%|▍         | 40/1000 [04:02<1:37:01,  6.06s/it][Succeeded / Failed / Skipped / Total] 16 / 24 / 0 / 40:   4%|▍         | 41/1000 [04:06<1:36:16,  6.02s/it][Succeeded / Failed / Skipped / Total] 16 / 25 / 0 / 41:   4%|▍         | 41/1000 [04:06<1:36:16,  6.02s/it][Succeeded / Failed / Skipped / Total] 16 / 25 / 0 / 41:   4%|▍         | 42/1000 [04:14<1:36:47,  6.06s/it][Succeeded / Failed / Skipped / Total] 16 / 26 / 0 / 42:   4%|▍         | 42/1000 [04:14<1:36:47,  6.06s/it][Succeeded / Failed / Skipped / Total] 16 / 26 / 0 / 42:   4%|▍         | 43/1000 [04:17<1:35:27,  5.98s/it]Add a long . --> [[[FAILED]]]

[[[[Adv]]]]: public static long [[addCap]] ( long a , long b ) { long u = a + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[bringap]] ( long a , long b ) { long u = a + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 35 ---------------------------------------------
Adds a new ranges to the set . --> Return a set of ranges --> Socre: 1.0

[[[[Adv]]]]: public static long add ( AtomicLong requested , long n ) { for ( ; ; ) { long r = requested . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long [[u]] = addCap ( r , n ) ; if ( requested . compareAndSet ( r , [[u]] ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long add ( AtomicLong requested , long n ) { for ( ; ; ) { long r = requested . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long [[h]] = addCap ( r , n ) ; if ( requested . compareAndSet ( r , [[h]] ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 36 ---------------------------------------------
Sets the current thread . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable [[next]] , Class < ? > [[observer]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[next]] ) ) { [[next]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observer]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable [[2nd]] , Class < ? > [[co]] ) { ObjectHelper . requireNonNull ( [[2nd]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[2nd]] ) ) { [[2nd]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[co]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 37 ---------------------------------------------
Adds a new object . --> Invoked when the object is enabled --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[assignment]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 38 ---------------------------------------------
Returns the long value . --> Subroutine to band --> Socre: 1.0

[[[[Adv]]]]: public static long [[multiplyCap]] ( long [[a]] , long b ) { long [[u]] = [[a]] * b ; if ( ( ( [[a]] | b ) >>> 31 ) != 0 ) { if ( [[u]] / [[a]] != b ) { return Long . MAX_VALUE ; } } return [[u]] ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[broadliparray]] ( long [[b]] , long b ) { long [[movement]] = [[b]] * b ; if ( ( ( [[b]] | b ) >>> 31 ) != 0 ) { if ( [[movement]] / [[b]] != b ) { return Long . MAX_VALUE ; } } return [[movement]] ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 39 ---------------------------------------------
Shuts down the executor . --> Shuts down all threads --> Socre: 1.0

[[[[Adv]]]]: public static void shutdown ( ) { ScheduledExecutorService [[exec]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[exec]] != null ) { [[exec]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void shutdown ( ) { ScheduledExecutorService [[osc]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[osc]] != null ) { [[osc]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 40 ---------------------------------------------
Create a new exception . --> [[[FAILED]]]

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[ripone]] ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 41 ---------------------------------------------
Creates a executor service . --> [[[FAILED]]]

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory [[factory]] ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , [[factory]] ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[artist]] ( ThreadFactory [[gallery]] ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , [[gallery]] ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 42 ---------------------------------------------
Shronously cancels the resources . --> [[[FAILED]]]

[[[[Adv]]]]: public final void setSubscription ( Subscription s ) { if ( cancelled ) { s . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( s , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = s ; long [[r]] = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( [[r]] != 0L ) { s . request ( [[r]] ) ; } return ; } Subscription a = missedSubscription . getAndSet ( s ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void setSubscription ( Subscription s ) { if ( cancelled ) { s . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( s , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = s ; long [[d]] = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( [[d]] != 0L ) { s . request ( [[d]] ) ; } return ; } Subscription a = missedSubscription . getAndSet ( s ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 43 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 27 / 0 / 43:   4%|▍         | 43/1000 [04:17<1:35:27,  5.98s/it][Succeeded / Failed / Skipped / Total] 16 / 27 / 0 / 43:   4%|▍         | 44/1000 [04:17<1:33:17,  5.86s/it][Succeeded / Failed / Skipped / Total] 16 / 28 / 0 / 44:   4%|▍         | 44/1000 [04:17<1:33:17,  5.86s/it][Succeeded / Failed / Skipped / Total] 16 / 28 / 0 / 44:   4%|▍         | 45/1000 [04:23<1:33:12,  5.86s/it][Succeeded / Failed / Skipped / Total] 16 / 29 / 0 / 45:   4%|▍         | 45/1000 [04:23<1:33:12,  5.86s/it][Succeeded / Failed / Skipped / Total] 16 / 29 / 0 / 45:   5%|▍         | 46/1000 [04:29<1:33:12,  5.86s/it][Succeeded / Failed / Skipped / Total] 16 / 30 / 0 / 46:   5%|▍         | 46/1000 [04:29<1:33:12,  5.86s/it][Succeeded / Failed / Skipped / Total] 16 / 30 / 0 / 46:   5%|▍         | 47/1000 [04:33<1:32:25,  5.82s/it][Succeeded / Failed / Skipped / Total] 16 / 31 / 0 / 47:   5%|▍         | 47/1000 [04:33<1:32:25,  5.82s/it]