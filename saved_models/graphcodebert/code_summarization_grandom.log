Some weights of the model checkpoint at microsoft/graphcodebert-base were not used when initializing RobertaModel: ['lm_head.decoder.weight', 'lm_head.bias', 'lm_head.layer_norm.weight', 'lm_head.dense.weight', 'lm_head.dense.bias', 'lm_head.decoder.bias', 'lm_head.layer_norm.bias']
- This IS expected if you are initializing RobertaModel from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
- This IS NOT expected if you are initializing RobertaModel from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).
Some weights of RobertaModel were not initialized from the model checkpoint at microsoft/graphcodebert-base and are newly initialized: ['roberta.pooler.dense.weight', 'roberta.pooler.dense.bias']
You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
textattack: Running 7 worker(s) on 7 GPU(s).
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/1000 [00:00<00:01, 885.81it/s][Succeeded / Failed / Skipped / Total] 1 / 1 / 0 / 2:   0%|          | 2/1000 [00:00<00:00, 1159.45it/s][Succeeded / Failed / Skipped / Total] 2 / 1 / 0 / 3:   0%|          | 3/1000 [00:00<00:00, 1286.33it/s][Succeeded / Failed / Skipped / Total] 3 / 1 / 0 / 4:   0%|          | 4/1000 [00:00<00:00, 1410.56it/s][Succeeded / Failed / Skipped / Total] 4 / 1 / 0 / 5:   0%|          | 5/1000 [00:00<00:00, 1490.51it/s]--------------------------------------------- Result 1 ---------------------------------------------
Emit the given value to the downstream . --> helper method to encapsulate a formula --> Socre: 1.0

[[[[Adv]]]]: protected final void [[fastPathOrderedEmit]] ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > [[q]] = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( [[q]] . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { [[q]] . offer ( value ) ; } } else { [[q]] . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( [[q]] , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void [[casa]] ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > [[mantra]] = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( [[mantra]] . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { [[mantra]] . offer ( value ) ; } } else { [[mantra]] . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( [[mantra]] , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 2 ---------------------------------------------
Wraps an Observable . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > [[source]] ) { ObjectHelper . requireNonNull ( [[source]] , "source is null" ) ; if ( [[source]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[source]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[source]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[dullard]] ( ObservableSource < T > [[disavowed]] ) { ObjectHelper . requireNonNull ( [[disavowed]] , "source is null" ) ; if ( [[disavowed]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[disavowed]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[disavowed]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 3 ---------------------------------------------
Observes the observable using the given scheduler . --> Observable from unapprove --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > [[co]] , final Scheduler scheduler ) { final Observable < T > observable = [[co]] . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[co]] , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > [[unapproachable]] , final Scheduler scheduler ) { final Observable < T > observable = [[unapproachable]] . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[unapproachable]] , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 4 ---------------------------------------------
Creates a new instance of this class . --> Create a BrucyProcessor --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[bronc]] ) { return new UnicastProcessor < T > ( [[bronc]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 5 ---------------------------------------------
Returns an Observable with the given sort function . --> Expiration for hotdogs --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[exclamation]] ( Comparator < ? super T > [[hotdogs]] ) { ObjectHelper . requireNonNull ( [[hotdogs]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[hotdogs]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 6 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 5 / 1 / 0 / 6:   1%|          | 6/1000 [00:00<00:00, 1456.52it/s][Succeeded / Failed / Skipped / Total] 6 / 1 / 0 / 7:   1%|          | 7/1000 [00:00<00:00, 1505.72it/s][Succeeded / Failed / Skipped / Total] 7 / 1 / 0 / 8:   1%|          | 8/1000 [00:00<00:00, 1557.34it/s][Succeeded / Failed / Skipped / Total] 8 / 1 / 0 / 9:   1%|          | 9/1000 [00:00<00:00, 1597.97it/s]Try to apply a scalar XMap function to a single Publisher . --> Demonstrates how many scalar X maps --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > [[source]] , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( [[source]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > [[disintegrate]] , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( [[disintegrate]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[disintegrate]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 7 ---------------------------------------------
Creates a new instance of the given capacity . --> create dingle process --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int capacityHint , Runnable [[onCancelled]] ) { ObjectHelper . requireNonNull ( [[onCancelled]] , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , [[onCancelled]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[dingle]] ( int capacityHint , Runnable [[stirrup]] ) { ObjectHelper . requireNonNull ( [[stirrup]] , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , [[stirrup]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 8 ---------------------------------------------
Construct a Maybe from a CompletableSource . --> Thhav from Completable --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromCompletable]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[madhav]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 9 ---------------------------------------------
Auxiliary method for applying a scalar XMap function to each element of a scalar value . -->  stormtro operator --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T [[value]] , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[value]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[stormtrooper]] ( final T [[luisito]] , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[luisito]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 10 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 9 / 1 / 0 / 10:   1%|          | 10/1000 [00:00<00:00, 1614.00it/s][Succeeded / Failed / Skipped / Total] 10 / 1 / 0 / 11:   1%|          | 11/1000 [00:00<00:00, 1634.97it/s][Succeeded / Failed / Skipped / Total] 10 / 2 / 0 / 12:   1%|          | 12/1000 [00:00<00:00, 1666.45it/s][Succeeded / Failed / Skipped / Total] 11 / 2 / 0 / 13:   1%|▏         | 13/1000 [00:00<00:00, 1647.51it/s][Succeeded / Failed / Skipped / Total] 12 / 2 / 0 / 14:   1%|▏         | 14/1000 [00:00<00:00, 1665.07it/s][Succeeded / Failed / Skipped / Total] 13 / 2 / 0 / 15:   2%|▏         | 15/1000 [00:00<00:00, 1683.51it/s][Succeeded / Failed / Skipped / Total] 14 / 2 / 0 / 16:   2%|▏         | 16/1000 [00:00<00:00, 1701.24it/s][Succeeded / Failed / Skipped / Total] 15 / 2 / 0 / 17:   2%|▏         | 17/1000 [00:00<00:00, 1710.73it/s]Reset the handlers . --> This method should be called when the scheduler is shutting down --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "[[False]]" != "[[False]]" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[stirrup]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "[[Andie]]" != "[[Andie]]" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 11 ---------------------------------------------
Retrieves the future with the given number of times . --> Retrieves a retry --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long times , Predicate < ? super Throwable > [[predicate]] ) { return toFlowable ( ) . retry ( times , [[predicate]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long times , Predicate < ? super Throwable > [[cynthia]] ) { return toFlowable ( ) . retry ( times , [[cynthia]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 12 ---------------------------------------------
Ensures that the given object is not null . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] requireNonNull ( [[T]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < [[arik]] > [[arik]] requireNonNull ( [[arik]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 13 ---------------------------------------------
Create a Maybe from a single source . --> Stormtro operator --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > [[singleSource]] ) { ObjectHelper . requireNonNull ( [[singleSource]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[singleSource]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[kools]] ( SingleSource < T > [[stormtrooper]] ) { ObjectHelper . requireNonNull ( [[stormtrooper]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[stormtrooper]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 14 ---------------------------------------------
Returns the identity function . --> puro --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T > Function < T , T > [[identity]] ( ) { return ( Function < T , T > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T > Function < T , T > [[puro]] ( ) { return ( Function < T , T > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 15 ---------------------------------------------
Creates a new reusable subject . --> Create a new boatherd --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[goatherd]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 16 ---------------------------------------------
Static factory for callable . --> dina function --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > [[justCallable]] ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > [[dina]] ( T [[mchenry]] ) { return new JustValue < Object , T > ( [[mchenry]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 17 ---------------------------------------------
Convenience factory method . --> Factory method to construct a tabooSubject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[economize]] ( int [[amsterdam]] ) { return new UnicastSubject < T > ( [[amsterdam]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 18 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 2 / 0 / 18:   2%|▏         | 18/1000 [00:00<00:00, 1718.66it/s][Succeeded / Failed / Skipped / Total] 16 / 2 / 0 / 18:   2%|▏         | 19/1000 [00:01<01:23, 11.77it/s]  [Succeeded / Failed / Skipped / Total] 16 / 3 / 0 / 19:   2%|▏         | 19/1000 [00:01<01:23, 11.76it/s][Succeeded / Failed / Skipped / Total] 16 / 4 / 0 / 20:   2%|▏         | 20/1000 [00:01<01:19, 12.37it/s][Succeeded / Failed / Skipped / Total] 17 / 4 / 0 / 21:   2%|▏         | 21/1000 [00:01<01:15, 12.98it/s][Succeeded / Failed / Skipped / Total] 17 / 5 / 0 / 22:   2%|▏         | 22/1000 [00:01<01:11, 13.59it/s][Succeeded / Failed / Skipped / Total] 18 / 5 / 0 / 23:   2%|▏         | 23/1000 [00:01<01:24, 11.59it/s][Succeeded / Failed / Skipped / Total] 19 / 5 / 0 / 24:   2%|▏         | 24/1000 [00:01<01:20, 12.09it/s]Create a new reusable subject . --> newPuro --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[puro]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 19 ---------------------------------------------
Returns a function that casts to a class . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Function < T , U > [[castFunction]] ( Class < U > target ) { return new CastToClass < T , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < T , U > Function < T , U > [[schnauzer]] ( Class < U > target ) { return new CastToClass < T , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 20 ---------------------------------------------
Returns a function that returns only the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[justFunction]] ( U value ) { return new JustValue < [[T]] , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[aryans]] , U > Function < [[aryans]] , U > [[switcheroo]] ( U value ) { return new JustValue < [[aryans]] , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 21 ---------------------------------------------
Creates a reusable subject . --> Shared Subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[capacityHint]] , onTerminate , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[shhhh]] ( int [[amiss]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[amiss]] , onTerminate , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 22 ---------------------------------------------
This method blocks until the queue is exhausted . --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[blackmails]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 23 ---------------------------------------------
Loops through the queue until a max value is encountered . --> Depth - first loop --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > [[a]] , boolean delayError , Disposable dispose , QueueDrain < T , U > [[qd]] ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = [[qd]] . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , [[a]] , delayError , q , [[qd]] ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = [[qd]] . requested ( ) ; if ( r != 0L ) { if ( [[qd]] . accept ( [[a]] , v ) ) { if ( r != Long . MAX_VALUE ) { [[qd]] . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } [[a]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = [[qd]] . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > [[hypocrisies]] , boolean delayError , Disposable dispose , QueueDrain < T , U > [[miscarriage]] ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = [[miscarriage]] . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , [[hypocrisies]] , delayError , q , [[miscarriage]] ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = [[miscarriage]] . requested ( ) ; if ( r != 0L ) { if ( [[miscarriage]] . accept ( [[hypocrisies]] , v ) ) { if ( r != Long . MAX_VALUE ) { [[miscarriage]] . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } [[hypocrisies]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = [[miscarriage]] . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 24 ---------------------------------------------
Wait for the element to be read . --> Waits for a retry --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long [[timeout]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[timeout]] , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[briar]] ( long [[peralta]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[peralta]] , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[peralta]] , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 25 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 20 / 5 / 0 / 25:   2%|▎         | 25/1000 [00:01<01:17, 12.54it/s][Succeeded / Failed / Skipped / Total] 21 / 5 / 0 / 26:   3%|▎         | 26/1000 [00:06<04:08,  3.93it/s][Succeeded / Failed / Skipped / Total] 22 / 5 / 0 / 27:   3%|▎         | 27/1000 [00:10<06:16,  2.58it/s][Succeeded / Failed / Skipped / Total] 22 / 6 / 0 / 28:   3%|▎         | 28/1000 [00:32<18:53,  1.17s/it][Succeeded / Failed / Skipped / Total] 23 / 6 / 0 / 29:   3%|▎         | 29/1000 [00:36<20:14,  1.25s/it][Succeeded / Failed / Skipped / Total] 23 / 7 / 0 / 30:   3%|▎         | 30/1000 [00:48<25:53,  1.60s/it][Succeeded / Failed / Skipped / Total] 24 / 7 / 0 / 31:   3%|▎         | 31/1000 [00:52<27:05,  1.68s/it]Waits until the element is complete or not . --> Waits for archiv menivens --> Socre: 1.0

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long [[timeout]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[archivist]] ( long [[irishmen]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[irishmen]] , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 26 ---------------------------------------------
Requests prefetch . --> Bulk request --> Socre: 1.0

[[[[Adv]]]]: public static void [[request]] ( Subscription s , int [[prefetch]] ) { s . request ( [[prefetch]] < 0 ? Long . MAX_VALUE : [[prefetch]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void [[buggery]] ( Subscription s , int [[acetate]] ) { s . request ( [[acetate]] < 0 ? Long . MAX_VALUE : [[acetate]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 27 ---------------------------------------------
Post complete event . --> afterCompletion is completed --> Socre: 1.0

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier [[isCancelled]] ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , [[isCancelled]] ) ) { return ; } for ( ; ; ) { long [[r]] = state . get ( ) ; if ( ( [[r]] & COMPLETED_MASK ) != 0L ) { return ; } long [[u]] = [[r]] | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier [[bunks]] ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , [[bunks]] ) ) { return ; } for ( ; ; ) { long [[tyrannosaurus]] = state . get ( ) ; if ( ( [[tyrannosaurus]] & COMPLETED_MASK ) != 0L ) { return ; } long [[ailey]] = [[tyrannosaurus]] | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 28 ---------------------------------------------
Get the value associated with this notification . --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[exclamation]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 29 ---------------------------------------------
Returns the value . --> Methode permutations --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object [[o]] = value ; if ( [[o]] != null && ! NotificationLite . isError ( [[o]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[conspirators]] ( ) { Object [[morlocks]] = value ; if ( [[morlocks]] != null && ! NotificationLite . isError ( [[morlocks]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 30 ---------------------------------------------
Called when the stream is complete . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[complete]] ( R [[n]] ) { long [[p]] = produced ; if ( [[p]] != 0 ) { BackpressureHelper . produced ( this , [[p]] ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( [[n]] ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( [[n]] ) ; downstream . onComplete ( ) ; return ; } value = [[n]] ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[vancouver]] ( R [[tapping]] ) { long [[arrived]] = produced ; if ( [[arrived]] != 0 ) { BackpressureHelper . produced ( this , [[arrived]] ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( [[tapping]] ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( [[tapping]] ) ; downstream . onComplete ( ) ; return ; } value = [[tapping]] ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 31 ---------------------------------------------
Cap a long . --> Capulo overflow --> Socre: 1.0

[[[[Adv]]]]: public static long addCap ( long a , long [[b]] ) { long u = a + [[b]] ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long addCap ( long a , long [[pfft]] ) { long u = a + [[pfft]] ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 32 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 25 / 7 / 0 / 32:   3%|▎         | 32/1000 [00:54<27:40,  1.72s/it][Succeeded / Failed / Skipped / Total] 26 / 7 / 0 / 33:   3%|▎         | 33/1000 [00:55<27:00,  1.68s/it][Succeeded / Failed / Skipped / Total] 27 / 7 / 0 / 34:   3%|▎         | 34/1000 [01:21<38:24,  2.39s/it][Succeeded / Failed / Skipped / Total] 28 / 7 / 0 / 35:   4%|▎         | 35/1000 [01:32<42:35,  2.65s/it][Succeeded / Failed / Skipped / Total] 29 / 7 / 0 / 36:   4%|▎         | 36/1000 [01:39<44:34,  2.77s/it][Succeeded / Failed / Skipped / Total] 30 / 7 / 0 / 37:   4%|▎         | 37/1000 [01:43<45:06,  2.81s/it][Succeeded / Failed / Skipped / Total] 30 / 7 / 0 / 37:   4%|▍         | 38/1000 [02:03<52:15,  3.26s/it][Succeeded / Failed / Skipped / Total] 31 / 7 / 0 / 38:   4%|▍         | 38/1000 [02:03<52:15,  3.26s/it][Succeeded / Failed / Skipped / Total] 31 / 7 / 0 / 38:   4%|▍         | 39/1000 [02:04<51:07,  3.19s/it]Determines whether or not the stream is valid . --> Methode permettant deactivation --> Socre: 1.0

[[[[Adv]]]]: public static boolean validate ( Disposable [[upstream]] , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( [[upstream]] != null ) { [[next]] . dispose ( ) ; if ( [[upstream]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Disposable [[demolish]] , Disposable [[akin]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[akin]] , "next is null" ) ; if ( [[demolish]] != null ) { [[akin]] . dispose ( ) ; if ( [[demolish]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 33 ---------------------------------------------
Multiply a long value . --> used by tests --> Socre: 1.0

[[[[Adv]]]]: public static long [[multiplyCap]] ( long a , long b ) { long u = a * b ; if ( ( ( a | b ) >>> 31 ) != 0 ) { if ( u / a != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[valve]] ( long a , long b ) { long u = a * b ; if ( ( ( a | b ) >>> 31 ) != 0 ) { if ( u / a != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 34 ---------------------------------------------
Adds an object to the end . --> Baumannannann --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[baumann]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 35 ---------------------------------------------
Shuts down the pool . --> Shutdown dulcimer --> Socre: 1.0

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService [[exec]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[exec]] != null ) { [[exec]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[dulcimer]] ( ) { ScheduledExecutorService [[organise]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[organise]] != null ) { [[organise]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 36 ---------------------------------------------
Atomically sets the next AtomicReference to the given AtomicReference . --> Gets gawking --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[setOnce]] ( AtomicReference < Disposable > [[upstream]] , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( [[upstream]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean [[gawking]] ( AtomicReference < Disposable > [[anointed]] , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[anointed]] . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( [[anointed]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 37 ---------------------------------------------
Validates an upstream subscription . --> validateSubscription --> Socre: 1.0

[[[[Adv]]]]: public static boolean validate ( Subscription [[upstream]] , Subscription next , Class < ? > [[subscriber]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[upstream]] != null ) { next . cancel ( ) ; if ( [[upstream]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[subscriber]] ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Subscription [[pasteur]] , Subscription next , Class < ? > [[literacy]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[pasteur]] != null ) { next . cancel ( ) ; if ( [[pasteur]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[literacy]] ) ; } return "False" != "False" ; } return "[[Archdeacon]]" == "[[Archdeacon]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 38 ---------------------------------------------
Loops through all the elements . --> must be called once --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[galactic]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 39 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 32 / 7 / 0 / 39:   4%|▍         | 39/1000 [02:04<51:07,  3.19s/it][Succeeded / Failed / Skipped / Total] 32 / 7 / 0 / 39:   4%|▍         | 40/1000 [02:14<53:54,  3.37s/it][Succeeded / Failed / Skipped / Total] 33 / 7 / 0 / 40:   4%|▍         | 40/1000 [02:14<53:54,  3.37s/it][Succeeded / Failed / Skipped / Total] 33 / 7 / 0 / 40:   4%|▍         | 41/1000 [02:31<58:58,  3.69s/it][Succeeded / Failed / Skipped / Total] 33 / 8 / 0 / 41:   4%|▍         | 41/1000 [02:31<58:58,  3.69s/it][Succeeded / Failed / Skipped / Total] 33 / 8 / 0 / 41:   4%|▍         | 42/1000 [02:34<58:51,  3.69s/it][Succeeded / Failed / Skipped / Total] 34 / 8 / 0 / 42:   4%|▍         | 42/1000 [02:34<58:52,  3.69s/it][Succeeded / Failed / Skipped / Total] 34 / 8 / 0 / 42:   4%|▍         | 43/1000 [02:39<59:14,  3.71s/it][Succeeded / Failed / Skipped / Total] 35 / 8 / 0 / 43:   4%|▍         | 43/1000 [02:39<59:14,  3.71s/it][Succeeded / Failed / Skipped / Total] 35 / 8 / 0 / 43:   4%|▍         | 44/1000 [02:44<59:33,  3.74s/it][Succeeded / Failed / Skipped / Total] 35 / 9 / 0 / 44:   4%|▍         | 44/1000 [02:44<59:33,  3.74s/it][Succeeded / Failed / Skipped / Total] 35 / 9 / 0 / 44:   4%|▍         | 45/1000 [02:44<58:17,  3.66s/it][Succeeded / Failed / Skipped / Total] 36 / 9 / 0 / 45:   4%|▍         | 45/1000 [02:44<58:17,  3.66s/it][Succeeded / Failed / Skipped / Total] 36 / 9 / 0 / 45:   5%|▍         | 46/1000 [02:52<59:38,  3.75s/it]Sets the Subscription . --> This method is intended to be called once per minute --> Socre: 1.0

[[[[Adv]]]]: public final void setSubscription ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[s]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[s]] . request ( r ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[s]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void setSubscription ( Subscription [[diluted]] ) { if ( cancelled ) { [[diluted]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[diluted]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[diluted]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[diluted]] . request ( r ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[diluted]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 40 ---------------------------------------------
Converts a Throwable to a NullPointerException . --> This method is used to construct an exception from an exception --> Socre: 1.0

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable [[ex]] ) { NullPointerException [[npe]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[npe]] . initCause ( [[ex]] ) ; return [[npe]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[barbu]] ( Throwable [[fel]] ) { NullPointerException [[anesthesiology]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[anesthesiology]] . initCause ( [[fel]] ) ; return [[anesthesiology]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 41 ---------------------------------------------
Atomically add n to the requested long . --> [[[FAILED]]]

[[[[Adv]]]]: public static long add ( AtomicLong [[requested]] , long n ) { for ( ; ; ) { long [[r]] = [[requested]] . get ( ) ; if ( [[r]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( [[r]] , n ) ; if ( [[requested]] . compareAndSet ( [[r]] , u ) ) { return [[r]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long add ( AtomicLong [[disposition]] , long n ) { for ( ; ; ) { long [[mero]] = [[disposition]] . get ( ) ; if ( [[mero]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( [[mero]] , n ) ; if ( [[disposition]] . compareAndSet ( [[mero]] , u ) ) { return [[mero]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 42 ---------------------------------------------
Removes all resources from the cache . --> Dulcimer timer --> Socre: 1.0

[[[[Adv]]]]: public void [[clear]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > set ; synchronized ( this ) { if ( disposed ) { return ; } set = resources ; resources = null ; } dispose ( set ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void [[dulcimer]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > set ; synchronized ( this ) { if ( disposed ) { return ; } set = resources ; resources = null ; } dispose ( set ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 43 ---------------------------------------------
Creates a single scheduled thread pool . --> Enable or disable ThreadFactory --> Socre: 1.0

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory [[factory]] ) { final ScheduledExecutorService [[exec]] = Executors . newScheduledThreadPool ( 1 , [[factory]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[exec]] ) ; return [[exec]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[bartering]] ( ThreadFactory [[animals]] ) { final ScheduledExecutorService [[chernobyl]] = Executors . newScheduledThreadPool ( 1 , [[animals]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[chernobyl]] ) ; return [[chernobyl]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 44 ---------------------------------------------
Wraps the given throwable if it is a RuntimeException . --> [[[FAILED]]]

[[[[Adv]]]]: public static RuntimeException [[wrapOrThrow]] ( Throwable [[error]] ) { if ( [[error]] instanceof Error ) { throw ( Error ) [[error]] ; } if ( [[error]] instanceof RuntimeException ) { return ( RuntimeException ) [[error]] ; } return new RuntimeException ( [[error]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException [[flavio]] ( Throwable [[catheter]] ) { if ( [[catheter]] instanceof Error ) { throw ( Error ) [[catheter]] ; } if ( [[catheter]] instanceof RuntimeException ) { return ( RuntimeException ) [[catheter]] ; } return new RuntimeException ( [[catheter]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 45 ---------------------------------------------
Atomically sets the AtomicReference to the given AtomicReference . --> Brampton Jetstream observer --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[setOnce]] ( AtomicReference < Subscription > [[upstream]] , Subscription next , Class < ? > [[subscriber]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( [[upstream]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[subscriber]] ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean [[brampton]] ( AtomicReference < Subscription > [[false]] , Subscription next , Class < ? > [[astrophysicist]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[false]] . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( [[false]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[astrophysicist]] ) ; } return "False" != "False" ; } return "[[Sherman]]" == "[[Sherman]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 46 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 36 / 10 / 0 / 46:   5%|▍         | 46/1000 [02:52<59:38,  3.75s/it][Succeeded / Failed / Skipped / Total] 36 / 10 / 0 / 46:   5%|▍         | 47/1000 [03:09<1:04:09,  4.04s/it][Succeeded / Failed / Skipped / Total] 37 / 10 / 0 / 47:   5%|▍         | 47/1000 [03:09<1:04:09,  4.04s/it][Succeeded / Failed / Skipped / Total] 37 / 10 / 0 / 47:   5%|▍         | 48/1000 [03:11<1:03:18,  3.99s/it][Succeeded / Failed / Skipped / Total] 38 / 10 / 0 / 48:   5%|▍         | 48/1000 [03:11<1:03:18,  3.99s/it][Succeeded / Failed / Skipped / Total] 38 / 10 / 0 / 48:   5%|▍         | 49/1000 [03:12<1:02:20,  3.93s/it][Succeeded / Failed / Skipped / Total] 38 / 11 / 0 / 49:   5%|▍         | 49/1000 [03:12<1:02:21,  3.93s/it][Succeeded / Failed / Skipped / Total] 38 / 11 / 0 / 49:   5%|▌         | 50/1000 [03:12<1:01:05,  3.86s/it][Succeeded / Failed / Skipped / Total] 39 / 11 / 0 / 50:   5%|▌         | 50/1000 [03:12<1:01:05,  3.86s/it][Succeeded / Failed / Skipped / Total] 39 / 11 / 0 / 50:   5%|▌         | 51/1000 [03:28<1:04:38,  4.09s/it][Succeeded / Failed / Skipped / Total] 40 / 11 / 0 / 51:   5%|▌         | 51/1000 [03:28<1:04:38,  4.09s/it][Succeeded / Failed / Skipped / Total] 40 / 11 / 0 / 51:   5%|▌         | 52/1000 [03:31<1:04:19,  4.07s/it][Succeeded / Failed / Skipped / Total] 41 / 11 / 0 / 52:   5%|▌         | 52/1000 [03:31<1:04:19,  4.07s/it][Succeeded / Failed / Skipped / Total] 41 / 11 / 0 / 52:   5%|▌         | 53/1000 [03:32<1:03:20,  4.01s/it]Throws an exception if the given exception is not a throwable . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[E]] [[extends]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[E]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[E]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[cyclist]] [[vern]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[cyclist]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[cyclist]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 47 ---------------------------------------------
Flatten a Throwable into a list --> to get all exceptions --> Socre: 1.0

[[[[Adv]]]]: public static List < Throwable > [[flatten]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > [[deque]] = new ArrayDeque < Throwable > ( ) ; [[deque]] . offer ( t ) ; while ( ! [[deque]] . isEmpty ( ) ) { Throwable e = [[deque]] . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException [[ce]] = ( CompositeException ) e ; List < Throwable > exceptions = [[ce]] . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { [[deque]] . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > [[puro]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > [[cinched]] = new ArrayDeque < Throwable > ( ) ; [[cinched]] . offer ( t ) ; while ( ! [[cinched]] . isEmpty ( ) ) { Throwable e = [[cinched]] . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException [[obsolete]] = ( CompositeException ) e ; List < Throwable > exceptions = [[obsolete]] . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { [[cinched]] . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 48 ---------------------------------------------
Accepts the given observer . --> Accept all notifications --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[a]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] [[chantel]] = head ; final int c = capacity ; while ( [[chantel]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[chantel]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } [[chantel]] = ( Object [ ] ) [[chantel]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 49 ---------------------------------------------
Returns the number of resources . --> [[[FAILED]]]

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[set]] = resources ; return [[set]] != null ? [[set]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[gush]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[kopecks]] = resources ; return [[kopecks]] != null ? [[kopecks]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 50 ---------------------------------------------
Start the stream . --> Distanced implementation --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[distanced]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 51 ---------------------------------------------
Accepts a notification . --> Checks to see if there is a jaffa with full subscription --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean [[accept]] ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object [[o]] = a [ i ] ; if ( [[o]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[o]] , subscriber ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean [[jaffa]] ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object [[ayutthaya]] = a [ i ] ; if ( [[ayutthaya]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[ayutthaya]] , subscriber ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 52 ---------------------------------------------
Start unbounded queue . --> must be called --> Socre: 1.0

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[doggett]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 53 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 42 / 11 / 0 / 53:   5%|▌         | 53/1000 [03:32<1:03:20,  4.01s/it][Succeeded / Failed / Skipped / Total] 42 / 11 / 0 / 53:   5%|▌         | 54/1000 [03:35<1:03:02,  4.00s/it][Succeeded / Failed / Skipped / Total] 43 / 11 / 0 / 54:   5%|▌         | 54/1000 [03:35<1:03:02,  4.00s/it][Succeeded / Failed / Skipped / Total] 43 / 11 / 0 / 54:   6%|▌         | 55/1000 [03:52<1:06:32,  4.23s/it][Succeeded / Failed / Skipped / Total] 44 / 11 / 0 / 55:   6%|▌         | 55/1000 [03:52<1:06:32,  4.23s/it][Succeeded / Failed / Skipped / Total] 44 / 11 / 0 / 55:   6%|▌         | 56/1000 [03:53<1:05:43,  4.18s/it][Succeeded / Failed / Skipped / Total] 45 / 11 / 0 / 56:   6%|▌         | 56/1000 [03:53<1:05:43,  4.18s/it][Succeeded / Failed / Skipped / Total] 45 / 11 / 0 / 56:   6%|▌         | 57/1000 [03:56<1:05:19,  4.16s/it][Succeeded / Failed / Skipped / Total] 46 / 11 / 0 / 57:   6%|▌         | 57/1000 [03:56<1:05:19,  4.16s/it][Succeeded / Failed / Skipped / Total] 46 / 11 / 0 / 57:   6%|▌         | 58/1000 [04:01<1:05:22,  4.16s/it][Succeeded / Failed / Skipped / Total] 47 / 11 / 0 / 58:   6%|▌         | 58/1000 [04:01<1:05:22,  4.16s/it][Succeeded / Failed / Skipped / Total] 47 / 11 / 0 / 58:   6%|▌         | 59/1000 [04:17<1:08:26,  4.36s/it][Succeeded / Failed / Skipped / Total] 48 / 11 / 0 / 59:   6%|▌         | 59/1000 [04:17<1:08:26,  4.36s/it][Succeeded / Failed / Skipped / Total] 48 / 11 / 0 / 59:   6%|▌         | 60/1000 [04:30<1:10:43,  4.51s/it][Succeeded / Failed / Skipped / Total] 49 / 11 / 0 / 60:   6%|▌         | 60/1000 [04:30<1:10:44,  4.51s/it][Succeeded / Failed / Skipped / Total] 49 / 11 / 0 / 60:   6%|▌         | 61/1000 [04:32<1:09:49,  4.46s/it]Offers an object to the sink . --> Offers a single leg --> Socre: 1.0

[[[[Adv]]]]: public boolean offer ( T [[t]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[t]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[t]] ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean offer ( T [[congratulation]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[congratulation]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[congratulation]] ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 54 ---------------------------------------------
Creates an observable that maps a scalar value using the given mapper . --> Jennie operator --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Observable < U > [[scalarXMap]] ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( value , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > [[jennie]] ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > [[eugh]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( value , [[eugh]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 55 ---------------------------------------------
Gets the underlying resource . --> Slicced method --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable [[d]] = resource . get ( ) ; if ( [[d]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[d]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[sicced]] ( ) { Disposable [[fulvia]] = resource . get ( ) ; if ( [[fulvia]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[fulvia]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 56 ---------------------------------------------
Completes completion . --> from interface Stream --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[arik]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 57 ---------------------------------------------
Completes the given value with the given value . --> Completes stream --> Socre: 1.0

[[[[Adv]]]]: public final void complete ( T [[value]] ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( [[state]] == FUSED_EMPTY ) { this . value = [[value]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[value]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void complete ( T [[cobblers]] ) { int [[cholla]] = get ( ) ; if ( ( [[cholla]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( [[cholla]] == FUSED_EMPTY ) { this . value = [[cobblers]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[cobblers]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 58 ---------------------------------------------
Concatenates a MonoStream with a delay between 0 and 1 . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[concatMapDelayError]] ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return [[concatMapDelayError]] ( mapper , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[stifles]] ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return [[stifles]] ( mapper , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 59 ---------------------------------------------
Requests n to the upstream . --> Perform n n n --> Socre: 1.0

[[[[Adv]]]]: protected final void [[request]] ( long n ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void [[forecasting]] ( long n ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 60 ---------------------------------------------
Atomically adds the given Dispatcher to the end of the queue . --> This is for testing --> Socre: 1.0

[[[[Adv]]]]: boolean [[add]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean [[sì]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 61 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 50 / 11 / 0 / 61:   6%|▌         | 61/1000 [04:32<1:09:49,  4.46s/it][Succeeded / Failed / Skipped / Total] 50 / 11 / 0 / 61:   6%|▌         | 62/1000 [04:35<1:09:29,  4.44s/it][Succeeded / Failed / Skipped / Total] 51 / 11 / 0 / 62:   6%|▌         | 62/1000 [04:35<1:09:29,  4.44s/it][Succeeded / Failed / Skipped / Total] 51 / 11 / 0 / 62:   6%|▋         | 63/1000 [04:36<1:08:33,  4.39s/it][Succeeded / Failed / Skipped / Total] 52 / 11 / 0 / 63:   6%|▋         | 63/1000 [04:36<1:08:33,  4.39s/it][Succeeded / Failed / Skipped / Total] 52 / 11 / 0 / 63:   6%|▋         | 64/1000 [04:41<1:08:42,  4.40s/it][Succeeded / Failed / Skipped / Total] 53 / 11 / 0 / 64:   6%|▋         | 64/1000 [04:41<1:08:42,  4.40s/it][Succeeded / Failed / Skipped / Total] 53 / 11 / 0 / 64:   6%|▋         | 65/1000 [04:55<1:10:44,  4.54s/it][Succeeded / Failed / Skipped / Total] 54 / 11 / 0 / 65:   6%|▋         | 65/1000 [04:55<1:10:44,  4.54s/it][Succeeded / Failed / Skipped / Total] 54 / 11 / 0 / 65:   7%|▋         | 66/1000 [05:00<1:10:51,  4.55s/it][Succeeded / Failed / Skipped / Total] 55 / 11 / 0 / 66:   7%|▋         | 66/1000 [05:00<1:10:51,  4.55s/it][Succeeded / Failed / Skipped / Total] 55 / 11 / 0 / 66:   7%|▋         | 67/1000 [05:01<1:10:03,  4.51s/it][Succeeded / Failed / Skipped / Total] 56 / 11 / 0 / 67:   7%|▋         | 67/1000 [05:01<1:10:03,  4.51s/it][Succeeded / Failed / Skipped / Total] 56 / 11 / 0 / 67:   7%|▋         | 68/1000 [05:15<1:11:58,  4.63s/it]Sends an error . --> Simplified method for testing --> Socre: 1.0

[[[[Adv]]]]: public final void [[error]] ( Throwable [[t]] ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[t]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[t]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[hypothetical]] ( Throwable [[hamper]] ) { int [[drastic]] = get ( ) ; if ( ( [[drastic]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[hamper]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[hamper]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 62 ---------------------------------------------
Wait for the consumer . --> Try to burn a burn --> Socre: 1.0

[[[[Adv]]]]: public PerfAsyncConsumer [[await]] ( int [[count]] ) { if ( [[count]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[await]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer [[burner]] ( int [[backdrop]] ) { if ( [[backdrop]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[burner]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 63 ---------------------------------------------
Concatenates all elements in the stream using the given mapper . --> Dulcimer --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return [[concatMapIterable]] ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[dulcimer]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[brandy]] ) { return [[dulcimer]] ( [[brandy]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 64 ---------------------------------------------
Returns a sorted stream of elements according to the given comparator . --> Nck algorithm --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[nck]] ( Comparator < ? super T > [[chaps]] ) { ObjectHelper . requireNonNull ( [[chaps]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[chaps]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 65 ---------------------------------------------
Observes a flowable flowable with a given scheduler . --> elcastable flowable --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[observeOn]] ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > flowable = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[eliott]] ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > flowable = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 66 ---------------------------------------------
Parses the annotations of a method . --> Resumulated methods --> Socre: 1.0

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > [[parseAnnotations]] ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > [[resumé]] ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 67 ---------------------------------------------
Sets the next delay in milliseconds . --> Sets dulcimer in milliseconds --> Socre: 1.0

[[[[Adv]]]]: public void setDelay ( long amount , TimeUnit unit ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[delayMs]] = unit . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void setDelay ( long amount , TimeUnit unit ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[dulcimer]] = unit . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 68 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 57 / 11 / 0 / 68:   7%|▋         | 68/1000 [05:15<1:11:58,  4.63s/it][Succeeded / Failed / Skipped / Total] 57 / 11 / 0 / 68:   7%|▋         | 69/1000 [05:16<1:11:14,  4.59s/it][Succeeded / Failed / Skipped / Total] 58 / 11 / 0 / 69:   7%|▋         | 69/1000 [05:16<1:11:14,  4.59s/it][Succeeded / Failed / Skipped / Total] 58 / 11 / 0 / 69:   7%|▋         | 70/1000 [05:18<1:10:37,  4.56s/it][Succeeded / Failed / Skipped / Total] 59 / 11 / 0 / 70:   7%|▋         | 70/1000 [05:18<1:10:37,  4.56s/it][Succeeded / Failed / Skipped / Total] 59 / 11 / 0 / 70:   7%|▋         | 71/1000 [05:22<1:10:22,  4.54s/it][Succeeded / Failed / Skipped / Total] 60 / 11 / 0 / 71:   7%|▋         | 71/1000 [05:22<1:10:22,  4.54s/it][Succeeded / Failed / Skipped / Total] 60 / 11 / 0 / 71:   7%|▋         | 72/1000 [05:25<1:09:51,  4.52s/it][Succeeded / Failed / Skipped / Total] 61 / 11 / 0 / 72:   7%|▋         | 72/1000 [05:25<1:09:51,  4.52s/it][Succeeded / Failed / Skipped / Total] 61 / 11 / 0 / 72:   7%|▋         | 73/1000 [05:39<1:11:57,  4.66s/it]Tries to apply scalar X map transformation . --> Baggery from an observable --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( ObservableSource < T > [[source]] , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( [[source]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R [[u]] ; try { [[u]] = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( [[u]] == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , [[u]] ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[buggery]] ( ObservableSource < T > [[gross]] , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( [[gross]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[gross]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R [[wingman]] ; try { [[wingman]] = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( [[wingman]] == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , [[wingman]] ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 69 ---------------------------------------------
Creates sample data . --> Performs kruse --> Socre: 1.0

[[[[Adv]]]]: private void [[createSampleData]] ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void [[kruse]] ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 70 ---------------------------------------------
Create an error response . --> Jeregisters ack --> Socre: 1.0

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > [[call]] ; try { [[call]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[call]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[call]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[call]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[jeremiah]] ( ) { Response < ? > [[frank]] ; try { [[frank]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[frank]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[frank]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[frank]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 71 ---------------------------------------------
Calculates the delay in milliseconds --> Implements threshold --> Socre: 1.0

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit unit ) { float [[delta]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[receptor]] ( TimeUnit unit ) { float [[alisha]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 72 ---------------------------------------------
Search for a user . --> Performs a search . --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations [[searchForUser]] ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations [[kiloton]] ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 73 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 62 / 11 / 0 / 73:   7%|▋         | 73/1000 [05:39<1:11:57,  4.66s/it][Succeeded / Failed / Skipped / Total] 62 / 11 / 0 / 73:   7%|▋         | 74/1000 [05:42<1:11:27,  4.63s/it][Succeeded / Failed / Skipped / Total] 63 / 11 / 0 / 74:   7%|▋         | 74/1000 [05:42<1:11:27,  4.63s/it][Succeeded / Failed / Skipped / Total] 63 / 11 / 0 / 74:   8%|▊         | 75/1000 [05:42<1:10:28,  4.57s/it][Succeeded / Failed / Skipped / Total] 64 / 11 / 0 / 75:   8%|▊         | 75/1000 [05:42<1:10:28,  4.57s/it][Succeeded / Failed / Skipped / Total] 64 / 11 / 0 / 75:   8%|▊         | 76/1000 [06:01<1:13:11,  4.75s/it][Succeeded / Failed / Skipped / Total] 65 / 11 / 0 / 76:   8%|▊         | 76/1000 [06:01<1:13:11,  4.75s/it][Succeeded / Failed / Skipped / Total] 65 / 11 / 0 / 76:   8%|▊         | 77/1000 [06:02<1:12:23,  4.71s/it][Succeeded / Failed / Skipped / Total] 66 / 11 / 0 / 77:   8%|▊         | 77/1000 [06:02<1:12:23,  4.71s/it][Succeeded / Failed / Skipped / Total] 66 / 11 / 0 / 77:   8%|▊         | 78/1000 [06:04<1:11:44,  4.67s/it][Succeeded / Failed / Skipped / Total] 67 / 11 / 0 / 78:   8%|▊         | 78/1000 [06:04<1:11:44,  4.67s/it][Succeeded / Failed / Skipped / Total] 67 / 11 / 0 / 78:   8%|▊         | 79/1000 [06:36<1:17:01,  5.02s/it][Succeeded / Failed / Skipped / Total] 67 / 12 / 0 / 79:   8%|▊         | 79/1000 [06:36<1:17:01,  5.02s/it][Succeeded / Failed / Skipped / Total] 67 / 12 / 0 / 79:   8%|▊         | 80/1000 [06:40<1:16:40,  5.00s/it][Succeeded / Failed / Skipped / Total] 68 / 12 / 0 / 80:   8%|▊         | 80/1000 [06:40<1:16:40,  5.00s/it][Succeeded / Failed / Skipped / Total] 68 / 12 / 0 / 80:   8%|▊         | 81/1000 [06:40<1:15:40,  4.94s/it]Returns the HttpMethod object for the given string . --> Convert aniversary --> Socre: 1.0

[[[[Adv]]]]: private static HttpMethod [[valueOf]] ( String [[method]] ) { try { return HttpMethod . valueOf ( [[method]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod [[tanganyika]] ( String [[anniversary]] ) { try { return HttpMethod . valueOf ( [[anniversary]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 74 ---------------------------------------------
Convenience method to perform the version checks . --> If the minimumSpringVersion is null set it . --> Socre: 1.0

[[[[Adv]]]]: private static void [[performVersionChecks]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void [[acetate]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 75 ---------------------------------------------
Removes a subscriber from the queue . --> remove gables --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > [[ps]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int [[n]] = a . length ; int j = - 1 ; for ( int [[i]] = 0 ; [[i]] < [[n]] ; [[i]] ++ ) { if ( a [ [[i]] ] == [[ps]] ) { j = [[i]] ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( [[n]] == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ [[n]] - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , [[n]] - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > [[gables]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int [[disciplining]] = a . length ; int j = - 1 ; for ( int [[nck]] = 0 ; [[nck]] < [[disciplining]] ; [[nck]] ++ ) { if ( a [ [[nck]] ] == [[gables]] ) { j = [[nck]] ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( [[disciplining]] == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ [[disciplining]] - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , [[disciplining]] - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 76 ---------------------------------------------
Apply an attribute exchange configurer . --> Add a BridgeportConfigurer --> Socre: 1.0

[[[[Adv]]]]: public AttributeExchangeConfigurer [[attributeExchange]] ( String identifierPattern ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer [[bridgeport]] ( String identifierPattern ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 77 ---------------------------------------------
Get OAuth2 resource server . --> Configurer for authentication --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[sì]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 78 ---------------------------------------------
Get OAuth2 client configurer . --> Apply nanoseconds to nanosecond --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[oauth2Client]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[nanosecond]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 79 ---------------------------------------------
Hashes a raw password . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[encode]] ( CharSequence rawPassword ) { String salt = PREFIX + this . [[saltGenerator]] . generateKey ( ) + SUFFIX ; return digest ( salt , rawPassword ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String [[alphabets]] ( CharSequence rawPassword ) { String salt = PREFIX + this . [[aguilera]] . generateKey ( ) + SUFFIX ; return digest ( salt , rawPassword ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 80 ---------------------------------------------
Computes the encoded password matches the given raw password . --> Checks if shogun s matches shogun --> Socre: 1.0

[[[[Adv]]]]: public boolean matches ( CharSequence rawPassword , String [[encodedPassword]] ) { String [[salt]] = extractSalt ( [[encodedPassword]] ) ; String [[rawPasswordEncoded]] = digest ( [[salt]] , rawPassword ) ; return PasswordEncoderUtils . equals ( [[encodedPassword]] . toString ( ) , [[rawPasswordEncoded]] ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean matches ( CharSequence rawPassword , String [[shogun]] ) { String [[hart]] = extractSalt ( [[shogun]] ) ; String [[mountaineering]] = digest ( [[hart]] , rawPassword ) ; return PasswordEncoderUtils . equals ( [[shogun]] . toString ( ) , [[mountaineering]] ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 81 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 69 / 12 / 0 / 81:   8%|▊         | 81/1000 [06:40<1:15:40,  4.94s/it][Succeeded / Failed / Skipped / Total] 69 / 12 / 0 / 81:   8%|▊         | 82/1000 [06:44<1:15:23,  4.93s/it][Succeeded / Failed / Skipped / Total] 69 / 13 / 0 / 82:   8%|▊         | 82/1000 [06:44<1:15:23,  4.93s/it][Succeeded / Failed / Skipped / Total] 69 / 13 / 0 / 82:   8%|▊         | 83/1000 [06:52<1:16:00,  4.97s/it][Succeeded / Failed / Skipped / Total] 69 / 14 / 0 / 83:   8%|▊         | 83/1000 [06:52<1:16:00,  4.97s/it][Succeeded / Failed / Skipped / Total] 69 / 14 / 0 / 83:   8%|▊         | 84/1000 [07:10<1:18:19,  5.13s/it][Succeeded / Failed / Skipped / Total] 70 / 14 / 0 / 84:   8%|▊         | 84/1000 [07:10<1:18:19,  5.13s/it][Succeeded / Failed / Skipped / Total] 70 / 14 / 0 / 84:   8%|▊         | 85/1000 [07:28<1:20:26,  5.27s/it][Succeeded / Failed / Skipped / Total] 71 / 14 / 0 / 85:   8%|▊         | 85/1000 [07:28<1:20:26,  5.27s/it][Succeeded / Failed / Skipped / Total] 71 / 14 / 0 / 85:   9%|▊         | 86/1000 [07:42<1:21:55,  5.38s/it][Succeeded / Failed / Skipped / Total] 72 / 14 / 0 / 86:   9%|▊         | 86/1000 [07:42<1:21:55,  5.38s/it][Succeeded / Failed / Skipped / Total] 72 / 14 / 0 / 86:   9%|▊         | 87/1000 [08:05<1:24:56,  5.58s/it]Retrieves the Spring Security Core --> private method for testing --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties [[properties]] = new Properties ( ) ; try { [[properties]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[properties]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[sedat]] ( ) { Properties [[chests]] = new Properties ( ) ; try { [[chests]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[chests]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 82 ---------------------------------------------
Provide a default security configurer for the application . --> [[[FAILED]]]

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[requiresChannel]] ( ) throws Exception { ApplicationContext context = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( context ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[boardinghouse]] ( ) throws Exception { ApplicationContext context = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( context ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 83 ---------------------------------------------
Determines whether the checks should be disabled . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean disableChecks ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return "[[True]]" == "[[True]]" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean disableChecks ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return "[[Sojo]]" == "[[Sojo]]" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 84 ---------------------------------------------
Retrieves or retrieves an entry . --> For testing purpose --> Socre: 1.0

[[[[Adv]]]]: public DirContextOperations [[retrieveEntry]] ( final String [[dn]] , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes [[attrs]] = ctx . getAttributes ( [[dn]] , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations [[ankh]] ( final String [[fancying]] , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes [[bates]] = ctx . getAttributes ( [[fancying]] , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 85 ---------------------------------------------
Builds a search controls . --> Creates a new SearchControls instance --> Socre: 1.0

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls [[originalControls]] ) { return new SearchControls ( [[originalControls]] . getSearchScope ( ) , [[originalControls]] . getCountLimit ( ) , [[originalControls]] . getTimeLimit ( ) , [[originalControls]] . getReturningAttributes ( ) , RETURN_OBJECT , [[originalControls]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[convincing]] ( SearchControls [[guilty]] ) { return new SearchControls ( [[guilty]] . getSearchScope ( ) , [[guilty]] . getCountLimit ( ) , [[guilty]] . getTimeLimit ( ) , [[guilty]] . getReturningAttributes ( ) , RETURN_OBJECT , [[guilty]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 86 ---------------------------------------------
Gets the primary keys for acl . --> dalanced search --> Socre: 1.0

[[[[Adv]]]]: private void [[lookupPrimaryKeys]] ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > [[sids]] ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , [[sids]] ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void [[dalton]] ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > [[alds]] ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , [[alds]] ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 87 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 73 / 14 / 0 / 87:   9%|▊         | 87/1000 [08:05<1:24:56,  5.58s/it][Succeeded / Failed / Skipped / Total] 73 / 14 / 0 / 87:   9%|▉         | 88/1000 [08:06<1:24:06,  5.53s/it][Succeeded / Failed / Skipped / Total] 74 / 14 / 0 / 88:   9%|▉         | 88/1000 [08:06<1:24:06,  5.53s/it][Succeeded / Failed / Skipped / Total] 74 / 14 / 0 / 88:   9%|▉         | 89/1000 [08:19<1:25:14,  5.61s/it][Succeeded / Failed / Skipped / Total] 75 / 14 / 0 / 89:   9%|▉         | 89/1000 [08:19<1:25:14,  5.61s/it][Succeeded / Failed / Skipped / Total] 75 / 14 / 0 / 89:   9%|▉         | 90/1000 [08:21<1:24:34,  5.58s/it]Create the embedded server definition . --> Creates the embedded server definition --> Socre: 1.0

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object [[source]] = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder [[contextSource]] = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; [[contextSource]] . addConstructorArgValue ( url ) ; [[contextSource]] . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; [[contextSource]] . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( [[source]] ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) [[contextSource]] . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object [[applause]] = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder [[maricón]] = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; [[maricón]] . addConstructorArgValue ( url ) ; [[maricón]] . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; [[maricón]] . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( [[applause]] ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) [[maricón]] . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 88 ---------------------------------------------
Create the Servlet API filter . --> Add britney . --> Socre: 1.0

[[[[Adv]]]]: private void [[createServletApiFilter]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void [[britney]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 89 ---------------------------------------------
Build pre - authenticated authorities web authentication details . --> Maps J2EE roles to WebAuthenticationDetails --> Socre: 1.0

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[buildDetails]] ( HttpServletRequest context ) { Collection < String > [[j2eeUserRoles]] = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[j2eeUserRoles]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + [[j2eeUserRoles]] + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[oswaldo]] ( HttpServletRequest context ) { Collection < String > [[guys]] = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[guys]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + [[guys]] + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 90 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 76 / 14 / 0 / 90:   9%|▉         | 90/1000 [08:21<1:24:34,  5.58s/it][Succeeded / Failed / Skipped / Total] 76 / 14 / 0 / 90:   9%|▉         | 91/1000 [08:28<1:24:38,  5.59s/it][Succeeded / Failed / Skipped / Total] 77 / 14 / 0 / 91:   9%|▉         | 91/1000 [08:28<1:24:38,  5.59s/it][Succeeded / Failed / Skipped / Total] 77 / 14 / 0 / 91:   9%|▉         | 92/1000 [08:47<1:26:50,  5.74s/it][Succeeded / Failed / Skipped / Total] 78 / 14 / 0 / 92:   9%|▉         | 92/1000 [08:47<1:26:50,  5.74s/it][Succeeded / Failed / Skipped / Total] 78 / 14 / 0 / 92:   9%|▉         | 93/1000 [08:51<1:26:19,  5.71s/it][Succeeded / Failed / Skipped / Total] 79 / 14 / 0 / 93:   9%|▉         | 93/1000 [08:51<1:26:19,  5.71s/it][Succeeded / Failed / Skipped / Total] 79 / 14 / 0 / 93:   9%|▉         | 94/1000 [09:05<1:27:37,  5.80s/it][Succeeded / Failed / Skipped / Total] 80 / 14 / 0 / 94:   9%|▉         | 94/1000 [09:05<1:27:37,  5.80s/it][Succeeded / Failed / Skipped / Total] 80 / 14 / 0 / 94:  10%|▉         | 95/1000 [09:12<1:27:46,  5.82s/it][Succeeded / Failed / Skipped / Total] 81 / 14 / 0 / 95:  10%|▉         | 95/1000 [09:12<1:27:46,  5.82s/it][Succeeded / Failed / Skipped / Total] 81 / 14 / 0 / 95:  10%|▉         | 96/1000 [09:27<1:29:01,  5.91s/it][Succeeded / Failed / Skipped / Total] 82 / 14 / 0 / 96:  10%|▉         | 96/1000 [09:27<1:29:01,  5.91s/it][Succeeded / Failed / Skipped / Total] 82 / 14 / 0 / 96:  10%|▉         | 97/1000 [09:28<1:28:10,  5.86s/it]Searches for multiple attribute values . --> Redbudbud to redbude --> Socre: 1.0

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[searchForMultipleAttributeValues]] ( final String [[base]] , final String filter , final Object [ ] [[params]] , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[redbud]] ( final String [[alouette]] , final String filter , final Object [ ] [[tye]] , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 91 ---------------------------------------------
Creates a whitelisted type resolver . -->  whitelisted type resolver --> Socre: 1.0

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[createWhitelistedDefaultTyping]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[neglecting]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 92 ---------------------------------------------
Create the JAAS API filter . -->  phonetic information --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[phonetic]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 93 ---------------------------------------------
Returns a list of granted authorities . --> Extract authorities from eskimos --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[attributes]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[attributes]] . size ( ) ) ; for ( String attribute : [[attributes]] ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[eskimos]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[eskimos]] . size ( ) ) ; for ( String attribute : [[eskimos]] ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 94 ---------------------------------------------
Adds the spring security filter to the web application context . --> Create a new security filter chain --> Socre: 1.0

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String [[contextAttribute]] = getWebApplicationContextAttribute ( ) ; if ( [[contextAttribute]] != null ) { springSecurityFilterChain . setContextAttribute ( [[contextAttribute]] ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String [[diwali]] = getWebApplicationContextAttribute ( ) ; if ( [[diwali]] != null ) { springSecurityFilterChain . setContextAttribute ( [[diwali]] ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 95 ---------------------------------------------
Injects any required properties --> Initialize the headlines --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[headlines]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 96 ---------------------------------------------
Creates a new Cipher . --> Trade the given Gabay algorithm --> Socre: 1.0

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String [[algorithm]] ) { try { return Cipher . getInstance ( [[algorithm]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[tradeoff]] ( String [[gabay]] ) { try { return Cipher . getInstance ( [[gabay]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 97 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 83 / 14 / 0 / 97:  10%|▉         | 97/1000 [09:28<1:28:10,  5.86s/it][Succeeded / Failed / Skipped / Total] 83 / 14 / 0 / 97:  10%|▉         | 98/1000 [09:35<1:28:16,  5.87s/it][Succeeded / Failed / Skipped / Total] 83 / 15 / 0 / 98:  10%|▉         | 98/1000 [09:35<1:28:16,  5.87s/it][Succeeded / Failed / Skipped / Total] 83 / 15 / 0 / 98:  10%|▉         | 99/1000 [10:00<1:31:02,  6.06s/it][Succeeded / Failed / Skipped / Total] 83 / 16 / 0 / 99:  10%|▉         | 99/1000 [10:00<1:31:02,  6.06s/it][Succeeded / Failed / Skipped / Total] 83 / 16 / 0 / 99:  10%|█         | 100/1000 [10:02<1:30:21,  6.02s/it][Succeeded / Failed / Skipped / Total] 84 / 16 / 0 / 100:  10%|█         | 100/1000 [10:02<1:30:21,  6.02s/it][Succeeded / Failed / Skipped / Total] 84 / 16 / 0 / 100:  10%|█         | 101/1000 [10:45<1:35:44,  6.39s/it]Check security context if required . --> Check expo for expo --> Socre: 1.0

[[[[Adv]]]]: public void [[doFilter]] ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void [[expo]] ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 98 ---------------------------------------------
Checks if the given dn matches the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object value ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > [[results]] = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( [[results]] . hasMore ( ) ) ; LdapUtils . closeEnumeration ( [[results]] ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object value ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > [[halpern]] = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( [[halpern]] . hasMore ( ) ) ; LdapUtils . closeEnumeration ( [[halpern]] ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 99 ---------------------------------------------
Retrieves a remember - me token for a given series . --> [[[FAILED]]]

[[[[Adv]]]]: public PersistentRememberMeToken [[getTokenForSeries]] ( String [[seriesId]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int [[rowNum]] ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , [[seriesId]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[seriesId]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[seriesId]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[seriesId]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken [[mix]] ( String [[nigel]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int [[brandished]] ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , [[nigel]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[nigel]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[nigel]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[nigel]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 100 ---------------------------------------------
Searches for attribute values . --> Checks to see HOK --> Socre: 1.0

[[[[Adv]]]]: public Set < String > [[searchForSingleAttributeValues]] ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] [[attributeNames]] = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , [[attributeNames]] ) ; Set < String > [[result]] = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { [[result]] . addAll ( values ) ; } } return [[result]] ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > [[jok]] ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] [[windshields]] = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , [[windshields]] ) ; Set < String > [[hailey]] = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { [[hailey]] . addAll ( values ) ; } } return [[hailey]] ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 101 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 85 / 16 / 0 / 101:  10%|█         | 101/1000 [10:45<1:35:44,  6.39s/it][Succeeded / Failed / Skipped / Total] 85 / 16 / 0 / 101:  10%|█         | 102/1000 [10:46<1:34:50,  6.34s/it][Succeeded / Failed / Skipped / Total] 86 / 16 / 0 / 102:  10%|█         | 102/1000 [10:46<1:34:50,  6.34s/it][Succeeded / Failed / Skipped / Total] 86 / 16 / 0 / 102:  10%|█         | 103/1000 [11:01<1:35:59,  6.42s/it][Succeeded / Failed / Skipped / Total] 86 / 17 / 0 / 103:  10%|█         | 103/1000 [11:01<1:35:59,  6.42s/it][Succeeded / Failed / Skipped / Total] 86 / 17 / 0 / 103:  10%|█         | 104/1000 [11:17<1:37:18,  6.52s/it][Succeeded / Failed / Skipped / Total] 87 / 17 / 0 / 104:  10%|█         | 104/1000 [11:17<1:37:18,  6.52s/it][Succeeded / Failed / Skipped / Total] 87 / 17 / 0 / 104:  10%|█         | 105/1000 [11:23<1:37:07,  6.51s/it]Update the authentication defaults . --> Methode d gout --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[logoutConfigurer]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[logoutConfigurer]] != null && ! [[logoutConfigurer]] . isCustomLogoutSuccess ( ) ) { [[logoutConfigurer]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[на]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[absentia]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[absentia]] != null && ! [[absentia]] . isCustomLogoutSuccess ( ) ) { [[absentia]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 102 ---------------------------------------------
Sets the login processing url . --> Sets archipelago --> Socre: 1.0

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String loginProcessingUrl ) { this . [[loginProcessingUrl]] = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[archipelago]] ( String loginProcessingUrl ) { this . [[springer]] = [[archipelago]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[archipelago]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 103 ---------------------------------------------
Map the authorities to the default authorities . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < GrantedAuthority > [[mapAuthorities]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > [[mapped]] = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority [[authority]] : authorities ) { [[mapped]] . add ( mapAuthority ( [[authority]] . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[mapped]] . add ( defaultAuthority ) ; } return [[mapped]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > [[bestseller]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > [[maestro]] = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority [[assim]] : authorities ) { [[maestro]] . add ( mapAuthority ( [[assim]] . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[maestro]] . add ( defaultAuthority ) ; } return [[maestro]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 104 ---------------------------------------------
Search for a single entry . --> returns results --> Socre: 1.0

[[[[Adv]]]]: public static DirContextOperations [[searchForSingleEntryInternal]] ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName [[ctxBaseDn]] = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + [[ctxBaseDn]] + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations [[ashok]] ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName [[quilted]] = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + [[quilted]] + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 105 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 88 / 17 / 0 / 105:  10%|█         | 105/1000 [11:23<1:37:07,  6.51s/it][Succeeded / Failed / Skipped / Total] 88 / 17 / 0 / 105:  11%|█         | 106/1000 [11:27<1:36:35,  6.48s/it][Succeeded / Failed / Skipped / Total] 89 / 17 / 0 / 106:  11%|█         | 106/1000 [11:27<1:36:35,  6.48s/it][Succeeded / Failed / Skipped / Total] 89 / 17 / 0 / 106:  11%|█         | 107/1000 [11:28<1:35:48,  6.44s/it][Succeeded / Failed / Skipped / Total] 90 / 17 / 0 / 107:  11%|█         | 107/1000 [11:28<1:35:49,  6.44s/it][Succeeded / Failed / Skipped / Total] 90 / 17 / 0 / 107:  11%|█         | 108/1000 [11:32<1:35:18,  6.41s/it][Succeeded / Failed / Skipped / Total] 91 / 17 / 0 / 108:  11%|█         | 108/1000 [11:32<1:35:18,  6.41s/it][Succeeded / Failed / Skipped / Total] 91 / 17 / 0 / 108:  11%|█         | 109/1000 [11:35<1:34:46,  6.38s/it][Succeeded / Failed / Skipped / Total] 91 / 18 / 0 / 109:  11%|█         | 109/1000 [11:35<1:34:46,  6.38s/it][Succeeded / Failed / Skipped / Total] 91 / 18 / 0 / 109:  11%|█         | 110/1000 [11:39<1:34:23,  6.36s/it]Checks if the current authentication principal has been changed . --> Checks whether there is a race condition --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[principalChanged]] ( HttpServletRequest request , Authentication [[currentAuthentication]] ) { Object [[principal]] = getPreAuthenticatedPrincipal ( request ) ; if ( ( [[principal]] instanceof String ) && [[currentAuthentication]] . getName ( ) . equals ( [[principal]] ) ) { return "False" != "False" ; } if ( [[principal]] != null && [[principal]] . equals ( [[currentAuthentication]] . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + [[principal]] + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean [[coca]] ( HttpServletRequest request , Authentication [[subway]] ) { Object [[whoreson]] = getPreAuthenticatedPrincipal ( request ) ; if ( ( [[whoreson]] instanceof String ) && [[subway]] . getName ( ) . equals ( [[whoreson]] ) ) { return "False" != "False" ; } if ( [[whoreson]] != null && [[whoreson]] . equals ( [[subway]] . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + [[whoreson]] + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 106 ---------------------------------------------
Map the password to a String . --> hiroo error --> Socre: 1.0

[[[[Adv]]]]: protected String [[mapPassword]] ( Object [[passwordValue]] ) { if ( ! ( [[passwordValue]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[hiroko]] ( Object [[bru]] ) { if ( ! ( [[bru]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 107 ---------------------------------------------
Updates the default access values . --> This method is used to permit all vulnerabilities --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B [[http]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[http]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[detonates]] ( B [[acrophobia]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[acrophobia]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 108 ---------------------------------------------
Checks if the content length is fully written . --> Perform tana --> Socre: 1.0

[[[[Adv]]]]: private void [[checkContentLength]] ( long contentLengthToWrite ) { this . [[contentWritten]] += contentLengthToWrite ; boolean isBodyFullyWritten = this . [[contentLength]] > 0 && this . [[contentWritten]] >= this . [[contentLength]] ; int [[bufferSize]] = getBufferSize ( ) ; boolean requiresFlush = [[bufferSize]] > 0 && this . [[contentWritten]] >= [[bufferSize]] ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void [[tana]] ( long contentLengthToWrite ) { this . [[coach]] += contentLengthToWrite ; boolean isBodyFullyWritten = this . [[biggest]] > 0 && this . [[coach]] >= this . [[biggest]] ; int [[macbeth]] = getBufferSize ( ) ; boolean requiresFlush = [[macbeth]] > 0 && this . [[coach]] >= [[macbeth]] ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 109 ---------------------------------------------
Do the actual authentication . --> [[[FAILED]]]

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object [[principal]] = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( [[principal]] == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + [[principal]] + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( [[principal]] , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object [[bartleby]] = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( [[bartleby]] == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + [[bartleby]] + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( [[bartleby]] , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 110 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 92 / 18 / 0 / 110:  11%|█         | 110/1000 [11:39<1:34:23,  6.36s/it][Succeeded / Failed / Skipped / Total] 92 / 18 / 0 / 110:  11%|█         | 111/1000 [11:50<1:34:47,  6.40s/it][Succeeded / Failed / Skipped / Total] 93 / 18 / 0 / 111:  11%|█         | 111/1000 [11:50<1:34:47,  6.40s/it][Succeeded / Failed / Skipped / Total] 93 / 18 / 0 / 111:  11%|█         | 112/1000 [12:05<1:35:55,  6.48s/it][Succeeded / Failed / Skipped / Total] 94 / 18 / 0 / 112:  11%|█         | 112/1000 [12:05<1:35:55,  6.48s/it][Succeeded / Failed / Skipped / Total] 94 / 18 / 0 / 112:  11%|█▏        | 113/1000 [12:11<1:35:38,  6.47s/it][Succeeded / Failed / Skipped / Total] 95 / 18 / 0 / 113:  11%|█▏        | 113/1000 [12:11<1:35:38,  6.47s/it][Succeeded / Failed / Skipped / Total] 95 / 18 / 0 / 113:  11%|█▏        | 114/1000 [12:20<1:35:52,  6.49s/it][Succeeded / Failed / Skipped / Total] 95 / 19 / 0 / 114:  11%|█▏        | 114/1000 [12:20<1:35:52,  6.49s/it][Succeeded / Failed / Skipped / Total] 95 / 19 / 0 / 114:  12%|█▏        | 115/1000 [12:29<1:36:04,  6.51s/it]Encode cookie . --> helper to encode the cookie tokens --> Socre: 1.0

[[[[Adv]]]]: protected String [[encodeCookie]] ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String [[galilei]] ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 111 ---------------------------------------------
Resolves the security context for the given parameter . --> Resolves a security context --> Socre: 1.0

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > [[reactiveSecurityContext]] = ReactiveSecurityContextHolder . getContext ( ) ; if ( [[reactiveSecurityContext]] == null ) { return null ; } return [[reactiveSecurityContext]] . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > [[bluestones]] = ReactiveSecurityContextHolder . getContext ( ) ; if ( [[bluestones]] == null ) { return null ; } return [[bluestones]] . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 112 ---------------------------------------------
Sets the cookie . --> Overridden in HttpServletRequest --> Socre: 1.0

[[[[Adv]]]]: protected void [[setCookie]] ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String [[cookieValue]] = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , [[cookieValue]] ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void [[bedridden]] ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String [[dang]] = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , [[dang]] ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 113 ---------------------------------------------
Performs the authentication . --> Authenticate an abandoning token --> Socre: 1.0

[[[[Adv]]]]: public Authentication authenticate ( Authentication [[auth]] ) throws AuthenticationException { if ( ! ( [[auth]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) [[auth]] ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication authenticate ( Authentication [[abandoning]] ) throws AuthenticationException { if ( ! ( [[abandoning]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) [[abandoning]] ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 114 ---------------------------------------------
Extract cookie from request . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[extractRememberMeCookie]] ( HttpServletRequest request ) { Cookie [ ] [[cookies]] = request . getCookies ( ) ; if ( ( [[cookies]] == null ) || ( [[cookies]] . length == 0 ) ) { return null ; } for ( Cookie cookie : [[cookies]] ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String [[ginseng]] ( HttpServletRequest request ) { Cookie [ ] [[agitate]] = request . getCookies ( ) ; if ( ( [[agitate]] == null ) || ( [[agitate]] . length == 0 ) ) { return null ; } for ( Cookie cookie : [[agitate]] ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 115 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 96 / 19 / 0 / 115:  12%|█▏        | 115/1000 [12:29<1:36:04,  6.51s/it][Succeeded / Failed / Skipped / Total] 96 / 19 / 0 / 115:  12%|█▏        | 116/1000 [12:37<1:36:11,  6.53s/it][Succeeded / Failed / Skipped / Total] 97 / 19 / 0 / 116:  12%|█▏        | 116/1000 [12:37<1:36:11,  6.53s/it][Succeeded / Failed / Skipped / Total] 97 / 19 / 0 / 116:  12%|█▏        | 117/1000 [12:38<1:35:22,  6.48s/it][Succeeded / Failed / Skipped / Total] 97 / 20 / 0 / 117:  12%|█▏        | 117/1000 [12:38<1:35:22,  6.48s/it][Succeeded / Failed / Skipped / Total] 97 / 20 / 0 / 117:  12%|█▏        | 118/1000 [12:41<1:34:49,  6.45s/it][Succeeded / Failed / Skipped / Total] 98 / 20 / 0 / 118:  12%|█▏        | 118/1000 [12:41<1:34:49,  6.45s/it][Succeeded / Failed / Skipped / Total] 98 / 20 / 0 / 118:  12%|█▏        | 119/1000 [12:43<1:34:09,  6.41s/it][Succeeded / Failed / Skipped / Total] 98 / 21 / 0 / 119:  12%|█▏        | 119/1000 [12:43<1:34:09,  6.41s/it][Succeeded / Failed / Skipped / Total] 98 / 21 / 0 / 119:  12%|█▏        | 120/1000 [12:49<1:34:06,  6.42s/it][Succeeded / Failed / Skipped / Total] 99 / 21 / 0 / 120:  12%|█▏        | 120/1000 [12:49<1:34:06,  6.42s/it][Succeeded / Failed / Skipped / Total] 99 / 21 / 0 / 120:  12%|█▏        | 121/1000 [12:56<1:33:59,  6.42s/it][Succeeded / Failed / Skipped / Total] 100 / 21 / 0 / 121:  12%|█▏        | 121/1000 [12:56<1:33:59,  6.42s/it][Succeeded / Failed / Skipped / Total] 100 / 21 / 0 / 121:  12%|█▏        | 122/1000 [13:10<1:34:45,  6.48s/it]Get the query string from the request . --> Tries to find a bartle by pattern --> Socre: 1.0

[[[[Adv]]]]: private String [[getQueryString]] ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String [[result]] = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( [[result]] . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String [[bartleby]] ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String [[bridgette]] = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( [[bridgette]] . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 116 ---------------------------------------------
Logout request . --> Log out client --> Socre: 1.0

[[[[Adv]]]]: public void logout ( HttpServletRequest [[request]] , HttpServletResponse [[response]] , Authentication authentication ) { Assert . notNull ( [[request]] , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = [[request]] . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void logout ( HttpServletRequest [[courier]] , HttpServletResponse [[beagles]] , Authentication authentication ) { Assert . notNull ( [[courier]] , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = [[courier]] . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 117 ---------------------------------------------
Returns the redirect URL . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[applejack]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 118 ---------------------------------------------
Get the LDAP principal . --> Obtain bonkers --> Socre: 1.0

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[authentication]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = [[authentication]] . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails [[details]] = ( LdapUserDetails ) principal ; return [[details]] . getDn ( ) ; } else if ( [[authentication]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[bonkers]] ( ) { Authentication [[electrodes]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[electrodes]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = [[electrodes]] . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails [[sternberg]] = ( LdapUserDetails ) principal ; return [[sternberg]] . getDn ( ) ; } else if ( [[electrodes]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 119 ---------------------------------------------
Get port from cas service url . --> [[[FAILED]]]

[[[[Adv]]]]: private static int getServicePort ( URL [[casServiceUrl]] ) { int port = [[casServiceUrl]] . getPort ( ) ; if ( port == - 1 ) { port = [[casServiceUrl]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int getServicePort ( URL [[newsmen]] ) { int port = [[newsmen]] . getPort ( ) ; if ( port == - 1 ) { port = [[newsmen]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 120 ---------------------------------------------
Render the tag . --> we don t need this --> Socre: 1.0

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[foresaw]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 121 ---------------------------------------------
Initialize the service . --> region CreateUserDetails --> Socre: 1.0

[[[[Adv]]]]: @ Override protected void [[initUserDetailsService]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void [[retrieval]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
--------------------------------------------- Result 122 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 101 / 21 / 0 / 122:  12%|█▏        | 122/1000 [13:10<1:34:45,  6.48s/it][Succeeded / Failed / Skipped / Total] 101 / 21 / 0 / 122:  12%|█▏        | 123/1000 [13:11<1:34:00,  6.43s/it][Succeeded / Failed / Skipped / Total] 102 / 21 / 0 / 123:  12%|█▏        | 123/1000 [13:11<1:34:00,  6.43s/it][Succeeded / Failed / Skipped / Total] 102 / 21 / 0 / 123:  12%|█▏        | 124/1000 [13:17<1:33:54,  6.43s/it][Succeeded / Failed / Skipped / Total] 102 / 22 / 0 / 124:  12%|█▏        | 124/1000 [13:17<1:33:54,  6.43s/it][Succeeded / Failed / Skipped / Total] 102 / 22 / 0 / 124:  12%|█▎        | 125/1000 [13:24<1:33:51,  6.44s/it][Succeeded / Failed / Skipped / Total] 103 / 22 / 0 / 125:  12%|█▎        | 125/1000 [13:24<1:33:51,  6.44s/it][Succeeded / Failed / Skipped / Total] 103 / 22 / 0 / 125:  13%|█▎        | 126/1000 [13:41<1:34:56,  6.52s/it][Succeeded / Failed / Skipped / Total] 104 / 22 / 0 / 126:  13%|█▎        | 126/1000 [13:41<1:34:56,  6.52s/it][Succeeded / Failed / Skipped / Total] 104 / 22 / 0 / 126:  13%|█▎        | 127/1000 [13:41<1:34:08,  6.47s/it][Succeeded / Failed / Skipped / Total] 104 / 22 / 1 / 127:  13%|█▎        | 127/1000 [13:41<1:34:08,  6.47s/it][Succeeded / Failed / Skipped / Total] 104 / 22 / 1 / 127:  13%|█▎        | 128/1000 [13:47<1:34:00,  6.47s/it][Succeeded / Failed / Skipped / Total] 105 / 22 / 1 / 128:  13%|█▎        | 128/1000 [13:47<1:34:00,  6.47s/it][Succeeded / Failed / Skipped / Total] 105 / 22 / 1 / 128:  13%|█▎        | 129/1000 [13:56<1:34:09,  6.49s/it]Checks for authentication . --> else return true --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[requiresAuthentication]] ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean [[на]] ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 123 ---------------------------------------------
Set context environment properties --> Configures the Antoolander --> Socre: 1.0

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > [[environment]] ) { Assert . notEmpty ( [[environment]] , "environment must not be empty" ) ; this . [[contextEnvironmentProperties]] = new Hashtable <> ( [[environment]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[zoolander]] ( Map < String , Object > [[aches]] ) { Assert . notEmpty ( [[aches]] , "environment must not be empty" ) ; this . [[adapted]] = new Hashtable <> ( [[aches]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 124 ---------------------------------------------
Gets the UserDetailsService . --> [[[FAILED]]]

[[[[Adv]]]]: private UserDetailsService [[getUserDetailsService]] ( ) { Map < String , ? > [[beans]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[beans]] . size ( ) == 0 ) { [[beans]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[beans]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[beans]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[beans]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService [[headway]] ( ) { Map < String , ? > [[fucked]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[fucked]] . size ( ) == 0 ) { [[fucked]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[fucked]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[fucked]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[fucked]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 125 ---------------------------------------------
Adds PkCE parameters . --> overhang method --> Socre: 1.0

[[[[Adv]]]]: private void [[addPkceParameters]] ( Map < String , Object > [[attributes]] , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; [[attributes]] . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void [[overhang]] ( Map < String , Object > [[assassinated]] , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; [[assassinated]] . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 126 ---------------------------------------------
Proxy authentication . --> don t use this method --> Socre: 1.0

[[[[Adv]]]]: private boolean [[proxyTicketRequest]] ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean [[result]] = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean [[mucking]] ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean [[overcook]] = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[overcook]] ) ; } return [[overcook]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 127 ---------------------------------------------
Encode a string value . --> [[[SKIPPED]]]

[[[[Adv]]]]: private String utf8UrlEncode ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 128 ---------------------------------------------
Retrieve the JWK set . --> Executes ambience method --> Socre: 1.0

[[[[Adv]]]]: private Mono < JWKSet > [[getJWKSet]] ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > [[ambience]] ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 129 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 106 / 22 / 1 / 129:  13%|█▎        | 129/1000 [13:56<1:34:09,  6.49s/it][Succeeded / Failed / Skipped / Total] 106 / 22 / 1 / 129:  13%|█▎        | 130/1000 [14:03<1:34:07,  6.49s/it][Succeeded / Failed / Skipped / Total] 107 / 22 / 1 / 130:  13%|█▎        | 130/1000 [14:03<1:34:07,  6.49s/it][Succeeded / Failed / Skipped / Total] 107 / 22 / 1 / 130:  13%|█▎        | 131/1000 [14:16<1:34:39,  6.54s/it][Succeeded / Failed / Skipped / Total] 107 / 23 / 1 / 131:  13%|█▎        | 131/1000 [14:16<1:34:39,  6.54s/it][Succeeded / Failed / Skipped / Total] 107 / 23 / 1 / 131:  13%|█▎        | 132/1000 [14:17<1:33:57,  6.50s/it][Succeeded / Failed / Skipped / Total] 108 / 23 / 1 / 132:  13%|█▎        | 132/1000 [14:17<1:33:57,  6.50s/it][Succeeded / Failed / Skipped / Total] 108 / 23 / 1 / 132:  13%|█▎        | 133/1000 [14:27<1:34:16,  6.52s/it][Succeeded / Failed / Skipped / Total] 109 / 23 / 1 / 133:  13%|█▎        | 133/1000 [14:27<1:34:16,  6.52s/it][Succeeded / Failed / Skipped / Total] 109 / 23 / 1 / 133:  13%|█▎        | 134/1000 [14:33<1:34:07,  6.52s/it][Succeeded / Failed / Skipped / Total] 109 / 24 / 1 / 134:  13%|█▎        | 134/1000 [14:33<1:34:07,  6.52s/it][Succeeded / Failed / Skipped / Total] 109 / 24 / 1 / 134:  14%|█▎        | 135/1000 [14:53<1:35:27,  6.62s/it]Checks if the current thread is authenticated . --> only for testing --> Socre: 1.0

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[authentication]] != null && [[authentication]] . isAuthenticated ( ) && ! ( [[authentication]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[hornsby]] ( ) { Authentication [[bogotá]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[bogotá]] != null && [[bogotá]] . isAuthenticated ( ) && ! ( [[bogotá]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 130 ---------------------------------------------
Creates a MethodSecurityExpression root object . --> Adapts a MethodSecurityOperation to a MethodSecurityExpression --> Socre: 1.0

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[createSecurityExpressionRoot]] ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot [[root]] = new MethodSecurityExpressionRoot ( authentication ) ; [[root]] . setThis ( invocation . getThis ( ) ) ; [[root]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[root]] . setTrustResolver ( getTrustResolver ( ) ) ; [[root]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[root]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[root]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[adapted]] ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot [[arguin]] = new MethodSecurityExpressionRoot ( authentication ) ; [[arguin]] . setThis ( invocation . getThis ( ) ) ; [[arguin]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[arguin]] . setTrustResolver ( getTrustResolver ( ) ) ; [[arguin]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[arguin]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[arguin]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 131 ---------------------------------------------
Returns true if this request should be executed . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean proxyReceptorRequest ( final HttpServletRequest [[request]] ) { final boolean [[result]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[request]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean proxyReceptorRequest ( final HttpServletRequest [[deniability]] ) { final boolean [[uninitiated]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[deniability]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[uninitiated]] ) ; } return [[uninitiated]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 132 ---------------------------------------------
Check for authentication . --> else return true --> Socre: 1.0

[[[[Adv]]]]: private boolean [[serviceTicketRequest]] ( final HttpServletRequest request , final HttpServletResponse [[response]] ) { boolean [[result]] = super . requiresAuthentication ( request , [[response]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean [[appeared]] ( final HttpServletRequest request , final HttpServletResponse [[monsoon]] ) { boolean [[wilderness]] = super . requiresAuthentication ( request , [[monsoon]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[wilderness]] ) ; } return [[wilderness]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 133 ---------------------------------------------
Maps current user groups to user s granted authorities . --> Map fritters to grants --> Socre: 1.0

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[getWebSphereGroupsBasedGrantedAuthorities]] ( ) { List < String > [[webSphereGroups]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[webSphereGroups]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[webSphereGroups]] + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[fritters]] ( ) { List < String > [[somewheres]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[somewheres]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[somewheres]] + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 134 ---------------------------------------------
Build a provider URL from a list of URLs . --> [[[FAILED]]]

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String [[baseDn]] ) { Assert . notNull ( [[baseDn]] , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String [[trimmedBaseDn]] = [[baseDn]] . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( [[trimmedBaseDn]] ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String [[bath]] ) { Assert . notNull ( [[bath]] , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String [[boyd]] = [[bath]] . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( [[boyd]] ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 135 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 109 / 25 / 1 / 135:  14%|█▎        | 135/1000 [14:53<1:35:27,  6.62s/it][Succeeded / Failed / Skipped / Total] 109 / 25 / 1 / 135:  14%|█▎        | 136/1000 [15:01<1:35:26,  6.63s/it][Succeeded / Failed / Skipped / Total] 110 / 25 / 1 / 136:  14%|█▎        | 136/1000 [15:01<1:35:26,  6.63s/it][Succeeded / Failed / Skipped / Total] 110 / 25 / 1 / 136:  14%|█▎        | 137/1000 [15:08<1:35:23,  6.63s/it][Succeeded / Failed / Skipped / Total] 111 / 25 / 1 / 137:  14%|█▎        | 137/1000 [15:08<1:35:23,  6.63s/it][Succeeded / Failed / Skipped / Total] 111 / 25 / 1 / 137:  14%|█▍        | 138/1000 [15:14<1:35:09,  6.62s/it][Succeeded / Failed / Skipped / Total] 112 / 25 / 1 / 138:  14%|█▍        | 138/1000 [15:14<1:35:09,  6.62s/it][Succeeded / Failed / Skipped / Total] 112 / 25 / 1 / 138:  14%|█▍        | 139/1000 [15:16<1:34:37,  6.59s/it][Succeeded / Failed / Skipped / Total] 113 / 25 / 1 / 139:  14%|█▍        | 139/1000 [15:16<1:34:37,  6.59s/it][Succeeded / Failed / Skipped / Total] 113 / 25 / 1 / 139:  14%|█▍        | 140/1000 [15:28<1:35:00,  6.63s/it][Succeeded / Failed / Skipped / Total] 114 / 25 / 1 / 140:  14%|█▍        | 140/1000 [15:28<1:35:00,  6.63s/it][Succeeded / Failed / Skipped / Total] 114 / 25 / 1 / 140:  14%|█▍        | 141/1000 [15:35<1:35:01,  6.64s/it][Succeeded / Failed / Skipped / Total] 115 / 25 / 1 / 141:  14%|█▍        | 141/1000 [15:35<1:35:01,  6.64s/it][Succeeded / Failed / Skipped / Total] 115 / 25 / 1 / 141:  14%|█▍        | 142/1000 [15:41<1:34:46,  6.63s/it]Load user by assertion . --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[accretion]] ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 136 ---------------------------------------------
Returns a list of granted authorities . --> Return all granted authorities associated with channel --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[attributes]] ) { ArrayList < GrantedAuthority > [[gaList]] = new ArrayList <> ( ) ; for ( String attribute : [[attributes]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { [[gaList]] . addAll ( c ) ; } } [[gaList]] . trimToSize ( ) ; return [[gaList]] ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[channel]] ) { ArrayList < GrantedAuthority > [[almighty]] = new ArrayList <> ( ) ; for ( String attribute : [[channel]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { [[almighty]] . addAll ( c ) ; } } [[almighty]] . trimToSize ( ) ; return [[almighty]] ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 137 ---------------------------------------------
Preprocess the map . --> Pre process attributes . --> Socre: 1.0

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > [[orgMap]] ) { Map < String , Collection < GrantedAuthority > > [[result]] = new HashMap < String , Collection < GrantedAuthority > > ( [[orgMap]] . size ( ) ) ; for ( Map . Entry < ? , ? > entry : [[orgMap]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[result]] . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > [[dinos]] ) { Map < String , Collection < GrantedAuthority > > [[acrophobia]] = new HashMap < String , Collection < GrantedAuthority > > ( [[dinos]] . size ( ) ) ; for ( Map . Entry < ? , ? > entry : [[dinos]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[acrophobia]] . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return [[acrophobia]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 138 ---------------------------------------------
Returns a sub - array . --> used for testing --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[subArray]] ( byte [ ] array , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] [[subarray]] = new byte [ length ] ; System . arraycopy ( array , beginIndex , [[subarray]] , 0 , length ) ; return [[subarray]] ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] [[clashed]] ( byte [ ] array , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] [[dominici]] = new byte [ length ] ; System . arraycopy ( array , beginIndex , [[dominici]] , 0 , length ) ; return [[dominici]] ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 139 ---------------------------------------------
Returns the pre - authenticated principal . --> This method should be overridden by subclasses --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[blindfolded]] ( HttpServletRequest [[errol]] ) { Object [[planing]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[planing]] ) ; } return [[planing]] ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 140 ---------------------------------------------
Concatenates two arrays . --> Concatenate a bunch of bytes --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... [[arrays]] ) { int [[length]] = 0 ; for ( byte [ ] array : [[arrays]] ) { [[length]] += array . length ; } byte [ ] newArray = new byte [ [[length]] ] ; int destPos = 0 ; for ( byte [ ] array : [[arrays]] ) { System . arraycopy ( array , 0 , newArray , destPos , array . length ) ; destPos += array . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... [[charged]] ) { int [[antagonism]] = 0 ; for ( byte [ ] array : [[charged]] ) { [[antagonism]] += array . length ; } byte [ ] newArray = new byte [ [[antagonism]] ] ; int destPos = 0 ; for ( byte [ ] array : [[charged]] ) { System . arraycopy ( array , 0 , newArray , destPos , array . length ) ; destPos += array . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 141 ---------------------------------------------
Gets the collection of grantedAuthority objects . --> Helper method for chaining . --> Socre: 1.0

[[[[Adv]]]]: private Collection < GrantedAuthority > [[getGrantedAuthorityCollection]] ( Object value ) { Collection < GrantedAuthority > [[result]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[result]] , value ) ; return [[result]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > [[chavez]] ( Object value ) { Collection < GrantedAuthority > [[splish]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[splish]] , value ) ; return [[splish]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 142 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 116 / 25 / 1 / 142:  14%|█▍        | 142/1000 [15:41<1:34:46,  6.63s/it][Succeeded / Failed / Skipped / Total] 116 / 25 / 1 / 142:  14%|█▍        | 143/1000 [15:48<1:34:45,  6.63s/it][Succeeded / Failed / Skipped / Total] 117 / 25 / 1 / 143:  14%|█▍        | 143/1000 [15:48<1:34:45,  6.63s/it][Succeeded / Failed / Skipped / Total] 117 / 25 / 1 / 143:  14%|█▍        | 144/1000 [15:54<1:34:32,  6.63s/it][Succeeded / Failed / Skipped / Total] 118 / 25 / 1 / 144:  14%|█▍        | 144/1000 [15:54<1:34:32,  6.63s/it][Succeeded / Failed / Skipped / Total] 118 / 25 / 1 / 144:  14%|█▍        | 145/1000 [15:59<1:34:15,  6.62s/it][Succeeded / Failed / Skipped / Total] 119 / 25 / 1 / 145:  14%|█▍        | 145/1000 [15:59<1:34:15,  6.62s/it][Succeeded / Failed / Skipped / Total] 119 / 25 / 1 / 145:  15%|█▍        | 146/1000 [16:03<1:33:55,  6.60s/it][Succeeded / Failed / Skipped / Total] 119 / 26 / 1 / 146:  15%|█▍        | 146/1000 [16:03<1:33:55,  6.60s/it][Succeeded / Failed / Skipped / Total] 119 / 26 / 1 / 146:  15%|█▍        | 147/1000 [16:07<1:33:31,  6.58s/it][Succeeded / Failed / Skipped / Total] 120 / 26 / 1 / 147:  15%|█▍        | 147/1000 [16:07<1:33:31,  6.58s/it][Succeeded / Failed / Skipped / Total] 120 / 26 / 1 / 147:  15%|█▍        | 148/1000 [16:11<1:33:11,  6.56s/it]Invoke interceptor interceptor . --> Executes interceptor interceptor --> Socre: 1.0

[[[[Adv]]]]: public Object invoke ( JoinPoint jp , AspectJCallback [[advisorProceed]] ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = [[advisorProceed]] . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object invoke ( JoinPoint jp , AspectJCallback [[decorates]] ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = [[decorates]] . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 143 ---------------------------------------------
Gets the shared object . --> Get the repayment of the borrowed type --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . [[sharedObjects]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[repayment]] > [[repayment]] getSharedObject ( Class < [[repayment]] > sharedType ) { return ( [[repayment]] ) this . [[sliced]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 144 ---------------------------------------------
Build the redirect URL for the given request . --> Generate baritone --> Socre: 1.0

[[[[Adv]]]]: protected String [[buildHttpsRedirectUrlForRequest]] ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder [[urlBuilder]] = new RedirectUrlBuilder ( ) ; [[urlBuilder]] . setScheme ( "https" ) ; [[urlBuilder]] . setServerName ( request . getServerName ( ) ) ; [[urlBuilder]] . setPort ( httpsPort . intValue ( ) ) ; [[urlBuilder]] . setContextPath ( request . getContextPath ( ) ) ; [[urlBuilder]] . setServletPath ( request . getServletPath ( ) ) ; [[urlBuilder]] . setPathInfo ( request . getPathInfo ( ) ) ; [[urlBuilder]] . setQuery ( request . getQueryString ( ) ) ; return [[urlBuilder]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String [[baritone]] ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder [[browns]] = new RedirectUrlBuilder ( ) ; [[browns]] . setScheme ( "https" ) ; [[browns]] . setServerName ( request . getServerName ( ) ) ; [[browns]] . setPort ( httpsPort . intValue ( ) ) ; [[browns]] . setContextPath ( request . getContextPath ( ) ) ; [[browns]] . setServletPath ( request . getServletPath ( ) ) ; [[browns]] . setPathInfo ( request . getPathInfo ( ) ) ; [[browns]] . setQuery ( request . getQueryString ( ) ) ; return [[browns]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 145 ---------------------------------------------
Checks if any of the roles in the given array are valid . --> Helper method to add Waffle to Waffle --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] [[hasAnyRole]] ( String ... roles ) { for ( int i = 0 ; i < roles . length ; i ++ ) { roles [ i ] = "ROLE_" + roles [ i ] ; } return roles ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] [[waffle]] ( String ... roles ) { for ( int i = 0 ; i < roles . length ; i ++ ) { roles [ i ] = "ROLE_" + roles [ i ] ; } return roles ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 146 ---------------------------------------------
Adds a granted authority to the given result . --> [[[FAILED]]]

[[[[Adv]]]]: private void addGrantedAuthorityCollection ( Collection < GrantedAuthority > [[result]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { addGrantedAuthorityCollection ( [[result]] , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { addGrantedAuthorityCollection ( [[result]] , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { addGrantedAuthorityCollection ( [[result]] , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void addGrantedAuthorityCollection ( Collection < GrantedAuthority > [[lifer]] , Object [[indifference]] ) { if ( [[indifference]] == null ) { return ; } if ( [[indifference]] instanceof Collection < ? > ) { addGrantedAuthorityCollection ( [[lifer]] , ( Collection < ? > ) [[indifference]] ) ; } else if ( [[indifference]] instanceof Object [ ] ) { addGrantedAuthorityCollection ( [[lifer]] , ( Object [ ] ) [[indifference]] ) ; } else if ( [[indifference]] instanceof String ) { addGrantedAuthorityCollection ( [[lifer]] , ( String ) [[indifference]] ) ; } else if ( [[indifference]] instanceof GrantedAuthority ) { [[lifer]] . add ( ( GrantedAuthority ) [[indifference]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[indifference]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 147 ---------------------------------------------
Get the pre - authenticated principal . --> Convenience method to obtain a blocker from a given request --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = [[httpRequest]] . getUserPrincipal ( ) == null ? null : [[httpRequest]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object [[bunky]] ( HttpServletRequest [[delivery]] ) { Object [[antagonism]] = [[delivery]] . getUserPrincipal ( ) == null ? null : [[delivery]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[antagonism]] ) ; } return [[antagonism]] ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 148 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 121 / 26 / 1 / 148:  15%|█▍        | 148/1000 [16:11<1:33:11,  6.56s/it][Succeeded / Failed / Skipped / Total] 121 / 26 / 1 / 148:  15%|█▍        | 149/1000 [16:20<1:33:21,  6.58s/it][Succeeded / Failed / Skipped / Total] 122 / 26 / 1 / 149:  15%|█▍        | 149/1000 [16:20<1:33:21,  6.58s/it][Succeeded / Failed / Skipped / Total] 122 / 26 / 1 / 149:  15%|█▌        | 150/1000 [16:25<1:33:04,  6.57s/it][Succeeded / Failed / Skipped / Total] 123 / 26 / 1 / 150:  15%|█▌        | 150/1000 [16:25<1:33:04,  6.57s/it][Succeeded / Failed / Skipped / Total] 123 / 26 / 1 / 150:  15%|█▌        | 151/1000 [16:31<1:32:52,  6.56s/it][Succeeded / Failed / Skipped / Total] 124 / 26 / 1 / 151:  15%|█▌        | 151/1000 [16:31<1:32:52,  6.56s/it][Succeeded / Failed / Skipped / Total] 124 / 26 / 1 / 151:  15%|█▌        | 152/1000 [17:07<1:35:31,  6.76s/it][Succeeded / Failed / Skipped / Total] 125 / 26 / 1 / 152:  15%|█▌        | 152/1000 [17:07<1:35:31,  6.76s/it][Succeeded / Failed / Skipped / Total] 125 / 26 / 1 / 152:  15%|█▌        | 153/1000 [17:15<1:35:30,  6.77s/it][Succeeded / Failed / Skipped / Total] 125 / 27 / 1 / 153:  15%|█▌        | 153/1000 [17:15<1:35:30,  6.77s/it][Succeeded / Failed / Skipped / Total] 125 / 27 / 1 / 153:  15%|█▌        | 154/1000 [17:25<1:35:45,  6.79s/it][Succeeded / Failed / Skipped / Total] 126 / 27 / 1 / 154:  15%|█▌        | 154/1000 [17:25<1:35:45,  6.79s/it][Succeeded / Failed / Skipped / Total] 126 / 27 / 1 / 154:  16%|█▌        | 155/1000 [17:28<1:35:16,  6.77s/it]Checks if the given string is a role . --> Change the name of the curie --> Socre: 1.0

[[[[Adv]]]]: private static String [[hasRole]] ( String [[role]] ) { Assert . isTrue ( ! [[role]] . startsWith ( "ROLE_" ) , ( ) -> [[role]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[role]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String [[chavez]] ( String [[curie]] ) { Assert . isTrue ( ! [[curie]] . startsWith ( "ROLE_" ) , ( ) -> [[curie]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[curie]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 149 ---------------------------------------------
Attempt to exit the authentication . --> Authenticate a catchphrase --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[catchphrase]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 150 ---------------------------------------------
Display public index --> Display a random contact --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[anatomical]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 151 ---------------------------------------------
Spring security filter --> Manage web application --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[ade]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 152 ---------------------------------------------
Authorizes the access using an access expression . --> Implementation of jock --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingAccessExpression]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression [[accessExpression]] ; try { [[accessExpression]] = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( [[accessExpression]] , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean [[jock]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression [[accretion]] ; try { [[accretion]] = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( [[accretion]] , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 153 ---------------------------------------------
Sets the exit user URL . --> [[[FAILED]]]

[[[[Adv]]]]: public void setExitUserUrl ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[exitUserMatcher]] = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void setExitUserUrl ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[moronic]] = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 154 ---------------------------------------------
Callback method for creating a persistent login token . --> Calls crock --> Socre: 1.0

[[[[Adv]]]]: protected void [[onLoginSuccess]] ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String [[username]] = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + [[username]] ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( [[username]] , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void [[crock]] ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String [[scientology]] = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + [[scientology]] ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( [[scientology]] , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 155 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 127 / 27 / 1 / 155:  16%|█▌        | 155/1000 [17:28<1:35:16,  6.77s/it][Succeeded / Failed / Skipped / Total] 127 / 27 / 1 / 155:  16%|█▌        | 156/1000 [17:30<1:34:44,  6.74s/it][Succeeded / Failed / Skipped / Total] 128 / 27 / 1 / 156:  16%|█▌        | 156/1000 [17:30<1:34:44,  6.74s/it][Succeeded / Failed / Skipped / Total] 128 / 27 / 1 / 156:  16%|█▌        | 157/1000 [17:31<1:34:03,  6.69s/it][Succeeded / Failed / Skipped / Total] 128 / 27 / 2 / 157:  16%|█▌        | 157/1000 [17:31<1:34:03,  6.69s/it][Succeeded / Failed / Skipped / Total] 128 / 27 / 2 / 157:  16%|█▌        | 158/1000 [17:36<1:33:52,  6.69s/it][Succeeded / Failed / Skipped / Total] 129 / 27 / 2 / 158:  16%|█▌        | 158/1000 [17:36<1:33:52,  6.69s/it][Succeeded / Failed / Skipped / Total] 129 / 27 / 2 / 158:  16%|█▌        | 159/1000 [17:38<1:33:16,  6.65s/it][Succeeded / Failed / Skipped / Total] 130 / 27 / 2 / 159:  16%|█▌        | 159/1000 [17:38<1:33:16,  6.66s/it][Succeeded / Failed / Skipped / Total] 130 / 27 / 2 / 159:  16%|█▌        | 160/1000 [17:45<1:33:12,  6.66s/it][Succeeded / Failed / Skipped / Total] 131 / 27 / 2 / 160:  16%|█▌        | 160/1000 [17:45<1:33:12,  6.66s/it][Succeeded / Failed / Skipped / Total] 131 / 27 / 2 / 160:  16%|█▌        | 161/1000 [17:47<1:32:43,  6.63s/it][Succeeded / Failed / Skipped / Total] 132 / 27 / 2 / 161:  16%|█▌        | 161/1000 [17:47<1:32:43,  6.63s/it][Succeeded / Failed / Skipped / Total] 132 / 27 / 2 / 161:  16%|█▌        | 162/1000 [17:51<1:32:21,  6.61s/it]Convert the given JWT to a collection of authorities . --> Convert a JWT to a collection of grants . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt [[jwt]] ) { return getScopes ( [[jwt]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt [[atone]] ) { return getScopes ( [[atone]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 156 ---------------------------------------------
Check if authorization is allowed for this context . --> Methode permete --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String [[contextPath]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[currentUser]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[contextPath]] , getUrl ( ) , getMethod ( ) , [[currentUser]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[alaikum]] ( ) throws IOException { String [[caceres]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[amadé]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[caceres]] , getUrl ( ) , getMethod ( ) , [[amadé]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 157 ---------------------------------------------
Handle addPermission --> [[[SKIPPED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 158 ---------------------------------------------
Generates a CsrF token for this request . --> Gets the CsrfToken . --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[coons]] ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 159 ---------------------------------------------
Decodes the JWT . --> Implementation of ching . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Jwt [[decode]] ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt [[createdJwt]] = createJwt ( token , jwt ) ; return validateJwt ( [[createdJwt]] ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt [[ching]] ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt [[bhuvan]] = createJwt ( token , jwt ) ; return validateJwt ( [[bhuvan]] ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 160 ---------------------------------------------
Display admin permission --> Display Cheltenham --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[cheltenham]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 161 ---------------------------------------------
Display AddPermission page for AddPermission --> Handle addPermission --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAddPermissionPageForContact]] ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[added]] ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 162 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 133 / 27 / 2 / 162:  16%|█▌        | 162/1000 [17:51<1:32:21,  6.61s/it][Succeeded / Failed / Skipped / Total] 133 / 27 / 2 / 162:  16%|█▋        | 163/1000 [18:01<1:32:32,  6.63s/it][Succeeded / Failed / Skipped / Total] 134 / 27 / 2 / 163:  16%|█▋        | 163/1000 [18:01<1:32:32,  6.63s/it][Succeeded / Failed / Skipped / Total] 134 / 27 / 2 / 163:  16%|█▋        | 164/1000 [18:07<1:32:25,  6.63s/it][Succeeded / Failed / Skipped / Total] 135 / 27 / 2 / 164:  16%|█▋        | 164/1000 [18:07<1:32:25,  6.63s/it][Succeeded / Failed / Skipped / Total] 135 / 27 / 2 / 164:  16%|█▋        | 165/1000 [18:12<1:32:08,  6.62s/it][Succeeded / Failed / Skipped / Total] 136 / 27 / 2 / 165:  16%|█▋        | 165/1000 [18:12<1:32:08,  6.62s/it][Succeeded / Failed / Skipped / Total] 136 / 27 / 2 / 165:  17%|█▋        | 166/1000 [18:28<1:32:51,  6.68s/it][Succeeded / Failed / Skipped / Total] 137 / 27 / 2 / 166:  17%|█▋        | 166/1000 [18:28<1:32:51,  6.68s/it][Succeeded / Failed / Skipped / Total] 137 / 27 / 2 / 166:  17%|█▋        | 167/1000 [18:33<1:32:35,  6.67s/it][Succeeded / Failed / Skipped / Total] 137 / 28 / 2 / 167:  17%|█▋        | 167/1000 [18:33<1:32:35,  6.67s/it][Succeeded / Failed / Skipped / Total] 137 / 28 / 2 / 167:  17%|█▋        | 168/1000 [18:40<1:32:29,  6.67s/it]Deletes a specific permission --> Delete all contacts --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[deletePermission]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[chiselers]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 163 ---------------------------------------------
Create a user details resource factory bean from a string . --> Deserialize UserDetailsResourceFactory bean . --> Socre: 1.0

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String [[users]] ) { InMemoryResource resource = new InMemoryResource ( [[users]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String [[tribulations]] ) { InMemoryResource resource = new InMemoryResource ( [[tribulations]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 164 ---------------------------------------------
Process auto login cookie . --> Bing user details --> Socre: 1.0

[[[[Adv]]]]: protected UserDetails [[processAutoLoginCookie]] ( String [ ] cookieTokens , HttpServletRequest [[request]] , HttpServletResponse [[response]] ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String [[presentedSeries]] = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( [[presentedSeries]] ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails [[boing]] ( String [ ] cookieTokens , HttpServletRequest [[doña]] , HttpServletResponse [[boland]] ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String [[hashanah]] = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( [[hashanah]] ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 165 ---------------------------------------------
Encodes a string into a byte array . --> Encode a CharSequence --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence string ) { try { ByteBuffer [[bytes]] = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] bytesCopy = new byte [ [[bytes]] . limit ( ) ] ; System . arraycopy ( [[bytes]] . array ( ) , 0 , bytesCopy , 0 , [[bytes]] . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence string ) { try { ByteBuffer [[shirt]] = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] bytesCopy = new byte [ [[shirt]] . limit ( ) ] ; System . arraycopy ( [[shirt]] . array ( ) , 0 , bytesCopy , 0 , [[shirt]] . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 166 ---------------------------------------------
Get the first value for the given attribute name . --> Gets vesuvius . --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String [[name]] ) { List < String > result = getAttributeValues ( [[name]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[vesuvius]] ( String [[alaikum]] ) { List < String > result = getAttributeValues ( [[alaikum]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 167 ---------------------------------------------
Attempt to switch to a user . --> [[[FAILED]]]

[[[[Adv]]]]: protected Authentication [[attemptSwitchUser]] ( HttpServletRequest [[request]] ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = [[request]] . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails [[targetUser]] = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( [[targetUser]] ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication [[acts]] ( HttpServletRequest [[kinch]] ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = [[kinch]] . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails [[cherubs]] = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( [[cherubs]] ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 168 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 137 / 29 / 2 / 168:  17%|█▋        | 168/1000 [18:40<1:32:29,  6.67s/it][Succeeded / Failed / Skipped / Total] 137 / 29 / 2 / 168:  17%|█▋        | 169/1000 [18:47<1:32:23,  6.67s/it][Succeeded / Failed / Skipped / Total] 138 / 29 / 2 / 169:  17%|█▋        | 169/1000 [18:47<1:32:23,  6.67s/it][Succeeded / Failed / Skipped / Total] 138 / 29 / 2 / 169:  17%|█▋        | 170/1000 [18:50<1:32:00,  6.65s/it][Succeeded / Failed / Skipped / Total] 139 / 29 / 2 / 170:  17%|█▋        | 170/1000 [18:50<1:32:00,  6.65s/it][Succeeded / Failed / Skipped / Total] 139 / 29 / 2 / 170:  17%|█▋        | 171/1000 [18:53<1:31:36,  6.63s/it][Succeeded / Failed / Skipped / Total] 140 / 29 / 2 / 171:  17%|█▋        | 171/1000 [18:53<1:31:36,  6.63s/it][Succeeded / Failed / Skipped / Total] 140 / 29 / 2 / 171:  17%|█▋        | 172/1000 [18:59<1:31:24,  6.62s/it][Succeeded / Failed / Skipped / Total] 141 / 29 / 2 / 172:  17%|█▋        | 172/1000 [18:59<1:31:24,  6.62s/it][Succeeded / Failed / Skipped / Total] 141 / 29 / 2 / 172:  17%|█▋        | 173/1000 [19:01<1:30:58,  6.60s/it][Succeeded / Failed / Skipped / Total] 142 / 29 / 2 / 173:  17%|█▋        | 173/1000 [19:01<1:30:58,  6.60s/it][Succeeded / Failed / Skipped / Total] 142 / 29 / 2 / 173:  17%|█▋        | 174/1000 [19:34<1:32:55,  6.75s/it][Succeeded / Failed / Skipped / Total] 143 / 29 / 2 / 174:  17%|█▋        | 174/1000 [19:34<1:32:55,  6.75s/it][Succeeded / Failed / Skipped / Total] 143 / 29 / 2 / 174:  18%|█▊        | 175/1000 [19:40<1:32:44,  6.74s/it][Succeeded / Failed / Skipped / Total] 144 / 29 / 2 / 175:  18%|█▊        | 175/1000 [19:40<1:32:44,  6.74s/it][Succeeded / Failed / Skipped / Total] 144 / 29 / 2 / 175:  18%|█▊        | 176/1000 [19:46<1:32:36,  6.74s/it]Decode a byte array into a string . --> [[[FAILED]]]

[[[[Adv]]]]: public static String decode ( byte [ ] [[bytes]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bytes]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String decode ( byte [ ] [[instalments]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[instalments]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 169 ---------------------------------------------
Get all the values of an attribute . --> Uses Globak conventions to see if there are any . --> Socre: 1.0

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String [[name]] ) { List < String > [[result]] = null ; if ( attributes != null ) { [[result]] = attributes . get ( [[name]] ) ; } if ( [[result]] == null ) { [[result]] = Collections . emptyList ( ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[manak]] ( String [[rot]] ) { List < String > [[commonplace]] = null ; if ( attributes != null ) { [[commonplace]] = attributes . get ( [[rot]] ) ; } if ( [[commonplace]] == null ) { [[commonplace]] = Collections . emptyList ( ) ; } return [[commonplace]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 170 ---------------------------------------------
Returns all attributes specified on the target class --> Returns all configuration attributes specified on targetClass --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[findAttributes]] ( Method method , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , targetClass ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[clai]] ( Method method , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , targetClass ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 171 ---------------------------------------------
Gets the role with the given default role prefix . --> associate aitch to aitch --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String [[defaultRolePrefix]] , String role ) { if ( role == null ) { return role ; } if ( [[defaultRolePrefix]] == null || [[defaultRolePrefix]] . length ( ) == 0 ) { return role ; } if ( role . startsWith ( [[defaultRolePrefix]] ) ) { return role ; } return [[defaultRolePrefix]] + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[alerted]] ( String [[aitch]] , String role ) { if ( role == null ) { return role ; } if ( [[aitch]] == null || [[aitch]] . length ( ) == 0 ) { return role ; } if ( role . startsWith ( [[aitch]] ) ) { return role ; } return [[aitch]] + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 172 ---------------------------------------------
Get all configuration attributes . --> Get all ConfigAttributes --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > getAllConfigAttributes ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[allAttributes]] . addAll ( attributeList ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > getAllConfigAttributes ( ) { Set < ConfigAttribute > [[aey]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[aey]] . addAll ( attributeList ) ; } return [[aey]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 173 ---------------------------------------------
Add a new contact --> Render Dorina --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[addContact]] ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact [[contact]] = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( [[contact]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[dorina]] ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact [[alway]] = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( [[alway]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 174 ---------------------------------------------
Adds a new secure method . --> This is deprecated --> Socre: 1.0

[[[[Adv]]]]: private void [[addSecureMethod]] ( RegisteredMethod method , List < ConfigAttribute > [[attr]] ) { Assert . notNull ( method , "RegisteredMethod required" ) ; Assert . notNull ( [[attr]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + method + "] with attributes [" + [[attr]] + "]" ) ; } this . methodMap . put ( method , [[attr]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void [[depraved]] ( RegisteredMethod method , List < ConfigAttribute > [[secretion]] ) { Assert . notNull ( method , "RegisteredMethod required" ) ; Assert . notNull ( [[secretion]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + method + "] with attributes [" + [[secretion]] + "]" ) ; } this . methodMap . put ( method , [[secretion]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 175 ---------------------------------------------
Maps any request matcher to match . --> Makes sure that we have enough waterills --> Socre: 1.0

[[[[Adv]]]]: public C anyRequest ( ) { Assert . state ( ! this . [[anyRequestConfigured]] , "Can't configure anyRequest after itself" ) ; C [[configurer]] = requestMatchers ( ANY_REQUEST ) ; this . [[anyRequestConfigured]] = "True" == "True" ; return [[configurer]] ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C anyRequest ( ) { Assert . state ( ! this . [[doshi]] , "Can't configure anyRequest after itself" ) ; C [[foothills]] = requestMatchers ( ANY_REQUEST ) ; this . [[doshi]] = "True" == "True" ; return [[foothills]] ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 176 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 145 / 29 / 2 / 176:  18%|█▊        | 176/1000 [19:46<1:32:36,  6.74s/it][Succeeded / Failed / Skipped / Total] 145 / 29 / 2 / 176:  18%|█▊        | 177/1000 [19:52<1:32:23,  6.74s/it][Succeeded / Failed / Skipped / Total] 146 / 29 / 2 / 177:  18%|█▊        | 177/1000 [19:52<1:32:23,  6.74s/it][Succeeded / Failed / Skipped / Total] 146 / 29 / 2 / 177:  18%|█▊        | 178/1000 [19:58<1:32:13,  6.73s/it][Succeeded / Failed / Skipped / Total] 147 / 29 / 2 / 178:  18%|█▊        | 178/1000 [19:58<1:32:13,  6.73s/it][Succeeded / Failed / Skipped / Total] 147 / 29 / 2 / 178:  18%|█▊        | 179/1000 [20:02<1:31:55,  6.72s/it][Succeeded / Failed / Skipped / Total] 148 / 29 / 2 / 179:  18%|█▊        | 179/1000 [20:02<1:31:55,  6.72s/it][Succeeded / Failed / Skipped / Total] 148 / 29 / 2 / 179:  18%|█▊        | 180/1000 [20:24<1:32:59,  6.80s/it][Succeeded / Failed / Skipped / Total] 149 / 29 / 2 / 180:  18%|█▊        | 180/1000 [20:24<1:32:59,  6.80s/it][Succeeded / Failed / Skipped / Total] 149 / 29 / 2 / 180:  18%|█▊        | 181/1000 [20:36<1:33:15,  6.83s/it][Succeeded / Failed / Skipped / Total] 149 / 30 / 2 / 181:  18%|█▊        | 181/1000 [20:36<1:33:15,  6.83s/it][Succeeded / Failed / Skipped / Total] 149 / 30 / 2 / 181:  18%|█▊        | 182/1000 [20:42<1:33:04,  6.83s/it][Succeeded / Failed / Skipped / Total] 150 / 30 / 2 / 182:  18%|█▊        | 182/1000 [20:42<1:33:04,  6.83s/it][Succeeded / Failed / Skipped / Total] 150 / 30 / 2 / 182:  18%|█▊        | 183/1000 [20:52<1:33:13,  6.85s/it]Get a random contact --> Get random contact --> Socre: 1.0

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int [[getNumber]] = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( [[getNumber]] ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int [[corpses]] = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( [[corpses]] ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 177 ---------------------------------------------
Checks if the given method is a match . --> is logistic --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isMatch]] ( String [[methodName]] , String [[mappedName]] ) { return ( [[mappedName]] . endsWith ( "*" ) && [[methodName]] . startsWith ( [[mappedName]] . substring ( 0 , [[mappedName]] . length ( ) - 1 ) ) ) || ( [[mappedName]] . startsWith ( "*" ) && [[methodName]] . endsWith ( [[mappedName]] . substring ( 1 , [[mappedName]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[logistic]] ( String [[barbaric]] , String [[masato]] ) { return ( [[masato]] . endsWith ( "*" ) && [[barbaric]] . startsWith ( [[masato]] . substring ( 0 , [[masato]] . length ( ) - 1 ) ) ) || ( [[masato]] . startsWith ( "*" ) && [[barbaric]] . endsWith ( [[masato]] . substring ( 1 , [[masato]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 178 ---------------------------------------------
Removes authentication exception from session . --> Remove encrypted entity --> Socre: 1.0

[[[[Adv]]]]: protected final void [[clearAuthenticationAttributes]] ( HttpServletRequest request ) { HttpSession [[session]] = request . getSession ( "False" != "False" ) ; if ( [[session]] == null ) { return ; } [[session]] . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void [[benzedrine]] ( HttpServletRequest request ) { HttpSession [[amadeo]] = request . getSession ( "False" != "False" ) ; if ( [[amadeo]] == null ) { return ; } [[amadeo]] . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 179 ---------------------------------------------
Handles bind exception . --> log lemmings --> Socre: 1.0

[[[[Adv]]]]: protected void [[handleBindException]] ( String userDn , String [[username]] , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void [[lemmings]] ( String userDn , String [[pemberton]] , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 180 ---------------------------------------------
Checks stack . --> Check stack . --> Socre: 1.0

[[[[Adv]]]]: private void checkFilterStack ( List < Filter > [[filters]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[filters]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[filters]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[filters]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[filters]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[filters]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[filters]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void checkFilterStack ( List < Filter > [[abuela]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[abuela]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[abuela]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[abuela]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[abuela]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[abuela]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[abuela]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[abuela]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[abuela]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 181 ---------------------------------------------
Returns the declared field of the specified class . --> [[[FAILED]]]

[[[[Adv]]]]: public static Field getField ( Class < ? > [[clazz]] , String fieldName ) throws IllegalStateException { Assert . notNull ( [[clazz]] , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return [[clazz]] . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field getField ( Class < ? > [[hypnotize]] , String fieldName ) throws IllegalStateException { Assert . notNull ( [[hypnotize]] , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return [[hypnotize]] . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 182 ---------------------------------------------
Create the service url . --> override this method --> Socre: 1.0

[[[[Adv]]]]: protected String [[createServiceUrl]] ( final HttpServletRequest request , final HttpServletResponse [[response]] ) { return CommonUtils . constructServiceUrl ( null , [[response]] , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[overjoyed]] ( final HttpServletRequest request , final HttpServletResponse [[birthing]] ) { return CommonUtils . constructServiceUrl ( null , [[birthing]] , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 183 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 150 / 31 / 2 / 183:  18%|█▊        | 183/1000 [20:52<1:33:13,  6.85s/it][Succeeded / Failed / Skipped / Total] 150 / 31 / 2 / 183:  18%|█▊        | 184/1000 [21:05<1:33:31,  6.88s/it][Succeeded / Failed / Skipped / Total] 151 / 31 / 2 / 184:  18%|█▊        | 184/1000 [21:05<1:33:31,  6.88s/it][Succeeded / Failed / Skipped / Total] 151 / 31 / 2 / 184:  18%|█▊        | 185/1000 [21:05<1:32:55,  6.84s/it][Succeeded / Failed / Skipped / Total] 151 / 31 / 3 / 185:  18%|█▊        | 185/1000 [21:05<1:32:55,  6.84s/it][Succeeded / Failed / Skipped / Total] 151 / 31 / 3 / 185:  19%|█▊        | 186/1000 [21:21<1:33:26,  6.89s/it][Succeeded / Failed / Skipped / Total] 151 / 32 / 3 / 186:  19%|█▊        | 186/1000 [21:21<1:33:26,  6.89s/it][Succeeded / Failed / Skipped / Total] 151 / 32 / 3 / 186:  19%|█▊        | 187/1000 [21:25<1:33:09,  6.87s/it][Succeeded / Failed / Skipped / Total] 152 / 32 / 3 / 187:  19%|█▊        | 187/1000 [21:25<1:33:09,  6.87s/it][Succeeded / Failed / Skipped / Total] 152 / 32 / 3 / 187:  19%|█▉        | 188/1000 [21:27<1:32:40,  6.85s/it][Succeeded / Failed / Skipped / Total] 152 / 33 / 3 / 188:  19%|█▉        | 188/1000 [21:27<1:32:40,  6.85s/it][Succeeded / Failed / Skipped / Total] 152 / 33 / 3 / 188:  19%|█▉        | 189/1000 [21:39<1:32:54,  6.87s/it]Extract SHA prefix . --> [[[FAILED]]]

[[[[Adv]]]]: private String extractPrefix ( String encPass ) { if ( ! encPass . startsWith ( "{" ) ) { return null ; } int [[secondBrace]] = encPass . lastIndexOf ( ' ' ) ; if ( [[secondBrace]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return encPass . substring ( 0 , [[secondBrace]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String extractPrefix ( String encPass ) { if ( ! encPass . startsWith ( "{" ) ) { return null ; } int [[albion]] = encPass . lastIndexOf ( ' ' ) ; if ( [[albion]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return encPass . substring ( 0 , [[albion]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 184 ---------------------------------------------
Register the access manager . --> Generates a vote manager --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String [[registerAccessManager]] ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String [[aitch]] ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 185 ---------------------------------------------
Compare two byte arrays --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 186 ---------------------------------------------
Create the redirect url . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[createRedirectUrl]] ( final String [[serviceUrl]] ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , [[serviceUrl]] , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[proof]] ( final String [[affraid]] ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , [[affraid]] , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 187 ---------------------------------------------
Called when the authentication method is called . --> Displays an attaining action --> Socre: 1.0

[[[[Adv]]]]: public void [[commence]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } [[response]] . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void [[attaining]] ( HttpServletRequest [[banquets]] , HttpServletResponse [[depict]] , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } [[depict]] . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 188 ---------------------------------------------
Gets the registered types . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > typeList = this . [[extractorMap]] . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[zooming]] ( ) { Set < Class < ? extends Throwable > > typeList = this . [[having]] . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 189 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 152 / 34 / 3 / 189:  19%|█▉        | 189/1000 [21:39<1:32:54,  6.87s/it][Succeeded / Failed / Skipped / Total] 152 / 34 / 3 / 189:  19%|█▉        | 190/1000 [22:02<1:33:59,  6.96s/it][Succeeded / Failed / Skipped / Total] 153 / 34 / 3 / 190:  19%|█▉        | 190/1000 [22:02<1:33:59,  6.96s/it][Succeeded / Failed / Skipped / Total] 153 / 34 / 3 / 190:  19%|█▉        | 191/1000 [22:11<1:33:57,  6.97s/it][Succeeded / Failed / Skipped / Total] 154 / 34 / 3 / 191:  19%|█▉        | 191/1000 [22:11<1:33:57,  6.97s/it][Succeeded / Failed / Skipped / Total] 154 / 34 / 3 / 191:  19%|█▉        | 192/1000 [22:20<1:33:59,  6.98s/it][Succeeded / Failed / Skipped / Total] 155 / 34 / 3 / 192:  19%|█▉        | 192/1000 [22:20<1:33:59,  6.98s/it][Succeeded / Failed / Skipped / Total] 155 / 34 / 3 / 192:  19%|█▉        | 193/1000 [22:22<1:33:33,  6.96s/it][Succeeded / Failed / Skipped / Total] 156 / 34 / 3 / 193:  19%|█▉        | 193/1000 [22:22<1:33:33,  6.96s/it][Succeeded / Failed / Skipped / Total] 156 / 34 / 3 / 193:  19%|█▉        | 194/1000 [22:26<1:33:13,  6.94s/it][Succeeded / Failed / Skipped / Total] 157 / 34 / 3 / 194:  19%|█▉        | 194/1000 [22:26<1:33:13,  6.94s/it][Succeeded / Failed / Skipped / Total] 157 / 34 / 3 / 194:  20%|█▉        | 195/1000 [22:49<1:34:14,  7.02s/it][Succeeded / Failed / Skipped / Total] 157 / 35 / 3 / 195:  20%|█▉        | 195/1000 [22:49<1:34:14,  7.02s/it][Succeeded / Failed / Skipped / Total] 157 / 35 / 3 / 195:  20%|█▉        | 196/1000 [22:51<1:33:47,  7.00s/it]Look up the parameter names for a given type . --> [[[FAILED]]]

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] [[parameterAnnotations]] = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = [[parameterAnnotations]] . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = [[parameterAnnotations]] [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] [[agro]] = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = [[agro]] . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = [[agro]] [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 190 ---------------------------------------------
Sets the function which allows to resolve hidden inputs . --> documentation inherited from Request --> Socre: 1.0

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > [[resolveHiddenInputs]] ) { Assert . notNull ( [[resolveHiddenInputs]] , "resolveHiddenInputs cannot be null" ) ; this . resolveHiddenInputs = [[resolveHiddenInputs]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[futures]] ( Function < HttpServletRequest , Map < String , String > > [[ludovic]] ) { Assert . notNull ( [[ludovic]] , "resolveHiddenInputs cannot be null" ) ; this . resolveHiddenInputs = [[ludovic]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 191 ---------------------------------------------
Sets the default failure url . --> CAMAP alerts --> Socre: 1.0

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String [[defaultFailureUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[defaultFailureUrl]] ) , ( ) -> "'" + [[defaultFailureUrl]] + "' is not a valid redirect URL" ) ; this . [[defaultFailureUrl]] = [[defaultFailureUrl]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[chamaco]] ( String [[alerted]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[alerted]] ) , ( ) -> "'" + [[alerted]] + "' is not a valid redirect URL" ) ; this . [[aces]] = [[alerted]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 192 ---------------------------------------------
Convert a collection of user authorities to a Set . --> Associate all the authorities with the given authority --> Socre: 1.0

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > [[userAuthorities]] ) { Assert . notNull ( [[userAuthorities]] , "userAuthorities cannot be null" ) ; Set < String > [[set]] = new HashSet <> ( [[userAuthorities]] . size ( ) ) ; for ( GrantedAuthority authority : [[userAuthorities]] ) { [[set]] . add ( authority . getAuthority ( ) ) ; } return [[set]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[amadé]] ( Collection < ? extends GrantedAuthority > [[cello]] ) { Assert . notNull ( [[cello]] , "userAuthorities cannot be null" ) ; Set < String > [[amigo]] = new HashSet <> ( [[cello]] . size ( ) ) ; for ( GrantedAuthority authority : [[cello]] ) { [[amigo]] . add ( authority . getAuthority ( ) ) ; } return [[amigo]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 193 ---------------------------------------------
Extracts the cause of the given throwable . --> Borrowed from Guice --> Socre: 1.0

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable [[throwable]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[entry]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[throwableType]] = [[entry]] . getKey ( ) ; if ( [[throwableType]] . isInstance ( [[throwable]] ) ) { ThrowableCauseExtractor extractor = [[entry]] . getValue ( ) ; return extractor . extractCause ( [[throwable]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[b]] ( Throwable [[dunning]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[milksop]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[arf]] = [[milksop]] . getKey ( ) ; if ( [[arf]] . isInstance ( [[dunning]] ) ) { ThrowableCauseExtractor extractor = [[milksop]] . getValue ( ) ; return extractor . extractCause ( [[dunning]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 194 ---------------------------------------------
Extracts the identifier from the given result set . --> serialize a deserializable --> Socre: 1.0

[[[[Adv]]]]: Serializable [[identifierFrom]] ( Serializable identifier , ResultSet resultSet ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable [[ś]] ( Serializable identifier , ResultSet resultSet ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 195 ---------------------------------------------
Checks if is an absolute URL . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String url ) { if ( url == null ) { return "False" != "False" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( url ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[anvil]] ( String url ) { if ( url == null ) { return "False" != "False" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( url ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 196 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 157 / 36 / 3 / 196:  20%|█▉        | 196/1000 [22:51<1:33:47,  7.00s/it][Succeeded / Failed / Skipped / Total] 157 / 36 / 3 / 196:  20%|█▉        | 197/1000 [22:52<1:33:14,  6.97s/it][Succeeded / Failed / Skipped / Total] 157 / 36 / 4 / 197:  20%|█▉        | 197/1000 [22:52<1:33:14,  6.97s/it][Succeeded / Failed / Skipped / Total] 157 / 36 / 4 / 197:  20%|█▉        | 198/1000 [23:06<1:33:34,  7.00s/it][Succeeded / Failed / Skipped / Total] 158 / 36 / 4 / 198:  20%|█▉        | 198/1000 [23:06<1:33:34,  7.00s/it][Succeeded / Failed / Skipped / Total] 158 / 36 / 4 / 198:  20%|█▉        | 199/1000 [23:21<1:34:03,  7.04s/it][Succeeded / Failed / Skipped / Total] 159 / 36 / 4 / 199:  20%|█▉        | 199/1000 [23:21<1:34:03,  7.04s/it][Succeeded / Failed / Skipped / Total] 159 / 36 / 4 / 199:  20%|██        | 200/1000 [23:22<1:33:31,  7.01s/it][Succeeded / Failed / Skipped / Total] 160 / 36 / 4 / 200:  20%|██        | 200/1000 [23:22<1:33:31,  7.01s/it][Succeeded / Failed / Skipped / Total] 160 / 36 / 4 / 200:  20%|██        | 201/1000 [23:37<1:33:56,  7.05s/it][Succeeded / Failed / Skipped / Total] 161 / 36 / 4 / 201:  20%|██        | 201/1000 [23:37<1:33:56,  7.05s/it][Succeeded / Failed / Skipped / Total] 161 / 36 / 4 / 201:  20%|██        | 202/1000 [23:43<1:33:44,  7.05s/it]Creates an attribute list for the given identifier . --> [[[FAILED]]]

[[[[Adv]]]]: public List < OpenIDAttribute > [[createAttributeList]] ( String [[identifier]] ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > [[entry]] : idToAttributes . entrySet ( ) ) { if ( [[entry]] . getKey ( ) . matcher ( [[identifier]] ) . matches ( ) ) { return [[entry]] . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > [[chiselers]] ( String [[seaworld]] ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > [[abusers]] : idToAttributes . entrySet ( ) ) { if ( [[abusers]] . getKey ( ) . matcher ( [[seaworld]] ) . matches ( ) ) { return [[abusers]] . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 197 ---------------------------------------------
Matching matcher --> [[[SKIPPED]]]

[[[[Adv]]]]: public static ServerWebExchangeMatcher anyExchange ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 198 ---------------------------------------------
Saves the current request . --> Disrobe --> Socre: 1.0

[[[[Adv]]]]: public void [[saveRequest]] ( HttpServletRequest [[request]] , HttpServletResponse response ) { if ( requestMatcher . matches ( [[request]] ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( [[request]] , portResolver ) ; if ( createSessionAllowed || [[request]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void [[disrobe]] ( HttpServletRequest [[edgewise]] , HttpServletResponse response ) { if ( requestMatcher . matches ( [[edgewise]] ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( [[edgewise]] , portResolver ) ; if ( createSessionAllowed || [[edgewise]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 199 ---------------------------------------------
Update an existing ACL . --> Generate a newcl --> Socre: 1.0

[[[[Adv]]]]: protected void [[updateObjectIdentity]] ( MutableAcl acl ) { Long [[parentId]] = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; [[parentId]] = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "True" == "True" ) ; int [[count]] = jdbcOperations . update ( [[updateObjectIdentity]] , [[parentId]] , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( [[count]] != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void [[thieve]] ( MutableAcl acl ) { Long [[lashed]] = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; [[lashed]] = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "True" == "True" ) ; int [[ã]] = jdbcOperations . update ( [[thieve]] , [[lashed]] , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( [[ã]] != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 200 ---------------------------------------------
Build the request URL --> Detach from a servlet path --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildRequestUrl]] ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder [[url]] = new StringBuilder ( ) ; if ( servletPath != null ) { [[url]] . append ( servletPath ) ; if ( pathInfo != null ) { [[url]] . append ( pathInfo ) ; } } else { [[url]] . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { [[url]] . append ( "?" ) . append ( queryString ) ; } return [[url]] . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String [[discernment]] ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder [[accelerant]] = new StringBuilder ( ) ; if ( servletPath != null ) { [[accelerant]] . append ( servletPath ) ; if ( pathInfo != null ) { [[accelerant]] . append ( pathInfo ) ; } } else { [[accelerant]] . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { [[accelerant]] . append ( "?" ) . append ( queryString ) ; } return [[accelerant]] . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 201 ---------------------------------------------
Creates a composite matcher for the given HTTP method . --> Sanity check for antio --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[pathMatchers]] ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > [[matchers]] = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { [[matchers]] . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( [[matchers]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[santino]] ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > [[basilio]] = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { [[basilio]] . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( [[basilio]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 202 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 162 / 36 / 4 / 202:  20%|██        | 202/1000 [23:43<1:33:44,  7.05s/it][Succeeded / Failed / Skipped / Total] 162 / 36 / 4 / 202:  20%|██        | 203/1000 [23:49<1:33:31,  7.04s/it][Succeeded / Failed / Skipped / Total] 163 / 36 / 4 / 203:  20%|██        | 203/1000 [23:49<1:33:31,  7.04s/it][Succeeded / Failed / Skipped / Total] 163 / 36 / 4 / 203:  20%|██        | 204/1000 [24:00<1:33:40,  7.06s/it][Succeeded / Failed / Skipped / Total] 164 / 36 / 4 / 204:  20%|██        | 204/1000 [24:00<1:33:40,  7.06s/it][Succeeded / Failed / Skipped / Total] 164 / 36 / 4 / 204:  20%|██        | 205/1000 [24:03<1:33:17,  7.04s/it][Succeeded / Failed / Skipped / Total] 164 / 37 / 4 / 205:  20%|██        | 205/1000 [24:03<1:33:17,  7.04s/it][Succeeded / Failed / Skipped / Total] 164 / 37 / 4 / 205:  21%|██        | 206/1000 [24:11<1:33:14,  7.05s/it][Succeeded / Failed / Skipped / Total] 165 / 37 / 4 / 206:  21%|██        | 206/1000 [24:11<1:33:14,  7.05s/it][Succeeded / Failed / Skipped / Total] 165 / 37 / 4 / 206:  21%|██        | 207/1000 [24:21<1:33:18,  7.06s/it][Succeeded / Failed / Skipped / Total] 166 / 37 / 4 / 207:  21%|██        | 207/1000 [24:21<1:33:18,  7.06s/it][Succeeded / Failed / Skipped / Total] 166 / 37 / 4 / 207:  21%|██        | 208/1000 [24:21<1:32:45,  7.03s/it]Write header to response . --> Write headers to response --> Socre: 1.0

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest [[request]] , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( [[request]] ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest [[garfunkel]] , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( [[garfunkel]] ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 203 ---------------------------------------------
Insert entries in acl . --> Detach aacl --> Socre: 1.0

[[[[Adv]]]]: protected void [[createEntries]] ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int [[i]] ) throws SQLException { AccessControlEntry [[entry_]] = acl . getEntries ( ) . get ( [[i]] ) ; Assert . isTrue ( [[entry_]] instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) [[entry_]] ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , [[i]] ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void [[vivant]] ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int [[aaaah]] ) throws SQLException { AccessControlEntry [[hypnotize]] = acl . getEntries ( ) . get ( [[aaaah]] ) ; Assert . isTrue ( [[hypnotize]] instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) [[hypnotize]] ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , [[aaaah]] ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 204 ---------------------------------------------
Determine the target URL to use . --> Performs an animation . --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return [[determineTargetUrl]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String [[animated]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return [[animated]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 205 ---------------------------------------------
Creates a cleartext encryptor with the given password and a salt . --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[delux]] ( CharSequence password , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( stronger ( password , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[øre]] ( CharSequence password , CharSequence [[birthing]] ) { return new HexEncodingTextEncryptor ( stronger ( password , [[birthing]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 206 ---------------------------------------------
Creates an encryptor with text and salt . --> TextEncryptor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor text ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( standard ( [[password]] , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor text ( CharSequence [[ã]] , CharSequence [[shortens]] ) { return new HexEncodingTextEncryptor ( standard ( [[ã]] , [[shortens]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 207 ---------------------------------------------
Creates the object identity . --> Methode permettant doutes --> Socre: 1.0

[[[[Adv]]]]: protected void [[createObjectIdentity]] ( ObjectIdentity [[object]] , Sid owner ) { Long [[sidId]] = createOrRetrieveSidPrimaryKey ( owner , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( [[object]] . getType ( ) , "True" == "True" , [[object]] . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , [[object]] . getIdentifier ( ) . toString ( ) , [[sidId]] , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void [[diferent]] ( ObjectIdentity [[golan]] , Sid owner ) { Long [[abusers]] = createOrRetrieveSidPrimaryKey ( owner , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( [[golan]] . getType ( ) , "True" == "True" , [[golan]] . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , [[golan]] . getIdentifier ( ) . toString ( ) , [[abusers]] , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
[Succeeded / Failed / Skipped / Total] 166 / 38 / 4 / 208:  21%|██        | 208/1000 [24:21<1:32:45,  7.03s/it][Succeeded / Failed / Skipped / Total] 166 / 38 / 4 / 208:  21%|██        | 209/1000 [24:22<1:32:16,  7.00s/it][Succeeded / Failed / Skipped / Total] 167 / 38 / 4 / 209:  21%|██        | 209/1000 [24:22<1:32:16,  7.00s/it][Succeeded / Failed / Skipped / Total] 167 / 38 / 4 / 209:  21%|██        | 210/1000 [24:35<1:32:30,  7.03s/it][Succeeded / Failed / Skipped / Total] 168 / 38 / 4 / 210:  21%|██        | 210/1000 [24:35<1:32:30,  7.03s/it][Succeeded / Failed / Skipped / Total] 168 / 38 / 4 / 210:  21%|██        | 211/1000 [24:43<1:32:27,  7.03s/it][Succeeded / Failed / Skipped / Total] 169 / 38 / 4 / 211:  21%|██        | 211/1000 [24:43<1:32:27,  7.03s/it][Succeeded / Failed / Skipped / Total] 169 / 38 / 4 / 211:  21%|██        | 212/1000 [24:44<1:31:58,  7.00s/it][Succeeded / Failed / Skipped / Total] 170 / 38 / 4 / 212:  21%|██        | 212/1000 [24:44<1:31:58,  7.00s/it][Succeeded / Failed / Skipped / Total] 170 / 38 / 4 / 212:  21%|██▏       | 213/1000 [24:50<1:31:46,  7.00s/it][Succeeded / Failed / Skipped / Total] 171 / 38 / 4 / 213:  21%|██▏       | 213/1000 [24:50<1:31:46,  7.00s/it][Succeeded / Failed / Skipped / Total] 171 / 38 / 4 / 213:  21%|██▏       | 214/1000 [24:52<1:31:21,  6.97s/it]--------------------------------------------- Result 208 ---------------------------------------------
Create encryptor . --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[queryableText]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[password]] . toString ( ) , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[faure]] ( CharSequence [[batya]] , CharSequence [[compound]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[batya]] . toString ( ) , [[compound]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 209 ---------------------------------------------
Gets the directory with immediate parent . --> Search for busy bodies --> Socre: 1.0

[[[[Adv]]]]: private Directory [[getDirectoryWithImmediateParentPopulated]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory [[busybodies]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 210 ---------------------------------------------
Creates shared objects . --> Duplicate SharedObjects . --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[duvall]] ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
[[[[Nl]]]]: Creates the shared objects
--------------------------------------------- Result 211 ---------------------------------------------
Returns the current date . --> UNIQUE --> Socre: 1.0

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[unification]] ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 212 ---------------------------------------------
Sets the target URL parameter . --> Sets newport --> Socre: 1.0

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String [[targetUrlParameter]] ) { if ( [[targetUrlParameter]] != null ) { Assert . hasText ( [[targetUrlParameter]] , "targetUrlParameter cannot be empty" ) ; } this . [[targetUrlParameter]] = [[targetUrlParameter]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[newport]] ( String [[candor]] ) { if ( [[candor]] != null ) { Assert . hasText ( [[candor]] , "targetUrlParameter cannot be empty" ) ; } this . [[ś]] = [[candor]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 213 ---------------------------------------------
Determines the target URL . --> else return null --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest [[request]] , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[gaelic]] ( HttpServletRequest [[malnourished]] , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 214 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 172 / 38 / 4 / 214:  21%|██▏       | 214/1000 [24:52<1:31:21,  6.97s/it][Succeeded / Failed / Skipped / Total] 172 / 38 / 4 / 214:  22%|██▏       | 215/1000 [25:09<1:31:52,  7.02s/it][Succeeded / Failed / Skipped / Total] 172 / 39 / 4 / 215:  22%|██▏       | 215/1000 [25:09<1:31:52,  7.02s/it][Succeeded / Failed / Skipped / Total] 172 / 39 / 4 / 215:  22%|██▏       | 216/1000 [25:12<1:31:30,  7.00s/it][Succeeded / Failed / Skipped / Total] 173 / 39 / 4 / 216:  22%|██▏       | 216/1000 [25:12<1:31:30,  7.00s/it][Succeeded / Failed / Skipped / Total] 173 / 39 / 4 / 216:  22%|██▏       | 217/1000 [25:20<1:31:26,  7.01s/it][Succeeded / Failed / Skipped / Total] 174 / 39 / 4 / 217:  22%|██▏       | 217/1000 [25:20<1:31:26,  7.01s/it][Succeeded / Failed / Skipped / Total] 174 / 39 / 4 / 217:  22%|██▏       | 218/1000 [25:24<1:31:07,  6.99s/it][Succeeded / Failed / Skipped / Total] 175 / 39 / 4 / 218:  22%|██▏       | 218/1000 [25:24<1:31:07,  6.99s/it][Succeeded / Failed / Skipped / Total] 175 / 39 / 4 / 218:  22%|██▏       | 219/1000 [25:38<1:31:25,  7.02s/it][Succeeded / Failed / Skipped / Total] 176 / 39 / 4 / 219:  22%|██▏       | 219/1000 [25:38<1:31:25,  7.02s/it][Succeeded / Failed / Skipped / Total] 176 / 39 / 4 / 219:  22%|██▏       | 220/1000 [25:39<1:30:58,  7.00s/it][Succeeded / Failed / Skipped / Total] 176 / 40 / 4 / 220:  22%|██▏       | 220/1000 [25:39<1:30:58,  7.00s/it][Succeeded / Failed / Skipped / Total] 176 / 40 / 4 / 220:  22%|██▏       | 221/1000 [25:54<1:31:19,  7.03s/it][Succeeded / Failed / Skipped / Total] 177 / 40 / 4 / 221:  22%|██▏       | 221/1000 [25:54<1:31:19,  7.03s/it][Succeeded / Failed / Skipped / Total] 177 / 40 / 4 / 221:  22%|██▏       | 222/1000 [25:58<1:31:02,  7.02s/it]Configures JAAS authentication . --> Configure jaas using Loas --> Socre: 1.0

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String [[loginConfigUrl]] = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( [[loginConfigUrl]] ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + [[loginConfigUrl]] ) ; Security . setProperty ( key , [[loginConfigUrl]] ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String [[neon]] = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( [[neon]] ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + [[neon]] ) ; Security . setProperty ( key , [[neon]] ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 215 ---------------------------------------------
Builds the DN with the given username . --> [[[FAILED]]]

[[[[Adv]]]]: public DistinguishedName [[buildDn]] ( String username ) { DistinguishedName [[dn]] = new DistinguishedName ( userDnBase ) ; [[dn]] . add ( usernameAttribute , username ) ; return [[dn]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName [[leibowitz]] ( String username ) { DistinguishedName [[amplify]] = new DistinguishedName ( userDnBase ) ; [[amplify]] . add ( usernameAttribute , username ) ; return [[amplify]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 216 ---------------------------------------------
Gets the groups associated with the specified security name . --> Utility method that obtains a list of strings --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[getWebSphereGroups]] ( final String securityName ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[abattoir]] ( final String securityName ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 217 ---------------------------------------------
Update cache . --> Put futures into the map --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[updateCache]] ( HashMap [[cache]] , Object key , Object value ) { if ( value == null ) { return ; } if ( [[cache]] . size ( ) > 1000 ) { [[cache]] . clear ( ) ; } [[cache]] . put ( key , value ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[futures]] ( HashMap [[abandons]] , Object key , Object value ) { if ( value == null ) { return ; } if ( [[abandons]] . size ( ) > 1000 ) { [[abandons]] . clear ( ) ; } [[abandons]] . put ( key , value ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 218 ---------------------------------------------
Internal method to parse a date value . --> Convert a String to a Long --> Socre: 1.0

[[[[Adv]]]]: private static Long [[internalParseDate]] ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int [[i]] = 0 ; ( date == null ) && ( [[i]] < formats . length ) ; [[i]] ++ ) { try { date = formats [ [[i]] ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long [[burmese]] ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int [[blowin]] = 0 ; ( date == null ) && ( [[blowin]] < formats . length ) ; [[blowin]] ++ ) { try { date = formats [ [[blowin]] ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 219 ---------------------------------------------
Throws a SessionAuthenticationException if allowed . --> Throws SessionAuthenticationException if allowed --> Socre: 1.0

[[[[Adv]]]]: protected void allowableSessionsExceeded ( List < SessionInformation > sessions , int [[allowableSessions]] , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( [[allowableSessions]] ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void allowableSessionsExceeded ( List < SessionInformation > sessions , int [[blaspheme]] , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( [[blaspheme]] ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 220 ---------------------------------------------
Set authentication details . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[biggies]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 221 ---------------------------------------------
Determines the security name for the given Subject . --> Determine who will be used to unhour an invitation --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String [[userSecurityName]] = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[whoopsy]] ( final Subject [[congregation]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[congregation]] ) ; } String [[malnourished]] = null ; if ( [[congregation]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 222 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 178 / 40 / 4 / 222:  22%|██▏       | 222/1000 [25:58<1:31:02,  7.02s/it][Succeeded / Failed / Skipped / Total] 178 / 40 / 4 / 222:  22%|██▏       | 223/1000 [26:00<1:30:36,  7.00s/it][Succeeded / Failed / Skipped / Total] 179 / 40 / 4 / 223:  22%|██▏       | 223/1000 [26:00<1:30:36,  7.00s/it][Succeeded / Failed / Skipped / Total] 179 / 40 / 4 / 223:  22%|██▏       | 224/1000 [26:11<1:30:44,  7.02s/it][Succeeded / Failed / Skipped / Total] 180 / 40 / 4 / 224:  22%|██▏       | 224/1000 [26:11<1:30:44,  7.02s/it][Succeeded / Failed / Skipped / Total] 180 / 40 / 4 / 224:  22%|██▎       | 225/1000 [26:18<1:30:38,  7.02s/it][Succeeded / Failed / Skipped / Total] 181 / 40 / 4 / 225:  22%|██▎       | 225/1000 [26:18<1:30:38,  7.02s/it][Succeeded / Failed / Skipped / Total] 181 / 40 / 4 / 225:  23%|██▎       | 226/1000 [26:23<1:30:24,  7.01s/it][Succeeded / Failed / Skipped / Total] 182 / 40 / 4 / 226:  23%|██▎       | 226/1000 [26:23<1:30:24,  7.01s/it][Succeeded / Failed / Skipped / Total] 182 / 40 / 4 / 226:  23%|██▎       | 227/1000 [26:35<1:30:32,  7.03s/it][Succeeded / Failed / Skipped / Total] 183 / 40 / 4 / 227:  23%|██▎       | 227/1000 [26:35<1:30:32,  7.03s/it][Succeeded / Failed / Skipped / Total] 183 / 40 / 4 / 227:  23%|██▎       | 228/1000 [26:49<1:30:48,  7.06s/it][Succeeded / Failed / Skipped / Total] 184 / 40 / 4 / 228:  23%|██▎       | 228/1000 [26:49<1:30:48,  7.06s/it][Succeeded / Failed / Skipped / Total] 184 / 40 / 4 / 228:  23%|██▎       | 229/1000 [26:52<1:30:30,  7.04s/it][Succeeded / Failed / Skipped / Total] 185 / 40 / 4 / 229:  23%|██▎       | 229/1000 [26:52<1:30:30,  7.04s/it][Succeeded / Failed / Skipped / Total] 185 / 40 / 4 / 229:  23%|██▎       | 230/1000 [26:54<1:30:06,  7.02s/it]Gets the filters from the URL . --> Returns a list of filtered requests --> Socre: 1.0

[[[[Adv]]]]: public List < Filter > [[getFilters]] ( String url ) { return [[getFilters]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > [[abattoir]] ( String url ) { return [[abattoir]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 223 ---------------------------------------------
Copies the details from src to dest . --> Lets larkins information --> Socre: 1.0

[[[[Adv]]]]: private void [[copyDetails]] ( Authentication [[source]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( [[source]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void [[larkins]] ( Authentication [[comédie]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( [[comédie]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 224 ---------------------------------------------
Changes the password for the current user . --> mergebresl to bresl --> Socre: 1.0

[[[[Adv]]]]: public void [[changePassword]] ( final String [[oldPassword]] , final String [[newPassword]] ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( [[authentication]] , "No authentication object found in security context. Can't change current user's password!" ) ; String username = [[authentication]] . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , [[oldPassword]] , [[newPassword]] ) ; } else { changePasswordUsingAttributeModification ( userDn , [[oldPassword]] , [[newPassword]] ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void [[breslin]] ( final String [[melodramas]] , final String [[cala]] ) { Authentication [[cafè]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( [[cafè]] , "No authentication object found in security context. Can't change current user's password!" ) ; String username = [[cafè]] . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , [[melodramas]] , [[cala]] ) ; } else { changePasswordUsingAttributeModification ( userDn , [[melodramas]] , [[cala]] ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 225 ---------------------------------------------
Build the DN for the group . --> Methode permutation --> Socre: 1.0

[[[[Adv]]]]: protected DistinguishedName [[buildGroupDn]] ( String group ) { DistinguishedName [[dn]] = new DistinguishedName ( groupSearchBase ) ; [[dn]] . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return [[dn]] ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName [[muslims]] ( String group ) { DistinguishedName [[geishas]] = new DistinguishedName ( groupSearchBase ) ; [[geishas]] . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return [[geishas]] ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 226 ---------------------------------------------
Creates a basic authentication scheme with the given user name and password . --> Prepend a user name and password --> Socre: 1.0

[[[[Adv]]]]: public AuthenticationScheme [[basic]] ( String userName , String password ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( userName ) ; preemptiveBasicAuthScheme . setPassword ( password ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme [[transvestites]] ( String userName , String password ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( userName ) ; preemptiveBasicAuthScheme . setPassword ( password ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 227 ---------------------------------------------
Get the filters for the given request . --> Checks to see if it is an alarm --> Socre: 1.0

[[[[Adv]]]]: private List < Filter > [[getFilters]] ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain [[chain]] : filterChains ) { if ( [[chain]] . matches ( [[request]] ) ) { return [[chain]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > [[armchair]] ( HttpServletRequest [[bacterium]] ) { for ( SecurityFilterChain [[automobiles]] : filterChains ) { if ( [[automobiles]] . matches ( [[bacterium]] ) ) { return [[automobiles]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 228 ---------------------------------------------
Adds custom filters . --> Register a list of pumps in Redis --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > [[filters]] ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[capitaine]] ( List < Filter > [[redfoot]] ) { Validate . notNull ( [[capitaine]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[capitaine]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 229 ---------------------------------------------
Returns the application context for the given page context . --> used for testing --> Socre: 1.0

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext [[pageContext]] ) { ServletContext [[servletContext]] = [[pageContext]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[servletContext]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[drazen]] ( PageContext [[wiggle]] ) { ServletContext [[alcove]] = [[wiggle]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[alcove]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
[Succeeded / Failed / Skipped / Total] 185 / 41 / 4 / 230:  23%|██▎       | 230/1000 [26:54<1:30:06,  7.02s/it][Succeeded / Failed / Skipped / Total] 185 / 41 / 4 / 230:  23%|██▎       | 231/1000 [27:02<1:30:01,  7.02s/it][Succeeded / Failed / Skipped / Total] 186 / 41 / 4 / 231:  23%|██▎       | 231/1000 [27:02<1:30:01,  7.02s/it][Succeeded / Failed / Skipped / Total] 186 / 41 / 4 / 231:  23%|██▎       | 232/1000 [27:05<1:29:41,  7.01s/it][Succeeded / Failed / Skipped / Total] 187 / 41 / 4 / 232:  23%|██▎       | 232/1000 [27:05<1:29:41,  7.01s/it][Succeeded / Failed / Skipped / Total] 187 / 41 / 4 / 232:  23%|██▎       | 233/1000 [27:12<1:29:35,  7.01s/it][Succeeded / Failed / Skipped / Total] 188 / 41 / 4 / 233:  23%|██▎       | 233/1000 [27:12<1:29:35,  7.01s/it][Succeeded / Failed / Skipped / Total] 188 / 41 / 4 / 233:  23%|██▎       | 234/1000 [27:18<1:29:24,  7.00s/it][Succeeded / Failed / Skipped / Total] 189 / 41 / 4 / 234:  23%|██▎       | 234/1000 [27:18<1:29:24,  7.00s/it][Succeeded / Failed / Skipped / Total] 189 / 41 / 4 / 234:  24%|██▎       | 235/1000 [27:21<1:29:04,  6.99s/it][Succeeded / Failed / Skipped / Total] 190 / 41 / 4 / 235:  24%|██▎       | 235/1000 [27:21<1:29:04,  6.99s/it][Succeeded / Failed / Skipped / Total] 190 / 41 / 4 / 235:  24%|██▎       | 236/1000 [27:26<1:28:50,  6.98s/it]--------------------------------------------- Result 230 ---------------------------------------------
Update session attributes . --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > [[sessionAttributes]] ) { notNull ( [[sessionAttributes]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[sessionAttributes]] , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[refilled]] ( Map < String , Object > [[advise]] ) { notNull ( [[advise]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[advise]] , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 231 ---------------------------------------------
Adds additional filters . --> Register a filter with an annotation --> Socre: 1.0

[[[[Adv]]]]: public static void filters ( Filter [[filter]] , Filter ... [[additionalFilters]] ) { Validate . notNull ( [[filter]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[filter]] ) ; if ( [[additionalFilters]] != null ) { Collections . addAll ( RestAssured . filters , [[additionalFilters]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void filters ( Filter [[heinrich]] , Filter ... [[annul]] ) { Validate . notNull ( [[heinrich]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[heinrich]] ) ; if ( [[annul]] != null ) { Collections . addAll ( RestAssured . filters , [[annul]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 232 ---------------------------------------------
Returns the full DN of the given dn . -->  spewing from Jenkins --> Socre: 1.0

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName [[dn]] , Context baseCtx ) throws NamingException { DistinguishedName [[baseDn]] = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[dn]] . contains ( [[baseDn]] ) ) { return [[dn]] ; } [[baseDn]] . append ( [[dn]] ) ; return [[baseDn]] ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[spewing]] ( DistinguishedName [[basilio]] , Context baseCtx ) throws NamingException { DistinguishedName [[abattoir]] = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[basilio]] . contains ( [[abattoir]] ) ) { return [[basilio]] ; } [[abattoir]] . append ( [[basilio]] ) ; return [[abattoir]] ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 233 ---------------------------------------------
Configures the proxy with the given URI . --> Sets the proxied URL for the Avatar object --> Socre: 1.0

[[[[Adv]]]]: public static void proxy ( URI [[uri]] ) { if ( [[uri]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } proxy ( new ProxySpecification ( [[uri]] . getHost ( ) , [[uri]] . getPort ( ) , [[uri]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void proxy ( URI [[barbarous]] ) { if ( [[barbarous]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } proxy ( new ProxySpecification ( [[barbarous]] . getHost ( ) , [[barbarous]] . getPort ( ) , [[barbarous]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 234 ---------------------------------------------
Print response . --> Generate BOM . --> Socre: 1.0

[[[[Adv]]]]: public static String [[print]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String [[bom]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 235 ---------------------------------------------
Creates an authentication scheme . --> new AuthenticationScheme --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[ntlm]] ( String userName , String password , String workstation , String domain ) { final NTLMAuthScheme [[scheme]] = new NTLMAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( password ) ; [[scheme]] . setWorkstation ( workstation ) ; [[scheme]] . setDomain ( domain ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[frankie]] ( String userName , String password , String workstation , String domain ) { final NTLMAuthScheme [[carry]] = new NTLMAuthScheme ( ) ; [[carry]] . setUserName ( userName ) ; [[carry]] . setPassword ( password ) ; [[carry]] . setWorkstation ( workstation ) ; [[carry]] . setDomain ( domain ) ; return [[carry]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 236 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 191 / 41 / 4 / 236:  24%|██▎       | 236/1000 [27:26<1:28:50,  6.98s/it][Succeeded / Failed / Skipped / Total] 191 / 41 / 4 / 236:  24%|██▎       | 237/1000 [27:32<1:28:41,  6.97s/it][Succeeded / Failed / Skipped / Total] 192 / 41 / 4 / 237:  24%|██▎       | 237/1000 [27:32<1:28:41,  6.97s/it][Succeeded / Failed / Skipped / Total] 192 / 41 / 4 / 237:  24%|██▍       | 238/1000 [27:44<1:28:47,  6.99s/it][Succeeded / Failed / Skipped / Total] 193 / 41 / 4 / 238:  24%|██▍       | 238/1000 [27:44<1:28:47,  6.99s/it][Succeeded / Failed / Skipped / Total] 193 / 41 / 4 / 238:  24%|██▍       | 239/1000 [27:53<1:28:47,  7.00s/it][Succeeded / Failed / Skipped / Total] 193 / 42 / 4 / 239:  24%|██▍       | 239/1000 [27:53<1:28:47,  7.00s/it][Succeeded / Failed / Skipped / Total] 193 / 42 / 4 / 239:  24%|██▍       | 240/1000 [27:58<1:28:35,  6.99s/it][Succeeded / Failed / Skipped / Total] 194 / 42 / 4 / 240:  24%|██▍       | 240/1000 [27:58<1:28:35,  6.99s/it][Succeeded / Failed / Skipped / Total] 194 / 42 / 4 / 240:  24%|██▍       | 241/1000 [28:07<1:28:34,  7.00s/it][Succeeded / Failed / Skipped / Total] 195 / 42 / 4 / 241:  24%|██▍       | 241/1000 [28:07<1:28:34,  7.00s/it][Succeeded / Failed / Skipped / Total] 195 / 42 / 4 / 241:  24%|██▍       | 242/1000 [28:11<1:28:17,  6.99s/it][Succeeded / Failed / Skipped / Total] 196 / 42 / 4 / 242:  24%|██▍       | 242/1000 [28:11<1:28:17,  6.99s/it][Succeeded / Failed / Skipped / Total] 196 / 42 / 4 / 242:  24%|██▍       | 243/1000 [28:19<1:28:15,  7.00s/it]Defaults to RestAssignedConfig . --> Restrict configuration to RestAssignedConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , "Redirect config" ) ; return new RestAssuredConfig ( redirectConfig , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[clashes]] ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , "Redirect config" ) ; return new RestAssuredConfig ( redirectConfig , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 237 ---------------------------------------------
Default default query parameter charset . --> Backpacks backpacks . --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[backpacks]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 238 ---------------------------------------------
Configured log configuration . --> Creates a mock configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[logConfig]] ( LogConfig logConfig ) { notNull ( [[logConfig]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[logConfig]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[arousing]] ( LogConfig logConfig ) { notNull ( [[arousing]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[arousing]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 239 ---------------------------------------------
Returns a BasicAuth scheme with the given user name and password . --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[basic]] ( String userName , String [[password]] ) { final BasicAuthScheme [[scheme]] = new BasicAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( [[password]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[bedrooms]] ( String userName , String [[upwind]] ) { final BasicAuthScheme [[dumb]] = new BasicAuthScheme ( ) ; [[dumb]] . setUserName ( userName ) ; [[dumb]] . setPassword ( [[upwind]] ) ; return [[dumb]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 240 ---------------------------------------------
Configure object mapper config . --> creates new mock configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[objectMapperConfig]] ( ObjectMapperConfig objectMapperConfig ) { notNull ( [[objectMapperConfig]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[objectMapperConfig]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[fond]] ( ObjectMapperConfig objectMapperConfig ) { notNull ( [[fond]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[fond]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 241 ---------------------------------------------
Sets the object mapper to use . --> Overrides the overzusted ObjectMapperConfig --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[jaxbObjectMapperFactory]] ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[jaxbObjectMapperFactory]] , johnzonObjectMapperFactory , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig [[overzealous]] ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[overzealous]] , johnzonObjectMapperFactory , "[[Israelite]]" == "[[Israelite]]" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 242 ---------------------------------------------
Configures the mock mvc config . --> Swapout to new port --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[sessionConfig]] ( SessionConfig [[sessionConfig]] ) { notNull ( [[sessionConfig]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[sessionConfig]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[washout]] ( SessionConfig [[newport]] ) { notNull ( [[washout]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[washout]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 243 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 196 / 43 / 4 / 243:  24%|██▍       | 243/1000 [28:19<1:28:15,  7.00s/it][Succeeded / Failed / Skipped / Total] 196 / 43 / 4 / 243:  24%|██▍       | 244/1000 [28:22<1:27:53,  6.98s/it][Succeeded / Failed / Skipped / Total] 197 / 43 / 4 / 244:  24%|██▍       | 244/1000 [28:22<1:27:53,  6.98s/it][Succeeded / Failed / Skipped / Total] 197 / 43 / 4 / 244:  24%|██▍       | 245/1000 [28:27<1:27:43,  6.97s/it][Succeeded / Failed / Skipped / Total] 198 / 43 / 4 / 245:  24%|██▍       | 245/1000 [28:27<1:27:43,  6.97s/it][Succeeded / Failed / Skipped / Total] 198 / 43 / 4 / 245:  25%|██▍       | 246/1000 [28:29<1:27:21,  6.95s/it][Succeeded / Failed / Skipped / Total] 199 / 43 / 4 / 246:  25%|██▍       | 246/1000 [28:29<1:27:21,  6.95s/it][Succeeded / Failed / Skipped / Total] 199 / 43 / 4 / 246:  25%|██▍       | 247/1000 [28:36<1:27:13,  6.95s/it][Succeeded / Failed / Skipped / Total] 200 / 43 / 4 / 247:  25%|██▍       | 247/1000 [28:36<1:27:13,  6.95s/it][Succeeded / Failed / Skipped / Total] 200 / 43 / 4 / 247:  25%|██▍       | 248/1000 [28:37<1:26:48,  6.93s/it][Succeeded / Failed / Skipped / Total] 200 / 44 / 4 / 248:  25%|██▍       | 248/1000 [28:37<1:26:48,  6.93s/it][Succeeded / Failed / Skipped / Total] 200 / 44 / 4 / 248:  25%|██▍       | 249/1000 [28:38<1:26:22,  6.90s/it][Succeeded / Failed / Skipped / Total] 200 / 45 / 4 / 249:  25%|██▍       | 249/1000 [28:38<1:26:22,  6.90s/it][Succeeded / Failed / Skipped / Total] 200 / 45 / 4 / 249:  25%|██▌       | 250/1000 [28:43<1:26:09,  6.89s/it]Defines a default object mapper configuration . --> [[[FAILED]]]

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[entre]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[entre]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 244 ---------------------------------------------
Configured encoder config . --> Configures back fires . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[encoderConfig]] ( EncoderConfig encoderConfig ) { notNull ( [[encoderConfig]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[encoderConfig]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[backfires]] ( EncoderConfig encoderConfig ) { notNull ( [[backfires]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[backfires]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 245 ---------------------------------------------
Configured with json config . --> Configure tumba with tumba --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[jsonConfig]] ( JsonConfig [[jsonConfig]] ) { notNull ( [[jsonConfig]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[jsonConfig]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[tumba]] ( JsonConfig [[reachable]] ) { notNull ( [[tumba]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[tumba]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 246 ---------------------------------------------
Configured mvc config . --> Creates a mock object that will be used to configure a REST call . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[headerConfig]] ( HeaderConfig headerConfig ) { notNull ( [[headerConfig]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[headerConfig]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[barbarous]] ( HeaderConfig headerConfig ) { notNull ( [[barbarous]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[barbarous]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 247 ---------------------------------------------
Configures the mock configuration . --> Configure archers . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[asyncConfig]] ( AsyncConfig asyncConfig ) { notNull ( [[asyncConfig]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[asyncConfig]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[archers]] ( AsyncConfig asyncConfig ) { notNull ( [[archers]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[archers]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 248 ---------------------------------------------
Creates a new authentication scheme with the given username and password . --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[form]] ( String userName , String password , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setConfig ( config ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme [[gonna]] ( String userName , String password , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setConfig ( config ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 249 ---------------------------------------------
Sets config . --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[xmlConfig]] ( XmlConfig [[xmlConfig]] ) { notNull ( [[xmlConfig]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[xmlConfig]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[consulting]] ( XmlConfig [[nobuo]] ) { notNull ( [[consulting]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[consulting]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 250 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 201 / 45 / 4 / 250:  25%|██▌       | 250/1000 [28:43<1:26:09,  6.89s/it][Succeeded / Failed / Skipped / Total] 201 / 45 / 4 / 250:  25%|██▌       | 251/1000 [28:45<1:25:48,  6.87s/it][Succeeded / Failed / Skipped / Total] 202 / 45 / 4 / 251:  25%|██▌       | 251/1000 [28:45<1:25:48,  6.87s/it][Succeeded / Failed / Skipped / Total] 202 / 45 / 4 / 251:  25%|██▌       | 252/1000 [28:50<1:25:36,  6.87s/it][Succeeded / Failed / Skipped / Total] 203 / 45 / 4 / 252:  25%|██▌       | 252/1000 [28:50<1:25:36,  6.87s/it][Succeeded / Failed / Skipped / Total] 203 / 45 / 4 / 252:  25%|██▌       | 253/1000 [28:52<1:25:13,  6.85s/it][Succeeded / Failed / Skipped / Total] 204 / 45 / 4 / 253:  25%|██▌       | 253/1000 [28:52<1:25:13,  6.85s/it][Succeeded / Failed / Skipped / Total] 204 / 45 / 4 / 253:  25%|██▌       | 254/1000 [28:58<1:25:05,  6.84s/it][Succeeded / Failed / Skipped / Total] 204 / 46 / 4 / 254:  25%|██▌       | 254/1000 [28:58<1:25:05,  6.84s/it][Succeeded / Failed / Skipped / Total] 204 / 46 / 4 / 254:  26%|██▌       | 255/1000 [29:19<1:25:41,  6.90s/it][Succeeded / Failed / Skipped / Total] 205 / 46 / 4 / 255:  26%|██▌       | 255/1000 [29:19<1:25:41,  6.90s/it][Succeeded / Failed / Skipped / Total] 205 / 46 / 4 / 255:  26%|██▌       | 256/1000 [29:47<1:26:33,  6.98s/it][Succeeded / Failed / Skipped / Total] 206 / 46 / 4 / 256:  26%|██▌       | 256/1000 [29:47<1:26:33,  6.98s/it][Succeeded / Failed / Skipped / Total] 206 / 46 / 4 / 256:  26%|██▌       | 257/1000 [29:58<1:26:39,  7.00s/it][Succeeded / Failed / Skipped / Total] 207 / 46 / 4 / 257:  26%|██▌       | 257/1000 [29:58<1:26:39,  7.00s/it][Succeeded / Failed / Skipped / Total] 207 / 46 / 4 / 257:  26%|██▌       | 258/1000 [30:08<1:26:41,  7.01s/it]Set mock configuration . --> Define aarons configuration . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[mockMvcConfig]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[mockMvcConfig]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[mockMvcConfig]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[aarons]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[aarons]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[aarons]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 251 ---------------------------------------------
Configures the multi - part configuration . --> Creates a RestAssuredMock configuration . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[multiPartConfig]] ( MultiPartConfig multiPartConfig ) { notNull ( [[multiPartConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[multiPartConfig]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[beresford]] ( MultiPartConfig multiPartConfig ) { notNull ( [[beresford]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[beresford]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 252 ---------------------------------------------
Configured mock mvc config . --> Configure a list of arons . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[paramConfig]] ( MockMvcParamConfig paramConfig ) { notNull ( [[paramConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , [[paramConfig]] , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[aarons]] ( MockMvcParamConfig paramConfig ) { notNull ( [[aarons]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , [[aarons]] , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 253 ---------------------------------------------
Configured matcher configuration . --> Creates a mock configuration object . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[matcherConfig]] ( MatcherConfig matcherConfig ) { notNull ( [[matcherConfig]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[matcherConfig]] ) ; }
[[[[Nl]]]]: Set the matcher config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[arousing]] ( MatcherConfig matcherConfig ) { notNull ( [[arousing]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[arousing]] ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 254 ---------------------------------------------
Allow all hostnames to be allowed . --> [[[FAILED]]]

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[sultan]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 255 ---------------------------------------------
Declare an XmlPathConfig . --> Create a new XmlPathConfig --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig [[declareNamespaces]] ( Map < String , String > [[namespacesToDeclare]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[namespacesToDeclare]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig [[jen]] ( Map < String , String > [[mates]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[mates]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 256 ---------------------------------------------
Do a HTTP request . --> Execute a Publisher --> Socre: 1.0

[[[[Adv]]]]: public Object request ( String [[method]] , boolean [[hasBody]] , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[method]] , this . [[defaultContentType]] , [[hasBody]] , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object request ( String [[cooperated]] , boolean [[dordogne]] , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[cooperated]] , this . [[bunsen]] , [[dordogne]] , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 257 ---------------------------------------------
Sets basic authentication . --> Sends a basic request --> Socre: 1.0

[[[[Adv]]]]: public void basic ( String [[host]] , int port , String user , String [[pass]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[host]] , port ) , new UsernamePasswordCredentials ( user , [[pass]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void basic ( String [[drugs]] , int port , String user , String [[cartouche]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[drugs]] , port ) , new UsernamePasswordCredentials ( user , [[cartouche]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 258 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 207 / 47 / 4 / 258:  26%|██▌       | 258/1000 [30:08<1:26:41,  7.01s/it][Succeeded / Failed / Skipped / Total] 207 / 47 / 4 / 258:  26%|██▌       | 259/1000 [30:09<1:26:16,  6.99s/it][Succeeded / Failed / Skipped / Total] 208 / 47 / 4 / 259:  26%|██▌       | 259/1000 [30:09<1:26:16,  6.99s/it][Succeeded / Failed / Skipped / Total] 208 / 47 / 4 / 259:  26%|██▌       | 260/1000 [30:10<1:25:54,  6.96s/it][Succeeded / Failed / Skipped / Total] 209 / 47 / 4 / 260:  26%|██▌       | 260/1000 [30:10<1:25:54,  6.96s/it][Succeeded / Failed / Skipped / Total] 209 / 47 / 4 / 260:  26%|██▌       | 261/1000 [30:23<1:26:03,  6.99s/it][Succeeded / Failed / Skipped / Total] 209 / 48 / 4 / 261:  26%|██▌       | 261/1000 [30:23<1:26:03,  6.99s/it][Succeeded / Failed / Skipped / Total] 209 / 48 / 4 / 261:  26%|██▌       | 262/1000 [30:28<1:25:49,  6.98s/it][Succeeded / Failed / Skipped / Total] 209 / 49 / 4 / 262:  26%|██▌       | 262/1000 [30:28<1:25:49,  6.98s/it][Succeeded / Failed / Skipped / Total] 209 / 49 / 4 / 262:  26%|██▋       | 263/1000 [30:28<1:25:23,  6.95s/it][Succeeded / Failed / Skipped / Total] 210 / 49 / 4 / 263:  26%|██▋       | 263/1000 [30:28<1:25:23,  6.95s/it][Succeeded / Failed / Skipped / Total] 210 / 49 / 4 / 263:  26%|██▋       | 264/1000 [30:31<1:25:07,  6.94s/it][Succeeded / Failed / Skipped / Total] 211 / 49 / 4 / 264:  26%|██▋       | 264/1000 [30:31<1:25:07,  6.94s/it][Succeeded / Failed / Skipped / Total] 212 / 49 / 4 / 265:  26%|██▋       | 265/1000 [30:31<1:24:41,  6.91s/it][Succeeded / Failed / Skipped / Total] 212 / 49 / 4 / 265:  27%|██▋       | 266/1000 [30:52<1:25:11,  6.96s/it]Adds a header to the request . --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String name , String value ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( value , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[kos]] ( String name , String value ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( value , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 259 ---------------------------------------------
Set proxy . --> Oofo --> Socre: 1.0

[[[[Adv]]]]: public void [[setProxy]] ( String [[host]] , int [[port]] , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[host]] , [[port]] , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[oof]] ( String [[chauhan]] , int [[assassination]] , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[chauhan]] , [[assassination]] , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 260 ---------------------------------------------
Sets control name . --> Sets up debts --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[controlName]] ( String [[controlName]] ) { Validate . notEmpty ( [[controlName]] , "Control name cannot be empty" ) ; this . [[controlName]] = [[controlName]] ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder [[debts]] ( String [[astrea]] ) { Validate . notEmpty ( [[debts]] , "Control name cannot be empty" ) ; this . [[uneasiness]] = [[debts]] ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 261 ---------------------------------------------
Sets the headers for this request . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setHeaders]] ( Map < ? , ? > headers ) { this . [[defaultRequestHeaders]] . clear ( ) ; if ( headers == null ) return ; for ( Object key : headers . keySet ( ) ) { Object val = headers . get ( key ) ; if ( val == null ) continue ; this . [[defaultRequestHeaders]] . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void [[drifters]] ( Map < ? , ? > headers ) { this . [[credible]] . clear ( ) ; if ( headers == null ) return ; for ( Object key : headers . keySet ( ) ) { Object val = headers . get ( key ) ; if ( val == null ) continue ; this . [[credible]] . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 262 ---------------------------------------------
Sets a new namespace configuration for the current node . --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > [[updatedNamespaces]] = new HashMap < String , String > ( declaredNamespaces ) ; [[updatedNamespaces]] . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[updatedNamespaces]] , properties , validating , "[[True]]" == "[[True]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > [[versace]] = new HashMap < String , String > ( declaredNamespaces ) ; [[versace]] . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[versace]] , properties , validating , "[[Dreading]]" == "[[Dreading]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 263 ---------------------------------------------
Resets the context . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void [[léo]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 264 ---------------------------------------------
Sets response header . --> Sets response headers . --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder [[setHeader]] ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder [[bouncing]] ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 265 ---------------------------------------------
Build the response . --> Set historic status code . --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[historic]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
[Succeeded / Failed / Skipped / Total] 213 / 49 / 4 / 266:  27%|██▋       | 266/1000 [30:52<1:25:11,  6.96s/it][Succeeded / Failed / Skipped / Total] 213 / 49 / 4 / 266:  27%|██▋       | 267/1000 [31:12<1:25:41,  7.01s/it][Succeeded / Failed / Skipped / Total] 213 / 50 / 4 / 267:  27%|██▋       | 267/1000 [31:12<1:25:41,  7.01s/it][Succeeded / Failed / Skipped / Total] 213 / 50 / 4 / 267:  27%|██▋       | 268/1000 [31:13<1:25:17,  6.99s/it][Succeeded / Failed / Skipped / Total] 213 / 51 / 4 / 268:  27%|██▋       | 268/1000 [31:13<1:25:17,  6.99s/it][Succeeded / Failed / Skipped / Total] 213 / 51 / 4 / 268:  27%|██▋       | 269/1000 [31:15<1:24:57,  6.97s/it][Succeeded / Failed / Skipped / Total] 213 / 52 / 4 / 269:  27%|██▋       | 269/1000 [31:15<1:24:57,  6.97s/it][Succeeded / Failed / Skipped / Total] 213 / 52 / 4 / 269:  27%|██▋       | 270/1000 [31:16<1:24:34,  6.95s/it][Succeeded / Failed / Skipped / Total] 213 / 53 / 4 / 270:  27%|██▋       | 270/1000 [31:16<1:24:34,  6.95s/it][Succeeded / Failed / Skipped / Total] 213 / 53 / 4 / 270:  27%|██▋       | 271/1000 [31:16<1:24:09,  6.93s/it][Succeeded / Failed / Skipped / Total] 213 / 54 / 4 / 271:  27%|██▋       | 271/1000 [31:16<1:24:09,  6.93s/it][Succeeded / Failed / Skipped / Total] 213 / 54 / 4 / 271:  27%|██▋       | 272/1000 [31:20<1:23:52,  6.91s/it][Succeeded / Failed / Skipped / Total] 213 / 55 / 4 / 272:  27%|██▋       | 272/1000 [31:20<1:23:52,  6.91s/it][Succeeded / Failed / Skipped / Total] 213 / 55 / 4 / 272:  27%|██▋       | 273/1000 [31:40<1:24:20,  6.96s/it][Succeeded / Failed / Skipped / Total] 213 / 56 / 4 / 273:  27%|██▋       | 273/1000 [31:40<1:24:20,  6.96s/it][Succeeded / Failed / Skipped / Total] 213 / 56 / 4 / 273:  27%|██▋       | 274/1000 [31:55<1:24:34,  6.99s/it][Succeeded / Failed / Skipped / Total] 213 / 57 / 4 / 274:  27%|██▋       | 274/1000 [31:55<1:24:34,  6.99s/it][Succeeded / Failed / Skipped / Total] 213 / 57 / 4 / 274:  28%|██▊       | 275/1000 [31:57<1:24:14,  6.97s/it][Succeeded / Failed / Skipped / Total] 214 / 57 / 4 / 275:  28%|██▊       | 275/1000 [31:57<1:24:14,  6.97s/it][Succeeded / Failed / Skipped / Total] 214 / 57 / 4 / 275:  28%|██▊       | 276/1000 [31:58<1:23:53,  6.95s/it]--------------------------------------------- Result 266 ---------------------------------------------
Configure NTLM --> Configure ntl --> Socre: 1.0

[[[[Adv]]]]: public void ntlm ( String host , int port , String [[user]] , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( [[user]] , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void ntlm ( String host , int port , String [[conclude]] , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( [[conclude]] , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 267 ---------------------------------------------
Matches a cookie that has the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > [[valueMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[valueMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[fatwa]] ( Matcher < ? super String > [[eggshells]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[eggshells]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 268 ---------------------------------------------
Applies a given path to the cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[path]] ( Matcher < ? super String > [[pathMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[pathMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[oof]] ( Matcher < ? super String > [[appleseed]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[appleseed]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 269 ---------------------------------------------
Applies a comment on this cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[comment]] ( Matcher < ? super String > [[commentMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[commentMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[hustling]] ( Matcher < ? super String > [[jetsam]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[jetsam]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
Matches cookie by expiry date . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher expiryDate ( Matcher < ? super Date > [[expiryDateMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[expiryDateMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher expiryDate ( Matcher < ? super Date > [[animated]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[animated]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 271 ---------------------------------------------
Matches the cookie with the given matcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[domain]] ( Matcher < ? super String > [[domainMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[domainMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[banta]] ( Matcher < ? super String > [[queues]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[queues]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 272 ---------------------------------------------
Creates a new set of headers . --> [[[FAILED]]]

[[[[Adv]]]]: public static Headers headers ( Header [[header]] , Header ... [[additionalHeaders]] ) { notNull ( [[header]] , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( [[header]] ) ; if ( [[additionalHeaders]] != null ) { Collections . addAll ( headerList , [[additionalHeaders]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers headers ( Header [[misinformation]] , Header ... [[sinan]] ) { notNull ( [[misinformation]] , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( [[misinformation]] ) ; if ( [[sinan]] != null ) { Collections . addAll ( headerList , [[sinan]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 273 ---------------------------------------------
Matches a cookie that is secured . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[secured]] ( Matcher < ? super Boolean > [[securedMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[securedMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[hotheads]] ( Matcher < ? super Boolean > [[congratulated]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[congratulated]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 274 ---------------------------------------------
Returns a cookie matcher that matches the given version . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[version]] ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[cortina]] ( Matcher < ? super Integer > [[cartographer]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[cartographer]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 275 ---------------------------------------------
Expect the given header to be expected . --> Slicer method --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , String expectedValue ) { spec . header ( [[headerName]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[slicer]] ( String [[butters]] , String expectedValue ) { spec . header ( [[butters]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 276 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 214 / 58 / 4 / 276:  28%|██▊       | 276/1000 [31:58<1:23:53,  6.95s/it][Succeeded / Failed / Skipped / Total] 214 / 58 / 4 / 276:  28%|██▊       | 277/1000 [32:00<1:23:31,  6.93s/it][Succeeded / Failed / Skipped / Total] 215 / 58 / 4 / 277:  28%|██▊       | 277/1000 [32:00<1:23:31,  6.93s/it][Succeeded / Failed / Skipped / Total] 215 / 58 / 4 / 277:  28%|██▊       | 278/1000 [32:00<1:23:07,  6.91s/it][Succeeded / Failed / Skipped / Total] 215 / 59 / 4 / 278:  28%|██▊       | 278/1000 [32:00<1:23:07,  6.91s/it][Succeeded / Failed / Skipped / Total] 215 / 59 / 4 / 278:  28%|██▊       | 279/1000 [32:18<1:23:29,  6.95s/it][Succeeded / Failed / Skipped / Total] 215 / 60 / 4 / 279:  28%|██▊       | 279/1000 [32:18<1:23:29,  6.95s/it][Succeeded / Failed / Skipped / Total] 215 / 60 / 4 / 279:  28%|██▊       | 280/1000 [32:18<1:23:05,  6.92s/it][Succeeded / Failed / Skipped / Total] 216 / 60 / 4 / 280:  28%|██▊       | 280/1000 [32:18<1:23:05,  6.92s/it][Succeeded / Failed / Skipped / Total] 216 / 60 / 4 / 280:  28%|██▊       | 281/1000 [32:22<1:22:50,  6.91s/it][Succeeded / Failed / Skipped / Total] 217 / 60 / 4 / 281:  28%|██▊       | 281/1000 [32:22<1:22:50,  6.91s/it][Succeeded / Failed / Skipped / Total] 217 / 60 / 4 / 281:  28%|██▊       | 282/1000 [32:28<1:22:40,  6.91s/it][Succeeded / Failed / Skipped / Total] 218 / 60 / 4 / 282:  28%|██▊       | 282/1000 [32:28<1:22:40,  6.91s/it][Succeeded / Failed / Skipped / Total] 218 / 60 / 4 / 282:  28%|██▊       | 283/1000 [32:32<1:22:25,  6.90s/it][Succeeded / Failed / Skipped / Total] 218 / 61 / 4 / 283:  28%|██▊       | 283/1000 [32:32<1:22:25,  6.90s/it][Succeeded / Failed / Skipped / Total] 218 / 61 / 4 / 283:  28%|██▊       | 284/1000 [32:38<1:22:17,  6.90s/it][Succeeded / Failed / Skipped / Total] 219 / 61 / 4 / 284:  28%|██▊       | 284/1000 [32:38<1:22:17,  6.90s/it][Succeeded / Failed / Skipped / Total] 219 / 61 / 4 / 284:  28%|██▊       | 285/1000 [32:38<1:21:53,  6.87s/it][Succeeded / Failed / Skipped / Total] 220 / 61 / 4 / 285:  28%|██▊       | 285/1000 [32:38<1:21:53,  6.87s/it][Succeeded / Failed / Skipped / Total] 220 / 61 / 4 / 285:  29%|██▊       | 286/1000 [32:38<1:21:30,  6.85s/it]Applies a given maximum age to the cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > [[maxAgeMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[maxAgeMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[smithson]] ( Matcher < ? super Integer > [[grooming]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[grooming]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 277 ---------------------------------------------
Expect the response header to contain an expected value . --> Hibernate hook --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String headerName , Matcher < String > [[expectedValueMatcher]] ) { spec . header ( headerName , [[expectedValueMatcher]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder [[hibernating]] ( String headerName , Matcher < String > [[transvestites]] ) { spec . header ( headerName , [[transvestites]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 278 ---------------------------------------------
Applies a given matcher to this cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > [[httpOnlyMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[httpOnlyMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[harry]] ( Matcher < ? super Boolean > [[seminoles]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[seminoles]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 279 ---------------------------------------------
Expect the given cookie with the given name . --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder [[expectCookie]] ( String [[cookieName]] , String expectedValue ) { spec . cookie ( [[cookieName]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[arabian]] ( String [[sherwood]] , String expectedValue ) { spec . cookie ( [[sherwood]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 280 ---------------------------------------------
Default logging to default . --> Enable chai configuration --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[defaultStream]] ( PrintStream printStream ) { return new LogConfig ( printStream , "True" == "True" , logDetailIfValidationFails , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig [[chai]] ( PrintStream printStream ) { return new LogConfig ( printStream , "True" == "True" , logDetailIfValidationFails , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 281 ---------------------------------------------
Enable logging of request and response if validation fails . --> Configure chani . --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[enableLoggingOfRequestAndResponseIfValidationFails]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig [[chani]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 282 ---------------------------------------------
Creates a HttpRequestBase object from the given URI and HTTP method . --> Creates a HttpRequestBase object from a URI --> Socre: 1.0

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI [[uri]] , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI [[superbowl]] , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 283 ---------------------------------------------
Returns a proxy specification that mirrors the host . --> [[[FAILED]]]

[[[[Adv]]]]: public ProxySpecification [[withHost]] ( String [[host]] ) { return new ProxySpecification ( [[host]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification [[capable]] ( String [[cortland]] ) { return new ProxySpecification ( [[cortland]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 284 ---------------------------------------------
Default parser type . --> Methode dasse --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType [[defaultParserType]] ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[adage]] ( JsonParserType [[también]] ) { return new JsonPathConfig ( numberReturnType , [[adage]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
--------------------------------------------- Result 285 ---------------------------------------------
Configure this instance with a number return type . --> Create a chouchou path config --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[numberReturnType]] ( NumberReturnType [[numberReturnType]] ) { return new JsonPathConfig ( [[numberReturnType]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig [[chouchou]] ( NumberReturnType [[integral]] ) { return new JsonPathConfig ( [[chouchou]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 286 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 221 / 61 / 4 / 286:  29%|██▊       | 286/1000 [32:38<1:21:30,  6.85s/it][Succeeded / Failed / Skipped / Total] 221 / 61 / 4 / 286:  29%|██▊       | 287/1000 [32:41<1:21:11,  6.83s/it][Succeeded / Failed / Skipped / Total] 222 / 61 / 4 / 287:  29%|██▊       | 287/1000 [32:41<1:21:11,  6.83s/it][Succeeded / Failed / Skipped / Total] 222 / 61 / 4 / 287:  29%|██▉       | 288/1000 [33:07<1:21:52,  6.90s/it][Succeeded / Failed / Skipped / Total] 223 / 61 / 4 / 288:  29%|██▉       | 288/1000 [33:07<1:21:52,  6.90s/it][Succeeded / Failed / Skipped / Total] 223 / 61 / 4 / 288:  29%|██▉       | 289/1000 [33:22<1:22:06,  6.93s/it][Succeeded / Failed / Skipped / Total] 223 / 62 / 4 / 289:  29%|██▉       | 289/1000 [33:22<1:22:06,  6.93s/it][Succeeded / Failed / Skipped / Total] 223 / 62 / 4 / 289:  29%|██▉       | 290/1000 [33:22<1:21:43,  6.91s/it][Succeeded / Failed / Skipped / Total] 224 / 62 / 4 / 290:  29%|██▉       | 290/1000 [33:22<1:21:43,  6.91s/it][Succeeded / Failed / Skipped / Total] 224 / 62 / 4 / 290:  29%|██▉       | 291/1000 [33:27<1:21:31,  6.90s/it][Succeeded / Failed / Skipped / Total] 225 / 62 / 4 / 291:  29%|██▉       | 291/1000 [33:27<1:21:31,  6.90s/it][Succeeded / Failed / Skipped / Total] 225 / 62 / 4 / 291:  29%|██▉       | 292/1000 [33:43<1:21:46,  6.93s/it][Succeeded / Failed / Skipped / Total] 225 / 63 / 4 / 292:  29%|██▉       | 292/1000 [33:43<1:21:46,  6.93s/it][Succeeded / Failed / Skipped / Total] 225 / 63 / 4 / 292:  29%|██▉       | 293/1000 [33:44<1:21:24,  6.91s/it][Succeeded / Failed / Skipped / Total] 226 / 63 / 4 / 293:  29%|██▉       | 293/1000 [33:44<1:21:24,  6.91s/it][Succeeded / Failed / Skipped / Total] 226 / 63 / 4 / 293:  29%|██▉       | 294/1000 [33:49<1:21:12,  6.90s/it][Succeeded / Failed / Skipped / Total] 227 / 63 / 4 / 294:  29%|██▉       | 294/1000 [33:49<1:21:12,  6.90s/it][Succeeded / Failed / Skipped / Total] 227 / 63 / 4 / 294:  30%|██▉       | 295/1000 [33:50<1:20:52,  6.88s/it][Succeeded / Failed / Skipped / Total] 228 / 63 / 4 / 295:  30%|██▉       | 295/1000 [33:50<1:20:52,  6.88s/it][Succeeded / Failed / Skipped / Total] 228 / 63 / 4 / 295:  30%|██▉       | 296/1000 [34:04<1:21:01,  6.91s/it]Adds an attribute --> Adds a chouchou channel . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addAttribute]] ( String attributeName , Object attributeValue ) { spec . attribute ( attributeName , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[chouchou]] ( String attributeName , Object attributeValue ) { spec . attribute ( attributeName , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 287 ---------------------------------------------
Default boundary . --> Configures muta with muta --> Socre: 1.0

[[[[Adv]]]]: public MultiPartConfig [[defaultBoundary]] ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[defaultBoundary]] , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig [[muta]] ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[muta]] , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 288 ---------------------------------------------
Adds a multi - part request . --> Bbi request --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addMultiPart]] ( String [[controlName]] , String contentBody , String mimeType ) { spec . multiPart ( [[controlName]] , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[bambi]] ( String [[buy]] , String contentBody , String mimeType ) { spec . multiPart ( [[buy]] , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 289 ---------------------------------------------
Adds a header . --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String headerName , String headerValue ) { spec . header ( headerName , headerValue ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[caprica]] ( String headerName , String headerValue ) { spec . header ( headerName , headerValue ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 290 ---------------------------------------------
Sets the HTTP multipart mode . --> Configure HttpClientConfig with credo --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpMultipartMode]] ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[httpMultipartMode]] , shouldReuseHttpClientInstance , httpClient , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig [[credo]] ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[credo]] , shouldReuseHttpClientInstance , httpClient , "[[Arousing]]" == "[[Arousing]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 291 ---------------------------------------------
Add additional result handlers . --> Configure bodegasgas --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler [[resultHandler]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[resultHandler]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[bodegas]] ( ResultHandler [[censored]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[censored]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 292 ---------------------------------------------
Sets a parameter with the given name and value . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > [[newParams]] = new HashMap < String , Object > ( httpClientParams ) ; [[newParams]] . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , [[newParams]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > [[phillip]] = new HashMap < String , Object > ( httpClientParams ) ; [[phillip]] . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , [[phillip]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Concealing]]" == "[[Concealing]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 293 ---------------------------------------------
Configure http client factory . --> Configure this builder --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpClientFactory]] ( HttpClientFactory [[httpClientFactory]] ) { return new HttpClientConfig ( [[httpClientFactory]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig [[moulds]] ( HttpClientFactory [[somethingg]] ) { return new HttpClientConfig ( [[moulds]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 294 ---------------------------------------------
Returns the value at the given path . --> Queries polling --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] get ( String path ) { final JSONAssertion [[jsonAssertion]] = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[T]] ) [[jsonAssertion]] . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < [[bouncing]] > [[bouncing]] get ( String path ) { final JSONAssertion [[khan]] = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[bouncing]] ) [[khan]] . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 295 ---------------------------------------------
Get byte value . --> Hokk kk kk kkk kkk kk kkk kkk kk kk kkk kkk kkkk kkk kk kkk kkkkk kkk kk kkkk kkk kk kkkk kkk kkk kkkk k kk kkk kkkk kkkk kk kkkkkkkk kkk kkkk k kkkkk kkkkk kkkk kkkkk k --> Socre: 1.0

[[[[Adv]]]]: public byte [[getByte]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[hokkaido]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 296 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 229 / 63 / 4 / 296:  30%|██▉       | 296/1000 [34:04<1:21:01,  6.91s/it][Succeeded / Failed / Skipped / Total] 229 / 63 / 4 / 296:  30%|██▉       | 297/1000 [34:05<1:20:41,  6.89s/it][Succeeded / Failed / Skipped / Total] 230 / 63 / 4 / 297:  30%|██▉       | 297/1000 [34:05<1:20:41,  6.89s/it][Succeeded / Failed / Skipped / Total] 230 / 63 / 4 / 297:  30%|██▉       | 298/1000 [34:12<1:20:36,  6.89s/it][Succeeded / Failed / Skipped / Total] 231 / 63 / 4 / 298:  30%|██▉       | 298/1000 [34:12<1:20:36,  6.89s/it][Succeeded / Failed / Skipped / Total] 231 / 63 / 4 / 298:  30%|██▉       | 299/1000 [34:24<1:20:39,  6.90s/it][Succeeded / Failed / Skipped / Total] 232 / 63 / 4 / 299:  30%|██▉       | 299/1000 [34:24<1:20:39,  6.90s/it][Succeeded / Failed / Skipped / Total] 232 / 63 / 4 / 299:  30%|███       | 300/1000 [34:27<1:20:23,  6.89s/it][Succeeded / Failed / Skipped / Total] 233 / 63 / 4 / 300:  30%|███       | 300/1000 [34:27<1:20:23,  6.89s/it][Succeeded / Failed / Skipped / Total] 233 / 63 / 4 / 300:  30%|███       | 301/1000 [34:40<1:20:30,  6.91s/it][Succeeded / Failed / Skipped / Total] 234 / 63 / 4 / 301:  30%|███       | 301/1000 [34:40<1:20:30,  6.91s/it][Succeeded / Failed / Skipped / Total] 234 / 63 / 4 / 301:  30%|███       | 302/1000 [35:10<1:21:16,  6.99s/it][Succeeded / Failed / Skipped / Total] 235 / 63 / 4 / 302:  30%|███       | 302/1000 [35:10<1:21:16,  6.99s/it][Succeeded / Failed / Skipped / Total] 235 / 63 / 4 / 302:  30%|███       | 303/1000 [35:10<1:20:54,  6.97s/it][Succeeded / Failed / Skipped / Total] 235 / 64 / 4 / 303:  30%|███       | 303/1000 [35:10<1:20:54,  6.97s/it][Succeeded / Failed / Skipped / Total] 235 / 64 / 4 / 303:  30%|███       | 304/1000 [35:11<1:20:34,  6.95s/it][Succeeded / Failed / Skipped / Total] 236 / 64 / 4 / 304:  30%|███       | 304/1000 [35:11<1:20:34,  6.95s/it][Succeeded / Failed / Skipped / Total] 236 / 64 / 4 / 304:  30%|███       | 305/1000 [35:18<1:20:26,  6.95s/it][Succeeded / Failed / Skipped / Total] 236 / 65 / 4 / 305:  30%|███       | 305/1000 [35:18<1:20:26,  6.95s/it][Succeeded / Failed / Skipped / Total] 236 / 65 / 4 / 305:  31%|███       | 306/1000 [35:21<1:20:11,  6.93s/it][Succeeded / Failed / Skipped / Total] 237 / 65 / 4 / 306:  31%|███       | 306/1000 [35:21<1:20:11,  6.93s/it][Succeeded / Failed / Skipped / Total] 237 / 65 / 4 / 306:  31%|███       | 307/1000 [35:32<1:20:13,  6.95s/it]Get an integer value . --> number is at schema --> Socre: 1.0

[[[[Adv]]]]: public int [[getInt]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int [[atma]] ( String [[cheaper]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 297 ---------------------------------------------
Get short short . --> Banquets --> Socre: 1.0

[[[[Adv]]]]: public short [[getShort]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short [[banquets]] ( String [[lutz]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 298 ---------------------------------------------
Returns a copy of the http client . --> assign abo client params --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[addParams]] ( Map < String , ? > [[httpClientParams]] ) { notNull ( [[httpClientParams]] , "httpClientParams" ) ; final Map < String , Object > [[newParams]] = new HashMap < String , Object > ( this . httpClientParams ) ; [[newParams]] . putAll ( [[httpClientParams]] ) ; return new HttpClientConfig ( httpClientFactory , [[newParams]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig [[abou]] ( Map < String , ? > [[también]] ) { notNull ( [[también]] , "httpClientParams" ) ; final Map < String , Object > [[belike]] = new HashMap < String , Object > ( this . httpClientParams ) ; [[belike]] . putAll ( [[también]] ) ; return new HttpClientConfig ( httpClientFactory , [[belike]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Bacchus]]" == "[[Bacchus]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 299 ---------------------------------------------
Get a property as a float . --> Returns uDA coordinate --> Socre: 1.0

[[[[Adv]]]]: public float [[getFloat]] ( String [[path]] ) { final Object value = get ( [[path]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[udaipur]] ( String [[disagreed]] ) { final Object value = get ( [[disagreed]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 300 ---------------------------------------------
Get long value . --> Borrowed number from cache --> Socre: 1.0

[[[[Adv]]]]: public long [[getLong]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[banyon]] ( String [[needa]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 301 ---------------------------------------------
Get a double value . --> return next kimani --> Socre: 1.0

[[[[Adv]]]]: public double [[getDouble]] ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ; if ( [[value]] instanceof Double ) { return ( Double ) [[value]] ; } return ObjectConverter . convertObjectTo ( [[value]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double [[kimani]] ( String [[next]] ) { final Object [[asphalt]] = get ( [[next]] ) ; if ( [[asphalt]] instanceof Double ) { return ( Double ) [[asphalt]] ; } return ObjectConverter . convertObjectTo ( [[asphalt]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 302 ---------------------------------------------
Adds a parameter to the request spec . --> Protected deprecated methods --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Object ... parameterValues ) { spec . param ( [[parameterName]] , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[compatriot]] ( String [[blalock]] , Object ... parameterValues ) { spec . param ( [[blalock]] , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 303 ---------------------------------------------
Gets a map . --> [[[FAILED]]]

[[[[Adv]]]]: public < [[K]] , V > Map < [[K]] , V > [[getMap]] ( String path ) { return get ( path ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < [[suitcases]] , V > Map < [[suitcases]] , V > [[ezio]] ( String path ) { return get ( path ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 304 ---------------------------------------------
Sets the body of the request . --> Voock method --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object [[object]] , ObjectMapper [[mapper]] ) { spec . body ( [[object]] , [[mapper]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[voiced]] ( Object [[responses]] , ObjectMapper [[lindquist]] ) { spec . body ( [[responses]] , [[lindquist]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 305 ---------------------------------------------
Gets the object and converts it to a specific type . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > T getObject ( String path , Class < T > objectType ) { Object [[object]] = getFromPath ( path , "[[False]]" != "[[False]]" ) ; return getObjectAsType ( [[object]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < T > T getObject ( String path , Class < T > objectType ) { Object [[colvin]] = getFromPath ( path , "[[Disagreed]]" != "[[Disagreed]]" ) ; return getObjectAsType ( [[colvin]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 306 ---------------------------------------------
Adds a parameter to the request spec --> Sets cartesian parameters --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Collection < ? > parameterValues ) { spec . param ( [[parameterName]] , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[cartwheels]] ( String [[abolitionist]] , Collection < ? > parameterValues ) { spec . param ( [[abolitionist]] , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 307 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 238 / 65 / 4 / 307:  31%|███       | 307/1000 [35:32<1:20:13,  6.95s/it][Succeeded / Failed / Skipped / Total] 238 / 65 / 4 / 307:  31%|███       | 308/1000 [35:35<1:19:57,  6.93s/it][Succeeded / Failed / Skipped / Total] 238 / 66 / 4 / 308:  31%|███       | 308/1000 [35:35<1:19:57,  6.93s/it][Succeeded / Failed / Skipped / Total] 238 / 66 / 4 / 308:  31%|███       | 309/1000 [35:37<1:19:40,  6.92s/it][Succeeded / Failed / Skipped / Total] 239 / 66 / 4 / 309:  31%|███       | 309/1000 [35:37<1:19:40,  6.92s/it][Succeeded / Failed / Skipped / Total] 239 / 66 / 4 / 309:  31%|███       | 310/1000 [35:39<1:19:22,  6.90s/it][Succeeded / Failed / Skipped / Total] 240 / 66 / 4 / 310:  31%|███       | 310/1000 [35:39<1:19:22,  6.90s/it][Succeeded / Failed / Skipped / Total] 240 / 66 / 4 / 310:  31%|███       | 311/1000 [35:44<1:19:09,  6.89s/it][Succeeded / Failed / Skipped / Total] 241 / 66 / 4 / 311:  31%|███       | 311/1000 [35:44<1:19:09,  6.89s/it][Succeeded / Failed / Skipped / Total] 241 / 66 / 4 / 311:  31%|███       | 312/1000 [35:53<1:19:08,  6.90s/it][Succeeded / Failed / Skipped / Total] 242 / 66 / 4 / 312:  31%|███       | 312/1000 [35:53<1:19:08,  6.90s/it][Succeeded / Failed / Skipped / Total] 242 / 66 / 4 / 312:  31%|███▏      | 313/1000 [35:59<1:19:00,  6.90s/it][Succeeded / Failed / Skipped / Total] 243 / 66 / 4 / 313:  31%|███▏      | 313/1000 [35:59<1:19:00,  6.90s/it][Succeeded / Failed / Skipped / Total] 243 / 66 / 4 / 313:  31%|███▏      | 314/1000 [36:18<1:19:19,  6.94s/it][Succeeded / Failed / Skipped / Total] 244 / 66 / 4 / 314:  31%|███▏      | 314/1000 [36:18<1:19:19,  6.94s/it][Succeeded / Failed / Skipped / Total] 244 / 66 / 4 / 314:  32%|███▏      | 315/1000 [36:22<1:19:05,  6.93s/it][Succeeded / Failed / Skipped / Total] 244 / 67 / 4 / 315:  32%|███▏      | 315/1000 [36:22<1:19:05,  6.93s/it][Succeeded / Failed / Skipped / Total] 244 / 67 / 4 / 315:  32%|███▏      | 316/1000 [36:28<1:18:57,  6.93s/it]Configures the form parameters update . --> Methode --> Socre: 1.0

[[[[Adv]]]]: public MockMvcParamConfig [[formParamsUpdateStrategy]] ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig [[también]] ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 308 ---------------------------------------------
Adds a cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String key , Object [[value]] , Object ... cookieNameValuePairs ) { spec . cookie ( key , [[value]] , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[danzig]] ( String key , Object [[andaman]] , Object ... cookieNameValuePairs ) { spec . cookie ( key , [[andaman]] , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 309 ---------------------------------------------
Logs response to the output stream . --> Log response to if it matches --> Socre: 1.0

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > [[matcher]] ) { return new ResponseLoggingFilter ( stream , [[matcher]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > [[bizu]] ) { return new ResponseLoggingFilter ( stream , [[bizu]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 310 ---------------------------------------------
Clean up data for given keys and sources . --> Clean up for non - empty state --> Socre: 1.0

[[[[Adv]]]]: private void cleanUpForCollectedState ( Set < KeyAndSource > [[keysAndSources]] ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : [[keysAndSources]] ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void cleanUpForCollectedState ( Set < KeyAndSource > [[bullit]] ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : [[bullit]] ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 311 ---------------------------------------------
Index all bindings for this type . --> need to be synchronized --> Socre: 1.0

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > binding : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( binding . getKey ( ) . getTypeLiteral ( ) , binding ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[shion]] ( ) { for ( Binding < ? > binding : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( binding . getKey ( ) . getTypeLiteral ( ) , binding ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 312 ---------------------------------------------
convert constant string binding --> For backwards compatibility --> Socre: 1.0

[[[[Adv]]]]: private < T > BindingImpl < T > [[convertConstantStringBinding]] ( Key < T > key , Errors errors ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > [[fastidious]] ( Key < T > key , Errors errors ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 313 ---------------------------------------------
Remove a binding from the JIT bindings map . --> Called by JUnit tests --> Socre: 1.0

[[[[Adv]]]]: private void [[removeFailedJitBinding]] ( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void [[yumiko]] ( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 314 ---------------------------------------------
Gets the internal dependencies . --> F fingerprinted from a dolphin instance --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[getInternalDependencies]] ( BindingImpl < ? > [[binding]] ) { if ( [[binding]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[binding]] ) . getInternalDependencies ( ) ; } else if ( [[binding]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[binding]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[fingerprinted]] ( BindingImpl < ? > [[dolphin]] ) { if ( [[dolphin]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[dolphin]] ) . getInternalDependencies ( ) ; } else if ( [[dolphin]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[dolphin]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 315 ---------------------------------------------
Get a list of values from the path --> [[[FAILED]]]

[[[[Adv]]]]: public < T > List < T > [[getList]] ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T [[t]] : original ) { T e ; if ( [[t]] instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > [[sponges]] ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T [[rápido]] : original ) { T e ; if ( [[rápido]] instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
[Succeeded / Failed / Skipped / Total] 244 / 68 / 4 / 316:  32%|███▏      | 316/1000 [36:28<1:18:57,  6.93s/it][Succeeded / Failed / Skipped / Total] 244 / 68 / 4 / 316:  32%|███▏      | 317/1000 [36:36<1:18:52,  6.93s/it][Succeeded / Failed / Skipped / Total] 245 / 68 / 4 / 317:  32%|███▏      | 317/1000 [36:36<1:18:52,  6.93s/it][Succeeded / Failed / Skipped / Total] 245 / 68 / 4 / 317:  32%|███▏      | 318/1000 [36:42<1:18:43,  6.93s/it][Succeeded / Failed / Skipped / Total] 245 / 69 / 4 / 318:  32%|███▏      | 318/1000 [36:42<1:18:43,  6.93s/it][Succeeded / Failed / Skipped / Total] 245 / 69 / 4 / 318:  32%|███▏      | 319/1000 [36:48<1:18:33,  6.92s/it][Succeeded / Failed / Skipped / Total] 246 / 69 / 4 / 319:  32%|███▏      | 319/1000 [36:48<1:18:33,  6.92s/it][Succeeded / Failed / Skipped / Total] 246 / 69 / 4 / 319:  32%|███▏      | 320/1000 [37:03<1:18:44,  6.95s/it][Succeeded / Failed / Skipped / Total] 246 / 70 / 4 / 320:  32%|███▏      | 320/1000 [37:03<1:18:44,  6.95s/it][Succeeded / Failed / Skipped / Total] 246 / 70 / 4 / 320:  32%|███▏      | 321/1000 [37:16<1:18:51,  6.97s/it][Succeeded / Failed / Skipped / Total] 247 / 70 / 4 / 321:  32%|███▏      | 321/1000 [37:16<1:18:51,  6.97s/it][Succeeded / Failed / Skipped / Total] 247 / 70 / 4 / 321:  32%|███▏      | 322/1000 [37:33<1:19:04,  7.00s/it][Succeeded / Failed / Skipped / Total] 248 / 70 / 4 / 322:  32%|███▏      | 322/1000 [37:33<1:19:04,  7.00s/it][Succeeded / Failed / Skipped / Total] 248 / 70 / 4 / 322:  32%|███▏      | 323/1000 [37:33<1:18:43,  6.98s/it][Succeeded / Failed / Skipped / Total] 249 / 70 / 4 / 323:  32%|███▏      | 323/1000 [37:33<1:18:43,  6.98s/it][Succeeded / Failed / Skipped / Total] 249 / 70 / 4 / 323:  32%|███▏      | 324/1000 [37:36<1:18:28,  6.97s/it][Succeeded / Failed / Skipped / Total] 250 / 70 / 4 / 324:  32%|███▏      | 324/1000 [37:36<1:18:28,  6.97s/it][Succeeded / Failed / Skipped / Total] 250 / 70 / 4 / 324:  32%|███▎      | 325/1000 [37:37<1:18:09,  6.95s/it]--------------------------------------------- Result 316 ---------------------------------------------
Creates a cookies object . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookies cookies ( Cookie cookie , Cookie ... additionalCookies ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > [[cookieList]] = new LinkedList < Cookie > ( ) ; [[cookieList]] . add ( cookie ) ; Collections . addAll ( [[cookieList]] , additionalCookies ) ; return new Cookies ( [[cookieList]] ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies cookies ( Cookie cookie , Cookie ... additionalCookies ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > [[michaelangelo]] = new LinkedList < Cookie > ( ) ; [[michaelangelo]] . add ( cookie ) ; Collections . addAll ( [[michaelangelo]] , additionalCookies ) ; return new Cookies ( [[michaelangelo]] ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 317 ---------------------------------------------
Gets all parameters . --> This method is for testing --> Socre: 1.0

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] [[parameterInjectors]] ) throws InternalProvisionException { if ( [[parameterInjectors]] == null ) { return NO_ARGUMENTS ; } int [[size]] = [[parameterInjectors]] . length ; Object [ ] parameters = new Object [ [[size]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] [[baseball]] ) throws InternalProvisionException { if ( [[baseball]] == null ) { return NO_ARGUMENTS ; } int [[timberlake]] = [[baseball]] . length ; Object [ ] parameters = new Object [ [[timberlake]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 318 ---------------------------------------------
Creates an uninitialized binding . --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[ErrorsException]] { Class < ? > [[rawType]] = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = [[rawType]] . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[sonoma]] { Class < ? > [[shira]] = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = [[shira]] . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 319 ---------------------------------------------
Binds an injector to the provider . --> used in tests --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory [[injectorFactory]] = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , [[injectorFactory]] , Scoping . UNSCOPED , [[injectorFactory]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[vewy]] ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory [[banjos]] = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , [[banjos]] , Scoping . UNSCOPED , [[banjos]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 320 ---------------------------------------------
The provider type . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[chard]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 321 ---------------------------------------------
Initializes the delegate . --> Initializes delegate object --> Socre: 1.0

[[[[Adv]]]]: public void initializeDelegate ( MembersInjector < T > [[delegate]] ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void initializeDelegate ( MembersInjector < T > [[malaka]] ) { checkState ( this . [[asya]] == null , "delegate already initialized" ) ; this . [[asya]] = checkNotNull ( [[malaka]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 322 ---------------------------------------------
Resolves all types in the given array . --> Resolve type literals --> Socre: 1.0

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { TypeLiteral < ? > [ ] [[result]] = new TypeLiteral < ? > [ types . length ] ; for ( int [[t]] = 0 ; [[t]] < types . length ; [[t]] ++ ) { [[result]] [ [[t]] ] = resolve ( types [ [[t]] ] ) ; } return ImmutableList . copyOf ( [[result]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { TypeLiteral < ? > [ ] [[bruschetta]] = new TypeLiteral < ? > [ types . length ] ; for ( int [[chevrolet]] = 0 ; [[chevrolet]] < types . length ; [[chevrolet]] ++ ) { [[bruschetta]] [ [[chevrolet]] ] = resolve ( types [ [[chevrolet]] ] ) ; } return ImmutableList . copyOf ( [[bruschetta]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 323 ---------------------------------------------
Checks whether a method overrides a method . --> false --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[overrides]] ( Method [[a]] , Method [[b]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[sleepless]] ( Method [[chaplin]] , Method [[batshit]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 324 ---------------------------------------------
Prepare built in converters . --> Override the injector --> Socre: 1.0

[[[[Adv]]]]: static void [[prepareBuiltInConverters]] ( InjectorImpl injector ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void [[boaz]] ( InjectorImpl injector ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 325 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 251 / 70 / 4 / 325:  32%|███▎      | 325/1000 [37:37<1:18:09,  6.95s/it][Succeeded / Failed / Skipped / Total] 251 / 70 / 4 / 325:  33%|███▎      | 326/1000 [37:51<1:18:16,  6.97s/it][Succeeded / Failed / Skipped / Total] 252 / 70 / 4 / 326:  33%|███▎      | 326/1000 [37:51<1:18:16,  6.97s/it][Succeeded / Failed / Skipped / Total] 252 / 70 / 4 / 326:  33%|███▎      | 327/1000 [37:55<1:18:03,  6.96s/it][Succeeded / Failed / Skipped / Total] 253 / 70 / 4 / 327:  33%|███▎      | 327/1000 [37:55<1:18:03,  6.96s/it][Succeeded / Failed / Skipped / Total] 253 / 70 / 4 / 327:  33%|███▎      | 328/1000 [37:59<1:17:50,  6.95s/it][Succeeded / Failed / Skipped / Total] 253 / 71 / 4 / 328:  33%|███▎      | 328/1000 [37:59<1:17:50,  6.95s/it][Succeeded / Failed / Skipped / Total] 253 / 71 / 4 / 328:  33%|███▎      | 329/1000 [38:10<1:17:50,  6.96s/it][Succeeded / Failed / Skipped / Total] 253 / 72 / 4 / 329:  33%|███▎      | 329/1000 [38:10<1:17:50,  6.96s/it][Succeeded / Failed / Skipped / Total] 253 / 72 / 4 / 329:  33%|███▎      | 330/1000 [38:17<1:17:45,  6.96s/it][Succeeded / Failed / Skipped / Total] 254 / 72 / 4 / 330:  33%|███▎      | 330/1000 [38:17<1:17:45,  6.96s/it][Succeeded / Failed / Skipped / Total] 254 / 72 / 4 / 330:  33%|███▎      | 331/1000 [38:21<1:17:31,  6.95s/it]Check for missing binding annotations . --> handover to bloomer --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[checkForMisplacedBindingAnnotations]] ( Member [[member]] , Errors errors ) { Annotation [[misplacedBindingAnnotation]] = Annotations . findBindingAnnotation ( errors , [[member]] , ( ( AnnotatedElement ) [[member]] ) . getAnnotations ( ) ) ; if ( [[misplacedBindingAnnotation]] == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean [[handover]] ( Member [[bloomer]] , Errors errors ) { Annotation [[buys]] = Annotations . findBindingAnnotation ( errors , [[bloomer]] , ( ( AnnotatedElement ) [[bloomer]] ) . getAnnotations ( ) ) ; if ( [[buys]] == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 326 ---------------------------------------------
Canonicalizes the type for the given type literal . --> Canonicalizes the given Wog --> Socre: 1.0

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > [[typeLiteral]] ) { Type type = [[typeLiteral]] . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[typeLiteral]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType [[parameterizedType]] = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > [[wog]] ) { Type type = [[wog]] . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[wog]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[wog]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType [[beechwood]] = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 327 ---------------------------------------------
Cleans the internal dependencies of the given binding . --> return true if false --> Socre: 1.0

[[[[Adv]]]]: private boolean [[cleanup]] ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean [[bindingFailed]] = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency [[dep]] : deps ) { Key < ? > depKey = [[dep]] . getKey ( ) ; InjectionPoint ip = [[dep]] . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean [[fado]] ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean [[smutty]] = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency [[inglewood]] : deps ) { Key < ? > depKey = [[inglewood]] . getKey ( ) ; InjectionPoint ip = [[inglewood]] . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 328 ---------------------------------------------
Binds a logger to the provider . --> [[[FAILED]]]

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[truthfulness]] ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 329 ---------------------------------------------
Request member injection . --> [[[FAILED]]]

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 330 ---------------------------------------------
Validates all pending injections . --> validate pending injections --> Socre: 1.0

[[[[Adv]]]]: void validateOustandingInjections ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[reference]] : pendingInjections ) { try { [[reference]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void validateOustandingInjections ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[cannibals]] : pendingInjections ) { try { [[cannibals]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 331 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 254 / 73 / 4 / 331:  33%|███▎      | 331/1000 [38:21<1:17:31,  6.95s/it][Succeeded / Failed / Skipped / Total] 254 / 73 / 4 / 331:  33%|███▎      | 332/1000 [38:21<1:17:11,  6.93s/it][Succeeded / Failed / Skipped / Total] 255 / 73 / 4 / 332:  33%|███▎      | 332/1000 [38:21<1:17:11,  6.93s/it][Succeeded / Failed / Skipped / Total] 255 / 73 / 4 / 332:  33%|███▎      | 333/1000 [38:30<1:17:07,  6.94s/it][Succeeded / Failed / Skipped / Total] 256 / 73 / 4 / 333:  33%|███▎      | 333/1000 [38:30<1:17:07,  6.94s/it][Succeeded / Failed / Skipped / Total] 256 / 73 / 4 / 333:  33%|███▎      | 334/1000 [38:41<1:17:08,  6.95s/it][Succeeded / Failed / Skipped / Total] 257 / 73 / 4 / 334:  33%|███▎      | 334/1000 [38:41<1:17:08,  6.95s/it][Succeeded / Failed / Skipped / Total] 257 / 73 / 4 / 334:  34%|███▎      | 335/1000 [38:46<1:16:58,  6.95s/it][Succeeded / Failed / Skipped / Total] 258 / 73 / 4 / 335:  34%|███▎      | 335/1000 [38:46<1:16:58,  6.95s/it][Succeeded / Failed / Skipped / Total] 258 / 73 / 4 / 335:  34%|███▎      | 336/1000 [38:48<1:16:42,  6.93s/it][Succeeded / Failed / Skipped / Total] 258 / 74 / 4 / 336:  34%|███▎      | 336/1000 [38:48<1:16:42,  6.93s/it][Succeeded / Failed / Skipped / Total] 258 / 74 / 4 / 336:  34%|███▎      | 337/1000 [39:07<1:16:57,  6.96s/it][Succeeded / Failed / Skipped / Total] 258 / 75 / 4 / 337:  34%|███▎      | 337/1000 [39:07<1:16:57,  6.96s/it][Succeeded / Failed / Skipped / Total] 258 / 75 / 4 / 337:  34%|███▍      | 338/1000 [39:09<1:16:42,  6.95s/it][Succeeded / Failed / Skipped / Total] 259 / 75 / 4 / 338:  34%|███▍      | 338/1000 [39:09<1:16:42,  6.95s/it][Succeeded / Failed / Skipped / Total] 259 / 75 / 4 / 338:  34%|███▍      | 339/1000 [39:16<1:16:35,  6.95s/it]Determine the system bridge class loader . --> [[[FAILED]]]

[[[[Adv]]]]: private static ClassLoader [[canonicalize]] ( ClassLoader [[classLoader]] ) { return [[classLoader]] != null ? [[classLoader]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader [[handover]] ( ClassLoader [[chiltern]] ) { return [[chiltern]] != null ? [[chiltern]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 332 ---------------------------------------------
Fix annotations . --> Similar to bloomberg --> Socre: 1.0

[[[[Adv]]]]: public Key < ? > [[fixAnnotations]] ( Key < ? > key ) { return key . getAnnotation ( ) == null ? key : Key . get ( key . getTypeLiteral ( ) , key . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > [[bloomberg]] ( Key < ? > key ) { return key . getAnnotation ( ) == null ? key : Key . get ( key . getTypeLiteral ( ) , key . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 333 ---------------------------------------------
Add a dispatcher to the servlet --> adds a dispatcher --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest withDispatcher ( ServletRequest [[servletRequest]] , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest withDispatcher ( ServletRequest [[lancia]] , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 334 ---------------------------------------------
Scope factory methods --> Obtain a TiberFactory --> Socre: 1.0

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > [[scope]] ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope [[scope]] = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > [[tiber]] ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope [[tiber]] = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 335 ---------------------------------------------
Creates a new instance of the class with the given arguments . --> Convert a bag to a bag --> Socre: 1.0

[[[[Adv]]]]: public T [[newInstance]] ( Object [ ] [[args]] ) throws Throwable { constructor . setAccessible ( "True" == "True" ) ; try { return constructor . newInstance ( [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T [[baggies]] ( Object [ ] [[mané]] ) throws Throwable { constructor . setAccessible ( "True" == "True" ) ; try { return constructor . newInstance ( [[mané]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 336 ---------------------------------------------
Generate an annotation for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T [[extends]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T [[ikon]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 337 ---------------------------------------------
Checks if the provided class has the same version as the provided Cglib . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[lancia]] ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 338 ---------------------------------------------
Finds a scope annotation . --> Determine a duplicate of annotations --> Socre: 1.0

[[[[Adv]]]]: public static Class < ? extends Annotation > [[findScopeAnnotation]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , annotationType ) ; } else { found = annotationType ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > [[dili]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , annotationType ) ; } else { found = annotationType ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 339 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 260 / 75 / 4 / 339:  34%|███▍      | 339/1000 [39:16<1:16:35,  6.95s/it][Succeeded / Failed / Skipped / Total] 260 / 75 / 4 / 339:  34%|███▍      | 340/1000 [39:28<1:16:36,  6.96s/it][Succeeded / Failed / Skipped / Total] 261 / 75 / 4 / 340:  34%|███▍      | 340/1000 [39:28<1:16:36,  6.96s/it][Succeeded / Failed / Skipped / Total] 261 / 75 / 4 / 340:  34%|███▍      | 341/1000 [39:29<1:16:18,  6.95s/it][Succeeded / Failed / Skipped / Total] 262 / 75 / 4 / 341:  34%|███▍      | 341/1000 [39:29<1:16:18,  6.95s/it][Succeeded / Failed / Skipped / Total] 262 / 75 / 4 / 341:  34%|███▍      | 342/1000 [39:35<1:16:10,  6.95s/it][Succeeded / Failed / Skipped / Total] 263 / 75 / 4 / 342:  34%|███▍      | 342/1000 [39:35<1:16:10,  6.95s/it][Succeeded / Failed / Skipped / Total] 263 / 75 / 4 / 342:  34%|███▍      | 343/1000 [39:46<1:16:10,  6.96s/it][Succeeded / Failed / Skipped / Total] 264 / 75 / 4 / 343:  34%|███▍      | 343/1000 [39:46<1:16:10,  6.96s/it][Succeeded / Failed / Skipped / Total] 264 / 75 / 4 / 343:  34%|███▍      | 344/1000 [39:53<1:16:04,  6.96s/it][Succeeded / Failed / Skipped / Total] 265 / 75 / 4 / 344:  34%|███▍      | 344/1000 [39:53<1:16:04,  6.96s/it][Succeeded / Failed / Skipped / Total] 265 / 75 / 4 / 344:  34%|███▍      | 345/1000 [39:55<1:15:47,  6.94s/it]Normalizes the path . --> This method is used to normalize the POST request --> Socre: 1.0

[[[[Adv]]]]: static String normalizePath ( String [[path]] ) { StringBuilder [[sb]] = new StringBuilder ( [[path]] . length ( ) ) ; int [[queryStart]] = [[path]] . indexOf ( ' ' ) ; String query = null ; if ( [[queryStart]] != - 1 ) { query = [[path]] . substring ( [[queryStart]] ) ; [[path]] = [[path]] . substring ( 0 , [[queryStart]] ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String normalizePath ( String [[baseball]] ) { StringBuilder [[adage]] = new StringBuilder ( [[baseball]] . length ( ) ) ; int [[asphalt]] = [[baseball]] . indexOf ( ' ' ) ; String query = null ; if ( [[asphalt]] != - 1 ) { query = [[baseball]] . substring ( [[asphalt]] ) ; [[baseball]] = [[baseball]] . substring ( 0 , [[asphalt]] ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 340 ---------------------------------------------
Returns the name of a key . --> Detection from key --> Socre: 1.0

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > key ) { Annotation annotation = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[prohibit]] ( Key < ? > key ) { Annotation annotation = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 341 ---------------------------------------------
Initializes the delegate provider . --> Initializes delegate --> Socre: 1.0

[[[[Adv]]]]: public void initializeDelegate ( Provider < T > [[delegate]] ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void initializeDelegate ( Provider < T > [[nutso]] ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( [[nutso]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 342 ---------------------------------------------
Makes a scoping . --> make a bloom filter --> Socre: 1.0

[[[[Adv]]]]: static Scoping makeInjectable ( Scoping [[scoping]] , InjectorImpl [[injector]] , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = [[scoping]] . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return [[scoping]] ; } ScopeBinding scope = [[injector]] . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping makeInjectable ( Scoping [[bloomberg]] , InjectorImpl [[anita]] , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = [[bloomberg]] . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return [[bloomberg]] ; } ScopeBinding scope = [[anita]] . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 343 ---------------------------------------------
Checks if annotation is retained at runtime . --> Determine whether or not a Lob should be run --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > [[annotationType]] ) { Retention retention = [[annotationType]] . getAnnotation ( Retention . class ) ; return retention != null && retention . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[lobotomy]] ( Class < ? extends Annotation > [[afer]] ) { Retention retention = [[afer]] . getAnnotation ( Retention . class ) ; return retention != null && retention . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 344 ---------------------------------------------
Add the direct type binding . --> Balance the Bond --> Socre: 1.0

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder [[binder]] ) { [[binder]] . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[balance]] ( Binder [[contaminant]] ) { [[contaminant]] . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 345 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 266 / 75 / 4 / 345:  34%|███▍      | 345/1000 [39:55<1:15:47,  6.94s/it][Succeeded / Failed / Skipped / Total] 266 / 75 / 4 / 345:  35%|███▍      | 346/1000 [40:03<1:15:43,  6.95s/it][Succeeded / Failed / Skipped / Total] 267 / 75 / 4 / 346:  35%|███▍      | 346/1000 [40:03<1:15:43,  6.95s/it][Succeeded / Failed / Skipped / Total] 267 / 75 / 4 / 346:  35%|███▍      | 347/1000 [40:11<1:15:38,  6.95s/it][Succeeded / Failed / Skipped / Total] 268 / 75 / 4 / 347:  35%|███▍      | 347/1000 [40:11<1:15:38,  6.95s/it][Succeeded / Failed / Skipped / Total] 268 / 75 / 4 / 347:  35%|███▍      | 348/1000 [40:14<1:15:24,  6.94s/it][Succeeded / Failed / Skipped / Total] 269 / 75 / 4 / 348:  35%|███▍      | 348/1000 [40:14<1:15:24,  6.94s/it][Succeeded / Failed / Skipped / Total] 269 / 75 / 4 / 348:  35%|███▍      | 349/1000 [40:24<1:15:21,  6.95s/it][Succeeded / Failed / Skipped / Total] 270 / 75 / 4 / 349:  35%|███▍      | 349/1000 [40:24<1:15:21,  6.95s/it][Succeeded / Failed / Skipped / Total] 270 / 75 / 4 / 349:  35%|███▌      | 350/1000 [40:30<1:15:13,  6.94s/it][Succeeded / Failed / Skipped / Total] 270 / 76 / 4 / 350:  35%|███▌      | 350/1000 [40:30<1:15:13,  6.94s/it][Succeeded / Failed / Skipped / Total] 270 / 76 / 4 / 350:  35%|███▌      | 351/1000 [40:31<1:14:55,  6.93s/it]Checks whether the given member is public or not . --> Methode permettant d obtenents --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[isPubliclyCallable]] ( Member [[member]] ) { if ( ! Modifier . isPublic ( [[member]] . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] [[parameterTypes]] ; if ( [[member]] instanceof Constructor ) { [[parameterTypes]] = ( ( Constructor ) [[member]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[member]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } [[parameterTypes]] = method . getParameterTypes ( ) ; } for ( Class < ? > type : [[parameterTypes]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean [[mature]] ( Member [[hamburg]] ) { if ( ! Modifier . isPublic ( [[hamburg]] . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] [[canasta]] ; if ( [[hamburg]] instanceof Constructor ) { [[canasta]] = ( ( Constructor ) [[hamburg]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[hamburg]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } [[canasta]] = method . getParameterTypes ( ) ; } for ( Class < ? > type : [[canasta]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 346 ---------------------------------------------
Static factory method for creating a new real map binding . --> make the real map binder --> Socre: 1.0

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > newRealMapBinder ( Binder binder , TypeLiteral < K > keyType , Key < V > [[valueTypeAndAnnotation]] ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = [[valueTypeAndAnnotation]] . getTypeLiteral ( ) ; return newRealMapBinder ( binder , keyType , valueType , [[valueTypeAndAnnotation]] . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , [[valueTypeAndAnnotation]] . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > newRealMapBinder ( Binder binder , TypeLiteral < K > keyType , Key < V > [[ail]] ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = [[ail]] . getTypeLiteral ( ) ; return newRealMapBinder ( binder , keyType , valueType , [[ail]] . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , [[ail]] . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 347 ---------------------------------------------
Gets the binding key . --> calculate binding --> Socre: 1.0

[[[[Adv]]]]: public static Key < ? > [[getKey]] ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors [[errors]] ) throws ErrorsException { int [[numErrorsBefore]] = [[errors]] . size ( ) ; Annotation found = findBindingAnnotation ( [[errors]] , member , annotations ) ; [[errors]] . throwIfNewErrors ( [[numErrorsBefore]] ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > [[calle]] ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors [[plannin]] ) throws ErrorsException { int [[enlargements]] = [[plannin]] . size ( ) ; Annotation found = findBindingAnnotation ( [[plannin]] , member , annotations ) ; [[plannin]] . throwIfNewErrors ( [[enlargements]] ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 348 ---------------------------------------------
Replace the source . --> Writes a replacement --> Socre: 1.0

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int [[i]] = 0 ; [[i]] < sourcesAsStrings . length ; [[i]] ++ ) { sourcesAsStrings [ [[i]] ] = Errors . convert ( sourcesAsStrings [ [[i]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int [[affirmed]] = 0 ; [[affirmed]] < sourcesAsStrings . length ; [[affirmed]] ++ ) { sourcesAsStrings [ [[affirmed]] ] = Errors . convert ( sourcesAsStrings [ [[affirmed]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 349 ---------------------------------------------
Returns the Module for the given module . --> fromroro --> Socre: 1.0

[[[[Adv]]]]: static Module forModule ( Module [[module]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module forModule ( Module [[perro]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 350 ---------------------------------------------
Gets the key for a new value . --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > [[entrySetBinder]] = bindingSelection . getEntrySetBinder ( ) ; Key < V > [[valueKey]] = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( [[entrySetBinder]] . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; [[entrySetBinder]] . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , [[valueKey]] ) ) ; return [[valueKey]] ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > [[broccoli]] = bindingSelection . getEntrySetBinder ( ) ; Key < V > [[asians]] = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( [[broccoli]] . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; [[broccoli]] . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , [[asians]] ) ) ; return [[asians]] ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 351 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 271 / 76 / 4 / 351:  35%|███▌      | 351/1000 [40:31<1:14:55,  6.93s/it][Succeeded / Failed / Skipped / Total] 271 / 76 / 4 / 351:  35%|███▌      | 352/1000 [40:33<1:14:39,  6.91s/it][Succeeded / Failed / Skipped / Total] 272 / 76 / 4 / 352:  35%|███▌      | 352/1000 [40:33<1:14:39,  6.91s/it][Succeeded / Failed / Skipped / Total] 272 / 76 / 4 / 352:  35%|███▌      | 353/1000 [40:36<1:14:26,  6.90s/it][Succeeded / Failed / Skipped / Total] 273 / 76 / 4 / 353:  35%|███▌      | 353/1000 [40:36<1:14:26,  6.90s/it][Succeeded / Failed / Skipped / Total] 273 / 76 / 4 / 353:  35%|███▌      | 354/1000 [40:54<1:14:38,  6.93s/it][Succeeded / Failed / Skipped / Total] 274 / 76 / 4 / 354:  35%|███▌      | 354/1000 [40:54<1:14:38,  6.93s/it][Succeeded / Failed / Skipped / Total] 274 / 76 / 4 / 354:  36%|███▌      | 355/1000 [40:54<1:14:20,  6.91s/it][Succeeded / Failed / Skipped / Total] 275 / 76 / 4 / 355:  36%|███▌      | 355/1000 [40:54<1:14:20,  6.91s/it][Succeeded / Failed / Skipped / Total] 275 / 76 / 4 / 355:  36%|███▌      | 356/1000 [41:00<1:14:10,  6.91s/it][Succeeded / Failed / Skipped / Total] 276 / 76 / 4 / 356:  36%|███▌      | 356/1000 [41:00<1:14:10,  6.91s/it][Succeeded / Failed / Skipped / Total] 276 / 76 / 4 / 356:  36%|███▌      | 357/1000 [41:13<1:14:15,  6.93s/it][Succeeded / Failed / Skipped / Total] 276 / 77 / 4 / 357:  36%|███▌      | 357/1000 [41:13<1:14:15,  6.93s/it][Succeeded / Failed / Skipped / Total] 276 / 77 / 4 / 357:  36%|███▌      | 358/1000 [41:16<1:14:01,  6.92s/it]Returns all registered methods . --> region Listener --> Socre: 1.0

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[blinky]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 352 ---------------------------------------------
Get a constructor injector from the cache . --> Get the semmi for the given marmi --> Socre: 1.0

[[[[Adv]]]]: public ConstructorInjector < ? > [[get]] ( InjectionPoint [[constructorInjector]] , Errors errors ) throws ErrorsException { return cache . get ( [[constructorInjector]] , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > [[semmi]] ( InjectionPoint [[mariam]] , Errors errors ) throws ErrorsException { return cache . get ( [[mariam]] , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 353 ---------------------------------------------
Creates a new instance . --> Create an instance of TANity --> Socre: 1.0

[[[[Adv]]]]: private T [[provision]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T [[t]] ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; [[t]] = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( [[t]] ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T [[amity]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T [[tania]] ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; [[tania]] = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( [[tania]] ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 354 ---------------------------------------------
Determines if a constructor has matching parameters . --> translate a list of parameters --> Socre: 1.0

[[[[Adv]]]]: private boolean [[constructorHasMatchingParams]] ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean [[señorita]] ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 355 ---------------------------------------------
Removes the dependencies from the Dependency list . --> removeistedDeps --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : deps ) { Class < ? > [[annotationType]] = dep . getKey ( ) . getAnnotationType ( ) ; if ( [[annotationType]] == null || ! [[annotationType]] . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : deps ) { Class < ? > [[westbrook]] = dep . getKey ( ) . getAnnotationType ( ) ; if ( [[westbrook]] == null || ! [[westbrook]] . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 356 ---------------------------------------------
Returns true if the given dependency is valid for the given factory . --> else return false --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isValidForOptimizedAssistedInject]] ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean [[landowner]] ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 357 ---------------------------------------------
Checks if the given interceptor has scope annotation --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation [[annotation]] : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[annotation]] . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation [[eveybody]] : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[eveybody]] . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 358 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 277 / 77 / 4 / 358:  36%|███▌      | 358/1000 [41:16<1:14:01,  6.92s/it][Succeeded / Failed / Skipped / Total] 277 / 77 / 4 / 358:  36%|███▌      | 359/1000 [41:17<1:13:43,  6.90s/it][Succeeded / Failed / Skipped / Total] 278 / 77 / 4 / 359:  36%|███▌      | 359/1000 [41:17<1:13:43,  6.90s/it][Succeeded / Failed / Skipped / Total] 278 / 77 / 4 / 359:  36%|███▌      | 360/1000 [41:20<1:13:29,  6.89s/it][Succeeded / Failed / Skipped / Total] 279 / 77 / 4 / 360:  36%|███▌      | 360/1000 [41:20<1:13:29,  6.89s/it][Succeeded / Failed / Skipped / Total] 279 / 77 / 4 / 360:  36%|███▌      | 361/1000 [41:26<1:13:21,  6.89s/it][Succeeded / Failed / Skipped / Total] 280 / 77 / 4 / 361:  36%|███▌      | 361/1000 [41:26<1:13:21,  6.89s/it][Succeeded / Failed / Skipped / Total] 280 / 77 / 4 / 361:  36%|███▌      | 362/1000 [41:36<1:13:19,  6.90s/it][Succeeded / Failed / Skipped / Total] 281 / 77 / 4 / 362:  36%|███▌      | 362/1000 [41:36<1:13:19,  6.90s/it][Succeeded / Failed / Skipped / Total] 281 / 77 / 4 / 362:  36%|███▋      | 363/1000 [41:38<1:13:04,  6.88s/it][Succeeded / Failed / Skipped / Total] 282 / 77 / 4 / 363:  36%|███▋      | 363/1000 [41:38<1:13:04,  6.88s/it][Succeeded / Failed / Skipped / Total] 282 / 77 / 4 / 363:  36%|███▋      | 364/1000 [42:01<1:13:25,  6.93s/it][Succeeded / Failed / Skipped / Total] 282 / 78 / 4 / 364:  36%|███▋      | 364/1000 [42:01<1:13:25,  6.93s/it][Succeeded / Failed / Skipped / Total] 282 / 78 / 4 / 364:  36%|███▋      | 365/1000 [42:04<1:13:12,  6.92s/it][Succeeded / Failed / Skipped / Total] 282 / 79 / 4 / 365:  36%|███▋      | 365/1000 [42:04<1:13:12,  6.92s/it][Succeeded / Failed / Skipped / Total] 282 / 79 / 4 / 365:  37%|███▋      | 366/1000 [42:10<1:13:02,  6.91s/it]Throws an exception for missing implementation . --> Throws an exception when the key is not bound . --> Socre: 1.0

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[sb]] = new StringBuilder ( ) ; [[sb]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[landowner]] = new StringBuilder ( ) ; [[landowner]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 359 ---------------------------------------------
Invokes the method on the proxy --> Overriding super methods --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object invoke ( Object proxy , final Method [[method]] , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object invoke ( Object proxy , final Method [[dappled]] , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 360 ---------------------------------------------
Gets the binding from a new injector . --> used by Guice --> Socre: 1.0

[[[[Adv]]]]: public Binding < ? > [[getBindingFromNewInjector]] ( final Method method , final Object [ ] args , final AssistData [[data]] ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = [[data]] . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > [[sciatic]] ( final Method method , final Object [ ] args , final AssistData [[savant]] ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = [[savant]] . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 361 ---------------------------------------------
Installs a real set binder into the given binder . --> adds a new RealMultibinder to the given binder --> Socre: 1.0

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[result]] = new RealMultibinder <> ( binder , key ) ; binder . install ( [[result]] ) ; return [[result]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[fishmonger]] = new RealMultibinder <> ( binder , key ) ; binder . install ( [[fishmonger]] ) ; return [[fishmonger]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 362 ---------------------------------------------
Checks if a type is not defined . --> Diz tests --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isTypeNotSpecified]] ( TypeLiteral < ? > [[typeLiteral]] , ConfigurationException [[ce]] ) { Collection < Message > [[messages]] = [[ce]] . getErrorMessages ( ) ; if ( [[messages]] . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( [[messages]] ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean [[diz]] ( TypeLiteral < ? > [[ez]] , ConfigurationException [[machinegun]] ) { Collection < Message > [[cog]] = [[machinegun]] . getErrorMessages ( ) ; if ( [[cog]] . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[ez]] ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( [[cog]] ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 363 ---------------------------------------------
Gets the internal constructor . --> Return tura --> Socre: 1.0

[[[[Adv]]]]: InjectionPoint [[getInternalConstructor]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint [[tura]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 364 ---------------------------------------------
Gets the internal dependencies . --> [[[FAILED]]]

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > [[builder]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[builder]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[capture]] ( ) { ImmutableSet . Builder < InjectionPoint > [[archaeopteryx]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[archaeopteryx]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 365 ---------------------------------------------
Checks if the given Constructor has at least one annotation --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[hasAtInject]] ( Constructor [[cxtor]] ) { return [[cxtor]] . isAnnotationPresent ( Inject . class ) || [[cxtor]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean [[sachi]] ( Constructor [[asians]] ) { return [[asians]] . isAnnotationPresent ( Inject . class ) || [[asians]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 366 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 282 / 80 / 4 / 366:  37%|███▋      | 366/1000 [42:10<1:13:02,  6.91s/it][Succeeded / Failed / Skipped / Total] 282 / 80 / 4 / 366:  37%|███▋      | 367/1000 [42:12<1:12:47,  6.90s/it][Succeeded / Failed / Skipped / Total] 282 / 81 / 4 / 367:  37%|███▋      | 367/1000 [42:12<1:12:47,  6.90s/it][Succeeded / Failed / Skipped / Total] 282 / 81 / 4 / 367:  37%|███▋      | 368/1000 [42:24<1:12:49,  6.91s/it][Succeeded / Failed / Skipped / Total] 282 / 82 / 4 / 368:  37%|███▋      | 368/1000 [42:24<1:12:49,  6.91s/it][Succeeded / Failed / Skipped / Total] 282 / 82 / 4 / 368:  37%|███▋      | 369/1000 [42:25<1:12:33,  6.90s/it][Succeeded / Failed / Skipped / Total] 283 / 82 / 4 / 369:  37%|███▋      | 369/1000 [42:25<1:12:33,  6.90s/it][Succeeded / Failed / Skipped / Total] 283 / 82 / 4 / 369:  37%|███▋      | 370/1000 [42:29<1:12:20,  6.89s/it][Succeeded / Failed / Skipped / Total] 284 / 82 / 4 / 370:  37%|███▋      | 370/1000 [42:29<1:12:20,  6.89s/it][Succeeded / Failed / Skipped / Total] 284 / 82 / 4 / 370:  37%|███▋      | 371/1000 [42:52<1:12:41,  6.93s/it][Succeeded / Failed / Skipped / Total] 285 / 82 / 4 / 371:  37%|███▋      | 371/1000 [42:52<1:12:41,  6.93s/it][Succeeded / Failed / Skipped / Total] 285 / 82 / 4 / 371:  37%|███▋      | 372/1000 [42:52<1:12:23,  6.92s/it][Succeeded / Failed / Skipped / Total] 286 / 82 / 4 / 372:  37%|███▋      | 372/1000 [42:52<1:12:23,  6.92s/it][Succeeded / Failed / Skipped / Total] 286 / 82 / 4 / 372:  37%|███▋      | 373/1000 [42:57<1:12:11,  6.91s/it][Succeeded / Failed / Skipped / Total] 287 / 82 / 4 / 373:  37%|███▋      | 373/1000 [42:57<1:12:11,  6.91s/it][Succeeded / Failed / Skipped / Total] 287 / 82 / 4 / 373:  37%|███▋      | 374/1000 [43:10<1:12:16,  6.93s/it]Get dependencies for ctor --> [[[FAILED]]]

[[[[Adv]]]]: private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 367 ---------------------------------------------
Find the next filter . --> [[[FAILED]]]

[[[[Adv]]]]: private Filter findNextFilter ( HttpServletRequest [[request]] ) { while ( ++ index < filterDefinitions . length ) { Filter [[filter]] = filterDefinitions [ index ] . getFilterIfMatching ( [[request]] ) ; if ( [[filter]] != null ) { return [[filter]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter findNextFilter ( HttpServletRequest [[yanqui]] ) { while ( ++ index < filterDefinitions . length ) { Filter [[boatmen]] = filterDefinitions [ index ] . getFilterIfMatching ( [[yanqui]] ) ; if ( [[boatmen]] != null ) { return [[boatmen]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 368 ---------------------------------------------
Gets the line number for the given member . --> [[[FAILED]]]

[[[[Adv]]]]: public Integer [[getLineNumber]] ( Member [[member]] ) { Preconditions . checkArgument ( type == [[member]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[member]] , [[member]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[member]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer [[authorizes]] ( Member [[assistants]] ) { Preconditions . checkArgument ( type == [[assistants]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[assistants]] , [[assistants]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[assistants]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 369 ---------------------------------------------
Initializes the injector . --> Clobox errors --> Socre: 1.0

[[[[Adv]]]]: void [[initialize]] ( Errors errors ) { injector . lookups = injector ; new LookupProcessor ( errors ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[clobbering]] ( Errors errors ) { injector . lookups = injector ; new LookupProcessor ( errors ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 370 ---------------------------------------------
Scan a module . --> can be null --> Socre: 1.0

[[[[Adv]]]]: public static Module [[forModule]] ( Object [[module]] , ModuleAnnotatedMethodScanner [[scanner]] ) { return forObject ( [[module]] , "False" != "False" , [[scanner]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module [[antonioni]] ( Object [[boatmen]] , ModuleAnnotatedMethodScanner [[onlv]] ) { return forObject ( [[boatmen]] , "False" != "False" , [[onlv]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 371 ---------------------------------------------
Wrap the callable in a future . --> minor is deprecated --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[continueRequest]] ( Callable < T > [[callable]] , Map < Key < ? > , Object > seedMap ) { return wrap ( [[callable]] , [[continueRequest]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[diminutive]] ( Callable < T > [[ponton]] , Map < Key < ? > , Object > seedMap ) { return wrap ( [[ponton]] , [[diminutive]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 372 ---------------------------------------------
Wraps the given callable . --> hava function --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > [[transferRequest]] ( Callable < T > [[callable]] ) { return wrap ( [[callable]] , [[transferRequest]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > [[ahí]] ( Callable < T > [[baklava]] ) { return wrap ( [[baklava]] , [[ahí]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 373 ---------------------------------------------
Validates the given value . --> biff is compatible --> Socre: 1.0

[[[[Adv]]]]: private static Object [[validateAndCanonicalizeValue]] ( Key < ? > key , Object [[object]] ) { if ( [[object]] == null || [[object]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[object]] ) ) { throw new IllegalArgumentException ( "Value[" + [[object]] + "] of type[" + [[object]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[object]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object [[biff]] ( Key < ? > key , Object [[balzac]] ) { if ( [[balzac]] == null || [[balzac]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[balzac]] ) ) { throw new IllegalArgumentException ( "Value[" + [[balzac]] + "] of type[" + [[balzac]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[balzac]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 374 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 288 / 82 / 4 / 374:  37%|███▋      | 374/1000 [43:10<1:12:16,  6.93s/it][Succeeded / Failed / Skipped / Total] 288 / 82 / 4 / 374:  38%|███▊      | 375/1000 [43:31<1:12:31,  6.96s/it][Succeeded / Failed / Skipped / Total] 289 / 82 / 4 / 375:  38%|███▊      | 375/1000 [43:31<1:12:32,  6.96s/it][Succeeded / Failed / Skipped / Total] 289 / 82 / 4 / 375:  38%|███▊      | 376/1000 [43:34<1:12:19,  6.95s/it][Succeeded / Failed / Skipped / Total] 290 / 82 / 4 / 376:  38%|███▊      | 376/1000 [43:34<1:12:19,  6.95s/it][Succeeded / Failed / Skipped / Total] 290 / 82 / 4 / 376:  38%|███▊      | 377/1000 [43:42<1:12:13,  6.96s/it][Succeeded / Failed / Skipped / Total] 291 / 82 / 4 / 377:  38%|███▊      | 377/1000 [43:42<1:12:13,  6.96s/it][Succeeded / Failed / Skipped / Total] 291 / 82 / 4 / 377:  38%|███▊      | 378/1000 [43:44<1:11:58,  6.94s/it][Succeeded / Failed / Skipped / Total] 291 / 83 / 4 / 378:  38%|███▊      | 378/1000 [43:44<1:11:58,  6.94s/it][Succeeded / Failed / Skipped / Total] 291 / 83 / 4 / 378:  38%|███▊      | 379/1000 [44:01<1:12:08,  6.97s/it]Creates a Key instance with an annotation strategy . --> hannnotationStrategy --> Socre: 1.0

[[[[Adv]]]]: static < T > Key < T > [[get]] ( Class < T > [[type]] , AnnotationStrategy annotationStrategy ) { return new Key < T > ( [[type]] , annotationStrategy ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > [[hanns]] ( Class < T > [[disse]] , AnnotationStrategy annotationStrategy ) { return new Key < T > ( [[disse]] , annotationStrategy ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 375 ---------------------------------------------
Gets the binding source . --> Implementation of Raymer --> Socre: 1.0

[[[[Adv]]]]: public String [[getBindingSource]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String [[raymer]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 376 ---------------------------------------------
Create a new injector for the given type . --> assigns all errors --> Socre: 1.0

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[createWithListeners]] ( TypeLiteral < T > type , Errors [[errors]] ) throws ErrorsException { int numErrorsBefore = [[errors]] . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { [[errors]] . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , [[errors]] ) ; [[errors]] . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( [[errors]] , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding [[binding]] : typeListenerBindings ) { TypeListener typeListener = [[binding]] . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && [[binding]] . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { [[errors]] . errorNotifyingTypeListener ( [[binding]] , type , e ) ; } } } encounter . invalidate ( ) ; [[errors]] . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[agata]] ( TypeLiteral < T > type , Errors [[youíre]] ) throws ErrorsException { int numErrorsBefore = [[youíre]] . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { [[youíre]] . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , [[youíre]] ) ; [[youíre]] . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( [[youíre]] , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding [[constitutes]] : typeListenerBindings ) { TypeListener typeListener = [[constitutes]] . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && [[constitutes]] . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { [[youíre]] . errorNotifyingTypeListener ( [[constitutes]] , type , e ) ; } } } encounter . invalidate ( ) ; [[youíre]] . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 377 ---------------------------------------------
Returns a strategy for the given annotation type . --> Methode permettant de classe --> Socre: 1.0

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > [[annotationType]] ) { [[annotationType]] = Annotations . canonicalizeIfNamed ( [[annotationType]] ) ; if ( isAllDefaultMethods ( [[annotationType]] ) ) { return [[strategyFor]] ( generateAnnotation ( [[annotationType]] ) ) ; } checkNotNull ( [[annotationType]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; return new AnnotationTypeStrategy ( [[annotationType]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[schroeder]] ( Class < ? extends Annotation > [[commandeered]] ) { [[commandeered]] = Annotations . canonicalizeIfNamed ( [[commandeered]] ) ; if ( isAllDefaultMethods ( [[commandeered]] ) ) { return [[schroeder]] ( generateAnnotation ( [[commandeered]] ) ) ; } checkNotNull ( [[commandeered]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[commandeered]] ) ; ensureIsBindingAnnotation ( [[commandeered]] ) ; return new AnnotationTypeStrategy ( [[commandeered]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 378 ---------------------------------------------
Try to find an annotation for a method . --> [[[FAILED]]]

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method [[method]] ) { if ( [[method]] . isBridge ( ) || [[method]] . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation [[foundAnnotation]] = [[method]] . getAnnotation ( annotationClass ) ; if ( [[foundAnnotation]] != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , [[method]] ) ; return null ; } annotation = [[foundAnnotation]] ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method [[kilometre]] ) { if ( [[kilometre]] . isBridge ( ) || [[kilometre]] . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation [[baccarat]] = [[kilometre]] . getAnnotation ( annotationClass ) ; if ( [[baccarat]] != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , [[kilometre]] ) ; return null ; } annotation = [[baccarat]] ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 379 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 291 / 84 / 4 / 379:  38%|███▊      | 379/1000 [44:01<1:12:08,  6.97s/it][Succeeded / Failed / Skipped / Total] 291 / 84 / 4 / 379:  38%|███▊      | 380/1000 [44:09<1:12:02,  6.97s/it][Succeeded / Failed / Skipped / Total] 291 / 85 / 4 / 380:  38%|███▊      | 380/1000 [44:09<1:12:02,  6.97s/it][Succeeded / Failed / Skipped / Total] 291 / 85 / 4 / 380:  38%|███▊      | 381/1000 [44:22<1:12:05,  6.99s/it][Succeeded / Failed / Skipped / Total] 292 / 85 / 4 / 381:  38%|███▊      | 381/1000 [44:22<1:12:05,  6.99s/it][Succeeded / Failed / Skipped / Total] 292 / 85 / 4 / 381:  38%|███▊      | 382/1000 [44:28<1:11:57,  6.99s/it][Succeeded / Failed / Skipped / Total] 293 / 85 / 4 / 382:  38%|███▊      | 382/1000 [44:28<1:11:57,  6.99s/it][Succeeded / Failed / Skipped / Total] 293 / 85 / 4 / 382:  38%|███▊      | 383/1000 [44:45<1:12:06,  7.01s/it][Succeeded / Failed / Skipped / Total] 294 / 85 / 4 / 383:  38%|███▊      | 383/1000 [44:45<1:12:06,  7.01s/it][Succeeded / Failed / Skipped / Total] 294 / 85 / 4 / 383:  38%|███▊      | 384/1000 [44:51<1:11:58,  7.01s/it][Succeeded / Failed / Skipped / Total] 294 / 86 / 4 / 384:  38%|███▊      | 384/1000 [44:51<1:11:58,  7.01s/it][Succeeded / Failed / Skipped / Total] 294 / 86 / 4 / 384:  38%|███▊      | 385/1000 [44:52<1:11:40,  6.99s/it][Succeeded / Failed / Skipped / Total] 295 / 86 / 4 / 385:  38%|███▊      | 385/1000 [44:52<1:11:40,  6.99s/it][Succeeded / Failed / Skipped / Total] 295 / 86 / 4 / 385:  39%|███▊      | 386/1000 [45:13<1:11:56,  7.03s/it]Returns a strategy for the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Annotation [[annotation]] ) { checkNotNull ( [[annotation]] , "annotation" ) ; Class < ? extends Annotation > [[annotationType]] = [[annotation]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; if ( Annotations . isMarker ( [[annotationType]] ) ) { return new AnnotationTypeStrategy ( [[annotationType]] , [[annotation]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[annotation]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy [[receiving]] ( Annotation [[shooters]] ) { checkNotNull ( [[shooters]] , "annotation" ) ; Class < ? extends Annotation > [[guedes]] = [[shooters]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[guedes]] ) ; ensureIsBindingAnnotation ( [[guedes]] ) ; if ( Annotations . isMarker ( [[guedes]] ) ) { return new AnnotationTypeStrategy ( [[guedes]] , [[shooters]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[shooters]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 380 ---------------------------------------------
Gets the injectors for the given injection points . --> [[[FAILED]]]

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[injectors]] = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; [[injectors]] . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[bridgette]] = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; [[bridgette]] . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 381 ---------------------------------------------
Convert an object to an element . --> Baklava style --> Socre: 1.0

[[[[Adv]]]]: static Object [[convert]] ( Object o ) { ElementSource source = null ; if ( o instanceof ElementSource ) { source = ( ElementSource ) o ; o = source . getDeclaringSource ( ) ; } return [[convert]] ( o , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object [[baklava]] ( Object o ) { ElementSource source = null ; if ( o instanceof ElementSource ) { source = ( ElementSource ) o ; o = source . getDeclaringSource ( ) ; } return [[baklava]] ( o , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 382 ---------------------------------------------
Creates a formatted message with the given message format and arguments . --> Convenience factory method --> Socre: 1.0

[[[[Adv]]]]: public static Message create ( String [[messageFormat]] , Object ... [[arguments]] ) { return create ( null , [[messageFormat]] , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message create ( String [[tantrum]] , Object ... [[devi]] ) { return create ( null , [[tantrum]] , [[devi]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 383 ---------------------------------------------
Gets the configuration source for the module classes . --> Configure a list of modules --> Socre: 1.0

[[[[Adv]]]]: public Object [[getFromClassNames]] ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String moduleClassName : moduleClassNames ) { if ( ! shouldBeSkipped ( moduleClassName ) ) { return new StackTraceElement ( moduleClassName , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object [[landlubbers]] ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String moduleClassName : moduleClassNames ) { if ( ! shouldBeSkipped ( moduleClassName ) ) { return new StackTraceElement ( moduleClassName , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 384 ---------------------------------------------
Determine if the given class should be skipped . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[shouldBeSkipped]] ( String [[className]] ) { return ( parent != null && parent . shouldBeSkipped ( [[className]] ) ) || classNamesToSkip . contains ( [[className]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean [[heartbreak]] ( String [[preach]] ) { return ( parent != null && parent . shouldBeSkipped ( [[preach]] ) ) || classNamesToSkip . contains ( [[preach]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
--------------------------------------------- Result 385 ---------------------------------------------
Manage jmx remote manager . --> Entry point to the bridge --> Socre: 1.0

[[[[Adv]]]]: public static void [[main]] ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void [[bridgette]] ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 386 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 296 / 86 / 4 / 386:  39%|███▊      | 386/1000 [45:13<1:11:56,  7.03s/it][Succeeded / Failed / Skipped / Total] 296 / 86 / 4 / 386:  39%|███▊      | 387/1000 [45:14<1:11:39,  7.01s/it][Succeeded / Failed / Skipped / Total] 297 / 86 / 4 / 387:  39%|███▊      | 387/1000 [45:14<1:11:39,  7.01s/it][Succeeded / Failed / Skipped / Total] 297 / 86 / 4 / 387:  39%|███▉      | 388/1000 [45:19<1:11:29,  7.01s/it][Succeeded / Failed / Skipped / Total] 297 / 87 / 4 / 388:  39%|███▉      | 388/1000 [45:19<1:11:29,  7.01s/it][Succeeded / Failed / Skipped / Total] 297 / 87 / 4 / 388:  39%|███▉      | 389/1000 [45:32<1:11:32,  7.02s/it][Succeeded / Failed / Skipped / Total] 298 / 87 / 4 / 389:  39%|███▉      | 389/1000 [45:32<1:11:32,  7.02s/it][Succeeded / Failed / Skipped / Total] 298 / 87 / 4 / 389:  39%|███▉      | 390/1000 [45:34<1:11:16,  7.01s/it][Succeeded / Failed / Skipped / Total] 299 / 87 / 4 / 390:  39%|███▉      | 390/1000 [45:34<1:11:16,  7.01s/it][Succeeded / Failed / Skipped / Total] 299 / 87 / 4 / 390:  39%|███▉      | 391/1000 [45:40<1:11:08,  7.01s/it][Succeeded / Failed / Skipped / Total] 299 / 88 / 4 / 391:  39%|███▉      | 391/1000 [45:40<1:11:08,  7.01s/it][Succeeded / Failed / Skipped / Total] 299 / 88 / 4 / 391:  39%|███▉      | 392/1000 [45:46<1:10:59,  7.01s/it][Succeeded / Failed / Skipped / Total] 300 / 88 / 4 / 392:  39%|███▉      | 392/1000 [45:46<1:10:59,  7.01s/it][Succeeded / Failed / Skipped / Total] 300 / 88 / 4 / 392:  39%|███▉      | 393/1000 [45:52<1:10:51,  7.00s/it][Succeeded / Failed / Skipped / Total] 301 / 88 / 4 / 393:  39%|███▉      | 393/1000 [45:52<1:10:51,  7.00s/it][Succeeded / Failed / Skipped / Total] 301 / 88 / 4 / 393:  39%|███▉      | 394/1000 [45:58<1:10:43,  7.00s/it]Removes the stack trace from a throwable . --> Remove poison - one or more classes --> Socre: 1.0

[[[[Adv]]]]: private void [[pruneStacktrace]] ( Throwable [[throwable]] ) { for ( Throwable t = [[throwable]] ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > [[pruned]] = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { [[pruned]] . add ( element ) ; } } t . setStackTrace ( [[pruned]] . toArray ( new StackTraceElement [ [[pruned]] . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void [[ooo]] ( Throwable [[cancer]] ) { for ( Throwable t = [[cancer]] ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > [[hiya]] = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { [[hiya]] . add ( element ) ; } } t . setStackTrace ( [[hiya]] . toArray ( new StackTraceElement [ [[hiya]] . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 387 ---------------------------------------------
Method pushState . --> Porthand method --> Socre: 1.0

[[[[Adv]]]]: void [[pushState]] ( com . google . inject . Key < ? > key , Object source ) { doPushState ( key , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void [[portholes]] ( com . google . inject . Key < ? > key , Object source ) { doPushState ( key , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 388 ---------------------------------------------
Creates a message from the given throwable and message . --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( Throwable cause , String [[messageFormat]] , Object ... [[arguments]] ) { return [[create]] ( cause , ImmutableList . of ( ) , [[messageFormat]] , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[budget]] ( Throwable cause , String [[oporto]] , Object ... [[coyotes]] ) { return [[budget]] ( cause , ImmutableList . of ( ) , [[oporto]] , [[coyotes]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 389 ---------------------------------------------
Process connection event . --> Process connection event --> Socre: 1.0

[[[[Adv]]]]: public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor [[processor]] : processorList ) { [[processor]] . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .

[[[[Adv]]]]: public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor [[andean]] : processorList ) { [[andean]] . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .
--------------------------------------------- Result 390 ---------------------------------------------
Creates a formatted message . --> Convenience factory method --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , List < Object > sources , String messageFormat , Object ... [[arguments]] ) { String message = format ( messageFormat , [[arguments]] ) ; return new Message ( sources , message , [[cause]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message [[illest]] ( Throwable [[darkness]] , List < Object > sources , String messageFormat , Object ... [[carlino]] ) { String message = format ( messageFormat , [[carlino]] ) ; return new Message ( sources , message , [[darkness]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 391 ---------------------------------------------
Returns an initializable instance --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Initializable < T > [[of]] ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > [[admiral]] ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 392 ---------------------------------------------
Pushes the dependency onto the dependency stack . --> add sigma --> Socre: 1.0

[[[[Adv]]]]: Dependency < ? > [[pushDependency]] ( Dependency < ? > [[dependency]] , Object source ) { Dependency < ? > [[previous]] = this . dependency ; this . dependency = [[dependency]] ; doPushState ( [[dependency]] , source ) ; return [[previous]] ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > [[sigma]] ( Dependency < ? > [[dies]] , Object source ) { Dependency < ? > [[serkan]] = this . dependency ; this . dependency = [[dies]] ; doPushState ( [[dies]] , source ) ; return [[serkan]] ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 393 ---------------------------------------------
Get the task result . --> we don t need to be synchronized --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[alzheimer]] > [[alzheimer]] getFutureTaskResult ( RunStateRecordedFutureTask < [[alzheimer]] > task , Logger logger ) { [[alzheimer]] t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 394 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 302 / 88 / 4 / 394:  39%|███▉      | 394/1000 [45:58<1:10:43,  7.00s/it][Succeeded / Failed / Skipped / Total] 302 / 88 / 4 / 394:  40%|███▉      | 395/1000 [46:00<1:10:28,  6.99s/it][Succeeded / Failed / Skipped / Total] 303 / 88 / 4 / 395:  40%|███▉      | 395/1000 [46:00<1:10:28,  6.99s/it][Succeeded / Failed / Skipped / Total] 303 / 88 / 4 / 395:  40%|███▉      | 396/1000 [46:01<1:10:11,  6.97s/it][Succeeded / Failed / Skipped / Total] 304 / 88 / 4 / 396:  40%|███▉      | 396/1000 [46:01<1:10:11,  6.97s/it][Succeeded / Failed / Skipped / Total] 304 / 88 / 4 / 396:  40%|███▉      | 397/1000 [46:14<1:10:13,  6.99s/it][Succeeded / Failed / Skipped / Total] 305 / 88 / 4 / 397:  40%|███▉      | 397/1000 [46:14<1:10:13,  6.99s/it][Succeeded / Failed / Skipped / Total] 305 / 88 / 4 / 397:  40%|███▉      | 398/1000 [46:19<1:10:03,  6.98s/it][Succeeded / Failed / Skipped / Total] 306 / 88 / 4 / 398:  40%|███▉      | 398/1000 [46:19<1:10:03,  6.98s/it][Succeeded / Failed / Skipped / Total] 306 / 88 / 4 / 398:  40%|███▉      | 399/1000 [46:27<1:09:58,  6.99s/it][Succeeded / Failed / Skipped / Total] 307 / 88 / 4 / 399:  40%|███▉      | 399/1000 [46:27<1:09:58,  6.99s/it][Succeeded / Failed / Skipped / Total] 307 / 88 / 4 / 399:  40%|████      | 400/1000 [46:36<1:09:54,  6.99s/it]Lazily executes the given Throwable . --> Throws unchecked exceptions . --> Socre: 1.0

[[[[Adv]]]]: public static void [[launderThrowable]] ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable

[[[[Adv]]]]: public static void [[afflicts]] ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 395 ---------------------------------------------
Register a remoting processor --> Registers a RemotingProcessor --> Socre: 1.0

[[[[Adv]]]]: public void [[registerProcessor]] ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . cmd2processors . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void [[cordially]] ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . cmd2processors . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 396 ---------------------------------------------
Adds a connection event processor . --> documentation inherited from interface ConnectionEventProcessor --> Socre: 1.0

[[[[Adv]]]]: public void [[addConnectionEventProcessor]] ( ConnectionEventType type , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > [[processorList]] = this . processors . get ( type ) ; if ( [[processorList]] == null ) { this . processors . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; [[processorList]] = this . processors . get ( type ) ; } [[processorList]] . add ( processor ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void [[dogcatcher]] ( ConnectionEventType type , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > [[puchi]] = this . processors . get ( type ) ; if ( [[puchi]] == null ) { this . processors . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; [[puchi]] = this . processors . get ( type ) ; } [[puchi]] . add ( processor ) ; }
[[[[Nl]]]]: Add event processor .
--------------------------------------------- Result 397 ---------------------------------------------
Creates a new instance . --> Aggregates the fogstas --> Socre: 1.0

[[[[Adv]]]]: protected T [[provision]] ( Provider < ? extends T > [[provider]] , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T [[t]] = [[provider]] . get ( ) ; if ( [[t]] == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( [[t]] ) ; return [[t]] ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T [[gangstas]] ( Provider < ? extends T > [[euphemism]] , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T [[firom]] = [[euphemism]] . get ( ) ; if ( [[firom]] == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( [[firom]] ) ; return [[firom]] ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .
--------------------------------------------- Result 398 ---------------------------------------------
Tries to get the URL . --> Checks if the given url is accepted . --> Socre: 1.0

[[[[Adv]]]]: private Url [[tryGet]] ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache

[[[[Adv]]]]: private Url [[accepts]] ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 399 ---------------------------------------------
Returns a map of all the connections in this group . --> region ConnectionPool Implementation --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > [[iterator]] = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( [[iterator]] . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = [[iterator]] . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { allConnections . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return allConnections ; }
[[[[Nl]]]]: Get all connections of all poolKey .

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > [[select]] = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( [[select]] . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = [[select]] . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { allConnections . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return allConnections ; }
[[[[Nl]]]]: Get all connections of all poolKey .
--------------------------------------------- Result 400 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 308 / 88 / 4 / 400:  40%|████      | 400/1000 [46:36<1:09:54,  6.99s/it][Succeeded / Failed / Skipped / Total] 308 / 88 / 4 / 400:  40%|████      | 401/1000 [46:46<1:09:52,  7.00s/it][Succeeded / Failed / Skipped / Total] 308 / 89 / 4 / 401:  40%|████      | 401/1000 [46:46<1:09:52,  7.00s/it][Succeeded / Failed / Skipped / Total] 308 / 89 / 4 / 401:  40%|████      | 402/1000 [46:48<1:09:37,  6.99s/it][Succeeded / Failed / Skipped / Total] 309 / 89 / 4 / 402:  40%|████      | 402/1000 [46:48<1:09:37,  6.99s/it][Succeeded / Failed / Skipped / Total] 309 / 89 / 4 / 402:  40%|████      | 403/1000 [46:58<1:09:34,  6.99s/it][Succeeded / Failed / Skipped / Total] 310 / 89 / 4 / 403:  40%|████      | 403/1000 [46:58<1:09:34,  6.99s/it][Succeeded / Failed / Skipped / Total] 310 / 89 / 4 / 403:  40%|████      | 404/1000 [47:03<1:09:25,  6.99s/it][Succeeded / Failed / Skipped / Total] 311 / 89 / 4 / 404:  40%|████      | 404/1000 [47:03<1:09:25,  6.99s/it][Succeeded / Failed / Skipped / Total] 311 / 89 / 4 / 404:  40%|████      | 405/1000 [47:09<1:09:16,  6.99s/it][Succeeded / Failed / Skipped / Total] 312 / 89 / 4 / 405:  40%|████      | 405/1000 [47:09<1:09:16,  6.99s/it][Succeeded / Failed / Skipped / Total] 312 / 89 / 4 / 405:  41%|████      | 406/1000 [47:09<1:08:59,  6.97s/it][Succeeded / Failed / Skipped / Total] 313 / 89 / 4 / 406:  41%|████      | 406/1000 [47:09<1:09:00,  6.97s/it][Succeeded / Failed / Skipped / Total] 313 / 89 / 4 / 406:  41%|████      | 407/1000 [47:18<1:08:55,  6.97s/it][Succeeded / Failed / Skipped / Total] 314 / 89 / 4 / 407:  41%|████      | 407/1000 [47:18<1:08:55,  6.97s/it][Succeeded / Failed / Skipped / Total] 314 / 89 / 4 / 407:  41%|████      | 408/1000 [47:24<1:08:47,  6.97s/it][Succeeded / Failed / Skipped / Total] 315 / 89 / 4 / 408:  41%|████      | 408/1000 [47:24<1:08:47,  6.97s/it][Succeeded / Failed / Skipped / Total] 315 / 89 / 4 / 408:  41%|████      | 409/1000 [47:26<1:08:33,  6.96s/it]Scan all idle pool tasks . --> Clears all idle connections . --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[scan]] ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan

[[[[Adv]]]]: @ Override public void [[airbrush]] ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 401 ---------------------------------------------
Registers the default processor --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerDefaultProcessor]] ( RemotingProcessor < ? > processor ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void [[divorcée]] ( RemotingProcessor < ? > processor ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 402 ---------------------------------------------
Create a connection to the remote server . --> Acquire an aqued connection --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[createConnectionAndHealIfNeed]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void [[aqueduct]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 403 ---------------------------------------------
Removes a connection task . --> Removes a connection from the pool . --> Socre: 1.0

[[[[Adv]]]]: private void removeTask ( String [[poolKey]] ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( [[poolKey]] ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void removeTask ( String [[tera]] ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( [[tera]] ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 404 ---------------------------------------------
Gets and creates a connection . --> This method is used to repair a connection --> Socre: 1.0

[[[[Adv]]]]: @ Override public Connection [[getAndCreateIfAbsent]] ( Url [[url]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection [[diminish]] ( Url [[seki]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 405 ---------------------------------------------
Removes the given url from the pool if needed . --> Sets beatnik . --> Socre: 1.0

[[[[Adv]]]]: private void [[healIfNeed]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void [[beatnik]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected
--------------------------------------------- Result 406 ---------------------------------------------
Decodes the protocol code . --> Checks to see if we can wagging a queue . --> Socre: 1.0

[[[[Adv]]]]: protected ProtocolCode [[decodeProtocolCode]] ( ByteBuf [[in]] ) { if ( [[in]] . readableBytes ( ) >= protocolCodeLength ) { byte [ ] [[protocolCodeBytes]] = new byte [ protocolCodeLength ] ; [[in]] . readBytes ( [[protocolCodeBytes]] ) ; return ProtocolCode . fromBytes ( [[protocolCodeBytes]] ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode [[wagging]] ( ByteBuf [[brautigan]] ) { if ( [[brautigan]] . readableBytes ( ) >= protocolCodeLength ) { byte [ ] [[animals]] = new byte [ protocolCodeLength ] ; [[brautigan]] . readBytes ( [[animals]] ) ; return ProtocolCode . fromBytes ( [[animals]] ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 407 ---------------------------------------------
Closes a connection . --> Removes the connection from the cache . --> Socre: 1.0

[[[[Adv]]]]: public void [[closeConnection]] ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address

[[[[Adv]]]]: public void [[allegations]] ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 408 ---------------------------------------------
Get a processor for a given command code --> Returns morg --> Socre: 1.0

[[[[Adv]]]]: public RemotingProcessor < ? > [[getProcessor]] ( CommandCode cmdCode ) { RemotingProcessor < ? > [[processor]] = this . [[cmd2processors]] . get ( cmdCode ) ; if ( [[processor]] != null ) { return [[processor]] ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > [[morg]] ( CommandCode cmdCode ) { RemotingProcessor < ? > [[buckland]] = this . [[onal]] . get ( cmdCode ) ; if ( [[buckland]] != null ) { return [[buckland]] ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .
--------------------------------------------- Result 409 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 316 / 89 / 4 / 409:  41%|████      | 409/1000 [47:26<1:08:33,  6.96s/it][Succeeded / Failed / Skipped / Total] 316 / 89 / 4 / 409:  41%|████      | 410/1000 [47:27<1:08:17,  6.95s/it][Succeeded / Failed / Skipped / Total] 317 / 89 / 4 / 410:  41%|████      | 410/1000 [47:27<1:08:17,  6.95s/it][Succeeded / Failed / Skipped / Total] 317 / 89 / 4 / 410:  41%|████      | 411/1000 [47:46<1:08:28,  6.98s/it][Succeeded / Failed / Skipped / Total] 318 / 89 / 4 / 411:  41%|████      | 411/1000 [47:46<1:08:28,  6.98s/it][Succeeded / Failed / Skipped / Total] 318 / 89 / 4 / 411:  41%|████      | 412/1000 [47:48<1:08:13,  6.96s/it][Succeeded / Failed / Skipped / Total] 319 / 89 / 4 / 412:  41%|████      | 412/1000 [47:48<1:08:13,  6.96s/it][Succeeded / Failed / Skipped / Total] 319 / 89 / 4 / 412:  41%|████▏     | 413/1000 [47:57<1:08:09,  6.97s/it][Succeeded / Failed / Skipped / Total] 320 / 89 / 4 / 413:  41%|████▏     | 413/1000 [47:57<1:08:09,  6.97s/it][Succeeded / Failed / Skipped / Total] 320 / 89 / 4 / 413:  41%|████▏     | 414/1000 [48:07<1:08:06,  6.97s/it][Succeeded / Failed / Skipped / Total] 321 / 89 / 4 / 414:  41%|████▏     | 414/1000 [48:07<1:08:06,  6.97s/it][Succeeded / Failed / Skipped / Total] 321 / 89 / 4 / 414:  42%|████▏     | 415/1000 [48:08<1:07:51,  6.96s/it]Do create . --> Creates adelina connection --> Socre: 1.0

[[[[Adv]]]]: private void [[doCreate]] ( final Url [[url]] , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = [[url]] . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( [[url]] . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( [[url]] ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > [[url]] . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + [[url]] . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections

[[[[Adv]]]]: private void [[adelina]] ( final Url [[theaters]] , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = [[theaters]] . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( [[theaters]] . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( [[theaters]] ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > [[theaters]] . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + [[theaters]] . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 410 ---------------------------------------------
Called when the connection is closed . --> Called by the client --> Socre: 1.0

[[[[Adv]]]]: public void [[onClose]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void [[apace]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 411 ---------------------------------------------
Dispatch request to user process . --> Logs reverse routing . --> Socre: 1.0

[[[[Adv]]]]: private void [[dispatchToUserProcessor]] ( RemotingContext ctx , RpcRequestCommand cmd ) { final int id = cmd . getId ( ) ; final byte type = cmd . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor

[[[[Adv]]]]: private void [[averse]] ( RemotingContext ctx , RpcRequestCommand cmd ) { final int id = cmd . getId ( ) ; final byte type = cmd . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor
--------------------------------------------- Result 412 ---------------------------------------------
Register a multi interest user processor . --> Registers the userProcessor --> Socre: 1.0

[[[[Adv]]]]: private static void registerUserProcessor ( MultiInterestUserProcessor < ? > [[processor]] , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == [[processor]] . multiInterest ( ) || [[processor]] . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : [[processor]] . multiInterest ( ) ) { UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( interest , [[processor]] ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void registerUserProcessor ( MultiInterestUserProcessor < ? > [[boyish]] , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == [[boyish]] . multiInterest ( ) || [[boyish]] . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : [[boyish]] . multiInterest ( ) ) { UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( interest , [[boyish]] ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .
--------------------------------------------- Result 413 ---------------------------------------------
Sets an attribute to the given value . --> add a Bohunk --> Socre: 1.0

[[[[Adv]]]]: public Object [[setAttributeIfAbsent]] ( String [[key]] , Object value ) { return attributes . putIfAbsent ( [[key]] , value ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object [[bohunk]] ( String [[sift]] , Object value ) { return attributes . putIfAbsent ( [[sift]] , value ) ; }
[[[[Nl]]]]: set attribute if key absent .
--------------------------------------------- Result 414 ---------------------------------------------
Registers a user processor . --> Registers a ButterWax --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerUserProcessor]] ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { [[registerUserProcessor]] ( ( MultiInterestUserProcessor ) processor , [[userProcessors]] ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = [[userProcessors]] . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void [[beeswax]] ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[endowment]] ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { [[beeswax]] ( ( MultiInterestUserProcessor ) processor , [[endowment]] ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = [[endowment]] . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .
--------------------------------------------- Result 415 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 322 / 89 / 4 / 415:  42%|████▏     | 415/1000 [48:08<1:07:51,  6.96s/it][Succeeded / Failed / Skipped / Total] 322 / 89 / 4 / 415:  42%|████▏     | 416/1000 [48:09<1:07:37,  6.95s/it][Succeeded / Failed / Skipped / Total] 323 / 89 / 4 / 416:  42%|████▏     | 416/1000 [48:09<1:07:37,  6.95s/it][Succeeded / Failed / Skipped / Total] 323 / 89 / 4 / 416:  42%|████▏     | 417/1000 [48:19<1:07:33,  6.95s/it][Succeeded / Failed / Skipped / Total] 324 / 89 / 4 / 417:  42%|████▏     | 417/1000 [48:19<1:07:33,  6.95s/it][Succeeded / Failed / Skipped / Total] 324 / 89 / 4 / 417:  42%|████▏     | 418/1000 [48:24<1:07:23,  6.95s/it][Succeeded / Failed / Skipped / Total] 325 / 89 / 4 / 418:  42%|████▏     | 418/1000 [48:24<1:07:23,  6.95s/it][Succeeded / Failed / Skipped / Total] 325 / 89 / 4 / 418:  42%|████▏     | 419/1000 [48:24<1:07:07,  6.93s/it][Succeeded / Failed / Skipped / Total] 325 / 89 / 5 / 419:  42%|████▏     | 419/1000 [48:24<1:07:07,  6.93s/it][Succeeded / Failed / Skipped / Total] 325 / 89 / 5 / 419:  42%|████▏     | 420/1000 [48:27<1:06:55,  6.92s/it]Post process remoting context . --> Sets request information . --> Socre: 1.0

[[[[Adv]]]]: private void [[preProcessRemotingContext]] ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz

[[[[Adv]]]]: private void [[airing]] ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz
--------------------------------------------- Result 416 ---------------------------------------------
Deserialize RpcRequestCommand --> Determine whether or not the RpcRequestCommand should be handled . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[deserializeRequestCommand]] ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = "[[True]]" == "[[True]]" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command

[[[[Adv]]]]: private boolean [[bambam]] ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = "[[Freshened]]" == "[[Freshened]]" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command
--------------------------------------------- Result 417 ---------------------------------------------
Log debug log . --> Logal arrival time . --> Socre: 1.0

[[[[Adv]]]]: private void [[debugLog]] ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request

[[[[Adv]]]]: private void [[alzheimer]] ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request
--------------------------------------------- Result 418 ---------------------------------------------
Print timeout log . --> remaining wait time --> Socre: 1.0

[[[[Adv]]]]: private void [[timeoutLog]] ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext [[ctx]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != [[ctx]] ) { ChannelHandlerContext channelCtx = [[ctx]] . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .

[[[[Adv]]]]: private void [[miniskirts]] ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext [[cantrell]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != [[cantrell]] ) { ChannelHandlerContext channelCtx = [[cantrell]] . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .
--------------------------------------------- Result 419 ---------------------------------------------
Converts an integer value into a BitSet --> [[[SKIPPED]]]

[[[[Adv]]]]: public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set
--------------------------------------------- Result 420 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 326 / 89 / 5 / 420:  42%|████▏     | 420/1000 [48:27<1:06:55,  6.92s/it][Succeeded / Failed / Skipped / Total] 326 / 89 / 5 / 420:  42%|████▏     | 421/1000 [48:27<1:06:39,  6.91s/it][Succeeded / Failed / Skipped / Total] 326 / 89 / 6 / 421:  42%|████▏     | 421/1000 [48:27<1:06:39,  6.91s/it][Succeeded / Failed / Skipped / Total] 326 / 89 / 6 / 421:  42%|████▏     | 422/1000 [48:36<1:06:34,  6.91s/it][Succeeded / Failed / Skipped / Total] 327 / 89 / 6 / 422:  42%|████▏     | 422/1000 [48:36<1:06:34,  6.91s/it][Succeeded / Failed / Skipped / Total] 327 / 89 / 6 / 422:  42%|████▏     | 423/1000 [48:42<1:06:26,  6.91s/it][Succeeded / Failed / Skipped / Total] 328 / 89 / 6 / 423:  42%|████▏     | 423/1000 [48:42<1:06:26,  6.91s/it][Succeeded / Failed / Skipped / Total] 328 / 89 / 6 / 423:  42%|████▏     | 424/1000 [48:45<1:06:14,  6.90s/it]Processes the message . --> Processes an entity --> Socre: 1.0

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T [[msg]] , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , [[msg]] ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T [[anselm]] , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , [[anselm]] ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .
--------------------------------------------- Result 421 ---------------------------------------------
Stops the service . --> [[[SKIPPED]]]

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread
--------------------------------------------- Result 422 ---------------------------------------------
Execute the invoke with a callback . --> Invoke a remoting command --> Socre: 1.0

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection [[conn]] , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( [[conn]] , request , request . getInvokeContext ( ) , invokeCallback ) ; [[conn]] . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = [[conn]] . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( [[conn]] . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; [[conn]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = [[conn]] . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[conn]] . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = [[conn]] . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[conn]] . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection [[natalie]] , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( [[natalie]] , request , request . getInvokeContext ( ) , invokeCallback ) ; [[natalie]] . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = [[natalie]] . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( [[natalie]] . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; [[natalie]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = [[natalie]] . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[natalie]] . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[natalie]] . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = [[natalie]] . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[natalie]] . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[natalie]] . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .
--------------------------------------------- Result 423 ---------------------------------------------
To byte value . --> Calculate DORman value . --> Socre: 1.0

[[[[Adv]]]]: public static byte [[toByte]] ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte

[[[[Adv]]]]: public static byte [[dorfman]] ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte
--------------------------------------------- Result 424 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 328 / 90 / 6 / 424:  42%|████▏     | 424/1000 [48:45<1:06:14,  6.90s/it][Succeeded / Failed / Skipped / Total] 328 / 90 / 6 / 424:  42%|████▎     | 425/1000 [48:59<1:06:17,  6.92s/it][Succeeded / Failed / Skipped / Total] 329 / 90 / 6 / 425:  42%|████▎     | 425/1000 [48:59<1:06:17,  6.92s/it][Succeeded / Failed / Skipped / Total] 329 / 90 / 6 / 425:  43%|████▎     | 426/1000 [49:09<1:06:13,  6.92s/it][Succeeded / Failed / Skipped / Total] 329 / 91 / 6 / 426:  43%|████▎     | 426/1000 [49:09<1:06:13,  6.92s/it][Succeeded / Failed / Skipped / Total] 329 / 91 / 6 / 426:  43%|████▎     | 427/1000 [49:09<1:05:58,  6.91s/it]Close the connection . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[close]] ( ) { if ( closed . compareAndSet ( "[[False]]" != "[[False]]" , "[[True]]" == "[[True]]" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void [[compromised]] ( ) { if ( closed . compareAndSet ( "[[Inequalities]]" != "[[Inequalities]]" , "[[Crybaby]]" == "[[Crybaby]]" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .
--------------------------------------------- Result 425 ---------------------------------------------
Filter connections --> Filters a list of connection --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection [[connection]] : connections ) { String serviceStatus = ( String ) [[connection]] . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( [[connection]] . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( [[connection]] ) ) { serviceOffConnections . add ( [[connection]] ) ; } } else { serviceOnConnections . add ( [[connection]] ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection [[outraged]] : connections ) { String serviceStatus = ( String ) [[outraged]] . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( [[outraged]] . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( [[outraged]] ) ) { serviceOffConnections . add ( [[outraged]] ) ; } } else { serviceOnConnections . add ( [[outraged]] ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor
--------------------------------------------- Result 426 ---------------------------------------------
Pretty prints the given error messages . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[formatMessages]] ( String heading , Collection < Message > [[errorMessages]] ) { Formatter [[fmt]] = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( [[errorMessages]] ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : [[errorMessages]] ) { int thisIdx = index ++ ; [[fmt]] . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( [[fmt]] , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; [[fmt]] . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; [[fmt]] . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } [[fmt]] . format ( "%n" ) ; } if ( [[errorMessages]] . size ( ) == 1 ) { [[fmt]] . format ( "1 error" ) ; } else { [[fmt]] . format ( "%s errors" , [[errorMessages]] . size ( ) ) ; } return [[fmt]] . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String [[bernardino]] ( String heading , Collection < Message > [[harmonia]] ) { Formatter [[accountability]] = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( [[harmonia]] ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : [[harmonia]] ) { int thisIdx = index ++ ; [[accountability]] . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( [[accountability]] , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; [[accountability]] . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; [[accountability]] . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } [[accountability]] . format ( "%n" ) ; } if ( [[harmonia]] . size ( ) == 1 ) { [[accountability]] . format ( "1 error" ) ; } else { [[accountability]] . format ( "%s errors" , [[harmonia]] . size ( ) ) ; } return [[accountability]] . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 427 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 330 / 91 / 6 / 427:  43%|████▎     | 427/1000 [49:09<1:05:58,  6.91s/it][Succeeded / Failed / Skipped / Total] 330 / 91 / 6 / 427:  43%|████▎     | 428/1000 [49:14<1:05:48,  6.90s/it][Succeeded / Failed / Skipped / Total] 331 / 91 / 6 / 428:  43%|████▎     | 428/1000 [49:14<1:05:48,  6.90s/it][Succeeded / Failed / Skipped / Total] 331 / 91 / 6 / 428:  43%|████▎     | 429/1000 [49:23<1:05:44,  6.91s/it][Succeeded / Failed / Skipped / Total] 332 / 91 / 6 / 429:  43%|████▎     | 429/1000 [49:23<1:05:44,  6.91s/it][Succeeded / Failed / Skipped / Total] 332 / 91 / 6 / 429:  43%|████▎     | 430/1000 [49:23<1:05:28,  6.89s/it][Succeeded / Failed / Skipped / Total] 333 / 91 / 6 / 430:  43%|████▎     | 430/1000 [49:23<1:05:28,  6.89s/it][Succeeded / Failed / Skipped / Total] 333 / 91 / 6 / 430:  43%|████▎     | 431/1000 [49:24<1:05:13,  6.88s/it]Convert request to remoting command . --> dahng --> Socre: 1.0

[[[[Adv]]]]: protected RemotingCommand [[toRemotingCommand]] ( Object [[request]] , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( [[request]] ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .

[[[[Adv]]]]: protected RemotingCommand [[adrienne]] ( Object [[dahn]] , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( [[dahn]] ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .
--------------------------------------------- Result 428 ---------------------------------------------
This method is used to monitor the active connection pools . --> Implements the monitoring of the configured connection pools . --> Socre: 1.0

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection [[lastSelectConnect]] = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( [[lastSelectConnect]] , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection [[lastSelectConnect]] = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( [[lastSelectConnect]] , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection [[ionosphere]] = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( [[ionosphere]] , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection [[ionosphere]] = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( [[ionosphere]] , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off
--------------------------------------------- Result 429 ---------------------------------------------
Gets a boolean property . --> Returns boolean value for given key . --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[getBool]] ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property

[[[[Adv]]]]: public static boolean [[anyplace]] ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property
--------------------------------------------- Result 430 ---------------------------------------------
Invoked when a remote command is received . --> This method is responsible for sending the request to the remote peer --> Socre: 1.0

[[[[Adv]]]]: protected void oneway ( final Connection [[conn]] , final RemotingCommand request ) { try { [[conn]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[f]] ) throws Exception { if ( ! [[f]] . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , [[f]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[conn]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .

[[[[Adv]]]]: protected void oneway ( final Connection [[colonise]] , final RemotingCommand request ) { try { [[colonise]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[tracking]] ) throws Exception { if ( ! [[tracking]] . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[colonise]] . getChannel ( ) ) , [[tracking]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[colonise]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[colonise]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .
--------------------------------------------- Result 431 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 333 / 91 / 7 / 431:  43%|████▎     | 431/1000 [49:24<1:05:13,  6.88s/it][Succeeded / Failed / Skipped / Total] 333 / 91 / 7 / 431:  43%|████▎     | 432/1000 [49:28<1:05:02,  6.87s/it][Succeeded / Failed / Skipped / Total] 334 / 91 / 7 / 432:  43%|████▎     | 432/1000 [49:28<1:05:02,  6.87s/it][Succeeded / Failed / Skipped / Total] 334 / 91 / 7 / 432:  43%|████▎     | 433/1000 [49:30<1:04:49,  6.86s/it][Succeeded / Failed / Skipped / Total] 335 / 91 / 7 / 433:  43%|████▎     | 433/1000 [49:30<1:04:49,  6.86s/it][Succeeded / Failed / Skipped / Total] 335 / 91 / 7 / 433:  43%|████▎     | 434/1000 [49:30<1:04:33,  6.84s/it][Succeeded / Failed / Skipped / Total] 336 / 91 / 7 / 434:  43%|████▎     | 434/1000 [49:30<1:04:33,  6.84s/it][Succeeded / Failed / Skipped / Total] 336 / 91 / 7 / 434:  44%|████▎     | 435/1000 [49:33<1:04:21,  6.84s/it][Succeeded / Failed / Skipped / Total] 337 / 91 / 7 / 435:  44%|████▎     | 435/1000 [49:33<1:04:21,  6.84s/it][Succeeded / Failed / Skipped / Total] 337 / 91 / 7 / 435:  44%|████▎     | 436/1000 [49:44<1:04:20,  6.84s/it][Succeeded / Failed / Skipped / Total] 338 / 91 / 7 / 436:  44%|████▎     | 436/1000 [49:44<1:04:20,  6.84s/it][Succeeded / Failed / Skipped / Total] 338 / 91 / 7 / 436:  44%|████▎     | 437/1000 [49:49<1:04:11,  6.84s/it][Succeeded / Failed / Skipped / Total] 339 / 91 / 7 / 437:  44%|████▎     | 437/1000 [49:49<1:04:11,  6.84s/it][Succeeded / Failed / Skipped / Total] 339 / 91 / 7 / 437:  44%|████▍     | 438/1000 [49:50<1:03:57,  6.83s/it][Succeeded / Failed / Skipped / Total] 340 / 91 / 7 / 438:  44%|████▍     | 438/1000 [49:50<1:03:57,  6.83s/it][Succeeded / Failed / Skipped / Total] 340 / 91 / 7 / 438:  44%|████▍     | 439/1000 [49:50<1:03:42,  6.81s/it][Succeeded / Failed / Skipped / Total] 340 / 91 / 8 / 439:  44%|████▍     | 439/1000 [49:50<1:03:42,  6.81s/it][Succeeded / Failed / Skipped / Total] 340 / 91 / 8 / 439:  44%|████▍     | 440/1000 [49:52<1:03:29,  6.80s/it]Returns the value for the given key . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . context . get ( key ) != null ? ( T ) this . context . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found
--------------------------------------------- Result 432 ---------------------------------------------
Log an info log . --> Prints an IP address --> Socre: 1.0

[[[[Adv]]]]: private void [[infoLog]] ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log

[[[[Adv]]]]: private void [[axles]] ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log
--------------------------------------------- Result 433 ---------------------------------------------
Check for fresh select connections --> Checks to see if there is a reconnect --> Socre: 1.0

[[[[Adv]]]]: private void [[closeFreshSelectConnections]] ( Connection [[lastSelectConnect]] , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != [[lastSelectConnect]] ) { if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[lastSelectConnect]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[lastSelectConnect]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[lastSelectConnect]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections

[[[[Adv]]]]: private void [[grosses]] ( Connection [[banana]] , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != [[banana]] ) { if ( [[banana]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[banana]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[banana]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[banana]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[banana]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections
--------------------------------------------- Result 434 ---------------------------------------------
Adds a new reconnect task . --> Attempts to establish a re - wire . --> Socre: 1.0

[[[[Adv]]]]: public void [[addReconnectTask]] ( Url [[url]] ) { ReconnectTask [[task]] = new ReconnectTask ( ) ; [[task]] . url = [[url]] ; tasks . add ( [[task]] ) ; }
[[[[Nl]]]]: add reconnect task

[[[[Adv]]]]: public void [[aho]] ( Url [[evoked]] ) { ReconnectTask [[yorkshire]] = new ReconnectTask ( ) ; [[yorkshire]] . url = [[evoked]] ; tasks . add ( [[yorkshire]] ) ; }
[[[[Nl]]]]: add reconnect task
--------------------------------------------- Result 435 ---------------------------------------------
Checks if request timeout . --> Return true if any arrive . --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isRequestTimeout]] ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout

[[[[Adv]]]]: public boolean [[anyplace]] ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout
--------------------------------------------- Result 436 ---------------------------------------------
Get a property by key --> Gets cata . --> Socre: 1.0

[[[[Adv]]]]: public String [[getProperty]] ( String key ) { if ( properties == null ) { return null ; } return properties . getProperty ( key ) ; }
[[[[Nl]]]]: Get property value according to property key

[[[[Adv]]]]: public String [[cata]] ( String key ) { if ( properties == null ) { return null ; } return properties . getProperty ( key ) ; }
[[[[Nl]]]]: Get property value according to property key
--------------------------------------------- Result 437 ---------------------------------------------
Get a random connection from the list of connections --> Tries to nicestrano . --> Socre: 1.0

[[[[Adv]]]]: private Connection [[randomGet]] ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly

[[[[Adv]]]]: private Connection [[nicaragua]] ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly
--------------------------------------------- Result 438 ---------------------------------------------
Deserialize response object . --> Called when cittest --> Socre: 1.0

[[[[Adv]]]]: private static Object [[toResponseObject]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) responseCommand ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .

[[[[Adv]]]]: private static Object [[città]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) responseCommand ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .
--------------------------------------------- Result 439 ---------------------------------------------
Creates a new EventLoopGroup --> [[[SKIPPED]]]

[[[[Adv]]]]: public static EventLoopGroup newEventLoopGroup ( int nThreads , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , threadFactory ) : new NioEventLoopGroup ( nThreads , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .
--------------------------------------------- Result 440 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 341 / 91 / 8 / 440:  44%|████▍     | 440/1000 [49:52<1:03:29,  6.80s/it][Succeeded / Failed / Skipped / Total] 341 / 91 / 8 / 440:  44%|████▍     | 441/1000 [49:54<1:03:15,  6.79s/it][Succeeded / Failed / Skipped / Total] 342 / 91 / 8 / 441:  44%|████▍     | 441/1000 [49:54<1:03:15,  6.79s/it][Succeeded / Failed / Skipped / Total] 342 / 91 / 8 / 441:  44%|████▍     | 442/1000 [50:14<1:03:25,  6.82s/it][Succeeded / Failed / Skipped / Total] 343 / 91 / 8 / 442:  44%|████▍     | 442/1000 [50:14<1:03:25,  6.82s/it][Succeeded / Failed / Skipped / Total] 343 / 91 / 8 / 442:  44%|████▍     | 443/1000 [50:14<1:03:10,  6.81s/it][Succeeded / Failed / Skipped / Total] 344 / 91 / 8 / 443:  44%|████▍     | 443/1000 [50:14<1:03:10,  6.81s/it][Succeeded / Failed / Skipped / Total] 345 / 91 / 8 / 444:  44%|████▍     | 444/1000 [50:14<1:02:55,  6.79s/it][Succeeded / Failed / Skipped / Total] 345 / 91 / 8 / 444:  44%|████▍     | 445/1000 [50:22<1:02:49,  6.79s/it][Succeeded / Failed / Skipped / Total] 346 / 91 / 8 / 445:  44%|████▍     | 445/1000 [50:22<1:02:49,  6.79s/it]Attempt to resolve a response object from a remote address . --> Deserializes an ASP --> Socre: 1.0

[[[[Adv]]]]: public static Object [[resolveResponseObject]] ( ResponseCommand responseCommand , String addr ) throws RemotingException { preProcess ( responseCommand , addr ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; logger . warn ( msg ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( msg , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .

[[[[Adv]]]]: public static Object [[pasó]] ( ResponseCommand responseCommand , String addr ) throws RemotingException { preProcess ( responseCommand , addr ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; logger . warn ( msg ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( msg , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .
--------------------------------------------- Result 441 ---------------------------------------------
Print error message --> Convert responseCommand to string . --> Socre: 1.0

[[[[Adv]]]]: private static String [[detailErrMsg]] ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command

[[[[Adv]]]]: private static String [[cup]] ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command
--------------------------------------------- Result 442 ---------------------------------------------
Converts a responseCommand to a Throwable . --> Extracts the exception from the responseCommand object --> Socre: 1.0

[[[[Adv]]]]: private static Throwable [[toThrowable]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand [[resp]] = ( RpcResponseCommand ) responseCommand ; [[resp]] . deserialize ( ) ; Object ex = [[resp]] . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .

[[[[Adv]]]]: private static Throwable [[averaged]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand [[environmentalist]] = ( RpcResponseCommand ) responseCommand ; [[environmentalist]] . deserialize ( ) ; Object ex = [[environmentalist]] . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .
--------------------------------------------- Result 443 ---------------------------------------------
Print connection trace log --> Called to send information about the client . --> Socre: 1.0

[[[[Adv]]]]: public static void [[printConnectionTraceLog]] ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log

[[[[Adv]]]]: public static void [[cervezas]] ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log
--------------------------------------------- Result 444 ---------------------------------------------
Get the remote address of the channel . --> Get MondAYAYAY --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteIP]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .

[[[[Adv]]]]: public static String [[mondays]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .
--------------------------------------------- Result 445 ---------------------------------------------
Gets a user processor . --> Checks to see if the given distember is a survivor --> Socre: 1.0

[[[[Adv]]]]: public UserProcessor < ? > [[getUserProcessor]] ( String [[className]] ) { return StringUtils . isBlank ( [[className]] ) ? null : this . [[userProcessors]] . get ( [[className]] ) ; }
[[[[Nl]]]]: Get user processor for class name .

[[[[Adv]]]]: public UserProcessor < ? > [[hanky]] ( String [[distillery]] ) { return StringUtils . isBlank ( [[distillery]] ) ? null : this . [[roe]] . get ( [[distillery]] ) ; }
[[[[Nl]]]]: Get user processor for class name .
--------------------------------------------- Result 446 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 347 / 91 / 8 / 446:  45%|████▍     | 446/1000 [50:27<1:02:40,  6.79s/it][Succeeded / Failed / Skipped / Total] 347 / 91 / 8 / 446:  45%|████▍     | 447/1000 [50:49<1:02:52,  6.82s/it][Succeeded / Failed / Skipped / Total] 347 / 92 / 8 / 447:  45%|████▍     | 447/1000 [50:49<1:02:52,  6.82s/it][Succeeded / Failed / Skipped / Total] 347 / 92 / 8 / 447:  45%|████▍     | 448/1000 [50:50<1:02:38,  6.81s/it][Succeeded / Failed / Skipped / Total] 347 / 93 / 8 / 448:  45%|████▍     | 448/1000 [50:50<1:02:38,  6.81s/it][Succeeded / Failed / Skipped / Total] 347 / 93 / 8 / 448:  45%|████▍     | 449/1000 [50:53<1:02:27,  6.80s/it][Succeeded / Failed / Skipped / Total] 348 / 93 / 8 / 449:  45%|████▍     | 449/1000 [50:53<1:02:27,  6.80s/it][Succeeded / Failed / Skipped / Total] 348 / 93 / 8 / 449:  45%|████▌     | 450/1000 [50:54<1:02:13,  6.79s/it][Succeeded / Failed / Skipped / Total] 349 / 93 / 8 / 450:  45%|████▌     | 450/1000 [50:54<1:02:13,  6.79s/it][Succeeded / Failed / Skipped / Total] 349 / 93 / 8 / 450:  45%|████▌     | 451/1000 [51:15<1:02:24,  6.82s/it][Succeeded / Failed / Skipped / Total] 350 / 93 / 8 / 451:  45%|████▌     | 451/1000 [51:15<1:02:24,  6.82s/it][Succeeded / Failed / Skipped / Total] 350 / 93 / 8 / 451:  45%|████▌     | 452/1000 [51:26<1:02:22,  6.83s/it][Succeeded / Failed / Skipped / Total] 351 / 93 / 8 / 452:  45%|████▌     | 452/1000 [51:26<1:02:22,  6.83s/it][Succeeded / Failed / Skipped / Total] 351 / 93 / 8 / 452:  45%|████▌     | 453/1000 [51:28<1:02:09,  6.82s/it][Succeeded / Failed / Skipped / Total] 352 / 93 / 8 / 453:  45%|████▌     | 453/1000 [51:28<1:02:09,  6.82s/it][Succeeded / Failed / Skipped / Total] 352 / 93 / 8 / 453:  45%|████▌     | 454/1000 [51:30<1:01:57,  6.81s/it][Succeeded / Failed / Skipped / Total] 353 / 93 / 8 / 454:  45%|████▌     | 454/1000 [51:30<1:01:57,  6.81s/it][Succeeded / Failed / Skipped / Total] 353 / 93 / 8 / 454:  46%|████▌     | 455/1000 [51:47<1:02:02,  6.83s/it]Convert a Throwable to a RpcServerException . --> Creates an RpcServerException object --> Socre: 1.0

[[[[Adv]]]]: private RpcServerException createServerException ( Throwable [[t]] , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , [[t]] . getClass ( ) . getName ( ) , [[t]] . getMessage ( ) , errMsg ) ; RpcServerException [[e]] = new RpcServerException ( formattedErrMsg ) ; [[e]] . setStackTrace ( [[t]] . getStackTrace ( ) ) ; return [[e]] ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .

[[[[Adv]]]]: private RpcServerException createServerException ( Throwable [[bulgur]] , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , [[bulgur]] . getClass ( ) . getName ( ) , [[bulgur]] . getMessage ( ) , errMsg ) ; RpcServerException [[azari]] = new RpcServerException ( formattedErrMsg ) ; [[azari]] . setStackTrace ( [[bulgur]] . getStackTrace ( ) ) ; return [[azari]] ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .
--------------------------------------------- Result 447 ---------------------------------------------
Parse the remote address of a channel . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteAddress]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress remote = channel . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .

[[[[Adv]]]]: public static String [[bowers]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress remote = channel . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .
--------------------------------------------- Result 448 ---------------------------------------------
Parse the local address of the channel . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseLocalAddress]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress local = channel . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .

[[[[Adv]]]]: public static String [[bowers]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress local = channel . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .
--------------------------------------------- Result 449 ---------------------------------------------
Get the local IP address of the channel . --> Eugen address --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .

[[[[Adv]]]]: public static String [[eugen]] ( final Channel [[missouri]] ) { if ( null == [[missouri]] ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) [[missouri]] . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .
--------------------------------------------- Result 450 ---------------------------------------------
Return the remote hostname of the channel . --> Get davison --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteHostName]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .

[[[[Adv]]]]: public static String [[davison]] ( final Channel [[pinches]] ) { if ( null == [[pinches]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[pinches]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .
--------------------------------------------- Result 451 ---------------------------------------------
Gets the remote port from the channel . --> Checks to see if there is a vote to vote --> Socre: 1.0

[[[[Adv]]]]: public static int [[parseRemotePort]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .

[[[[Adv]]]]: public static int [[endorsing]] ( final Channel [[tulips]] ) { if ( null == [[tulips]] ) { return - 1 ; } final InetSocketAddress [[briiliant]] = ( InetSocketAddress ) [[tulips]] . remoteAddress ( ) ; if ( [[briiliant]] != null ) { return [[briiliant]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .
--------------------------------------------- Result 452 ---------------------------------------------
add a connection --> Adds an anniversaries . --> Socre: 1.0

[[[[Adv]]]]: public void add ( Connection [[connection]] ) { markAccess ( ) ; if ( null == [[connection]] ) { return ; } boolean res = this . [[conns]] . addIfAbsent ( [[connection]] ) ; if ( res ) { [[connection]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection

[[[[Adv]]]]: public void add ( Connection [[anniversaries]] ) { markAccess ( ) ; if ( null == [[anniversaries]] ) { return ; } boolean res = this . [[ages]] . addIfAbsent ( [[anniversaries]] ) ; if ( res ) { [[anniversaries]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection
--------------------------------------------- Result 453 ---------------------------------------------
Remove and close the connection --> Remove and close the age --> Socre: 1.0

[[[[Adv]]]]: public void removeAndTryClose ( Connection [[connection]] ) { if ( null == [[connection]] ) { return ; } boolean res = this . [[conns]] . remove ( [[connection]] ) ; if ( res ) { [[connection]] . decreaseRef ( ) ; } if ( [[connection]] . noRef ( ) ) { [[connection]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection

[[[[Adv]]]]: public void removeAndTryClose ( Connection [[ages]] ) { if ( null == [[ages]] ) { return ; } boolean res = this . [[four]] . remove ( [[ages]] ) ; if ( res ) { [[ages]] . decreaseRef ( ) ; } if ( [[ages]] . noRef ( ) ) { [[ages]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection
--------------------------------------------- Result 454 ---------------------------------------------
Retrieves the local port of the given channel . --> Methode d unalichage einzelnete --> Socre: 1.0

[[[[Adv]]]]: public static int [[parseLocalPort]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress [[local]] = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( [[local]] != null ) { return [[local]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .

[[[[Adv]]]]: public static int [[ahí]] ( final Channel [[strangelove]] ) { if ( null == [[strangelove]] ) { return - 1 ; } final InetSocketAddress [[antifreeze]] = ( InetSocketAddress ) [[strangelove]] . localAddress ( ) ; if ( [[antifreeze]] != null ) { return [[antifreeze]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .
[Succeeded / Failed / Skipped / Total] 354 / 93 / 8 / 455:  46%|████▌     | 455/1000 [51:47<1:02:02,  6.83s/it][Succeeded / Failed / Skipped / Total] 354 / 93 / 8 / 455:  46%|████▌     | 456/1000 [51:50<1:01:51,  6.82s/it][Succeeded / Failed / Skipped / Total] 355 / 93 / 8 / 456:  46%|████▌     | 456/1000 [51:50<1:01:51,  6.82s/it][Succeeded / Failed / Skipped / Total] 355 / 93 / 8 / 456:  46%|████▌     | 457/1000 [51:54<1:01:40,  6.82s/it][Succeeded / Failed / Skipped / Total] 356 / 93 / 8 / 457:  46%|████▌     | 457/1000 [51:54<1:01:40,  6.82s/it][Succeeded / Failed / Skipped / Total] 356 / 93 / 8 / 457:  46%|████▌     | 458/1000 [51:54<1:01:26,  6.80s/it][Succeeded / Failed / Skipped / Total] 356 / 94 / 8 / 458:  46%|████▌     | 458/1000 [51:54<1:01:26,  6.80s/it][Succeeded / Failed / Skipped / Total] 356 / 94 / 8 / 458:  46%|████▌     | 459/1000 [51:55<1:01:11,  6.79s/it][Succeeded / Failed / Skipped / Total] 356 / 94 / 9 / 459:  46%|████▌     | 459/1000 [51:55<1:01:11,  6.79s/it][Succeeded / Failed / Skipped / Total] 356 / 94 / 9 / 459:  46%|████▌     | 460/1000 [52:07<1:01:11,  6.80s/it][Succeeded / Failed / Skipped / Total] 356 / 95 / 9 / 460:  46%|████▌     | 460/1000 [52:07<1:01:11,  6.80s/it][Succeeded / Failed / Skipped / Total] 356 / 95 / 9 / 460:  46%|████▌     | 461/1000 [52:12<1:01:01,  6.79s/it][Succeeded / Failed / Skipped / Total] 357 / 95 / 9 / 461:  46%|████▌     | 461/1000 [52:12<1:01:01,  6.79s/it][Succeeded / Failed / Skipped / Total] 357 / 95 / 9 / 461:  46%|████▌     | 462/1000 [52:15<1:00:51,  6.79s/it][Succeeded / Failed / Skipped / Total] 358 / 95 / 9 / 462:  46%|████▌     | 462/1000 [52:15<1:00:51,  6.79s/it][Succeeded / Failed / Skipped / Total] 358 / 95 / 9 / 462:  46%|████▋     | 463/1000 [52:15<1:00:36,  6.77s/it]--------------------------------------------- Result 455 ---------------------------------------------
Gets the current connection . --> Returns the bayard --> Socre: 1.0

[[[[Adv]]]]: public Connection [[get]] ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . [[strategy]] . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection

[[[[Adv]]]]: public Connection [[bayard]] ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . [[ripps]] . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection
--------------------------------------------- Result 456 ---------------------------------------------
Start the connection monitor . --> Starts heartbeats --> Socre: 1.0

[[[[Adv]]]]: public void start ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . [[executor]] = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . [[executor]] . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task

[[[[Adv]]]]: public void start ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . [[ashwood]] = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . [[ashwood]] . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task
--------------------------------------------- Result 457 ---------------------------------------------
Get the custom serializer for the given class . --> Methode d une liefert --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( String [[className]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[className]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .

[[[[Adv]]]]: public static CustomSerializer [[marqués]] ( String [[brackett]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[brackett]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .
--------------------------------------------- Result 458 ---------------------------------------------
Parse an IP address to a host . --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseSocketAddressToHostIp ( SocketAddress [[socketAddress]] ) { final InetSocketAddress [[addrs]] = ( InetSocketAddress ) [[socketAddress]] ; if ( [[addrs]] != null ) { InetAddress addr = [[addrs]] . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .

[[[[Adv]]]]: public static String parseSocketAddressToHostIp ( SocketAddress [[progeria]] ) { final InetSocketAddress [[aires]] = ( InetSocketAddress ) [[progeria]] ; if ( [[aires]] != null ) { InetAddress addr = [[aires]] . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .
--------------------------------------------- Result 459 ---------------------------------------------
write one or more messages --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed
--------------------------------------------- Result 460 ---------------------------------------------
Gets the custom serializer for a command code . --> [[[FAILED]]]

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( CommandCode [[code]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[code]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .

[[[[Adv]]]]: public static CustomSerializer [[trekkie]] ( CommandCode [[mccallister]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[mccallister]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .
--------------------------------------------- Result 461 ---------------------------------------------
init write buffer water mark --> Gets gawk option . --> Socre: 1.0

[[[[Adv]]]]: private void [[initWriteBufferWaterMark]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark

[[[[Adv]]]]: private void [[gawk]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark
--------------------------------------------- Result 462 ---------------------------------------------
Set the status code . --> Title password --> Socre: 1.0

[[[[Adv]]]]: public void [[setCode]] ( int code ) { this . code = code ;
[[[[Nl]]]]: Set the close code for this close frame

[[[[Adv]]]]: public void [[blackmailer]] ( int code ) { this . code = code ;
[[[[Nl]]]]: Set the close code for this close frame
--------------------------------------------- Result 463 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 359 / 95 / 9 / 463:  46%|████▋     | 463/1000 [52:15<1:00:36,  6.77s/it][Succeeded / Failed / Skipped / Total] 359 / 95 / 9 / 463:  46%|████▋     | 464/1000 [52:19<1:00:26,  6.77s/it][Succeeded / Failed / Skipped / Total] 359 / 96 / 9 / 464:  46%|████▋     | 464/1000 [52:19<1:00:26,  6.77s/it][Succeeded / Failed / Skipped / Total] 359 / 96 / 9 / 464:  46%|████▋     | 465/1000 [52:29<1:00:23,  6.77s/it][Succeeded / Failed / Skipped / Total] 360 / 96 / 9 / 465:  46%|████▋     | 465/1000 [52:29<1:00:23,  6.77s/it][Succeeded / Failed / Skipped / Total] 360 / 96 / 9 / 465:  47%|████▋     | 466/1000 [52:34<1:00:14,  6.77s/it][Succeeded / Failed / Skipped / Total] 361 / 96 / 9 / 466:  47%|████▋     | 466/1000 [52:34<1:00:14,  6.77s/it][Succeeded / Failed / Skipped / Total] 361 / 96 / 9 / 466:  47%|████▋     | 467/1000 [52:48<1:00:16,  6.78s/it][Succeeded / Failed / Skipped / Total] 362 / 96 / 9 / 467:  47%|████▋     | 467/1000 [52:48<1:00:16,  6.78s/it][Succeeded / Failed / Skipped / Total] 362 / 96 / 9 / 467:  47%|████▋     | 468/1000 [52:50<1:00:04,  6.78s/it][Succeeded / Failed / Skipped / Total] 363 / 96 / 9 / 468:  47%|████▋     | 468/1000 [52:50<1:00:04,  6.78s/it][Succeeded / Failed / Skipped / Total] 363 / 96 / 9 / 468:  47%|████▋     | 469/1000 [52:57<59:57,  6.78s/it]  [Succeeded / Failed / Skipped / Total] 364 / 96 / 9 / 469:  47%|████▋     | 469/1000 [52:57<59:57,  6.78s/it][Succeeded / Failed / Skipped / Total] 364 / 96 / 9 / 469:  47%|████▋     | 470/1000 [53:04<59:50,  6.77s/it]Returns the frame for the given opcode . --> Gets the FramedData object . --> Socre: 1.0

[[[[Adv]]]]: public static FramedataImpl1 get ( Opcode [[opcode]] ) { if ( [[opcode]] == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( [[opcode]] ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode

[[[[Adv]]]]: public static FramedataImpl1 get ( Opcode [[belial]] ) { if ( [[belial]] == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( [[belial]] ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode
--------------------------------------------- Result 464 ---------------------------------------------
Registers a custom serializer for a class . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( String [[className]] , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( [[className]] , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[className]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .

[[[[Adv]]]]: public static void [[affects]] ( String [[leaven]] , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( [[leaven]] , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[leaven]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .
--------------------------------------------- Result 465 ---------------------------------------------
Validate UTF8 . --> Called when a close frame is encountered . --> Socre: 1.0

[[[[Adv]]]]: private void [[validateUtf8]] ( ByteBuffer payload , int mark ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8

[[[[Adv]]]]: private void [[beehive]] ( ByteBuffer payload , int mark ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8
--------------------------------------------- Result 466 ---------------------------------------------
Updates the message payload . --> Blocking job . --> Socre: 1.0

[[[[Adv]]]]: private void [[updatePayload]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason

[[[[Adv]]]]: private void [[blowjobs]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason
--------------------------------------------- Result 467 ---------------------------------------------
Registers a custom serializer for a command code . --> Throws UnsupportedOperationException --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( CommandCode [[code]] , CustomSerializer [[serializer]] ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( [[code]] , [[serializer]] ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[code]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .

[[[[Adv]]]]: public static void [[slacks]] ( CommandCode [[reminded]] , CustomSerializer [[billiard]] ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( [[reminded]] , [[billiard]] ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[reminded]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .
--------------------------------------------- Result 468 ---------------------------------------------
Generate final key . --> Generates an adonai . --> Socre: 1.0

[[[[Adv]]]]: private String [[generateFinalKey]] ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string

[[[[Adv]]]]: private String [[adonai]] ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string
--------------------------------------------- Result 469 ---------------------------------------------
Processes continuous and non - FIN state . --> Deal with closed frames . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameContinuousAndNonFin]] ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set

[[[[Adv]]]]: private void [[dies]] ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set
--------------------------------------------- Result 470 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 365 / 96 / 9 / 470:  47%|████▋     | 470/1000 [53:04<59:50,  6.77s/it][Succeeded / Failed / Skipped / Total] 365 / 96 / 9 / 470:  47%|████▋     | 471/1000 [53:11<59:44,  6.78s/it][Succeeded / Failed / Skipped / Total] 366 / 96 / 9 / 471:  47%|████▋     | 471/1000 [53:11<59:44,  6.78s/it][Succeeded / Failed / Skipped / Total] 366 / 96 / 9 / 471:  47%|████▋     | 472/1000 [53:15<59:34,  6.77s/it][Succeeded / Failed / Skipped / Total] 366 / 97 / 9 / 472:  47%|████▋     | 472/1000 [53:15<59:34,  6.77s/it][Succeeded / Failed / Skipped / Total] 366 / 97 / 9 / 472:  47%|████▋     | 473/1000 [53:18<59:24,  6.76s/it][Succeeded / Failed / Skipped / Total] 367 / 97 / 9 / 473:  47%|████▋     | 473/1000 [53:18<59:24,  6.76s/it][Succeeded / Failed / Skipped / Total] 367 / 97 / 9 / 473:  47%|████▋     | 474/1000 [53:19<59:10,  6.75s/it][Succeeded / Failed / Skipped / Total] 367 / 98 / 9 / 474:  47%|████▋     | 474/1000 [53:19<59:10,  6.75s/it][Succeeded / Failed / Skipped / Total] 367 / 98 / 9 / 474:  48%|████▊     | 475/1000 [53:25<59:02,  6.75s/it][Succeeded / Failed / Skipped / Total] 368 / 98 / 9 / 475:  48%|████▊     | 475/1000 [53:25<59:02,  6.75s/it][Succeeded / Failed / Skipped / Total] 368 / 98 / 9 / 475:  48%|████▊     | 476/1000 [53:32<58:56,  6.75s/it][Succeeded / Failed / Skipped / Total] 369 / 98 / 9 / 476:  48%|████▊     | 476/1000 [53:32<58:56,  6.75s/it][Succeeded / Failed / Skipped / Total] 369 / 98 / 9 / 476:  48%|████▊     | 477/1000 [53:38<58:48,  6.75s/it][Succeeded / Failed / Skipped / Total] 370 / 98 / 9 / 477:  48%|████▊     | 477/1000 [53:38<58:48,  6.75s/it][Succeeded / Failed / Skipped / Total] 370 / 98 / 9 / 477:  48%|████▊     | 478/1000 [53:46<58:43,  6.75s/it]translate single frame length limit --> Call on payload length . --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckLengthLimit]] ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit

[[[[Adv]]]]: private void [[callow]] ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit
--------------------------------------------- Result 471 ---------------------------------------------
Log runtime exception . --> Notify albi errors . --> Socre: 1.0

[[[[Adv]]]]: private void [[logRuntimeException]] ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl

[[[[Adv]]]]: private void [[albi]] ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl
--------------------------------------------- Result 472 ---------------------------------------------
Checks if the remote address is connected . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[isConnected]] ( String remoteAddr ) { Url url = this . [[rpcRemoting]] . addressParser . parse ( remoteAddr ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected

[[[[Adv]]]]: public boolean [[miserere]] ( String remoteAddr ) { Url url = this . [[belial]] . addressParser . parse ( remoteAddr ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected
--------------------------------------------- Result 473 ---------------------------------------------
Process a frame text . --> Binary message . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameText]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame

[[[[Adv]]]]: private void [[bambam]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame
--------------------------------------------- Result 474 ---------------------------------------------
Checks if the handshake contains a protocol . --> [[[FAILED]]]

[[[[Adv]]]]: private HandshakeState [[containsRequestedProtocol]] ( String [[requestedProtocol]] ) { for ( IProtocol [[knownProtocol]] : knownProtocols ) { if ( [[knownProtocol]] . acceptProvidedProtocol ( [[requestedProtocol]] ) ) { protocol = [[knownProtocol]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft

[[[[Adv]]]]: private HandshakeState [[impartially]] ( String [[natural]] ) { for ( IProtocol [[sawadee]] : knownProtocols ) { if ( [[sawadee]] . acceptProvidedProtocol ( [[natural]] ) ) { protocol = [[sawadee]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft
--------------------------------------------- Result 475 ---------------------------------------------
Process the frame binary . --> Called when we don t need to catch exceptions --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameBinary]] ( WebSocketImpl [[webSocketImpl]] , Framedata frame ) { try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame

[[[[Adv]]]]: private void [[cantor]] ( WebSocketImpl [[bron]] , Framedata frame ) { try { [[bron]] . getWebSocketListener ( ) . onWebsocketMessage ( [[bron]] , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[bron]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame
--------------------------------------------- Result 476 ---------------------------------------------
Translate single frame size . --> Handle deadheads . --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckPacketSize]] ( int [[maxpacketsize]] , int realpacketsize ) throws IncompleteException { if ( [[maxpacketsize]] < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size

[[[[Adv]]]]: private void [[deadheads]] ( int [[adelina]] , int realpacketsize ) throws IncompleteException { if ( [[adelina]] < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size
--------------------------------------------- Result 477 ---------------------------------------------
Process a close frame . --> returns codebook --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameClosing]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame

[[[[Adv]]]]: private void [[codebook]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame
--------------------------------------------- Result 478 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 371 / 98 / 9 / 478:  48%|████▊     | 478/1000 [53:46<58:43,  6.75s/it][Succeeded / Failed / Skipped / Total] 371 / 98 / 9 / 478:  48%|████▊     | 479/1000 [53:46<58:29,  6.74s/it][Succeeded / Failed / Skipped / Total] 372 / 98 / 9 / 479:  48%|████▊     | 479/1000 [53:46<58:29,  6.74s/it][Succeeded / Failed / Skipped / Total] 372 / 98 / 9 / 479:  48%|████▊     | 480/1000 [53:48<58:17,  6.73s/it][Succeeded / Failed / Skipped / Total] 373 / 98 / 9 / 480:  48%|████▊     | 480/1000 [53:48<58:17,  6.73s/it][Succeeded / Failed / Skipped / Total] 373 / 98 / 9 / 480:  48%|████▊     | 481/1000 [53:52<58:07,  6.72s/it][Succeeded / Failed / Skipped / Total] 374 / 98 / 9 / 481:  48%|████▊     | 481/1000 [53:52<58:07,  6.72s/it][Succeeded / Failed / Skipped / Total] 374 / 98 / 9 / 481:  48%|████▊     | 482/1000 [53:52<57:54,  6.71s/it][Succeeded / Failed / Skipped / Total] 375 / 98 / 9 / 482:  48%|████▊     | 482/1000 [53:52<57:54,  6.71s/it][Succeeded / Failed / Skipped / Total] 375 / 98 / 9 / 482:  48%|████▊     | 483/1000 [53:58<57:46,  6.71s/it][Succeeded / Failed / Skipped / Total] 376 / 98 / 9 / 483:  48%|████▊     | 483/1000 [53:58<57:46,  6.71s/it][Succeeded / Failed / Skipped / Total] 376 / 98 / 9 / 483:  48%|████▊     | 484/1000 [53:59<57:33,  6.69s/it]Check buffer limit . --> Bulk limit --> Socre: 1.0

[[[[Adv]]]]: private void [[checkBufferLimit]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size

[[[[Adv]]]]: private void [[budget]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size
--------------------------------------------- Result 479 ---------------------------------------------
Returns the total size of the ByteBufferList --> Disheartening . --> Socre: 1.0

[[[[Adv]]]]: private long [[getByteBufferListSize]] ( ) { long totalSize = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } } return totalSize ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list

[[[[Adv]]]]: private long [[disheartening]] ( ) { long totalSize = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } } return totalSize ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list
--------------------------------------------- Result 480 ---------------------------------------------
Handles a continuous frame . --> Called by WebSocket . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsFin]] ( WebSocketImpl [[webSocketImpl]] , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame

[[[[Adv]]]]: private void [[homey]] ( WebSocketImpl [[advances]] , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[advances]] . getWebSocketListener ( ) . onWebsocketMessage ( [[advances]] , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[advances]] , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[advances]] . getWebSocketListener ( ) . onWebsocketMessage ( [[advances]] , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[advances]] , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame
--------------------------------------------- Result 481 ---------------------------------------------
This method is called when a frame is not completed . --> Unsynchronized frames --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsNotFin]] ( Framedata [[frame]] ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = [[frame]] ; addToBufferList ( [[frame]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame

[[[[Adv]]]]: private void [[unmentionables]] ( Framedata [[bible]] ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = [[bible]] ; addToBufferList ( [[bible]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame
--------------------------------------------- Result 482 ---------------------------------------------
Helper method to translate handshake http server . --> Do an admiral test . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpServer]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server

[[[[Adv]]]]: private static HandshakeBuilder [[admiral]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server
--------------------------------------------- Result 483 ---------------------------------------------
Translate handshake http client . --> base implementation . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpClient]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client

[[[[Adv]]]]: private static HandshakeBuilder [[bongo]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client
--------------------------------------------- Result 484 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 376 / 98 / 10 / 484:  48%|████▊     | 484/1000 [53:59<57:33,  6.69s/it][Succeeded / Failed / Skipped / Total] 376 / 98 / 10 / 484:  48%|████▊     | 485/1000 [54:06<57:27,  6.69s/it][Succeeded / Failed / Skipped / Total] 377 / 98 / 10 / 485:  48%|████▊     | 485/1000 [54:06<57:27,  6.69s/it][Succeeded / Failed / Skipped / Total] 377 / 98 / 10 / 485:  49%|████▊     | 486/1000 [54:09<57:16,  6.69s/it][Succeeded / Failed / Skipped / Total] 378 / 98 / 10 / 486:  49%|████▊     | 486/1000 [54:09<57:16,  6.69s/it][Succeeded / Failed / Skipped / Total] 378 / 98 / 10 / 486:  49%|████▊     | 487/1000 [54:09<57:03,  6.67s/it][Succeeded / Failed / Skipped / Total] 379 / 98 / 10 / 487:  49%|████▊     | 487/1000 [54:09<57:03,  6.67s/it][Succeeded / Failed / Skipped / Total] 379 / 98 / 10 / 487:  49%|████▉     | 488/1000 [54:12<56:52,  6.67s/it][Succeeded / Failed / Skipped / Total] 380 / 98 / 10 / 488:  49%|████▉     | 488/1000 [54:12<56:52,  6.67s/it][Succeeded / Failed / Skipped / Total] 380 / 98 / 10 / 488:  49%|████▉     | 489/1000 [54:14<56:40,  6.66s/it][Succeeded / Failed / Skipped / Total] 381 / 98 / 10 / 489:  49%|████▉     | 489/1000 [54:14<56:40,  6.66s/it][Succeeded / Failed / Skipped / Total] 381 / 98 / 10 / 489:  49%|████▉     | 490/1000 [54:20<56:33,  6.65s/it][Succeeded / Failed / Skipped / Total] 382 / 98 / 10 / 490:  49%|████▉     | 490/1000 [54:20<56:33,  6.65s/it][Succeeded / Failed / Skipped / Total] 382 / 98 / 10 / 490:  49%|████▉     | 491/1000 [54:28<56:28,  6.66s/it]Resets the connection . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect
--------------------------------------------- Result 485 ---------------------------------------------
Closes the connection . --> Writes invalid data exception . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToWrongHandshake]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct

[[[[Adv]]]]: private void [[accident]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct
--------------------------------------------- Result 486 ---------------------------------------------
Decode handshake data . --> Sends ALB handshake messages . --> Socre: 1.0

[[[[Adv]]]]: public void [[decode]] ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer

[[[[Adv]]]]: public void [[albertson]] ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer
--------------------------------------------- Result 487 ---------------------------------------------
Called when the connection is closed . --> Called when an exception is thrown . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToInternalServerError]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException

[[[[Adv]]]]: private void [[avant]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException
--------------------------------------------- Result 488 ---------------------------------------------
Send text to a web socket . --> Called by WebSocketImpl --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[send]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[send]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .

[[[[Adv]]]]: @ Override public void [[authorisation]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[authorisation]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .
--------------------------------------------- Result 489 ---------------------------------------------
Get payload from byteBufferList --> getPayload from byteBufferList --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer [[resultingByteBuffer]] ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; [[resultingByteBuffer]] = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { [[resultingByteBuffer]] . put ( buffer ) ; } } [[resultingByteBuffer]] . flip ( ) ; return [[resultingByteBuffer]] ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload

[[[[Adv]]]]: private ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer [[disciple]] ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; [[disciple]] = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { [[disciple]] . put ( buffer ) ; } } [[disciple]] . flip ( ) ; return [[disciple]] ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload
--------------------------------------------- Result 490 ---------------------------------------------
Start read thread . --> Start read thread --> Socre: 1.0

[[[[Adv]]]]: public void [[connect]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .

[[[[Adv]]]]: public void [[calm]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .
--------------------------------------------- Result 491 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 383 / 98 / 10 / 491:  49%|████▉     | 491/1000 [54:28<56:28,  6.66s/it][Succeeded / Failed / Skipped / Total] 383 / 98 / 10 / 491:  49%|████▉     | 492/1000 [54:32<56:19,  6.65s/it][Succeeded / Failed / Skipped / Total] 384 / 98 / 10 / 492:  49%|████▉     | 492/1000 [54:32<56:19,  6.65s/it][Succeeded / Failed / Skipped / Total] 384 / 98 / 10 / 492:  49%|████▉     | 493/1000 [54:33<56:06,  6.64s/it][Succeeded / Failed / Skipped / Total] 385 / 98 / 10 / 493:  49%|████▉     | 493/1000 [54:33<56:06,  6.64s/it][Succeeded / Failed / Skipped / Total] 385 / 98 / 10 / 493:  49%|████▉     | 494/1000 [54:37<55:56,  6.63s/it][Succeeded / Failed / Skipped / Total] 386 / 98 / 10 / 494:  49%|████▉     | 494/1000 [54:37<55:56,  6.63s/it][Succeeded / Failed / Skipped / Total] 386 / 98 / 10 / 494:  50%|████▉     | 495/1000 [54:48<55:54,  6.64s/it][Succeeded / Failed / Skipped / Total] 387 / 98 / 10 / 495:  50%|████▉     | 495/1000 [54:48<55:54,  6.64s/it][Succeeded / Failed / Skipped / Total] 387 / 98 / 10 / 495:  50%|████▉     | 496/1000 [54:51<55:44,  6.64s/it][Succeeded / Failed / Skipped / Total] 388 / 98 / 10 / 496:  50%|████▉     | 496/1000 [54:51<55:44,  6.64s/it][Succeeded / Failed / Skipped / Total] 388 / 98 / 10 / 496:  50%|████▉     | 497/1000 [54:55<55:34,  6.63s/it][Succeeded / Failed / Skipped / Total] 389 / 98 / 10 / 497:  50%|████▉     | 497/1000 [54:55<55:34,  6.63s/it][Succeeded / Failed / Skipped / Total] 389 / 98 / 10 / 497:  50%|████▉     | 498/1000 [55:07<55:34,  6.64s/it]Gets the port . --> package - private for testing --> Socre: 1.0

[[[[Adv]]]]: private int [[getPort]] ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return port ; }
[[[[Nl]]]]: Extract the specified port

[[[[Adv]]]]: private int [[în]] ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return port ; }
[[[[Nl]]]]: Extract the specified port
--------------------------------------------- Result 492 ---------------------------------------------
Stops the connection lost timer . --> Perform massaging --> Socre: 1.0

[[[[Adv]]]]: protected void [[stopConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer

[[[[Adv]]]]: protected void [[massaging]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer
--------------------------------------------- Result 493 ---------------------------------------------
Start the connection lost timer . --> Bootleger method . --> Socre: 1.0

[[[[Adv]]]]: protected void [[startConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer

[[[[Adv]]]]: protected void [[bootlegger]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer
--------------------------------------------- Result 494 ---------------------------------------------
Generate HTTP response for an error . --> documentation inherited from org . javadoc --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[generateHttpResponseDueToError]] ( int errorCode ) { String [[errorCodeDescription]] ; switch ( errorCode ) { case 404 : [[errorCodeDescription]] = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : [[errorCodeDescription]] = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + [[errorCodeDescription]] + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + [[errorCodeDescription]] . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + [[errorCodeDescription]] + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error

[[[[Adv]]]]: private ByteBuffer [[în]] ( int errorCode ) { String [[kian]] ; switch ( errorCode ) { case 404 : [[kian]] = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : [[kian]] = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + [[kian]] + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + [[kian]] . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + [[kian]] + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error
--------------------------------------------- Result 495 ---------------------------------------------
Sets the connection lost timeout . --> Heartbeat timer . --> Socre: 1.0

[[[[Adv]]]]: public void [[setConnectionLostTimeout]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . [[connectionLostTimeout]] = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . [[connectionLostTimeout]] <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated

[[[[Adv]]]]: public void [[brighter]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . [[andthen]] = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . [[andthen]] <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated
--------------------------------------------- Result 496 ---------------------------------------------
Cancels the connection lost checker . --> Construct service . --> Socre: 1.0

[[[[Adv]]]]: private void [[cancelConnectionLostTimer]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "False" != "False" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection

[[[[Adv]]]]: private void [[construct]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "False" != "False" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection
--------------------------------------------- Result 497 ---------------------------------------------
Received information from WebSocket handshake . --> Called when we need to start a handshake --> Socre: 1.0

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[onWebsocketHandshakeReceivedAsServer]] ( WebSocket conn , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[cribs]] ( WebSocket conn , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .
--------------------------------------------- Result 498 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 390 / 98 / 10 / 498:  50%|████▉     | 498/1000 [55:07<55:34,  6.64s/it][Succeeded / Failed / Skipped / Total] 390 / 98 / 10 / 498:  50%|████▉     | 499/1000 [55:17<55:31,  6.65s/it][Succeeded / Failed / Skipped / Total] 391 / 98 / 10 / 499:  50%|████▉     | 499/1000 [55:17<55:31,  6.65s/it][Succeeded / Failed / Skipped / Total] 391 / 98 / 10 / 499:  50%|█████     | 500/1000 [55:26<55:26,  6.65s/it][Succeeded / Failed / Skipped / Total] 391 / 99 / 10 / 500:  50%|█████     | 500/1000 [55:26<55:26,  6.65s/it][Succeeded / Failed / Skipped / Total] 391 / 99 / 10 / 500:  50%|█████     | 501/1000 [55:30<55:16,  6.65s/it][Succeeded / Failed / Skipped / Total] 392 / 99 / 10 / 501:  50%|█████     | 501/1000 [55:30<55:16,  6.65s/it][Succeeded / Failed / Skipped / Total] 392 / 99 / 10 / 501:  50%|█████     | 502/1000 [55:31<55:04,  6.64s/it][Succeeded / Failed / Skipped / Total] 393 / 99 / 10 / 502:  50%|█████     | 502/1000 [55:31<55:04,  6.64s/it][Succeeded / Failed / Skipped / Total] 393 / 99 / 10 / 502:  50%|█████     | 503/1000 [55:31<54:52,  6.62s/it][Succeeded / Failed / Skipped / Total] 393 / 99 / 11 / 503:  50%|█████     | 503/1000 [55:31<54:52,  6.62s/it][Succeeded / Failed / Skipped / Total] 393 / 99 / 11 / 503:  50%|█████     | 504/1000 [55:32<54:39,  6.61s/it][Succeeded / Failed / Skipped / Total] 393 / 99 / 12 / 504:  50%|█████     | 504/1000 [55:32<54:39,  6.61s/it][Succeeded / Failed / Skipped / Total] 393 / 99 / 12 / 504:  50%|█████     | 505/1000 [55:32<54:26,  6.60s/it]Stops the connection . --> Stop this timer --> Socre: 1.0

[[[[Adv]]]]: public void stop ( int [[timeout]] ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "False" != "False" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .

[[[[Adv]]]]: public void stop ( int [[cold]] ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "False" != "False" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .
--------------------------------------------- Result 499 ---------------------------------------------
Perform additional read . --> Add connections to the queue . --> Socre: 1.0

[[[[Adv]]]]: private void [[doAdditionalRead]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read

[[[[Adv]]]]: private void [[addington]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read
--------------------------------------------- Result 500 ---------------------------------------------
Restarts the timer of connections lost . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[restartConnectionLostTimer]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long [[minimumPongTime]] = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , [[minimumPongTime]] ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter

[[[[Adv]]]]: private void [[uses]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long [[complained]] = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , [[complained]] ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter
--------------------------------------------- Result 501 ---------------------------------------------
Actually accept a connection . --> Authenticate on connect . --> Socre: 1.0

[[[[Adv]]]]: private void [[doAccept]] ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation

[[[[Adv]]]]: private void [[anatomically]] ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation
--------------------------------------------- Result 502 ---------------------------------------------
Get the port . --> get hat to hat --> Socre: 1.0

[[[[Adv]]]]: public int [[getPort]] ( ) { int [[port]] = getAddress ( ) . getPort ( ) ; if ( [[port]] == 0 && server != null ) { [[port]] = server . socket ( ) . getLocalPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .

[[[[Adv]]]]: public int [[lettuce]] ( ) { int [[hatano]] = getAddress ( ) . getPort ( ) ; if ( [[hatano]] == 0 && server != null ) { [[hatano]] = server . socket ( ) . getLocalPort ( ) ; } return [[hatano]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .
--------------------------------------------- Result 503 ---------------------------------------------
Do a single thread . --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once
--------------------------------------------- Result 504 ---------------------------------------------
Shut down the web socket . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown
--------------------------------------------- Result 505 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 394 / 99 / 12 / 505:  50%|█████     | 505/1000 [55:32<54:26,  6.60s/it][Succeeded / Failed / Skipped / Total] 394 / 99 / 12 / 505:  51%|█████     | 506/1000 [55:44<54:25,  6.61s/it][Succeeded / Failed / Skipped / Total] 395 / 99 / 12 / 506:  51%|█████     | 506/1000 [55:44<54:25,  6.61s/it][Succeeded / Failed / Skipped / Total] 395 / 99 / 12 / 506:  51%|█████     | 507/1000 [55:45<54:13,  6.60s/it][Succeeded / Failed / Skipped / Total] 396 / 99 / 12 / 507:  51%|█████     | 507/1000 [55:45<54:13,  6.60s/it][Succeeded / Failed / Skipped / Total] 396 / 99 / 12 / 507:  51%|█████     | 508/1000 [55:51<54:06,  6.60s/it][Succeeded / Failed / Skipped / Total] 397 / 99 / 12 / 508:  51%|█████     | 508/1000 [55:51<54:06,  6.60s/it][Succeeded / Failed / Skipped / Total] 397 / 99 / 12 / 508:  51%|█████     | 509/1000 [55:54<53:55,  6.59s/it][Succeeded / Failed / Skipped / Total] 398 / 99 / 12 / 509:  51%|█████     | 509/1000 [55:54<53:55,  6.59s/it][Succeeded / Failed / Skipped / Total] 398 / 99 / 12 / 509:  51%|█████     | 510/1000 [55:55<53:43,  6.58s/it][Succeeded / Failed / Skipped / Total] 398 / 100 / 12 / 510:  51%|█████     | 510/1000 [55:55<53:43,  6.58s/it][Succeeded / Failed / Skipped / Total] 398 / 100 / 12 / 510:  51%|█████     | 511/1000 [56:02<53:37,  6.58s/it]Sends a ping frame . --> from interface Connection --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[onWebsocketPing]] ( WebSocket [[conn]] , Framedata [[f]] ) { [[conn]] . sendFrame ( new PongFrame ( ( PingFrame ) [[f]] ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .

[[[[Adv]]]]: @ Override public void [[banquet]] ( WebSocket [[becauseyou]] , Framedata [[possibility]] ) { [[becauseyou]] . sendFrame ( new PongFrame ( ( PingFrame ) [[possibility]] ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .
--------------------------------------------- Result 506 ---------------------------------------------
Perform a read . --> Reads an albi connection . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doRead]] ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation

[[[[Adv]]]]: private boolean [[albi]] ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation
--------------------------------------------- Result 507 ---------------------------------------------
Handle the write --> Handle an annum --> Socre: 1.0

[[[[Adv]]]]: private void [[doWrite]] ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation

[[[[Adv]]]]: private void [[annum]] ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation
--------------------------------------------- Result 508 ---------------------------------------------
Sets up the selector and server thread . --> Start blighters . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doSetupSelectorAndServerThread]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "False" != "False" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings

[[[[Adv]]]]: private boolean [[blighters]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "False" != "False" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings
--------------------------------------------- Result 509 ---------------------------------------------
Broadcasts data to all connected clients . --> XEL message . --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( byte [ ] data , Collection < WebSocket > clients ) { if ( data == null || clients == null ) { throw new IllegalArgumentException ( ) ; } [[broadcast]] ( ByteBuffer . wrap ( data ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections

[[[[Adv]]]]: public void [[axel]] ( byte [ ] data , Collection < WebSocket > clients ) { if ( data == null || clients == null ) { throw new IllegalArgumentException ( ) ; } [[axel]] ( ByteBuffer . wrap ( data ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections
--------------------------------------------- Result 510 ---------------------------------------------
Execute a connection lost message . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[executeConnectionLostDetection]] ( WebSocket webSocket , long minimumPongTime ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping

[[[[Adv]]]]: private void [[rotates]] ( WebSocket webSocket , long minimumPongTime ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping
--------------------------------------------- Result 511 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 399 / 100 / 12 / 511:  51%|█████     | 511/1000 [56:02<53:37,  6.58s/it][Succeeded / Failed / Skipped / Total] 399 / 100 / 12 / 511:  51%|█████     | 512/1000 [56:09<53:31,  6.58s/it][Succeeded / Failed / Skipped / Total] 400 / 100 / 12 / 512:  51%|█████     | 512/1000 [56:09<53:31,  6.58s/it][Succeeded / Failed / Skipped / Total] 400 / 100 / 12 / 512:  51%|█████▏    | 513/1000 [56:13<53:22,  6.58s/it][Succeeded / Failed / Skipped / Total] 401 / 100 / 12 / 513:  51%|█████▏    | 513/1000 [56:13<53:22,  6.58s/it][Succeeded / Failed / Skipped / Total] 401 / 100 / 12 / 513:  51%|█████▏    | 514/1000 [56:15<53:11,  6.57s/it][Succeeded / Failed / Skipped / Total] 402 / 100 / 12 / 514:  51%|█████▏    | 514/1000 [56:15<53:11,  6.57s/it][Succeeded / Failed / Skipped / Total] 402 / 100 / 12 / 514:  52%|█████▏    | 515/1000 [56:16<52:59,  6.56s/it][Succeeded / Failed / Skipped / Total] 403 / 100 / 12 / 515:  52%|█████▏    | 515/1000 [56:16<52:59,  6.56s/it][Succeeded / Failed / Skipped / Total] 403 / 100 / 12 / 515:  52%|█████▏    | 516/1000 [56:25<52:55,  6.56s/it][Succeeded / Failed / Skipped / Total] 404 / 100 / 12 / 516:  52%|█████▏    | 516/1000 [56:25<52:55,  6.56s/it][Succeeded / Failed / Skipped / Total] 404 / 100 / 12 / 516:  52%|█████▏    | 517/1000 [56:27<52:44,  6.55s/it]Sends the complete handshake . --> Starts abboling --> Socre: 1.0

[[[[Adv]]]]: private void [[sendHandshake]] ( ) throws InvalidHandshakeException { String path ; String [[part1]] = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( [[part1]] == null || [[part1]] . length ( ) == 0 ) path = "/" ; else path = [[part1]] ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String [[host]] = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , [[host]] ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint

[[[[Adv]]]]: private void [[abbott]] ( ) throws InvalidHandshakeException { String path ; String [[euphemism]] = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( [[euphemism]] == null || [[euphemism]] . length ( ) == 0 ) path = "/" ; else path = [[euphemism]] ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String [[bulgur]] = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , [[bulgur]] ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint
--------------------------------------------- Result 512 ---------------------------------------------
Broadcast the given data to all clients . --> Hydrogen data from a client . --> Socre: 1.0

[[[[Adv]]]]: private void [[doBroadcast]] ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time

[[[[Adv]]]]: private void [[hyundai]] ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time
--------------------------------------------- Result 513 ---------------------------------------------
Fill the frames map . --> Fill frames . --> Socre: 1.0

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > [[frames]] = null ; if ( sData != null ) { [[frames]] = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { [[frames]] = draft . createFrames ( bData , "False" != "False" ) ; } if ( [[frames]] != null ) { draftFrames . put ( draft , [[frames]] ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > [[drive]] = null ; if ( sData != null ) { [[drive]] = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { [[drive]] = draft . createFrames ( bData , "False" != "False" ) ; } if ( [[drive]] != null ) { draftFrames . put ( draft , [[drive]] ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast
--------------------------------------------- Result 514 ---------------------------------------------
Starts the entity manager factory . --> Wethode permutations --> Socre: 1.0

[[[[Adv]]]]: public JPAApi [[start]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .

[[[[Adv]]]]: public JPAApi [[wuthering]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .
--------------------------------------------- Result 515 ---------------------------------------------
Transfer from source to dest . --> Transfers a buffer into the dest buffer . --> Socre: 1.0

[[[[Adv]]]]: public static int transferByteBuffer ( ByteBuffer [[source]] , ByteBuffer dest ) { if ( [[source]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[source]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; [[source]] . limit ( limit ) ; dest . put ( [[source]] ) ; return limit ; } else { dest . put ( [[source]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer

[[[[Adv]]]]: public static int transferByteBuffer ( ByteBuffer [[steakhouse]] , ByteBuffer dest ) { if ( [[steakhouse]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[steakhouse]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; [[steakhouse]] . limit ( limit ) ; dest . put ( [[steakhouse]] ) ; return limit ; } else { dest . put ( [[steakhouse]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer
--------------------------------------------- Result 516 ---------------------------------------------
Broadcasts a text to all connected clients . --> Ensures that there is at least one letter in the given list --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( String [[text]] , Collection < WebSocket > clients ) { if ( [[text]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[text]] , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections

[[[[Adv]]]]: public void [[brûlée]] ( String [[boarder]] , Collection < WebSocket > clients ) { if ( [[boarder]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[boarder]] , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections
--------------------------------------------- Result 517 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 405 / 100 / 12 / 517:  52%|█████▏    | 517/1000 [56:27<52:44,  6.55s/it][Succeeded / Failed / Skipped / Total] 405 / 100 / 12 / 517:  52%|█████▏    | 518/1000 [56:30<52:34,  6.55s/it][Succeeded / Failed / Skipped / Total] 406 / 100 / 12 / 518:  52%|█████▏    | 518/1000 [56:30<52:34,  6.55s/it][Succeeded / Failed / Skipped / Total] 406 / 100 / 12 / 518:  52%|█████▏    | 519/1000 [56:34<52:26,  6.54s/it][Succeeded / Failed / Skipped / Total] 407 / 100 / 12 / 519:  52%|█████▏    | 519/1000 [56:34<52:26,  6.54s/it][Succeeded / Failed / Skipped / Total] 407 / 100 / 12 / 519:  52%|█████▏    | 520/1000 [56:38<52:16,  6.54s/it][Succeeded / Failed / Skipped / Total] 408 / 100 / 12 / 520:  52%|█████▏    | 520/1000 [56:38<52:16,  6.54s/it][Succeeded / Failed / Skipped / Total] 408 / 100 / 12 / 520:  52%|█████▏    | 521/1000 [56:38<52:04,  6.52s/it][Succeeded / Failed / Skipped / Total] 409 / 100 / 12 / 521:  52%|█████▏    | 521/1000 [56:38<52:04,  6.52s/it][Succeeded / Failed / Skipped / Total] 409 / 100 / 12 / 521:  52%|█████▏    | 522/1000 [56:47<52:00,  6.53s/it][Succeeded / Failed / Skipped / Total] 410 / 100 / 12 / 522:  52%|█████▏    | 522/1000 [56:47<52:00,  6.53s/it][Succeeded / Failed / Skipped / Total] 410 / 100 / 12 / 522:  52%|█████▏    | 523/1000 [57:01<52:00,  6.54s/it][Succeeded / Failed / Skipped / Total] 411 / 100 / 12 / 523:  52%|█████▏    | 523/1000 [57:01<52:00,  6.54s/it][Succeeded / Failed / Skipped / Total] 411 / 100 / 12 / 523:  52%|█████▏    | 524/1000 [57:01<51:48,  6.53s/it][Succeeded / Failed / Skipped / Total] 411 / 100 / 13 / 524:  52%|█████▏    | 524/1000 [57:01<51:48,  6.53s/it][Succeeded / Failed / Skipped / Total] 411 / 100 / 13 / 524:  52%|█████▎    | 525/1000 [57:09<51:42,  6.53s/it][Succeeded / Failed / Skipped / Total] 412 / 100 / 13 / 525:  52%|█████▎    | 525/1000 [57:09<51:42,  6.53s/it][Succeeded / Failed / Skipped / Total] 412 / 100 / 13 / 525:  53%|█████▎    | 526/1000 [57:13<51:34,  6.53s/it][Succeeded / Failed / Skipped / Total] 413 / 100 / 13 / 526:  53%|█████▎    | 526/1000 [57:13<51:34,  6.53s/it][Succeeded / Failed / Skipped / Total] 413 / 100 / 13 / 526:  53%|█████▎    | 527/1000 [57:23<51:30,  6.53s/it][Succeeded / Failed / Skipped / Total] 414 / 100 / 13 / 527:  53%|█████▎    | 527/1000 [57:23<51:30,  6.53s/it][Succeeded / Failed / Skipped / Total] 414 / 100 / 13 / 527:  53%|█████▎    | 528/1000 [57:28<51:22,  6.53s/it]Returns the socket . --> Bootlecker --> Socre: 1.0

[[[[Adv]]]]: private Socket [[getSocket]] ( WebSocket [[conn]] ) { WebSocketImpl [[impl]] = ( WebSocketImpl ) [[conn]] ; return ( ( SocketChannel ) [[impl]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection

[[[[Adv]]]]: private Socket [[bootlegger]] ( WebSocket [[bulging]] ) { WebSocketImpl [[clippers]] = ( WebSocketImpl ) [[bulging]] ; return ( ( SocketChannel ) [[clippers]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection
--------------------------------------------- Result 518 ---------------------------------------------
Allows the given transaction to be used in a transaction . --> Branch implementation --> Socre: 1.0

[[[[Adv]]]]: public void [[withTransaction]] ( Consumer < EntityManager > block ) { [[withTransaction]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .

[[[[Adv]]]]: public void [[brunette]] ( Consumer < EntityManager > block ) { [[brunette]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .
--------------------------------------------- Result 519 ---------------------------------------------
Convert arguments to a Scala buffer . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: private static Seq < Object > [[convertArgsToScalaBuffer]] ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary

[[[[Adv]]]]: private static Seq < Object > [[devoting]] ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary
--------------------------------------------- Result 520 ---------------------------------------------
Wraps an array to a List if needed . --> Helper method to bind varargs --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[wrapArgsToListIfNeeded]] ( final T ... args ) { List < T > out ; if ( args != null && args . length == 1 && args [ 0 ] instanceof List ) { out = ( List < T > ) args [ 0 ] ; } else { out = Arrays . asList ( args ) ; } return out ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[bindle]] ( final T ... args ) { List < T > out ; if ( args != null && args . length == 1 && args [ 0 ] instanceof List ) { out = ( List < T > ) args [ 0 ] ; } else { out = Arrays . asList ( args ) ; } return out ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .
--------------------------------------------- Result 521 ---------------------------------------------
Gets the message . --> Get indicator by key --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang lang , String key , Object ... args ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( key , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates a message .

[[[[Adv]]]]: public String [[indicator]] ( play . api . i18n . Lang lang , String key , Object ... args ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( key , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates a message .
--------------------------------------------- Result 522 ---------------------------------------------
Returns the EntityManager for the given name . --> Advance admiral --> Socre: 1.0

[[[[Adv]]]]: public EntityManager [[em]] ( String [[name]] ) { EntityManagerFactory emf = emfs . get ( [[name]] ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .

[[[[Adv]]]]: public EntityManager [[admiral]] ( String [[canapés]] ) { EntityManagerFactory emf = emfs . get ( [[canapés]] ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .
--------------------------------------------- Result 523 ---------------------------------------------
Specify the bindings for the given modules . --> A convenience method for creating an instance of this class --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .

[[[[Adv]]]]: public final Self [[anesthetist]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .
--------------------------------------------- Result 524 ---------------------------------------------
Sets the REPLACEME --> [[[SKIPPED]]]

[[[[Adv]]]]: public final Self REPLACEME0 ( play . api . inject . Binding < ? > ... REPLACEME0 ) { return REPLACEME0 ( Guiceable . bindings ( REPLACEME0 ) ) ; }
[[[[Nl]]]]: Add Play bindings .
--------------------------------------------- Result 525 ---------------------------------------------
Define Guice binding . --> Calculates a self - facing Agreement with the current settings --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( play . api . inject . Module ... modules ) { return [[bindings]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .

[[[[Adv]]]]: public final Self [[agnès]] ( play . api . inject . Module ... modules ) { return [[agnès]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .
--------------------------------------------- Result 526 ---------------------------------------------
Returns the preferred message for this request . --> Performs Parabolic --> Socre: 1.0

[[[[Adv]]]]: public Messages [[preferred]] ( Http . RequestHeader request ) { play . api . i18n . Messages [[msgs]] = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( [[msgs]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .

[[[[Adv]]]]: public Messages [[parabolic]] ( Http . RequestHeader request ) { play . api . i18n . Messages [[cache]] = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( [[cache]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .
--------------------------------------------- Result 527 ---------------------------------------------
Specifies the module overrides from the given modules . --> Sets the Fills from the Guice module --> Socre: 1.0

[[[[Adv]]]]: public final Self overrides ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .

[[[[Adv]]]]: public final Self overrides ( GuiceableModule ... [[foothills]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[foothills]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .
--------------------------------------------- Result 528 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 415 / 100 / 13 / 528:  53%|█████▎    | 528/1000 [57:28<51:22,  6.53s/it][Succeeded / Failed / Skipped / Total] 415 / 100 / 13 / 528:  53%|█████▎    | 529/1000 [57:28<51:10,  6.52s/it][Succeeded / Failed / Skipped / Total] 415 / 100 / 14 / 529:  53%|█████▎    | 529/1000 [57:28<51:10,  6.52s/it][Succeeded / Failed / Skipped / Total] 415 / 100 / 14 / 529:  53%|█████▎    | 530/1000 [57:29<50:58,  6.51s/it][Succeeded / Failed / Skipped / Total] 416 / 100 / 14 / 530:  53%|█████▎    | 530/1000 [57:29<50:58,  6.51s/it][Succeeded / Failed / Skipped / Total] 416 / 100 / 14 / 530:  53%|█████▎    | 531/1000 [57:30<50:47,  6.50s/it][Succeeded / Failed / Skipped / Total] 417 / 100 / 14 / 531:  53%|█████▎    | 531/1000 [57:30<50:47,  6.50s/it][Succeeded / Failed / Skipped / Total] 417 / 100 / 14 / 531:  53%|█████▎    | 532/1000 [57:34<50:38,  6.49s/it][Succeeded / Failed / Skipped / Total] 418 / 100 / 14 / 532:  53%|█████▎    | 532/1000 [57:34<50:38,  6.49s/it][Succeeded / Failed / Skipped / Total] 418 / 100 / 14 / 532:  53%|█████▎    | 533/1000 [57:36<50:28,  6.48s/it][Succeeded / Failed / Skipped / Total] 418 / 101 / 14 / 533:  53%|█████▎    | 533/1000 [57:36<50:28,  6.48s/it][Succeeded / Failed / Skipped / Total] 418 / 101 / 14 / 533:  53%|█████▎    | 534/1000 [57:46<50:24,  6.49s/it][Succeeded / Failed / Skipped / Total] 419 / 101 / 14 / 534:  53%|█████▎    | 534/1000 [57:46<50:24,  6.49s/it][Succeeded / Failed / Skipped / Total] 419 / 101 / 14 / 534:  54%|█████▎    | 535/1000 [57:49<50:15,  6.49s/it][Succeeded / Failed / Skipped / Total] 419 / 102 / 14 / 535:  54%|█████▎    | 535/1000 [57:49<50:15,  6.49s/it][Succeeded / Failed / Skipped / Total] 419 / 102 / 14 / 535:  54%|█████▎    | 536/1000 [57:50<50:04,  6.48s/it][Succeeded / Failed / Skipped / Total] 419 / 103 / 14 / 536:  54%|█████▎    | 536/1000 [57:50<50:04,  6.48s/it][Succeeded / Failed / Skipped / Total] 419 / 103 / 14 / 536:  54%|█████▎    | 537/1000 [57:52<49:53,  6.47s/it][Succeeded / Failed / Skipped / Total] 420 / 103 / 14 / 537:  54%|█████▎    | 537/1000 [57:52<49:53,  6.47s/it][Succeeded / Failed / Skipped / Total] 420 / 103 / 14 / 537:  54%|█████▍    | 538/1000 [57:56<49:45,  6.46s/it][Succeeded / Failed / Skipped / Total] 421 / 103 / 14 / 538:  54%|█████▍    | 538/1000 [57:56<49:45,  6.46s/it][Succeeded / Failed / Skipped / Total] 421 / 103 / 14 / 538:  54%|█████▍    | 539/1000 [57:58<49:34,  6.45s/it][Succeeded / Failed / Skipped / Total] 422 / 103 / 14 / 539:  54%|█████▍    | 539/1000 [57:58<49:34,  6.45s/it][Succeeded / Failed / Skipped / Total] 422 / 103 / 14 / 539:  54%|█████▍    | 540/1000 [58:18<49:39,  6.48s/it]Gets the translation . --> returns a string with all arguments --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang lang , List < String > keys , Object ... args ) { Buffer < String > [[keyArgs]] = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > [[scalaArgs]] = convertArgsToScalaBuffer ( args ) ; return messages . apply ( [[keyArgs]] . toSeq ( ) , [[scalaArgs]] , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .

[[[[Adv]]]]: public String [[andthen]] ( play . api . i18n . Lang lang , List < String > keys , Object ... args ) { Buffer < String > [[ultramodern]] = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > [[kian]] = convertArgsToScalaBuffer ( args ) ; return messages . apply ( [[ultramodern]] . toSeq ( ) , [[kian]] , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .
--------------------------------------------- Result 529 ---------------------------------------------
from interface --> [[[SKIPPED]]]

[[[[Adv]]]]: public CompletionStage < Result > call ( Request req ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .
--------------------------------------------- Result 530 ---------------------------------------------
Set the language to the given result . --> Overrides confederation --> Socre: 1.0

[[[[Adv]]]]: public Result [[setLang]] ( Result [[result]] , Lang lang ) { return messages . setLang ( [[result]] . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .

[[[[Adv]]]]: public Result [[confederation]] ( Result [[conejo]] , Lang lang ) { return messages . setLang ( [[conejo]] . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .
--------------------------------------------- Result 531 ---------------------------------------------
Specifies this module overrides . --> Creates an instance with azlr --> Socre: 1.0

[[[[Adv]]]]: public final Self overrides ( play . api . inject . Module ... [[modules]] ) { return overrides ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .

[[[[Adv]]]]: public final Self overrides ( play . api . inject . Module ... [[azriel]] ) { return overrides ( Guiceable . [[azriel]] ( [[azriel]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .
--------------------------------------------- Result 532 ---------------------------------------------
Specifies the Guice to use . --> Create a new burn side --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Binding < ? > ... bindings ) { return [[overrides]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .

[[[[Adv]]]]: public final Self [[burnside]] ( play . api . inject . Binding < ? > ... bindings ) { return [[burnside]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .
--------------------------------------------- Result 533 ---------------------------------------------
Checks if is defined at the specified language . --> [[[FAILED]]]

[[[[Adv]]]]: public Boolean isDefinedAt ( play . api . i18n . Lang [[lang]] , String key ) { return messages . isDefinedAt ( key , [[lang]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .

[[[[Adv]]]]: public Boolean isDefinedAt ( play . api . i18n . Lang [[mimeograph]] , String key ) { return messages . isDefinedAt ( key , [[mimeograph]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .
--------------------------------------------- Result 534 ---------------------------------------------
Disable the given modules . --> Returns a copy of this mock with the given module classes --> Socre: 1.0

[[[[Adv]]]]: public final Self [[disable]] ( Class < ? > ... moduleClasses ) { return newBuilder ( delegate . disable ( Scala . toSeq ( moduleClasses ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .

[[[[Adv]]]]: public final Self [[welded]] ( Class < ? > ... moduleClasses ) { return newBuilder ( delegate . disable ( Scala . toSeq ( moduleClasses ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .
--------------------------------------------- Result 535 ---------------------------------------------
Creates a binding for the given scope . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .

[[[[Adv]]]]: public < A [[lightened]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .
--------------------------------------------- Result 536 ---------------------------------------------
Selects the preferred languages . --> [[[FAILED]]]

[[[[Adv]]]]: public Messages [[preferred]] ( Collection < Lang > candidates ) { Seq < Lang > cs = Scala . asScala ( candidates ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .

[[[[Adv]]]]: public Messages [[jaisalmer]] ( Collection < Lang > candidates ) { Seq < Lang > cs = Scala . asScala ( candidates ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .
--------------------------------------------- Result 537 ---------------------------------------------
Static factory method for creating a new instance . --> Returns an Aganist instance --> Socre: 1.0

[[[[Adv]]]]: public static < A , B > [[Tuple]] < A , B > [[Tuple]] ( A a , B b ) { return new [[Tuple]] < A , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B

[[[[Adv]]]]: public static < A , B > [[Aganist]] < A , B > [[Aganist]] ( A a , B b ) { return new [[Aganist]] < A , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B
--------------------------------------------- Result 538 ---------------------------------------------
Convert execution context to Executor --> Wrapper around ExecutionContext --> Socre: 1.0

[[[[Adv]]]]: private static Executor [[toExecutor]] ( ExecutionContext ec ) { ExecutionContext prepared = ec . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .

[[[[Adv]]]]: private static Executor [[keir]] ( ExecutionContext ec ) { ExecutionContext prepared = ec . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .
--------------------------------------------- Result 539 ---------------------------------------------
Creates a tuple of five values . --> Factory method for five tuples . --> Socre: 1.0

[[[[Adv]]]]: public static < [[A]] , B , C , D , E > Tuple5 < [[A]] , B , C , D , E > Tuple5 ( [[A]] a , B b , C c , D d , E e ) { return new Tuple5 < [[A]] , B , C , D , E > ( a , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E

[[[[Adv]]]]: public static < [[bernd]] , B , C , D , E > Tuple5 < [[bernd]] , B , C , D , E > Tuple5 ( [[bernd]] a , B b , C c , D d , E e ) { return new Tuple5 < [[bernd]] , B , C , D , E > ( a , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E
--------------------------------------------- Result 540 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 422 / 104 / 14 / 540:  54%|█████▍    | 540/1000 [58:18<49:39,  6.48s/it][Succeeded / Failed / Skipped / Total] 422 / 104 / 14 / 540:  54%|█████▍    | 541/1000 [58:32<49:39,  6.49s/it][Succeeded / Failed / Skipped / Total] 422 / 105 / 14 / 541:  54%|█████▍    | 541/1000 [58:32<49:39,  6.49s/it][Succeeded / Failed / Skipped / Total] 422 / 105 / 14 / 541:  54%|█████▍    | 542/1000 [58:38<49:33,  6.49s/it][Succeeded / Failed / Skipped / Total] 422 / 106 / 14 / 542:  54%|█████▍    | 542/1000 [58:38<49:33,  6.49s/it][Succeeded / Failed / Skipped / Total] 422 / 106 / 14 / 542:  54%|█████▍    | 543/1000 [58:38<49:21,  6.48s/it][Succeeded / Failed / Skipped / Total] 423 / 106 / 14 / 543:  54%|█████▍    | 543/1000 [58:38<49:21,  6.48s/it][Succeeded / Failed / Skipped / Total] 423 / 106 / 14 / 543:  54%|█████▍    | 544/1000 [58:39<49:10,  6.47s/it][Succeeded / Failed / Skipped / Total] 424 / 106 / 14 / 544:  54%|█████▍    | 544/1000 [58:39<49:10,  6.47s/it][Succeeded / Failed / Skipped / Total] 424 / 106 / 14 / 544:  55%|█████▍    | 545/1000 [58:51<49:07,  6.48s/it][Succeeded / Failed / Skipped / Total] 425 / 106 / 14 / 545:  55%|█████▍    | 545/1000 [58:51<49:07,  6.48s/it][Succeeded / Failed / Skipped / Total] 425 / 106 / 14 / 545:  55%|█████▍    | 546/1000 [58:56<49:00,  6.48s/it][Succeeded / Failed / Skipped / Total] 426 / 106 / 14 / 546:  55%|█████▍    | 546/1000 [58:56<49:00,  6.48s/it][Succeeded / Failed / Skipped / Total] 426 / 106 / 14 / 546:  55%|█████▍    | 547/1000 [59:04<48:55,  6.48s/it][Succeeded / Failed / Skipped / Total] 427 / 106 / 14 / 547:  55%|█████▍    | 547/1000 [59:04<48:55,  6.48s/it][Succeeded / Failed / Skipped / Total] 427 / 106 / 14 / 547:  55%|█████▍    | 548/1000 [59:11<48:49,  6.48s/it]Gets an existing file . --> [[[FAILED]]]

[[[[Adv]]]]: public Optional < File > [[getExistingFile]] ( String [[relativePath]] ) { return OptionConverters . toJava ( env . getExistingFile ( [[relativePath]] ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .

[[[[Adv]]]]: public Optional < File > [[español]] ( String [[banners]] ) { return OptionConverters . toJava ( env . getExistingFile ( [[banners]] ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .
--------------------------------------------- Result 541 ---------------------------------------------
Inject ByteString into ByteString --> [[[FAILED]]]

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > string ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > string ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .
--------------------------------------------- Result 542 ---------------------------------------------
Adds a constraint validator . --> [[[FAILED]]]

[[[[Adv]]]]: public < T [[extends]] ConstraintValidator < ? , ? > > MappedConstraintValidatorFactory addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .

[[[[Adv]]]]: public < T [[deportations]] ConstraintValidator < ? , ? > > MappedConstraintValidatorFactory addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .
--------------------------------------------- Result 543 ---------------------------------------------
Gets a flow from a JsonNode --> Inject acker into ack --> Socre: 1.0

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[json]] ( String [[callbackName]] ) { return Flow . of ( JsonNode . class ) . map ( [[json]] -> { return ByteString . fromString ( Json . stringify ( [[json]] ) ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[acker]] ( String [[barbell]] ) { return Flow . of ( JsonNode . class ) . map ( [[acker]] -> { return ByteString . fromString ( Json . stringify ( [[acker]] ) ) ; } ) . via ( flow ( [[barbell]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .
--------------------------------------------- Result 544 ---------------------------------------------
Creates new instance of the given constraint validator class . --> Returns a new instance of the given class --> Socre: 1.0

[[[[Adv]]]]: private < [[T]] extends ConstraintValidator < ? , ? > > [[T]] newInstance ( Class < [[T]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .

[[[[Adv]]]]: private < [[baldie]] extends ConstraintValidator < ? , ? > > [[baldie]] newInstance ( Class < [[baldie]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .
--------------------------------------------- Result 545 ---------------------------------------------
Creates a new JPAConfig instance . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String [[name]] , String [[unitName]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[name]] , [[unitName]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .

[[[[Adv]]]]: public static JPAConfig [[deliberated]] ( String [[césar]] , String [[coveralls]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[césar]] , [[coveralls]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .
--------------------------------------------- Result 546 ---------------------------------------------
Handle bad request . --> region BadRequest --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > onBadRequest ( RequestHeader [[request]] , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( [[request]] . method ( ) , [[request]] . uri ( ) , message , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .

[[[[Adv]]]]: protected CompletionStage < Result > onBadRequest ( RequestHeader [[whale]] , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( [[whale]] . method ( ) , [[whale]] . uri ( ) , message , [[whale]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .
--------------------------------------------- Result 547 ---------------------------------------------
Creates a default JPAConfig . --> Liberty changes --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String [[n1]] , String u1 , String n2 , String [[u2]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[n1]] , u1 ) , new JPAConfig . PersistenceUnit ( n2 , [[u2]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .

[[[[Adv]]]]: public static JPAConfig [[deliberated]] ( String [[diphtheria]] , String u1 , String n2 , String [[electro]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[diphtheria]] , u1 ) , new JPAConfig . PersistenceUnit ( n2 , [[electro]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .
--------------------------------------------- Result 548 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 428 / 106 / 14 / 548:  55%|█████▍    | 548/1000 [59:11<48:49,  6.48s/it][Succeeded / Failed / Skipped / Total] 428 / 106 / 14 / 548:  55%|█████▍    | 549/1000 [59:16<48:41,  6.48s/it][Succeeded / Failed / Skipped / Total] 428 / 107 / 14 / 549:  55%|█████▍    | 549/1000 [59:16<48:41,  6.48s/it][Succeeded / Failed / Skipped / Total] 428 / 107 / 14 / 549:  55%|█████▌    | 550/1000 [59:19<48:32,  6.47s/it][Succeeded / Failed / Skipped / Total] 429 / 107 / 14 / 550:  55%|█████▌    | 550/1000 [59:19<48:32,  6.47s/it][Succeeded / Failed / Skipped / Total] 429 / 107 / 14 / 550:  55%|█████▌    | 551/1000 [59:24<48:24,  6.47s/it][Succeeded / Failed / Skipped / Total] 430 / 107 / 14 / 551:  55%|█████▌    | 551/1000 [59:24<48:24,  6.47s/it][Succeeded / Failed / Skipped / Total] 430 / 107 / 14 / 551:  55%|█████▌    | 552/1000 [59:35<48:21,  6.48s/it][Succeeded / Failed / Skipped / Total] 431 / 107 / 14 / 552:  55%|█████▌    | 552/1000 [59:35<48:21,  6.48s/it][Succeeded / Failed / Skipped / Total] 431 / 107 / 14 / 552:  55%|█████▌    | 553/1000 [59:48<48:20,  6.49s/it][Succeeded / Failed / Skipped / Total] 432 / 107 / 14 / 553:  55%|█████▌    | 553/1000 [59:48<48:20,  6.49s/it][Succeeded / Failed / Skipped / Total] 432 / 107 / 14 / 553:  55%|█████▌    | 554/1000 [59:52<48:12,  6.48s/it]On not found request . --> region NotFoundException --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > onNotFound ( RequestHeader [[request]] , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , [[request]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[request]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .

[[[[Adv]]]]: protected CompletionStage < Result > onNotFound ( RequestHeader [[renovation]] , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[renovation]] . method ( ) , [[renovation]] . uri ( ) , [[renovation]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[renovation]] . method ( ) , [[renovation]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[renovation]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .
--------------------------------------------- Result 549 ---------------------------------------------
Creates a new JPAConfig instance from the given map . --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig [[from]] ( Map < String , String > map ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > [[entry]] : map . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( [[entry]] . getKey ( ) , [[entry]] . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .

[[[[Adv]]]]: public static JPAConfig [[absolution]] ( Map < String , String > map ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > [[contented]] : map . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( [[contented]] . getKey ( ) , [[contented]] . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .
--------------------------------------------- Result 550 ---------------------------------------------
Called when an error occurs . --> Called to handle cropping --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onClientError]] ( RequestHeader request , int [[statusCode]] , String message ) { if ( [[statusCode]] == 400 ) { return onBadRequest ( request , message ) ; } else if ( [[statusCode]] == 403 ) { return onForbidden ( request , message ) ; } else if ( [[statusCode]] == 404 ) { return onNotFound ( request , message ) ; } else if ( [[statusCode]] >= 400 && [[statusCode]] < 500 ) { return onOtherClientError ( request , [[statusCode]] , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + [[statusCode]] + ": " + message ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[croker]] ( RequestHeader request , int [[benda]] , String message ) { if ( [[benda]] == 400 ) { return onBadRequest ( request , message ) ; } else if ( [[benda]] == 403 ) { return onForbidden ( request , message ) ; } else if ( [[benda]] == 404 ) { return onNotFound ( request , message ) ; } else if ( [[benda]] >= 400 && [[benda]] < 500 ) { return onOtherClientError ( request , [[benda]] , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + [[benda]] + ": " + message ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .
--------------------------------------------- Result 551 ---------------------------------------------
Logs an error . --> Print out a useful exception message --> Socre: 1.0

[[[[Adv]]]]: protected void [[logServerError]] ( RequestHeader request , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , request . method ( ) , request . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .

[[[[Adv]]]]: protected void [[alongwith]] ( RequestHeader request , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , request . method ( ) , request . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .
--------------------------------------------- Result 552 ---------------------------------------------
Handle unauthorized action . --> Cased version --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onForbidden]] ( RequestHeader request , String [[message]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .

[[[[Adv]]]]: protected CompletionStage < Result > [[cased]] ( RequestHeader request , String [[emphysema]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .
--------------------------------------------- Result 553 ---------------------------------------------
Create a BuildDocHandler from the resources . --> Methode permettant dirs --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromResources]] ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .

[[[[Adv]]]]: public static BuildDocHandler [[maitre]] ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .
--------------------------------------------- Result 554 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 433 / 107 / 14 / 554:  55%|█████▌    | 554/1000 [59:52<48:12,  6.48s/it][Succeeded / Failed / Skipped / Total] 433 / 107 / 14 / 554:  56%|█████▌    | 555/1000 [59:57<48:04,  6.48s/it][Succeeded / Failed / Skipped / Total] 434 / 107 / 14 / 555:  56%|█████▌    | 555/1000 [59:57<48:04,  6.48s/it][Succeeded / Failed / Skipped / Total] 434 / 107 / 14 / 555:  56%|█████▌    | 556/1000 [1:00:06<48:00,  6.49s/it][Succeeded / Failed / Skipped / Total] 435 / 107 / 14 / 556:  56%|█████▌    | 556/1000 [1:00:06<48:00,  6.49s/it][Succeeded / Failed / Skipped / Total] 435 / 107 / 14 / 556:  56%|█████▌    | 557/1000 [1:00:12<47:53,  6.49s/it][Succeeded / Failed / Skipped / Total] 436 / 107 / 14 / 557:  56%|█████▌    | 557/1000 [1:00:12<47:53,  6.49s/it][Succeeded / Failed / Skipped / Total] 436 / 107 / 14 / 557:  56%|█████▌    | 558/1000 [1:00:17<47:45,  6.48s/it][Succeeded / Failed / Skipped / Total] 436 / 108 / 14 / 558:  56%|█████▌    | 558/1000 [1:00:17<47:45,  6.48s/it][Succeeded / Failed / Skipped / Total] 436 / 108 / 14 / 558:  56%|█████▌    | 559/1000 [1:00:18<47:34,  6.47s/it][Succeeded / Failed / Skipped / Total] 437 / 108 / 14 / 559:  56%|█████▌    | 559/1000 [1:00:18<47:34,  6.47s/it][Succeeded / Failed / Skipped / Total] 437 / 108 / 14 / 559:  56%|█████▌    | 560/1000 [1:00:19<47:23,  6.46s/it][Succeeded / Failed / Skipped / Total] 437 / 109 / 14 / 560:  56%|█████▌    | 560/1000 [1:00:19<47:23,  6.46s/it][Succeeded / Failed / Skipped / Total] 437 / 109 / 14 / 560:  56%|█████▌    | 561/1000 [1:00:27<47:18,  6.47s/it][Succeeded / Failed / Skipped / Total] 438 / 109 / 14 / 561:  56%|█████▌    | 561/1000 [1:00:27<47:18,  6.47s/it][Succeeded / Failed / Skipped / Total] 438 / 109 / 14 / 561:  56%|█████▌    | 562/1000 [1:00:33<47:11,  6.46s/it]Converts a throwable to a useful exception . --> This method should only be used for testing purposes only --> Socre: 1.0

[[[[Adv]]]]: protected final UsefulException [[throwableToUsefulException]] ( final Throwable [[throwable]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[throwable]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .

[[[[Adv]]]]: protected final UsefulException [[manchurian]] ( final Throwable [[reprogrammed]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[reprogrammed]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .
--------------------------------------------- Result 555 ---------------------------------------------
Sends an error . --> Permanently puncture --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onDevServerError]] ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .

[[[[Adv]]]]: protected CompletionStage < Result > [[puncture]] ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .
--------------------------------------------- Result 556 ---------------------------------------------
Handles server error . --> This method is intended to be used for testing purposes --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onServerError]] ( RequestHeader [[request]] , Throwable exception ) { try { UsefulException [[usefulException]] = throwableToUsefulException ( exception ) ; logServerError ( [[request]] , [[usefulException]] ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( [[request]] , [[usefulException]] ) ; default : return onDevServerError ( [[request]] , [[usefulException]] ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[sharpest]] ( RequestHeader [[accused]] , Throwable exception ) { try { UsefulException [[woodsmen]] = throwableToUsefulException ( exception ) ; logServerError ( [[accused]] , [[woodsmen]] ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( [[accused]] , [[woodsmen]] ) ; default : return onDevServerError ( [[accused]] , [[woodsmen]] ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .
--------------------------------------------- Result 557 ---------------------------------------------
Creates a new BuildDocHandler from a directory and a jar file . --> Useful for testing --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File directory , JarFile jarFile , String base ) { return [[fromDirectoryAndJar]] ( directory , jarFile , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository

[[[[Adv]]]]: public static BuildDocHandler [[fiction]] ( File directory , JarFile jarFile , String base ) { return [[fiction]] ( directory , jarFile , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository
--------------------------------------------- Result 558 ---------------------------------------------
Gets the matching method . --> [[[FAILED]]]

[[[[Adv]]]]: public static Method [[getMatchingAccessibleMethod]] ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .

[[[[Adv]]]]: public static Method [[mangan]] ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .
--------------------------------------------- Result 559 ---------------------------------------------
Creates a documentation handler from a directory . --> Parabolic document handler --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectory]] ( File directory ) { FileRepository [[repo]] = new FilesystemRepository ( directory ) ; return new DocumentationHandler ( [[repo]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .

[[[[Adv]]]]: public static BuildDocHandler [[parabolic]] ( File directory ) { FileRepository [[skippy]] = new FilesystemRepository ( directory ) ; return new DocumentationHandler ( [[skippy]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .
--------------------------------------------- Result 560 ---------------------------------------------
Sends a server error . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > [[onProdServerError]] ( RequestHeader request , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[exception]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .

[[[[Adv]]]]: protected CompletionStage < Result > [[mastro]] ( RequestHeader request , UsefulException [[anomalies]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[anomalies]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .
--------------------------------------------- Result 561 ---------------------------------------------
Consumes the data stream with the given material . --> Completes an axel --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < ByteString > [[consumeData]] ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
[[[[Nl]]]]: Consumes the data .

[[[[Adv]]]]: public CompletionStage < ByteString > [[axel]] ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
[[[[Nl]]]]: Consumes the data .
--------------------------------------------- Result 562 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 439 / 109 / 14 / 562:  56%|█████▌    | 562/1000 [1:00:33<47:11,  6.46s/it][Succeeded / Failed / Skipped / Total] 439 / 109 / 14 / 562:  56%|█████▋    | 563/1000 [1:00:40<47:05,  6.47s/it][Succeeded / Failed / Skipped / Total] 440 / 109 / 14 / 563:  56%|█████▋    | 563/1000 [1:00:40<47:05,  6.47s/it][Succeeded / Failed / Skipped / Total] 440 / 109 / 14 / 563:  56%|█████▋    | 564/1000 [1:00:40<46:54,  6.46s/it][Succeeded / Failed / Skipped / Total] 441 / 109 / 14 / 564:  56%|█████▋    | 564/1000 [1:00:40<46:54,  6.46s/it][Succeeded / Failed / Skipped / Total] 441 / 109 / 14 / 564:  56%|█████▋    | 565/1000 [1:00:42<46:44,  6.45s/it][Succeeded / Failed / Skipped / Total] 442 / 109 / 14 / 565:  56%|█████▋    | 565/1000 [1:00:42<46:44,  6.45s/it][Succeeded / Failed / Skipped / Total] 442 / 109 / 14 / 565:  57%|█████▋    | 566/1000 [1:00:42<46:33,  6.44s/it][Succeeded / Failed / Skipped / Total] 442 / 109 / 15 / 566:  57%|█████▋    | 566/1000 [1:00:42<46:33,  6.44s/it][Succeeded / Failed / Skipped / Total] 442 / 109 / 15 / 566:  57%|█████▋    | 567/1000 [1:00:51<46:28,  6.44s/it][Succeeded / Failed / Skipped / Total] 443 / 109 / 15 / 567:  57%|█████▋    | 567/1000 [1:00:51<46:28,  6.44s/it][Succeeded / Failed / Skipped / Total] 443 / 109 / 15 / 567:  57%|█████▋    | 568/1000 [1:00:56<46:20,  6.44s/it][Succeeded / Failed / Skipped / Total] 444 / 109 / 15 / 568:  57%|█████▋    | 568/1000 [1:00:56<46:20,  6.44s/it][Succeeded / Failed / Skipped / Total] 444 / 109 / 15 / 568:  57%|█████▋    | 569/1000 [1:00:58<46:11,  6.43s/it][Succeeded / Failed / Skipped / Total] 445 / 109 / 15 / 569:  57%|█████▋    | 569/1000 [1:00:58<46:11,  6.43s/it][Succeeded / Failed / Skipped / Total] 445 / 109 / 15 / 569:  57%|█████▋    | 570/1000 [1:01:01<46:02,  6.42s/it][Succeeded / Failed / Skipped / Total] 446 / 109 / 15 / 570:  57%|█████▋    | 570/1000 [1:01:01<46:02,  6.42s/it][Succeeded / Failed / Skipped / Total] 446 / 109 / 15 / 570:  57%|█████▋    | 571/1000 [1:01:11<45:58,  6.43s/it][Succeeded / Failed / Skipped / Total] 446 / 110 / 15 / 571:  57%|█████▋    | 571/1000 [1:01:11<45:58,  6.43s/it][Succeeded / Failed / Skipped / Total] 446 / 110 / 15 / 571:  57%|█████▋    | 572/1000 [1:01:18<45:52,  6.43s/it]Create HttpEntity from content . --> UTF - 8 --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromContent]] ( Content content , String charset ) { String body ; if ( content instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .

[[[[Adv]]]]: public static final HttpEntity [[duckling]] ( Content content , String charset ) { String body ; if ( content instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .
--------------------------------------------- Result 563 ---------------------------------------------
Creates a new documentation handler from a jar file . --> Html handler --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromJar]] ( JarFile [[jarFile]] , String base ) { FileRepository repo = new JarRepository ( [[jarFile]] , Option . apply ( base ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[hennessy]] ( JarFile [[dishwasher]] , String base ) { FileRepository repo = new JarRepository ( [[dishwasher]] , Option . apply ( base ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 564 ---------------------------------------------
Creates a chunked entity from a source . --> Create an HttpEntity --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[chunked]] ( Source < ByteString , ? > data , Optional < String > contentType ) { return new Chunked ( data . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .

[[[[Adv]]]]: public static final HttpEntity [[rajeev]] ( Source < ByteString , ? > data , Optional < String > contentType ) { return new Chunked ( data . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .
--------------------------------------------- Result 565 ---------------------------------------------
Create a Result with the given status code and content . --> return status code --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int [[status]] , JsonNode content ) { return status ( status , content , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .

[[[[Adv]]]]: public static Result status ( int [[nasreddin]] , JsonNode content ) { return status ( status , content , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .
--------------------------------------------- Result 566 ---------------------------------------------
Return user by id --> [[[SKIPPED]]]

[[[[Adv]]]]: private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
[[[[Nl]]]]: designed to be lightweight operation
--------------------------------------------- Result 567 ---------------------------------------------
Sends response with status code . --> Method used to send SWT SWT --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int status , JsonNode content , JsonEncoding [[encoding]] ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return status ( status ) . sendJson ( content , [[encoding]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .

[[[[Adv]]]]: public static Result status ( int status , JsonNode content , JsonEncoding [[pawnshop]] ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return status ( status ) . sendJson ( content , [[pawnshop]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .
--------------------------------------------- Result 568 ---------------------------------------------
Creates a Result . --> Methode eee es kee es ene ese es kee ese es kee es kee ese kee es kee es keee es kee es kee esee ese es keee es kee ese es kee es kee ese es kee es keee es kee es kee es kee es keee ese es kee es keee keee ese es kee es kee ese ese es keeee ese es kee es keee es kee es kee --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , byte [ ] content ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( [[status]] , new HttpEntity . Strict ( ByteString . fromArray ( content ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .

[[[[Adv]]]]: public static Result [[noël]] ( int status , byte [ ] content ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( [[noël]] , new HttpEntity . Strict ( ByteString . fromArray ( content ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .
--------------------------------------------- Result 569 ---------------------------------------------
Creates a documentation handler from a directory and a jar file . --> Factory method for testing --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File [[directory]] , JarFile jarFile , String [[base]] , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( [[directory]] ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( [[base]] ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[piddle]] ( File [[gynecologist]] , JarFile jarFile , String [[beds]] , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( [[gynecologist]] ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( [[beds]] ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 570 ---------------------------------------------
Create an HttpEntity from a string . --> Creates HttpEntity --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromString]] ( String [[content]] , String charset ) { return new Strict ( ByteString . fromString ( [[content]] , charset ) , Optional . of ( "text/plain; charset=" + charset ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .

[[[[Adv]]]]: public static final HttpEntity [[abandoned]] ( String [[edoardo]] , String charset ) { return new Strict ( ByteString . fromString ( [[edoardo]] , charset ) , Optional . of ( "text/plain; charset=" + charset ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .
--------------------------------------------- Result 571 ---------------------------------------------
Returns a unique call . --> [[[FAILED]]]

[[[[Adv]]]]: public Call [[unique]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .

[[[[Adv]]]]: public Call [[differs]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .
--------------------------------------------- Result 572 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 447 / 110 / 15 / 572:  57%|█████▋    | 572/1000 [1:01:18<45:52,  6.43s/it][Succeeded / Failed / Skipped / Total] 447 / 110 / 15 / 572:  57%|█████▋    | 573/1000 [1:01:21<45:43,  6.43s/it][Succeeded / Failed / Skipped / Total] 448 / 110 / 15 / 573:  57%|█████▋    | 573/1000 [1:01:21<45:43,  6.43s/it][Succeeded / Failed / Skipped / Total] 448 / 110 / 15 / 573:  57%|█████▋    | 574/1000 [1:01:22<45:32,  6.41s/it][Succeeded / Failed / Skipped / Total] 449 / 110 / 15 / 574:  57%|█████▋    | 574/1000 [1:01:22<45:32,  6.41s/it][Succeeded / Failed / Skipped / Total] 449 / 110 / 15 / 574:  57%|█████▊    | 575/1000 [1:01:22<45:21,  6.40s/it][Succeeded / Failed / Skipped / Total] 450 / 110 / 15 / 575:  57%|█████▊    | 575/1000 [1:01:22<45:21,  6.40s/it][Succeeded / Failed / Skipped / Total] 450 / 110 / 15 / 575:  58%|█████▊    | 576/1000 [1:01:27<45:14,  6.40s/it][Succeeded / Failed / Skipped / Total] 451 / 110 / 15 / 576:  58%|█████▊    | 576/1000 [1:01:27<45:14,  6.40s/it][Succeeded / Failed / Skipped / Total] 451 / 110 / 15 / 576:  58%|█████▊    | 577/1000 [1:01:33<45:07,  6.40s/it][Succeeded / Failed / Skipped / Total] 451 / 111 / 15 / 577:  58%|█████▊    | 577/1000 [1:01:33<45:07,  6.40s/it][Succeeded / Failed / Skipped / Total] 451 / 111 / 15 / 577:  58%|█████▊    | 578/1000 [1:01:37<44:59,  6.40s/it][Succeeded / Failed / Skipped / Total] 452 / 111 / 15 / 578:  58%|█████▊    | 578/1000 [1:01:37<44:59,  6.40s/it][Succeeded / Failed / Skipped / Total] 452 / 111 / 15 / 578:  58%|█████▊    | 579/1000 [1:01:41<44:51,  6.39s/it][Succeeded / Failed / Skipped / Total] 453 / 111 / 15 / 579:  58%|█████▊    | 579/1000 [1:01:41<44:51,  6.39s/it][Succeeded / Failed / Skipped / Total] 454 / 111 / 15 / 580:  58%|█████▊    | 580/1000 [1:01:41<44:40,  6.38s/it][Succeeded / Failed / Skipped / Total] 454 / 111 / 15 / 580:  58%|█████▊    | 581/1000 [1:01:44<44:31,  6.38s/it][Succeeded / Failed / Skipped / Total] 455 / 111 / 15 / 581:  58%|█████▊    | 581/1000 [1:01:44<44:31,  6.38s/it][Succeeded / Failed / Skipped / Total] 456 / 111 / 15 / 582:  58%|█████▊    | 582/1000 [1:01:47<44:23,  6.37s/it][Succeeded / Failed / Skipped / Total] 456 / 111 / 15 / 582:  58%|█████▊    | 583/1000 [1:02:01<44:21,  6.38s/it]Returns the absolute URL for the given request . --> Creates a cleartcloth for the request --> Socre: 1.0

[[[[Adv]]]]: public String [[absoluteURL]] ( Http . Request request ) { return [[absoluteURL]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .

[[[[Adv]]]]: public String [[dishcloth]] ( Http . Request request ) { return [[dishcloth]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .
--------------------------------------------- Result 573 ---------------------------------------------
Selects the preferred language . --> package - private for testing --> Socre: 1.0

[[[[Adv]]]]: public Lang [[preferred]] ( Collection < Lang > [[candidates]] ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( [[candidates]] ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .

[[[[Adv]]]]: public Lang [[chesapeake]] ( Collection < Lang > [[thanks]] ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( [[thanks]] ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .
--------------------------------------------- Result 574 ---------------------------------------------
Creates a result with a file content . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int [[status]] , File [[content]] ) { return status ( status , [[content]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .

[[[[Adv]]]]: public static Result status ( int [[pathan]] , File [[gamers]] ) { return status ( status , [[gamers]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .
--------------------------------------------- Result 575 ---------------------------------------------
Returns the web socket URL . --> Calculate cardi for the given request --> Socre: 1.0

[[[[Adv]]]]: public String [[webSocketURL]] ( Http . Request request ) { return [[webSocketURL]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .

[[[[Adv]]]]: public String [[cardiogram]] ( Http . Request request ) { return [[cardiogram]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .
--------------------------------------------- Result 576 ---------------------------------------------
Sends an input stream to the response . --> Called when an input stream is opened --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int status , InputStream [[content]] , long [[contentLength]] ) { return status ( status ) . sendInputStream ( [[content]] , [[contentLength]] ) ; }
[[[[Nl]]]]: Generates a chunked result .

[[[[Adv]]]]: public static Result status ( int status , InputStream [[kiosk]] , long [[asano]] ) { return status ( status ) . sendInputStream ( [[kiosk]] , [[asano]] ) ; }
[[[[Nl]]]]: Generates a chunked result .
--------------------------------------------- Result 577 ---------------------------------------------
Creates a new call with the given fragment . --> [[[FAILED]]]

[[[[Adv]]]]: public Call [[withFragment]] ( String [[fragment]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[fragment]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .

[[[[Adv]]]]: public Call [[permeate]] ( String [[dowager]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[dowager]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .
--------------------------------------------- Result 578 ---------------------------------------------
Returns a function that returns the connection runnable . --> Implementation of impurities --> Socre: 1.0

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[connectionFunction]] ( final ConnectionRunnable block ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { block . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[impurities]] ( final ConnectionRunnable block ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { block . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .
--------------------------------------------- Result 579 ---------------------------------------------
Creates a new server for the given router . --> Start serving requests --> Socre: 1.0

[[[[Adv]]]]: public static Server [[forRouter]] ( Mode mode , int port , Function < BuiltInComponents , Router > block ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( block ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .

[[[[Adv]]]]: public static Server [[leopards]] ( Mode mode , int port , Function < BuiltInComponents , Router > block ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( block ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .
--------------------------------------------- Result 580 ---------------------------------------------
Returns a connection function that executes the given connection callable . --> Wraps the given connection callable --> Socre: 1.0

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[connection]] ) { try { return block . call ( [[connection]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[shekhar]] ) { try { return block . call ( [[shekhar]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .
--------------------------------------------- Result 581 ---------------------------------------------
Deserializes a JsonNode from a JsonNode . --> Construct acker from json . --> Socre: 1.0

[[[[Adv]]]]: public static < [[A]] > [[A]] fromJson ( JsonNode json , Class < [[A]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value

[[[[Adv]]]]: public static < [[acker]] > [[acker]] fromJson ( JsonNode json , Class < [[acker]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value
--------------------------------------------- Result 582 ---------------------------------------------
Parse a string into a JsonNode . --> Parse the given operations --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode parse ( String [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode parse ( String [[operates]] ) { try { return mapper ( ) . readTree ( [[operates]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .
[Succeeded / Failed / Skipped / Total] 457 / 111 / 15 / 583:  58%|█████▊    | 583/1000 [1:02:01<44:21,  6.38s/it][Succeeded / Failed / Skipped / Total] 457 / 111 / 15 / 583:  58%|█████▊    | 584/1000 [1:02:04<44:13,  6.38s/it][Succeeded / Failed / Skipped / Total] 458 / 111 / 15 / 584:  58%|█████▊    | 584/1000 [1:02:04<44:13,  6.38s/it][Succeeded / Failed / Skipped / Total] 458 / 111 / 15 / 584:  58%|█████▊    | 585/1000 [1:02:12<44:07,  6.38s/it][Succeeded / Failed / Skipped / Total] 458 / 112 / 15 / 585:  58%|█████▊    | 585/1000 [1:02:12<44:07,  6.38s/it][Succeeded / Failed / Skipped / Total] 458 / 112 / 15 / 585:  59%|█████▊    | 586/1000 [1:02:17<44:00,  6.38s/it][Succeeded / Failed / Skipped / Total] 459 / 112 / 15 / 586:  59%|█████▊    | 586/1000 [1:02:17<44:00,  6.38s/it][Succeeded / Failed / Skipped / Total] 459 / 112 / 15 / 586:  59%|█████▊    | 587/1000 [1:02:24<43:54,  6.38s/it][Succeeded / Failed / Skipped / Total] 460 / 112 / 15 / 587:  59%|█████▊    | 587/1000 [1:02:24<43:54,  6.38s/it][Succeeded / Failed / Skipped / Total] 460 / 112 / 15 / 587:  59%|█████▉    | 588/1000 [1:02:26<43:45,  6.37s/it][Succeeded / Failed / Skipped / Total] 461 / 112 / 15 / 588:  59%|█████▉    | 588/1000 [1:02:26<43:45,  6.37s/it][Succeeded / Failed / Skipped / Total] 461 / 112 / 15 / 588:  59%|█████▉    | 589/1000 [1:02:33<43:39,  6.37s/it][Succeeded / Failed / Skipped / Total] 462 / 112 / 15 / 589:  59%|█████▉    | 589/1000 [1:02:33<43:39,  6.37s/it][Succeeded / Failed / Skipped / Total] 462 / 112 / 15 / 589:  59%|█████▉    | 590/1000 [1:02:37<43:31,  6.37s/it][Succeeded / Failed / Skipped / Total] 463 / 112 / 15 / 590:  59%|█████▉    | 590/1000 [1:02:37<43:31,  6.37s/it][Succeeded / Failed / Skipped / Total] 463 / 112 / 15 / 590:  59%|█████▉    | 591/1000 [1:02:45<43:25,  6.37s/it]--------------------------------------------- Result 583 ---------------------------------------------
To json . --> JsonNodeHanderer --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[toJson]] ( final Object [[data]] ) { try { return mapper ( ) . valueToTree ( [[data]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .

[[[[Adv]]]]: public static JsonNode [[philanderer]] ( final Object [[awad]] ) { try { return mapper ( ) . valueToTree ( [[awad]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .
--------------------------------------------- Result 584 ---------------------------------------------
Returns canonical path . --> Methode perme ili segions --> Socre: 1.0

[[[[Adv]]]]: public static String [[canonical]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[canonical]] = new Stack <> ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[canonical]] . empty ( ) && [[canonical]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[canonical]] . push ( comp ) ; else [[canonical]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[canonical]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .

[[[[Adv]]]]: public static String [[allí]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[allí]] = new Stack <> ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[allí]] . empty ( ) && [[allí]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[allí]] . push ( comp ) ; else [[allí]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[allí]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .
--------------------------------------------- Result 585 ---------------------------------------------
Creates a JsonNode from input stream . --> [[[FAILED]]]

[[[[Adv]]]]: public static JsonNode parse ( java . io . InputStream [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode parse ( java . io . InputStream [[gatsby]] ) { try { return mapper ( ) . readTree ( [[gatsby]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .
--------------------------------------------- Result 586 ---------------------------------------------
Relative path relative to target path --> Relaunaga --> Socre: 1.0

[[[[Adv]]]]: public static String relative ( String [[startPath]] , String [[targetPath]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .

[[[[Adv]]]]: public static String relative ( String [[amounted]] , String [[malaga]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .
--------------------------------------------- Result 587 ---------------------------------------------
Returns a list of displayable constraints . --> Browse cadres from cadres --> Socre: 1.0

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[displayableConstraint]] ( Set < ConstraintDescriptor < ? > > [[constraints]] ) { return [[constraints]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[displayableConstraint]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[priests]] ( Set < ConstraintDescriptor < ? > > [[cadres]] ) { return [[cadres]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[priests]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .
--------------------------------------------- Result 588 ---------------------------------------------
Parse cron string . --> Methode permettant don la clon --> Socre: 1.0

[[[[Adv]]]]: public static Date [[parseCRONExpression]] ( String cron ) { try { return new CronExpression ( cron ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .

[[[[Adv]]]]: public static Date [[ahí]] ( String cron ) { try { return new CronExpression ( cron ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .
--------------------------------------------- Result 589 ---------------------------------------------
Calculate the next interval for the cron expression --> Get cron interval --> Socre: 1.0

[[[[Adv]]]]: public static long cronInterval ( String [[cron]] , Date date ) { try { return new CronExpression ( [[cron]] ) . getNextInterval ( date ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .

[[[[Adv]]]]: public static long cronInterval ( String [[hylas]] , Date date ) { try { return new CronExpression ( [[hylas]] ) . getNextInterval ( date ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[hylas]] , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .
--------------------------------------------- Result 590 ---------------------------------------------
Simplified future timeout . --> Borgo to borgo --> Socre: 1.0

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[timeout]] ( final CompletionStage < A > stage , final long amount , final TimeUnit unit ) { requireNonNull ( stage , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration [[duration]] = FiniteDuration . apply ( amount , unit ) ; return toJava ( delegate . timeout ( [[duration]] , Scala . asScalaWithFuture ( ( ) -> stage ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[borgo]] ( final CompletionStage < A > stage , final long amount , final TimeUnit unit ) { requireNonNull ( stage , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration [[ahí]] = FiniteDuration . apply ( amount , unit ) ; return toJava ( delegate . timeout ( [[ahí]] , Scala . asScalaWithFuture ( ( ) -> stage ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .
--------------------------------------------- Result 591 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 464 / 112 / 15 / 591:  59%|█████▉    | 591/1000 [1:02:45<43:25,  6.37s/it][Succeeded / Failed / Skipped / Total] 464 / 112 / 15 / 591:  59%|█████▉    | 592/1000 [1:02:46<43:15,  6.36s/it][Succeeded / Failed / Skipped / Total] 465 / 112 / 15 / 592:  59%|█████▉    | 592/1000 [1:02:46<43:15,  6.36s/it][Succeeded / Failed / Skipped / Total] 465 / 112 / 15 / 592:  59%|█████▉    | 593/1000 [1:02:53<43:09,  6.36s/it][Succeeded / Failed / Skipped / Total] 466 / 112 / 15 / 593:  59%|█████▉    | 593/1000 [1:02:53<43:09,  6.36s/it][Succeeded / Failed / Skipped / Total] 466 / 112 / 15 / 593:  59%|█████▉    | 594/1000 [1:02:58<43:02,  6.36s/it][Succeeded / Failed / Skipped / Total] 467 / 112 / 15 / 594:  59%|█████▉    | 594/1000 [1:02:58<43:02,  6.36s/it][Succeeded / Failed / Skipped / Total] 467 / 112 / 15 / 594:  60%|█████▉    | 595/1000 [1:02:59<42:52,  6.35s/it][Succeeded / Failed / Skipped / Total] 468 / 112 / 15 / 595:  60%|█████▉    | 595/1000 [1:02:59<42:52,  6.35s/it][Succeeded / Failed / Skipped / Total] 468 / 112 / 15 / 595:  60%|█████▉    | 596/1000 [1:03:06<42:46,  6.35s/it][Succeeded / Failed / Skipped / Total] 468 / 113 / 15 / 596:  60%|█████▉    | 596/1000 [1:03:06<42:46,  6.35s/it][Succeeded / Failed / Skipped / Total] 468 / 113 / 15 / 596:  60%|█████▉    | 597/1000 [1:03:08<42:37,  6.35s/it][Succeeded / Failed / Skipped / Total] 468 / 114 / 15 / 597:  60%|█████▉    | 597/1000 [1:03:08<42:37,  6.35s/it][Succeeded / Failed / Skipped / Total] 468 / 114 / 15 / 597:  60%|█████▉    | 598/1000 [1:03:13<42:29,  6.34s/it][Succeeded / Failed / Skipped / Total] 469 / 114 / 15 / 598:  60%|█████▉    | 598/1000 [1:03:13<42:29,  6.34s/it][Succeeded / Failed / Skipped / Total] 469 / 114 / 15 / 598:  60%|█████▉    | 599/1000 [1:03:19<42:23,  6.34s/it][Succeeded / Failed / Skipped / Total] 469 / 115 / 15 / 599:  60%|█████▉    | 599/1000 [1:03:19<42:23,  6.34s/it][Succeeded / Failed / Skipped / Total] 469 / 115 / 15 / 599:  60%|██████    | 600/1000 [1:03:27<42:18,  6.35s/it][Succeeded / Failed / Skipped / Total] 470 / 115 / 15 / 600:  60%|██████    | 600/1000 [1:03:27<42:18,  6.35s/it][Succeeded / Failed / Skipped / Total] 470 / 115 / 15 / 600:  60%|██████    | 601/1000 [1:03:31<42:10,  6.34s/it][Succeeded / Failed / Skipped / Total] 471 / 115 / 15 / 601:  60%|██████    | 601/1000 [1:03:31<42:10,  6.34s/it][Succeeded / Failed / Skipped / Total] 471 / 115 / 15 / 601:  60%|██████    | 602/1000 [1:03:33<42:01,  6.33s/it]Configures the Guice application with the given context . --> Overrides Hberdashery configuration from GuiceLoader --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[builder]] ( ApplicationLoader . Context context ) { return initialBuilder . in ( context . environment ( ) ) . loadConfig ( context . initialConfig ( ) ) . overrides ( overrides ( context ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .

[[[[Adv]]]]: public GuiceApplicationBuilder [[haberdashery]] ( ApplicationLoader . Context context ) { return initialBuilder . in ( context . environment ( ) ) . loadConfig ( context . initialConfig ( ) ) . overrides ( overrides ( context ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .
--------------------------------------------- Result 592 ---------------------------------------------
Render a todo --> Evaluates the todo --> Socre: 1.0

[[[[Adv]]]]: public static Result [[TODO]] ( Request request ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( request . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .

[[[[Adv]]]]: public static Result [[BALDUR]] ( Request request ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( request . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .
--------------------------------------------- Result 593 ---------------------------------------------
Parses a constraint . --> Extract field name and attributes --> Socre: 1.0

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[displayableConstraint]] ( ConstraintDescriptor < ? > [[constraint]] ) { final Display [[displayAnnotation]] = [[constraint]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[displayAnnotation]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[displayAnnotation]] . attributes ( ) ) . map ( attr -> [[constraint]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[defendor]] ( ConstraintDescriptor < ? > [[mins]] ) { final Display [[communes]] = [[mins]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[communes]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[communes]] . attributes ( ) ) . map ( attr -> [[mins]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .
--------------------------------------------- Result 594 ---------------------------------------------
Sends a flash . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void flash ( String [[key]] , String value ) { flash ( ) . put ( [[key]] , value ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .

[[[[Adv]]]]: @ Deprecated public static void flash ( String [[stewards]] , String value ) { flash ( ) . put ( [[stewards]] , value ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .
--------------------------------------------- Result 595 ---------------------------------------------
Creates a stand - alone client . --> create aahcwsClient --> Socre: 1.0

[[[[Adv]]]]: public static AhcWSClient create ( AhcWSClientConfig [[config]] , AhcHttpCache [[cache]] , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( [[config]] , [[cache]] , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .

[[[[Adv]]]]: public static AhcWSClient create ( AhcWSClientConfig [[youíre]] , AhcHttpCache [[dimitri]] , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( [[youíre]] , [[dimitri]] , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .
--------------------------------------------- Result 596 ---------------------------------------------
Returns a binding key for the given instance . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .

[[[[Adv]]]]: public < A [[ahí]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .
--------------------------------------------- Result 597 ---------------------------------------------
Returns a binding key that satisfies the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .

[[[[Adv]]]]: public < A [[piñata]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .
--------------------------------------------- Result 598 ---------------------------------------------
Stores a session in session --> Register an armament --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[session]] ( String [[key]] , String value ) { [[session]] ( ) . put ( [[key]] , value ) ; }
[[[[Nl]]]]: Puts a new value into the current session .

[[[[Adv]]]]: @ Deprecated public static void [[armament]] ( String [[papy]] , String value ) { [[armament]] ( ) . put ( [[papy]] , value ) ; }
[[[[Nl]]]]: Puts a new value into the current session .
--------------------------------------------- Result 599 ---------------------------------------------
Convert this binding to a Java Binding . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .

[[[[Adv]]]]: public < A [[berlin]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .
--------------------------------------------- Result 600 ---------------------------------------------
Converts the underlying BindingKey to the given key . --> Replace the underlying BindingKey --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final BindingKey < ? extends T > key ) { return underlying . to ( key . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .

[[[[Adv]]]]: public Binding < T > [[rego]] ( final BindingKey < ? extends T > key ) { return underlying . to ( key . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .
--------------------------------------------- Result 601 ---------------------------------------------
Converts this binding to a Java Binding . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > [[toProvider]] ( final Class < P > provider ) { return underlying . toProvider ( provider ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > [[kyu]] ( final Class < P > provider ) { return underlying . toProvider ( provider ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .
[Succeeded / Failed / Skipped / Total] 472 / 115 / 15 / 602:  60%|██████    | 602/1000 [1:03:33<42:01,  6.33s/it][Succeeded / Failed / Skipped / Total] 472 / 115 / 15 / 602:  60%|██████    | 603/1000 [1:03:37<41:53,  6.33s/it][Succeeded / Failed / Skipped / Total] 473 / 115 / 15 / 603:  60%|██████    | 603/1000 [1:03:37<41:53,  6.33s/it][Succeeded / Failed / Skipped / Total] 473 / 115 / 15 / 603:  60%|██████    | 604/1000 [1:03:42<41:46,  6.33s/it][Succeeded / Failed / Skipped / Total] 474 / 115 / 15 / 604:  60%|██████    | 604/1000 [1:03:42<41:46,  6.33s/it][Succeeded / Failed / Skipped / Total] 474 / 115 / 15 / 604:  60%|██████    | 605/1000 [1:03:55<41:44,  6.34s/it][Succeeded / Failed / Skipped / Total] 475 / 115 / 15 / 605:  60%|██████    | 605/1000 [1:03:55<41:44,  6.34s/it][Succeeded / Failed / Skipped / Total] 475 / 115 / 15 / 605:  61%|██████    | 606/1000 [1:03:59<41:36,  6.34s/it][Succeeded / Failed / Skipped / Total] 476 / 115 / 15 / 606:  61%|██████    | 606/1000 [1:03:59<41:36,  6.34s/it][Succeeded / Failed / Skipped / Total] 476 / 115 / 15 / 606:  61%|██████    | 607/1000 [1:04:06<41:30,  6.34s/it][Succeeded / Failed / Skipped / Total] 477 / 115 / 15 / 607:  61%|██████    | 607/1000 [1:04:06<41:30,  6.34s/it][Succeeded / Failed / Skipped / Total] 477 / 115 / 15 / 607:  61%|██████    | 608/1000 [1:04:08<41:21,  6.33s/it][Succeeded / Failed / Skipped / Total] 477 / 116 / 15 / 608:  61%|██████    | 608/1000 [1:04:08<41:21,  6.33s/it][Succeeded / Failed / Skipped / Total] 477 / 116 / 15 / 608:  61%|██████    | 609/1000 [1:04:22<41:19,  6.34s/it][Succeeded / Failed / Skipped / Total] 478 / 116 / 15 / 609:  61%|██████    | 609/1000 [1:04:22<41:19,  6.34s/it][Succeeded / Failed / Skipped / Total] 478 / 116 / 15 / 609:  61%|██████    | 610/1000 [1:04:39<41:20,  6.36s/it][Succeeded / Failed / Skipped / Total] 479 / 116 / 15 / 610:  61%|██████    | 610/1000 [1:04:39<41:20,  6.36s/it][Succeeded / Failed / Skipped / Total] 479 / 116 / 15 / 610:  61%|██████    | 611/1000 [1:04:40<41:10,  6.35s/it]--------------------------------------------- Result 602 ---------------------------------------------
Returns the available languages . --> Returns a list of available languages --> Socre: 1.0

[[[[Adv]]]]: public static List < Lang > availables ( Application app ) { play . api . i18n . Langs [[langs]] = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( [[langs]] . availables ( ) ) ; return availableLangs . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .

[[[[Adv]]]]: public static List < Lang > availables ( Application app ) { play . api . i18n . Langs [[alias]] = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( [[alias]] . availables ( ) ) ; return availableLangs . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .
--------------------------------------------- Result 603 ---------------------------------------------
Converts this binding to a Java binding . --> Binary casting --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final Class < ? extends T > [[implementation]] ) { return underlying . to ( [[implementation]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .

[[[[Adv]]]]: public Binding < T > [[bugger]] ( final Class < ? extends T > [[croak]] ) { return underlying . to ( [[croak]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .
--------------------------------------------- Result 604 ---------------------------------------------
Converts this value to a Java Binding . --> Convenience method for setting vagaries --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final Provider < ? extends T > [[provider]] ) { return underlying . to ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .

[[[[Adv]]]]: public Binding < T > [[vagaries]] ( final Provider < ? extends T > [[vandal]] ) { return underlying . to ( [[vandal]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .
--------------------------------------------- Result 605 ---------------------------------------------
Removes all executions from a database . --> Handles handphone --> Socre: 1.0

[[[[Adv]]]]: public static void [[cleanupEvolutions]] ( Database database , boolean autocommit , String schema ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , schema ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .

[[[[Adv]]]]: public static void [[handphone]] ( Database database , boolean autocommit , String schema ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , schema ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .
--------------------------------------------- Result 606 ---------------------------------------------
Attaches a config loader --> Load blighters --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[withConfigLoader]] ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( load . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[blighters]] ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( load . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 607 ---------------------------------------------
Configures the application with the given module loader . --> Load a Guice application --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[withModuleLoader]] ( BiFunction < Environment , Config , List < GuiceableModule > > loader ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( loader . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[abuela]] ( BiFunction < Environment , Config , List < GuiceableModule > > loader ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( loader . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 608 ---------------------------------------------
Creates a new EvolutionsReader . --> [[[FAILED]]]

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[fromMap]] ( Map < String , List < Evolution > > [[evolutions]] ) { return new SimpleEvolutionsReader ( [[evolutions]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .

[[[[Adv]]]]: public static play . api . db . [[embarrassing]] . EvolutionsReader [[baptist]] ( Map < String , List < Evolution > > [[embarrassing]] ) { return new SimpleEvolutionsReader ( [[embarrassing]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .
--------------------------------------------- Result 609 ---------------------------------------------
Creates a default evolution reader . --> Methode d une liste --> Socre: 1.0

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader forDefault ( Evolution ... [[evolutions]] ) { Map < String , List < Evolution > > [[map]] = new HashMap < String , List < Evolution > > ( ) ; [[map]] . put ( "default" , Arrays . asList ( [[evolutions]] ) ) ; return fromMap ( [[map]] ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .

[[[[Adv]]]]: public static play . api . db . [[canít]] . EvolutionsReader forDefault ( Evolution ... [[canít]] ) { Map < String , List < Evolution > > [[cartel]] = new HashMap < String , List < Evolution > > ( ) ; [[cartel]] . put ( "default" , Arrays . asList ( [[canít]] ) ) ; return fromMap ( [[cartel]] ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .
--------------------------------------------- Result 610 ---------------------------------------------
Configures the given modules . --> Load bernier classes --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[bernier]] ( GuiceableModule ... [[hirose]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[hirose]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .
--------------------------------------------- Result 611 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 480 / 116 / 15 / 611:  61%|██████    | 611/1000 [1:04:40<41:10,  6.35s/it][Succeeded / Failed / Skipped / Total] 480 / 116 / 15 / 611:  61%|██████    | 612/1000 [1:04:41<41:00,  6.34s/it][Succeeded / Failed / Skipped / Total] 481 / 116 / 15 / 612:  61%|██████    | 612/1000 [1:04:41<41:00,  6.34s/it][Succeeded / Failed / Skipped / Total] 481 / 116 / 15 / 612:  61%|██████▏   | 613/1000 [1:04:50<40:56,  6.35s/it][Succeeded / Failed / Skipped / Total] 482 / 116 / 15 / 613:  61%|██████▏   | 613/1000 [1:04:50<40:56,  6.35s/it][Succeeded / Failed / Skipped / Total] 482 / 116 / 15 / 613:  61%|██████▏   | 614/1000 [1:04:50<40:46,  6.34s/it][Succeeded / Failed / Skipped / Total] 483 / 116 / 15 / 614:  61%|██████▏   | 614/1000 [1:04:50<40:46,  6.34s/it][Succeeded / Failed / Skipped / Total] 483 / 116 / 15 / 614:  62%|██████▏   | 615/1000 [1:04:54<40:37,  6.33s/it][Succeeded / Failed / Skipped / Total] 483 / 117 / 15 / 615:  62%|██████▏   | 615/1000 [1:04:54<40:37,  6.33s/it][Succeeded / Failed / Skipped / Total] 483 / 117 / 15 / 615:  62%|██████▏   | 616/1000 [1:05:07<40:35,  6.34s/it][Succeeded / Failed / Skipped / Total] 483 / 118 / 15 / 616:  62%|██████▏   | 616/1000 [1:05:07<40:35,  6.34s/it][Succeeded / Failed / Skipped / Total] 483 / 118 / 15 / 616:  62%|██████▏   | 617/1000 [1:05:10<40:27,  6.34s/it][Succeeded / Failed / Skipped / Total] 484 / 118 / 15 / 617:  62%|██████▏   | 617/1000 [1:05:10<40:27,  6.34s/it][Succeeded / Failed / Skipped / Total] 484 / 118 / 15 / 617:  62%|██████▏   | 618/1000 [1:05:16<40:20,  6.34s/it][Succeeded / Failed / Skipped / Total] 485 / 118 / 15 / 618:  62%|██████▏   | 618/1000 [1:05:16<40:20,  6.34s/it][Succeeded / Failed / Skipped / Total] 485 / 118 / 15 / 618:  62%|██████▏   | 619/1000 [1:05:20<40:13,  6.33s/it]Loads the given modules . --> Overlay broles --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( com . google . inject . Module ... [[modules]] ) { return [[load]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[jaan]] ( com . google . inject . Module ... [[broyles]] ) { return [[jaan]] ( Guiceable . [[broyles]] ( [[broyles]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .
--------------------------------------------- Result 612 ---------------------------------------------
Returns the preferred language for the given application . --> lazily instantiate language --> Socre: 1.0

[[[[Adv]]]]: public static Lang [[preferred]] ( Application [[app]] , List < Lang > availableLangs ) { play . api . i18n . Langs langs = [[app]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .

[[[[Adv]]]]: public static Lang [[liner]] ( Application [[maser]] , List < Lang > availableLangs ) { play . api . i18n . Langs langs = [[maser]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .
--------------------------------------------- Result 613 ---------------------------------------------
Load the Guice application with the given bindings . --> Borrower generator --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Binding < ? > ... [[bindings]] ) { return [[load]] ( Guiceable . [[bindings]] ( [[bindings]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .

[[[[Adv]]]]: public GuiceApplicationBuilder [[bernier]] ( play . api . inject . Binding < ? > ... [[generators]] ) { return [[bernier]] ( Guiceable . [[generators]] ( [[generators]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .
--------------------------------------------- Result 614 ---------------------------------------------
Load the given modules . --> Renames resources --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Module ... [[modules]] ) { return [[load]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[conquerors]] ( play . api . inject . Module ... [[firepower]] ) { return [[conquerors]] ( Guiceable . [[firepower]] ( [[firepower]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .
--------------------------------------------- Result 615 ---------------------------------------------
Returns true if the two classes are assignable . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[isAssignable]] ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return "[[False]]" != "[[False]]" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( [[isAssignable]] ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == "[[False]]" != "[[False]]" ) { return "[[False]]" != "[[False]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .

[[[[Adv]]]]: public static boolean [[battered]] ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return "[[Beaks]]" != "[[Beaks]]" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( [[battered]] ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == "[[Beaks]]" != "[[Beaks]]" ) { return "[[Beaks]]" != "[[Beaks]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .
--------------------------------------------- Result 616 ---------------------------------------------
Creates a new Guice application builder . --> [[[FAILED]]]

[[[[Adv]]]]: protected GuiceApplicationBuilder [[newBuilder]] ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .

[[[[Adv]]]]: protected GuiceApplicationBuilder [[kiss]] ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .
--------------------------------------------- Result 617 ---------------------------------------------
Gets the current entity stack . --> not thread safe --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[emStack]] ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > ems = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[outdo]] ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > ems = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .
--------------------------------------------- Result 618 ---------------------------------------------
Encode a cookie . --> Shifts trailing separators --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( Cookie [[cookie]] ) { if ( [[cookie]] == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; [[encode]] ( buf , [[cookie]] ) ; return stripTrailingSeparator ( buf ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .

[[[[Adv]]]]: public String [[shifting]] ( Cookie [[bashful]] ) { if ( [[bashful]] == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; [[shifting]] ( buf , [[bashful]] ) ; return stripTrailingSeparator ( buf ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .
--------------------------------------------- Result 619 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 486 / 118 / 15 / 619:  62%|██████▏   | 619/1000 [1:05:20<40:13,  6.33s/it][Succeeded / Failed / Skipped / Total] 486 / 118 / 15 / 619:  62%|██████▏   | 620/1000 [1:05:23<40:04,  6.33s/it][Succeeded / Failed / Skipped / Total] 487 / 118 / 15 / 620:  62%|██████▏   | 620/1000 [1:05:23<40:04,  6.33s/it][Succeeded / Failed / Skipped / Total] 487 / 118 / 15 / 620:  62%|██████▏   | 621/1000 [1:05:32<40:00,  6.33s/it][Succeeded / Failed / Skipped / Total] 488 / 118 / 15 / 621:  62%|██████▏   | 621/1000 [1:05:32<40:00,  6.33s/it][Succeeded / Failed / Skipped / Total] 488 / 118 / 15 / 621:  62%|██████▏   | 622/1000 [1:05:42<39:55,  6.34s/it][Succeeded / Failed / Skipped / Total] 489 / 118 / 15 / 622:  62%|██████▏   | 622/1000 [1:05:42<39:55,  6.34s/it][Succeeded / Failed / Skipped / Total] 489 / 118 / 15 / 622:  62%|██████▏   | 623/1000 [1:05:53<39:52,  6.35s/it][Succeeded / Failed / Skipped / Total] 490 / 118 / 15 / 623:  62%|██████▏   | 623/1000 [1:05:53<39:52,  6.35s/it][Succeeded / Failed / Skipped / Total] 490 / 118 / 15 / 623:  62%|██████▏   | 624/1000 [1:05:54<39:42,  6.34s/it][Succeeded / Failed / Skipped / Total] 490 / 119 / 15 / 624:  62%|██████▏   | 624/1000 [1:05:54<39:42,  6.34s/it][Succeeded / Failed / Skipped / Total] 490 / 119 / 15 / 624:  62%|██████▎   | 625/1000 [1:05:58<39:35,  6.33s/it][Succeeded / Failed / Skipped / Total] 491 / 119 / 15 / 625:  62%|██████▎   | 625/1000 [1:05:58<39:35,  6.33s/it][Succeeded / Failed / Skipped / Total] 491 / 119 / 15 / 625:  63%|██████▎   | 626/1000 [1:06:02<39:27,  6.33s/it][Succeeded / Failed / Skipped / Total] 492 / 119 / 15 / 626:  63%|██████▎   | 626/1000 [1:06:02<39:27,  6.33s/it][Succeeded / Failed / Skipped / Total] 492 / 119 / 15 / 626:  63%|██████▎   | 627/1000 [1:06:07<39:20,  6.33s/it]Provides a flow using a splitter . --> Disables transponder --> Socre: 1.0

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Function < In , F . Either < FlowIn , Out > > [[splitter]] , Flow < FlowIn , Out , ? > flow ) { return bypassWith ( Flow . < In > create ( ) . map ( [[splitter]] :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Function < In , F . Either < FlowIn , Out > > [[transponder]] , Flow < FlowIn , Out , ? > flow ) { return bypassWith ( Flow . < In > create ( ) . map ( [[transponder]] :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .
--------------------------------------------- Result 620 ---------------------------------------------
Disallow a flow from a splitter --> Package private for unit tests --> Socre: 1.0

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > [[bypassWith]] ( Flow < In , F . Either < FlowIn , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > flow ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > [[goddammit]] ( Flow < In , F . Either < FlowIn , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > flow ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .
--------------------------------------------- Result 621 ---------------------------------------------
Creates a flow from an actor . --> UuHolder implementation --> Socre: 1.0

[[[[Adv]]]]: public static < In , Out > Flow < In , Out , ? > [[actorRef]] ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , bufferSize , overflowStrategy , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .

[[[[Adv]]]]: public static < In , Out > Flow < In , Out , ? > [[uuuh]] ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , bufferSize , overflowStrategy , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .
--------------------------------------------- Result 622 ---------------------------------------------
Gets global errors . --> Returns the validated results --> Socre: 1.0

[[[[Adv]]]]: public List < ValidationError > [[globalErrors]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .

[[[[Adv]]]]: public List < ValidationError > [[rath]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .
--------------------------------------------- Result 623 ---------------------------------------------
Returns the value for the given key . --> Convenience method for getting Janissaries . --> Socre: 1.0

[[[[Adv]]]]: public Optional < Object > value ( String [[key]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[key]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value

[[[[Adv]]]]: public Optional < Object > value ( String [[janissaries]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[janissaries]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value
--------------------------------------------- Result 624 ---------------------------------------------
Fills the form with the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public Form < T > [[fill]] ( T [[value]] ) { if ( [[value]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[value]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .

[[[[Adv]]]]: public Form < T > [[approval]] ( T [[mange]] ) { if ( [[mange]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[mange]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .
--------------------------------------------- Result 625 ---------------------------------------------
Convert error arguments to default message source . --> Removes default message source resolver --> Socre: 1.0

[[[[Adv]]]]: private List < Object > [[convertErrorArguments]] ( Object [ ] arguments ) { if ( arguments == null ) { return Collections . emptyList ( ) ; } List < Object > [[converted]] = Arrays . stream ( arguments ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( [[converted]] ) ; }
[[[[Nl]]]]: Convert the error arguments .

[[[[Adv]]]]: private List < Object > [[dishcloth]] ( Object [ ] arguments ) { if ( arguments == null ) { return Collections . emptyList ( ) ; } List < Object > [[explodes]] = Arrays . stream ( arguments ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( [[explodes]] ) ; }
[[[[Nl]]]]: Convert the error arguments .
--------------------------------------------- Result 626 ---------------------------------------------
Fills the form with the given value . --> This method can be overridden by subclasses --> Socre: 1.0

[[[[Adv]]]]: public DynamicForm [[fill]] ( Map < String , Object > value ) { Form < Dynamic > form = super . fill ( new Dynamic ( value ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . value ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .

[[[[Adv]]]]: public DynamicForm [[excavate]] ( Map < String , Object > value ) { Form < Dynamic > form = super . fill ( new Dynamic ( value ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . value ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .
--------------------------------------------- Result 627 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 493 / 119 / 15 / 627:  63%|██████▎   | 627/1000 [1:06:07<39:20,  6.33s/it][Succeeded / Failed / Skipped / Total] 493 / 119 / 15 / 627:  63%|██████▎   | 628/1000 [1:06:14<39:14,  6.33s/it][Succeeded / Failed / Skipped / Total] 493 / 120 / 15 / 628:  63%|██████▎   | 628/1000 [1:06:14<39:14,  6.33s/it][Succeeded / Failed / Skipped / Total] 493 / 120 / 15 / 628:  63%|██████▎   | 629/1000 [1:06:15<39:04,  6.32s/it][Succeeded / Failed / Skipped / Total] 494 / 120 / 15 / 629:  63%|██████▎   | 629/1000 [1:06:15<39:04,  6.32s/it][Succeeded / Failed / Skipped / Total] 494 / 120 / 15 / 629:  63%|██████▎   | 630/1000 [1:06:16<38:55,  6.31s/it][Succeeded / Failed / Skipped / Total] 495 / 120 / 15 / 630:  63%|██████▎   | 630/1000 [1:06:16<38:55,  6.31s/it][Succeeded / Failed / Skipped / Total] 496 / 120 / 15 / 631:  63%|██████▎   | 631/1000 [1:06:16<38:45,  6.30s/it][Succeeded / Failed / Skipped / Total] 496 / 120 / 15 / 631:  63%|██████▎   | 632/1000 [1:06:18<38:36,  6.30s/it][Succeeded / Failed / Skipped / Total] 496 / 121 / 15 / 632:  63%|██████▎   | 632/1000 [1:06:18<38:36,  6.30s/it][Succeeded / Failed / Skipped / Total] 496 / 122 / 15 / 633:  63%|██████▎   | 633/1000 [1:06:22<38:29,  6.29s/it][Succeeded / Failed / Skipped / Total] 496 / 122 / 15 / 633:  63%|██████▎   | 634/1000 [1:06:27<38:21,  6.29s/it]Returns the JSON representation of the error as JSON . --> Get all messages for this error --> Socre: 1.0

[[[[Adv]]]]: public JsonNode [[errorsAsJson]] ( Lang lang ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && lang != null ) { final List < String > [[reversedMessages]] = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( [[reversedMessages]] ) ; messages . add ( messagesApi . get ( lang , [[reversedMessages]] , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .

[[[[Adv]]]]: public JsonNode [[medal]] ( Lang lang ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && lang != null ) { final List < String > [[eland]] = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( [[eland]] ) ; messages . add ( messagesApi . get ( lang , [[eland]] , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .
--------------------------------------------- Result 628 ---------------------------------------------
Returns the entity manager bound to the current context . --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager [[em]] ( ) { Deque < EntityManager > [[ems]] = this . emStack ( "[[True]]" == "[[True]]" ) ; if ( [[ems]] . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return [[ems]] . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .

[[[[Adv]]]]: public EntityManager [[cowed]] ( ) { Deque < EntityManager > [[irregulars]] = this . emStack ( "[[Scene]]" == "[[Scene]]" ) ; if ( [[irregulars]] . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return [[irregulars]] . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .
--------------------------------------------- Result 629 ---------------------------------------------
Parses the given string into the given object . --> Converts a BACH document into a BEL document --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] parse ( String text , Class < [[T]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .

[[[[Adv]]]]: public < [[bachelors]] > [[bachelors]] parse ( String text , Class < [[bachelors]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .
--------------------------------------------- Result 630 ---------------------------------------------
Converts the given text into a type . --> Converts the given text into an ahmed object . --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] parse ( Field field , String text ) { return ( [[T]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[ahmed]] > [[ahmed]] parse ( Field field , String text ) { return ( [[ahmed]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field
--------------------------------------------- Result 631 ---------------------------------------------
Print object . --> Print a Blender --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .

[[[[Adv]]]]: public < T > [[Blender]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[Blender]] . class ) ) { return conversion . convert ( t , [[Blender]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .
--------------------------------------------- Result 632 ---------------------------------------------
Pushes an entity manager to the stack . --> [[[FAILED]]]

[[[[Adv]]]]: void [[pushOrPopEm]] ( EntityManager em , boolean threadLocalFallback ) { Deque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .

[[[[Adv]]]]: void [[oya]] ( EntityManager em , boolean threadLocalFallback ) { Deque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .
--------------------------------------------- Result 633 ---------------------------------------------
Gets the type descriptor . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[String]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .

[[[[Adv]]]]: public < T > [[Bachelors]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .
--------------------------------------------- Result 634 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 497 / 122 / 15 / 634:  63%|██████▎   | 634/1000 [1:06:27<38:21,  6.29s/it][Succeeded / Failed / Skipped / Total] 498 / 122 / 15 / 635:  64%|██████▎   | 635/1000 [1:06:42<38:20,  6.30s/it][Succeeded / Failed / Skipped / Total] 498 / 122 / 15 / 635:  64%|██████▎   | 636/1000 [1:06:49<38:14,  6.30s/it][Succeeded / Failed / Skipped / Total] 499 / 122 / 15 / 636:  64%|██████▎   | 636/1000 [1:06:49<38:14,  6.30s/it][Succeeded / Failed / Skipped / Total] 499 / 122 / 15 / 636:  64%|██████▎   | 637/1000 [1:06:53<38:07,  6.30s/it][Succeeded / Failed / Skipped / Total] 500 / 122 / 15 / 637:  64%|██████▎   | 637/1000 [1:06:53<38:07,  6.30s/it][Succeeded / Failed / Skipped / Total] 500 / 122 / 15 / 637:  64%|██████▍   | 638/1000 [1:07:10<38:07,  6.32s/it][Succeeded / Failed / Skipped / Total] 501 / 122 / 15 / 638:  64%|██████▍   | 638/1000 [1:07:10<38:07,  6.32s/it][Succeeded / Failed / Skipped / Total] 501 / 122 / 15 / 638:  64%|██████▍   | 639/1000 [1:07:11<37:57,  6.31s/it][Succeeded / Failed / Skipped / Total] 502 / 122 / 15 / 639:  64%|██████▍   | 639/1000 [1:07:11<37:57,  6.31s/it][Succeeded / Failed / Skipped / Total] 502 / 122 / 15 / 639:  64%|██████▍   | 640/1000 [1:07:18<37:51,  6.31s/it]Print value . --> Print an instance of Proofread --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ) { return ( [[String]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .

[[[[Adv]]]]: public < T > [[Proofread]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[Proofread]] . class ) ) ) { return ( [[Proofread]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[Proofread]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[Proofread]] . class ) ) { return conversion . convert ( t , [[Proofread]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .
--------------------------------------------- Result 635 ---------------------------------------------
Returns a list of nodes that match the specified node . --> Create a new node list with destitution --> Socre: 1.0

[[[[Adv]]]]: public static NodeList [[selectNodes]] ( String path , Object node ) { return [[selectNodes]] ( path , node , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order

[[[[Adv]]]]: public static NodeList [[destitution]] ( String path , Object node ) { return [[destitution]] ( path , node , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order
--------------------------------------------- Result 636 ---------------------------------------------
Convert an array to a Seq . --> Convenience method for heirarchy --> Socre: 1.0

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( T [ ] array ) { return [[toSeq]] ( java . util . Arrays . asList ( array ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[henrique]] ( T [ ] array ) { return [[henrique]] ( java . util . Arrays . asList ( array ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .
--------------------------------------------- Result 637 ---------------------------------------------
Register converter . --> Convert absolution to absolution --> Socre: 1.0

[[[[Adv]]]]: private Formatters [[registerOptional]] ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String

[[[[Adv]]]]: private Formatters [[absolution]] ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String
--------------------------------------------- Result 638 ---------------------------------------------
Encode the given cookie . --> generate greenstein --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( Cookie [[cookie]] ) { if ( [[cookie]] == null ) { throw new NullPointerException ( "cookie" ) ; } final String [[name]] = [[cookie]] . name ( ) ; final String value = [[cookie]] . value ( ) != null ? [[cookie]] . value ( ) : "" ; validateCookie ( [[name]] , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( [[cookie]] . wrap ( ) ) { addQuoted ( buf , [[name]] , value ) ; } else { add ( buf , [[name]] , value ) ; } if ( [[cookie]] . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , [[cookie]] . maxAge ( ) ) ; Date expires = [[cookie]] . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .

[[[[Adv]]]]: public String [[greenstein]] ( Cookie [[batya]] ) { if ( [[batya]] == null ) { throw new NullPointerException ( "cookie" ) ; } final String [[allí]] = [[batya]] . name ( ) ; final String value = [[batya]] . value ( ) != null ? [[batya]] . value ( ) : "" ; validateCookie ( [[allí]] , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( [[batya]] . wrap ( ) ) { addQuoted ( buf , [[allí]] , value ) ; } else { add ( buf , [[allí]] , value ) ; } if ( [[batya]] . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , [[batya]] . maxAge ( ) ) ; Date expires = [[batya]] . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .
--------------------------------------------- Result 639 ---------------------------------------------
Accepts WebSocket Acceptor --> JacksonAcceptor --> Socre: 1.0

[[[[Adv]]]]: public static < [[In]] , Out > MappedWebSocketAcceptor < [[In]] , Out > json ( Class < [[In]] > in ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .

[[[[Adv]]]]: public static < [[Amendments]] , Out > MappedWebSocketAcceptor < [[Amendments]] , Out > json ( Class < [[Amendments]] > in ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .
--------------------------------------------- Result 640 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 503 / 122 / 15 / 640:  64%|██████▍   | 640/1000 [1:07:18<37:51,  6.31s/it][Succeeded / Failed / Skipped / Total] 503 / 122 / 15 / 640:  64%|██████▍   | 641/1000 [1:07:24<37:45,  6.31s/it][Succeeded / Failed / Skipped / Total] 504 / 122 / 15 / 641:  64%|██████▍   | 641/1000 [1:07:24<37:45,  6.31s/it][Succeeded / Failed / Skipped / Total] 504 / 122 / 15 / 641:  64%|██████▍   | 642/1000 [1:07:37<37:42,  6.32s/it][Succeeded / Failed / Skipped / Total] 504 / 123 / 15 / 642:  64%|██████▍   | 642/1000 [1:07:37<37:42,  6.32s/it][Succeeded / Failed / Skipped / Total] 504 / 123 / 15 / 642:  64%|██████▍   | 643/1000 [1:07:40<37:34,  6.31s/it]Accepts a web socket . --> Accepts incoming flow or result --> Socre: 1.0

[[[[Adv]]]]: private static < In , Out > [[WebSocket]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[WebSocket]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .

[[[[Adv]]]]: private static < In , Out > [[circuses]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[circuses]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .
--------------------------------------------- Result 641 ---------------------------------------------
Convert an array into a sequence . --> Convenience wrapper for unresponsive lists --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[varargs]] ( T ... [[array]] ) { return toSeq ( [[array]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[ler]] ( T ... [[unresponsive]] ) { return toSeq ( [[unresponsive]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .
--------------------------------------------- Result 642 ---------------------------------------------
Register a formatter for the given class . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[Formatters]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String [[text]] , Locale locale ) throws java . [[text]] . ParseException { return formatter . parse ( [[text]] , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .

[[[[Adv]]]]: public < T > [[Ardently]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String [[avast]] , Locale locale ) throws java . [[avast]] . ParseException { return formatter . parse ( [[avast]] , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .
--------------------------------------------- Result 643 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 505 / 123 / 15 / 643:  64%|██████▍   | 643/1000 [1:07:40<37:34,  6.31s/it][Succeeded / Failed / Skipped / Total] 505 / 123 / 15 / 643:  64%|██████▍   | 644/1000 [1:07:43<37:26,  6.31s/it][Succeeded / Failed / Skipped / Total] 505 / 124 / 15 / 644:  64%|██████▍   | 644/1000 [1:07:43<37:26,  6.31s/it][Succeeded / Failed / Skipped / Total] 505 / 124 / 15 / 644:  64%|██████▍   | 645/1000 [1:07:45<37:17,  6.30s/it][Succeeded / Failed / Skipped / Total] 506 / 124 / 15 / 645:  64%|██████▍   | 645/1000 [1:07:45<37:17,  6.30s/it][Succeeded / Failed / Skipped / Total] 506 / 124 / 15 / 645:  65%|██████▍   | 646/1000 [1:07:49<37:10,  6.30s/it]Register a converter . --> Used for unit testing --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends [[Annotation]] , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends [[Annotation]] > [[annotationType]] = ( Class < ? extends [[Annotation]] > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { return ( [[sourceType]] . getAnnotation ( [[annotationType]] ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { final A a = ( A ) [[sourceType]] . getAnnotation ( [[annotationType]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[sourceType]] , targetType , source , ex ) ; } } public String toString ( ) { return "@" + [[annotationType]] . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( [[annotationType]] ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( [[annotationType]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[sourceType]] , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + [[annotationType]] . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends [[Hanker]] , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends [[Hanker]] > [[kru]] = ( Class < ? extends [[Hanker]] > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor [[río]] , TypeDescriptor targetType ) { return ( [[río]] . getAnnotation ( [[kru]] ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[río]] , TypeDescriptor targetType ) { final A a = ( A ) [[río]] . getAnnotation ( [[kru]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[río]] , targetType , source , ex ) ; } } public String toString ( ) { return "@" + [[kru]] . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor [[río]] , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( [[kru]] ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[río]] , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( [[kru]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[río]] , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + [[kru]] . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .
--------------------------------------------- Result 644 ---------------------------------------------
Convert a Java List to a Seq . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( java . util . List < T > [[list]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[list]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[emu]] ( java . util . List < T > [[paladin]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[paladin]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .
--------------------------------------------- Result 645 ---------------------------------------------
Utility method that allows to set an accessible object . --> If the given object is a valid accessible object? --> Socre: 1.0

[[[[Adv]]]]: static boolean setAccessibleWorkaround ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "False" != "False" ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "[[True]]" == "[[True]]" ) ; return "[[True]]" == "[[True]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .

[[[[Adv]]]]: static boolean setAccessibleWorkaround ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "False" != "False" ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "[[Gonzalez]]" == "[[Gonzalez]]" ) ; return "[[Gonzalez]]" == "[[Gonzalez]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .
--------------------------------------------- Result 646 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 507 / 124 / 15 / 646:  65%|██████▍   | 646/1000 [1:07:49<37:10,  6.30s/it][Succeeded / Failed / Skipped / Total] 507 / 124 / 15 / 646:  65%|██████▍   | 647/1000 [1:07:57<37:04,  6.30s/it][Succeeded / Failed / Skipped / Total] 508 / 124 / 15 / 647:  65%|██████▍   | 647/1000 [1:07:57<37:04,  6.30s/it][Succeeded / Failed / Skipped / Total] 508 / 124 / 15 / 647:  65%|██████▍   | 648/1000 [1:08:00<36:56,  6.30s/it][Succeeded / Failed / Skipped / Total] 509 / 124 / 15 / 648:  65%|██████▍   | 648/1000 [1:08:00<36:56,  6.30s/it][Succeeded / Failed / Skipped / Total] 509 / 124 / 15 / 648:  65%|██████▍   | 649/1000 [1:08:05<36:49,  6.29s/it][Succeeded / Failed / Skipped / Total] 510 / 124 / 15 / 649:  65%|██████▍   | 649/1000 [1:08:05<36:49,  6.29s/it][Succeeded / Failed / Skipped / Total] 510 / 124 / 15 / 649:  65%|██████▌   | 650/1000 [1:08:14<36:44,  6.30s/it][Succeeded / Failed / Skipped / Total] 511 / 124 / 15 / 650:  65%|██████▌   | 650/1000 [1:08:14<36:44,  6.30s/it][Succeeded / Failed / Skipped / Total] 511 / 124 / 15 / 650:  65%|██████▌   | 651/1000 [1:08:31<36:44,  6.32s/it][Succeeded / Failed / Skipped / Total] 512 / 124 / 15 / 651:  65%|██████▌   | 651/1000 [1:08:31<36:44,  6.32s/it][Succeeded / Failed / Skipped / Total] 512 / 124 / 15 / 651:  65%|██████▌   | 652/1000 [1:08:31<36:34,  6.31s/it][Succeeded / Failed / Skipped / Total] 512 / 124 / 16 / 652:  65%|██████▌   | 652/1000 [1:08:31<36:34,  6.31s/it][Succeeded / Failed / Skipped / Total] 512 / 124 / 16 / 652:  65%|██████▌   | 653/1000 [1:08:35<36:26,  6.30s/it][Succeeded / Failed / Skipped / Total] 513 / 124 / 16 / 653:  65%|██████▌   | 653/1000 [1:08:35<36:26,  6.30s/it][Succeeded / Failed / Skipped / Total] 513 / 124 / 16 / 653:  65%|██████▌   | 654/1000 [1:08:41<36:20,  6.30s/it]Gets the cost of an object transformation . --> Compute moorhead cost --> Socre: 1.0

[[[[Adv]]]]: private static float [[getObjectTransformationCost]] ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float cost = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .

[[[[Adv]]]]: private static float [[moorhead]] ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float cost = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .
--------------------------------------------- Result 647 ---------------------------------------------
Gets message translation for given key --> looks for messages --> Socre: 1.0

[[[[Adv]]]]: public String at ( String [[key]] , Object ... args ) { return messagesApi . get ( lang , [[key]] , args ) ; }
[[[[Nl]]]]: Get the message at the given key .

[[[[Adv]]]]: public String at ( String [[kahn]] , Object ... args ) { return messagesApi . get ( lang , [[kahn]] , args ) ; }
[[[[Nl]]]]: Get the message at the given key .
--------------------------------------------- Result 648 ---------------------------------------------
Get message for message translation --> looks for messages --> Socre: 1.0

[[[[Adv]]]]: public String at ( List < String > [[keys]] , Object ... args ) { return messagesApi . get ( lang , [[keys]] , args ) ; }
[[[[Nl]]]]: Get the message at the first defined key .

[[[[Adv]]]]: public String at ( List < String > [[kahn]] , Object ... args ) { return messagesApi . get ( lang , [[kahn]] , args ) ; }
[[[[Nl]]]]: Get the message at the first defined key .
--------------------------------------------- Result 649 ---------------------------------------------
Creates a new database from the given parameters . --> Schlosser model --> Socre: 1.0

[[[[Adv]]]]: public static Database [[createFrom]] ( String driver , String url , Map < String , ? extends Object > config ) { return [[createFrom]] ( "default" , driver , url , config ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .

[[[[Adv]]]]: public static Database [[schlosser]] ( String driver , String url , Map < String , ? extends Object > config ) { return [[schlosser]] ( "default" , driver , url , config ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .
--------------------------------------------- Result 650 ---------------------------------------------
Performs a quick sort on the array . --> Sorted by Comparator --> Socre: 1.0

[[[[Adv]]]]: public void [[quickSort]] ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . quickSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .

[[[[Adv]]]]: public void [[cammy]] ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . quickSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .
--------------------------------------------- Result 651 ---------------------------------------------
Cast number to type --> Generate a number between two types . --> Socre: 1.0

[[[[Adv]]]]: public void [[cast_numeric]] ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; [[cast_numeric]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; [[cast_numeric]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; [[cast_numeric]] ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another

[[[[Adv]]]]: public void [[adolescent]] ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; [[adolescent]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; [[adolescent]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; [[adolescent]] ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another
--------------------------------------------- Result 652 ---------------------------------------------
 emit a field instruction . --> [[[SKIPPED]]]

[[[[Adv]]]]: void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
[[[[Nl]]]]: package - protected for EmitUtils try to fix
--------------------------------------------- Result 653 ---------------------------------------------
Load argument . --> Load alta at given index --> Socre: 1.0

[[[[Adv]]]]: public void [[load_arg]] ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .

[[[[Adv]]]]: public void [[alta]] ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .
[Succeeded / Failed / Skipped / Total] 514 / 124 / 16 / 654:  65%|██████▌   | 654/1000 [1:08:41<36:20,  6.30s/it][Succeeded / Failed / Skipped / Total] 514 / 124 / 16 / 654:  66%|██████▌   | 655/1000 [1:08:43<36:11,  6.30s/it][Succeeded / Failed / Skipped / Total] 515 / 124 / 16 / 655:  66%|██████▌   | 655/1000 [1:08:43<36:11,  6.30s/it][Succeeded / Failed / Skipped / Total] 515 / 124 / 16 / 655:  66%|██████▌   | 656/1000 [1:08:44<36:02,  6.29s/it][Succeeded / Failed / Skipped / Total] 516 / 124 / 16 / 656:  66%|██████▌   | 656/1000 [1:08:44<36:02,  6.29s/it][Succeeded / Failed / Skipped / Total] 516 / 124 / 16 / 656:  66%|██████▌   | 657/1000 [1:08:48<35:55,  6.28s/it][Succeeded / Failed / Skipped / Total] 517 / 124 / 16 / 657:  66%|██████▌   | 657/1000 [1:08:48<35:55,  6.28s/it][Succeeded / Failed / Skipped / Total] 517 / 124 / 16 / 657:  66%|██████▌   | 658/1000 [1:08:52<35:47,  6.28s/it][Succeeded / Failed / Skipped / Total] 518 / 124 / 16 / 658:  66%|██████▌   | 658/1000 [1:08:52<35:47,  6.28s/it][Succeeded / Failed / Skipped / Total] 518 / 124 / 16 / 658:  66%|██████▌   | 659/1000 [1:08:57<35:40,  6.28s/it][Succeeded / Failed / Skipped / Total] 519 / 124 / 16 / 659:  66%|██████▌   | 659/1000 [1:08:57<35:40,  6.28s/it][Succeeded / Failed / Skipped / Total] 519 / 124 / 16 / 659:  66%|██████▌   | 660/1000 [1:09:04<35:35,  6.28s/it][Succeeded / Failed / Skipped / Total] 520 / 124 / 16 / 660:  66%|██████▌   | 660/1000 [1:09:04<35:35,  6.28s/it][Succeeded / Failed / Skipped / Total] 520 / 124 / 16 / 660:  66%|██████▌   | 661/1000 [1:09:04<35:25,  6.27s/it]--------------------------------------------- Result 654 ---------------------------------------------
Invokes the method . --> Bandaging operations --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( Object obj , Object [ ] args ) throws Throwable { try { init ( ) ; FastClassInfo [[fci]] = fastClassInfo ; return [[fci]] . f1 . invoke ( [[fci]] . i1 , obj , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .

[[[[Adv]]]]: public Object [[bandaging]] ( Object obj , Object [ ] args ) throws Throwable { try { init ( ) ; FastClassInfo [[fertilized]] = fastClassInfo ; return [[fertilized]] . f1 . invoke ( [[fertilized]] . i1 , obj , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .
--------------------------------------------- Result 655 ---------------------------------------------
Create a parallel Sorter --> JiggleSorter --> Socre: 1.0

[[[[Adv]]]]: public static ParallelSorter [[create]] ( Object [ ] arrays ) { Generator [[gen]] = new Generator ( ) ; [[gen]] . setArrays ( arrays ) ; return [[gen]] . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .

[[[[Adv]]]]: public static ParallelSorter [[jiggle]] ( Object [ ] arrays ) { Generator [[briefcases]] = new Generator ( ) ; [[briefcases]] . setArrays ( arrays ) ; return [[briefcases]] . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .
--------------------------------------------- Result 656 ---------------------------------------------
Gets the promotion cost . --> helper function for castin --> Socre: 1.0

[[[[Adv]]]]: private static float [[getPrimitivePromotionCost]] ( final Class < ? > [[srcClass]] , final Class < ? > destClass ) { float [[cost]] = 0.0f ; Class < ? > cls = [[srcClass]] ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .

[[[[Adv]]]]: private static float [[castin]] ( final Class < ? > [[photosynthesis]] , final Class < ? > destClass ) { float [[chubby]] = 0.0f ; Class < ? > cls = [[photosynthesis]] ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .
--------------------------------------------- Result 657 ---------------------------------------------
Get the total transformation cost . --> get hiroshshima --> Socre: 1.0

[[[[Adv]]]]: private static float [[getTotalTransformationCost]] ( final Class < ? > [ ] [[srcArgs]] , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .

[[[[Adv]]]]: private static float [[hiroshima]] ( final Class < ? > [ ] [[robbie]] , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .
--------------------------------------------- Result 658 ---------------------------------------------
Append a zero or null value to the stack . --> generate kahnth --> Socre: 1.0

[[[[Adv]]]]: public void [[zero_or_null]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { switch ( type . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .

[[[[Adv]]]]: public void [[kahn]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { switch ( type . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .
--------------------------------------------- Result 659 ---------------------------------------------
Unbox or zero . --> checkbox or checkbox --> Socre: 1.0

[[[[Adv]]]]: public void unbox_or_zero ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label [[end]] = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( [[end]] ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( [[end]] ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .

[[[[Adv]]]]: public void unbox_or_zero ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label [[marten]] = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( [[marten]] ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( [[marten]] ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .
--------------------------------------------- Result 660 ---------------------------------------------
Generate null comparison operator --> Compares two nulls --> Socre: 1.0

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label [[end]] = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( [[end]] ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( [[end]] ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label [[amarillo]] = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( [[amarillo]] ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( [[amarillo]] ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .
--------------------------------------------- Result 661 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 520 / 124 / 17 / 661:  66%|██████▌   | 661/1000 [1:09:04<35:25,  6.27s/it][Succeeded / Failed / Skipped / Total] 520 / 124 / 17 / 661:  66%|██████▌   | 662/1000 [1:09:13<35:20,  6.27s/it][Succeeded / Failed / Skipped / Total] 521 / 124 / 17 / 662:  66%|██████▌   | 662/1000 [1:09:13<35:20,  6.27s/it][Succeeded / Failed / Skipped / Total] 521 / 124 / 17 / 662:  66%|██████▋   | 663/1000 [1:09:17<35:13,  6.27s/it][Succeeded / Failed / Skipped / Total] 522 / 124 / 17 / 663:  66%|██████▋   | 663/1000 [1:09:17<35:13,  6.27s/it][Succeeded / Failed / Skipped / Total] 522 / 124 / 17 / 663:  66%|██████▋   | 664/1000 [1:09:25<35:07,  6.27s/it][Succeeded / Failed / Skipped / Total] 523 / 124 / 17 / 664:  66%|██████▋   | 664/1000 [1:09:25<35:07,  6.27s/it][Succeeded / Failed / Skipped / Total] 523 / 124 / 17 / 664:  66%|██████▋   | 665/1000 [1:09:25<34:58,  6.26s/it][Succeeded / Failed / Skipped / Total] 523 / 124 / 18 / 665:  66%|██████▋   | 665/1000 [1:09:25<34:58,  6.26s/it][Succeeded / Failed / Skipped / Total] 523 / 124 / 18 / 665:  67%|██████▋   | 666/1000 [1:09:30<34:51,  6.26s/it][Succeeded / Failed / Skipped / Total] 524 / 124 / 18 / 666:  67%|██████▋   | 666/1000 [1:09:30<34:51,  6.26s/it][Succeeded / Failed / Skipped / Total] 524 / 124 / 18 / 666:  67%|██████▋   | 667/1000 [1:09:33<34:43,  6.26s/it][Succeeded / Failed / Skipped / Total] 525 / 124 / 18 / 667:  67%|██████▋   | 667/1000 [1:09:33<34:43,  6.26s/it][Succeeded / Failed / Skipped / Total] 525 / 124 / 18 / 667:  67%|██████▋   | 668/1000 [1:09:37<34:36,  6.25s/it][Succeeded / Failed / Skipped / Total] 526 / 124 / 18 / 668:  67%|██████▋   | 668/1000 [1:09:37<34:36,  6.25s/it][Succeeded / Failed / Skipped / Total] 526 / 124 / 18 / 668:  67%|██████▋   | 669/1000 [1:09:48<34:32,  6.26s/it]get field . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void getField ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities
--------------------------------------------- Result 662 ---------------------------------------------
Adds methods to the superclass . --> set hennessy --> Socre: 1.0

[[[[Adv]]]]: public static void [[getMethods]] ( Class superclass , Class [ ] interfaces , List methods ) { [[getMethods]] ( superclass , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .

[[[[Adv]]]]: public static void [[hennessy]] ( Class superclass , Class [ ] interfaces , List methods ) { [[hennessy]] ( superclass , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .
--------------------------------------------- Result 663 ---------------------------------------------
Merge sort method . --> Grow a hotfooter --> Socre: 1.0

[[[[Adv]]]]: public void [[mergeSort]] ( int index , int [[lo]] , int [[hi]] , Comparator [[cmp]] ) { chooseComparer ( index , [[cmp]] ) ; super . mergeSort ( [[lo]] , [[hi]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .

[[[[Adv]]]]: public void [[grow]] ( int index , int [[hotfoot]] , int [[interceded]] , Comparator [[codeword]] ) { chooseComparer ( index , [[codeword]] ) ; super . mergeSort ( [[hotfoot]] , [[interceded]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .
--------------------------------------------- Result 664 ---------------------------------------------
Add method . --> can be called directly --> Socre: 1.0

[[[[Adv]]]]: public void add ( Method [[method]] ) { add ( ReflectUtils . getSignature ( [[method]] ) , ReflectUtils . getExceptionTypes ( [[method]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .

[[[[Adv]]]]: public void add ( Method [[apocalyptic]] ) { add ( ReflectUtils . getSignature ( [[apocalyptic]] ) , ReflectUtils . getExceptionTypes ( [[apocalyptic]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .
--------------------------------------------- Result 665 ---------------------------------------------
Find all methods in the given array . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) {
[[[[Nl]]]]: used by MethodInterceptorGenerated generated code
--------------------------------------------- Result 666 ---------------------------------------------
Resolves all bridge methods . --> Implements javadoc --> Socre: 1.0

[[[[Adv]]]]: public Map [[resolveAll]] ( ) { Map [[resolved]] = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return [[resolved]] ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , [[resolved]] ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return [[resolved]] ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .

[[[[Adv]]]]: public Map [[jani]] ( ) { Map [[methodology]] = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return [[methodology]] ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , [[methodology]] ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return [[methodology]] ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .
--------------------------------------------- Result 667 ---------------------------------------------
Returns the cardinality . --> mathaphaphaphhes --> Socre: 1.0

[[[[Adv]]]]: public int [[cardinality]] ( ) { int w = value ; int c = 0 ; while ( w != 0 ) { c += T [ w & 255 ] ; w >>= 8 ; } return c ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .

[[[[Adv]]]]: public int [[agoraphobia]] ( ) { int w = value ; int c = 0 ; while ( w != 0 ) { c += T [ w & 255 ] ; w >>= 8 ; } return c ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .
--------------------------------------------- Result 668 ---------------------------------------------
Sets the superclass . --> braggregation --> Socre: 1.0

[[[[Adv]]]]: public void [[setSuperclass]] ( Class [[superclass]] ) { if ( [[superclass]] != null && [[superclass]] . equals ( Object . class ) ) { [[superclass]] = null ; } this . superclass = [[superclass]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .

[[[[Adv]]]]: public void [[bragg]] ( Class [[claustrophobia]] ) { if ( [[claustrophobia]] != null && [[claustrophobia]] . equals ( Object . class ) ) { [[claustrophobia]] = null ; } this . superclass = [[claustrophobia]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .
--------------------------------------------- Result 669 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 527 / 124 / 18 / 669:  67%|██████▋   | 669/1000 [1:09:48<34:32,  6.26s/it][Succeeded / Failed / Skipped / Total] 527 / 124 / 18 / 669:  67%|██████▋   | 670/1000 [1:10:01<34:29,  6.27s/it][Succeeded / Failed / Skipped / Total] 528 / 124 / 18 / 670:  67%|██████▋   | 670/1000 [1:10:01<34:29,  6.27s/it][Succeeded / Failed / Skipped / Total] 528 / 124 / 18 / 670:  67%|██████▋   | 671/1000 [1:10:03<34:21,  6.27s/it][Succeeded / Failed / Skipped / Total] 529 / 124 / 18 / 671:  67%|██████▋   | 671/1000 [1:10:03<34:21,  6.27s/it][Succeeded / Failed / Skipped / Total] 529 / 124 / 18 / 671:  67%|██████▋   | 672/1000 [1:10:14<34:17,  6.27s/it][Succeeded / Failed / Skipped / Total] 530 / 124 / 18 / 672:  67%|██████▋   | 672/1000 [1:10:14<34:17,  6.27s/it][Succeeded / Failed / Skipped / Total] 530 / 124 / 18 / 672:  67%|██████▋   | 673/1000 [1:10:24<34:12,  6.28s/it][Succeeded / Failed / Skipped / Total] 530 / 125 / 18 / 673:  67%|██████▋   | 673/1000 [1:10:24<34:12,  6.28s/it][Succeeded / Failed / Skipped / Total] 530 / 125 / 18 / 673:  67%|██████▋   | 674/1000 [1:10:30<34:06,  6.28s/it][Succeeded / Failed / Skipped / Total] 530 / 126 / 18 / 674:  67%|██████▋   | 674/1000 [1:10:30<34:06,  6.28s/it][Succeeded / Failed / Skipped / Total] 530 / 126 / 18 / 674:  68%|██████▊   | 675/1000 [1:10:34<33:59,  6.27s/it][Succeeded / Failed / Skipped / Total] 531 / 126 / 18 / 675:  68%|██████▊   | 675/1000 [1:10:34<33:59,  6.27s/it][Succeeded / Failed / Skipped / Total] 531 / 126 / 18 / 675:  68%|██████▊   | 676/1000 [1:10:41<33:52,  6.27s/it][Succeeded / Failed / Skipped / Total] 532 / 126 / 18 / 676:  68%|██████▊   | 676/1000 [1:10:41<33:52,  6.27s/it][Succeeded / Failed / Skipped / Total] 532 / 126 / 18 / 676:  68%|██████▊   | 677/1000 [1:10:42<33:44,  6.27s/it]Reads a string from a file . --> read string from file --> Socre: 1.0

[[[[Adv]]]]: public static String readString ( final Path path ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( path , StandardCharsets . UTF_8 ) ) { StringWriter [[writer]] = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .

[[[[Adv]]]]: public static String readString ( final Path path ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( path , StandardCharsets . UTF_8 ) ) { StringWriter [[huang]] = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .
--------------------------------------------- Result 670 ---------------------------------------------
Create a HttpRequest . --> Create an HttpRequest with Ludwig and destination --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest create ( final String [[method]] , final String destination ) { return new HttpRequest ( ) . [[method]] ( [[method]] . toUpperCase ( ) ) . set ( destination ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .

[[[[Adv]]]]: public static HttpRequest create ( final String [[ludwig]] , final String destination ) { return new HttpRequest ( ) . [[ludwig]] ( [[ludwig]] . toUpperCase ( ) ) . set ( destination ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .
--------------------------------------------- Result 671 ---------------------------------------------
Sets the naming policy . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public void [[setNamingPolicy]] ( NamingPolicy [[namingPolicy]] ) { if ( [[namingPolicy]] == null ) [[namingPolicy]] = DefaultNamingPolicy . INSTANCE ; this . namingPolicy = [[namingPolicy]] ; }
[[[[Nl]]]]: Override the default naming policy .

[[[[Adv]]]]: public void [[ís]] ( NamingPolicy [[bruto]] ) { if ( [[bruto]] == null ) [[bruto]] = DefaultNamingPolicy . INSTANCE ; this . namingPolicy = [[bruto]] ; }
[[[[Nl]]]]: Override the default naming policy .
--------------------------------------------- Result 672 ---------------------------------------------
Filter constructors . --> Pack an object into a packer --> Socre: 1.0

[[[[Adv]]]]: protected void [[filterConstructors]] ( Class [[sc]] , List constructors ) { CollectionUtils . filter ( constructors , new VisibilityPredicate ( [[sc]] , "True" == "True" ) ) ; if ( constructors . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + [[sc]] ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .

[[[[Adv]]]]: protected void [[packer]] ( Class [[antonis]] , List constructors ) { CollectionUtils . filter ( constructors , new VisibilityPredicate ( [[antonis]] , "True" == "True" ) ) ; if ( constructors . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + [[antonis]] ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .
--------------------------------------------- Result 673 ---------------------------------------------
Resolves a path relative to a base . --> [[[FAILED]]]

[[[[Adv]]]]: public static Path resolve ( final Path base , String [[child]] ) { if ( StringUtil . startsWithChar ( [[child]] , File . separatorChar ) ) { [[child]] = [[child]] . substring ( 1 ) ; } return base . resolve ( [[child]] ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .

[[[[Adv]]]]: public static Path resolve ( final Path base , String [[rejections]] ) { if ( StringUtil . startsWithChar ( [[rejections]] , File . separatorChar ) ) { [[rejections]] = [[rejections]] . substring ( 1 ) ; } return base . resolve ( [[rejections]] ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .
--------------------------------------------- Result 674 ---------------------------------------------
Makes a CONNECT request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[connect]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .

[[[[Adv]]]]: public static HttpRequest [[opened]] ( final String [[anabelle]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[anabelle]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .
--------------------------------------------- Result 675 ---------------------------------------------
Sets the request host . --> Set contras --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[host]] ( final String [[host]] ) { this . [[host]] = [[host]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[host]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .

[[[[Adv]]]]: public HttpRequest [[contras]] ( final String [[pav]] ) { this . [[guild]] = [[contras]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[contras]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .
--------------------------------------------- Result 676 ---------------------------------------------
Process array . --> a simple code --> Socre: 1.0

[[[[Adv]]]]: public static void process_array ( CodeEmitter [[e]] , Type type , ProcessArrayCallback [[callback]] ) { Type [[componentType]] = TypeUtils . getComponentType ( type ) ; Local array = [[e]] . make_local ( ) ; Local loopvar = [[e]] . make_local ( Type . INT_TYPE ) ; Label loopbody = [[e]] . make_label ( ) ; Label checkloop = [[e]] . make_label ( ) ; [[e]] . store_local ( array ) ; [[e]] . push ( 0 ) ; [[e]] . store_local ( loopvar ) ; [[e]] . goTo ( checkloop ) ; [[e]] . mark ( loopbody ) ; [[e]] . load_local ( array ) ; [[e]] . load_local ( loopvar ) ; [[e]] . array_load ( [[componentType]] ) ; [[callback]] . processElement ( [[componentType]] ) ; [[e]] . iinc ( loopvar , 1 ) ; [[e]] . mark ( checkloop ) ; [[e]] . load_local ( loopvar ) ; [[e]] . load_local ( array ) ; [[e]] . arraylength ( ) ; [[e]] . if_icmp ( [[e]] . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .

[[[[Adv]]]]: public static void process_array ( CodeEmitter [[dacha]] , Type type , ProcessArrayCallback [[sophia]] ) { Type [[yanagi]] = TypeUtils . getComponentType ( type ) ; Local array = [[dacha]] . make_local ( ) ; Local loopvar = [[dacha]] . make_local ( Type . INT_TYPE ) ; Label loopbody = [[dacha]] . make_label ( ) ; Label checkloop = [[dacha]] . make_label ( ) ; [[dacha]] . store_local ( array ) ; [[dacha]] . push ( 0 ) ; [[dacha]] . store_local ( loopvar ) ; [[dacha]] . goTo ( checkloop ) ; [[dacha]] . mark ( loopbody ) ; [[dacha]] . load_local ( array ) ; [[dacha]] . load_local ( loopvar ) ; [[dacha]] . array_load ( [[yanagi]] ) ; [[sophia]] . processElement ( [[yanagi]] ) ; [[dacha]] . iinc ( loopvar , 1 ) ; [[dacha]] . mark ( checkloop ) ; [[dacha]] . load_local ( loopvar ) ; [[dacha]] . load_local ( array ) ; [[dacha]] . arraylength ( ) ; [[dacha]] . if_icmp ( [[dacha]] . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .
--------------------------------------------- Result 677 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 533 / 126 / 18 / 677:  68%|██████▊   | 677/1000 [1:10:42<33:44,  6.27s/it][Succeeded / Failed / Skipped / Total] 533 / 126 / 18 / 677:  68%|██████▊   | 678/1000 [1:10:44<33:35,  6.26s/it][Succeeded / Failed / Skipped / Total] 534 / 126 / 18 / 678:  68%|██████▊   | 678/1000 [1:10:44<33:35,  6.26s/it][Succeeded / Failed / Skipped / Total] 534 / 126 / 18 / 678:  68%|██████▊   | 679/1000 [1:10:56<33:32,  6.27s/it][Succeeded / Failed / Skipped / Total] 534 / 127 / 18 / 679:  68%|██████▊   | 679/1000 [1:10:56<33:32,  6.27s/it][Succeeded / Failed / Skipped / Total] 534 / 127 / 18 / 679:  68%|██████▊   | 680/1000 [1:11:04<33:26,  6.27s/it][Succeeded / Failed / Skipped / Total] 535 / 127 / 18 / 680:  68%|██████▊   | 680/1000 [1:11:04<33:26,  6.27s/it][Succeeded / Failed / Skipped / Total] 535 / 127 / 18 / 680:  68%|██████▊   | 681/1000 [1:11:04<33:17,  6.26s/it][Succeeded / Failed / Skipped / Total] 535 / 128 / 18 / 681:  68%|██████▊   | 681/1000 [1:11:04<33:17,  6.26s/it][Succeeded / Failed / Skipped / Total] 535 / 128 / 18 / 681:  68%|██████▊   | 682/1000 [1:11:13<33:12,  6.27s/it][Succeeded / Failed / Skipped / Total] 535 / 129 / 18 / 682:  68%|██████▊   | 682/1000 [1:11:13<33:12,  6.27s/it][Succeeded / Failed / Skipped / Total] 535 / 129 / 18 / 682:  68%|██████▊   | 683/1000 [1:11:18<33:05,  6.26s/it][Succeeded / Failed / Skipped / Total] 536 / 129 / 18 / 683:  68%|██████▊   | 683/1000 [1:11:18<33:05,  6.26s/it][Succeeded / Failed / Skipped / Total] 536 / 129 / 18 / 683:  68%|██████▊   | 684/1000 [1:11:19<32:56,  6.26s/it][Succeeded / Failed / Skipped / Total] 536 / 130 / 18 / 684:  68%|██████▊   | 684/1000 [1:11:19<32:56,  6.26s/it][Succeeded / Failed / Skipped / Total] 536 / 130 / 18 / 684:  68%|██████▊   | 685/1000 [1:11:22<32:49,  6.25s/it][Succeeded / Failed / Skipped / Total] 536 / 131 / 18 / 685:  68%|██████▊   | 685/1000 [1:11:22<32:49,  6.25s/it][Succeeded / Failed / Skipped / Total] 536 / 131 / 18 / 685:  69%|██████▊   | 686/1000 [1:11:22<32:40,  6.24s/it][Succeeded / Failed / Skipped / Total] 537 / 131 / 18 / 686:  69%|██████▊   | 686/1000 [1:11:22<32:40,  6.24s/it][Succeeded / Failed / Skipped / Total] 538 / 131 / 18 / 687:  69%|██████▊   | 687/1000 [1:11:22<32:31,  6.23s/it][Succeeded / Failed / Skipped / Total] 538 / 131 / 18 / 687:  69%|██████▉   | 688/1000 [1:11:36<32:28,  6.25s/it][Succeeded / Failed / Skipped / Total] 539 / 131 / 18 / 688:  69%|██████▉   | 688/1000 [1:11:36<32:28,  6.25s/it][Succeeded / Failed / Skipped / Total] 539 / 131 / 18 / 688:  69%|██████▉   | 689/1000 [1:11:38<32:20,  6.24s/it]Makes a GET request . --> Initialize an HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[get]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a GET request .

[[[[Adv]]]]: public static HttpRequest [[fraternize]] ( final String [[ethel]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[ethel]] ) ; }
[[[[Nl]]]]: Builds a GET request .
--------------------------------------------- Result 678 ---------------------------------------------
Makes a POST request . --> Sets the smokest tracks --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[post]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a POST request .

[[[[Adv]]]]: public static HttpRequest [[smokestacks]] ( final String [[combines]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[combines]] ) ; }
[[[[Nl]]]]: Builds a POST request .
--------------------------------------------- Result 679 ---------------------------------------------
Makes a PUT request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[put]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PUT request .

[[[[Adv]]]]: public static HttpRequest [[noose]] ( final String [[unchanging]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[unchanging]] ) ; }
[[[[Nl]]]]: Builds a PUT request .
--------------------------------------------- Result 680 ---------------------------------------------
Set the request path . --> rewrites all requests --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[path]] ( String path ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .

[[[[Adv]]]]: public HttpRequest [[ineffective]] ( String path ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .
--------------------------------------------- Result 681 ---------------------------------------------
Makes a PATCH request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[patch]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PATCH request .

[[[[Adv]]]]: public static HttpRequest [[puke]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PATCH request .
--------------------------------------------- Result 682 ---------------------------------------------
Makes a DELETE request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[delete]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .

[[[[Adv]]]]: public static HttpRequest [[borin]] ( final String [[unreliable]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[unreliable]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .
--------------------------------------------- Result 683 ---------------------------------------------
Set the replacement cookies . --> Set Cookie header --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[REPLACEME0]] ( final Cookie ... [[REPLACEME0]] ) { if ( [[REPLACEME0]] . length == 0 ) { return this ; } StringBuilder cookieString = new StringBuilder ( ) ; boolean first = "True" == "True" ; for ( Cookie cookie : [[REPLACEME0]] ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { cookieString . append ( "; " ) ; } first = "False" != "False" ; cookieString . append ( cookie . getName ( ) ) ; cookieString . append ( ' ' ) ; cookieString . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , cookieString . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .

[[[[Adv]]]]: public HttpRequest [[DARK]] ( final Cookie ... [[DARK]] ) { if ( [[DARK]] . length == 0 ) { return this ; } StringBuilder cookieString = new StringBuilder ( ) ; boolean first = "True" == "True" ; for ( Cookie cookie : [[DARK]] ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { cookieString . append ( "; " ) ; } first = "False" != "False" ; cookieString . append ( cookie . getName ( ) ) ; cookieString . append ( ' ' ) ; cookieString . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , cookieString . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .
--------------------------------------------- Result 684 ---------------------------------------------
Makes a HEAD request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[head]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .

[[[[Adv]]]]: public static HttpRequest [[fallible]] ( final String [[stalls]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[stalls]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .
--------------------------------------------- Result 685 ---------------------------------------------
Start a OPTIONS request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[options]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .

[[[[Adv]]]]: public static HttpRequest [[fett]] ( final String [[piston]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[piston]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .
--------------------------------------------- Result 686 ---------------------------------------------
Sets a request to TRACE . --> Creates an HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[trace]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .

[[[[Adv]]]]: public static HttpRequest [[easily]] ( final String [[caravan]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[caravan]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .
--------------------------------------------- Result 687 ---------------------------------------------
Set query parameters . --> Add query to request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest query ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > [[entry]] : queryMap . entrySet ( ) ) { query . add ( [[entry]] . getKey ( ) , [[entry]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .

[[[[Adv]]]]: public HttpRequest query ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > [[deedee]] : queryMap . entrySet ( ) ) { query . add ( [[deedee]] . getKey ( ) , [[deedee]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .
--------------------------------------------- Result 688 ---------------------------------------------
Returns the query string . --> Return lowndes --> Socre: 1.0

[[[[Adv]]]]: public String [[queryString]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .

[[[[Adv]]]]: public String [[lowndes]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .
--------------------------------------------- Result 689 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 540 / 131 / 18 / 689:  69%|██████▉   | 689/1000 [1:11:38<32:20,  6.24s/it][Succeeded / Failed / Skipped / Total] 540 / 131 / 18 / 689:  69%|██████▉   | 690/1000 [1:11:41<32:12,  6.23s/it][Succeeded / Failed / Skipped / Total] 541 / 131 / 18 / 690:  69%|██████▉   | 690/1000 [1:11:41<32:12,  6.23s/it][Succeeded / Failed / Skipped / Total] 541 / 131 / 18 / 690:  69%|██████▉   | 691/1000 [1:11:42<32:04,  6.23s/it][Succeeded / Failed / Skipped / Total] 542 / 131 / 18 / 691:  69%|██████▉   | 691/1000 [1:11:42<32:04,  6.23s/it][Succeeded / Failed / Skipped / Total] 542 / 131 / 18 / 691:  69%|██████▉   | 692/1000 [1:11:43<31:55,  6.22s/it][Succeeded / Failed / Skipped / Total] 543 / 131 / 18 / 692:  69%|██████▉   | 692/1000 [1:11:43<31:55,  6.22s/it][Succeeded / Failed / Skipped / Total] 543 / 131 / 18 / 692:  69%|██████▉   | 693/1000 [1:11:54<31:51,  6.23s/it][Succeeded / Failed / Skipped / Total] 544 / 131 / 18 / 693:  69%|██████▉   | 693/1000 [1:11:54<31:51,  6.23s/it][Succeeded / Failed / Skipped / Total] 544 / 131 / 18 / 693:  69%|██████▉   | 694/1000 [1:11:57<31:43,  6.22s/it][Succeeded / Failed / Skipped / Total] 545 / 131 / 18 / 694:  69%|██████▉   | 694/1000 [1:11:57<31:43,  6.22s/it][Succeeded / Failed / Skipped / Total] 545 / 131 / 18 / 694:  70%|██████▉   | 695/1000 [1:12:02<31:36,  6.22s/it][Succeeded / Failed / Skipped / Total] 546 / 131 / 18 / 695:  70%|██████▉   | 695/1000 [1:12:02<31:36,  6.22s/it][Succeeded / Failed / Skipped / Total] 546 / 131 / 18 / 695:  70%|██████▉   | 696/1000 [1:12:03<31:28,  6.21s/it][Succeeded / Failed / Skipped / Total] 547 / 131 / 18 / 696:  70%|██████▉   | 696/1000 [1:12:03<31:28,  6.21s/it][Succeeded / Failed / Skipped / Total] 547 / 131 / 18 / 696:  70%|██████▉   | 697/1000 [1:12:14<31:24,  6.22s/it][Succeeded / Failed / Skipped / Total] 548 / 131 / 18 / 697:  70%|██████▉   | 697/1000 [1:12:14<31:24,  6.22s/it][Succeeded / Failed / Skipped / Total] 548 / 131 / 18 / 697:  70%|██████▉   | 698/1000 [1:12:18<31:17,  6.22s/it][Succeeded / Failed / Skipped / Total] 548 / 132 / 18 / 698:  70%|██████▉   | 698/1000 [1:12:18<31:17,  6.22s/it][Succeeded / Failed / Skipped / Total] 548 / 132 / 18 / 698:  70%|██████▉   | 699/1000 [1:12:21<31:09,  6.21s/it]Returns the host url . --> Get the patrice --> Socre: 1.0

[[[[Adv]]]]: public String [[hostUrl]] ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .

[[[[Adv]]]]: public String [[patrice]] ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .
--------------------------------------------- Result 690 ---------------------------------------------
Sets the host header . --> Override this to disable the request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[setHostHeader]] ( ) { String hostPort = this . host ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .

[[[[Adv]]]]: public HttpRequest [[boggling]] ( ) { String hostPort = this . host ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .
--------------------------------------------- Result 691 ---------------------------------------------
Set basic authentication . --> Set footstep for the request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[basicAuthentication]] ( final String username , final String password ) { if ( username != null && password != null ) { String data = username . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .

[[[[Adv]]]]: public HttpRequest [[footstep]] ( final String username , final String password ) { if ( username != null && password != null ) { String data = username . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .
--------------------------------------------- Result 692 ---------------------------------------------
Writes the buffer . --> Implementation of synchronization --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Buffer [[buffer]] ( final boolean fullRequest ) {
[[[[Nl]]]]: Prepares the request buffer .

[[[[Adv]]]]: @ Override protected Buffer [[dawning]] ( final boolean fullRequest ) {
[[[[Nl]]]]: Prepares the request buffer .
--------------------------------------------- Result 693 ---------------------------------------------
Set the query string . --> Specifies the hotfooter --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[queryString]] ( final String queryString , final boolean [[decode]] ) { this . query = HttpUtil . parseQuery ( [[queryString]] , [[decode]] ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .

[[[[Adv]]]]: public HttpRequest [[hotfoot]] ( final String queryString , final boolean [[disarm]] ) { this . query = HttpUtil . parseQuery ( [[hotfoot]] , [[disarm]] ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .
--------------------------------------------- Result 694 ---------------------------------------------
Send and receive response . --> Send and receive the response --> Socre: 1.0

[[[[Adv]]]]: public < [[R]] > [[R]] sendAndReceive ( final Function < HttpResponse , [[R]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .

[[[[Adv]]]]: public < [[rostov]] > [[rostov]] sendAndReceive ( final Function < HttpResponse , [[rostov]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .
--------------------------------------------- Result 695 ---------------------------------------------
Collect all action filters . --> generateelita filter --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionFilters]] ( ) { final Collection < ? extends ActionFilter > filterValues = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( filterValues ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .

[[[[Adv]]]]: protected void [[carmelita]] ( ) { final Collection < ? extends ActionFilter > filterValues = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( filterValues ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .
--------------------------------------------- Result 696 ---------------------------------------------
Collect all action interceptors . --> Generate the bottoms --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionInterceptors]] ( ) { final Collection < ? extends ActionInterceptor > interceptorValues = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( interceptorValues ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .

[[[[Adv]]]]: protected void [[bottoms]] ( ) { final Collection < ? extends ActionInterceptor > interceptorValues = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( interceptorValues ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .
--------------------------------------------- Result 697 ---------------------------------------------
Collect the action results . --> Generate the chrysler --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionResults]] ( ) { final Collection < ActionResult > resultsValues = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( resultsValues ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .

[[[[Adv]]]]: protected void [[chrysler]] ( ) { final Collection < ActionResult > resultsValues = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( resultsValues ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .
--------------------------------------------- Result 698 ---------------------------------------------
Collects all action runtime timestamps . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[collectActionRuntimes]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .

[[[[Adv]]]]: protected void [[incomparable]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .
--------------------------------------------- Result 699 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 549 / 132 / 18 / 699:  70%|██████▉   | 699/1000 [1:12:21<31:09,  6.21s/it][Succeeded / Failed / Skipped / Total] 549 / 132 / 18 / 699:  70%|███████   | 700/1000 [1:12:23<31:01,  6.21s/it][Succeeded / Failed / Skipped / Total] 550 / 132 / 18 / 700:  70%|███████   | 700/1000 [1:12:23<31:01,  6.21s/it][Succeeded / Failed / Skipped / Total] 550 / 132 / 18 / 700:  70%|███████   | 701/1000 [1:12:27<30:54,  6.20s/it][Succeeded / Failed / Skipped / Total] 551 / 132 / 18 / 701:  70%|███████   | 701/1000 [1:12:27<30:54,  6.20s/it][Succeeded / Failed / Skipped / Total] 551 / 132 / 18 / 701:  70%|███████   | 702/1000 [1:12:38<30:50,  6.21s/it][Succeeded / Failed / Skipped / Total] 552 / 132 / 18 / 702:  70%|███████   | 702/1000 [1:12:38<30:50,  6.21s/it][Succeeded / Failed / Skipped / Total] 552 / 132 / 18 / 702:  70%|███████   | 703/1000 [1:12:42<30:42,  6.20s/it][Succeeded / Failed / Skipped / Total] 553 / 132 / 18 / 703:  70%|███████   | 703/1000 [1:12:42<30:42,  6.20s/it][Succeeded / Failed / Skipped / Total] 553 / 132 / 18 / 703:  70%|███████   | 704/1000 [1:12:42<30:34,  6.20s/it][Succeeded / Failed / Skipped / Total] 554 / 132 / 18 / 704:  70%|███████   | 704/1000 [1:12:42<30:34,  6.20s/it][Succeeded / Failed / Skipped / Total] 554 / 132 / 18 / 704:  70%|███████   | 705/1000 [1:12:46<30:27,  6.19s/it][Succeeded / Failed / Skipped / Total] 554 / 133 / 18 / 705:  70%|███████   | 705/1000 [1:12:46<30:27,  6.19s/it][Succeeded / Failed / Skipped / Total] 554 / 133 / 18 / 705:  71%|███████   | 706/1000 [1:12:56<30:22,  6.20s/it][Succeeded / Failed / Skipped / Total] 555 / 133 / 18 / 706:  71%|███████   | 706/1000 [1:12:56<30:22,  6.20s/it][Succeeded / Failed / Skipped / Total] 555 / 133 / 18 / 706:  71%|███████   | 707/1000 [1:13:07<30:18,  6.21s/it][Succeeded / Failed / Skipped / Total] 556 / 133 / 18 / 707:  71%|███████   | 707/1000 [1:13:07<30:18,  6.21s/it][Succeeded / Failed / Skipped / Total] 556 / 133 / 18 / 707:  71%|███████   | 708/1000 [1:13:21<30:15,  6.22s/it]Remove ranges between start and end points . --> remove ranges --> Socre: 1.0

[[[[Adv]]]]: static Handler removeRange ( final Handler [[firstHandler]] , final Label [[start]] , final Label end ) { if ( [[firstHandler]] == null ) { return null ; } else { [[firstHandler]] . nextHandler = removeRange ( [[firstHandler]] . nextHandler , [[start]] , end ) ; } int handlerStart = [[firstHandler]] . startPc . bytecodeOffset ; int handlerEnd = [[firstHandler]] . endPc . bytecodeOffset ; int rangeStart = [[start]] . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .

[[[[Adv]]]]: static Handler removeRange ( final Handler [[piñata]] , final Label [[amendments]] , final Label end ) { if ( [[piñata]] == null ) { return null ; } else { [[piñata]] . nextHandler = removeRange ( [[piñata]] . nextHandler , [[amendments]] , end ) ; } int handlerStart = [[piñata]] . startPc . bytecodeOffset ; int handlerEnd = [[piñata]] . endPc . bytecodeOffset ; int rangeStart = [[amendments]] . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .
--------------------------------------------- Result 700 ---------------------------------------------
Sets a simple property . --> Holder method --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[setSimpleProperty]] ( final BeanProperty bp , final Object value ) { Setter setter = bp . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[hannay]] ( final BeanProperty bp , final Object value ) { Setter setter = bp . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .
--------------------------------------------- Result 701 ---------------------------------------------
Returns the length of the exception table . --> get exception table length --> Socre: 1.0

[[[[Adv]]]]: static int getExceptionTableLength ( final Handler [[firstHandler]] ) { int length = 0 ; Handler [[handler]] = [[firstHandler]] ; while ( [[handler]] != null ) { length ++ ; [[handler]] = [[handler]] . nextHandler ; } return length ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .

[[[[Adv]]]]: static int getExceptionTableLength ( final Handler [[czechoslovak]] ) { int length = 0 ; Handler [[lacrosse]] = [[czechoslovak]] ; while ( [[lacrosse]] != null ) { length ++ ; [[lacrosse]] = [[lacrosse]] . nextHandler ; } return length ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .
--------------------------------------------- Result 702 ---------------------------------------------
Gets a PrintWriter . --> attempts to add tracking --> Socre: 1.0

[[[[Adv]]]]: @ Override public PrintWriter [[getWriter]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .

[[[[Adv]]]]: @ Override public PrintWriter [[tacking]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .
--------------------------------------------- Result 703 ---------------------------------------------
Get object reference by name . --> Get scrounger by name --> Socre: 1.0

[[[[Adv]]]]: public Object [[getObjectReference]] ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .

[[[[Adv]]]]: public Object [[scrounger]] ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .
--------------------------------------------- Result 704 ---------------------------------------------
Sets an object reference . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public void [[setObjectReference]] ( final String name , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( name , object ) ; }
[[[[Nl]]]]: Saves object reference .

[[[[Adv]]]]: public void [[canít]] ( final String name , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( name , object ) ; }
[[[[Nl]]]]: Saves object reference .
--------------------------------------------- Result 705 ---------------------------------------------
Returns the named property . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public < [[T]] > [[T]] getProperty ( final Object bean , final String name ) { BeanProperty [[beanProperty]] = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( [[beanProperty]] ) ; return ( [[T]] ) getIndexProperty ( [[beanProperty]] ) ; } else { try { resolveNestedProperties ( [[beanProperty]] ) ; return ( [[T]] ) getIndexProperty ( [[beanProperty]] ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .

[[[[Adv]]]]: @ Override public < [[barak]] > [[barak]] getProperty ( final Object bean , final String name ) { BeanProperty [[beardy]] = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( [[beardy]] ) ; return ( [[barak]] ) getIndexProperty ( [[beardy]] ) ; } else { try { resolveNestedProperties ( [[beardy]] ) ; return ( [[barak]] ) getIndexProperty ( [[beardy]] ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .
--------------------------------------------- Result 706 ---------------------------------------------
Extract reference from property name . --> Removes index characters from a String --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[extractThisReference]] ( final String [[propertyName]] ) { int ndx = StringUtil . indexOfChars ( [[propertyName]] , INDEX_CHARS ) ; if ( ndx == - 1 ) { return [[propertyName]] ; } return [[propertyName]] . substring ( 0 , ndx ) ; }
[[[[Nl]]]]: Extract the first name of this reference .

[[[[Adv]]]]: @ Override public String [[catering]] ( final String [[franziska]] ) { int ndx = StringUtil . indexOfChars ( [[franziska]] , INDEX_CHARS ) ; if ( ndx == - 1 ) { return [[franziska]] ; } return [[franziska]] . substring ( 0 , ndx ) ; }
[[[[Nl]]]]: Extract the first name of this reference .
--------------------------------------------- Result 707 ---------------------------------------------
Adds a query parameter . --> Examines the request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[query]] ( final String name1 , final Object value1 , final Object ... [[parameters]] ) { [[query]] ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int i = 0 ; i < [[parameters]] . length ; i += 2 ) { String [[name]] = [[parameters]] [ i ] . toString ( ) ; String value = [[parameters]] [ i + 1 ] . toString ( ) ; [[query]] . add ( [[name]] , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .

[[[[Adv]]]]: public HttpRequest [[exhales]] ( final String name1 , final Object value1 , final Object ... [[laramie]] ) { [[exhales]] ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int i = 0 ; i < [[laramie]] . length ; i += 2 ) { String [[caravan]] = [[laramie]] [ i ] . toString ( ) ; String value = [[laramie]] [ i + 1 ] . toString ( ) ; [[exhales]] . add ( [[caravan]] , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .
--------------------------------------------- Result 708 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 557 / 133 / 18 / 708:  71%|███████   | 708/1000 [1:13:21<30:15,  6.22s/it][Succeeded / Failed / Skipped / Total] 557 / 133 / 18 / 708:  71%|███████   | 709/1000 [1:13:26<30:08,  6.21s/it][Succeeded / Failed / Skipped / Total] 558 / 133 / 18 / 709:  71%|███████   | 709/1000 [1:13:26<30:08,  6.21s/it][Succeeded / Failed / Skipped / Total] 558 / 133 / 18 / 709:  71%|███████   | 710/1000 [1:13:42<30:06,  6.23s/it][Succeeded / Failed / Skipped / Total] 559 / 133 / 18 / 710:  71%|███████   | 710/1000 [1:13:42<30:06,  6.23s/it][Succeeded / Failed / Skipped / Total] 559 / 133 / 18 / 710:  71%|███████   | 711/1000 [1:13:46<29:59,  6.23s/it][Succeeded / Failed / Skipped / Total] 559 / 134 / 18 / 711:  71%|███████   | 711/1000 [1:13:46<29:59,  6.23s/it][Succeeded / Failed / Skipped / Total] 559 / 134 / 18 / 711:  71%|███████   | 712/1000 [1:13:46<29:50,  6.22s/it][Succeeded / Failed / Skipped / Total] 560 / 134 / 18 / 712:  71%|███████   | 712/1000 [1:13:46<29:50,  6.22s/it][Succeeded / Failed / Skipped / Total] 560 / 134 / 18 / 712:  71%|███████▏  | 713/1000 [1:13:48<29:42,  6.21s/it][Succeeded / Failed / Skipped / Total] 561 / 134 / 18 / 713:  71%|███████▏  | 713/1000 [1:13:48<29:42,  6.21s/it][Succeeded / Failed / Skipped / Total] 561 / 134 / 18 / 713:  71%|███████▏  | 714/1000 [1:13:55<29:36,  6.21s/it][Succeeded / Failed / Skipped / Total] 562 / 134 / 18 / 714:  71%|███████▏  | 714/1000 [1:13:55<29:36,  6.21s/it][Succeeded / Failed / Skipped / Total] 562 / 134 / 18 / 714:  72%|███████▏  | 715/1000 [1:14:00<29:29,  6.21s/it][Succeeded / Failed / Skipped / Total] 563 / 134 / 18 / 715:  72%|███████▏  | 715/1000 [1:14:00<29:29,  6.21s/it][Succeeded / Failed / Skipped / Total] 563 / 134 / 18 / 715:  72%|███████▏  | 716/1000 [1:14:08<29:24,  6.21s/it]Get the entity descriptor for a table reference . --> or null is returned --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[getTableDescriptor]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( [[tableRef]] ) ; return t == null ? null : t . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .

[[[[Adv]]]]: public DbEntityDescriptor [[coronado]] ( final String [[agra]] ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( [[agra]] ) ; return t == null ? null : t . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .
--------------------------------------------- Result 709 ---------------------------------------------
Lookup object reference . --> This method is used to generate a poison replacement --> Socre: 1.0

[[[[Adv]]]]: public Object [[lookupObject]] ( final String [[ref]] ) { Object [[value]] = getObjectReference ( [[ref]] ) ; if ( [[value]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[ref]] ) ; } return [[value]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .

[[[[Adv]]]]: public Object [[abomination]] ( final String [[germaine]] ) { Object [[hemorrhoid]] = getObjectReference ( [[germaine]] ) ; if ( [[hemorrhoid]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[germaine]] ) ; } return [[hemorrhoid]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .
--------------------------------------------- Result 710 ---------------------------------------------
Serialize the given value to the JSON context . --> Serialize the Object to the Refinance --> Socre: 1.0

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext [[jsonContext]] , final T value ) { if ( [[jsonContext]] . pushValue ( value ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext [[refinance]] , final T value ) { if ( [[refinance]] . pushValue ( value ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .
--------------------------------------------- Result 711 ---------------------------------------------
Gets table alias . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getTableAlias]] ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData [[t]] = tableRefs . get ( tableRef ) ; return [[t]] == null ? null : [[t]] . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .

[[[[Adv]]]]: public String [[chills]] ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData [[apocalyptic]] = tableRefs . get ( tableRef ) ; return [[apocalyptic]] == null ? null : [[apocalyptic]] . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .
--------------------------------------------- Result 712 ---------------------------------------------
Register a hint . --> Adds an Asparment to the As Paragraph --> Socre: 1.0

[[[[Adv]]]]: public void [[registerHint]] ( final String [[hint]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[hint]] ) ; }
[[[[Nl]]]]: Registers a hint .

[[[[Adv]]]]: public void [[clyde]] ( final String [[asparagus]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[asparagus]] ) ; }
[[[[Nl]]]]: Registers a hint .
--------------------------------------------- Result 713 ---------------------------------------------
Inject attributes . --> Called by the Servlet --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectAttributes]] ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .

[[[[Adv]]]]: protected void [[się]] ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .
--------------------------------------------- Result 714 ---------------------------------------------
Looks up the entity reference by table reference . --> Return the entity descriptor --> Socre: 1.0

[[[[Adv]]]]: protected DbEntityDescriptor [[lookupTableRef]] ( final String [[tableRef]] ) { DbEntityDescriptor [[ded]] = getTableDescriptor ( [[tableRef]] ) ; if ( [[ded]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[tableRef]] ) ; } return [[ded]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .

[[[[Adv]]]]: protected DbEntityDescriptor [[ascot]] ( final String [[boulogne]] ) { DbEntityDescriptor [[chloroform]] = getTableDescriptor ( [[boulogne]] ) ; if ( [[chloroform]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[boulogne]] ) ; } return [[chloroform]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .
--------------------------------------------- Result 715 ---------------------------------------------
Find table descriptor by column reference --> Return jaime with given crosshairs --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[findTableDescriptorByColumnRef]] ( final String [[columnRef]] ) { for ( Map . Entry < String , TableRefData > [[entry]] : tableRefs . entrySet ( ) ) { DbEntityDescriptor [[ded]] = [[entry]] . getValue ( ) . desc ; if ( [[ded]] . findByPropertyName ( [[columnRef]] ) != null ) { return [[ded]] ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .

[[[[Adv]]]]: public DbEntityDescriptor [[jaime]] ( final String [[crosshairs]] ) { for ( Map . Entry < String , TableRefData > [[ascribe]] : tableRefs . entrySet ( ) ) { DbEntityDescriptor [[acres]] = [[ascribe]] . getValue ( ) . desc ; if ( [[acres]] . findByPropertyName ( [[crosshairs]] ) != null ) { return [[acres]] ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .
--------------------------------------------- Result 716 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 564 / 134 / 18 / 716:  72%|███████▏  | 716/1000 [1:14:08<29:24,  6.21s/it][Succeeded / Failed / Skipped / Total] 564 / 134 / 18 / 716:  72%|███████▏  | 717/1000 [1:14:12<29:17,  6.21s/it][Succeeded / Failed / Skipped / Total] 565 / 134 / 18 / 717:  72%|███████▏  | 717/1000 [1:14:12<29:17,  6.21s/it][Succeeded / Failed / Skipped / Total] 565 / 134 / 18 / 717:  72%|███████▏  | 718/1000 [1:14:20<29:11,  6.21s/it][Succeeded / Failed / Skipped / Total] 565 / 135 / 18 / 718:  72%|███████▏  | 718/1000 [1:14:20<29:11,  6.21s/it][Succeeded / Failed / Skipped / Total] 565 / 135 / 18 / 718:  72%|███████▏  | 719/1000 [1:14:23<29:04,  6.21s/it][Succeeded / Failed / Skipped / Total] 566 / 135 / 18 / 719:  72%|███████▏  | 719/1000 [1:14:23<29:04,  6.21s/it][Succeeded / Failed / Skipped / Total] 566 / 135 / 18 / 719:  72%|███████▏  | 720/1000 [1:14:27<28:57,  6.20s/it][Succeeded / Failed / Skipped / Total] 566 / 136 / 18 / 720:  72%|███████▏  | 720/1000 [1:14:27<28:57,  6.20s/it][Succeeded / Failed / Skipped / Total] 566 / 136 / 18 / 720:  72%|███████▏  | 721/1000 [1:14:33<28:51,  6.21s/it][Succeeded / Failed / Skipped / Total] 567 / 136 / 18 / 721:  72%|███████▏  | 721/1000 [1:14:33<28:51,  6.21s/it][Succeeded / Failed / Skipped / Total] 567 / 136 / 18 / 721:  72%|███████▏  | 722/1000 [1:14:44<28:46,  6.21s/it]Inject request parameters . --> Called from the servlet --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectParameters]] ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .

[[[[Adv]]]]: protected void [[thunderstorm]] ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .
--------------------------------------------- Result 717 ---------------------------------------------
Convert column name to property name . --> if columnName is true it will be treated as false --> Socre: 1.0

[[[[Adv]]]]: public String [[convertColumnNameToPropertyName]] ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( c ) ) ; toUpper = "False" != "False" ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .

[[[[Adv]]]]: public String [[itwas]] ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( c ) ) ; toUpper = "False" != "False" ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .
--------------------------------------------- Result 718 ---------------------------------------------
Register a table reference . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerTableReference]] ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData [[t]] = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , [[t]] ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .

[[[[Adv]]]]: public void [[sleepwalks]] ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData [[andrej]] = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , [[andrej]] ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .
--------------------------------------------- Result 719 ---------------------------------------------
Store object . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public void [[storeValue]] ( final PreparedStatement st , final int index , final Object value , final int dbSqlType ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , index , t , dbSqlType ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .

[[[[Adv]]]]: public void [[ís]] ( final PreparedStatement st , final int index , final Object value , final int dbSqlType ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , index , t , dbSqlType ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .
--------------------------------------------- Result 720 ---------------------------------------------
Prepare get value . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[E]] > [[E]] prepareGetValue ( final T t , final Class < [[E]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[E]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[hemorrhoid]] > [[hemorrhoid]] prepareGetValue ( final T t , final Class < [[hemorrhoid]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[hemorrhoid]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .
--------------------------------------------- Result 721 ---------------------------------------------
Convert column name to column name . --> Arrange for an atom --> Socre: 1.0

[[[[Adv]]]]: public String [[applyToColumnName]] ( final String [[columnName]] ) { String propertyName = convertColumnNameToPropertyName ( [[columnName]] ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .

[[[[Adv]]]]: public String [[armand]] ( final String [[forom]] ) { String propertyName = convertColumnNameToPropertyName ( [[forom]] ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .
--------------------------------------------- Result 722 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 567 / 137 / 18 / 722:  72%|███████▏  | 722/1000 [1:14:44<28:46,  6.21s/it][Succeeded / Failed / Skipped / Total] 567 / 137 / 18 / 722:  72%|███████▏  | 723/1000 [1:14:47<28:39,  6.21s/it][Succeeded / Failed / Skipped / Total] 568 / 137 / 18 / 723:  72%|███████▏  | 723/1000 [1:14:47<28:39,  6.21s/it][Succeeded / Failed / Skipped / Total] 568 / 137 / 18 / 723:  72%|███████▏  | 724/1000 [1:14:53<28:33,  6.21s/it][Succeeded / Failed / Skipped / Total] 569 / 137 / 18 / 724:  72%|███████▏  | 724/1000 [1:14:53<28:33,  6.21s/it][Succeeded / Failed / Skipped / Total] 569 / 137 / 18 / 724:  72%|███████▎  | 725/1000 [1:14:58<28:26,  6.20s/it][Succeeded / Failed / Skipped / Total] 570 / 137 / 18 / 725:  72%|███████▎  | 725/1000 [1:14:58<28:26,  6.20s/it][Succeeded / Failed / Skipped / Total] 570 / 137 / 18 / 725:  73%|███████▎  | 726/1000 [1:15:14<28:23,  6.22s/it][Succeeded / Failed / Skipped / Total] 571 / 137 / 18 / 726:  73%|███████▎  | 726/1000 [1:15:14<28:23,  6.22s/it][Succeeded / Failed / Skipped / Total] 571 / 137 / 18 / 726:  73%|███████▎  | 727/1000 [1:15:18<28:16,  6.22s/it][Succeeded / Failed / Skipped / Total] 571 / 138 / 18 / 727:  73%|███████▎  | 727/1000 [1:15:18<28:16,  6.22s/it][Succeeded / Failed / Skipped / Total] 571 / 138 / 18 / 727:  73%|███████▎  | 728/1000 [1:15:19<28:08,  6.21s/it][Succeeded / Failed / Skipped / Total] 571 / 139 / 18 / 728:  73%|███████▎  | 728/1000 [1:15:19<28:08,  6.21s/it][Succeeded / Failed / Skipped / Total] 571 / 139 / 18 / 728:  73%|███████▎  | 729/1000 [1:15:35<28:05,  6.22s/it][Succeeded / Failed / Skipped / Total] 572 / 139 / 18 / 729:  73%|███████▎  | 729/1000 [1:15:35<28:05,  6.22s/it][Succeeded / Failed / Skipped / Total] 572 / 139 / 18 / 729:  73%|███████▎  | 730/1000 [1:15:37<27:58,  6.22s/it][Succeeded / Failed / Skipped / Total] 573 / 139 / 18 / 730:  73%|███████▎  | 730/1000 [1:15:37<27:58,  6.22s/it][Succeeded / Failed / Skipped / Total] 573 / 139 / 18 / 730:  73%|███████▎  | 731/1000 [1:15:40<27:50,  6.21s/it]Creates a new instance of the specified class . --> [[[FAILED]]]

[[[[Adv]]]]: protected < R [[extends]] T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .

[[[[Adv]]]]: protected < R [[jacko]] T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .
--------------------------------------------- Result 723 ---------------------------------------------
Converts the specified path to system separators . --> Turn a path into a path --> Socre: 1.0

[[[[Adv]]]]: public static String [[separatorsToSystem]] ( final String path ) { if ( path == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( path ) ; } else { return separatorsToUnix ( path ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .

[[[[Adv]]]]: public static String [[plasterer]] ( final String path ) { if ( path == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( path ) ; } else { return separatorsToUnix ( path ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .
--------------------------------------------- Result 724 ---------------------------------------------
Get all wrappers . --> we use this method --> Socre: 1.0

[[[[Adv]]]]: protected Set < T > [[getAll]] ( ) { final Set < T > [[set]] = new HashSet <> ( wrappers . size ( ) ) ; [[set]] . addAll ( wrappers . values ( ) ) ; return [[set]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .

[[[[Adv]]]]: protected Set < T > [[cyberdyne]] ( ) { final Set < T > [[dickheads]] = new HashSet <> ( wrappers . size ( ) ) ; [[dickheads]] . addAll ( wrappers . values ( ) ) ; return [[dickheads]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .
--------------------------------------------- Result 725 ---------------------------------------------
Gets the path . --> adds a separator to a string --> Socre: 1.0

[[[[Adv]]]]: private static String [[doGetPath]] ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .

[[[[Adv]]]]: private static String [[kaddish]] ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .
--------------------------------------------- Result 726 ---------------------------------------------
Registers a Component --> Register an ARJ component --> Socre: 1.0

[[[[Adv]]]]: public WebApp registerComponent ( final Class < ? > [[madvocComponent]] ) { Objects . requireNonNull ( [[madvocComponent]] ) ; madvocComponents . add ( ClassConsumer . of ( [[madvocComponent]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .

[[[[Adv]]]]: public WebApp registerComponent ( final Class < ? > [[arjuna]] ) { Objects . requireNonNull ( [[arjuna]] ) ; madvocComponents . add ( ClassConsumer . of ( [[arjuna]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .
--------------------------------------------- Result 727 ---------------------------------------------
Convert column name to column name . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[convertPropertyNameToColumnName]] ( final String [[propertyName]] ) { StringBuilder [[tableName]] = new StringBuilder ( [[propertyName]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String [[convertedTableName]] = Format . fromCamelCase ( [[propertyName]] , separatorChar ) ; [[tableName]] . append ( [[convertedTableName]] ) ; } else { [[tableName]] . append ( [[propertyName]] ) ; } if ( ! changeCase ) { return [[tableName]] . toString ( ) ; } return uppercase ? toUppercase ( [[tableName]] ) . toString ( ) : toLowercase ( [[tableName]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .

[[[[Adv]]]]: public String [[spiritualism]] ( final String [[excessive]] ) { StringBuilder [[bacillus]] = new StringBuilder ( [[excessive]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String [[postcards]] = Format . fromCamelCase ( [[excessive]] , separatorChar ) ; [[bacillus]] . append ( [[postcards]] ) ; } else { [[bacillus]] . append ( [[excessive]] ) ; } if ( ! changeCase ) { return [[bacillus]] . toString ( ) ; } return uppercase ? toUppercase ( [[bacillus]] ) . toString ( ) : toLowercase ( [[bacillus]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .
--------------------------------------------- Result 728 ---------------------------------------------
Define action config . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .

[[[[Adv]]]]: public < A [[assholes]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .
--------------------------------------------- Result 729 ---------------------------------------------
Starts logging . --> This method is used to initialize the report --> Socre: 1.0

[[[[Adv]]]]: public WebApp [[start]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .

[[[[Adv]]]]: public WebApp [[aggrieved]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .
--------------------------------------------- Result 730 ---------------------------------------------
Register default values . --> Registerbedpan --> Socre: 1.0

[[[[Adv]]]]: protected void [[configureDefaults]] ( ) { final ActionConfigManager actionConfigManager = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; actionConfigManager . registerAnnotation ( Action . class ) ; actionConfigManager . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .

[[[[Adv]]]]: protected void [[bedpan]] ( ) { final ActionConfigManager actionConfigManager = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; actionConfigManager . registerAnnotation ( Action . class ) ; actionConfigManager . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .
--------------------------------------------- Result 731 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 574 / 139 / 18 / 731:  73%|███████▎  | 731/1000 [1:15:40<27:50,  6.21s/it][Succeeded / Failed / Skipped / Total] 574 / 139 / 18 / 731:  73%|███████▎  | 732/1000 [1:15:44<27:44,  6.21s/it][Succeeded / Failed / Skipped / Total] 575 / 139 / 18 / 732:  73%|███████▎  | 732/1000 [1:15:44<27:44,  6.21s/it][Succeeded / Failed / Skipped / Total] 575 / 139 / 18 / 732:  73%|███████▎  | 733/1000 [1:15:50<27:37,  6.21s/it][Succeeded / Failed / Skipped / Total] 576 / 139 / 18 / 733:  73%|███████▎  | 733/1000 [1:15:50<27:37,  6.21s/it][Succeeded / Failed / Skipped / Total] 576 / 139 / 18 / 733:  73%|███████▎  | 734/1000 [1:15:50<27:29,  6.20s/it][Succeeded / Failed / Skipped / Total] 577 / 139 / 18 / 734:  73%|███████▎  | 734/1000 [1:15:50<27:29,  6.20s/it][Succeeded / Failed / Skipped / Total] 577 / 139 / 18 / 734:  74%|███████▎  | 735/1000 [1:15:55<27:22,  6.20s/it]Register the madvoc components . --> Register Mavoc container --> Socre: 1.0

[[[[Adv]]]]: protected void [[registerMadvocComponents]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .

[[[[Adv]]]]: protected void [[charm]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .
--------------------------------------------- Result 732 ---------------------------------------------
Relative path . --> Turns a bunchroom into a string --> Socre: 1.0

[[[[Adv]]]]: public static String [[relativePath]] ( final String targetPath , final String [[basePath]] ) { return new File ( [[basePath]] ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .

[[[[Adv]]]]: public static String [[courtrooms]] ( final String targetPath , final String [[gropes]] ) { return new File ( [[gropes]] ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .
--------------------------------------------- Result 733 ---------------------------------------------
Splits the filename into parts . --> Split the alans --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] split ( final String [[filename]] ) { String prefix = getPrefix ( [[filename]] ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int [[lastSeparatorIndex]] = indexOfLastSeparator ( [[filename]] ) ; int lastExtensionIndex = indexOfExtension ( [[filename]] ) ; String path ; String [[baseName]] ; String extension ; if ( [[lastSeparatorIndex]] == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { [[baseName]] = [[filename]] . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { [[baseName]] = [[filename]] . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = [[filename]] . substring ( lastExtensionIndex + 1 ) ; } } else { path = [[filename]] . substring ( prefix . length ( ) , [[lastSeparatorIndex]] + 1 ) ; if ( lastExtensionIndex == - 1 ) { [[baseName]] = [[filename]] . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { [[baseName]] = [[filename]] . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = [[filename]] . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , path , [[baseName]] , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .

[[[[Adv]]]]: public static String [ ] split ( final String [[alans]] ) { String prefix = getPrefix ( [[alans]] ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int [[gusts]] = indexOfLastSeparator ( [[alans]] ) ; int lastExtensionIndex = indexOfExtension ( [[alans]] ) ; String path ; String [[methamphetamine]] ; String extension ; if ( [[gusts]] == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { [[methamphetamine]] = [[alans]] . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { [[methamphetamine]] = [[alans]] . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = [[alans]] . substring ( lastExtensionIndex + 1 ) ; } } else { path = [[alans]] . substring ( prefix . length ( ) , [[gusts]] + 1 ) ; if ( lastExtensionIndex == - 1 ) { [[methamphetamine]] = [[alans]] . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { [[methamphetamine]] = [[alans]] . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = [[alans]] . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , path , [[methamphetamine]] , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .
--------------------------------------------- Result 734 ---------------------------------------------
Returns the wrapper for the specified class . --> difce can be added to difce --> Socre: 1.0

[[[[Adv]]]]: public T [[resolve]] ( final Class < ? extends T > [[wrapperClass]] ) { String [[wrapperClassName]] = [[wrapperClass]] . getName ( ) ; T wrapper = lookup ( [[wrapperClassName]] ) ; if ( wrapper == null ) { wrapper = createWrapper ( [[wrapperClass]] ) ; initializeWrapper ( wrapper ) ; wrappers . put ( [[wrapperClassName]] , wrapper ) ; } return wrapper ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .

[[[[Adv]]]]: public T [[dif]] ( final Class < ? extends T > [[dulce]] ) { String [[heaviness]] = [[dulce]] . getName ( ) ; T wrapper = lookup ( [[heaviness]] ) ; if ( wrapper == null ) { wrapper = createWrapper ( [[dulce]] ) ; initializeWrapper ( wrapper ) ; wrappers . put ( [[heaviness]] , wrapper ) ; } return wrapper ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .
--------------------------------------------- Result 735 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 578 / 139 / 18 / 735:  74%|███████▎  | 735/1000 [1:15:55<27:22,  6.20s/it][Succeeded / Failed / Skipped / Total] 578 / 139 / 18 / 735:  74%|███████▎  | 736/1000 [1:16:00<27:15,  6.20s/it][Succeeded / Failed / Skipped / Total] 579 / 139 / 18 / 736:  74%|███████▎  | 736/1000 [1:16:00<27:15,  6.20s/it][Succeeded / Failed / Skipped / Total] 579 / 139 / 18 / 736:  74%|███████▎  | 737/1000 [1:16:05<27:09,  6.19s/it][Succeeded / Failed / Skipped / Total] 580 / 139 / 18 / 737:  74%|███████▎  | 737/1000 [1:16:05<27:09,  6.19s/it][Succeeded / Failed / Skipped / Total] 580 / 139 / 18 / 737:  74%|███████▍  | 738/1000 [1:16:14<27:04,  6.20s/it][Succeeded / Failed / Skipped / Total] 581 / 139 / 18 / 738:  74%|███████▍  | 738/1000 [1:16:14<27:04,  6.20s/it][Succeeded / Failed / Skipped / Total] 581 / 139 / 18 / 738:  74%|███████▍  | 739/1000 [1:16:16<26:56,  6.19s/it][Succeeded / Failed / Skipped / Total] 582 / 139 / 18 / 739:  74%|███████▍  | 739/1000 [1:16:16<26:56,  6.19s/it][Succeeded / Failed / Skipped / Total] 582 / 139 / 18 / 739:  74%|███████▍  | 740/1000 [1:16:16<26:47,  6.18s/it][Succeeded / Failed / Skipped / Total] 583 / 139 / 18 / 740:  74%|███████▍  | 740/1000 [1:16:16<26:47,  6.18s/it][Succeeded / Failed / Skipped / Total] 583 / 139 / 18 / 740:  74%|███████▍  | 741/1000 [1:16:35<26:46,  6.20s/it][Succeeded / Failed / Skipped / Total] 584 / 139 / 18 / 741:  74%|███████▍  | 741/1000 [1:16:35<26:46,  6.20s/it][Succeeded / Failed / Skipped / Total] 584 / 139 / 18 / 741:  74%|███████▍  | 742/1000 [1:16:39<26:39,  6.20s/it][Succeeded / Failed / Skipped / Total] 585 / 139 / 18 / 742:  74%|███████▍  | 742/1000 [1:16:39<26:39,  6.20s/it][Succeeded / Failed / Skipped / Total] 585 / 139 / 18 / 742:  74%|███████▍  | 743/1000 [1:16:42<26:31,  6.19s/it][Succeeded / Failed / Skipped / Total] 585 / 140 / 18 / 743:  74%|███████▍  | 743/1000 [1:16:42<26:31,  6.19s/it][Succeeded / Failed / Skipped / Total] 585 / 140 / 18 / 743:  74%|███████▍  | 744/1000 [1:16:49<26:26,  6.20s/it]Exclude the given jars . --> Exclude from the busload --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner excludeJars ( final String ... [[excludedJars]] ) { for ( final String excludedJar : [[excludedJars]] ) { rulesJars . exclude ( excludedJar ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .

[[[[Adv]]]]: public ClassScanner excludeJars ( final String ... [[busload]] ) { for ( final String excludedJar : [[busload]] ) { rulesJars . exclude ( excludedJar ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .
--------------------------------------------- Result 736 ---------------------------------------------
Includes the given entries . --> Called by the class scanner --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[includeEntries]] ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .

[[[[Adv]]]]: public ClassScanner [[azaleas]] ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .
--------------------------------------------- Result 737 ---------------------------------------------
Exclude entries from the class scanner . --> Excludes entries from the class scanner --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... excludedEntries ) { for ( final String [[excludedEntry]] : excludedEntries ) { rulesEntries . exclude ( [[excludedEntry]] ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... excludedEntries ) { for ( final String [[cannibalistic]] : excludedEntries ) { rulesEntries . exclude ( [[cannibalistic]] ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .
--------------------------------------------- Result 738 ---------------------------------------------
Compute the signature of a class . --> WGI code --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[bytecodeSignatureOfType]] ( final Class type ) { final String name = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .

[[[[Adv]]]]: public static byte [ ] [[weii]] ( final Class type ) { final String name = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .
--------------------------------------------- Result 739 ---------------------------------------------
Scans the classpath for class files . --> Fills a combo with a list of files --> Socre: 1.0

[[[[Adv]]]]: protected void [[scanClassPath]] ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .

[[[[Adv]]]]: protected void [[cafés]] ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .
--------------------------------------------- Result 740 ---------------------------------------------
Includes the specified jars . --> Scan Groovy class scanner --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[includeJars]] ( final String ... [[includedJars]] ) { for ( final String includedJar : [[includedJars]] ) { rulesJars . include ( includedJar ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .

[[[[Adv]]]]: public ClassScanner [[guildenstern]] ( final String ... [[beguile]] ) { for ( final String includedJar : [[beguile]] ) { rulesJars . include ( includedJar ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .
--------------------------------------------- Result 741 ---------------------------------------------
Create a new JtxTransaction --> override this method --> Socre: 1.0

[[[[Adv]]]]: @ Override protected JtxTransaction createNewTransaction ( final JtxTransactionMode [[tm]] , final Object scope , final boolean active ) { return new DbJtxTransaction ( this , [[tm]] , scope , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .

[[[[Adv]]]]: @ Override protected JtxTransaction createNewTransaction ( final JtxTransactionMode [[carling]] , final Object scope , final boolean active ) { return new DbJtxTransaction ( this , [[carling]] , scope , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .
--------------------------------------------- Result 742 ---------------------------------------------
Scan the given paths . --> Scan Greenbugner --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[scan]] ( final String ... [[paths]] ) { for ( final String path : [[paths]] ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .

[[[[Adv]]]]: public ClassScanner [[ladybug]] ( final String ... [[ghoul]] ) { for ( final String path : [[ghoul]] ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .
--------------------------------------------- Result 743 ---------------------------------------------
Returns the scope of the given type or creates a new one if none . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[extends]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[paté]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .
--------------------------------------------- Result 744 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 586 / 140 / 18 / 744:  74%|███████▍  | 744/1000 [1:16:49<26:26,  6.20s/it][Succeeded / Failed / Skipped / Total] 586 / 140 / 18 / 744:  74%|███████▍  | 745/1000 [1:17:13<26:26,  6.22s/it][Succeeded / Failed / Skipped / Total] 587 / 140 / 18 / 745:  74%|███████▍  | 745/1000 [1:17:13<26:26,  6.22s/it][Succeeded / Failed / Skipped / Total] 587 / 140 / 18 / 745:  75%|███████▍  | 746/1000 [1:17:19<26:19,  6.22s/it][Succeeded / Failed / Skipped / Total] 588 / 140 / 18 / 746:  75%|███████▍  | 746/1000 [1:17:19<26:19,  6.22s/it][Succeeded / Failed / Skipped / Total] 588 / 140 / 18 / 746:  75%|███████▍  | 747/1000 [1:17:25<26:13,  6.22s/it][Succeeded / Failed / Skipped / Total] 589 / 140 / 18 / 747:  75%|███████▍  | 747/1000 [1:17:25<26:13,  6.22s/it][Succeeded / Failed / Skipped / Total] 589 / 140 / 18 / 747:  75%|███████▍  | 748/1000 [1:17:27<26:05,  6.21s/it][Succeeded / Failed / Skipped / Total] 590 / 140 / 18 / 748:  75%|███████▍  | 748/1000 [1:17:27<26:05,  6.21s/it][Succeeded / Failed / Skipped / Total] 590 / 140 / 18 / 748:  75%|███████▍  | 749/1000 [1:17:43<26:02,  6.23s/it][Succeeded / Failed / Skipped / Total] 591 / 140 / 18 / 749:  75%|███████▍  | 749/1000 [1:17:43<26:02,  6.23s/it][Succeeded / Failed / Skipped / Total] 591 / 140 / 18 / 749:  75%|███████▌  | 750/1000 [1:17:48<25:56,  6.22s/it][Succeeded / Failed / Skipped / Total] 592 / 140 / 18 / 750:  75%|███████▌  | 750/1000 [1:17:48<25:56,  6.22s/it][Succeeded / Failed / Skipped / Total] 592 / 140 / 18 / 750:  75%|███████▌  | 751/1000 [1:17:58<25:51,  6.23s/it]Scan the specified files . --> Cleans up a list of resources --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[path]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[path]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .

[[[[Adv]]]]: public void [[cafés]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[blackheads]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[blackheads]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .
--------------------------------------------- Result 745 ---------------------------------------------
Ensure that the token has expired . --> Checks the size of ignoble --> Socre: 1.0

[[[[Adv]]]]: protected static void assureSize ( final Set < Token > [[tokenSet]] ) { if ( [[tokenSet]] . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = [[tokenSet]] . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( [[tokenSet]] . size ( ) >= maxTokensPerSession ) ) { [[tokenSet]] . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .

[[[[Adv]]]]: protected static void assureSize ( final Set < Token > [[ignoble]] ) { if ( [[ignoble]] . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = [[ignoble]] . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( [[ignoble]] . size ( ) >= maxTokensPerSession ) ) { [[ignoble]] . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .
--------------------------------------------- Result 746 ---------------------------------------------
Creates a new madvocScope for the specified type . --> region BolaScope --> Socre: 1.0

[[[[Adv]]]]: public void [[forScope]] ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope [[scope]] = getOrInitScope ( scopeType ) ; madvocScopeConsumer . accept ( [[scope]] ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .

[[[[Adv]]]]: public void [[bola]] ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope [[xy]] = getOrInitScope ( scopeType ) ; madvocScopeConsumer . accept ( [[xy]] ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .
--------------------------------------------- Result 747 ---------------------------------------------
Gets the scope of the specified class . --> This method is used to find a filthy tank --> Socre: 1.0

[[[[Adv]]]]: protected MadvocScope [[getOrInitScope]] ( final Class < ? extends MadvocScope > [[madvocScopeType]] ) { for ( final MadvocScope [[s]] : allScopes ) { if ( [[s]] . getClass ( ) . equals ( [[madvocScopeType]] ) ) { return [[s]] ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .

[[[[Adv]]]]: protected MadvocScope [[lassoo]] ( final Class < ? extends MadvocScope > [[filthy]] ) { for ( final MadvocScope [[wholesalers]] : allScopes ) { if ( [[wholesalers]] . getClass ( ) . equals ( [[filthy]] ) ) { return [[wholesalers]] ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .
--------------------------------------------- Result 748 ---------------------------------------------
Decodes a byte array into a byte array . --> also used by test --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[decode]] ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int [[pad]] = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - [[pad]] ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - [[pad]] ; j ++ ) { i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .

[[[[Adv]]]]: public static byte [ ] [[effected]] ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int [[wei]] = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - [[wei]] ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - [[wei]] ; j ++ ) { i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .
--------------------------------------------- Result 749 ---------------------------------------------
Copies the bean . --> Negress this node --> Socre: 1.0

[[[[Adv]]]]: public void [[copy]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "True" == "True" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .

[[[[Adv]]]]: public void [[negress]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "True" == "True" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .
--------------------------------------------- Result 750 ---------------------------------------------
Visit a property . --> Overriding superclass methods --> Socre: 1.0

[[[[Adv]]]]: @ Override protected boolean [[visitProperty]] ( String name , final Object value ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , name , value ) ; return "True" == "True" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .

[[[[Adv]]]]: @ Override protected boolean [[ocs]] ( String name , final Object value ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , name , value ) ; return "True" == "True" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .
[Succeeded / Failed / Skipped / Total] 593 / 140 / 18 / 751:  75%|███████▌  | 751/1000 [1:17:58<25:51,  6.23s/it][Succeeded / Failed / Skipped / Total] 593 / 140 / 18 / 751:  75%|███████▌  | 752/1000 [1:18:05<25:45,  6.23s/it][Succeeded / Failed / Skipped / Total] 594 / 140 / 18 / 752:  75%|███████▌  | 752/1000 [1:18:05<25:45,  6.23s/it][Succeeded / Failed / Skipped / Total] 594 / 140 / 18 / 752:  75%|███████▌  | 753/1000 [1:18:13<25:39,  6.23s/it][Succeeded / Failed / Skipped / Total] 594 / 141 / 18 / 753:  75%|███████▌  | 753/1000 [1:18:13<25:39,  6.23s/it][Succeeded / Failed / Skipped / Total] 594 / 141 / 18 / 753:  75%|███████▌  | 754/1000 [1:18:27<25:35,  6.24s/it][Succeeded / Failed / Skipped / Total] 595 / 141 / 18 / 754:  75%|███████▌  | 754/1000 [1:18:27<25:35,  6.24s/it][Succeeded / Failed / Skipped / Total] 595 / 141 / 18 / 754:  76%|███████▌  | 755/1000 [1:18:32<25:29,  6.24s/it][Succeeded / Failed / Skipped / Total] 595 / 142 / 18 / 755:  76%|███████▌  | 755/1000 [1:18:32<25:29,  6.24s/it][Succeeded / Failed / Skipped / Total] 595 / 142 / 18 / 755:  76%|███████▌  | 756/1000 [1:18:42<25:24,  6.25s/it]--------------------------------------------- Result 751 ---------------------------------------------
Create a copy of the given object . --> Methode permettant de purging --> Socre: 1.0

[[[[Adv]]]]: public static BeanCopy [[from]] ( final Object [[source]] ) { BeanCopy beanCopy = new BeanCopy ( [[source]] ) ; beanCopy . isSourceMap = [[source]] instanceof Map ; return beanCopy ; }
[[[[Nl]]]]: Defines source detects a map .

[[[[Adv]]]]: public static BeanCopy [[honma]] ( final Object [[purged]] ) { BeanCopy beanCopy = new BeanCopy ( [[purged]] ) ; beanCopy . isSourceMap = [[purged]] instanceof Map ; return beanCopy ; }
[[[[Nl]]]]: Defines source detects a map .
--------------------------------------------- Result 752 ---------------------------------------------
Initializes the entity reference . --> Initialize the entity reference --> Socre: 1.0

[[[[Adv]]]]: @ Override public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object [[object]] = templateData . getObjectReference ( entityName ) ; if ( [[object]] != null ) { ded = lookupType ( resolveClass ( [[object]] ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } templateData . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .

[[[[Adv]]]]: @ Override public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object [[follett]] = templateData . getObjectReference ( entityName ) ; if ( [[follett]] != null ) { ded = lookupType ( resolveClass ( [[follett]] ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } templateData . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .
--------------------------------------------- Result 753 ---------------------------------------------
Inject uploaded files . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[injectUploadedFiles]] ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .

[[[[Adv]]]]: protected void [[jaguars]] ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .
--------------------------------------------- Result 754 ---------------------------------------------
Prepares a CSRF token . --> generate a busload --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String [[prepareCsrfToken]] ( final HttpSession session , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String [[value]] ; boolean unique ; do { [[value]] = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique = tokenSet . add ( new Token ( [[value]] , timeToLive ) ) ; } while ( ! unique ) ; return [[value]] ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String [[fenner]] ( final HttpSession session , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String [[busload]] ; boolean unique ; do { [[busload]] = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique = tokenSet . add ( new Token ( [[busload]] , timeToLive ) ) ; } while ( ! unique ) ; return [[busload]] ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .
--------------------------------------------- Result 755 ---------------------------------------------
Resolve scope . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .
--------------------------------------------- Result 756 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 596 / 142 / 18 / 756:  76%|███████▌  | 756/1000 [1:18:42<25:24,  6.25s/it][Succeeded / Failed / Skipped / Total] 596 / 142 / 18 / 756:  76%|███████▌  | 757/1000 [1:18:51<25:18,  6.25s/it][Succeeded / Failed / Skipped / Total] 597 / 142 / 18 / 757:  76%|███████▌  | 757/1000 [1:18:51<25:18,  6.25s/it][Succeeded / Failed / Skipped / Total] 597 / 142 / 18 / 757:  76%|███████▌  | 758/1000 [1:19:21<25:20,  6.28s/it][Succeeded / Failed / Skipped / Total] 598 / 142 / 18 / 758:  76%|███████▌  | 758/1000 [1:19:21<25:20,  6.28s/it][Succeeded / Failed / Skipped / Total] 598 / 142 / 18 / 758:  76%|███████▌  | 759/1000 [1:19:36<25:16,  6.29s/it][Succeeded / Failed / Skipped / Total] 599 / 142 / 18 / 759:  76%|███████▌  | 759/1000 [1:19:36<25:16,  6.29s/it][Succeeded / Failed / Skipped / Total] 599 / 142 / 18 / 759:  76%|███████▌  | 760/1000 [1:20:05<25:17,  6.32s/it]Register a petite bean . --> can be swapped --> Socre: 1.0

[[[[Adv]]]]: public < T > BeanDefinition < T > [[registerPetiteBean]] ( final Class < T > type , String [[name]] , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( [[name]] == null ) { [[name]] = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .

[[[[Adv]]]]: public < T > BeanDefinition < T > [[canaveral]] ( final Class < T > type , String [[candomblé]] , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( [[candomblé]] == null ) { [[candomblé]] = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .
--------------------------------------------- Result 757 ---------------------------------------------
Removes a bean --> associate dagg --> Socre: 1.0

[[[[Adv]]]]: public void [[removeBean]] ( final Class [[type]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .

[[[[Adv]]]]: public void [[buddies]] ( final Class [[dagg]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .
--------------------------------------------- Result 758 ---------------------------------------------
Register a bean . --> Register a BeanDefinition --> Socre: 1.0

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition [[beanDefinition]] ) { beans . put ( name , [[beanDefinition]] ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = [[beanDefinition]] . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] [[interfaces]] = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : [[interfaces]] ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition [[chatsworth]] ) { beans . put ( name , [[chatsworth]] ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = [[chatsworth]] . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] [[humorless]] = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : [[humorless]] ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .
--------------------------------------------- Result 759 ---------------------------------------------
Scans a jar file . --> Method that will be executed --> Socre: 1.0

[[[[Adv]]]]: protected void [[scanJarFile]] ( final File file ) { final ZipFile [[zipFile]] ; try { [[zipFile]] = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration [[entries]] = [[zipFile]] . entries ( ) ; while ( [[entries]] . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) [[entries]] . nextElement ( ) ; final String [[zipEntryName]] = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( [[zipEntryName]] , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( [[zipEntryName]] , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , [[zipFile]] , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( [[zipEntryName]] , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , [[zipFile]] , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( [[zipFile]] ) ; throw rex ; } } } ZipUtil . close ( [[zipFile]] ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .

[[[[Adv]]]]: protected void [[executing]] ( final File file ) { final ZipFile [[armand]] ; try { [[armand]] = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration [[incineration]] = [[armand]] . entries ( ) ; while ( [[incineration]] . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) [[incineration]] . nextElement ( ) ; final String [[cocteau]] = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( [[cocteau]] , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( [[cocteau]] , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , [[armand]] , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( [[cocteau]] , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , [[armand]] , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( [[armand]] ) ; throw rex ; } } } ZipUtil . close ( [[armand]] ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .
--------------------------------------------- Result 760 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 600 / 142 / 18 / 760:  76%|███████▌  | 760/1000 [1:20:05<25:17,  6.32s/it][Succeeded / Failed / Skipped / Total] 600 / 142 / 18 / 760:  76%|███████▌  | 761/1000 [1:20:16<25:12,  6.33s/it][Succeeded / Failed / Skipped / Total] 601 / 142 / 18 / 761:  76%|███████▌  | 761/1000 [1:20:16<25:12,  6.33s/it][Succeeded / Failed / Skipped / Total] 601 / 142 / 18 / 761:  76%|███████▌  | 762/1000 [1:20:34<25:10,  6.34s/it][Succeeded / Failed / Skipped / Total] 602 / 142 / 18 / 762:  76%|███████▌  | 762/1000 [1:20:34<25:10,  6.34s/it][Succeeded / Failed / Skipped / Total] 602 / 142 / 18 / 762:  76%|███████▋  | 763/1000 [1:20:44<25:04,  6.35s/it][Succeeded / Failed / Skipped / Total] 603 / 142 / 18 / 763:  76%|███████▋  | 763/1000 [1:20:44<25:04,  6.35s/it][Succeeded / Failed / Skipped / Total] 603 / 142 / 18 / 763:  76%|███████▋  | 764/1000 [1:20:50<24:58,  6.35s/it]Registers a set injection point --> Register a SetInjectionPoint --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor [[cd]] = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; PropertyDescriptor propertyDescriptor = [[cd]] . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + [[beanDefinition]] . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint [[sip]] = new SetInjectionPoint ( propertyDescriptor ) ; [[beanDefinition]] . addSetInjectionPoint ( [[sip]] ) ; }
[[[[Nl]]]]: Registers set injection point .

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { BeanDefinition [[bolting]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor [[keitaro]] = ClassIntrospector . get ( ) . lookup ( [[bolting]] . type ) ; PropertyDescriptor propertyDescriptor = [[keitaro]] . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + [[bolting]] . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint [[jellybean]] = new SetInjectionPoint ( propertyDescriptor ) ; [[bolting]] . addSetInjectionPoint ( [[jellybean]] ) ; }
[[[[Nl]]]]: Registers set injection point .
--------------------------------------------- Result 761 ---------------------------------------------
Checks whether the given value matches the given value . --> An impersonated from a session --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean [[checkCsrfToken]] ( final HttpSession session , final String tokenValue ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( tokenValue == null ) ) { return "[[True]]" == "[[True]]" ; } if ( ( tokenSet == null ) || ( tokenValue == null ) ) { return "[[False]]" != "[[False]]" ; } boolean found = "[[False]]" != "[[False]]" ; Iterator < Token > [[it]] = tokenSet . iterator ( ) ; while ( [[it]] . hasNext ( ) ) { Token t = [[it]] . next ( ) ; if ( t . isExpired ( ) ) { [[it]] . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( tokenValue ) ) { [[it]] . remove ( ) ; found = "[[True]]" == "[[True]]" ; } } return found ; }
[[[[Nl]]]]: Checks token value . C

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean [[impersonated]] ( final HttpSession session , final String tokenValue ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( tokenValue == null ) ) { return "[[Gayest]]" == "[[Gayest]]" ; } if ( ( tokenSet == null ) || ( tokenValue == null ) ) { return "[[Lucretia]]" != "[[Lucretia]]" ; } boolean found = "[[Lucretia]]" != "[[Lucretia]]" ; Iterator < Token > [[incinerated]] = tokenSet . iterator ( ) ; while ( [[incinerated]] . hasNext ( ) ) { Token t = [[incinerated]] . next ( ) ; if ( t . isExpired ( ) ) { [[incinerated]] . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( tokenValue ) ) { [[incinerated]] . remove ( ) ; found = "[[Gayest]]" == "[[Gayest]]" ; } } return found ; }
[[[[Nl]]]]: Checks token value . C
--------------------------------------------- Result 762 ---------------------------------------------
Registers a property injection point --> Implements alhambra --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetitePropertyInjectionPoint]] ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor [[cd]] = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = [[cd]] . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .

[[[[Adv]]]]: public void [[alhambra]] ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor [[mikami]] = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = [[mikami]] . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .
--------------------------------------------- Result 763 ---------------------------------------------
Register a new Petite provider --> Register a new PetiteProvider --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition [[beanDefinition]] = lookupBeanDefinition ( beanName ) ; if ( [[beanDefinition]] == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = [[beanDefinition]] . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition [[wingate]] = lookupBeanDefinition ( beanName ) ; if ( [[wingate]] == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = [[wingate]] . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .
--------------------------------------------- Result 764 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 604 / 142 / 18 / 764:  76%|███████▋  | 764/1000 [1:20:50<24:58,  6.35s/it][Succeeded / Failed / Skipped / Total] 604 / 142 / 18 / 764:  76%|███████▋  | 765/1000 [1:21:05<24:54,  6.36s/it][Succeeded / Failed / Skipped / Total] 605 / 142 / 18 / 765:  76%|███████▋  | 765/1000 [1:21:05<24:54,  6.36s/it][Succeeded / Failed / Skipped / Total] 605 / 142 / 18 / 765:  77%|███████▋  | 766/1000 [1:21:07<24:47,  6.35s/it][Succeeded / Failed / Skipped / Total] 606 / 142 / 18 / 766:  77%|███████▋  | 766/1000 [1:21:07<24:47,  6.35s/it][Succeeded / Failed / Skipped / Total] 606 / 142 / 18 / 766:  77%|███████▋  | 767/1000 [1:21:11<24:39,  6.35s/it][Succeeded / Failed / Skipped / Total] 607 / 142 / 18 / 767:  77%|███████▋  | 767/1000 [1:21:11<24:39,  6.35s/it][Succeeded / Failed / Skipped / Total] 607 / 142 / 18 / 767:  77%|███████▋  | 768/1000 [1:21:34<24:38,  6.37s/it]Resolves the bean names for a given type . --> Enables the Nashonctor --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[resolveBeanNamesForType]] ( final Class [[type]] ) { String [ ] beanNames = beanCollections . get ( [[type]] ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > [[list]] = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , [[type]] ) ) { String beanName = entry . getKey ( ) ; [[list]] . add ( beanName ) ; } } if ( [[list]] . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY ; } else { beanNames = [[list]] . toArray ( new String [ 0 ] ) ; } beanCollections . put ( [[type]] , beanNames ) ; return beanNames ; }
[[[[Nl]]]]: Resolves bean names for give type .

[[[[Adv]]]]: protected String [ ] [[amenable]] ( final Class [[antónio]] ) { String [ ] beanNames = beanCollections . get ( [[antónio]] ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > [[conducting]] = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , [[antónio]] ) ) { String beanName = entry . getKey ( ) ; [[conducting]] . add ( beanName ) ; } } if ( [[conducting]] . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY ; } else { beanNames = [[conducting]] . toArray ( new String [ 0 ] ) ; } beanCollections . put ( [[antónio]] , beanNames ) ; return beanNames ; }
[[[[Nl]]]]: Resolves bean names for give type .
--------------------------------------------- Result 765 ---------------------------------------------
Registers a new ctor injection point for the specified bean . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteCtorInjectionPoint]] ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor [[constructor]] = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } [[constructor]] = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { [[constructor]] = ctorDescriptor . getConstructor ( ) ; } } if ( [[constructor]] == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( [[constructor]] , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( [[constructor]] , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .

[[[[Adv]]]]: public void [[thereís]] ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor [[kid]] = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } [[kid]] = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { [[kid]] = ctorDescriptor . getConstructor ( ) ; } } if ( [[kid]] == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( [[kid]] , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( [[kid]] , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .
--------------------------------------------- Result 766 ---------------------------------------------
Iterates over all beans of the given type . --> Parses an antonoion --> Socre: 1.0

[[[[Adv]]]]: public void [[forEachBeanType]] ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .

[[[[Adv]]]]: public void [[antónio]] ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .
--------------------------------------------- Result 767 ---------------------------------------------
Registers new init methods for the given bean . --> package private for testing --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String [[beanName]] , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( [[beanName]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int [[total]] = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ [[total]] ] ; int [[i]] ; for ( [[i]] = 0 ; [[i]] < initMethodNames . length ; [[i]] ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ [[i]] ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ [[i]] ] ) ; } initMethodPoints [ [[i]] ] = new InitMethodPoint ( md . getMethod ( ) , [[i]] , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String [[llll]] , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( [[llll]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int [[dickheads]] = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ [[dickheads]] ] ; int [[reliance]] ; for ( [[reliance]] = 0 ; [[reliance]] < initMethodNames . length ; [[reliance]] ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ [[reliance]] ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ [[reliance]] ] ) ; } initMethodPoints [ [[reliance]] ] = new InitMethodPoint ( md . getMethod ( ) , [[reliance]] , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .
--------------------------------------------- Result 768 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 608 / 142 / 18 / 768:  77%|███████▋  | 768/1000 [1:21:34<24:38,  6.37s/it][Succeeded / Failed / Skipped / Total] 608 / 142 / 18 / 768:  77%|███████▋  | 769/1000 [1:21:38<24:31,  6.37s/it][Succeeded / Failed / Skipped / Total] 609 / 142 / 18 / 769:  77%|███████▋  | 769/1000 [1:21:38<24:31,  6.37s/it][Succeeded / Failed / Skipped / Total] 609 / 142 / 18 / 769:  77%|███████▋  | 770/1000 [1:21:53<24:27,  6.38s/it][Succeeded / Failed / Skipped / Total] 610 / 142 / 18 / 770:  77%|███████▋  | 770/1000 [1:21:53<24:27,  6.38s/it][Succeeded / Failed / Skipped / Total] 610 / 142 / 18 / 770:  77%|███████▋  | 771/1000 [1:21:55<24:19,  6.38s/it][Succeeded / Failed / Skipped / Total] 611 / 142 / 18 / 771:  77%|███████▋  | 771/1000 [1:21:55<24:19,  6.38s/it][Succeeded / Failed / Skipped / Total] 611 / 142 / 18 / 771:  77%|███████▋  | 772/1000 [1:21:58<24:12,  6.37s/it][Succeeded / Failed / Skipped / Total] 612 / 142 / 18 / 772:  77%|███████▋  | 772/1000 [1:21:58<24:12,  6.37s/it][Succeeded / Failed / Skipped / Total] 612 / 142 / 18 / 772:  77%|███████▋  | 773/1000 [1:22:02<24:05,  6.37s/it][Succeeded / Failed / Skipped / Total] 613 / 142 / 18 / 773:  77%|███████▋  | 773/1000 [1:22:02<24:05,  6.37s/it][Succeeded / Failed / Skipped / Total] 613 / 142 / 18 / 773:  77%|███████▋  | 774/1000 [1:22:04<23:57,  6.36s/it][Succeeded / Failed / Skipped / Total] 614 / 142 / 18 / 774:  77%|███████▋  | 774/1000 [1:22:04<23:57,  6.36s/it][Succeeded / Failed / Skipped / Total] 614 / 142 / 18 / 774:  78%|███████▊  | 775/1000 [1:22:19<23:54,  6.37s/it]Defines a map of parameters . --> Loads aehler into aehler --> Socre: 1.0

[[[[Adv]]]]: public void [[defineParameters]] ( final Map < ? , ? > [[properties]] ) { for ( Map . Entry < ? , ? > entry : [[properties]] . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .

[[[[Adv]]]]: public void [[aeh]] ( final Map < ? , ? > [[chronicler]] ) { for ( Map . Entry < ? , ? > entry : [[chronicler]] . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .
--------------------------------------------- Result 769 ---------------------------------------------
Register a provider --> Add a player to this player --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteProvider]] ( final String providerName , final Class type , final String staticMethodName , final Class [ ] [[arguments]] ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor [[md]] = cd . getMethodDescriptor ( staticMethodName , [[arguments]] , "True" == "True" ) ; if ( [[md]] == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , [[md]] . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .

[[[[Adv]]]]: public void [[played]] ( final String providerName , final Class type , final String staticMethodName , final Class [ ] [[acquiesce]] ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor [[carnahan]] = cd . getMethodDescriptor ( staticMethodName , [[acquiesce]] , "True" == "True" ) ; if ( [[carnahan]] == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , [[carnahan]] . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .
--------------------------------------------- Result 770 ---------------------------------------------
Pushes an integer onto the stack . --> JACQ instructions --> Socre: 1.0

[[[[Adv]]]]: public static void [[pushInt]] ( final MethodVisitor [[mv]] , final int value ) { if ( value <= 5 ) { [[mv]] . visitInsn ( ICONST_0 + value ) ; } else if ( value <= Byte . MAX_VALUE ) { [[mv]] . visitIntInsn ( BIPUSH , value ) ; } else { [[mv]] . visitIntInsn ( SIPUSH , value ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .

[[[[Adv]]]]: public static void [[jacq]] ( final MethodVisitor [[henpecked]] , final int value ) { if ( value <= 5 ) { [[henpecked]] . visitInsn ( ICONST_0 + value ) ; } else if ( value <= Byte . MAX_VALUE ) { [[henpecked]] . visitIntInsn ( BIPUSH , value ) ; } else { [[henpecked]] . visitIntInsn ( SIPUSH , value ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .
--------------------------------------------- Result 771 ---------------------------------------------
Checks that the given index is valid . --> This method is used to check that the josce is valid --> Socre: 1.0

[[[[Adv]]]]: public static void checkArgumentIndex ( final MethodInfo methodInfo , final int [[argIndex]] ) { if ( ( [[argIndex]] < 1 ) || ( [[argIndex]] > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[argIndex]] ) ; } }
[[[[Nl]]]]: Validates argument index .

[[[[Adv]]]]: public static void checkArgumentIndex ( final MethodInfo methodInfo , final int [[josi]] ) { if ( ( [[josi]] < 1 ) || ( [[josi]] > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[josi]] ) ; } }
[[[[Nl]]]]: Validates argument index .
--------------------------------------------- Result 772 ---------------------------------------------
Get advice field name --> Borrowed with index --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceFieldName]] ( final String name , final int index ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + index ; }
[[[[Nl]]]]: Builds advice field name .

[[[[Adv]]]]: public static String [[embellish]] ( final String name , final int index ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + index ; }
[[[[Nl]]]]: Builds advice field name .
--------------------------------------------- Result 773 ---------------------------------------------
Intercepts the given action request . --> Intercept a biochemical request --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object intercept ( final ActionRequest actionRequest ) throws Exception { printBefore ( actionRequest ) ; long startTime = System . currentTimeMillis ( ) ; Object [[result]] = null ; try { [[result]] = actionRequest . invoke ( ) ; } catch ( Exception ex ) { [[result]] = "<exception>" ; throw ex ; } catch ( Throwable th ) { [[result]] = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( actionRequest , executionTime , [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Measure action invocation time .

[[[[Adv]]]]: @ Override public Object intercept ( final ActionRequest actionRequest ) throws Exception { printBefore ( actionRequest ) ; long startTime = System . currentTimeMillis ( ) ; Object [[biochemical]] = null ; try { [[biochemical]] = actionRequest . invoke ( ) ; } catch ( Exception ex ) { [[biochemical]] = "<exception>" ; throw ex ; } catch ( Throwable th ) { [[biochemical]] = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( actionRequest , executionTime , [[biochemical]] ) ; } return [[biochemical]] ; }
[[[[Nl]]]]: Measure action invocation time .
--------------------------------------------- Result 774 ---------------------------------------------
Registers a new destroy method for the specified bean . --> Define a twinview --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteDestroyMethods]] ( final String beanName , String ... destroyMethodNames ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + [[beanDefinition]] . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } [[beanDefinition]] . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .

[[[[Adv]]]]: public void [[doy]] ( final String beanName , String ... destroyMethodNames ) { BeanDefinition [[twinview]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[twinview]] . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + [[twinview]] . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } [[twinview]] . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .
[Succeeded / Failed / Skipped / Total] 615 / 142 / 18 / 775:  78%|███████▊  | 775/1000 [1:22:19<23:54,  6.37s/it][Succeeded / Failed / Skipped / Total] 615 / 142 / 18 / 775:  78%|███████▊  | 776/1000 [1:22:35<23:50,  6.39s/it][Succeeded / Failed / Skipped / Total] 616 / 142 / 18 / 776:  78%|███████▊  | 776/1000 [1:22:35<23:50,  6.39s/it][Succeeded / Failed / Skipped / Total] 616 / 142 / 18 / 776:  78%|███████▊  | 777/1000 [1:22:57<23:48,  6.41s/it][Succeeded / Failed / Skipped / Total] 617 / 142 / 18 / 777:  78%|███████▊  | 777/1000 [1:22:57<23:48,  6.41s/it][Succeeded / Failed / Skipped / Total] 617 / 142 / 18 / 777:  78%|███████▊  | 778/1000 [1:23:10<23:44,  6.42s/it][Succeeded / Failed / Skipped / Total] 618 / 142 / 18 / 778:  78%|███████▊  | 778/1000 [1:23:10<23:44,  6.42s/it][Succeeded / Failed / Skipped / Total] 618 / 142 / 18 / 778:  78%|███████▊  | 779/1000 [1:23:16<23:37,  6.41s/it][Succeeded / Failed / Skipped / Total] 619 / 142 / 18 / 779:  78%|███████▊  | 779/1000 [1:23:16<23:37,  6.41s/it][Succeeded / Failed / Skipped / Total] 619 / 142 / 18 / 779:  78%|███████▊  | 780/1000 [1:23:17<23:29,  6.41s/it][Succeeded / Failed / Skipped / Total] 619 / 143 / 18 / 780:  78%|███████▊  | 780/1000 [1:23:17<23:29,  6.41s/it][Succeeded / Failed / Skipped / Total] 619 / 143 / 18 / 780:  78%|███████▊  | 781/1000 [1:23:25<23:23,  6.41s/it][Succeeded / Failed / Skipped / Total] 620 / 143 / 18 / 781:  78%|███████▊  | 781/1000 [1:23:25<23:23,  6.41s/it][Succeeded / Failed / Skipped / Total] 620 / 143 / 18 / 781:  78%|███████▊  | 782/1000 [1:23:58<23:24,  6.44s/it]--------------------------------------------- Result 775 ---------------------------------------------
Resolves java version . --> also used for testing --> Socre: 1.0

[[[[Adv]]]]: public static int [[resolveJavaVersion]] ( final int [[version]] ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int platformVersion = javaVersionNumber - 8 + 52 ; return [[version]] > platformVersion ? [[version]] : platformVersion ; }
[[[[Nl]]]]: Resolves Java version from current version .

[[[[Adv]]]]: public static int [[iyo]] ( final int [[asylum]] ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int platformVersion = javaVersionNumber - 8 + 52 ; return [[asylum]] > platformVersion ? [[asylum]] : platformVersion ; }
[[[[Nl]]]]: Resolves Java version from current version .
--------------------------------------------- Result 776 ---------------------------------------------
Get advice method name . --> Provides key with Peekt --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceMethodName]] ( final String name , final int [[index]] ) { return ProxettaNames . methodPrefix + name + ProxettaNames . methodDivider + [[index]] ; }
[[[[Nl]]]]: Builds advice method name .

[[[[Adv]]]]: public static String [[pedestals]] ( final String name , final int [[chon]] ) { return ProxettaNames . methodPrefix + name + ProxettaNames . methodDivider + [[chon]] ; }
[[[[Nl]]]]: Builds advice method name .
--------------------------------------------- Result 777 ---------------------------------------------
Prepare return value . --> generate bola --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareReturnValue]] ( final MethodVisitor mv , final MethodInfo methodInfo , int varOffset ) { varOffset += methodInfo . getAllArgumentsSize ( ) ; switch ( methodInfo . getReturnType ( ) . getOpcode ( ) ) { case ' ' : mv . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( mv ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( mv ) ; break ; case ' ' : AsmUtil . valueOfShort ( mv ) ; break ; case ' ' : AsmUtil . valueOfInteger ( mv ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( mv ) ; break ; case ' ' : AsmUtil . valueOfLong ( mv ) ; break ; case ' ' : AsmUtil . valueOfFloat ( mv ) ; break ; case ' ' : AsmUtil . valueOfDouble ( mv ) ; break ; } }
[[[[Nl]]]]: Prepares return value .

[[[[Adv]]]]: public static void [[bola]] ( final MethodVisitor mv , final MethodInfo methodInfo , int varOffset ) { varOffset += methodInfo . getAllArgumentsSize ( ) ; switch ( methodInfo . getReturnType ( ) . getOpcode ( ) ) { case ' ' : mv . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( mv ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( mv ) ; break ; case ' ' : AsmUtil . valueOfShort ( mv ) ; break ; case ' ' : AsmUtil . valueOfInteger ( mv ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( mv ) ; break ; case ' ' : AsmUtil . valueOfLong ( mv ) ; break ; case ' ' : AsmUtil . valueOfFloat ( mv ) ; break ; case ' ' : AsmUtil . valueOfDouble ( mv ) ; break ; } }
[[[[Nl]]]]: Prepares return value .
--------------------------------------------- Result 778 ---------------------------------------------
Load method arguments . --> Methode deactivation --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadSpecialMethodArguments]] ( final MethodVisitor mv , final MethodInfo methodInfo ) { mv . visitVarInsn ( ALOAD , 0 ) ; for ( int [[i]] = 1 ; [[i]] <= methodInfo . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( mv , methodInfo , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .

[[[[Adv]]]]: public static void [[martín]] ( final MethodVisitor mv , final MethodInfo methodInfo ) { mv . visitVarInsn ( ALOAD , 0 ) ; for ( int [[acquiesce]] = 1 ; [[acquiesce]] <= methodInfo . getArgumentsCount ( ) ; [[acquiesce]] ++ ) { loadMethodArgument ( mv , methodInfo , [[acquiesce]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .
--------------------------------------------- Result 779 ---------------------------------------------
Creates a signature key . --> Generate a clicker --> Socre: 1.0

[[[[Adv]]]]: public static String [[createMethodSignaturesKey]] ( final int access , final String methodName , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( methodName ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .

[[[[Adv]]]]: public static String [[clicker]] ( final int access , final String methodName , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( methodName ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .
--------------------------------------------- Result 780 ---------------------------------------------
Load static method arguments . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[loadStaticMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] ) { for ( int i = 0 ; i < [[methodInfo]] . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[mv]] , [[methodInfo]] , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .

[[[[Adv]]]]: public static void [[v]] ( final MethodVisitor [[blend]] , final MethodInfo [[addictions]] ) { for ( int i = 0 ; i < [[addictions]] . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[blend]] , [[addictions]] , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .
--------------------------------------------- Result 781 ---------------------------------------------
Load the arguments of the method . --> Assigns an agent to anton --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadVirtualMethodArguments]] ( final MethodVisitor mv , final MethodInfo [[methodInfo]] ) { for ( int [[i]] = 1 ; [[i]] <= [[methodInfo]] . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( mv , [[methodInfo]] , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .

[[[[Adv]]]]: public static void [[antónio]] ( final MethodVisitor mv , final MethodInfo [[carburetors]] ) { for ( int [[perfect]] = 1 ; [[perfect]] <= [[carburetors]] . getArgumentsCount ( ) ; [[perfect]] ++ ) { loadMethodArgument ( mv , [[carburetors]] , [[perfect]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .
--------------------------------------------- Result 782 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 621 / 143 / 18 / 782:  78%|███████▊  | 782/1000 [1:23:58<23:24,  6.44s/it][Succeeded / Failed / Skipped / Total] 621 / 143 / 18 / 782:  78%|███████▊  | 783/1000 [1:23:58<23:16,  6.44s/it][Succeeded / Failed / Skipped / Total] 622 / 143 / 18 / 783:  78%|███████▊  | 783/1000 [1:23:58<23:16,  6.44s/it][Succeeded / Failed / Skipped / Total] 622 / 143 / 18 / 783:  78%|███████▊  | 784/1000 [1:24:01<23:08,  6.43s/it][Succeeded / Failed / Skipped / Total] 623 / 143 / 18 / 784:  78%|███████▊  | 784/1000 [1:24:01<23:08,  6.43s/it][Succeeded / Failed / Skipped / Total] 623 / 143 / 18 / 784:  78%|███████▊  | 785/1000 [1:24:01<23:00,  6.42s/it]Store instruction into array . --> Methode permettant --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeIntoArray]] ( final MethodVisitor mv , final Class [[componentType]] ) { if ( [[componentType]] == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( [[componentType]] == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( [[componentType]] == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( [[componentType]] == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( [[componentType]] == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[componentType]] == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( [[componentType]] == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[componentType]] == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .

[[[[Adv]]]]: public static void [[amaro]] ( final MethodVisitor mv , final Class [[brimley]] ) { if ( [[brimley]] == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( [[brimley]] == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( [[brimley]] == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( [[brimley]] == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( [[brimley]] == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[brimley]] == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( [[brimley]] == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( [[brimley]] == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .
--------------------------------------------- Result 783 ---------------------------------------------
Generate new array --> This is a helper method to cull from scratch --> Socre: 1.0

[[[[Adv]]]]: public static void [[newArray]] ( final MethodVisitor mv , final Class [[componentType]] ) { if ( [[componentType]] == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[componentType]] == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[componentType]] == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[componentType]] == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[componentType]] == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[componentType]] == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[componentType]] == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[componentType]] == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[componentType]] ) ) ; }
[[[[Nl]]]]: Creates new array .

[[[[Adv]]]]: public static void [[butte]] ( final MethodVisitor mv , final Class [[desolate]] ) { if ( [[desolate]] == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[desolate]] == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[desolate]] == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[desolate]] == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[desolate]] == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[desolate]] == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[desolate]] == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[desolate]] == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[desolate]] ) ) ; }
[[[[Nl]]]]: Creates new array .
--------------------------------------------- Result 784 ---------------------------------------------
Load method argument . --> Generate a bload --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadMethodArgument]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int [[offset]] = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , [[offset]] ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , [[offset]] ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , [[offset]] ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , [[offset]] ) ; break ; default : mv . visitVarInsn ( ALOAD , [[offset]] ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[bruner]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int [[aussi]] = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , [[aussi]] ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , [[aussi]] ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , [[aussi]] ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , [[aussi]] ) ; break ; default : mv . visitVarInsn ( ALOAD , [[aussi]] ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 785 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 624 / 143 / 18 / 785:  78%|███████▊  | 785/1000 [1:24:01<23:00,  6.42s/it][Succeeded / Failed / Skipped / Total] 624 / 143 / 18 / 785:  79%|███████▊  | 786/1000 [1:24:07<22:54,  6.42s/it][Succeeded / Failed / Skipped / Total] 625 / 143 / 18 / 786:  79%|███████▊  | 786/1000 [1:24:07<22:54,  6.42s/it][Succeeded / Failed / Skipped / Total] 625 / 143 / 18 / 786:  79%|███████▊  | 787/1000 [1:24:11<22:47,  6.42s/it][Succeeded / Failed / Skipped / Total] 626 / 143 / 18 / 787:  79%|███████▊  | 787/1000 [1:24:11<22:47,  6.42s/it][Succeeded / Failed / Skipped / Total] 626 / 143 / 18 / 787:  79%|███████▉  | 788/1000 [1:24:20<22:41,  6.42s/it][Succeeded / Failed / Skipped / Total] 627 / 143 / 18 / 788:  79%|███████▉  | 788/1000 [1:24:20<22:41,  6.42s/it][Succeeded / Failed / Skipped / Total] 627 / 143 / 18 / 788:  79%|███████▉  | 789/1000 [1:24:24<22:34,  6.42s/it][Succeeded / Failed / Skipped / Total] 628 / 143 / 18 / 789:  79%|███████▉  | 789/1000 [1:24:24<22:34,  6.42s/it][Succeeded / Failed / Skipped / Total] 628 / 143 / 18 / 789:  79%|███████▉  | 790/1000 [1:24:31<22:28,  6.42s/it]Registers a new method for the given bean . --> Highlight a given bean with a cell block --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteMethodInjectionPoint]] ( final String beanName , final String [[methodName]] , final Class [ ] [[arguments]] , final String [ ] [[references]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( [[arguments]] == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( [[methodName]] ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + [[methodName]] ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( [[methodName]] , [[arguments]] , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + [[methodName]] ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , [[references]] ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .

[[[[Adv]]]]: public void [[beckham]] ( final String beanName , final String [[darkie]] , final Class [ ] [[cellblock]] , final String [ ] [[eliminated]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( [[cellblock]] == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( [[darkie]] ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + [[darkie]] ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( [[darkie]] , [[cellblock]] , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + [[darkie]] ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , [[eliminated]] ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .
--------------------------------------------- Result 786 ---------------------------------------------
Store method argument . --> also used in tests --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeMethodArgument]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int [[offset]] = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , [[offset]] ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , [[offset]] ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , [[offset]] ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , [[offset]] ) ; break ; default : mv . visitVarInsn ( ASTORE , [[offset]] ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[aigoo]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int [[burdette]] = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , [[burdette]] ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , [[burdette]] ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , [[burdette]] ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , [[burdette]] ) ; break ; default : mv . visitVarInsn ( ASTORE , [[burdette]] ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 787 ---------------------------------------------
Returns true if any flags are empty . --> Liefert die uebergebenen Methode . --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isEmptyFlags]] ( Flags flags ) { if ( flags == null ) return "[[True]]" == "[[True]]" ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = flags . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Check whether flags is a empty flags

[[[[Adv]]]]: public static boolean [[krueger]] ( Flags flags ) { if ( flags == null ) return "[[Apéritif]]" == "[[Apéritif]]" ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = flags . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "[[Apéritif]]" == "[[Apéritif]]" ; }
[[[[Nl]]]]: Check whether flags is a empty flags
--------------------------------------------- Result 788 ---------------------------------------------
Resolve the OAuth bearer token . --> Creates a string that will be used for all the adjectives --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveAuthBearerToken]] ( final HttpServletRequest request ) { String header = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( header == null ) { return null ; } int ndx = header . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return header . substring ( ndx + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .

[[[[Adv]]]]: public static String [[clichés]] ( final HttpServletRequest request ) { String header = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( header == null ) { return null ; } int ndx = header . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return header . substring ( ndx + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .
--------------------------------------------- Result 789 ---------------------------------------------
Prepares the response with the given file name and size . --> Sets the Stephane --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareResponse]] ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String extension = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( extension ) ; } if ( mimeType != null ) { response . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { response . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .

[[[[Adv]]]]: public static void [[stéphane]] ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String extension = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( extension ) ; } if ( mimeType != null ) { response . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { response . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .
--------------------------------------------- Result 790 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 629 / 143 / 18 / 790:  79%|███████▉  | 790/1000 [1:24:31<22:28,  6.42s/it][Succeeded / Failed / Skipped / Total] 629 / 143 / 18 / 790:  79%|███████▉  | 791/1000 [1:24:42<22:22,  6.43s/it][Succeeded / Failed / Skipped / Total] 630 / 143 / 18 / 791:  79%|███████▉  | 791/1000 [1:24:42<22:22,  6.43s/it][Succeeded / Failed / Skipped / Total] 630 / 143 / 18 / 791:  79%|███████▉  | 792/1000 [1:24:56<22:18,  6.44s/it][Succeeded / Failed / Skipped / Total] 630 / 144 / 18 / 792:  79%|███████▉  | 792/1000 [1:24:56<22:18,  6.44s/it][Succeeded / Failed / Skipped / Total] 630 / 144 / 18 / 792:  79%|███████▉  | 793/1000 [1:25:00<22:11,  6.43s/it][Succeeded / Failed / Skipped / Total] 631 / 144 / 18 / 793:  79%|███████▉  | 793/1000 [1:25:00<22:11,  6.43s/it][Succeeded / Failed / Skipped / Total] 631 / 144 / 18 / 793:  79%|███████▉  | 794/1000 [1:25:07<22:05,  6.43s/it][Succeeded / Failed / Skipped / Total] 632 / 144 / 18 / 794:  79%|███████▉  | 794/1000 [1:25:07<22:05,  6.43s/it][Succeeded / Failed / Skipped / Total] 632 / 144 / 18 / 794:  80%|███████▉  | 795/1000 [1:25:14<21:58,  6.43s/it][Succeeded / Failed / Skipped / Total] 633 / 144 / 18 / 795:  80%|███████▉  | 795/1000 [1:25:14<21:58,  6.43s/it][Succeeded / Failed / Skipped / Total] 633 / 144 / 18 / 795:  80%|███████▉  | 796/1000 [1:25:22<21:52,  6.44s/it][Succeeded / Failed / Skipped / Total] 634 / 144 / 18 / 796:  80%|███████▉  | 796/1000 [1:25:22<21:52,  6.44s/it][Succeeded / Failed / Skipped / Total] 634 / 144 / 18 / 796:  80%|███████▉  | 797/1000 [1:25:26<21:45,  6.43s/it]Read request body from a reader --> Get alhambra --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromReader]] ( final HttpServletRequest request ) throws IOException { BufferedReader buff = request . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( buff , out ) ; return out . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[alhambra]] ( final HttpServletRequest request ) throws IOException { BufferedReader buff = request . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( buff , out ) ; return out . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!
--------------------------------------------- Result 791 ---------------------------------------------
Read request body from request --> Hack for testing --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromStream]] ( final HttpServletRequest request ) throws IOException { String charEncoding = request . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = request . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[hacksaw]] ( final HttpServletRequest request ) throws IOException { String charEncoding = request . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = request . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!
--------------------------------------------- Result 792 ---------------------------------------------
Require authentication . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[requireAuthentication]] ( final HttpServletResponse [[resp]] , final String realm ) throws IOException { [[resp]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; [[resp]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .

[[[[Adv]]]]: public static void [[heartening]] ( final HttpServletResponse [[poverty]] , final String realm ) throws IOException { [[poverty]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; [[poverty]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .
--------------------------------------------- Result 793 ---------------------------------------------
Extracts encoding from content type --> return the ktv element --> Socre: 1.0

[[[[Adv]]]]: public static String [[extractEncoding]] ( final String [[contentType]] , String defaultEncoding ) { String encoding = [[extractEncoding]] ( [[contentType]] ) ; if ( encoding == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ; } encoding = defaultEncoding ; } return encoding ; }
[[[[Nl]]]]: Extracts encoding from a given content type .

[[[[Adv]]]]: public static String [[ktv]] ( final String [[henpecked]] , String defaultEncoding ) { String encoding = [[ktv]] ( [[henpecked]] ) ; if ( encoding == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ; } encoding = defaultEncoding ; } return encoding ; }
[[[[Nl]]]]: Extracts encoding from a given content type .
--------------------------------------------- Result 794 ---------------------------------------------
Checks if is a GET parameter . --> for test --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isGetParameter]] ( final HttpServletRequest request , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( name ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .

[[[[Adv]]]]: public boolean [[città]] ( final HttpServletRequest request , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( name ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .
--------------------------------------------- Result 795 ---------------------------------------------
Stores the current context path . --> Distended from ServletContext --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeContextPath]] ( final ServletContext servletContext , final String [[contextPathVariableName]] ) { String ctxPath = getContextPath ( servletContext ) ; servletContext . setAttribute ( [[contextPathVariableName]] , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .

[[[[Adv]]]]: public static void [[distended]] ( final ServletContext servletContext , final String [[prod]] ) { String ctxPath = getContextPath ( servletContext ) ; servletContext . setAttribute ( [[prod]] , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .
--------------------------------------------- Result 796 ---------------------------------------------
Prepare query parameters . --> Restore empty parameter values --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] [[prepareParameters]] ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { if ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int i = 0 ; i < paramValues . length ; i ++ ) { String paramValue = paramValues [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { paramValue = null ; } } paramValues [ i ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .

[[[[Adv]]]]: public static String [ ] [[arrack]] ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { if ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int i = 0 ; i < paramValues . length ; i ++ ) { String paramValue = paramValues [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { paramValue = null ; } } paramValues [ i ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .
--------------------------------------------- Result 797 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 635 / 144 / 18 / 797:  80%|███████▉  | 797/1000 [1:25:26<21:45,  6.43s/it][Succeeded / Failed / Skipped / Total] 635 / 144 / 18 / 797:  80%|███████▉  | 798/1000 [1:25:41<21:41,  6.44s/it][Succeeded / Failed / Skipped / Total] 636 / 144 / 18 / 798:  80%|███████▉  | 798/1000 [1:25:41<21:41,  6.44s/it][Succeeded / Failed / Skipped / Total] 636 / 144 / 18 / 798:  80%|███████▉  | 799/1000 [1:25:45<21:34,  6.44s/it][Succeeded / Failed / Skipped / Total] 637 / 144 / 18 / 799:  80%|███████▉  | 799/1000 [1:25:45<21:34,  6.44s/it][Succeeded / Failed / Skipped / Total] 637 / 144 / 18 / 799:  80%|████████  | 800/1000 [1:25:47<21:26,  6.43s/it][Succeeded / Failed / Skipped / Total] 638 / 144 / 18 / 800:  80%|████████  | 800/1000 [1:25:47<21:26,  6.43s/it][Succeeded / Failed / Skipped / Total] 638 / 144 / 18 / 800:  80%|████████  | 801/1000 [1:25:55<21:20,  6.44s/it][Succeeded / Failed / Skipped / Total] 639 / 144 / 18 / 801:  80%|████████  | 801/1000 [1:25:55<21:20,  6.44s/it][Succeeded / Failed / Skipped / Total] 639 / 144 / 18 / 801:  80%|████████  | 802/1000 [1:26:07<21:15,  6.44s/it][Succeeded / Failed / Skipped / Total] 640 / 144 / 18 / 802:  80%|████████  | 802/1000 [1:26:07<21:15,  6.44s/it][Succeeded / Failed / Skipped / Total] 640 / 144 / 18 / 802:  80%|████████  | 803/1000 [1:26:07<21:07,  6.44s/it][Succeeded / Failed / Skipped / Total] 641 / 144 / 18 / 803:  80%|████████  | 803/1000 [1:26:07<21:07,  6.44s/it][Succeeded / Failed / Skipped / Total] 641 / 144 / 18 / 803:  80%|████████  | 804/1000 [1:26:07<20:59,  6.43s/it][Succeeded / Failed / Skipped / Total] 641 / 144 / 19 / 804:  80%|████████  | 804/1000 [1:26:07<20:59,  6.43s/it][Succeeded / Failed / Skipped / Total] 641 / 144 / 19 / 804:  80%|████████  | 805/1000 [1:26:09<20:52,  6.42s/it]Prepares a download . --> Generate an arranger model --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareDownload]] ( final HttpServletResponse [[response]] , final File file , final String [[mimeType]] ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + file ) ; } if ( file . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + file ) ; } prepareResponse ( [[response]] , file . getAbsolutePath ( ) , [[mimeType]] , ( int ) file . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .

[[[[Adv]]]]: public static void [[arranger]] ( final HttpServletResponse [[autographs]] , final File file , final String [[civvy]] ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + file ) ; } if ( file . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + file ) ; } prepareResponse ( [[autographs]] , file . getAbsolutePath ( ) , [[civvy]] , ( int ) file . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .
--------------------------------------------- Result 798 ---------------------------------------------
Render the body to a String . --> Render the subtitle --> Socre: 1.0

[[[[Adv]]]]: public static String renderBodyToString ( final JspFragment body ) throws JspException { char [ ] [[result]] = renderBody ( body ) ; return new String ( [[result]] ) ; }
[[[[Nl]]]]: Renders tag body to string .

[[[[Adv]]]]: public static String renderBodyToString ( final JspFragment body ) throws JspException { char [ ] [[subtitle]] = renderBody ( body ) ; return new String ( [[subtitle]] ) ; }
[[[[Nl]]]]: Renders tag body to string .
--------------------------------------------- Result 799 ---------------------------------------------
Copies request parameters to attributes . --> generate interdement --> Socre: 1.0

[[[[Adv]]]]: public static void [[copyParamsToAttributes]] ( final HttpServletRequest [[servletRequest]] , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = [[servletRequest]] . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( [[servletRequest]] . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = [[servletRequest]] . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } [[servletRequest]] . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .

[[[[Adv]]]]: public static void [[interdiction]] ( final HttpServletRequest [[gagné]] , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = [[gagné]] . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( [[gagné]] . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = [[gagné]] . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } [[gagné]] . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .
--------------------------------------------- Result 800 ---------------------------------------------
Invokes the body of the tag . --> This method must be called immediately --> Socre: 1.0

[[[[Adv]]]]: public static void [[invokeBody]] ( final JspFragment [[body]] ) throws JspException { if ( [[body]] == null ) { return ; } try { [[body]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .

[[[[Adv]]]]: public static void [[dostoyevsky]] ( final JspFragment [[apparently]] ) throws JspException { if ( [[apparently]] == null ) { return ; } try { [[apparently]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .
--------------------------------------------- Result 801 ---------------------------------------------
Renders the given body into a char array . --> Render the HTML fragment --> Socre: 1.0

[[[[Adv]]]]: public static char [ ] renderBody ( final JspFragment [[body]] ) throws JspException { FastCharArrayWriter [[writer]] = new FastCharArrayWriter ( ) ; invokeBody ( [[body]] , [[writer]] ) ; return [[writer]] . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .

[[[[Adv]]]]: public static char [ ] renderBody ( final JspFragment [[embellish]] ) throws JspException { FastCharArrayWriter [[milou]] = new FastCharArrayWriter ( ) ; invokeBody ( [[embellish]] , [[milou]] ) ; return [[milou]] . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .
--------------------------------------------- Result 802 ---------------------------------------------
Create new bean instance . --> Return the prototype of this bean --> Socre: 1.0

[[[[Adv]]]]: public Object [[newBeanInstance]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .

[[[[Adv]]]]: public Object [[astro]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .
--------------------------------------------- Result 803 ---------------------------------------------
Inject parameters . --> Borigine method --> Socre: 1.0

[[[[Adv]]]]: public void [[injectParams]] ( final ParamManager paramManager , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) {
[[[[Nl]]]]: Injects all parameters .

[[[[Adv]]]]: public void [[aborigine]] ( final ParamManager paramManager , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) {
[[[[Nl]]]]: Injects all parameters .
--------------------------------------------- Result 804 ---------------------------------------------
Put a single entry . --> [[[SKIPPED]]]

[[[[Adv]]]]: protected void put ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String realValue = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties
--------------------------------------------- Result 805 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 642 / 144 / 19 / 805:  80%|████████  | 805/1000 [1:26:09<20:52,  6.42s/it][Succeeded / Failed / Skipped / Total] 642 / 144 / 19 / 805:  81%|████████  | 806/1000 [1:26:10<20:44,  6.41s/it][Succeeded / Failed / Skipped / Total] 643 / 144 / 19 / 806:  81%|████████  | 806/1000 [1:26:10<20:44,  6.41s/it][Succeeded / Failed / Skipped / Total] 643 / 144 / 19 / 806:  81%|████████  | 807/1000 [1:26:13<20:37,  6.41s/it][Succeeded / Failed / Skipped / Total] 643 / 145 / 19 / 807:  81%|████████  | 807/1000 [1:26:13<20:37,  6.41s/it][Succeeded / Failed / Skipped / Total] 643 / 145 / 19 / 807:  81%|████████  | 808/1000 [1:26:19<20:30,  6.41s/it][Succeeded / Failed / Skipped / Total] 644 / 145 / 19 / 808:  81%|████████  | 808/1000 [1:26:19<20:30,  6.41s/it][Succeeded / Failed / Skipped / Total] 644 / 145 / 19 / 808:  81%|████████  | 809/1000 [1:26:28<20:24,  6.41s/it][Succeeded / Failed / Skipped / Total] 645 / 145 / 19 / 809:  81%|████████  | 809/1000 [1:26:28<20:24,  6.41s/it][Succeeded / Failed / Skipped / Total] 645 / 145 / 19 / 809:  81%|████████  | 810/1000 [1:26:29<20:17,  6.41s/it][Succeeded / Failed / Skipped / Total] 646 / 145 / 19 / 810:  81%|████████  | 810/1000 [1:26:29<20:17,  6.41s/it][Succeeded / Failed / Skipped / Total] 646 / 145 / 19 / 810:  81%|████████  | 811/1000 [1:26:30<20:09,  6.40s/it][Succeeded / Failed / Skipped / Total] 647 / 145 / 19 / 811:  81%|████████  | 811/1000 [1:26:30<20:09,  6.40s/it][Succeeded / Failed / Skipped / Total] 647 / 145 / 19 / 811:  81%|████████  | 812/1000 [1:26:33<20:02,  6.40s/it][Succeeded / Failed / Skipped / Total] 648 / 145 / 19 / 812:  81%|████████  | 812/1000 [1:26:33<20:02,  6.40s/it][Succeeded / Failed / Skipped / Total] 648 / 145 / 19 / 812:  81%|████████▏ | 813/1000 [1:26:43<19:56,  6.40s/it][Succeeded / Failed / Skipped / Total] 649 / 145 / 19 / 813:  81%|████████▏ | 813/1000 [1:26:43<19:56,  6.40s/it][Succeeded / Failed / Skipped / Total] 649 / 145 / 19 / 813:  81%|████████▏ | 814/1000 [1:26:54<19:51,  6.41s/it]Stores the current context path into the request context . --> generate a chronicle --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeContextPath]] ( final PageContext [[pageContext]] , final String [[contextPathVariableName]] ) { String ctxPath = getContextPath ( [[pageContext]] ) ; HttpServletRequest [[request]] = ( HttpServletRequest ) [[pageContext]] . getRequest ( ) ; [[request]] . setAttribute ( [[contextPathVariableName]] , ctxPath ) ; ServletContext servletContext = [[pageContext]] . getServletContext ( ) ; servletContext . setAttribute ( [[contextPathVariableName]] , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .

[[[[Adv]]]]: public static void [[chronicle]] ( final PageContext [[manoel]] , final String [[gagné]] ) { String ctxPath = getContextPath ( [[manoel]] ) ; HttpServletRequest [[safeguard]] = ( HttpServletRequest ) [[manoel]] . getRequest ( ) ; [[safeguard]] . setAttribute ( [[gagné]] , ctxPath ) ; ServletContext servletContext = [[manoel]] . getServletContext ( ) ; servletContext . setAttribute ( [[gagné]] , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .
--------------------------------------------- Result 806 ---------------------------------------------
Invokes init init methods --> Invoke providers with the given scopes --> Socre: 1.0

[[[[Adv]]]]: public void [[invokeInitMethods]] ( final InitMethodInvocationStrategy [[invocationStrategy]] ) { for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { if ( [[invocationStrategy]] != initMethod . invocationStrategy ) { continue ; } try { initMethod . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + initMethod , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .

[[[[Adv]]]]: public void [[providers]] ( final InitMethodInvocationStrategy [[scatters]] ) { for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { if ( [[scatters]] != initMethod . invocationStrategy ) { continue ; } try { initMethod . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + initMethod , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .
--------------------------------------------- Result 807 ---------------------------------------------
Get all cookies with the given name . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookie [ ] [[getAllCookies]] ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( cookies . length ) ; for ( Cookie cookie : cookies ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { list . add ( cookie ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .

[[[[Adv]]]]: public static Cookie [ ] [[psychotherapist]] ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( cookies . length ) ; for ( Cookie cookie : cookies ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { list . add ( cookie ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .
--------------------------------------------- Result 808 ---------------------------------------------
Calls all the destroy methods on the bean . --> Invokes tau --> Socre: 1.0

[[[[Adv]]]]: public void [[callDestroyMethods]] ( ) { for ( final DestroyMethodPoint [[destroyMethodPoint]] : beanDefinition . destroyMethodPoints ( ) ) { try { [[destroyMethodPoint]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + [[destroyMethodPoint]] . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .

[[[[Adv]]]]: public void [[tau]] ( ) { for ( final DestroyMethodPoint [[fon]] : beanDefinition . destroyMethodPoints ( ) ) { try { [[fon]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + [[fon]] . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .
--------------------------------------------- Result 809 ---------------------------------------------
Put a base property . --> Add an option to the map --> Socre: 1.0

[[[[Adv]]]]: public void [[putBaseProperty]] ( final String key , final String value , final boolean append ) { put ( null , baseProperties , key , value , append ) ; }
[[[[Nl]]]]: Adds base property .

[[[[Adv]]]]: public void [[sailfish]] ( final String key , final String value , final boolean append ) { put ( null , baseProperties , key , value , append ) ; }
[[[[Nl]]]]: Adds base property .
--------------------------------------------- Result 810 ---------------------------------------------
Put profile . --> Add a key to the cluster --> Socre: 1.0

[[[[Adv]]]]: public void [[putProfileProperty]] ( final String key , final String value , final String profile , final boolean append ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , map , key , value , append ) ; }
[[[[Nl]]]]: Adds profile property .

[[[[Adv]]]]: public void [[swimsuit]] ( final String key , final String value , final String profile , final boolean append ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , map , key , value , append ) ; }
[[[[Nl]]]]: Adds profile property .
--------------------------------------------- Result 811 ---------------------------------------------
Get profile from profile --> Get espy props --> Socre: 1.0

[[[[Adv]]]]: public PropsEntry [[getProfileProperty]] ( final String profile , final String key ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( profile ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( key ) ; }
[[[[Nl]]]]: Returns profile property .

[[[[Adv]]]]: public PropsEntry [[espy]] ( final String profile , final String key ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( profile ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( key ) ; }
[[[[Nl]]]]: Returns profile property .
--------------------------------------------- Result 812 ---------------------------------------------
Resolve macro macros . --> Hook for HANNO --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveMacros]] ( String value , final String ... profiles ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .

[[[[Adv]]]]: public String [[hanne]] ( String value , final String ... profiles ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .
--------------------------------------------- Result 813 ---------------------------------------------
Rewrite the given action path . --> Convenience method for setting a bridal request --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String [[rewrite]] ( final HttpServletRequest servletRequest , final String [[actionPath]] , final String httpMethod ) { return [[actionPath]] ; }
[[[[Nl]]]]: Rewrites action path .

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String [[butte]] ( final HttpServletRequest servletRequest , final String [[bridal]] , final String httpMethod ) { return [[bridal]] ; }
[[[[Nl]]]]: Rewrites action path .
--------------------------------------------- Result 814 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 650 / 145 / 19 / 814:  81%|████████▏ | 814/1000 [1:26:54<19:51,  6.41s/it][Succeeded / Failed / Skipped / Total] 650 / 145 / 19 / 814:  82%|████████▏ | 815/1000 [1:26:54<19:43,  6.40s/it][Succeeded / Failed / Skipped / Total] 651 / 145 / 19 / 815:  82%|████████▏ | 815/1000 [1:26:54<19:43,  6.40s/it][Succeeded / Failed / Skipped / Total] 651 / 145 / 19 / 815:  82%|████████▏ | 816/1000 [1:27:07<19:38,  6.41s/it][Succeeded / Failed / Skipped / Total] 652 / 145 / 19 / 816:  82%|████████▏ | 816/1000 [1:27:07<19:38,  6.41s/it][Succeeded / Failed / Skipped / Total] 652 / 145 / 19 / 816:  82%|████████▏ | 817/1000 [1:27:10<19:31,  6.40s/it][Succeeded / Failed / Skipped / Total] 653 / 145 / 19 / 817:  82%|████████▏ | 817/1000 [1:27:10<19:31,  6.40s/it][Succeeded / Failed / Skipped / Total] 653 / 145 / 19 / 817:  82%|████████▏ | 818/1000 [1:27:23<19:26,  6.41s/it][Succeeded / Failed / Skipped / Total] 654 / 145 / 19 / 818:  82%|████████▏ | 818/1000 [1:27:23<19:26,  6.41s/it][Succeeded / Failed / Skipped / Total] 654 / 145 / 19 / 818:  82%|████████▏ | 819/1000 [1:27:36<19:21,  6.42s/it][Succeeded / Failed / Skipped / Total] 655 / 145 / 19 / 819:  82%|████████▏ | 819/1000 [1:27:36<19:21,  6.42s/it][Succeeded / Failed / Skipped / Total] 655 / 145 / 19 / 819:  82%|████████▏ | 820/1000 [1:27:36<19:13,  6.41s/it][Succeeded / Failed / Skipped / Total] 656 / 145 / 19 / 820:  82%|████████▏ | 820/1000 [1:27:36<19:13,  6.41s/it][Succeeded / Failed / Skipped / Total] 656 / 145 / 19 / 820:  82%|████████▏ | 821/1000 [1:27:37<19:06,  6.40s/it][Succeeded / Failed / Skipped / Total] 657 / 145 / 19 / 821:  82%|████████▏ | 821/1000 [1:27:37<19:06,  6.40s/it][Succeeded / Failed / Skipped / Total] 657 / 145 / 19 / 821:  82%|████████▏ | 822/1000 [1:27:56<19:02,  6.42s/it]Convert a 4 - byte word to a 32 - bit word . --> convert 4 bytes to an unsigned integer --> Socre: 1.0

[[[[Adv]]]]: private static int streamtoword ( byte [ ] data , int [ ] offp ) { int i ; int [[word]] = 0 ; int off = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { [[word]] = ( [[word]] << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return [[word]] ; }
[[[[Nl]]]]: Cycically extract a word of key material .

[[[[Adv]]]]: private static int streamtoword ( byte [ ] data , int [ ] offp ) { int i ; int [[omer]] = 0 ; int off = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { [[omer]] = ( [[omer]] << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return [[omer]] ; }
[[[[Nl]]]]: Cycically extract a word of key material .
--------------------------------------------- Result 815 ---------------------------------------------
Copies all characters from the stream into the output stream . --> Writes canoodling --> Socre: 1.0

[[[[Adv]]]]: public int [[copyAll]] ( final OutputStream out ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .

[[[[Adv]]]]: public int [[canoodling]] ( final OutputStream out ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .
--------------------------------------------- Result 816 ---------------------------------------------
Copies bytes from the input stream to the output stream . --> copied from earphones --> Socre: 1.0

[[[[Adv]]]]: public int copyMax ( final OutputStream [[out]] , final int maxBytes ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } [[out]] . write ( b ) ; count ++ ; if ( count == maxBytes ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .

[[[[Adv]]]]: public int copyMax ( final OutputStream [[earphones]] , final int maxBytes ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } [[earphones]] . write ( b ) ; count ++ ; if ( count == maxBytes ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .
--------------------------------------------- Result 817 ---------------------------------------------
Adds a header . --> Add one or more cascading --> Socre: 1.0

[[[[Adv]]]]: public void [[addHeader]] ( final String name , final String value ) { List < String > [[valuesList]] = super . getAll ( name ) ; if ( [[valuesList]] . isEmpty ( ) ) { super . add ( name , value ) ; return ; } super . remove ( name ) ; [[valuesList]] . add ( value ) ; super . addAll ( name , [[valuesList]] ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .

[[[[Adv]]]]: public void [[avalanche]] ( final String name , final String value ) { List < String > [[convoy]] = super . getAll ( name ) ; if ( [[convoy]] . isEmpty ( ) ) { super . add ( name , value ) ; return ; } super . remove ( name ) ; [[convoy]] . add ( value ) ; super . addAll ( name , [[convoy]] ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .
--------------------------------------------- Result 818 ---------------------------------------------
Checks if a plaintext hashed password . --> Checks if is clicker --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[checkpw]] ( String [[plaintext]] , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String try_pw = hashpw ( [[plaintext]] , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "False" != "False" ; } if ( hashed_bytes . length != try_bytes . length ) { return "False" != "False" ; } byte ret = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .

[[[[Adv]]]]: public static boolean [[clicker]] ( String [[facelift]] , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String try_pw = hashpw ( [[facelift]] , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "False" != "False" ; } if ( hashed_bytes . length != try_bytes . length ) { return "False" != "False" ; } byte ret = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .
--------------------------------------------- Result 819 ---------------------------------------------
Resolves the action config . --> Get ActionConfig from annotationValues --> Socre: 1.0

[[[[Adv]]]]: protected ActionConfig [[resolveActionConfig]] ( final ActionAnnotationValues annotationValues ) { final Class < ? extends Annotation > [[annotationType]] ; if ( annotationValues == null ) { [[annotationType]] = Action . class ; } else { [[annotationType]] = annotationValues . annotationType ( ) ; } return actionConfigManager . lookup ( [[annotationType]] ) ; }
[[[[Nl]]]]: Resolves action config .

[[[[Adv]]]]: protected ActionConfig [[defending]] ( final ActionAnnotationValues annotationValues ) { final Class < ? extends Annotation > [[morn]] ; if ( annotationValues == null ) { [[morn]] = Action . class ; } else { [[morn]] = annotationValues . annotationType ( ) ; } return actionConfigManager . lookup ( [[morn]] ) ; }
[[[[Nl]]]]: Resolves action config .
--------------------------------------------- Result 820 ---------------------------------------------
Parse action runtime . --> Resolve a cellblock instance --> Socre: 1.0

[[[[Adv]]]]: public ActionRuntime [[parse]] ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues [[annotationValues]] = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( [[annotationValues]] ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .

[[[[Adv]]]]: public ActionRuntime [[cellblock]] ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues [[baywatch]] = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( [[baywatch]] ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .
--------------------------------------------- Result 821 ---------------------------------------------
Extract profile . --> Examine a set of profiles --> Socre: 1.0

[[[[Adv]]]]: public Map [[extract]] ( Map target , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { if ( target == null ) { target = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .

[[[[Adv]]]]: public Map [[exorcism]] ( Map target , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { if ( target == null ) { target = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .
[Succeeded / Failed / Skipped / Total] 658 / 145 / 19 / 822:  82%|████████▏ | 822/1000 [1:27:56<19:02,  6.42s/it][Succeeded / Failed / Skipped / Total] 658 / 145 / 19 / 822:  82%|████████▏ | 823/1000 [1:27:57<18:55,  6.41s/it][Succeeded / Failed / Skipped / Total] 659 / 145 / 19 / 823:  82%|████████▏ | 823/1000 [1:27:57<18:55,  6.41s/it][Succeeded / Failed / Skipped / Total] 659 / 145 / 19 / 823:  82%|████████▏ | 824/1000 [1:27:58<18:47,  6.41s/it][Succeeded / Failed / Skipped / Total] 659 / 145 / 20 / 824:  82%|████████▏ | 824/1000 [1:27:58<18:47,  6.41s/it][Succeeded / Failed / Skipped / Total] 659 / 145 / 20 / 824:  82%|████████▎ | 825/1000 [1:28:17<18:43,  6.42s/it][Succeeded / Failed / Skipped / Total] 660 / 145 / 20 / 825:  82%|████████▎ | 825/1000 [1:28:17<18:43,  6.42s/it][Succeeded / Failed / Skipped / Total] 660 / 145 / 20 / 825:  83%|████████▎ | 826/1000 [1:28:22<18:37,  6.42s/it][Succeeded / Failed / Skipped / Total] 661 / 145 / 20 / 826:  83%|████████▎ | 826/1000 [1:28:22<18:37,  6.42s/it][Succeeded / Failed / Skipped / Total] 661 / 145 / 20 / 826:  83%|████████▎ | 827/1000 [1:28:25<18:29,  6.42s/it][Succeeded / Failed / Skipped / Total] 662 / 145 / 20 / 827:  83%|████████▎ | 827/1000 [1:28:25<18:29,  6.42s/it][Succeeded / Failed / Skipped / Total] 662 / 145 / 20 / 827:  83%|████████▎ | 828/1000 [1:28:38<18:24,  6.42s/it][Succeeded / Failed / Skipped / Total] 662 / 146 / 20 / 828:  83%|████████▎ | 828/1000 [1:28:38<18:24,  6.42s/it][Succeeded / Failed / Skipped / Total] 662 / 146 / 20 / 828:  83%|████████▎ | 829/1000 [1:28:50<18:19,  6.43s/it][Succeeded / Failed / Skipped / Total] 663 / 146 / 20 / 829:  83%|████████▎ | 829/1000 [1:28:50<18:19,  6.43s/it][Succeeded / Failed / Skipped / Total] 663 / 146 / 20 / 829:  83%|████████▎ | 830/1000 [1:28:51<18:11,  6.42s/it][Succeeded / Failed / Skipped / Total] 664 / 146 / 20 / 830:  83%|████████▎ | 830/1000 [1:28:51<18:11,  6.42s/it][Succeeded / Failed / Skipped / Total] 664 / 146 / 20 / 830:  83%|████████▎ | 831/1000 [1:28:59<18:05,  6.43s/it]--------------------------------------------- Result 822 ---------------------------------------------
Read the interceptor annotation . --> Extracts the greenberg agent from the agent --> Socre: 1.0

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[readActionInterceptors]] ( final AnnotatedElement [[actionClassOrMethod]] ) { Class < ? extends ActionInterceptor > [ ] result = null ; InterceptedBy interceptedBy = [[actionClassOrMethod]] . getAnnotation ( InterceptedBy . class ) ; if ( interceptedBy != null ) { result = interceptedBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[greenberg]] ( final AnnotatedElement [[psychotherapy]] ) { Class < ? extends ActionInterceptor > [ ] result = null ; InterceptedBy interceptedBy = [[psychotherapy]] . getAnnotation ( InterceptedBy . class ) ; if ( interceptedBy != null ) { result = interceptedBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .
--------------------------------------------- Result 823 ---------------------------------------------
Parses the method alias . --> on annotation values --> Socre: 1.0

[[[[Adv]]]]: protected String [[parseMethodAlias]] ( final ActionAnnotationValues annotationValues ) { String alias = null ; if ( annotationValues != null ) { alias = annotationValues . alias ( ) ; } return alias ; }
[[[[Nl]]]]: Reads method s alias value .

[[[[Adv]]]]: protected String [[bonn]] ( final ActionAnnotationValues annotationValues ) { String alias = null ; if ( annotationValues != null ) { alias = annotationValues . alias ( ) ; } return alias ; }
[[[[Nl]]]]: Reads method s alias value .
--------------------------------------------- Result 824 ---------------------------------------------
Set the status of the request . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override protected void preResponseCommit ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( "Last-Modified" , lastModified ) ; } else { response . reset ( ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; } } }
[[[[Nl]]]]: todo move to BufferResponseWrapper ?
--------------------------------------------- Result 825 ---------------------------------------------
Read package action path . --> Generate carre --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readPackageActionPath]] ( final Class actionClass ) { Package [[actionPackage]] = actionClass . getPackage ( ) ; final String actionPackageName = [[actionPackage]] . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .

[[[[Adv]]]]: protected String [ ] [[carre]] ( final Class actionClass ) { Package [[maharani]] = actionClass . getPackage ( ) ; final String actionPackageName = [[maharani]] . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .
--------------------------------------------- Result 826 ---------------------------------------------
Detect alias . --> Searches the action path for the action definition --> Socre: 1.0

[[[[Adv]]]]: protected void [[detectAndRegisterAlias]] ( final ActionAnnotationValues annotationValues , final ActionDefinition [[actionDefinition]] ) { final String [[alias]] = parseMethodAlias ( annotationValues ) ; if ( [[alias]] != null ) { String aliasPath = StringUtil . cutToIndexOf ( [[actionDefinition]] . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( [[alias]] , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .

[[[[Adv]]]]: protected void [[bruni]] ( final ActionAnnotationValues annotationValues , final ActionDefinition [[frazier]] ) { final String [[blanche]] = parseMethodAlias ( annotationValues ) ; if ( [[blanche]] != null ) { String aliasPath = StringUtil . cutToIndexOf ( [[frazier]] . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( [[blanche]] , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .
--------------------------------------------- Result 827 ---------------------------------------------
Read action filters . --> Read filter from komodo --> Socre: 1.0

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] readActionFilters ( final AnnotatedElement [[actionClassOrMethod]] ) { Class < ? extends ActionFilter > [ ] [[result]] = null ; FilteredBy [[filteredBy]] = [[actionClassOrMethod]] . getAnnotation ( FilteredBy . class ) ; if ( [[filteredBy]] != null ) { [[result]] = [[filteredBy]] . value ( ) ; if ( [[result]] . length == 0 ) { [[result]] = null ; } } return [[result]] ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] readActionFilters ( final AnnotatedElement [[komodo]] ) { Class < ? extends ActionFilter > [ ] [[matias]] = null ; FilteredBy [[genocide]] = [[komodo]] . getAnnotation ( FilteredBy . class ) ; if ( [[genocide]] != null ) { [[matias]] = [[genocide]] . value ( ) ; if ( [[matias]] . length == 0 ) { [[matias]] = null ; } } return [[matias]] ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .
--------------------------------------------- Result 828 ---------------------------------------------
Apply proxy advice for given target class . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] applyAdvice ( final Class < [[T]] > targetClass ) { Class [[adviceClass]] = cache . get ( targetClass ) ; if ( [[adviceClass]] == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .

[[[[Adv]]]]: public static < [[soak]] > [[soak]] applyAdvice ( final Class < [[soak]] > targetClass ) { Class [[amazed]] = cache . get ( targetClass ) ; if ( [[amazed]] == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .
--------------------------------------------- Result 829 ---------------------------------------------
Resolves the real name for the given json name . --> Hack for testing --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final String jsonName ) { if ( jsonNames == null ) { return jsonName ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; if ( jsonIndex == - 1 ) { return jsonName ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .

[[[[Adv]]]]: public String [[hacksaw]] ( final String jsonName ) { if ( jsonNames == null ) { return jsonName ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; if ( jsonIndex == - 1 ) { return jsonName ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .
--------------------------------------------- Result 830 ---------------------------------------------
Read method action path . --> Overridden methods --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readMethodActionPath]] ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig [[actionConfig]] ) {
[[[[Nl]]]]: Reads action path from the action method .

[[[[Adv]]]]: protected String [ ] [[aigoo]] ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig [[helder]] ) {
[[[[Nl]]]]: Reads action path from the action method .
--------------------------------------------- Result 831 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 665 / 146 / 20 / 831:  83%|████████▎ | 831/1000 [1:28:59<18:05,  6.43s/it][Succeeded / Failed / Skipped / Total] 665 / 146 / 20 / 831:  83%|████████▎ | 832/1000 [1:29:00<17:58,  6.42s/it][Succeeded / Failed / Skipped / Total] 666 / 146 / 20 / 832:  83%|████████▎ | 832/1000 [1:29:00<17:58,  6.42s/it][Succeeded / Failed / Skipped / Total] 666 / 146 / 20 / 832:  83%|████████▎ | 833/1000 [1:29:13<17:53,  6.43s/it][Succeeded / Failed / Skipped / Total] 667 / 146 / 20 / 833:  83%|████████▎ | 833/1000 [1:29:13<17:53,  6.43s/it][Succeeded / Failed / Skipped / Total] 667 / 146 / 20 / 833:  83%|████████▎ | 834/1000 [1:29:21<17:47,  6.43s/it][Succeeded / Failed / Skipped / Total] 667 / 147 / 20 / 834:  83%|████████▎ | 834/1000 [1:29:21<17:47,  6.43s/it][Succeeded / Failed / Skipped / Total] 667 / 147 / 20 / 834:  84%|████████▎ | 835/1000 [1:29:32<17:41,  6.43s/it][Succeeded / Failed / Skipped / Total] 668 / 147 / 20 / 835:  84%|████████▎ | 835/1000 [1:29:32<17:41,  6.43s/it][Succeeded / Failed / Skipped / Total] 668 / 147 / 20 / 835:  84%|████████▎ | 836/1000 [1:29:40<17:35,  6.44s/it][Succeeded / Failed / Skipped / Total] 669 / 147 / 20 / 836:  84%|████████▎ | 836/1000 [1:29:40<17:35,  6.44s/it][Succeeded / Failed / Skipped / Total] 669 / 147 / 20 / 836:  84%|████████▎ | 837/1000 [1:29:41<17:28,  6.43s/it][Succeeded / Failed / Skipped / Total] 670 / 147 / 20 / 837:  84%|████████▎ | 837/1000 [1:29:41<17:28,  6.43s/it][Succeeded / Failed / Skipped / Total] 670 / 147 / 20 / 837:  84%|████████▍ | 838/1000 [1:29:43<17:20,  6.42s/it][Succeeded / Failed / Skipped / Total] 671 / 147 / 20 / 838:  84%|████████▍ | 838/1000 [1:29:43<17:20,  6.42s/it][Succeeded / Failed / Skipped / Total] 671 / 147 / 20 / 838:  84%|████████▍ | 839/1000 [1:29:55<17:15,  6.43s/it][Succeeded / Failed / Skipped / Total] 671 / 148 / 20 / 839:  84%|████████▍ | 839/1000 [1:29:55<17:15,  6.43s/it][Succeeded / Failed / Skipped / Total] 671 / 148 / 20 / 839:  84%|████████▍ | 840/1000 [1:30:03<17:09,  6.43s/it]Inject target into proxy --> Configure a Greenberg instance --> Socre: 1.0

[[[[Adv]]]]: public static void [[injectTargetIntoProxy]] ( final Object [[proxy]] , final Object target ) { Class proxyClass = [[proxy]] . getClass ( ) ; try { Field field = proxyClass . getField ( "$___target$0" ) ; field . set ( [[proxy]] , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .

[[[[Adv]]]]: public static void [[deepening]] ( final Object [[greenberg]] , final Object target ) { Class proxyClass = [[greenberg]] . getClass ( ) ; try { Field field = proxyClass . getField ( "$___target$0" ) ; field . set ( [[greenberg]] , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .
--------------------------------------------- Result 832 ---------------------------------------------
Resolve json name . --> If realName is not found return jsonName --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final String realName ) { if ( realNames == null ) { return realName ; } int realIndex = ArraysUtil . indexOf ( realNames , realName ) ; if ( realIndex == - 1 ) { return realName ; } return jsonNames [ realIndex ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .

[[[[Adv]]]]: public String [[electrocution]] ( final String realName ) { if ( realNames == null ) { return realName ; } int realIndex = ArraysUtil . indexOf ( realNames , realName ) ; if ( realIndex == - 1 ) { return realName ; } return jsonNames [ realIndex ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .
--------------------------------------------- Result 833 ---------------------------------------------
Hashes a password with a salt . --> also used for testing --> Socre: 1.0

[[[[Adv]]]]: public static String [[hashpw]] ( String password , String [[salt]] ) { BCrypt [[B]] ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( [[salt]] . charAt ( 0 ) != ' ' || [[salt]] . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( [[salt]] . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = [[salt]] . charAt ( 2 ) ; if ( minor != ' ' || [[salt]] . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .

[[[[Adv]]]]: public static String [[billeting]] ( String password , String [[insurgent]] ) { BCrypt [[archbishop]] ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( [[insurgent]] . charAt ( 0 ) != ' ' || [[insurgent]] . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( [[insurgent]] . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = [[insurgent]] . charAt ( 2 ) ; if ( minor != ' ' || [[insurgent]] . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .
--------------------------------------------- Result 834 ---------------------------------------------
Visits an annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public AnnotationVisitor [[visitAnnotation]] ( final String [[descriptor]] , final boolean [[visible]] ) { if ( fv != null ) { return fv . visitAnnotation ( [[descriptor]] , [[visible]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .

[[[[Adv]]]]: public AnnotationVisitor [[fleeing]] ( final String [[lawmen]] , final boolean [[sleepwalking]] ) { if ( fv != null ) { return fv . visitAnnotation ( [[lawmen]] , [[sleepwalking]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .
--------------------------------------------- Result 835 ---------------------------------------------
Lookup type data for given class . --> Get TypeData for given Class --> Socre: 1.0

[[[[Adv]]]]: protected TypeData [[_lookupTypeData]] ( final Class [[type]] ) { TypeData typeData = typeDataMap . get ( [[type]] ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , typeData ) ; } return typeData ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .

[[[[Adv]]]]: protected TypeData [[hyde]] ( final Class [[highchair]] ) { TypeData typeData = typeDataMap . get ( [[highchair]] ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( [[highchair]] ) ; typeDataMap . put ( [[highchair]] , typeData ) ; } return typeData ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .
--------------------------------------------- Result 836 ---------------------------------------------
Find the type data for a sub class . --> Checks if there is a subclass annotation --> Socre: 1.0

[[[[Adv]]]]: protected TypeData findSubclassTypeData ( final Class [[type]] ) { final Class < ? extends Annotation > [[defaultAnnotation]] = jsonAnnotation ; if ( [[type]] . getAnnotation ( [[defaultAnnotation]] ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .

[[[[Adv]]]]: protected TypeData findSubclassTypeData ( final Class [[ofour]] ) { final Class < ? extends Annotation > [[valued]] = jsonAnnotation ; if ( [[ofour]] . getAnnotation ( [[valued]] ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .
--------------------------------------------- Result 837 ---------------------------------------------
Resolves a JSON name . --> get flatter --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final Class type , final String [[name]] ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveJsonName ( [[name]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .

[[[[Adv]]]]: public String [[flatter]] ( final Class type , final String [[klove]] ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveJsonName ( [[klove]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .
--------------------------------------------- Result 838 ---------------------------------------------
Returns the file content . --> Dereference data from tempfile --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[getFileContent]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .

[[[[Adv]]]]: @ Override public byte [ ] [[dissimilar]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .
--------------------------------------------- Result 839 ---------------------------------------------
Lookup the TypeData for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public TypeData lookupTypeData ( final Class [[type]] ) { TypeData typeData = typeDataMap . get ( [[type]] ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( [[type]] ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , typeData ) ; } } return typeData ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .

[[[[Adv]]]]: public TypeData lookupTypeData ( final Class [[unquote]] ) { TypeData typeData = typeDataMap . get ( [[unquote]] ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( [[unquote]] ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( [[unquote]] ) ; typeDataMap . put ( [[unquote]] , typeData ) ; } } return typeData ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .
--------------------------------------------- Result 840 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 672 / 148 / 20 / 840:  84%|████████▍ | 840/1000 [1:30:03<17:09,  6.43s/it][Succeeded / Failed / Skipped / Total] 672 / 148 / 20 / 840:  84%|████████▍ | 841/1000 [1:30:19<17:04,  6.44s/it][Succeeded / Failed / Skipped / Total] 673 / 148 / 20 / 841:  84%|████████▍ | 841/1000 [1:30:19<17:04,  6.44s/it][Succeeded / Failed / Skipped / Total] 673 / 148 / 20 / 841:  84%|████████▍ | 842/1000 [1:30:22<16:57,  6.44s/it][Succeeded / Failed / Skipped / Total] 674 / 148 / 20 / 842:  84%|████████▍ | 842/1000 [1:30:22<16:57,  6.44s/it][Succeeded / Failed / Skipped / Total] 674 / 148 / 20 / 842:  84%|████████▍ | 843/1000 [1:30:25<16:50,  6.44s/it][Succeeded / Failed / Skipped / Total] 674 / 149 / 20 / 843:  84%|████████▍ | 843/1000 [1:30:25<16:50,  6.44s/it][Succeeded / Failed / Skipped / Total] 674 / 149 / 20 / 843:  84%|████████▍ | 844/1000 [1:30:26<16:43,  6.43s/it][Succeeded / Failed / Skipped / Total] 675 / 149 / 20 / 844:  84%|████████▍ | 844/1000 [1:30:26<16:43,  6.43s/it][Succeeded / Failed / Skipped / Total] 675 / 149 / 20 / 844:  84%|████████▍ | 845/1000 [1:30:38<16:37,  6.44s/it][Succeeded / Failed / Skipped / Total] 676 / 149 / 20 / 845:  84%|████████▍ | 845/1000 [1:30:38<16:37,  6.44s/it][Succeeded / Failed / Skipped / Total] 676 / 149 / 20 / 845:  85%|████████▍ | 846/1000 [1:31:05<16:34,  6.46s/it][Succeeded / Failed / Skipped / Total] 677 / 149 / 20 / 846:  85%|████████▍ | 846/1000 [1:31:05<16:34,  6.46s/it][Succeeded / Failed / Skipped / Total] 677 / 149 / 20 / 846:  85%|████████▍ | 847/1000 [1:31:22<16:30,  6.47s/it]Sets the major version and constant pool . --> Add a new swan --> Socre: 1.0

[[[[Adv]]]]: int [[setMajorVersionAndClassName]] ( final int majorVersion , final String className ) { this . majorVersion = majorVersion ; this . className = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .

[[[[Adv]]]]: int [[swan]] ( final int majorVersion , final String className ) { this . majorVersion = majorVersion ; this . className = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .
--------------------------------------------- Result 841 ---------------------------------------------
Puts the constant pool . --> Put a bonking --> Socre: 1.0

[[[[Adv]]]]: void [[putConstantPool]] ( final ByteVector [[output]] ) { [[output]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .

[[[[Adv]]]]: void [[bonking]] ( final ByteVector [[brion]] ) { [[brion]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .
--------------------------------------------- Result 842 ---------------------------------------------
Put bootstrap methods . --> Add ELB method --> Socre: 1.0

[[[[Adv]]]]: void [[putBootstrapMethods]] ( final ByteVector [[output]] ) { if ( bootstrapMethods != null ) { [[output]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .

[[[[Adv]]]]: void [[elba]] ( final ByteVector [[americus]] ) { if ( bootstrapMethods != null ) { [[americus]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .
--------------------------------------------- Result 843 ---------------------------------------------
Copy the bootstrap methods . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[copyBootstrapMethods]] ( final ClassReader classReader , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .

[[[[Adv]]]]: private void [[coleman]] ( final ClassReader classReader , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .
--------------------------------------------- Result 844 ---------------------------------------------
Create action runtime . --> Get a bataanan --> Socre: 1.0

[[[[Adv]]]]: public ActionRuntime [[createActionRuntime]] ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] [[filters]] , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , [[filters]] , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .

[[[[Adv]]]]: public ActionRuntime [[bataan]] ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] [[crew]] , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , [[crew]] , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .
--------------------------------------------- Result 845 ---------------------------------------------
Resolves the real name . --> Gets an attribute --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final Class [[type]] , final String jsonName ) { TypeData [[typeData]] = lookupTypeData ( [[type]] ) ; return [[typeData]] . resolveRealName ( jsonName ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .

[[[[Adv]]]]: public String [[attribute]] ( final Class [[schaefer]] , final String jsonName ) { TypeData [[approving]] = lookupTypeData ( [[schaefer]] ) ; return [[approving]] . resolveRealName ( jsonName ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .
--------------------------------------------- Result 846 ---------------------------------------------
Adds a reference to the constant map . --> add bogne --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantMemberReference]] ( final int [[index]] , final int tag , final String owner , final String name , final String descriptor ) { add ( new Entry ( [[index]] , tag , owner , name , descriptor , 0 , hash ( tag , owner , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[borgias]] ( final int [[bourgogne]] , final int tag , final String owner , final String name , final String descriptor ) { add ( new Entry ( [[bourgogne]] , tag , owner , name , descriptor , 0 , hash ( tag , owner , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .
--------------------------------------------- Result 847 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 678 / 149 / 20 / 847:  85%|████████▍ | 847/1000 [1:31:22<16:30,  6.47s/it][Succeeded / Failed / Skipped / Total] 678 / 149 / 20 / 847:  85%|████████▍ | 848/1000 [1:31:25<16:23,  6.47s/it][Succeeded / Failed / Skipped / Total] 678 / 150 / 20 / 848:  85%|████████▍ | 848/1000 [1:31:25<16:23,  6.47s/it][Succeeded / Failed / Skipped / Total] 678 / 150 / 20 / 848:  85%|████████▍ | 849/1000 [1:31:41<16:18,  6.48s/it][Succeeded / Failed / Skipped / Total] 678 / 151 / 20 / 849:  85%|████████▍ | 849/1000 [1:31:41<16:18,  6.48s/it][Succeeded / Failed / Skipped / Total] 678 / 151 / 20 / 849:  85%|████████▌ | 850/1000 [1:31:45<16:11,  6.48s/it][Succeeded / Failed / Skipped / Total] 679 / 151 / 20 / 850:  85%|████████▌ | 850/1000 [1:31:45<16:11,  6.48s/it][Succeeded / Failed / Skipped / Total] 679 / 151 / 20 / 850:  85%|████████▌ | 851/1000 [1:32:00<16:06,  6.49s/it][Succeeded / Failed / Skipped / Total] 679 / 152 / 20 / 851:  85%|████████▌ | 851/1000 [1:32:00<16:06,  6.49s/it][Succeeded / Failed / Skipped / Total] 679 / 152 / 20 / 851:  85%|████████▌ | 852/1000 [1:32:22<16:02,  6.51s/it][Succeeded / Failed / Skipped / Total] 680 / 152 / 20 / 852:  85%|████████▌ | 852/1000 [1:32:22<16:02,  6.51s/it][Succeeded / Failed / Skipped / Total] 680 / 152 / 20 / 852:  85%|████████▌ | 853/1000 [1:32:29<15:56,  6.51s/it][Succeeded / Failed / Skipped / Total] 680 / 153 / 20 / 853:  85%|████████▌ | 853/1000 [1:32:29<15:56,  6.51s/it][Succeeded / Failed / Skipped / Total] 680 / 153 / 20 / 853:  85%|████████▌ | 854/1000 [1:32:32<15:49,  6.50s/it]Adds a constant reference to the constant pool . --> returns an aurora --> Socre: 1.0

[[[[Adv]]]]: private Entry [[addConstantMemberReference]] ( final int tag , final String [[owner]] , final String name , final String descriptor ) { int hashCode = hash ( tag , [[owner]] , name , descriptor ) ; Entry [[entry]] = get ( hashCode ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == tag && [[entry]] . hashCode == hashCode && [[entry]] . owner . equals ( [[owner]] ) && [[entry]] . name . equals ( name ) && [[entry]] . value . equals ( descriptor ) ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } constantPool . put122 ( tag , addConstantClass ( [[owner]] ) . index , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , [[owner]] , name , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Entry [[armada]] ( final int tag , final String [[blogger]] , final String name , final String descriptor ) { int hashCode = hash ( tag , [[blogger]] , name , descriptor ) ; Entry [[aurora]] = get ( hashCode ) ; while ( [[aurora]] != null ) { if ( [[aurora]] . tag == tag && [[aurora]] . hashCode == hashCode && [[aurora]] . owner . equals ( [[blogger]] ) && [[aurora]] . name . equals ( name ) && [[aurora]] . value . equals ( descriptor ) ) { return [[aurora]] ; } [[aurora]] = [[aurora]] . next ; } constantPool . put122 ( tag , addConstantClass ( [[blogger]] ) . index , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , [[blogger]] , name , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 848 ---------------------------------------------
Adds a constant field ref . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addConstantFieldref]] ( final String owner , final String name , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[ladybird]] ( final String owner , final String name , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 849 ---------------------------------------------
Adds an integer constant . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantIntegerOrFloat]] ( final int index , final int tag , final int [[value]] ) { add ( new Entry ( index , tag , [[value]] , hash ( tag , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[reformation]] ( final int index , final int tag , final int [[isolate]] ) { add ( new Entry ( index , tag , [[isolate]] , hash ( tag , [[isolate]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .
--------------------------------------------- Result 850 ---------------------------------------------
Adds a long or double entry . --> Packet information --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantLongOrDouble]] ( final int [[index]] , final int tag , final long value ) { add ( new Entry ( [[index]] , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[papo]] ( final int [[electrocution]] , final int tag , final long value ) { add ( new Entry ( [[electrocution]] , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .
--------------------------------------------- Result 851 ---------------------------------------------
Adds a constant method ref . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addConstantMethodref]] ( final String owner , final String name , final String descriptor , final boolean isInterface ) { int [[tag]] = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( [[tag]] , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[ballon]] ( final String owner , final String name , final String descriptor , final boolean isInterface ) { int [[boost]] = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( [[boost]] , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 852 ---------------------------------------------
Add a constant method handle . -->  isolate from method handle --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantMethodHandle]] ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[isolate]] ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 853 ---------------------------------------------
Adds an integer or float constant to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol [[addConstantIntegerOrFloat]] ( final int tag , final int value ) { int [[hashCode]] = hash ( tag , value ) ; Entry entry = get ( [[hashCode]] ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == [[hashCode]] && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[marionette]] ( final int tag , final int value ) { int [[convincing]] = hash ( tag , value ) ; Entry entry = get ( [[convincing]] ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == [[convincing]] && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , [[convincing]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 854 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 681 / 153 / 20 / 854:  85%|████████▌ | 854/1000 [1:32:32<15:49,  6.50s/it][Succeeded / Failed / Skipped / Total] 681 / 153 / 20 / 854:  86%|████████▌ | 855/1000 [1:32:35<15:42,  6.50s/it][Succeeded / Failed / Skipped / Total] 682 / 153 / 20 / 855:  86%|████████▌ | 855/1000 [1:32:35<15:42,  6.50s/it][Succeeded / Failed / Skipped / Total] 682 / 153 / 20 / 855:  86%|████████▌ | 856/1000 [1:32:43<15:35,  6.50s/it][Succeeded / Failed / Skipped / Total] 683 / 153 / 20 / 856:  86%|████████▌ | 856/1000 [1:32:43<15:35,  6.50s/it][Succeeded / Failed / Skipped / Total] 683 / 153 / 20 / 856:  86%|████████▌ | 857/1000 [1:32:44<15:28,  6.49s/it][Succeeded / Failed / Skipped / Total] 684 / 153 / 20 / 857:  86%|████████▌ | 857/1000 [1:32:44<15:28,  6.49s/it][Succeeded / Failed / Skipped / Total] 684 / 153 / 20 / 857:  86%|████████▌ | 858/1000 [1:32:54<15:22,  6.50s/it][Succeeded / Failed / Skipped / Total] 685 / 153 / 20 / 858:  86%|████████▌ | 858/1000 [1:32:54<15:22,  6.50s/it][Succeeded / Failed / Skipped / Total] 685 / 153 / 20 / 858:  86%|████████▌ | 859/1000 [1:33:22<15:19,  6.52s/it][Succeeded / Failed / Skipped / Total] 685 / 154 / 20 / 859:  86%|████████▌ | 859/1000 [1:33:22<15:19,  6.52s/it][Succeeded / Failed / Skipped / Total] 685 / 154 / 20 / 859:  86%|████████▌ | 860/1000 [1:33:32<15:13,  6.53s/it]Adds a constant name and type . --> aller artmen --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantNameAndType]] ( final int [[index]] , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( [[index]] , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[alligator]] ( final int [[martín]] , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( [[martín]] , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .
--------------------------------------------- Result 855 ---------------------------------------------
Adds a constant name and type to the constant pool . --> new tauber --> Socre: 1.0

[[[[Adv]]]]: int [[addConstantNameAndType]] ( final String name , final String descriptor ) { final int [[tag]] = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int [[hashCode]] = hash ( [[tag]] , name , descriptor ) ; Entry entry = get ( [[hashCode]] ) ; while ( entry != null ) { if ( entry . tag == [[tag]] && entry . hashCode == [[hashCode]] && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( [[tag]] , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , [[tag]] , name , descriptor , [[hashCode]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int [[tauber]] ( final String name , final String descriptor ) { final int [[milo]] = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int [[será]] = hash ( [[milo]] , name , descriptor ) ; Entry entry = get ( [[será]] ) ; while ( entry != null ) { if ( entry . tag == [[milo]] && entry . hashCode == [[será]] && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( [[milo]] , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , [[milo]] , name , descriptor , [[será]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 856 ---------------------------------------------
Adds constant method handle . --> Dorkus method handle --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantMethodHandle]] ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; add ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[dorkus]] ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; add ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .
--------------------------------------------- Result 857 ---------------------------------------------
Adds a UTF8 constant . --> Methode permutation --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantUtf8]] ( final int [[index]] , final String [[value]] ) { add ( new Entry ( [[index]] , Symbol . CONSTANT_UTF8_TAG , [[value]] , hash ( Symbol . CONSTANT_UTF8_TAG , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[trickle]] ( final int [[pompous]] , final String [[pays]] ) { add ( new Entry ( [[pompous]] , Symbol . CONSTANT_UTF8_TAG , [[pays]] , hash ( Symbol . CONSTANT_UTF8_TAG , [[pays]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .
--------------------------------------------- Result 858 ---------------------------------------------
Adds a long or double constant . --> public for testing --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantLongOrDouble]] ( final int tag , final long value ) { int [[hashCode]] = hash ( tag , value ) ; Entry [[entry]] = get ( [[hashCode]] ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == tag && [[entry]] . hashCode == [[hashCode]] && [[entry]] . data == value ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , value , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[privatisation]] ( final int tag , final long value ) { int [[actions]] = hash ( tag , value ) ; Entry [[plastered]] = get ( [[actions]] ) ; while ( [[plastered]] != null ) { if ( [[plastered]] . tag == tag && [[plastered]] . hashCode == [[actions]] && [[plastered]] . data == value ) { return [[plastered]] ; } [[plastered]] = [[plastered]] . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , value , [[actions]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 859 ---------------------------------------------
Adds a UTF8 constant to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: int [[addConstantUtf8]] ( final String value ) { int [[hashCode]] = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( [[hashCode]] ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == [[hashCode]] && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , [[hashCode]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int [[pom]] ( final String value ) { int [[hedonism]] = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( [[hedonism]] ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == [[hedonism]] && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , [[hedonism]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 860 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 686 / 154 / 20 / 860:  86%|████████▌ | 860/1000 [1:33:32<15:13,  6.53s/it][Succeeded / Failed / Skipped / Total] 686 / 154 / 20 / 860:  86%|████████▌ | 861/1000 [1:34:21<15:14,  6.58s/it][Succeeded / Failed / Skipped / Total] 687 / 154 / 20 / 861:  86%|████████▌ | 861/1000 [1:34:21<15:14,  6.58s/it][Succeeded / Failed / Skipped / Total] 687 / 154 / 20 / 861:  86%|████████▌ | 862/1000 [1:34:29<15:07,  6.58s/it][Succeeded / Failed / Skipped / Total] 687 / 155 / 20 / 862:  86%|████████▌ | 862/1000 [1:34:29<15:07,  6.58s/it][Succeeded / Failed / Skipped / Total] 687 / 155 / 20 / 862:  86%|████████▋ | 863/1000 [1:34:33<15:00,  6.57s/it][Succeeded / Failed / Skipped / Total] 687 / 156 / 20 / 863:  86%|████████▋ | 863/1000 [1:34:33<15:00,  6.57s/it][Succeeded / Failed / Skipped / Total] 687 / 156 / 20 / 863:  86%|████████▋ | 864/1000 [1:34:39<14:54,  6.57s/it][Succeeded / Failed / Skipped / Total] 687 / 157 / 20 / 864:  86%|████████▋ | 864/1000 [1:34:39<14:54,  6.57s/it][Succeeded / Failed / Skipped / Total] 687 / 157 / 20 / 864:  86%|████████▋ | 865/1000 [1:34:49<14:47,  6.58s/it][Succeeded / Failed / Skipped / Total] 687 / 158 / 20 / 865:  86%|████████▋ | 865/1000 [1:34:49<14:47,  6.58s/it][Succeeded / Failed / Skipped / Total] 687 / 158 / 20 / 865:  87%|████████▋ | 866/1000 [1:34:52<14:40,  6.57s/it]Adds a reference to the constant pool . --> add nighter --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantUtf8Reference]] ( final int index , final int [[tag]] , final String value ) { add ( new Entry ( index , [[tag]] , value , hash ( [[tag]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[nighter]] ( final int index , final int [[streptomycin]] , final String value ) { add ( new Entry ( index , [[streptomycin]] , value , hash ( [[streptomycin]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .
--------------------------------------------- Result 861 ---------------------------------------------
Add bootstrap method . --> Shikoku methods --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addBootstrapMethod]] ( final Handle [[bootstrapMethodHandle]] , final Object ... [[bootstrapMethodArguments]] ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .

[[[[Adv]]]]: Symbol [[shikoku]] ( final Handle [[queenie]] , final Object ... [[homecoming]] ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .
--------------------------------------------- Result 862 ---------------------------------------------
Add a static constant . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addConstantDynamic]] ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[chronicles]] ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 863 ---------------------------------------------
Add a merged type . --> [[[FAILED]]]

[[[[Adv]]]]: int [[addMergedType]] ( final int typeTableIndex1 , final int typeTableIndex2 ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .

[[[[Adv]]]]: int [[superficial]] ( final int typeTableIndex1 , final int typeTableIndex2 ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .
--------------------------------------------- Result 864 ---------------------------------------------
Adds a static constant . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantUtf8Reference ( final int tag , final String [[value]] ) { int hashCode = hash ( tag , [[value]] ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( [[value]] ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( [[value]] ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , [[value]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantUtf8Reference ( final int tag , final String [[counsellor]] ) { int hashCode = hash ( tag , [[counsellor]] ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( [[counsellor]] ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( [[counsellor]] ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , [[counsellor]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 865 ---------------------------------------------
Add a static invoke dynamic method . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addConstantInvokeDynamic]] ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[breaker]] ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 866 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 687 / 159 / 20 / 866:  87%|████████▋ | 866/1000 [1:34:52<14:40,  6.57s/it][Succeeded / Failed / Skipped / Total] 687 / 159 / 20 / 866:  87%|████████▋ | 867/1000 [1:35:03<14:34,  6.58s/it][Succeeded / Failed / Skipped / Total] 687 / 160 / 20 / 867:  87%|████████▋ | 867/1000 [1:35:03<14:34,  6.58s/it][Succeeded / Failed / Skipped / Total] 687 / 160 / 20 / 867:  87%|████████▋ | 868/1000 [1:35:12<14:28,  6.58s/it][Succeeded / Failed / Skipped / Total] 688 / 160 / 20 / 868:  87%|████████▋ | 868/1000 [1:35:12<14:28,  6.58s/it][Succeeded / Failed / Skipped / Total] 688 / 160 / 20 / 868:  87%|████████▋ | 869/1000 [1:35:12<14:21,  6.57s/it][Succeeded / Failed / Skipped / Total] 689 / 160 / 20 / 869:  87%|████████▋ | 869/1000 [1:35:12<14:21,  6.57s/it][Succeeded / Failed / Skipped / Total] 689 / 160 / 20 / 869:  87%|████████▋ | 870/1000 [1:35:34<14:16,  6.59s/it][Succeeded / Failed / Skipped / Total] 690 / 160 / 20 / 870:  87%|████████▋ | 870/1000 [1:35:34<14:16,  6.59s/it][Succeeded / Failed / Skipped / Total] 690 / 160 / 20 / 870:  87%|████████▋ | 871/1000 [1:35:49<14:11,  6.60s/it][Succeeded / Failed / Skipped / Total] 691 / 160 / 20 / 871:  87%|████████▋ | 871/1000 [1:35:49<14:11,  6.60s/it][Succeeded / Failed / Skipped / Total] 691 / 160 / 20 / 871:  87%|████████▋ | 872/1000 [1:35:50<14:04,  6.59s/it][Succeeded / Failed / Skipped / Total] 691 / 161 / 20 / 872:  87%|████████▋ | 872/1000 [1:35:50<14:04,  6.59s/it][Succeeded / Failed / Skipped / Total] 691 / 161 / 20 / 872:  87%|████████▋ | 873/1000 [1:35:53<13:57,  6.59s/it]Add or invoke dynamic reference . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantDynamicOrInvokeDynamicReference ( final int [[tag]] , final String name , final String [[descriptor]] , final int bootstrapMethodIndex ) { int hashCode = hash ( [[tag]] , name , [[descriptor]] , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == [[tag]] && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( [[descriptor]] ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( [[tag]] , bootstrapMethodIndex , addConstantNameAndType ( name , [[descriptor]] ) ) ; return put ( new Entry ( constantPoolCount ++ , [[tag]] , null , name , [[descriptor]] , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantDynamicOrInvokeDynamicReference ( final int [[blevins]] , final String name , final String [[conquistador]] , final int bootstrapMethodIndex ) { int hashCode = hash ( [[blevins]] , name , [[conquistador]] , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == [[blevins]] && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( [[conquistador]] ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( [[blevins]] , bootstrapMethodIndex , addConstantNameAndType ( name , [[conquistador]] ) ) ; return put ( new Entry ( constantPoolCount ++ , [[blevins]] , null , name , [[conquistador]] , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 867 ---------------------------------------------
Add or invoke dynamic reference . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantDynamicOrInvokeDynamicReference]] ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int [[hashCode]] = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[hideouts]] ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int [[ealing]] = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , [[ealing]] ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .
--------------------------------------------- Result 868 ---------------------------------------------
Removes all entries from the multimap . --> Overridden in tests --> Socre: 1.0

[[[[Adv]]]]: public HttpMultiMap < V > [[clear]] ( ) { for ( int [[i]] = 0 ; [[i]] < entries . length ; [[i]] ++ ) { entries [ [[i]] ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .

[[[[Adv]]]]: public HttpMultiMap < V > [[jackknife]] ( ) { for ( int [[ferrying]] = 0 ; [[ferrying]] < entries . length ; [[ferrying]] ++ ) { entries [ [[ferrying]] ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .
--------------------------------------------- Result 869 ---------------------------------------------
Creates a hash from a name . --> Convert a name to a capitalized representation --> Socre: 1.0

[[[[Adv]]]]: private int [[hash]] ( final String name ) { int h = 0 ; for ( int i = name . length ( ) - 1 ; i >= 0 ; i -- ) { char [[c]] = name . charAt ( i ) ; if ( ! caseSensitive ) { if ( [[c]] >= ' ' && [[c]] <= ' ' ) { [[c]] += 32 ; } } h = 31 * h + [[c]] ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .

[[[[Adv]]]]: private int [[mopped]] ( final String name ) { int h = 0 ; for ( int i = name . length ( ) - 1 ; i >= 0 ; i -- ) { char [[abstraction]] = name . charAt ( i ) ; if ( ! caseSensitive ) { if ( [[abstraction]] >= ' ' && [[abstraction]] <= ' ' ) { [[abstraction]] += 32 ; } } h = 31 * h + [[abstraction]] ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .
--------------------------------------------- Result 870 ---------------------------------------------
overrides the visitEnd method --> Visit endpoints --> Socre: 1.0

[[[[Adv]]]]: @ Override public void visitEnd ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[p]] = 0 ; [[p]] < tmd . proxyData . length ; [[p]] ++ ) { tmd . selectCurrentProxy ( [[p]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .

[[[[Adv]]]]: @ Override public void visitEnd ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[galleon]] = 0 ; [[galleon]] < tmd . proxyData . length ; [[galleon]] ++ ) { tmd . selectCurrentProxy ( [[galleon]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .
--------------------------------------------- Result 871 ---------------------------------------------
Appends a substring to the buffer . --> borrowed from CharSequence --> Socre: 1.0

[[[[Adv]]]]: @ Override public FastCharBuffer [[append]] ( final CharSequence csq , final int start , final int end ) { for ( int [[i]] = start ; [[i]] < end ; [[i]] ++ ) { [[append]] ( csq . charAt ( [[i]] ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .

[[[[Adv]]]]: @ Override public FastCharBuffer [[marinated]] ( final CharSequence csq , final int start , final int end ) { for ( int [[bobbins]] = start ; [[bobbins]] < end ; [[bobbins]] ++ ) { [[marinated]] ( csq . charAt ( [[bobbins]] ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .
--------------------------------------------- Result 872 ---------------------------------------------
Returns an iterator over the elements in this map . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[iterator]] ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > next = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return next ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[kissin]] ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > next = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return next ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .
--------------------------------------------- Result 873 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 692 / 161 / 20 / 873:  87%|████████▋ | 873/1000 [1:35:53<13:57,  6.59s/it][Succeeded / Failed / Skipped / Total] 692 / 161 / 20 / 873:  87%|████████▋ | 874/1000 [1:35:55<13:49,  6.58s/it][Succeeded / Failed / Skipped / Total] 692 / 162 / 20 / 874:  87%|████████▋ | 874/1000 [1:35:55<13:49,  6.58s/it][Succeeded / Failed / Skipped / Total] 692 / 162 / 20 / 874:  88%|████████▊ | 875/1000 [1:36:10<13:44,  6.59s/it][Succeeded / Failed / Skipped / Total] 693 / 162 / 20 / 875:  88%|████████▊ | 875/1000 [1:36:10<13:44,  6.59s/it][Succeeded / Failed / Skipped / Total] 693 / 162 / 20 / 875:  88%|████████▊ | 876/1000 [1:36:12<13:37,  6.59s/it][Succeeded / Failed / Skipped / Total] 694 / 162 / 20 / 876:  88%|████████▊ | 876/1000 [1:36:12<13:37,  6.59s/it][Succeeded / Failed / Skipped / Total] 694 / 162 / 20 / 876:  88%|████████▊ | 877/1000 [1:36:16<13:30,  6.59s/it][Succeeded / Failed / Skipped / Total] 695 / 162 / 20 / 877:  88%|████████▊ | 877/1000 [1:36:16<13:30,  6.59s/it][Succeeded / Failed / Skipped / Total] 695 / 162 / 20 / 877:  88%|████████▊ | 878/1000 [1:36:18<13:22,  6.58s/it][Succeeded / Failed / Skipped / Total] 696 / 162 / 20 / 878:  88%|████████▊ | 878/1000 [1:36:18<13:22,  6.58s/it][Succeeded / Failed / Skipped / Total] 696 / 162 / 20 / 878:  88%|████████▊ | 879/1000 [1:36:27<13:16,  6.58s/it][Succeeded / Failed / Skipped / Total] 697 / 162 / 20 / 879:  88%|████████▊ | 879/1000 [1:36:27<13:16,  6.58s/it][Succeeded / Failed / Skipped / Total] 697 / 162 / 20 / 879:  88%|████████▊ | 880/1000 [1:36:30<13:09,  6.58s/it][Succeeded / Failed / Skipped / Total] 698 / 162 / 20 / 880:  88%|████████▊ | 880/1000 [1:36:30<13:09,  6.58s/it][Succeeded / Failed / Skipped / Total] 698 / 162 / 20 / 880:  88%|████████▊ | 881/1000 [1:36:34<13:02,  6.58s/it]Create the start chain delegate . --> Displays antisocial activity --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Start]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .

[[[[Adv]]]]: protected void [[antisocial]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .
--------------------------------------------- Result 874 ---------------------------------------------
Returns all of the entries in this map . --> [[[FAILED]]]

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[entries]] ( ) { List < Map . Entry < String , V > > all = new LinkedList <> ( ) ; MapEntry < V > [[e]] = head . after ; while ( [[e]] != head ) { all . add ( [[e]] ) ; [[e]] = [[e]] . after ; } return all ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[georg]] ( ) { List < Map . Entry < String , V > > all = new LinkedList <> ( ) ; MapEntry < V > [[passersby]] = head . after ; while ( [[passersby]] != head ) { all . add ( [[passersby]] ) ; [[passersby]] = [[passersby]] . after ; } return all ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .
--------------------------------------------- Result 875 ---------------------------------------------
Create the first chain delegate statement --> load boll --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Continue]] ( final TargetMethodData tmd ) { methodVisitor . visitCode ( ) ; if ( tmd . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , tmd . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .

[[[[Adv]]]]: protected void [[boll]] ( final TargetMethodData tmd ) { methodVisitor . visitCode ( ) ; if ( tmd . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , tmd . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .
--------------------------------------------- Result 876 ---------------------------------------------
Pushes a new field to the path . --> Marks a pathmatical --> Socre: 1.0

[[[[Adv]]]]: public Path [[push]] ( final CharSequence field ) { _push ( field ) ; if ( altPath != null ) { altPath . push ( field ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .

[[[[Adv]]]]: public Path [[cliché]] ( final CharSequence field ) { _push ( field ) ; if ( altPath != null ) { altPath . push ( field ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .
--------------------------------------------- Result 877 ---------------------------------------------
Configure the servlet context --> This method is used to register an americus --> Socre: 1.0

[[[[Adv]]]]: private void [[configureServletContext]] ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration filter = servletContext . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .

[[[[Adv]]]]: private void [[americus]] ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration filter = servletContext . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .
--------------------------------------------- Result 878 ---------------------------------------------
Visits an annotation . --> This is an entry point for all methods that have been filtered out --> Socre: 1.0

[[[[Adv]]]]: @ Override public AnnotationVisitor [[visitAnnotation]] ( final String [[desc]] , final boolean visible ) { AnnotationVisitor [[destAnn]] = methodVisitor . visitAnnotation ( [[desc]] , visible ) ;
[[[[Nl]]]]: Copies target method annotations .

[[[[Adv]]]]: @ Override public AnnotationVisitor [[allotment]] ( final String [[calorie]] , final boolean visible ) { AnnotationVisitor [[noooooo]] = methodVisitor . visitAnnotation ( [[calorie]] , visible ) ;
[[[[Nl]]]]: Copies target method annotations .
--------------------------------------------- Result 879 ---------------------------------------------
Parse path . --> public for testing --> Socre: 1.0

[[[[Adv]]]]: public static Path [[parse]] ( final String [[path]] ) { return [[path]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[path]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .

[[[[Adv]]]]: public static Path [[privatisation]] ( final String [[augie]] ) { return [[augie]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[augie]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .
--------------------------------------------- Result 880 ---------------------------------------------
Execute the method --> Execute this path --> Socre: 1.0

[[[[Adv]]]]: public Object execute ( ) { String [[methodName]] = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object next = pathref . continueWith ( this , [[methodName]] , returnType ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;

[[[[Adv]]]]: public Object execute ( ) { String [[bigot]] = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object next = pathref . continueWith ( this , [[bigot]] , returnType ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;
--------------------------------------------- Result 881 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 699 / 162 / 20 / 881:  88%|████████▊ | 881/1000 [1:36:34<13:02,  6.58s/it][Succeeded / Failed / Skipped / Total] 699 / 162 / 20 / 881:  88%|████████▊ | 882/1000 [1:36:40<12:56,  6.58s/it][Succeeded / Failed / Skipped / Total] 700 / 162 / 20 / 882:  88%|████████▊ | 882/1000 [1:36:40<12:56,  6.58s/it][Succeeded / Failed / Skipped / Total] 700 / 162 / 20 / 882:  88%|████████▊ | 883/1000 [1:36:41<12:48,  6.57s/it][Succeeded / Failed / Skipped / Total] 701 / 162 / 20 / 883:  88%|████████▊ | 883/1000 [1:36:41<12:48,  6.57s/it][Succeeded / Failed / Skipped / Total] 701 / 162 / 20 / 883:  88%|████████▊ | 884/1000 [1:36:55<12:43,  6.58s/it][Succeeded / Failed / Skipped / Total] 702 / 162 / 20 / 884:  88%|████████▊ | 884/1000 [1:36:55<12:43,  6.58s/it][Succeeded / Failed / Skipped / Total] 702 / 162 / 20 / 884:  88%|████████▊ | 885/1000 [1:37:03<12:36,  6.58s/it][Succeeded / Failed / Skipped / Total] 703 / 162 / 20 / 885:  88%|████████▊ | 885/1000 [1:37:03<12:36,  6.58s/it][Succeeded / Failed / Skipped / Total] 703 / 162 / 20 / 885:  89%|████████▊ | 886/1000 [1:37:13<12:30,  6.58s/it][Succeeded / Failed / Skipped / Total] 704 / 162 / 20 / 886:  89%|████████▊ | 886/1000 [1:37:13<12:30,  6.58s/it][Succeeded / Failed / Skipped / Total] 704 / 162 / 20 / 886:  89%|████████▊ | 887/1000 [1:37:15<12:23,  6.58s/it][Succeeded / Failed / Skipped / Total] 705 / 162 / 20 / 887:  89%|████████▊ | 887/1000 [1:37:15<12:23,  6.58s/it][Succeeded / Failed / Skipped / Total] 705 / 162 / 20 / 887:  89%|████████▉ | 888/1000 [1:37:46<12:19,  6.61s/it]Grows the internal buffer . --> if there are at least one --> Socre: 1.0

[[[[Adv]]]]: private void [[grow]] ( final int [[minCapacity]] ) { final int oldCapacity = buffer . length ; int [[newCapacity]] = oldCapacity << 1 ; if ( [[newCapacity]] - [[minCapacity]] < 0 ) {
[[[[Nl]]]]: Grows the buffer .

[[[[Adv]]]]: private void [[lastly]] ( final int [[causing]] ) { final int oldCapacity = buffer . length ; int [[estás]] = oldCapacity << 1 ; if ( [[estás]] - [[causing]] < 0 ) {
[[[[Nl]]]]: Grows the buffer .
--------------------------------------------- Result 882 ---------------------------------------------
Returns all values matching the specified name . --> Return a list of BillPartitionedValues --> Socre: 1.0

[[[[Adv]]]]: public List < V > [[getAll]] ( final String [[name]] ) { LinkedList < V > values = new LinkedList <> ( ) ; int [[h]] = hash ( [[name]] ) ; int [[i]] = index ( [[h]] ) ; MapEntry < V > [[e]] = entries [ [[i]] ] ; while ( [[e]] != null ) { if ( [[e]] . hash == [[h]] && eq ( [[name]] , [[e]] . key ) ) { values . addFirst ( [[e]] . getValue ( ) ) ; } [[e]] = [[e]] . next ; } return values ; }
[[[[Nl]]]]: Returns all values associated with the name .

[[[[Adv]]]]: public List < V > [[postpartum]] ( final String [[royalties]] ) { LinkedList < V > values = new LinkedList <> ( ) ; int [[schultz]] = hash ( [[royalties]] ) ; int [[tenets]] = index ( [[schultz]] ) ; MapEntry < V > [[abstraction]] = entries [ [[tenets]] ] ; while ( [[abstraction]] != null ) { if ( [[abstraction]] . hash == [[schultz]] && eq ( [[royalties]] , [[abstraction]] . key ) ) { values . addFirst ( [[abstraction]] . getValue ( ) ) ; } [[abstraction]] = [[abstraction]] . next ; } return values ; }
[[[[Nl]]]]: Returns all values associated with the name .
--------------------------------------------- Result 883 ---------------------------------------------
Convert jtxTransactionMode to DbTransactionMode . --> Creates DbTransactionMode from jtxTransaction --> Socre: 1.0

[[[[Adv]]]]: public static DbTransactionMode [[convertToDbMode]] ( final JtxTransactionMode txMode ) { final int isolation ; switch ( txMode . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( isolation , txMode . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .

[[[[Adv]]]]: public static DbTransactionMode [[backpack]] ( final JtxTransactionMode txMode ) { final int isolation ; switch ( txMode . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( isolation , txMode . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .
--------------------------------------------- Result 884 ---------------------------------------------
Appends the specified buffer to this buffer . --> Chandler handler --> Socre: 1.0

[[[[Adv]]]]: public Buffer [[append]] ( final Buffer buffer ) { if ( buffer . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .

[[[[Adv]]]]: public Buffer [[chandler]] ( final Buffer buffer ) { if ( buffer . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .
--------------------------------------------- Result 885 ---------------------------------------------
Creates a bean definition for registration . --> Proxy creation method --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class [[originalType]] = type ; final ProxettaFactory [[builder]] = proxetta . proxy ( ) ; [[builder]] . setTarget ( type ) ; type = [[builder]] . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , wiringMode , [[originalType]] , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class [[maharani]] = type ; final ProxettaFactory [[bernice]] = proxetta . proxy ( ) ; [[bernice]] . setTarget ( type ) ; type = [[bernice]] . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , wiringMode , [[maharani]] , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .
--------------------------------------------- Result 886 ---------------------------------------------
Reads the value of the given property from the given source object . --> factory method --> Socre: 1.0

[[[[Adv]]]]: private Object [[readProperty]] ( final Object source , final PropertyDescriptor [[propertyDescriptor]] ) { Getter getter = [[propertyDescriptor]] . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( source ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .

[[[[Adv]]]]: private Object [[gleason]] ( final Object source , final PropertyDescriptor [[più]] ) { Getter getter = [[più]] . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( source ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .
--------------------------------------------- Result 887 ---------------------------------------------
Writes the response to the stream . --> Broadmatrix http response --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .

[[[[Adv]]]]: public void [[hazmat]] ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .
--------------------------------------------- Result 888 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 706 / 162 / 20 / 888:  89%|████████▉ | 888/1000 [1:37:46<12:19,  6.61s/it][Succeeded / Failed / Skipped / Total] 706 / 162 / 20 / 888:  89%|████████▉ | 889/1000 [1:37:55<12:13,  6.61s/it][Succeeded / Failed / Skipped / Total] 707 / 162 / 20 / 889:  89%|████████▉ | 889/1000 [1:37:55<12:13,  6.61s/it][Succeeded / Failed / Skipped / Total] 707 / 162 / 20 / 889:  89%|████████▉ | 890/1000 [1:37:56<12:06,  6.60s/it][Succeeded / Failed / Skipped / Total] 708 / 162 / 20 / 890:  89%|████████▉ | 890/1000 [1:37:56<12:06,  6.60s/it][Succeeded / Failed / Skipped / Total] 708 / 162 / 20 / 890:  89%|████████▉ | 891/1000 [1:38:02<11:59,  6.60s/it][Succeeded / Failed / Skipped / Total] 709 / 162 / 20 / 891:  89%|████████▉ | 891/1000 [1:38:02<11:59,  6.60s/it][Succeeded / Failed / Skipped / Total] 709 / 162 / 20 / 891:  89%|████████▉ | 892/1000 [1:38:03<11:52,  6.60s/it][Succeeded / Failed / Skipped / Total] 710 / 162 / 20 / 892:  89%|████████▉ | 892/1000 [1:38:03<11:52,  6.60s/it][Succeeded / Failed / Skipped / Total] 710 / 162 / 20 / 892:  89%|████████▉ | 893/1000 [1:38:05<11:45,  6.59s/it][Succeeded / Failed / Skipped / Total] 710 / 163 / 20 / 893:  89%|████████▉ | 893/1000 [1:38:05<11:45,  6.59s/it][Succeeded / Failed / Skipped / Total] 710 / 163 / 20 / 893:  89%|████████▉ | 894/1000 [1:38:07<11:38,  6.59s/it][Succeeded / Failed / Skipped / Total] 711 / 163 / 20 / 894:  89%|████████▉ | 894/1000 [1:38:07<11:38,  6.59s/it][Succeeded / Failed / Skipped / Total] 711 / 163 / 20 / 894:  90%|████████▉ | 895/1000 [1:38:13<11:31,  6.58s/it]Returns a string value for the given key . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public String getString ( final String [[key]] ) { CharSequence [[cs]] = ( CharSequence ) map . get ( [[key]] ) ; return [[cs]] == null ? null : [[cs]] . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .

[[[[Adv]]]]: public String getString ( final String [[damiano]] ) { CharSequence [[leash]] = ( CharSequence ) map . get ( [[damiano]] ) ; return [[leash]] == null ? null : [[leash]] . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .
--------------------------------------------- Result 889 ---------------------------------------------
Returns the long value for the given key . --> getTakeo --> Socre: 1.0

[[[[Adv]]]]: public Long getLong ( final String [[key]] ) { Number [[number]] = ( Number ) map . get ( [[key]] ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Long ) { return ( Long ) [[number]] ; } return [[number]] . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .

[[[[Adv]]]]: public Long getLong ( final String [[girlhood]] ) { Number [[takeo]] = ( Number ) map . get ( [[girlhood]] ) ; if ( [[takeo]] == null ) { return null ; } if ( [[takeo]] instanceof Long ) { return ( Long ) [[takeo]] ; } return [[takeo]] . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .
--------------------------------------------- Result 890 ---------------------------------------------
Copies all of the values from the given map into this one . --> creates a succohood --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[putAll]] ( final Map [[t]] ) { for ( Object o : [[t]] . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) o ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .

[[[[Adv]]]]: @ Override public void [[succo]] ( final Map [[girlhood]] ) { for ( Object o : [[girlhood]] . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) o ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .
--------------------------------------------- Result 891 ---------------------------------------------
Write the object to the given writer . --> Copied from FileSystem --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final Writer [[writer]] ) throws IOException { for ( Object [[o]] : list ) { if ( [[o]] instanceof FastByteBuffer ) { FastByteBuffer [[fastByteBuffer]] = ( FastByteBuffer ) [[o]] ; byte [ ] array = [[fastByteBuffer]] . toArray ( ) ; [[writer]] . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( [[o]] instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) [[o]] ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[writer]] , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .

[[[[Adv]]]]: public void [[ostentation]] ( final Writer [[grouped]] ) throws IOException { for ( Object [[banded]] : list ) { if ( [[banded]] instanceof FastByteBuffer ) { FastByteBuffer [[chaperoned]] = ( FastByteBuffer ) [[banded]] ; byte [ ] array = [[chaperoned]] . toArray ( ) ; [[grouped]] . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( [[banded]] instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) [[banded]] ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[grouped]] , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .
--------------------------------------------- Result 892 ---------------------------------------------
Write this object to the output stream . --> copied from org --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream [[out]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer [[fastByteBuffer]] = ( FastByteBuffer ) o ; [[out]] . write ( [[fastByteBuffer]] . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream [[inputStream]] = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( [[inputStream]] , [[out]] ) ; } finally { StreamUtil . close ( [[inputStream]] ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .

[[[[Adv]]]]: public void [[debrief]] ( final OutputStream [[commend]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer [[steele]] = ( FastByteBuffer ) o ; [[commend]] . write ( [[steele]] . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream [[strident]] = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( [[strident]] , [[commend]] ) ; } finally { StreamUtil . close ( [[strident]] ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .
--------------------------------------------- Result 893 ---------------------------------------------
Gets the FieldDescriptors . --> [[[FAILED]]]

[[[[Adv]]]]: public FieldDescriptor [ ] getAllFieldDescriptors ( ) { if ( [[allFields]] == null ) { FieldDescriptor [ ] [[allFields]] = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { [[allFields]] [ index ] = fieldDescriptor ; index ++ ; } Arrays . sort ( [[allFields]] , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = [[allFields]] ; } return [[allFields]] ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .

[[[[Adv]]]]: public FieldDescriptor [ ] getAllFieldDescriptors ( ) { if ( [[plunging]] == null ) { FieldDescriptor [ ] [[plunging]] = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { [[plunging]] [ index ] = fieldDescriptor ; index ++ ; } Arrays . sort ( [[plunging]] , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = [[plunging]] ; } return [[plunging]] ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .
--------------------------------------------- Result 894 ---------------------------------------------
Gets a Double . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public Double [[getDouble]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .

[[[[Adv]]]]: public Double [[egyptian]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .
--------------------------------------------- Result 895 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 712 / 163 / 20 / 895:  90%|████████▉ | 895/1000 [1:38:13<11:31,  6.58s/it][Succeeded / Failed / Skipped / Total] 712 / 163 / 20 / 895:  90%|████████▉ | 896/1000 [1:38:16<11:24,  6.58s/it][Succeeded / Failed / Skipped / Total] 713 / 163 / 20 / 896:  90%|████████▉ | 896/1000 [1:38:16<11:24,  6.58s/it][Succeeded / Failed / Skipped / Total] 713 / 163 / 20 / 896:  90%|████████▉ | 897/1000 [1:38:27<11:18,  6.59s/it][Succeeded / Failed / Skipped / Total] 714 / 163 / 20 / 897:  90%|████████▉ | 897/1000 [1:38:27<11:18,  6.59s/it][Succeeded / Failed / Skipped / Total] 714 / 163 / 20 / 897:  90%|████████▉ | 898/1000 [1:38:31<11:11,  6.58s/it][Succeeded / Failed / Skipped / Total] 715 / 163 / 20 / 898:  90%|████████▉ | 898/1000 [1:38:31<11:11,  6.58s/it][Succeeded / Failed / Skipped / Total] 715 / 163 / 20 / 898:  90%|████████▉ | 899/1000 [1:38:39<11:05,  6.59s/it][Succeeded / Failed / Skipped / Total] 716 / 163 / 20 / 899:  90%|████████▉ | 899/1000 [1:38:39<11:05,  6.59s/it][Succeeded / Failed / Skipped / Total] 716 / 163 / 20 / 899:  90%|█████████ | 900/1000 [1:38:40<10:57,  6.58s/it][Succeeded / Failed / Skipped / Total] 717 / 163 / 20 / 900:  90%|█████████ | 900/1000 [1:38:40<10:57,  6.58s/it][Succeeded / Failed / Skipped / Total] 717 / 163 / 20 / 900:  90%|█████████ | 901/1000 [1:38:41<10:50,  6.57s/it][Succeeded / Failed / Skipped / Total] 717 / 163 / 21 / 901:  90%|█████████ | 901/1000 [1:38:41<10:50,  6.57s/it][Succeeded / Failed / Skipped / Total] 717 / 163 / 21 / 901:  90%|█████████ | 902/1000 [1:38:46<10:43,  6.57s/it][Succeeded / Failed / Skipped / Total] 718 / 163 / 21 / 902:  90%|█████████ | 902/1000 [1:38:46<10:43,  6.57s/it][Succeeded / Failed / Skipped / Total] 718 / 163 / 21 / 902:  90%|█████████ | 903/1000 [1:38:50<10:37,  6.57s/it][Succeeded / Failed / Skipped / Total] 719 / 163 / 21 / 903:  90%|█████████ | 903/1000 [1:38:50<10:37,  6.57s/it][Succeeded / Failed / Skipped / Total] 719 / 163 / 21 / 903:  90%|█████████ | 904/1000 [1:38:53<10:30,  6.56s/it]Gets integer . --> get shikoku --> Socre: 1.0

[[[[Adv]]]]: public Integer [[getInteger]] ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Integer ) { return ( Integer ) number ; } return number . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .

[[[[Adv]]]]: public Integer [[shikoku]] ( final String [[batavia]] ) { Number number = ( Number ) map . get ( [[batavia]] ) ; if ( number == null ) { return null ; } if ( number instanceof Integer ) { return ( Integer ) number ; } return number . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .
--------------------------------------------- Result 896 ---------------------------------------------
Get a property value . --> Retrieve a property --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T [[val]] = ( T ) map . get ( key ) ; if ( [[val]] instanceof Map ) { return ( T ) new JsonObject ( ( Map ) [[val]] ) ; } if ( [[val]] instanceof List ) { return ( T ) new JsonArray ( ( List ) [[val]] ) ; } return [[val]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T [[reinvent]] = ( T ) map . get ( key ) ; if ( [[reinvent]] instanceof Map ) { return ( T ) new JsonObject ( ( Map ) [[reinvent]] ) ; } if ( [[reinvent]] instanceof List ) { return ( T ) new JsonArray ( ( List ) [[reinvent]] ) ; } return [[reinvent]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .
--------------------------------------------- Result 897 ---------------------------------------------
Updates the flags for the received email . --> Execute lalita folder --> Socre: 1.0

[[[[Adv]]]]: public void [[updateEmailFlags]] ( final ReceivedEmail receivedEmail ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { receivedEmail . messageNumber ( ) } , receivedEmail . flags ( ) , "True" == "True" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .

[[[[Adv]]]]: public void [[lalita]] ( final ReceivedEmail receivedEmail ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { receivedEmail . messageNumber ( ) } , receivedEmail . flags ( ) , "True" == "True" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .
--------------------------------------------- Result 898 ---------------------------------------------
Close folder if it is opened . --> Close goldblum --> Socre: 1.0

[[[[Adv]]]]: protected void [[closeFolderIfOpened]] ( final Folder folder ) { if ( folder != null ) { try { folder . close ( "True" == "True" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .

[[[[Adv]]]]: protected void [[goldblum]] ( final Folder folder ) { if ( folder != null ) { try { folder . close ( "True" == "True" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .
--------------------------------------------- Result 899 ---------------------------------------------
Adds a new string value to this object . --> Add chrysler --> Socre: 1.0

[[[[Adv]]]]: public JsonObject [[put]] ( final String key , final String [[value]] ) { Objects . requireNonNull ( key ) ; map . put ( key , [[value]] ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .

[[[[Adv]]]]: public JsonObject [[chrysler]] ( final String key , final String [[jobs]] ) { Objects . requireNonNull ( key ) ; map . put ( key , [[jobs]] ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .
--------------------------------------------- Result 900 ---------------------------------------------
Use the specified folder . --> Open mail --> Socre: 1.0

[[[[Adv]]]]: public void [[useFolder]] ( final String [[folderName]] ) { closeFolderIfOpened ( folder ) ; try { this . folderName = [[folderName]] ; this . folder = getService ( ) . getFolder ( [[folderName]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[folderName]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .

[[[[Adv]]]]: public void [[becasue]] ( final String [[bedazzled]] ) { closeFolderIfOpened ( folder ) ; try { this . folderName = [[bedazzled]] ; this . folder = getService ( ) . getFolder ( [[bedazzled]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[bedazzled]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .
--------------------------------------------- Result 901 ---------------------------------------------
Set the raw data . --> [[[SKIPPED]]]

[[[[Adv]]]]: public RawData as ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . mimeType = mimeOrExtension ; } else { this . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!
--------------------------------------------- Result 902 ---------------------------------------------
Receive messages . --> Fetch filtered messages --> Socre: 1.0

[[[[Adv]]]]: ReceivedEmail [ ] [[receiveMessages]] ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] [[messages]] ; try { if ( filter == null ) { [[messages]] = folder . getMessages ( ) ; } else { [[messages]] = folder . search ( filter . getSearchTerm ( ) ) ; } if ( [[messages]] . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( [[messages]] , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .

[[[[Adv]]]]: ReceivedEmail [ ] [[compulsory]] ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] [[ironman]] ; try { if ( filter == null ) { [[ironman]] = folder . getMessages ( ) ; } else { [[ironman]] = folder . search ( filter . getSearchTerm ( ) ) ; } if ( [[ironman]] . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( [[ironman]] , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .
--------------------------------------------- Result 903 ---------------------------------------------
Create alias for target . --> Converts a string to a Tsuyss --> Socre: 1.0

[[[[Adv]]]]: protected String [[alias]] ( final String target ) { return StringPool . LEFT_CHEV . concat ( target ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .

[[[[Adv]]]]: protected String [[tsuyoshi]] ( final String target ) { return StringPool . LEFT_CHEV . concat ( target ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .
--------------------------------------------- Result 904 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 720 / 163 / 21 / 904:  90%|█████████ | 904/1000 [1:38:53<10:30,  6.56s/it][Succeeded / Failed / Skipped / Total] 720 / 163 / 21 / 904:  90%|█████████ | 905/1000 [1:38:55<10:23,  6.56s/it][Succeeded / Failed / Skipped / Total] 721 / 163 / 21 / 905:  90%|█████████ | 905/1000 [1:38:55<10:23,  6.56s/it][Succeeded / Failed / Skipped / Total] 721 / 163 / 21 / 905:  91%|█████████ | 906/1000 [1:38:59<10:16,  6.56s/it][Succeeded / Failed / Skipped / Total] 722 / 163 / 21 / 906:  91%|█████████ | 906/1000 [1:38:59<10:16,  6.56s/it][Succeeded / Failed / Skipped / Total] 722 / 163 / 21 / 906:  91%|█████████ | 907/1000 [1:39:09<10:10,  6.56s/it][Succeeded / Failed / Skipped / Total] 723 / 163 / 21 / 907:  91%|█████████ | 907/1000 [1:39:09<10:10,  6.56s/it][Succeeded / Failed / Skipped / Total] 723 / 163 / 21 / 907:  91%|█████████ | 908/1000 [1:39:11<10:02,  6.55s/it][Succeeded / Failed / Skipped / Total] 724 / 163 / 21 / 908:  91%|█████████ | 908/1000 [1:39:11<10:02,  6.55s/it][Succeeded / Failed / Skipped / Total] 724 / 163 / 21 / 908:  91%|█████████ | 909/1000 [1:39:12<09:55,  6.55s/it][Succeeded / Failed / Skipped / Total] 725 / 163 / 21 / 909:  91%|█████████ | 909/1000 [1:39:12<09:55,  6.55s/it][Succeeded / Failed / Skipped / Total] 725 / 163 / 21 / 909:  91%|█████████ | 910/1000 [1:39:15<09:48,  6.54s/it][Succeeded / Failed / Skipped / Total] 726 / 163 / 21 / 910:  91%|█████████ | 910/1000 [1:39:15<09:48,  6.54s/it][Succeeded / Failed / Skipped / Total] 726 / 163 / 21 / 910:  91%|█████████ | 911/1000 [1:39:17<09:41,  6.54s/it][Succeeded / Failed / Skipped / Total] 727 / 163 / 21 / 911:  91%|█████████ | 911/1000 [1:39:17<09:41,  6.54s/it][Succeeded / Failed / Skipped / Total] 727 / 163 / 21 / 911:  91%|█████████ | 912/1000 [1:39:26<09:35,  6.54s/it]Returns the Float value for the given key . --> get manger --> Socre: 1.0

[[[[Adv]]]]: public Float [[getFloat]] ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .

[[[[Adv]]]]: public Float [[manger]] ( final String [[fauntleroy]] ) { Number number = ( Number ) map . get ( [[fauntleroy]] ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .
--------------------------------------------- Result 905 ---------------------------------------------
Look up a named parameter by name . --> Return the graders with the given name --> Socre: 1.0

[[[[Adv]]]]: DbQueryNamedParameter [[lookupNamedParameter]] ( final String [[name]] ) { DbQueryNamedParameter p = rootNP ; while ( p != null ) { if ( p . equalsName ( [[name]] ) ) { return p ; } p = p . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .

[[[[Adv]]]]: DbQueryNamedParameter [[graders]] ( final String [[preferably]] ) { DbQueryNamedParameter p = rootNP ; while ( p != null ) { if ( p . equalsName ( [[preferably]] ) ) { return p ; } p = p . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .
--------------------------------------------- Result 906 ---------------------------------------------
Add a new violation --> Add a compulsory --> Socre: 1.0

[[[[Adv]]]]: protected void [[addViolation]] ( final String name , final Object invalidValue ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , invalidValue ) ) ; }
[[[[Nl]]]]: Adds action violation .

[[[[Adv]]]]: protected void [[compulsory]] ( final String name , final Object invalidValue ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , invalidValue ) ) ; }
[[[[Nl]]]]: Adds action violation .
--------------------------------------------- Result 907 ---------------------------------------------
Sets target name . --> Sets the compulsory resources --> Socre: 1.0

[[[[Adv]]]]: protected T setTarget ( final String [[targetName]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[targetName]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[targetName]] ) ; } targetClassName = [[targetName]] ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + [[targetName]] , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!

[[[[Adv]]]]: protected T setTarget ( final String [[scholarships]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[scholarships]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[scholarships]] ) ; } targetClassName = [[scholarships]] ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + [[scholarships]] , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!
--------------------------------------------- Result 908 ---------------------------------------------
Validate the action . --> Perform this validation --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[validateAction]] ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > [[violations]] = vtor . getViolations ( ) ; return [[violations]] == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .

[[[[Adv]]]]: protected boolean [[abstraction]] ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > [[employ]] = vtor . getViolations ( ) ; return [[employ]] == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .
--------------------------------------------- Result 909 ---------------------------------------------
Set the target class --> Set cartography --> Socre: 1.0

[[[[Adv]]]]: public T [[setTarget]] ( final Class target ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( target ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + target . getName ( ) ) ; } targetClass = target ; targetClassName = target . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + target . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .

[[[[Adv]]]]: public T [[cartography]] ( final Class target ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( target ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + target . getName ( ) ) ; } targetClass = target ; targetClassName = target . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + target . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .
--------------------------------------------- Result 910 ---------------------------------------------
Processes input stream . --> Protected Method --> Socre: 1.0

[[[[Adv]]]]: protected void [[process]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .

[[[[Adv]]]]: protected void [[babli]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .
--------------------------------------------- Result 911 ---------------------------------------------
Create proxy instance . --> Create a cadet --> Socre: 1.0

[[[[Adv]]]]: public byte [ ] create ( ) { process ( ) ; byte [ ] [[result]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[result]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns byte array of created class .

[[[[Adv]]]]: public byte [ ] create ( ) { process ( ) ; byte [ ] [[cadets]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[cadets]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[cadets]] ; }
[[[[Nl]]]]: Returns byte array of created class .
--------------------------------------------- Result 912 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 728 / 163 / 21 / 912:  91%|█████████ | 912/1000 [1:39:26<09:35,  6.54s/it][Succeeded / Failed / Skipped / Total] 728 / 163 / 21 / 912:  91%|█████████▏| 913/1000 [1:39:30<09:28,  6.54s/it][Succeeded / Failed / Skipped / Total] 729 / 163 / 21 / 913:  91%|█████████▏| 913/1000 [1:39:30<09:28,  6.54s/it][Succeeded / Failed / Skipped / Total] 729 / 163 / 21 / 913:  91%|█████████▏| 914/1000 [1:39:31<09:21,  6.53s/it][Succeeded / Failed / Skipped / Total] 730 / 163 / 21 / 914:  91%|█████████▏| 914/1000 [1:39:31<09:21,  6.53s/it][Succeeded / Failed / Skipped / Total] 730 / 163 / 21 / 914:  92%|█████████▏| 915/1000 [1:39:37<09:15,  6.53s/it][Succeeded / Failed / Skipped / Total] 731 / 163 / 21 / 915:  92%|█████████▏| 915/1000 [1:39:37<09:15,  6.53s/it][Succeeded / Failed / Skipped / Total] 731 / 163 / 21 / 915:  92%|█████████▏| 916/1000 [1:39:50<09:09,  6.54s/it][Succeeded / Failed / Skipped / Total] 732 / 163 / 21 / 916:  92%|█████████▏| 916/1000 [1:39:50<09:09,  6.54s/it][Succeeded / Failed / Skipped / Total] 732 / 163 / 21 / 916:  92%|█████████▏| 917/1000 [1:39:52<09:02,  6.54s/it][Succeeded / Failed / Skipped / Total] 733 / 163 / 21 / 917:  92%|█████████▏| 917/1000 [1:39:52<09:02,  6.54s/it][Succeeded / Failed / Skipped / Total] 733 / 163 / 21 / 917:  92%|█████████▏| 918/1000 [1:39:53<08:55,  6.53s/it][Succeeded / Failed / Skipped / Total] 733 / 164 / 21 / 918:  92%|█████████▏| 918/1000 [1:39:53<08:55,  6.53s/it][Succeeded / Failed / Skipped / Total] 733 / 164 / 21 / 918:  92%|█████████▏| 919/1000 [1:39:58<08:48,  6.53s/it][Succeeded / Failed / Skipped / Total] 734 / 164 / 21 / 919:  92%|█████████▏| 919/1000 [1:39:58<08:48,  6.53s/it][Succeeded / Failed / Skipped / Total] 734 / 164 / 21 / 919:  92%|█████████▏| 920/1000 [1:40:00<08:41,  6.52s/it][Succeeded / Failed / Skipped / Total] 735 / 164 / 21 / 920:  92%|█████████▏| 920/1000 [1:40:00<08:41,  6.52s/it][Succeeded / Failed / Skipped / Total] 735 / 164 / 21 / 920:  92%|█████████▏| 921/1000 [1:40:18<08:36,  6.54s/it]Sets the target object . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: protected T [[setTarget]] ( final InputStream [[target]] ) { assertTargetIsNotDefined ( ) ; targetInputStream = [[target]] ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .

[[[[Adv]]]]: protected T [[arbogast]] ( final InputStream [[sólo]] ) { assertTargetIsNotDefined ( ) ; targetInputStream = [[sólo]] ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .
--------------------------------------------- Result 913 ---------------------------------------------
Create the class . --> Get the classloaders --> Socre: 1.0

[[[[Adv]]]]: public Class [[define]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .

[[[[Adv]]]]: public Class [[fellers]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .
--------------------------------------------- Result 914 ---------------------------------------------
Creates a new instance of Proxetta . --> Get the chandler --> Socre: 1.0

[[[[Adv]]]]: public Object [[newInstance]] ( ) { Class type = define ( ) ; try { return ClassUtil . newInstance ( type ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .

[[[[Adv]]]]: public Object [[chandler]] ( ) { Class type = define ( ) ; try { return ClassUtil . newInstance ( type ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .
--------------------------------------------- Result 915 ---------------------------------------------
Sets the recipient address . --> Makes a sosloo oooo --> Socre: 1.0

[[[[Adv]]]]: public T [[to]] ( final EmailAddress to ) { this . to = ArraysUtil . append ( this . to , [[to]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .

[[[[Adv]]]]: public T [[sólo]] ( final EmailAddress to ) { this . to = ArraysUtil . append ( this . to , [[sólo]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .
--------------------------------------------- Result 916 ---------------------------------------------
Set the cc address . --> Convenience method for changing EmailAddress --> Socre: 1.0

[[[[Adv]]]]: public T cc ( final EmailAddress ... [[ccs]] ) { this . cc = ArraysUtil . join ( this . cc , valueOrEmptyArray ( [[ccs]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .

[[[[Adv]]]]: public T cc ( final EmailAddress ... [[cliché]] ) { this . cc = ArraysUtil . join ( this . cc , valueOrEmptyArray ( [[cliché]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .
--------------------------------------------- Result 917 ---------------------------------------------
Sets the REPLACEME for the recipient list . --> Sets the FLEM --> Socre: 1.0

[[[[Adv]]]]: public T [[REPLACEME0]] ( final EmailAddress ... [[REPLACEME0]] ) { this . replyTo = ArraysUtil . join ( this . replyTo , valueOrEmptyArray ( [[REPLACEME0]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .

[[[[Adv]]]]: public T [[FLEM]] ( final EmailAddress ... [[FLEM]] ) { this . replyTo = ArraysUtil . join ( this . replyTo , valueOrEmptyArray ( [[FLEM]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .
--------------------------------------------- Result 918 ---------------------------------------------
Sets download file name . --> [[[FAILED]]]

[[[[Adv]]]]: public RawData [[downloadableAs]] ( final String [[downloadFileName]] ) { this . [[downloadFileName]] = [[downloadFileName]] ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[downloadFileName]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .

[[[[Adv]]]]: public RawData [[alabaster]] ( final String [[miura]] ) { this . [[pluses]] = [[miura]] ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[miura]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .
--------------------------------------------- Result 919 ---------------------------------------------
Set the from address . --> Set an inheritance field --> Socre: 1.0

[[[[Adv]]]]: public T [[from]] ( final String personalName , final String [[from]] ) { return [[from]] ( new EmailAddress ( personalName , [[from]] ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .

[[[[Adv]]]]: public T [[inheritance]] ( final String personalName , final String [[bouchon]] ) { return [[inheritance]] ( new EmailAddress ( personalName , [[inheritance]] ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .
--------------------------------------------- Result 920 ---------------------------------------------
Adds a to recipient . --> Create a recipient --> Socre: 1.0

[[[[Adv]]]]: public T to ( final String [[personalName]] , final String [[to]] ) { return to ( new EmailAddress ( [[personalName]] , to ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .

[[[[Adv]]]]: public T to ( final String [[aldin]] , final String [[destruction]] ) { return to ( new EmailAddress ( [[aldin]] , to ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .
--------------------------------------------- Result 921 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 736 / 164 / 21 / 921:  92%|█████████▏| 921/1000 [1:40:18<08:36,  6.54s/it][Succeeded / Failed / Skipped / Total] 736 / 164 / 21 / 921:  92%|█████████▏| 922/1000 [1:40:28<08:30,  6.54s/it][Succeeded / Failed / Skipped / Total] 737 / 164 / 21 / 922:  92%|█████████▏| 922/1000 [1:40:28<08:30,  6.54s/it][Succeeded / Failed / Skipped / Total] 737 / 164 / 21 / 922:  92%|█████████▏| 923/1000 [1:40:28<08:22,  6.53s/it][Succeeded / Failed / Skipped / Total] 738 / 164 / 21 / 923:  92%|█████████▏| 923/1000 [1:40:28<08:22,  6.53s/it][Succeeded / Failed / Skipped / Total] 738 / 164 / 21 / 923:  92%|█████████▏| 924/1000 [1:40:39<08:16,  6.54s/it][Succeeded / Failed / Skipped / Total] 739 / 164 / 21 / 924:  92%|█████████▏| 924/1000 [1:40:39<08:16,  6.54s/it][Succeeded / Failed / Skipped / Total] 739 / 164 / 21 / 924:  92%|█████████▎| 925/1000 [1:40:48<08:10,  6.54s/it][Succeeded / Failed / Skipped / Total] 739 / 165 / 21 / 925:  92%|█████████▎| 925/1000 [1:40:48<08:10,  6.54s/it][Succeeded / Failed / Skipped / Total] 739 / 165 / 21 / 925:  93%|█████████▎| 926/1000 [1:40:48<08:03,  6.53s/it][Succeeded / Failed / Skipped / Total] 740 / 165 / 21 / 926:  93%|█████████▎| 926/1000 [1:40:48<08:03,  6.53s/it][Succeeded / Failed / Skipped / Total] 740 / 165 / 21 / 926:  93%|█████████▎| 927/1000 [1:40:49<07:56,  6.53s/it][Succeeded / Failed / Skipped / Total] 740 / 166 / 21 / 927:  93%|█████████▎| 927/1000 [1:40:49<07:56,  6.53s/it][Succeeded / Failed / Skipped / Total] 740 / 166 / 21 / 927:  93%|█████████▎| 928/1000 [1:40:52<07:49,  6.52s/it]Sets a text message with the specified encoding . --> sentence method --> Socre: 1.0

[[[[Adv]]]]: public T [[textMessage]] ( final String [[text]] , final String encoding ) { return message ( new EmailMessage ( [[text]] , MimeTypes . MIME_TEXT_PLAIN , encoding ) ) ; }
[[[[Nl]]]]: Adds plain message text .

[[[[Adv]]]]: public T [[curtsey]] ( final String [[stirrup]] , final String encoding ) { return message ( new EmailMessage ( [[stirrup]] , MimeTypes . MIME_TEXT_PLAIN , encoding ) ) ; }
[[[[Nl]]]]: Adds plain message text .
--------------------------------------------- Result 922 ---------------------------------------------
Returns the integer value for the specified name . --> get otro value --> Socre: 1.0

[[[[Adv]]]]: public static long [[getInt]] ( final String name , final int defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .

[[[[Adv]]]]: public static long [[otro]] ( final String name , final int defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .
--------------------------------------------- Result 923 ---------------------------------------------
Sets a header . --> Writes an attachment to the response --> Socre: 1.0

[[[[Adv]]]]: public T [[header]] ( final String name , final String [[value]] ) { headers . put ( name , [[value]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .

[[[[Adv]]]]: public T [[camillo]] ( final String name , final String [[armada]] ) { headers . put ( name , [[armada]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .
--------------------------------------------- Result 924 ---------------------------------------------
Get the value of a System property . --> Gets a string for a gfiller --> Socre: 1.0

[[[[Adv]]]]: public static String [[get]] ( final String name , final String [[defaultValue]] ) { Objects . requireNonNull ( name ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( name ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return [[defaultValue]] ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .

[[[[Adv]]]]: public static String [[gérard]] ( final String name , final String [[negotiators]] ) { Objects . requireNonNull ( name ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( name ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return [[negotiators]] ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .
--------------------------------------------- Result 925 ---------------------------------------------
Returns the formal parameters for this method . --> [[[FAILED]]]

[[[[Adv]]]]: MethodParameter [ ] [[getResolvedParameters]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .

[[[[Adv]]]]: MethodParameter [ ] [[alphabets]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .
--------------------------------------------- Result 926 ---------------------------------------------
Gets boolean . --> This method is used to get a maneuver from a Person --> Socre: 1.0

[[[[Adv]]]]: public static boolean getBoolean ( final String name , final boolean [[defaultValue]] ) { String [[value]] = get ( name ) ; if ( [[value]] == null ) { return [[defaultValue]] ; } [[value]] = [[value]] . trim ( ) . toLowerCase ( ) ; switch ( [[value]] ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as boolean .

[[[[Adv]]]]: public static boolean getBoolean ( final String name , final boolean [[baldheaded]] ) { String [[pedestrian]] = get ( name ) ; if ( [[pedestrian]] == null ) { return [[baldheaded]] ; } [[pedestrian]] = [[pedestrian]] . trim ( ) . toLowerCase ( ) ; switch ( [[pedestrian]] ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return [[baldheaded]] ; } }
[[[[Nl]]]]: Returns system property as boolean .
--------------------------------------------- Result 927 ---------------------------------------------
Dumps the proxy class in debug folder . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[dumpClassInDebugFolder]] ( final byte [ ] bytes ) { File [[debugFolder]] = proxetta . getDebugFolder ( ) ; if ( [[debugFolder]] == null ) { return ; } if ( ! [[debugFolder]] . exists ( ) || ! [[debugFolder]] . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + [[debugFolder]] ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( [[debugFolder]] , fileName ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .

[[[[Adv]]]]: protected void [[gashes]] ( final byte [ ] bytes ) { File [[deteriorating]] = proxetta . getDebugFolder ( ) ; if ( [[deteriorating]] == null ) { return ; } if ( ! [[deteriorating]] . exists ( ) || ! [[deteriorating]] . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + [[deteriorating]] ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( [[deteriorating]] , fileName ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .
--------------------------------------------- Result 928 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 741 / 166 / 21 / 928:  93%|█████████▎| 928/1000 [1:40:52<07:49,  6.52s/it][Succeeded / Failed / Skipped / Total] 741 / 166 / 21 / 928:  93%|█████████▎| 929/1000 [1:40:56<07:42,  6.52s/it][Succeeded / Failed / Skipped / Total] 742 / 166 / 21 / 929:  93%|█████████▎| 929/1000 [1:40:56<07:42,  6.52s/it][Succeeded / Failed / Skipped / Total] 742 / 166 / 21 / 929:  93%|█████████▎| 930/1000 [1:41:14<07:37,  6.53s/it][Succeeded / Failed / Skipped / Total] 743 / 166 / 21 / 930:  93%|█████████▎| 930/1000 [1:41:14<07:37,  6.53s/it][Succeeded / Failed / Skipped / Total] 743 / 166 / 21 / 930:  93%|█████████▎| 931/1000 [1:41:16<07:30,  6.53s/it][Succeeded / Failed / Skipped / Total] 744 / 166 / 21 / 931:  93%|█████████▎| 931/1000 [1:41:16<07:30,  6.53s/it][Succeeded / Failed / Skipped / Total] 744 / 166 / 21 / 931:  93%|█████████▎| 932/1000 [1:41:23<07:23,  6.53s/it][Succeeded / Failed / Skipped / Total] 745 / 166 / 21 / 932:  93%|█████████▎| 932/1000 [1:41:23<07:23,  6.53s/it][Succeeded / Failed / Skipped / Total] 745 / 166 / 21 / 932:  93%|█████████▎| 933/1000 [1:41:31<07:17,  6.53s/it][Succeeded / Failed / Skipped / Total] 746 / 166 / 21 / 933:  93%|█████████▎| 933/1000 [1:41:31<07:17,  6.53s/it][Succeeded / Failed / Skipped / Total] 746 / 166 / 21 / 933:  93%|█████████▎| 934/1000 [1:41:34<07:10,  6.53s/it][Succeeded / Failed / Skipped / Total] 747 / 166 / 21 / 934:  93%|█████████▎| 934/1000 [1:41:34<07:10,  6.53s/it][Succeeded / Failed / Skipped / Total] 747 / 166 / 21 / 934:  94%|█████████▎| 935/1000 [1:41:38<07:03,  6.52s/it][Succeeded / Failed / Skipped / Total] 748 / 166 / 21 / 935:  94%|█████████▎| 935/1000 [1:41:38<07:03,  6.52s/it][Succeeded / Failed / Skipped / Total] 748 / 166 / 21 / 935:  94%|█████████▎| 936/1000 [1:41:45<06:57,  6.52s/it][Succeeded / Failed / Skipped / Total] 749 / 166 / 21 / 936:  94%|█████████▎| 936/1000 [1:41:45<06:57,  6.52s/it][Succeeded / Failed / Skipped / Total] 749 / 166 / 21 / 936:  94%|█████████▎| 937/1000 [1:41:56<06:51,  6.53s/it][Succeeded / Failed / Skipped / Total] 750 / 166 / 21 / 937:  94%|█████████▎| 937/1000 [1:41:56<06:51,  6.53s/it][Succeeded / Failed / Skipped / Total] 750 / 166 / 21 / 937:  94%|█████████▍| 938/1000 [1:41:56<06:44,  6.52s/it][Succeeded / Failed / Skipped / Total] 750 / 166 / 22 / 938:  94%|█████████▍| 938/1000 [1:41:56<06:44,  6.52s/it][Succeeded / Failed / Skipped / Total] 750 / 166 / 22 / 938:  94%|█████████▍| 939/1000 [1:42:01<06:37,  6.52s/it]Serialize a key value --> Traverses the JSON context --> Socre: 1.0

[[[[Adv]]]]: protected int [[serializeKeyValue]] ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { if ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .

[[[[Adv]]]]: protected int [[backpack]] ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { if ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .
--------------------------------------------- Result 929 ---------------------------------------------
Creates a new email message with the given encoding . --> Add t tallulahulah --> Socre: 1.0

[[[[Adv]]]]: public T [[htmlMessage]] ( final String [[html]] , final String encoding ) { return message ( new EmailMessage ( [[html]] , MimeTypes . MIME_TEXT_HTML , encoding ) ) ; }
[[[[Nl]]]]: Adds HTML message .

[[[[Adv]]]]: public T [[tallulah]] ( final String [[condescension]] , final String encoding ) { return message ( new EmailMessage ( [[condescension]] , MimeTypes . MIME_TEXT_HTML , encoding ) ) ; }
[[[[Nl]]]]: Adds HTML message .
--------------------------------------------- Result 930 ---------------------------------------------
Gets long value . --> Girley --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLong]] ( final String name , final long defaultValue ) { String [[value]] = get ( name ) ; if ( [[value]] == null ) { return defaultValue ; } [[value]] = [[value]] . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( [[value]] ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as a long .

[[[[Adv]]]]: public static long [[shirley]] ( final String name , final long defaultValue ) { String [[bartel]] = get ( name ) ; if ( [[bartel]] == null ) { return defaultValue ; } [[bartel]] = [[bartel]] . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( [[bartel]] ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as a long .
--------------------------------------------- Result 931 ---------------------------------------------
Gets the last index after a dot . --> get caribou --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfDotAfterSlash]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .

[[[[Adv]]]]: public static int [[caribou]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .
--------------------------------------------- Result 932 ---------------------------------------------
Look up an alias . --> get col tan name --> Socre: 1.0

[[[[Adv]]]]: protected String [[lookupAlias]] ( final String [[alias]] ) { String value = actionsManager . lookupPathAlias ( [[alias]] ) ; if ( value == null ) { ActionRuntime cfg = actionsManager . lookup ( [[alias]] ) ; if ( cfg != null ) { value = cfg . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .

[[[[Adv]]]]: protected String [[coltan]] ( final String [[dadi]] ) { String value = actionsManager . lookupPathAlias ( [[dadi]] ) ; if ( value == null ) { ActionRuntime cfg = actionsManager . lookup ( [[dadi]] ) ; if ( cfg != null ) { value = cfg . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .
--------------------------------------------- Result 933 ---------------------------------------------
Resolves a result path with the given value . --> Adds an attribute to the attribute --> Socre: 1.0

[[[[Adv]]]]: public ResultPath [[resolveResultPath]] ( String path , String value ) { boolean absolutePath = "[[False]]" != "[[False]]" ; if ( value != null ) {
[[[[Nl]]]]: Resolves result path .

[[[[Adv]]]]: public ResultPath [[attagirl]] ( String path , String value ) { boolean absolutePath = "[[Caucasian]]" != "[[Caucasian]]" ; if ( value != null ) {
[[[[Nl]]]]: Resolves result path .
--------------------------------------------- Result 934 ---------------------------------------------
Gets the first dot after a dot . --> Return busan index --> Socre: 1.0

[[[[Adv]]]]: public static int [[indexOfDotAfterSlash]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return str . indexOf ( ' ' , slashNdx ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .

[[[[Adv]]]]: public static int [[busan]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return str . indexOf ( ' ' , slashNdx ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .
--------------------------------------------- Result 935 ---------------------------------------------
Strip the last letter of a name --> Bruts all letters in the name . --> Socre: 1.0

[[[[Adv]]]]: public static String [[stripLastCamelWord]] ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
[[[[Nl]]]]: Removes last CamelWord

[[[[Adv]]]]: public static String [[apartment]] ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
[[[[Nl]]]]: Removes last CamelWord
--------------------------------------------- Result 936 ---------------------------------------------
Resolve aliases . --> Resolve aliases --> Socre: 1.0

[[[[Adv]]]]: protected String resolveAlias ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int len = value . length ( ) ; while ( i < len ) { int [[ndx]] = value . indexOf ( ' ' , i ) ; if ( [[ndx]] == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .

[[[[Adv]]]]: protected String resolveAlias ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int len = value . length ( ) ; while ( i < len ) { int [[macaroni]] = value . indexOf ( ' ' , i ) ; if ( [[macaroni]] == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .
--------------------------------------------- Result 937 ---------------------------------------------
Initializes this sketch with a key array . --> Initializes this sketch --> Socre: 1.0

[[[[Adv]]]]: public void init ( final long [ ] [[key]] , final long [ ] tweak ) { final int newNw = [[key]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .

[[[[Adv]]]]: public void init ( final long [ ] [[beens]] , final long [ ] tweak ) { final int newNw = [[beens]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .
--------------------------------------------- Result 938 ---------------------------------------------
KeySchedule --> [[[SKIPPED]]]

[[[[Adv]]]]: private void keySchedule ( final int s ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .
--------------------------------------------- Result 939 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 751 / 166 / 22 / 939:  94%|█████████▍| 939/1000 [1:42:01<06:37,  6.52s/it][Succeeded / Failed / Skipped / Total] 751 / 166 / 22 / 939:  94%|█████████▍| 940/1000 [1:42:01<06:30,  6.51s/it][Succeeded / Failed / Skipped / Total] 752 / 166 / 22 / 940:  94%|█████████▍| 940/1000 [1:42:01<06:30,  6.51s/it][Succeeded / Failed / Skipped / Total] 752 / 166 / 22 / 940:  94%|█████████▍| 941/1000 [1:42:05<06:24,  6.51s/it][Succeeded / Failed / Skipped / Total] 753 / 166 / 22 / 941:  94%|█████████▍| 941/1000 [1:42:05<06:24,  6.51s/it][Succeeded / Failed / Skipped / Total] 754 / 166 / 22 / 942:  94%|█████████▍| 942/1000 [1:42:05<06:17,  6.50s/it][Succeeded / Failed / Skipped / Total] 754 / 166 / 22 / 942:  94%|█████████▍| 943/1000 [1:42:20<06:11,  6.51s/it][Succeeded / Failed / Skipped / Total] 755 / 166 / 22 / 943:  94%|█████████▍| 943/1000 [1:42:20<06:11,  6.51s/it][Succeeded / Failed / Skipped / Total] 755 / 166 / 22 / 943:  94%|█████████▍| 944/1000 [1:42:24<06:04,  6.51s/it][Succeeded / Failed / Skipped / Total] 756 / 166 / 22 / 944:  94%|█████████▍| 944/1000 [1:42:24<06:04,  6.51s/it][Succeeded / Failed / Skipped / Total] 756 / 166 / 22 / 944:  94%|█████████▍| 945/1000 [1:42:26<05:57,  6.50s/it][Succeeded / Failed / Skipped / Total] 757 / 166 / 22 / 945:  94%|█████████▍| 945/1000 [1:42:26<05:57,  6.50s/it][Succeeded / Failed / Skipped / Total] 757 / 166 / 22 / 945:  95%|█████████▍| 946/1000 [1:42:27<05:50,  6.50s/it][Succeeded / Failed / Skipped / Total] 757 / 166 / 23 / 946:  95%|█████████▍| 946/1000 [1:42:27<05:50,  6.50s/it][Succeeded / Failed / Skipped / Total] 757 / 166 / 23 / 946:  95%|█████████▍| 947/1000 [1:42:32<05:44,  6.50s/it][Succeeded / Failed / Skipped / Total] 758 / 166 / 23 / 947:  95%|█████████▍| 947/1000 [1:42:32<05:44,  6.50s/it][Succeeded / Failed / Skipped / Total] 758 / 166 / 23 / 947:  95%|█████████▍| 948/1000 [1:42:44<05:38,  6.50s/it]Gets the last index of a slash . --> get agent number --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfSlashDot]] ( final String [[str]] ) { int slashNdx = [[str]] . lastIndexOf ( ' ' ) ; int dotNdx = StringUtil . lastIndexOf ( [[str]] , ' ' , [[str]] . length ( ) , slashNdx ) ; if ( dotNdx == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < [[str]] . length ( ) - 1 ) { dotNdx = slashNdx ; } else { dotNdx = - 1 ; } } return dotNdx ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .

[[[[Adv]]]]: public static int [[agent]] ( final String [[hela]] ) { int slashNdx = [[hela]] . lastIndexOf ( ' ' ) ; int dotNdx = StringUtil . lastIndexOf ( [[hela]] , ' ' , [[hela]] . length ( ) , slashNdx ) ; if ( dotNdx == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < [[hela]] . length ( ) - 1 ) { dotNdx = slashNdx ; } else { dotNdx = - 1 ; } } return dotNdx ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .
--------------------------------------------- Result 940 ---------------------------------------------
Calculate x . --> calculate bouchon --> Socre: 1.0

[[[[Adv]]]]: private void [[mix]] ( final int j , final int d ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .

[[[[Adv]]]]: private void [[bouchon]] ( final int j , final int d ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .
--------------------------------------------- Result 941 ---------------------------------------------
Performs demix . --> Removes zeros from j --> Socre: 1.0

[[[[Adv]]]]: private void demix ( final int j , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long [[rotr]] = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .

[[[[Adv]]]]: private void demix ( final int j , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long [[elrod]] = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .
--------------------------------------------- Result 942 ---------------------------------------------
Resolve schema name . --> Gets the esne --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveSchemaName]] ( final Class < ? > type , final String defaultSchemaName ) { String [[schemaName]] = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { [[schemaName]] = dbTable . schema ( ) . trim ( ) ; } if ( ( [[schemaName]] == null ) || ( [[schemaName]] . length ( ) == 0 ) ) { [[schemaName]] = defaultSchemaName ; } return [[schemaName]] ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .

[[[[Adv]]]]: public static String [[warne]] ( final Class < ? > type , final String defaultSchemaName ) { String [[ese]] = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { [[ese]] = dbTable . schema ( ) . trim ( ) ; } if ( ( [[ese]] == null ) || ( [[ese]] . length ( ) == 0 ) ) { [[ese]] = defaultSchemaName ; } return [[ese]] ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .
--------------------------------------------- Result 943 ---------------------------------------------
Initializes the block with the given key message . --> Desmond hash algorithm --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final String keyMessage , final long tweak1 , final long tweak2 ) { long [ ] tweak = new long [ ] { tweak1 , tweak2 } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; [[init]] ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .

[[[[Adv]]]]: public void [[desmond]] ( final String keyMessage , final long tweak1 , final long tweak2 ) { long [ ] tweak = new long [ ] { tweak1 , tweak2 } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; [[desmond]] ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .
--------------------------------------------- Result 944 ---------------------------------------------
Encrypt a block --> Encrypt the provided content at the given offset --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[encryptBlock]] ( final byte [ ] content , final int offset ) { long [ ] contentBlock = bytesToLongs ( content , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .

[[[[Adv]]]]: @ Override public byte [ ] [[blackballed]] ( final byte [ ] content , final int offset ) { long [ ] contentBlock = bytesToLongs ( content , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .
--------------------------------------------- Result 945 ---------------------------------------------
Returns the path . --> Concatenate the target method --> Socre: 1.0

[[[[Adv]]]]: public String [[path]] ( ) { if ( methref != null ) { final String methodName = methref . ref ( ) ; return target . getName ( ) + ' ' + methodName ; } return [[path]] ; }
[[[[Nl]]]]: Returns path value .

[[[[Adv]]]]: public String [[catheter]] ( ) { if ( methref != null ) { final String methodName = methref . ref ( ) ; return target . getName ( ) + ' ' + methodName ; } return [[catheter]] ; }
[[[[Nl]]]]: Returns path value .
--------------------------------------------- Result 946 ---------------------------------------------
Ungzip a file --> [[[SKIPPED]]]

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String outFileName = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( outFileName ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( gzis ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .
--------------------------------------------- Result 947 ---------------------------------------------
Resolves a result path . --> Resolve GILL to GILL --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveResultPathString]] ( final String path , final String [[value]] ) { final ResultPath [[resultPath]] = resolveResultPath ( path , [[value]] ) ; final String [[result]] = [[resultPath]] . pathValue ( ) ; return resolveAlias ( [[result]] ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .

[[[[Adv]]]]: public String [[glenda]] ( final String path , final String [[bright]] ) { final ResultPath [[poundin]] = resolveResultPath ( path , [[bright]] ) ; final String [[gill]] = [[poundin]] . pathValue ( ) ; return resolveAlias ( [[gill]] ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .
--------------------------------------------- Result 948 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 759 / 166 / 23 / 948:  95%|█████████▍| 948/1000 [1:42:44<05:38,  6.50s/it][Succeeded / Failed / Skipped / Total] 759 / 166 / 23 / 948:  95%|█████████▍| 949/1000 [1:42:45<05:31,  6.50s/it][Succeeded / Failed / Skipped / Total] 760 / 166 / 23 / 949:  95%|█████████▍| 949/1000 [1:42:45<05:31,  6.50s/it][Succeeded / Failed / Skipped / Total] 760 / 166 / 23 / 949:  95%|█████████▌| 950/1000 [1:42:46<05:24,  6.49s/it][Succeeded / Failed / Skipped / Total] 761 / 166 / 23 / 950:  95%|█████████▌| 950/1000 [1:42:46<05:24,  6.49s/it][Succeeded / Failed / Skipped / Total] 761 / 166 / 23 / 950:  95%|█████████▌| 951/1000 [1:43:06<05:18,  6.51s/it][Succeeded / Failed / Skipped / Total] 762 / 166 / 23 / 951:  95%|█████████▌| 951/1000 [1:43:06<05:18,  6.51s/it][Succeeded / Failed / Skipped / Total] 762 / 166 / 23 / 951:  95%|█████████▌| 952/1000 [1:43:10<05:12,  6.50s/it][Succeeded / Failed / Skipped / Total] 763 / 166 / 23 / 952:  95%|█████████▌| 952/1000 [1:43:10<05:12,  6.50s/it][Succeeded / Failed / Skipped / Total] 763 / 166 / 23 / 952:  95%|█████████▌| 953/1000 [1:43:11<05:05,  6.50s/it][Succeeded / Failed / Skipped / Total] 764 / 166 / 23 / 953:  95%|█████████▌| 953/1000 [1:43:11<05:05,  6.50s/it][Succeeded / Failed / Skipped / Total] 764 / 166 / 23 / 953:  95%|█████████▌| 954/1000 [1:43:33<04:59,  6.51s/it][Succeeded / Failed / Skipped / Total] 765 / 166 / 23 / 954:  95%|█████████▌| 954/1000 [1:43:33<04:59,  6.51s/it][Succeeded / Failed / Skipped / Total] 765 / 166 / 23 / 954:  96%|█████████▌| 955/1000 [1:43:35<04:52,  6.51s/it]Gzip a file --> Perform gumpling --> Socre: 1.0

[[[[Adv]]]]: public static File [[gzip]] ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; String gzipName = file . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .

[[[[Adv]]]]: public static File [[dumpling]] ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; String gzipName = file . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .
--------------------------------------------- Result 949 ---------------------------------------------
Convert a byte array to a long array . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: protected static long [ ] [[bytesToLongs]] ( final byte [ ] ba , final int offset , final int size ) { long [ ] [[result]] = new long [ size >> 3 ] ; int i8 = offset ; for ( int i = 0 ; i < [[result]] . length ; i ++ ) { [[result]] [ i ] = Bits . getLong ( ba , i8 ) ; i8 += 8 ; } return [[result]] ; }
[[[[Nl]]]]: Converts segment of byte array into long array .

[[[[Adv]]]]: protected static long [ ] [[cadets]] ( final byte [ ] ba , final int offset , final int size ) { long [ ] [[dueling]] = new long [ size >> 3 ] ; int i8 = offset ; for ( int i = 0 ; i < [[dueling]] . length ; i ++ ) { [[dueling]] [ i ] = Bits . getLong ( ba , i8 ) ; i8 += 8 ; } return [[dueling]] ; }
[[[[Nl]]]]: Converts segment of byte array into long array .
--------------------------------------------- Result 950 ---------------------------------------------
Remove bounds from string . --> Removes any bounding characters --> Socre: 1.0

[[[[Adv]]]]: private static String removeAnyBounding ( final char [[s]] , final char [[e]] , final String str ) { if ( str == null || str . length ( ) < 2 ) { return str ; } if ( str . startsWith ( String . valueOf ( [[s]] ) ) && str . endsWith ( String . valueOf ( [[e]] ) ) ) { return str . substring ( 1 , str . length ( ) - 1 ) ; } return str ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .

[[[[Adv]]]]: private static String removeAnyBounding ( final char [[disembarking]] , final char [[forfeited]] , final String str ) { if ( str == null || str . length ( ) < 2 ) { return str ; } if ( str . startsWith ( String . valueOf ( [[disembarking]] ) ) && str . endsWith ( String . valueOf ( [[forfeited]] ) ) ) { return str . substring ( 1 , str . length ( ) - 1 ) ; } return str ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .
--------------------------------------------- Result 951 ---------------------------------------------
Adds a file to a ZIP output stream . --> generate pi components --> Socre: 1.0

[[[[Adv]]]]: public static void [[addToZip]] ( final ZipOutputStream zos , final File file , String path , final String comment , final boolean recursive ) throws IOException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . toString ( ) ) ; } if ( path == null ) { path = file . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean isDir = file . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .

[[[[Adv]]]]: public static void [[più]] ( final ZipOutputStream zos , final File file , String path , final String comment , final boolean recursive ) throws IOException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . toString ( ) ) ; } if ( path == null ) { path = file . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean isDir = file . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .
--------------------------------------------- Result 952 ---------------------------------------------
Unzip a zip file into a directory --> Unzip one or more files into another --> Socre: 1.0

[[[[Adv]]]]: public static void unzip ( final String [[zipFile]] , final String destDir , final String ... [[patterns]] ) throws IOException { unzip ( new File ( [[zipFile]] ) , new File ( destDir ) , [[patterns]] ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .

[[[[Adv]]]]: public static void unzip ( final String [[lingering]] , final String destDir , final String ... [[different]] ) throws IOException { unzip ( new File ( [[lingering]] ) , new File ( destDir ) , [[different]] ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .
--------------------------------------------- Result 953 ---------------------------------------------
Gets a field descriptor . --> Get a FieldDescriptor --> Socre: 1.0

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String name , final boolean declared ) { final FieldDescriptor [[fieldDescriptor]] = getFields ( ) . getFieldDescriptor ( name ) ; if ( [[fieldDescriptor]] != null ) { if ( ! [[fieldDescriptor]] . matchDeclared ( declared ) ) { return null ; } } return [[fieldDescriptor]] ; }
[[[[Nl]]]]: Returns field descriptor .

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String name , final boolean declared ) { final FieldDescriptor [[crore]] = getFields ( ) . getFieldDescriptor ( name ) ; if ( [[crore]] != null ) { if ( ! [[crore]] . matchDeclared ( declared ) ) { return null ; } } return [[crore]] ; }
[[[[Nl]]]]: Returns field descriptor .
--------------------------------------------- Result 954 ---------------------------------------------
Returns the property descriptor for the given name . --> Return the PropertyDescriptor for a given string --> Socre: 1.0

[[[[Adv]]]]: public PropertyDescriptor getPropertyDescriptor ( final String [[name]] , final boolean declared ) { PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( [[name]] ) ; if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( declared ) ) { return propertyDescriptor ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .

[[[[Adv]]]]: public PropertyDescriptor getPropertyDescriptor ( final String [[dede]] , final boolean declared ) { PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( [[dede]] ) ; if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( declared ) ) { return propertyDescriptor ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .
--------------------------------------------- Result 955 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 766 / 166 / 23 / 955:  96%|█████████▌| 955/1000 [1:43:35<04:52,  6.51s/it][Succeeded / Failed / Skipped / Total] 766 / 166 / 23 / 955:  96%|█████████▌| 956/1000 [1:43:35<04:46,  6.50s/it][Succeeded / Failed / Skipped / Total] 767 / 166 / 23 / 956:  96%|█████████▌| 956/1000 [1:43:35<04:46,  6.50s/it][Succeeded / Failed / Skipped / Total] 767 / 166 / 23 / 956:  96%|█████████▌| 957/1000 [1:43:48<04:39,  6.51s/it][Succeeded / Failed / Skipped / Total] 768 / 166 / 23 / 957:  96%|█████████▌| 957/1000 [1:43:48<04:39,  6.51s/it][Succeeded / Failed / Skipped / Total] 768 / 166 / 23 / 957:  96%|█████████▌| 958/1000 [1:43:52<04:33,  6.51s/it][Succeeded / Failed / Skipped / Total] 769 / 166 / 23 / 958:  96%|█████████▌| 958/1000 [1:43:52<04:33,  6.51s/it][Succeeded / Failed / Skipped / Total] 769 / 166 / 23 / 958:  96%|█████████▌| 959/1000 [1:44:10<04:27,  6.52s/it][Succeeded / Failed / Skipped / Total] 769 / 167 / 23 / 959:  96%|█████████▌| 959/1000 [1:44:10<04:27,  6.52s/it][Succeeded / Failed / Skipped / Total] 769 / 167 / 23 / 959:  96%|█████████▌| 960/1000 [1:44:17<04:20,  6.52s/it][Succeeded / Failed / Skipped / Total] 770 / 167 / 23 / 960:  96%|█████████▌| 960/1000 [1:44:17<04:20,  6.52s/it][Succeeded / Failed / Skipped / Total] 770 / 167 / 23 / 960:  96%|█████████▌| 961/1000 [1:44:28<04:14,  6.52s/it]List a zip file . --> Return an unmodifiable list of converters --> Socre: 1.0

[[[[Adv]]]]: public static List < String > [[listZip]] ( final File [[zipFile]] ) throws IOException { List < String > entries = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( [[zipFile]] ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; entries . add ( entryName ) ; } return Collections . unmodifiableList ( entries ) ; }
[[[[Nl]]]]: Lists zip content .

[[[[Adv]]]]: public static List < String > [[addicts]] ( final File [[converters]] ) throws IOException { List < String > entries = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( [[converters]] ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; entries . add ( entryName ) ; } return Collections . unmodifiableList ( entries ) ; }
[[[[Nl]]]]: Lists zip content .
--------------------------------------------- Result 956 ---------------------------------------------
Compresses the given file . --> Zipped content --> Socre: 1.0

[[[[Adv]]]]: public static File zlib ( final File [[file]] ) throws IOException { if ( [[file]] . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( [[file]] ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = [[file]] . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream [[dos]] = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , [[dos]] ) ; } finally { StreamUtil . close ( [[dos]] ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .

[[[[Adv]]]]: public static File zlib ( final File [[ethylene]] ) throws IOException { if ( [[ethylene]] . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( [[ethylene]] ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = [[ethylene]] . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream [[adolf]] = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , [[adolf]] ) ; } finally { StreamUtil . close ( [[adolf]] ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .
--------------------------------------------- Result 957 ---------------------------------------------
Sets the bundle name for the current request . --> Set aeroplanes attribute --> Socre: 1.0

[[[[Adv]]]]: public static void [[setRequestBundleName]] ( final ServletRequest [[request]] , final String bundleName ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + bundleName ) ; } [[request]] . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , bundleName ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .

[[[[Adv]]]]: public static void [[aeroplanes]] ( final ServletRequest [[lampwick]] , final String bundleName ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + bundleName ) ; } [[lampwick]] . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , bundleName ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .
--------------------------------------------- Result 958 ---------------------------------------------
Adds content to a zip output stream . --> also used in test --> Socre: 1.0

[[[[Adv]]]]: public static void [[addToZip]] ( final ZipOutputStream zos , final byte [ ] content , String [[path]] , final String comment ) throws IOException { while ( [[path]] . length ( ) != 0 && [[path]] . charAt ( 0 ) == ' ' ) { [[path]] = [[path]] . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( [[path]] , ' ' ) ) { [[path]] = [[path]] . substring ( 0 , [[path]] . length ( ) - 1 ) ; } ZipEntry [[zipEntry]] = new ZipEntry ( [[path]] ) ; [[zipEntry]] . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { [[zipEntry]] . setComment ( comment ) ; } zos . putNextEntry ( [[zipEntry]] ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .

[[[[Adv]]]]: public static void [[arbogast]] ( final ZipOutputStream zos , final byte [ ] content , String [[addictive]] , final String comment ) throws IOException { while ( [[addictive]] . length ( ) != 0 && [[addictive]] . charAt ( 0 ) == ' ' ) { [[addictive]] = [[addictive]] . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( [[addictive]] , ' ' ) ) { [[addictive]] = [[addictive]] . substring ( 0 , [[addictive]] . length ( ) - 1 ) ; } ZipEntry [[blight]] = new ZipEntry ( [[addictive]] ) ; [[blight]] . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { [[blight]] . setComment ( comment ) ; } zos . putNextEntry ( [[blight]] ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .
--------------------------------------------- Result 959 ---------------------------------------------
Add profile . --> [[[FAILED]]]

[[[[Adv]]]]: public PropsEntries [[profile]] ( final String ... [[profiles]] ) { if ( [[profiles]] == null ) { return this ; } for ( String [[profile]] : [[profiles]] ) { addProfiles ( [[profile]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .

[[[[Adv]]]]: public PropsEntries [[sweep]] ( final String ... [[newspapermen]] ) { if ( [[newspapermen]] == null ) { return this ; } for ( String [[sweep]] : [[newspapermen]] ) { addProfiles ( [[sweep]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .
--------------------------------------------- Result 960 ---------------------------------------------
Filter parameters for bean name . --> Marshmallow beans --> Socre: 1.0

[[[[Adv]]]]: public String [ ] [[filterParametersForBeanName]] ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > [[list]] = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! key . startsWith ( beanName ) ) { continue ; } [[list]] . add ( key ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .

[[[[Adv]]]]: public String [ ] [[marshmallow]] ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > [[asada]] = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! key . startsWith ( beanName ) ) { continue ; } [[asada]] . add ( key ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .
--------------------------------------------- Result 961 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 770 / 168 / 23 / 961:  96%|█████████▌| 961/1000 [1:44:28<04:14,  6.52s/it][Succeeded / Failed / Skipped / Total] 770 / 168 / 23 / 961:  96%|█████████▌| 962/1000 [1:44:29<04:07,  6.52s/it][Succeeded / Failed / Skipped / Total] 770 / 169 / 23 / 962:  96%|█████████▌| 962/1000 [1:44:29<04:07,  6.52s/it][Succeeded / Failed / Skipped / Total] 770 / 169 / 23 / 962:  96%|█████████▋| 963/1000 [1:44:32<04:01,  6.51s/it][Succeeded / Failed / Skipped / Total] 771 / 169 / 23 / 963:  96%|█████████▋| 963/1000 [1:44:32<04:01,  6.51s/it][Succeeded / Failed / Skipped / Total] 771 / 169 / 23 / 963:  96%|█████████▋| 964/1000 [1:44:35<03:54,  6.51s/it][Succeeded / Failed / Skipped / Total] 771 / 170 / 23 / 964:  96%|█████████▋| 964/1000 [1:44:35<03:54,  6.51s/it][Succeeded / Failed / Skipped / Total] 771 / 170 / 23 / 964:  96%|█████████▋| 965/1000 [1:44:36<03:47,  6.50s/it][Succeeded / Failed / Skipped / Total] 772 / 170 / 23 / 965:  96%|█████████▋| 965/1000 [1:44:36<03:47,  6.50s/it][Succeeded / Failed / Skipped / Total] 772 / 170 / 23 / 965:  97%|█████████▋| 966/1000 [1:44:43<03:41,  6.50s/it][Succeeded / Failed / Skipped / Total] 773 / 170 / 23 / 966:  97%|█████████▋| 966/1000 [1:44:43<03:41,  6.50s/it][Succeeded / Failed / Skipped / Total] 773 / 170 / 23 / 966:  97%|█████████▋| 967/1000 [1:44:54<03:34,  6.51s/it][Succeeded / Failed / Skipped / Total] 774 / 170 / 23 / 967:  97%|█████████▋| 967/1000 [1:44:54<03:34,  6.51s/it][Succeeded / Failed / Skipped / Total] 774 / 170 / 23 / 967:  97%|█████████▋| 968/1000 [1:45:03<03:28,  6.51s/it]Stores the session in the session . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[setSessionLocale]] ( final HttpSession [[session]] , final String [[localeCode]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[localeCode]] ) ; } Locale locale = Locale . forLanguageTag ( [[localeCode]] ) ; [[session]] . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .

[[[[Adv]]]]: public static void [[doorbell]] ( final HttpSession [[cornea]] , final String [[furthermore]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[furthermore]] ) ; } Locale locale = Locale . forLanguageTag ( [[furthermore]] ) ; [[cornea]] . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .
--------------------------------------------- Result 962 ---------------------------------------------
Resolve column names . --> [[[FAILED]]]

[[[[Adv]]]]: public static DbEntityColumnDescriptor [[resolveColumnDescriptors]] ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .

[[[[Adv]]]]: public static DbEntityColumnDescriptor [[amuck]] ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .
--------------------------------------------- Result 963 ---------------------------------------------
Reads a label . --> Liefert den konmergebenen --> Socre: 1.0

[[[[Adv]]]]: protected Label [[readLabel]] ( final int bytecodeOffset , final Label [ ] labels ) { if ( labels [ bytecodeOffset ] == null ) { labels [ bytecodeOffset ] = new Label ( ) ; } return labels [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .

[[[[Adv]]]]: protected Label [[katzenjammer]] ( final int bytecodeOffset , final Label [ ] labels ) { if ( labels [ bytecodeOffset ] == null ) { labels [ bytecodeOffset ] = new Label ( ) ; } return labels [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .
--------------------------------------------- Result 964 ---------------------------------------------
Returns the session locale . --> [[[FAILED]]]

[[[[Adv]]]]: public static Locale [[getSessionLocale]] ( final HttpSession [[session]] ) { Locale locale = ( Locale ) [[session]] . getAttribute ( SESSION_LOCALE_ATTR ) ; return locale == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : locale ; }
[[[[Nl]]]]: Returns current locale from session . s

[[[[Adv]]]]: public static Locale [[goldblum]] ( final HttpSession [[boludo]] ) { Locale locale = ( Locale ) [[boludo]] . getAttribute ( SESSION_LOCALE_ATTR ) ; return locale == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : locale ; }
[[[[Nl]]]]: Returns current locale from session . s
--------------------------------------------- Result 965 ---------------------------------------------
Reads the given stream into a byte array . --> Read data from InputStream --> Socre: 1.0

[[[[Adv]]]]: private static byte [ ] readStream ( final InputStream [[inputStream]] , final boolean close ) throws IOException { if ( [[inputStream]] == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream [[outputStream]] = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = [[inputStream]] . read ( data , 0 , data . length ) ) != - 1 ) { [[outputStream]] . write ( data , 0 , bytesRead ) ; } [[outputStream]] . flush ( ) ; return [[outputStream]] . toByteArray ( ) ; } finally { if ( close ) { [[inputStream]] . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .

[[[[Adv]]]]: private static byte [ ] readStream ( final InputStream [[chez]] , final boolean close ) throws IOException { if ( [[chez]] == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream [[werther]] = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = [[chez]] . read ( data , 0 , data . length ) ) != - 1 ) { [[werther]] . write ( data , 0 , bytesRead ) ; } [[werther]] . flush ( ) ; return [[werther]] . toByteArray ( ) ; } finally { if ( close ) { [[chez]] . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .
--------------------------------------------- Result 966 ---------------------------------------------
Returns the bytecode offset for the given type annotation index . --> For internal use only --> Socre: 1.0

[[[[Adv]]]]: private int [[getTypeAnnotationBytecodeOffset]] ( final int [ ] typeAnnotationOffsets , final int typeAnnotationIndex ) { if ( typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( typeAnnotationOffsets [ typeAnnotationIndex ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .

[[[[Adv]]]]: private int [[flatware]] ( final int [ ] typeAnnotationOffsets , final int typeAnnotationIndex ) { if ( typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( typeAnnotationOffsets [ typeAnnotationIndex ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .
--------------------------------------------- Result 967 ---------------------------------------------
Get a long from the buffer at the given offset . --> Renders Burrowslestone --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLongLittleEndian]] ( final byte [ ] [[buf]] , final int offset ) { return ( ( long ) [[buf]] [ offset + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .

[[[[Adv]]]]: public static long [[brûlée]] ( final byte [ ] [[deliverance]] , final int offset ) { return ( ( long ) [[deliverance]] [ offset + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .
--------------------------------------------- Result 968 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 775 / 170 / 23 / 968:  97%|█████████▋| 968/1000 [1:45:03<03:28,  6.51s/it][Succeeded / Failed / Skipped / Total] 775 / 170 / 23 / 968:  97%|█████████▋| 969/1000 [1:45:14<03:22,  6.52s/it][Succeeded / Failed / Skipped / Total] 776 / 170 / 23 / 969:  97%|█████████▋| 969/1000 [1:45:14<03:22,  6.52s/it][Succeeded / Failed / Skipped / Total] 776 / 170 / 23 / 969:  97%|█████████▋| 970/1000 [1:45:20<03:15,  6.52s/it][Succeeded / Failed / Skipped / Total] 777 / 170 / 23 / 970:  97%|█████████▋| 970/1000 [1:45:20<03:15,  6.52s/it][Succeeded / Failed / Skipped / Total] 777 / 170 / 23 / 970:  97%|█████████▋| 971/1000 [1:45:23<03:08,  6.51s/it][Succeeded / Failed / Skipped / Total] 778 / 170 / 23 / 971:  97%|█████████▋| 971/1000 [1:45:23<03:08,  6.51s/it][Succeeded / Failed / Skipped / Total] 778 / 170 / 23 / 971:  97%|█████████▋| 972/1000 [1:45:27<03:02,  6.51s/it][Succeeded / Failed / Skipped / Total] 779 / 170 / 23 / 972:  97%|█████████▋| 972/1000 [1:45:27<03:02,  6.51s/it][Succeeded / Failed / Skipped / Total] 779 / 170 / 23 / 972:  97%|█████████▋| 973/1000 [1:45:36<02:55,  6.51s/it][Succeeded / Failed / Skipped / Total] 780 / 170 / 23 / 973:  97%|█████████▋| 973/1000 [1:45:36<02:55,  6.51s/it][Succeeded / Failed / Skipped / Total] 780 / 170 / 23 / 973:  97%|█████████▋| 974/1000 [1:45:43<02:49,  6.51s/it][Succeeded / Failed / Skipped / Total] 781 / 170 / 23 / 974:  97%|█████████▋| 974/1000 [1:45:43<02:49,  6.51s/it][Succeeded / Failed / Skipped / Total] 781 / 170 / 23 / 974:  98%|█████████▊| 975/1000 [1:45:54<02:42,  6.52s/it][Succeeded / Failed / Skipped / Total] 781 / 171 / 23 / 975:  98%|█████████▊| 975/1000 [1:45:54<02:42,  6.52s/it][Succeeded / Failed / Skipped / Total] 781 / 171 / 23 / 975:  98%|█████████▊| 976/1000 [1:45:59<02:36,  6.52s/it][Succeeded / Failed / Skipped / Total] 782 / 171 / 23 / 976:  98%|█████████▊| 976/1000 [1:45:59<02:36,  6.52s/it][Succeeded / Failed / Skipped / Total] 782 / 171 / 23 / 976:  98%|█████████▊| 977/1000 [1:46:17<02:30,  6.53s/it]Returns the matching descriptor for the given arguments . --> return the first ctorDescriptor found in this class --> Socre: 1.0

[[[[Adv]]]]: public CtorDescriptor getCtorDescriptor ( final Class ... [[args]] ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] arg = ctorDescriptor . getParameters ( ) ; if ( arg . length != [[args]] . length ) { continue ; } for ( int j = 0 ; j < arg . length ; j ++ ) { if ( arg [ j ] != [[args]] [ j ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .

[[[[Adv]]]]: public CtorDescriptor getCtorDescriptor ( final Class ... [[beens]] ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] arg = ctorDescriptor . getParameters ( ) ; if ( arg . length != [[beens]] . length ) { continue ; } for ( int j = 0 ; j < arg . length ; j ++ ) { if ( arg [ j ] != [[beens]] [ j ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .
--------------------------------------------- Result 969 ---------------------------------------------
Read bootstrap methods attribute . --> Dahn - Dahnch --> Socre: 1.0

[[[[Adv]]]]: private int [ ] [[readBootstrapMethodsAttribute]] ( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] [[currentBootstrapMethodOffsets]] = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .

[[[[Adv]]]]: private int [ ] [[dahn]] ( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] [[andit]] = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .
--------------------------------------------- Result 970 ---------------------------------------------
Get all constructors . --> create the CtorDescriptors --> Socre: 1.0

[[[[Adv]]]]: protected CtorDescriptor [ ] [[inspectConstructors]] ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] [[allCtors]] = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor ctor = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; [[allCtors]] [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return [[allCtors]] ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .

[[[[Adv]]]]: protected CtorDescriptor [ ] [[emotionally]] ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] [[naoki]] = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor ctor = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; [[naoki]] [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return [[naoki]] ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .
--------------------------------------------- Result 971 ---------------------------------------------
Returns the request map . --> Retrieves a list of TransientBeanData instances --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[getRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { return ( Map < String , TransientBeanData > ) [[servletRequest]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[multi]] ( final HttpServletRequest [[wedding]] ) { return ( Map < String , TransientBeanData > ) [[wedding]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .
--------------------------------------------- Result 972 ---------------------------------------------
Read the values of an element . --> Don t do anything? --> Socre: 1.0

[[[[Adv]]]]: private int [[readElementValues]] ( final AnnotationVisitor [[annotationVisitor]] , final int annotationOffset , final boolean [[named]] , final char [ ] charBuffer ) { int currentOffset = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .

[[[[Adv]]]]: private int [[flourishing]] ( final AnnotationVisitor [[brainwashed]] , final int annotationOffset , final boolean [[bachelorhood]] , final char [ ] charBuffer ) { int currentOffset = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .
--------------------------------------------- Result 973 ---------------------------------------------
Initializes the filter . --> Checks if crom is crom --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[init]] ( final FilterConfig filterConfig ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .

[[[[Adv]]]]: @ Override public void [[crom]] ( final FilterConfig filterConfig ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .
--------------------------------------------- Result 974 ---------------------------------------------
Registers a file consumer . --> Register a listener for files to be canceled . --> Socre: 1.0

[[[[Adv]]]]: public FindFile onFile ( final Consumer < File > [[fileConsumer]] ) { if ( consumers == null ) { consumers = Consumers . of ( [[fileConsumer]] ) ; } else { consumers . add ( [[fileConsumer]] ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer

[[[[Adv]]]]: public FindFile onFile ( final Consumer < File > [[cancellations]] ) { if ( consumers == null ) { consumers = Consumers . of ( [[cancellations]] ) ; } else { consumers . add ( [[cancellations]] ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer
--------------------------------------------- Result 975 ---------------------------------------------
Creates the request map . --> [[[FAILED]]]

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[createRequestMap]] ( final HttpServletRequest servletRequest ) { Map < String , TransientBeanData > map = new HashMap <> ( ) ; servletRequest . setAttribute ( ATTR_NAME , map ) ; return map ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[taiga]] ( final HttpServletRequest servletRequest ) { Map < String , TransientBeanData > map = new HashMap <> ( ) ; servletRequest . setAttribute ( ATTR_NAME , map ) ; return map ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .
--------------------------------------------- Result 976 ---------------------------------------------
Add search path . --> Add file to findFile --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URI [[searchPath]] ) { File file ; try { file = new File ( [[searchPath]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[searchPath]] , ex ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .

[[[[Adv]]]]: public FindFile [[chez]] ( final URI [[sickles]] ) { File file ; try { file = new File ( [[chez]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[chez]] , ex ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .
[Succeeded / Failed / Skipped / Total] 783 / 171 / 23 / 977:  98%|█████████▊| 977/1000 [1:46:17<02:30,  6.53s/it][Succeeded / Failed / Skipped / Total] 783 / 171 / 23 / 977:  98%|█████████▊| 978/1000 [1:46:22<02:23,  6.53s/it][Succeeded / Failed / Skipped / Total] 784 / 171 / 23 / 978:  98%|█████████▊| 978/1000 [1:46:22<02:23,  6.53s/it][Succeeded / Failed / Skipped / Total] 784 / 171 / 23 / 978:  98%|█████████▊| 979/1000 [1:46:25<02:16,  6.52s/it][Succeeded / Failed / Skipped / Total] 785 / 171 / 23 / 979:  98%|█████████▊| 979/1000 [1:46:25<02:16,  6.52s/it][Succeeded / Failed / Skipped / Total] 785 / 171 / 23 / 979:  98%|█████████▊| 980/1000 [1:46:30<02:10,  6.52s/it][Succeeded / Failed / Skipped / Total] 786 / 171 / 23 / 980:  98%|█████████▊| 980/1000 [1:46:30<02:10,  6.52s/it][Succeeded / Failed / Skipped / Total] 786 / 171 / 23 / 980:  98%|█████████▊| 981/1000 [1:46:43<02:04,  6.53s/it][Succeeded / Failed / Skipped / Total] 787 / 171 / 23 / 981:  98%|█████████▊| 981/1000 [1:46:43<02:04,  6.53s/it][Succeeded / Failed / Skipped / Total] 787 / 171 / 23 / 981:  98%|█████████▊| 982/1000 [1:46:45<01:57,  6.52s/it][Succeeded / Failed / Skipped / Total] 788 / 171 / 23 / 982:  98%|█████████▊| 982/1000 [1:46:45<01:57,  6.52s/it][Succeeded / Failed / Skipped / Total] 788 / 171 / 23 / 982:  98%|█████████▊| 983/1000 [1:46:50<01:50,  6.52s/it][Succeeded / Failed / Skipped / Total] 789 / 171 / 23 / 983:  98%|█████████▊| 983/1000 [1:46:50<01:50,  6.52s/it][Succeeded / Failed / Skipped / Total] 789 / 171 / 23 / 983:  98%|█████████▊| 984/1000 [1:46:54<01:44,  6.52s/it]--------------------------------------------- Result 977 ---------------------------------------------
Includes the given patterns . --> Eugen rules --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[include]] ( final String ... [[patterns]] ) { for ( String pattern : [[patterns]] ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .

[[[[Adv]]]]: public FindFile [[eugen]] ( final String ... [[gweilo]] ) { for ( String pattern : [[gweilo]] ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .
--------------------------------------------- Result 978 ---------------------------------------------
Add search path . --> Skip blacklayers --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URL searchPath ) { File [[file]] = FileUtil . toContainerFile ( [[searchPath]] ) ; if ( [[file]] == null ) { throw new FindFileException ( "URL error: " + [[searchPath]] ) ; } addPath ( [[file]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .

[[[[Adv]]]]: public FindFile [[bricklayers]] ( final URL searchPath ) { File [[apprehensive]] = FileUtil . toContainerFile ( [[bricklayers]] ) ; if ( [[apprehensive]] == null ) { throw new FindFileException ( "URL error: " + [[bricklayers]] ) ; } addPath ( [[apprehensive]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .
--------------------------------------------- Result 979 ---------------------------------------------
Convert array to array . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: protected long [ ] [[convertArrayToArray]] ( final Object [[value]] ) { final Class [[valueComponentType]] = [[value]] . getClass ( ) . getComponentType ( ) ; final long [ ] [[result]] ; if ( [[valueComponentType]] . isPrimitive ( ) ) { [[result]] = convertPrimitiveArrayToArray ( [[value]] , [[valueComponentType]] ) ; } else {
[[[[Nl]]]]: Converts array value to array .

[[[[Adv]]]]: protected long [ ] [[delivers]] ( final Object [[styles]] ) { final Class [[antivirals]] = [[styles]] . getClass ( ) . getComponentType ( ) ; final long [ ] [[pattern]] ; if ( [[antivirals]] . isPrimitive ( ) ) { [[pattern]] = convertPrimitiveArrayToArray ( [[styles]] , [[antivirals]] ) ; } else {
[[[[Nl]]]]: Converts array value to array .
--------------------------------------------- Result 980 ---------------------------------------------
Adds a file to the repository . --> Add hatfields --> Socre: 1.0

[[[[Adv]]]]: protected void [[addPath]] ( final File [[path]] ) { if ( ! [[path]] . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( [[path]] ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .

[[[[Adv]]]]: protected void [[quite]] ( final File [[hatfields]] ) { if ( ! [[hatfields]] . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( [[hatfields]] ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .
--------------------------------------------- Result 981 ---------------------------------------------
Iterates over all files in the collection . --> Sloppiness algorithm --> Socre: 1.0

[[[[Adv]]]]: @ Override public Iterator < File > [[iterator]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .

[[[[Adv]]]]: @ Override public Iterator < File > [[sloppiness]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .
--------------------------------------------- Result 982 ---------------------------------------------
Exclude patterns . --> Removes LOCKS from the end of the list --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[exclude]] ( final String ... [[patterns]] ) { for ( String [[pattern]] : [[patterns]] ) { rules . exclude ( [[pattern]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .

[[[[Adv]]]]: public FindFile [[lobotomized]] ( final String ... [[eastwick]] ) { for ( String [[fords]] : [[eastwick]] ) { rules . exclude ( [[fords]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .
--------------------------------------------- Result 983 ---------------------------------------------
Reads the verification type information . --> private static final ; --> Socre: 1.0

[[[[Adv]]]]: private int [[readVerificationTypeInfo]] ( final int [[verificationTypeInfoOffset]] , final Object [ ] frame , final int [[index]] , final char [ ] charBuffer , final Label [ ] labels ) { int currentOffset = [[verificationTypeInfoOffset]] ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ [[index]] ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ [[index]] ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ [[index]] ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ [[index]] ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ [[index]] ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ [[index]] ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ [[index]] ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ [[index]] ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ [[index]] ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .

[[[[Adv]]]]: private int [[bir]] ( final int [[huckleberry]] , final Object [ ] frame , final int [[friar]] , final char [ ] charBuffer , final Label [ ] labels ) { int currentOffset = [[huckleberry]] ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ [[friar]] ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ [[friar]] ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ [[friar]] ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ [[friar]] ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ [[friar]] ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ [[friar]] ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ [[friar]] ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ [[friar]] ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ [[friar]] ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .
--------------------------------------------- Result 984 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 790 / 171 / 23 / 984:  98%|█████████▊| 984/1000 [1:46:54<01:44,  6.52s/it][Succeeded / Failed / Skipped / Total] 790 / 171 / 23 / 984:  98%|█████████▊| 985/1000 [1:47:06<01:37,  6.52s/it][Succeeded / Failed / Skipped / Total] 790 / 172 / 23 / 985:  98%|█████████▊| 985/1000 [1:47:06<01:37,  6.52s/it][Succeeded / Failed / Skipped / Total] 790 / 172 / 23 / 985:  99%|█████████▊| 986/1000 [1:47:07<01:31,  6.52s/it][Succeeded / Failed / Skipped / Total] 790 / 173 / 23 / 986:  99%|█████████▊| 986/1000 [1:47:07<01:31,  6.52s/it][Succeeded / Failed / Skipped / Total] 790 / 173 / 23 / 986:  99%|█████████▊| 987/1000 [1:47:23<01:24,  6.53s/it][Succeeded / Failed / Skipped / Total] 790 / 174 / 23 / 987:  99%|█████████▊| 987/1000 [1:47:23<01:24,  6.53s/it][Succeeded / Failed / Skipped / Total] 790 / 174 / 23 / 987:  99%|█████████▉| 988/1000 [1:47:26<01:18,  6.52s/it][Succeeded / Failed / Skipped / Total] 791 / 174 / 23 / 988:  99%|█████████▉| 988/1000 [1:47:26<01:18,  6.52s/it][Succeeded / Failed / Skipped / Total] 791 / 174 / 23 / 988:  99%|█████████▉| 989/1000 [1:47:27<01:11,  6.52s/it][Succeeded / Failed / Skipped / Total] 792 / 174 / 23 / 989:  99%|█████████▉| 989/1000 [1:47:27<01:11,  6.52s/it][Succeeded / Failed / Skipped / Total] 792 / 174 / 23 / 989:  99%|█████████▉| 990/1000 [1:47:47<01:05,  6.53s/it][Succeeded / Failed / Skipped / Total] 793 / 174 / 23 / 990:  99%|█████████▉| 990/1000 [1:47:47<01:05,  6.53s/it][Succeeded / Failed / Skipped / Total] 793 / 174 / 23 / 990:  99%|█████████▉| 991/1000 [1:47:49<00:58,  6.53s/it]Initialize todo . --> Initialize the system --> Socre: 1.0

[[[[Adv]]]]: protected void init ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] [[files]] = new String [ pathList . size ( ) ] ; int index = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { [[files]] [ index ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( index != 0 ) { FilesIterator filesIterator = new FilesIterator ( [[files]] ) ; todoFiles . add ( filesIterator ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .

[[[[Adv]]]]: protected void init ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] [[parasites]] = new String [ pathList . size ( ) ] ; int index = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { [[parasites]] [ index ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( index != 0 ) { FilesIterator filesIterator = new FilesIterator ( [[parasites]] ) ; todoFiles . add ( filesIterator ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .
--------------------------------------------- Result 985 ---------------------------------------------
Returns the output stream . --> [[[FAILED]]]

[[[[Adv]]]]: public ServletOutputStream [[getOutputStream]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .

[[[[Adv]]]]: public ServletOutputStream [[fertilization]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .
--------------------------------------------- Result 986 ---------------------------------------------
Gets the output writer . --> [[[FAILED]]]

[[[[Adv]]]]: public PrintWriter [[getWriter]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .

[[[[Adv]]]]: public PrintWriter [[thrashing]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .
--------------------------------------------- Result 987 ---------------------------------------------
Find all files . --> [[[FAILED]]]

[[[[Adv]]]]: public List < File > [[findAll]] ( ) { List < File > [[allFiles]] = new ArrayList <> ( ) ; File [[file]] ; while ( ( [[file]] = nextFile ( ) ) != null ) { [[allFiles]] . add ( [[file]] ) ; } return [[allFiles]] ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .

[[[[Adv]]]]: public List < File > [[georgie]] ( ) { List < File > [[berman]] = new ArrayList <> ( ) ; File [[guarantor]] ; while ( ( [[guarantor]] = nextFile ( ) ) != null ) { [[berman]] . add ( [[guarantor]] ) ; } return [[berman]] ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .
--------------------------------------------- Result 988 ---------------------------------------------
Returns the wiring mode for the given type . --> This method should be used for testing purposes --> Socre: 1.0

[[[[Adv]]]]: public WiringMode [[resolveBeanWiringMode]] ( final Class [[type]] ) { PetiteBean [[petiteBean]] = ( ( Class < ? > ) [[type]] ) . getAnnotation ( PetiteBean . class ) ; return [[petiteBean]] != null ? [[petiteBean]] . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .

[[[[Adv]]]]: public WiringMode [[aul]] ( final Class [[cheaper]] ) { PetiteBean [[orcutt]] = ( ( Class < ? > ) [[cheaper]] ) . getAnnotation ( PetiteBean . class ) ; return [[orcutt]] != null ? [[orcutt]] . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .
--------------------------------------------- Result 989 ---------------------------------------------
Gets the descriptor of a method . --> Generate a reaction --> Socre: 1.0

[[[[Adv]]]]: public static String getMethodDescriptor ( final Method method ) { StringBuilder [[stringBuilder]] = new StringBuilder ( ) ; [[stringBuilder]] . append ( ' ' ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , [[stringBuilder]] ) ; } [[stringBuilder]] . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , [[stringBuilder]] ) ; return [[stringBuilder]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .

[[[[Adv]]]]: public static String getMethodDescriptor ( final Method method ) { StringBuilder [[reacted]] = new StringBuilder ( ) ; [[reacted]] . append ( ' ' ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , [[reacted]] ) ; } [[reacted]] . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , [[reacted]] ) ; return [[reacted]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .
--------------------------------------------- Result 990 ---------------------------------------------
Gets the size of the query . --> Methode code --> Socre: 1.0

[[[[Adv]]]]: public int [[getSize]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .

[[[[Adv]]]]: public int [[ét]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .
--------------------------------------------- Result 991 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 794 / 174 / 23 / 991:  99%|█████████▉| 991/1000 [1:47:49<00:58,  6.53s/it][Succeeded / Failed / Skipped / Total] 794 / 174 / 23 / 991:  99%|█████████▉| 992/1000 [1:47:49<00:52,  6.52s/it][Succeeded / Failed / Skipped / Total] 795 / 174 / 23 / 992:  99%|█████████▉| 992/1000 [1:47:49<00:52,  6.52s/it][Succeeded / Failed / Skipped / Total] 796 / 174 / 23 / 993:  99%|█████████▉| 993/1000 [1:47:49<00:45,  6.52s/it][Succeeded / Failed / Skipped / Total] 796 / 174 / 23 / 993:  99%|█████████▉| 994/1000 [1:48:00<00:39,  6.52s/it][Succeeded / Failed / Skipped / Total] 797 / 174 / 23 / 994:  99%|█████████▉| 994/1000 [1:48:00<00:39,  6.52s/it][Succeeded / Failed / Skipped / Total] 797 / 174 / 23 / 994: 100%|█████████▉| 995/1000 [1:48:06<00:32,  6.52s/it][Succeeded / Failed / Skipped / Total] 798 / 174 / 23 / 995: 100%|█████████▉| 995/1000 [1:48:06<00:32,  6.52s/it][Succeeded / Failed / Skipped / Total] 798 / 174 / 23 / 995: 100%|█████████▉| 996/1000 [1:48:08<00:26,  6.51s/it][Succeeded / Failed / Skipped / Total] 799 / 174 / 23 / 996: 100%|█████████▉| 996/1000 [1:48:08<00:26,  6.51s/it][Succeeded / Failed / Skipped / Total] 799 / 174 / 23 / 996: 100%|█████████▉| 997/1000 [1:48:08<00:19,  6.51s/it]Gets the method descriptor . --> create idler --> Socre: 1.0

[[[[Adv]]]]: public static String [[getMethodDescriptor]] ( final Type [[returnType]] , final Type ... argumentTypes ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; for ( Type argumentType : argumentTypes ) { argumentType . appendDescriptor ( stringBuilder ) ; } stringBuilder . append ( ' ' ) ; [[returnType]] . appendDescriptor ( stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .

[[[[Adv]]]]: public static String [[idler]] ( final Type [[chelo]] , final Type ... argumentTypes ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; for ( Type argumentType : argumentTypes ) { argumentType . appendDescriptor ( stringBuilder ) ; } stringBuilder . append ( ' ' ) ; [[chelo]] . appendDescriptor ( stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .
--------------------------------------------- Result 992 ---------------------------------------------
Get the descriptor for a constructor . --> generate blackboard code --> Socre: 1.0

[[[[Adv]]]]: public static String [[getConstructorDescriptor]] ( final Constructor < ? > constructor ) { StringBuilder [[stringBuilder]] = new StringBuilder ( ) ; [[stringBuilder]] . append ( ' ' ) ; Class < ? > [ ] [[parameters]] = constructor . getParameterTypes ( ) ; for ( Class < ? > parameter : [[parameters]] ) { appendDescriptor ( parameter , [[stringBuilder]] ) ; } return [[stringBuilder]] . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .

[[[[Adv]]]]: public static String [[blackboard]] ( final Constructor < ? > constructor ) { StringBuilder [[torres]] = new StringBuilder ( ) ; [[torres]] . append ( ' ' ) ; Class < ? > [ ] [[exhort]] = constructor . getParameterTypes ( ) ; for ( Class < ? > parameter : [[exhort]] ) { appendDescriptor ( parameter , [[torres]] ) ; } return [[torres]] . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .
--------------------------------------------- Result 993 ---------------------------------------------
Returns the binary representation of the primitive type . --> generate a sentence --> Socre: 1.0

[[[[Adv]]]]: public String [[getClassName]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder [[stringBuilder]] = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int [[i]] = getDimensions ( ) ; [[i]] > 0 ; -- [[i]] ) { [[stringBuilder]] . append ( "[]" ) ; } return [[stringBuilder]] . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .

[[[[Adv]]]]: public String [[sprechen]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder [[sì]] = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int [[guevara]] = getDimensions ( ) ; [[guevara]] > 0 ; -- [[guevara]] ) { [[sì]] . append ( "[]" ) ; } return [[sì]] . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .
--------------------------------------------- Result 994 ---------------------------------------------
Appends the descriptor to the given string builder . --> Append Latigo --> Socre: 1.0

[[[[Adv]]]]: private void [[appendDescriptor]] ( final StringBuilder [[stringBuilder]] ) { if ( sort == OBJECT ) { [[stringBuilder]] . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { [[stringBuilder]] . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { [[stringBuilder]] . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .

[[[[Adv]]]]: private void [[latigo]] ( final StringBuilder [[lets]] ) { if ( sort == OBJECT ) { [[lets]] . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { [[lets]] . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { [[lets]] . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .
--------------------------------------------- Result 995 ---------------------------------------------
Mark this transaction as rollback only . --> Mark rollback --> Socre: 1.0

[[[[Adv]]]]: public void [[setRollbackOnly]] ( final Throwable th ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = th ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .

[[[[Adv]]]]: public void [[plonker]] ( final Throwable th ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = th ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .
--------------------------------------------- Result 996 ---------------------------------------------
Resolves the bean name . --> Liefert den uebergebenen --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveBeanName]] ( final Class [[type]] , final boolean useLongTypeName ) { PetiteBean [[petiteBean]] = ( ( Class < ? > ) [[type]] ) . getAnnotation ( PetiteBean . class ) ; String [[name]] = null ; if ( [[petiteBean]] != null ) { [[name]] = [[petiteBean]] . value ( ) . trim ( ) ; } if ( ( [[name]] == null ) || ( [[name]] . length ( ) == 0 ) ) { if ( useLongTypeName ) { [[name]] = [[type]] . getName ( ) ; } else { [[name]] = StringUtil . uncapitalize ( [[type]] . getSimpleName ( ) ) ; } } return [[name]] ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .

[[[[Adv]]]]: public String [[bruiser]] ( final Class [[manon]] , final boolean useLongTypeName ) { PetiteBean [[samehada]] = ( ( Class < ? > ) [[manon]] ) . getAnnotation ( PetiteBean . class ) ; String [[ibuprofen]] = null ; if ( [[samehada]] != null ) { [[ibuprofen]] = [[samehada]] . value ( ) . trim ( ) ; } if ( ( [[ibuprofen]] == null ) || ( [[ibuprofen]] . length ( ) == 0 ) ) { if ( useLongTypeName ) { [[ibuprofen]] = [[manon]] . getName ( ) ; } else { [[ibuprofen]] = StringUtil . uncapitalize ( [[manon]] . getSimpleName ( ) ) ; } } return [[ibuprofen]] ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .
--------------------------------------------- Result 997 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 800 / 174 / 23 / 997: 100%|█████████▉| 997/1000 [1:48:08<00:19,  6.51s/it][Succeeded / Failed / Skipped / Total] 800 / 174 / 23 / 997: 100%|█████████▉| 998/1000 [1:48:11<00:13,  6.50s/it][Succeeded / Failed / Skipped / Total] 801 / 174 / 23 / 998: 100%|█████████▉| 998/1000 [1:48:11<00:13,  6.50s/it][Succeeded / Failed / Skipped / Total] 801 / 174 / 23 / 998: 100%|█████████▉| 999/1000 [1:48:29<00:06,  6.52s/it][Succeeded / Failed / Skipped / Total] 802 / 174 / 23 / 999: 100%|█████████▉| 999/1000 [1:48:29<00:06,  6.52s/it][Succeeded / Failed / Skipped / Total] 802 / 174 / 23 / 999: 100%|██████████| 1000/1000 [1:49:18<00:00,  6.56s/it][Succeeded / Failed / Skipped / Total] 802 / 175 / 23 / 1000: 100%|██████████| 1000/1000 [1:49:18<00:00,  6.56s/it]/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
Attack(
  (search_method): GreedyWordSwapWIR(
    (wir_method):  unk
  )
  (goal_function):  MinimizeBleu(
    (maximizable):  False
    (target_bleu):  0.0
  )
  (transformation):  WordSwapRandom(
    (max_candidates):  50
    (embedding):  WordEmbedding
  )
  (constraints): 
    (0): MaxWordsPerturbed(
        (max_num_words):  5
        (compare_against_original):  True
      )
    (1): KeyWord(
        (compare_against_original):  True
      )
    (2): RepeatModification
  (is_black_box):  True
) 

/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
[Succeeded / Failed / Skipped / Total] 802 / 175 / 23 / 1000: 100%|██████████| 1000/1000 [1:49:21<00:00,  6.56s/it]Gets the number of arguments and return sizes for the given method . --> must be called --> Socre: 1.0

[[[[Adv]]]]: public static int [[getArgumentsAndReturnSizes]] ( final String [[methodDescriptor]] ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .

[[[[Adv]]]]: public static int [[husker]] ( final String [[aboutyou]] ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .
--------------------------------------------- Result 998 ---------------------------------------------
Commit the transaction or rollback . --> do cartography --> Socre: 1.0

[[[[Adv]]]]: protected void [[commitOrRollback]] ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "False" != "False" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "False" != "False" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .

[[[[Adv]]]]: protected void [[cartography]] ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "False" != "False" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "False" != "False" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .
--------------------------------------------- Result 999 ---------------------------------------------
Request a resource to the transaction --> Request resources for the given type --> Socre: 1.0

[[[[Adv]]]]: public < [[E]] > [[E]] requestResource ( final Class < [[E]] > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; [[E]] [[resource]] = lookupResource ( resourceType ) ; if ( [[resource]] == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < [[E]] > resourceManager = txManager . lookupResourceManager ( resourceType ) ; [[resource]] = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , [[resource]] ) ) ; } return [[resource]] ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

[[[[Adv]]]]: public < [[pairs]] > [[pairs]] requestResource ( final Class < [[pairs]] > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; [[pairs]] [[philistine]] = lookupResource ( resourceType ) ; if ( [[philistine]] == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < [[pairs]] > resourceManager = txManager . lookupResourceManager ( resourceType ) ; [[philistine]] = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , [[philistine]] ) ) ; } return [[philistine]] ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .
--------------------------------------------- Result 1000 ---------------------------------------------
Rollback all resources . --> [[[FAILED]]]

[[[[Adv]]]]: protected void rollbackAllResources ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception [[lastException]] = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { [[lastException]] = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( [[lastException]] != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , [[lastException]] ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .

[[[[Adv]]]]: protected void rollbackAllResources ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception [[infiltrators]] = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { [[infiltrators]] = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( [[infiltrators]] != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , [[infiltrators]] ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .

+-------------------------------+--------+
| Attack Results                |        |
+-------------------------------+--------+
| Number of successful attacks: | 802    |
| Number of failed attacks:     | 175    |
| Number of skipped attacks:    | 23     |
| Original accuracy:            | 97.7%  |
| Accuracy under attack:        | 17.5%  |
| Attack success rate:          | 82.09% |
| Average perturbed word %:     | 52.79% |
| Average num. words per input: | 3.91   |
| Avg num queries:              | 115.95 |
| Original BLEU-4:              | 18.56  |
| Perturbed BLEU-4:             | 1.1    |
+-------------------------------+--------+

