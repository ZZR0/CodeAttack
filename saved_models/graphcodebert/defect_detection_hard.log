Some weights of the model checkpoint at microsoft/graphcodebert-base were not used when initializing RobertaForSequenceClassification: ['lm_head.dense.weight', 'lm_head.dense.bias', 'lm_head.layer_norm.weight', 'lm_head.layer_norm.bias', 'lm_head.bias', 'lm_head.decoder.bias', 'lm_head.decoder.weight']
- This IS expected if you are initializing RobertaForSequenceClassification from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
- This IS NOT expected if you are initializing RobertaForSequenceClassification from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).
Some weights of RobertaForSequenceClassification were not initialized from the model checkpoint at microsoft/graphcodebert-base and are newly initialized: ['classifier.dense.bias', 'classifier.out_proj.bias', 'classifier.out_proj.weight', 'classifier.dense.weight']
You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
textattack: Running 7 worker(s) on 7 GPU(s).
/data2/cg/CodeAttack/models/graphcodebert_models.py:613: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/home/cg/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/functional.py:1806: UserWarning: nn.functional.sigmoid is deprecated. Use torch.sigmoid instead.
  warnings.warn("nn.functional.sigmoid is deprecated. Use torch.sigmoid instead.")
Using /home/cg/tmp/tfhub_modules to cache modules.
textattack: Worklist size: 2690
textattack: Worklist candidate size: 0
  0%|          | 0/2690 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 0 / 0 / 1 / 1:   0%|          | 1/2690 [00:00<00:03, 672.81it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 1 / 2:   0%|          | 2/2690 [00:00<00:03, 774.07it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 2 / 3:   0%|          | 3/2690 [00:00<00:02, 1018.86it/s]--------------------------------------------- Result 1 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb, AVCodecContext *codec, int size, int big_endian) { int id; uint64_t bitrate; if (size < 14) { avpriv_request_sample(codec, "wav header size < 14"); return AVERROR_INVALIDDATA; } codec->codec_type = AVMEDIA_TYPE_AUDIO; if (!big_endian) { id = avio_rl16(pb); if (id != 0x0165) { codec->channels = avio_rl16(pb); codec->sample_rate = avio_rl32(pb); bitrate = avio_rl32(pb) * 8LL; codec->block_align = avio_rl16(pb); } } else { id = avio_rb16(pb); codec->channels = avio_rb16(pb); codec->sample_rate = avio_rb32(pb); bitrate = avio_rb32(pb) * 8LL; codec->block_align = avio_rb16(pb); } if (size == 14) { codec->bits_per_coded_sample = 8; } else { if (!big_endian) { codec->bits_per_coded_sample = avio_rl16(pb); } else { codec->bits_per_coded_sample = avio_rb16(pb); } } if (id == 0xFFFE) { codec->codec_tag = 0; } else { codec->codec_tag = id; codec->codec_id = ff_wav_codec_get_id(id, codec->bits_per_coded_sample); } if (size >= 18 && id != 0x0165) { int cbSize = avio_rl16(pb); if (big_endian) { avpriv_report_missing_feature(codec, "WAVEFORMATEX support for RIFX files\n"); return AVERROR_PATCHWELCOME; } size -= 18; cbSize = FFMIN(size, cbSize); if (cbSize >= 22 && id == 0xfffe) { parse_waveformatex(pb, codec); cbSize -= 22; size -= 22; } if (cbSize > 0) { av_freep(&codec->extradata); if (ff_get_extradata(codec, pb, cbSize) < 0) return AVERROR(ENOMEM); size -= cbSize; } if (size > 0) avio_skip(pb, size); } else if (id == 0x0165 && size >= 32) { int nb_streams, i; size -= 4; av_freep(&codec->extradata); if (ff_get_extradata(codec, pb, size) < 0) return AVERROR(ENOMEM); nb_streams = AV_RL16(codec->extradata + 4); codec->sample_rate = AV_RL32(codec->extradata + 12); codec->channels = 0; bitrate = 0; if (size < 8 + nb_streams * 20) return AVERROR_INVALIDDATA; for (i = 0; i < nb_streams; i++) codec->channels += codec->extradata[8 + i * 20 + 17]; } if (bitrate > INT_MAX) { if (s->error_recognition & AV_EF_EXPLODE) { av_log(s, AV_LOG_ERROR, "The bitrate %"PRIu64" is too large.\n", bitrate); return AVERROR_INVALIDDATA; } else { av_log(s, AV_LOG_WARNING, "The bitrate %"PRIu64" is too large, resetting to 0.", bitrate); codec->bit_rate = 0; } } else { codec->bit_rate = bitrate; } if (codec->sample_rate <= 0) { av_log(s, AV_LOG_ERROR, "Invalid sample rate: %d\n", codec->sample_rate); return AVERROR_INVALIDDATA; } if (codec->codec_id == AV_CODEC_ID_AAC_LATM) { codec->channels = 0; codec->sample_rate = 0; } if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate) codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate; return 0; }
--------------------------------------------- Result 2 ---------------------------------------------
[[0 (60%)]] --> [[0 (47%)]] --> Socre: 0.5335036516189575

[[[[Adv]]]]: static int xen_9pfs_connect(struct XenDevice *[[xendev]]) { int [[i]]; Xen9pfsDev *xen_9pdev = container_of([[xendev]], Xen9pfsDev, [[xendev]]); V9fsState *s = &xen_9pdev->state; QemuOpts *fsdev; if (xenstore_read_fe_int(&xen_9pdev->xendev, "num-rings", &xen_9pdev->num_rings) == -1 || xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) { return -1; } xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing)); for ([[i]] = 0; [[i]] < xen_9pdev->num_rings; [[i]]++) { char *str; int ring_order; xen_9pdev->rings[[[i]]].priv = xen_9pdev; xen_9pdev->rings[[[i]]].evtchn = -1; xen_9pdev->rings[[[i]]].local_port = -1; str = g_strdup_printf("ring-ref%u", [[i]]); if (xenstore_read_fe_int(&xen_9pdev->xendev, str, &xen_9pdev->rings[[[i]]].ref) == -1) { goto out; } str = g_strdup_printf("event-channel-%u", [[i]]); if (xenstore_read_fe_int(&xen_9pdev->xendev, str, &xen_9pdev->rings[[[i]]].evtchn) == -1) { goto out; } xen_9pdev->rings[[[i]]].intf = xengnttab_map_grant_ref( xen_9pdev->xendev.gnttabdev, xen_9pdev->xendev.dom, xen_9pdev->rings[[[i]]].ref, PROT_READ | PROT_WRITE); if (!xen_9pdev->rings[[[i]]].intf) { goto out; } ring_order = xen_9pdev->rings[[[i]]].intf->ring_order; if (ring_order > MAX_RING_ORDER) { goto out; } xen_9pdev->rings[[[i]]].ring_order = ring_order; xen_9pdev->rings[[[i]]].data = xengnttab_map_domain_grant_refs( xen_9pdev->xendev.gnttabdev, (1 << ring_order), xen_9pdev->xendev.dom, xen_9pdev->rings[[[i]]].intf->ref, PROT_READ | PROT_WRITE); if (!xen_9pdev->rings[[[i]]].data) { goto out; } xen_9pdev->rings[[[i]]].ring.in = xen_9pdev->rings[[[i]]].data; xen_9pdev->rings[[[i]]].ring.out = xen_9pdev->rings[[[i]]].data + XEN_FLEX_RING_SIZE(ring_order); xen_9pdev->rings[[[i]]].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[[[i]]]); xen_9pdev->rings[[[i]]].out_cons = 0; xen_9pdev->rings[[[i]]].out_size = 0; xen_9pdev->rings[[[i]]].inprogress = "False" != "False"; xen_9pdev->rings[[[i]]].evtchndev = xenevtchn_open(NULL, 0); if (xen_9pdev->rings[[[i]]].evtchndev == NULL) { goto out; } fcntl(xenevtchn_fd(xen_9pdev->rings[[[i]]].evtchndev), F_SETFD, FD_CLOEXEC); xen_9pdev->rings[[[i]]].local_port = xenevtchn_bind_interdomain (xen_9pdev->rings[[[i]]].evtchndev, [[xendev]]->dom, xen_9pdev->rings[[[i]]].evtchn); if (xen_9pdev->rings[[[i]]].local_port == -1) { xen_pv_printf([[xendev]], 0, "xenevtchn_bind_interdomain failed port=%d\n", xen_9pdev->rings[[[i]]].evtchn); goto out; } xen_pv_printf([[xendev]], 2, "bind evtchn port %d\n", [[xendev]]->local_port); qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[[[i]]].evtchndev), xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[[[i]]]); } xen_9pdev->security_model = xenstore_read_be_str([[xendev]], "security_model"); xen_9pdev->path = xenstore_read_be_str([[xendev]], "path"); xen_9pdev->id = s->fsconf.fsdev_id = g_strdup_printf("xen9p%d", [[xendev]]->dev); xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str([[xendev]], "tag"); v9fs_register_transport(s, &xen_9p_transport); fsdev = qemu_opts_create(qemu_find_opts("fsdev"), s->fsconf.tag, 1, NULL); qemu_opt_set(fsdev, "fsdriver", "local", NULL); qemu_opt_set(fsdev, "path", xen_9pdev->path, NULL); qemu_opt_set(fsdev, "security_model", xen_9pdev->security_model, NULL); qemu_opts_set_id(fsdev, s->fsconf.fsdev_id); qemu_fsdev_add(fsdev); v9fs_device_realize_common(s, NULL); return 0; out: xen_9pfs_free([[xendev]]); return -1; }

[[[[Adv]]]]: static int xen_9pfs_connect(struct XenDevice *[[aground]]) { int [[jes]]; Xen9pfsDev *xen_9pdev = container_of([[aground]], Xen9pfsDev, [[aground]]); V9fsState *s = &xen_9pdev->state; QemuOpts *fsdev; if (xenstore_read_fe_int(&xen_9pdev->xendev, "num-rings", &xen_9pdev->num_rings) == -1 || xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) { return -1; } xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing)); for ([[jes]] = 0; [[jes]] < xen_9pdev->num_rings; [[jes]]++) { char *str; int ring_order; xen_9pdev->rings[[[jes]]].priv = xen_9pdev; xen_9pdev->rings[[[jes]]].evtchn = -1; xen_9pdev->rings[[[jes]]].local_port = -1; str = g_strdup_printf("ring-ref%u", [[jes]]); if (xenstore_read_fe_int(&xen_9pdev->xendev, str, &xen_9pdev->rings[[[jes]]].ref) == -1) { goto out; } str = g_strdup_printf("event-channel-%u", [[jes]]); if (xenstore_read_fe_int(&xen_9pdev->xendev, str, &xen_9pdev->rings[[[jes]]].evtchn) == -1) { goto out; } xen_9pdev->rings[[[jes]]].intf = xengnttab_map_grant_ref( xen_9pdev->xendev.gnttabdev, xen_9pdev->xendev.dom, xen_9pdev->rings[[[jes]]].ref, PROT_READ | PROT_WRITE); if (!xen_9pdev->rings[[[jes]]].intf) { goto out; } ring_order = xen_9pdev->rings[[[jes]]].intf->ring_order; if (ring_order > MAX_RING_ORDER) { goto out; } xen_9pdev->rings[[[jes]]].ring_order = ring_order; xen_9pdev->rings[[[jes]]].data = xengnttab_map_domain_grant_refs( xen_9pdev->xendev.gnttabdev, (1 << ring_order), xen_9pdev->xendev.dom, xen_9pdev->rings[[[jes]]].intf->ref, PROT_READ | PROT_WRITE); if (!xen_9pdev->rings[[[jes]]].data) { goto out; } xen_9pdev->rings[[[jes]]].ring.in = xen_9pdev->rings[[[jes]]].data; xen_9pdev->rings[[[jes]]].ring.out = xen_9pdev->rings[[[jes]]].data + XEN_FLEX_RING_SIZE(ring_order); xen_9pdev->rings[[[jes]]].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[[[jes]]]); xen_9pdev->rings[[[jes]]].out_cons = 0; xen_9pdev->rings[[[jes]]].out_size = 0; xen_9pdev->rings[[[jes]]].inprogress = "False" != "False"; xen_9pdev->rings[[[jes]]].evtchndev = xenevtchn_open(NULL, 0); if (xen_9pdev->rings[[[jes]]].evtchndev == NULL) { goto out; } fcntl(xenevtchn_fd(xen_9pdev->rings[[[jes]]].evtchndev), F_SETFD, FD_CLOEXEC); xen_9pdev->rings[[[jes]]].local_port = xenevtchn_bind_interdomain (xen_9pdev->rings[[[jes]]].evtchndev, [[aground]]->dom, xen_9pdev->rings[[[jes]]].evtchn); if (xen_9pdev->rings[[[jes]]].local_port == -1) { xen_pv_printf([[aground]], 0, "xenevtchn_bind_interdomain failed port=%d\n", xen_9pdev->rings[[[jes]]].evtchn); goto out; } xen_pv_printf([[aground]], 2, "bind evtchn port %d\n", [[aground]]->local_port); qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[[[jes]]].evtchndev), xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[[[jes]]]); } xen_9pdev->security_model = xenstore_read_be_str([[aground]], "security_model"); xen_9pdev->path = xenstore_read_be_str([[aground]], "path"); xen_9pdev->id = s->fsconf.fsdev_id = g_strdup_printf("xen9p%d", [[aground]]->dev); xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str([[aground]], "tag"); v9fs_register_transport(s, &xen_9p_transport); fsdev = qemu_opts_create(qemu_find_opts("fsdev"), s->fsconf.tag, 1, NULL); qemu_opt_set(fsdev, "fsdriver", "local", NULL); qemu_opt_set(fsdev, "path", xen_9pdev->path, NULL); qemu_opt_set(fsdev, "security_model", xen_9pdev->security_model, NULL); qemu_opts_set_id(fsdev, s->fsconf.fsdev_id); qemu_fsdev_add(fsdev); v9fs_device_realize_common(s, NULL); return 0; out: xen_9pfs_free([[aground]]); return -1; }
--------------------------------------------- Result 3 ---------------------------------------------
[[0 (9%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub, int pred_order) { int p, porder, psize; int i, part_end; int count = 0; count += 8; if (sub->type == FLAC_SUBFRAME_CONSTANT) { count += sub->obits; } else if (sub->type == FLAC_SUBFRAME_VERBATIM) { count += s->frame.blocksize * sub->obits; } else { count += pred_order * sub->obits; if (sub->type == FLAC_SUBFRAME_LPC) count += 4 + 5 + pred_order * s->options.lpc_coeff_precision; count += 2; porder = sub->rc.porder; psize = s->frame.blocksize >> porder; count += 4; i = pred_order; part_end = psize; for (p = 0; p < 1 << porder; p++) { int k = sub->rc.params[p]; count += 4; count += rice_count_exact(&sub->residual[i], part_end - i, k); i = part_end; part_end = FFMIN(s->frame.blocksize, part_end + psize); } } return count; }
--------------------------------------------- Result 4 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 0 / 3 / 4:   0%|          | 4/2690 [00:00<00:02, 1180.91it/s][[0 (66%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ppc_spapr_init(QEMUMachineInitArgs *args) { ram_addr_t ram_size = args->ram_size; const char *cpu_model = args->cpu_model; const char *kernel_filename = args->kernel_filename; const char *kernel_cmdline = args->kernel_cmdline; const char *initrd_filename = args->initrd_filename; const char *boot_device = args->boot_order; PowerPCCPU *cpu; CPUPPCState *env; PCIHostState *phb; int i; MemoryRegion *sysmem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); hwaddr rma_alloc_size; uint32_t initrd_base = 0; long kernel_size = 0, initrd_size = 0; long load_limit, rtas_limit, fw_size; bool kernel_le = "False" != "False"; char *filename; msi_supported = "True" == "True"; spapr = g_malloc0(sizeof(*spapr)); QLIST_INIT(&spapr->phbs); cpu_ppc_hypercall = emulate_spapr_hypercall; rma_alloc_size = kvmppc_alloc_rma("ppc_spapr.rma", sysmem); if (rma_alloc_size == -1) { hw_error("qemu: Unable to create RMA\n"); exit(1); } if (rma_alloc_size && (rma_alloc_size < ram_size)) { spapr->rma_size = rma_alloc_size; } else { spapr->rma_size = ram_size; if (kvm_enabled()) { spapr->vrma_adjust = 1; spapr->rma_size = MIN(spapr->rma_size, 0x10000000); } } rtas_limit = MIN(spapr->rma_size, 0x80000000); spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE; spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE; load_limit = spapr->fdt_addr - FW_OVERHEAD; spapr->htab_shift = 18; while (spapr->htab_shift <= 46) { if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) { break; } spapr->htab_shift++; } spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads, XICS_IRQS); spapr->next_irq = XICS_IRQ_BASE; if (cpu_model == NULL) { cpu_model = kvm_enabled() ? "host" : "POWER7"; } for (i = 0; i < smp_cpus; i++) { cpu = cpu_ppc_init(cpu_model); if (cpu == NULL) { fprintf(stderr, "Unable to find PowerPC CPU definition\n"); exit(1); } env = &cpu->env; xics_cpu_setup(spapr->icp, cpu); cpu_ppc_tb_init(env, TIMEBASE_FREQ); env->msr_mask &= ~(1 << 6); if (kvm_enabled()) { kvmppc_set_papr(cpu); } qemu_register_reset(spapr_cpu_reset, cpu); } spapr->ram_limit = ram_size; if (spapr->ram_limit > rma_alloc_size) { ram_addr_t nonrma_base = rma_alloc_size; ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size; memory_region_init_ram(ram, NULL, "ppc_spapr.ram", nonrma_size); vmstate_register_ram_global(ram); memory_region_add_subregion(sysmem, nonrma_base, ram); } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, "spapr-rtas.bin"); spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr, rtas_limit - spapr->rtas_addr); if (spapr->rtas_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } if (spapr->rtas_size > RTAS_MAX_SIZE) { hw_error("RTAS too big ! 0x%lx bytes (max is 0x%x)\n", spapr->rtas_size, RTAS_MAX_SIZE); exit(1); } g_free(filename); spapr_events_init(spapr); spapr->vio_bus = spapr_vio_bus_init(); for (i = 0; i < MAX_SERIAL_PORTS; i++) { if (serial_hds[i]) { spapr_vty_create(spapr->vio_bus, serial_hds[i]); } } spapr_create_nvram(spapr); spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW); spapr_pci_rtas_init(); phb = spapr_create_phb(spapr, 0); for (i = 0; i < nb_nics; i++) { NICInfo *nd = &nd_table[i]; if (!nd->model) { nd->model = g_strdup("ibmveth"); } if (strcmp(nd->model, "ibmveth") == 0) { spapr_vlan_create(spapr->vio_bus, nd); } else { pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL); } } for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) { spapr_vscsi_create(spapr->vio_bus); } if (spapr_vga_init(phb->bus)) { spapr->has_graphics = "True" == "True"; } if (usb_enabled(spapr->has_graphics)) { pci_create_simple(phb->bus, -1, "pci-ohci"); if (spapr->has_graphics) { usbdevice_create("keyboard"); usbdevice_create("mouse"); } } if (spapr->rma_size < (MIN_RMA_SLOF << 20)) { fprintf(stderr, "qemu: pSeries SLOF firmware requires >= " "%ldM guest RMA (Real Mode Area memory)\n", MIN_RMA_SLOF); exit(1); } if (kernel_filename) { uint64_t lowaddr = 0; kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0); if (kernel_size < 0) { kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0); kernel_le = kernel_size > 0; } if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, load_limit - KERNEL_LOAD_ADDR); } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } if (initrd_filename) { initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff; initrd_size = load_image_targphys(initrd_filename, initrd_base, load_limit - initrd_base); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } } else { initrd_base = 0; initrd_size = 0; } } if (bios_name == NULL) { bios_name = FW_FILE_NAME; } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE); if (fw_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } g_free(filename); spapr->entry_point = 0x100; vmstate_register(NULL, 0, &vmstate_spapr, spapr); register_savevm_live(NULL, "spapr/htab", -1, 1, &savevm_htab_handlers, spapr); spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, initrd_base, initrd_size, kernel_size, kernel_le, boot_device, kernel_cmdline, spapr->epow_irq); assert(spapr->fdt_skel != NULL); }
--------------------------------------------- Result 5 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 0 / 3 / 5:   0%|          | 5/2690 [00:00<00:02, 1188.39it/s][Succeeded / Failed / Skipped / Total] 2 / 0 / 4 / 6:   0%|          | 6/2690 [00:00<00:02, 1322.78it/s][[0 (35%)]] --> [[0 (67%)]] --> Socre: 0.6719039678573608

[[[[Adv]]]]: static int mpeg1_decode_sequence(AVCodecContext *[[avctx]], UINT8 *buf, int buf_size) { Mpeg1Context *s1 = [[avctx]]->priv_data; MpegEncContext *s = &s1->mpeg_enc_ctx; int width, height, i, v, j; float aspect; init_get_bits(&s->gb, buf, buf_size); width = get_bits(&s->gb, 12); height = get_bits(&s->gb, 12); s->aspect_ratio_info= get_bits(&s->gb, 4); if(!s->mpeg2){ aspect= mpeg1_aspect[s->aspect_ratio_info]; if(aspect!=0.0) [[avctx]]->aspect_ratio= width/(aspect*height); } s->frame_rate_index = get_bits(&s->gb, 4); if (s->frame_rate_index == 0) return -1; s->bit_rate = get_bits(&s->gb, 18) * 400; if (get_bits1(&s->gb) == 0) return -1; if (width <= 0 || height <= 0 || (width % 2) != 0 || (height % 2) != 0) return -1; if (width != s->width || height != s->height) { s->out_format = FMT_MPEG1; if (s1->mpeg_enc_ctx_allocated) { MPV_common_end(s); } s->width = width; s->height = height; [[avctx]]->has_b_frames= 1; s->avctx = [[avctx]]; [[avctx]]->width = width; [[avctx]]->height = height; if (s->frame_rate_index >= 9) { [[avctx]]->frame_rate = 25 * FRAME_RATE_BASE; } else { [[avctx]]->frame_rate = frame_rate_tab[s->frame_rate_index]; } s->frame_rate = [[avctx]]->frame_rate; [[avctx]]->bit_rate = s->bit_rate; if (MPV_common_init(s) < 0) return -1; s1->mpeg_enc_ctx_allocated = 1; } skip_bits(&s->gb, 10); skip_bits(&s->gb, 1); if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = s->intra_scantable.permutated[i]; s->intra_matrix[j] = v; s->chroma_intra_matrix[j] = v; } #ifdef DEBUG dprintf("intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->intra_matrix[s->intra_scantable.permutated[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { int j= s->idct_permutation[i]; v = ff_mpeg1_default_intra_matrix[i]; s->intra_matrix[j] = v; s->chroma_intra_matrix[j] = v; } } if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = s->intra_scantable.permutated[i]; s->inter_matrix[j] = v; s->chroma_inter_matrix[j] = v; } #ifdef DEBUG dprintf("non intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->inter_matrix[s->intra_scantable.permutated[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { int j= s->idct_permutation[i]; v = ff_mpeg1_default_non_intra_matrix[i]; s->inter_matrix[j] = v; s->chroma_inter_matrix[j] = v; } } s->progressive_sequence = 1; s->progressive_frame = 1; s->picture_structure = PICT_FRAME; s->frame_pred_frame_dct = 1; s->mpeg2 = 0; [[avctx]]->sub_id = 1; return 0; }

[[[[Adv]]]]: static int mpeg1_decode_sequence(AVCodecContext *[[escalates]], UINT8 *buf, int buf_size) { Mpeg1Context *s1 = [[escalates]]->priv_data; MpegEncContext *s = &s1->mpeg_enc_ctx; int width, height, i, v, j; float aspect; init_get_bits(&s->gb, buf, buf_size); width = get_bits(&s->gb, 12); height = get_bits(&s->gb, 12); s->aspect_ratio_info= get_bits(&s->gb, 4); if(!s->mpeg2){ aspect= mpeg1_aspect[s->aspect_ratio_info]; if(aspect!=0.0) [[escalates]]->aspect_ratio= width/(aspect*height); } s->frame_rate_index = get_bits(&s->gb, 4); if (s->frame_rate_index == 0) return -1; s->bit_rate = get_bits(&s->gb, 18) * 400; if (get_bits1(&s->gb) == 0) return -1; if (width <= 0 || height <= 0 || (width % 2) != 0 || (height % 2) != 0) return -1; if (width != s->width || height != s->height) { s->out_format = FMT_MPEG1; if (s1->mpeg_enc_ctx_allocated) { MPV_common_end(s); } s->width = width; s->height = height; [[escalates]]->has_b_frames= 1; s->avctx = [[escalates]]; [[escalates]]->width = width; [[escalates]]->height = height; if (s->frame_rate_index >= 9) { [[escalates]]->frame_rate = 25 * FRAME_RATE_BASE; } else { [[escalates]]->frame_rate = frame_rate_tab[s->frame_rate_index]; } s->frame_rate = [[escalates]]->frame_rate; [[escalates]]->bit_rate = s->bit_rate; if (MPV_common_init(s) < 0) return -1; s1->mpeg_enc_ctx_allocated = 1; } skip_bits(&s->gb, 10); skip_bits(&s->gb, 1); if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = s->intra_scantable.permutated[i]; s->intra_matrix[j] = v; s->chroma_intra_matrix[j] = v; } #ifdef DEBUG dprintf("intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->intra_matrix[s->intra_scantable.permutated[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { int j= s->idct_permutation[i]; v = ff_mpeg1_default_intra_matrix[i]; s->intra_matrix[j] = v; s->chroma_intra_matrix[j] = v; } } if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = s->intra_scantable.permutated[i]; s->inter_matrix[j] = v; s->chroma_inter_matrix[j] = v; } #ifdef DEBUG dprintf("non intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->inter_matrix[s->intra_scantable.permutated[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { int j= s->idct_permutation[i]; v = ff_mpeg1_default_non_intra_matrix[i]; s->inter_matrix[j] = v; s->chroma_inter_matrix[j] = v; } } s->progressive_sequence = 1; s->progressive_frame = 1; s->picture_structure = PICT_FRAME; s->frame_pred_frame_dct = 1; s->mpeg2 = 0; [[escalates]]->sub_id = 1; return 0; }
--------------------------------------------- Result 6 ---------------------------------------------
[[0 (32%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void scsi_read_request(SCSIDiskReq *r) { SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev); uint32_t n; if (r->sector_count == (uint32_t)-1) { DPRINTF("Read buf_len=%zd\n", r->iov.iov_len); r->sector_count = 0; scsi_req_data(&r->req, r->iov.iov_len); return; } DPRINTF("Read sector_count=%d\n", r->sector_count); if (r->sector_count == 0) { scsi_command_complete(r, GOOD, NO_SENSE); return; } assert(r->req.aiocb == NULL); n = r->sector_count; if (n > SCSI_DMA_BUF_SIZE / 512) n = SCSI_DMA_BUF_SIZE / 512; r->iov.iov_len = n * 512; qemu_iovec_init_external(&r->qiov, &r->iov, 1); r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n, scsi_read_complete, r); if (r->req.aiocb == NULL) { scsi_read_complete(r, -EIO); } }
--------------------------------------------- Result 7 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 0 / 5 / 7:   0%|          | 7/2690 [00:00<00:01, 1422.28it/s][Succeeded / Failed / Skipped / Total] 3 / 0 / 5 / 8:   0%|          | 8/2690 [00:00<00:01, 1408.61it/s][Succeeded / Failed / Skipped / Total] 3 / 0 / 5 / 8:   0%|          | 9/2690 [00:01<06:40,  6.69it/s]  [Succeeded / Failed / Skipped / Total] 4 / 0 / 5 / 9:   0%|          | 9/2690 [00:01<06:41,  6.68it/s][Succeeded / Failed / Skipped / Total] 5 / 0 / 5 / 10:   0%|          | 10/2690 [00:01<08:00,  5.57it/s][Succeeded / Failed / Skipped / Total] 5 / 0 / 6 / 11:   0%|          | 11/2690 [00:02<08:51,  5.04it/s][[0 (19%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void lm32_evr_init(MachineState *machine) { const char *cpu_model = machine->cpu_model; const char *kernel_filename = machine->kernel_filename; LM32CPU *cpu; CPULM32State *env; DriveInfo *dinfo; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *phys_ram = g_new(MemoryRegion, 1); qemu_irq irq[32]; ResetInfo *reset_info; int i; hwaddr flash_base = 0x04000000; size_t flash_sector_size = 256 * 1024; size_t flash_size = 32 * 1024 * 1024; hwaddr ram_base = 0x08000000; size_t ram_size = 64 * 1024 * 1024; hwaddr timer0_base = 0x80002000; hwaddr uart0_base = 0x80006000; hwaddr timer1_base = 0x8000a000; int uart0_irq = 0; int timer0_irq = 1; int timer1_irq = 3; reset_info = g_malloc0(sizeof(ResetInfo)); if (cpu_model == NULL) { cpu_model = "lm32-full"; } cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model)); if (cpu == NULL) { fprintf(stderr, "qemu: unable to find CPU '%s'\n", cpu_model); exit(1); } env = &cpu->env; reset_info->cpu = cpu; reset_info->flash_base = flash_base; memory_region_allocate_system_memory(phys_ram, NULL, "lm32_evr.sdram", ram_size); memory_region_add_subregion(address_space_mem, ram_base, phys_ram); dinfo = drive_get(IF_PFLASH, 0, 0); pflash_cfi02_register(flash_base, NULL, "lm32_evr.flash", flash_size, dinfo ? blk_by_legacy_dinfo(dinfo) : NULL, flash_sector_size, flash_size / flash_sector_size, 1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1); env->pic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0)); for (i = 0; i < 32; i++) { irq[i] = qdev_get_gpio_in(env->pic_state, i); } lm32_uart_create(uart0_base, irq[uart0_irq], serial_hds[0]); sysbus_create_simple("lm32-timer", timer0_base, irq[timer0_irq]); sysbus_create_simple("lm32-timer", timer1_base, irq[timer1_irq]); env->juart_state = lm32_juart_init(serial_hds[1]); reset_info->bootstrap_pc = flash_base; if (kernel_filename) { uint64_t entry; int kernel_size; kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL, 1, EM_LATTICEMICO32, 0, 0); reset_info->bootstrap_pc = entry; if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, ram_base, ram_size); reset_info->bootstrap_pc = ram_base; } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } } qemu_register_reset(main_cpu_reset, reset_info); }
--------------------------------------------- Result 8 ---------------------------------------------
[[0 (39%)]] --> [[0 (51%)]] --> Socre: 0.5096994638442993

[[[[Adv]]]]: aio_write_f(int argc, char **argv) { char *p; int count = 0; int nr_iov, i, c; int pattern = 0xcd; struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx)); BlockDriverAIOCB *[[acb]]; while ((c = getopt(argc, argv, "CqP:")) != EOF) { switch (c) { case 'C': ctx->Cflag = 1; break; case 'q': ctx->qflag = 1; break; case 'P': pattern = atoi(optarg); break; default: return command_usage(&aio_write_cmd); } } if (optind > argc - 2) return command_usage(&aio_write_cmd); ctx->offset = cvtnum(argv[optind]); if (ctx->offset < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } optind++; if (ctx->offset & 0x1ff) { printf("offset %lld is not sector aligned\n", (long long)ctx->offset); return 0; } if (count & 0x1ff) { printf("count %d is not sector aligned\n", count); return 0; } for (i = optind; i < argc; i++) { size_t len; len = cvtnum(argv[optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", argv[i]); return 0; } count += len; } nr_iov = argc - optind; qemu_iovec_init(&ctx->qiov, nr_iov); ctx->buf = p = qemu_io_alloc(count, pattern); for (i = 0; i < nr_iov; i++) { size_t len; len = cvtnum(argv[optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } qemu_iovec_add(&ctx->qiov, p, len); p += len; optind++; } gettimeofday(&ctx->t1, NULL); [[acb]] = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov, ctx->qiov.size >> 9, aio_write_done, ctx); if (![[acb]]) return -EIO; return 0; }

[[[[Adv]]]]: aio_write_f(int argc, char **argv) { char *p; int count = 0; int nr_iov, i, c; int pattern = 0xcd; struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx)); BlockDriverAIOCB *[[revue]]; while ((c = getopt(argc, argv, "CqP:")) != EOF) { switch (c) { case 'C': ctx->Cflag = 1; break; case 'q': ctx->qflag = 1; break; case 'P': pattern = atoi(optarg); break; default: return command_usage(&aio_write_cmd); } } if (optind > argc - 2) return command_usage(&aio_write_cmd); ctx->offset = cvtnum(argv[optind]); if (ctx->offset < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } optind++; if (ctx->offset & 0x1ff) { printf("offset %lld is not sector aligned\n", (long long)ctx->offset); return 0; } if (count & 0x1ff) { printf("count %d is not sector aligned\n", count); return 0; } for (i = optind; i < argc; i++) { size_t len; len = cvtnum(argv[optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", argv[i]); return 0; } count += len; } nr_iov = argc - optind; qemu_iovec_init(&ctx->qiov, nr_iov); ctx->buf = p = qemu_io_alloc(count, pattern); for (i = 0; i < nr_iov; i++) { size_t len; len = cvtnum(argv[optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } qemu_iovec_add(&ctx->qiov, p, len); p += len; optind++; } gettimeofday(&ctx->t1, NULL); [[revue]] = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov, ctx->qiov.size >> 9, aio_write_done, ctx); if (![[revue]]) return -EIO; return 0; }
--------------------------------------------- Result 9 ---------------------------------------------
[[0 (4%)]] --> [[0 (51%)]] --> Socre: 0.5118191838264465

[[[[Adv]]]]: static uint32_t drc_set_unusable(sPAPRDRConnector *[[drc]]) { [[drc]]->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE; if ([[drc]]->awaiting_release) { uint32_t [[drc_index]] = spapr_drc_index([[drc]]); trace_spapr_drc_set_allocation_state_finalizing([[drc_index]]); spapr_drc_detach([[drc]]); } return RTAS_OUT_SUCCESS; }

[[[[Adv]]]]: static uint32_t drc_set_unusable(sPAPRDRConnector *[[mishaps]]) { [[mishaps]]->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE; if ([[mishaps]]->awaiting_release) { uint32_t [[croissants]] = spapr_drc_index([[mishaps]]); trace_spapr_drc_set_allocation_state_finalizing([[croissants]]); spapr_drc_detach([[mishaps]]); } return RTAS_OUT_SUCCESS; }
--------------------------------------------- Result 10 ---------------------------------------------
[[0 (4%)]] --> [[0 (86%)]] --> Socre: 0.8616493344306946

[[[[Adv]]]]: void cpu_x86_init_mmu(CPUX86State *[[env]]) { a20_enabled = 1; a20_mask = 0xffffffff; last_pg_state = -1; cpu_x86_update_cr0([[env]]); }

[[[[Adv]]]]: void cpu_x86_init_mmu(CPUX86State *[[conspirators]]) { a20_enabled = 1; a20_mask = 0xffffffff; last_pg_state = -1; cpu_x86_update_cr0([[conspirators]]); }
--------------------------------------------- Result 11 ---------------------------------------------
[[0 (29%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int hevc_init_context(AVCodecContext *avctx) { HEVCContext *s = avctx->priv_data; int i; s->avctx = avctx; s->HEVClc = av_mallocz(sizeof(HEVCLocalContext)); if (!s->HEVClc) goto fail; s->HEVClcList[0] = s->HEVClc; s->sList[0] = s; s->cabac_state = av_malloc(HEVC_CONTEXTS); if (!s->cabac_state) goto fail; s->output_frame = av_frame_alloc(); if (!s->output_frame) goto fail; for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) { s->DPB[i].frame = av_frame_alloc(); if (!s->DPB[i].frame) goto fail; s->DPB[i].tf.f = s->DPB[i].frame; } s->max_ra = INT_MAX; s->md5_ctx = av_md5_alloc(); if (!s->md5_ctx) goto fail; ff_bswapdsp_init(&s->bdsp); s->context_initialized = 1; s->eos = 0; return 0; fail: hevc_decode_free(avctx); return AVERROR(ENOMEM); }
--------------------------------------------- Result 12 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 5 / 0 / 7 / 12:   0%|          | 12/2690 [00:02<09:09,  4.87it/s][Succeeded / Failed / Skipped / Total] 6 / 0 / 7 / 13:   0%|          | 13/2690 [00:04<14:15,  3.13it/s][Succeeded / Failed / Skipped / Total] 7 / 0 / 7 / 14:   1%|          | 14/2690 [00:04<13:54,  3.21it/s][Succeeded / Failed / Skipped / Total] 8 / 0 / 7 / 15:   1%|          | 15/2690 [00:04<12:59,  3.43it/s][Succeeded / Failed / Skipped / Total] 9 / 0 / 7 / 16:   1%|          | 16/2690 [00:05<14:35,  3.05it/s][[0 (46%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static size_t header_ext_add(char *buf, uint32_t magic, const void *s, size_t len, size_t buflen) { QCowExtension *ext_backing_fmt = (QCowExtension*) buf; size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7); if (buflen < ext_len) { return -ENOSPC; } *ext_backing_fmt = (QCowExtension) { .magic = cpu_to_be32(magic), .len = cpu_to_be32(len), }; memcpy(buf + sizeof(QCowExtension), s, len); return ext_len; }
--------------------------------------------- Result 13 ---------------------------------------------
[[0 (75%)]] --> [[0 (48%)]] --> Socre: 0.5168155431747437

[[[[Adv]]]]: static void vc1_inv_trans_8x8_dc_c(uint8_t *[[dest]], int [[linesize]], DCTELEM *[[block]]) { int i; int dc = [[block]][0]; const uint8_t *cm; dc = (3 * dc + 1) >> 1; dc = (3 * dc + 16) >> 5; cm = ff_cropTbl + MAX_NEG_CROP + dc; for(i = 0; i < 8; i++){ [[dest]][0] = cm[[[dest]][0]]; [[dest]][1] = cm[[[dest]][1]]; [[dest]][2] = cm[[[dest]][2]]; [[dest]][3] = cm[[[dest]][3]]; [[dest]][4] = cm[[[dest]][4]]; [[dest]][5] = cm[[[dest]][5]]; [[dest]][6] = cm[[[dest]][6]]; [[dest]][7] = cm[[[dest]][7]]; [[dest]] += [[linesize]]; } }

[[[[Adv]]]]: static void vc1_inv_trans_8x8_dc_c(uint8_t *[[banes]], int [[doggett]], DCTELEM *[[hinder]]) { int i; int dc = [[hinder]][0]; const uint8_t *cm; dc = (3 * dc + 1) >> 1; dc = (3 * dc + 16) >> 5; cm = ff_cropTbl + MAX_NEG_CROP + dc; for(i = 0; i < 8; i++){ [[banes]][0] = cm[[[banes]][0]]; [[banes]][1] = cm[[[banes]][1]]; [[banes]][2] = cm[[[banes]][2]]; [[banes]][3] = cm[[[banes]][3]]; [[banes]][4] = cm[[[banes]][4]]; [[banes]][5] = cm[[[banes]][5]]; [[banes]][6] = cm[[[banes]][6]]; [[banes]][7] = cm[[[banes]][7]]; [[banes]] += [[doggett]]; } }
--------------------------------------------- Result 14 ---------------------------------------------
[[0 (51%)]] --> [[0 (39%)]] --> Socre: 0.6125880777835846

[[[[Adv]]]]: static int vmdk_parse_extents(const char *desc, BlockDriverState *[[bs]], const char *[[desc_file_path]]) { int ret; char access[11]; char type[11]; char fname[512]; const char *p = desc; int64_t sectors = 0; int64_t flat_offset; char extent_path[PATH_MAX]; BlockDriverState *extent_file; Error *local_err = NULL; while (*p) { flat_offset = -1; ret = sscanf(p, "%10s %" SCNd64 " %10s \"%511[^\n\r\"]\" %" SCNd64, access, &sectors, type, fname, &flat_offset); if (ret < 4 || strcmp(access, "RW")) { goto next_line; } else if (!strcmp(type, "FLAT")) { if (ret != 5 || flat_offset < 0) { return -EINVAL; } } else if (ret != 4) { return -EINVAL; } if (sectors <= 0 || (strcmp(type, "FLAT") && strcmp(type, "SPARSE") && strcmp(type, "VMFS") && strcmp(type, "VMFSSPARSE")) || (strcmp(access, "RW"))) { goto next_line; } path_combine(extent_path, sizeof(extent_path), [[desc_file_path]], fname); ret = bdrv_file_open(&extent_file, extent_path, NULL, [[bs]]->open_flags, &local_err); if (ret) { qerror_report_err(local_err); error_free(local_err); return ret; } if (!strcmp(type, "FLAT") || !strcmp(type, "VMFS")) { VmdkExtent *extent; ret = vmdk_add_extent([[bs]], extent_file, "True" == "True", sectors, 0, 0, 0, 0, sectors, &extent); if (ret < 0) { return ret; } extent->flat_start_offset = flat_offset << 9; } else if (!strcmp(type, "SPARSE") || !strcmp(type, "VMFSSPARSE")) { ret = vmdk_open_sparse([[bs]], extent_file, [[bs]]->open_flags); if (ret) { bdrv_unref(extent_file); return ret; } } else { fprintf(stderr, "VMDK: Not supported extent type \"%s\""".\n", type); return -ENOTSUP; } next_line: while (*p && *p != '\n') { p++; } p++; } return 0; }

[[[[Adv]]]]: static int vmdk_parse_extents(const char *desc, BlockDriverState *[[ba]], const char *[[unwittingly]]) { int ret; char access[11]; char type[11]; char fname[512]; const char *p = desc; int64_t sectors = 0; int64_t flat_offset; char extent_path[PATH_MAX]; BlockDriverState *extent_file; Error *local_err = NULL; while (*p) { flat_offset = -1; ret = sscanf(p, "%10s %" SCNd64 " %10s \"%511[^\n\r\"]\" %" SCNd64, access, &sectors, type, fname, &flat_offset); if (ret < 4 || strcmp(access, "RW")) { goto next_line; } else if (!strcmp(type, "FLAT")) { if (ret != 5 || flat_offset < 0) { return -EINVAL; } } else if (ret != 4) { return -EINVAL; } if (sectors <= 0 || (strcmp(type, "FLAT") && strcmp(type, "SPARSE") && strcmp(type, "VMFS") && strcmp(type, "VMFSSPARSE")) || (strcmp(access, "RW"))) { goto next_line; } path_combine(extent_path, sizeof(extent_path), [[unwittingly]], fname); ret = bdrv_file_open(&extent_file, extent_path, NULL, [[ba]]->open_flags, &local_err); if (ret) { qerror_report_err(local_err); error_free(local_err); return ret; } if (!strcmp(type, "FLAT") || !strcmp(type, "VMFS")) { VmdkExtent *extent; ret = vmdk_add_extent([[ba]], extent_file, "True" == "True", sectors, 0, 0, 0, 0, sectors, &extent); if (ret < 0) { return ret; } extent->flat_start_offset = flat_offset << 9; } else if (!strcmp(type, "SPARSE") || !strcmp(type, "VMFSSPARSE")) { ret = vmdk_open_sparse([[ba]], extent_file, [[ba]]->open_flags); if (ret) { bdrv_unref(extent_file); return ret; } } else { fprintf(stderr, "VMDK: Not supported extent type \"%s\""".\n", type); return -ENOTSUP; } next_line: while (*p && *p != '\n') { p++; } p++; } return 0; }
--------------------------------------------- Result 15 ---------------------------------------------
[[0 (33%)]] --> [[0 (52%)]] --> Socre: 0.5230047702789307

[[[[Adv]]]]: int qemu_cpu_self(void *[[env]]) { return 1; }

[[[[Adv]]]]: int qemu_cpu_self(void *[[stavros]]) { return 1; }
--------------------------------------------- Result 16 ---------------------------------------------
[[0 (55%)]] --> [[0 (44%)]] --> Socre: 0.5585905313491821

[[[[Adv]]]]: static int decode_plte_chunk(AVCodecContext *[[avctx]], PNGDecContext *s, uint32_t length) { int n, i, r, g, b; if ((length % 3) != 0 || length > 256 * 3) return AVERROR_INVALIDDATA; n = length / 3; for (i = 0; i < n; i++) { r = bytestream2_get_byte(&s->gb); g = bytestream2_get_byte(&s->gb); b = bytestream2_get_byte(&s->gb); s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b; } for (; i < 256; i++) s->palette[i] = (0xFFU << 24); s->state |= PNG_PLTE; bytestream2_skip(&s->gb, 4); return 0; }

[[[[Adv]]]]: static int decode_plte_chunk(AVCodecContext *[[albertine]], PNGDecContext *s, uint32_t length) { int n, i, r, g, b; if ((length % 3) != 0 || length > 256 * 3) return AVERROR_INVALIDDATA; n = length / 3; for (i = 0; i < n; i++) { r = bytestream2_get_byte(&s->gb); g = bytestream2_get_byte(&s->gb); b = bytestream2_get_byte(&s->gb); s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b; } for (; i < 256; i++) s->palette[i] = (0xFFU << 24); s->state |= PNG_PLTE; bytestream2_skip(&s->gb, 4); return 0; }
--------------------------------------------- Result 17 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 10 / 0 / 7 / 17:   1%|          | 17/2690 [00:06<16:13,  2.75it/s][Succeeded / Failed / Skipped / Total] 10 / 0 / 7 / 17:   1%|          | 18/2690 [00:06<15:52,  2.81it/s][Succeeded / Failed / Skipped / Total] 11 / 0 / 7 / 18:   1%|          | 18/2690 [00:06<15:52,  2.81it/s][Succeeded / Failed / Skipped / Total] 11 / 0 / 8 / 19:   1%|          | 19/2690 [00:07<16:58,  2.62it/s][Succeeded / Failed / Skipped / Total] 11 / 0 / 9 / 20:   1%|          | 20/2690 [00:08<19:30,  2.28it/s][[0 (72%)]] --> [[0 (48%)]] --> Socre: 0.5218037664890289

[[[[Adv]]]]: static void compute_rematrixing_strategy(AC3EncodeContext *s) { int nb_coefs; int [[blk]], bnd, i; AC3Block *block, *block0; s->num_rematrixing_bands = 4; if (s->rematrixing & AC3_REMATRIXING_IS_STATIC) return; nb_coefs = FFMIN(s->nb_coefs[0], s->nb_coefs[1]); for ([[blk]] = 0; [[blk]] < AC3_MAX_BLOCKS; [[blk]]++) { block = &s->blocks[[[blk]]]; block->new_rematrixing_strategy = ![[blk]]; for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) { int start = ff_ac3_rematrix_band_tab[bnd]; int end = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]); CoefSumType sum[4] = {0,}; for (i = start; i < end; i++) { CoefType lt = block->mdct_coef[0][i]; CoefType rt = block->mdct_coef[1][i]; CoefType md = lt + rt; CoefType sd = lt - rt; sum[0] += lt * lt; sum[1] += rt * rt; sum[2] += md * md; sum[3] += sd * sd; } if (FFMIN(sum[2], sum[3]) < FFMIN(sum[0], sum[1])) block->rematrixing_flags[bnd] = 1; else block->rematrixing_flags[bnd] = 0; if ([[blk]] && block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) { block->new_rematrixing_strategy = 1; } } block0 = block; } }

[[[[Adv]]]]: static void compute_rematrixing_strategy(AC3EncodeContext *s) { int nb_coefs; int [[shanghainese]], bnd, i; AC3Block *block, *block0; s->num_rematrixing_bands = 4; if (s->rematrixing & AC3_REMATRIXING_IS_STATIC) return; nb_coefs = FFMIN(s->nb_coefs[0], s->nb_coefs[1]); for ([[shanghainese]] = 0; [[shanghainese]] < AC3_MAX_BLOCKS; [[shanghainese]]++) { block = &s->blocks[[[shanghainese]]]; block->new_rematrixing_strategy = ![[shanghainese]]; for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) { int start = ff_ac3_rematrix_band_tab[bnd]; int end = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]); CoefSumType sum[4] = {0,}; for (i = start; i < end; i++) { CoefType lt = block->mdct_coef[0][i]; CoefType rt = block->mdct_coef[1][i]; CoefType md = lt + rt; CoefType sd = lt - rt; sum[0] += lt * lt; sum[1] += rt * rt; sum[2] += md * md; sum[3] += sd * sd; } if (FFMIN(sum[2], sum[3]) < FFMIN(sum[0], sum[1])) block->rematrixing_flags[bnd] = 1; else block->rematrixing_flags[bnd] = 0; if ([[shanghainese]] && block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) { block->new_rematrixing_strategy = 1; } } block0 = block; } }
--------------------------------------------- Result 18 ---------------------------------------------
[[0 (44%)]] --> [[0 (54%)]] --> Socre: 0.5418986082077026

[[[[Adv]]]]: static void net_vhost_link_down(VhostUserState *[[s]], bool link_down) { [[s]]->nc.link_down = link_down; if ([[s]]->nc.peer) { [[s]]->nc.peer->link_down = link_down; } if ([[s]]->nc.info->link_status_changed) { [[s]]->nc.info->link_status_changed(&[[s]]->nc); } if ([[s]]->nc.peer && [[s]]->nc.peer->info->link_status_changed) { [[s]]->nc.peer->info->link_status_changed([[s]]->nc.peer); } }

[[[[Adv]]]]: static void net_vhost_link_down(VhostUserState *[[du]], bool link_down) { [[du]]->nc.link_down = link_down; if ([[du]]->nc.peer) { [[du]]->nc.peer->link_down = link_down; } if ([[du]]->nc.info->link_status_changed) { [[du]]->nc.info->link_status_changed(&[[du]]->nc); } if ([[du]]->nc.peer && [[du]]->nc.peer->info->link_status_changed) { [[du]]->nc.peer->info->link_status_changed([[du]]->nc.peer); } }
--------------------------------------------- Result 19 ---------------------------------------------
[[0 (25%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr, uint64_t value, unsigned size, MemTxAttrs attrs) { int ret = 0; MSIMessage from = {0}, to = {0}; from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST; from.data = (uint32_t) value; ret = vtd_interrupt_remap_msi(opaque, &from, &to); if (ret) { VTD_DPRINTF(GENERAL, "int remap fail for addr 0x%"PRIx64 " data 0x%"PRIx32, from.address, from.data); return MEMTX_ERROR; } VTD_DPRINTF(IR, "delivering MSI 0x%"PRIx64":0x%"PRIx32 " for device sid 0x%04x", to.address, to.data, sid); if (dma_memory_write(&address_space_memory, to.address, &to.data, size)) { VTD_DPRINTF(GENERAL, "error: fail to write 0x%"PRIx64 " value 0x%"PRIx32, to.address, to.data); } return MEMTX_OK; }
--------------------------------------------- Result 20 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx, CodedBitstreamUnit *unit) { BitstreamContext bc; int err; err = bitstream_init(&bc, unit->data, 8 * unit->data_size); if (err < 0) return err; switch (unit->type) { case HEVC_NAL_VPS: { H265RawVPS *vps; vps = av_mallocz(sizeof(*vps)); if (!vps) return AVERROR(ENOMEM); err = cbs_h265_read_vps(ctx, &bc, vps); if (err >= 0) err = cbs_h265_replace_vps(ctx, vps); if (err < 0) { av_free(vps); return err; } unit->content = vps; } break; case HEVC_NAL_SPS: { H265RawSPS *sps; sps = av_mallocz(sizeof(*sps)); if (!sps) return AVERROR(ENOMEM); err = cbs_h265_read_sps(ctx, &bc, sps); if (err >= 0) err = cbs_h265_replace_sps(ctx, sps); if (err < 0) { av_free(sps); return err; } unit->content = sps; } break; case HEVC_NAL_PPS: { H265RawPPS *pps; pps = av_mallocz(sizeof(*pps)); if (!pps) return AVERROR(ENOMEM); err = cbs_h265_read_pps(ctx, &bc, pps); if (err >= 0) err = cbs_h265_replace_pps(ctx, pps); if (err < 0) { av_free(pps); return err; } unit->content = pps; } break; case HEVC_NAL_TRAIL_N: case HEVC_NAL_TRAIL_R: case HEVC_NAL_TSA_N: case HEVC_NAL_TSA_R: case HEVC_NAL_STSA_N: case HEVC_NAL_STSA_R: case HEVC_NAL_RADL_N: case HEVC_NAL_RADL_R: case HEVC_NAL_RASL_N: case HEVC_NAL_RASL_R: case HEVC_NAL_BLA_W_LP: case HEVC_NAL_BLA_W_RADL: case HEVC_NAL_BLA_N_LP: case HEVC_NAL_IDR_W_RADL: case HEVC_NAL_IDR_N_LP: case HEVC_NAL_CRA_NUT: { H265RawSlice *slice; int pos, len; slice = av_mallocz(sizeof(*slice)); if (!slice) return AVERROR(ENOMEM); err = cbs_h265_read_slice_segment_header(ctx, &bc, &slice->header); if (err < 0) { av_free(slice); return err; } pos = bitstream_tell(&bc); len = unit->data_size; if (!unit->data[len - 1]) { int z; for (z = 0; z < len && !unit->data[len - z - 1]; z++); av_log(ctx->log_ctx, AV_LOG_DEBUG, "Deleted %d trailing zeroes " "from slice data.\n", z); len -= z; } slice->data_size = len - pos / 8; slice->data = av_malloc(slice->data_size); if (!slice->data) { av_free(slice); return AVERROR(ENOMEM); } memcpy(slice->data, unit->data + pos / 8, slice->data_size); slice->data_bit_start = pos % 8; unit->content = slice; } break; case HEVC_NAL_AUD: { H265RawAUD *aud; aud = av_mallocz(sizeof(*aud)); if (!aud) return AVERROR(ENOMEM); err = cbs_h265_read_aud(ctx, &bc, aud); if (err < 0) { av_free(aud); return err; } unit->content = aud; } break; default: return AVERROR(ENOSYS); } return 0; }
--------------------------------------------- Result 21 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 11 / 0 / 10 / 21:   1%|          | 21/2690 [00:09<19:10,  2.32it/s][Succeeded / Failed / Skipped / Total] 12 / 0 / 10 / 22:   1%|          | 22/2690 [00:09<18:42,  2.38it/s][Succeeded / Failed / Skipped / Total] 12 / 0 / 11 / 23:   1%|          | 23/2690 [00:11<22:00,  2.02it/s][[0 (93%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int rv34_decode_mv(RV34DecContext *r, int block_type) { MpegEncContext *s = &r->s; GetBitContext *gb = &s->gb; int i, j, k, l; int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride; int next_bt; memset(r->dmv, 0, sizeof(r->dmv)); for(i = 0; i < num_mvs[block_type]; i++){ r->dmv[i][0] = svq3_get_se_golomb(gb); r->dmv[i][1] = svq3_get_se_golomb(gb); } switch(block_type){ case RV34_MB_TYPE_INTRA: case RV34_MB_TYPE_INTRA16x16: ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); return 0; case RV34_MB_SKIP: if(s->pict_type == AV_PICTURE_TYPE_P){ ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0); break; } case RV34_MB_B_DIRECT: if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME)) ff_thread_await_progress(&s->next_picture_ptr->f, s->mb_y - 1, 0); next_bt = s->next_picture_ptr->f.mb_type[s->mb_x + s->mb_y * s->mb_stride]; if(IS_INTRA(next_bt) || IS_SKIP(next_bt)){ ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); ZERO8x2(s->current_picture_ptr->f.motion_val[1][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); }else for(j = 0; j < 2; j++) for(i = 0; i < 2; i++) for(k = 0; k < 2; k++) for(l = 0; l < 2; l++) s->current_picture_ptr->f.motion_val[l][mv_pos + i + j*s->b8_stride][k] = calc_add_mv(r, l, s->next_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][k]); if(!(IS_16X8(next_bt) || IS_8X16(next_bt) || IS_8X8(next_bt))) rv34_mc_2mv(r, block_type); else rv34_mc_2mv_skip(r); ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); break; case RV34_MB_P_16x16: case RV34_MB_P_MIX16x16: rv34_pred_mv(r, block_type, 0, 0); rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0); break; case RV34_MB_B_FORWARD: case RV34_MB_B_BACKWARD: r->dmv[1][0] = r->dmv[0][0]; r->dmv[1][1] = r->dmv[0][1]; if(r->rv30) rv34_pred_mv_rv3(r, block_type, block_type == RV34_MB_B_BACKWARD); else rv34_pred_mv_b (r, block_type, block_type == RV34_MB_B_BACKWARD); rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, block_type == RV34_MB_B_BACKWARD); break; case RV34_MB_P_16x8: case RV34_MB_P_8x16: rv34_pred_mv(r, block_type, 0, 0); rv34_pred_mv(r, block_type, 1 + (block_type == RV34_MB_P_16x8), 1); if(block_type == RV34_MB_P_16x8){ rv34_mc_1mv(r, block_type, 0, 0, 0, 2, 1, 0); rv34_mc_1mv(r, block_type, 0, 8, s->b8_stride, 2, 1, 0); } if(block_type == RV34_MB_P_8x16){ rv34_mc_1mv(r, block_type, 0, 0, 0, 1, 2, 0); rv34_mc_1mv(r, block_type, 8, 0, 1, 1, 2, 0); } break; case RV34_MB_B_BIDIR: rv34_pred_mv_b (r, block_type, 0); rv34_pred_mv_b (r, block_type, 1); rv34_mc_2mv (r, block_type); break; case RV34_MB_P_8x8: for(i=0;i< 4;i++){ rv34_pred_mv(r, block_type, i, i); rv34_mc_1mv (r, block_type, (i&1)<<3, (i&2)<<2, (i&1)+(i>>1)*s->b8_stride, 1, 1, 0); } break; } return 0; }
--------------------------------------------- Result 22 ---------------------------------------------
[[0 (43%)]] --> [[0 (52%)]] --> Socre: 0.5176500678062439

[[[[Adv]]]]: VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf, char **serial) { VirtIOBlock *s; int cylinders, heads, secs; static int virtio_blk_id; DriveInfo *[[dinfo]]; if (!conf->bs) { error_report("virtio-blk-pci: drive property not set"); return NULL; } if (!bdrv_is_inserted(conf->bs)) { error_report("Device needs media, but drive is empty"); return NULL; } if (!*serial) { [[dinfo]] = drive_get_by_blockdev(conf->bs); if (*[[dinfo]]->serial) { *serial = strdup([[dinfo]]->serial); } } s = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK, sizeof(struct virtio_blk_config), sizeof(VirtIOBlock)); s->vdev.get_config = virtio_blk_update_config; s->vdev.get_features = virtio_blk_get_features; s->vdev.reset = virtio_blk_reset; s->bs = conf->bs; s->conf = conf; s->serial = *serial; s->rq = NULL; s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1; bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs); s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output); qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s); s->qdev = dev; register_savevm(dev, "virtio-blk", virtio_blk_id++, 2, virtio_blk_save, virtio_blk_load, s); bdrv_set_dev_ops(s->bs, &virtio_block_ops, s); bdrv_set_buffer_alignment(s->bs, conf->logical_block_size); bdrv_iostatus_enable(s->bs); add_boot_device_path(conf->bootindex, dev, "/disk@0,0"); return &s->vdev; }

[[[[Adv]]]]: VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf, char **serial) { VirtIOBlock *s; int cylinders, heads, secs; static int virtio_blk_id; DriveInfo *[[knock]]; if (!conf->bs) { error_report("virtio-blk-pci: drive property not set"); return NULL; } if (!bdrv_is_inserted(conf->bs)) { error_report("Device needs media, but drive is empty"); return NULL; } if (!*serial) { [[knock]] = drive_get_by_blockdev(conf->bs); if (*[[knock]]->serial) { *serial = strdup([[knock]]->serial); } } s = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK, sizeof(struct virtio_blk_config), sizeof(VirtIOBlock)); s->vdev.get_config = virtio_blk_update_config; s->vdev.get_features = virtio_blk_get_features; s->vdev.reset = virtio_blk_reset; s->bs = conf->bs; s->conf = conf; s->serial = *serial; s->rq = NULL; s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1; bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs); s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output); qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s); s->qdev = dev; register_savevm(dev, "virtio-blk", virtio_blk_id++, 2, virtio_blk_save, virtio_blk_load, s); bdrv_set_dev_ops(s->bs, &virtio_block_ops, s); bdrv_set_buffer_alignment(s->bs, conf->logical_block_size); bdrv_iostatus_enable(s->bs); add_boot_device_path(conf->bootindex, dev, "/disk@0,0"); return &s->vdev; }
--------------------------------------------- Result 23 ---------------------------------------------
[[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qpa_audio_fini (void *opaque) { (void) opaque; }
--------------------------------------------- Result 24 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 12 / 0 / 12 / 24:   1%|          | 24/2690 [00:11<21:34,  2.06it/s][Succeeded / Failed / Skipped / Total] 13 / 0 / 12 / 25:   1%|          | 25/2690 [00:14<25:13,  1.76it/s][[0 (41%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target, const char *replaces, int64_t speed, uint32_t granularity, int64_t buf_size, BlockdevOnError on_source_error, BlockdevOnError on_target_error, bool unmap, BlockCompletionFunc *cb, void *opaque, Error **errp, const BlockJobDriver *driver, bool is_none_mode, BlockDriverState *base) { MirrorBlockJob *s; if (granularity == 0) { granularity = bdrv_get_default_bitmap_granularity(target); } assert ((granularity & (granularity - 1)) == 0); if ((on_source_error == BLOCKDEV_ON_ERROR_STOP || on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) && (!bs->blk || !blk_iostatus_is_enabled(bs->blk))) { error_setg(errp, QERR_INVALID_PARAMETER, "on-source-error"); return; } if (buf_size < 0) { error_setg(errp, "Invalid parameter 'buf-size'"); return; } if (buf_size == 0) { buf_size = DEFAULT_MIRROR_BUF_SIZE; } if (replaces) { replaced_bs = bdrv_lookup_bs(replaces, replaces, errp); if (replaced_bs == NULL) { return; } } else { replaced_bs = bs; } if (replaced_bs->blk && target->blk) { error_setg(errp, "Can't create node with two BlockBackends"); return; } s = block_job_create(driver, bs, speed, cb, opaque, errp); if (!s) { return; } s->replaces = g_strdup(replaces); s->on_source_error = on_source_error; s->on_target_error = on_target_error; s->target = target; s->is_none_mode = is_none_mode; s->base = base; s->granularity = granularity; s->buf_size = ROUND_UP(buf_size, granularity); s->unmap = unmap; s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp); if (!s->dirty_bitmap) { g_free(s->replaces); block_job_unref(&s->common); return; } bdrv_op_block_all(s->target, s->common.blocker); bdrv_set_enable_write_cache(s->target, "True" == "True"); if (s->target->blk) { blk_set_on_error(s->target->blk, on_target_error, on_target_error); blk_iostatus_enable(s->target->blk); } s->common.co = qemu_coroutine_create(mirror_run); trace_mirror_start(bs, s, s->common.co, opaque); qemu_coroutine_enter(s->common.co, s); }
--------------------------------------------- Result 25 ---------------------------------------------
[[0 (75%)]] --> [[0 (46%)]] --> Socre: 0.5438076555728912

[[[[Adv]]]]: static void usbredir_bulk_packet(void *priv, uint32_t id, struct usb_redir_bulk_packet_header *bulk_packet, uint8_t *data, int data_len) { USBRedirDevice *dev = priv; uint8_t ep = bulk_packet->endpoint; int len = bulk_packet->length; AsyncURB *[[aurb]]; DPRINTF("bulk-in status %d ep %02X len %d id %u\n", bulk_packet->status, ep, len, id); [[aurb]] = async_find(dev, id); if (![[aurb]]) { free(data); return; } if ([[aurb]]->bulk_packet.endpoint != bulk_packet->endpoint || [[aurb]]->bulk_packet.stream_id != bulk_packet->stream_id) { ERROR("return bulk packet mismatch, please report this!\n"); len = USB_RET_NAK; } if ([[aurb]]->packet) { len = usbredir_handle_status(dev, bulk_packet->status, len); if (len > 0) { usbredir_log_data(dev, "bulk data in:", data, data_len); if (data_len <= [[aurb]]->packet->len) { memcpy([[aurb]]->packet->data, data, data_len); } else { ERROR("bulk buffer too small (%d > %d)\n", data_len, [[aurb]]->packet->len); len = USB_RET_STALL; } } [[aurb]]->packet->len = len; usb_packet_complete(&dev->dev, [[aurb]]->packet); } async_free(dev, [[aurb]]); free(data); }

[[[[Adv]]]]: static void usbredir_bulk_packet(void *priv, uint32_t id, struct usb_redir_bulk_packet_header *bulk_packet, uint8_t *data, int data_len) { USBRedirDevice *dev = priv; uint8_t ep = bulk_packet->endpoint; int len = bulk_packet->length; AsyncURB *[[pistols]]; DPRINTF("bulk-in status %d ep %02X len %d id %u\n", bulk_packet->status, ep, len, id); [[pistols]] = async_find(dev, id); if (![[pistols]]) { free(data); return; } if ([[pistols]]->bulk_packet.endpoint != bulk_packet->endpoint || [[pistols]]->bulk_packet.stream_id != bulk_packet->stream_id) { ERROR("return bulk packet mismatch, please report this!\n"); len = USB_RET_NAK; } if ([[pistols]]->packet) { len = usbredir_handle_status(dev, bulk_packet->status, len); if (len > 0) { usbredir_log_data(dev, "bulk data in:", data, data_len); if (data_len <= [[pistols]]->packet->len) { memcpy([[pistols]]->packet->data, data, data_len); } else { ERROR("bulk buffer too small (%d > %d)\n", data_len, [[pistols]]->packet->len); len = USB_RET_STALL; } } [[pistols]]->packet->len = len; usb_packet_complete(&dev->dev, [[pistols]]->packet); } async_free(dev, [[pistols]]); free(data); }
--------------------------------------------- Result 26 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 13 / 0 / 13 / 26:   1%|          | 26/2690 [00:14<25:09,  1.77it/s][Succeeded / Failed / Skipped / Total] 13 / 0 / 13 / 26:   1%|          | 27/2690 [00:24<40:32,  1.09it/s][Succeeded / Failed / Skipped / Total] 14 / 0 / 13 / 27:   1%|          | 27/2690 [00:24<40:32,  1.09it/s][Succeeded / Failed / Skipped / Total] 14 / 0 / 13 / 27:   1%|          | 28/2690 [00:31<49:38,  1.12s/it][Succeeded / Failed / Skipped / Total] 15 / 0 / 13 / 28:   1%|          | 28/2690 [00:31<49:38,  1.12s/it][Succeeded / Failed / Skipped / Total] 15 / 0 / 13 / 28:   1%|          | 29/2690 [00:42<1:05:12,  1.47s/it][[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int net_init_tap(const Netdev *netdev, const char *name, NetClientState *peer, Error **errp) { const NetdevTapOptions *tap; int fd, vnet_hdr = 0, i = 0, queues; const char *script = NULL; const char *downscript = NULL; Error *err = NULL; const char *vhostfdname; char ifname[128]; assert(netdev->type == NET_CLIENT_DRIVER_TAP); tap = &netdev->u.tap; queues = tap->has_queues ? tap->queues : 1; vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL; if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) { error_setg(errp, "Multiqueue tap cannot be used with QEMU vlans"); return -1; } if (tap->has_fd) { if (tap->has_ifname || tap->has_script || tap->has_downscript || tap->has_vnet_hdr || tap->has_helper || tap->has_queues || tap->has_fds || tap->has_vhostfds) { error_setg(errp, "ifname=, script=, downscript=, vnet_hdr=, " "helper=, queues=, fds=, and vhostfds= " "are invalid with fd="); return -1; } fd = monitor_fd_param(cur_mon, tap->fd, &err); if (fd == -1) { error_propagate(errp, err); return -1; } fcntl(fd, F_SETFL, O_NONBLOCK); vnet_hdr = tap_probe_vnet_hdr(fd); net_init_tap_one(tap, peer, "tap", name, NULL, script, downscript, vhostfdname, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); return -1; } } else if (tap->has_fds) { char **fds = g_new0(char *, MAX_TAP_QUEUES); char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES); int nfds, nvhosts; if (tap->has_ifname || tap->has_script || tap->has_downscript || tap->has_vnet_hdr || tap->has_helper || tap->has_queues || tap->has_vhostfd) { error_setg(errp, "ifname=, script=, downscript=, vnet_hdr=, " "helper=, queues=, and vhostfd= " "are invalid with fds="); return -1; } nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES); if (tap->has_vhostfds) { nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES); if (nfds != nvhosts) { error_setg(errp, "The number of fds passed does not match " "the number of vhostfds passed"); goto free_fail; } } for (i = 0; i < nfds; i++) { fd = monitor_fd_param(cur_mon, fds[i], &err); if (fd == -1) { error_propagate(errp, err); goto free_fail; } fcntl(fd, F_SETFL, O_NONBLOCK); if (i == 0) { vnet_hdr = tap_probe_vnet_hdr(fd); } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) { error_setg(errp, "vnet_hdr not consistent across given tap fds"); goto free_fail; } net_init_tap_one(tap, peer, "tap", name, ifname, script, downscript, tap->has_vhostfds ? vhost_fds[i] : NULL, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); goto free_fail; } } g_free(fds); g_free(vhost_fds); return 0; free_fail: for (i = 0; i < nfds; i++) { g_free(fds[i]); g_free(vhost_fds[i]); } g_free(fds); g_free(vhost_fds); return -1; } else if (tap->has_helper) { if (tap->has_ifname || tap->has_script || tap->has_downscript || tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) { error_setg(errp, "ifname=, script=, downscript=, vnet_hdr=, " "queues=, and vhostfds= are invalid with helper="); return -1; } fd = net_bridge_run_helper(tap->helper, tap->has_br ? tap->br : DEFAULT_BRIDGE_INTERFACE, errp); if (fd == -1) { return -1; } fcntl(fd, F_SETFL, O_NONBLOCK); vnet_hdr = tap_probe_vnet_hdr(fd); net_init_tap_one(tap, peer, "bridge", name, ifname, script, downscript, vhostfdname, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); close(fd); return -1; } } else { if (tap->has_vhostfds) { error_setg(errp, "vhostfds= is invalid if fds= wasn't specified"); return -1; } script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT; downscript = tap->has_downscript ? tap->downscript : DEFAULT_NETWORK_DOWN_SCRIPT; if (tap->has_ifname) { pstrcpy(ifname, sizeof ifname, tap->ifname); } else { ifname[0] = '\0'; } for (i = 0; i < queues; i++) { fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? "no" : script, ifname, sizeof ifname, queues > 1, errp); if (fd == -1) { return -1; } if (queues > 1 && i == 0 && !tap->has_ifname) { if (tap_fd_get_ifname(fd, ifname)) { error_setg(errp, "Fail to get ifname"); close(fd); return -1; } } net_init_tap_one(tap, peer, "tap", name, ifname, i >= 1 ? "no" : script, i >= 1 ? "no" : downscript, vhostfdname, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); close(fd); return -1; } } } return 0; }
--------------------------------------------- Result 27 ---------------------------------------------
[[0 (13%)]] --> [[0 (69%)]] --> Socre: 0.6948099732398987

[[[[Adv]]]]: static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *[[buf]]) { uint32_t rgb = 0; if (bpp == 32) { rgb |= (([[buf]][0] & ~1) | !(([[buf]][4] >> 3) & 1)) << 24; rgb |= (([[buf]][1] & ~1) | !(([[buf]][4] >> 2) & 1)) << 16; rgb |= (([[buf]][2] & ~1) | !(([[buf]][4] >> 1) & 1)) << 8; rgb |= (([[buf]][3] & ~1) | !(([[buf]][4] >> 0) & 1)) << 0; } if (bpp == 16) { rgb |= (([[buf]][0] & ~1) | !(([[buf]][2] >> 1) & 1)) << 8; rgb |= (([[buf]][1] & ~1) | !(([[buf]][2] >> 0) & 1)) << 0; } return rgb; }

[[[[Adv]]]]: static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *[[receptor]]) { uint32_t rgb = 0; if (bpp == 32) { rgb |= (([[receptor]][0] & ~1) | !(([[receptor]][4] >> 3) & 1)) << 24; rgb |= (([[receptor]][1] & ~1) | !(([[receptor]][4] >> 2) & 1)) << 16; rgb |= (([[receptor]][2] & ~1) | !(([[receptor]][4] >> 1) & 1)) << 8; rgb |= (([[receptor]][3] & ~1) | !(([[receptor]][4] >> 0) & 1)) << 0; } if (bpp == 16) { rgb |= (([[receptor]][0] & ~1) | !(([[receptor]][2] >> 1) & 1)) << 8; rgb |= (([[receptor]][1] & ~1) | !(([[receptor]][2] >> 0) & 1)) << 0; } return rgb; }
--------------------------------------------- Result 28 ---------------------------------------------
[[0 (56%)]] --> [[0 (49%)]] --> Socre: 0.5103503167629242

[[[[Adv]]]]: int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *[[got_picture_ptr]], AVPacket *avpkt) { int [[ret]]; *[[got_picture_ptr]] = 0; if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx)) return -1; avctx->pkt = avpkt; apply_param_change(avctx, avpkt); if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) { if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME) [[ret]] = ff_thread_decode_frame(avctx, picture, [[got_picture_ptr]], avpkt); else { [[ret]] = avctx->codec->decode(avctx, picture, [[got_picture_ptr]], avpkt); picture->pkt_dts = avpkt->dts; picture->sample_aspect_ratio = avctx->sample_aspect_ratio; picture->width = avctx->width; picture->height = avctx->height; picture->format = avctx->pix_fmt; } emms_c(); if (*[[got_picture_ptr]]) avctx->frame_number++; } else [[ret]] = 0; picture->extended_data = picture->data; return [[ret]]; }

[[[[Adv]]]]: int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *[[cooper]], AVPacket *avpkt) { int [[withdrawing]]; *[[cooper]] = 0; if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx)) return -1; avctx->pkt = avpkt; apply_param_change(avctx, avpkt); if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) { if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME) [[withdrawing]] = ff_thread_decode_frame(avctx, picture, [[cooper]], avpkt); else { [[withdrawing]] = avctx->codec->decode(avctx, picture, [[cooper]], avpkt); picture->pkt_dts = avpkt->dts; picture->sample_aspect_ratio = avctx->sample_aspect_ratio; picture->width = avctx->width; picture->height = avctx->height; picture->format = avctx->pix_fmt; } emms_c(); if (*[[cooper]]) avctx->frame_number++; } else [[withdrawing]] = 0; picture->extended_data = picture->data; return [[withdrawing]]; }
--------------------------------------------- Result 29 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 0 / 13 / 29:   1%|          | 29/2690 [00:42<1:05:12,  1.47s/it][Succeeded / Failed / Skipped / Total] 16 / 0 / 13 / 29:   1%|          | 30/2690 [00:43<1:03:48,  1.44s/it][Succeeded / Failed / Skipped / Total] 16 / 0 / 14 / 30:   1%|          | 30/2690 [00:43<1:03:48,  1.44s/it][Succeeded / Failed / Skipped / Total] 16 / 0 / 14 / 30:   1%|          | 31/2690 [00:56<1:20:03,  1.81s/it][Succeeded / Failed / Skipped / Total] 17 / 0 / 14 / 31:   1%|          | 31/2690 [00:56<1:20:03,  1.81s/it][Succeeded / Failed / Skipped / Total] 17 / 0 / 14 / 31:   1%|          | 32/2690 [01:29<2:04:00,  2.80s/it][Succeeded / Failed / Skipped / Total] 18 / 0 / 14 / 32:   1%|          | 32/2690 [01:29<2:04:00,  2.80s/it][Succeeded / Failed / Skipped / Total] 18 / 0 / 14 / 32:   1%|          | 33/2690 [02:23<3:12:37,  4.35s/it][Succeeded / Failed / Skipped / Total] 19 / 0 / 14 / 33:   1%|          | 33/2690 [02:23<3:12:37,  4.35s/it][Succeeded / Failed / Skipped / Total] 19 / 0 / 14 / 33:   1%|         | 34/2690 [02:30<3:15:57,  4.43s/it][Succeeded / Failed / Skipped / Total] 20 / 0 / 14 / 34:   1%|         | 34/2690 [02:30<3:15:57,  4.43s/it][Succeeded / Failed / Skipped / Total] 20 / 0 / 14 / 34:   1%|         | 35/2690 [02:31<3:10:55,  4.31s/it][Succeeded / Failed / Skipped / Total] 20 / 0 / 15 / 35:   1%|         | 35/2690 [02:31<3:10:55,  4.31s/it][Succeeded / Failed / Skipped / Total] 20 / 0 / 15 / 35:   1%|         | 36/2690 [02:31<3:06:09,  4.21s/it][[0 (79%)]] --> [[0 (40%)]] --> Socre: 0.6018357276916504

[[[[Adv]]]]: static int omap_gpio_init(SysBusDevice *[[sbd]]) { DeviceState *[[dev]] = DEVICE([[sbd]]); struct omap_gpif_s *s = OMAP1_GPIO([[dev]]); if (!s->clk) { hw_error("omap-gpio: clk not connected\n"); } qdev_init_gpio_in([[dev]], omap_gpio_set, 16); qdev_init_gpio_out([[dev]], s->omap1.handler, 16); sysbus_init_irq([[sbd]], &s->omap1.irq); memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1, "omap.gpio", 0x1000); sysbus_init_mmio([[sbd]], &s->iomem); return 0; }

[[[[Adv]]]]: static int omap_gpio_init(SysBusDevice *[[bastard]]) { DeviceState *[[vivek]] = DEVICE([[bastard]]); struct omap_gpif_s *s = OMAP1_GPIO([[vivek]]); if (!s->clk) { hw_error("omap-gpio: clk not connected\n"); } qdev_init_gpio_in([[vivek]], omap_gpio_set, 16); qdev_init_gpio_out([[vivek]], s->omap1.handler, 16); sysbus_init_irq([[bastard]], &s->omap1.irq); memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1, "omap.gpio", 0x1000); sysbus_init_mmio([[bastard]], &s->iomem); return 0; }
--------------------------------------------- Result 30 ---------------------------------------------
[[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave) { s->codec = slave; slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0]; slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0]; }
--------------------------------------------- Result 31 ---------------------------------------------
[[0 (88%)]] --> [[0 (48%)]] --> Socre: 0.5235489308834076

[[[[Adv]]]]: static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom [[atom]]) { AVStream *st; if (c->fc->nb_streams < 1) return 0; if ([[atom]].size <= 40) return 0; st = c->fc->streams[c->fc->nb_streams-1]; if ((uint64_t)[[atom]].size > (1<<30)) return AVERROR_INVALIDDATA; av_free(st->codec->extradata); st->codec->extradata = av_mallocz([[atom]].size - 40 + FF_INPUT_BUFFER_PADDING_SIZE); if (!st->codec->extradata) return AVERROR(ENOMEM); st->codec->extradata_size = [[atom]].size - 40; avio_skip(pb, 40); avio_read(pb, st->codec->extradata, [[atom]].size - 40); return 0; }

[[[[Adv]]]]: static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom [[ionization]]) { AVStream *st; if (c->fc->nb_streams < 1) return 0; if ([[ionization]].size <= 40) return 0; st = c->fc->streams[c->fc->nb_streams-1]; if ((uint64_t)[[ionization]].size > (1<<30)) return AVERROR_INVALIDDATA; av_free(st->codec->extradata); st->codec->extradata = av_mallocz([[ionization]].size - 40 + FF_INPUT_BUFFER_PADDING_SIZE); if (!st->codec->extradata) return AVERROR(ENOMEM); st->codec->extradata_size = [[ionization]].size - 40; avio_skip(pb, 40); avio_read(pb, st->codec->extradata, [[ionization]].size - 40); return 0; }
--------------------------------------------- Result 32 ---------------------------------------------
[[0 (54%)]] --> [[0 (49%)]] --> Socre: 0.506702721118927

[[[[Adv]]]]: void stream_start(const char *job_id, BlockDriverState *bs, BlockDriverState *base, const char *backing_file_str, int64_t speed, BlockdevOnError on_error, BlockCompletionFunc *cb, void *opaque, Error **errp) { StreamBlockJob *[[s]]; [[s]] = block_job_create(job_id, &stream_job_driver, bs, speed, cb, opaque, errp); if (![[s]]) { return; } [[s]]->base = base; [[s]]->backing_file_str = g_strdup(backing_file_str); [[s]]->on_error = on_error; [[s]]->common.co = qemu_coroutine_create(stream_run); trace_stream_start(bs, base, [[s]], [[s]]->common.co, opaque); qemu_coroutine_enter([[s]]->common.co, [[s]]); }

[[[[Adv]]]]: void stream_start(const char *job_id, BlockDriverState *bs, BlockDriverState *base, const char *backing_file_str, int64_t speed, BlockdevOnError on_error, BlockCompletionFunc *cb, void *opaque, Error **errp) { StreamBlockJob *[[dans]]; [[dans]] = block_job_create(job_id, &stream_job_driver, bs, speed, cb, opaque, errp); if (![[dans]]) { return; } [[dans]]->base = base; [[dans]]->backing_file_str = g_strdup(backing_file_str); [[dans]]->on_error = on_error; [[dans]]->common.co = qemu_coroutine_create(stream_run); trace_stream_start(bs, base, [[dans]], [[dans]]->common.co, opaque); qemu_coroutine_enter([[dans]]->common.co, [[dans]]); }
--------------------------------------------- Result 33 ---------------------------------------------
[[0 (3%)]] --> [[0 (93%)]] --> Socre: 0.9283651113510132

[[[[Adv]]]]: void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter [[func]]) { lexer->emit = [[func]]; lexer->state = IN_START; lexer->token = qstring_new(); lexer->x = lexer->y = 0; }

[[[[Adv]]]]: void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter [[rve]]) { lexer->emit = [[rve]]; lexer->state = IN_START; lexer->token = qstring_new(); lexer->x = lexer->y = 0; }
--------------------------------------------- Result 34 ---------------------------------------------
[[0 (55%)]] --> [[0 (47%)]] --> Socre: 0.5258113443851471

[[[[Adv]]]]: static int crypto_open(URLContext *h, const char *uri, int [[flags]]) { const char *[[nested_url]]; int ret; CryptoContext *c = h->priv_data; if (!av_strstart(uri, "crypto+", &[[nested_url]]) && !av_strstart(uri, "crypto:", &[[nested_url]])) { av_log(h, AV_LOG_ERROR, "Unsupported url %s\n", uri); ret = AVERROR(EINVAL); goto err; } if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) { av_log(h, AV_LOG_ERROR, "Key or IV not set\n"); ret = AVERROR(EINVAL); goto err; } if ([[flags]] & AVIO_FLAG_WRITE) { av_log(h, AV_LOG_ERROR, "Only decryption is supported currently\n"); ret = AVERROR(ENOSYS); goto err; } if ((ret = ffurl_open(&c->hd, [[nested_url]], AVIO_FLAG_READ)) < 0) { av_log(h, AV_LOG_ERROR, "Unable to open input\n"); goto err; } c->aes = av_mallocz(av_aes_size); if (!c->aes) { ret = AVERROR(ENOMEM); goto err; } av_aes_init(c->aes, c->key, 128, 1); h->is_streamed = 1; return 0; err: av_free(c->key); av_free(c->iv); return ret; }

[[[[Adv]]]]: static int crypto_open(URLContext *h, const char *uri, int [[markings]]) { const char *[[ruinous]]; int ret; CryptoContext *c = h->priv_data; if (!av_strstart(uri, "crypto+", &[[ruinous]]) && !av_strstart(uri, "crypto:", &[[ruinous]])) { av_log(h, AV_LOG_ERROR, "Unsupported url %s\n", uri); ret = AVERROR(EINVAL); goto err; } if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) { av_log(h, AV_LOG_ERROR, "Key or IV not set\n"); ret = AVERROR(EINVAL); goto err; } if ([[markings]] & AVIO_FLAG_WRITE) { av_log(h, AV_LOG_ERROR, "Only decryption is supported currently\n"); ret = AVERROR(ENOSYS); goto err; } if ((ret = ffurl_open(&c->hd, [[ruinous]], AVIO_FLAG_READ)) < 0) { av_log(h, AV_LOG_ERROR, "Unable to open input\n"); goto err; } c->aes = av_mallocz(av_aes_size); if (!c->aes) { ret = AVERROR(ENOMEM); goto err; } av_aes_init(c->aes, c->key, 128, 1); h->is_streamed = 1; return 0; err: av_free(c->key); av_free(c->iv); return ret; }
--------------------------------------------- Result 35 ---------------------------------------------
[[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_alloc_entries(AVCodecContext *avctx, int count) { int i; if (avctx->active_thread_type & FF_THREAD_SLICE) { SliceThreadContext *p = avctx->internal->thread_ctx; p->thread_count = avctx->thread_count; p->entries = av_mallocz_array(count, sizeof(int)); if (!p->entries) { return AVERROR(ENOMEM); } p->entries_count = count; p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t)); p->progress_cond = av_malloc_array(p->thread_count, sizeof(pthread_cond_t)); for (i = 0; i < p->thread_count; i++) { pthread_mutex_init(&p->progress_mutex[i], NULL); pthread_cond_init(&p->progress_cond[i], NULL); } } return 0; }
--------------------------------------------- Result 36 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 20 / 0 / 16 / 36:   1%|         | 36/2690 [02:31<3:06:09,  4.21s/it][Succeeded / Failed / Skipped / Total] 20 / 0 / 16 / 36:   1%|         | 37/2690 [02:40<3:11:59,  4.34s/it][Succeeded / Failed / Skipped / Total] 21 / 0 / 16 / 37:   1%|         | 37/2690 [02:40<3:11:59,  4.34s/it][Succeeded / Failed / Skipped / Total] 21 / 0 / 16 / 37:   1%|         | 38/2690 [02:42<3:08:41,  4.27s/it][[0 (14%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int floppy_probe_device(const char *filename) { int fd, ret; int prio = 0; struct floppy_struct fdparam; struct stat st; if (strstart(filename, "/dev/fd", NULL) && !strstart(filename, "/dev/fdset/", NULL)) { prio = 50; } fd = qemu_open(filename, O_RDONLY | O_NONBLOCK); if (fd < 0) { goto out; } ret = fstat(fd, &st); if (ret == -1 || !S_ISBLK(st.st_mode)) { goto outc; } ret = ioctl(fd, FDGETPRM, &fdparam); if (ret >= 0) prio = 100; outc: qemu_close(fd); out: return prio; }
--------------------------------------------- Result 37 ---------------------------------------------
[[0 (9%)]] --> [[0 (54%)]] --> Socre: 0.5413727760314941

[[[[Adv]]]]: BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd, int64_t sector_num, QEMUIOVector *qiov, int nb_sectors, BlockDriverCompletionFunc *cb, void *[[opaque]], int type) { struct qemu_paiocb *[[acb]]; [[acb]] = qemu_aio_get(&raw_aio_pool, bs, cb, [[opaque]]); if (![[acb]]) return NULL; [[acb]]->aio_type = type; [[acb]]->aio_fildes = fd; [[acb]]->ev_signo = SIGUSR2; [[acb]]->async_context_id = get_async_context_id(); if (qiov) { [[acb]]->aio_iov = qiov->iov; [[acb]]->aio_niov = qiov->niov; } [[acb]]->aio_nbytes = nb_sectors * 512; [[acb]]->aio_offset = sector_num * 512; [[acb]]->next = posix_aio_state->first_aio; posix_aio_state->first_aio = [[acb]]; trace_paio_submit([[acb]], [[opaque]], sector_num, nb_sectors, type); qemu_paio_submit([[acb]]); return &[[acb]]->common; }

[[[[Adv]]]]: BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd, int64_t sector_num, QEMUIOVector *qiov, int nb_sectors, BlockDriverCompletionFunc *cb, void *[[perplexing]], int type) { struct qemu_paiocb *[[intervene]]; [[intervene]] = qemu_aio_get(&raw_aio_pool, bs, cb, [[perplexing]]); if (![[intervene]]) return NULL; [[intervene]]->aio_type = type; [[intervene]]->aio_fildes = fd; [[intervene]]->ev_signo = SIGUSR2; [[intervene]]->async_context_id = get_async_context_id(); if (qiov) { [[intervene]]->aio_iov = qiov->iov; [[intervene]]->aio_niov = qiov->niov; } [[intervene]]->aio_nbytes = nb_sectors * 512; [[intervene]]->aio_offset = sector_num * 512; [[intervene]]->next = posix_aio_state->first_aio; posix_aio_state->first_aio = [[intervene]]; trace_paio_submit([[intervene]], [[perplexing]], sector_num, nb_sectors, type); qemu_paio_submit([[intervene]]); return &[[intervene]]->common; }
--------------------------------------------- Result 38 ---------------------------------------------
[[0 (20%)]] --> [[0 (52%)]] --> Socre: 0.5212401747703552

[[[[Adv]]]]: static void sun4uv_init(ram_addr_t RAM_size, const char *boot_devices, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model, const struct hwdef *hwdef) { CPUState *env; char *filename; m48t59_t *nvram; int ret, linux_boot; unsigned int i; ram_addr_t ram_offset, prom_offset; long initrd_size, kernel_size; PCIBus *pci_bus, *pci_bus2, *pci_bus3; QEMUBH *bh; qemu_irq *irq; int [[drive_index]]; BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; BlockDriverState *fd[MAX_FD]; void *fw_cfg; ResetData *reset_info; linux_boot = (kernel_filename != NULL); if (!cpu_model) cpu_model = hwdef->default_cpu_model; env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to find Sparc CPU definition\n"); exit(1); } bh = qemu_bh_new(tick_irq, env); env->tick = ptimer_init(bh); ptimer_set_period(env->tick, 1ULL); bh = qemu_bh_new(stick_irq, env); env->stick = ptimer_init(bh); ptimer_set_period(env->stick, 1ULL); bh = qemu_bh_new(hstick_irq, env); env->hstick = ptimer_init(bh); ptimer_set_period(env->hstick, 1ULL); reset_info = qemu_mallocz(sizeof(ResetData)); reset_info->env = env; reset_info->reset_addr = hwdef->prom_addr + 0x40ULL; qemu_register_reset(main_cpu_reset, reset_info); main_cpu_reset(reset_info); env->pc = hwdef->prom_addr + 0x20ULL; env->npc = env->pc + 4; ram_offset = qemu_ram_alloc(RAM_size); cpu_register_physical_memory(0, RAM_size, ram_offset); prom_offset = qemu_ram_alloc(PROM_SIZE_MAX); cpu_register_physical_memory(hwdef->prom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK, prom_offset | IO_MEM_ROM); if (bios_name == NULL) bios_name = PROM_FILENAME; filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (filename) { ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR, NULL, NULL, NULL); if (ret < 0) { ret = load_image_targphys(filename, hwdef->prom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK); } qemu_free(filename); } else { ret = -1; } if (ret < 0) { fprintf(stderr, "qemu: could not load prom '%s'\n", bios_name); exit(1); } kernel_size = 0; initrd_size = 0; if (linux_boot) { kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL); if (kernel_size < 0) kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size < 0) kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } if (initrd_filename) { initrd_size = load_image_targphys(initrd_filename, INITRD_LOAD_ADDR, ram_size - INITRD_LOAD_ADDR); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } } if (initrd_size > 0) { for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) { if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR); stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size); break; } } } } pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2, &pci_bus3); isa_mem_base = VGA_BASE; pci_vga_init(pci_bus, 0, 0); pci_ebus_init(pci_bus, -1); i = 0; if (hwdef->console_serial_base) { serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200, serial_hds[i], 1); i++; } for(; i < MAX_SERIAL_PORTS; i++) { if (serial_hds[i]) { serial_init(serial_io[i], NULL , 115200, serial_hds[i]); } } for(i = 0; i < MAX_PARALLEL_PORTS; i++) { if (parallel_hds[i]) { parallel_init(parallel_io[i], NULL , parallel_hds[i]); } } for(i = 0; i < nb_nics; i++) pci_nic_init(&nd_table[i], "ne2k_pci", NULL); irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS); if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) { fprintf(stderr, "qemu: too many IDE bus\n"); exit(1); } for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) { [[drive_index]] = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS); if ([[drive_index]] != -1) hd[i] = drives_table[[[drive_index]]].bdrv; else hd[i] = NULL; } pci_cmd646_ide_init(pci_bus, hd, 1); i8042_init(NULL , NULL , 0x60); for(i = 0; i < MAX_FD; i++) { [[drive_index]] = drive_get_index(IF_FLOPPY, 0, i); if ([[drive_index]] != -1) fd[i] = drives_table[[[drive_index]]].bdrv; else fd[i] = NULL; } floppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd); nvram = m48t59_init(NULL , 0, 0x0074, NVRAM_SIZE, 59); sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, "Sun4u", RAM_size, boot_devices, KERNEL_LOAD_ADDR, kernel_size, kernel_cmdline, INITRD_LOAD_ADDR, initrd_size, 0, graphic_width, graphic_height, graphic_depth, (uint8_t *)&nd_table[0].macaddr); fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0); fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1); fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size); fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size); if (kernel_cmdline) { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR); pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline); } else { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0); } fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size); fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]); qemu_register_boot_set(fw_cfg_boot_set, fw_cfg); }

[[[[Adv]]]]: static void sun4uv_init(ram_addr_t RAM_size, const char *boot_devices, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model, const struct hwdef *hwdef) { CPUState *env; char *filename; m48t59_t *nvram; int ret, linux_boot; unsigned int i; ram_addr_t ram_offset, prom_offset; long initrd_size, kernel_size; PCIBus *pci_bus, *pci_bus2, *pci_bus3; QEMUBH *bh; qemu_irq *irq; int [[cult]]; BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; BlockDriverState *fd[MAX_FD]; void *fw_cfg; ResetData *reset_info; linux_boot = (kernel_filename != NULL); if (!cpu_model) cpu_model = hwdef->default_cpu_model; env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to find Sparc CPU definition\n"); exit(1); } bh = qemu_bh_new(tick_irq, env); env->tick = ptimer_init(bh); ptimer_set_period(env->tick, 1ULL); bh = qemu_bh_new(stick_irq, env); env->stick = ptimer_init(bh); ptimer_set_period(env->stick, 1ULL); bh = qemu_bh_new(hstick_irq, env); env->hstick = ptimer_init(bh); ptimer_set_period(env->hstick, 1ULL); reset_info = qemu_mallocz(sizeof(ResetData)); reset_info->env = env; reset_info->reset_addr = hwdef->prom_addr + 0x40ULL; qemu_register_reset(main_cpu_reset, reset_info); main_cpu_reset(reset_info); env->pc = hwdef->prom_addr + 0x20ULL; env->npc = env->pc + 4; ram_offset = qemu_ram_alloc(RAM_size); cpu_register_physical_memory(0, RAM_size, ram_offset); prom_offset = qemu_ram_alloc(PROM_SIZE_MAX); cpu_register_physical_memory(hwdef->prom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK, prom_offset | IO_MEM_ROM); if (bios_name == NULL) bios_name = PROM_FILENAME; filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (filename) { ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR, NULL, NULL, NULL); if (ret < 0) { ret = load_image_targphys(filename, hwdef->prom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK); } qemu_free(filename); } else { ret = -1; } if (ret < 0) { fprintf(stderr, "qemu: could not load prom '%s'\n", bios_name); exit(1); } kernel_size = 0; initrd_size = 0; if (linux_boot) { kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL); if (kernel_size < 0) kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size < 0) kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } if (initrd_filename) { initrd_size = load_image_targphys(initrd_filename, INITRD_LOAD_ADDR, ram_size - INITRD_LOAD_ADDR); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } } if (initrd_size > 0) { for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) { if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR); stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size); break; } } } } pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2, &pci_bus3); isa_mem_base = VGA_BASE; pci_vga_init(pci_bus, 0, 0); pci_ebus_init(pci_bus, -1); i = 0; if (hwdef->console_serial_base) { serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200, serial_hds[i], 1); i++; } for(; i < MAX_SERIAL_PORTS; i++) { if (serial_hds[i]) { serial_init(serial_io[i], NULL , 115200, serial_hds[i]); } } for(i = 0; i < MAX_PARALLEL_PORTS; i++) { if (parallel_hds[i]) { parallel_init(parallel_io[i], NULL , parallel_hds[i]); } } for(i = 0; i < nb_nics; i++) pci_nic_init(&nd_table[i], "ne2k_pci", NULL); irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS); if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) { fprintf(stderr, "qemu: too many IDE bus\n"); exit(1); } for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) { [[cult]] = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS); if ([[cult]] != -1) hd[i] = drives_table[[[cult]]].bdrv; else hd[i] = NULL; } pci_cmd646_ide_init(pci_bus, hd, 1); i8042_init(NULL , NULL , 0x60); for(i = 0; i < MAX_FD; i++) { [[cult]] = drive_get_index(IF_FLOPPY, 0, i); if ([[cult]] != -1) fd[i] = drives_table[[[cult]]].bdrv; else fd[i] = NULL; } floppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd); nvram = m48t59_init(NULL , 0, 0x0074, NVRAM_SIZE, 59); sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, "Sun4u", RAM_size, boot_devices, KERNEL_LOAD_ADDR, kernel_size, kernel_cmdline, INITRD_LOAD_ADDR, initrd_size, 0, graphic_width, graphic_height, graphic_depth, (uint8_t *)&nd_table[0].macaddr); fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0); fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1); fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size); fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size); if (kernel_cmdline) { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR); pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline); } else { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0); } fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size); fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]); qemu_register_boot_set(fw_cfg_boot_set, fw_cfg); }[Succeeded / Failed / Skipped / Total] 22 / 0 / 16 / 38:   1%|         | 38/2690 [02:42<3:08:41,  4.27s/it][Succeeded / Failed / Skipped / Total] 22 / 0 / 16 / 38:   1%|         | 39/2690 [02:43<3:04:53,  4.18s/it][Succeeded / Failed / Skipped / Total] 23 / 0 / 16 / 39:   1%|         | 39/2690 [02:43<3:04:53,  4.18s/it][Succeeded / Failed / Skipped / Total] 23 / 0 / 16 / 39:   1%|         | 40/2690 [02:43<3:00:45,  4.09s/it][Succeeded / Failed / Skipped / Total] 23 / 0 / 17 / 40:   1%|         | 40/2690 [02:43<3:00:45,  4.09s/it][Succeeded / Failed / Skipped / Total] 23 / 0 / 17 / 40:   2%|         | 41/2690 [03:01<3:15:55,  4.44s/it][Succeeded / Failed / Skipped / Total] 24 / 0 / 17 / 41:   2%|         | 41/2690 [03:01<3:15:56,  4.44s/it][Succeeded / Failed / Skipped / Total] 24 / 0 / 17 / 41:   2%|         | 42/2690 [03:02<3:11:41,  4.34s/it][Succeeded / Failed / Skipped / Total] 24 / 0 / 18 / 42:   2%|         | 42/2690 [03:02<3:11:41,  4.34s/it][Succeeded / Failed / Skipped / Total] 24 / 0 / 18 / 42:   2%|         | 43/2690 [03:02<3:07:39,  4.25s/it][Succeeded / Failed / Skipped / Total] 24 / 0 / 19 / 43:   2%|         | 43/2690 [03:02<3:07:39,  4.25s/it][Succeeded / Failed / Skipped / Total] 24 / 0 / 19 / 43:   2%|         | 44/2690 [03:03<3:03:50,  4.17s/it]
--------------------------------------------- Result 39 ---------------------------------------------
[[0 (1%)]] --> [[0 (98%)]] --> Socre: 0.9811353087425232

[[[[Adv]]]]: int floatx80_eq(floatx80 [[a]], floatx80 b, float_status *status) { if ( ( ( extractFloatx80Exp( [[a]] ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( [[a]] )<<1 ) ) || ( ( extractFloatx80Exp( b ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( b )<<1 ) ) ) { float_raise(float_flag_invalid, status); return 0; } return ( [[a]].low == b.low ) && ( ( [[a]].high == b.high ) || ( ( [[a]].low == 0 ) && ( (uint16_t) ( ( [[a]].high | b.high )<<1 ) == 0 ) ) ); }

[[[[Adv]]]]: int floatx80_eq(floatx80 [[]], floatx80 b, float_status *status) { if ( ( ( extractFloatx80Exp( [[]] ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( [[]] )<<1 ) ) || ( ( extractFloatx80Exp( b ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( b )<<1 ) ) ) { float_raise(float_flag_invalid, status); return 0; } return ( [[]].low == b.low ) && ( ( [[]].high == b.high ) || ( ( [[]].low == 0 ) && ( (uint16_t) ( ( [[]].high | b.high )<<1 ) == 0 ) ) ); }
--------------------------------------------- Result 40 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: DeviceState *qdev_device_add(QemuOpts *opts) { ObjectClass *oc; DeviceClass *dc; const char *driver, *path, *id; DeviceState *dev; BusState *bus = NULL; Error *err = NULL; driver = qemu_opt_get(opts, "driver"); if (!driver) { qerror_report(QERR_MISSING_PARAMETER, "driver"); return NULL; } oc = object_class_by_name(driver); if (!oc) { const char *typename = find_typename_by_alias(driver); if (typename) { driver = typename; oc = object_class_by_name(driver); } } if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) { qerror_report(ERROR_CLASS_GENERIC_ERROR, "'%s' is not a valid device model name", driver); return NULL; } if (object_class_is_abstract(oc)) { qerror_report(QERR_INVALID_PARAMETER_VALUE, "driver", "non-abstract device type"); return NULL; } dc = DEVICE_CLASS(oc); if (dc->cannot_instantiate_with_device_add_yet) { qerror_report(QERR_INVALID_PARAMETER_VALUE, "driver", "pluggable device type"); return NULL; } path = qemu_opt_get(opts, "bus"); if (path != NULL) { bus = qbus_find(path); if (!bus) { return NULL; } if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) { qerror_report(QERR_BAD_BUS_FOR_DEVICE, driver, object_get_typename(OBJECT(bus))); return NULL; } } else if (dc->bus_type != NULL) { bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type); if (!bus) { qerror_report(QERR_NO_BUS_FOR_DEVICE, dc->bus_type, driver); return NULL; } } if (qdev_hotplug && bus && !bus->allow_hotplug) { qerror_report(QERR_BUS_NO_HOTPLUG, bus->name); return NULL; } dev = DEVICE(object_new(driver)); if (bus) { qdev_set_parent_bus(dev, bus); } id = qemu_opts_id(opts); if (id) { dev->id = id; } if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) { object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); return NULL; } if (dev->id) { object_property_add_child(qdev_get_peripheral(), dev->id, OBJECT(dev), NULL); } else { static int anon_count; gchar *name = g_strdup_printf("device[%d]", anon_count++); object_property_add_child(qdev_get_peripheral_anon(), name, OBJECT(dev), NULL); g_free(name); } dev->opts = opts; object_property_set_bool(OBJECT(dev), "True" == "True", "realized", &err); if (err != NULL) { qerror_report_err(err); error_free(err); dev->opts = NULL; object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); qerror_report(QERR_DEVICE_INIT_FAILED, driver); return NULL; } return dev; }
--------------------------------------------- Result 41 ---------------------------------------------
[[0 (3%)]] --> [[0 (55%)]] --> Socre: 0.5535518527030945

[[[[Adv]]]]: void thread_pool_submit(ThreadPoolFunc *[[func]], void *[[arg]]) { thread_pool_submit_aio([[func]], [[arg]], NULL, NULL); }

[[[[Adv]]]]: void thread_pool_submit(ThreadPoolFunc *[[misogynist]], void *[[approximately]]) { thread_pool_submit_aio([[misogynist]], [[approximately]], NULL, NULL); }
--------------------------------------------- Result 42 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int cpu_exec(CPUState *cpu) { CPUClass *cc = CPU_GET_CLASS(cpu); int ret; SyncClocks sc; current_cpu = cpu; if (cpu_handle_halt(cpu)) { return EXCP_HALTED; } rcu_read_lock(); cc->cpu_exec_enter(cpu); init_delay_params(&sc, cpu); if (sigsetjmp(cpu->jmp_env, 0) != 0) { #if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6) cpu = current_cpu; cc = CPU_GET_CLASS(cpu); #else g_assert(cpu == current_cpu); g_assert(cc == CPU_GET_CLASS(cpu)); #endif cpu->can_do_io = 1; tb_lock_reset(); if (qemu_mutex_iothread_locked()) { qemu_mutex_unlock_iothread(); } } while (!cpu_handle_exception(cpu, &ret)) { TranslationBlock *last_tb = NULL; int tb_exit = 0; while (!cpu_handle_interrupt(cpu, &last_tb)) { TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit); cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc); align_clocks(&sc, cpu); } } cc->cpu_exec_exit(cpu); rcu_read_unlock(); current_cpu = NULL; return ret; }
--------------------------------------------- Result 43 ---------------------------------------------
[[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw) { int i; uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL; uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL; copy_scsw_to_guest(&dest->scsw, &src->scsw); for (i = 0; i < ARRAY_SIZE(dest->esw); i++) { dest->esw[i] = cpu_to_be32(src->esw[i]); } for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) { dest->ecw[i] = cpu_to_be32(src->ecw[i]); } if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) || !(pmcw->flags & PMCW_FLAGS_MASK_TF) || !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) { return; } if (!(stctl & SCSW_STCTL_STATUS_PEND)) { return; } if ((stctl & SCSW_STCTL_PRIMARY) || (stctl == SCSW_STCTL_SECONDARY) || ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) { for (i = 0; i < ARRAY_SIZE(dest->emw); i++) { dest->emw[i] = cpu_to_be32(src->emw[i]); } } }
--------------------------------------------- Result 44 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 24 / 0 / 20 / 44:   2%|         | 44/2690 [03:03<3:03:50,  4.17s/it][Succeeded / Failed / Skipped / Total] 24 / 0 / 20 / 44:   2%|         | 45/2690 [03:04<3:01:01,  4.11s/it][[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int process_input_packet(InputStream *ist, const AVPacket *pkt) { int i; int got_output; AVPacket avpkt; if (ist->next_dts == AV_NOPTS_VALUE) ist->next_dts = ist->last_dts; if (pkt == NULL) { av_init_packet(&avpkt); avpkt.data = NULL; avpkt.size = 0; goto handle_eof; } else { avpkt = *pkt; } if (pkt->dts != AV_NOPTS_VALUE) ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q); while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) { int ret = 0; handle_eof: ist->last_dts = ist->next_dts; if (avpkt.size && avpkt.size != pkt->size && !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) { av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING, "Multiple frames in a packet from stream %d\n", pkt->stream_index); ist->showed_multi_packet_warning = 1; } switch (ist->dec_ctx->codec_type) { case AVMEDIA_TYPE_AUDIO: ret = decode_audio (ist, &avpkt, &got_output); break; case AVMEDIA_TYPE_VIDEO: ret = decode_video (ist, &avpkt, &got_output); if (avpkt.duration) ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q); else if (ist->st->avg_frame_rate.num) ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate), AV_TIME_BASE_Q); else if (ist->dec_ctx->time_base.num != 0) { int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame; ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q); } break; case AVMEDIA_TYPE_SUBTITLE: ret = transcode_subtitles(ist, &avpkt, &got_output); break; default: return -1; } if (ret < 0) return ret; if (pkt) { avpkt.data += ret; avpkt.size -= ret; } if (!got_output) { continue; } } if (!ist->decoding_needed) { ist->last_dts = ist->next_dts; switch (ist->dec_ctx->codec_type) { case AVMEDIA_TYPE_AUDIO: ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) / ist->dec_ctx->sample_rate; break; case AVMEDIA_TYPE_VIDEO: if (ist->dec_ctx->time_base.num != 0) { int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame; ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->time_base.num * ticks) / ist->dec_ctx->time_base.den; } break; } } for (i = 0; pkt && i < nb_output_streams; i++) { OutputStream *ost = output_streams[i]; if (!check_output_constraints(ist, ost) || ost->encoding_needed) continue; do_streamcopy(ist, ost, pkt); } return 0; }
--------------------------------------------- Result 45 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static target_ulong disas_insn(DisasContext *s, CPUState *cpu) { CPUX86State *env = cpu->env_ptr; int b, prefixes; int shift; TCGMemOp ot, aflag, dflag; int modrm, reg, rm, mod, op, opreg, val; target_ulong next_eip, tval; int rex_w, rex_r; target_ulong pc_start = s->base.pc_next; s->pc_start = s->pc = pc_start; prefixes = 0; s->override = -1; rex_w = -1; rex_r = 0; #ifdef TARGET_X86_64 s->rex_x = 0; s->rex_b = 0; x86_64_hregs = 0; #endif s->rip_offset = 0; s->vex_l = 0; s->vex_v = 0; if (sigsetjmp(s->jmpbuf, 0) != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); return s->pc; } next_byte: b = x86_ldub_code(env, s); switch (b) { case 0xf3: prefixes |= PREFIX_REPZ; goto next_byte; case 0xf2: prefixes |= PREFIX_REPNZ; goto next_byte; case 0xf0: prefixes |= PREFIX_LOCK; goto next_byte; case 0x2e: s->override = R_CS; goto next_byte; case 0x36: s->override = R_SS; goto next_byte; case 0x3e: s->override = R_DS; goto next_byte; case 0x26: s->override = R_ES; goto next_byte; case 0x64: s->override = R_FS; goto next_byte; case 0x65: s->override = R_GS; goto next_byte; case 0x66: prefixes |= PREFIX_DATA; goto next_byte; case 0x67: prefixes |= PREFIX_ADR; goto next_byte; #ifdef TARGET_X86_64 case 0x40 ... 0x4f: if (CODE64(s)) { rex_w = (b >> 3) & 1; rex_r = (b & 0x4) << 1; s->rex_x = (b & 0x2) << 2; REX_B(s) = (b & 0x1) << 3; x86_64_hregs = 1; goto next_byte; } break; #endif case 0xc5: case 0xc4: if (s->code32 && !s->vm86) { static const int pp_prefix[4] = { 0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ }; int vex3, vex2 = x86_ldub_code(env, s); if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) { break; } s->pc++; if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ | PREFIX_LOCK | PREFIX_DATA)) { goto illegal_op; } #ifdef TARGET_X86_64 if (x86_64_hregs) { goto illegal_op; } #endif rex_r = (~vex2 >> 4) & 8; if (b == 0xc5) { vex3 = vex2; b = x86_ldub_code(env, s); } else { #ifdef TARGET_X86_64 s->rex_x = (~vex2 >> 3) & 8; s->rex_b = (~vex2 >> 2) & 8; #endif vex3 = x86_ldub_code(env, s); rex_w = (vex3 >> 7) & 1; switch (vex2 & 0x1f) { case 0x01: b = x86_ldub_code(env, s) | 0x100; break; case 0x02: b = 0x138; break; case 0x03: b = 0x13a; break; default: goto unknown_op; } } s->vex_v = (~vex3 >> 3) & 0xf; s->vex_l = (vex3 >> 2) & 1; prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX; } break; } if (CODE64(s)) { dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32); aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64); } else { if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) { dflag = MO_32; } else { dflag = MO_16; } if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) { aflag = MO_32; } else { aflag = MO_16; } } s->prefix = prefixes; s->aflag = aflag; s->dflag = dflag; reswitch: switch(b) { case 0x0f: b = x86_ldub_code(env, s) | 0x100; goto reswitch; case 0x00 ... 0x05: case 0x08 ... 0x0d: case 0x10 ... 0x15: case 0x18 ... 0x1d: case 0x20 ... 0x25: case 0x28 ... 0x2d: case 0x30 ... 0x35: case 0x38 ... 0x3d: { int op, f, val; op = (b >> 3) & 7; f = (b >> 1) & 3; ot = mo_b_d(b, dflag); switch(f) { case 0: modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod != 3) { gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; } else if (op == OP_XORL && rm == reg) { xor_zero: set_cc_op(s, CC_OP_CLR); tcg_gen_movi_tl(cpu_T0, 0); gen_op_mov_reg_v(ot, reg, cpu_T0); break; } else { opreg = rm; } gen_op_mov_v_reg(ot, cpu_T1, reg); gen_op(s, op, ot, opreg); break; case 1: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; reg = ((modrm >> 3) & 7) | rex_r; rm = (modrm & 7) | REX_B(s); if (mod != 3) { gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, cpu_T1, cpu_A0); } else if (op == OP_XORL && rm == reg) { goto xor_zero; } else { gen_op_mov_v_reg(ot, cpu_T1, rm); } gen_op(s, op, ot, reg); break; case 2: val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T1, val); gen_op(s, op, ot, OR_EAX); break; } } break; case 0x82: if (CODE64(s)) goto illegal_op; case 0x80: case 0x81: case 0x83: { int val; ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); op = (modrm >> 3) & 7; if (mod != 3) { if (b == 0x83) s->rip_offset = 1; else s->rip_offset = insn_const_size(ot); gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; } else { opreg = rm; } switch(b) { default: case 0x80: case 0x81: case 0x82: val = insn_get(env, s, ot); break; case 0x83: val = (int8_t)insn_get(env, s, MO_8); break; } tcg_gen_movi_tl(cpu_T1, val); gen_op(s, op, ot, opreg); } break; case 0x40 ... 0x47: ot = dflag; gen_inc(s, ot, OR_EAX + (b & 7), 1); break; case 0x48 ... 0x4f: ot = dflag; gen_inc(s, ot, OR_EAX + (b & 7), -1); break; case 0xf6: case 0xf7: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); op = (modrm >> 3) & 7; if (mod != 3) { if (op == 0) { s->rip_offset = insn_const_size(ot); } gen_lea_modrm(env, s, modrm); if (!(s->prefix & PREFIX_LOCK) || op != 2) { gen_op_ld_v(s, ot, cpu_T0, cpu_A0); } } else { gen_op_mov_v_reg(ot, cpu_T0, rm); } switch(op) { case 0: val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T1, val); gen_op_testl_T0_T1_cc(); set_cc_op(s, CC_OP_LOGICB + ot); break; case 2: if (s->prefix & PREFIX_LOCK) { if (mod == 3) { goto illegal_op; } tcg_gen_movi_tl(cpu_T0, ~0); tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0, s->mem_index, ot | MO_LE); } else { tcg_gen_not_tl(cpu_T0, cpu_T0); if (mod != 3) { gen_op_st_v(s, ot, cpu_T0, cpu_A0); } else { gen_op_mov_reg_v(ot, rm, cpu_T0); } } break; case 3: if (s->prefix & PREFIX_LOCK) { TCGLabel *label1; TCGv a0, t0, t1, t2; if (mod == 3) { goto illegal_op; } a0 = tcg_temp_local_new(); t0 = tcg_temp_local_new(); label1 = gen_new_label(); tcg_gen_mov_tl(a0, cpu_A0); tcg_gen_mov_tl(t0, cpu_T0); gen_set_label(label1); t1 = tcg_temp_new(); t2 = tcg_temp_new(); tcg_gen_mov_tl(t2, t0); tcg_gen_neg_tl(t1, t0); tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1, s->mem_index, ot | MO_LE); tcg_temp_free(t1); tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1); tcg_temp_free(t2); tcg_temp_free(a0); tcg_gen_mov_tl(cpu_T0, t0); tcg_temp_free(t0); } else { tcg_gen_neg_tl(cpu_T0, cpu_T0); if (mod != 3) { gen_op_st_v(s, ot, cpu_T0, cpu_A0); } else { gen_op_mov_reg_v(ot, rm, cpu_T0); } } gen_op_update_neg_cc(); set_cc_op(s, CC_OP_SUBB + ot); break; case 4: switch(ot) { case MO_8: gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX); tcg_gen_ext8u_tl(cpu_T0, cpu_T0); tcg_gen_ext8u_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00); set_cc_op(s, CC_OP_MULB); break; case MO_16: gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX); tcg_gen_ext16u_tl(cpu_T0, cpu_T0); tcg_gen_ext16u_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_shri_tl(cpu_T0, cpu_T0, 16); gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0); tcg_gen_mov_tl(cpu_cc_src, cpu_T0); set_cc_op(s, CC_OP_MULW); break; default: case MO_32: tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]); tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32); tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]); tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]); set_cc_op(s, CC_OP_MULL); break; #ifdef TARGET_X86_64 case MO_64: tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_T0, cpu_regs[R_EAX]); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]); tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]); set_cc_op(s, CC_OP_MULQ); break; #endif } break; case 5: switch(ot) { case MO_8: gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX); tcg_gen_ext8s_tl(cpu_T0, cpu_T0); tcg_gen_ext8s_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0); tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0); set_cc_op(s, CC_OP_MULB); break; case MO_16: gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX); tcg_gen_ext16s_tl(cpu_T0, cpu_T0); tcg_gen_ext16s_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0); tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0); tcg_gen_shri_tl(cpu_T0, cpu_T0, 16); gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0); set_cc_op(s, CC_OP_MULW); break; default: case MO_32: tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]); tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32); tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32); tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]); tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32); set_cc_op(s, CC_OP_MULL); break; #ifdef TARGET_X86_64 case MO_64: tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_T0, cpu_regs[R_EAX]); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]); tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63); tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]); set_cc_op(s, CC_OP_MULQ); break; #endif } break; case 6: switch(ot) { case MO_8: gen_helper_divb_AL(cpu_env, cpu_T0); break; case MO_16: gen_helper_divw_AX(cpu_env, cpu_T0); break; default: case MO_32: gen_helper_divl_EAX(cpu_env, cpu_T0); break; #ifdef TARGET_X86_64 case MO_64: gen_helper_divq_EAX(cpu_env, cpu_T0); break; #endif } break; case 7: switch(ot) { case MO_8: gen_helper_idivb_AL(cpu_env, cpu_T0); break; case MO_16: gen_helper_idivw_AX(cpu_env, cpu_T0); break; default: case MO_32: gen_helper_idivl_EAX(cpu_env, cpu_T0); break; #ifdef TARGET_X86_64 case MO_64: gen_helper_idivq_EAX(cpu_env, cpu_T0); break; #endif } break; default: goto unknown_op; } break; case 0xfe: case 0xff: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); op = (modrm >> 3) & 7; if (op >= 2 && b == 0xfe) { goto unknown_op; } if (CODE64(s)) { if (op == 2 || op == 4) { ot = MO_64; } else if (op == 3 || op == 5) { ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16; } else if (op == 6) { ot = mo_pushpop(s, dflag); } } if (mod != 3) { gen_lea_modrm(env, s, modrm); if (op >= 2 && op != 3 && op != 5) gen_op_ld_v(s, ot, cpu_T0, cpu_A0); } else { gen_op_mov_v_reg(ot, cpu_T0, rm); } switch(op) { case 0: if (mod != 3) opreg = OR_TMP0; else opreg = rm; gen_inc(s, ot, opreg, 1); break; case 1: if (mod != 3) opreg = OR_TMP0; else opreg = rm; gen_inc(s, ot, opreg, -1); break; case 2: if (dflag == MO_16) { tcg_gen_ext16u_tl(cpu_T0, cpu_T0); } next_eip = s->pc - s->cs_base; tcg_gen_movi_tl(cpu_T1, next_eip); gen_push_v(s, cpu_T1); gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 3: gen_op_ld_v(s, ot, cpu_T1, cpu_A0); gen_add_A0_im(s, 1 << ot); gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0); do_lcall: if (s->pe && !s->vm86) { tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1, tcg_const_i32(dflag - 1), tcg_const_tl(s->pc - s->cs_base)); } else { tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1, tcg_const_i32(dflag - 1), tcg_const_i32(s->pc - s->cs_base)); } tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip)); gen_jr(s, cpu_tmp4); break; case 4: if (dflag == MO_16) { tcg_gen_ext16u_tl(cpu_T0, cpu_T0); } gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 5: gen_op_ld_v(s, ot, cpu_T1, cpu_A0); gen_add_A0_im(s, 1 << ot); gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0); do_ljmp: if (s->pe && !s->vm86) { tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1, tcg_const_tl(s->pc - s->cs_base)); } else { gen_op_movl_seg_T0_vm(R_CS); gen_op_jmp_v(cpu_T1); } tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip)); gen_jr(s, cpu_tmp4); break; case 6: gen_push_v(s, cpu_T0); break; default: goto unknown_op; } break; case 0x84: case 0x85: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_op_mov_v_reg(ot, cpu_T1, reg); gen_op_testl_T0_T1_cc(); set_cc_op(s, CC_OP_LOGICB + ot); break; case 0xa8: case 0xa9: ot = mo_b_d(b, dflag); val = insn_get(env, s, ot); gen_op_mov_v_reg(ot, cpu_T0, OR_EAX); tcg_gen_movi_tl(cpu_T1, val); gen_op_testl_T0_T1_cc(); set_cc_op(s, CC_OP_LOGICB + ot); break; case 0x98: switch (dflag) { #ifdef TARGET_X86_64 case MO_64: gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX); tcg_gen_ext32s_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0); break; #endif case MO_32: gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX); tcg_gen_ext16s_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0); break; case MO_16: gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX); tcg_gen_ext8s_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); break; default: tcg_abort(); } break; case 0x99: switch (dflag) { #ifdef TARGET_X86_64 case MO_64: gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX); tcg_gen_sari_tl(cpu_T0, cpu_T0, 63); gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0); break; #endif case MO_32: gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX); tcg_gen_ext32s_tl(cpu_T0, cpu_T0); tcg_gen_sari_tl(cpu_T0, cpu_T0, 31); gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0); break; case MO_16: gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX); tcg_gen_ext16s_tl(cpu_T0, cpu_T0); tcg_gen_sari_tl(cpu_T0, cpu_T0, 15); gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0); break; default: tcg_abort(); } break; case 0x1af: case 0x69: case 0x6b: ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; if (b == 0x69) s->rip_offset = insn_const_size(ot); else if (b == 0x6b) s->rip_offset = 1; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); if (b == 0x69) { val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T1, val); } else if (b == 0x6b) { val = (int8_t)insn_get(env, s, MO_8); tcg_gen_movi_tl(cpu_T1, val); } else { gen_op_mov_v_reg(ot, cpu_T1, reg); } switch (ot) { #ifdef TARGET_X86_64 case MO_64: tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]); tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63); tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1); break; #endif case MO_32: tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1); tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32); tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]); tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32); break; default: tcg_gen_ext16s_tl(cpu_T0, cpu_T0); tcg_gen_ext16s_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0); tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0); gen_op_mov_reg_v(ot, reg, cpu_T0); break; } set_cc_op(s, CC_OP_MULB + ot); break; case 0x1c0: case 0x1c1: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; gen_op_mov_v_reg(ot, cpu_T0, reg); if (mod == 3) { rm = (modrm & 7) | REX_B(s); gen_op_mov_v_reg(ot, cpu_T1, rm); tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(ot, reg, cpu_T1); gen_op_mov_reg_v(ot, rm, cpu_T0); } else { gen_lea_modrm(env, s, modrm); if (s->prefix & PREFIX_LOCK) { tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0, s->mem_index, ot | MO_LE); tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1); } else { gen_op_ld_v(s, ot, cpu_T1, cpu_A0); tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_st_v(s, ot, cpu_T0, cpu_A0); } gen_op_mov_reg_v(ot, reg, cpu_T1); } gen_op_update2_cc(); set_cc_op(s, CC_OP_ADDB + ot); break; case 0x1b0: case 0x1b1: { TCGv oldv, newv, cmpv; ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; oldv = tcg_temp_new(); newv = tcg_temp_new(); cmpv = tcg_temp_new(); gen_op_mov_v_reg(ot, newv, reg); tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]); if (s->prefix & PREFIX_LOCK) { if (mod == 3) { goto illegal_op; } gen_lea_modrm(env, s, modrm); tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv, s->mem_index, ot | MO_LE); gen_op_mov_reg_v(ot, R_EAX, oldv); } else { if (mod == 3) { rm = (modrm & 7) | REX_B(s); gen_op_mov_v_reg(ot, oldv, rm); } else { gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, oldv, cpu_A0); rm = 0; } gen_extu(ot, oldv); gen_extu(ot, cmpv); tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv); if (mod == 3) { gen_op_mov_reg_v(ot, R_EAX, oldv); gen_op_mov_reg_v(ot, rm, newv); } else { gen_op_st_v(s, ot, newv, cpu_A0); gen_op_mov_reg_v(ot, R_EAX, oldv); } } tcg_gen_mov_tl(cpu_cc_src, oldv); tcg_gen_mov_tl(cpu_cc_srcT, cmpv); tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv); set_cc_op(s, CC_OP_SUBB + ot); tcg_temp_free(oldv); tcg_temp_free(newv); tcg_temp_free(cmpv); } break; case 0x1c7: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; if ((mod == 3) || ((modrm & 0x38) != 0x8)) goto illegal_op; #ifdef TARGET_X86_64 if (dflag == MO_64) { if (!(s->cpuid_ext_features & CPUID_EXT_CX16)) goto illegal_op; gen_lea_modrm(env, s, modrm); if ((s->prefix & PREFIX_LOCK) && parallel_cpus) { gen_helper_cmpxchg16b(cpu_env, cpu_A0); } else { gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0); } } else #endif { if (!(s->cpuid_features & CPUID_CX8)) goto illegal_op; gen_lea_modrm(env, s, modrm); if ((s->prefix & PREFIX_LOCK) && parallel_cpus) { gen_helper_cmpxchg8b(cpu_env, cpu_A0); } else { gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0); } } set_cc_op(s, CC_OP_EFLAGS); break; case 0x50 ... 0x57: gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s)); gen_push_v(s, cpu_T0); break; case 0x58 ... 0x5f: ot = gen_pop_T0(s); gen_pop_update(s, ot); gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0); break; case 0x60: if (CODE64(s)) goto illegal_op; gen_pusha(s); break; case 0x61: if (CODE64(s)) goto illegal_op; gen_popa(s); break; case 0x68: case 0x6a: ot = mo_pushpop(s, dflag); if (b == 0x68) val = insn_get(env, s, ot); else val = (int8_t)insn_get(env, s, MO_8); tcg_gen_movi_tl(cpu_T0, val); gen_push_v(s, cpu_T0); break; case 0x8f: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; ot = gen_pop_T0(s); if (mod == 3) { gen_pop_update(s, ot); rm = (modrm & 7) | REX_B(s); gen_op_mov_reg_v(ot, rm, cpu_T0); } else { s->popl_esp_hack = 1 << ot; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); s->popl_esp_hack = 0; gen_pop_update(s, ot); } break; case 0xc8: { int level; val = x86_lduw_code(env, s); level = x86_ldub_code(env, s); gen_enter(s, val, level); } break; case 0xc9: gen_leave(s); break; case 0x06: case 0x0e: case 0x16: case 0x1e: if (CODE64(s)) goto illegal_op; gen_op_movl_T0_seg(b >> 3); gen_push_v(s, cpu_T0); break; case 0x1a0: case 0x1a8: gen_op_movl_T0_seg((b >> 3) & 7); gen_push_v(s, cpu_T0); break; case 0x07: case 0x17: case 0x1f: if (CODE64(s)) goto illegal_op; reg = b >> 3; ot = gen_pop_T0(s); gen_movl_seg_T0(s, reg); gen_pop_update(s, ot); if (s->base.is_jmp) { gen_jmp_im(s->pc - s->cs_base); if (reg == R_SS) { s->tf = 0; gen_eob_inhibit_irq(s, "True" == "True"); } else { gen_eob(s); } } break; case 0x1a1: case 0x1a9: ot = gen_pop_T0(s); gen_movl_seg_T0(s, (b >> 3) & 7); gen_pop_update(s, ot); if (s->base.is_jmp) { gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } break; case 0x88: case 0x89: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, reg, 1); break; case 0xc6: case 0xc7: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; if (mod != 3) { s->rip_offset = insn_const_size(ot); gen_lea_modrm(env, s, modrm); } val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T0, val); if (mod != 3) { gen_op_st_v(s, ot, cpu_T0, cpu_A0); } else { gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0); } break; case 0x8a: case 0x8b: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_op_mov_reg_v(ot, reg, cpu_T0); break; case 0x8e: modrm = x86_ldub_code(env, s); reg = (modrm >> 3) & 7; if (reg >= 6 || reg == R_CS) goto illegal_op; gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); gen_movl_seg_T0(s, reg); if (s->base.is_jmp) { gen_jmp_im(s->pc - s->cs_base); if (reg == R_SS) { s->tf = 0; gen_eob_inhibit_irq(s, "True" == "True"); } else { gen_eob(s); } } break; case 0x8c: modrm = x86_ldub_code(env, s); reg = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; if (reg >= 6) goto illegal_op; gen_op_movl_T0_seg(reg); ot = mod == 3 ? dflag : MO_16; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 0x1b6: case 0x1b7: case 0x1be: case 0x1bf: { TCGMemOp d_ot; TCGMemOp s_ot; d_ot = dflag; ot = (b & 1) + MO_8; s_ot = b & 8 ? MO_SIGN | ot : ot; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod == 3) { if (s_ot == MO_SB && byte_reg_is_xH(rm)) { tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8); } else { gen_op_mov_v_reg(ot, cpu_T0, rm); switch (s_ot) { case MO_UB: tcg_gen_ext8u_tl(cpu_T0, cpu_T0); break; case MO_SB: tcg_gen_ext8s_tl(cpu_T0, cpu_T0); break; case MO_UW: tcg_gen_ext16u_tl(cpu_T0, cpu_T0); break; default: case MO_SW: tcg_gen_ext16s_tl(cpu_T0, cpu_T0); break; } } gen_op_mov_reg_v(d_ot, reg, cpu_T0); } else { gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0); gen_op_mov_reg_v(d_ot, reg, cpu_T0); } } break; case 0x8d: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; if (mod == 3) goto illegal_op; reg = ((modrm >> 3) & 7) | rex_r; { AddressParts a = gen_lea_modrm_0(env, s, modrm); TCGv ea = gen_lea_modrm_1(a); gen_lea_v_seg(s, s->aflag, ea, -1, -1); gen_op_mov_reg_v(dflag, reg, cpu_A0); } break; case 0xa0: case 0xa1: case 0xa2: case 0xa3: { target_ulong offset_addr; ot = mo_b_d(b, dflag); switch (s->aflag) { #ifdef TARGET_X86_64 case MO_64: offset_addr = x86_ldq_code(env, s); break; #endif default: offset_addr = insn_get(env, s, s->aflag); break; } tcg_gen_movi_tl(cpu_A0, offset_addr); gen_add_A0_ds_seg(s); if ((b & 2) == 0) { gen_op_ld_v(s, ot, cpu_T0, cpu_A0); gen_op_mov_reg_v(ot, R_EAX, cpu_T0); } else { gen_op_mov_v_reg(ot, cpu_T0, R_EAX); gen_op_st_v(s, ot, cpu_T0, cpu_A0); } } break; case 0xd7: tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]); tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]); tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0); gen_extu(s->aflag, cpu_A0); gen_add_A0_ds_seg(s); gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0); gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0); break; case 0xb0 ... 0xb7: val = insn_get(env, s, MO_8); tcg_gen_movi_tl(cpu_T0, val); gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0); break; case 0xb8 ... 0xbf: #ifdef TARGET_X86_64 if (dflag == MO_64) { uint64_t tmp; tmp = x86_ldq_code(env, s); reg = (b & 7) | REX_B(s); tcg_gen_movi_tl(cpu_T0, tmp); gen_op_mov_reg_v(MO_64, reg, cpu_T0); } else #endif { ot = dflag; val = insn_get(env, s, ot); reg = (b & 7) | REX_B(s); tcg_gen_movi_tl(cpu_T0, val); gen_op_mov_reg_v(ot, reg, cpu_T0); } break; case 0x91 ... 0x97: do_xchg_reg_eax: ot = dflag; reg = (b & 7) | REX_B(s); rm = R_EAX; goto do_xchg_reg; case 0x86: case 0x87: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; if (mod == 3) { rm = (modrm & 7) | REX_B(s); do_xchg_reg: gen_op_mov_v_reg(ot, cpu_T0, reg); gen_op_mov_v_reg(ot, cpu_T1, rm); gen_op_mov_reg_v(ot, rm, cpu_T0); gen_op_mov_reg_v(ot, reg, cpu_T1); } else { gen_lea_modrm(env, s, modrm); gen_op_mov_v_reg(ot, cpu_T0, reg); tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0, s->mem_index, ot | MO_LE); gen_op_mov_reg_v(ot, reg, cpu_T1); } break; case 0xc4: op = R_ES; goto do_lxx; case 0xc5: op = R_DS; goto do_lxx; case 0x1b2: op = R_SS; goto do_lxx; case 0x1b4: op = R_FS; goto do_lxx; case 0x1b5: op = R_GS; do_lxx: ot = dflag != MO_16 ? MO_32 : MO_16; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; if (mod == 3) goto illegal_op; gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, cpu_T1, cpu_A0); gen_add_A0_im(s, 1 << ot); gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0); gen_movl_seg_T0(s, op); gen_op_mov_reg_v(ot, reg, cpu_T1); if (s->base.is_jmp) { gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } break; case 0xc0: case 0xc1: shift = 2; grp2: { ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; op = (modrm >> 3) & 7; if (mod != 3) { if (shift == 2) { s->rip_offset = 1; } gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; } else { opreg = (modrm & 7) | REX_B(s); } if (shift == 0) { gen_shift(s, op, ot, opreg, OR_ECX); } else { if (shift == 2) { shift = x86_ldub_code(env, s); } gen_shifti(s, op, ot, opreg, shift); } } break; case 0xd0: case 0xd1: shift = 1; goto grp2; case 0xd2: case 0xd3: shift = 0; goto grp2; case 0x1a4: op = 0; shift = 1; goto do_shiftd; case 0x1a5: op = 0; shift = 0; goto do_shiftd; case 0x1ac: op = 1; shift = 1; goto do_shiftd; case 0x1ad: op = 1; shift = 0; do_shiftd: ot = dflag; modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); reg = ((modrm >> 3) & 7) | rex_r; if (mod != 3) { gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; } else { opreg = rm; } gen_op_mov_v_reg(ot, cpu_T1, reg); if (shift) { TCGv imm = tcg_const_tl(x86_ldub_code(env, s)); gen_shiftd_rm_T1(s, ot, opreg, op, imm); tcg_temp_free(imm); } else { gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]); } break; case 0xd8 ... 0xdf: if (s->flags & (HF_EM_MASK | HF_TS_MASK)) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); break; } modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; rm = modrm & 7; op = ((b & 7) << 3) | ((modrm >> 3) & 7); if (mod != 3) { gen_lea_modrm(env, s, modrm); switch(op) { case 0x00 ... 0x07: case 0x10 ... 0x17: case 0x20 ... 0x27: case 0x30 ... 0x37: { int op1; op1 = op & 7; switch(op >> 4) { case 0: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32); break; case 1: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32); break; case 2: tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64); break; case 3: default: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LESW); gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32); break; } gen_helper_fp_arith_ST0_FT0(op1); if (op1 == 3) { gen_helper_fpop(cpu_env); } } break; case 0x08: case 0x0a: case 0x0b: case 0x18 ... 0x1b: case 0x28 ... 0x2b: case 0x38 ... 0x3b: switch(op & 7) { case 0: switch(op >> 4) { case 0: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32); break; case 1: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32); break; case 2: tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64); break; case 3: default: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LESW); gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32); break; } break; case 1: switch(op >> 4) { case 1: gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); break; case 2: gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env); tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); break; case 3: default: gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUW); break; } gen_helper_fpop(cpu_env); break; default: switch(op >> 4) { case 0: gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); break; case 1: gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); break; case 2: gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env); tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); break; case 3: default: gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUW); break; } if ((op & 7) == 3) gen_helper_fpop(cpu_env); break; } break; case 0x0c: gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x0d: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUW); gen_helper_fldcw(cpu_env, cpu_tmp2_i32); break; case 0x0e: gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x0f: gen_helper_fnstcw(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUW); break; case 0x1d: gen_helper_fldt_ST0(cpu_env, cpu_A0); break; case 0x1f: gen_helper_fstt_ST0(cpu_env, cpu_A0); gen_helper_fpop(cpu_env); break; case 0x2c: gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x2e: gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x2f: gen_helper_fnstsw(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUW); break; case 0x3c: gen_helper_fbld_ST0(cpu_env, cpu_A0); break; case 0x3e: gen_helper_fbst_ST0(cpu_env, cpu_A0); gen_helper_fpop(cpu_env); break; case 0x3d: tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64); break; case 0x3f: gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env); tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); gen_helper_fpop(cpu_env); break; default: goto unknown_op; } } else { opreg = rm; switch(op) { case 0x08: gen_helper_fpush(cpu_env); gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32((opreg + 1) & 7)); break; case 0x09: case 0x29: case 0x39: gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg)); break; case 0x0a: switch(rm) { case 0: gen_helper_fwait(cpu_env); break; default: goto unknown_op; } break; case 0x0c: switch(rm) { case 0: gen_helper_fchs_ST0(cpu_env); break; case 1: gen_helper_fabs_ST0(cpu_env); break; case 4: gen_helper_fldz_FT0(cpu_env); gen_helper_fcom_ST0_FT0(cpu_env); break; case 5: gen_helper_fxam_ST0(cpu_env); break; default: goto unknown_op; } break; case 0x0d: { switch(rm) { case 0: gen_helper_fpush(cpu_env); gen_helper_fld1_ST0(cpu_env); break; case 1: gen_helper_fpush(cpu_env); gen_helper_fldl2t_ST0(cpu_env); break; case 2: gen_helper_fpush(cpu_env); gen_helper_fldl2e_ST0(cpu_env); break; case 3: gen_helper_fpush(cpu_env); gen_helper_fldpi_ST0(cpu_env); break; case 4: gen_helper_fpush(cpu_env); gen_helper_fldlg2_ST0(cpu_env); break; case 5: gen_helper_fpush(cpu_env); gen_helper_fldln2_ST0(cpu_env); break; case 6: gen_helper_fpush(cpu_env); gen_helper_fldz_ST0(cpu_env); break; default: goto unknown_op; } } break; case 0x0e: switch(rm) { case 0: gen_helper_f2xm1(cpu_env); break; case 1: gen_helper_fyl2x(cpu_env); break; case 2: gen_helper_fptan(cpu_env); break; case 3: gen_helper_fpatan(cpu_env); break; case 4: gen_helper_fxtract(cpu_env); break; case 5: gen_helper_fprem1(cpu_env); break; case 6: gen_helper_fdecstp(cpu_env); break; default: case 7: gen_helper_fincstp(cpu_env); break; } break; case 0x0f: switch(rm) { case 0: gen_helper_fprem(cpu_env); break; case 1: gen_helper_fyl2xp1(cpu_env); break; case 2: gen_helper_fsqrt(cpu_env); break; case 3: gen_helper_fsincos(cpu_env); break; case 5: gen_helper_fscale(cpu_env); break; case 4: gen_helper_frndint(cpu_env); break; case 6: gen_helper_fsin(cpu_env); break; default: case 7: gen_helper_fcos(cpu_env); break; } break; case 0x00: case 0x01: case 0x04 ... 0x07: case 0x20: case 0x21: case 0x24 ... 0x27: case 0x30: case 0x31: case 0x34 ... 0x37: { int op1; op1 = op & 7; if (op >= 0x20) { gen_helper_fp_arith_STN_ST0(op1, opreg); if (op >= 0x30) gen_helper_fpop(cpu_env); } else { gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fp_arith_ST0_FT0(op1); } } break; case 0x02: case 0x22: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcom_ST0_FT0(cpu_env); break; case 0x03: case 0x23: case 0x32: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); break; case 0x15: switch(rm) { case 1: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1)); gen_helper_fucom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); gen_helper_fpop(cpu_env); break; default: goto unknown_op; } break; case 0x1c: switch(rm) { case 0: break; case 1: break; case 2: gen_helper_fclex(cpu_env); break; case 3: gen_helper_fninit(cpu_env); break; case 4: break; default: goto unknown_op; } break; case 0x1d: if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucomi_ST0_FT0(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x1e: if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcomi_ST0_FT0(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x28: gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg)); break; case 0x2a: gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg)); break; case 0x2b: case 0x0b: case 0x3a: case 0x3b: gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg)); gen_helper_fpop(cpu_env); break; case 0x2c: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucom_ST0_FT0(cpu_env); break; case 0x2d: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); break; case 0x33: switch(rm) { case 1: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1)); gen_helper_fcom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); gen_helper_fpop(cpu_env); break; default: goto unknown_op; } break; case 0x38: gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fpop(cpu_env); break; case 0x3c: switch(rm) { case 0: gen_helper_fnstsw(cpu_tmp2_i32, cpu_env); tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); break; default: goto unknown_op; } break; case 0x3d: if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucomi_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x3e: if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcomi_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x10 ... 0x13: case 0x18 ... 0x1b: { int op1; TCGLabel *l1; static const uint8_t fcmov_cc[8] = { (JCC_B << 1), (JCC_Z << 1), (JCC_BE << 1), (JCC_P << 1), }; if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1); l1 = gen_new_label(); gen_jcc1_noeob(s, op1, l1); gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg)); gen_set_label(l1); } break; default: goto unknown_op; } } break; case 0xa4: case 0xa5: ot = mo_b_d(b, dflag); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) { gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base); } else { gen_movs(s, ot); } break; case 0xaa: case 0xab: ot = mo_b_d(b, dflag); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) { gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base); } else { gen_stos(s, ot); } break; case 0xac: case 0xad: ot = mo_b_d(b, dflag); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) { gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base); } else { gen_lods(s, ot); } break; case 0xae: case 0xaf: ot = mo_b_d(b, dflag); if (prefixes & PREFIX_REPNZ) { gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1); } else if (prefixes & PREFIX_REPZ) { gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0); } else { gen_scas(s, ot); } break; case 0xa6: case 0xa7: ot = mo_b_d(b, dflag); if (prefixes & PREFIX_REPNZ) { gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1); } else if (prefixes & PREFIX_REPZ) { gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0); } else { gen_cmps(s, ot); } break; case 0x6c: case 0x6d: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]); gen_check_io(s, ot, pc_start - s->cs_base, SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) { gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base); } else { gen_ins(s, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_jmp(s, s->pc - s->cs_base); } } break; case 0x6e: case 0x6f: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]); gen_check_io(s, ot, pc_start - s->cs_base, svm_is_rep(prefixes) | 4); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) { gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base); } else { gen_outs(s, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_jmp(s, s->pc - s->cs_base); } } break; case 0xe4: case 0xe5: ot = mo_b_d32(b, dflag); val = x86_ldub_code(env, s); tcg_gen_movi_tl(cpu_T0, val); gen_check_io(s, ot, pc_start - s->cs_base, SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes)); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } tcg_gen_movi_i32(cpu_tmp2_i32, val); gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32); gen_op_mov_reg_v(ot, R_EAX, cpu_T1); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; case 0xe6: case 0xe7: ot = mo_b_d32(b, dflag); val = x86_ldub_code(env, s); tcg_gen_movi_tl(cpu_T0, val); gen_check_io(s, ot, pc_start - s->cs_base, svm_is_rep(prefixes)); gen_op_mov_v_reg(ot, cpu_T1, R_EAX); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } tcg_gen_movi_i32(cpu_tmp2_i32, val); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1); gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; case 0xec: case 0xed: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]); gen_check_io(s, ot, pc_start - s->cs_base, SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes)); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32); gen_op_mov_reg_v(ot, R_EAX, cpu_T1); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; case 0xee: case 0xef: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]); gen_check_io(s, ot, pc_start - s->cs_base, svm_is_rep(prefixes)); gen_op_mov_v_reg(ot, cpu_T1, R_EAX); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1); gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; case 0xc2: val = x86_ldsw_code(env, s); ot = gen_pop_T0(s); gen_stack_update(s, val + (1 << ot)); gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 0xc3: ot = gen_pop_T0(s); gen_pop_update(s, ot); gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 0xca: val = x86_ldsw_code(env, s); do_lret: if (s->pe && !s->vm86) { gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1), tcg_const_i32(val)); } else { gen_stack_A0(s); gen_op_ld_v(s, dflag, cpu_T0, cpu_A0); gen_op_jmp_v(cpu_T0); gen_add_A0_im(s, 1 << dflag); gen_op_ld_v(s, dflag, cpu_T0, cpu_A0); gen_op_movl_seg_T0_vm(R_CS); gen_stack_update(s, val + (2 << dflag)); } gen_eob(s); break; case 0xcb: val = 0; goto do_lret; case 0xcf: gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET); if (!s->pe) { gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1)); set_cc_op(s, CC_OP_EFLAGS); } else if (s->vm86) { if (s->iopl != 3) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1)); set_cc_op(s, CC_OP_EFLAGS); } } else { gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1), tcg_const_i32(s->pc - s->cs_base)); set_cc_op(s, CC_OP_EFLAGS); } gen_eob(s); break; case 0xe8: { if (dflag != MO_16) { tval = (int32_t)insn_get(env, s, MO_32); } else { tval = (int16_t)insn_get(env, s, MO_16); } next_eip = s->pc - s->cs_base; tval += next_eip; if (dflag == MO_16) { tval &= 0xffff; } else if (!CODE64(s)) { tval &= 0xffffffff; } tcg_gen_movi_tl(cpu_T0, next_eip); gen_push_v(s, cpu_T0); gen_bnd_jmp(s); gen_jmp(s, tval); } break; case 0x9a: { unsigned int selector, offset; if (CODE64(s)) goto illegal_op; ot = dflag; offset = insn_get(env, s, ot); selector = insn_get(env, s, MO_16); tcg_gen_movi_tl(cpu_T0, selector); tcg_gen_movi_tl(cpu_T1, offset); } goto do_lcall; case 0xe9: if (dflag != MO_16) { tval = (int32_t)insn_get(env, s, MO_32); } else { tval = (int16_t)insn_get(env, s, MO_16); } tval += s->pc - s->cs_base; if (dflag == MO_16) { tval &= 0xffff; } else if (!CODE64(s)) { tval &= 0xffffffff; } gen_bnd_jmp(s); gen_jmp(s, tval); break; case 0xea: { unsigned int selector, offset; if (CODE64(s)) goto illegal_op; ot = dflag; offset = insn_get(env, s, ot); selector = insn_get(env, s, MO_16); tcg_gen_movi_tl(cpu_T0, selector); tcg_gen_movi_tl(cpu_T1, offset); } goto do_ljmp; case 0xeb: tval = (int8_t)insn_get(env, s, MO_8); tval += s->pc - s->cs_base; if (dflag == MO_16) { tval &= 0xffff; } gen_jmp(s, tval); break; case 0x70 ... 0x7f: tval = (int8_t)insn_get(env, s, MO_8); goto do_jcc; case 0x180 ... 0x18f: if (dflag != MO_16) { tval = (int32_t)insn_get(env, s, MO_32); } else { tval = (int16_t)insn_get(env, s, MO_16); } do_jcc: next_eip = s->pc - s->cs_base; tval += next_eip; if (dflag == MO_16) { tval &= 0xffff; } gen_bnd_jmp(s); gen_jcc(s, b, tval, next_eip); break; case 0x190 ... 0x19f: modrm = x86_ldub_code(env, s); gen_setcc1(s, b, cpu_T0); gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1); break; case 0x140 ... 0x14f: if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_cmovcc1(env, s, ot, b, modrm, reg); break; case 0x9c: gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF); if (s->vm86 && s->iopl != 3) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_update_cc_op(s); gen_helper_read_eflags(cpu_T0, cpu_env); gen_push_v(s, cpu_T0); } break; case 0x9d: gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF); if (s->vm86 && s->iopl != 3) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { ot = gen_pop_T0(s); if (s->cpl == 0) { if (dflag != MO_16) { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK))); } else { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK) & 0xffff)); } } else { if (s->cpl <= s->iopl) { if (dflag != MO_16) { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK))); } else { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK) & 0xffff)); } } else { if (dflag != MO_16) { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK))); } else { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK) & 0xffff)); } } } gen_pop_update(s, ot); set_cc_op(s, CC_OP_EFLAGS); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } break; case 0x9e: if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM)) goto illegal_op; gen_op_mov_v_reg(MO_8, cpu_T0, R_AH); gen_compute_eflags(s); tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O); tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C); tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0); break; case 0x9f: if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM)) goto illegal_op; gen_compute_eflags(s); tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02); gen_op_mov_reg_v(MO_8, R_AH, cpu_T0); break; case 0xf5: gen_compute_eflags(s); tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C); break; case 0xf8: gen_compute_eflags(s); tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C); break; case 0xf9: gen_compute_eflags(s); tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C); break; case 0xfc: tcg_gen_movi_i32(cpu_tmp2_i32, 1); tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df)); break; case 0xfd: tcg_gen_movi_i32(cpu_tmp2_i32, -1); tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df)); break; case 0x1ba: ot = dflag; modrm = x86_ldub_code(env, s); op = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod != 3) { s->rip_offset = 1; gen_lea_modrm(env, s, modrm); if (!(s->prefix & PREFIX_LOCK)) { gen_op_ld_v(s, ot, cpu_T0, cpu_A0); } } else { gen_op_mov_v_reg(ot, cpu_T0, rm); } val = x86_ldub_code(env, s); tcg_gen_movi_tl(cpu_T1, val); if (op < 4) goto unknown_op; op -= 4; goto bt_op; case 0x1a3: op = 0; goto do_btx; case 0x1ab: op = 1; goto do_btx; case 0x1b3: op = 2; goto do_btx; case 0x1bb: op = 3; do_btx: ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); gen_op_mov_v_reg(MO_32, cpu_T1, reg); if (mod != 3) { AddressParts a = gen_lea_modrm_0(env, s, modrm); gen_exts(ot, cpu_T1); tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot); tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot); tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0); gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override); if (!(s->prefix & PREFIX_LOCK)) { gen_op_ld_v(s, ot, cpu_T0, cpu_A0); } } else { gen_op_mov_v_reg(ot, cpu_T0, rm); } bt_op: tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1); tcg_gen_movi_tl(cpu_tmp0, 1); tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1); if (s->prefix & PREFIX_LOCK) { switch (op) { case 0: gen_op_ld_v(s, ot, cpu_T0, cpu_A0); break; case 1: tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0, s->mem_index, ot | MO_LE); break; case 2: tcg_gen_not_tl(cpu_tmp0, cpu_tmp0); tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0, s->mem_index, ot | MO_LE); break; default: case 3: tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0, s->mem_index, ot | MO_LE); break; } tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1); } else { tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1); switch (op) { case 0: break; case 1: tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0); break; case 2: tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0); break; default: case 3: tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0); break; } if (op != 0) { if (mod != 3) { gen_op_st_v(s, ot, cpu_T0, cpu_A0); } else { gen_op_mov_reg_v(ot, rm, cpu_T0); } } } switch (s->cc_op) { case CC_OP_MULB ... CC_OP_MULQ: case CC_OP_ADDB ... CC_OP_ADDQ: case CC_OP_ADCB ... CC_OP_ADCQ: case CC_OP_SUBB ... CC_OP_SUBQ: case CC_OP_SBBB ... CC_OP_SBBQ: case CC_OP_LOGICB ... CC_OP_LOGICQ: case CC_OP_INCB ... CC_OP_INCQ: case CC_OP_DECB ... CC_OP_DECQ: case CC_OP_SHLB ... CC_OP_SHLQ: case CC_OP_SARB ... CC_OP_SARQ: case CC_OP_BMILGB ... CC_OP_BMILGQ: tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4); set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB); break; default: gen_compute_eflags(s); tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4, ctz32(CC_C), 1); break; } break; case 0x1bc: case 0x1bd: ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_extu(ot, cpu_T0); if ((prefixes & PREFIX_REPZ) && (b & 1 ? s->cpuid_ext3_features & CPUID_EXT3_ABM : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) { int size = 8 << ot; tcg_gen_mov_tl(cpu_cc_src, cpu_T0); if (b & 1) { tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS); tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size); } else { tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size); } gen_op_update1_cc(); set_cc_op(s, CC_OP_BMILGB + ot); } else { tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); set_cc_op(s, CC_OP_LOGICB + ot); if (b & 1) { tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1); tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1); tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1); } else { tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]); } } gen_op_mov_reg_v(ot, reg, cpu_T0); break; case 0x27: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_daa(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x2f: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_das(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x37: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_aaa(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x3f: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_aas(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0xd4: if (CODE64(s)) goto illegal_op; val = x86_ldub_code(env, s); if (val == 0) { gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base); } else { gen_helper_aam(cpu_env, tcg_const_i32(val)); set_cc_op(s, CC_OP_LOGICB); } break; case 0xd5: if (CODE64(s)) goto illegal_op; val = x86_ldub_code(env, s); gen_helper_aad(cpu_env, tcg_const_i32(val)); set_cc_op(s, CC_OP_LOGICB); break; case 0x90: if (prefixes & PREFIX_LOCK) { goto illegal_op; } if (REX_B(s)) { goto do_xchg_reg_eax; } if (prefixes & PREFIX_REPZ) { gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start)); s->base.is_jmp = DISAS_NORETURN; } break; case 0x9b: if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) == (HF_MP_MASK | HF_TS_MASK)) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); } else { gen_helper_fwait(cpu_env); } break; case 0xcc: gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base); break; case 0xcd: val = x86_ldub_code(env, s); if (s->vm86 && s->iopl != 3) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base); } break; case 0xce: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start)); break; #ifdef WANT_ICEBP case 0xf1: gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP); #if 1 gen_debug(s, pc_start - s->cs_base); #else tb_flush(CPU(x86_env_get_cpu(env))); qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM); #endif break; #endif case 0xfa: if (!s->vm86) { if (s->cpl <= s->iopl) { gen_helper_cli(cpu_env); } else { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } } else { if (s->iopl == 3) { gen_helper_cli(cpu_env); } else { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } } break; case 0xfb: if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) { gen_helper_sti(cpu_env); gen_jmp_im(s->pc - s->cs_base); gen_eob_inhibit_irq(s, "True" == "True"); } else { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } break; case 0x62: if (CODE64(s)) goto illegal_op; ot = dflag; modrm = x86_ldub_code(env, s); reg = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; if (mod == 3) goto illegal_op; gen_op_mov_v_reg(ot, cpu_T0, reg); gen_lea_modrm(env, s, modrm); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); if (ot == MO_16) { gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32); } else { gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32); } break; case 0x1c8 ... 0x1cf: reg = (b & 7) | REX_B(s); #ifdef TARGET_X86_64 if (dflag == MO_64) { gen_op_mov_v_reg(MO_64, cpu_T0, reg); tcg_gen_bswap64_i64(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_64, reg, cpu_T0); } else #endif { gen_op_mov_v_reg(MO_32, cpu_T0, reg); tcg_gen_ext32u_tl(cpu_T0, cpu_T0); tcg_gen_bswap32_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_32, reg, cpu_T0); } break; case 0xd6: if (CODE64(s)) goto illegal_op; gen_compute_eflags_c(s, cpu_T0); tcg_gen_neg_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0); break; case 0xe0: case 0xe1: case 0xe2: case 0xe3: { TCGLabel *l1, *l2, *l3; tval = (int8_t)insn_get(env, s, MO_8); next_eip = s->pc - s->cs_base; tval += next_eip; if (dflag == MO_16) { tval &= 0xffff; } l1 = gen_new_label(); l2 = gen_new_label(); l3 = gen_new_label(); b &= 3; switch(b) { case 0: case 1: gen_op_add_reg_im(s->aflag, R_ECX, -1); gen_op_jz_ecx(s->aflag, l3); gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1); break; case 2: gen_op_add_reg_im(s->aflag, R_ECX, -1); gen_op_jnz_ecx(s->aflag, l1); break; default: case 3: gen_op_jz_ecx(s->aflag, l1); break; } gen_set_label(l3); gen_jmp_im(next_eip); tcg_gen_br(l2); gen_set_label(l1); gen_jmp_im(tval); gen_set_label(l2); gen_eob(s); } break; case 0x130: case 0x132: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); if (b & 2) { gen_helper_rdmsr(cpu_env); } else { gen_helper_wrmsr(cpu_env); } } break; case 0x131: gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } gen_helper_rdtsc(cpu_env); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; case 0x133: gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_rdpmc(cpu_env); break; case 0x134: if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1) goto illegal_op; if (!s->pe) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_helper_sysenter(cpu_env); gen_eob(s); } break; case 0x135: if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1) goto illegal_op; if (!s->pe) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1)); gen_eob(s); } break; #ifdef TARGET_X86_64 case 0x105: gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start)); gen_eob_worker(s, "False" != "False", "True" == "True"); break; case 0x107: if (!s->pe) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1)); if (s->lma) { set_cc_op(s, CC_OP_EFLAGS); } gen_eob_worker(s, "False" != "False", "True" == "True"); } break; #endif case 0x1a2: gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_cpuid(cpu_env); break; case 0xf4: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start)); s->base.is_jmp = DISAS_NORETURN; } break; case 0x100: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; op = (modrm >> 3) & 7; switch(op) { case 0: if (!s->pe || s->vm86) goto illegal_op; gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, ldt.selector)); ot = mod == 3 ? dflag : MO_16; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 2: if (!s->pe || s->vm86) goto illegal_op; if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE); gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_lldt(cpu_env, cpu_tmp2_i32); } break; case 1: if (!s->pe || s->vm86) goto illegal_op; gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, tr.selector)); ot = mod == 3 ? dflag : MO_16; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 3: if (!s->pe || s->vm86) goto illegal_op; if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE); gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_ltr(cpu_env, cpu_tmp2_i32); } break; case 4: case 5: if (!s->pe || s->vm86) goto illegal_op; gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); gen_update_cc_op(s); if (op == 4) { gen_helper_verr(cpu_env, cpu_T0); } else { gen_helper_verw(cpu_env, cpu_T0); } set_cc_op(s, CC_OP_EFLAGS); break; default: goto unknown_op; } break; case 0x101: modrm = x86_ldub_code(env, s); switch (modrm) { CASE_MODRM_MEM_OP(0): gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ); gen_lea_modrm(env, s, modrm); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.limit)); gen_op_st_v(s, MO_16, cpu_T0, cpu_A0); gen_add_A0_im(s, 2); tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base)); if (dflag == MO_16) { tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); } gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); break; case 0xc8: if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) { goto illegal_op; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]); gen_extu(s->aflag, cpu_A0); gen_add_A0_ds_seg(s); gen_helper_monitor(cpu_env, cpu_A0); break; case 0xc9: if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) { goto illegal_op; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start)); gen_eob(s); break; case 0xca: if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP) || s->cpl != 0) { goto illegal_op; } gen_helper_clac(cpu_env); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; case 0xcb: if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP) || s->cpl != 0) { goto illegal_op; } gen_helper_stac(cpu_env); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; CASE_MODRM_MEM_OP(1): gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ); gen_lea_modrm(env, s, modrm); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit)); gen_op_st_v(s, MO_16, cpu_T0, cpu_A0); gen_add_A0_im(s, 2); tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base)); if (dflag == MO_16) { tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); } gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); break; case 0xd0: if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (s->prefix & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) { goto illegal_op; } tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]); gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32); tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64); break; case 0xd1: if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (s->prefix & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX], cpu_regs[R_EDX]); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]); gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; case 0xd8: if (!(s->flags & HF_SVME_MASK) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1), tcg_const_i32(s->pc - pc_start)); tcg_gen_exit_tb(0); s->base.is_jmp = DISAS_NORETURN; break; case 0xd9: if (!(s->flags & HF_SVME_MASK)) { goto illegal_op; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_vmmcall(cpu_env); break; case 0xda: if (!(s->flags & HF_SVME_MASK) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1)); break; case 0xdb: if (!(s->flags & HF_SVME_MASK) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1)); break; case 0xdc: if ((!(s->flags & HF_SVME_MASK) && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT)) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_stgi(cpu_env); break; case 0xdd: if (!(s->flags & HF_SVME_MASK) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_clgi(cpu_env); break; case 0xde: if ((!(s->flags & HF_SVME_MASK) && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT)) || !s->pe) { goto illegal_op; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_skinit(cpu_env); break; case 0xdf: if (!(s->flags & HF_SVME_MASK) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1)); break; CASE_MODRM_MEM_OP(2): if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE); gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0); gen_add_A0_im(s, 2); gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); if (dflag == MO_16) { tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); } tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base)); tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit)); break; CASE_MODRM_MEM_OP(3): if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE); gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0); gen_add_A0_im(s, 2); gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); if (dflag == MO_16) { tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); } tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base)); tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit)); break; CASE_MODRM_OP(4): gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0); tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0])); if (CODE64(s)) { mod = (modrm >> 6) & 3; ot = (mod != 3 ? MO_16 : s->dflag); } else { ot = MO_16; } gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 0xee: if (prefixes & PREFIX_LOCK) { goto illegal_op; } tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]); gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32); tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64); break; case 0xef: if (prefixes & PREFIX_LOCK) { goto illegal_op; } tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX], cpu_regs[R_EDX]); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]); gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64); break; CASE_MODRM_OP(6): if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0); gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); gen_helper_lmsw(cpu_env, cpu_T0); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; CASE_MODRM_MEM_OP(7): if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_lea_modrm(env, s, modrm); gen_helper_invlpg(cpu_env, cpu_A0); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; case 0xf8: #ifdef TARGET_X86_64 if (CODE64(s)) { if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]); tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env, offsetof(CPUX86State, kernelgsbase)); tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, kernelgsbase)); } break; } #endif goto illegal_op; case 0xf9: if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) { goto illegal_op; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } gen_helper_rdtscp(cpu_env); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; default: goto unknown_op; } break; case 0x108: case 0x109: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD); } break; case 0x63: #ifdef TARGET_X86_64 if (CODE64(s)) { int d_ot; d_ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod == 3) { gen_op_mov_v_reg(MO_32, cpu_T0, rm); if (d_ot == MO_64) { tcg_gen_ext32s_tl(cpu_T0, cpu_T0); } gen_op_mov_reg_v(d_ot, reg, cpu_T0); } else { gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0); gen_op_mov_reg_v(d_ot, reg, cpu_T0); } } else #endif { TCGLabel *label1; TCGv t0, t1, t2, a0; if (!s->pe || s->vm86) goto illegal_op; t0 = tcg_temp_local_new(); t1 = tcg_temp_local_new(); t2 = tcg_temp_local_new(); ot = MO_16; modrm = x86_ldub_code(env, s); reg = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; rm = modrm & 7; if (mod != 3) { gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, t0, cpu_A0); a0 = tcg_temp_local_new(); tcg_gen_mov_tl(a0, cpu_A0); } else { gen_op_mov_v_reg(ot, t0, rm); TCGV_UNUSED(a0); } gen_op_mov_v_reg(ot, t1, reg); tcg_gen_andi_tl(cpu_tmp0, t0, 3); tcg_gen_andi_tl(t1, t1, 3); tcg_gen_movi_tl(t2, 0); label1 = gen_new_label(); tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1); tcg_gen_andi_tl(t0, t0, ~3); tcg_gen_or_tl(t0, t0, t1); tcg_gen_movi_tl(t2, CC_Z); gen_set_label(label1); if (mod != 3) { gen_op_st_v(s, ot, t0, a0); tcg_temp_free(a0); } else { gen_op_mov_reg_v(ot, rm, t0); } gen_compute_eflags(s); tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z); tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2); tcg_temp_free(t0); tcg_temp_free(t1); tcg_temp_free(t2); } break; case 0x102: case 0x103: { TCGLabel *label1; TCGv t0; if (!s->pe || s->vm86) goto illegal_op; ot = dflag != MO_16 ? MO_32 : MO_16; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); t0 = tcg_temp_local_new(); gen_update_cc_op(s); if (b == 0x102) { gen_helper_lar(t0, cpu_env, cpu_T0); } else { gen_helper_lsl(t0, cpu_env, cpu_T0); } tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z); label1 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1); gen_op_mov_reg_v(ot, reg, t0); gen_set_label(label1); set_cc_op(s, CC_OP_EFLAGS); tcg_temp_free(t0); } break; case 0x118: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; op = (modrm >> 3) & 7; switch(op) { case 0: case 1: case 2: case 3: if (mod == 3) goto illegal_op; gen_nop_modrm(env, s, modrm); break; default: gen_nop_modrm(env, s, modrm); break; } break; case 0x11a: modrm = x86_ldub_code(env, s); if (s->flags & HF_MPX_EN_MASK) { mod = (modrm >> 6) & 3; reg = ((modrm >> 3) & 7) | rex_r; if (prefixes & PREFIX_REPZ) { if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16) { goto illegal_op; } gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]); } else if (prefixes & PREFIX_REPNZ) { if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16) { goto illegal_op; } TCGv_i64 notu = tcg_temp_new_i64(); tcg_gen_not_i64(notu, cpu_bndu[reg]); gen_bndck(env, s, modrm, TCG_COND_GTU, notu); tcg_temp_free_i64(notu); } else if (prefixes & PREFIX_DATA) { if (reg >= 4 || s->aflag == MO_16) { goto illegal_op; } if (mod == 3) { int reg2 = (modrm & 7) | REX_B(s); if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) { goto illegal_op; } if (s->flags & HF_MPX_IU_MASK) { tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]); tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]); } } else { gen_lea_modrm(env, s, modrm); if (CODE64(s)) { tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0, s->mem_index, MO_LEQ); tcg_gen_addi_tl(cpu_A0, cpu_A0, 8); tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0, s->mem_index, MO_LEQ); } else { tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0, s->mem_index, MO_LEUL); tcg_gen_addi_tl(cpu_A0, cpu_A0, 4); tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0, s->mem_index, MO_LEUL); } gen_set_hflag(s, HF_MPX_IU_MASK); } } else if (mod != 3) { AddressParts a = gen_lea_modrm_0(env, s, modrm); if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16 || a.base < -1) { goto illegal_op; } if (a.base >= 0) { tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp); } else { tcg_gen_movi_tl(cpu_A0, 0); } gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override); if (a.index >= 0) { tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]); } else { tcg_gen_movi_tl(cpu_T0, 0); } if (CODE64(s)) { gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0); tcg_gen_ld_i64(cpu_bndu[reg], cpu_env, offsetof(CPUX86State, mmx_t0.MMX_Q(0))); } else { gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0); tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]); tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32); } gen_set_hflag(s, HF_MPX_IU_MASK); } } gen_nop_modrm(env, s, modrm); break; case 0x11b: modrm = x86_ldub_code(env, s); if (s->flags & HF_MPX_EN_MASK) { mod = (modrm >> 6) & 3; reg = ((modrm >> 3) & 7) | rex_r; if (mod != 3 && (prefixes & PREFIX_REPZ)) { if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16) { goto illegal_op; } AddressParts a = gen_lea_modrm_0(env, s, modrm); if (a.base >= 0) { tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]); if (!CODE64(s)) { tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]); } } else if (a.base == -1) { tcg_gen_movi_i64(cpu_bndl[reg], 0); } else { goto illegal_op; } tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a)); if (!CODE64(s)) { tcg_gen_ext32u_tl(cpu_A0, cpu_A0); } tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0); gen_set_hflag(s, HF_MPX_IU_MASK); break; } else if (prefixes & PREFIX_REPNZ) { if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16) { goto illegal_op; } gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]); } else if (prefixes & PREFIX_DATA) { if (reg >= 4 || s->aflag == MO_16) { goto illegal_op; } if (mod == 3) { int reg2 = (modrm & 7) | REX_B(s); if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) { goto illegal_op; } if (s->flags & HF_MPX_IU_MASK) { tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]); tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]); } } else { gen_lea_modrm(env, s, modrm); if (CODE64(s)) { tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0, s->mem_index, MO_LEQ); tcg_gen_addi_tl(cpu_A0, cpu_A0, 8); tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0, s->mem_index, MO_LEQ); } else { tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0, s->mem_index, MO_LEUL); tcg_gen_addi_tl(cpu_A0, cpu_A0, 4); tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0, s->mem_index, MO_LEUL); } } } else if (mod != 3) { AddressParts a = gen_lea_modrm_0(env, s, modrm); if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16 || a.base < -1) { goto illegal_op; } if (a.base >= 0) { tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp); } else { tcg_gen_movi_tl(cpu_A0, 0); } gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override); if (a.index >= 0) { tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]); } else { tcg_gen_movi_tl(cpu_T0, 0); } if (CODE64(s)) { gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0, cpu_bndl[reg], cpu_bndu[reg]); } else { gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0, cpu_bndl[reg], cpu_bndu[reg]); } } } gen_nop_modrm(env, s, modrm); break; case 0x119: case 0x11c ... 0x11f: modrm = x86_ldub_code(env, s); gen_nop_modrm(env, s, modrm); break; case 0x120: case 0x122: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { modrm = x86_ldub_code(env, s); rm = (modrm & 7) | REX_B(s); reg = ((modrm >> 3) & 7) | rex_r; if (CODE64(s)) ot = MO_64; else ot = MO_32; if ((prefixes & PREFIX_LOCK) && (reg == 0) && (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) { reg = 8; } switch(reg) { case 0: case 2: case 3: case 4: case 8: gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); if (b & 2) { if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } gen_op_mov_v_reg(ot, cpu_T0, rm); gen_helper_write_crN(cpu_env, tcg_const_i32(reg), cpu_T0); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); } gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } else { if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg)); gen_op_mov_reg_v(ot, rm, cpu_T0); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); } } break; default: goto unknown_op; } } break; case 0x121: case 0x123: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { modrm = x86_ldub_code(env, s); rm = (modrm & 7) | REX_B(s); reg = ((modrm >> 3) & 7) | rex_r; if (CODE64(s)) ot = MO_64; else ot = MO_32; if (reg >= 8) { goto illegal_op; } if (b & 2) { gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg); gen_op_mov_v_reg(ot, cpu_T0, rm); tcg_gen_movi_i32(cpu_tmp2_i32, reg); gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } else { gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg); tcg_gen_movi_i32(cpu_tmp2_i32, reg); gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32); gen_op_mov_reg_v(ot, rm, cpu_T0); } } break; case 0x106: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0); gen_helper_clts(cpu_env); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } break; case 0x1c3: if (!(s->cpuid_features & CPUID_SSE2)) goto illegal_op; ot = mo_64_32(dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; if (mod == 3) goto illegal_op; reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, reg, 1); break; case 0x1ae: modrm = x86_ldub_code(env, s); switch (modrm) { CASE_MODRM_MEM_OP(0): if (!(s->cpuid_features & CPUID_FXSR) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); break; } gen_lea_modrm(env, s, modrm); gen_helper_fxsave(cpu_env, cpu_A0); break; CASE_MODRM_MEM_OP(1): if (!(s->cpuid_features & CPUID_FXSR) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); break; } gen_lea_modrm(env, s, modrm); gen_helper_fxrstor(cpu_env, cpu_A0); break; CASE_MODRM_MEM_OP(2): if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) { goto illegal_op; } if (s->flags & HF_TS_MASK) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); break; } gen_lea_modrm(env, s, modrm); tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32); break; CASE_MODRM_MEM_OP(3): if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) { goto illegal_op; } if (s->flags & HF_TS_MASK) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); break; } gen_lea_modrm(env, s, modrm); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr)); gen_op_st_v(s, MO_32, cpu_T0, cpu_A0); break; CASE_MODRM_MEM_OP(4): if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (prefixes & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) { goto illegal_op; } gen_lea_modrm(env, s, modrm); tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX], cpu_regs[R_EDX]); gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64); break; CASE_MODRM_MEM_OP(5): if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (prefixes & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) { goto illegal_op; } gen_lea_modrm(env, s, modrm); tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX], cpu_regs[R_EDX]); gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64); gen_update_cc_op(s); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; CASE_MODRM_MEM_OP(6): if (prefixes & PREFIX_LOCK) { goto illegal_op; } if (prefixes & PREFIX_DATA) { if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) { goto illegal_op; } gen_nop_modrm(env, s, modrm); } else { if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0 || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) { goto illegal_op; } gen_lea_modrm(env, s, modrm); tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX], cpu_regs[R_EDX]); gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64); } break; CASE_MODRM_MEM_OP(7): if (prefixes & PREFIX_LOCK) { goto illegal_op; } if (prefixes & PREFIX_DATA) { if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) { goto illegal_op; } } else { if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ)) || !(s->cpuid_features & CPUID_CLFLUSH)) { goto illegal_op; } } gen_nop_modrm(env, s, modrm); break; case 0xc0 ... 0xc7: case 0xc8 ... 0xcf: case 0xd0 ... 0xd7: case 0xd8 ... 0xdf: if (CODE64(s) && (prefixes & PREFIX_REPZ) && !(prefixes & PREFIX_LOCK) && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) { TCGv base, treg, src, dst; tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK); gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32); base = cpu_seg_base[modrm & 8 ? R_GS : R_FS]; treg = cpu_regs[(modrm & 7) | REX_B(s)]; if (modrm & 0x10) { dst = base, src = treg; } else { dst = treg, src = base; } if (s->dflag == MO_32) { tcg_gen_ext32u_tl(dst, src); } else { tcg_gen_mov_tl(dst, src); } break; } goto unknown_op; case 0xf8: if (prefixes & PREFIX_DATA) { if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } break; } case 0xf9 ... 0xff: if (!(s->cpuid_features & CPUID_SSE) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC); break; case 0xe8 ... 0xef: if (!(s->cpuid_features & CPUID_SSE) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC); break; case 0xf0 ... 0xf7: if (!(s->cpuid_features & CPUID_SSE2) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC); break; default: goto unknown_op; } break; case 0x10d: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; if (mod == 3) goto illegal_op; gen_nop_modrm(env, s, modrm); break; case 0x1aa: gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM); if (!(s->flags & HF_SMM_MASK)) goto illegal_op; gen_update_cc_op(s); gen_jmp_im(s->pc - s->cs_base); gen_helper_rsm(cpu_env); gen_eob(s); break; case 0x1b8: if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) != PREFIX_REPZ) goto illegal_op; if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT)) goto illegal_op; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; if (s->prefix & PREFIX_DATA) { ot = MO_16; } else { ot = mo_64_32(dflag); } gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_extu(ot, cpu_T0); tcg_gen_mov_tl(cpu_cc_src, cpu_T0); tcg_gen_ctpop_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(ot, reg, cpu_T0); set_cc_op(s, CC_OP_POPCNT); break; case 0x10e ... 0x10f: s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA); case 0x110 ... 0x117: case 0x128 ... 0x12f: case 0x138 ... 0x13a: case 0x150 ... 0x179: case 0x17c ... 0x17f: case 0x1c2: case 0x1c4 ... 0x1c6: case 0x1d0 ... 0x1fe: gen_sse(env, s, b, pc_start, rex_r); break; default: goto unknown_op; } return s->pc; illegal_op: gen_illegal_opcode(s); return s->pc; unknown_op: gen_unknown_opcode(env, s); return s->pc; }[Succeeded / Failed / Skipped / Total] 24 / 0 / 21 / 45:   2%|         | 45/2690 [03:04<3:01:01,  4.11s/it][Succeeded / Failed / Skipped / Total] 24 / 0 / 21 / 45:   2%|         | 46/2690 [03:05<2:57:30,  4.03s/it][Succeeded / Failed / Skipped / Total] 24 / 0 / 22 / 46:   2%|         | 46/2690 [03:05<2:57:30,  4.03s/it][Succeeded / Failed / Skipped / Total] 24 / 0 / 22 / 46:   2%|         | 47/2690 [03:23<3:10:28,  4.32s/it][Succeeded / Failed / Skipped / Total] 25 / 0 / 22 / 47:   2%|         | 47/2690 [03:23<3:10:28,  4.32s/it][Succeeded / Failed / Skipped / Total] 25 / 0 / 22 / 47:   2%|         | 48/2690 [03:23<3:06:54,  4.24s/it][Succeeded / Failed / Skipped / Total] 25 / 0 / 23 / 48:   2%|         | 48/2690 [03:23<3:06:54,  4.24s/it][Succeeded / Failed / Skipped / Total] 25 / 0 / 23 / 48:   2%|         | 49/2690 [03:30<3:08:59,  4.29s/it]
--------------------------------------------- Result 46 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int iscsi_open(BlockDriverState *bs, const char *filename, int flags) { IscsiLun *iscsilun = bs->opaque; struct iscsi_context *iscsi = NULL; struct iscsi_url *iscsi_url = NULL; struct IscsiTask task; char *initiator_name = NULL; int ret; if ((BDRV_SECTOR_SIZE % 512) != 0) { error_report("iSCSI: Invalid BDRV_SECTOR_SIZE. " "BDRV_SECTOR_SIZE(%lld) is not a multiple " "of 512", BDRV_SECTOR_SIZE); return -EINVAL; } iscsi_url = iscsi_parse_full_url(iscsi, filename); if (iscsi_url == NULL) { error_report("Failed to parse URL : %s %s", filename, iscsi_get_error(iscsi)); ret = -EINVAL; goto failed; } memset(iscsilun, 0, sizeof(IscsiLun)); initiator_name = parse_initiator_name(iscsi_url->target); iscsi = iscsi_create_context(initiator_name); if (iscsi == NULL) { error_report("iSCSI: Failed to create iSCSI context."); ret = -ENOMEM; goto failed; } if (iscsi_set_targetname(iscsi, iscsi_url->target)) { error_report("iSCSI: Failed to set target name."); ret = -EINVAL; goto failed; } if (iscsi_url->user != NULL) { ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user, iscsi_url->passwd); if (ret != 0) { error_report("Failed to set initiator username and password"); ret = -EINVAL; goto failed; } } if (parse_chap(iscsi, iscsi_url->target) != 0) { error_report("iSCSI: Failed to set CHAP user/password"); ret = -EINVAL; goto failed; } if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) { error_report("iSCSI: Failed to set session type to normal."); ret = -EINVAL; goto failed; } iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C); parse_header_digest(iscsi, iscsi_url->target); task.iscsilun = iscsilun; task.status = 0; task.complete = 0; task.bs = bs; iscsilun->iscsi = iscsi; iscsilun->lun = iscsi_url->lun; if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun, iscsi_connect_cb, &task) != 0) { error_report("iSCSI: Failed to start async connect."); ret = -EINVAL; goto failed; } while (!task.complete) { iscsi_set_events(iscsilun); qemu_aio_wait(); } if (task.status != 0) { error_report("iSCSI: Failed to connect to LUN : %s", iscsi_get_error(iscsi)); ret = -EINVAL; goto failed; } if (iscsi_url != NULL) { iscsi_destroy_url(iscsi_url); } if (iscsilun->type == TYPE_MEDIUM_CHANGER || iscsilun->type == TYPE_TAPE) { bs->sg = 1; } return 0; failed: if (initiator_name != NULL) { g_free(initiator_name); } if (iscsi_url != NULL) { iscsi_destroy_url(iscsi_url); } if (iscsi != NULL) { iscsi_destroy_context(iscsi); } memset(iscsilun, 0, sizeof(IscsiLun)); return ret; }
--------------------------------------------- Result 47 ---------------------------------------------
[[0 (26%)]] --> [[0 (72%)]] --> Socre: 0.7188898921012878

[[[[Adv]]]]: static void fpu_init (CPUMIPSState *[[env]], const mips_def_t *def) { int i; for (i = 0; i < MIPS_FPU_MAX; i++) [[env]]->fpus[i].fcr0 = def->CP1_fcr0; memcpy(&[[env]]->active_fpu, &[[env]]->fpus[0], sizeof([[env]]->active_fpu)); if ([[env]]->user_mode_only) { if ([[env]]->CP0_Config1 & (1 << CP0C1_FP)) [[env]]->hflags |= MIPS_HFLAG_FPU; #ifdef TARGET_MIPS64 if ([[env]]->active_fpu.fcr0 & (1 << FCR0_F64)) [[env]]->hflags |= MIPS_HFLAG_F64; #endif } }

[[[[Adv]]]]: static void fpu_init (CPUMIPSState *[[eerie]], const mips_def_t *def) { int i; for (i = 0; i < MIPS_FPU_MAX; i++) [[eerie]]->fpus[i].fcr0 = def->CP1_fcr0; memcpy(&[[eerie]]->active_fpu, &[[eerie]]->fpus[0], sizeof([[eerie]]->active_fpu)); if ([[eerie]]->user_mode_only) { if ([[eerie]]->CP0_Config1 & (1 << CP0C1_FP)) [[eerie]]->hflags |= MIPS_HFLAG_FPU; #ifdef TARGET_MIPS64 if ([[eerie]]->active_fpu.fcr0 & (1 << FCR0_F64)) [[eerie]]->hflags |= MIPS_HFLAG_F64; #endif } }
--------------------------------------------- Result 48 ---------------------------------------------
[[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: CommandInfoList *qmp_query_commands(Error **errp) { CommandInfoList *list = NULL; qmp_for_each_command(&qmp_commands, query_commands_cb, &list); return list; }
--------------------------------------------- Result 49 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 26 / 0 / 23 / 49:   2%|         | 49/2690 [03:30<3:08:59,  4.29s/it][Succeeded / Failed / Skipped / Total] 26 / 0 / 23 / 49:   2%|         | 50/2690 [03:30<3:05:34,  4.22s/it][Succeeded / Failed / Skipped / Total] 26 / 0 / 24 / 50:   2%|         | 50/2690 [03:30<3:05:34,  4.22s/it][Succeeded / Failed / Skipped / Total] 26 / 0 / 24 / 50:   2%|         | 51/2690 [03:38<3:08:44,  4.29s/it][[0 (62%)]] --> [[0 (40%)]] --> Socre: 0.6020467281341553

[[[[Adv]]]]: static int bfi_decode_frame(AVCodecContext *avctx, void *[[data]], int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size; int buf_size = avpkt->size; BFIContext *bfi = avctx->priv_data; uint8_t *dst = bfi->dst; uint8_t *src, *dst_offset, colour1, colour2; uint8_t *frame_end = bfi->dst + avctx->width * avctx->height; uint32_t *pal; int i, j, height = avctx->height; if (bfi->frame.data[0]) avctx->release_buffer(avctx, &bfi->frame); bfi->frame.reference = 1; if (avctx->get_buffer(avctx, &bfi->frame) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return -1; } if (!avctx->frame_number) { bfi->frame.pict_type = AV_PICTURE_TYPE_I; bfi->frame.key_frame = 1; if (avctx->extradata_size > 768) { av_log(NULL, AV_LOG_ERROR, "Palette is too large.\n"); return -1; } pal = (uint32_t *)bfi->frame.data[1]; for (i = 0; i < avctx->extradata_size / 3; i++) { int shift = 16; *pal = 0; for (j = 0; j < 3; j++, shift -= 8) *pal += ((avctx->extradata[i * 3 + j] << 2) | (avctx->extradata[i * 3 + j] >> 4)) << shift; pal++; } bfi->frame.palette_has_changed = 1; } else { bfi->frame.pict_type = AV_PICTURE_TYPE_P; bfi->frame.key_frame = 0; } buf += 4; while (dst != frame_end) { static const uint8_t lentab[4] = { 0, 2, 0, 1 }; unsigned int byte = *buf++, av_uninit(offset); unsigned int code = byte >> 6; unsigned int length = byte & ~0xC0; if (buf >= buf_end) { av_log(avctx, AV_LOG_ERROR, "Input resolution larger than actual frame.\n"); return -1; } if (length == 0) { if (code == 1) { length = bytestream_get_byte(&buf); offset = bytestream_get_le16(&buf); } else { length = bytestream_get_le16(&buf); if (code == 2 && length == 0) break; } } else { if (code == 1) offset = bytestream_get_byte(&buf); } if (dst + (length << lentab[code]) > frame_end) break; switch (code) { case 0: if (length >= buf_end - buf) { av_log(avctx, AV_LOG_ERROR, "Frame larger than buffer.\n"); return -1; } bytestream_get_buffer(&buf, dst, length); dst += length; break; case 1: dst_offset = dst - offset; length *= 4; if (dst_offset < bfi->dst) break; while (length--) *dst++ = *dst_offset++; break; case 2: dst += length; break; case 3: colour1 = bytestream_get_byte(&buf); colour2 = bytestream_get_byte(&buf); while (length--) { *dst++ = colour1; *dst++ = colour2; } break; } } src = bfi->dst; dst = bfi->frame.data[0]; while (height--) { memcpy(dst, src, avctx->width); src += avctx->width; dst += bfi->frame.linesize[0]; } *data_size = sizeof(AVFrame); *(AVFrame *)[[data]] = bfi->frame; return buf_size; }

[[[[Adv]]]]: static int bfi_decode_frame(AVCodecContext *avctx, void *[[numbers]], int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size; int buf_size = avpkt->size; BFIContext *bfi = avctx->priv_data; uint8_t *dst = bfi->dst; uint8_t *src, *dst_offset, colour1, colour2; uint8_t *frame_end = bfi->dst + avctx->width * avctx->height; uint32_t *pal; int i, j, height = avctx->height; if (bfi->frame.data[0]) avctx->release_buffer(avctx, &bfi->frame); bfi->frame.reference = 1; if (avctx->get_buffer(avctx, &bfi->frame) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return -1; } if (!avctx->frame_number) { bfi->frame.pict_type = AV_PICTURE_TYPE_I; bfi->frame.key_frame = 1; if (avctx->extradata_size > 768) { av_log(NULL, AV_LOG_ERROR, "Palette is too large.\n"); return -1; } pal = (uint32_t *)bfi->frame.data[1]; for (i = 0; i < avctx->extradata_size / 3; i++) { int shift = 16; *pal = 0; for (j = 0; j < 3; j++, shift -= 8) *pal += ((avctx->extradata[i * 3 + j] << 2) | (avctx->extradata[i * 3 + j] >> 4)) << shift; pal++; } bfi->frame.palette_has_changed = 1; } else { bfi->frame.pict_type = AV_PICTURE_TYPE_P; bfi->frame.key_frame = 0; } buf += 4; while (dst != frame_end) { static const uint8_t lentab[4] = { 0, 2, 0, 1 }; unsigned int byte = *buf++, av_uninit(offset); unsigned int code = byte >> 6; unsigned int length = byte & ~0xC0; if (buf >= buf_end) { av_log(avctx, AV_LOG_ERROR, "Input resolution larger than actual frame.\n"); return -1; } if (length == 0) { if (code == 1) { length = bytestream_get_byte(&buf); offset = bytestream_get_le16(&buf); } else { length = bytestream_get_le16(&buf); if (code == 2 && length == 0) break; } } else { if (code == 1) offset = bytestream_get_byte(&buf); } if (dst + (length << lentab[code]) > frame_end) break; switch (code) { case 0: if (length >= buf_end - buf) { av_log(avctx, AV_LOG_ERROR, "Frame larger than buffer.\n"); return -1; } bytestream_get_buffer(&buf, dst, length); dst += length; break; case 1: dst_offset = dst - offset; length *= 4; if (dst_offset < bfi->dst) break; while (length--) *dst++ = *dst_offset++; break; case 2: dst += length; break; case 3: colour1 = bytestream_get_byte(&buf); colour2 = bytestream_get_byte(&buf); while (length--) { *dst++ = colour1; *dst++ = colour2; } break; } } src = bfi->dst; dst = bfi->frame.data[0]; while (height--) { memcpy(dst, src, avctx->width); src += avctx->width; dst += bfi->frame.linesize[0]; } *data_size = sizeof(AVFrame); *(AVFrame *)[[numbers]] = bfi->frame; return buf_size; }
--------------------------------------------- Result 50 ---------------------------------------------
[[0 (57%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int write_f(int argc, char **argv) { struct timeval t1, t2; int Cflag = 0, pflag = 0, qflag = 0, bflag = 0; int c, cnt; char *buf; int64_t offset; int count; int total = 0; int pattern = 0xcd; while ((c = getopt(argc, argv, "bCpP:q")) != EOF) { switch (c) { case 'b': bflag = 1; break; case 'C': Cflag = 1; break; case 'p': pflag = 1; break; case 'P': pattern = parse_pattern(optarg); if (pattern < 0) { return 0; } break; case 'q': qflag = 1; break; default: return command_usage(&write_cmd); } } if (optind != argc - 2) { return command_usage(&write_cmd); } if (bflag && pflag) { printf("-b and -p cannot be specified at the same time\n"); return 0; } offset = cvtnum(argv[optind]); if (offset < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } optind++; count = cvtnum(argv[optind]); if (count < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } if (!pflag) { if (offset & 0x1ff) { printf("offset %" PRId64 " is not sector aligned\n", offset); return 0; } if (count & 0x1ff) { printf("count %d is not sector aligned\n", count); return 0; } } buf = qemu_io_alloc(count, pattern); gettimeofday(&t1, NULL); if (pflag) { cnt = do_pwrite(buf, offset, count, &total); } else if (bflag) { cnt = do_save_vmstate(buf, offset, count, &total); } else { cnt = do_write(buf, offset, count, &total); } gettimeofday(&t2, NULL); if (cnt < 0) { printf("write failed: %s\n", strerror(-cnt)); goto out; } if (qflag) { goto out; } t2 = tsub(t2, t1); print_report("wrote", &t2, offset, count, total, cnt, Cflag); out: qemu_io_free(buf); return 0; }
--------------------------------------------- Result 51 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 27 / 0 / 24 / 51:   2%|         | 51/2690 [03:38<3:08:44,  4.29s/it][Succeeded / Failed / Skipped / Total] 27 / 0 / 24 / 51:   2%|         | 52/2690 [03:39<3:05:26,  4.22s/it][Succeeded / Failed / Skipped / Total] 27 / 0 / 25 / 52:   2%|         | 52/2690 [03:39<3:05:27,  4.22s/it][Succeeded / Failed / Skipped / Total] 27 / 0 / 25 / 52:   2%|         | 53/2690 [03:39<3:02:19,  4.15s/it][[0 (75%)]] --> [[0 (49%)]] --> Socre: 0.5142349898815155

[[[[Adv]]]]: static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt, const void *[[pkt_data]], size_t [[pkt_len]]) { struct virtio_net_hdr *[[vhdr]]; bool isip4, isip6, istcp, isudp; uint8_t *data; int len; if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) { return; } [[vhdr]] = vmxnet_rx_pkt_get_vhdr(pkt); if (!VMXNET_FLAG_IS_SET([[vhdr]]->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) { return; } vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp); if (!(isip4 || isip6) || !(istcp || isudp)) { return; } vmxnet3_dump_virt_hdr([[vhdr]]); if ([[pkt_len]] < ([[vhdr]]->csum_start + [[vhdr]]->csum_offset + 2)) { VMW_PKPRN("packet len:%d < csum_start(%d) + csum_offset(%d) + 2, " "cannot calculate checksum", len, [[vhdr]]->csum_start, [[vhdr]]->csum_offset); return; } data = (uint8_t *)[[pkt_data]] + [[vhdr]]->csum_start; len = [[pkt_len]] - [[vhdr]]->csum_start; stw_be_p(data + [[vhdr]]->csum_offset, net_raw_checksum(data, len)); [[vhdr]]->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM; [[vhdr]]->flags |= VIRTIO_NET_HDR_F_DATA_VALID; }

[[[[Adv]]]]: static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt, const void *[[grizzled]], size_t [[phenomena]]) { struct virtio_net_hdr *[[calle]]; bool isip4, isip6, istcp, isudp; uint8_t *data; int len; if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) { return; } [[calle]] = vmxnet_rx_pkt_get_vhdr(pkt); if (!VMXNET_FLAG_IS_SET([[calle]]->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) { return; } vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp); if (!(isip4 || isip6) || !(istcp || isudp)) { return; } vmxnet3_dump_virt_hdr([[calle]]); if ([[phenomena]] < ([[calle]]->csum_start + [[calle]]->csum_offset + 2)) { VMW_PKPRN("packet len:%d < csum_start(%d) + csum_offset(%d) + 2, " "cannot calculate checksum", len, [[calle]]->csum_start, [[calle]]->csum_offset); return; } data = (uint8_t *)[[grizzled]] + [[calle]]->csum_start; len = [[phenomena]] - [[calle]]->csum_start; stw_be_p(data + [[calle]]->csum_offset, net_raw_checksum(data, len)); [[calle]]->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM; [[calle]]->flags |= VIRTIO_NET_HDR_F_DATA_VALID; }
--------------------------------------------- Result 52 ---------------------------------------------
[[0 (98%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void build_feed_streams(void) { FFStream *stream, *feed; int i; for(stream = first_stream; stream != NULL; stream = stream->next) { feed = stream->feed; if (feed) { if (!stream->is_feed) { for(i=0;i<stream->nb_streams;i++) stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]); } } } for(stream = first_stream; stream != NULL; stream = stream->next) { feed = stream->feed; if (feed) { if (stream->is_feed) { for(i=0;i<stream->nb_streams;i++) stream->feed_streams[i] = i; } } } for(feed = first_feed; feed != NULL; feed = feed->next_feed) { int fd; if (url_exist(feed->feed_filename)) { AVFormatContext *s; int matches = 0; if (av_open_input_file(&s, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) { if (s->nb_streams == feed->nb_streams) { matches = 1; for(i=0;i<s->nb_streams;i++) { AVStream *sf, *ss; sf = feed->streams[i]; ss = s->streams[i]; if (sf->index != ss->index || sf->id != ss->id) { http_log("Index & Id do not match for stream %d (%s)\n", i, feed->feed_filename); matches = 0; } else { AVCodecContext *ccf, *ccs; ccf = sf->codec; ccs = ss->codec; #define CHECK_CODEC(x) (ccf->x != ccs->x) if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) { http_log("Codecs do not match for stream %d\n", i); matches = 0; } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) { http_log("Codec bitrates do not match for stream %d\n", i); matches = 0; } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) { if (CHECK_CODEC(time_base.den) || CHECK_CODEC(time_base.num) || CHECK_CODEC(width) || CHECK_CODEC(height)) { http_log("Codec width, height and framerate do not match for stream %d\n", i); matches = 0; } } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) { if (CHECK_CODEC(sample_rate) || CHECK_CODEC(channels) || CHECK_CODEC(frame_size)) { http_log("Codec sample_rate, channels, frame_size do not match for stream %d\n", i); matches = 0; } } else { http_log("Unknown codec type\n"); matches = 0; } } if (!matches) break; } } else http_log("Deleting feed file '%s' as stream counts differ (%d != %d)\n", feed->feed_filename, s->nb_streams, feed->nb_streams); av_close_input_file(s); } else http_log("Deleting feed file '%s' as it appears to be corrupt\n", feed->feed_filename); if (!matches) { if (feed->readonly) { http_log("Unable to delete feed file '%s' as it is marked readonly\n", feed->feed_filename); exit(1); } unlink(feed->feed_filename); } } if (!url_exist(feed->feed_filename)) { AVFormatContext s1 = {0}, *s = &s1; if (feed->readonly) { http_log("Unable to create feed file '%s' as it is marked readonly\n", feed->feed_filename); exit(1); } if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) { http_log("Could not open output feed file '%s'\n", feed->feed_filename); exit(1); } s->oformat = feed->fmt; s->nb_streams = feed->nb_streams; for(i=0;i<s->nb_streams;i++) { AVStream *st; st = feed->streams[i]; s->streams[i] = st; } av_set_parameters(s, NULL); if (av_write_header(s) < 0) { http_log("Container doesn't supports the required parameters\n"); exit(1); } av_freep(&s->priv_data); avio_close(s->pb); } fd = open(feed->feed_filename, O_RDONLY); if (fd < 0) { http_log("Could not open output feed file '%s'\n", feed->feed_filename); exit(1); } feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE); feed->feed_size = lseek(fd, 0, SEEK_END); if (feed->feed_max_size && feed->feed_max_size < feed->feed_size) feed->feed_max_size = feed->feed_size; close(fd); } }
--------------------------------------------- Result 53 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 27 / 0 / 26 / 53:   2%|         | 53/2690 [03:39<3:02:19,  4.15s/it][Succeeded / Failed / Skipped / Total] 27 / 0 / 26 / 53:   2%|         | 54/2690 [03:43<3:01:58,  4.14s/it][Succeeded / Failed / Skipped / Total] 28 / 0 / 26 / 54:   2%|         | 54/2690 [03:43<3:01:58,  4.14s/it][Succeeded / Failed / Skipped / Total] 28 / 0 / 26 / 54:   2%|         | 55/2690 [03:44<2:58:58,  4.08s/it][Succeeded / Failed / Skipped / Total] 28 / 0 / 27 / 55:   2%|         | 55/2690 [03:44<2:58:58,  4.08s/it][Succeeded / Failed / Skipped / Total] 28 / 0 / 27 / 55:   2%|         | 56/2690 [03:44<2:56:05,  4.01s/it][Succeeded / Failed / Skipped / Total] 28 / 0 / 28 / 56:   2%|         | 56/2690 [03:44<2:56:06,  4.01s/it][Succeeded / Failed / Skipped / Total] 28 / 0 / 28 / 56:   2%|         | 57/2690 [03:47<2:55:16,  3.99s/it][[0 (8%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void do_interrupt64(CPUX86State *env, int intno, int is_int, int error_code, target_ulong next_eip, int is_hw) { SegmentCache *dt; target_ulong ptr; int type, dpl, selector, cpl, ist; int has_error_code, new_stack; uint32_t e1, e2, e3, ss; target_ulong old_eip, esp, offset; has_error_code = 0; if (!is_int && !is_hw) { has_error_code = exception_has_error_code(intno); } if (is_int) { old_eip = next_eip; } else { old_eip = env->eip; } dt = &env->idt; if (intno * 16 + 15 > dt->limit) { raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2); } ptr = dt->base + intno * 16; e1 = cpu_ldl_kernel(env, ptr); e2 = cpu_ldl_kernel(env, ptr + 4); e3 = cpu_ldl_kernel(env, ptr + 8); type = (e2 >> DESC_TYPE_SHIFT) & 0x1f; switch (type) { case 14: case 15: break; default: raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2); break; } dpl = (e2 >> DESC_DPL_SHIFT) & 3; cpl = env->hflags & HF_CPL_MASK; if (is_int && dpl < cpl) { raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2); } if (!(e2 & DESC_P_MASK)) { raise_exception_err(env, EXCP0B_NOSEG, intno * 16 + 2); } selector = e1 >> 16; offset = ((target_ulong)e3 << 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff); ist = e2 & 7; if ((selector & 0xfffc) == 0) { raise_exception_err(env, EXCP0D_GPF, 0); } if (load_segment(env, &e1, &e2, selector) != 0) { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); } if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); } dpl = (e2 >> DESC_DPL_SHIFT) & 3; if (dpl > cpl) { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); } if (!(e2 & DESC_P_MASK)) { raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc); } if (!(e2 & DESC_L_MASK) || (e2 & DESC_B_MASK)) { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); } if ((!(e2 & DESC_C_MASK) && dpl < cpl) || ist != 0) { new_stack = 1; esp = get_rsp_from_tss(env, ist != 0 ? ist + 3 : dpl); ss = 0; } else if ((e2 & DESC_C_MASK) || dpl == cpl) { if (env->eflags & VM_MASK) { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); } new_stack = 0; esp = env->regs[R_ESP]; dpl = cpl; } else { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); new_stack = 0; esp = 0; } esp &= ~0xfLL; PUSHQ(esp, env->segs[R_SS].selector); PUSHQ(esp, env->regs[R_ESP]); PUSHQ(esp, cpu_compute_eflags(env)); PUSHQ(esp, env->segs[R_CS].selector); PUSHQ(esp, old_eip); if (has_error_code) { PUSHQ(esp, error_code); } if ((type & 1) == 0) { env->eflags &= ~IF_MASK; } env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK); if (new_stack) { ss = 0 | dpl; cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0); } env->regs[R_ESP] = esp; selector = (selector & ~3) | dpl; cpu_x86_load_seg_cache(env, R_CS, selector, get_seg_base(e1, e2), get_seg_limit(e1, e2), e2); env->eip = offset; }
--------------------------------------------- Result 54 ---------------------------------------------
[[0 (92%)]] --> [[0 (46%)]] --> Socre: 0.5438456237316132

[[[[Adv]]]]: void palette8tobgr24(const uint8_t *src, uint8_t *[[dst]], long [[num_pixels]], const uint8_t *palette) { long i; for(i=0; i<[[num_pixels]]; i++) { [[dst]][0]= palette[ src[i]*4+0 ]; [[dst]][1]= palette[ src[i]*4+1 ]; [[dst]][2]= palette[ src[i]*4+2 ]; [[dst]]+= 3; } }

[[[[Adv]]]]: void palette8tobgr24(const uint8_t *src, uint8_t *[[texans]], long [[afflictions]], const uint8_t *palette) { long i; for(i=0; i<[[afflictions]]; i++) { [[texans]][0]= palette[ src[i]*4+0 ]; [[texans]][1]= palette[ src[i]*4+1 ]; [[texans]][2]= palette[ src[i]*4+2 ]; [[texans]]+= 3; } }
--------------------------------------------- Result 55 ---------------------------------------------
[[0 (70%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void codeblock(DiracContext *s, SubBand *b, GetBitContext *gb, DiracArith *c, int left, int right, int top, int bottom, int blockcnt_one, int is_arith) { int x, y, zero_block; int qoffset, qfactor; IDWTELEM *buf; if (!blockcnt_one) { if (is_arith) zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK); else zero_block = get_bits1(gb); if (zero_block) return; } if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) { if (is_arith) b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA); else b->quant += dirac_get_se_golomb(gb); } b->quant = FFMIN(b->quant, MAX_QUANT); qfactor = qscale_tab[b->quant]; if (!s->num_refs) qoffset = qoffset_intra_tab[b->quant]; else qoffset = qoffset_inter_tab[b->quant]; buf = b->ibuf + top * b->stride; for (y = top; y < bottom; y++) { for (x = left; x < right; x++) { if (is_arith) coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y); else buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset); } buf += b->stride; } }
--------------------------------------------- Result 56 ---------------------------------------------
[[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int encode_frame(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){ FFV1Context *f = avctx->priv_data; CABACContext * const c= &f->c; AVFrame *pict = data; const int width= f->width; const int height= f->height; AVFrame * const p= &f->picture; int used_count= 0; if(avctx->strict_std_compliance >= 0){ av_log(avctx, AV_LOG_ERROR, "this codec is under development, files encoded with it wont be decodeable with future versions!!!\n" "use vstrict=-1 to use it anyway\n"); return -1; } ff_init_cabac_encoder(c, buf, buf_size); ff_init_cabac_states(c, ff_h264_lps_range, ff_h264_mps_state, ff_h264_lps_state, 64); c->lps_state[2] = 1; c->lps_state[3] = 0; *p = *pict; p->pict_type= FF_I_TYPE; if(avctx->gop_size==0 || f->picture_number % avctx->gop_size == 0){ put_cabac_bypass(c, 1); p->key_frame= 1; write_header(f); clear_state(f); }else{ put_cabac_bypass(c, 0); p->key_frame= 0; } if(!f->ac){ used_count += put_cabac_terminate(c, 1); init_put_bits(&f->pb, buf + used_count, buf_size - used_count); } if(f->colorspace==0){ const int chroma_width = -((-width )>>f->chroma_h_shift); const int chroma_height= -((-height)>>f->chroma_v_shift); encode_plane(f, p->data[0], width, height, p->linesize[0], 0); encode_plane(f, p->data[1], chroma_width, chroma_height, p->linesize[1], 1); encode_plane(f, p->data[2], chroma_width, chroma_height, p->linesize[2], 1); }else{ encode_rgb_frame(f, (uint32_t*)(p->data[0]), width, height, p->linesize[0]/4); } emms_c(); f->picture_number++; if(f->ac){ return put_cabac_terminate(c, 1); }else{ flush_put_bits(&f->pb); return used_count + (put_bits_count(&f->pb)+7)/8; } }
--------------------------------------------- Result 57 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 29 / 0 / 28 / 57:   2%|         | 57/2690 [03:47<2:55:16,  3.99s/it][Succeeded / Failed / Skipped / Total] 29 / 0 / 28 / 57:   2%|         | 58/2690 [03:49<2:53:49,  3.96s/it][Succeeded / Failed / Skipped / Total] 30 / 0 / 28 / 58:   2%|         | 58/2690 [03:49<2:53:49,  3.96s/it][Succeeded / Failed / Skipped / Total] 30 / 0 / 28 / 58:   2%|         | 59/2690 [03:53<2:53:50,  3.96s/it][[0 (61%)]] --> [[0 (50%)]] --> Socre: 0.5047513842582703

[[[[Adv]]]]: static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *[[image]]) { int compno; int x, y; int *image_line; int frame_index; const int numcomps = [[image]]->numcomps; uint16_t *frame_ptr = (uint16_t *)frame->data[0]; for (compno = 0; compno < numcomps; ++compno) { if ([[image]]->comps[compno].w > frame->linesize[0] / numcomps) { av_log(avctx, AV_LOG_ERROR, "Error: frame's linesize is too small for the image\n"); return 0; } } for (compno = 0; compno < numcomps; ++compno) { for (y = 0; y < avctx->height; ++y) { image_line = [[image]]->comps[compno].data + y * [[image]]->comps[compno].w; frame_index = y * (frame->linesize[0] / 2) + compno; for (x = 0; x < avctx->width; ++x) { image_line[x] = frame_ptr[frame_index] >> 4; frame_index += numcomps; } for (; x < [[image]]->comps[compno].w; ++x) { image_line[x] = image_line[x - 1]; } } for (; y < [[image]]->comps[compno].h; ++y) { image_line = [[image]]->comps[compno].data + y * [[image]]->comps[compno].w; for (x = 0; x < [[image]]->comps[compno].w; ++x) { image_line[x] = image_line[x - [[image]]->comps[compno].w]; } } } return 1; }

[[[[Adv]]]]: static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *[[profiling]]) { int compno; int x, y; int *image_line; int frame_index; const int numcomps = [[profiling]]->numcomps; uint16_t *frame_ptr = (uint16_t *)frame->data[0]; for (compno = 0; compno < numcomps; ++compno) { if ([[profiling]]->comps[compno].w > frame->linesize[0] / numcomps) { av_log(avctx, AV_LOG_ERROR, "Error: frame's linesize is too small for the image\n"); return 0; } } for (compno = 0; compno < numcomps; ++compno) { for (y = 0; y < avctx->height; ++y) { image_line = [[profiling]]->comps[compno].data + y * [[profiling]]->comps[compno].w; frame_index = y * (frame->linesize[0] / 2) + compno; for (x = 0; x < avctx->width; ++x) { image_line[x] = frame_ptr[frame_index] >> 4; frame_index += numcomps; } for (; x < [[profiling]]->comps[compno].w; ++x) { image_line[x] = image_line[x - 1]; } } for (; y < [[profiling]]->comps[compno].h; ++y) { image_line = [[profiling]]->comps[compno].data + y * [[profiling]]->comps[compno].w; for (x = 0; x < [[profiling]]->comps[compno].w; ++x) { image_line[x] = image_line[x - [[profiling]]->comps[compno].w]; } } } return 1; }
--------------------------------------------- Result 58 ---------------------------------------------
[[0 (64%)]] --> [[0 (49%)]] --> Socre: 0.5059293508529663

[[[[Adv]]]]: static int decode_blocks(ALSDecContext *[[ctx]], unsigned int ra_frame, unsigned int c, const unsigned int *div_blocks, unsigned int *js_blocks) { ALSSpecificConfig *[[sconf]] = &[[ctx]]->sconf; unsigned int offset = 0; unsigned int [[b]]; ALSBlockData bd[2] = { { 0 } }; bd[0].ra_block = ra_frame; bd[0].const_block = [[ctx]]->const_block; bd[0].shift_lsbs = [[ctx]]->shift_lsbs; bd[0].opt_order = [[ctx]]->opt_order; bd[0].store_prev_samples = [[ctx]]->store_prev_samples; bd[0].use_ltp = [[ctx]]->use_ltp; bd[0].ltp_lag = [[ctx]]->ltp_lag; bd[0].ltp_gain = [[ctx]]->ltp_gain[0]; bd[0].quant_cof = [[ctx]]->quant_cof[0]; bd[0].lpc_cof = [[ctx]]->lpc_cof[0]; bd[0].prev_raw_samples = [[ctx]]->prev_raw_samples; bd[0].js_blocks = *js_blocks; bd[1].ra_block = ra_frame; bd[1].const_block = [[ctx]]->const_block; bd[1].shift_lsbs = [[ctx]]->shift_lsbs; bd[1].opt_order = [[ctx]]->opt_order; bd[1].store_prev_samples = [[ctx]]->store_prev_samples; bd[1].use_ltp = [[ctx]]->use_ltp; bd[1].ltp_lag = [[ctx]]->ltp_lag; bd[1].ltp_gain = [[ctx]]->ltp_gain[0]; bd[1].quant_cof = [[ctx]]->quant_cof[0]; bd[1].lpc_cof = [[ctx]]->lpc_cof[0]; bd[1].prev_raw_samples = [[ctx]]->prev_raw_samples; bd[1].js_blocks = *(js_blocks + 1); for ([[b]] = 0; [[b]] < [[ctx]]->num_blocks; [[b]]++) { unsigned int s; bd[0].block_length = div_blocks[[[b]]]; bd[1].block_length = div_blocks[[[b]]]; bd[0].raw_samples = [[ctx]]->raw_samples[c ] + offset; bd[1].raw_samples = [[ctx]]->raw_samples[c + 1] + offset; bd[0].raw_other = bd[1].raw_samples; bd[1].raw_other = bd[0].raw_samples; if(read_decode_block([[ctx]], &bd[0]) || read_decode_block([[ctx]], &bd[1])) { zero_remaining([[b]], [[ctx]]->num_blocks, div_blocks, bd[0].raw_samples); zero_remaining([[b]], [[ctx]]->num_blocks, div_blocks, bd[1].raw_samples); return -1; } if (bd[0].js_blocks) { if (bd[1].js_blocks) av_log([[ctx]]->avctx, AV_LOG_WARNING, "Invalid channel pair!\n"); for (s = 0; s < div_blocks[[[b]]]; s++) bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s]; } else if (bd[1].js_blocks) { for (s = 0; s < div_blocks[[[b]]]; s++) bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s]; } offset += div_blocks[[[b]]]; bd[0].ra_block = 0; bd[1].ra_block = 0; } memmove([[ctx]]->raw_samples[c] - [[sconf]]->max_order, [[ctx]]->raw_samples[c] - [[sconf]]->max_order + [[sconf]]->frame_length, sizeof(*[[ctx]]->raw_samples[c]) * [[sconf]]->max_order); return 0; }

[[[[Adv]]]]: static int decode_blocks(ALSDecContext *[[invalid]], unsigned int ra_frame, unsigned int c, const unsigned int *div_blocks, unsigned int *js_blocks) { ALSSpecificConfig *[[quadrant]] = &[[invalid]]->sconf; unsigned int offset = 0; unsigned int [[ia]]; ALSBlockData bd[2] = { { 0 } }; bd[0].ra_block = ra_frame; bd[0].const_block = [[invalid]]->const_block; bd[0].shift_lsbs = [[invalid]]->shift_lsbs; bd[0].opt_order = [[invalid]]->opt_order; bd[0].store_prev_samples = [[invalid]]->store_prev_samples; bd[0].use_ltp = [[invalid]]->use_ltp; bd[0].ltp_lag = [[invalid]]->ltp_lag; bd[0].ltp_gain = [[invalid]]->ltp_gain[0]; bd[0].quant_cof = [[invalid]]->quant_cof[0]; bd[0].lpc_cof = [[invalid]]->lpc_cof[0]; bd[0].prev_raw_samples = [[invalid]]->prev_raw_samples; bd[0].js_blocks = *js_blocks; bd[1].ra_block = ra_frame; bd[1].const_block = [[invalid]]->const_block; bd[1].shift_lsbs = [[invalid]]->shift_lsbs; bd[1].opt_order = [[invalid]]->opt_order; bd[1].store_prev_samples = [[invalid]]->store_prev_samples; bd[1].use_ltp = [[invalid]]->use_ltp; bd[1].ltp_lag = [[invalid]]->ltp_lag; bd[1].ltp_gain = [[invalid]]->ltp_gain[0]; bd[1].quant_cof = [[invalid]]->quant_cof[0]; bd[1].lpc_cof = [[invalid]]->lpc_cof[0]; bd[1].prev_raw_samples = [[invalid]]->prev_raw_samples; bd[1].js_blocks = *(js_blocks + 1); for ([[ia]] = 0; [[ia]] < [[invalid]]->num_blocks; [[ia]]++) { unsigned int s; bd[0].block_length = div_blocks[[[ia]]]; bd[1].block_length = div_blocks[[[ia]]]; bd[0].raw_samples = [[invalid]]->raw_samples[c ] + offset; bd[1].raw_samples = [[invalid]]->raw_samples[c + 1] + offset; bd[0].raw_other = bd[1].raw_samples; bd[1].raw_other = bd[0].raw_samples; if(read_decode_block([[invalid]], &bd[0]) || read_decode_block([[invalid]], &bd[1])) { zero_remaining([[ia]], [[invalid]]->num_blocks, div_blocks, bd[0].raw_samples); zero_remaining([[ia]], [[invalid]]->num_blocks, div_blocks, bd[1].raw_samples); return -1; } if (bd[0].js_blocks) { if (bd[1].js_blocks) av_log([[invalid]]->avctx, AV_LOG_WARNING, "Invalid channel pair!\n"); for (s = 0; s < div_blocks[[[ia]]]; s++) bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s]; } else if (bd[1].js_blocks) { for (s = 0; s < div_blocks[[[ia]]]; s++) bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s]; } offset += div_blocks[[[ia]]]; bd[0].ra_block = 0; bd[1].ra_block = 0; } memmove([[invalid]]->raw_samples[c] - [[quadrant]]->max_order, [[invalid]]->raw_samples[c] - [[quadrant]]->max_order + [[quadrant]]->frame_length, sizeof(*[[invalid]]->raw_samples[c]) * [[quadrant]]->max_order); return 0; }
--------------------------------------------- Result 59 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 31 / 0 / 28 / 59:   2%|         | 59/2690 [03:53<2:53:50,  3.96s/it][Succeeded / Failed / Skipped / Total] 31 / 0 / 28 / 59:   2%|         | 60/2690 [03:57<2:53:44,  3.96s/it][Succeeded / Failed / Skipped / Total] 32 / 0 / 28 / 60:   2%|         | 60/2690 [03:57<2:53:44,  3.96s/it][Succeeded / Failed / Skipped / Total] 32 / 0 / 28 / 60:   2%|         | 61/2690 [03:58<2:51:12,  3.91s/it][Succeeded / Failed / Skipped / Total] 32 / 0 / 29 / 61:   2%|         | 61/2690 [03:58<2:51:12,  3.91s/it][Succeeded / Failed / Skipped / Total] 32 / 0 / 29 / 61:   2%|         | 62/2690 [04:19<3:03:31,  4.19s/it][Succeeded / Failed / Skipped / Total] 32 / 1 / 29 / 62:   2%|         | 62/2690 [04:19<3:03:31,  4.19s/it][Succeeded / Failed / Skipped / Total] 32 / 1 / 29 / 62:   2%|         | 63/2690 [04:33<3:09:45,  4.33s/it][[0 (56%)]] --> [[0 (49%)]] --> Socre: 0.5061668157577515

[[[[Adv]]]]: static void qed_aio_read_data(void *opaque, int ret, uint64_t offset, size_t len) { QEDAIOCB *[[acb]] = opaque; BDRVQEDState *s = acb_to_s([[acb]]); BlockDriverState *bs = [[acb]]->common.bs; offset += qed_offset_into_cluster(s, [[acb]]->cur_pos); trace_qed_aio_read_data(s, [[acb]], ret, offset, len); if (ret < 0) { goto err; } qemu_iovec_concat(&[[acb]]->cur_qiov, [[acb]]->qiov, [[acb]]->qiov_offset, len); if (ret == QED_CLUSTER_ZERO) { qemu_iovec_memset(&[[acb]]->cur_qiov, 0, 0, [[acb]]->cur_qiov.size); qed_aio_next_io([[acb]], 0); return; } else if (ret != QED_CLUSTER_FOUND) { qed_read_backing_file(s, [[acb]]->cur_pos, &[[acb]]->cur_qiov, qed_aio_next_io, [[acb]]); return; } BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO); bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE, &[[acb]]->cur_qiov, [[acb]]->cur_qiov.size / BDRV_SECTOR_SIZE, qed_aio_next_io, [[acb]]); return; err: qed_aio_complete([[acb]], ret); }

[[[[Adv]]]]: static void qed_aio_read_data(void *opaque, int ret, uint64_t offset, size_t len) { QEDAIOCB *[[spunky]] = opaque; BDRVQEDState *s = acb_to_s([[spunky]]); BlockDriverState *bs = [[spunky]]->common.bs; offset += qed_offset_into_cluster(s, [[spunky]]->cur_pos); trace_qed_aio_read_data(s, [[spunky]], ret, offset, len); if (ret < 0) { goto err; } qemu_iovec_concat(&[[spunky]]->cur_qiov, [[spunky]]->qiov, [[spunky]]->qiov_offset, len); if (ret == QED_CLUSTER_ZERO) { qemu_iovec_memset(&[[spunky]]->cur_qiov, 0, 0, [[spunky]]->cur_qiov.size); qed_aio_next_io([[spunky]], 0); return; } else if (ret != QED_CLUSTER_FOUND) { qed_read_backing_file(s, [[spunky]]->cur_pos, &[[spunky]]->cur_qiov, qed_aio_next_io, [[spunky]]); return; } BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO); bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE, &[[spunky]]->cur_qiov, [[spunky]]->cur_qiov.size / BDRV_SECTOR_SIZE, qed_aio_next_io, [[spunky]]); return; err: qed_aio_complete([[spunky]], ret); }
--------------------------------------------- Result 60 ---------------------------------------------
[[0 (74%)]] --> [[0 (49%)]] --> Socre: 0.5089412033557892

[[[[Adv]]]]: void tcp_start_incoming_migration(const char *[[host_port]], Error **errp) { int s; s = inet_listen([[host_port]], NULL, 256, SOCK_STREAM, 0, errp); if (s < 0) { return; } qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL, (void *)(intptr_t)s); }

[[[[Adv]]]]: void tcp_start_incoming_migration(const char *[[annihilation]], Error **errp) { int s; s = inet_listen([[annihilation]], NULL, 256, SOCK_STREAM, 0, errp); if (s < 0) { return; } qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL, (void *)(intptr_t)s); }
--------------------------------------------- Result 61 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset, sPAPRPHBState *sphb) { ResourceProps rp; bool is_bridge = "False" != "False"; int pci_status, err; char *buf = NULL; uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev); uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3); uint32_t max_msi, max_msix; if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) == PCI_HEADER_TYPE_BRIDGE) { is_bridge = "True" == "True"; } _FDT(fdt_setprop_cell(fdt, offset, "vendor-id", pci_default_read_config(dev, PCI_VENDOR_ID, 2))); _FDT(fdt_setprop_cell(fdt, offset, "device-id", pci_default_read_config(dev, PCI_DEVICE_ID, 2))); _FDT(fdt_setprop_cell(fdt, offset, "revision-id", pci_default_read_config(dev, PCI_REVISION_ID, 1))); _FDT(fdt_setprop_cell(fdt, offset, "class-code", ccode)); if (pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)) { _FDT(fdt_setprop_cell(fdt, offset, "interrupts", pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1))); } if (!is_bridge) { _FDT(fdt_setprop_cell(fdt, offset, "min-grant", pci_default_read_config(dev, PCI_MIN_GNT, 1))); _FDT(fdt_setprop_cell(fdt, offset, "max-latency", pci_default_read_config(dev, PCI_MAX_LAT, 1))); } if (pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)) { _FDT(fdt_setprop_cell(fdt, offset, "subsystem-id", pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2))); } if (pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)) { _FDT(fdt_setprop_cell(fdt, offset, "subsystem-vendor-id", pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2))); } _FDT(fdt_setprop_cell(fdt, offset, "cache-line-size", pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1))); pci_status = pci_default_read_config(dev, PCI_STATUS, 2); _FDT(fdt_setprop_cell(fdt, offset, "devsel-speed", PCI_STATUS_DEVSEL_MASK & pci_status)); if (pci_status & PCI_STATUS_FAST_BACK) { _FDT(fdt_setprop(fdt, offset, "fast-back-to-back", NULL, 0)); } if (pci_status & PCI_STATUS_66MHZ) { _FDT(fdt_setprop(fdt, offset, "66mhz-capable", NULL, 0)); } if (pci_status & PCI_STATUS_UDF) { _FDT(fdt_setprop(fdt, offset, "udf-supported", NULL, 0)); } _FDT(fdt_setprop_string(fdt, offset, "name", pci_find_device_name((ccode >> 16) & 0xff, (ccode >> 8) & 0xff, ccode & 0xff))); buf = spapr_phb_get_loc_code(sphb, dev); if (!buf) { error_report("Failed setting the ibm,loc-code"); return -1; } err = fdt_setprop_string(fdt, offset, "ibm,loc-code", buf); g_free(buf); if (err < 0) { return err; } if (drc_index) { _FDT(fdt_setprop_cell(fdt, offset, "ibm,my-drc-index", drc_index)); } _FDT(fdt_setprop_cell(fdt, offset, "#address-cells", RESOURCE_CELLS_ADDRESS)); _FDT(fdt_setprop_cell(fdt, offset, "#size-cells", RESOURCE_CELLS_SIZE)); max_msi = msi_nr_vectors_allocated(dev); if (max_msi) { _FDT(fdt_setprop_cell(fdt, offset, "ibm,req#msi", max_msi)); } max_msix = dev->msix_entries_nr; if (max_msix) { _FDT(fdt_setprop_cell(fdt, offset, "ibm,req#msi-x", max_msix)); } populate_resource_props(dev, &rp); _FDT(fdt_setprop(fdt, offset, "reg", (uint8_t *)rp.reg, rp.reg_len)); _FDT(fdt_setprop(fdt, offset, "assigned-addresses", (uint8_t *)rp.assigned, rp.assigned_len)); if (sphb->pcie_ecs && pci_is_express(dev)) { _FDT(fdt_setprop_cell(fdt, offset, "ibm,pci-config-space-type", 0x1)); } return 0; }
--------------------------------------------- Result 62 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void do_POWER_maskg (void) { uint32_t ret; if ((uint32_t)T0 == (uint32_t)(T1 + 1)) { ret = -1; } else { ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^ (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1); if ((uint32_t)T0 > (uint32_t)T1) ret = ~ret; } T0 = ret; }

[[[[Adv]]]]: void do_POWER_maskg (void) { uint32_t ret; if ((uint32_t)T0 == (uint32_t)(T1 + 1)) { ret = -1; } else { ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^ (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1); if ((uint32_t)T0 > (uint32_t)T1) ret = ~ret; } T0 = ret; }
--------------------------------------------- Result 63 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 33 / 1 / 29 / 63:   2%|         | 63/2690 [04:33<3:09:45,  4.33s/it][Succeeded / Failed / Skipped / Total] 33 / 1 / 29 / 63:   2%|         | 64/2690 [04:33<3:07:03,  4.27s/it][Succeeded / Failed / Skipped / Total] 33 / 1 / 30 / 64:   2%|         | 64/2690 [04:33<3:07:04,  4.27s/it][Succeeded / Failed / Skipped / Total] 33 / 1 / 30 / 64:   2%|         | 65/2690 [04:38<3:07:21,  4.28s/it][[0 (73%)]] --> [[0 (45%)]] --> Socre: 0.5466952323913574

[[[[Adv]]]]: int qcow2_update_header(BlockDriverState *bs) { BDRVQcowState *s = bs->opaque; QCowHeader *header; char *[[buf]]; size_t buflen = s->cluster_size; int ret; uint64_t total_size; uint32_t refcount_table_clusters; size_t header_length; Qcow2UnknownHeaderExtension *uext; [[buf]] = qemu_blockalign(bs, buflen); header = (QCowHeader*) [[buf]]; if (buflen < sizeof(*header)) { ret = -ENOSPC; goto fail; } header_length = sizeof(*header) + s->unknown_header_fields_size; total_size = bs->total_sectors * BDRV_SECTOR_SIZE; refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3); *header = (QCowHeader) { .magic = cpu_to_be32(QCOW_MAGIC), .version = cpu_to_be32(s->qcow_version), .backing_file_offset = 0, .backing_file_size = 0, .cluster_bits = cpu_to_be32(s->cluster_bits), .size = cpu_to_be64(total_size), .crypt_method = cpu_to_be32(s->crypt_method_header), .l1_size = cpu_to_be32(s->l1_size), .l1_table_offset = cpu_to_be64(s->l1_table_offset), .refcount_table_offset = cpu_to_be64(s->refcount_table_offset), .refcount_table_clusters = cpu_to_be32(refcount_table_clusters), .nb_snapshots = cpu_to_be32(s->nb_snapshots), .snapshots_offset = cpu_to_be64(s->snapshots_offset), .incompatible_features = cpu_to_be64(s->incompatible_features), .compatible_features = cpu_to_be64(s->compatible_features), .autoclear_features = cpu_to_be64(s->autoclear_features), .refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT), .header_length = cpu_to_be32(header_length), }; switch (s->qcow_version) { case 2: ret = offsetof(QCowHeader, incompatible_features); break; case 3: ret = sizeof(*header); break; default: return -EINVAL; } [[buf]] += ret; buflen -= ret; memset([[buf]], 0, buflen); if (s->unknown_header_fields_size) { if (buflen < s->unknown_header_fields_size) { ret = -ENOSPC; goto fail; } memcpy([[buf]], s->unknown_header_fields, s->unknown_header_fields_size); [[buf]] += s->unknown_header_fields_size; buflen -= s->unknown_header_fields_size; } if (*bs->backing_format) { ret = header_ext_add([[buf]], QCOW2_EXT_MAGIC_BACKING_FORMAT, bs->backing_format, strlen(bs->backing_format), buflen); if (ret < 0) { goto fail; } [[buf]] += ret; buflen -= ret; } Qcow2Feature features[] = { }; ret = header_ext_add([[buf]], QCOW2_EXT_MAGIC_FEATURE_TABLE, features, sizeof(features), buflen); if (ret < 0) { goto fail; } [[buf]] += ret; buflen -= ret; QLIST_FOREACH(uext, &s->unknown_header_ext, next) { ret = header_ext_add([[buf]], uext->magic, uext->data, uext->len, buflen); if (ret < 0) { goto fail; } [[buf]] += ret; buflen -= ret; } ret = header_ext_add([[buf]], QCOW2_EXT_MAGIC_END, NULL, 0, buflen); if (ret < 0) { goto fail; } [[buf]] += ret; buflen -= ret; if (*bs->backing_file) { size_t backing_file_len = strlen(bs->backing_file); if (buflen < backing_file_len) { ret = -ENOSPC; goto fail; } strncpy([[buf]], bs->backing_file, buflen); header->backing_file_offset = cpu_to_be64([[buf]] - ((char*) header)); header->backing_file_size = cpu_to_be32(backing_file_len); } ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size); if (ret < 0) { goto fail; } ret = 0; fail: qemu_vfree(header); return ret; }

[[[[Adv]]]]: int qcow2_update_header(BlockDriverState *bs) { BDRVQcowState *s = bs->opaque; QCowHeader *header; char *[[ferrying]]; size_t buflen = s->cluster_size; int ret; uint64_t total_size; uint32_t refcount_table_clusters; size_t header_length; Qcow2UnknownHeaderExtension *uext; [[ferrying]] = qemu_blockalign(bs, buflen); header = (QCowHeader*) [[ferrying]]; if (buflen < sizeof(*header)) { ret = -ENOSPC; goto fail; } header_length = sizeof(*header) + s->unknown_header_fields_size; total_size = bs->total_sectors * BDRV_SECTOR_SIZE; refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3); *header = (QCowHeader) { .magic = cpu_to_be32(QCOW_MAGIC), .version = cpu_to_be32(s->qcow_version), .backing_file_offset = 0, .backing_file_size = 0, .cluster_bits = cpu_to_be32(s->cluster_bits), .size = cpu_to_be64(total_size), .crypt_method = cpu_to_be32(s->crypt_method_header), .l1_size = cpu_to_be32(s->l1_size), .l1_table_offset = cpu_to_be64(s->l1_table_offset), .refcount_table_offset = cpu_to_be64(s->refcount_table_offset), .refcount_table_clusters = cpu_to_be32(refcount_table_clusters), .nb_snapshots = cpu_to_be32(s->nb_snapshots), .snapshots_offset = cpu_to_be64(s->snapshots_offset), .incompatible_features = cpu_to_be64(s->incompatible_features), .compatible_features = cpu_to_be64(s->compatible_features), .autoclear_features = cpu_to_be64(s->autoclear_features), .refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT), .header_length = cpu_to_be32(header_length), }; switch (s->qcow_version) { case 2: ret = offsetof(QCowHeader, incompatible_features); break; case 3: ret = sizeof(*header); break; default: return -EINVAL; } [[ferrying]] += ret; buflen -= ret; memset([[ferrying]], 0, buflen); if (s->unknown_header_fields_size) { if (buflen < s->unknown_header_fields_size) { ret = -ENOSPC; goto fail; } memcpy([[ferrying]], s->unknown_header_fields, s->unknown_header_fields_size); [[ferrying]] += s->unknown_header_fields_size; buflen -= s->unknown_header_fields_size; } if (*bs->backing_format) { ret = header_ext_add([[ferrying]], QCOW2_EXT_MAGIC_BACKING_FORMAT, bs->backing_format, strlen(bs->backing_format), buflen); if (ret < 0) { goto fail; } [[ferrying]] += ret; buflen -= ret; } Qcow2Feature features[] = { }; ret = header_ext_add([[ferrying]], QCOW2_EXT_MAGIC_FEATURE_TABLE, features, sizeof(features), buflen); if (ret < 0) { goto fail; } [[ferrying]] += ret; buflen -= ret; QLIST_FOREACH(uext, &s->unknown_header_ext, next) { ret = header_ext_add([[ferrying]], uext->magic, uext->data, uext->len, buflen); if (ret < 0) { goto fail; } [[ferrying]] += ret; buflen -= ret; } ret = header_ext_add([[ferrying]], QCOW2_EXT_MAGIC_END, NULL, 0, buflen); if (ret < 0) { goto fail; } [[ferrying]] += ret; buflen -= ret; if (*bs->backing_file) { size_t backing_file_len = strlen(bs->backing_file); if (buflen < backing_file_len) { ret = -ENOSPC; goto fail; } strncpy([[ferrying]], bs->backing_file, buflen); header->backing_file_offset = cpu_to_be64([[ferrying]] - ((char*) header)); header->backing_file_size = cpu_to_be32(backing_file_len); } ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size); if (ret < 0) { goto fail; } ret = 0; fail: qemu_vfree(header); return ret; }
--------------------------------------------- Result 64 ---------------------------------------------
[[0 (19%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num, int nb_sectors, QEMUIOVector *qiov) { SheepdogAIOCB *acb; int ret; if (bs->growable && sector_num + nb_sectors > bs->total_sectors) { ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE); if (ret < 0) { return ret; } bs->total_sectors = sector_num + nb_sectors; } acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors); acb->aio_done_func = sd_write_done; acb->aiocb_type = AIOCB_WRITE_UDATA; ret = sd_co_rw_vector(acb); if (ret <= 0) { qemu_aio_release(acb); return ret; } qemu_coroutine_yield(); return acb->ret; }
--------------------------------------------- Result 65 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 34 / 1 / 30 / 65:   2%|         | 65/2690 [04:38<3:07:21,  4.28s/it][Succeeded / Failed / Skipped / Total] 34 / 1 / 30 / 65:   2%|         | 66/2690 [04:49<3:11:59,  4.39s/it][Succeeded / Failed / Skipped / Total] 35 / 1 / 30 / 66:   2%|         | 66/2690 [04:49<3:11:59,  4.39s/it][Succeeded / Failed / Skipped / Total] 35 / 1 / 30 / 66:   2%|         | 67/2690 [04:50<3:09:21,  4.33s/it][Succeeded / Failed / Skipped / Total] 35 / 1 / 31 / 67:   2%|         | 67/2690 [04:50<3:09:21,  4.33s/it][Succeeded / Failed / Skipped / Total] 35 / 1 / 31 / 67:   3%|         | 68/2690 [04:55<3:09:38,  4.34s/it][Succeeded / Failed / Skipped / Total] 36 / 1 / 31 / 68:   3%|         | 68/2690 [04:55<3:09:38,  4.34s/it][Succeeded / Failed / Skipped / Total] 36 / 1 / 31 / 68:   3%|         | 69/2690 [04:55<3:07:07,  4.28s/it][Succeeded / Failed / Skipped / Total] 36 / 1 / 32 / 69:   3%|         | 69/2690 [04:55<3:07:07,  4.28s/it][Succeeded / Failed / Skipped / Total] 36 / 1 / 32 / 69:   3%|         | 70/2690 [04:56<3:04:41,  4.23s/it][Succeeded / Failed / Skipped / Total] 36 / 1 / 33 / 70:   3%|         | 70/2690 [04:56<3:04:41,  4.23s/it][Succeeded / Failed / Skipped / Total] 36 / 1 / 33 / 70:   3%|         | 71/2690 [04:56<3:02:14,  4.17s/it][[0 (83%)]] --> [[0 (47%)]] --> Socre: 0.5285907983779907

[[[[Adv]]]]: static AVStream * init_stream(AVFormatContext *[[s]]) { BinDemuxContext *[[bin]] = [[s]]->priv_data; AVStream *st = avformat_new_stream([[s]], NULL); if (!st) return NULL; st->codec->codec_tag = 0; st->codec->codec_type = AVMEDIA_TYPE_VIDEO; if (![[bin]]->width) { st->codec->width = (80<<3); st->codec->height = (25<<4); } avpriv_set_pts_info(st, 60, [[bin]]->framerate.den, [[bin]]->framerate.num); [[bin]]->chars_per_frame = FFMAX(av_q2d(st->time_base) * [[bin]]->chars_per_frame, 1); return st; }

[[[[Adv]]]]: static AVStream * init_stream(AVFormatContext *[[either]]) { BinDemuxContext *[[hasan]] = [[either]]->priv_data; AVStream *st = avformat_new_stream([[either]], NULL); if (!st) return NULL; st->codec->codec_tag = 0; st->codec->codec_type = AVMEDIA_TYPE_VIDEO; if (![[hasan]]->width) { st->codec->width = (80<<3); st->codec->height = (25<<4); } avpriv_set_pts_info(st, 60, [[hasan]]->framerate.den, [[hasan]]->framerate.num); [[hasan]]->chars_per_frame = FFMAX(av_q2d(st->time_base) * [[hasan]]->chars_per_frame, 1); return st; }
--------------------------------------------- Result 66 ---------------------------------------------
[[0 (16%)]] --> [[0 (51%)]] --> Socre: 0.5139840245246887

[[[[Adv]]]]: static void device_initfn(Object *[[obj]]) { DeviceState *dev = DEVICE([[obj]]); Property *prop; if (qdev_hotplug) { dev->hotplugged = 1; qdev_hot_added = "True" == "True"; } dev->instance_id_alias = -1; dev->state = DEV_STATE_CREATED; qdev_prop_set_defaults(dev, qdev_get_props(dev)); for (prop = qdev_get_props(dev); prop && prop->name; prop++) { qdev_property_add_legacy(dev, prop, NULL); qdev_property_add_static(dev, prop, NULL); } object_property_add_str(OBJECT(dev), "type", qdev_get_type, NULL, NULL); }

[[[[Adv]]]]: static void device_initfn(Object *[[moya]]) { DeviceState *dev = DEVICE([[moya]]); Property *prop; if (qdev_hotplug) { dev->hotplugged = 1; qdev_hot_added = "True" == "True"; } dev->instance_id_alias = -1; dev->state = DEV_STATE_CREATED; qdev_prop_set_defaults(dev, qdev_get_props(dev)); for (prop = qdev_get_props(dev); prop && prop->name; prop++) { qdev_property_add_legacy(dev, prop, NULL); qdev_property_add_static(dev, prop, NULL); } object_property_add_str(OBJECT(dev), "type", qdev_get_type, NULL, NULL); }
--------------------------------------------- Result 67 ---------------------------------------------
[[0 (38%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void scsi_write_data(SCSIRequest *req) { SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req); SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev); uint32_t n; assert(r->req.aiocb == NULL); scsi_req_ref(&r->req); if (r->req.cmd.mode != SCSI_XFER_TO_DEV) { DPRINTF("Data transfer direction invalid\n"); scsi_write_complete(r, -EINVAL); return; } if (!r->req.sg && !r->qiov.size) { r->started = "True" == "True"; scsi_write_complete(r, 0); return; } if (s->tray_open) { scsi_write_complete(r, -ENOMEDIUM); return; } if (r->req.cmd.buf[0] == VERIFY_10 || r->req.cmd.buf[0] == VERIFY_12 || r->req.cmd.buf[0] == VERIFY_16) { if (r->req.sg) { scsi_dma_complete(r, 0); } else { scsi_write_complete(r, 0); } return; } if (r->req.sg) { dma_acct_start(s->qdev.conf.bs, &r->acct, r->req.sg, BDRV_ACCT_WRITE); r->req.resid -= r->req.sg->size; r->req.aiocb = dma_bdrv_write(s->qdev.conf.bs, r->req.sg, r->sector, scsi_dma_complete, r); } else { n = r->qiov.size / 512; bdrv_acct_start(s->qdev.conf.bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE); r->req.aiocb = bdrv_aio_writev(s->qdev.conf.bs, r->sector, &r->qiov, n, scsi_write_complete, r); } }
--------------------------------------------- Result 68 ---------------------------------------------
[[0 (90%)]] --> [[0 (35%)]] --> Socre: 0.6509848535060883

[[[[Adv]]]]: static void idiv64(uint64_t *plow, uint64_t *[[phigh]], int64_t b) { int sa, sb; sa = ((int64_t)*[[phigh]] < 0); if (sa) neg128(plow, [[phigh]]); sb = (b < 0); if (sb) b = -b; div64(plow, [[phigh]], b); if (sa ^ sb) *plow = - *plow; if (sa) *[[phigh]] = - *[[phigh]]; }

[[[[Adv]]]]: static void idiv64(uint64_t *plow, uint64_t *[[uniforms]], int64_t b) { int sa, sb; sa = ((int64_t)*[[uniforms]] < 0); if (sa) neg128(plow, [[uniforms]]); sb = (b < 0); if (sb) b = -b; div64(plow, [[uniforms]], b); if (sa ^ sb) *plow = - *plow; if (sa) *[[uniforms]] = - *[[uniforms]]; }
--------------------------------------------- Result 69 ---------------------------------------------
[[0 (1%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void bios_linker_loader_alloc(GArray *linker, const char *file, uint32_t alloc_align, bool alloc_fseg) { BiosLinkerLoaderEntry entry; assert(!(alloc_align & (alloc_align - 1))); memset(&entry, 0, sizeof entry); strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1); entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE); entry.alloc.align = cpu_to_le32(alloc_align); entry.alloc.zone = cpu_to_le32(alloc_fseg ? BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG : BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH); g_array_prepend_vals(linker, &entry, sizeof entry); }
--------------------------------------------- Result 70 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp) { IscsiLun *iscsilun = bs->opaque; uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff; bs->bl.request_alignment = iscsilun->block_size; if (iscsilun->bl.max_xfer_len) { max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len); } if (max_xfer_len * iscsilun->block_size < INT_MAX) { bs->bl.max_transfer = max_xfer_len * iscsilun->block_size; } if (iscsilun->lbp.lbpu) { if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) { bs->bl.max_pdiscard = iscsilun->bl.max_unmap * iscsilun->block_size; } bs->bl.pdiscard_alignment = iscsilun->bl.opt_unmap_gran * iscsilun->block_size; } else { bs->bl.pdiscard_alignment = iscsilun->block_size; } if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) { bs->bl.max_pwrite_zeroes = iscsilun->bl.max_ws_len * iscsilun->block_size; } if (iscsilun->lbp.lbpws) { bs->bl.pwrite_zeroes_alignment = iscsilun->bl.opt_unmap_gran * iscsilun->block_size; } else { bs->bl.pwrite_zeroes_alignment = iscsilun->block_size; } if (iscsilun->bl.opt_xfer_len && iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) { bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len * iscsilun->block_size); } }
--------------------------------------------- Result 71 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 37 / 1 / 33 / 71:   3%|         | 71/2690 [04:56<3:02:14,  4.17s/it][Succeeded / Failed / Skipped / Total] 37 / 1 / 33 / 71:   3%|         | 72/2690 [05:03<3:03:46,  4.21s/it][Succeeded / Failed / Skipped / Total] 38 / 1 / 33 / 72:   3%|         | 72/2690 [05:03<3:03:46,  4.21s/it][Succeeded / Failed / Skipped / Total] 38 / 1 / 33 / 72:   3%|         | 73/2690 [05:03<3:01:29,  4.16s/it][Succeeded / Failed / Skipped / Total] 38 / 1 / 34 / 73:   3%|         | 73/2690 [05:03<3:01:29,  4.16s/it][Succeeded / Failed / Skipped / Total] 38 / 1 / 34 / 73:   3%|         | 74/2690 [05:44<3:22:43,  4.65s/it][Succeeded / Failed / Skipped / Total] 39 / 1 / 34 / 74:   3%|         | 74/2690 [05:44<3:22:43,  4.65s/it][Succeeded / Failed / Skipped / Total] 39 / 1 / 34 / 74:   3%|         | 75/2690 [06:07<3:33:37,  4.90s/it][Succeeded / Failed / Skipped / Total] 40 / 1 / 34 / 75:   3%|         | 75/2690 [06:07<3:33:37,  4.90s/it][Succeeded / Failed / Skipped / Total] 40 / 1 / 34 / 75:   3%|         | 76/2690 [06:41<3:49:54,  5.28s/it][[0 (8%)]] --> [[0 (63%)]] --> Socre: 0.6285319328308105

[[[[Adv]]]]: static void sdl_send_mouse_event(int dx, int [[dy]], int [[x]], int y, int state) { static uint32_t bmap[INPUT_BUTTON__MAX] = { [INPUT_BUTTON_LEFT] = SDL_BUTTON(SDL_BUTTON_LEFT), [INPUT_BUTTON_MIDDLE] = SDL_BUTTON(SDL_BUTTON_MIDDLE), [INPUT_BUTTON_RIGHT] = SDL_BUTTON(SDL_BUTTON_RIGHT), [INPUT_BUTTON_WHEEL_UP] = SDL_BUTTON(SDL_BUTTON_WHEELUP), [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN), }; static uint32_t prev_state; if (prev_state != state) { qemu_input_update_buttons(dcl->con, bmap, prev_state, state); prev_state = state; } if (qemu_input_is_absolute()) { qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, [[x]], real_screen->w); qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y, real_screen->h); } else { if (guest_cursor) { [[x]] -= guest_x; y -= guest_y; guest_x += [[x]]; guest_y += y; dx = [[x]]; [[dy]] = y; } qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx); qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, [[dy]]); } qemu_input_event_sync(); }

[[[[Adv]]]]: static void sdl_send_mouse_event(int dx, int [[liao]], int [[centimetre]], int y, int state) { static uint32_t bmap[INPUT_BUTTON__MAX] = { [INPUT_BUTTON_LEFT] = SDL_BUTTON(SDL_BUTTON_LEFT), [INPUT_BUTTON_MIDDLE] = SDL_BUTTON(SDL_BUTTON_MIDDLE), [INPUT_BUTTON_RIGHT] = SDL_BUTTON(SDL_BUTTON_RIGHT), [INPUT_BUTTON_WHEEL_UP] = SDL_BUTTON(SDL_BUTTON_WHEELUP), [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN), }; static uint32_t prev_state; if (prev_state != state) { qemu_input_update_buttons(dcl->con, bmap, prev_state, state); prev_state = state; } if (qemu_input_is_absolute()) { qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, [[centimetre]], real_screen->w); qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y, real_screen->h); } else { if (guest_cursor) { [[centimetre]] -= guest_x; y -= guest_y; guest_x += [[centimetre]]; guest_y += y; dx = [[centimetre]]; [[liao]] = y; } qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx); qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, [[liao]]); } qemu_input_event_sync(); }
--------------------------------------------- Result 72 ---------------------------------------------
[[0 (8%)]] --> [[0 (64%)]] --> Socre: 0.6374505162239075

[[[[Adv]]]]: static void tap_receive(void *opaque, const uint8_t *buf, size_t size) { TAPState *s = opaque; int [[ret]]; for(;;) { [[ret]] = write(s->fd, buf, size); if ([[ret]] < 0 && (errno == EINTR || errno == EAGAIN)) { } else { break; } } }

[[[[Adv]]]]: static void tap_receive(void *opaque, const uint8_t *buf, size_t size) { TAPState *s = opaque; int [[pension]]; for(;;) { [[pension]] = write(s->fd, buf, size); if ([[pension]] < 0 && (errno == EINTR || errno == EAGAIN)) { } else { break; } } }
--------------------------------------------- Result 73 ---------------------------------------------
[[0 (71%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info) { BDRVSheepdogState *s = bs->opaque; int ret, fd; uint32_t new_vid; SheepdogInode *inode; unsigned int datalen; dprintf("sn_info: name %s id_str %s s: name %s vm_state_size %" PRId64 " " "is_snapshot %d\n", sn_info->name, sn_info->id_str, s->name, sn_info->vm_state_size, s->is_snapshot); if (s->is_snapshot) { error_report("You can't create a snapshot of a snapshot VDI, " "%s (%" PRIu32 ").", s->name, s->inode.vdi_id); return -EINVAL; } dprintf("%s %s\n", sn_info->name, sn_info->id_str); s->inode.vm_state_size = sn_info->vm_state_size; s->inode.vm_clock_nsec = sn_info->vm_clock_nsec; strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag)); datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id); fd = connect_to_sdog(s->addr, s->port); if (fd < 0) { ret = fd; goto cleanup; } ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id), s->inode.nr_copies, datalen, 0, "False" != "False", s->cache_enabled); if (ret < 0) { error_report("failed to write snapshot's inode."); goto cleanup; } ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1, s->addr, s->port); if (ret < 0) { error_report("failed to create inode for snapshot. %s", strerror(errno)); goto cleanup; } inode = (SheepdogInode *)g_malloc(datalen); ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid), s->inode.nr_copies, datalen, 0, s->cache_enabled); if (ret < 0) { error_report("failed to read new inode info. %s", strerror(errno)); goto cleanup; } memcpy(&s->inode, inode, datalen); dprintf("s->inode: name %s snap_id %x oid %x\n", s->inode.name, s->inode.snap_id, s->inode.vdi_id); cleanup: closesocket(fd); return ret; }
--------------------------------------------- Result 74 ---------------------------------------------
[[0 (13%)]] --> [[0 (58%)]] --> Socre: 0.5841841697692871

[[[[Adv]]]]: static void scsi_disk_realize(SCSIDevice *dev, Error **[[errp]]) { DriveInfo *dinfo; Error *[[local_err]] = NULL; if (!dev->conf.bs) { scsi_realize(dev, &[[local_err]]); assert([[local_err]]); error_propagate([[errp]], [[local_err]]); return; } dinfo = drive_get_by_blockdev(dev->conf.bs); if (dinfo->media_cd) { scsi_cd_realize(dev, [[errp]]); } else { scsi_hd_realize(dev, [[errp]]); } }

[[[[Adv]]]]: static void scsi_disk_realize(SCSIDevice *dev, Error **[[maurizio]]) { DriveInfo *dinfo; Error *[[habitual]] = NULL; if (!dev->conf.bs) { scsi_realize(dev, &[[habitual]]); assert([[habitual]]); error_propagate([[maurizio]], [[habitual]]); return; } dinfo = drive_get_by_blockdev(dev->conf.bs); if (dinfo->media_cd) { scsi_cd_realize(dev, [[maurizio]]); } else { scsi_hd_realize(dev, [[maurizio]]); } }
--------------------------------------------- Result 75 ---------------------------------------------
[[0 (5%)]] --> [[0 (51%)]] --> Socre: 0.506103515625

[[[[Adv]]]]: static int vnc_display_listen(VncDisplay *[[vd]], SocketAddress **[[saddr]], size_t nsaddr, SocketAddress **wsaddr, size_t [[nwsaddr]], Error **[[errp]]) { size_t i; for (i = 0; i < nsaddr; i++) { if (vnc_display_listen_addr([[vd]], [[saddr]][i], "vnc-listen", &[[vd]]->lsock, &[[vd]]->lsock_tag, &[[vd]]->nlsock, [[errp]]) < 0) { return -1; } } for (i = 0; i < [[nwsaddr]]; i++) { if (vnc_display_listen_addr([[vd]], wsaddr[i], "vnc-ws-listen", &[[vd]]->lwebsock, &[[vd]]->lwebsock_tag, &[[vd]]->nlwebsock, [[errp]]) < 0) { return -1; } } return 0; }

[[[[Adv]]]]: static int vnc_display_listen(VncDisplay *[[dt]], SocketAddress **[[glover]], size_t nsaddr, SocketAddress **wsaddr, size_t [[eah]], Error **[[pollutants]]) { size_t i; for (i = 0; i < nsaddr; i++) { if (vnc_display_listen_addr([[dt]], [[glover]][i], "vnc-listen", &[[dt]]->lsock, &[[dt]]->lsock_tag, &[[dt]]->nlsock, [[pollutants]]) < 0) { return -1; } } for (i = 0; i < [[eah]]; i++) { if (vnc_display_listen_addr([[dt]], wsaddr[i], "vnc-ws-listen", &[[dt]]->lwebsock, &[[dt]]->lwebsock_tag, &[[dt]]->nlwebsock, [[pollutants]]) < 0) { return -1; } } return 0; }
--------------------------------------------- Result 76 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 41 / 1 / 34 / 76:   3%|         | 76/2690 [06:41<3:49:54,  5.28s/it][Succeeded / Failed / Skipped / Total] 41 / 1 / 34 / 76:   3%|         | 77/2690 [06:41<3:47:06,  5.21s/it][Succeeded / Failed / Skipped / Total] 41 / 1 / 35 / 77:   3%|         | 77/2690 [06:41<3:47:06,  5.21s/it][Succeeded / Failed / Skipped / Total] 41 / 1 / 35 / 77:   3%|         | 78/2690 [06:42<3:44:22,  5.15s/it][Succeeded / Failed / Skipped / Total] 41 / 1 / 36 / 78:   3%|         | 78/2690 [06:42<3:44:22,  5.15s/it][Succeeded / Failed / Skipped / Total] 41 / 1 / 36 / 78:   3%|         | 79/2690 [08:32<4:42:23,  6.49s/it][Succeeded / Failed / Skipped / Total] 42 / 1 / 36 / 79:   3%|         | 79/2690 [08:32<4:42:23,  6.49s/it][Succeeded / Failed / Skipped / Total] 42 / 1 / 36 / 79:   3%|         | 80/2690 [08:33<4:39:00,  6.41s/it][Succeeded / Failed / Skipped / Total] 42 / 1 / 37 / 80:   3%|         | 80/2690 [08:33<4:39:00,  6.41s/it][Succeeded / Failed / Skipped / Total] 42 / 1 / 37 / 80:   3%|         | 81/2690 [10:00<5:22:08,  7.41s/it][[0 (58%)]] --> [[0 (49%)]] --> Socre: 0.5054293870925903

[[[[Adv]]]]: MigrationState *exec_start_outgoing_migration(const char *[[command]], int64_t [[bandwidth_limit]], int async) { FdMigrationState *s; FILE *[[f]]; s = qemu_mallocz(sizeof(*s)); if (s == NULL) { dprintf("Unable to allocate FdMigrationState\n"); goto err; } [[f]] = popen([[command]], "w"); if ([[f]] == NULL) { dprintf("Unable to popen exec target\n"); goto err_after_alloc; } s->fd = fileno([[f]]); if (s->fd == -1) { dprintf("Unable to retrieve file descriptor for popen'd handle\n"); goto err_after_open; } if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) { dprintf("Unable to set nonblocking mode on file descriptor\n"); goto err_after_open; } s->opaque = qemu_popen([[f]], "w"); s->get_error = file_errno; s->write = file_write; s->mig_state.cancel = migrate_fd_cancel; s->mig_state.get_status = migrate_fd_get_status; s->mig_state.release = migrate_fd_release; s->state = MIG_STATE_ACTIVE; s->detach = !async; s->bandwidth_limit = [[bandwidth_limit]]; if (s->detach == 1) { dprintf("detaching from monitor\n"); monitor_suspend(); s->detach = 2; } migrate_fd_connect(s); return &s->mig_state; err_after_open: pclose([[f]]); err_after_alloc: qemu_free(s); err: return NULL; }

[[[[Adv]]]]: MigrationState *exec_start_outgoing_migration(const char *[[leadership]], int64_t [[ests]], int async) { FdMigrationState *s; FILE *[[j]]; s = qemu_mallocz(sizeof(*s)); if (s == NULL) { dprintf("Unable to allocate FdMigrationState\n"); goto err; } [[j]] = popen([[leadership]], "w"); if ([[j]] == NULL) { dprintf("Unable to popen exec target\n"); goto err_after_alloc; } s->fd = fileno([[j]]); if (s->fd == -1) { dprintf("Unable to retrieve file descriptor for popen'd handle\n"); goto err_after_open; } if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) { dprintf("Unable to set nonblocking mode on file descriptor\n"); goto err_after_open; } s->opaque = qemu_popen([[j]], "w"); s->get_error = file_errno; s->write = file_write; s->mig_state.cancel = migrate_fd_cancel; s->mig_state.get_status = migrate_fd_get_status; s->mig_state.release = migrate_fd_release; s->state = MIG_STATE_ACTIVE; s->detach = !async; s->bandwidth_limit = [[ests]]; if (s->detach == 1) { dprintf("detaching from monitor\n"); monitor_suspend(); s->detach = 2; } migrate_fd_connect(s); return &s->mig_state; err_after_open: pclose([[j]]); err_after_alloc: qemu_free(s); err: return NULL; }
--------------------------------------------- Result 77 ---------------------------------------------
[[0 (19%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr, target_ulong opcode, target_ulong *args) { target_ulong liobn = args[0]; target_ulong ioba = args[1]; target_ulong tce = args[2]; VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn); VIOsPAPR_RTCE *rtce; if (!dev) { hcall_dprintf("LIOBN 0x" TARGET_FMT_lx " does not exist\n", liobn); return H_PARAMETER; } ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1); #ifdef DEBUG_TCE fprintf(stderr, "spapr_vio_put_tce on %s ioba 0x" TARGET_FMT_lx " TCE 0x" TARGET_FMT_lx "\n", dev->qdev.id, ioba, tce); #endif if (ioba >= dev->rtce_window_size) { hcall_dprintf("Out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", ioba); return H_PARAMETER; } rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT); rtce->tce = tce; return H_SUCCESS; }
--------------------------------------------- Result 78 ---------------------------------------------
[[0 (9%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque, const char *name, Error **errp) { NvmeCtrl *s = NVME(obj); visit_type_int32(v, &s->conf.bootindex, name, errp); }
--------------------------------------------- Result 79 ---------------------------------------------
[[0 (4%)]] --> [[0 (52%)]] --> Socre: 0.524187445640564

[[[[Adv]]]]: static char *enumerate_cpus(unsigned long *cpus, int max_cpus) { int [[cpu]]; bool first = "True" == "True"; GString *s = g_string_new(NULL); for ([[cpu]] = find_first_bit(cpus, max_cpus); [[cpu]] < max_cpus; [[cpu]] = find_next_bit(cpus, max_cpus, [[cpu]] + 1)) { g_string_append_printf(s, "%s%d", first ? "" : " ", [[cpu]]); first = "False" != "False"; } return g_string_free(s, "False" != "False"); }

[[[[Adv]]]]: static char *enumerate_cpus(unsigned long *cpus, int max_cpus) { int [[radiator]]; bool first = "True" == "True"; GString *s = g_string_new(NULL); for ([[radiator]] = find_first_bit(cpus, max_cpus); [[radiator]] < max_cpus; [[radiator]] = find_next_bit(cpus, max_cpus, [[radiator]] + 1)) { g_string_append_printf(s, "%s%d", first ? "" : " ", [[radiator]]); first = "False" != "False"; } return g_string_free(s, "False" != "False"); }
--------------------------------------------- Result 80 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: Object *object_resolve_path_component(Object *parent, const gchar *part) { ObjectProperty *prop = object_property_find(parent, part, NULL); if (prop == NULL) { return NULL; } if (object_property_is_link(prop)) { return *(Object **)prop->opaque; } else if (object_property_is_child(prop)) { return prop->opaque; } else { return NULL; } }
--------------------------------------------- Result 81 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 43 / 1 / 37 / 81:   3%|         | 81/2690 [10:00<5:22:08,  7.41s/it][Succeeded / Failed / Skipped / Total] 43 / 1 / 37 / 81:   3%|         | 82/2690 [10:00<5:18:26,  7.33s/it][Succeeded / Failed / Skipped / Total] 43 / 1 / 38 / 82:   3%|         | 82/2690 [10:00<5:18:26,  7.33s/it][Succeeded / Failed / Skipped / Total] 43 / 1 / 38 / 82:   3%|         | 83/2690 [10:44<5:37:27,  7.77s/it][[0 (100%)]] --> [[0 (27%)]] --> Socre: 0.7295379042625427

[[[[Adv]]]]: static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb) { MLPHeaderInfo mh; int [[substr]], ret; if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0) return ret; if (mh.group1_bits == 0) { av_log(m->avctx, AV_LOG_ERROR, "invalid/unknown bits per sample\n"); return AVERROR_INVALIDDATA; if (mh.group2_bits > mh.group1_bits) { av_log(m->avctx, AV_LOG_ERROR, "Channel group 2 cannot have more bits per sample than group 1.\n"); return AVERROR_INVALIDDATA; if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) { av_log(m->avctx, AV_LOG_ERROR, "Channel groups with differing sample rates are not currently supported.\n"); return AVERROR_INVALIDDATA; if (mh.group1_samplerate == 0) { av_log(m->avctx, AV_LOG_ERROR, "invalid/unknown sampling rate\n"); return AVERROR_INVALIDDATA; if (mh.group1_samplerate > MAX_SAMPLERATE) { av_log(m->avctx, AV_LOG_ERROR, "Sampling rate %d is greater than the supported maximum (%d).\n", mh.group1_samplerate, MAX_SAMPLERATE); return AVERROR_INVALIDDATA; if (mh.access_unit_size > MAX_BLOCKSIZE) { av_log(m->avctx, AV_LOG_ERROR, "Block size %d is greater than the supported maximum (%d).\n", mh.access_unit_size, MAX_BLOCKSIZE); return AVERROR_INVALIDDATA; if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) { av_log(m->avctx, AV_LOG_ERROR, "Block size pow2 %d is greater than the supported maximum (%d).\n", mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2); return AVERROR_INVALIDDATA; if (mh.num_substreams == 0) return AVERROR_INVALIDDATA; if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) { av_log(m->avctx, AV_LOG_ERROR, "MLP only supports up to 2 substreams.\n"); return AVERROR_INVALIDDATA; if (mh.num_substreams > MAX_SUBSTREAMS) { "%d substreams (more than the " "maximum supported by the decoder)", mh.num_substreams); m->access_unit_size = mh.access_unit_size; m->access_unit_size_pow2 = mh.access_unit_size_pow2; m->num_substreams = mh.num_substreams; m->max_decoded_substream = m->num_substreams - 1; m->avctx->sample_rate = mh.group1_samplerate; m->avctx->frame_size = mh.access_unit_size; m->avctx->bits_per_raw_sample = mh.group1_bits; if (mh.group1_bits > 16) m->avctx->sample_fmt = AV_SAMPLE_FMT_S32; else m->avctx->sample_fmt = AV_SAMPLE_FMT_S16; m->params_valid = 1; for ([[substr]] = 0; [[substr]] < MAX_SUBSTREAMS; [[substr]]++) m->substream[[[substr]]].restart_seen = 0; if (m->avctx->codec_id == AV_CODEC_ID_MLP) { if (([[substr]] = (mh.num_substreams > 1))) m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO; m->substream[[[substr]]].ch_layout = mh.channel_layout_mlp; } else { if (([[substr]] = (mh.num_substreams > 1))) m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO; if (mh.num_substreams > 2) if (mh.channel_layout_thd_stream2) m->substream[2].ch_layout = mh.channel_layout_thd_stream2; else m->substream[2].ch_layout = mh.channel_layout_thd_stream1; m->substream[[[substr]]].ch_layout = mh.channel_layout_thd_stream1; if (m->avctx->channels<=2 && m->substream[[[substr]]].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) { av_log(m->avctx, AV_LOG_DEBUG, "Mono stream with 2 substreams, ignoring 2nd\n"); m->max_decoded_substream = 0; if (m->avctx->channels==2) m->avctx->channel_layout = AV_CH_LAYOUT_STEREO; m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20; return 0;

[[[[Adv]]]]: static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb) { MLPHeaderInfo mh; int [[mnage]], ret; if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0) return ret; if (mh.group1_bits == 0) { av_log(m->avctx, AV_LOG_ERROR, "invalid/unknown bits per sample\n"); return AVERROR_INVALIDDATA; if (mh.group2_bits > mh.group1_bits) { av_log(m->avctx, AV_LOG_ERROR, "Channel group 2 cannot have more bits per sample than group 1.\n"); return AVERROR_INVALIDDATA; if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) { av_log(m->avctx, AV_LOG_ERROR, "Channel groups with differing sample rates are not currently supported.\n"); return AVERROR_INVALIDDATA; if (mh.group1_samplerate == 0) { av_log(m->avctx, AV_LOG_ERROR, "invalid/unknown sampling rate\n"); return AVERROR_INVALIDDATA; if (mh.group1_samplerate > MAX_SAMPLERATE) { av_log(m->avctx, AV_LOG_ERROR, "Sampling rate %d is greater than the supported maximum (%d).\n", mh.group1_samplerate, MAX_SAMPLERATE); return AVERROR_INVALIDDATA; if (mh.access_unit_size > MAX_BLOCKSIZE) { av_log(m->avctx, AV_LOG_ERROR, "Block size %d is greater than the supported maximum (%d).\n", mh.access_unit_size, MAX_BLOCKSIZE); return AVERROR_INVALIDDATA; if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) { av_log(m->avctx, AV_LOG_ERROR, "Block size pow2 %d is greater than the supported maximum (%d).\n", mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2); return AVERROR_INVALIDDATA; if (mh.num_substreams == 0) return AVERROR_INVALIDDATA; if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) { av_log(m->avctx, AV_LOG_ERROR, "MLP only supports up to 2 substreams.\n"); return AVERROR_INVALIDDATA; if (mh.num_substreams > MAX_SUBSTREAMS) { "%d substreams (more than the " "maximum supported by the decoder)", mh.num_substreams); m->access_unit_size = mh.access_unit_size; m->access_unit_size_pow2 = mh.access_unit_size_pow2; m->num_substreams = mh.num_substreams; m->max_decoded_substream = m->num_substreams - 1; m->avctx->sample_rate = mh.group1_samplerate; m->avctx->frame_size = mh.access_unit_size; m->avctx->bits_per_raw_sample = mh.group1_bits; if (mh.group1_bits > 16) m->avctx->sample_fmt = AV_SAMPLE_FMT_S32; else m->avctx->sample_fmt = AV_SAMPLE_FMT_S16; m->params_valid = 1; for ([[mnage]] = 0; [[mnage]] < MAX_SUBSTREAMS; [[mnage]]++) m->substream[[[mnage]]].restart_seen = 0; if (m->avctx->codec_id == AV_CODEC_ID_MLP) { if (([[mnage]] = (mh.num_substreams > 1))) m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO; m->substream[[[mnage]]].ch_layout = mh.channel_layout_mlp; } else { if (([[mnage]] = (mh.num_substreams > 1))) m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO; if (mh.num_substreams > 2) if (mh.channel_layout_thd_stream2) m->substream[2].ch_layout = mh.channel_layout_thd_stream2; else m->substream[2].ch_layout = mh.channel_layout_thd_stream1; m->substream[[[mnage]]].ch_layout = mh.channel_layout_thd_stream1; if (m->avctx->channels<=2 && m->substream[[[mnage]]].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) { av_log(m->avctx, AV_LOG_DEBUG, "Mono stream with 2 substreams, ignoring 2nd\n"); m->max_decoded_substream = 0; if (m->avctx->channels==2) m->avctx->channel_layout = AV_CH_LAYOUT_STEREO; m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20; return 0;
--------------------------------------------- Result 82 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void cpu_tick_set_count(CPUTimer *timer, uint64_t count) { uint64_t real_count = count & ~timer->disabled_mask; uint64_t disabled_bit = count & timer->disabled_mask; int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) - cpu_to_timer_ticks(real_count, timer->frequency); TIMER_DPRINTF("%s set_count count=0x%016lx (%s) p=%p\n", timer->name, real_count, timer->disabled?"disabled":"enabled", timer); timer->disabled = disabled_bit ? 1 : 0; timer->clock_offset = vm_clock_offset; }
--------------------------------------------- Result 83 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 44 / 1 / 38 / 83:   3%|         | 83/2690 [10:44<5:37:27,  7.77s/it][Succeeded / Failed / Skipped / Total] 44 / 1 / 38 / 83:   3%|         | 84/2690 [11:19<5:51:32,  8.09s/it][Succeeded / Failed / Skipped / Total] 44 / 2 / 38 / 84:   3%|         | 84/2690 [11:19<5:51:32,  8.09s/it][Succeeded / Failed / Skipped / Total] 44 / 2 / 38 / 84:   3%|         | 85/2690 [11:20<5:47:31,  8.00s/it][Succeeded / Failed / Skipped / Total] 44 / 2 / 39 / 85:   3%|         | 85/2690 [11:20<5:47:31,  8.00s/it][Succeeded / Failed / Skipped / Total] 44 / 2 / 39 / 85:   3%|         | 86/2690 [11:20<5:43:36,  7.92s/it][Succeeded / Failed / Skipped / Total] 44 / 2 / 40 / 86:   3%|         | 86/2690 [11:20<5:43:36,  7.92s/it][Succeeded / Failed / Skipped / Total] 44 / 2 / 40 / 86:   3%|         | 87/2690 [11:21<5:39:46,  7.83s/it][Succeeded / Failed / Skipped / Total] 44 / 2 / 41 / 87:   3%|         | 87/2690 [11:21<5:39:46,  7.83s/it][Succeeded / Failed / Skipped / Total] 44 / 2 / 41 / 87:   3%|         | 88/2690 [11:23<5:37:00,  7.77s/it][Succeeded / Failed / Skipped / Total] 45 / 2 / 41 / 88:   3%|         | 88/2690 [11:23<5:37:00,  7.77s/it][Succeeded / Failed / Skipped / Total] 45 / 2 / 41 / 88:   3%|         | 89/2690 [11:24<5:33:19,  7.69s/it][Succeeded / Failed / Skipped / Total] 45 / 2 / 42 / 89:   3%|         | 89/2690 [11:24<5:33:19,  7.69s/it][Succeeded / Failed / Skipped / Total] 45 / 2 / 42 / 89:   3%|         | 90/2690 [11:33<5:33:48,  7.70s/it][Succeeded / Failed / Skipped / Total] 46 / 2 / 42 / 90:   3%|         | 90/2690 [11:33<5:33:48,  7.70s/it][Succeeded / Failed / Skipped / Total] 46 / 2 / 42 / 90:   3%|         | 91/2690 [11:57<5:41:37,  7.89s/it][[0 (80%)]] --> [[0 (41%)]] --> Socre: 0.5884890556335449

[[[[Adv]]]]: static void vscsi_process_login(VSCSIState *[[s]], vscsi_req *[[req]]) { union viosrp_iu *[[iu]] = &[[req]]->iu; struct srp_login_rsp *rsp = &[[iu]]->srp.login_rsp; uint64_t tag = [[iu]]->srp.rsp.tag; trace_spapr_vscsi__process_login(); memset([[iu]], 0, sizeof(struct srp_login_rsp)); rsp->opcode = SRP_LOGIN_RSP; rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2); rsp->tag = tag; rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu)); rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu)); rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT); vscsi_send_iu([[s]], [[req]], sizeof(*rsp), VIOSRP_SRP_FORMAT); }

[[[[Adv]]]]: static void vscsi_process_login(VSCSIState *[[to]], vscsi_req *[[requirements]]) { union viosrp_iu *[[metaphysical]] = &[[requirements]]->iu; struct srp_login_rsp *rsp = &[[metaphysical]]->srp.login_rsp; uint64_t tag = [[metaphysical]]->srp.rsp.tag; trace_spapr_vscsi__process_login(); memset([[metaphysical]], 0, sizeof(struct srp_login_rsp)); rsp->opcode = SRP_LOGIN_RSP; rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2); rsp->tag = tag; rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu)); rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu)); rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT); vscsi_send_iu([[to]], [[requirements]], sizeof(*rsp), VIOSRP_SRP_FORMAT); }
--------------------------------------------- Result 84 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int bdrv_is_removable(BlockDriverState *bs) { return bs->removable; }

[[[[Adv]]]]: int bdrv_is_removable(BlockDriverState *bs) { return bs->removable; }
--------------------------------------------- Result 85 ---------------------------------------------
[[0 (12%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref) { return 0; }
--------------------------------------------- Result 86 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qmp_blockdev_add(BlockdevOptions *options, Error **errp) { QmpOutputVisitor *ov = qmp_output_visitor_new(); QObject *obj; QDict *qdict; Error *local_err = NULL; if (!options->has_id) { error_setg(errp, "Block device needs an ID"); goto fail; } if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) { bool direct = options->cache->has_direct && options->cache->direct; if (!options->has_cache && !direct) { error_setg(errp, "aio=native requires cache.direct=true"); goto fail; } } visit_type_BlockdevOptions(qmp_output_get_visitor(ov), &options, NULL, &local_err); if (local_err) { error_propagate(errp, local_err); goto fail; } obj = qmp_output_get_qobject(ov); qdict = qobject_to_qdict(obj); qdict_flatten(qdict); blockdev_init(NULL, qdict, &local_err); if (local_err) { error_propagate(errp, local_err); goto fail; } fail: qmp_output_visitor_cleanup(ov); }
--------------------------------------------- Result 87 ---------------------------------------------
[[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void kvmclock_pre_save(void *opaque) { KVMClockState *s = opaque; struct kvm_clock_data data; int ret; if (s->clock_valid) { return; } ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data); if (ret < 0) { fprintf(stderr, "KVM_GET_CLOCK failed: %s\n", strerror(ret)); data.clock = 0; } s->clock = data.clock; s->clock_valid = !runstate_is_running(); }
--------------------------------------------- Result 88 ---------------------------------------------
[[0 (65%)]] --> [[0 (43%)]] --> Socre: 0.5688989162445068

[[[[Adv]]]]: static void handle_satn(ESPState *s) { uint8_t buf[32]; int [[len]]; if (s->dma && !s->dma_enabled) { s->dma_cb = handle_satn; return; } [[len]] = get_cmd(s, buf); if ([[len]]) do_cmd(s, buf); }

[[[[Adv]]]]: static void handle_satn(ESPState *s) { uint8_t buf[32]; int [[hardly]]; if (s->dma && !s->dma_enabled) { s->dma_cb = handle_satn; return; } [[hardly]] = get_cmd(s, buf); if ([[hardly]]) do_cmd(s, buf); }
--------------------------------------------- Result 89 ---------------------------------------------
[[0 (7%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int check_checksum(ByteIOContext *bc){ unsigned long checksum= get_checksum(bc); av_log(NULL, AV_LOG_ERROR, "%08X %08X\n", checksum, (int)get_be32(bc)); return 0; }
--------------------------------------------- Result 90 ---------------------------------------------
[[0 (43%)]] --> [[0 (53%)]] --> Socre: 0.5322648286819458

[[[[Adv]]]]: int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind [[kind]], const char *version, const char *serial, const char *model, uint64_t wwn, uint32_t cylinders, uint32_t heads, uint32_t secs, int [[chs_trans]]) { uint64_t nb_sectors; s->blk = blk; s->drive_kind = [[kind]]; blk_get_geometry(blk, &nb_sectors); s->cylinders = cylinders; s->heads = heads; s->sectors = secs; s->chs_trans = [[chs_trans]]; s->nb_sectors = nb_sectors; s->wwn = wwn; s->smart_enabled = 1; s->smart_autosave = 1; s->smart_errors = 0; s->smart_selftest_count = 0; if ([[kind]] == IDE_CD) { blk_set_dev_ops(blk, &ide_cd_block_ops, s); blk_set_guest_block_size(blk, 2048); } else { if (!blk_is_inserted(s->blk)) { error_report("Device needs media, but drive is empty"); return -1; } if (blk_is_read_only(blk)) { error_report("Can't use a read-only drive"); return -1; } blk_set_dev_ops(blk, &ide_hd_block_ops, s); } if (serial) { pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial); } else { snprintf(s->drive_serial_str, sizeof(s->drive_serial_str), "QM%05d", s->drive_serial); } if (model) { pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model); } else { switch ([[kind]]) { case IDE_CD: strcpy(s->drive_model_str, "QEMU DVD-ROM"); break; case IDE_CFATA: strcpy(s->drive_model_str, "QEMU MICRODRIVE"); break; default: strcpy(s->drive_model_str, "QEMU HARDDISK"); break; } } if (version) { pstrcpy(s->version, sizeof(s->version), version); } else { pstrcpy(s->version, sizeof(s->version), qemu_get_version()); } ide_reset(s); blk_iostatus_enable(blk); return 0; }

[[[[Adv]]]]: int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind [[marshalling]], const char *version, const char *serial, const char *model, uint64_t wwn, uint32_t cylinders, uint32_t heads, uint32_t secs, int [[projectiles]]) { uint64_t nb_sectors; s->blk = blk; s->drive_kind = [[marshalling]]; blk_get_geometry(blk, &nb_sectors); s->cylinders = cylinders; s->heads = heads; s->sectors = secs; s->chs_trans = [[projectiles]]; s->nb_sectors = nb_sectors; s->wwn = wwn; s->smart_enabled = 1; s->smart_autosave = 1; s->smart_errors = 0; s->smart_selftest_count = 0; if ([[marshalling]] == IDE_CD) { blk_set_dev_ops(blk, &ide_cd_block_ops, s); blk_set_guest_block_size(blk, 2048); } else { if (!blk_is_inserted(s->blk)) { error_report("Device needs media, but drive is empty"); return -1; } if (blk_is_read_only(blk)) { error_report("Can't use a read-only drive"); return -1; } blk_set_dev_ops(blk, &ide_hd_block_ops, s); } if (serial) { pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial); } else { snprintf(s->drive_serial_str, sizeof(s->drive_serial_str), "QM%05d", s->drive_serial); } if (model) { pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model); } else { switch ([[marshalling]]) { case IDE_CD: strcpy(s->drive_model_str, "QEMU DVD-ROM"); break; case IDE_CFATA: strcpy(s->drive_model_str, "QEMU MICRODRIVE"); break; default: strcpy(s->drive_model_str, "QEMU HARDDISK"); break; } } if (version) { pstrcpy(s->version, sizeof(s->version), version); } else { pstrcpy(s->version, sizeof(s->version), qemu_get_version()); } ide_reset(s); blk_iostatus_enable(blk); return 0; }
--------------------------------------------- Result 91 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 47 / 2 / 42 / 91:   3%|         | 91/2690 [11:57<5:41:37,  7.89s/it][Succeeded / Failed / Skipped / Total] 47 / 2 / 42 / 91:   3%|         | 92/2690 [12:36<5:56:08,  8.23s/it][Succeeded / Failed / Skipped / Total] 48 / 2 / 42 / 92:   3%|         | 92/2690 [12:36<5:56:08,  8.23s/it][Succeeded / Failed / Skipped / Total] 48 / 2 / 42 / 92:   3%|         | 93/2690 [12:42<5:54:40,  8.19s/it][Succeeded / Failed / Skipped / Total] 49 / 2 / 42 / 93:   3%|         | 93/2690 [12:42<5:54:40,  8.19s/it][Succeeded / Failed / Skipped / Total] 49 / 2 / 42 / 93:   3%|         | 94/2690 [12:42<5:51:00,  8.11s/it][Succeeded / Failed / Skipped / Total] 49 / 2 / 43 / 94:   3%|         | 94/2690 [12:42<5:51:00,  8.11s/it][Succeeded / Failed / Skipped / Total] 49 / 2 / 43 / 94:   4%|         | 95/2690 [14:13<6:28:31,  8.98s/it][[0 (55%)]] --> [[0 (34%)]] --> Socre: 0.6556187272071838

[[[[Adv]]]]: int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev, uint64_t [[iova]], uint64_t len) { struct vhost_iotlb_msg imsg; imsg.iova = [[iova]]; imsg.size = len; imsg.type = VHOST_IOTLB_INVALIDATE; return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg); }

[[[[Adv]]]]: int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev, uint64_t [[clary]], uint64_t len) { struct vhost_iotlb_msg imsg; imsg.iova = [[clary]]; imsg.size = len; imsg.type = VHOST_IOTLB_INVALIDATE; return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg); }
--------------------------------------------- Result 92 ---------------------------------------------
[[0 (3%)]] --> [[0 (54%)]] --> Socre: 0.5410327315330505

[[[[Adv]]]]: static uint32_t gic_dist_readw(void *[[opaque]], target_phys_addr_t [[offset]]) { uint32_t val; val = gic_dist_readb([[opaque]], [[offset]]); val |= gic_dist_readb([[opaque]], [[offset]] + 1) << 8; return val; }

[[[[Adv]]]]: static uint32_t gic_dist_readw(void *[[misty]], target_phys_addr_t [[reimburse]]) { uint32_t val; val = gic_dist_readb([[misty]], [[reimburse]]); val |= gic_dist_readb([[misty]], [[reimburse]] + 1) << 8; return val; }
--------------------------------------------- Result 93 ---------------------------------------------
[[0 (46%)]] --> [[0 (69%)]] --> Socre: 0.6945853233337402

[[[[Adv]]]]: static void test_qemu_strtoull_overflow(void) { const char *str = "99999999999999999999999999999999999999999999"; char f = 'X'; const char *[[endptr]] = &f; uint64_t res = 999; int err; err = qemu_strtoull(str, &[[endptr]], 0, &res); g_assert_cmpint(err, ==, -ERANGE); g_assert_cmpint(res, ==, ULLONG_MAX); g_assert([[endptr]] == str + strlen(str)); }

[[[[Adv]]]]: static void test_qemu_strtoull_overflow(void) { const char *str = "99999999999999999999999999999999999999999999"; char f = 'X'; const char *[[himmat]] = &f; uint64_t res = 999; int err; err = qemu_strtoull(str, &[[himmat]], 0, &res); g_assert_cmpint(err, ==, -ERANGE); g_assert_cmpint(res, ==, ULLONG_MAX); g_assert([[himmat]] == str + strlen(str)); }
--------------------------------------------- Result 94 ---------------------------------------------
[[0 (64%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: PXA2xxState *pxa255_init(unsigned int sdram_size) { PXA2xxState *s; int iomemtype, i; DriveInfo *dinfo; s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState)); s->env = cpu_init("pxa255"); if (!s->env) { fprintf(stderr, "Unable to find CPU definition\n"); exit(1); } s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0]; cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size, qemu_ram_alloc(NULL, "pxa255.sdram", sdram_size) | IO_MEM_RAM); cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE, qemu_ram_alloc(NULL, "pxa255.internal", PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM); s->pic = pxa2xx_pic_init(0x40d00000, s->env); s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]); pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]); s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85); dinfo = drive_get(IF_SD, 0, 0); if (!dinfo) { fprintf(stderr, "qemu: missing SecureDigital device\n"); exit(1); } s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv, s->pic[PXA2XX_PIC_MMC], s->dma); for (i = 0; pxa255_serial[i].io_base; i ++) if (serial_hds[i]) { #ifdef TARGET_WORDS_BIGENDIAN serial_mm_init(pxa255_serial[i].io_base, 2, s->pic[pxa255_serial[i].irqn], 14745600/16, serial_hds[i], 1, 1); #else serial_mm_init(pxa255_serial[i].io_base, 2, s->pic[pxa255_serial[i].irqn], 14745600/16, serial_hds[i], 1, 0); #endif } else { break; } if (serial_hds[i]) s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP], s->dma, serial_hds[i]); s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]); s->cm_base = 0x41300000; s->cm_regs[CCCR >> 2] = 0x02000210; s->clkcfg = 0x00000009; iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn, pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype); register_savevm(NULL, "pxa2xx_cm", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s); cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s); s->mm_base = 0x48000000; s->mm_regs[MDMRS >> 2] = 0x00020002; s->mm_regs[MDREFR >> 2] = 0x03ca4000; s->mm_regs[MECR >> 2] = 0x00000001; iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn, pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype); register_savevm(NULL, "pxa2xx_mm", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s); s->pm_base = 0x40f00000; iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn, pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->pm_base, 0x100, iomemtype); register_savevm(NULL, "pxa2xx_pm", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s); for (i = 0; pxa255_ssp[i].io_base; i ++); s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i); for (i = 0; pxa255_ssp[i].io_base; i ++) { DeviceState *dev; dev = sysbus_create_simple("pxa2xx-ssp", pxa255_ssp[i].io_base, s->pic[pxa255_ssp[i].irqn]); s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, "ssi"); } if (usb_enabled) { sysbus_create_simple("sysbus-ohci", 0x4c000000, s->pic[PXA2XX_PIC_USBH1]); } s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000); s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000); s->rtc_base = 0x40900000; iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn, pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype); pxa2xx_rtc_init(s); register_savevm(NULL, "pxa2xx_rtc", 0, 0, pxa2xx_rtc_save, pxa2xx_rtc_load, s); s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff); s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff); s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma); qdev_connect_gpio_out(s->gpio, 1, s->reset); return s; }
--------------------------------------------- Result 95 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 50 / 2 / 43 / 95:   4%|         | 95/2690 [14:13<6:28:31,  8.98s/it][Succeeded / Failed / Skipped / Total] 50 / 2 / 43 / 95:   4%|         | 96/2690 [15:04<6:47:30,  9.43s/it][Succeeded / Failed / Skipped / Total] 51 / 2 / 43 / 96:   4%|         | 96/2690 [15:04<6:47:30,  9.43s/it][Succeeded / Failed / Skipped / Total] 51 / 2 / 43 / 96:   4%|         | 97/2690 [15:12<6:46:22,  9.40s/it][[0 (100%)]] --> [[0 (37%)]] --> Socre: 0.6277719736099243

[[[[Adv]]]]: void commit_start(const char *job_id, BlockDriverState *bs, BlockDriverState *base, BlockDriverState *[[top]], int64_t speed, BlockdevOnError on_error, const char *[[backing_file_str]], const char *filter_node_name, Error **errp) { CommitBlockJob *s; BlockReopenQueue *reopen_queue = NULL; int orig_overlay_flags; int orig_base_flags; BlockDriverState *iter; BlockDriverState *overlay_bs; BlockDriverState *commit_top_bs = NULL; Error *local_err = NULL; int ret; assert([[top]] != bs); if ([[top]] == base) { error_setg(errp, "Invalid files for merge: top and base are the same"); return; overlay_bs = bdrv_find_overlay(bs, [[top]]); if (overlay_bs == NULL) { error_setg(errp, "Could not find overlay image for %s:", [[top]]->filename); return; s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL, speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp); if (!s) { return; orig_base_flags = bdrv_get_flags(base); orig_overlay_flags = bdrv_get_flags(overlay_bs); if (!(orig_base_flags & BDRV_O_RDWR)) { reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL, orig_base_flags | BDRV_O_RDWR); if (!(orig_overlay_flags & BDRV_O_RDWR)) { reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL, orig_overlay_flags | BDRV_O_RDWR); if (reopen_queue) { bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err); if (local_err != NULL) { error_propagate(errp, local_err); goto fail; commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0, errp); if (commit_top_bs == NULL) { goto fail; commit_top_bs->total_sectors = [[top]]->total_sectors; bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context([[top]])); bdrv_set_backing_hd(commit_top_bs, [[top]], &local_err); if (local_err) { bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err); if (local_err) { bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; s->commit_top_bs = commit_top_bs; bdrv_unref(commit_top_bs); assert(bdrv_chain_contains([[top]], base)); for (iter = [[top]]; iter != base; iter = backing_bs(iter)) { ret = block_job_add_bdrv(&s->common, "intermediate node", iter, 0, BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE, errp); if (ret < 0) { goto fail; ret = block_job_add_bdrv(&s->common, "base", base, 0, BLK_PERM_ALL, errp); if (ret < 0) { goto fail; ret = block_job_add_bdrv(&s->common, "overlay of top", overlay_bs, BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp); if (ret < 0) { goto fail; s->base = blk_new(BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE | BLK_PERM_RESIZE, BLK_PERM_CONSISTENT_READ | BLK_PERM_GRAPH_MOD | BLK_PERM_WRITE_UNCHANGED); ret = blk_insert_bs(s->base, base, errp); if (ret < 0) { goto fail; s->top = blk_new(0, BLK_PERM_ALL); ret = blk_insert_bs(s->top, [[top]], errp); if (ret < 0) { goto fail; s->active = bs; s->base_flags = orig_base_flags; s->orig_overlay_flags = orig_overlay_flags; s->backing_file_str = g_strdup([[backing_file_str]]); s->on_error = on_error; trace_commit_start(bs, base, [[top]], s); block_job_start(&s->common); return; fail: if (s->base) { blk_unref(s->base); if (s->top) { blk_unref(s->top); if (commit_top_bs) { bdrv_set_backing_hd(overlay_bs, [[top]], &error_abort); block_job_early_fail(&s->common);

[[[[Adv]]]]: void commit_start(const char *job_id, BlockDriverState *bs, BlockDriverState *base, BlockDriverState *[[leading]], int64_t speed, BlockdevOnError on_error, const char *[[slo]], const char *filter_node_name, Error **errp) { CommitBlockJob *s; BlockReopenQueue *reopen_queue = NULL; int orig_overlay_flags; int orig_base_flags; BlockDriverState *iter; BlockDriverState *overlay_bs; BlockDriverState *commit_top_bs = NULL; Error *local_err = NULL; int ret; assert([[leading]] != bs); if ([[leading]] == base) { error_setg(errp, "Invalid files for merge: top and base are the same"); return; overlay_bs = bdrv_find_overlay(bs, [[leading]]); if (overlay_bs == NULL) { error_setg(errp, "Could not find overlay image for %s:", [[leading]]->filename); return; s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL, speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp); if (!s) { return; orig_base_flags = bdrv_get_flags(base); orig_overlay_flags = bdrv_get_flags(overlay_bs); if (!(orig_base_flags & BDRV_O_RDWR)) { reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL, orig_base_flags | BDRV_O_RDWR); if (!(orig_overlay_flags & BDRV_O_RDWR)) { reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL, orig_overlay_flags | BDRV_O_RDWR); if (reopen_queue) { bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err); if (local_err != NULL) { error_propagate(errp, local_err); goto fail; commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0, errp); if (commit_top_bs == NULL) { goto fail; commit_top_bs->total_sectors = [[leading]]->total_sectors; bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context([[leading]])); bdrv_set_backing_hd(commit_top_bs, [[leading]], &local_err); if (local_err) { bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err); if (local_err) { bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; s->commit_top_bs = commit_top_bs; bdrv_unref(commit_top_bs); assert(bdrv_chain_contains([[leading]], base)); for (iter = [[leading]]; iter != base; iter = backing_bs(iter)) { ret = block_job_add_bdrv(&s->common, "intermediate node", iter, 0, BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE, errp); if (ret < 0) { goto fail; ret = block_job_add_bdrv(&s->common, "base", base, 0, BLK_PERM_ALL, errp); if (ret < 0) { goto fail; ret = block_job_add_bdrv(&s->common, "overlay of top", overlay_bs, BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp); if (ret < 0) { goto fail; s->base = blk_new(BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE | BLK_PERM_RESIZE, BLK_PERM_CONSISTENT_READ | BLK_PERM_GRAPH_MOD | BLK_PERM_WRITE_UNCHANGED); ret = blk_insert_bs(s->base, base, errp); if (ret < 0) { goto fail; s->top = blk_new(0, BLK_PERM_ALL); ret = blk_insert_bs(s->top, [[leading]], errp); if (ret < 0) { goto fail; s->active = bs; s->base_flags = orig_base_flags; s->orig_overlay_flags = orig_overlay_flags; s->backing_file_str = g_strdup([[slo]]); s->on_error = on_error; trace_commit_start(bs, base, [[leading]], s); block_job_start(&s->common); return; fail: if (s->base) { blk_unref(s->base); if (s->top) { blk_unref(s->top); if (commit_top_bs) { bdrv_set_backing_hd(overlay_bs, [[leading]], &error_abort); block_job_early_fail(&s->common);
--------------------------------------------- Result 96 ---------------------------------------------
[[0 (2%)]] --> [[0 (94%)]] --> Socre: 0.9401501417160034

[[[[Adv]]]]: int usb_device_delete_addr(int [[busnr]], int addr) { USBBus *bus; USBPort *port; USBDevice *dev; bus = usb_bus_find([[busnr]]); if (!bus) return -1; TAILQ_FOREACH(port, &bus->used, next) { if (port->dev->addr == addr) break; } if (!port) return -1; dev = port->dev; TAILQ_REMOVE(&bus->used, port, next); bus->nused--; usb_attach(port, NULL); dev->info->handle_destroy(dev); TAILQ_INSERT_TAIL(&bus->free, port, next); bus->nfree++; return 0; }

[[[[Adv]]]]: int usb_device_delete_addr(int [[to]], int addr) { USBBus *bus; USBPort *port; USBDevice *dev; bus = usb_bus_find([[to]]); if (!bus) return -1; TAILQ_FOREACH(port, &bus->used, next) { if (port->dev->addr == addr) break; } if (!port) return -1; dev = port->dev; TAILQ_REMOVE(&bus->used, port, next); bus->nused--; usb_attach(port, NULL); dev->info->handle_destroy(dev); TAILQ_INSERT_TAIL(&bus->free, port, next); bus->nfree++; return 0; }
--------------------------------------------- Result 97 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 51 / 3 / 43 / 97:   4%|         | 97/2690 [15:12<6:46:22,  9.40s/it][Succeeded / Failed / Skipped / Total] 51 / 3 / 43 / 97:   4%|         | 98/2690 [15:13<6:42:28,  9.32s/it][Succeeded / Failed / Skipped / Total] 52 / 3 / 43 / 98:   4%|         | 98/2690 [15:13<6:42:28,  9.32s/it][Succeeded / Failed / Skipped / Total] 52 / 3 / 43 / 98:   4%|         | 99/2690 [15:13<6:38:30,  9.23s/it][[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: START_TEST(qint_get_int_test) { QInt *qi; const int value = 123456; qi = qint_from_int(value); fail_unless(qint_get_int(qi) == value); QDECREF(qi); }

[[[[Adv]]]]: START_TEST(qint_get_int_test) { QInt *qi; const int value = 123456; qi = qint_from_int(value); fail_unless(qint_get_int(qi) == value); QDECREF(qi); }
--------------------------------------------- Result 98 ---------------------------------------------
[[0 (55%)]] --> [[0 (36%)]] --> Socre: 0.6371446847915649

[[[[Adv]]]]: static int aio_write_f(BlockBackend *[[blk]], int argc, char **argv) { int nr_iov, c; int pattern = 0xcd; struct aio_ctx *ctx = g_new0(struct aio_ctx, 1); ctx->blk = [[blk]]; while ((c = getopt(argc, argv, "CqP:z")) != -1) { switch (c) { case 'C': ctx->Cflag = 1; break; case 'q': ctx->qflag = 1; break; case 'P': pattern = parse_pattern(optarg); if (pattern < 0) { return 0; } break; case 'z': ctx->zflag = 1; break; default: return qemuio_command_usage(&aio_write_cmd); } } if (optind > argc - 2) { return qemuio_command_usage(&aio_write_cmd); } if (ctx->zflag && optind != argc - 2) { printf("-z supports only a single length parameter\n"); return 0; } if (ctx->zflag && ctx->Pflag) { printf("-z and -P cannot be specified at the same time\n"); return 0; } ctx->offset = cvtnum(argv[optind]); if (ctx->offset < 0) { print_cvtnum_err(ctx->offset, argv[optind]); return 0; } optind++; if (ctx->offset & 0x1ff) { printf("offset %" PRId64 " is not sector aligned\n", ctx->offset); block_acct_invalid(blk_get_stats([[blk]]), BLOCK_ACCT_WRITE); return 0; } if (ctx->zflag) { int64_t count = cvtnum(argv[optind]); if (count < 0) { print_cvtnum_err(count, argv[optind]); return 0; } ctx->qiov.size = count; blk_aio_write_zeroes([[blk]], ctx->offset >> 9, count >> 9, 0, aio_write_done, ctx); } else { nr_iov = argc - optind; ctx->buf = create_iovec([[blk]], &ctx->qiov, &argv[optind], nr_iov, pattern); if (ctx->buf == NULL) { block_acct_invalid(blk_get_stats([[blk]]), BLOCK_ACCT_WRITE); return 0; } gettimeofday(&ctx->t1, NULL); block_acct_start(blk_get_stats([[blk]]), &ctx->acct, ctx->qiov.size, BLOCK_ACCT_WRITE); blk_aio_writev([[blk]], ctx->offset >> 9, &ctx->qiov, ctx->qiov.size >> 9, aio_write_done, ctx); } return 0; }

[[[[Adv]]]]: static int aio_write_f(BlockBackend *[[infantry]], int argc, char **argv) { int nr_iov, c; int pattern = 0xcd; struct aio_ctx *ctx = g_new0(struct aio_ctx, 1); ctx->blk = [[infantry]]; while ((c = getopt(argc, argv, "CqP:z")) != -1) { switch (c) { case 'C': ctx->Cflag = 1; break; case 'q': ctx->qflag = 1; break; case 'P': pattern = parse_pattern(optarg); if (pattern < 0) { return 0; } break; case 'z': ctx->zflag = 1; break; default: return qemuio_command_usage(&aio_write_cmd); } } if (optind > argc - 2) { return qemuio_command_usage(&aio_write_cmd); } if (ctx->zflag && optind != argc - 2) { printf("-z supports only a single length parameter\n"); return 0; } if (ctx->zflag && ctx->Pflag) { printf("-z and -P cannot be specified at the same time\n"); return 0; } ctx->offset = cvtnum(argv[optind]); if (ctx->offset < 0) { print_cvtnum_err(ctx->offset, argv[optind]); return 0; } optind++; if (ctx->offset & 0x1ff) { printf("offset %" PRId64 " is not sector aligned\n", ctx->offset); block_acct_invalid(blk_get_stats([[infantry]]), BLOCK_ACCT_WRITE); return 0; } if (ctx->zflag) { int64_t count = cvtnum(argv[optind]); if (count < 0) { print_cvtnum_err(count, argv[optind]); return 0; } ctx->qiov.size = count; blk_aio_write_zeroes([[infantry]], ctx->offset >> 9, count >> 9, 0, aio_write_done, ctx); } else { nr_iov = argc - optind; ctx->buf = create_iovec([[infantry]], &ctx->qiov, &argv[optind], nr_iov, pattern); if (ctx->buf == NULL) { block_acct_invalid(blk_get_stats([[infantry]]), BLOCK_ACCT_WRITE); return 0; } gettimeofday(&ctx->t1, NULL); block_acct_start(blk_get_stats([[infantry]]), &ctx->acct, ctx->qiov.size, BLOCK_ACCT_WRITE); blk_aio_writev([[infantry]], ctx->offset >> 9, &ctx->qiov, ctx->qiov.size >> 9, aio_write_done, ctx); } return 0; }
--------------------------------------------- Result 99 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 52 / 3 / 44 / 99:   4%|         | 99/2690 [15:13<6:38:30,  9.23s/it][Succeeded / Failed / Skipped / Total] 52 / 3 / 44 / 99:   4%|         | 100/2690 [15:21<6:37:55,  9.22s/it][Succeeded / Failed / Skipped / Total] 53 / 3 / 44 / 100:   4%|         | 100/2690 [15:21<6:37:55,  9.22s/it][Succeeded / Failed / Skipped / Total] 53 / 3 / 44 / 100:   4%|         | 101/2690 [16:17<6:57:46,  9.68s/it][[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int alac_decode_frame(AVCodecContext *avctx, void *outbuffer, int *outputsize, const uint8_t *inbuffer, int input_buffer_size) { ALACContext *alac = avctx->priv_data; int channels; unsigned int outputsamples; int hassize; int readsamplesize; int wasted_bytes; int isnotcompressed; uint8_t interlacing_shift; uint8_t interlacing_leftweight; if (!inbuffer || !input_buffer_size) return input_buffer_size; if (!alac->context_initialized) { if (alac->avctx->extradata_size != ALAC_EXTRADATA_SIZE) { av_log(avctx, AV_LOG_ERROR, "alac: expected %d extradata bytes\n", ALAC_EXTRADATA_SIZE); return input_buffer_size; } if (alac_set_info(alac)) { av_log(avctx, AV_LOG_ERROR, "alac: set_info failed\n"); return input_buffer_size; } alac->context_initialized = 1; } init_get_bits(&alac->gb, inbuffer, input_buffer_size * 8); channels = get_bits(&alac->gb, 3) + 1; if (channels > MAX_CHANNELS) { av_log(avctx, AV_LOG_ERROR, "channels > %d not supported\n", MAX_CHANNELS); return input_buffer_size; } skip_bits(&alac->gb, 4); skip_bits(&alac->gb, 12); hassize = get_bits1(&alac->gb); wasted_bytes = get_bits(&alac->gb, 2); isnotcompressed = get_bits1(&alac->gb); if (hassize) { outputsamples = get_bits_long(&alac->gb, 32); if(outputsamples > alac->setinfo_max_samples_per_frame){ av_log(avctx, AV_LOG_ERROR, "outputsamples %d > %d\n", outputsamples, alac->setinfo_max_samples_per_frame); return -1; } } else outputsamples = alac->setinfo_max_samples_per_frame; if(outputsamples > *outputsize / alac->bytespersample){ av_log(avctx, AV_LOG_ERROR, "sample buffer too small\n"); return -1; } *outputsize = outputsamples * alac->bytespersample; readsamplesize = alac->setinfo_sample_size - (wasted_bytes * 8) + channels - 1; if (!isnotcompressed) { int16_t predictor_coef_table[channels][32]; int predictor_coef_num[channels]; int prediction_type[channels]; int prediction_quantitization[channels]; int ricemodifier[channels]; int i, chan; interlacing_shift = get_bits(&alac->gb, 8); interlacing_leftweight = get_bits(&alac->gb, 8); for (chan = 0; chan < channels; chan++) { prediction_type[chan] = get_bits(&alac->gb, 4); prediction_quantitization[chan] = get_bits(&alac->gb, 4); ricemodifier[chan] = get_bits(&alac->gb, 3); predictor_coef_num[chan] = get_bits(&alac->gb, 5); for (i = 0; i < predictor_coef_num[chan]; i++) predictor_coef_table[chan][i] = (int16_t)get_bits(&alac->gb, 16); } if (wasted_bytes) av_log(avctx, AV_LOG_ERROR, "FIXME: unimplemented, unhandling of wasted_bytes\n"); for (chan = 0; chan < channels; chan++) { bastardized_rice_decompress(alac, alac->predicterror_buffer[chan], outputsamples, readsamplesize, alac->setinfo_rice_initialhistory, alac->setinfo_rice_kmodifier, ricemodifier[chan] * alac->setinfo_rice_historymult / 4, (1 << alac->setinfo_rice_kmodifier) - 1); if (prediction_type[chan] == 0) { predictor_decompress_fir_adapt(alac->predicterror_buffer[chan], alac->outputsamples_buffer[chan], outputsamples, readsamplesize, predictor_coef_table[chan], predictor_coef_num[chan], prediction_quantitization[chan]); } else { av_log(avctx, AV_LOG_ERROR, "FIXME: unhandled prediction type: %i\n", prediction_type[chan]); } } } else { int i, chan; for (i = 0; i < outputsamples; i++) for (chan = 0; chan < channels; chan++) { int32_t audiobits; audiobits = get_bits_long(&alac->gb, alac->setinfo_sample_size); audiobits = extend_sign32(audiobits, alac->setinfo_sample_size); alac->outputsamples_buffer[chan][i] = audiobits; } interlacing_shift = 0; interlacing_leftweight = 0; } if (get_bits(&alac->gb, 3) != 7) av_log(avctx, AV_LOG_ERROR, "Error : Wrong End Of Frame\n"); switch(alac->setinfo_sample_size) { case 16: if (channels == 2) { reconstruct_stereo_16(alac->outputsamples_buffer, (int16_t*)outbuffer, alac->numchannels, outputsamples, interlacing_shift, interlacing_leftweight); } else { int i; for (i = 0; i < outputsamples; i++) { int16_t sample = alac->outputsamples_buffer[0][i]; ((int16_t*)outbuffer)[i * alac->numchannels] = sample; } } break; case 20: case 24: case 32: av_log(avctx, AV_LOG_ERROR, "FIXME: unimplemented sample size %i\n", alac->setinfo_sample_size); break; default: break; } if (input_buffer_size * 8 - get_bits_count(&alac->gb) > 8) av_log(avctx, AV_LOG_ERROR, "Error : %d bits left\n", input_buffer_size * 8 - get_bits_count(&alac->gb)); return input_buffer_size; }
--------------------------------------------- Result 100 ---------------------------------------------
[[0 (32%)]] --> [[0 (52%)]] --> Socre: 0.5181629061698914

[[[[Adv]]]]: static int getopt(int argc, char *argv[], char *opts) { static int sp = 1; int c; char *[[cp]]; if (sp == 1) if (optind >= argc || argv[optind][0] != '-' || argv[optind][1] == '\0') return EOF; else if (!strcmp(argv[optind], "--")) { optind++; return EOF; } optopt = c = argv[optind][sp]; if (c == ':' || ([[cp]] = strchr(opts, c)) == NULL) { fprintf(stderr, ": illegal option -- %c\n", c); if (argv[optind][++sp] == '\0') { optind++; sp = 1; } return '?'; } if (*++[[cp]] == ':') { if (argv[optind][sp+1] != '\0') optarg = &argv[optind++][sp+1]; else if(++optind >= argc) { fprintf(stderr, ": option requires an argument -- %c\n", c); sp = 1; return '?'; } else optarg = argv[optind++]; sp = 1; } else { if (argv[optind][++sp] == '\0') { sp = 1; optind++; } optarg = NULL; } return c; }

[[[[Adv]]]]: static int getopt(int argc, char *argv[], char *opts) { static int sp = 1; int c; char *[[coppers]]; if (sp == 1) if (optind >= argc || argv[optind][0] != '-' || argv[optind][1] == '\0') return EOF; else if (!strcmp(argv[optind], "--")) { optind++; return EOF; } optopt = c = argv[optind][sp]; if (c == ':' || ([[coppers]] = strchr(opts, c)) == NULL) { fprintf(stderr, ": illegal option -- %c\n", c); if (argv[optind][++sp] == '\0') { optind++; sp = 1; } return '?'; } if (*++[[coppers]] == ':') { if (argv[optind][sp+1] != '\0') optarg = &argv[optind++][sp+1]; else if(++optind >= argc) { fprintf(stderr, ": option requires an argument -- %c\n", c); sp = 1; return '?'; } else optarg = argv[optind++]; sp = 1; } else { if (argv[optind][++sp] == '\0') { sp = 1; optind++; } optarg = NULL; } return c; }
--------------------------------------------- Result 101 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 54 / 3 / 44 / 101:   4%|         | 101/2690 [16:17<6:57:46,  9.68s/it][Succeeded / Failed / Skipped / Total] 54 / 3 / 44 / 101:   4%|         | 102/2690 [16:21<6:55:08,  9.62s/it][Succeeded / Failed / Skipped / Total] 55 / 3 / 44 / 102:   4%|         | 102/2690 [16:21<6:55:08,  9.62s/it][Succeeded / Failed / Skipped / Total] 55 / 3 / 44 / 102:   4%|         | 103/2690 [16:49<7:02:40,  9.80s/it][Succeeded / Failed / Skipped / Total] 56 / 3 / 44 / 103:   4%|         | 103/2690 [16:49<7:02:40,  9.80s/it][Succeeded / Failed / Skipped / Total] 56 / 3 / 44 / 103:   4%|         | 104/2690 [17:03<7:04:15,  9.84s/it][Succeeded / Failed / Skipped / Total] 57 / 3 / 44 / 104:   4%|         | 104/2690 [17:03<7:04:15,  9.84s/it][Succeeded / Failed / Skipped / Total] 57 / 3 / 44 / 104:   4%|         | 105/2690 [17:04<7:00:15,  9.75s/it][[0 (14%)]] --> [[0 (93%)]] --> Socre: 0.9306324124336243

[[[[Adv]]]]: static void slavio_timer_mem_writel(void *[[opaque]], target_phys_addr_t addr, uint32_t val) { SLAVIO_TIMERState *s = [[opaque]]; uint32_t [[saddr]]; int [[reload]] = 0; DPRINTF("write " TARGET_FMT_plx " %08x\n", addr, val); [[saddr]] = (addr & TIMER_MAXADDR) >> 2; switch ([[saddr]]) { case TIMER_LIMIT: if (slavio_timer_is_user(s)) { qemu_irq_lower(s->irq); s->limit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s->slave_index); ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1); } else { qemu_irq_lower(s->irq); s->limit = val & TIMER_MAX_COUNT32; if (!s->limit) s->limit = TIMER_MAX_COUNT32; ptimer_set_limit(s->timer, s->limit >> 9, 1); } break; case TIMER_COUNTER: if (slavio_timer_is_user(s)) { qemu_irq_lower(s->irq); s->limit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s->slave_index); ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1); } else DPRINTF("not user timer\n"); break; case TIMER_COUNTER_NORST: s->limit = val & TIMER_MAX_COUNT32; if (!s->limit) s->limit = TIMER_MAX_COUNT32; ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), [[reload]]); break; case TIMER_STATUS: if (slavio_timer_is_user(s)) { if ((val & 1) && !s->running) { DPRINTF("processor %d user timer started\n", s->slave_index); ptimer_run(s->timer, 0); s->running = 1; } else if (!(val & 1) && s->running) { DPRINTF("processor %d user timer stopped\n", s->slave_index); ptimer_stop(s->timer); s->running = 0; } } break; case TIMER_MODE: if (s->master == NULL) { unsigned int i; for (i = 0; i < s->num_slaves; i++) { if (val & (1 << i)) { qemu_irq_lower(s->slave[i]->irq); s->slave[i]->limit = -1ULL; } if ((val & (1 << i)) != (s->slave_mode & (1 << i))) { ptimer_stop(s->slave[i]->timer); ptimer_set_limit(s->slave[i]->timer, LIMIT_TO_PERIODS(s->slave[i]->limit), 1); DPRINTF("processor %d timer changed\n", s->slave[i]->slave_index); ptimer_run(s->slave[i]->timer, 0); } } s->slave_mode = val & ((1 << s->num_slaves) - 1); } else DPRINTF("not system timer\n"); break; default: DPRINTF("invalid write address " TARGET_FMT_plx "\n", addr); break; } }

[[[[Adv]]]]: static void slavio_timer_mem_writel(void *[[disorienting]], target_phys_addr_t addr, uint32_t val) { SLAVIO_TIMERState *s = [[disorienting]]; uint32_t [[nieto]]; int [[toner]] = 0; DPRINTF("write " TARGET_FMT_plx " %08x\n", addr, val); [[nieto]] = (addr & TIMER_MAXADDR) >> 2; switch ([[nieto]]) { case TIMER_LIMIT: if (slavio_timer_is_user(s)) { qemu_irq_lower(s->irq); s->limit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s->slave_index); ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1); } else { qemu_irq_lower(s->irq); s->limit = val & TIMER_MAX_COUNT32; if (!s->limit) s->limit = TIMER_MAX_COUNT32; ptimer_set_limit(s->timer, s->limit >> 9, 1); } break; case TIMER_COUNTER: if (slavio_timer_is_user(s)) { qemu_irq_lower(s->irq); s->limit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s->slave_index); ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1); } else DPRINTF("not user timer\n"); break; case TIMER_COUNTER_NORST: s->limit = val & TIMER_MAX_COUNT32; if (!s->limit) s->limit = TIMER_MAX_COUNT32; ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), [[toner]]); break; case TIMER_STATUS: if (slavio_timer_is_user(s)) { if ((val & 1) && !s->running) { DPRINTF("processor %d user timer started\n", s->slave_index); ptimer_run(s->timer, 0); s->running = 1; } else if (!(val & 1) && s->running) { DPRINTF("processor %d user timer stopped\n", s->slave_index); ptimer_stop(s->timer); s->running = 0; } } break; case TIMER_MODE: if (s->master == NULL) { unsigned int i; for (i = 0; i < s->num_slaves; i++) { if (val & (1 << i)) { qemu_irq_lower(s->slave[i]->irq); s->slave[i]->limit = -1ULL; } if ((val & (1 << i)) != (s->slave_mode & (1 << i))) { ptimer_stop(s->slave[i]->timer); ptimer_set_limit(s->slave[i]->timer, LIMIT_TO_PERIODS(s->slave[i]->limit), 1); DPRINTF("processor %d timer changed\n", s->slave[i]->slave_index); ptimer_run(s->slave[i]->timer, 0); } } s->slave_mode = val & ((1 << s->num_slaves) - 1); } else DPRINTF("not system timer\n"); break; default: DPRINTF("invalid write address " TARGET_FMT_plx "\n", addr); break; } }
--------------------------------------------- Result 102 ---------------------------------------------
[[0 (49%)]] --> [[0 (65%)]] --> Socre: 0.6523966193199158

[[[[Adv]]]]: void qemu_cpu_kick(void *[[env]]) { return; }

[[[[Adv]]]]: void qemu_cpu_kick(void *[[rickshaws]]) { return; }
--------------------------------------------- Result 103 ---------------------------------------------
[[0 (17%)]] --> [[0 (79%)]] --> Socre: 0.7866057753562927

[[[[Adv]]]]: static void temp_allocate_frame(TCGContext *s, int temp) { TCGTemp *[[ts]]; [[ts]] = &s->temps[temp]; s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1); if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end) tcg_abort(); [[ts]]->mem_offset = s->current_frame_offset; [[ts]]->mem_reg = s->frame_reg; [[ts]]->mem_allocated = 1; s->current_frame_offset += sizeof(tcg_target_long); }

[[[[Adv]]]]: static void temp_allocate_frame(TCGContext *s, int temp) { TCGTemp *[[tuberculosis]]; [[tuberculosis]] = &s->temps[temp]; s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1); if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end) tcg_abort(); [[tuberculosis]]->mem_offset = s->current_frame_offset; [[tuberculosis]]->mem_reg = s->frame_reg; [[tuberculosis]]->mem_allocated = 1; s->current_frame_offset += sizeof(tcg_target_long); }
--------------------------------------------- Result 104 ---------------------------------------------
[[0 (34%)]] --> [[0 (72%)]] --> Socre: 0.7203837633132935

[[[[Adv]]]]: void qmp_block_stream(const char *device, bool has_base, const char *base, Error **errp) { BlockDriverState *bs; BlockDriverState *base_bs = NULL; Error *[[local_err]] = NULL; bs = bdrv_find(device); if (!bs) { error_set(errp, QERR_DEVICE_NOT_FOUND, device); return; } if (base) { base_bs = bdrv_find_backing_image(bs, base); if (base_bs == NULL) { error_set(errp, QERR_BASE_NOT_FOUND, base); return; } } stream_start(bs, base_bs, base, block_stream_cb, bs, &[[local_err]]); if (error_is_set(&[[local_err]])) { error_propagate(errp, [[local_err]]); return; } drive_get_ref(drive_get_by_blockdev(bs)); trace_qmp_block_stream(bs, bs->job); }

[[[[Adv]]]]: void qmp_block_stream(const char *device, bool has_base, const char *base, Error **errp) { BlockDriverState *bs; BlockDriverState *base_bs = NULL; Error *[[clawing]] = NULL; bs = bdrv_find(device); if (!bs) { error_set(errp, QERR_DEVICE_NOT_FOUND, device); return; } if (base) { base_bs = bdrv_find_backing_image(bs, base); if (base_bs == NULL) { error_set(errp, QERR_BASE_NOT_FOUND, base); return; } } stream_start(bs, base_bs, base, block_stream_cb, bs, &[[clawing]]); if (error_is_set(&[[clawing]])) { error_propagate(errp, [[clawing]]); return; } drive_get_ref(drive_get_by_blockdev(bs)); trace_qmp_block_stream(bs, bs->job); }
--------------------------------------------- Result 105 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 57 / 3 / 45 / 105:   4%|         | 105/2690 [17:04<7:00:15,  9.75s/it][Succeeded / Failed / Skipped / Total] 57 / 3 / 45 / 105:   4%|         | 106/2690 [17:17<7:01:24,  9.79s/it][Succeeded / Failed / Skipped / Total] 58 / 3 / 45 / 106:   4%|         | 106/2690 [17:17<7:01:24,  9.79s/it][Succeeded / Failed / Skipped / Total] 58 / 3 / 45 / 106:   4%|         | 107/2690 [17:17<6:57:30,  9.70s/it][Succeeded / Failed / Skipped / Total] 58 / 3 / 46 / 107:   4%|         | 107/2690 [17:17<6:57:30,  9.70s/it][Succeeded / Failed / Skipped / Total] 58 / 3 / 46 / 107:   4%|         | 108/2690 [17:28<6:57:58,  9.71s/it][Succeeded / Failed / Skipped / Total] 59 / 3 / 46 / 108:   4%|         | 108/2690 [17:28<6:57:58,  9.71s/it][Succeeded / Failed / Skipped / Total] 59 / 3 / 46 / 108:   4%|         | 109/2690 [17:35<6:56:34,  9.68s/it][Succeeded / Failed / Skipped / Total] 59 / 4 / 46 / 109:   4%|         | 109/2690 [17:35<6:56:34,  9.68s/it][Succeeded / Failed / Skipped / Total] 59 / 4 / 46 / 109:   4%|         | 110/2690 [17:36<6:52:49,  9.60s/it][Succeeded / Failed / Skipped / Total] 59 / 4 / 47 / 110:   4%|         | 110/2690 [17:36<6:52:49,  9.60s/it][Succeeded / Failed / Skipped / Total] 59 / 4 / 47 / 110:   4%|         | 111/2690 [17:39<6:50:21,  9.55s/it][Succeeded / Failed / Skipped / Total] 60 / 4 / 47 / 111:   4%|         | 111/2690 [17:39<6:50:21,  9.55s/it][Succeeded / Failed / Skipped / Total] 60 / 4 / 47 / 111:   4%|         | 112/2690 [17:52<6:51:21,  9.57s/it][Succeeded / Failed / Skipped / Total] 60 / 5 / 47 / 112:   4%|         | 112/2690 [17:52<6:51:21,  9.57s/it][Succeeded / Failed / Skipped / Total] 60 / 5 / 47 / 112:   4%|         | 113/2690 [18:03<6:51:40,  9.58s/it][[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void mptsas_scsi_init(PCIDevice *dev, Error **errp) { DeviceState *d = DEVICE(dev); MPTSASState *s = MPT_SAS(dev); dev->config[PCI_LATENCY_TIMER] = 0; dev->config[PCI_INTERRUPT_PIN] = 0x01; memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s, "mptsas-mmio", 0x4000); memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s, "mptsas-io", 256); memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s, "mptsas-diag", 0x10000); if (s->msi != ON_OFF_AUTO_OFF && msi_init(dev, 0, 1, "True" == "True", "False" != "False") >= 0) { s->msi_in_use = "True" == "True"; } pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io); pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io); pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io); if (!s->sas_addr) { s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) | IEEE_COMPANY_LOCALLY_ASSIGNED) << 36; s->sas_addr |= (pci_bus_num(dev->bus) << 16); s->sas_addr |= (PCI_SLOT(dev->devfn) << 8); s->sas_addr |= PCI_FUNC(dev->devfn); } s->max_devices = MPTSAS_NUM_PORTS; s->request_bh = qemu_bh_new(mptsas_fetch_requests, s); QTAILQ_INIT(&s->pending); scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL); if (!d->hotplugged) { scsi_bus_legacy_handle_cmdline(&s->bus, errp); } }
--------------------------------------------- Result 106 ---------------------------------------------
[[0 (6%)]] --> [[0 (73%)]] --> Socre: 0.7317296266555786

[[[[Adv]]]]: static void qmp_output_type_number(Visitor *v, const char *name, double *obj, Error **[[errp]]) { QmpOutputVisitor *qov = to_qov(v); qmp_output_add(qov, name, qfloat_from_double(*obj)); }

[[[[Adv]]]]: static void qmp_output_type_number(Visitor *v, const char *name, double *obj, Error **[[zo]]) { QmpOutputVisitor *qov = to_qov(v); qmp_output_add(qov, name, qfloat_from_double(*obj)); }
--------------------------------------------- Result 107 ---------------------------------------------
[[0 (17%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: FFTContext *av_fft_init(int nbits, int inverse) { FFTContext *s = av_malloc(sizeof(*s)); if (s && ff_fft_init(s, nbits, inverse)) av_freep(&s); return s; }
--------------------------------------------- Result 108 ---------------------------------------------
[[0 (98%)]] --> [[0 (47%)]] --> Socre: 0.5314527153968811

[[[[Adv]]]]: static void gen_set_CF_bit31(TCGv [[var]]) { TCGv [[tmp]] = new_tmp(); tcg_gen_shri_i32([[tmp]], [[var]], 31); gen_set_CF([[tmp]]); dead_tmp([[tmp]]); }

[[[[Adv]]]]: static void gen_set_CF_bit31(TCGv [[eval]]) { TCGv [[filling]] = new_tmp(); tcg_gen_shri_i32([[filling]], [[eval]], 31); gen_set_CF([[filling]]); dead_tmp([[filling]]); }
--------------------------------------------- Result 109 ---------------------------------------------
[[0 (3%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline int num_effective_busses(XilinxSPIPS *s) { return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS && s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1; }

[[[[Adv]]]]: static inline int num_effective_busses(XilinxSPIPS *s) { return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS && s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1; }
--------------------------------------------- Result 110 ---------------------------------------------
[[0 (17%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp) { CommitBlockJob *s = container_of(job, CommitBlockJob, common); if (speed < 0) { error_setg(errp, QERR_INVALID_PARAMETER, "speed"); return; } ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME); }
--------------------------------------------- Result 111 ---------------------------------------------
[[0 (70%)]] --> [[0 (48%)]] --> Socre: 0.5215080976486206

[[[[Adv]]]]: static void sd_1d97_int(int *[[p]], int i0, int i1) { int [[i]]; if (i1 <= i0 + 1) { if (i0 == 1) [[p]][1] = ([[p]][1] * I_LFTG_X + (1<<15)) >> 16; else [[p]][0] = ([[p]][0] * I_LFTG_K + (1<<15)) >> 16; return; } extend97_int([[p]], i0, i1); i0++; i1++; for ([[i]] = i0/2 - 2; [[i]] < i1/2 + 1; [[i]]++) [[p]][2 * [[i]] + 1] -= (I_LFTG_ALPHA * ([[p]][2 * [[i]]] + [[p]][2 * [[i]] + 2]) + (1 << 15)) >> 16; for ([[i]] = i0/2 - 1; [[i]] < i1/2 + 1; [[i]]++) [[p]][2 * [[i]]] -= (I_LFTG_BETA * ([[p]][2 * [[i]] - 1] + [[p]][2 * [[i]] + 1]) + (1 << 15)) >> 16; for ([[i]] = i0/2 - 1; [[i]] < i1/2; [[i]]++) [[p]][2 * [[i]] + 1] += (I_LFTG_GAMMA * ([[p]][2 * [[i]]] + [[p]][2 * [[i]] + 2]) + (1 << 15)) >> 16; for ([[i]] = i0/2; [[i]] < i1/2; [[i]]++) [[p]][2 * [[i]]] += (I_LFTG_DELTA * ([[p]][2 * [[i]] - 1] + [[p]][2 * [[i]] + 1]) + (1 << 15)) >> 16; }

[[[[Adv]]]]: static void sd_1d97_int(int *[[sodium]], int i0, int i1) { int [[li]]; if (i1 <= i0 + 1) { if (i0 == 1) [[sodium]][1] = ([[sodium]][1] * I_LFTG_X + (1<<15)) >> 16; else [[sodium]][0] = ([[sodium]][0] * I_LFTG_K + (1<<15)) >> 16; return; } extend97_int([[sodium]], i0, i1); i0++; i1++; for ([[li]] = i0/2 - 2; [[li]] < i1/2 + 1; [[li]]++) [[sodium]][2 * [[li]] + 1] -= (I_LFTG_ALPHA * ([[sodium]][2 * [[li]]] + [[sodium]][2 * [[li]] + 2]) + (1 << 15)) >> 16; for ([[li]] = i0/2 - 1; [[li]] < i1/2 + 1; [[li]]++) [[sodium]][2 * [[li]]] -= (I_LFTG_BETA * ([[sodium]][2 * [[li]] - 1] + [[sodium]][2 * [[li]] + 1]) + (1 << 15)) >> 16; for ([[li]] = i0/2 - 1; [[li]] < i1/2; [[li]]++) [[sodium]][2 * [[li]] + 1] += (I_LFTG_GAMMA * ([[sodium]][2 * [[li]]] + [[sodium]][2 * [[li]] + 2]) + (1 << 15)) >> 16; for ([[li]] = i0/2; [[li]] < i1/2; [[li]]++) [[sodium]][2 * [[li]]] += (I_LFTG_DELTA * ([[sodium]][2 * [[li]] - 1] + [[sodium]][2 * [[li]] + 1]) + (1 << 15)) >> 16; }
--------------------------------------------- Result 112 ---------------------------------------------
[[0 (4%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void mem_begin(MemoryListener *listener) { AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener); d->phys_map.ptr = PHYS_MAP_NODE_NIL; }

[[[[Adv]]]]: static void mem_begin(MemoryListener *listener) { AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener); d->phys_map.ptr = PHYS_MAP_NODE_NIL; }
--------------------------------------------- Result 113 ---------------------------------------------
[[0 (99%)]] --> [[0 (25%)]] --> Socre: 0.7547825276851654

[[[[Adv]]]]: static int get_siz(Jpeg2000DecoderContext *s) { int i; int ncomponents; uint32_t [[log2_chroma_wh]] = 0; const enum AVPixelFormat *possible_fmts = NULL; int possible_fmts_nb = 0; if (bytestream2_get_bytes_left(&s->g) < 36) { av_log(s->avctx, AV_LOG_ERROR, "Insufficient space for SIZ\n"); s->avctx->profile = bytestream2_get_be16u(&s->g); s->width = bytestream2_get_be32u(&s->g); s->height = bytestream2_get_be32u(&s->g); s->image_offset_x = bytestream2_get_be32u(&s->g); s->image_offset_y = bytestream2_get_be32u(&s->g); s->tile_width = bytestream2_get_be32u(&s->g); s->tile_height = bytestream2_get_be32u(&s->g); s->tile_offset_x = bytestream2_get_be32u(&s->g); s->tile_offset_y = bytestream2_get_be32u(&s->g); ncomponents = bytestream2_get_be16u(&s->g); if (s->image_offset_x || s->image_offset_y) { avpriv_request_sample(s->avctx, "Support for image offsets"); return AVERROR_PATCHWELCOME; if (av_image_check_size(s->width, s->height, 0, s->avctx)) { avpriv_request_sample(s->avctx, "Large Dimensions"); return AVERROR_PATCHWELCOME; if (ncomponents <= 0) { av_log(s->avctx, AV_LOG_ERROR, "Invalid number of components: %d\n", if (ncomponents > 4) { avpriv_request_sample(s->avctx, "Support for %d components", ncomponents); return AVERROR_PATCHWELCOME; s->ncomponents = ncomponents; if (s->tile_width <= 0 || s->tile_height <= 0) { av_log(s->avctx, AV_LOG_ERROR, "Invalid tile dimension %dx%d.\n", s->tile_width, s->tile_height); if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) { av_log(s->avctx, AV_LOG_ERROR, "Insufficient space for %d components in SIZ\n", s->ncomponents); for (i = 0; i < s->ncomponents; i++) { uint8_t x = bytestream2_get_byteu(&s->g); s->cbps[i] = (x & 0x7f) + 1; s->precision = FFMAX(s->cbps[i], s->precision); s->sgnd[i] = !!(x & 0x80); s->cdx[i] = bytestream2_get_byteu(&s->g); s->cdy[i] = bytestream2_get_byteu(&s->g); if ( !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4 || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) { av_log(s->avctx, AV_LOG_ERROR, "Invalid sample separation %d/%d\n", s->cdx[i], s->cdy[i]); [[log2_chroma_wh]] |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2; s->numXtiles = ff_jpeg2000_ceildiv(s->width - s->tile_offset_x, s->tile_width); s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height); if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) { s->numXtiles = s->numYtiles = 0; return AVERROR(EINVAL); s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile)); if (!s->tile) { s->numXtiles = s->numYtiles = 0; return AVERROR(ENOMEM); for (i = 0; i < s->numXtiles * s->numYtiles; i++) { Jpeg2000Tile *tile = s->tile + i; tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp)); if (!tile->comp) return AVERROR(ENOMEM); s->avctx->width = ff_jpeg2000_ceildivpow2(s->width - s->image_offset_x, s->reduction_factor); s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y, s->reduction_factor); if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) { possible_fmts = xyz_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts); } else { switch (s->colour_space) { case 16: possible_fmts = rgb_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts); break; case 17: possible_fmts = gray_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts); break; case 18: possible_fmts = yuv_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts); break; default: possible_fmts = all_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts); break; for (i = 0; i < possible_fmts_nb; ++i) { if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, [[log2_chroma_wh]], s->pal8)) { s->avctx->pix_fmt = possible_fmts[i]; break; if (i == possible_fmts_nb) { if (ncomponents == 4 && s->cdy[0] == 1 && s->cdx[0] == 1 && s->cdy[1] == 1 && s->cdx[1] == 1 && s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) { if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) { s->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; s->cdef[0] = 0; s->cdef[1] = 1; s->cdef[2] = 2; s->cdef[3] = 3; i = 0; if (i == possible_fmts_nb) { av_log(s->avctx, AV_LOG_ERROR, "Unknown pix_fmt, profile: %d, colour_space: %d, " "components: %d, precision: %d\n" "cdx[0]: %d, cdy[0]: %d\n" "cdx[1]: %d, cdy[1]: %d\n" "cdx[2]: %d, cdy[2]: %d\n" "cdx[3]: %d, cdy[3]: %d\n", s->avctx->profile, s->colour_space, ncomponents, s->precision, s->cdx[0], s->cdy[0], ncomponents > 1 ? s->cdx[1] : 0, ncomponents > 1 ? s->cdy[1] : 0, ncomponents > 2 ? s->cdx[2] : 0, ncomponents > 2 ? s->cdy[2] : 0, ncomponents > 3 ? s->cdx[3] : 0, ncomponents > 3 ? s->cdy[3] : 0); return AVERROR_PATCHWELCOME; s->avctx->bits_per_raw_sample = s->precision; return 0;

[[[[Adv]]]]: static int get_siz(Jpeg2000DecoderContext *s) { int i; int ncomponents; uint32_t [[rve]] = 0; const enum AVPixelFormat *possible_fmts = NULL; int possible_fmts_nb = 0; if (bytestream2_get_bytes_left(&s->g) < 36) { av_log(s->avctx, AV_LOG_ERROR, "Insufficient space for SIZ\n"); s->avctx->profile = bytestream2_get_be16u(&s->g); s->width = bytestream2_get_be32u(&s->g); s->height = bytestream2_get_be32u(&s->g); s->image_offset_x = bytestream2_get_be32u(&s->g); s->image_offset_y = bytestream2_get_be32u(&s->g); s->tile_width = bytestream2_get_be32u(&s->g); s->tile_height = bytestream2_get_be32u(&s->g); s->tile_offset_x = bytestream2_get_be32u(&s->g); s->tile_offset_y = bytestream2_get_be32u(&s->g); ncomponents = bytestream2_get_be16u(&s->g); if (s->image_offset_x || s->image_offset_y) { avpriv_request_sample(s->avctx, "Support for image offsets"); return AVERROR_PATCHWELCOME; if (av_image_check_size(s->width, s->height, 0, s->avctx)) { avpriv_request_sample(s->avctx, "Large Dimensions"); return AVERROR_PATCHWELCOME; if (ncomponents <= 0) { av_log(s->avctx, AV_LOG_ERROR, "Invalid number of components: %d\n", if (ncomponents > 4) { avpriv_request_sample(s->avctx, "Support for %d components", ncomponents); return AVERROR_PATCHWELCOME; s->ncomponents = ncomponents; if (s->tile_width <= 0 || s->tile_height <= 0) { av_log(s->avctx, AV_LOG_ERROR, "Invalid tile dimension %dx%d.\n", s->tile_width, s->tile_height); if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) { av_log(s->avctx, AV_LOG_ERROR, "Insufficient space for %d components in SIZ\n", s->ncomponents); for (i = 0; i < s->ncomponents; i++) { uint8_t x = bytestream2_get_byteu(&s->g); s->cbps[i] = (x & 0x7f) + 1; s->precision = FFMAX(s->cbps[i], s->precision); s->sgnd[i] = !!(x & 0x80); s->cdx[i] = bytestream2_get_byteu(&s->g); s->cdy[i] = bytestream2_get_byteu(&s->g); if ( !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4 || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) { av_log(s->avctx, AV_LOG_ERROR, "Invalid sample separation %d/%d\n", s->cdx[i], s->cdy[i]); [[rve]] |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2; s->numXtiles = ff_jpeg2000_ceildiv(s->width - s->tile_offset_x, s->tile_width); s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height); if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) { s->numXtiles = s->numYtiles = 0; return AVERROR(EINVAL); s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile)); if (!s->tile) { s->numXtiles = s->numYtiles = 0; return AVERROR(ENOMEM); for (i = 0; i < s->numXtiles * s->numYtiles; i++) { Jpeg2000Tile *tile = s->tile + i; tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp)); if (!tile->comp) return AVERROR(ENOMEM); s->avctx->width = ff_jpeg2000_ceildivpow2(s->width - s->image_offset_x, s->reduction_factor); s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y, s->reduction_factor); if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) { possible_fmts = xyz_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts); } else { switch (s->colour_space) { case 16: possible_fmts = rgb_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts); break; case 17: possible_fmts = gray_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts); break; case 18: possible_fmts = yuv_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts); break; default: possible_fmts = all_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts); break; for (i = 0; i < possible_fmts_nb; ++i) { if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, [[rve]], s->pal8)) { s->avctx->pix_fmt = possible_fmts[i]; break; if (i == possible_fmts_nb) { if (ncomponents == 4 && s->cdy[0] == 1 && s->cdx[0] == 1 && s->cdy[1] == 1 && s->cdx[1] == 1 && s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) { if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) { s->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; s->cdef[0] = 0; s->cdef[1] = 1; s->cdef[2] = 2; s->cdef[3] = 3; i = 0; if (i == possible_fmts_nb) { av_log(s->avctx, AV_LOG_ERROR, "Unknown pix_fmt, profile: %d, colour_space: %d, " "components: %d, precision: %d\n" "cdx[0]: %d, cdy[0]: %d\n" "cdx[1]: %d, cdy[1]: %d\n" "cdx[2]: %d, cdy[2]: %d\n" "cdx[3]: %d, cdy[3]: %d\n", s->avctx->profile, s->colour_space, ncomponents, s->precision, s->cdx[0], s->cdy[0], ncomponents > 1 ? s->cdx[1] : 0, ncomponents > 1 ? s->cdy[1] : 0, ncomponents > 2 ? s->cdx[2] : 0, ncomponents > 2 ? s->cdy[2] : 0, ncomponents > 3 ? s->cdx[3] : 0, ncomponents > 3 ? s->cdy[3] : 0); return AVERROR_PATCHWELCOME; s->avctx->bits_per_raw_sample = s->precision; return 0;[Succeeded / Failed / Skipped / Total] 61 / 5 / 47 / 113:   4%|         | 113/2690 [18:03<6:51:40,  9.58s/it][Succeeded / Failed / Skipped / Total] 61 / 5 / 47 / 113:   4%|         | 114/2690 [18:15<6:52:39,  9.61s/it][Succeeded / Failed / Skipped / Total] 62 / 5 / 47 / 114:   4%|         | 114/2690 [18:15<6:52:39,  9.61s/it][Succeeded / Failed / Skipped / Total] 62 / 5 / 47 / 114:   4%|         | 115/2690 [18:43<6:59:12,  9.77s/it][Succeeded / Failed / Skipped / Total] 63 / 5 / 47 / 115:   4%|         | 115/2690 [18:43<6:59:12,  9.77s/it][Succeeded / Failed / Skipped / Total] 63 / 5 / 47 / 115:   4%|         | 116/2690 [18:46<6:56:35,  9.71s/it][Succeeded / Failed / Skipped / Total] 64 / 5 / 47 / 116:   4%|         | 116/2690 [18:46<6:56:35,  9.71s/it][Succeeded / Failed / Skipped / Total] 64 / 5 / 47 / 116:   4%|         | 117/2690 [18:51<6:54:49,  9.67s/it]
--------------------------------------------- Result 114 ---------------------------------------------
[[0 (69%)]] --> [[0 (49%)]] --> Socre: 0.5078923404216766

[[[[Adv]]]]: ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *ast, int len, AVPacket *[[pkt]], int *seq, int flags, int64_t timestamp) { RMDemuxContext *rm = s->priv_data; int ret; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { rm->current_stream= st->id; ret = rm_assemble_video_frame(s, pb, rm, ast, [[pkt]], len, seq, &timestamp); if(ret) return ret < 0 ? ret : -1; } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if ((ast->deint_id == DEINT_ID_GENR) || (ast->deint_id == DEINT_ID_INT4) || (ast->deint_id == DEINT_ID_SIPR)) { int x; int sps = ast->sub_packet_size; int cfs = ast->coded_framesize; int h = ast->sub_packet_h; int y = ast->sub_packet_cnt; int w = ast->audio_framesize; if (flags & 2) y = ast->sub_packet_cnt = 0; if (!y) ast->audiotimestamp = timestamp; switch (ast->deint_id) { case DEINT_ID_INT4: for (x = 0; x < h/2; x++) avio_read(pb, ast->pkt.data+x*2*w+y*cfs, cfs); break; case DEINT_ID_GENR: for (x = 0; x < w/sps; x++) avio_read(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps); break; case DEINT_ID_SIPR: avio_read(pb, ast->pkt.data + y * w, w); break; } if (++(ast->sub_packet_cnt) < h) return -1; if (ast->deint_id == DEINT_ID_SIPR) ff_rm_reorder_sipr_data(ast->pkt.data, h, w); ast->sub_packet_cnt = 0; rm->audio_stream_num = st->index; rm->audio_pkt_cnt = h * w / st->codec->block_align; } else if ((ast->deint_id == DEINT_ID_VBRF) || (ast->deint_id == DEINT_ID_VBRS)) { int x; rm->audio_stream_num = st->index; ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4; if (ast->sub_packet_cnt) { for (x = 0; x < ast->sub_packet_cnt; x++) ast->sub_packet_lengths[x] = avio_rb16(pb); rm->audio_pkt_cnt = ast->sub_packet_cnt; ast->audiotimestamp = timestamp; } else return -1; } else { av_get_packet(pb, [[pkt]], len); rm_ac3_swap_bytes(st, [[pkt]]); } } else av_get_packet(pb, [[pkt]], len); [[pkt]]->stream_index = st->index; #if 0 if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { if(st->codec->codec_id == AV_CODEC_ID_RV20){ int seq= 128*([[pkt]]->data[2]&0x7F) + ([[pkt]]->data[3]>>1); av_log(s, AV_LOG_DEBUG, "%d %"PRId64" %d\n", *timestamp, *timestamp*512LL/25, seq); seq |= (timestamp&~0x3FFF); if(seq - timestamp > 0x2000) seq -= 0x4000; if(seq - timestamp < -0x2000) seq += 0x4000; } } #endif [[pkt]]->pts = timestamp; if (flags & 2) [[pkt]]->flags |= AV_PKT_FLAG_KEY; return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0; }

[[[[Adv]]]]: ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *ast, int len, AVPacket *[[pelosi]], int *seq, int flags, int64_t timestamp) { RMDemuxContext *rm = s->priv_data; int ret; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { rm->current_stream= st->id; ret = rm_assemble_video_frame(s, pb, rm, ast, [[pelosi]], len, seq, &timestamp); if(ret) return ret < 0 ? ret : -1; } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if ((ast->deint_id == DEINT_ID_GENR) || (ast->deint_id == DEINT_ID_INT4) || (ast->deint_id == DEINT_ID_SIPR)) { int x; int sps = ast->sub_packet_size; int cfs = ast->coded_framesize; int h = ast->sub_packet_h; int y = ast->sub_packet_cnt; int w = ast->audio_framesize; if (flags & 2) y = ast->sub_packet_cnt = 0; if (!y) ast->audiotimestamp = timestamp; switch (ast->deint_id) { case DEINT_ID_INT4: for (x = 0; x < h/2; x++) avio_read(pb, ast->pkt.data+x*2*w+y*cfs, cfs); break; case DEINT_ID_GENR: for (x = 0; x < w/sps; x++) avio_read(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps); break; case DEINT_ID_SIPR: avio_read(pb, ast->pkt.data + y * w, w); break; } if (++(ast->sub_packet_cnt) < h) return -1; if (ast->deint_id == DEINT_ID_SIPR) ff_rm_reorder_sipr_data(ast->pkt.data, h, w); ast->sub_packet_cnt = 0; rm->audio_stream_num = st->index; rm->audio_pkt_cnt = h * w / st->codec->block_align; } else if ((ast->deint_id == DEINT_ID_VBRF) || (ast->deint_id == DEINT_ID_VBRS)) { int x; rm->audio_stream_num = st->index; ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4; if (ast->sub_packet_cnt) { for (x = 0; x < ast->sub_packet_cnt; x++) ast->sub_packet_lengths[x] = avio_rb16(pb); rm->audio_pkt_cnt = ast->sub_packet_cnt; ast->audiotimestamp = timestamp; } else return -1; } else { av_get_packet(pb, [[pelosi]], len); rm_ac3_swap_bytes(st, [[pelosi]]); } } else av_get_packet(pb, [[pelosi]], len); [[pelosi]]->stream_index = st->index; #if 0 if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { if(st->codec->codec_id == AV_CODEC_ID_RV20){ int seq= 128*([[pelosi]]->data[2]&0x7F) + ([[pelosi]]->data[3]>>1); av_log(s, AV_LOG_DEBUG, "%d %"PRId64" %d\n", *timestamp, *timestamp*512LL/25, seq); seq |= (timestamp&~0x3FFF); if(seq - timestamp > 0x2000) seq -= 0x4000; if(seq - timestamp < -0x2000) seq += 0x4000; } } #endif [[pelosi]]->pts = timestamp; if (flags & 2) [[pelosi]]->flags |= AV_PKT_FLAG_KEY; return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0; }
--------------------------------------------- Result 115 ---------------------------------------------
[[0 (93%)]] --> [[0 (40%)]] --> Socre: 0.6032778918743134

[[[[Adv]]]]: static inline void RENAME(rgb32ToY)(uint8_t *[[dst]], uint8_t *src, int [[width]]) { int i; for(i=0; i<[[width]]; i++) { int r= ((uint32_t*)src)[i]&0xFF; int g= (((uint32_t*)src)[i]>>8)&0xFF; int b= (((uint32_t*)src)[i]>>16)&0xFF; [[dst]][i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT); } }

[[[[Adv]]]]: static inline void RENAME(rgb32ToY)(uint8_t *[[wakeup]], uint8_t *src, int [[longitude]]) { int i; for(i=0; i<[[longitude]]; i++) { int r= ((uint32_t*)src)[i]&0xFF; int g= (((uint32_t*)src)[i]>>8)&0xFF; int b= (((uint32_t*)src)[i]>>16)&0xFF; [[wakeup]][i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT); } }
--------------------------------------------- Result 116 ---------------------------------------------
[[0 (9%)]] --> [[0 (54%)]] --> Socre: 0.543287992477417

[[[[Adv]]]]: static uint32_t s390_pci_generate_fid(Error **[[errp]]) { uint32_t [[fid]] = 0; while ([[fid]] <= ZPCI_MAX_FID) { if (!s390_pci_find_dev_by_fid([[fid]])) { return [[fid]]; } if ([[fid]] == ZPCI_MAX_FID) { break; } [[fid]]++; } error_setg([[errp]], "no free fid could be found"); return 0; }

[[[[Adv]]]]: static uint32_t s390_pci_generate_fid(Error **[[sayama]]) { uint32_t [[kapil]] = 0; while ([[kapil]] <= ZPCI_MAX_FID) { if (!s390_pci_find_dev_by_fid([[kapil]])) { return [[kapil]]; } if ([[kapil]] == ZPCI_MAX_FID) { break; } [[kapil]]++; } error_setg([[sayama]], "no free fid could be found"); return 0; }
--------------------------------------------- Result 117 ---------------------------------------------
[[0 (89%)]] --> [[0 (49%)]] --> Socre: 0.513076663017273

[[[[Adv]]]]: static int opus_decode_frame(OpusStreamContext *s, const uint8_t *data, int size) { int samples = s->packet.frame_duration; int redundancy = 0; int [[redundancy_size]], redundancy_pos; int ret, i, consumed; int delayed_samples = s->delayed_samples; ret = opus_rc_init(&s->rc, data, size); if (ret < 0) return ret; if (s->packet.mode == OPUS_MODE_SILK || s->packet.mode == OPUS_MODE_HYBRID) { if (!swr_is_initialized(s->swr)) { ret = opus_init_resample(s); if (ret < 0) return ret; } samples = ff_silk_decode_superframe(s->silk, &s->rc, s->silk_output, FFMIN(s->packet.bandwidth, OPUS_BANDWIDTH_WIDEBAND), s->packet.stereo + 1, silk_frame_duration_ms[s->packet.config]); if (samples < 0) { av_log(s->avctx, AV_LOG_ERROR, "Error decoding a SILK frame.\n"); return samples; } samples = swr_convert(s->swr, (uint8_t**)s->out, s->packet.frame_duration, (const uint8_t**)s->silk_output, samples); if (samples < 0) { av_log(s->avctx, AV_LOG_ERROR, "Error resampling SILK data.\n"); return samples; } s->delayed_samples += s->packet.frame_duration - samples; } else ff_silk_flush(s->silk); consumed = opus_rc_tell(&s->rc); if (s->packet.mode == OPUS_MODE_HYBRID && consumed + 37 <= size * 8) redundancy = opus_rc_p2model(&s->rc, 12); else if (s->packet.mode == OPUS_MODE_SILK && consumed + 17 <= size * 8) redundancy = 1; if (redundancy) { redundancy_pos = opus_rc_p2model(&s->rc, 1); if (s->packet.mode == OPUS_MODE_HYBRID) [[redundancy_size]] = opus_rc_unimodel(&s->rc, 256) + 2; else [[redundancy_size]] = size - (consumed + 7) / 8; size -= [[redundancy_size]]; if (size < 0) { av_log(s->avctx, AV_LOG_ERROR, "Invalid redundancy frame size.\n"); return AVERROR_INVALIDDATA; } if (redundancy_pos) { ret = opus_decode_redundancy(s, data + size, [[redundancy_size]]); if (ret < 0) return ret; ff_celt_flush(s->celt); } } if (s->packet.mode == OPUS_MODE_CELT || s->packet.mode == OPUS_MODE_HYBRID) { float *out_tmp[2] = { s->out[0], s->out[1] }; float **dst = (s->packet.mode == OPUS_MODE_CELT) ? out_tmp : s->celt_output; int celt_output_samples = samples; int delay_samples = av_audio_fifo_size(s->celt_delay); if (delay_samples) { if (s->packet.mode == OPUS_MODE_HYBRID) { av_audio_fifo_read(s->celt_delay, (void**)s->celt_output, delay_samples); for (i = 0; i < s->output_channels; i++) { s->fdsp->vector_fmac_scalar(out_tmp[i], s->celt_output[i], 1.0, delay_samples); out_tmp[i] += delay_samples; } celt_output_samples -= delay_samples; } else { av_log(s->avctx, AV_LOG_WARNING, "Spurious CELT delay samples present.\n"); av_audio_fifo_drain(s->celt_delay, delay_samples); if (s->avctx->err_recognition & AV_EF_EXPLODE) return AVERROR_BUG; } } opus_raw_init(&s->rc, data + size, size); ret = ff_celt_decode_frame(s->celt, &s->rc, dst, s->packet.stereo + 1, s->packet.frame_duration, (s->packet.mode == OPUS_MODE_HYBRID) ? 17 : 0, celt_band_end[s->packet.bandwidth]); if (ret < 0) return ret; if (s->packet.mode == OPUS_MODE_HYBRID) { int celt_delay = s->packet.frame_duration - celt_output_samples; void *delaybuf[2] = { s->celt_output[0] + celt_output_samples, s->celt_output[1] + celt_output_samples }; for (i = 0; i < s->output_channels; i++) { s->fdsp->vector_fmac_scalar(out_tmp[i], s->celt_output[i], 1.0, celt_output_samples); } ret = av_audio_fifo_write(s->celt_delay, delaybuf, celt_delay); if (ret < 0) return ret; } } else ff_celt_flush(s->celt); if (s->redundancy_idx) { for (i = 0; i < s->output_channels; i++) opus_fade(s->out[i], s->out[i], s->redundancy_output[i] + 120 + s->redundancy_idx, ff_celt_window2 + s->redundancy_idx, 120 - s->redundancy_idx); s->redundancy_idx = 0; } if (redundancy) { if (!redundancy_pos) { ff_celt_flush(s->celt); ret = opus_decode_redundancy(s, data + size, [[redundancy_size]]); if (ret < 0) return ret; for (i = 0; i < s->output_channels; i++) { opus_fade(s->out[i] + samples - 120 + delayed_samples, s->out[i] + samples - 120 + delayed_samples, s->redundancy_output[i] + 120, ff_celt_window2, 120 - delayed_samples); if (delayed_samples) s->redundancy_idx = 120 - delayed_samples; } } else { for (i = 0; i < s->output_channels; i++) { memcpy(s->out[i] + delayed_samples, s->redundancy_output[i], 120 * sizeof(float)); opus_fade(s->out[i] + 120 + delayed_samples, s->redundancy_output[i] + 120, s->out[i] + 120 + delayed_samples, ff_celt_window2, 120); } } } return samples; }

[[[[Adv]]]]: static int opus_decode_frame(OpusStreamContext *s, const uint8_t *data, int size) { int samples = s->packet.frame_duration; int redundancy = 0; int [[tallman]], redundancy_pos; int ret, i, consumed; int delayed_samples = s->delayed_samples; ret = opus_rc_init(&s->rc, data, size); if (ret < 0) return ret; if (s->packet.mode == OPUS_MODE_SILK || s->packet.mode == OPUS_MODE_HYBRID) { if (!swr_is_initialized(s->swr)) { ret = opus_init_resample(s); if (ret < 0) return ret; } samples = ff_silk_decode_superframe(s->silk, &s->rc, s->silk_output, FFMIN(s->packet.bandwidth, OPUS_BANDWIDTH_WIDEBAND), s->packet.stereo + 1, silk_frame_duration_ms[s->packet.config]); if (samples < 0) { av_log(s->avctx, AV_LOG_ERROR, "Error decoding a SILK frame.\n"); return samples; } samples = swr_convert(s->swr, (uint8_t**)s->out, s->packet.frame_duration, (const uint8_t**)s->silk_output, samples); if (samples < 0) { av_log(s->avctx, AV_LOG_ERROR, "Error resampling SILK data.\n"); return samples; } s->delayed_samples += s->packet.frame_duration - samples; } else ff_silk_flush(s->silk); consumed = opus_rc_tell(&s->rc); if (s->packet.mode == OPUS_MODE_HYBRID && consumed + 37 <= size * 8) redundancy = opus_rc_p2model(&s->rc, 12); else if (s->packet.mode == OPUS_MODE_SILK && consumed + 17 <= size * 8) redundancy = 1; if (redundancy) { redundancy_pos = opus_rc_p2model(&s->rc, 1); if (s->packet.mode == OPUS_MODE_HYBRID) [[tallman]] = opus_rc_unimodel(&s->rc, 256) + 2; else [[tallman]] = size - (consumed + 7) / 8; size -= [[tallman]]; if (size < 0) { av_log(s->avctx, AV_LOG_ERROR, "Invalid redundancy frame size.\n"); return AVERROR_INVALIDDATA; } if (redundancy_pos) { ret = opus_decode_redundancy(s, data + size, [[tallman]]); if (ret < 0) return ret; ff_celt_flush(s->celt); } } if (s->packet.mode == OPUS_MODE_CELT || s->packet.mode == OPUS_MODE_HYBRID) { float *out_tmp[2] = { s->out[0], s->out[1] }; float **dst = (s->packet.mode == OPUS_MODE_CELT) ? out_tmp : s->celt_output; int celt_output_samples = samples; int delay_samples = av_audio_fifo_size(s->celt_delay); if (delay_samples) { if (s->packet.mode == OPUS_MODE_HYBRID) { av_audio_fifo_read(s->celt_delay, (void**)s->celt_output, delay_samples); for (i = 0; i < s->output_channels; i++) { s->fdsp->vector_fmac_scalar(out_tmp[i], s->celt_output[i], 1.0, delay_samples); out_tmp[i] += delay_samples; } celt_output_samples -= delay_samples; } else { av_log(s->avctx, AV_LOG_WARNING, "Spurious CELT delay samples present.\n"); av_audio_fifo_drain(s->celt_delay, delay_samples); if (s->avctx->err_recognition & AV_EF_EXPLODE) return AVERROR_BUG; } } opus_raw_init(&s->rc, data + size, size); ret = ff_celt_decode_frame(s->celt, &s->rc, dst, s->packet.stereo + 1, s->packet.frame_duration, (s->packet.mode == OPUS_MODE_HYBRID) ? 17 : 0, celt_band_end[s->packet.bandwidth]); if (ret < 0) return ret; if (s->packet.mode == OPUS_MODE_HYBRID) { int celt_delay = s->packet.frame_duration - celt_output_samples; void *delaybuf[2] = { s->celt_output[0] + celt_output_samples, s->celt_output[1] + celt_output_samples }; for (i = 0; i < s->output_channels; i++) { s->fdsp->vector_fmac_scalar(out_tmp[i], s->celt_output[i], 1.0, celt_output_samples); } ret = av_audio_fifo_write(s->celt_delay, delaybuf, celt_delay); if (ret < 0) return ret; } } else ff_celt_flush(s->celt); if (s->redundancy_idx) { for (i = 0; i < s->output_channels; i++) opus_fade(s->out[i], s->out[i], s->redundancy_output[i] + 120 + s->redundancy_idx, ff_celt_window2 + s->redundancy_idx, 120 - s->redundancy_idx); s->redundancy_idx = 0; } if (redundancy) { if (!redundancy_pos) { ff_celt_flush(s->celt); ret = opus_decode_redundancy(s, data + size, [[tallman]]); if (ret < 0) return ret; for (i = 0; i < s->output_channels; i++) { opus_fade(s->out[i] + samples - 120 + delayed_samples, s->out[i] + samples - 120 + delayed_samples, s->redundancy_output[i] + 120, ff_celt_window2, 120 - delayed_samples); if (delayed_samples) s->redundancy_idx = 120 - delayed_samples; } } else { for (i = 0; i < s->output_channels; i++) { memcpy(s->out[i] + delayed_samples, s->redundancy_output[i], 120 * sizeof(float)); opus_fade(s->out[i] + 120 + delayed_samples, s->redundancy_output[i] + 120, s->out[i] + 120 + delayed_samples, ff_celt_window2, 120); } } } return samples; }[Succeeded / Failed / Skipped / Total] 65 / 5 / 47 / 117:   4%|         | 117/2690 [18:51<6:54:49,  9.67s/it][Succeeded / Failed / Skipped / Total] 65 / 5 / 47 / 117:   4%|         | 118/2690 [18:52<6:51:22,  9.60s/it][Succeeded / Failed / Skipped / Total] 65 / 5 / 48 / 118:   4%|         | 118/2690 [18:52<6:51:22,  9.60s/it][Succeeded / Failed / Skipped / Total] 65 / 5 / 48 / 118:   4%|         | 119/2690 [18:56<6:49:11,  9.55s/it][Succeeded / Failed / Skipped / Total] 66 / 5 / 48 / 119:   4%|         | 119/2690 [18:56<6:49:11,  9.55s/it][Succeeded / Failed / Skipped / Total] 66 / 5 / 48 / 119:   4%|         | 120/2690 [18:59<6:46:38,  9.49s/it][Succeeded / Failed / Skipped / Total] 67 / 5 / 48 / 120:   4%|         | 120/2690 [18:59<6:46:38,  9.49s/it][Succeeded / Failed / Skipped / Total] 67 / 5 / 48 / 120:   4%|         | 121/2690 [18:59<6:43:12,  9.42s/it][Succeeded / Failed / Skipped / Total] 68 / 5 / 48 / 121:   4%|         | 121/2690 [18:59<6:43:12,  9.42s/it][Succeeded / Failed / Skipped / Total] 68 / 5 / 48 / 121:   5%|         | 122/2690 [19:18<6:46:29,  9.50s/it][Succeeded / Failed / Skipped / Total] 69 / 5 / 48 / 122:   5%|         | 122/2690 [19:18<6:46:29,  9.50s/it][Succeeded / Failed / Skipped / Total] 69 / 5 / 48 / 122:   5%|         | 123/2690 [19:23<6:44:52,  9.46s/it][Succeeded / Failed / Skipped / Total] 70 / 5 / 48 / 123:   5%|         | 123/2690 [19:23<6:44:52,  9.46s/it][Succeeded / Failed / Skipped / Total] 70 / 5 / 48 / 123:   5%|         | 124/2690 [19:26<6:42:17,  9.41s/it][Succeeded / Failed / Skipped / Total] 71 / 5 / 48 / 124:   5%|         | 124/2690 [19:26<6:42:17,  9.41s/it][Succeeded / Failed / Skipped / Total] 71 / 5 / 48 / 124:   5%|         | 125/2690 [19:26<6:39:05,  9.34s/it]
--------------------------------------------- Result 118 ---------------------------------------------
[[0 (20%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int channelNum, int codingMode) { int band, result=0, numSubbands, lastTonal, numBands; if (codingMode == JOINT_STEREO && channelNum == 1) { if (get_bits(gb,2) != 3) { av_log(NULL,AV_LOG_ERROR,"JS mono Sound Unit id != 3.\n"); return -1; } } else { if (get_bits(gb,6) != 0x28) { av_log(NULL,AV_LOG_ERROR,"Sound Unit id != 0x28.\n"); return -1; } } pSnd->bandsCoded = get_bits(gb,2); result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded); if (result) return result; pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded); if (pSnd->numComponents == -1) return -1; numSubbands = decodeSpectrum (gb, pSnd->spectrum); lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components); numBands = (subbandTab[numSubbands] - 1) >> 8; if (lastTonal >= 0) numBands = FFMAX((lastTonal + 256) >> 8, numBands); for (band=0; band<4; band++) { if (band <= numBands) { IMLT(&(pSnd->spectrum[band*256]), pSnd->IMDCT_buf, band&1); } else memset(pSnd->IMDCT_buf, 0, 512 * sizeof(float)); gainCompensateAndOverlap (pSnd->IMDCT_buf, &(pSnd->prevFrame[band*256]), &(pOut[band*256]), &((pSnd->gainBlock[1 - (pSnd->gcBlkSwitch)]).gBlock[band]), &((pSnd->gainBlock[pSnd->gcBlkSwitch]).gBlock[band])); } pSnd->gcBlkSwitch ^= 1; return 0; }
--------------------------------------------- Result 119 ---------------------------------------------
[[0 (86%)]] --> [[0 (42%)]] --> Socre: 0.58212611079216

[[[[Adv]]]]: static target_long monitor_get_reg(const struct MonitorDef *md, int val) { CPUState *[[env]] = mon_get_cpu(); if (![[env]]) return 0; return [[env]]->regwptr[val]; }

[[[[Adv]]]]: static target_long monitor_get_reg(const struct MonitorDef *md, int val) { CPUState *[[advices]] = mon_get_cpu(); if (![[advices]]) return 0; return [[advices]]->regwptr[val]; }
--------------------------------------------- Result 120 ---------------------------------------------
[[0 (43%)]] --> [[0 (63%)]] --> Socre: 0.6271411776542664

[[[[Adv]]]]: static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t [[block]][4][16], ptrdiff_t stride) { vp8_idct_dc_add_c(dst+stride*0+0, [[block]][0], stride); vp8_idct_dc_add_c(dst+stride*0+4, [[block]][1], stride); vp8_idct_dc_add_c(dst+stride*4+0, [[block]][2], stride); vp8_idct_dc_add_c(dst+stride*4+4, [[block]][3], stride); }

[[[[Adv]]]]: static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t [[obstruct]][4][16], ptrdiff_t stride) { vp8_idct_dc_add_c(dst+stride*0+0, [[obstruct]][0], stride); vp8_idct_dc_add_c(dst+stride*0+4, [[obstruct]][1], stride); vp8_idct_dc_add_c(dst+stride*4+0, [[obstruct]][2], stride); vp8_idct_dc_add_c(dst+stride*4+4, [[obstruct]][3], stride); }
--------------------------------------------- Result 121 ---------------------------------------------
[[0 (67%)]] --> [[0 (38%)]] --> Socre: 0.6233191192150116

[[[[Adv]]]]: bool qemu_co_enter_next(CoQueue *queue) { Coroutine *[[next]]; [[next]] = QSIMPLEQ_FIRST(&queue->entries); if (![[next]]) { return "False" != "False"; } QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next); qemu_coroutine_enter([[next]], NULL); return "True" == "True"; }

[[[[Adv]]]]: bool qemu_co_enter_next(CoQueue *queue) { Coroutine *[[forthcoming]]; [[forthcoming]] = QSIMPLEQ_FIRST(&queue->entries); if (![[forthcoming]]) { return "False" != "False"; } QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next); qemu_coroutine_enter([[forthcoming]], NULL); return "True" == "True"; }
--------------------------------------------- Result 122 ---------------------------------------------
[[0 (35%)]] --> [[0 (64%)]] --> Socre: 0.6420454978942871

[[[[Adv]]]]: static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp) { VirtIODevice *vdev = VIRTIO_DEVICE(dev); V9fsVirtioState *[[v]] = VIRTIO_9P(dev); V9fsState *s = &[[v]]->state; virtio_cleanup(vdev); v9fs_device_unrealize_common(s, errp); }

[[[[Adv]]]]: static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp) { VirtIODevice *vdev = VIRTIO_DEVICE(dev); V9fsVirtioState *[[washington]] = VIRTIO_9P(dev); V9fsState *s = &[[washington]]->state; virtio_cleanup(vdev); v9fs_device_unrealize_common(s, errp); }
--------------------------------------------- Result 123 ---------------------------------------------
[[0 (56%)]] --> [[0 (48%)]] --> Socre: 0.5173284113407135

[[[[Adv]]]]: static av_cold int png_dec_end(AVCodecContext *avctx) { PNGDecContext *[[s]] = avctx->priv_data; ff_thread_release_buffer(avctx, &[[s]]->previous_picture); av_frame_free(&[[s]]->previous_picture.f); ff_thread_release_buffer(avctx, &[[s]]->last_picture); av_frame_free(&[[s]]->last_picture.f); ff_thread_release_buffer(avctx, &[[s]]->picture); av_frame_free(&[[s]]->picture.f); av_freep(&[[s]]->buffer); [[s]]->buffer_size = 0; av_freep(&[[s]]->last_row); [[s]]->last_row_size = 0; av_freep(&[[s]]->tmp_row); [[s]]->tmp_row_size = 0; av_freep(&[[s]]->extra_data); [[s]]->extra_data_size = 0; return 0; }

[[[[Adv]]]]: static av_cold int png_dec_end(AVCodecContext *avctx) { PNGDecContext *[[seconds]] = avctx->priv_data; ff_thread_release_buffer(avctx, &[[seconds]]->previous_picture); av_frame_free(&[[seconds]]->previous_picture.f); ff_thread_release_buffer(avctx, &[[seconds]]->last_picture); av_frame_free(&[[seconds]]->last_picture.f); ff_thread_release_buffer(avctx, &[[seconds]]->picture); av_frame_free(&[[seconds]]->picture.f); av_freep(&[[seconds]]->buffer); [[seconds]]->buffer_size = 0; av_freep(&[[seconds]]->last_row); [[seconds]]->last_row_size = 0; av_freep(&[[seconds]]->tmp_row); [[seconds]]->tmp_row_size = 0; av_freep(&[[seconds]]->extra_data); [[seconds]]->extra_data_size = 0; return 0; }
--------------------------------------------- Result 124 ---------------------------------------------
[[0 (62%)]] --> [[0 (49%)]] --> Socre: 0.5109699666500092

[[[[Adv]]]]: static void fd_chr_update_read_handler(CharDriverState *[[chr]]) { FDCharDriver *[[s]] = [[chr]]->opaque; if ([[s]]->fd_in_tag) { g_source_remove([[s]]->fd_in_tag); [[s]]->fd_in_tag = 0; } if ([[s]]->fd_in) { [[s]]->fd_in_tag = io_add_watch_poll([[s]]->fd_in, fd_chr_read_poll, fd_chr_read, [[chr]]); } }

[[[[Adv]]]]: static void fd_chr_update_read_handler(CharDriverState *[[veridian]]) { FDCharDriver *[[d]] = [[veridian]]->opaque; if ([[d]]->fd_in_tag) { g_source_remove([[d]]->fd_in_tag); [[d]]->fd_in_tag = 0; } if ([[d]]->fd_in) { [[d]]->fd_in_tag = io_add_watch_poll([[d]]->fd_in, fd_chr_read_poll, fd_chr_read, [[veridian]]); } }
--------------------------------------------- Result 125 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 71 / 5 / 49 / 125:   5%|         | 125/2690 [19:26<6:39:05,  9.34s/it][Succeeded / Failed / Skipped / Total] 71 / 5 / 49 / 125:   5%|         | 126/2690 [19:27<6:35:56,  9.27s/it][Succeeded / Failed / Skipped / Total] 71 / 5 / 50 / 126:   5%|         | 126/2690 [19:27<6:35:56,  9.27s/it][Succeeded / Failed / Skipped / Total] 71 / 5 / 50 / 126:   5%|         | 127/2690 [20:26<6:52:37,  9.66s/it][Succeeded / Failed / Skipped / Total] 72 / 5 / 50 / 127:   5%|         | 127/2690 [20:26<6:52:37,  9.66s/it][Succeeded / Failed / Skipped / Total] 72 / 5 / 50 / 127:   5%|         | 128/2690 [20:27<6:49:25,  9.59s/it][Succeeded / Failed / Skipped / Total] 72 / 5 / 51 / 128:   5%|         | 128/2690 [20:27<6:49:25,  9.59s/it][Succeeded / Failed / Skipped / Total] 72 / 5 / 51 / 128:   5%|         | 129/2690 [20:39<6:50:12,  9.61s/it][[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int probe_file(WriterContext *wctx, const char *filename) { AVFormatContext *fmt_ctx; int ret, i; int section_id; do_read_frames = do_show_frames || do_count_frames; do_read_packets = do_show_packets || do_count_packets; ret = open_input_file(&fmt_ctx, filename); if (ret < 0) return ret; #define CHECK_END if (ret < 0) goto end nb_streams_frames = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames)); nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets)); selected_streams = av_calloc(fmt_ctx->nb_streams, sizeof(*selected_streams)); for (i = 0; i < fmt_ctx->nb_streams; i++) { if (stream_specifier) { ret = avformat_match_stream_specifier(fmt_ctx, fmt_ctx->streams[i], stream_specifier); CHECK_END; else selected_streams[i] = ret; ret = 0; } else { selected_streams[i] = 1; } } if (do_read_frames || do_read_packets) { if (do_show_frames && do_show_packets && wctx->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER) section_id = SECTION_ID_PACKETS_AND_FRAMES; else if (do_show_packets && !do_show_frames) section_id = SECTION_ID_PACKETS; else section_id = SECTION_ID_FRAMES; if (do_show_frames || do_show_packets) writer_print_section_header(wctx, section_id); ret = read_packets(wctx, fmt_ctx); if (do_show_frames || do_show_packets) writer_print_section_footer(wctx); CHECK_END; } if (do_show_programs) { ret = show_programs(wctx, fmt_ctx); CHECK_END; } if (do_show_streams) { ret = show_streams(wctx, fmt_ctx); CHECK_END; } if (do_show_chapters) { ret = show_chapters(wctx, fmt_ctx); CHECK_END; } if (do_show_format) { ret = show_format(wctx, fmt_ctx); CHECK_END; } end: close_input_file(&fmt_ctx); av_freep(&nb_streams_frames); av_freep(&nb_streams_packets); av_freep(&selected_streams); return ret; }
--------------------------------------------- Result 126 ---------------------------------------------
[[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr, target_phys_addr_t end_addr) { KVMState *s = kvm_state; unsigned long size, allocated_size = 0; KVMDirtyLog d; KVMSlot *mem; int ret = 0; d.dirty_bitmap = NULL; while (start_addr < end_addr) { mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr); if (mem == NULL) { break; } size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8; if (!d.dirty_bitmap) { d.dirty_bitmap = qemu_malloc(size); } else if (size > allocated_size) { d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size); } allocated_size = size; memset(d.dirty_bitmap, 0, allocated_size); d.slot = mem->slot; if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) { DPRINTF("ioctl failed %d\n", errno); ret = -1; break; } kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap, mem->start_addr, mem->memory_size); start_addr = mem->start_addr + mem->memory_size; } qemu_free(d.dirty_bitmap); return ret; }
--------------------------------------------- Result 127 ---------------------------------------------
[[0 (59%)]] --> [[0 (42%)]] --> Socre: 0.5801800191402435

[[[[Adv]]]]: static void integratorcp_init(QEMUMachineInitArgs *args) { ram_addr_t ram_size = args->ram_size; const char *cpu_model = args->cpu_model; const char *[[kernel_filename]] = args->kernel_filename; const char *kernel_cmdline = args->kernel_cmdline; const char *initrd_filename = args->initrd_filename; ARMCPU *cpu; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); MemoryRegion *ram_alias = g_new(MemoryRegion, 1); qemu_irq pic[32]; DeviceState *[[dev]]; int i; if (!cpu_model) { cpu_model = "arm926"; } cpu = cpu_arm_init(cpu_model); if (!cpu) { fprintf(stderr, "Unable to find CPU definition\n"); exit(1); } memory_region_init_ram(ram, NULL, "integrator.ram", ram_size); vmstate_register_ram_global(ram); memory_region_add_subregion(address_space_mem, 0, ram); memory_region_init_alias(ram_alias, NULL, "ram.alias", ram, 0, ram_size); memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias); [[dev]] = qdev_create(NULL, TYPE_INTEGRATOR_CM); qdev_prop_set_uint32([[dev]], "memsz", ram_size >> 20); qdev_init_nofail([[dev]]); sysbus_mmio_map((SysBusDevice *)[[dev]], 0, 0x10000000); [[dev]] = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000, qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ), qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ), NULL); for (i = 0; i < 32; i++) { pic[i] = qdev_get_gpio_in([[dev]], i); } sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, pic[26]); sysbus_create_varargs("integrator_pit", 0x13000000, pic[5], pic[6], pic[7], NULL); sysbus_create_simple("pl031", 0x15000000, pic[8]); sysbus_create_simple("pl011", 0x16000000, pic[1]); sysbus_create_simple("pl011", 0x17000000, pic[2]); icp_control_init(0xcb000000); sysbus_create_simple("pl050_keyboard", 0x18000000, pic[3]); sysbus_create_simple("pl050_mouse", 0x19000000, pic[4]); sysbus_create_varargs("pl181", 0x1c000000, pic[23], pic[24], NULL); if (nd_table[0].used) smc91c111_init(&nd_table[0], 0xc8000000, pic[27]); sysbus_create_simple("pl110", 0xc0000000, pic[22]); integrator_binfo.ram_size = ram_size; integrator_binfo.kernel_filename = [[kernel_filename]]; integrator_binfo.kernel_cmdline = kernel_cmdline; integrator_binfo.initrd_filename = initrd_filename; arm_load_kernel(cpu, &integrator_binfo); }

[[[[Adv]]]]: static void integratorcp_init(QEMUMachineInitArgs *args) { ram_addr_t ram_size = args->ram_size; const char *cpu_model = args->cpu_model; const char *[[spittoon]] = args->kernel_filename; const char *kernel_cmdline = args->kernel_cmdline; const char *initrd_filename = args->initrd_filename; ARMCPU *cpu; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); MemoryRegion *ram_alias = g_new(MemoryRegion, 1); qemu_irq pic[32]; DeviceState *[[nitin]]; int i; if (!cpu_model) { cpu_model = "arm926"; } cpu = cpu_arm_init(cpu_model); if (!cpu) { fprintf(stderr, "Unable to find CPU definition\n"); exit(1); } memory_region_init_ram(ram, NULL, "integrator.ram", ram_size); vmstate_register_ram_global(ram); memory_region_add_subregion(address_space_mem, 0, ram); memory_region_init_alias(ram_alias, NULL, "ram.alias", ram, 0, ram_size); memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias); [[nitin]] = qdev_create(NULL, TYPE_INTEGRATOR_CM); qdev_prop_set_uint32([[nitin]], "memsz", ram_size >> 20); qdev_init_nofail([[nitin]]); sysbus_mmio_map((SysBusDevice *)[[nitin]], 0, 0x10000000); [[nitin]] = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000, qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ), qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ), NULL); for (i = 0; i < 32; i++) { pic[i] = qdev_get_gpio_in([[nitin]], i); } sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, pic[26]); sysbus_create_varargs("integrator_pit", 0x13000000, pic[5], pic[6], pic[7], NULL); sysbus_create_simple("pl031", 0x15000000, pic[8]); sysbus_create_simple("pl011", 0x16000000, pic[1]); sysbus_create_simple("pl011", 0x17000000, pic[2]); icp_control_init(0xcb000000); sysbus_create_simple("pl050_keyboard", 0x18000000, pic[3]); sysbus_create_simple("pl050_mouse", 0x19000000, pic[4]); sysbus_create_varargs("pl181", 0x1c000000, pic[23], pic[24], NULL); if (nd_table[0].used) smc91c111_init(&nd_table[0], 0xc8000000, pic[27]); sysbus_create_simple("pl110", 0xc0000000, pic[22]); integrator_binfo.ram_size = ram_size; integrator_binfo.kernel_filename = [[spittoon]]; integrator_binfo.kernel_cmdline = kernel_cmdline; integrator_binfo.initrd_filename = initrd_filename; arm_load_kernel(cpu, &integrator_binfo); }
--------------------------------------------- Result 128 ---------------------------------------------
[[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int main(void) { int nf; Suite *s; SRunner *sr; s = qfloat_suite(); sr = srunner_create(s); srunner_run_all(sr, CK_NORMAL); nf = srunner_ntests_failed(sr); srunner_free(sr); return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE; }
--------------------------------------------- Result 129 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 73 / 5 / 51 / 129:   5%|         | 129/2690 [20:39<6:50:12,  9.61s/it][Succeeded / Failed / Skipped / Total] 73 / 5 / 51 / 129:   5%|         | 130/2690 [20:40<6:47:03,  9.54s/it][Succeeded / Failed / Skipped / Total] 73 / 5 / 52 / 130:   5%|         | 130/2690 [20:40<6:47:03,  9.54s/it][Succeeded / Failed / Skipped / Total] 73 / 5 / 52 / 130:   5%|         | 131/2690 [20:40<6:43:57,  9.47s/it][Succeeded / Failed / Skipped / Total] 73 / 5 / 53 / 131:   5%|         | 131/2690 [20:40<6:43:57,  9.47s/it][Succeeded / Failed / Skipped / Total] 73 / 5 / 53 / 131:   5%|         | 132/2690 [21:22<6:54:16,  9.72s/it][Succeeded / Failed / Skipped / Total] 74 / 5 / 53 / 132:   5%|         | 132/2690 [21:22<6:54:16,  9.72s/it][Succeeded / Failed / Skipped / Total] 74 / 5 / 53 / 132:   5%|         | 133/2690 [21:29<6:53:03,  9.69s/it][[0 (2%)]] --> [[0 (99%)]] --> Socre: 0.9909680485725403

[[[[Adv]]]]: static target_ulong put_tce_emu(sPAPRTCETable *[[tcet]], target_ulong ioba, target_ulong tce) { IOMMUTLBEntry entry; hwaddr page_mask = IOMMU_PAGE_MASK([[tcet]]->page_shift); unsigned long index = (ioba - [[tcet]]->bus_offset) >> [[tcet]]->page_shift; if (index >= [[tcet]]->nb_table) { hcall_dprintf("spapr_vio_put_tce on out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", ioba); return H_PARAMETER; } [[tcet]]->table[index] = tce; entry.target_as = &address_space_memory, entry.iova = ioba & page_mask; entry.translated_addr = tce & page_mask; entry.addr_mask = ~page_mask; entry.perm = spapr_tce_iommu_access_flags(tce); memory_region_notify_iommu(&[[tcet]]->iommu, entry); return H_SUCCESS; }

[[[[Adv]]]]: static target_ulong put_tce_emu(sPAPRTCETable *[[enchant]], target_ulong ioba, target_ulong tce) { IOMMUTLBEntry entry; hwaddr page_mask = IOMMU_PAGE_MASK([[enchant]]->page_shift); unsigned long index = (ioba - [[enchant]]->bus_offset) >> [[enchant]]->page_shift; if (index >= [[enchant]]->nb_table) { hcall_dprintf("spapr_vio_put_tce on out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", ioba); return H_PARAMETER; } [[enchant]]->table[index] = tce; entry.target_as = &address_space_memory, entry.iova = ioba & page_mask; entry.translated_addr = tce & page_mask; entry.addr_mask = ~page_mask; entry.perm = spapr_tce_iommu_access_flags(tce); memory_region_notify_iommu(&[[enchant]]->iommu, entry); return H_SUCCESS; }
--------------------------------------------- Result 130 ---------------------------------------------
[[0 (65%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static target_ulong h_enter(CPUState *env, sPAPREnvironment *spapr, target_ulong opcode, target_ulong *args) { target_ulong flags = args[0]; target_ulong pte_index = args[1]; target_ulong pteh = args[2]; target_ulong ptel = args[3]; target_ulong i; uint8_t *hpte; if (pteh & HPTE_V_LARGE) { #if 0 if ((ptel & 0xf000) == 0x1000) { } else #endif if ((ptel & 0xff000) == 0) { if (pteh & 0x80) { return H_PARAMETER; } } else { return H_PARAMETER; } } if ((ptel & HPTE_R_WIMG) != HPTE_R_M) { return H_PARAMETER; } pteh &= ~0x60ULL; if ((pte_index * HASH_PTE_SIZE_64) & ~env->htab_mask) { return H_PARAMETER; } if (likely((flags & H_EXACT) == 0)) { pte_index &= ~7ULL; hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64); for (i = 0; ; ++i) { if (i == 8) { return H_PTEG_FULL; } if (((ldq_p(hpte) & HPTE_V_VALID) == 0) && lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) { break; } hpte += HASH_PTE_SIZE_64; } } else { i = 0; hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64); if (!lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) { return H_PTEG_FULL; } } stq_p(hpte + (HASH_PTE_SIZE_64/2), ptel); stq_p(hpte, pteh); assert(!(ldq_p(hpte) & HPTE_V_HVLOCK)); args[0] = pte_index + i; return H_SUCCESS; }
--------------------------------------------- Result 131 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1, TCGv arg2, int add_ca, int compute_ca, int compute_ov) { TCGv t0, t1; if ((!compute_ca && !compute_ov) || (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2))) { t0 = ret; } else { t0 = tcg_temp_local_new(); } if (add_ca) { t1 = tcg_temp_local_new(); tcg_gen_mov_tl(t1, cpu_ca); } else { TCGV_UNUSED(t1); } if (compute_ca) { tcg_gen_movi_tl(cpu_ca, 0); } if (compute_ov) { tcg_gen_movi_tl(cpu_ov, 0); } tcg_gen_add_tl(t0, arg1, arg2); if (compute_ca) { gen_op_arith_compute_ca(ctx, t0, arg1, 0); } if (add_ca) { tcg_gen_add_tl(t0, t0, t1); gen_op_arith_compute_ca(ctx, t0, t1, 0); tcg_temp_free(t1); } if (compute_ov) { gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0); } if (unlikely(Rc(ctx->opcode) != 0)) gen_set_Rc0(ctx, t0); if (!TCGV_EQUAL(t0, ret)) { tcg_gen_mov_tl(ret, t0); tcg_temp_free(t0); } }
--------------------------------------------- Result 132 ---------------------------------------------
[[0 (84%)]] --> [[0 (44%)]] --> Socre: 0.5636920630931854

[[[[Adv]]]]: static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size) { const uint16_t *end; const uint16_t *[[mm_end]]; uint8_t *d = dst; const uint16_t *s = (const uint16_t*)src; end = s + src_size/2; __asm__ volatile(PREFETCH" %0"::"m"(*s):"memory"); [[mm_end]] = end - 7; while (s < [[mm_end]]) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movq %1, %%mm0 \n\t" "movq %1, %%mm1 \n\t" "movq %1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq $8, %%mm1 \n\t" "psllq $16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq $8, %%mm4 \n\t" "psllq $16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" "movq %%mm0, %%mm6 \n\t" "movq %%mm3, %%mm7 \n\t" "movq 8%1, %%mm0 \n\t" "movq 8%1, %%mm1 \n\t" "movq 8%1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq $8, %%mm1 \n\t" "psllq $16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq $8, %%mm4 \n\t" "psllq $16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" :"=m"(*d) :"m"(*s),"m"(mask15b),"m"(mask15g),"m"(mask15r), "m"(mmx_null) :"memory"); __asm__ volatile( "movq %%mm0, %%mm4 \n\t" "movq %%mm3, %%mm5 \n\t" "movq %%mm6, %%mm0 \n\t" "movq %%mm7, %%mm1 \n\t" "movq %%mm4, %%mm6 \n\t" "movq %%mm5, %%mm7 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" STORE_BGR24_MMX :"=m"(*d) :"m"(*s) :"memory"); d += 24; s += 8; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while (s < end) { register uint16_t bgr; bgr = *s++; *d++ = (bgr&0x1F)<<3; *d++ = (bgr&0x3E0)>>2; *d++ = (bgr&0x7C00)>>7; } }

[[[[Adv]]]]: static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size) { const uint16_t *end; const uint16_t *[[profiteering]]; uint8_t *d = dst; const uint16_t *s = (const uint16_t*)src; end = s + src_size/2; __asm__ volatile(PREFETCH" %0"::"m"(*s):"memory"); [[profiteering]] = end - 7; while (s < [[profiteering]]) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movq %1, %%mm0 \n\t" "movq %1, %%mm1 \n\t" "movq %1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq $8, %%mm1 \n\t" "psllq $16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq $8, %%mm4 \n\t" "psllq $16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" "movq %%mm0, %%mm6 \n\t" "movq %%mm3, %%mm7 \n\t" "movq 8%1, %%mm0 \n\t" "movq 8%1, %%mm1 \n\t" "movq 8%1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq $8, %%mm1 \n\t" "psllq $16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq $8, %%mm4 \n\t" "psllq $16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" :"=m"(*d) :"m"(*s),"m"(mask15b),"m"(mask15g),"m"(mask15r), "m"(mmx_null) :"memory"); __asm__ volatile( "movq %%mm0, %%mm4 \n\t" "movq %%mm3, %%mm5 \n\t" "movq %%mm6, %%mm0 \n\t" "movq %%mm7, %%mm1 \n\t" "movq %%mm4, %%mm6 \n\t" "movq %%mm5, %%mm7 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" STORE_BGR24_MMX :"=m"(*d) :"m"(*s) :"memory"); d += 24; s += 8; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while (s < end) { register uint16_t bgr; bgr = *s++; *d++ = (bgr&0x1F)<<3; *d++ = (bgr&0x3E0)>>2; *d++ = (bgr&0x7C00)>>7; } }
--------------------------------------------- Result 133 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 75 / 5 / 53 / 133:   5%|         | 133/2690 [21:29<6:53:03,  9.69s/it][Succeeded / Failed / Skipped / Total] 75 / 5 / 53 / 133:   5%|         | 134/2690 [21:33<6:51:21,  9.66s/it][Succeeded / Failed / Skipped / Total] 76 / 5 / 53 / 134:   5%|         | 134/2690 [21:33<6:51:21,  9.66s/it][Succeeded / Failed / Skipped / Total] 76 / 5 / 53 / 134:   5%|         | 135/2690 [22:21<7:03:04,  9.94s/it][[0 (52%)]] --> [[0 (41%)]] --> Socre: 0.5874531865119934

[[[[Adv]]]]: int inet_dgram_opts(QemuOpts *opts) { struct addrinfo ai, *peer = NULL, *local = NULL; const char *addr; const char *[[port]]; char uaddr[INET6_ADDRSTRLEN+1]; char uport[33]; int sock = -1, rc; memset(&ai,0, sizeof(ai)); ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG; ai.ai_family = PF_UNSPEC; ai.ai_socktype = SOCK_DGRAM; addr = qemu_opt_get(opts, "host"); [[port]] = qemu_opt_get(opts, "port"); if (addr == NULL || strlen(addr) == 0) { addr = "localhost"; } if ([[port]] == NULL || strlen([[port]]) == 0) { fprintf(stderr, "inet_dgram: port not specified\n"); return -1; } if (qemu_opt_get_bool(opts, "ipv4", 0)) ai.ai_family = PF_INET; if (qemu_opt_get_bool(opts, "ipv6", 0)) ai.ai_family = PF_INET6; if (0 != (rc = getaddrinfo(addr, [[port]], &ai, &peer))) { fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, [[port]], gai_strerror(rc)); return -1; } if (sockets_debug) { fprintf(stderr, "%s: peer (%s:%s)\n", __FUNCTION__, addr, [[port]]); inet_print_addrinfo(__FUNCTION__, peer); } memset(&ai,0, sizeof(ai)); ai.ai_flags = AI_PASSIVE; ai.ai_family = peer->ai_family; ai.ai_socktype = SOCK_DGRAM; addr = qemu_opt_get(opts, "localaddr"); [[port]] = qemu_opt_get(opts, "localport"); if (addr == NULL || strlen(addr) == 0) { addr = NULL; } if (![[port]] || strlen([[port]]) == 0) [[port]] = "0"; if (0 != (rc = getaddrinfo(addr, [[port]], &ai, &local))) { fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, [[port]], gai_strerror(rc)); return -1; } if (sockets_debug) { fprintf(stderr, "%s: local (%s:%s)\n", __FUNCTION__, addr, [[port]]); inet_print_addrinfo(__FUNCTION__, local); } sock = socket(peer->ai_family, peer->ai_socktype, peer->ai_protocol); if (sock < 0) { fprintf(stderr,"%s: socket(%s): %s\n", __FUNCTION__, inet_strfamily(peer->ai_family), strerror(errno)); goto err; } setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on)); if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen, uaddr,INET6_ADDRSTRLEN,uport,32, NI_NUMERICHOST | NI_NUMERICSERV) != 0) { fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__); goto err; } if (bind(sock, local->ai_addr, local->ai_addrlen) < 0) { fprintf(stderr,"%s: bind(%s,%s,%d): OK\n", __FUNCTION__, inet_strfamily(local->ai_family), uaddr, inet_getport(local)); goto err; } if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen, uaddr, INET6_ADDRSTRLEN, uport, 32, NI_NUMERICHOST | NI_NUMERICSERV) != 0) { fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__); goto err; } if (connect(sock,peer->ai_addr,peer->ai_addrlen) < 0) { fprintf(stderr, "%s: connect(%s,%s,%s,%s): %s\n", __FUNCTION__, inet_strfamily(peer->ai_family), peer->ai_canonname, uaddr, uport, strerror(errno)); goto err; } freeaddrinfo(local); freeaddrinfo(peer); return sock; err: if (-1 != sock) closesocket(sock); if (local) freeaddrinfo(local); if (peer) freeaddrinfo(peer); return -1; }

[[[[Adv]]]]: int inet_dgram_opts(QemuOpts *opts) { struct addrinfo ai, *peer = NULL, *local = NULL; const char *addr; const char *[[oasis]]; char uaddr[INET6_ADDRSTRLEN+1]; char uport[33]; int sock = -1, rc; memset(&ai,0, sizeof(ai)); ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG; ai.ai_family = PF_UNSPEC; ai.ai_socktype = SOCK_DGRAM; addr = qemu_opt_get(opts, "host"); [[oasis]] = qemu_opt_get(opts, "port"); if (addr == NULL || strlen(addr) == 0) { addr = "localhost"; } if ([[oasis]] == NULL || strlen([[oasis]]) == 0) { fprintf(stderr, "inet_dgram: port not specified\n"); return -1; } if (qemu_opt_get_bool(opts, "ipv4", 0)) ai.ai_family = PF_INET; if (qemu_opt_get_bool(opts, "ipv6", 0)) ai.ai_family = PF_INET6; if (0 != (rc = getaddrinfo(addr, [[oasis]], &ai, &peer))) { fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, [[oasis]], gai_strerror(rc)); return -1; } if (sockets_debug) { fprintf(stderr, "%s: peer (%s:%s)\n", __FUNCTION__, addr, [[oasis]]); inet_print_addrinfo(__FUNCTION__, peer); } memset(&ai,0, sizeof(ai)); ai.ai_flags = AI_PASSIVE; ai.ai_family = peer->ai_family; ai.ai_socktype = SOCK_DGRAM; addr = qemu_opt_get(opts, "localaddr"); [[oasis]] = qemu_opt_get(opts, "localport"); if (addr == NULL || strlen(addr) == 0) { addr = NULL; } if (![[oasis]] || strlen([[oasis]]) == 0) [[oasis]] = "0"; if (0 != (rc = getaddrinfo(addr, [[oasis]], &ai, &local))) { fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, [[oasis]], gai_strerror(rc)); return -1; } if (sockets_debug) { fprintf(stderr, "%s: local (%s:%s)\n", __FUNCTION__, addr, [[oasis]]); inet_print_addrinfo(__FUNCTION__, local); } sock = socket(peer->ai_family, peer->ai_socktype, peer->ai_protocol); if (sock < 0) { fprintf(stderr,"%s: socket(%s): %s\n", __FUNCTION__, inet_strfamily(peer->ai_family), strerror(errno)); goto err; } setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on)); if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen, uaddr,INET6_ADDRSTRLEN,uport,32, NI_NUMERICHOST | NI_NUMERICSERV) != 0) { fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__); goto err; } if (bind(sock, local->ai_addr, local->ai_addrlen) < 0) { fprintf(stderr,"%s: bind(%s,%s,%d): OK\n", __FUNCTION__, inet_strfamily(local->ai_family), uaddr, inet_getport(local)); goto err; } if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen, uaddr, INET6_ADDRSTRLEN, uport, 32, NI_NUMERICHOST | NI_NUMERICSERV) != 0) { fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__); goto err; } if (connect(sock,peer->ai_addr,peer->ai_addrlen) < 0) { fprintf(stderr, "%s: connect(%s,%s,%s,%s): %s\n", __FUNCTION__, inet_strfamily(peer->ai_family), peer->ai_canonname, uaddr, uport, strerror(errno)); goto err; } freeaddrinfo(local); freeaddrinfo(peer); return sock; err: if (-1 != sock) closesocket(sock); if (local) freeaddrinfo(local); if (peer) freeaddrinfo(peer); return -1; }
--------------------------------------------- Result 134 ---------------------------------------------
[[0 (28%)]] --> [[0 (53%)]] --> Socre: 0.5331723690032959

[[[[Adv]]]]: static int ftp_file_size(FTPContext *s) { char command[CONTROL_BUFFER_SIZE]; char *res = NULL; const int [[size_codes]][] = {213, 0}; snprintf(command, sizeof(command), "SIZE %s\r\n", s->path); if (ftp_send_command(s, command, [[size_codes]], &res)) { s->filesize = strtoll(&res[4], NULL, 10); } else { s->filesize = -1; av_free(res); return AVERROR(EIO); } av_free(res); return 0; }

[[[[Adv]]]]: static int ftp_file_size(FTPContext *s) { char command[CONTROL_BUFFER_SIZE]; char *res = NULL; const int [[cougars]][] = {213, 0}; snprintf(command, sizeof(command), "SIZE %s\r\n", s->path); if (ftp_send_command(s, command, [[cougars]], &res)) { s->filesize = strtoll(&res[4], NULL, 10); } else { s->filesize = -1; av_free(res); return AVERROR(EIO); } av_free(res); return 0; }
--------------------------------------------- Result 135 ---------------------------------------------
[[0 (64%)]] --> [[0 (49%)]] --> Socre: 0.5091046690940857

[[[[Adv]]]]: static int alloc_refcount_block(BlockDriverState *bs, int64_t cluster_index, uint16_t **refcount_block) { BDRVQcowState *s = bs->opaque; unsigned int [[refcount_table_index]]; int ret; BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC); [[refcount_table_index]] = cluster_index >> s->refcount_block_bits; if ([[refcount_table_index]] < s->refcount_table_size) { uint64_t refcount_block_offset = s->refcount_table[[[refcount_table_index]]] & REFT_OFFSET_MASK; if (refcount_block_offset) { if (offset_into_cluster(s, refcount_block_offset)) { qcow2_signal_corruption(bs, "True" == "True", -1, -1, "Refblock offset %#" PRIx64 " unaligned (reftable index: " "%#x)", refcount_block_offset, [[refcount_table_index]]); return -EIO; } return load_refcount_block(bs, refcount_block_offset, (void**) refcount_block); } } *refcount_block = NULL; ret = qcow2_cache_flush(bs, s->l2_table_cache); if (ret < 0) { return ret; } int64_t new_block = alloc_clusters_noref(bs, s->cluster_size); if (new_block < 0) { return new_block; } #ifdef DEBUG_ALLOC2 fprintf(stderr, "qcow2: Allocate refcount block %d for %" PRIx64 " at %" PRIx64 "\n", [[refcount_table_index]], cluster_index << s->cluster_bits, new_block); #endif if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) { ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block, (void**) refcount_block); if (ret < 0) { goto fail_block; } memset(*refcount_block, 0, s->cluster_size); int block_index = (new_block >> s->cluster_bits) & (s->refcount_block_size - 1); (*refcount_block)[block_index] = cpu_to_be16(1); } else { ret = update_refcount(bs, new_block, s->cluster_size, 1, "False" != "False", QCOW2_DISCARD_NEVER); if (ret < 0) { goto fail_block; } ret = qcow2_cache_flush(bs, s->refcount_block_cache); if (ret < 0) { goto fail_block; } ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block, (void**) refcount_block); if (ret < 0) { goto fail_block; } memset(*refcount_block, 0, s->cluster_size); } BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE); qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block); ret = qcow2_cache_flush(bs, s->refcount_block_cache); if (ret < 0) { goto fail_block; } if ([[refcount_table_index]] < s->refcount_table_size) { uint64_t data64 = cpu_to_be64(new_block); BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP); ret = bdrv_pwrite_sync(bs->file, s->refcount_table_offset + [[refcount_table_index]] * sizeof(uint64_t), &data64, sizeof(data64)); if (ret < 0) { goto fail_block; } s->refcount_table[[[refcount_table_index]]] = new_block; return -EAGAIN; } ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block); if (ret < 0) { goto fail_block; } BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW); uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size); if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) { return -EFBIG; } uint64_t table_size = next_refcount_table_size(s, blocks_used + 1); uint64_t last_table_size; uint64_t blocks_clusters; do { uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t)); blocks_clusters = 1 + ((table_clusters + s->refcount_block_size - 1) / s->refcount_block_size); uint64_t meta_clusters = table_clusters + blocks_clusters; last_table_size = table_size; table_size = next_refcount_table_size(s, blocks_used + ((meta_clusters + s->refcount_block_size - 1) / s->refcount_block_size)); } while (last_table_size != table_size); #ifdef DEBUG_ALLOC2 fprintf(stderr, "qcow2: Grow refcount table %" PRId32 " => %" PRId64 "\n", s->refcount_table_size, table_size); #endif uint64_t meta_offset = (blocks_used * s->refcount_block_size) * s->cluster_size; uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size; uint64_t *new_table = g_try_new0(uint64_t, table_size); uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size); assert(table_size > 0 && blocks_clusters > 0); if (new_table == NULL || new_blocks == NULL) { ret = -ENOMEM; goto fail_table; } memcpy(new_table, s->refcount_table, s->refcount_table_size * sizeof(uint64_t)); new_table[[[refcount_table_index]]] = new_block; int i; for (i = 0; i < blocks_clusters; i++) { new_table[blocks_used + i] = meta_offset + (i * s->cluster_size); } uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t)); int block = 0; for (i = 0; i < table_clusters + blocks_clusters; i++) { new_blocks[block++] = cpu_to_be16(1); } BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS); ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks, blocks_clusters * s->cluster_size); g_free(new_blocks); new_blocks = NULL; if (ret < 0) { goto fail_table; } for(i = 0; i < table_size; i++) { cpu_to_be64s(&new_table[i]); } BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE); ret = bdrv_pwrite_sync(bs->file, table_offset, new_table, table_size * sizeof(uint64_t)); if (ret < 0) { goto fail_table; } for(i = 0; i < table_size; i++) { be64_to_cpus(&new_table[i]); } uint8_t data[12]; cpu_to_be64w((uint64_t*)data, table_offset); cpu_to_be32w((uint32_t*)(data + 8), table_clusters); BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE); ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset), data, sizeof(data)); if (ret < 0) { goto fail_table; } uint64_t old_table_offset = s->refcount_table_offset; uint64_t old_table_size = s->refcount_table_size; g_free(s->refcount_table); s->refcount_table = new_table; s->refcount_table_size = table_size; s->refcount_table_offset = table_offset; qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t), QCOW2_DISCARD_OTHER); ret = load_refcount_block(bs, new_block, (void**) refcount_block); if (ret < 0) { return ret; } return -EAGAIN; fail_table: g_free(new_blocks); g_free(new_table); fail_block: if (*refcount_block != NULL) { qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block); } return ret; }

[[[[Adv]]]]: static int alloc_refcount_block(BlockDriverState *bs, int64_t cluster_index, uint16_t **refcount_block) { BDRVQcowState *s = bs->opaque; unsigned int [[blackmailed]]; int ret; BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC); [[blackmailed]] = cluster_index >> s->refcount_block_bits; if ([[blackmailed]] < s->refcount_table_size) { uint64_t refcount_block_offset = s->refcount_table[[[blackmailed]]] & REFT_OFFSET_MASK; if (refcount_block_offset) { if (offset_into_cluster(s, refcount_block_offset)) { qcow2_signal_corruption(bs, "True" == "True", -1, -1, "Refblock offset %#" PRIx64 " unaligned (reftable index: " "%#x)", refcount_block_offset, [[blackmailed]]); return -EIO; } return load_refcount_block(bs, refcount_block_offset, (void**) refcount_block); } } *refcount_block = NULL; ret = qcow2_cache_flush(bs, s->l2_table_cache); if (ret < 0) { return ret; } int64_t new_block = alloc_clusters_noref(bs, s->cluster_size); if (new_block < 0) { return new_block; } #ifdef DEBUG_ALLOC2 fprintf(stderr, "qcow2: Allocate refcount block %d for %" PRIx64 " at %" PRIx64 "\n", [[blackmailed]], cluster_index << s->cluster_bits, new_block); #endif if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) { ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block, (void**) refcount_block); if (ret < 0) { goto fail_block; } memset(*refcount_block, 0, s->cluster_size); int block_index = (new_block >> s->cluster_bits) & (s->refcount_block_size - 1); (*refcount_block)[block_index] = cpu_to_be16(1); } else { ret = update_refcount(bs, new_block, s->cluster_size, 1, "False" != "False", QCOW2_DISCARD_NEVER); if (ret < 0) { goto fail_block; } ret = qcow2_cache_flush(bs, s->refcount_block_cache); if (ret < 0) { goto fail_block; } ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block, (void**) refcount_block); if (ret < 0) { goto fail_block; } memset(*refcount_block, 0, s->cluster_size); } BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE); qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block); ret = qcow2_cache_flush(bs, s->refcount_block_cache); if (ret < 0) { goto fail_block; } if ([[blackmailed]] < s->refcount_table_size) { uint64_t data64 = cpu_to_be64(new_block); BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP); ret = bdrv_pwrite_sync(bs->file, s->refcount_table_offset + [[blackmailed]] * sizeof(uint64_t), &data64, sizeof(data64)); if (ret < 0) { goto fail_block; } s->refcount_table[[[blackmailed]]] = new_block; return -EAGAIN; } ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block); if (ret < 0) { goto fail_block; } BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW); uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size); if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) { return -EFBIG; } uint64_t table_size = next_refcount_table_size(s, blocks_used + 1); uint64_t last_table_size; uint64_t blocks_clusters; do { uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t)); blocks_clusters = 1 + ((table_clusters + s->refcount_block_size - 1) / s->refcount_block_size); uint64_t meta_clusters = table_clusters + blocks_clusters; last_table_size = table_size; table_size = next_refcount_table_size(s, blocks_used + ((meta_clusters + s->refcount_block_size - 1) / s->refcount_block_size)); } while (last_table_size != table_size); #ifdef DEBUG_ALLOC2 fprintf(stderr, "qcow2: Grow refcount table %" PRId32 " => %" PRId64 "\n", s->refcount_table_size, table_size); #endif uint64_t meta_offset = (blocks_used * s->refcount_block_size) * s->cluster_size; uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size; uint64_t *new_table = g_try_new0(uint64_t, table_size); uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size); assert(table_size > 0 && blocks_clusters > 0); if (new_table == NULL || new_blocks == NULL) { ret = -ENOMEM; goto fail_table; } memcpy(new_table, s->refcount_table, s->refcount_table_size * sizeof(uint64_t)); new_table[[[blackmailed]]] = new_block; int i; for (i = 0; i < blocks_clusters; i++) { new_table[blocks_used + i] = meta_offset + (i * s->cluster_size); } uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t)); int block = 0; for (i = 0; i < table_clusters + blocks_clusters; i++) { new_blocks[block++] = cpu_to_be16(1); } BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS); ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks, blocks_clusters * s->cluster_size); g_free(new_blocks); new_blocks = NULL; if (ret < 0) { goto fail_table; } for(i = 0; i < table_size; i++) { cpu_to_be64s(&new_table[i]); } BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE); ret = bdrv_pwrite_sync(bs->file, table_offset, new_table, table_size * sizeof(uint64_t)); if (ret < 0) { goto fail_table; } for(i = 0; i < table_size; i++) { be64_to_cpus(&new_table[i]); } uint8_t data[12]; cpu_to_be64w((uint64_t*)data, table_offset); cpu_to_be32w((uint32_t*)(data + 8), table_clusters); BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE); ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset), data, sizeof(data)); if (ret < 0) { goto fail_table; } uint64_t old_table_offset = s->refcount_table_offset; uint64_t old_table_size = s->refcount_table_size; g_free(s->refcount_table); s->refcount_table = new_table; s->refcount_table_size = table_size; s->refcount_table_offset = table_offset; qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t), QCOW2_DISCARD_OTHER); ret = load_refcount_block(bs, new_block, (void**) refcount_block); if (ret < 0) { return ret; } return -EAGAIN; fail_table: g_free(new_blocks); g_free(new_table); fail_block: if (*refcount_block != NULL) { qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block); } return ret; }[Succeeded / Failed / Skipped / Total] 77 / 5 / 53 / 135:   5%|         | 135/2690 [22:21<7:03:04,  9.94s/it][Succeeded / Failed / Skipped / Total] 77 / 5 / 53 / 135:   5%|         | 136/2690 [22:21<6:59:57,  9.87s/it][Succeeded / Failed / Skipped / Total] 77 / 5 / 54 / 136:   5%|         | 136/2690 [22:21<6:59:57,  9.87s/it][Succeeded / Failed / Skipped / Total] 77 / 5 / 54 / 136:   5%|         | 137/2690 [22:29<6:59:07,  9.85s/it][Succeeded / Failed / Skipped / Total] 78 / 5 / 54 / 137:   5%|         | 137/2690 [22:29<6:59:07,  9.85s/it][Succeeded / Failed / Skipped / Total] 78 / 5 / 54 / 137:   5%|         | 138/2690 [22:31<6:56:41,  9.80s/it][Succeeded / Failed / Skipped / Total] 79 / 5 / 54 / 138:   5%|         | 138/2690 [22:31<6:56:41,  9.80s/it][Succeeded / Failed / Skipped / Total] 79 / 5 / 54 / 138:   5%|         | 139/2690 [22:34<6:54:20,  9.75s/it][Succeeded / Failed / Skipped / Total] 80 / 5 / 54 / 139:   5%|         | 139/2690 [22:34<6:54:20,  9.75s/it][Succeeded / Failed / Skipped / Total] 80 / 5 / 54 / 139:   5%|         | 140/2690 [22:39<6:52:43,  9.71s/it]
--------------------------------------------- Result 136 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_h264_decode_ref_pic_marking(const H264Context *h, H264SliceContext *sl, GetBitContext *gb) { int i; MMCO *mmco = sl->mmco; int nb_mmco = 0; if (h->nal_unit_type == NAL_IDR_SLICE) { skip_bits1(gb); if (get_bits1(gb)) { mmco[0].opcode = MMCO_LONG; mmco[0].long_arg = 0; nb_mmco = 1; } sl->explicit_ref_marking = 1; } else { sl->explicit_ref_marking = get_bits1(gb); if (sl->explicit_ref_marking) { for (i = 0; i < MAX_MMCO_COUNT; i++) { MMCOOpcode opcode = get_ue_golomb_31(gb); mmco[i].opcode = opcode; if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) { mmco[i].short_pic_num = (sl->curr_pic_num - get_ue_golomb(gb) - 1) & (sl->max_pic_num - 1); #if 0 if (mmco[i].short_pic_num >= h->short_ref_count || !h->short_ref[mmco[i].short_pic_num]) { av_log(s->avctx, AV_LOG_ERROR, "illegal short ref in memory management control " "operation %d\n", mmco); return -1; } #endif } if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED || opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) { unsigned int long_arg = get_ue_golomb_31(gb); if (long_arg >= 32 || (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG && long_arg == 16) && !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) { av_log(h->avctx, AV_LOG_ERROR, "illegal long ref in memory management control " "operation %d\n", opcode); return -1; } mmco[i].long_arg = long_arg; } if (opcode > (unsigned) MMCO_LONG) { av_log(h->avctx, AV_LOG_ERROR, "illegal memory management control operation %d\n", opcode); return -1; } if (opcode == MMCO_END) break; } nb_mmco = i; } } sl->nb_mmco = nb_mmco; return 0; }
--------------------------------------------- Result 137 ---------------------------------------------
[[0 (9%)]] --> [[0 (67%)]] --> Socre: 0.6718876957893372

[[[[Adv]]]]: void cpu_sh4_invalidate_tlb(CPUSH4State *s) { int i; for (i = 0; i < UTLB_SIZE; i++) { tlb_t * [[entry]] = &s->utlb[i]; [[entry]]->v = 0; } for (i = 0; i < UTLB_SIZE; i++) { tlb_t * [[entry]] = &s->utlb[i]; [[entry]]->v = 0; } tlb_flush(s, 1); }

[[[[Adv]]]]: void cpu_sh4_invalidate_tlb(CPUSH4State *s) { int i; for (i = 0; i < UTLB_SIZE; i++) { tlb_t * [[introducing]] = &s->utlb[i]; [[introducing]]->v = 0; } for (i = 0; i < UTLB_SIZE; i++) { tlb_t * [[introducing]] = &s->utlb[i]; [[introducing]]->v = 0; } tlb_flush(s, 1); }
--------------------------------------------- Result 138 ---------------------------------------------
[[0 (8%)]] --> [[0 (66%)]] --> Socre: 0.6564316153526306

[[[[Adv]]]]: uint16_t net_checksum_finish(uint32_t [[sum]]) { while ([[sum]]>>16) [[sum]] = ([[sum]] & 0xFFFF)+([[sum]] >> 16); return ~[[sum]]; }

[[[[Adv]]]]: uint16_t net_checksum_finish(uint32_t [[amounts]]) { while ([[amounts]]>>16) [[amounts]] = ([[amounts]] & 0xFFFF)+([[amounts]] >> 16); return ~[[amounts]]; }
--------------------------------------------- Result 139 ---------------------------------------------
[[0 (58%)]] --> [[0 (50%)]] --> Socre: 0.5001600384712219

[[[[Adv]]]]: static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64) { TCGReg datalo, datahi, addrlo, rbase; TCGReg addrhi __attribute__((unused)); TCGMemOpIdx oi; TCGMemOp opc, s_bits; #ifdef CONFIG_SOFTMMU int [[mem_index]]; tcg_insn_unit *label_ptr; #endif datalo = *args++; datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0); addrlo = *args++; addrhi = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *args++ : 0); oi = *args++; opc = get_memop(oi); s_bits = opc & MO_SIZE; #ifdef CONFIG_SOFTMMU [[mem_index]] = get_mmuidx(oi); addrlo = tcg_out_tlb_read(s, s_bits, addrlo, addrhi, [[mem_index]], "[[True]]" == "[[True]]"); label_ptr = s->code_ptr; tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK); rbase = TCG_REG_R3; #else rbase = GUEST_BASE ? TCG_GUEST_BASE_REG : 0; if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) { tcg_out_ext32u(s, TCG_REG_TMP1, addrlo); addrlo = TCG_REG_TMP1; } #endif if (TCG_TARGET_REG_BITS == 32 && s_bits == MO_64) { if (opc & MO_BSWAP) { tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo)); tcg_out32(s, LWBRX | TAB(datahi, rbase, TCG_REG_R0)); } else if (rbase != 0) { tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWZX | TAB(datahi, rbase, addrlo)); tcg_out32(s, LWZX | TAB(datalo, rbase, TCG_REG_R0)); } else if (addrlo == datahi) { tcg_out32(s, LWZ | TAI(datalo, addrlo, 4)); tcg_out32(s, LWZ | TAI(datahi, addrlo, 0)); } else { tcg_out32(s, LWZ | TAI(datahi, addrlo, 0)); tcg_out32(s, LWZ | TAI(datalo, addrlo, 4)); } } else { uint32_t insn = qemu_ldx_opc[opc & (MO_BSWAP | MO_SSIZE)]; if (!HAVE_ISA_2_06 && insn == LDBRX) { tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo)); tcg_out32(s, LWBRX | TAB(TCG_REG_R0, rbase, TCG_REG_R0)); tcg_out_rld(s, RLDIMI, datalo, TCG_REG_R0, 32, 0); } else if (insn) { tcg_out32(s, insn | TAB(datalo, rbase, addrlo)); } else { insn = qemu_ldx_opc[opc & (MO_SIZE | MO_BSWAP)]; tcg_out32(s, insn | TAB(datalo, rbase, addrlo)); insn = qemu_exts_opc[s_bits]; tcg_out32(s, insn | RA(datalo) | RS(datalo)); } } #ifdef CONFIG_SOFTMMU add_qemu_ldst_label(s, "[[True]]" == "[[True]]", oi, datalo, datahi, addrlo, addrhi, s->code_ptr, label_ptr); #endif }

[[[[Adv]]]]: static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64) { TCGReg datalo, datahi, addrlo, rbase; TCGReg addrhi __attribute__((unused)); TCGMemOpIdx oi; TCGMemOp opc, s_bits; #ifdef CONFIG_SOFTMMU int [[lorne]]; tcg_insn_unit *label_ptr; #endif datalo = *args++; datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0); addrlo = *args++; addrhi = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *args++ : 0); oi = *args++; opc = get_memop(oi); s_bits = opc & MO_SIZE; #ifdef CONFIG_SOFTMMU [[lorne]] = get_mmuidx(oi); addrlo = tcg_out_tlb_read(s, s_bits, addrlo, addrhi, [[lorne]], "[[Actually]]" == "[[Actually]]"); label_ptr = s->code_ptr; tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK); rbase = TCG_REG_R3; #else rbase = GUEST_BASE ? TCG_GUEST_BASE_REG : 0; if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) { tcg_out_ext32u(s, TCG_REG_TMP1, addrlo); addrlo = TCG_REG_TMP1; } #endif if (TCG_TARGET_REG_BITS == 32 && s_bits == MO_64) { if (opc & MO_BSWAP) { tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo)); tcg_out32(s, LWBRX | TAB(datahi, rbase, TCG_REG_R0)); } else if (rbase != 0) { tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWZX | TAB(datahi, rbase, addrlo)); tcg_out32(s, LWZX | TAB(datalo, rbase, TCG_REG_R0)); } else if (addrlo == datahi) { tcg_out32(s, LWZ | TAI(datalo, addrlo, 4)); tcg_out32(s, LWZ | TAI(datahi, addrlo, 0)); } else { tcg_out32(s, LWZ | TAI(datahi, addrlo, 0)); tcg_out32(s, LWZ | TAI(datalo, addrlo, 4)); } } else { uint32_t insn = qemu_ldx_opc[opc & (MO_BSWAP | MO_SSIZE)]; if (!HAVE_ISA_2_06 && insn == LDBRX) { tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo)); tcg_out32(s, LWBRX | TAB(TCG_REG_R0, rbase, TCG_REG_R0)); tcg_out_rld(s, RLDIMI, datalo, TCG_REG_R0, 32, 0); } else if (insn) { tcg_out32(s, insn | TAB(datalo, rbase, addrlo)); } else { insn = qemu_ldx_opc[opc & (MO_SIZE | MO_BSWAP)]; tcg_out32(s, insn | TAB(datalo, rbase, addrlo)); insn = qemu_exts_opc[s_bits]; tcg_out32(s, insn | RA(datalo) | RS(datalo)); } } #ifdef CONFIG_SOFTMMU add_qemu_ldst_label(s, "[[Actually]]" == "[[Actually]]", oi, datalo, datahi, addrlo, addrhi, s->code_ptr, label_ptr); #endif }
--------------------------------------------- Result 140 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 81 / 5 / 54 / 140:   5%|         | 140/2690 [22:39<6:52:43,  9.71s/it][Succeeded / Failed / Skipped / Total] 81 / 5 / 54 / 140:   5%|         | 141/2690 [23:05<6:57:22,  9.82s/it][Succeeded / Failed / Skipped / Total] 81 / 6 / 54 / 141:   5%|         | 141/2690 [23:05<6:57:22,  9.82s/it][Succeeded / Failed / Skipped / Total] 81 / 6 / 54 / 141:   5%|         | 142/2690 [23:05<6:54:25,  9.76s/it][[0 (43%)]] --> [[0 (69%)]] --> Socre: 0.6900216937065125

[[[[Adv]]]]: static TranslationBlock *tb_alloc(target_ulong [[pc]]) { TranslationBlock *tb; TBContext *ctx; assert_tb_locked(); tb = tcg_tb_alloc(&tcg_ctx); if (unlikely(tb == NULL)) { return NULL; } ctx = &tcg_ctx.tb_ctx; if (unlikely(ctx->nb_tbs == ctx->tbs_size)) { ctx->tbs_size *= 2; ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size); } ctx->tbs[ctx->nb_tbs++] = tb; tb->pc = [[pc]]; tb->cflags = 0; tb->invalid = "False" != "False"; return tb; }

[[[[Adv]]]]: static TranslationBlock *tb_alloc(target_ulong [[apparatus]]) { TranslationBlock *tb; TBContext *ctx; assert_tb_locked(); tb = tcg_tb_alloc(&tcg_ctx); if (unlikely(tb == NULL)) { return NULL; } ctx = &tcg_ctx.tb_ctx; if (unlikely(ctx->nb_tbs == ctx->tbs_size)) { ctx->tbs_size *= 2; ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size); } ctx->tbs[ctx->nb_tbs++] = tb; tb->pc = [[apparatus]]; tb->cflags = 0; tb->invalid = "False" != "False"; return tb; }
--------------------------------------------- Result 141 ---------------------------------------------
[[0 (10%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void pci_init_mask_bridge(PCIDevice *d) { memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4); d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff; d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff; pci_set_word(d->wmask + PCI_MEMORY_BASE, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word(d->wmask + PCI_MEMORY_LIMIT, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_MASK & 0xffff); pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_MASK & 0xffff); memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8); d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16; d->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16; pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_64); pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_64); #define PCI_BRIDGE_CTL_VGA_16BIT 0x10 #define PCI_BRIDGE_CTL_DISCARD 0x100 #define PCI_BRIDGE_CTL_SEC_DISCARD 0x200 #define PCI_BRIDGE_CTL_DISCARD_STATUS 0x400 #define PCI_BRIDGE_CTL_DISCARD_SERR 0x800 pci_set_word(d->wmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_PARITY | PCI_BRIDGE_CTL_SERR | PCI_BRIDGE_CTL_ISA | PCI_BRIDGE_CTL_VGA | PCI_BRIDGE_CTL_VGA_16BIT | PCI_BRIDGE_CTL_MASTER_ABORT | PCI_BRIDGE_CTL_BUS_RESET | PCI_BRIDGE_CTL_FAST_BACK | PCI_BRIDGE_CTL_DISCARD | PCI_BRIDGE_CTL_SEC_DISCARD | PCI_BRIDGE_CTL_DISCARD_SERR); pci_set_word(d->w1cmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_DISCARD_STATUS); d->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK; d->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK; pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_MASK); pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_MASK); }

[[[[Adv]]]]: static void pci_init_mask_bridge(PCIDevice *d) { memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4); d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff; d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff; pci_set_word(d->wmask + PCI_MEMORY_BASE, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word(d->wmask + PCI_MEMORY_LIMIT, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_MASK & 0xffff); pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_MASK & 0xffff); memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8); d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16; d->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16; pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_64); pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_64); #define PCI_BRIDGE_CTL_VGA_16BIT 0x10 #define PCI_BRIDGE_CTL_DISCARD 0x100 #define PCI_BRIDGE_CTL_SEC_DISCARD 0x200 #define PCI_BRIDGE_CTL_DISCARD_STATUS 0x400 #define PCI_BRIDGE_CTL_DISCARD_SERR 0x800 pci_set_word(d->wmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_PARITY | PCI_BRIDGE_CTL_SERR | PCI_BRIDGE_CTL_ISA | PCI_BRIDGE_CTL_VGA | PCI_BRIDGE_CTL_VGA_16BIT | PCI_BRIDGE_CTL_MASTER_ABORT | PCI_BRIDGE_CTL_BUS_RESET | PCI_BRIDGE_CTL_FAST_BACK | PCI_BRIDGE_CTL_DISCARD | PCI_BRIDGE_CTL_SEC_DISCARD | PCI_BRIDGE_CTL_DISCARD_SERR); pci_set_word(d->w1cmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_DISCARD_STATUS); d->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK; d->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK; pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_MASK); pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_MASK); }
--------------------------------------------- Result 142 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 81 / 6 / 55 / 142:   5%|         | 142/2690 [23:05<6:54:25,  9.76s/it][Succeeded / Failed / Skipped / Total] 81 / 6 / 55 / 142:   5%|         | 143/2690 [23:06<6:51:30,  9.69s/it][Succeeded / Failed / Skipped / Total] 81 / 6 / 56 / 143:   5%|         | 143/2690 [23:06<6:51:30,  9.69s/it][Succeeded / Failed / Skipped / Total] 81 / 6 / 56 / 143:   5%|         | 144/2690 [23:06<6:48:38,  9.63s/it][[0 (56%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { TiffContext *const s = avctx->priv_data; AVFrame *const p = data; ThreadFrame frame = { .f = data }; unsigned off; int le, ret, plane, planes; int i, j, entries, stride; unsigned soff, ssize; uint8_t *dst; GetByteContext stripsizes; GetByteContext stripdata; bytestream2_init(&s->gb, avpkt->data, avpkt->size); if ((ret = ff_tdecode_header(&s->gb, &le, &off))) { av_log(avctx, AV_LOG_ERROR, "Invalid TIFF header\n"); return ret; } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) { av_log(avctx, AV_LOG_ERROR, "IFD offset is greater than image size\n"); return AVERROR_INVALIDDATA; } s->le = le; s->bppcount = s->bpp = 1; s->photometric = TIFF_PHOTOMETRIC_NONE; s->compr = TIFF_RAW; s->fill_order = 0; free_geotags(s); s->stripsizesoff = s->strippos = 0; bytestream2_seek(&s->gb, off, SEEK_SET); entries = ff_tget_short(&s->gb, le); if (bytestream2_get_bytes_left(&s->gb) < entries * 12) return AVERROR_INVALIDDATA; for (i = 0; i < entries; i++) { if ((ret = tiff_decode_tag(s, p)) < 0) return ret; } for (i = 0; i<s->geotag_count; i++) { const char *keyname = get_geokey_name(s->geotags[i].key); if (!keyname) { av_log(avctx, AV_LOG_WARNING, "Unknown or unsupported GeoTIFF key %d\n", s->geotags[i].key); continue; } if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) { av_log(avctx, AV_LOG_WARNING, "Type of GeoTIFF key %d is wrong\n", s->geotags[i].key); continue; } ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s->geotags[i].val, 0); if (ret<0) { av_log(avctx, AV_LOG_ERROR, "Writing metadata with key '%s' failed\n", keyname); return ret; } } if (!s->strippos && !s->stripoff) { av_log(avctx, AV_LOG_ERROR, "Image data is missing\n"); return AVERROR_INVALIDDATA; } if ((ret = init_image(s, &frame)) < 0) return ret; if (s->strips == 1 && !s->stripsize) { av_log(avctx, AV_LOG_WARNING, "Image data size missing\n"); s->stripsize = avpkt->size - s->stripoff; } if (s->stripsizesoff) { if (s->stripsizesoff >= (unsigned)avpkt->size) return AVERROR_INVALIDDATA; bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff, avpkt->size - s->stripsizesoff); } if (s->strippos) { if (s->strippos >= (unsigned)avpkt->size) return AVERROR_INVALIDDATA; bytestream2_init(&stripdata, avpkt->data + s->strippos, avpkt->size - s->strippos); } if (s->rps <= 0) { av_log(avctx, AV_LOG_ERROR, "rps %d invalid\n", s->rps); return AVERROR_INVALIDDATA; } planes = s->planar ? s->bppcount : 1; for (plane = 0; plane < planes; plane++) { stride = p->linesize[plane]; dst = p->data[plane]; for (i = 0; i < s->height; i += s->rps) { if (s->stripsizesoff) ssize = ff_tget(&stripsizes, s->sstype, le); else ssize = s->stripsize; if (s->strippos) soff = ff_tget(&stripdata, s->sot, le); else soff = s->stripoff; if (soff > avpkt->size || ssize > avpkt->size - soff) { av_log(avctx, AV_LOG_ERROR, "Invalid strip size/offset\n"); return AVERROR_INVALIDDATA; } if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i, FFMIN(s->rps, s->height - i))) < 0) { if (avctx->err_recognition & AV_EF_EXPLODE) return ret; break; } dst += s->rps * stride; } if (s->predictor == 2) { if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) { av_log(s->avctx, AV_LOG_ERROR, "predictor == 2 with YUV is unsupported"); return AVERROR_PATCHWELCOME; } dst = p->data[plane]; soff = s->bpp >> 3; if (s->planar) soff = FFMAX(soff / s->bppcount, 1); ssize = s->width * soff; if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE || s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE || s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE || s->avctx->pix_fmt == AV_PIX_FMT_YA16LE || s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE || s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) { for (i = 0; i < s->height; i++) { for (j = soff; j < ssize; j += 2) AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff)); dst += stride; } } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE || s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE || s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE || s->avctx->pix_fmt == AV_PIX_FMT_YA16BE || s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE || s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) { for (i = 0; i < s->height; i++) { for (j = soff; j < ssize; j += 2) AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff)); dst += stride; } } else { for (i = 0; i < s->height; i++) { for (j = soff; j < ssize; j++) dst[j] += dst[j - soff]; dst += stride; } } } if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) { dst = p->data[plane]; for (i = 0; i < s->height; i++) { for (j = 0; j < stride; j++) dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j]; dst += stride; } } } if (s->planar && s->bppcount > 2) { FFSWAP(uint8_t*, p->data[0], p->data[2]); FFSWAP(int, p->linesize[0], p->linesize[2]); FFSWAP(uint8_t*, p->data[0], p->data[1]); FFSWAP(int, p->linesize[0], p->linesize[1]); } *got_frame = 1; return avpkt->size; }
--------------------------------------------- Result 143 ---------------------------------------------
[[0 (59%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr, AVPacket *avpkt) { int ret; *got_picture_ptr = 0; if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx)) return -1; avctx->pkt = avpkt; apply_param_change(avctx, avpkt); avcodec_get_frame_defaults(picture); if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) { if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME) ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr, avpkt); else { ret = avctx->codec->decode(avctx, picture, got_picture_ptr, avpkt); picture->pkt_dts = avpkt->dts; picture->sample_aspect_ratio = avctx->sample_aspect_ratio; picture->width = avctx->width; picture->height = avctx->height; picture->format = avctx->pix_fmt; } emms_c(); if (*got_picture_ptr) avctx->frame_number++; } else ret = 0; picture->extended_data = picture->data; return ret; }
--------------------------------------------- Result 144 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 81 / 6 / 57 / 144:   5%|         | 144/2690 [23:06<6:48:38,  9.63s/it][Succeeded / Failed / Skipped / Total] 81 / 6 / 57 / 144:   5%|         | 145/2690 [23:32<6:53:14,  9.74s/it][Succeeded / Failed / Skipped / Total] 82 / 6 / 57 / 145:   5%|         | 145/2690 [23:32<6:53:14,  9.74s/it][Succeeded / Failed / Skipped / Total] 82 / 6 / 57 / 145:   5%|         | 146/2690 [23:33<6:50:23,  9.68s/it][Succeeded / Failed / Skipped / Total] 82 / 6 / 58 / 146:   5%|         | 146/2690 [23:33<6:50:23,  9.68s/it][Succeeded / Failed / Skipped / Total] 82 / 6 / 58 / 146:   5%|         | 147/2690 [23:35<6:48:01,  9.63s/it][Succeeded / Failed / Skipped / Total] 83 / 6 / 58 / 147:   5%|         | 147/2690 [23:35<6:48:01,  9.63s/it][Succeeded / Failed / Skipped / Total] 83 / 6 / 58 / 147:   6%|         | 148/2690 [23:35<6:45:14,  9.57s/it][Succeeded / Failed / Skipped / Total] 83 / 6 / 59 / 148:   6%|         | 148/2690 [23:35<6:45:14,  9.57s/it][Succeeded / Failed / Skipped / Total] 83 / 6 / 59 / 148:   6%|         | 149/2690 [23:36<6:42:29,  9.50s/it][Succeeded / Failed / Skipped / Total] 83 / 6 / 60 / 149:   6%|         | 149/2690 [23:36<6:42:29,  9.50s/it][Succeeded / Failed / Skipped / Total] 83 / 6 / 60 / 149:   6%|         | 150/2690 [23:44<6:42:07,  9.50s/it][[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun, MegasasCmd *cmd) { struct mfi_pd_info *info = cmd->iov_buf; size_t dcmd_size = sizeof(struct mfi_pd_info); uint64_t pd_size; uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (lun & 0xFF); uint8_t cmdbuf[6]; SCSIRequest *req; size_t len, resid; if (!cmd->iov_buf) { cmd->iov_buf = g_malloc0(dcmd_size); info = cmd->iov_buf; info->inquiry_data[0] = 0x7f; info->vpd_page83[0] = 0x7f; megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data)); req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd); if (!req) { trace_megasas_dcmd_req_alloc_failed(cmd->index, "PD get info std inquiry"); g_free(cmd->iov_buf); cmd->iov_buf = NULL; return MFI_STAT_FLASH_ALLOC_FAIL; } trace_megasas_dcmd_internal_submit(cmd->index, "PD get info std inquiry", lun); len = scsi_req_enqueue(req); if (len > 0) { cmd->iov_size = len; scsi_req_continue(req); } return MFI_STAT_INVALID_STATUS; } else if (info->inquiry_data[0] != 0x7f && info->vpd_page83[0] == 0x7f) { megasas_setup_inquiry(cmdbuf, 0x83, sizeof(info->vpd_page83)); req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd); if (!req) { trace_megasas_dcmd_req_alloc_failed(cmd->index, "PD get info vpd inquiry"); return MFI_STAT_FLASH_ALLOC_FAIL; } trace_megasas_dcmd_internal_submit(cmd->index, "PD get info vpd inquiry", lun); len = scsi_req_enqueue(req); if (len > 0) { cmd->iov_size = len; scsi_req_continue(req); } return MFI_STAT_INVALID_STATUS; } if ((info->inquiry_data[0] >> 5) == 0) { if (megasas_is_jbod(cmd->state)) { info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM); } else { info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE); } } else { info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE); } info->ref.v.device_id = cpu_to_le16(pd_id); info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD| MFI_PD_DDF_TYPE_INTF_SAS); blk_get_geometry(sdev->conf.blk, &pd_size); info->raw_size = cpu_to_le64(pd_size); info->non_coerced_size = cpu_to_le64(pd_size); info->coerced_size = cpu_to_le64(pd_size); info->encl_device_id = 0xFFFF; info->slot_number = (sdev->id & 0xFF); info->path_info.count = 1; info->path_info.sas_addr[0] = cpu_to_le64(megasas_get_sata_addr(pd_id)); info->connected_port_bitmap = 0x1; info->device_speed = 1; info->link_speed = 1; resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg); g_free(cmd->iov_buf); cmd->iov_size = dcmd_size - resid; cmd->iov_buf = NULL; return MFI_STAT_OK; }
--------------------------------------------- Result 145 ---------------------------------------------
[[0 (7%)]] --> [[0 (98%)]] --> Socre: 0.9843272566795349

[[[[Adv]]]]: static void gpollfds_from_select(void) { int fd; for (fd = 0; fd <= nfds; fd++) { int events = 0; if (FD_ISSET(fd, &rfds)) { events |= G_IO_IN | G_IO_HUP | G_IO_ERR; } if (FD_ISSET(fd, &wfds)) { events |= G_IO_OUT | G_IO_ERR; } if (FD_ISSET(fd, &xfds)) { events |= G_IO_PRI; } if (events) { GPollFD [[pfd]] = { .fd = fd, .events = events, }; g_array_append_val(gpollfds, [[pfd]]); } } }

[[[[Adv]]]]: static void gpollfds_from_select(void) { int fd; for (fd = 0; fd <= nfds; fd++) { int events = 0; if (FD_ISSET(fd, &rfds)) { events |= G_IO_IN | G_IO_HUP | G_IO_ERR; } if (FD_ISSET(fd, &wfds)) { events |= G_IO_OUT | G_IO_ERR; } if (FD_ISSET(fd, &xfds)) { events |= G_IO_PRI; } if (events) { GPollFD [[jalapeo]] = { .fd = fd, .events = events, }; g_array_append_val(gpollfds, [[jalapeo]]); } } }
--------------------------------------------- Result 146 ---------------------------------------------
[[0 (88%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void stream_process_mem2s(struct Stream *s, StreamSlave *tx_dev) { uint32_t prev_d; unsigned char txbuf[16 * 1024]; unsigned int txlen; uint32_t app[6]; if (!stream_running(s) || stream_idle(s)) { return; } while (1) { stream_desc_load(s, s->regs[R_CURDESC]); if (s->desc.status & SDESC_STATUS_COMPLETE) { s->regs[R_DMASR] |= DMASR_HALTED; break; } if (stream_desc_sof(&s->desc)) { s->pos = 0; memcpy(app, s->desc.app, sizeof app); } txlen = s->desc.control & SDESC_CTRL_LEN_MASK; if ((txlen + s->pos) > sizeof txbuf) { hw_error("%s: too small internal txbuf! %d\n", __func__, txlen + s->pos); } cpu_physical_memory_read(s->desc.buffer_address, txbuf + s->pos, txlen); s->pos += txlen; if (stream_desc_eof(&s->desc)) { stream_push(tx_dev, txbuf, s->pos, app); s->pos = 0; stream_complete(s); } s->desc.status = txlen | SDESC_STATUS_COMPLETE; stream_desc_store(s, s->regs[R_CURDESC]); prev_d = s->regs[R_CURDESC]; s->regs[R_CURDESC] = s->desc.nxtdesc; if (prev_d == s->regs[R_TAILDESC]) { s->regs[R_DMASR] |= DMASR_IDLE; break; } } }
--------------------------------------------- Result 147 ---------------------------------------------
[[0 (42%)]] --> [[0 (55%)]] --> Socre: 0.5499234795570374

[[[[Adv]]]]: static int adpcm_decode_init(AVCodecContext * [[avctx]]) { ADPCMContext *c = [[avctx]]->priv_data; if([[avctx]]->channels > 2U){ return -1; } c->channel = 0; c->status[0].predictor = c->status[1].predictor = 0; c->status[0].step_index = c->status[1].step_index = 0; c->status[0].step = c->status[1].step = 0; switch([[avctx]]->codec->id) { case CODEC_ID_ADPCM_CT: c->status[0].step = c->status[1].step = 511; break; case CODEC_ID_ADPCM_IMA_WS: if ([[avctx]]->extradata && [[avctx]]->extradata_size == 2 * 4) { c->status[0].predictor = AV_RL32([[avctx]]->extradata); c->status[1].predictor = AV_RL32([[avctx]]->extradata + 4); } break; default: break; } return 0; }

[[[[Adv]]]]: static int adpcm_decode_init(AVCodecContext * [[chucking]]) { ADPCMContext *c = [[chucking]]->priv_data; if([[chucking]]->channels > 2U){ return -1; } c->channel = 0; c->status[0].predictor = c->status[1].predictor = 0; c->status[0].step_index = c->status[1].step_index = 0; c->status[0].step = c->status[1].step = 0; switch([[chucking]]->codec->id) { case CODEC_ID_ADPCM_CT: c->status[0].step = c->status[1].step = 511; break; case CODEC_ID_ADPCM_IMA_WS: if ([[chucking]]->extradata && [[chucking]]->extradata_size == 2 * 4) { c->status[0].predictor = AV_RL32([[chucking]]->extradata); c->status[1].predictor = AV_RL32([[chucking]]->extradata + 4); } break; default: break; } return 0; }
--------------------------------------------- Result 148 ---------------------------------------------
[[0 (23%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci) { read_local_name_rp params; params.status = HCI_SUCCESS; memset(params.name, 0, sizeof(params.name)); if (hci->device.lmp_name) strncpy(params.name, hci->device.lmp_name, sizeof(params.name)); bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE); }
--------------------------------------------- Result 149 ---------------------------------------------
[[0 (9%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static bool vnc_should_update(VncState *vs) { switch (vs->update) { case VNC_STATE_UPDATE_NONE: break; case VNC_STATE_UPDATE_INCREMENTAL: if (!vs->output.offset || vs->audio_cap) { return "True" == "True"; } break; case VNC_STATE_UPDATE_FORCE: return "True" == "True"; } return "False" != "False"; }
--------------------------------------------- Result 150 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 84 / 6 / 60 / 150:   6%|         | 150/2690 [23:44<6:42:07,  9.50s/it][Succeeded / Failed / Skipped / Total] 84 / 6 / 60 / 150:   6%|         | 151/2690 [23:45<6:39:27,  9.44s/it][[0 (82%)]] --> [[0 (49%)]] --> Socre: 0.5057351291179657

[[[[Adv]]]]: static void filter(USPPContext *p, uint8_t *[[dst]][3], uint8_t *src[3], int dst_stride[3], int src_stride[3], int width, int height, uint8_t *qp_store, int qp_stride) { int x, y, i, j; const int [[count]] = 1<<p->log2_count; for (i = 0; i < 3; i++) { int is_chroma = !!i; int w = width >> (is_chroma ? p->hsub : 0); int h = height >> (is_chroma ? p->vsub : 0); int [[stride]] = p->temp_stride[i]; int block = BLOCK >> (is_chroma ? p->hsub : 0); if (!src[i] || ![[dst]][i]) continue; for (y = 0; y < h; y++) { int index = block + block * [[stride]] + y * [[stride]]; memcpy(p->src[i] + index, src[i] + y * src_stride[i], w ); for (x = 0; x < block; x++) { p->src[i][index - x - 1] = p->src[i][index + x ]; p->src[i][index + w + x ] = p->src[i][index + w - x - 1]; } } for (y = 0; y < block; y++) { memcpy(p->src[i] + ( block-1-y) * [[stride]], p->src[i] + ( y+block ) * [[stride]], [[stride]]); memcpy(p->src[i] + (h+block +y) * [[stride]], p->src[i] + (h-y+block-1) * [[stride]], [[stride]]); } p->frame->linesize[i] = [[stride]]; memset(p->temp[i], 0, (h + 2 * block) * [[stride]] * sizeof(int16_t)); } if (p->qp) p->frame->quality = p->qp * FF_QP2LAMBDA; else { int qpsum=0; int qpcount = (height>>4) * (height>>4); for (y = 0; y < (height>>4); y++) { for (x = 0; x < (width>>4); x++) qpsum += qp_store[x + y * qp_stride]; } p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA; } p->frame->height = height; p->frame->width = width; for (i = 0; i < [[count]]; i++) { const int x1 = offset[i+[[count]]-1][0]; const int y1 = offset[i+[[count]]-1][1]; const int x1c = x1 >> p->hsub; const int y1c = y1 >> p->vsub; const int BLOCKc = BLOCK >> p->hsub; int offset; AVPacket pkt; int got_pkt_ptr; av_init_packet(&pkt); pkt.data = p->outbuf; pkt.size = p->outbuf_size; p->frame->data[0] = p->src[0] + x1 + y1 * p->frame->linesize[0]; p->frame->data[1] = p->src[1] + x1c + y1c * p->frame->linesize[1]; p->frame->data[2] = p->src[2] + x1c + y1c * p->frame->linesize[2]; p->frame->format = p->avctx_enc[i]->pix_fmt; avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr); p->frame_dec = p->avctx_enc[i]->coded_frame; offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0]; for (y = 0; y < height; y++) for (x = 0; x < width; x++) p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset]; if (!src[2] || ![[dst]][2]) continue; offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1]; for (y = 0; y < height>>p->vsub; y++) { for (x = 0; x < width>>p->hsub; x++) { p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset]; p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset]; } } } for (j = 0; j < 3; j++) { int is_chroma = !!j; if (![[dst]][j]) continue; store_slice_c([[dst]][j], p->temp[j], dst_stride[j], p->temp_stride[j], width >> (is_chroma ? p->hsub : 0), height >> (is_chroma ? p->vsub : 0), 8-p->log2_count); } }

[[[[Adv]]]]: static void filter(USPPContext *p, uint8_t *[[sti]][3], uint8_t *src[3], int dst_stride[3], int src_stride[3], int width, int height, uint8_t *qp_store, int qp_stride) { int x, y, i, j; const int [[chiefs]] = 1<<p->log2_count; for (i = 0; i < 3; i++) { int is_chroma = !!i; int w = width >> (is_chroma ? p->hsub : 0); int h = height >> (is_chroma ? p->vsub : 0); int [[leap]] = p->temp_stride[i]; int block = BLOCK >> (is_chroma ? p->hsub : 0); if (!src[i] || ![[sti]][i]) continue; for (y = 0; y < h; y++) { int index = block + block * [[leap]] + y * [[leap]]; memcpy(p->src[i] + index, src[i] + y * src_stride[i], w ); for (x = 0; x < block; x++) { p->src[i][index - x - 1] = p->src[i][index + x ]; p->src[i][index + w + x ] = p->src[i][index + w - x - 1]; } } for (y = 0; y < block; y++) { memcpy(p->src[i] + ( block-1-y) * [[leap]], p->src[i] + ( y+block ) * [[leap]], [[leap]]); memcpy(p->src[i] + (h+block +y) * [[leap]], p->src[i] + (h-y+block-1) * [[leap]], [[leap]]); } p->frame->linesize[i] = [[leap]]; memset(p->temp[i], 0, (h + 2 * block) * [[leap]] * sizeof(int16_t)); } if (p->qp) p->frame->quality = p->qp * FF_QP2LAMBDA; else { int qpsum=0; int qpcount = (height>>4) * (height>>4); for (y = 0; y < (height>>4); y++) { for (x = 0; x < (width>>4); x++) qpsum += qp_store[x + y * qp_stride]; } p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA; } p->frame->height = height; p->frame->width = width; for (i = 0; i < [[chiefs]]; i++) { const int x1 = offset[i+[[chiefs]]-1][0]; const int y1 = offset[i+[[chiefs]]-1][1]; const int x1c = x1 >> p->hsub; const int y1c = y1 >> p->vsub; const int BLOCKc = BLOCK >> p->hsub; int offset; AVPacket pkt; int got_pkt_ptr; av_init_packet(&pkt); pkt.data = p->outbuf; pkt.size = p->outbuf_size; p->frame->data[0] = p->src[0] + x1 + y1 * p->frame->linesize[0]; p->frame->data[1] = p->src[1] + x1c + y1c * p->frame->linesize[1]; p->frame->data[2] = p->src[2] + x1c + y1c * p->frame->linesize[2]; p->frame->format = p->avctx_enc[i]->pix_fmt; avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr); p->frame_dec = p->avctx_enc[i]->coded_frame; offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0]; for (y = 0; y < height; y++) for (x = 0; x < width; x++) p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset]; if (!src[2] || ![[sti]][2]) continue; offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1]; for (y = 0; y < height>>p->vsub; y++) { for (x = 0; x < width>>p->hsub; x++) { p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset]; p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset]; } } } for (j = 0; j < 3; j++) { int is_chroma = !!j; if (![[sti]][j]) continue; store_slice_c([[sti]][j], p->temp[j], dst_stride[j], p->temp_stride[j], width >> (is_chroma ? p->hsub : 0), height >> (is_chroma ? p->vsub : 0), 8-p->log2_count); } }
--------------------------------------------- Result 151 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 84 / 6 / 61 / 151:   6%|         | 151/2690 [23:45<6:39:27,  9.44s/it][Succeeded / Failed / Skipped / Total] 84 / 6 / 61 / 151:   6%|         | 152/2690 [23:58<6:40:23,  9.47s/it][Succeeded / Failed / Skipped / Total] 85 / 6 / 61 / 152:   6%|         | 152/2690 [23:58<6:40:23,  9.47s/it][Succeeded / Failed / Skipped / Total] 85 / 6 / 61 / 152:   6%|         | 153/2690 [24:03<6:38:48,  9.43s/it][Succeeded / Failed / Skipped / Total] 86 / 6 / 61 / 153:   6%|         | 153/2690 [24:03<6:38:48,  9.43s/it][Succeeded / Failed / Skipped / Total] 86 / 6 / 61 / 153:   6%|         | 154/2690 [24:14<6:39:04,  9.44s/it][[0 (81%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void test_migrate(void) { char *uri = g_strdup_printf("unix:%s/migsocket", tmpfs); QTestState *global = global_qtest, *from, *to; unsigned char dest_byte_a, dest_byte_b, dest_byte_c, dest_byte_d; gchar *cmd; QDict *rsp; char *bootpath = g_strdup_printf("%s/bootsect", tmpfs); FILE *bootfile = fopen(bootpath, "wb"); got_stop = "False" != "False"; g_assert_cmpint(fwrite(bootsect, 512, 1, bootfile), ==, 1); fclose(bootfile); cmd = g_strdup_printf("-machine accel=kvm:tcg -m 150M" " -name pcsource,debug-threads=on" " -serial file:%s/src_serial" " -drive file=%s,format=raw", tmpfs, bootpath); from = qtest_start(cmd); g_free(cmd); cmd = g_strdup_printf("-machine accel=kvm:tcg -m 150M" " -name pcdest,debug-threads=on" " -serial file:%s/dest_serial" " -drive file=%s,format=raw" " -incoming %s", tmpfs, bootpath, uri); to = qtest_init(cmd); g_free(cmd); global_qtest = from; rsp = qmp("{ 'execute': 'migrate-set-capabilities'," "'arguments': { " "'capabilities': [ {" "'capability': 'postcopy-ram'," "'state': true } ] } }"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); global_qtest = to; rsp = qmp("{ 'execute': 'migrate-set-capabilities'," "'arguments': { " "'capabilities': [ {" "'capability': 'postcopy-ram'," "'state': true } ] } }"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); global_qtest = from; rsp = qmp("{ 'execute': 'migrate_set_speed'," "'arguments': { 'value': 100000000 } }"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); rsp = qmp("{ 'execute': 'migrate_set_downtime'," "'arguments': { 'value': 0.001 } }"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); wait_for_serial("src_serial"); cmd = g_strdup_printf("{ 'execute': 'migrate'," "'arguments': { 'uri': '%s' } }", uri); rsp = qmp(cmd); g_free(cmd); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); wait_for_migration_pass(); rsp = return_or_event(qmp("{ 'execute': 'migrate-start-postcopy' }")); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); if (!got_stop) { qmp_eventwait("STOP"); } global_qtest = to; qmp_eventwait("RESUME"); wait_for_serial("dest_serial"); global_qtest = from; wait_for_migration_complete(); qtest_quit(from); global_qtest = to; qtest_memread(to, start_address, &dest_byte_a, 1); do { qtest_memread(to, start_address, &dest_byte_b, 1); usleep(10 * 1000); } while (dest_byte_a == dest_byte_b); qmp("{ 'execute' : 'stop'}"); qtest_memread(to, start_address, &dest_byte_c, 1); sleep(1); qtest_memread(to, start_address, &dest_byte_d, 1); g_assert_cmpint(dest_byte_c, ==, dest_byte_d); check_guests_ram(); qtest_quit(to); g_free(uri); global_qtest = global; cleanup("bootsect"); cleanup("migsocket"); cleanup("src_serial"); cleanup("dest_serial"); }
--------------------------------------------- Result 152 ---------------------------------------------
[[0 (3%)]] --> [[0 (95%)]] --> Socre: 0.9476400017738342

[[[[Adv]]]]: static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *[[pkt]], bool tso_enable) { uint8_t rc = VIRTIO_NET_HDR_GSO_NONE; uint16_t l3_proto; l3_proto = eth_get_l3_proto([[pkt]]->vec[NET_TX_PKT_L2HDR_FRAG].iov_base, [[pkt]]->vec[NET_TX_PKT_L2HDR_FRAG].iov_len); if (!tso_enable) { goto func_exit; } rc = eth_get_gso_type(l3_proto, [[pkt]]->vec[NET_TX_PKT_L3HDR_FRAG].iov_base, [[pkt]]->l4proto); func_exit: return rc; }

[[[[Adv]]]]: static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *[[mnage]], bool tso_enable) { uint8_t rc = VIRTIO_NET_HDR_GSO_NONE; uint16_t l3_proto; l3_proto = eth_get_l3_proto([[mnage]]->vec[NET_TX_PKT_L2HDR_FRAG].iov_base, [[mnage]]->vec[NET_TX_PKT_L2HDR_FRAG].iov_len); if (!tso_enable) { goto func_exit; } rc = eth_get_gso_type(l3_proto, [[mnage]]->vec[NET_TX_PKT_L3HDR_FRAG].iov_base, [[mnage]]->l4proto); func_exit: return rc; }
--------------------------------------------- Result 153 ---------------------------------------------
[[0 (61%)]] --> [[0 (40%)]] --> Socre: 0.5994935929775238

[[[[Adv]]]]: static int scsi_req_length(SCSIRequest *req, uint8_t *[[cmd]]) { switch ([[cmd]][0] >> 5) { case 0: req->cmd.xfer = [[cmd]][4]; req->cmd.len = 6; if (req->cmd.xfer == 0) req->cmd.xfer = 256; break; case 1: case 2: req->cmd.xfer = [[cmd]][8] | ([[cmd]][7] << 8); req->cmd.len = 10; break; case 4: req->cmd.xfer = [[cmd]][13] | ([[cmd]][12] << 8) | ([[cmd]][11] << 16) | ([[cmd]][10] << 24); req->cmd.len = 16; break; case 5: req->cmd.xfer = [[cmd]][9] | ([[cmd]][8] << 8) | ([[cmd]][7] << 16) | ([[cmd]][6] << 24); req->cmd.len = 12; break; default: trace_scsi_req_parse_bad(req->dev->id, req->lun, req->tag, [[cmd]][0]); return -1; } switch([[cmd]][0]) { case TEST_UNIT_READY: case START_STOP: case SEEK_6: case WRITE_FILEMARKS: case SPACE: case RESERVE: case RELEASE: case ERASE: case ALLOW_MEDIUM_REMOVAL: case VERIFY: case SEEK_10: case SYNCHRONIZE_CACHE: case LOCK_UNLOCK_CACHE: case LOAD_UNLOAD: case SET_CD_SPEED: case SET_LIMITS: case WRITE_LONG: case MOVE_MEDIUM: case UPDATE_BLOCK: req->cmd.xfer = 0; break; case MODE_SENSE: break; case WRITE_SAME: req->cmd.xfer = 1; break; case READ_CAPACITY: req->cmd.xfer = 8; break; case READ_BLOCK_LIMITS: req->cmd.xfer = 6; break; case READ_POSITION: req->cmd.xfer = 20; break; case SEND_VOLUME_TAG: req->cmd.xfer *= 40; break; case MEDIUM_SCAN: req->cmd.xfer *= 8; break; case WRITE_10: case WRITE_VERIFY: case WRITE_6: case WRITE_12: case WRITE_VERIFY_12: case WRITE_16: case WRITE_VERIFY_16: req->cmd.xfer *= req->dev->blocksize; break; case READ_10: case READ_6: case READ_REVERSE: case RECOVER_BUFFERED_DATA: case READ_12: case READ_16: req->cmd.xfer *= req->dev->blocksize; break; case INQUIRY: req->cmd.xfer = [[cmd]][4] | ([[cmd]][3] << 8); break; case MAINTENANCE_OUT: case MAINTENANCE_IN: if (req->dev->type == TYPE_ROM) { req->cmd.xfer = [[cmd]][9] | ([[cmd]][8] << 8); } break; } return 0; }

[[[[Adv]]]]: static int scsi_req_length(SCSIRequest *req, uint8_t *[[dlg]]) { switch ([[dlg]][0] >> 5) { case 0: req->cmd.xfer = [[dlg]][4]; req->cmd.len = 6; if (req->cmd.xfer == 0) req->cmd.xfer = 256; break; case 1: case 2: req->cmd.xfer = [[dlg]][8] | ([[dlg]][7] << 8); req->cmd.len = 10; break; case 4: req->cmd.xfer = [[dlg]][13] | ([[dlg]][12] << 8) | ([[dlg]][11] << 16) | ([[dlg]][10] << 24); req->cmd.len = 16; break; case 5: req->cmd.xfer = [[dlg]][9] | ([[dlg]][8] << 8) | ([[dlg]][7] << 16) | ([[dlg]][6] << 24); req->cmd.len = 12; break; default: trace_scsi_req_parse_bad(req->dev->id, req->lun, req->tag, [[dlg]][0]); return -1; } switch([[dlg]][0]) { case TEST_UNIT_READY: case START_STOP: case SEEK_6: case WRITE_FILEMARKS: case SPACE: case RESERVE: case RELEASE: case ERASE: case ALLOW_MEDIUM_REMOVAL: case VERIFY: case SEEK_10: case SYNCHRONIZE_CACHE: case LOCK_UNLOCK_CACHE: case LOAD_UNLOAD: case SET_CD_SPEED: case SET_LIMITS: case WRITE_LONG: case MOVE_MEDIUM: case UPDATE_BLOCK: req->cmd.xfer = 0; break; case MODE_SENSE: break; case WRITE_SAME: req->cmd.xfer = 1; break; case READ_CAPACITY: req->cmd.xfer = 8; break; case READ_BLOCK_LIMITS: req->cmd.xfer = 6; break; case READ_POSITION: req->cmd.xfer = 20; break; case SEND_VOLUME_TAG: req->cmd.xfer *= 40; break; case MEDIUM_SCAN: req->cmd.xfer *= 8; break; case WRITE_10: case WRITE_VERIFY: case WRITE_6: case WRITE_12: case WRITE_VERIFY_12: case WRITE_16: case WRITE_VERIFY_16: req->cmd.xfer *= req->dev->blocksize; break; case READ_10: case READ_6: case READ_REVERSE: case RECOVER_BUFFERED_DATA: case READ_12: case READ_16: req->cmd.xfer *= req->dev->blocksize; break; case INQUIRY: req->cmd.xfer = [[dlg]][4] | ([[dlg]][3] << 8); break; case MAINTENANCE_OUT: case MAINTENANCE_IN: if (req->dev->type == TYPE_ROM) { req->cmd.xfer = [[dlg]][9] | ([[dlg]][8] << 8); } break; } return 0; }
--------------------------------------------- Result 154 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 87 / 6 / 61 / 154:   6%|         | 154/2690 [24:14<6:39:04,  9.44s/it][Succeeded / Failed / Skipped / Total] 87 / 6 / 61 / 154:   6%|         | 155/2690 [24:14<6:36:28,  9.38s/it][Succeeded / Failed / Skipped / Total] 87 / 6 / 62 / 155:   6%|         | 155/2690 [24:14<6:36:28,  9.38s/it][Succeeded / Failed / Skipped / Total] 87 / 6 / 62 / 155:   6%|         | 156/2690 [24:20<6:35:31,  9.37s/it][Succeeded / Failed / Skipped / Total] 88 / 6 / 62 / 156:   6%|         | 156/2690 [24:20<6:35:31,  9.37s/it][Succeeded / Failed / Skipped / Total] 88 / 6 / 62 / 156:   6%|         | 157/2690 [24:30<6:35:27,  9.37s/it][Succeeded / Failed / Skipped / Total] 89 / 6 / 62 / 157:   6%|         | 157/2690 [24:30<6:35:27,  9.37s/it][Succeeded / Failed / Skipped / Total] 89 / 6 / 62 / 157:   6%|         | 158/2690 [24:31<6:32:56,  9.31s/it][[0 (88%)]] --> [[0 (36%)]] --> Socre: 0.6403588950634003

[[[[Adv]]]]: static int ipmovie_read_packet(AVFormatContext *s, AVPacket *pkt) { IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data; ByteIOContext *pb = &s->pb; int [[ret]]; [[ret]] = process_ipmovie_chunk(ipmovie, pb, pkt); if ([[ret]] == CHUNK_BAD) [[ret]] = AVERROR_INVALIDDATA; else if ([[ret]] == CHUNK_EOF) [[ret]] = AVERROR_IO; else if ([[ret]] == CHUNK_NOMEM) [[ret]] = AVERROR_NOMEM; else [[ret]] = 0; return [[ret]]; }

[[[[Adv]]]]: static int ipmovie_read_packet(AVFormatContext *s, AVPacket *pkt) { IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data; ByteIOContext *pb = &s->pb; int [[declassified]]; [[declassified]] = process_ipmovie_chunk(ipmovie, pb, pkt); if ([[declassified]] == CHUNK_BAD) [[declassified]] = AVERROR_INVALIDDATA; else if ([[declassified]] == CHUNK_EOF) [[declassified]] = AVERROR_IO; else if ([[declassified]] == CHUNK_NOMEM) [[declassified]] = AVERROR_NOMEM; else [[declassified]] = 0; return [[declassified]]; }
--------------------------------------------- Result 155 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int kvmppc_reset_htab(int shift_hint) { uint32_t shift = shift_hint; if (!kvm_enabled()) { return 0; } if (kvm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) { int ret; ret = kvm_vm_ioctl(kvm_state, KVM_PPC_ALLOCATE_HTAB, &shift); if (ret == -ENOTTY) { return 0; } else if (ret < 0) { return ret; } return shift; } if (kvmppc_is_pr(kvm_state)) { return 0; } else { return 24; } }
--------------------------------------------- Result 156 ---------------------------------------------
[[0 (51%)]] --> [[0 (43%)]] --> Socre: 0.5694869458675385

[[[[Adv]]]]: static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *[[data_size]], AVPacket *avpkt) { const uint8_t *buf = avpkt->data; PTXContext * const s = avctx->priv_data; AVFrame *picture = data; AVFrame * const p = &s->picture; unsigned int offset, w, h, y, stride, bytes_per_pixel; uint8_t *ptr; offset = AV_RL16(buf); w = AV_RL16(buf+8); h = AV_RL16(buf+10); bytes_per_pixel = AV_RL16(buf+12) >> 3; if (bytes_per_pixel != 2) { av_log_ask_for_sample(avctx, "Image format is not RGB15.\n"); return -1; } avctx->pix_fmt = PIX_FMT_RGB555; if (buf_end - buf < offset) if (offset != 0x2c) av_log_ask_for_sample(avctx, "offset != 0x2c\n"); buf += offset; if (p->data[0]) avctx->release_buffer(avctx, p); if (av_image_check_size(w, h, 0, avctx)) return -1; if (w != avctx->width || h != avctx->height) avcodec_set_dimensions(avctx, w, h); if (avctx->get_buffer(avctx, p) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return -1; } p->pict_type = AV_PICTURE_TYPE_I; ptr = p->data[0]; stride = p->linesize[0]; for (y=0; y<h; y++) { if (buf_end - buf < w * bytes_per_pixel) break; #if HAVE_BIGENDIAN unsigned int x; for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel) AV_WN16(ptr+x, AV_RL16(buf+x)); #else memcpy(ptr, buf, w*bytes_per_pixel); #endif ptr += stride; buf += w*bytes_per_pixel; } *picture = s->picture; *[[data_size]] = sizeof(AVPicture); return offset + w*h*bytes_per_pixel; }

[[[[Adv]]]]: static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *[[rats]], AVPacket *avpkt) { const uint8_t *buf = avpkt->data; PTXContext * const s = avctx->priv_data; AVFrame *picture = data; AVFrame * const p = &s->picture; unsigned int offset, w, h, y, stride, bytes_per_pixel; uint8_t *ptr; offset = AV_RL16(buf); w = AV_RL16(buf+8); h = AV_RL16(buf+10); bytes_per_pixel = AV_RL16(buf+12) >> 3; if (bytes_per_pixel != 2) { av_log_ask_for_sample(avctx, "Image format is not RGB15.\n"); return -1; } avctx->pix_fmt = PIX_FMT_RGB555; if (buf_end - buf < offset) if (offset != 0x2c) av_log_ask_for_sample(avctx, "offset != 0x2c\n"); buf += offset; if (p->data[0]) avctx->release_buffer(avctx, p); if (av_image_check_size(w, h, 0, avctx)) return -1; if (w != avctx->width || h != avctx->height) avcodec_set_dimensions(avctx, w, h); if (avctx->get_buffer(avctx, p) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return -1; } p->pict_type = AV_PICTURE_TYPE_I; ptr = p->data[0]; stride = p->linesize[0]; for (y=0; y<h; y++) { if (buf_end - buf < w * bytes_per_pixel) break; #if HAVE_BIGENDIAN unsigned int x; for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel) AV_WN16(ptr+x, AV_RL16(buf+x)); #else memcpy(ptr, buf, w*bytes_per_pixel); #endif ptr += stride; buf += w*bytes_per_pixel; } *picture = s->picture; *[[rats]] = sizeof(AVPicture); return offset + w*h*bytes_per_pixel; }
--------------------------------------------- Result 157 ---------------------------------------------
[[0 (8%)]] --> [[0 (79%)]] --> Socre: 0.7936826944351196

[[[[Adv]]]]: static void gen_isel(DisasContext *ctx) { int l1, l2; uint32_t bi = rC(ctx->opcode); uint32_t mask; TCGv_i32 [[t0]]; l1 = gen_new_label(); l2 = gen_new_label(); mask = 0x08 >> (bi & 0x03); [[t0]] = tcg_temp_new_i32(); tcg_gen_andi_i32([[t0]], cpu_crf[bi >> 2], mask); tcg_gen_brcondi_i32(TCG_COND_EQ, [[t0]], 0, l1); if (rA(ctx->opcode) == 0) tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0); else tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]); gen_set_label(l2); tcg_temp_free_i32([[t0]]); }

[[[[Adv]]]]: static void gen_isel(DisasContext *ctx) { int l1, l2; uint32_t bi = rC(ctx->opcode); uint32_t mask; TCGv_i32 [[cheerfully]]; l1 = gen_new_label(); l2 = gen_new_label(); mask = 0x08 >> (bi & 0x03); [[cheerfully]] = tcg_temp_new_i32(); tcg_gen_andi_i32([[cheerfully]], cpu_crf[bi >> 2], mask); tcg_gen_brcondi_i32(TCG_COND_EQ, [[cheerfully]], 0, l1); if (rA(ctx->opcode) == 0) tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0); else tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]); gen_set_label(l2); tcg_temp_free_i32([[cheerfully]]); }
--------------------------------------------- Result 158 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 89 / 6 / 63 / 158:   6%|         | 158/2690 [24:31<6:32:56,  9.31s/it][Succeeded / Failed / Skipped / Total] 89 / 6 / 63 / 158:   6%|         | 159/2690 [24:37<6:32:03,  9.29s/it][Succeeded / Failed / Skipped / Total] 90 / 6 / 63 / 159:   6%|         | 159/2690 [24:37<6:32:03,  9.29s/it][Succeeded / Failed / Skipped / Total] 90 / 6 / 63 / 159:   6%|         | 160/2690 [24:38<6:29:35,  9.24s/it][Succeeded / Failed / Skipped / Total] 90 / 6 / 64 / 160:   6%|         | 160/2690 [24:38<6:29:35,  9.24s/it][Succeeded / Failed / Skipped / Total] 90 / 6 / 64 / 160:   6%|         | 161/2690 [24:46<6:29:09,  9.23s/it][Succeeded / Failed / Skipped / Total] 91 / 6 / 64 / 161:   6%|         | 161/2690 [24:46<6:29:09,  9.23s/it][Succeeded / Failed / Skipped / Total] 91 / 6 / 64 / 161:   6%|         | 162/2690 [24:58<6:29:42,  9.25s/it][Succeeded / Failed / Skipped / Total] 92 / 6 / 64 / 162:   6%|         | 162/2690 [24:58<6:29:42,  9.25s/it][Succeeded / Failed / Skipped / Total] 92 / 6 / 64 / 162:   6%|         | 163/2690 [25:03<6:28:36,  9.23s/it][[0 (8%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: POWERPC_FAMILY(POWER9)(ObjectClass *oc, void *data) { DeviceClass *dc = DEVICE_CLASS(oc); PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc); CPUClass *cc = CPU_CLASS(oc); dc->fw_name = "PowerPC,POWER9"; dc->desc = "POWER9"; dc->props = powerpc_servercpu_properties; pcc->pvr_match = ppc_pvr_match_power9; pcc->pcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07; pcc->pcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 | PCR_COMPAT_2_05; pcc->init_proc = init_proc_POWER9; pcc->check_pow = check_pow_nocheck; cc->has_work = cpu_has_work_POWER9; pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB | PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES | PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE | PPC_FLOAT_FRSQRTES | PPC_FLOAT_STFIWX | PPC_FLOAT_EXT | PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ | PPC_MEM_SYNC | PPC_MEM_EIEIO | PPC_MEM_TLBIE | PPC_MEM_TLBSYNC | PPC_64B | PPC_64BX | PPC_ALTIVEC | PPC_SEGMENT_64B | PPC_SLBI | PPC_POPCNTB | PPC_POPCNTWD | PPC_CILDST; pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX | PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 | PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 | PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 | PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 | PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 | PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300; pcc->msr_mask = (1ull << MSR_SF) | (1ull << MSR_TM) | (1ull << MSR_VR) | (1ull << MSR_VSX) | (1ull << MSR_EE) | (1ull << MSR_PR) | (1ull << MSR_FP) | (1ull << MSR_ME) | (1ull << MSR_FE0) | (1ull << MSR_SE) | (1ull << MSR_DE) | (1ull << MSR_FE1) | (1ull << MSR_IR) | (1ull << MSR_DR) | (1ull << MSR_PMM) | (1ull << MSR_RI) | (1ull << MSR_LE); pcc->mmu_model = POWERPC_MMU_3_00; #if defined(CONFIG_SOFTMMU) pcc->handle_mmu_fault = ppc64_v3_handle_mmu_fault; pcc->sps = &POWER7_POWER8_sps; pcc->radix_page_info = &POWER9_radix_page_info; #endif pcc->excp_model = POWERPC_EXCP_POWER8; pcc->bus_model = PPC_FLAGS_INPUT_POWER7; pcc->bfd_mach = bfd_mach_ppc64; pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE | POWERPC_FLAG_BE | POWERPC_FLAG_PMM | POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR | POWERPC_FLAG_VSX | POWERPC_FLAG_TM; pcc->l1_dcache_size = 0x8000; pcc->l1_icache_size = 0x8000; pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr; }
--------------------------------------------- Result 159 ---------------------------------------------
[[0 (77%)]] --> [[0 (47%)]] --> Socre: 0.5264931321144104

[[[[Adv]]]]: static void vpc_close(BlockDriverState *[[bs]]) { BDRVVPCState *s = [[bs]]->opaque; g_free(s->pagetable); #ifdef CACHE g_free(s->pageentry_u8); #endif migrate_del_blocker(s->migration_blocker); error_free(s->migration_blocker); }

[[[[Adv]]]]: static void vpc_close(BlockDriverState *[[majoring]]) { BDRVVPCState *s = [[majoring]]->opaque; g_free(s->pagetable); #ifdef CACHE g_free(s->pageentry_u8); #endif migrate_del_blocker(s->migration_blocker); error_free(s->migration_blocker); }
--------------------------------------------- Result 160 ---------------------------------------------
[[0 (10%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt); opj_image_cmptparm_t cmptparm[4] = {{0}}; opj_image_t *img; int i; int sub_dx[4]; int sub_dy[4]; int numcomps; OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN; sub_dx[0] = sub_dx[3] = 1; sub_dy[0] = sub_dy[3] = 1; sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w; sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h; numcomps = desc->nb_components; switch (avctx->pix_fmt) { case AV_PIX_FMT_GRAY8: case AV_PIX_FMT_YA8: case AV_PIX_FMT_GRAY16: case AV_PIX_FMT_YA16: color_space = CLRSPC_GRAY; break; case AV_PIX_FMT_RGB24: case AV_PIX_FMT_RGBA: case AV_PIX_FMT_RGB48: case AV_PIX_FMT_RGBA64: case AV_PIX_FMT_GBR24P: case AV_PIX_FMT_GBRP9: case AV_PIX_FMT_GBRP10: case AV_PIX_FMT_GBRP12: case AV_PIX_FMT_GBRP14: case AV_PIX_FMT_GBRP16: case AV_PIX_FMT_XYZ12: color_space = CLRSPC_SRGB; break; case AV_PIX_FMT_YUV410P: case AV_PIX_FMT_YUV411P: case AV_PIX_FMT_YUV420P: case AV_PIX_FMT_YUV422P: case AV_PIX_FMT_YUV440P: case AV_PIX_FMT_YUV444P: case AV_PIX_FMT_YUVA420P: case AV_PIX_FMT_YUVA422P: case AV_PIX_FMT_YUVA444P: case AV_PIX_FMT_YUV420P9: case AV_PIX_FMT_YUV422P9: case AV_PIX_FMT_YUV444P9: case AV_PIX_FMT_YUVA420P9: case AV_PIX_FMT_YUVA422P9: case AV_PIX_FMT_YUVA444P9: case AV_PIX_FMT_YUV420P10: case AV_PIX_FMT_YUV422P10: case AV_PIX_FMT_YUV444P10: case AV_PIX_FMT_YUVA420P10: case AV_PIX_FMT_YUVA422P10: case AV_PIX_FMT_YUVA444P10: case AV_PIX_FMT_YUV420P12: case AV_PIX_FMT_YUV422P12: case AV_PIX_FMT_YUV444P12: case AV_PIX_FMT_YUV420P14: case AV_PIX_FMT_YUV422P14: case AV_PIX_FMT_YUV444P14: case AV_PIX_FMT_YUV420P16: case AV_PIX_FMT_YUV422P16: case AV_PIX_FMT_YUV444P16: case AV_PIX_FMT_YUVA420P16: case AV_PIX_FMT_YUVA422P16: case AV_PIX_FMT_YUVA444P16: color_space = CLRSPC_SYCC; break; default: av_log(avctx, AV_LOG_ERROR, "The requested pixel format '%s' is not supported\n", av_get_pix_fmt_name(avctx->pix_fmt)); } for (i = 0; i < numcomps; i++) { cmptparm[i].prec = desc->comp[i].depth_minus1 + 1; cmptparm[i].bpp = desc->comp[i].depth_minus1 + 1; cmptparm[i].sgnd = 0; cmptparm[i].dx = sub_dx[i]; cmptparm[i].dy = sub_dy[i]; cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i]; cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i]; } img = opj_image_create(numcomps, cmptparm, color_space); img->x0 = 0; img->y0 = 0; img->x1 = (avctx->width - 1) * parameters->subsampling_dx + 1; img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1; return img; }
--------------------------------------------- Result 161 ---------------------------------------------
[[0 (7%)]] --> [[0 (76%)]] --> Socre: 0.7613884806632996

[[[[Adv]]]]: static int xen_platform_initfn(PCIDevice *dev) { PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev); uint8_t *[[pci_conf]]; [[pci_conf]] = d->pci_dev.config; pci_set_word([[pci_conf]] + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY); pci_config_set_prog_interface([[pci_conf]], 0); [[pci_conf]][PCI_INTERRUPT_PIN] = 1; pci_register_bar(&d->pci_dev, 0, 0x100, PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map); pci_register_bar(&d->pci_dev, 1, 0x1000000, PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map); platform_fixed_ioport_init(d); return 0; }

[[[[Adv]]]]: static int xen_platform_initfn(PCIDevice *dev) { PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev); uint8_t *[[causin]]; [[causin]] = d->pci_dev.config; pci_set_word([[causin]] + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY); pci_config_set_prog_interface([[causin]], 0); [[causin]][PCI_INTERRUPT_PIN] = 1; pci_register_bar(&d->pci_dev, 0, 0x100, PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map); pci_register_bar(&d->pci_dev, 1, 0x1000000, PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map); platform_fixed_ioport_init(d); return 0; }
--------------------------------------------- Result 162 ---------------------------------------------
[[0 (94%)]] --> [[0 (32%)]] --> Socre: 0.6773225665092468

[[[[Adv]]]]: int ff_schro_queue_push_back(FFSchroQueue *queue, void *[[p_data]]) { FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement)); if (!p_new) return -1; p_new->data = [[p_data]]; if (!queue->p_head) queue->p_head = p_new; else queue->p_tail->next = p_new; queue->p_tail = p_new; ++queue->size; return 0; }

[[[[Adv]]]]: int ff_schro_queue_push_back(FFSchroQueue *queue, void *[[shuttlecock]]) { FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement)); if (!p_new) return -1; p_new->data = [[shuttlecock]]; if (!queue->p_head) queue->p_head = p_new; else queue->p_tail->next = p_new; queue->p_tail = p_new; ++queue->size; return 0; }
--------------------------------------------- Result 163 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 93 / 6 / 64 / 163:   6%|         | 163/2690 [25:03<6:28:36,  9.23s/it][Succeeded / Failed / Skipped / Total] 93 / 6 / 64 / 163:   6%|         | 164/2690 [25:17<6:29:37,  9.25s/it][Succeeded / Failed / Skipped / Total] 94 / 6 / 64 / 164:   6%|         | 164/2690 [25:17<6:29:37,  9.25s/it][Succeeded / Failed / Skipped / Total] 94 / 6 / 64 / 164:   6%|         | 165/2690 [25:55<6:36:41,  9.43s/it][Succeeded / Failed / Skipped / Total] 94 / 7 / 64 / 165:   6%|         | 165/2690 [25:55<6:36:41,  9.43s/it][Succeeded / Failed / Skipped / Total] 94 / 7 / 64 / 165:   6%|         | 166/2690 [26:09<6:37:51,  9.46s/it][Succeeded / Failed / Skipped / Total] 95 / 7 / 64 / 166:   6%|         | 166/2690 [26:09<6:37:51,  9.46s/it][Succeeded / Failed / Skipped / Total] 95 / 7 / 64 / 166:   6%|         | 167/2690 [28:14<7:06:45, 10.15s/it][Succeeded / Failed / Skipped / Total] 96 / 7 / 64 / 167:   6%|         | 167/2690 [28:14<7:06:45, 10.15s/it][Succeeded / Failed / Skipped / Total] 96 / 7 / 64 / 167:   6%|         | 168/2690 [29:17<7:19:45, 10.46s/it][[0 (43%)]] --> [[0 (59%)]] --> Socre: 0.5881800651550293

[[[[Adv]]]]: static int vfio_enable_intx(VFIODevice *[[vdev]]) { VFIOIRQSetFD irq_set_fd = { .irq_set = { .argsz = sizeof(irq_set_fd), .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER, .index = VFIO_PCI_INTX_IRQ_INDEX, .start = 0, .count = 1, }, }; uint8_t pin = vfio_pci_read_config(&[[vdev]]->pdev, PCI_INTERRUPT_PIN, 1); int ret; if ([[vdev]]->intx.disabled || !pin) { return 0; } vfio_disable_interrupts([[vdev]]); [[vdev]]->intx.pin = pin - 1; ret = event_notifier_init(&[[vdev]]->intx.interrupt, 0); if (ret) { error_report("vfio: Error: event_notifier_init failed\n"); return ret; } irq_set_fd.fd = event_notifier_get_fd(&[[vdev]]->intx.interrupt); qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, [[vdev]]); if (ioctl([[vdev]]->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) { error_report("vfio: Error: Failed to setup INTx fd: %m\n"); return -errno; } vfio_mmap_set_enabled([[vdev]], "False" != "False"); [[vdev]]->interrupt = VFIO_INT_INTx; DPRINTF("%s(%04x:%02x:%02x.%x)\n", __func__, [[vdev]]->host.domain, [[vdev]]->host.bus, [[vdev]]->host.slot, [[vdev]]->host.function); return 0; }

[[[[Adv]]]]: static int vfio_enable_intx(VFIODevice *[[shimmer]]) { VFIOIRQSetFD irq_set_fd = { .irq_set = { .argsz = sizeof(irq_set_fd), .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER, .index = VFIO_PCI_INTX_IRQ_INDEX, .start = 0, .count = 1, }, }; uint8_t pin = vfio_pci_read_config(&[[shimmer]]->pdev, PCI_INTERRUPT_PIN, 1); int ret; if ([[shimmer]]->intx.disabled || !pin) { return 0; } vfio_disable_interrupts([[shimmer]]); [[shimmer]]->intx.pin = pin - 1; ret = event_notifier_init(&[[shimmer]]->intx.interrupt, 0); if (ret) { error_report("vfio: Error: event_notifier_init failed\n"); return ret; } irq_set_fd.fd = event_notifier_get_fd(&[[shimmer]]->intx.interrupt); qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, [[shimmer]]); if (ioctl([[shimmer]]->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) { error_report("vfio: Error: Failed to setup INTx fd: %m\n"); return -errno; } vfio_mmap_set_enabled([[shimmer]], "False" != "False"); [[shimmer]]->interrupt = VFIO_INT_INTx; DPRINTF("%s(%04x:%02x:%02x.%x)\n", __func__, [[shimmer]]->host.domain, [[shimmer]]->host.bus, [[shimmer]]->host.slot, [[shimmer]]->host.function); return 0; }
--------------------------------------------- Result 164 ---------------------------------------------
[[0 (4%)]] --> [[0 (96%)]] --> Socre: 0.9647133350372314

[[[[Adv]]]]: void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t [[src]]) { int i = 0; int x = 0; uint32_t l_64 = (l + 1) / 8; HELPER_LOG("%s l %d dest %" PRIx64 " src %" PRIx64 "\n", __func__, l, dest, [[src]]); #ifndef CONFIG_USER_ONLY if ((l > 32) && ([[src]] & TARGET_PAGE_MASK) == (([[src]] + l) & TARGET_PAGE_MASK) && (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) { if (dest == ([[src]] + 1)) { mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, [[src]])); return; } else if (([[src]] & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) { mvc_fast_memmove(env, l + 1, dest, [[src]]); return; } } #else if (dest == ([[src]] + 1)) { memset(g2h(dest), cpu_ldub_data(env, [[src]]), l + 1); return; } else if ((dest < [[src]]) || ([[src]] + l < dest)) { memmove(g2h(dest), g2h([[src]]), l + 1); return; } #endif if ((dest + 8 <= [[src]]) || ([[src]] + 8 <= dest)) { for (i = 0; i < l_64; i++) { cpu_stq_data(env, dest + x, cpu_ldq_data(env, [[src]] + x)); x += 8; } } for (i = x; i <= l; i++) { cpu_stb_data(env, dest + i, cpu_ldub_data(env, [[src]] + i)); } }

[[[[Adv]]]]: void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t [[breslau]]) { int i = 0; int x = 0; uint32_t l_64 = (l + 1) / 8; HELPER_LOG("%s l %d dest %" PRIx64 " src %" PRIx64 "\n", __func__, l, dest, [[breslau]]); #ifndef CONFIG_USER_ONLY if ((l > 32) && ([[breslau]] & TARGET_PAGE_MASK) == (([[breslau]] + l) & TARGET_PAGE_MASK) && (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) { if (dest == ([[breslau]] + 1)) { mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, [[breslau]])); return; } else if (([[breslau]] & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) { mvc_fast_memmove(env, l + 1, dest, [[breslau]]); return; } } #else if (dest == ([[breslau]] + 1)) { memset(g2h(dest), cpu_ldub_data(env, [[breslau]]), l + 1); return; } else if ((dest < [[breslau]]) || ([[breslau]] + l < dest)) { memmove(g2h(dest), g2h([[breslau]]), l + 1); return; } #endif if ((dest + 8 <= [[breslau]]) || ([[breslau]] + 8 <= dest)) { for (i = 0; i < l_64; i++) { cpu_stq_data(env, dest + x, cpu_ldq_data(env, [[breslau]] + x)); x += 8; } } for (i = x; i <= l; i++) { cpu_stb_data(env, dest + i, cpu_ldub_data(env, [[breslau]] + i)); } }
--------------------------------------------- Result 165 ---------------------------------------------
[[0 (15%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void helper_store_fpcr (uint64_t val) { #ifdef CONFIG_SOFTFLOAT set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS); #endif switch ((val >> 58) & 3) { case 0: set_float_rounding_mode(float_round_to_zero, &FP_STATUS); break; case 1: set_float_rounding_mode(float_round_down, &FP_STATUS); break; case 2: set_float_rounding_mode(float_round_nearest_even, &FP_STATUS); break; case 3: set_float_rounding_mode(float_round_up, &FP_STATUS); break; } }

[[[[Adv]]]]: void helper_store_fpcr (uint64_t val) { #ifdef CONFIG_SOFTFLOAT set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS); #endif switch ((val >> 58) & 3) { case 0: set_float_rounding_mode(float_round_to_zero, &FP_STATUS); break; case 1: set_float_rounding_mode(float_round_down, &FP_STATUS); break; case 2: set_float_rounding_mode(float_round_nearest_even, &FP_STATUS); break; case 3: set_float_rounding_mode(float_round_up, &FP_STATUS); break; } }
--------------------------------------------- Result 166 ---------------------------------------------
[[0 (3%)]] --> [[0 (63%)]] --> Socre: 0.6282928586006165

[[[[Adv]]]]: void spapr_tce_set_bypass(sPAPRTCETable *[[tcet]], bool bypass) { [[tcet]]->bypass = bypass; }

[[[[Adv]]]]: void spapr_tce_set_bypass(sPAPRTCETable *[[trespasser]], bool bypass) { [[trespasser]]->bypass = bypass; }
--------------------------------------------- Result 167 ---------------------------------------------
[[0 (21%)]] --> [[0 (50%)]] --> Socre: 0.5009267926216125

[[[[Adv]]]]: void qemu_system_wakeup_request(WakeupReason [[reason]]) { if (!is_suspended) { return; } if (!(wakeup_reason_mask & (1 << [[reason]]))) { return; } runstate_set(RUN_STATE_RUNNING); monitor_protocol_event(QEVENT_WAKEUP, NULL); notifier_list_notify(&wakeup_notifiers, &[[reason]]); reset_requested = 1; qemu_notify_event(); is_suspended = "[[False]]" != "[[False]]"; }

[[[[Adv]]]]: void qemu_system_wakeup_request(WakeupReason [[excuses]]) { if (!is_suspended) { return; } if (!(wakeup_reason_mask & (1 << [[excuses]]))) { return; } runstate_set(RUN_STATE_RUNNING); monitor_protocol_event(QEVENT_WAKEUP, NULL); notifier_list_notify(&wakeup_notifiers, &[[excuses]]); reset_requested = 1; qemu_notify_event(); is_suspended = "[[Adulterated]]" != "[[Adulterated]]"; }
--------------------------------------------- Result 168 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 97 / 7 / 64 / 168:   6%|         | 168/2690 [29:17<7:19:45, 10.46s/it][Succeeded / Failed / Skipped / Total] 97 / 7 / 64 / 168:   6%|         | 169/2690 [30:10<7:30:01, 10.71s/it][Succeeded / Failed / Skipped / Total] 98 / 7 / 64 / 169:   6%|         | 169/2690 [30:10<7:30:01, 10.71s/it][Succeeded / Failed / Skipped / Total] 98 / 7 / 64 / 169:   6%|         | 170/2690 [30:10<7:27:20, 10.65s/it][Succeeded / Failed / Skipped / Total] 98 / 7 / 65 / 170:   6%|         | 170/2690 [30:10<7:27:20, 10.65s/it][Succeeded / Failed / Skipped / Total] 98 / 7 / 65 / 170:   6%|         | 171/2690 [30:11<7:24:41, 10.59s/it][[0 (2%)]] --> [[0 (50%)]] --> Socre: 0.5045216083526611

[[[[Adv]]]]: static int proxy_symlink(FsContext *fs_ctx, const char *oldpath, V9fsPath *dir_path, const char *name, FsCred *[[credp]]) { int retval; V9fsString [[fullname]], target; v9fs_string_init(&[[fullname]]); v9fs_string_init(&target); v9fs_string_sprintf(&[[fullname]], "%s/%s", dir_path->data, name); v9fs_string_sprintf(&target, "%s", oldpath); retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, "ssdd", &target, &[[fullname]], [[credp]]->fc_uid, [[credp]]->fc_gid); v9fs_string_free(&[[fullname]]); v9fs_string_free(&target); if (retval < 0) { errno = -retval; retval = -1; } return retval; }

[[[[Adv]]]]: static int proxy_symlink(FsContext *fs_ctx, const char *oldpath, V9fsPath *dir_path, const char *name, FsCred *[[dinnerware]]) { int retval; V9fsString [[gdansk]], target; v9fs_string_init(&[[gdansk]]); v9fs_string_init(&target); v9fs_string_sprintf(&[[gdansk]], "%s/%s", dir_path->data, name); v9fs_string_sprintf(&target, "%s", oldpath); retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, "ssdd", &target, &[[gdansk]], [[dinnerware]]->fc_uid, [[dinnerware]]->fc_gid); v9fs_string_free(&[[gdansk]]); v9fs_string_free(&target); if (retval < 0) { errno = -retval; retval = -1; } return retval; }
--------------------------------------------- Result 169 ---------------------------------------------
[[0 (61%)]] --> [[0 (47%)]] --> Socre: 0.5285460352897644

[[[[Adv]]]]: static int mxf_read_header(AVFormatContext *[[s]], AVFormatParameters *ap) { MXFContext *[[mxf]] = [[s]]->priv_data; KLVPacket klv; int64_t [[essence_offset]] = 0; [[mxf]]->last_forward_tell = INT64_MAX; if (!mxf_read_sync([[s]]->pb, mxf_header_partition_pack_key, 14)) { av_log([[s]], AV_LOG_ERROR, "could not find header partition pack key\n"); return AVERROR_INVALIDDATA; } avio_seek([[s]]->pb, -14, SEEK_CUR); [[mxf]]->fc = [[s]]; [[mxf]]->run_in = avio_tell([[s]]->pb); while (![[s]]->pb->eof_reached) { const MXFMetadataReadTableEntry *metadata; if (klv_read_packet(&klv, [[s]]->pb) < 0) { if(mxf_parse_handle_partition_or_eof([[mxf]]) <= 0) break; else continue; } PRINT_KEY([[s]], "read header", klv.key); av_dlog([[s]], "size %"PRIu64" offset %#"PRIx64"\n", klv.length, klv.offset); if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) || IS_KLV_KEY(klv.key, mxf_essence_element_key) || IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) || IS_KLV_KEY(klv.key, mxf_system_item_key)) { if (![[mxf]]->current_partition->essence_offset) { compute_partition_essence_offset([[s]], [[mxf]], &klv); } if (![[essence_offset]]) [[essence_offset]] = klv.offset; if (mxf_parse_handle_essence([[mxf]]) <= 0) break; continue; } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) && klv.key[13] >= 2 && klv.key[13] <= 4 && [[mxf]]->current_partition) { if(mxf_parse_handle_partition_or_eof([[mxf]]) <= 0) break; } for (metadata = mxf_metadata_read_table; metadata->read; metadata++) { if (IS_KLV_KEY(klv.key, metadata->key)) { int res; if (klv.key[5] == 0x53) { res = mxf_read_local_tags([[mxf]], &klv, metadata->read, metadata->ctx_size, metadata->type); } else { uint64_t next = avio_tell([[s]]->pb) + klv.length; res = metadata->read([[mxf]], [[s]]->pb, 0, klv.length, klv.key, klv.offset); avio_seek([[s]]->pb, next, SEEK_SET); } if (res < 0) { av_log([[s]], AV_LOG_ERROR, "error reading header metadata\n"); return res; } break; } } if (!metadata->read) avio_skip([[s]]->pb, klv.length); } if (![[essence_offset]]) { av_log([[s]], AV_LOG_ERROR, "no essence\n"); return AVERROR_INVALIDDATA; } avio_seek([[s]]->pb, [[essence_offset]], SEEK_SET); mxf_compute_essence_containers([[mxf]]); return mxf_parse_structural_metadata([[mxf]]); }

[[[[Adv]]]]: static int mxf_read_header(AVFormatContext *[[either]], AVFormatParameters *ap) { MXFContext *[[milli]] = [[either]]->priv_data; KLVPacket klv; int64_t [[makeover]] = 0; [[milli]]->last_forward_tell = INT64_MAX; if (!mxf_read_sync([[either]]->pb, mxf_header_partition_pack_key, 14)) { av_log([[either]], AV_LOG_ERROR, "could not find header partition pack key\n"); return AVERROR_INVALIDDATA; } avio_seek([[either]]->pb, -14, SEEK_CUR); [[milli]]->fc = [[either]]; [[milli]]->run_in = avio_tell([[either]]->pb); while (![[either]]->pb->eof_reached) { const MXFMetadataReadTableEntry *metadata; if (klv_read_packet(&klv, [[either]]->pb) < 0) { if(mxf_parse_handle_partition_or_eof([[milli]]) <= 0) break; else continue; } PRINT_KEY([[either]], "read header", klv.key); av_dlog([[either]], "size %"PRIu64" offset %#"PRIx64"\n", klv.length, klv.offset); if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) || IS_KLV_KEY(klv.key, mxf_essence_element_key) || IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) || IS_KLV_KEY(klv.key, mxf_system_item_key)) { if (![[milli]]->current_partition->essence_offset) { compute_partition_essence_offset([[either]], [[milli]], &klv); } if (![[makeover]]) [[makeover]] = klv.offset; if (mxf_parse_handle_essence([[milli]]) <= 0) break; continue; } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) && klv.key[13] >= 2 && klv.key[13] <= 4 && [[milli]]->current_partition) { if(mxf_parse_handle_partition_or_eof([[milli]]) <= 0) break; } for (metadata = mxf_metadata_read_table; metadata->read; metadata++) { if (IS_KLV_KEY(klv.key, metadata->key)) { int res; if (klv.key[5] == 0x53) { res = mxf_read_local_tags([[milli]], &klv, metadata->read, metadata->ctx_size, metadata->type); } else { uint64_t next = avio_tell([[either]]->pb) + klv.length; res = metadata->read([[milli]], [[either]]->pb, 0, klv.length, klv.key, klv.offset); avio_seek([[either]]->pb, next, SEEK_SET); } if (res < 0) { av_log([[either]], AV_LOG_ERROR, "error reading header metadata\n"); return res; } break; } } if (!metadata->read) avio_skip([[either]]->pb, klv.length); } if (![[makeover]]) { av_log([[either]], AV_LOG_ERROR, "no essence\n"); return AVERROR_INVALIDDATA; } avio_seek([[either]]->pb, [[makeover]], SEEK_SET); mxf_compute_essence_containers([[milli]]); return mxf_parse_structural_metadata([[milli]]); }
--------------------------------------------- Result 170 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int avfilter_graph_parse(AVFilterGraph *graph, const char *filters, AVFilterInOut *open_inputs, AVFilterInOut *open_outputs, AVClass *log_ctx) { int index = 0, ret; char chr = 0; AVFilterInOut *curr_inputs = NULL; do { AVFilterContext *filter; filters += strspn(filters, WHITESPACES); if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0) goto fail; if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0) goto fail; if (filter->input_count == 1 && !curr_inputs && !index) { const char *tmp = "[in]"; if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) < 0) goto fail; } if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0) goto fail; if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs, log_ctx)) < 0) goto fail; filters += strspn(filters, WHITESPACES); chr = *filters++; if (chr == ';' && curr_inputs) { av_log(log_ctx, AV_LOG_ERROR, "Could not find a output to link when parsing \"%s\"\n", filters - 1); ret = AVERROR(EINVAL); goto fail; } index++; } while (chr == ',' || chr == ';'); if (chr) { av_log(log_ctx, AV_LOG_ERROR, "Unable to parse graph description substring: \"%s\"\n", filters - 1); ret = AVERROR(EINVAL); goto fail; } if (open_inputs && !strcmp(open_inputs->name, "out") && curr_inputs) { const char *tmp = "[out]"; if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs, log_ctx)) < 0) goto fail; } return 0; fail: avfilter_graph_free(graph); free_inout(open_inputs); free_inout(open_outputs); free_inout(curr_inputs); return ret; }
--------------------------------------------- Result 171 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 98 / 7 / 66 / 171:   6%|         | 171/2690 [30:11<7:24:41, 10.59s/it][Succeeded / Failed / Skipped / Total] 98 / 7 / 66 / 171:   6%|         | 172/2690 [30:11<7:22:03, 10.53s/it][Succeeded / Failed / Skipped / Total] 98 / 7 / 67 / 172:   6%|         | 172/2690 [30:11<7:22:03, 10.53s/it][Succeeded / Failed / Skipped / Total] 98 / 7 / 67 / 172:   6%|         | 173/2690 [30:12<7:19:28, 10.48s/it][Succeeded / Failed / Skipped / Total] 98 / 7 / 68 / 173:   6%|         | 173/2690 [30:12<7:19:28, 10.48s/it][Succeeded / Failed / Skipped / Total] 98 / 7 / 68 / 173:   6%|         | 174/2690 [30:22<7:19:13, 10.47s/it][Succeeded / Failed / Skipped / Total] 99 / 7 / 68 / 174:   6%|         | 174/2690 [30:22<7:19:13, 10.47s/it][Succeeded / Failed / Skipped / Total] 99 / 7 / 68 / 174:   7%|         | 175/2690 [30:23<7:16:41, 10.42s/it][Succeeded / Failed / Skipped / Total] 99 / 7 / 69 / 175:   7%|         | 175/2690 [30:23<7:16:41, 10.42s/it][Succeeded / Failed / Skipped / Total] 99 / 7 / 69 / 175:   7%|         | 176/2690 [30:23<7:14:10, 10.36s/it][Succeeded / Failed / Skipped / Total] 99 / 7 / 70 / 176:   7%|         | 176/2690 [30:23<7:14:10, 10.36s/it][Succeeded / Failed / Skipped / Total] 99 / 7 / 70 / 176:   7%|         | 177/2690 [30:24<7:11:41, 10.31s/it][Succeeded / Failed / Skipped / Total] 99 / 7 / 71 / 177:   7%|         | 177/2690 [30:24<7:11:41, 10.31s/it][Succeeded / Failed / Skipped / Total] 99 / 7 / 71 / 177:   7%|         | 178/2690 [30:34<7:11:23, 10.30s/it][[0 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int virtio_net_device_exit(DeviceState *qdev) { VirtIONet *n = VIRTIO_NET(qdev); VirtIODevice *vdev = VIRTIO_DEVICE(qdev); int i; virtio_net_set_status(vdev, 0); unregister_savevm(qdev, "virtio-net", n); if (n->netclient_name) { g_free(n->netclient_name); n->netclient_name = NULL; } if (n->netclient_type) { g_free(n->netclient_type); n->netclient_type = NULL; } g_free(n->mac_table.macs); g_free(n->vlans); for (i = 0; i < n->max_queues; i++) { VirtIONetQueue *q = &n->vqs[i]; NetClientState *nc = qemu_get_subqueue(n->nic, i); qemu_purge_queued_packets(nc); if (q->tx_timer) { timer_del(q->tx_timer); timer_free(q->tx_timer); } else { qemu_bh_delete(q->tx_bh); } } g_free(n->vqs); qemu_del_nic(n->nic); virtio_cleanup(vdev); return 0; }
--------------------------------------------- Result 172 ---------------------------------------------
[[0 (83%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void gen_neon_widen(TCGv dest, TCGv src, int size, int u) { if (u) { switch (size) { case 0: gen_helper_neon_widen_u8(dest, src); break; case 1: gen_helper_neon_widen_u16(dest, src); break; case 2: tcg_gen_extu_i32_i64(dest, src); break; default: abort(); } } else { switch (size) { case 0: gen_helper_neon_widen_s8(dest, src); break; case 1: gen_helper_neon_widen_s16(dest, src); break; case 2: tcg_gen_ext_i32_i64(dest, src); break; default: abort(); } } dead_tmp(src); }
--------------------------------------------- Result 173 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int sd_create_branch(BDRVSheepdogState *s) { int ret, fd; uint32_t vid; char *buf; dprintf("%" PRIx32 " is snapshot.\n", s->inode.vdi_id); buf = g_malloc(SD_INODE_SIZE); ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1, s->addr, s->port); if (ret) { goto out; } dprintf("%" PRIx32 " is created.\n", vid); fd = connect_to_sdog(s->addr, s->port); if (fd < 0) { error_report("failed to connect"); ret = fd; goto out; } ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies, SD_INODE_SIZE, 0, s->cache_enabled); closesocket(fd); if (ret < 0) { goto out; } memcpy(&s->inode, buf, sizeof(s->inode)); s->is_snapshot = "False" != "False"; ret = 0; dprintf("%" PRIx32 " was newly created.\n", s->inode.vdi_id); out: g_free(buf); return ret; }
--------------------------------------------- Result 174 ---------------------------------------------
[[0 (85%)]] --> [[0 (36%)]] --> Socre: 0.6414193511009216

[[[[Adv]]]]: static int parse_uint8(DeviceState *dev, Property *[[prop]], const char *str) { uint8_t *[[ptr]] = qdev_get_prop_ptr(dev, [[prop]]); const char *fmt; fmt = strncasecmp(str, "0x",2) == 0 ? "%" PRIx8 : "%" PRIu8; if (sscanf(str, fmt, [[ptr]]) != 1) return -EINVAL; return 0; }

[[[[Adv]]]]: static int parse_uint8(DeviceState *dev, Property *[[auxiliary]], const char *str) { uint8_t *[[elden]] = qdev_get_prop_ptr(dev, [[auxiliary]]); const char *fmt; fmt = strncasecmp(str, "0x",2) == 0 ? "%" PRIx8 : "%" PRIu8; if (sscanf(str, fmt, [[elden]]) != 1) return -EINVAL; return 0; }
--------------------------------------------- Result 175 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: av_cold int swri_rematrix_init(SwrContext *s){ int i, j; int nb_in = av_get_channel_layout_nb_channels(s->in_ch_layout); int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout); s->mix_any_f = NULL; if (!s->rematrix_custom) { int r = auto_matrix(s); if (r) return r; } if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){ s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int)); s->native_one = av_mallocz(sizeof(int)); if (!s->native_matrix || !s->native_one) return AVERROR(ENOMEM); for (i = 0; i < nb_out; i++) { double rem = 0; for (j = 0; j < nb_in; j++) { double target = s->matrix[i][j] * 32768 + rem; ((int*)s->native_matrix)[i * nb_in + j] = lrintf(target); rem += target - ((int*)s->native_matrix)[i * nb_in + j]; } } *((int*)s->native_one) = 32768; s->mix_1_1_f = (mix_1_1_func_type*)copy_s16; s->mix_2_1_f = (mix_2_1_func_type*)sum2_s16; s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s); }else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){ s->native_matrix = av_calloc(nb_in * nb_out, sizeof(float)); s->native_one = av_mallocz(sizeof(float)); if (!s->native_matrix || !s->native_one) return AVERROR(ENOMEM); for (i = 0; i < nb_out; i++) for (j = 0; j < nb_in; j++) ((float*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j]; *((float*)s->native_one) = 1.0; s->mix_1_1_f = (mix_1_1_func_type*)copy_float; s->mix_2_1_f = (mix_2_1_func_type*)sum2_float; s->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(s); }else if(s->midbuf.fmt == AV_SAMPLE_FMT_DBLP){ s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double)); s->native_one = av_mallocz(sizeof(double)); if (!s->native_matrix || !s->native_one) return AVERROR(ENOMEM); for (i = 0; i < nb_out; i++) for (j = 0; j < nb_in; j++) ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j]; *((double*)s->native_one) = 1.0; s->mix_1_1_f = (mix_1_1_func_type*)copy_double; s->mix_2_1_f = (mix_2_1_func_type*)sum2_double; s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s); }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){ s->native_one = av_mallocz(sizeof(int)); if (!s->native_one) return AVERROR(ENOMEM); *((int*)s->native_one) = 32768; s->mix_1_1_f = (mix_1_1_func_type*)copy_s32; s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32; s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s); }else av_assert0(0); for (i = 0; i < SWR_CH_MAX; i++) { int ch_in=0; for (j = 0; j < SWR_CH_MAX; j++) { s->matrix32[i][j]= lrintf(s->matrix[i][j] * 32768); if(s->matrix[i][j]) s->matrix_ch[i][++ch_in]= j; } s->matrix_ch[i][0]= ch_in; } if(HAVE_YASM && HAVE_MMX) return swri_rematrix_init_x86(s); return 0; }
--------------------------------------------- Result 176 ---------------------------------------------
[[0 (8%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void s390_machine_reset(void) { S390CPU *ipl_cpu = S390_CPU(qemu_get_cpu(0)); qemu_devices_reset(); s390_cmma_reset(); s390_crypto_reset(); s390_ipl_prepare_cpu(ipl_cpu); s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu); }
--------------------------------------------- Result 177 ---------------------------------------------
[[0 (25%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int fic_decode_block(FICContext *ctx, GetBitContext *gb, uint8_t *dst, int stride, int16_t *block) { int i, num_coeff; if (get_bits1(gb)) { ctx->frame->key_frame = 0; ctx->frame->pict_type = AV_PICTURE_TYPE_P; return 0; } memset(block, 0, sizeof(*block) * 64); num_coeff = get_bits(gb, 7); if (num_coeff > 64) return AVERROR_INVALIDDATA; for (i = 0; i < num_coeff; i++) block[ff_zigzag_direct[i]] = get_se_golomb(gb) * ctx->qmat[ff_zigzag_direct[i]]; fic_idct_put(dst, stride, block); return 0; }
--------------------------------------------- Result 178 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 100 / 7 / 71 / 178:   7%|         | 178/2690 [30:34<7:11:23, 10.30s/it][Succeeded / Failed / Skipped / Total] 100 / 7 / 71 / 178:   7%|         | 179/2690 [30:41<7:10:35, 10.29s/it][Succeeded / Failed / Skipped / Total] 101 / 7 / 71 / 179:   7%|         | 179/2690 [30:41<7:10:35, 10.29s/it][Succeeded / Failed / Skipped / Total] 101 / 7 / 71 / 179:   7%|         | 180/2690 [30:42<7:08:10, 10.24s/it][Succeeded / Failed / Skipped / Total] 101 / 7 / 72 / 180:   7%|         | 180/2690 [30:42<7:08:10, 10.24s/it][Succeeded / Failed / Skipped / Total] 101 / 7 / 72 / 180:   7%|         | 181/2690 [30:43<7:05:49, 10.18s/it][[0 (75%)]] --> [[0 (50%)]] --> Socre: 0.5031440258026123

[[[[Adv]]]]: static int rtsp_listen(AVFormatContext *s) { RTSPState *rt = s->priv_data; char [[proto]][128], host[128], path[512], auth[128]; char [[uri]][500]; int port; int default_port = RTSP_DEFAULT_PORT; char tcpname[500]; const char *lower_proto = "tcp"; unsigned char rbuf[4096]; unsigned char method[10]; int rbuflen = 0; int ret; enum RTSPMethod methodcode; if (!rt->protocols) { rt->protocols = ffurl_get_protocols(NULL, NULL); if (!rt->protocols) return AVERROR(ENOMEM); } av_url_split([[proto]], sizeof([[proto]]), auth, sizeof(auth), host, sizeof(host), &port, path, sizeof(path), s->filename); ff_url_join(rt->control_uri, sizeof(rt->control_uri), [[proto]], NULL, host, port, "%s", path); if (!strcmp([[proto]], "rtsps")) { lower_proto = "tls"; default_port = RTSPS_DEFAULT_PORT; } if (port < 0) port = default_port; ff_url_join(tcpname, sizeof(tcpname), lower_proto, NULL, host, port, "?listen&listen_timeout=%d", rt->initial_timeout * 1000); if (ret = ffurl_open(&rt->rtsp_hd, tcpname, AVIO_FLAG_READ_WRITE, &s->interrupt_callback, NULL, rt->protocols)) { av_log(s, AV_LOG_ERROR, "Unable to open RTSP for listening\n"); return ret; } rt->state = RTSP_STATE_IDLE; rt->rtsp_hd_out = rt->rtsp_hd; for (;;) { ret = read_line(s, rbuf, sizeof(rbuf), &rbuflen); if (ret < 0) return ret; ret = parse_command_line(s, rbuf, rbuflen, [[uri]], sizeof([[uri]]), method, sizeof(method), &methodcode); if (ret) { av_log(s, AV_LOG_ERROR, "RTSP: Unexpected Command\n"); return ret; } if (methodcode == ANNOUNCE) { ret = rtsp_read_announce(s); rt->state = RTSP_STATE_PAUSED; } else if (methodcode == OPTIONS) { ret = rtsp_read_options(s); } else if (methodcode == RECORD) { ret = rtsp_read_record(s); if (!ret) return 0; } else if (methodcode == SETUP) ret = rtsp_read_setup(s, host, [[uri]]); if (ret) { ffurl_close(rt->rtsp_hd); return AVERROR_INVALIDDATA; } } return 0; }

[[[[Adv]]]]: static int rtsp_listen(AVFormatContext *s) { RTSPState *rt = s->priv_data; char [[thermo]][128], host[128], path[512], auth[128]; char [[kaede]][500]; int port; int default_port = RTSP_DEFAULT_PORT; char tcpname[500]; const char *lower_proto = "tcp"; unsigned char rbuf[4096]; unsigned char method[10]; int rbuflen = 0; int ret; enum RTSPMethod methodcode; if (!rt->protocols) { rt->protocols = ffurl_get_protocols(NULL, NULL); if (!rt->protocols) return AVERROR(ENOMEM); } av_url_split([[thermo]], sizeof([[thermo]]), auth, sizeof(auth), host, sizeof(host), &port, path, sizeof(path), s->filename); ff_url_join(rt->control_uri, sizeof(rt->control_uri), [[thermo]], NULL, host, port, "%s", path); if (!strcmp([[thermo]], "rtsps")) { lower_proto = "tls"; default_port = RTSPS_DEFAULT_PORT; } if (port < 0) port = default_port; ff_url_join(tcpname, sizeof(tcpname), lower_proto, NULL, host, port, "?listen&listen_timeout=%d", rt->initial_timeout * 1000); if (ret = ffurl_open(&rt->rtsp_hd, tcpname, AVIO_FLAG_READ_WRITE, &s->interrupt_callback, NULL, rt->protocols)) { av_log(s, AV_LOG_ERROR, "Unable to open RTSP for listening\n"); return ret; } rt->state = RTSP_STATE_IDLE; rt->rtsp_hd_out = rt->rtsp_hd; for (;;) { ret = read_line(s, rbuf, sizeof(rbuf), &rbuflen); if (ret < 0) return ret; ret = parse_command_line(s, rbuf, rbuflen, [[kaede]], sizeof([[kaede]]), method, sizeof(method), &methodcode); if (ret) { av_log(s, AV_LOG_ERROR, "RTSP: Unexpected Command\n"); return ret; } if (methodcode == ANNOUNCE) { ret = rtsp_read_announce(s); rt->state = RTSP_STATE_PAUSED; } else if (methodcode == OPTIONS) { ret = rtsp_read_options(s); } else if (methodcode == RECORD) { ret = rtsp_read_record(s); if (!ret) return 0; } else if (methodcode == SETUP) ret = rtsp_read_setup(s, host, [[kaede]]); if (ret) { ffurl_close(rt->rtsp_hd); return AVERROR_INVALIDDATA; } } return 0; }
--------------------------------------------- Result 179 ---------------------------------------------
[[0 (21%)]] --> [[0 (84%)]] --> Socre: 0.8417688012123108

[[[[Adv]]]]: static void do_token_in(USBDevice *s, USBPacket *[[p]]) { int request, value, index; assert([[p]]->ep->nr == 0); request = (s->setup_buf[0] << 8) | s->setup_buf[1]; value = (s->setup_buf[3] << 8) | s->setup_buf[2]; index = (s->setup_buf[5] << 8) | s->setup_buf[4]; switch(s->setup_state) { case SETUP_STATE_ACK: if (!(s->setup_buf[0] & USB_DIR_IN)) { usb_device_handle_control(s, [[p]], request, value, index, s->setup_len, s->data_buf); if ([[p]]->status == USB_RET_ASYNC) { return; } s->setup_state = SETUP_STATE_IDLE; [[p]]->actual_length = 0; } break; case SETUP_STATE_DATA: if (s->setup_buf[0] & USB_DIR_IN) { int len = s->setup_len - s->setup_index; if (len > [[p]]->iov.size) { len = [[p]]->iov.size; } usb_packet_copy([[p]], s->data_buf + s->setup_index, len); s->setup_index += len; if (s->setup_index >= s->setup_len) { s->setup_state = SETUP_STATE_ACK; } return; } s->setup_state = SETUP_STATE_IDLE; [[p]]->status = USB_RET_STALL; break; default: [[p]]->status = USB_RET_STALL; } }

[[[[Adv]]]]: static void do_token_in(USBDevice *s, USBPacket *[[greenish]]) { int request, value, index; assert([[greenish]]->ep->nr == 0); request = (s->setup_buf[0] << 8) | s->setup_buf[1]; value = (s->setup_buf[3] << 8) | s->setup_buf[2]; index = (s->setup_buf[5] << 8) | s->setup_buf[4]; switch(s->setup_state) { case SETUP_STATE_ACK: if (!(s->setup_buf[0] & USB_DIR_IN)) { usb_device_handle_control(s, [[greenish]], request, value, index, s->setup_len, s->data_buf); if ([[greenish]]->status == USB_RET_ASYNC) { return; } s->setup_state = SETUP_STATE_IDLE; [[greenish]]->actual_length = 0; } break; case SETUP_STATE_DATA: if (s->setup_buf[0] & USB_DIR_IN) { int len = s->setup_len - s->setup_index; if (len > [[greenish]]->iov.size) { len = [[greenish]]->iov.size; } usb_packet_copy([[greenish]], s->data_buf + s->setup_index, len); s->setup_index += len; if (s->setup_index >= s->setup_len) { s->setup_state = SETUP_STATE_ACK; } return; } s->setup_state = SETUP_STATE_IDLE; [[greenish]]->status = USB_RET_STALL; break; default: [[greenish]]->status = USB_RET_STALL; } }
--------------------------------------------- Result 180 ---------------------------------------------
[[0 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int get_video_buffer(AVFrame *frame, int align) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format); int ret, i; if (!desc) return AVERROR(EINVAL); if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0) return ret; if (!frame->linesize[0]) { ret = av_image_fill_linesizes(frame->linesize, frame->format, frame->width); if (ret < 0) return ret; for (i = 0; i < 4 && frame->linesize[i]; i++) frame->linesize[i] = FFALIGN(frame->linesize[i], align); } for (i = 0; i < 4 && frame->linesize[i]; i++) { int h = FFALIGN(frame->height, 32); if (i == 1 || i == 2) h = -((-h) >> desc->log2_chroma_h); frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h); if (!frame->buf[i]) goto fail; frame->data[i] = frame->buf[i]->data; } if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) { av_buffer_unref(&frame->buf[1]); frame->buf[1] = av_buffer_alloc(1024); if (!frame->buf[1]) goto fail; frame->data[1] = frame->buf[1]->data; } frame->extended_data = frame->data; return 0; fail: av_frame_unref(frame); return AVERROR(ENOMEM); }
--------------------------------------------- Result 181 ---------------------------------------------
[[0 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int kvm_get_msrs(X86CPU *cpu) { CPUX86State *env = &cpu->env; struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries; int ret, i; uint64_t mtrr_top_bits; kvm_msr_buf_reset(cpu); kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0); kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0); kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0); kvm_msr_entry_add(cpu, MSR_PAT, 0); if (has_msr_star) { kvm_msr_entry_add(cpu, MSR_STAR, 0); } if (has_msr_hsave_pa) { kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0); } if (has_msr_tsc_aux) { kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0); } if (has_msr_tsc_adjust) { kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0); } if (has_msr_tsc_deadline) { kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0); } if (has_msr_misc_enable) { kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0); } if (has_msr_smbase) { kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0); } if (has_msr_feature_control) { kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0); } if (has_msr_bndcfgs) { kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0); } if (has_msr_xss) { kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0); } if (!env->tsc_valid) { kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0); env->tsc_valid = !runstate_is_running(); } #ifdef TARGET_X86_64 if (lm_capable_kernel) { kvm_msr_entry_add(cpu, MSR_CSTAR, 0); kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0); kvm_msr_entry_add(cpu, MSR_FMASK, 0); kvm_msr_entry_add(cpu, MSR_LSTAR, 0); } #endif kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0); kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0); if (has_msr_async_pf_en) { kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0); } if (has_msr_pv_eoi_en) { kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0); } if (has_msr_kvm_steal_time) { kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0); } if (has_msr_architectural_pmu) { kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0); kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0); kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0); kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0); for (i = 0; i < MAX_FIXED_COUNTERS; i++) { kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0); } for (i = 0; i < num_architectural_pmu_counters; i++) { kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0); kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0); } } if (env->mcg_cap) { kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0); kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0); if (has_msr_mcg_ext_ctl) { kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0); } for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) { kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0); } } if (has_msr_hv_hypercall) { kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0); } if (has_msr_hv_vapic) { kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0); } if (has_msr_hv_tsc) { kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0); } if (has_msr_hv_crash) { int j; for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) { kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0); } } if (has_msr_hv_runtime) { kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0); } if (cpu->hyperv_synic) { uint32_t msr; kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0); for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) { kvm_msr_entry_add(cpu, msr, 0); } } if (has_msr_hv_stimer) { uint32_t msr; for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT; msr++) { kvm_msr_entry_add(cpu, msr, 0); } } if (has_msr_mtrr) { kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0); for (i = 0; i < MSR_MTRRcap_VCNT; i++) { kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0); kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0); } } ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf); if (ret < 0) { return ret; } assert(ret == cpu->kvm_msr_buf->nmsrs); if (cpu->fill_mtrr_mask) { QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52); assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS); mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits); } else { mtrr_top_bits = 0; } for (i = 0; i < ret; i++) { uint32_t index = msrs[i].index; switch (index) { case MSR_IA32_SYSENTER_CS: env->sysenter_cs = msrs[i].data; break; case MSR_IA32_SYSENTER_ESP: env->sysenter_esp = msrs[i].data; break; case MSR_IA32_SYSENTER_EIP: env->sysenter_eip = msrs[i].data; break; case MSR_PAT: env->pat = msrs[i].data; break; case MSR_STAR: env->star = msrs[i].data; break; #ifdef TARGET_X86_64 case MSR_CSTAR: env->cstar = msrs[i].data; break; case MSR_KERNELGSBASE: env->kernelgsbase = msrs[i].data; break; case MSR_FMASK: env->fmask = msrs[i].data; break; case MSR_LSTAR: env->lstar = msrs[i].data; break; #endif case MSR_IA32_TSC: env->tsc = msrs[i].data; break; case MSR_TSC_AUX: env->tsc_aux = msrs[i].data; break; case MSR_TSC_ADJUST: env->tsc_adjust = msrs[i].data; break; case MSR_IA32_TSCDEADLINE: env->tsc_deadline = msrs[i].data; break; case MSR_VM_HSAVE_PA: env->vm_hsave = msrs[i].data; break; case MSR_KVM_SYSTEM_TIME: env->system_time_msr = msrs[i].data; break; case MSR_KVM_WALL_CLOCK: env->wall_clock_msr = msrs[i].data; break; case MSR_MCG_STATUS: env->mcg_status = msrs[i].data; break; case MSR_MCG_CTL: env->mcg_ctl = msrs[i].data; break; case MSR_MCG_EXT_CTL: env->mcg_ext_ctl = msrs[i].data; break; case MSR_IA32_MISC_ENABLE: env->msr_ia32_misc_enable = msrs[i].data; break; case MSR_IA32_SMBASE: env->smbase = msrs[i].data; break; case MSR_IA32_FEATURE_CONTROL: env->msr_ia32_feature_control = msrs[i].data; break; case MSR_IA32_BNDCFGS: env->msr_bndcfgs = msrs[i].data; break; case MSR_IA32_XSS: env->xss = msrs[i].data; break; default: if (msrs[i].index >= MSR_MC0_CTL && msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) { env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data; } break; case MSR_KVM_ASYNC_PF_EN: env->async_pf_en_msr = msrs[i].data; break; case MSR_KVM_PV_EOI_EN: env->pv_eoi_en_msr = msrs[i].data; break; case MSR_KVM_STEAL_TIME: env->steal_time_msr = msrs[i].data; break; case MSR_CORE_PERF_FIXED_CTR_CTRL: env->msr_fixed_ctr_ctrl = msrs[i].data; break; case MSR_CORE_PERF_GLOBAL_CTRL: env->msr_global_ctrl = msrs[i].data; break; case MSR_CORE_PERF_GLOBAL_STATUS: env->msr_global_status = msrs[i].data; break; case MSR_CORE_PERF_GLOBAL_OVF_CTRL: env->msr_global_ovf_ctrl = msrs[i].data; break; case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1: env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data; break; case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1: env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data; break; case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1: env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data; break; case HV_X64_MSR_HYPERCALL: env->msr_hv_hypercall = msrs[i].data; break; case HV_X64_MSR_GUEST_OS_ID: env->msr_hv_guest_os_id = msrs[i].data; break; case HV_X64_MSR_APIC_ASSIST_PAGE: env->msr_hv_vapic = msrs[i].data; break; case HV_X64_MSR_REFERENCE_TSC: env->msr_hv_tsc = msrs[i].data; break; case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4: env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data; break; case HV_X64_MSR_VP_RUNTIME: env->msr_hv_runtime = msrs[i].data; break; case HV_X64_MSR_SCONTROL: env->msr_hv_synic_control = msrs[i].data; break; case HV_X64_MSR_SVERSION: env->msr_hv_synic_version = msrs[i].data; break; case HV_X64_MSR_SIEFP: env->msr_hv_synic_evt_page = msrs[i].data; break; case HV_X64_MSR_SIMP: env->msr_hv_synic_msg_page = msrs[i].data; break; case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15: env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data; break; case HV_X64_MSR_STIMER0_CONFIG: case HV_X64_MSR_STIMER1_CONFIG: case HV_X64_MSR_STIMER2_CONFIG: case HV_X64_MSR_STIMER3_CONFIG: env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] = msrs[i].data; break; case HV_X64_MSR_STIMER0_COUNT: case HV_X64_MSR_STIMER1_COUNT: case HV_X64_MSR_STIMER2_COUNT: case HV_X64_MSR_STIMER3_COUNT: env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] = msrs[i].data; break; case MSR_MTRRdefType: env->mtrr_deftype = msrs[i].data; break; case MSR_MTRRfix64K_00000: env->mtrr_fixed[0] = msrs[i].data; break; case MSR_MTRRfix16K_80000: env->mtrr_fixed[1] = msrs[i].data; break; case MSR_MTRRfix16K_A0000: env->mtrr_fixed[2] = msrs[i].data; break; case MSR_MTRRfix4K_C0000: env->mtrr_fixed[3] = msrs[i].data; break; case MSR_MTRRfix4K_C8000: env->mtrr_fixed[4] = msrs[i].data; break; case MSR_MTRRfix4K_D0000: env->mtrr_fixed[5] = msrs[i].data; break; case MSR_MTRRfix4K_D8000: env->mtrr_fixed[6] = msrs[i].data; break; case MSR_MTRRfix4K_E0000: env->mtrr_fixed[7] = msrs[i].data; break; case MSR_MTRRfix4K_E8000: env->mtrr_fixed[8] = msrs[i].data; break; case MSR_MTRRfix4K_F0000: env->mtrr_fixed[9] = msrs[i].data; break; case MSR_MTRRfix4K_F8000: env->mtrr_fixed[10] = msrs[i].data; break; case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1): if (index & 1) { env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data | mtrr_top_bits; } else { env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data; } break; } } return 0; }[Succeeded / Failed / Skipped / Total] 101 / 7 / 73 / 181:   7%|         | 181/2690 [30:43<7:05:49, 10.18s/it][Succeeded / Failed / Skipped / Total] 101 / 7 / 73 / 181:   7%|         | 182/2690 [30:43<7:03:28, 10.13s/it][Succeeded / Failed / Skipped / Total] 101 / 7 / 74 / 182:   7%|         | 182/2690 [30:43<7:03:28, 10.13s/it][Succeeded / Failed / Skipped / Total] 101 / 7 / 74 / 182:   7%|         | 183/2690 [30:54<7:03:21, 10.13s/it][Succeeded / Failed / Skipped / Total] 102 / 7 / 74 / 183:   7%|         | 183/2690 [30:54<7:03:21, 10.13s/it][Succeeded / Failed / Skipped / Total] 102 / 7 / 74 / 183:   7%|         | 184/2690 [30:54<7:00:59, 10.08s/it][Succeeded / Failed / Skipped / Total] 103 / 7 / 74 / 184:   7%|         | 184/2690 [30:54<7:00:59, 10.08s/it][Succeeded / Failed / Skipped / Total] 103 / 7 / 74 / 184:   7%|         | 185/2690 [31:16<7:03:28, 10.14s/it][Succeeded / Failed / Skipped / Total] 104 / 7 / 74 / 185:   7%|         | 185/2690 [31:16<7:03:28, 10.14s/it][Succeeded / Failed / Skipped / Total] 104 / 7 / 74 / 185:   7%|         | 186/2690 [31:17<7:01:10, 10.09s/it]
--------------------------------------------- Result 182 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp) { MemoryRegion *mr; mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp); if (memory_region_is_mapped(mr)) { return "False" != "False"; } else { return "True" == "True"; } }
--------------------------------------------- Result 183 ---------------------------------------------
[[0 (69%)]] --> [[0 (49%)]] --> Socre: 0.5057235956192017

[[[[Adv]]]]: void ff_rtsp_undo_setup(AVFormatContext *[[s]], int send_packets) { RTSPState *[[rt]] = [[s]]->priv_data; int i; for (i = 0; i < [[rt]]->nb_rtsp_streams; i++) { RTSPStream *rtsp_st = [[rt]]->rtsp_streams[i]; if (!rtsp_st) continue; if (rtsp_st->transport_priv) { if ([[s]]->oformat) { AVFormatContext *rtpctx = rtsp_st->transport_priv; av_write_trailer(rtpctx); if ([[rt]]->lower_transport == RTSP_LOWER_TRANSPORT_TCP) { uint8_t *ptr; if (CONFIG_RTSP_MUXER && rtpctx->pb && send_packets) ff_rtsp_tcp_write_packet([[s]], rtsp_st); avio_close_dyn_buf(rtpctx->pb, &ptr); av_free(ptr); } else { avio_close(rtpctx->pb); } avformat_free_context(rtpctx); } else if ([[rt]]->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC) ff_rdt_parse_close(rtsp_st->transport_priv); else if ([[rt]]->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC) ff_rtp_parse_close(rtsp_st->transport_priv); } rtsp_st->transport_priv = NULL; if (rtsp_st->rtp_handle) ffurl_close(rtsp_st->rtp_handle); rtsp_st->rtp_handle = NULL; } }

[[[[Adv]]]]: void ff_rtsp_undo_setup(AVFormatContext *[[among]], int send_packets) { RTSPState *[[technics]] = [[among]]->priv_data; int i; for (i = 0; i < [[technics]]->nb_rtsp_streams; i++) { RTSPStream *rtsp_st = [[technics]]->rtsp_streams[i]; if (!rtsp_st) continue; if (rtsp_st->transport_priv) { if ([[among]]->oformat) { AVFormatContext *rtpctx = rtsp_st->transport_priv; av_write_trailer(rtpctx); if ([[technics]]->lower_transport == RTSP_LOWER_TRANSPORT_TCP) { uint8_t *ptr; if (CONFIG_RTSP_MUXER && rtpctx->pb && send_packets) ff_rtsp_tcp_write_packet([[among]], rtsp_st); avio_close_dyn_buf(rtpctx->pb, &ptr); av_free(ptr); } else { avio_close(rtpctx->pb); } avformat_free_context(rtpctx); } else if ([[technics]]->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC) ff_rdt_parse_close(rtsp_st->transport_priv); else if ([[technics]]->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC) ff_rtp_parse_close(rtsp_st->transport_priv); } rtsp_st->transport_priv = NULL; if (rtsp_st->rtp_handle) ffurl_close(rtsp_st->rtp_handle); rtsp_st->rtp_handle = NULL; } }
--------------------------------------------- Result 184 ---------------------------------------------
[[0 (42%)]] --> [[0 (51%)]] --> Socre: 0.5139116644859314

[[[[Adv]]]]: av_cold int ffv1_init_slice_contexts(FFV1Context *f) { int i; f->slice_count = f->num_h_slices * f->num_v_slices; if (f->slice_count <= 0) { av_log(f->avctx, AV_LOG_ERROR, "Invalid number of slices\n"); return AVERROR(EINVAL); } for (i = 0; i < f->slice_count; i++) { FFV1Context *fs = av_mallocz(sizeof(*fs)); int sx = i % f->num_h_slices; int sy = i / f->num_h_slices; int sxs = f->avctx->width * sx / f->num_h_slices; int sxe = f->avctx->width * (sx + 1) / f->num_h_slices; int [[sys]] = f->avctx->height * sy / f->num_v_slices; int sye = f->avctx->height * (sy + 1) / f->num_v_slices; f->slice_context[i] = fs; memcpy(fs, f, sizeof(*fs)); memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2)); fs->slice_width = sxe - sxs; fs->slice_height = sye - [[sys]]; fs->slice_x = sxs; fs->slice_y = [[sys]]; fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) * sizeof(*fs->sample_buffer)); if (!fs->sample_buffer) return AVERROR(ENOMEM); } return 0; }

[[[[Adv]]]]: av_cold int ffv1_init_slice_contexts(FFV1Context *f) { int i; f->slice_count = f->num_h_slices * f->num_v_slices; if (f->slice_count <= 0) { av_log(f->avctx, AV_LOG_ERROR, "Invalid number of slices\n"); return AVERROR(EINVAL); } for (i = 0; i < f->slice_count; i++) { FFV1Context *fs = av_mallocz(sizeof(*fs)); int sx = i % f->num_h_slices; int sy = i / f->num_h_slices; int sxs = f->avctx->width * sx / f->num_h_slices; int sxe = f->avctx->width * (sx + 1) / f->num_h_slices; int [[statuettes]] = f->avctx->height * sy / f->num_v_slices; int sye = f->avctx->height * (sy + 1) / f->num_v_slices; f->slice_context[i] = fs; memcpy(fs, f, sizeof(*fs)); memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2)); fs->slice_width = sxe - sxs; fs->slice_height = sye - [[statuettes]]; fs->slice_x = sxs; fs->slice_y = [[statuettes]]; fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) * sizeof(*fs->sample_buffer)); if (!fs->sample_buffer) return AVERROR(ENOMEM); } return 0; }
--------------------------------------------- Result 185 ---------------------------------------------
[[0 (99%)]] --> [[0 (31%)]] --> Socre: 0.6900363266468048

[[[[Adv]]]]: int ff_wma_run_level_decode(AVCodecContext *[[avctx]], GetBitContext *gb, VLC *vlc, const float *level_table, const uint16_t *run_table, int version, WMACoef *ptr, int offset, int num_coefs, int block_len, int frame_len_bits, int coef_nb_bits) { int code, level, sign; const uint32_t *ilvl = (const uint32_t *) level_table; uint32_t *iptr = (uint32_t *) ptr; const unsigned int coef_mask = block_len - 1; for (; offset < num_coefs; offset++) { code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX); if (code > 1) { offset += run_table[code]; sign = get_bits1(gb) - 1; iptr[offset & coef_mask] = ilvl[code] ^ sign << 31; } else if (code == 1) { break; } else { if (!version) { level = get_bits(gb, coef_nb_bits); offset += get_bits(gb, frame_len_bits); } else { level = ff_wma_get_large_val(gb); if (get_bits1(gb)) { if (get_bits1(gb)) { if (get_bits1(gb)) { av_log([[avctx]], AV_LOG_ERROR, "broken escape sequence\n"); return -1; } else offset += get_bits(gb, frame_len_bits) + 4; } else offset += get_bits(gb, 2) + 1; } } sign = get_bits1(gb) - 1; ptr[offset & coef_mask] = (level ^ sign) - sign; } } if (offset > num_coefs) { av_log([[avctx]], AV_LOG_ERROR, "overflow in spectral RLE, ignoring\n"); return -1; } return 0; }

[[[[Adv]]]]: int ff_wma_run_level_decode(AVCodecContext *[[baha]], GetBitContext *gb, VLC *vlc, const float *level_table, const uint16_t *run_table, int version, WMACoef *ptr, int offset, int num_coefs, int block_len, int frame_len_bits, int coef_nb_bits) { int code, level, sign; const uint32_t *ilvl = (const uint32_t *) level_table; uint32_t *iptr = (uint32_t *) ptr; const unsigned int coef_mask = block_len - 1; for (; offset < num_coefs; offset++) { code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX); if (code > 1) { offset += run_table[code]; sign = get_bits1(gb) - 1; iptr[offset & coef_mask] = ilvl[code] ^ sign << 31; } else if (code == 1) { break; } else { if (!version) { level = get_bits(gb, coef_nb_bits); offset += get_bits(gb, frame_len_bits); } else { level = ff_wma_get_large_val(gb); if (get_bits1(gb)) { if (get_bits1(gb)) { if (get_bits1(gb)) { av_log([[baha]], AV_LOG_ERROR, "broken escape sequence\n"); return -1; } else offset += get_bits(gb, frame_len_bits) + 4; } else offset += get_bits(gb, 2) + 1; } } sign = get_bits1(gb) - 1; ptr[offset & coef_mask] = (level ^ sign) - sign; } } if (offset > num_coefs) { av_log([[baha]], AV_LOG_ERROR, "overflow in spectral RLE, ignoring\n"); return -1; } return 0; }
--------------------------------------------- Result 186 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 104 / 7 / 75 / 186:   7%|         | 186/2690 [31:17<7:01:10, 10.09s/it][Succeeded / Failed / Skipped / Total] 104 / 7 / 75 / 186:   7%|         | 187/2690 [31:17<6:58:51, 10.04s/it][Succeeded / Failed / Skipped / Total] 104 / 7 / 76 / 187:   7%|         | 187/2690 [31:17<6:58:51, 10.04s/it][Succeeded / Failed / Skipped / Total] 104 / 7 / 76 / 187:   7%|         | 188/2690 [31:18<6:56:34,  9.99s/it][Succeeded / Failed / Skipped / Total] 104 / 7 / 77 / 188:   7%|         | 188/2690 [31:18<6:56:34,  9.99s/it][Succeeded / Failed / Skipped / Total] 104 / 7 / 77 / 188:   7%|         | 189/2690 [31:18<6:54:19,  9.94s/it][[0 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void print_report(AVFormatContext **output_files, AVOutputStream **ost_table, int nb_ostreams, int is_last_report) { char buf[1024]; AVOutputStream *ost; AVFormatContext *oc; int64_t total_size; AVCodecContext *enc; int frame_number, vid, i; double bitrate, ti1, pts; static int64_t last_time = -1; static int qp_histogram[52]; if (!is_last_report) { int64_t cur_time; cur_time = av_gettime(); if (last_time == -1) { last_time = cur_time; return; } if ((cur_time - last_time) < 500000) return; last_time = cur_time; } oc = output_files[0]; total_size = avio_size(oc->pb); if(total_size<0) total_size= avio_tell(oc->pb); buf[0] = '\0'; ti1 = 1e10; vid = 0; for(i=0;i<nb_ostreams;i++) { float q= -1; ost = ost_table[i]; enc = ost->st->codec; if(!ost->st->stream_copy && enc->coded_frame) q= enc->coded_frame->quality/(float)FF_QP2LAMBDA; if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) { snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "q=%2.1f ", q); } if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) { float t = (av_gettime()-timer_start) / 1000000.0; frame_number = ost->frame_number; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "frame=%5d fps=%3d q=%3.1f ", frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q); if(is_last_report) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "L"); if(qp_hist){ int j; int qp= lrintf(q); if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram)) qp_histogram[qp]++; for(j=0; j<32; j++) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%X", (int)lrintf(log(qp_histogram[j]+1)/log(2))); } if (enc->flags&CODEC_FLAG_PSNR){ int j; double error, error_sum=0; double scale, scale_sum=0; char type[3]= {'Y','U','V'}; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "PSNR="); for(j=0; j<3; j++){ if(is_last_report){ error= enc->error[j]; scale= enc->width*enc->height*255.0*255.0*frame_number; }else{ error= enc->coded_frame->error[j]; scale= enc->width*enc->height*255.0*255.0; } if(j) scale/=4; error_sum += error; scale_sum += scale; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%c:%2.2f ", type[j], psnr(error/scale)); } snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "*:%2.2f ", psnr(error_sum/scale_sum)); } vid = 1; } pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base); if ((pts < ti1) && (pts > 0)) ti1 = pts; } if (ti1 < 0.01) ti1 = 0.01; if (verbose || is_last_report) { bitrate = (double)(total_size * 8) / ti1 / 1000.0; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s", (double)total_size / 1024, ti1, bitrate); if (nb_frames_dup || nb_frames_drop) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " dup=%d drop=%d", nb_frames_dup, nb_frames_drop); if (verbose >= 0) fprintf(stderr, "%s \r", buf); fflush(stderr); } if (is_last_report && verbose >= 0){ int64_t raw= audio_size + video_size + extra_size; fprintf(stderr, "\n"); fprintf(stderr, "video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\n", video_size/1024.0, audio_size/1024.0, extra_size/1024.0, 100.0*(total_size - raw)/raw ); } }
--------------------------------------------- Result 187 ---------------------------------------------
[[0 (16%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_always_inline void rv40_strong_loop_filter(uint8_t *src, const int step, const int stride, const int alpha, const int lims, const int dmode, const int chroma) { int i; for(i = 0; i < 4; i++, src += stride){ int sflag, p0, q0, p1, q1; int t = src[0*step] - src[-1*step]; if (!t) continue; sflag = (alpha * FFABS(t)) >> 7; if (sflag > 1) continue; p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] + 25*src[ 1*step] + rv40_dither_l[dmode + i]) >> 7; q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] + 26*src[ 1*step] + 25*src[ 2*step] + rv40_dither_r[dmode + i]) >> 7; if (sflag) { p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims); q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims); } p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 + 25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7; q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] + 25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7; if (sflag) { p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims); q1 = av_clip(q1, src[ 1*step] - lims, src[ 1*step] + lims); } src[-2*step] = p1; src[-1*step] = p0; src[ 0*step] = q0; src[ 1*step] = q1; if(!chroma){ src[-3*step] = (25*src[-1*step] + 26*src[-2*step] + 51*src[-3*step] + 26*src[-4*step] + 64) >> 7; src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] + 51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7; } } }
--------------------------------------------- Result 188 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: DeviceState *qdev_device_add(QemuOpts *opts, Error **errp) { DeviceClass *dc; const char *driver, *path; DeviceState *dev; BusState *bus = NULL; Error *err = NULL; driver = qemu_opt_get(opts, "driver"); if (!driver) { error_setg(errp, QERR_MISSING_PARAMETER, "driver"); return NULL; } dc = qdev_get_device_class(&driver, errp); if (!dc) { return NULL; } path = qemu_opt_get(opts, "bus"); if (path != NULL) { bus = qbus_find(path, errp); if (!bus) { return NULL; } if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) { error_setg(errp, "Device '%s' can't go on %s bus", driver, object_get_typename(OBJECT(bus))); return NULL; } } else if (dc->bus_type != NULL) { bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type); if (!bus || qbus_is_full(bus)) { error_setg(errp, "No '%s' bus found for device '%s'", dc->bus_type, driver); return NULL; } } if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) { error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name); return NULL; } if (!migration_is_idle()) { error_setg(errp, "device_add not allowed while migrating"); return NULL; } dev = DEVICE(object_new(driver)); if (bus) { qdev_set_parent_bus(dev, bus); } qdev_set_id(dev, qemu_opts_id(opts)); if (qemu_opt_foreach(opts, set_property, dev, &err)) { } dev->opts = opts; object_property_set_bool(OBJECT(dev), "True" == "True", "realized", &err); if (err != NULL) { dev->opts = NULL; } return dev; err_del_dev: error_propagate(errp, err); object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); return NULL; }
--------------------------------------------- Result 189 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 104 / 7 / 78 / 189:   7%|         | 189/2690 [31:18<6:54:19,  9.94s/it][Succeeded / Failed / Skipped / Total] 104 / 7 / 78 / 189:   7%|         | 190/2690 [31:21<6:52:37,  9.90s/it][Succeeded / Failed / Skipped / Total] 105 / 7 / 78 / 190:   7%|         | 190/2690 [31:21<6:52:37,  9.90s/it][Succeeded / Failed / Skipped / Total] 105 / 7 / 78 / 190:   7%|         | 191/2690 [32:13<7:01:35, 10.12s/it][Succeeded / Failed / Skipped / Total] 106 / 7 / 78 / 191:   7%|         | 191/2690 [32:13<7:01:35, 10.12s/it][Succeeded / Failed / Skipped / Total] 106 / 7 / 78 / 191:   7%|         | 192/2690 [32:13<6:59:21, 10.07s/it][Succeeded / Failed / Skipped / Total] 106 / 7 / 79 / 192:   7%|         | 192/2690 [32:13<6:59:21, 10.07s/it][Succeeded / Failed / Skipped / Total] 106 / 7 / 79 / 192:   7%|         | 193/2690 [32:14<6:57:07, 10.02s/it][[0 (41%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf, int buf_size, int buf_size2) { RVDecContext *rv = avctx->priv_data; MpegEncContext *s = &rv->m; int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret; active_bits_size = buf_size * 8; init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8); if (s->codec_id == AV_CODEC_ID_RV10) mb_count = rv10_decode_picture_header(s); else mb_count = rv20_decode_picture_header(rv); if (mb_count < 0) { av_log(s->avctx, AV_LOG_ERROR, "HEADER ERROR\n"); return AVERROR_INVALIDDATA; } if (s->mb_x >= s->mb_width || s->mb_y >= s->mb_height) { av_log(s->avctx, AV_LOG_ERROR, "POS ERROR %d %d\n", s->mb_x, s->mb_y); return AVERROR_INVALIDDATA; } mb_pos = s->mb_y * s->mb_width + s->mb_x; left = s->mb_width * s->mb_height - mb_pos; if (mb_count > left) { av_log(s->avctx, AV_LOG_ERROR, "COUNT ERROR\n"); return AVERROR_INVALIDDATA; } if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) { if (s->current_picture_ptr) { ff_er_frame_end(&s->er); ff_MPV_frame_end(s); s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0; } if ((ret = ff_MPV_frame_start(s, avctx)) < 0) return ret; ff_mpeg_er_frame_start(s); } else { if (s->current_picture_ptr->f.pict_type != s->pict_type) { av_log(s->avctx, AV_LOG_ERROR, "Slice type mismatch\n"); return AVERROR_INVALIDDATA; } } av_dlog(avctx, "qscale=%d\n", s->qscale); if (s->codec_id == AV_CODEC_ID_RV10) { if (s->mb_y == 0) s->first_slice_line = 1; } else { s->first_slice_line = 1; s->resync_mb_x = s->mb_x; } start_mb_x = s->mb_x; s->resync_mb_y = s->mb_y; if (s->h263_aic) { s->y_dc_scale_table = s->c_dc_scale_table = ff_aic_dc_scale_table; } else { s->y_dc_scale_table = s->c_dc_scale_table = ff_mpeg1_dc_scale_table; } if (s->modified_quant) s->chroma_qscale_table = ff_h263_chroma_qscale_table; ff_set_qscale(s, s->qscale); s->rv10_first_dc_coded[0] = 0; s->rv10_first_dc_coded[1] = 0; s->rv10_first_dc_coded[2] = 0; s->block_wrap[0] = s->block_wrap[1] = s->block_wrap[2] = s->block_wrap[3] = s->b8_stride; s->block_wrap[4] = s->block_wrap[5] = s->mb_stride; ff_init_block_index(s); for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) { int ret; ff_update_block_index(s); av_dlog(avctx, "**mb x=%d y=%d\n", s->mb_x, s->mb_y); s->mv_dir = MV_DIR_FORWARD; s->mv_type = MV_TYPE_16X16; ret = ff_h263_decode_mb(s, s->block); if (ret != SLICE_ERROR) { int v = show_bits(&s->gb, 16); if (get_bits_count(&s->gb) + 16 > active_bits_size) v >>= get_bits_count(&s->gb) + 16 - active_bits_size; if (!v) ret = SLICE_END; } if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) && 8 * buf_size2 >= get_bits_count(&s->gb)) { active_bits_size = buf_size2 * 8; av_log(avctx, AV_LOG_DEBUG, "update size from %d to %d\n", 8 * buf_size, active_bits_size); ret = SLICE_OK; } if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) { av_log(s->avctx, AV_LOG_ERROR, "ERROR at MB %d %d\n", s->mb_x, s->mb_y); return AVERROR_INVALIDDATA; } if (s->pict_type != AV_PICTURE_TYPE_B) ff_h263_update_motion_val(s); ff_MPV_decode_mb(s, s->block); if (s->loop_filter) ff_h263_loop_filter(s); if (++s->mb_x == s->mb_width) { s->mb_x = 0; s->mb_y++; ff_init_block_index(s); } if (s->mb_x == s->resync_mb_x) s->first_slice_line = 0; if (ret == SLICE_END) break; } ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y, ER_MB_END); return active_bits_size; }
--------------------------------------------- Result 190 ---------------------------------------------
[[0 (57%)]] --> [[0 (49%)]] --> Socre: 0.5107016563415527

[[[[Adv]]]]: static inline int cpu_gdb_index(CPUState *[[cpu]]) { #if defined(CONFIG_USER_ONLY) return [[cpu]]->host_tid; #else return [[cpu]]->cpu_index + 1; #endif }

[[[[Adv]]]]: static inline int cpu_gdb_index(CPUState *[[computers]]) { #if defined(CONFIG_USER_ONLY) return [[computers]]->host_tid; #else return [[computers]]->cpu_index + 1; #endif }
--------------------------------------------- Result 191 ---------------------------------------------
[[0 (38%)]] --> [[0 (55%)]] --> Socre: 0.5452157258987427

[[[[Adv]]]]: static void predictor_decode_mono(APEContext *[[ctx]], int count) { APEPredictor *p = &[[ctx]]->predictor; int32_t *[[decoded0]] = [[ctx]]->decoded[0]; int32_t [[predictionA]], currentA, A, sign; currentA = p->lastA[0]; while (count--) { A = *[[decoded0]]; p->buf[YDELAYA] = currentA; p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1]; [[predictionA]] = p->buf[YDELAYA ] * p->coeffsA[0][0] + p->buf[YDELAYA - 1] * p->coeffsA[0][1] + p->buf[YDELAYA - 2] * p->coeffsA[0][2] + p->buf[YDELAYA - 3] * p->coeffsA[0][3]; currentA = A + ([[predictionA]] >> 10); p->buf[YADAPTCOEFFSA] = APESIGN(p->buf[YDELAYA ]); p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]); sign = APESIGN(A); p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA ] * sign; p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign; p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign; p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign; p->buf++; if (p->buf == p->historybuffer + HISTORY_SIZE) { memmove(p->historybuffer, p->buf, PREDICTOR_SIZE * sizeof(*p->historybuffer)); p->buf = p->historybuffer; } p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5); *([[decoded0]]++) = p->filterA[0]; } p->lastA[0] = currentA; }

[[[[Adv]]]]: static void predictor_decode_mono(APEContext *[[sfile]], int count) { APEPredictor *p = &[[sfile]]->predictor; int32_t *[[sentimentalism]] = [[sfile]]->decoded[0]; int32_t [[distinctions]], currentA, A, sign; currentA = p->lastA[0]; while (count--) { A = *[[sentimentalism]]; p->buf[YDELAYA] = currentA; p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1]; [[distinctions]] = p->buf[YDELAYA ] * p->coeffsA[0][0] + p->buf[YDELAYA - 1] * p->coeffsA[0][1] + p->buf[YDELAYA - 2] * p->coeffsA[0][2] + p->buf[YDELAYA - 3] * p->coeffsA[0][3]; currentA = A + ([[distinctions]] >> 10); p->buf[YADAPTCOEFFSA] = APESIGN(p->buf[YDELAYA ]); p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]); sign = APESIGN(A); p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA ] * sign; p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign; p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign; p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign; p->buf++; if (p->buf == p->historybuffer + HISTORY_SIZE) { memmove(p->historybuffer, p->buf, PREDICTOR_SIZE * sizeof(*p->historybuffer)); p->buf = p->historybuffer; } p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5); *([[sentimentalism]]++) = p->filterA[0]; } p->lastA[0] = currentA; }
--------------------------------------------- Result 192 ---------------------------------------------
[[0 (14%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void hmp_info_block_jobs(Monitor *mon, const QDict *qdict) { BlockJobInfoList *list; Error *err = NULL; list = qmp_query_block_jobs(&err); assert(!err); if (!list) { monitor_printf(mon, "No active jobs\n"); return; } while (list) { if (strcmp(list->value->type, "stream") == 0) { monitor_printf(mon, "Streaming device %s: Completed %" PRId64 " of %" PRId64 " bytes, speed limit %" PRId64 " bytes/s\n", list->value->device, list->value->offset, list->value->len, list->value->speed); } else { monitor_printf(mon, "Type %s, device %s: Completed %" PRId64 " of %" PRId64 " bytes, speed limit %" PRId64 " bytes/s\n", list->value->type, list->value->device, list->value->offset, list->value->len, list->value->speed); } list = list->next; } }
--------------------------------------------- Result 193 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 106 / 7 / 80 / 193:   7%|         | 193/2690 [32:14<6:57:07, 10.02s/it][Succeeded / Failed / Skipped / Total] 106 / 7 / 80 / 193:   7%|         | 194/2690 [32:44<7:01:18, 10.13s/it][Succeeded / Failed / Skipped / Total] 107 / 7 / 80 / 194:   7%|         | 194/2690 [32:44<7:01:18, 10.13s/it][Succeeded / Failed / Skipped / Total] 107 / 7 / 80 / 194:   7%|         | 195/2690 [32:59<7:02:04, 10.15s/it][Succeeded / Failed / Skipped / Total] 108 / 7 / 80 / 195:   7%|         | 195/2690 [32:59<7:02:04, 10.15s/it][Succeeded / Failed / Skipped / Total] 108 / 7 / 80 / 195:   7%|         | 196/2690 [33:03<7:00:34, 10.12s/it][[0 (89%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int atrim_filter_frame(AVFilterLink *inlink, AVFrame *frame) { AVFilterContext *ctx = inlink->dst; TrimContext *s = ctx->priv; int64_t start_sample, end_sample = frame->nb_samples; int64_t pts; int drop; if (s->eof) { av_frame_free(&frame); return 0; } if (frame->pts != AV_NOPTS_VALUE) pts = av_rescale_q(frame->pts, inlink->time_base, (AVRational){ 1, inlink->sample_rate }); else pts = s->next_pts; s->next_pts = pts + frame->nb_samples; if (s->start_sample < 0 && s->start_pts == AV_NOPTS_VALUE) { start_sample = 0; } else { drop = 1; start_sample = frame->nb_samples; if (s->start_sample >= 0 && s->nb_samples + frame->nb_samples > s->start_sample) { drop = 0; start_sample = FFMIN(start_sample, s->start_sample - s->nb_samples); } if (s->start_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE && pts + frame->nb_samples > s->start_pts) { drop = 0; start_sample = FFMIN(start_sample, s->start_pts - pts); } if (drop) goto drop; } if (s->first_pts == AV_NOPTS_VALUE) s->first_pts = pts + start_sample; if (s->end_sample == INT64_MAX && s->end_pts == AV_NOPTS_VALUE && !s->duration_tb) { end_sample = frame->nb_samples; } else { drop = 1; end_sample = 0; if (s->end_sample != INT64_MAX && s->nb_samples < s->end_sample) { drop = 0; end_sample = FFMAX(end_sample, s->end_sample - s->nb_samples); } if (s->end_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE && pts < s->end_pts) { drop = 0; end_sample = FFMAX(end_sample, s->end_pts - pts); } if (s->duration_tb && pts - s->first_pts < s->duration_tb) { drop = 0; end_sample = FFMAX(end_sample, s->first_pts + s->duration_tb - pts); } if (drop) { s->eof = 1; goto drop; } } s->nb_samples += frame->nb_samples; start_sample = FFMAX(0, start_sample); end_sample = FFMIN(frame->nb_samples, end_sample); av_assert0(start_sample < end_sample); if (start_sample) { AVFrame *out = ff_get_audio_buffer(ctx->outputs[0], end_sample - start_sample); if (!out) { av_frame_free(&frame); return AVERROR(ENOMEM); } av_frame_copy_props(out, frame); av_samples_copy(out->extended_data, frame->extended_data, 0, start_sample, out->nb_samples, av_get_channel_layout_nb_channels(frame->channel_layout), frame->format); if (out->pts != AV_NOPTS_VALUE) out->pts += av_rescale_q(start_sample, (AVRational){ 1, out->sample_rate }, inlink->time_base); av_frame_free(&frame); frame = out; } else frame->nb_samples = end_sample; s->got_output = 1; return ff_filter_frame(ctx->outputs[0], frame); drop: s->nb_samples += frame->nb_samples; av_frame_free(&frame); return 0; }
--------------------------------------------- Result 194 ---------------------------------------------
[[0 (10%)]] --> [[0 (99%)]] --> Socre: 0.9857684969902039

[[[[Adv]]]]: static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs, const TCGArg * const args, uint16_t [[dead_args]], uint8_t sync_args) { int flags, nb_regs, i; TCGReg [[reg]]; TCGArg arg; TCGTemp *ts; intptr_t [[stack_offset]]; size_t call_stack_size; tcg_insn_unit *func_addr; int allocate_args; TCGRegSet [[allocated_regs]]; func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs]; flags = args[nb_oargs + nb_iargs + 1]; nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs); if (nb_regs > nb_iargs) { nb_regs = nb_iargs; } call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long); call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & ~(TCG_TARGET_STACK_ALIGN - 1); allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE); if (allocate_args) { tcg_abort(); } [[stack_offset]] = TCG_TARGET_CALL_STACK_OFFSET; for(i = nb_regs; i < nb_iargs; i++) { arg = args[nb_oargs + i]; #ifdef TCG_TARGET_STACK_GROWSUP [[stack_offset]] -= sizeof(tcg_target_long); #endif if (arg != TCG_CALL_DUMMY_ARG) { ts = &s->temps[arg]; temp_load(s, ts, tcg_target_available_regs[ts->type], s->reserved_regs); tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, [[stack_offset]]); } #ifndef TCG_TARGET_STACK_GROWSUP [[stack_offset]] += sizeof(tcg_target_long); #endif } tcg_regset_set([[allocated_regs]], s->reserved_regs); for(i = 0; i < nb_regs; i++) { arg = args[nb_oargs + i]; if (arg != TCG_CALL_DUMMY_ARG) { ts = &s->temps[arg]; [[reg]] = tcg_target_call_iarg_regs[i]; tcg_reg_free(s, [[reg]], [[allocated_regs]]); if (ts->val_type == TEMP_VAL_REG) { if (ts->reg != [[reg]]) { tcg_out_mov(s, ts->type, [[reg]], ts->reg); } } else { TCGRegSet arg_set; tcg_regset_clear(arg_set); tcg_regset_set_reg(arg_set, [[reg]]); temp_load(s, ts, arg_set, [[allocated_regs]]); } tcg_regset_set_reg([[allocated_regs]], [[reg]]); } } for(i = nb_oargs; i < nb_iargs + nb_oargs; i++) { if (IS_DEAD_ARG(i)) { temp_dead(s, &s->temps[args[i]]); } } for (i = 0; i < TCG_TARGET_NB_REGS; i++) { if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) { tcg_reg_free(s, i, [[allocated_regs]]); } } if (flags & TCG_CALL_NO_READ_GLOBALS) { } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) { sync_globals(s, [[allocated_regs]]); } else { save_globals(s, [[allocated_regs]]); } tcg_out_call(s, func_addr); for(i = 0; i < nb_oargs; i++) { arg = args[i]; ts = &s->temps[arg]; [[reg]] = tcg_target_call_oarg_regs[i]; assert(s->reg_to_temp[[[reg]]] == NULL); if (ts->fixed_reg) { if (ts->reg != [[reg]]) { tcg_out_mov(s, ts->type, ts->reg, [[reg]]); } } else { if (ts->val_type == TEMP_VAL_REG) { s->reg_to_temp[ts->reg] = NULL; } ts->val_type = TEMP_VAL_REG; ts->reg = [[reg]]; ts->mem_coherent = 0; s->reg_to_temp[[[reg]]] = ts; if (NEED_SYNC_ARG(i)) { tcg_reg_sync(s, [[reg]], [[allocated_regs]]); } if (IS_DEAD_ARG(i)) { temp_dead(s, ts); } } } }

[[[[Adv]]]]: static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs, const TCGArg * const args, uint16_t [[caliban]], uint8_t sync_args) { int flags, nb_regs, i; TCGReg [[saunders]]; TCGArg arg; TCGTemp *ts; intptr_t [[awkward]]; size_t call_stack_size; tcg_insn_unit *func_addr; int allocate_args; TCGRegSet [[dreamers]]; func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs]; flags = args[nb_oargs + nb_iargs + 1]; nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs); if (nb_regs > nb_iargs) { nb_regs = nb_iargs; } call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long); call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & ~(TCG_TARGET_STACK_ALIGN - 1); allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE); if (allocate_args) { tcg_abort(); } [[awkward]] = TCG_TARGET_CALL_STACK_OFFSET; for(i = nb_regs; i < nb_iargs; i++) { arg = args[nb_oargs + i]; #ifdef TCG_TARGET_STACK_GROWSUP [[awkward]] -= sizeof(tcg_target_long); #endif if (arg != TCG_CALL_DUMMY_ARG) { ts = &s->temps[arg]; temp_load(s, ts, tcg_target_available_regs[ts->type], s->reserved_regs); tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, [[awkward]]); } #ifndef TCG_TARGET_STACK_GROWSUP [[awkward]] += sizeof(tcg_target_long); #endif } tcg_regset_set([[dreamers]], s->reserved_regs); for(i = 0; i < nb_regs; i++) { arg = args[nb_oargs + i]; if (arg != TCG_CALL_DUMMY_ARG) { ts = &s->temps[arg]; [[saunders]] = tcg_target_call_iarg_regs[i]; tcg_reg_free(s, [[saunders]], [[dreamers]]); if (ts->val_type == TEMP_VAL_REG) { if (ts->reg != [[saunders]]) { tcg_out_mov(s, ts->type, [[saunders]], ts->reg); } } else { TCGRegSet arg_set; tcg_regset_clear(arg_set); tcg_regset_set_reg(arg_set, [[saunders]]); temp_load(s, ts, arg_set, [[dreamers]]); } tcg_regset_set_reg([[dreamers]], [[saunders]]); } } for(i = nb_oargs; i < nb_iargs + nb_oargs; i++) { if (IS_DEAD_ARG(i)) { temp_dead(s, &s->temps[args[i]]); } } for (i = 0; i < TCG_TARGET_NB_REGS; i++) { if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) { tcg_reg_free(s, i, [[dreamers]]); } } if (flags & TCG_CALL_NO_READ_GLOBALS) { } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) { sync_globals(s, [[dreamers]]); } else { save_globals(s, [[dreamers]]); } tcg_out_call(s, func_addr); for(i = 0; i < nb_oargs; i++) { arg = args[i]; ts = &s->temps[arg]; [[saunders]] = tcg_target_call_oarg_regs[i]; assert(s->reg_to_temp[[[saunders]]] == NULL); if (ts->fixed_reg) { if (ts->reg != [[saunders]]) { tcg_out_mov(s, ts->type, ts->reg, [[saunders]]); } } else { if (ts->val_type == TEMP_VAL_REG) { s->reg_to_temp[ts->reg] = NULL; } ts->val_type = TEMP_VAL_REG; ts->reg = [[saunders]]; ts->mem_coherent = 0; s->reg_to_temp[[[saunders]]] = ts; if (NEED_SYNC_ARG(i)) { tcg_reg_sync(s, [[saunders]], [[dreamers]]); } if (IS_DEAD_ARG(i)) { temp_dead(s, ts); } } } }
--------------------------------------------- Result 195 ---------------------------------------------
[[0 (20%)]] --> [[0 (52%)]] --> Socre: 0.5231781005859375

[[[[Adv]]]]: static void curl_multi_do(void *arg) { BDRVCURLState *s = (BDRVCURLState *)arg; int running; int [[r]]; if (!s->multi) { return; } do { [[r]] = curl_multi_socket_all(s->multi, &running); } while([[r]] == CURLM_CALL_MULTI_PERFORM); curl_multi_read(s); }

[[[[Adv]]]]: static void curl_multi_do(void *arg) { BDRVCURLState *s = (BDRVCURLState *)arg; int running; int [[kumar]]; if (!s->multi) { return; } do { [[kumar]] = curl_multi_socket_all(s->multi, &running); } while([[kumar]] == CURLM_CALL_MULTI_PERFORM); curl_multi_read(s); }
--------------------------------------------- Result 196 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 109 / 7 / 80 / 196:   7%|         | 196/2690 [33:03<7:00:34, 10.12s/it][Succeeded / Failed / Skipped / Total] 109 / 7 / 80 / 196:   7%|         | 197/2690 [33:03<6:58:22, 10.07s/it][[0 (43%)]] --> [[0 (56%)]] --> Socre: 0.5587537288665771

[[[[Adv]]]]: static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *config) { static int hinted = 0; int ret = 0; AVDictionaryEntry *e; const AVOption *o = NULL; const char *[[option]] = NULL; const char *codec_name = NULL; char buff[1024]; AVCodecContext *ctx; AVDictionary **dict; enum AVCodecID guessed_codec_id; switch (type) { case AV_OPT_FLAG_VIDEO_PARAM: ctx = config->dummy_vctx; dict = &config->video_opts; guessed_codec_id = config->guessed_video_codec_id != AV_CODEC_ID_NONE ? config->guessed_video_codec_id : AV_CODEC_ID_H264; break; case AV_OPT_FLAG_AUDIO_PARAM: ctx = config->dummy_actx; dict = &config->audio_opts; guessed_codec_id = config->guessed_audio_codec_id != AV_CODEC_ID_NONE ? config->guessed_audio_codec_id : AV_CODEC_ID_AAC; break; default: av_assert0(0); } if (strchr(opt, ':')) { snprintf(buff, sizeof(buff), "%s", opt); codec_name = buff; [[option]] = strchr(buff, ':'); buff[[[option]] - buff] = '\0'; [[option]]++; if ((ret = ffserver_set_codec(ctx, codec_name, config)) < 0) return ret; if (!ctx->codec || !ctx->priv_data) return -1; } else { [[option]] = opt; } o = av_opt_find(ctx, [[option]], NULL, type | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN); if (!o && (!strcmp([[option]], "time_base") || !strcmp([[option]], "pixel_format") || !strcmp([[option]], "video_size") || !strcmp([[option]], "codec_tag"))) o = av_opt_find(ctx, [[option]], NULL, 0, 0); if (!o) { report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Option not found: %s\n", opt); if (!hinted && ctx->codec_id == AV_CODEC_ID_NONE) { hinted = 1; report_config_error(config->filename, config->line_num, AV_LOG_ERROR, NULL, "If '%s' is a codec private option, then prefix it with codec name, " "for example '%s:%s %s' or define codec earlier.\n", opt, avcodec_get_name(guessed_codec_id) ,opt, arg); } } else if ((ret = av_opt_set(ctx, [[option]], arg, AV_OPT_SEARCH_CHILDREN)) < 0) { report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Invalid value for option %s (%s): %s\n", opt, arg, av_err2str(ret)); } else if ((e = av_dict_get(*dict, [[option]], NULL, 0))) { if ((o->type == AV_OPT_TYPE_FLAGS) && arg && (arg[0] == '+' || arg[0] == '-')) return av_dict_set(dict, [[option]], arg, AV_DICT_APPEND); report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Redeclaring value of the option %s, previous value: %s\n", opt, e->value); } else if (av_dict_set(dict, [[option]], arg, 0) < 0) { return AVERROR(ENOMEM); } return 0; }

[[[[Adv]]]]: static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *config) { static int hinted = 0; int ret = 0; AVDictionaryEntry *e; const AVOption *o = NULL; const char *[[substituting]] = NULL; const char *codec_name = NULL; char buff[1024]; AVCodecContext *ctx; AVDictionary **dict; enum AVCodecID guessed_codec_id; switch (type) { case AV_OPT_FLAG_VIDEO_PARAM: ctx = config->dummy_vctx; dict = &config->video_opts; guessed_codec_id = config->guessed_video_codec_id != AV_CODEC_ID_NONE ? config->guessed_video_codec_id : AV_CODEC_ID_H264; break; case AV_OPT_FLAG_AUDIO_PARAM: ctx = config->dummy_actx; dict = &config->audio_opts; guessed_codec_id = config->guessed_audio_codec_id != AV_CODEC_ID_NONE ? config->guessed_audio_codec_id : AV_CODEC_ID_AAC; break; default: av_assert0(0); } if (strchr(opt, ':')) { snprintf(buff, sizeof(buff), "%s", opt); codec_name = buff; [[substituting]] = strchr(buff, ':'); buff[[[substituting]] - buff] = '\0'; [[substituting]]++; if ((ret = ffserver_set_codec(ctx, codec_name, config)) < 0) return ret; if (!ctx->codec || !ctx->priv_data) return -1; } else { [[substituting]] = opt; } o = av_opt_find(ctx, [[substituting]], NULL, type | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN); if (!o && (!strcmp([[substituting]], "time_base") || !strcmp([[substituting]], "pixel_format") || !strcmp([[substituting]], "video_size") || !strcmp([[substituting]], "codec_tag"))) o = av_opt_find(ctx, [[substituting]], NULL, 0, 0); if (!o) { report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Option not found: %s\n", opt); if (!hinted && ctx->codec_id == AV_CODEC_ID_NONE) { hinted = 1; report_config_error(config->filename, config->line_num, AV_LOG_ERROR, NULL, "If '%s' is a codec private option, then prefix it with codec name, " "for example '%s:%s %s' or define codec earlier.\n", opt, avcodec_get_name(guessed_codec_id) ,opt, arg); } } else if ((ret = av_opt_set(ctx, [[substituting]], arg, AV_OPT_SEARCH_CHILDREN)) < 0) { report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Invalid value for option %s (%s): %s\n", opt, arg, av_err2str(ret)); } else if ((e = av_dict_get(*dict, [[substituting]], NULL, 0))) { if ((o->type == AV_OPT_TYPE_FLAGS) && arg && (arg[0] == '+' || arg[0] == '-')) return av_dict_set(dict, [[substituting]], arg, AV_DICT_APPEND); report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Redeclaring value of the option %s, previous value: %s\n", opt, e->value); } else if (av_dict_set(dict, [[substituting]], arg, 0) < 0) { return AVERROR(ENOMEM); } return 0; }
--------------------------------------------- Result 197 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decode_opc(MoxieCPU *cpu, DisasContext *ctx) { CPUMoxieState *env = &cpu->env; int opcode; int length = 2; if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) { tcg_gen_debug_insn_start(ctx->pc); } opcode = ctx->opcode; if (opcode & (1 << 15)) { if (opcode & (1 << 14)) { int inst = (opcode >> 10 & 0xf); #define BRANCH(cond) \ do { \ int l1 = gen_new_label(); \ tcg_gen_brcond_i32(cond, cc_a, cc_b, l1); \ gen_goto_tb(env, ctx, 1, ctx->pc+2); \ gen_set_label(l1); \ gen_goto_tb(env, ctx, 0, extract_branch_offset(opcode) + ctx->pc+2); \ ctx->bstate = BS_BRANCH; \ } while (0) switch (inst) { case 0x00: BRANCH(TCG_COND_EQ); break; case 0x01: BRANCH(TCG_COND_NE); break; case 0x02: BRANCH(TCG_COND_LT); break; case 0x03: BRANCH(TCG_COND_GT); break; case 0x04: BRANCH(TCG_COND_LTU); break; case 0x05: BRANCH(TCG_COND_GTU); break; case 0x06: BRANCH(TCG_COND_GE); break; case 0x07: BRANCH(TCG_COND_LE); break; case 0x08: BRANCH(TCG_COND_GEU); break; case 0x09: BRANCH(TCG_COND_LEU); break; default: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BAD); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; } } else { int inst = (opcode >> 12 & 0x3); switch (inst) { case 0x00: { int a = (opcode >> 8) & 0xf; unsigned int v = (opcode & 0xff); tcg_gen_addi_i32(REG(a), REG(a), v); } break; case 0x01: { int a = (opcode >> 8) & 0xf; unsigned int v = (opcode & 0xff); tcg_gen_subi_i32(REG(a), REG(a), v); } break; case 0x02: { int a = (opcode >> 8) & 0xf; unsigned v = (opcode & 0xff); tcg_gen_ld_i32(REG(a), cpu_env, offsetof(CPUMoxieState, sregs[v])); } break; case 0x03: { int a = (opcode >> 8) & 0xf; unsigned v = (opcode & 0xff); tcg_gen_st_i32(REG(a), cpu_env, offsetof(CPUMoxieState, sregs[v])); } break; default: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BAD); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; } } } else { int inst = opcode >> 8; switch (inst) { case 0x00: break; case 0x01: { int reg = (opcode >> 4) & 0xf; int val = cpu_ldl_code(env, ctx->pc+2); tcg_gen_movi_i32(REG(reg), val); length = 6; } break; case 0x02: { int dest = (opcode >> 4) & 0xf; int src = opcode & 0xf; tcg_gen_mov_i32(REG(dest), REG(src)); } break; case 0x03: { TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_movi_i32(t1, ctx->pc + 6); tcg_gen_subi_i32(t2, REG(1), 8); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(t1, REG(1), ctx->memidx); tcg_gen_subi_i32(t2, REG(1), 4); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx); tcg_gen_mov_i32(REG(0), REG(1)); gen_goto_tb(env, ctx, 0, cpu_ldl_code(env, ctx->pc+2)); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); ctx->bstate = BS_BRANCH; length = 6; } break; case 0x04: { TCGv t1 = tcg_temp_new_i32(); tcg_gen_mov_i32(REG(1), REG(0)); tcg_gen_qemu_ld32u(REG(0), REG(1), ctx->memidx); tcg_gen_addi_i32(t1, REG(1), 4); tcg_gen_mov_i32(REG(1), t1); tcg_gen_qemu_ld32u(cpu_pc, REG(1), ctx->memidx); tcg_gen_addi_i32(t1, REG(1), 8); tcg_gen_mov_i32(REG(1), t1); tcg_temp_free_i32(t1); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; } break; case 0x05: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_add_i32(REG(a), REG(a), REG(b)); } break; case 0x06: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); tcg_gen_subi_i32(t1, REG(a), 4); tcg_gen_mov_i32(REG(a), t1); tcg_gen_qemu_st32(REG(b), REG(a), ctx->memidx); tcg_temp_free_i32(t1); } break; case 0x07: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); tcg_gen_qemu_ld32u(REG(b), REG(a), ctx->memidx); tcg_gen_addi_i32(t1, REG(a), 4); tcg_gen_mov_i32(REG(a), t1); tcg_temp_free_i32(t1); } break; case 0x08: { int reg = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld32u(REG(reg), ptr, ctx->memidx); tcg_temp_free_i32(ptr); length = 6; } break; case 0x09: { int val = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st32(REG(val), ptr, ctx->memidx); tcg_temp_free_i32(ptr); length = 6; } break; case 0x0a: { int src = opcode & 0xf; int dest = (opcode >> 4) & 0xf; tcg_gen_qemu_ld32u(REG(dest), REG(src), ctx->memidx); } break; case 0x0b: { int dest = (opcode >> 4) & 0xf; int val = opcode & 0xf; tcg_gen_qemu_st32(REG(val), REG(dest), ctx->memidx); } break; case 0x0c: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld32u(t2, t1, ctx->memidx); tcg_gen_mov_i32(REG(a), t2); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); length = 6; } break; case 0x0d: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st32(REG(b), t1, ctx->memidx); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); length = 6; } break; case 0x0e: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_mov_i32(cc_a, REG(a)); tcg_gen_mov_i32(cc_b, REG(b)); } break; case 0x19: { int fnreg = (opcode >> 4) & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_movi_i32(t1, ctx->pc+2); tcg_gen_subi_i32(t2, REG(1), 8); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(t1, REG(1), ctx->memidx); tcg_gen_subi_i32(t2, REG(1), 4); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx); tcg_gen_mov_i32(REG(0), REG(1)); tcg_gen_mov_i32(cpu_pc, REG(fnreg)); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; } break; case 0x1a: { tcg_gen_movi_i32(cpu_pc, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; length = 6; } break; case 0x1b: { int reg = (opcode >> 4) & 0xf; int val = cpu_ldl_code(env, ctx->pc+2); tcg_gen_movi_i32(REG(reg), val); length = 6; } break; case 0x1c: { int src = opcode & 0xf; int dest = (opcode >> 4) & 0xf; tcg_gen_qemu_ld8u(REG(dest), REG(src), ctx->memidx); } break; case 0x1d: { int reg = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld8u(REG(reg), ptr, ctx->memidx); tcg_temp_free_i32(ptr); length = 6; } break; case 0x1e: { int dest = (opcode >> 4) & 0xf; int val = opcode & 0xf; tcg_gen_qemu_st8(REG(val), REG(dest), ctx->memidx); } break; case 0x1f: { int val = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st8(REG(val), ptr, ctx->memidx); tcg_temp_free_i32(ptr); length = 6; } break; case 0x20: { int reg = (opcode >> 4) & 0xf; int val = cpu_ldl_code(env, ctx->pc+2); tcg_gen_movi_i32(REG(reg), val); length = 6; } break; case 0x21: { int src = opcode & 0xf; int dest = (opcode >> 4) & 0xf; tcg_gen_qemu_ld16u(REG(dest), REG(src), ctx->memidx); } break; case 0x22: { int reg = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld16u(REG(reg), ptr, ctx->memidx); tcg_temp_free_i32(ptr); length = 6; } break; case 0x23: { int dest = (opcode >> 4) & 0xf; int val = opcode & 0xf; tcg_gen_qemu_st16(REG(val), REG(dest), ctx->memidx); } break; case 0x24: { int val = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st16(REG(val), ptr, ctx->memidx); tcg_temp_free_i32(ptr); length = 6; } break; case 0x25: { int reg = (opcode >> 4) & 0xf; tcg_gen_mov_i32(cpu_pc, REG(reg)); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; } break; case 0x26: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_and_i32(REG(a), REG(a), REG(b)); } break; case 0x27: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv sv = tcg_temp_new_i32(); tcg_gen_andi_i32(sv, REG(b), 0x1f); tcg_gen_shr_i32(REG(a), REG(a), sv); tcg_temp_free_i32(sv); } break; case 0x28: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv sv = tcg_temp_new_i32(); tcg_gen_andi_i32(sv, REG(b), 0x1f); tcg_gen_shl_i32(REG(a), REG(a), sv); tcg_temp_free_i32(sv); } break; case 0x29: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_sub_i32(REG(a), REG(a), REG(b)); } break; case 0x2a: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_neg_i32(REG(a), REG(b)); } break; case 0x2b: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_or_i32(REG(a), REG(a), REG(b)); } break; case 0x2c: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_not_i32(REG(a), REG(b)); } break; case 0x2d: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv sv = tcg_temp_new_i32(); tcg_gen_andi_i32(sv, REG(b), 0x1f); tcg_gen_sar_i32(REG(a), REG(a), sv); tcg_temp_free_i32(sv); } break; case 0x2e: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_xor_i32(REG(a), REG(a), REG(b)); } break; case 0x2f: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_mul_i32(REG(a), REG(a), REG(b)); } break; case 0x30: { int val = cpu_ldl_code(env, ctx->pc+2); TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(temp, val); tcg_gen_st_i32(temp, cpu_env, offsetof(CPUMoxieState, sregs[3])); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_SWI); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); length = 6; } break; case 0x31: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_movi_i32(cpu_pc, ctx->pc); gen_helper_div(REG(a), cpu_env, REG(a), REG(b)); } break; case 0x32: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_movi_i32(cpu_pc, ctx->pc); gen_helper_udiv(REG(a), cpu_env, REG(a), REG(b)); } break; case 0x33: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_rem_i32(REG(a), REG(a), REG(b)); } break; case 0x34: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_remu_i32(REG(a), REG(a), REG(b)); } break; case 0x35: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BREAK); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; case 0x36: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld8u(t2, t1, ctx->memidx); tcg_gen_mov_i32(REG(a), t2); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); length = 6; } break; case 0x37: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st8(REG(b), t1, ctx->memidx); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); length = 6; } break; case 0x38: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld16u(t2, t1, ctx->memidx); tcg_gen_mov_i32(REG(a), t2); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); length = 6; } break; case 0x39: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st16(REG(b), t1, ctx->memidx); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); length = 6; } break; default: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BAD); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; } } return length; }[Succeeded / Failed / Skipped / Total] 109 / 7 / 81 / 197:   7%|         | 197/2690 [33:03<6:58:22, 10.07s/it][Succeeded / Failed / Skipped / Total] 109 / 7 / 81 / 197:   7%|         | 198/2690 [33:25<7:00:41, 10.13s/it][Succeeded / Failed / Skipped / Total] 110 / 7 / 81 / 198:   7%|         | 198/2690 [33:25<7:00:41, 10.13s/it][Succeeded / Failed / Skipped / Total] 110 / 7 / 81 / 198:   7%|         | 199/2690 [33:44<7:02:22, 10.17s/it][Succeeded / Failed / Skipped / Total] 111 / 7 / 81 / 199:   7%|         | 199/2690 [33:44<7:02:22, 10.17s/it][Succeeded / Failed / Skipped / Total] 111 / 7 / 81 / 199:   7%|         | 200/2690 [33:46<7:00:24, 10.13s/it][Succeeded / Failed / Skipped / Total] 112 / 7 / 81 / 200:   7%|         | 200/2690 [33:46<7:00:24, 10.13s/it][Succeeded / Failed / Skipped / Total] 112 / 7 / 81 / 200:   7%|         | 201/2690 [33:46<6:58:14, 10.08s/it][Succeeded / Failed / Skipped / Total] 112 / 7 / 82 / 201:   7%|         | 201/2690 [33:46<6:58:14, 10.08s/it][Succeeded / Failed / Skipped / Total] 112 / 7 / 82 / 201:   8%|         | 202/2690 [33:47<6:56:07, 10.03s/it]
--------------------------------------------- Result 198 ---------------------------------------------
[[0 (18%)]] --> [[0 (79%)]] --> Socre: 0.787922203540802

[[[[Adv]]]]: static void tcg_out_opc(TCGContext *s, int [[opc]], int r, int rm, int x) { int rex; if ([[opc]] & P_GS) { tcg_out8(s, 0x65); } if ([[opc]] & P_DATA16) { assert(([[opc]] & P_REXW) == 0); tcg_out8(s, 0x66); } if ([[opc]] & P_ADDR32) { tcg_out8(s, 0x67); } rex = 0; rex |= ([[opc]] & P_REXW) ? 0x8 : 0x0; rex |= (r & 8) >> 1; rex |= (x & 8) >> 2; rex |= (rm & 8) >> 3; rex |= [[opc]] & (r >= 4 ? P_REXB_R : 0); rex |= [[opc]] & (rm >= 4 ? P_REXB_RM : 0); if (rex) { tcg_out8(s, (uint8_t)(rex | 0x40)); } if ([[opc]] & (P_EXT | P_EXT38)) { tcg_out8(s, 0x0f); if ([[opc]] & P_EXT38) { tcg_out8(s, 0x38); } } tcg_out8(s, [[opc]]); }

[[[[Adv]]]]: static void tcg_out_opc(TCGContext *s, int [[lpez]], int r, int rm, int x) { int rex; if ([[lpez]] & P_GS) { tcg_out8(s, 0x65); } if ([[lpez]] & P_DATA16) { assert(([[lpez]] & P_REXW) == 0); tcg_out8(s, 0x66); } if ([[lpez]] & P_ADDR32) { tcg_out8(s, 0x67); } rex = 0; rex |= ([[lpez]] & P_REXW) ? 0x8 : 0x0; rex |= (r & 8) >> 1; rex |= (x & 8) >> 2; rex |= (rm & 8) >> 3; rex |= [[lpez]] & (r >= 4 ? P_REXB_R : 0); rex |= [[lpez]] & (rm >= 4 ? P_REXB_RM : 0); if (rex) { tcg_out8(s, (uint8_t)(rex | 0x40)); } if ([[lpez]] & (P_EXT | P_EXT38)) { tcg_out8(s, 0x0f); if ([[lpez]] & P_EXT38) { tcg_out8(s, 0x38); } } tcg_out8(s, [[lpez]]); }
--------------------------------------------- Result 199 ---------------------------------------------
[[0 (56%)]] --> [[0 (49%)]] --> Socre: 0.5087929666042328

[[[[Adv]]]]: qcow2_co_pwritev_compressed(BlockDriverState *bs, uint64_t offset, uint64_t bytes, QEMUIOVector *qiov) { BDRVQcow2State *[[s]] = bs->opaque; QEMUIOVector hd_qiov; struct iovec iov; z_stream strm; int ret, out_len; uint8_t *buf, *out_buf; uint64_t [[cluster_offset]]; if (bytes == 0) { [[cluster_offset]] = bdrv_getlength(bs->file->bs); return bdrv_truncate(bs->file, [[cluster_offset]], PREALLOC_MODE_OFF, NULL); } buf = qemu_blockalign(bs, [[s]]->cluster_size); if (bytes != [[s]]->cluster_size) { if (bytes > [[s]]->cluster_size || offset + bytes != bs->total_sectors << BDRV_SECTOR_BITS) { qemu_vfree(buf); return -EINVAL; } memset(buf + bytes, 0, [[s]]->cluster_size - bytes); } qemu_iovec_to_buf(qiov, 0, buf, bytes); out_buf = g_malloc([[s]]->cluster_size); memset(&strm, 0, sizeof(strm)); ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION, Z_DEFLATED, -12, 9, Z_DEFAULT_STRATEGY); if (ret != 0) { ret = -EINVAL; goto fail; } strm.avail_in = [[s]]->cluster_size; strm.next_in = (uint8_t *)buf; strm.avail_out = [[s]]->cluster_size; strm.next_out = out_buf; ret = deflate(&strm, Z_FINISH); if (ret != Z_STREAM_END && ret != Z_OK) { deflateEnd(&strm); ret = -EINVAL; goto fail; } out_len = strm.next_out - out_buf; deflateEnd(&strm); if (ret != Z_STREAM_END || out_len >= [[s]]->cluster_size) { ret = qcow2_co_pwritev(bs, offset, bytes, qiov, 0); if (ret < 0) { goto fail; } goto success; } qemu_co_mutex_lock(&[[s]]->lock); [[cluster_offset]] = qcow2_alloc_compressed_cluster_offset(bs, offset, out_len); if (![[cluster_offset]]) { qemu_co_mutex_unlock(&[[s]]->lock); ret = -EIO; goto fail; } [[cluster_offset]] &= [[s]]->cluster_offset_mask; ret = qcow2_pre_write_overlap_check(bs, 0, [[cluster_offset]], out_len); qemu_co_mutex_unlock(&[[s]]->lock); if (ret < 0) { goto fail; } iov = (struct iovec) { .iov_base = out_buf, .iov_len = out_len, }; qemu_iovec_init_external(&hd_qiov, &iov, 1); BLKDBG_EVENT(bs->file, BLKDBG_WRITE_COMPRESSED); ret = bdrv_co_pwritev(bs->file, [[cluster_offset]], out_len, &hd_qiov, 0); if (ret < 0) { goto fail; } success: ret = 0; fail: qemu_vfree(buf); g_free(out_buf); return ret; }

[[[[Adv]]]]: qcow2_co_pwritev_compressed(BlockDriverState *bs, uint64_t offset, uint64_t bytes, QEMUIOVector *qiov) { BDRVQcow2State *[[into]] = bs->opaque; QEMUIOVector hd_qiov; struct iovec iov; z_stream strm; int ret, out_len; uint8_t *buf, *out_buf; uint64_t [[arbitrarily]]; if (bytes == 0) { [[arbitrarily]] = bdrv_getlength(bs->file->bs); return bdrv_truncate(bs->file, [[arbitrarily]], PREALLOC_MODE_OFF, NULL); } buf = qemu_blockalign(bs, [[into]]->cluster_size); if (bytes != [[into]]->cluster_size) { if (bytes > [[into]]->cluster_size || offset + bytes != bs->total_sectors << BDRV_SECTOR_BITS) { qemu_vfree(buf); return -EINVAL; } memset(buf + bytes, 0, [[into]]->cluster_size - bytes); } qemu_iovec_to_buf(qiov, 0, buf, bytes); out_buf = g_malloc([[into]]->cluster_size); memset(&strm, 0, sizeof(strm)); ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION, Z_DEFLATED, -12, 9, Z_DEFAULT_STRATEGY); if (ret != 0) { ret = -EINVAL; goto fail; } strm.avail_in = [[into]]->cluster_size; strm.next_in = (uint8_t *)buf; strm.avail_out = [[into]]->cluster_size; strm.next_out = out_buf; ret = deflate(&strm, Z_FINISH); if (ret != Z_STREAM_END && ret != Z_OK) { deflateEnd(&strm); ret = -EINVAL; goto fail; } out_len = strm.next_out - out_buf; deflateEnd(&strm); if (ret != Z_STREAM_END || out_len >= [[into]]->cluster_size) { ret = qcow2_co_pwritev(bs, offset, bytes, qiov, 0); if (ret < 0) { goto fail; } goto success; } qemu_co_mutex_lock(&[[into]]->lock); [[arbitrarily]] = qcow2_alloc_compressed_cluster_offset(bs, offset, out_len); if (![[arbitrarily]]) { qemu_co_mutex_unlock(&[[into]]->lock); ret = -EIO; goto fail; } [[arbitrarily]] &= [[into]]->cluster_offset_mask; ret = qcow2_pre_write_overlap_check(bs, 0, [[arbitrarily]], out_len); qemu_co_mutex_unlock(&[[into]]->lock); if (ret < 0) { goto fail; } iov = (struct iovec) { .iov_base = out_buf, .iov_len = out_len, }; qemu_iovec_init_external(&hd_qiov, &iov, 1); BLKDBG_EVENT(bs->file, BLKDBG_WRITE_COMPRESSED); ret = bdrv_co_pwritev(bs->file, [[arbitrarily]], out_len, &hd_qiov, 0); if (ret < 0) { goto fail; } success: ret = 0; fail: qemu_vfree(buf); g_free(out_buf); return ret; }
--------------------------------------------- Result 200 ---------------------------------------------
[[0 (76%)]] --> [[0 (48%)]] --> Socre: 0.5213360488414764

[[[[Adv]]]]: static void gen_mfrom(DisasContext *[[ctx]]) { #if defined(CONFIG_USER_ONLY) gen_inval_exception([[ctx]], POWERPC_EXCP_PRIV_OPC); #else if (unlikely([[ctx]]->pr)) { gen_inval_exception([[ctx]], POWERPC_EXCP_PRIV_OPC); return; } gen_helper_602_mfrom(cpu_gpr[rD([[ctx]]->opcode)], cpu_gpr[rA([[ctx]]->opcode)]); #endif }

[[[[Adv]]]]: static void gen_mfrom(DisasContext *[[parameter]]) { #if defined(CONFIG_USER_ONLY) gen_inval_exception([[parameter]], POWERPC_EXCP_PRIV_OPC); #else if (unlikely([[parameter]]->pr)) { gen_inval_exception([[parameter]], POWERPC_EXCP_PRIV_OPC); return; } gen_helper_602_mfrom(cpu_gpr[rD([[parameter]]->opcode)], cpu_gpr[rA([[parameter]]->opcode)]); #endif }
--------------------------------------------- Result 201 ---------------------------------------------
[[0 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst, long width, long height, long lumStride, long chromStride, long dstStride) { RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1); }
--------------------------------------------- Result 202 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 112 / 7 / 83 / 202:   8%|         | 202/2690 [33:47<6:56:07, 10.03s/it][Succeeded / Failed / Skipped / Total] 112 / 7 / 83 / 202:   8%|         | 203/2690 [33:47<6:54:00,  9.99s/it][Succeeded / Failed / Skipped / Total] 112 / 7 / 84 / 203:   8%|         | 203/2690 [33:47<6:54:00,  9.99s/it][Succeeded / Failed / Skipped / Total] 112 / 7 / 84 / 203:   8%|         | 204/2690 [33:51<6:52:39,  9.96s/it][Succeeded / Failed / Skipped / Total] 113 / 7 / 84 / 204:   8%|         | 204/2690 [33:51<6:52:39,  9.96s/it][Succeeded / Failed / Skipped / Total] 113 / 7 / 84 / 204:   8%|         | 205/2690 [34:11<6:54:28, 10.01s/it][Succeeded / Failed / Skipped / Total] 114 / 7 / 84 / 205:   8%|         | 205/2690 [34:11<6:54:28, 10.01s/it][Succeeded / Failed / Skipped / Total] 114 / 7 / 84 / 205:   8%|         | 206/2690 [34:12<6:52:23,  9.96s/it][Succeeded / Failed / Skipped / Total] 114 / 7 / 85 / 206:   8%|         | 206/2690 [34:12<6:52:23,  9.96s/it][Succeeded / Failed / Skipped / Total] 114 / 7 / 85 / 206:   8%|         | 207/2690 [39:41<7:56:06, 11.50s/it][[0 (66%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static gboolean ga_channel_open(GAChannel *c, const gchar *path, GAChannelMethod method, int fd) { int ret; c->method = method; switch (c->method) { case GA_CHANNEL_VIRTIO_SERIAL: { assert(fd < 0); fd = qemu_open(path, O_RDWR | O_NONBLOCK #ifndef CONFIG_SOLARIS | O_ASYNC #endif ); if (fd == -1) { g_critical("error opening channel: %s", strerror(errno)); return "False" != "False"; } #ifdef CONFIG_SOLARIS ret = ioctl(fd, I_SETSIG, S_OUTPUT | S_INPUT | S_HIPRI); if (ret == -1) { g_critical("error setting event mask for channel: %s", strerror(errno)); close(fd); return "False" != "False"; } #endif ret = ga_channel_client_add(c, fd); if (ret) { g_critical("error adding channel to main loop"); close(fd); return "False" != "False"; } break; } case GA_CHANNEL_ISA_SERIAL: { struct termios tio; assert(fd < 0); fd = qemu_open(path, O_RDWR | O_NOCTTY | O_NONBLOCK); if (fd == -1) { g_critical("error opening channel: %s", strerror(errno)); return "False" != "False"; } tcgetattr(fd, &tio); tio.c_iflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY | IMAXBEL); tio.c_oflag = 0; tio.c_lflag = 0; tio.c_cflag |= GA_CHANNEL_BAUDRATE_DEFAULT; tio.c_cc[VMIN] = 1; tio.c_cc[VTIME] = 0; tcflush(fd, TCIFLUSH); tcsetattr(fd, TCSANOW, &tio); ret = ga_channel_client_add(c, fd); if (ret) { g_critical("error adding channel to main loop"); close(fd); return "False" != "False"; } break; } case GA_CHANNEL_UNIX_LISTEN: { if (fd < 0) { Error *local_err = NULL; fd = unix_listen(path, NULL, strlen(path), &local_err); if (local_err != NULL) { g_critical("%s", error_get_pretty(local_err)); error_free(local_err); return "False" != "False"; } } ga_channel_listen_add(c, fd, "True" == "True"); break; } case GA_CHANNEL_VSOCK_LISTEN: { if (fd < 0) { Error *local_err = NULL; SocketAddress *addr; char *addr_str; addr_str = g_strdup_printf("vsock:%s", path); addr = socket_parse(addr_str, &local_err); g_free(addr_str); if (local_err != NULL) { g_critical("%s", error_get_pretty(local_err)); error_free(local_err); return "False" != "False"; } fd = socket_listen(addr, &local_err); qapi_free_SocketAddress(addr); if (local_err != NULL) { g_critical("%s", error_get_pretty(local_err)); error_free(local_err); return "False" != "False"; } } ga_channel_listen_add(c, fd, "True" == "True"); break; } default: g_critical("error binding/listening to specified socket"); return "False" != "False"; } return "True" == "True"; }
--------------------------------------------- Result 203 ---------------------------------------------
[[0 (81%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ram_save_block(QEMUFile *f) { RAMBlock *block = last_block; ram_addr_t offset = last_offset; int bytes_sent = -1; MemoryRegion *mr; if (!block) block = QLIST_FIRST(&ram_list.blocks); do { mr = block->mr; if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE, DIRTY_MEMORY_MIGRATION)) { uint8_t *p; int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0; memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE, DIRTY_MEMORY_MIGRATION); p = memory_region_get_ram_ptr(mr) + offset; if (is_dup_page(p)) { save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS); qemu_put_byte(f, *p); bytes_sent = 1; } else { save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE); qemu_put_buffer(f, p, TARGET_PAGE_SIZE); bytes_sent = TARGET_PAGE_SIZE; } break; } offset += TARGET_PAGE_SIZE; if (offset >= block->length) { offset = 0; block = QLIST_NEXT(block, next); if (!block) block = QLIST_FIRST(&ram_list.blocks); } } while (block != last_block || offset != last_offset); last_block = block; last_offset = offset; return bytes_sent; }
--------------------------------------------- Result 204 ---------------------------------------------
[[0 (30%)]] --> [[0 (52%)]] --> Socre: 0.5152449607849121

[[[[Adv]]]]: bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr [[pa]], size_t len) { hwaddr [[mapped_len]] = 0; struct iovec *ventry; assert(pkt); assert(pkt->max_raw_frags > pkt->raw_frags); if (!len) { return "True" == "True"; } ventry = &pkt->raw[pkt->raw_frags]; [[mapped_len]] = len; ventry->iov_base = cpu_physical_memory_map([[pa]], &[[mapped_len]], "False" != "False"); ventry->iov_len = [[mapped_len]]; pkt->raw_frags += !!ventry->iov_base; if ((ventry->iov_base == NULL) || (len != [[mapped_len]])) { return "False" != "False"; } return "True" == "True"; }

[[[[Adv]]]]: bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr [[papa]], size_t len) { hwaddr [[tumbled]] = 0; struct iovec *ventry; assert(pkt); assert(pkt->max_raw_frags > pkt->raw_frags); if (!len) { return "True" == "True"; } ventry = &pkt->raw[pkt->raw_frags]; [[tumbled]] = len; ventry->iov_base = cpu_physical_memory_map([[papa]], &[[tumbled]], "False" != "False"); ventry->iov_len = [[tumbled]]; pkt->raw_frags += !!ventry->iov_base; if ((ventry->iov_base == NULL) || (len != [[tumbled]])) { return "False" != "False"; } return "True" == "True"; }
--------------------------------------------- Result 205 ---------------------------------------------
[[0 (32%)]] --> [[0 (57%)]] --> Socre: 0.5742819905281067

[[[[Adv]]]]: yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0, const uint16_t *buf1, const uint16_t *ubuf0, const uint16_t *ubuf1, const uint16_t *vbuf0, const uint16_t *[[vbuf1]], const uint16_t *abuf0, const uint16_t *abuf1, uint8_t *dest, int dstW, int yalpha, int uvalpha, int y, enum PixelFormat target) { int [[yalpha1]] = 4095 - yalpha; int uvalpha1 = 4095 - uvalpha; int i; for (i = 0; i < (dstW >> 1); i++) { int Y1 = (buf0[i * 2] * [[yalpha1]] + buf1[i * 2] * yalpha) >> 19; int Y2 = (buf0[i * 2 + 1] * [[yalpha1]] + buf1[i * 2 + 1] * yalpha) >> 19; int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha) >> 19; int V = (vbuf0[i] * uvalpha1 + [[vbuf1]][i] * uvalpha) >> 19; output_pixels(i * 4, Y1, U, Y2, V); } }

[[[[Adv]]]]: yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0, const uint16_t *buf1, const uint16_t *ubuf0, const uint16_t *ubuf1, const uint16_t *vbuf0, const uint16_t *[[ravage]], const uint16_t *abuf0, const uint16_t *abuf1, uint8_t *dest, int dstW, int yalpha, int uvalpha, int y, enum PixelFormat target) { int [[surnames]] = 4095 - yalpha; int uvalpha1 = 4095 - uvalpha; int i; for (i = 0; i < (dstW >> 1); i++) { int Y1 = (buf0[i * 2] * [[surnames]] + buf1[i * 2] * yalpha) >> 19; int Y2 = (buf0[i * 2 + 1] * [[surnames]] + buf1[i * 2 + 1] * yalpha) >> 19; int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha) >> 19; int V = (vbuf0[i] * uvalpha1 + [[ravage]][i] * uvalpha) >> 19; output_pixels(i * 4, Y1, U, Y2, V); } }
--------------------------------------------- Result 206 ---------------------------------------------
[[0 (68%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src, int linesize, int block_w, int block_h, int src_x, int src_y, int w, int h, emu_edge_core_func *core_fn) { int start_y, start_x, end_y, end_x, src_y_add = 0; if (src_y >= h) { src_y_add = h - 1 - src_y; src_y = h - 1; } else if (src_y <= -block_h) { src_y_add = 1 - block_h - src_y; src_y = 1 - block_h; } if (src_x >= w) { src += w - 1 - src_x; src_x = w - 1; } else if (src_x <= -block_w) { src += 1 - block_w - src_x; src_x = 1 - block_w; } start_y = FFMAX(0, -src_y); start_x = FFMAX(0, -src_x); end_y = FFMIN(block_h, h-src_y); end_x = FFMIN(block_w, w-src_x); av_assert2(start_x < end_x && block_w > 0); av_assert2(start_y < end_y && block_h > 0); src += (src_y_add + start_y) * linesize + start_x; buf += start_x; core_fn(buf, src, linesize, start_y, end_y, block_h, start_x, end_x, block_w); }
--------------------------------------------- Result 207 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 114 / 8 / 85 / 207:   8%|         | 207/2690 [39:41<7:56:06, 11.50s/it][Succeeded / Failed / Skipped / Total] 114 / 8 / 85 / 207:   8%|         | 208/2690 [39:48<7:55:00, 11.48s/it][Succeeded / Failed / Skipped / Total] 115 / 8 / 85 / 208:   8%|         | 208/2690 [39:48<7:55:00, 11.48s/it][Succeeded / Failed / Skipped / Total] 115 / 8 / 85 / 208:   8%|         | 209/2690 [40:01<7:55:02, 11.49s/it][Succeeded / Failed / Skipped / Total] 116 / 8 / 85 / 209:   8%|         | 209/2690 [40:01<7:55:02, 11.49s/it][Succeeded / Failed / Skipped / Total] 116 / 8 / 85 / 209:   8%|         | 210/2690 [40:50<8:02:17, 11.67s/it][[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void OPPROTO op_udiv_T1_T0(void) { uint64_t x0; uint32_t x1; x0 = T0 | ((uint64_t) (env->y) << 32); x1 = T1; x0 = x0 / x1; if (x0 > 0xffffffff) { T0 = 0xffffffff; T1 = 1; } else { T0 = x0; T1 = 0; FORCE_RET();

[[[[Adv]]]]: void OPPROTO op_udiv_T1_T0(void) { uint64_t x0; uint32_t x1; x0 = T0 | ((uint64_t) (env->y) << 32); x1 = T1; x0 = x0 / x1; if (x0 > 0xffffffff) { T0 = 0xffffffff; T1 = 1; } else { T0 = x0; T1 = 0; FORCE_RET();
--------------------------------------------- Result 208 ---------------------------------------------
[[0 (63%)]] --> [[0 (45%)]] --> Socre: 0.5527494549751282

[[[[Adv]]]]: static void quorum_vote(QuorumAIOCB *acb) { bool [[quorum]] = "True" == "True"; int i, j, ret; QuorumVoteValue hash; BDRVQuorumState *s = acb->common.bs->opaque; QuorumVoteVersion *winner; if (quorum_has_too_much_io_failed(acb)) { return; } for (i = 0; i < s->num_children; i++) { if (!acb->qcrs[i].ret) { break; } } assert(i < s->num_children); for (j = i + 1; j < s->num_children; j++) { if (acb->qcrs[j].ret) { continue; } [[quorum]] = quorum_compare(acb, &acb->qcrs[i].qiov, &acb->qcrs[j].qiov); if (![[quorum]]) { break; } } if ([[quorum]]) { quorum_copy_qiov(acb->qiov, &acb->qcrs[i].qiov); return; } for (i = 0; i < s->num_children; i++) { if (acb->qcrs[i].ret) { continue; } ret = quorum_compute_hash(acb, i, &hash); if (ret < 0) { acb->vote_ret = ret; goto free_exit; } quorum_count_vote(&acb->votes, &hash, i); } winner = quorum_get_vote_winner(&acb->votes); if (winner->vote_count < s->threshold) { quorum_report_failure(acb); acb->vote_ret = -EIO; goto free_exit; } quorum_copy_qiov(acb->qiov, &acb->qcrs[winner->index].qiov); quorum_report_bad_versions(s, acb, &winner->value); free_exit: quorum_free_vote_list(&acb->votes); }

[[[[Adv]]]]: static void quorum_vote(QuorumAIOCB *acb) { bool [[voters]] = "True" == "True"; int i, j, ret; QuorumVoteValue hash; BDRVQuorumState *s = acb->common.bs->opaque; QuorumVoteVersion *winner; if (quorum_has_too_much_io_failed(acb)) { return; } for (i = 0; i < s->num_children; i++) { if (!acb->qcrs[i].ret) { break; } } assert(i < s->num_children); for (j = i + 1; j < s->num_children; j++) { if (acb->qcrs[j].ret) { continue; } [[voters]] = quorum_compare(acb, &acb->qcrs[i].qiov, &acb->qcrs[j].qiov); if (![[voters]]) { break; } } if ([[voters]]) { quorum_copy_qiov(acb->qiov, &acb->qcrs[i].qiov); return; } for (i = 0; i < s->num_children; i++) { if (acb->qcrs[i].ret) { continue; } ret = quorum_compute_hash(acb, i, &hash); if (ret < 0) { acb->vote_ret = ret; goto free_exit; } quorum_count_vote(&acb->votes, &hash, i); } winner = quorum_get_vote_winner(&acb->votes); if (winner->vote_count < s->threshold) { quorum_report_failure(acb); acb->vote_ret = -EIO; goto free_exit; } quorum_copy_qiov(acb->qiov, &acb->qcrs[winner->index].qiov); quorum_report_bad_versions(s, acb, &winner->value); free_exit: quorum_free_vote_list(&acb->votes); }
--------------------------------------------- Result 209 ---------------------------------------------
[[0 (60%)]] --> [[0 (46%)]] --> Socre: 0.5401094257831573

[[[[Adv]]]]: static void stellaris_init(const char *kernel_filename, const char *cpu_model, stellaris_board_info *board) { static const int uart_irq[] = {5, 6, 33, 34}; static const int timer_irq[] = {19, 21, 23, 35}; static const uint32_t gpio_addr[7] = { 0x40004000, 0x40005000, 0x40006000, 0x40007000, 0x40024000, 0x40025000, 0x40026000}; static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31}; qemu_irq *pic; DeviceState *gpio_dev[7]; qemu_irq gpio_in[7][8]; qemu_irq gpio_out[7][8]; qemu_irq adc; int sram_size; int [[flash_size]]; I2CBus *i2c; DeviceState *[[dev]]; int i; int j; MemoryRegion *sram = g_new(MemoryRegion, 1); MemoryRegion *flash = g_new(MemoryRegion, 1); MemoryRegion *system_memory = get_system_memory(); [[flash_size]] = (((board->dc0 & 0xffff) + 1) << 1) * 1024; sram_size = ((board->dc0 >> 18) + 1) * 1024; memory_region_init_ram(flash, NULL, "stellaris.flash", [[flash_size]], &error_abort); vmstate_register_ram_global(flash); memory_region_set_readonly(flash, "True" == "True"); memory_region_add_subregion(system_memory, 0, flash); memory_region_init_ram(sram, NULL, "stellaris.sram", sram_size, &error_abort); vmstate_register_ram_global(sram); memory_region_add_subregion(system_memory, 0x20000000, sram); pic = armv7m_init(system_memory, [[flash_size]], NUM_IRQ_LINES, kernel_filename, cpu_model); if (board->dc1 & (1 << 16)) { [[dev]] = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000, pic[14], pic[15], pic[16], pic[17], NULL); adc = qdev_get_gpio_in([[dev]], 0); } else { adc = NULL; } for (i = 0; i < 4; i++) { if (board->dc2 & (0x10000 << i)) { [[dev]] = sysbus_create_simple(TYPE_STELLARIS_GPTM, 0x40030000 + i * 0x1000, pic[timer_irq[i]]); qdev_connect_gpio_out([[dev]], 0, adc); } } stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr.a); for (i = 0; i < 7; i++) { if (board->dc4 & (1 << i)) { gpio_dev[i] = sysbus_create_simple("pl061_luminary", gpio_addr[i], pic[gpio_irq[i]]); for (j = 0; j < 8; j++) { gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j); gpio_out[i][j] = NULL; } } } if (board->dc2 & (1 << 12)) { [[dev]] = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]); i2c = (I2CBus *)qdev_get_child_bus([[dev]], "i2c"); if (board->peripherals & BP_OLED_I2C) { i2c_create_slave(i2c, "ssd0303", 0x3d); } } for (i = 0; i < 4; i++) { if (board->dc2 & (1 << i)) { sysbus_create_simple("pl011_luminary", 0x4000c000 + i * 0x1000, pic[uart_irq[i]]); } } if (board->dc2 & (1 << 4)) { [[dev]] = sysbus_create_simple("pl022", 0x40008000, pic[7]); if (board->peripherals & BP_OLED_SSI) { void *bus; DeviceState *sddev; DeviceState *ssddev; bus = qdev_get_child_bus([[dev]], "ssi"); sddev = ssi_create_slave(bus, "ssi-sd"); ssddev = ssi_create_slave(bus, "ssd0323"); gpio_out[GPIO_D][0] = qemu_irq_split( qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0), qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0)); gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0); qemu_irq_raise(gpio_out[GPIO_D][0]); } } if (board->dc4 & (1 << 28)) { DeviceState *enet; qemu_check_nic_model(&nd_table[0], "stellaris"); enet = qdev_create(NULL, "stellaris_enet"); qdev_set_nic_properties(enet, &nd_table[0]); qdev_init_nofail(enet); sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000); sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]); } if (board->peripherals & BP_GAMEPAD) { qemu_irq gpad_irq[5]; static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d }; gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); stellaris_gamepad_init(5, gpad_irq, gpad_keycode); } for (i = 0; i < 7; i++) { if (board->dc4 & (1 << i)) { for (j = 0; j < 8; j++) { if (gpio_out[i][j]) { qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]); } } } } }

[[[[Adv]]]]: static void stellaris_init(const char *kernel_filename, const char *cpu_model, stellaris_board_info *board) { static const int uart_irq[] = {5, 6, 33, 34}; static const int timer_irq[] = {19, 21, 23, 35}; static const uint32_t gpio_addr[7] = { 0x40004000, 0x40005000, 0x40006000, 0x40007000, 0x40024000, 0x40025000, 0x40026000}; static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31}; qemu_irq *pic; DeviceState *gpio_dev[7]; qemu_irq gpio_in[7][8]; qemu_irq gpio_out[7][8]; qemu_irq adc; int sram_size; int [[tengo]]; I2CBus *i2c; DeviceState *[[nath]]; int i; int j; MemoryRegion *sram = g_new(MemoryRegion, 1); MemoryRegion *flash = g_new(MemoryRegion, 1); MemoryRegion *system_memory = get_system_memory(); [[tengo]] = (((board->dc0 & 0xffff) + 1) << 1) * 1024; sram_size = ((board->dc0 >> 18) + 1) * 1024; memory_region_init_ram(flash, NULL, "stellaris.flash", [[tengo]], &error_abort); vmstate_register_ram_global(flash); memory_region_set_readonly(flash, "True" == "True"); memory_region_add_subregion(system_memory, 0, flash); memory_region_init_ram(sram, NULL, "stellaris.sram", sram_size, &error_abort); vmstate_register_ram_global(sram); memory_region_add_subregion(system_memory, 0x20000000, sram); pic = armv7m_init(system_memory, [[tengo]], NUM_IRQ_LINES, kernel_filename, cpu_model); if (board->dc1 & (1 << 16)) { [[nath]] = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000, pic[14], pic[15], pic[16], pic[17], NULL); adc = qdev_get_gpio_in([[nath]], 0); } else { adc = NULL; } for (i = 0; i < 4; i++) { if (board->dc2 & (0x10000 << i)) { [[nath]] = sysbus_create_simple(TYPE_STELLARIS_GPTM, 0x40030000 + i * 0x1000, pic[timer_irq[i]]); qdev_connect_gpio_out([[nath]], 0, adc); } } stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr.a); for (i = 0; i < 7; i++) { if (board->dc4 & (1 << i)) { gpio_dev[i] = sysbus_create_simple("pl061_luminary", gpio_addr[i], pic[gpio_irq[i]]); for (j = 0; j < 8; j++) { gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j); gpio_out[i][j] = NULL; } } } if (board->dc2 & (1 << 12)) { [[nath]] = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]); i2c = (I2CBus *)qdev_get_child_bus([[nath]], "i2c"); if (board->peripherals & BP_OLED_I2C) { i2c_create_slave(i2c, "ssd0303", 0x3d); } } for (i = 0; i < 4; i++) { if (board->dc2 & (1 << i)) { sysbus_create_simple("pl011_luminary", 0x4000c000 + i * 0x1000, pic[uart_irq[i]]); } } if (board->dc2 & (1 << 4)) { [[nath]] = sysbus_create_simple("pl022", 0x40008000, pic[7]); if (board->peripherals & BP_OLED_SSI) { void *bus; DeviceState *sddev; DeviceState *ssddev; bus = qdev_get_child_bus([[nath]], "ssi"); sddev = ssi_create_slave(bus, "ssi-sd"); ssddev = ssi_create_slave(bus, "ssd0323"); gpio_out[GPIO_D][0] = qemu_irq_split( qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0), qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0)); gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0); qemu_irq_raise(gpio_out[GPIO_D][0]); } } if (board->dc4 & (1 << 28)) { DeviceState *enet; qemu_check_nic_model(&nd_table[0], "stellaris"); enet = qdev_create(NULL, "stellaris_enet"); qdev_set_nic_properties(enet, &nd_table[0]); qdev_init_nofail(enet); sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000); sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]); } if (board->peripherals & BP_GAMEPAD) { qemu_irq gpad_irq[5]; static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d }; gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); stellaris_gamepad_init(5, gpad_irq, gpad_keycode); } for (i = 0; i < 7; i++) { if (board->dc4 & (1 << i)) { for (j = 0; j < 8; j++) { if (gpio_out[i][j]) { qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]); } } } } }
--------------------------------------------- Result 210 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 117 / 8 / 85 / 210:   8%|         | 210/2690 [40:50<8:02:17, 11.67s/it][Succeeded / Failed / Skipped / Total] 117 / 8 / 85 / 210:   8%|         | 211/2690 [41:57<8:12:57, 11.93s/it][Succeeded / Failed / Skipped / Total] 118 / 8 / 85 / 211:   8%|         | 211/2690 [41:57<8:12:57, 11.93s/it][Succeeded / Failed / Skipped / Total] 118 / 8 / 85 / 211:   8%|         | 212/2690 [41:57<8:10:31, 11.88s/it][Succeeded / Failed / Skipped / Total] 118 / 8 / 86 / 212:   8%|         | 212/2690 [41:57<8:10:31, 11.88s/it][Succeeded / Failed / Skipped / Total] 118 / 8 / 86 / 212:   8%|         | 213/2690 [46:03<8:55:36, 12.97s/it][Succeeded / Failed / Skipped / Total] 119 / 8 / 86 / 213:   8%|         | 213/2690 [46:03<8:55:36, 12.97s/it][Succeeded / Failed / Skipped / Total] 119 / 8 / 86 / 213:   8%|         | 214/2690 [46:38<8:59:35, 13.08s/it][[0 (68%)]] --> [[0 (44%)]] --> Socre: 0.5636759102344513

[[[[Adv]]]]: void cpu_exec_init(CPUState *[[env]]) { CPUState **penv; int cpu_index; if (!code_gen_ptr) { code_gen_ptr = code_gen_buffer; page_init(); io_mem_init(); } [[env]]->next_cpu = NULL; penv = &first_cpu; cpu_index = 0; while (*penv != NULL) { penv = (CPUState **)&(*penv)->next_cpu; cpu_index++; } [[env]]->cpu_index = cpu_index; *penv = [[env]]; }

[[[[Adv]]]]: void cpu_exec_init(CPUState *[[vigorous]]) { CPUState **penv; int cpu_index; if (!code_gen_ptr) { code_gen_ptr = code_gen_buffer; page_init(); io_mem_init(); } [[vigorous]]->next_cpu = NULL; penv = &first_cpu; cpu_index = 0; while (*penv != NULL) { penv = (CPUState **)&(*penv)->next_cpu; cpu_index++; } [[vigorous]]->cpu_index = cpu_index; *penv = [[vigorous]]; }
--------------------------------------------- Result 211 ---------------------------------------------
[[0 (66%)]] --> [[0 (47%)]] --> Socre: 0.5257569551467896

[[[[Adv]]]]: static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *[[usrc]], const uint8_t *vsrc, uint8_t *dst, long width, long height, long lumStride, long chromStride, long [[dstStride]]) { RENAME(yuvPlanartoyuy2)(ysrc, [[usrc]], vsrc, dst, width, height, lumStride, chromStride, [[dstStride]], 1); }

[[[[Adv]]]]: static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *[[negotiated]], const uint8_t *vsrc, uint8_t *dst, long width, long height, long lumStride, long chromStride, long [[propose]]) { RENAME(yuvPlanartoyuy2)(ysrc, [[negotiated]], vsrc, dst, width, height, lumStride, chromStride, [[propose]], 1); }
--------------------------------------------- Result 212 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline bool handler_is_async(const mon_cmd_t *cmd) { return cmd->flags & MONITOR_CMD_ASYNC; }
--------------------------------------------- Result 213 ---------------------------------------------
[[0 (96%)]] --> [[0 (46%)]] --> Socre: 0.5351933240890503

[[[[Adv]]]]: static inline int *DEC_UQUAD(int *[[dst]], unsigned idx, unsigned sign) { unsigned [[nz]] = idx >> 12; [[dst]][0] = (idx & 3) * (1 + (((int)sign >> 31) << 1)); sign <<= [[nz]] & 1; [[nz]] >>= 1; [[dst]][1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1)); sign <<= [[nz]] & 1; [[nz]] >>= 1; [[dst]][2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1)); sign <<= [[nz]] & 1; [[nz]] >>= 1; [[dst]][3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1)); return [[dst]] + 4; }

[[[[Adv]]]]: static inline int *DEC_UQUAD(int *[[std]], unsigned idx, unsigned sign) { unsigned [[notifying]] = idx >> 12; [[std]][0] = (idx & 3) * (1 + (((int)sign >> 31) << 1)); sign <<= [[notifying]] & 1; [[notifying]] >>= 1; [[std]][1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1)); sign <<= [[notifying]] & 1; [[notifying]] >>= 1; [[std]][2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1)); sign <<= [[notifying]] & 1; [[notifying]] >>= 1; [[std]][3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1)); return [[std]] + 4; }
--------------------------------------------- Result 214 ---------------------------------------------
[[0 (43%)]] --> [[0 (82%)]] --> Socre: 0.821381151676178

[[[[Adv]]]]: static int open_output_file(OptionsContext *o, const char *[[filename]]) { AVFormatContext *oc; int i, j, err; AVOutputFormat *file_oformat; OutputFile *of; OutputStream *ost; InputStream *ist; AVDictionary *unused_opts = NULL; AVDictionaryEntry *e = NULL; if (configure_complex_filters() < 0) { av_log(NULL, AV_LOG_FATAL, "Error configuring filters.\n"); exit_program(1); } if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) { o->stop_time = INT64_MAX; av_log(NULL, AV_LOG_WARNING, "-t and -to cannot be used together; using -t.\n"); } if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) { int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time; if (o->stop_time <= start_time) { av_log(NULL, AV_LOG_WARNING, "-to value smaller than -ss; ignoring -to.\n"); o->stop_time = INT64_MAX; } else { o->recording_time = o->stop_time - start_time; } } GROW_ARRAY(output_files, nb_output_files); of = av_mallocz(sizeof(*of)); if (!of) exit_program(1); output_files[nb_output_files - 1] = of; of->ost_index = nb_output_streams; of->recording_time = o->recording_time; of->start_time = o->start_time; of->limit_filesize = o->limit_filesize; of->shortest = o->shortest; av_dict_copy(&of->opts, o->g->format_opts, 0); if (!strcmp([[filename]], "-")) [[filename]] = "pipe:"; err = avformat_alloc_output_context2(&oc, NULL, o->format, [[filename]]); if (!oc) { print_error([[filename]], err); exit_program(1); } of->ctx = oc; if (o->recording_time != INT64_MAX) oc->duration = o->recording_time; file_oformat= oc->oformat; oc->interrupt_callback = int_cb; for (i = 0; i < nb_filtergraphs; i++) { FilterGraph *fg = filtergraphs[i]; for (j = 0; j < fg->nb_outputs; j++) { OutputFilter *ofilter = fg->outputs[j]; if (!ofilter->out_tmp || ofilter->out_tmp->name) continue; switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads, ofilter->out_tmp->pad_idx)) { case AVMEDIA_TYPE_VIDEO: o->video_disable = 1; break; case AVMEDIA_TYPE_AUDIO: o->audio_disable = 1; break; case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break; } init_output_filter(ofilter, o, oc); } } if (!strcmp(file_oformat->name, "ffm") && av_strstart([[filename]], "http:", NULL)) { int err = parse_option(o, "metadata", "creation_time=now", options); if (err < 0) { print_error([[filename]], err); exit_program(1); } } if (!strcmp(file_oformat->name, "ffm") && !override_ffserver && av_strstart([[filename]], "http:", NULL)) { int j; int err = read_ffserver_streams(o, oc, [[filename]]); if (err < 0) { print_error([[filename]], err); exit_program(1); } for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) { ost = output_streams[j]; for (i = 0; i < nb_input_streams; i++) { ist = input_streams[i]; if(ist->st->codec->codec_type == ost->st->codec->codec_type){ ost->sync_ist= ist; ost->source_index= i; if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup("anull"); if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup("null"); ist->discard = 0; ist->st->discard = AVDISCARD_NONE; break; } } if(!ost->sync_ist){ av_log(NULL, AV_LOG_FATAL, "Missing %s stream which is required by this ffm\n", av_get_media_type_string(ost->st->codec->codec_type)); exit_program(1); } } } else if (!o->nb_stream_maps) { char *subtitle_codec_name = NULL; if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) { int area = 0, idx = -1; int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0); for (i = 0; i < nb_input_streams; i++) { int new_area; ist = input_streams[i]; new_area = ist->st->codec->width * ist->st->codec->height; if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC)) new_area = 1; if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && new_area > area) { if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC)) continue; area = new_area; idx = i; } } if (idx >= 0) new_video_stream(o, oc, idx); } if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) { int channels = 0, idx = -1; for (i = 0; i < nb_input_streams; i++) { ist = input_streams[i]; if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO && ist->st->codec->channels > channels) { channels = ist->st->codec->channels; idx = i; } } if (idx >= 0) new_audio_stream(o, oc, idx); } MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, "s"); if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) { for (i = 0; i < nb_input_streams; i++) if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) { new_subtitle_stream(o, oc, i); break; } } } else { for (i = 0; i < o->nb_stream_maps; i++) { StreamMap *map = &o->stream_maps[i]; if (map->disabled) continue; if (map->linklabel) { FilterGraph *fg; OutputFilter *ofilter = NULL; int j, k; for (j = 0; j < nb_filtergraphs; j++) { fg = filtergraphs[j]; for (k = 0; k < fg->nb_outputs; k++) { AVFilterInOut *out = fg->outputs[k]->out_tmp; if (out && !strcmp(out->name, map->linklabel)) { ofilter = fg->outputs[k]; goto loop_end; } } } loop_end: if (!ofilter) { av_log(NULL, AV_LOG_FATAL, "Output with label '%s' does not exist " "in any defined filter graph, or was already used elsewhere.\n", map->linklabel); exit_program(1); } init_output_filter(ofilter, o, oc); } else { int src_idx = input_files[map->file_index]->ist_index + map->stream_index; ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index]; if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) continue; if(o-> audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) continue; if(o-> video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) continue; if(o-> data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA) continue; switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_VIDEO: ost = new_video_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_AUDIO: ost = new_audio_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_DATA: ost = new_data_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break; default: av_log(NULL, AV_LOG_FATAL, "Cannot map stream #%d:%d - unsupported type.\n", map->file_index, map->stream_index); exit_program(1); } } } } for (i = 0; i < o->nb_attachments; i++) { AVIOContext *pb; uint8_t *attachment; const char *p; int64_t len; if ((err = avio_open2(&pb, o->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) { av_log(NULL, AV_LOG_FATAL, "Could not open attachment file %s.\n", o->attachments[i]); exit_program(1); } if ((len = avio_size(pb)) <= 0) { av_log(NULL, AV_LOG_FATAL, "Could not get size of the attachment %s.\n", o->attachments[i]); exit_program(1); } if (!(attachment = av_malloc(len))) { av_log(NULL, AV_LOG_FATAL, "Attachment %s too large to fit into memory.\n", o->attachments[i]); exit_program(1); } avio_read(pb, attachment, len); ost = new_attachment_stream(o, oc, -1); ost->stream_copy = 0; ost->attachment_filename = o->attachments[i]; ost->finished = 1; ost->st->codec->extradata = attachment; ost->st->codec->extradata_size = len; p = strrchr(o->attachments[i], '/'); av_dict_set(&ost->st->metadata, "filename", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE); avio_close(pb); } for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) { AVDictionaryEntry *e; ost = output_streams[i]; if ((ost->stream_copy || ost->attachment_filename) && (e = av_dict_get(o->g->codec_opts, "flags", NULL, AV_DICT_IGNORE_SUFFIX)) && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6))) if (av_opt_set(ost->st->codec, "flags", e->value, 0) < 0) exit_program(1); } unused_opts = strip_specifiers(o->g->codec_opts); for (i = of->ost_index; i < nb_output_streams; i++) { e = NULL; while ((e = av_dict_get(output_streams[i]->opts, "", e, AV_DICT_IGNORE_SUFFIX))) av_dict_set(&unused_opts, e->key, NULL, 0); } e = NULL; while ((e = av_dict_get(unused_opts, "", e, AV_DICT_IGNORE_SUFFIX))) { const AVClass *class = avcodec_get_class(); const AVOption *option = av_opt_find(&class, e->key, NULL, 0, AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ); if (!option) continue; if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) { av_log(NULL, AV_LOG_ERROR, "Codec AVOption %s (%s) specified for " "output file #%d (%s) is not an encoding option.\n", e->key, option->help ? option->help : "", nb_output_files - 1, [[filename]]); exit_program(1); } if (!strcmp(e->key, "gop_timecode")) continue; av_log(NULL, AV_LOG_WARNING, "Codec AVOption %s (%s) specified for " "output file #%d (%s) has not been used for any stream. The most " "likely reason is either wrong type (e.g. a video option with " "no video streams) or that it is a private option of some encoder " "which was not actually used for any stream.\n", e->key, option->help ? option->help : "", nb_output_files - 1, [[filename]]); } av_dict_free(&unused_opts); if (oc->oformat->flags & AVFMT_NEEDNUMBER) { if (!av_filename_number_test(oc->filename)) { print_error(oc->filename, AVERROR(EINVAL)); exit_program(1); } } if (!(oc->oformat->flags & AVFMT_NOFILE)) { assert_file_overwrite([[filename]]); if ((err = avio_open2(&oc->pb, [[filename]], AVIO_FLAG_WRITE, &oc->interrupt_callback, &of->opts)) < 0) { print_error([[filename]], err); exit_program(1); } } else if (strcmp(oc->oformat->name, "image2")==0 && !av_filename_number_test([[filename]])) assert_file_overwrite([[filename]]); if (o->mux_preload) { uint8_t buf[64]; snprintf(buf, sizeof(buf), "%d", (int)(o->mux_preload*AV_TIME_BASE)); av_dict_set(&of->opts, "preload", buf, 0); } oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE); for (i = 0; i < o->nb_metadata_map; i++) { char *p; int in_file_index = strtol(o->metadata_map[i].u.str, &p, 0); if (in_file_index >= nb_input_files) { av_log(NULL, AV_LOG_FATAL, "Invalid input file index %d while processing metadata maps\n", in_file_index); exit_program(1); } copy_metadata(o->metadata_map[i].specifier, *p ? p + 1 : p, oc, in_file_index >= 0 ? input_files[in_file_index]->ctx : NULL, o); } if (o->chapters_input_file >= nb_input_files) { if (o->chapters_input_file == INT_MAX) { o->chapters_input_file = -1; for (i = 0; i < nb_input_files; i++) if (input_files[i]->ctx->nb_chapters) { o->chapters_input_file = i; break; } } else { av_log(NULL, AV_LOG_FATAL, "Invalid input file index %d in chapter mapping.\n", o->chapters_input_file); exit_program(1); } } if (o->chapters_input_file >= 0) copy_chapters(input_files[o->chapters_input_file], of, !o->metadata_chapters_manual); if (!o->metadata_global_manual && nb_input_files){ av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata, AV_DICT_DONT_OVERWRITE); if(o->recording_time != INT64_MAX) av_dict_set(&oc->metadata, "duration", NULL, 0); av_dict_set(&oc->metadata, "creation_time", NULL, 0); } if (!o->metadata_streams_manual) for (i = of->ost_index; i < nb_output_streams; i++) { InputStream *ist; if (output_streams[i]->source_index < 0) continue; ist = input_streams[output_streams[i]->source_index]; av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE); } for (i = 0; i < o->nb_metadata; i++) { AVDictionary **m; char type, *val; const char *stream_spec; int index = 0, j, ret = 0; val = strchr(o->metadata[i].u.str, '='); if (!val) { av_log(NULL, AV_LOG_FATAL, "No '=' character in metadata string %s.\n", o->metadata[i].u.str); exit_program(1); } *val++ = 0; parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec); if (type == 's') { for (j = 0; j < oc->nb_streams; j++) { if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) { av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0); } else if (ret < 0) exit_program(1); } } else { switch (type) { case 'g': m = &oc->metadata; break; case 'c': if (index < 0 || index >= oc->nb_chapters) { av_log(NULL, AV_LOG_FATAL, "Invalid chapter index %d in metadata specifier.\n", index); exit_program(1); } m = &oc->chapters[index]->metadata; break; default: av_log(NULL, AV_LOG_FATAL, "Invalid metadata specifier %s.\n", o->metadata[i].specifier); exit_program(1); } av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0); } } return 0; }

[[[[Adv]]]]: static int open_output_file(OptionsContext *o, const char *[[adu]]) { AVFormatContext *oc; int i, j, err; AVOutputFormat *file_oformat; OutputFile *of; OutputStream *ost; InputStream *ist; AVDictionary *unused_opts = NULL; AVDictionaryEntry *e = NULL; if (configure_complex_filters() < 0) { av_log(NULL, AV_LOG_FATAL, "Error configuring filters.\n"); exit_program(1); } if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) { o->stop_time = INT64_MAX; av_log(NULL, AV_LOG_WARNING, "-t and -to cannot be used together; using -t.\n"); } if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) { int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time; if (o->stop_time <= start_time) { av_log(NULL, AV_LOG_WARNING, "-to value smaller than -ss; ignoring -to.\n"); o->stop_time = INT64_MAX; } else { o->recording_time = o->stop_time - start_time; } } GROW_ARRAY(output_files, nb_output_files); of = av_mallocz(sizeof(*of)); if (!of) exit_program(1); output_files[nb_output_files - 1] = of; of->ost_index = nb_output_streams; of->recording_time = o->recording_time; of->start_time = o->start_time; of->limit_filesize = o->limit_filesize; of->shortest = o->shortest; av_dict_copy(&of->opts, o->g->format_opts, 0); if (!strcmp([[adu]], "-")) [[adu]] = "pipe:"; err = avformat_alloc_output_context2(&oc, NULL, o->format, [[adu]]); if (!oc) { print_error([[adu]], err); exit_program(1); } of->ctx = oc; if (o->recording_time != INT64_MAX) oc->duration = o->recording_time; file_oformat= oc->oformat; oc->interrupt_callback = int_cb; for (i = 0; i < nb_filtergraphs; i++) { FilterGraph *fg = filtergraphs[i]; for (j = 0; j < fg->nb_outputs; j++) { OutputFilter *ofilter = fg->outputs[j]; if (!ofilter->out_tmp || ofilter->out_tmp->name) continue; switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads, ofilter->out_tmp->pad_idx)) { case AVMEDIA_TYPE_VIDEO: o->video_disable = 1; break; case AVMEDIA_TYPE_AUDIO: o->audio_disable = 1; break; case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break; } init_output_filter(ofilter, o, oc); } } if (!strcmp(file_oformat->name, "ffm") && av_strstart([[adu]], "http:", NULL)) { int err = parse_option(o, "metadata", "creation_time=now", options); if (err < 0) { print_error([[adu]], err); exit_program(1); } } if (!strcmp(file_oformat->name, "ffm") && !override_ffserver && av_strstart([[adu]], "http:", NULL)) { int j; int err = read_ffserver_streams(o, oc, [[adu]]); if (err < 0) { print_error([[adu]], err); exit_program(1); } for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) { ost = output_streams[j]; for (i = 0; i < nb_input_streams; i++) { ist = input_streams[i]; if(ist->st->codec->codec_type == ost->st->codec->codec_type){ ost->sync_ist= ist; ost->source_index= i; if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup("anull"); if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup("null"); ist->discard = 0; ist->st->discard = AVDISCARD_NONE; break; } } if(!ost->sync_ist){ av_log(NULL, AV_LOG_FATAL, "Missing %s stream which is required by this ffm\n", av_get_media_type_string(ost->st->codec->codec_type)); exit_program(1); } } } else if (!o->nb_stream_maps) { char *subtitle_codec_name = NULL; if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) { int area = 0, idx = -1; int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0); for (i = 0; i < nb_input_streams; i++) { int new_area; ist = input_streams[i]; new_area = ist->st->codec->width * ist->st->codec->height; if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC)) new_area = 1; if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && new_area > area) { if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC)) continue; area = new_area; idx = i; } } if (idx >= 0) new_video_stream(o, oc, idx); } if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) { int channels = 0, idx = -1; for (i = 0; i < nb_input_streams; i++) { ist = input_streams[i]; if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO && ist->st->codec->channels > channels) { channels = ist->st->codec->channels; idx = i; } } if (idx >= 0) new_audio_stream(o, oc, idx); } MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, "s"); if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) { for (i = 0; i < nb_input_streams; i++) if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) { new_subtitle_stream(o, oc, i); break; } } } else { for (i = 0; i < o->nb_stream_maps; i++) { StreamMap *map = &o->stream_maps[i]; if (map->disabled) continue; if (map->linklabel) { FilterGraph *fg; OutputFilter *ofilter = NULL; int j, k; for (j = 0; j < nb_filtergraphs; j++) { fg = filtergraphs[j]; for (k = 0; k < fg->nb_outputs; k++) { AVFilterInOut *out = fg->outputs[k]->out_tmp; if (out && !strcmp(out->name, map->linklabel)) { ofilter = fg->outputs[k]; goto loop_end; } } } loop_end: if (!ofilter) { av_log(NULL, AV_LOG_FATAL, "Output with label '%s' does not exist " "in any defined filter graph, or was already used elsewhere.\n", map->linklabel); exit_program(1); } init_output_filter(ofilter, o, oc); } else { int src_idx = input_files[map->file_index]->ist_index + map->stream_index; ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index]; if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) continue; if(o-> audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) continue; if(o-> video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) continue; if(o-> data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA) continue; switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_VIDEO: ost = new_video_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_AUDIO: ost = new_audio_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_DATA: ost = new_data_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break; default: av_log(NULL, AV_LOG_FATAL, "Cannot map stream #%d:%d - unsupported type.\n", map->file_index, map->stream_index); exit_program(1); } } } } for (i = 0; i < o->nb_attachments; i++) { AVIOContext *pb; uint8_t *attachment; const char *p; int64_t len; if ((err = avio_open2(&pb, o->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) { av_log(NULL, AV_LOG_FATAL, "Could not open attachment file %s.\n", o->attachments[i]); exit_program(1); } if ((len = avio_size(pb)) <= 0) { av_log(NULL, AV_LOG_FATAL, "Could not get size of the attachment %s.\n", o->attachments[i]); exit_program(1); } if (!(attachment = av_malloc(len))) { av_log(NULL, AV_LOG_FATAL, "Attachment %s too large to fit into memory.\n", o->attachments[i]); exit_program(1); } avio_read(pb, attachment, len); ost = new_attachment_stream(o, oc, -1); ost->stream_copy = 0; ost->attachment_filename = o->attachments[i]; ost->finished = 1; ost->st->codec->extradata = attachment; ost->st->codec->extradata_size = len; p = strrchr(o->attachments[i], '/'); av_dict_set(&ost->st->metadata, "filename", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE); avio_close(pb); } for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) { AVDictionaryEntry *e; ost = output_streams[i]; if ((ost->stream_copy || ost->attachment_filename) && (e = av_dict_get(o->g->codec_opts, "flags", NULL, AV_DICT_IGNORE_SUFFIX)) && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6))) if (av_opt_set(ost->st->codec, "flags", e->value, 0) < 0) exit_program(1); } unused_opts = strip_specifiers(o->g->codec_opts); for (i = of->ost_index; i < nb_output_streams; i++) { e = NULL; while ((e = av_dict_get(output_streams[i]->opts, "", e, AV_DICT_IGNORE_SUFFIX))) av_dict_set(&unused_opts, e->key, NULL, 0); } e = NULL; while ((e = av_dict_get(unused_opts, "", e, AV_DICT_IGNORE_SUFFIX))) { const AVClass *class = avcodec_get_class(); const AVOption *option = av_opt_find(&class, e->key, NULL, 0, AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ); if (!option) continue; if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) { av_log(NULL, AV_LOG_ERROR, "Codec AVOption %s (%s) specified for " "output file #%d (%s) is not an encoding option.\n", e->key, option->help ? option->help : "", nb_output_files - 1, [[adu]]); exit_program(1); } if (!strcmp(e->key, "gop_timecode")) continue; av_log(NULL, AV_LOG_WARNING, "Codec AVOption %s (%s) specified for " "output file #%d (%s) has not been used for any stream. The most " "likely reason is either wrong type (e.g. a video option with " "no video streams) or that it is a private option of some encoder " "which was not actually used for any stream.\n", e->key, option->help ? option->help : "", nb_output_files - 1, [[adu]]); } av_dict_free(&unused_opts); if (oc->oformat->flags & AVFMT_NEEDNUMBER) { if (!av_filename_number_test(oc->filename)) { print_error(oc->filename, AVERROR(EINVAL)); exit_program(1); } } if (!(oc->oformat->flags & AVFMT_NOFILE)) { assert_file_overwrite([[adu]]); if ((err = avio_open2(&oc->pb, [[adu]], AVIO_FLAG_WRITE, &oc->interrupt_callback, &of->opts)) < 0) { print_error([[adu]], err); exit_program(1); } } else if (strcmp(oc->oformat->name, "image2")==0 && !av_filename_number_test([[adu]])) assert_file_overwrite([[adu]]); if (o->mux_preload) { uint8_t buf[64]; snprintf(buf, sizeof(buf), "%d", (int)(o->mux_preload*AV_TIME_BASE)); av_dict_set(&of->opts, "preload", buf, 0); } oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE); for (i = 0; i < o->nb_metadata_map; i++) { char *p; int in_file_index = strtol(o->metadata_map[i].u.str, &p, 0); if (in_file_index >= nb_input_files) { av_log(NULL, AV_LOG_FATAL, "Invalid input file index %d while processing metadata maps\n", in_file_index); exit_program(1); } copy_metadata(o->metadata_map[i].specifier, *p ? p + 1 : p, oc, in_file_index >= 0 ? input_files[in_file_index]->ctx : NULL, o); } if (o->chapters_input_file >= nb_input_files) { if (o->chapters_input_file == INT_MAX) { o->chapters_input_file = -1; for (i = 0; i < nb_input_files; i++) if (input_files[i]->ctx->nb_chapters) { o->chapters_input_file = i; break; } } else { av_log(NULL, AV_LOG_FATAL, "Invalid input file index %d in chapter mapping.\n", o->chapters_input_file); exit_program(1); } } if (o->chapters_input_file >= 0) copy_chapters(input_files[o->chapters_input_file], of, !o->metadata_chapters_manual); if (!o->metadata_global_manual && nb_input_files){ av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata, AV_DICT_DONT_OVERWRITE); if(o->recording_time != INT64_MAX) av_dict_set(&oc->metadata, "duration", NULL, 0); av_dict_set(&oc->metadata, "creation_time", NULL, 0); } if (!o->metadata_streams_manual) for (i = of->ost_index; i < nb_output_streams; i++) { InputStream *ist; if (output_streams[i]->source_index < 0) continue; ist = input_streams[output_streams[i]->source_index]; av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE); } for (i = 0; i < o->nb_metadata; i++) { AVDictionary **m; char type, *val; const char *stream_spec; int index = 0, j, ret = 0; val = strchr(o->metadata[i].u.str, '='); if (!val) { av_log(NULL, AV_LOG_FATAL, "No '=' character in metadata string %s.\n", o->metadata[i].u.str); exit_program(1); } *val++ = 0; parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec); if (type == 's') { for (j = 0; j < oc->nb_streams; j++) { if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) { av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0); } else if (ret < 0) exit_program(1); } } else { switch (type) { case 'g': m = &oc->metadata; break; case 'c': if (index < 0 || index >= oc->nb_chapters) { av_log(NULL, AV_LOG_FATAL, "Invalid chapter index %d in metadata specifier.\n", index); exit_program(1); } m = &oc->chapters[index]->metadata; break; default: av_log(NULL, AV_LOG_FATAL, "Invalid metadata specifier %s.\n", o->metadata[i].specifier); exit_program(1); } av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0); } } return 0; }[Succeeded / Failed / Skipped / Total] 120 / 8 / 86 / 214:   8%|         | 214/2690 [46:38<8:59:35, 13.08s/it][Succeeded / Failed / Skipped / Total] 120 / 8 / 86 / 214:   8%|         | 215/2690 [48:00<9:12:38, 13.40s/it][Succeeded / Failed / Skipped / Total] 121 / 8 / 86 / 215:   8%|         | 215/2690 [48:00<9:12:38, 13.40s/it][Succeeded / Failed / Skipped / Total] 121 / 8 / 86 / 215:   8%|         | 216/2690 [48:06<9:11:04, 13.36s/it][Succeeded / Failed / Skipped / Total] 122 / 8 / 86 / 216:   8%|         | 216/2690 [48:06<9:11:05, 13.36s/it][Succeeded / Failed / Skipped / Total] 122 / 8 / 86 / 216:   8%|         | 217/2690 [48:07<9:08:25, 13.31s/it][Succeeded / Failed / Skipped / Total] 122 / 8 / 87 / 217:   8%|         | 217/2690 [48:07<9:08:25, 13.31s/it][Succeeded / Failed / Skipped / Total] 122 / 8 / 87 / 217:   8%|         | 218/2690 [49:55<9:26:09, 13.74s/it][Succeeded / Failed / Skipped / Total] 123 / 8 / 87 / 218:   8%|         | 218/2690 [49:55<9:26:09, 13.74s/it][Succeeded / Failed / Skipped / Total] 123 / 8 / 87 / 218:   8%|         | 219/2690 [53:16<10:01:05, 14.60s/it]
--------------------------------------------- Result 215 ---------------------------------------------
[[0 (73%)]] --> [[0 (38%)]] --> Socre: 0.6239247024059296

[[[[Adv]]]]: static bool logic_imm_decode_wmask(uint64_t *result, unsigned int [[immn]], unsigned int imms, unsigned int [[immr]]) { uint64_t mask; unsigned e, levels, s, r; int len; assert([[immn]] < 2 && imms < 64 && [[immr]] < 64); len = 31 - clz32(([[immn]] << 6) | (~imms & 0x3f)); if (len < 1) { return "False" != "False"; } e = 1 << len; levels = e - 1; s = imms & levels; r = [[immr]] & levels; if (s == levels) { return "False" != "False"; } mask = bitmask64(s + 1); mask = (mask >> r) | (mask << (e - r)); mask = bitfield_replicate(mask, e); *result = mask; return "True" == "True"; }

[[[[Adv]]]]: static bool logic_imm_decode_wmask(uint64_t *result, unsigned int [[signor]], unsigned int imms, unsigned int [[tasking]]) { uint64_t mask; unsigned e, levels, s, r; int len; assert([[signor]] < 2 && imms < 64 && [[tasking]] < 64); len = 31 - clz32(([[signor]] << 6) | (~imms & 0x3f)); if (len < 1) { return "False" != "False"; } e = 1 << len; levels = e - 1; s = imms & levels; r = [[tasking]] & levels; if (s == levels) { return "False" != "False"; } mask = bitmask64(s + 1); mask = (mask >> r) | (mask << (e - r)); mask = bitfield_replicate(mask, e); *result = mask; return "True" == "True"; }
--------------------------------------------- Result 216 ---------------------------------------------
[[0 (82%)]] --> [[0 (48%)]] --> Socre: 0.5222396552562714

[[[[Adv]]]]: static int add_candidate_ref(HEVCContext *s, RefPicList *list, int [[poc]], int ref_flag) { HEVCFrame *[[ref]] = find_ref_idx(s, [[poc]]); if ([[ref]] == s->ref) return AVERROR_INVALIDDATA; if (![[ref]]) { [[ref]] = generate_missing_ref(s, [[poc]]); if (![[ref]]) return AVERROR(ENOMEM); } list->list[list->nb_refs] = [[ref]]->poc; list->ref[list->nb_refs] = [[ref]]; list->nb_refs++; mark_ref([[ref]], ref_flag); return 0; }

[[[[Adv]]]]: static int add_candidate_ref(HEVCContext *s, RefPicList *list, int [[cubs]], int ref_flag) { HEVCFrame *[[joubert]] = find_ref_idx(s, [[cubs]]); if ([[joubert]] == s->ref) return AVERROR_INVALIDDATA; if (![[joubert]]) { [[joubert]] = generate_missing_ref(s, [[cubs]]); if (![[joubert]]) return AVERROR(ENOMEM); } list->list[list->nb_refs] = [[joubert]]->poc; list->ref[list->nb_refs] = [[joubert]]; list->nb_refs++; mark_ref([[joubert]], ref_flag); return 0; }
--------------------------------------------- Result 217 ---------------------------------------------
[[0 (23%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn) { if (r < 0 || r > 15) { fprintf(stderr, "wrong register write $p%d\n", r); } if (r == PR_BZ || r == PR_WZ || r == PR_DZ) { return; } else if (r == PR_SRS) { tcg_gen_andi_tl(cpu_PR[r], tn, 3); } else { if (r == PR_PID) { gen_helper_tlb_flush_pid(cpu_env, tn); } if (dc->tb_flags & S_FLAG && r == PR_SPC) { gen_helper_spc_write(cpu_env, tn); } else if (r == PR_CCS) { dc->cpustate_changed = 1; } tcg_gen_mov_tl(cpu_PR[r], tn); } }
--------------------------------------------- Result 218 ---------------------------------------------
[[0 (70%)]] --> [[0 (49%)]] --> Socre: 0.5060561895370483

[[[[Adv]]]]: static int vorbis_parse_id_hdr(vorbis_context *vc){ GetBitContext *gb=&vc->gb; uint_fast8_t [[bl0]], bl1; if ((get_bits(gb, 8)!='v') || (get_bits(gb, 8)!='o') || (get_bits(gb, 8)!='r') || (get_bits(gb, 8)!='b') || (get_bits(gb, 8)!='i') || (get_bits(gb, 8)!='s')) { av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (no vorbis signature). \n"); return 1; } vc->version=get_bits_long(gb, 32); vc->audio_channels=get_bits(gb, 8); vc->audio_samplerate=get_bits_long(gb, 32); vc->bitrate_maximum=get_bits_long(gb, 32); vc->bitrate_nominal=get_bits_long(gb, 32); vc->bitrate_minimum=get_bits_long(gb, 32); [[bl0]]=get_bits(gb, 4); bl1=get_bits(gb, 4); vc->blocksize[0]=(1<<[[bl0]]); vc->blocksize[1]=(1<<bl1); if ([[bl0]]>13 || [[bl0]]<6 || bl1>13 || bl1<6 || bl1<[[bl0]]) { av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (illegal blocksize). \n"); return 3; } if (vc->blocksize[1]/2 * vc->audio_channels * 2 > AVCODEC_MAX_AUDIO_FRAME_SIZE) { av_log(vc->avccontext, AV_LOG_ERROR, "Vorbis channel count makes " "output packets too large.\n"); return 4; } vc->win[0]=ff_vorbis_vwin[[[bl0]]-6]; vc->win[1]=ff_vorbis_vwin[bl1-6]; if(vc->exp_bias){ int i, j; for(j=0; j<2; j++){ float *win = av_malloc(vc->blocksize[j]/2 * sizeof(float)); for(i=0; i<vc->blocksize[j]/2; i++) win[i] = vc->win[j][i] * (1<<15); vc->win[j] = win; } } if ((get_bits1(gb)) == 0) { av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (framing flag not set). \n"); return 2; } vc->channel_residues= av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float)); vc->channel_floors = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float)); vc->saved = av_mallocz((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float)); vc->ret = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float)); vc->buf = av_malloc( vc->blocksize[1] * sizeof(float)); vc->buf_tmp = av_malloc( vc->blocksize[1] * sizeof(float)); vc->previous_window=0; ff_mdct_init(&vc->mdct[0], [[bl0]], 1); ff_mdct_init(&vc->mdct[1], bl1, 1); AV_DEBUG(" vorbis version %d \n audio_channels %d \n audio_samplerate %d \n bitrate_max %d \n bitrate_nom %d \n bitrate_min %d \n blk_0 %d blk_1 %d \n ", vc->version, vc->audio_channels, vc->audio_samplerate, vc->bitrate_maximum, vc->bitrate_nominal, vc->bitrate_minimum, vc->blocksize[0], vc->blocksize[1]); return 0; }

[[[[Adv]]]]: static int vorbis_parse_id_hdr(vorbis_context *vc){ GetBitContext *gb=&vc->gb; uint_fast8_t [[lubricant]], bl1; if ((get_bits(gb, 8)!='v') || (get_bits(gb, 8)!='o') || (get_bits(gb, 8)!='r') || (get_bits(gb, 8)!='b') || (get_bits(gb, 8)!='i') || (get_bits(gb, 8)!='s')) { av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (no vorbis signature). \n"); return 1; } vc->version=get_bits_long(gb, 32); vc->audio_channels=get_bits(gb, 8); vc->audio_samplerate=get_bits_long(gb, 32); vc->bitrate_maximum=get_bits_long(gb, 32); vc->bitrate_nominal=get_bits_long(gb, 32); vc->bitrate_minimum=get_bits_long(gb, 32); [[lubricant]]=get_bits(gb, 4); bl1=get_bits(gb, 4); vc->blocksize[0]=(1<<[[lubricant]]); vc->blocksize[1]=(1<<bl1); if ([[lubricant]]>13 || [[lubricant]]<6 || bl1>13 || bl1<6 || bl1<[[lubricant]]) { av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (illegal blocksize). \n"); return 3; } if (vc->blocksize[1]/2 * vc->audio_channels * 2 > AVCODEC_MAX_AUDIO_FRAME_SIZE) { av_log(vc->avccontext, AV_LOG_ERROR, "Vorbis channel count makes " "output packets too large.\n"); return 4; } vc->win[0]=ff_vorbis_vwin[[[lubricant]]-6]; vc->win[1]=ff_vorbis_vwin[bl1-6]; if(vc->exp_bias){ int i, j; for(j=0; j<2; j++){ float *win = av_malloc(vc->blocksize[j]/2 * sizeof(float)); for(i=0; i<vc->blocksize[j]/2; i++) win[i] = vc->win[j][i] * (1<<15); vc->win[j] = win; } } if ((get_bits1(gb)) == 0) { av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (framing flag not set). \n"); return 2; } vc->channel_residues= av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float)); vc->channel_floors = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float)); vc->saved = av_mallocz((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float)); vc->ret = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float)); vc->buf = av_malloc( vc->blocksize[1] * sizeof(float)); vc->buf_tmp = av_malloc( vc->blocksize[1] * sizeof(float)); vc->previous_window=0; ff_mdct_init(&vc->mdct[0], [[lubricant]], 1); ff_mdct_init(&vc->mdct[1], bl1, 1); AV_DEBUG(" vorbis version %d \n audio_channels %d \n audio_samplerate %d \n bitrate_max %d \n bitrate_nom %d \n bitrate_min %d \n blk_0 %d blk_1 %d \n ", vc->version, vc->audio_channels, vc->audio_samplerate, vc->bitrate_maximum, vc->bitrate_nominal, vc->bitrate_minimum, vc->blocksize[0], vc->blocksize[1]); return 0; }
[Succeeded / Failed / Skipped / Total] 124 / 8 / 87 / 219:   8%|         | 219/2690 [53:16<10:01:05, 14.60s/it][Succeeded / Failed / Skipped / Total] 124 / 8 / 87 / 219:   8%|         | 220/2690 [53:16<9:58:12, 14.53s/it] [Succeeded / Failed / Skipped / Total] 124 / 8 / 88 / 220:   8%|         | 220/2690 [53:16<9:58:12, 14.53s/it][Succeeded / Failed / Skipped / Total] 124 / 8 / 88 / 220:   8%|         | 221/2690 [53:50<10:01:27, 14.62s/it][Succeeded / Failed / Skipped / Total] 125 / 8 / 88 / 221:   8%|         | 221/2690 [53:50<10:01:27, 14.62s/it][Succeeded / Failed / Skipped / Total] 125 / 8 / 88 / 221:   8%|         | 222/2690 [53:50<9:58:36, 14.55s/it] [Succeeded / Failed / Skipped / Total] 125 / 8 / 89 / 222:   8%|         | 222/2690 [53:50<9:58:36, 14.55s/it][Succeeded / Failed / Skipped / Total] 125 / 8 / 89 / 222:   8%|         | 223/2690 [53:58<9:57:08, 14.52s/it]--------------------------------------------- Result 219 ---------------------------------------------
[[0 (1%)]] --> [[0 (67%)]] --> Socre: 0.6662160158157349

[[[[Adv]]]]: static void omap_pwt_write(void *[[opaque]], target_phys_addr_t addr, uint64_t [[value]], unsigned size) { struct omap_pwt_s *s = (struct omap_pwt_s *) [[opaque]]; int [[offset]] = addr & OMAP_MPUI_REG_MASK; if (size != 1) { return omap_badwidth_write8([[opaque]], addr, [[value]]); } switch ([[offset]]) { case 0x00: s->frc = [[value]] & 0x3f; break; case 0x04: if (([[value]] ^ s->vrc) & 1) { if ([[value]] & 1) printf("%s: %iHz buzz on\n", __FUNCTION__, (int) ((omap_clk_getrate(s->clk) >> 3) / ((s->gcr & 2) ? 1 : 154) / (2 << ([[value]] & 3)) * (([[value]] & (1 << 2)) ? 101 : 107) * (([[value]] & (1 << 3)) ? 49 : 55) * (([[value]] & (1 << 4)) ? 50 : 63) * (([[value]] & (1 << 5)) ? 80 : 127) / (107 * 55 * 63 * 127))); else printf("%s: silence!\n", __FUNCTION__); } s->vrc = [[value]] & 0x7f; break; case 0x08: s->gcr = [[value]] & 3; break; default: OMAP_BAD_REG(addr); return; } }

[[[[Adv]]]]: static void omap_pwt_write(void *[[bewildering]], target_phys_addr_t addr, uint64_t [[inestimable]], unsigned size) { struct omap_pwt_s *s = (struct omap_pwt_s *) [[bewildering]]; int [[deactivated]] = addr & OMAP_MPUI_REG_MASK; if (size != 1) { return omap_badwidth_write8([[bewildering]], addr, [[inestimable]]); } switch ([[deactivated]]) { case 0x00: s->frc = [[inestimable]] & 0x3f; break; case 0x04: if (([[inestimable]] ^ s->vrc) & 1) { if ([[inestimable]] & 1) printf("%s: %iHz buzz on\n", __FUNCTION__, (int) ((omap_clk_getrate(s->clk) >> 3) / ((s->gcr & 2) ? 1 : 154) / (2 << ([[inestimable]] & 3)) * (([[inestimable]] & (1 << 2)) ? 101 : 107) * (([[inestimable]] & (1 << 3)) ? 49 : 55) * (([[inestimable]] & (1 << 4)) ? 50 : 63) * (([[inestimable]] & (1 << 5)) ? 80 : 127) / (107 * 55 * 63 * 127))); else printf("%s: silence!\n", __FUNCTION__); } s->vrc = [[inestimable]] & 0x7f; break; case 0x08: s->gcr = [[inestimable]] & 3; break; default: OMAP_BAD_REG(addr); return; } }
--------------------------------------------- Result 220 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int net_vhost_user_init(NetClientState *peer, const char *device, const char *name, CharDriverState *chr, int queues) { NetClientState *nc; VhostUserState *s; int i; for (i = 0; i < queues; i++) { nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name); snprintf(nc->info_str, sizeof(nc->info_str), "vhost-user%d to %s", i, chr->label); nc->queue_index = i; s = DO_UPCAST(VhostUserState, nc, nc); s->chr = chr; } qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name); return 0; }
--------------------------------------------- Result 221 ---------------------------------------------
[[0 (6%)]] --> [[0 (53%)]] --> Socre: 0.5335231423377991

[[[[Adv]]]]: static int flv_probe(AVProbeData *[[p]]) { const uint8_t *[[d]]; if ([[p]]->buf_size < 6) return 0; [[d]] = [[p]]->buf; if ([[d]][0] == 'F' && [[d]][1] == 'L' && [[d]][2] == 'V' && [[d]][3] < 5 && [[d]][5]==0) { return AVPROBE_SCORE_MAX; } return 0; }

[[[[Adv]]]]: static int flv_probe(AVProbeData *[[pg]]) { const uint8_t *[[aux]]; if ([[pg]]->buf_size < 6) return 0; [[aux]] = [[pg]]->buf; if ([[aux]][0] == 'F' && [[aux]][1] == 'L' && [[aux]][2] == 'V' && [[aux]][3] < 5 && [[aux]][5]==0) { return AVPROBE_SCORE_MAX; } return 0; }
--------------------------------------------- Result 222 ---------------------------------------------
[[0 (71%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void scsi_read_data(SCSIDevice *d, uint32_t tag) { SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d); SCSIDiskReq *r; r = scsi_find_request(s, tag); if (!r) { BADF("Bad read tag 0x%x\n", tag); scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR); return; } assert(r->req.aiocb == NULL); scsi_read_request(r); }
--------------------------------------------- Result 223 ---------------------------------------------
[[0 (42%)]] --> [[0 (96%)]] --> Socre: 0.9598616361618042

[[[[Adv]]]]: static void opt_output_file(void *optctx, const char *[[filename]]) { OptionsContext *o = optctx; AVFormatContext *oc; int i, err; AVOutputFormat *file_oformat; OutputStream *ost; InputStream *ist; if (!strcmp([[filename]], "-")) [[filename]] = "pipe:"; oc = avformat_alloc_context(); if (!oc) { print_error([[filename]], AVERROR(ENOMEM)); exit_program(1); } if (last_asked_format) { file_oformat = av_guess_format(last_asked_format, NULL, NULL); if (!file_oformat) { fprintf(stderr, "Requested output format '%s' is not a suitable output format\n", last_asked_format); exit_program(1); } last_asked_format = NULL; } else { file_oformat = av_guess_format(NULL, [[filename]], NULL); if (!file_oformat) { fprintf(stderr, "Unable to find a suitable output format for '%s'\n", [[filename]]); exit_program(1); } } oc->oformat = file_oformat; av_strlcpy(oc->filename, [[filename]], sizeof(oc->filename)); if (!strcmp(file_oformat->name, "ffm") && av_strstart([[filename]], "http:", NULL)) { int err = read_avserver_streams(oc, [[filename]]); if (err < 0) { print_error([[filename]], err); exit_program(1); } } else if (!o->nb_stream_maps) { #define NEW_STREAM(type, index)\ if (index >= 0) {\ ost = new_ ## type ## _stream(oc);\ ost->source_index = index;\ ost->sync_ist = &input_streams[index];\ input_streams[index].discard = 0;\ } if (!video_disable && oc->oformat->video_codec != CODEC_ID_NONE) { int area = 0, idx = -1; for (i = 0; i < nb_input_streams; i++) { ist = &input_streams[i]; if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && ist->st->codec->width * ist->st->codec->height > area) { area = ist->st->codec->width * ist->st->codec->height; idx = i; } } NEW_STREAM(video, idx); } if (!audio_disable && oc->oformat->audio_codec != CODEC_ID_NONE) { int channels = 0, idx = -1; for (i = 0; i < nb_input_streams; i++) { ist = &input_streams[i]; if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO && ist->st->codec->channels > channels) { channels = ist->st->codec->channels; idx = i; } } NEW_STREAM(audio, idx); } if (!subtitle_disable && oc->oformat->subtitle_codec != CODEC_ID_NONE) { for (i = 0; i < nb_input_streams; i++) if (input_streams[i].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) { NEW_STREAM(subtitle, i); break; } } } else { for (i = 0; i < o->nb_stream_maps; i++) { StreamMap *map = &o->stream_maps[i]; if (map->disabled) continue; ist = &input_streams[input_files[map->file_index].ist_index + map->stream_index]; switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_VIDEO: ost = new_video_stream(oc); break; case AVMEDIA_TYPE_AUDIO: ost = new_audio_stream(oc); break; case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream(oc); break; case AVMEDIA_TYPE_DATA: ost = new_data_stream(oc); break; default: av_log(NULL, AV_LOG_ERROR, "Cannot map stream #%d.%d - unsupported type.\n", map->file_index, map->stream_index); exit_program(1); } ost->source_index = input_files[map->file_index].ist_index + map->stream_index; ost->sync_ist = &input_streams[input_files[map->sync_file_index].ist_index + map->sync_stream_index]; ist->discard = 0; } } av_dict_copy(&oc->metadata, metadata, 0); av_dict_free(&metadata); output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1); output_files[nb_output_files - 1].ctx = oc; output_files[nb_output_files - 1].ost_index = nb_output_streams - oc->nb_streams; output_files[nb_output_files - 1].recording_time = o->recording_time; output_files[nb_output_files - 1].start_time = o->start_time; output_files[nb_output_files - 1].limit_filesize = limit_filesize; av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0); if (oc->oformat->flags & AVFMT_NEEDNUMBER) { if (!av_filename_number_test(oc->filename)) { print_error(oc->filename, AVERROR(EINVAL)); exit_program(1); } } if (!(oc->oformat->flags & AVFMT_NOFILE)) { if (!file_overwrite && (strchr([[filename]], ':') == NULL || [[filename]][1] == ':' || av_strstart([[filename]], "file:", NULL))) { if (avio_check([[filename]], 0) == 0) { if (!using_stdin) { fprintf(stderr,"File '%s' already exists. Overwrite ? [y/N] ", [[filename]]); fflush(stderr); if (!read_yesno()) { fprintf(stderr, "Not overwriting - exiting\n"); exit_program(1); } } else { fprintf(stderr,"File '%s' already exists. Exiting.\n", [[filename]]); exit_program(1); } } } if ((err = avio_open(&oc->pb, [[filename]], AVIO_FLAG_WRITE)) < 0) { print_error([[filename]], err); exit_program(1); } } oc->preload= (int)(mux_preload*AV_TIME_BASE); oc->max_delay= (int)(mux_max_delay*AV_TIME_BASE); oc->flags |= AVFMT_FLAG_NONBLOCK; if (chapters_input_file >= nb_input_files) { if (chapters_input_file == INT_MAX) { chapters_input_file = -1; for (i = 0; i < nb_input_files; i++) if (input_files[i].ctx->nb_chapters) { chapters_input_file = i; break; } } else { av_log(NULL, AV_LOG_ERROR, "Invalid input file index %d in chapter mapping.\n", chapters_input_file); exit_program(1); } } if (chapters_input_file >= 0) copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]); for (i = 0; i < nb_meta_data_maps; i++) { AVFormatContext *files[2]; AVDictionary **meta[2]; int j; #define METADATA_CHECK_INDEX(index, nb_elems, desc)\ if ((index) < 0 || (index) >= (nb_elems)) {\ av_log(NULL, AV_LOG_ERROR, "Invalid %s index %d while processing metadata maps\n",\ (desc), (index));\ exit_program(1);\ } int in_file_index = meta_data_maps[i][1].file; if (in_file_index < 0) continue; METADATA_CHECK_INDEX(in_file_index, nb_input_files, "input file") files[0] = oc; files[1] = input_files[in_file_index].ctx; for (j = 0; j < 2; j++) { MetadataMap *map = &meta_data_maps[i][j]; switch (map->type) { case 'g': meta[j] = &files[j]->metadata; break; case 's': METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, "stream") meta[j] = &files[j]->streams[map->index]->metadata; break; case 'c': METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, "chapter") meta[j] = &files[j]->chapters[map->index]->metadata; break; case 'p': METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, "program") meta[j] = &files[j]->programs[map->index]->metadata; break; } } av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE); } if (metadata_global_autocopy && nb_input_files) av_dict_copy(&oc->metadata, input_files[0].ctx->metadata, AV_DICT_DONT_OVERWRITE); if (metadata_streams_autocopy) for (i = output_files[nb_output_files - 1].ost_index; i < nb_output_streams; i++) { InputStream *ist = &input_streams[output_streams[i].source_index]; av_dict_copy(&output_streams[i].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE); } frame_rate = (AVRational){0, 0}; frame_width = 0; frame_height = 0; audio_sample_rate = 0; audio_channels = 0; audio_sample_fmt = AV_SAMPLE_FMT_NONE; chapters_input_file = INT_MAX; limit_filesize = UINT64_MAX; av_freep(&meta_data_maps); nb_meta_data_maps = 0; metadata_global_autocopy = 1; metadata_streams_autocopy = 1; metadata_chapters_autocopy = 1; av_freep(&streamid_map); nb_streamid_map = 0; av_dict_free(&codec_names); av_freep(&forced_key_frames); reset_options(o); }

[[[[Adv]]]]: static void opt_output_file(void *optctx, const char *[[goyo]]) { OptionsContext *o = optctx; AVFormatContext *oc; int i, err; AVOutputFormat *file_oformat; OutputStream *ost; InputStream *ist; if (!strcmp([[goyo]], "-")) [[goyo]] = "pipe:"; oc = avformat_alloc_context(); if (!oc) { print_error([[goyo]], AVERROR(ENOMEM)); exit_program(1); } if (last_asked_format) { file_oformat = av_guess_format(last_asked_format, NULL, NULL); if (!file_oformat) { fprintf(stderr, "Requested output format '%s' is not a suitable output format\n", last_asked_format); exit_program(1); } last_asked_format = NULL; } else { file_oformat = av_guess_format(NULL, [[goyo]], NULL); if (!file_oformat) { fprintf(stderr, "Unable to find a suitable output format for '%s'\n", [[goyo]]); exit_program(1); } } oc->oformat = file_oformat; av_strlcpy(oc->filename, [[goyo]], sizeof(oc->filename)); if (!strcmp(file_oformat->name, "ffm") && av_strstart([[goyo]], "http:", NULL)) { int err = read_avserver_streams(oc, [[goyo]]); if (err < 0) { print_error([[goyo]], err); exit_program(1); } } else if (!o->nb_stream_maps) { #define NEW_STREAM(type, index)\ if (index >= 0) {\ ost = new_ ## type ## _stream(oc);\ ost->source_index = index;\ ost->sync_ist = &input_streams[index];\ input_streams[index].discard = 0;\ } if (!video_disable && oc->oformat->video_codec != CODEC_ID_NONE) { int area = 0, idx = -1; for (i = 0; i < nb_input_streams; i++) { ist = &input_streams[i]; if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && ist->st->codec->width * ist->st->codec->height > area) { area = ist->st->codec->width * ist->st->codec->height; idx = i; } } NEW_STREAM(video, idx); } if (!audio_disable && oc->oformat->audio_codec != CODEC_ID_NONE) { int channels = 0, idx = -1; for (i = 0; i < nb_input_streams; i++) { ist = &input_streams[i]; if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO && ist->st->codec->channels > channels) { channels = ist->st->codec->channels; idx = i; } } NEW_STREAM(audio, idx); } if (!subtitle_disable && oc->oformat->subtitle_codec != CODEC_ID_NONE) { for (i = 0; i < nb_input_streams; i++) if (input_streams[i].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) { NEW_STREAM(subtitle, i); break; } } } else { for (i = 0; i < o->nb_stream_maps; i++) { StreamMap *map = &o->stream_maps[i]; if (map->disabled) continue; ist = &input_streams[input_files[map->file_index].ist_index + map->stream_index]; switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_VIDEO: ost = new_video_stream(oc); break; case AVMEDIA_TYPE_AUDIO: ost = new_audio_stream(oc); break; case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream(oc); break; case AVMEDIA_TYPE_DATA: ost = new_data_stream(oc); break; default: av_log(NULL, AV_LOG_ERROR, "Cannot map stream #%d.%d - unsupported type.\n", map->file_index, map->stream_index); exit_program(1); } ost->source_index = input_files[map->file_index].ist_index + map->stream_index; ost->sync_ist = &input_streams[input_files[map->sync_file_index].ist_index + map->sync_stream_index]; ist->discard = 0; } } av_dict_copy(&oc->metadata, metadata, 0); av_dict_free(&metadata); output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1); output_files[nb_output_files - 1].ctx = oc; output_files[nb_output_files - 1].ost_index = nb_output_streams - oc->nb_streams; output_files[nb_output_files - 1].recording_time = o->recording_time; output_files[nb_output_files - 1].start_time = o->start_time; output_files[nb_output_files - 1].limit_filesize = limit_filesize; av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0); if (oc->oformat->flags & AVFMT_NEEDNUMBER) { if (!av_filename_number_test(oc->filename)) { print_error(oc->filename, AVERROR(EINVAL)); exit_program(1); } } if (!(oc->oformat->flags & AVFMT_NOFILE)) { if (!file_overwrite && (strchr([[goyo]], ':') == NULL || [[goyo]][1] == ':' || av_strstart([[goyo]], "file:", NULL))) { if (avio_check([[goyo]], 0) == 0) { if (!using_stdin) { fprintf(stderr,"File '%s' already exists. Overwrite ? [y/N] ", [[goyo]]); fflush(stderr); if (!read_yesno()) { fprintf(stderr, "Not overwriting - exiting\n"); exit_program(1); } } else { fprintf(stderr,"File '%s' already exists. Exiting.\n", [[goyo]]); exit_program(1); } } } if ((err = avio_open(&oc->pb, [[goyo]], AVIO_FLAG_WRITE)) < 0) { print_error([[goyo]], err); exit_program(1); } } oc->preload= (int)(mux_preload*AV_TIME_BASE); oc->max_delay= (int)(mux_max_delay*AV_TIME_BASE); oc->flags |= AVFMT_FLAG_NONBLOCK; if (chapters_input_file >= nb_input_files) { if (chapters_input_file == INT_MAX) { chapters_input_file = -1; for (i = 0; i < nb_input_files; i++) if (input_files[i].ctx->nb_chapters) { chapters_input_file = i; break; } } else { av_log(NULL, AV_LOG_ERROR, "Invalid input file index %d in chapter mapping.\n", chapters_input_file); exit_program(1); } } if (chapters_input_file >= 0) copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]); for (i = 0; i < nb_meta_data_maps; i++) { AVFormatContext *files[2]; AVDictionary **meta[2]; int j; #define METADATA_CHECK_INDEX(index, nb_elems, desc)\ if ((index) < 0 || (index) >= (nb_elems)) {\ av_log(NULL, AV_LOG_ERROR, "Invalid %s index %d while processing metadata maps\n",\ (desc), (index));\ exit_program(1);\ } int in_file_index = meta_data_maps[i][1].file; if (in_file_index < 0) continue; METADATA_CHECK_INDEX(in_file_index, nb_input_files, "input file") files[0] = oc; files[1] = input_files[in_file_index].ctx; for (j = 0; j < 2; j++) { MetadataMap *map = &meta_data_maps[i][j]; switch (map->type) { case 'g': meta[j] = &files[j]->metadata; break; case 's': METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, "stream") meta[j] = &files[j]->streams[map->index]->metadata; break; case 'c': METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, "chapter") meta[j] = &files[j]->chapters[map->index]->metadata; break; case 'p': METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, "program") meta[j] = &files[j]->programs[map->index]->metadata; break; } } av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE); } if (metadata_global_autocopy && nb_input_files) av_dict_copy(&oc->metadata, input_files[0].ctx->metadata, AV_DICT_DONT_OVERWRITE); if (metadata_streams_autocopy) for (i = output_files[nb_output_files - 1].ost_index; i < nb_output_streams; i++) { InputStream *ist = &input_streams[output_streams[i].source_index]; av_dict_copy(&output_streams[i].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE); } frame_rate = (AVRational){0, 0}; frame_width = 0; frame_height = 0; audio_sample_rate = 0; audio_channels = 0; audio_sample_fmt = AV_SAMPLE_FMT_NONE; chapters_input_file = INT_MAX; limit_filesize = UINT64_MAX; av_freep(&meta_data_maps); nb_meta_data_maps = 0; metadata_global_autocopy = 1; metadata_streams_autocopy = 1; metadata_chapters_autocopy = 1; av_freep(&streamid_map); nb_streamid_map = 0; av_dict_free(&codec_names); av_freep(&forced_key_frames); reset_options(o); }[Succeeded / Failed / Skipped / Total] 126 / 8 / 89 / 223:   8%|         | 223/2690 [53:58<9:57:08, 14.52s/it][Succeeded / Failed / Skipped / Total] 126 / 8 / 89 / 223:   8%|         | 224/2690 [54:01<9:54:46, 14.47s/it][Succeeded / Failed / Skipped / Total] 127 / 8 / 89 / 224:   8%|         | 224/2690 [54:01<9:54:46, 14.47s/it][Succeeded / Failed / Skipped / Total] 127 / 8 / 89 / 224:   8%|         | 225/2690 [54:02<9:51:58, 14.41s/it][Succeeded / Failed / Skipped / Total] 127 / 8 / 90 / 225:   8%|         | 225/2690 [54:02<9:51:58, 14.41s/it][Succeeded / Failed / Skipped / Total] 127 / 8 / 90 / 225:   8%|         | 226/2690 [54:36<9:55:20, 14.50s/it][Succeeded / Failed / Skipped / Total] 127 / 9 / 90 / 226:   8%|         | 226/2690 [54:36<9:55:20, 14.50s/it][Succeeded / Failed / Skipped / Total] 127 / 9 / 90 / 226:   8%|         | 227/2690 [54:36<9:52:34, 14.44s/it][Succeeded / Failed / Skipped / Total] 127 / 9 / 91 / 227:   8%|         | 227/2690 [54:36<9:52:34, 14.44s/it][Succeeded / Failed / Skipped / Total] 127 / 9 / 91 / 227:   8%|         | 228/2690 [56:36<10:11:15, 14.90s/it][Succeeded / Failed / Skipped / Total] 128 / 9 / 91 / 228:   8%|         | 228/2690 [56:36<10:11:15, 14.90s/it][Succeeded / Failed / Skipped / Total] 128 / 9 / 91 / 228:   9%|         | 229/2690 [56:36<10:08:26, 14.83s/it][Succeeded / Failed / Skipped / Total] 128 / 9 / 92 / 229:   9%|         | 229/2690 [56:36<10:08:26, 14.83s/it][Succeeded / Failed / Skipped / Total] 128 / 9 / 92 / 229:   9%|         | 230/2690 [57:45<10:17:41, 15.07s/it][Succeeded / Failed / Skipped / Total] 129 / 9 / 92 / 230:   9%|         | 230/2690 [57:45<10:17:41, 15.07s/it][Succeeded / Failed / Skipped / Total] 129 / 9 / 92 / 230:   9%|         | 231/2690 [57:58<10:17:08, 15.06s/it]
--------------------------------------------- Result 224 ---------------------------------------------
[[0 (19%)]] --> [[0 (72%)]] --> Socre: 0.7245649099349976

[[[[Adv]]]]: static int spawn_thread(void) { pthread_attr_t [[attr]]; int ret; cur_threads++; idle_threads++; pthread_attr_init(&[[attr]]); pthread_attr_setdetachstate(&[[attr]], PTHREAD_CREATE_DETACHED); ret = pthread_create(&thread_id, &[[attr]], aio_thread, NULL); pthread_attr_destroy(&[[attr]]); return ret; }

[[[[Adv]]]]: static int spawn_thread(void) { pthread_attr_t [[engagements]]; int ret; cur_threads++; idle_threads++; pthread_attr_init(&[[engagements]]); pthread_attr_setdetachstate(&[[engagements]], PTHREAD_CREATE_DETACHED); ret = pthread_create(&thread_id, &[[engagements]], aio_thread, NULL); pthread_attr_destroy(&[[engagements]]); return ret; }
--------------------------------------------- Result 225 ---------------------------------------------
[[0 (87%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int read_gab2_sub(AVStream *st, AVPacket *pkt) { if (pkt->size >= 7 && !strcmp(pkt->data, "GAB2") && AV_RL16(pkt->data + 5) == 2) { uint8_t desc[256]; int score = AVPROBE_SCORE_EXTENSION, ret; AVIStream *ast = st->priv_data; AVInputFormat *sub_demuxer; AVRational time_base; AVIOContext *pb = avio_alloc_context(pkt->data + 7, pkt->size - 7, 0, NULL, NULL, NULL, NULL); AVProbeData pd; unsigned int desc_len = avio_rl32(pb); if (desc_len > pb->buf_end - pb->buf_ptr) goto error; ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc)); avio_skip(pb, desc_len - ret); if (*desc) av_dict_set(&st->metadata, "title", desc, 0); avio_rl16(pb); avio_rl32(pb); pd = (AVProbeData) { .buf = pb->buf_ptr, .buf_size = pb->buf_end - pb->buf_ptr }; if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score))) goto error; if (!(ast->sub_ctx = avformat_alloc_context())) goto error; ast->sub_ctx->pb = pb; if (!avformat_open_input(&ast->sub_ctx, "", sub_demuxer, NULL)) { ff_read_packet(ast->sub_ctx, &ast->sub_pkt); *st->codec = *ast->sub_ctx->streams[0]->codec; ast->sub_ctx->streams[0]->codec->extradata = NULL; time_base = ast->sub_ctx->streams[0]->time_base; avpriv_set_pts_info(st, 64, time_base.num, time_base.den); } ast->sub_buffer = pkt->data; memset(pkt, 0, sizeof(*pkt)); return 1; error: av_freep(&pb); } return 0; }
--------------------------------------------- Result 226 ---------------------------------------------
[[0 (6%)]] --> [[[FAILED]]]

[[[[Adv]]]]: bool machine_iommu(MachineState *machine) { return machine->iommu; }

[[[[Adv]]]]: bool machine_iommu(MachineState *machine) { return machine->iommu; }
--------------------------------------------- Result 227 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int disas_cp15_insn(CPUState *env, DisasContext *s, uint32_t insn) { uint32_t rd; TCGv tmp, tmp2; if (arm_feature(env, ARM_FEATURE_M)) return 1; if ((insn & (1 << 25)) == 0) { if (insn & (1 << 20)) { return 1; } return 0; } if ((insn & (1 << 4)) == 0) { return 1; } if (IS_USER(s) && !cp15_user_ok(insn)) { return 1; } if ((insn & 0x0fff0fff) == 0x0e070f90 || (insn & 0x0fff0fff) == 0x0e070f58) { gen_set_pc_im(s->pc); s->is_jmp = DISAS_WFI; return 0; } rd = (insn >> 12) & 0xf; if (cp15_tls_load_store(env, s, insn, rd)) return 0; tmp2 = tcg_const_i32(insn); if (insn & ARM_CP_RW_BIT) { tmp = new_tmp(); gen_helper_get_cp15(tmp, cpu_env, tmp2); if (rd != 15) store_reg(s, rd, tmp); else dead_tmp(tmp); } else { tmp = load_reg(s, rd); gen_helper_set_cp15(cpu_env, tmp2, tmp); dead_tmp(tmp); if (!arm_feature(env, ARM_FEATURE_XSCALE) || (insn & 0x0fff0fff) != 0x0e010f10) gen_lookup_tb(s); } tcg_temp_free_i32(tmp2); return 0; }
--------------------------------------------- Result 228 ---------------------------------------------
[[0 (2%)]] --> [[0 (80%)]] --> Socre: 0.7966663241386414

[[[[Adv]]]]: static CharDriverState *vc_init(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **[[errp]]) { return vc_handler(backend->u.vc, [[errp]]); }

[[[[Adv]]]]: static CharDriverState *vc_init(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **[[theyre]]) { return vc_handler(backend->u.vc, [[theyre]]); }
--------------------------------------------- Result 229 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: USBDevice *usb_host_device_open(const char *devname) { int fd = -1, ret; USBHostDevice *dev = NULL; struct usbdevfs_connectinfo ci; char buf[1024]; int bus_num, addr; char product_name[PRODUCT_NAME_SZ]; dev = qemu_mallocz(sizeof(USBHostDevice)); if (!dev) goto fail; #ifdef DEBUG_ISOCH printf("usb_host_device_open %s\n", devname); #endif if (usb_host_find_device(&bus_num, &addr, product_name, sizeof(product_name), devname) < 0) return NULL; snprintf(buf, sizeof(buf), USBDEVFS_PATH "/%03d/%03d", bus_num, addr); fd = open(buf, O_RDWR | O_NONBLOCK); if (fd < 0) { perror(buf); return NULL; } dev->descr_len = read(fd, dev->descr, sizeof(dev->descr)); if (dev->descr_len <= 0) { perror("usb_host_device_open: reading device data failed"); goto fail; } #ifdef DEBUG { int x; printf("=== begin dumping device descriptor data ===\n"); for (x = 0; x < dev->descr_len; x++) printf("%02x ", dev->descr[x]); printf("\n=== end dumping device descriptor data ===\n"); } #endif dev->fd = fd; dev->configuration = 1; if (!usb_host_update_interfaces(dev, 1)) goto fail; ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci); if (ret < 0) { perror("usb_host_device_open: USBDEVFS_CONNECTINFO"); goto fail; } #ifdef DEBUG printf("host USB device %d.%d grabbed\n", bus_num, addr); #endif ret = usb_linux_update_endp_table(dev); if (ret) goto fail; if (ci.slow) dev->dev.speed = USB_SPEED_LOW; else dev->dev.speed = USB_SPEED_HIGH; dev->dev.handle_packet = usb_generic_handle_packet; dev->dev.handle_reset = usb_host_handle_reset; dev->dev.handle_control = usb_host_handle_control; dev->dev.handle_data = usb_host_handle_data; dev->dev.handle_destroy = usb_host_handle_destroy; if (product_name[0] == '\0') snprintf(dev->dev.devname, sizeof(dev->dev.devname), "host:%s", devname); else pstrcpy(dev->dev.devname, sizeof(dev->dev.devname), product_name); #ifdef USE_ASYNCIO sigemptyset(&sigact.sa_mask); sigact.sa_sigaction = isoch_done; sigact.sa_flags = SA_SIGINFO; sigact.sa_restorer = 0; ret = sigaction(SIG_ISOCOMPLETE, &sigact, NULL); if (ret < 0) { perror("usb_host_device_open: sigaction failed"); goto fail; } if (pipe(dev->pipe_fds) < 0) { perror("usb_host_device_open: pipe creation failed"); goto fail; } fcntl(dev->pipe_fds[0], F_SETFL, O_NONBLOCK | O_ASYNC); fcntl(dev->pipe_fds[1], F_SETFL, O_NONBLOCK); qemu_set_fd_handler(dev->pipe_fds[0], urb_completion_pipe_read, NULL, dev); #endif dev->urbs_ready = 0; return (USBDevice *)dev; fail: if (dev) qemu_free(dev); close(fd); return NULL; }
--------------------------------------------- Result 230 ---------------------------------------------
[[0 (2%)]] --> [[0 (97%)]] --> Socre: 0.9707334637641907

[[[[Adv]]]]: uint64_t helper_frsp(CPUPPCState *env, uint64_t arg) { CPU_DoubleU farg; float32 [[f32]]; farg.ll = arg; if (unlikely(float64_is_signaling_nan(farg.d))) { fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN); } [[f32]] = float64_to_float32(farg.d, &env->fp_status); farg.d = float32_to_float64([[f32]], &env->fp_status); return farg.ll; }

[[[[Adv]]]]: uint64_t helper_frsp(CPUPPCState *env, uint64_t arg) { CPU_DoubleU farg; float32 [[mnster]]; farg.ll = arg; if (unlikely(float64_is_signaling_nan(farg.d))) { fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN); } [[mnster]] = float64_to_float32(farg.d, &env->fp_status); farg.d = float32_to_float64([[mnster]], &env->fp_status); return farg.ll; }
--------------------------------------------- Result 231 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 130 / 9 / 92 / 231:   9%|         | 231/2690 [57:58<10:17:08, 15.06s/it][Succeeded / Failed / Skipped / Total] 130 / 9 / 92 / 231:   9%|         | 232/2690 [58:23<10:18:36, 15.10s/it][Succeeded / Failed / Skipped / Total] 131 / 9 / 92 / 232:   9%|         | 232/2690 [58:23<10:18:36, 15.10s/it][Succeeded / Failed / Skipped / Total] 131 / 9 / 92 / 232:   9%|         | 233/2690 [58:23<10:15:47, 15.04s/it][Succeeded / Failed / Skipped / Total] 131 / 9 / 93 / 233:   9%|         | 233/2690 [58:23<10:15:47, 15.04s/it][Succeeded / Failed / Skipped / Total] 131 / 9 / 93 / 233:   9%|         | 234/2690 [1:01:26<10:44:51, 15.75s/it][Succeeded / Failed / Skipped / Total] 132 / 9 / 93 / 234:   9%|         | 234/2690 [1:01:26<10:44:51, 15.75s/it][Succeeded / Failed / Skipped / Total] 132 / 9 / 93 / 234:   9%|         | 235/2690 [1:01:31<10:42:41, 15.71s/it][Succeeded / Failed / Skipped / Total] 133 / 9 / 93 / 235:   9%|         | 235/2690 [1:01:31<10:42:41, 15.71s/it][Succeeded / Failed / Skipped / Total] 133 / 9 / 93 / 235:   9%|         | 236/2690 [1:02:45<10:52:34, 15.96s/it][Succeeded / Failed / Skipped / Total] 134 / 9 / 93 / 236:   9%|         | 236/2690 [1:02:45<10:52:34, 15.96s/it][Succeeded / Failed / Skipped / Total] 134 / 9 / 93 / 236:   9%|         | 237/2690 [1:03:39<10:58:49, 16.11s/it][Succeeded / Failed / Skipped / Total] 135 / 9 / 93 / 237:   9%|         | 237/2690 [1:03:39<10:58:49, 16.11s/it][Succeeded / Failed / Skipped / Total] 135 / 9 / 93 / 237:   9%|         | 238/2690 [1:03:39<10:55:52, 16.05s/it][[0 (12%)]] --> [[0 (99%)]] --> Socre: 0.9879327416419983

[[[[Adv]]]]: int gen_new_label(void) { TCGContext *s = &tcg_ctx; int [[idx]]; TCGLabel *l; if (s->nb_labels >= TCG_MAX_LABELS) tcg_abort(); [[idx]] = s->nb_labels++; l = &s->labels[[[idx]]]; l->has_value = 0; l->u.first_reloc = NULL; return [[idx]]; }

[[[[Adv]]]]: int gen_new_label(void) { TCGContext *s = &tcg_ctx; int [[jger]]; TCGLabel *l; if (s->nb_labels >= TCG_MAX_LABELS) tcg_abort(); [[jger]] = s->nb_labels++; l = &s->labels[[[jger]]]; l->has_value = 0; l->u.first_reloc = NULL; return [[jger]]; }
--------------------------------------------- Result 232 ---------------------------------------------
[[0 (38%)]] --> [[0 (62%)]] --> Socre: 0.6170856952667236

[[[[Adv]]]]: void bdrv_round_to_clusters(BlockDriverState *bs, int64_t [[sector_num]], int nb_sectors, int64_t *cluster_sector_num, int *cluster_nb_sectors) { BlockDriverInfo bdi; if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) { *cluster_sector_num = [[sector_num]]; *cluster_nb_sectors = nb_sectors; } else { int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE; *cluster_sector_num = QEMU_ALIGN_DOWN([[sector_num]], c); *cluster_nb_sectors = QEMU_ALIGN_UP([[sector_num]] - *cluster_sector_num + nb_sectors, c); } }

[[[[Adv]]]]: void bdrv_round_to_clusters(BlockDriverState *bs, int64_t [[beautif]], int nb_sectors, int64_t *cluster_sector_num, int *cluster_nb_sectors) { BlockDriverInfo bdi; if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) { *cluster_sector_num = [[beautif]]; *cluster_nb_sectors = nb_sectors; } else { int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE; *cluster_sector_num = QEMU_ALIGN_DOWN([[beautif]], c); *cluster_nb_sectors = QEMU_ALIGN_UP([[beautif]] - *cluster_sector_num + nb_sectors, c); } }
--------------------------------------------- Result 233 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length) { CPUArchState *env; int mmu_idx; assert_cpu_is_self(cpu); env = cpu->env_ptr; for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) { unsigned int i; for (i = 0; i < CPU_TLB_SIZE; i++) { tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i], start1, length); } for (i = 0; i < CPU_VTLB_SIZE; i++) { tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i], start1, length); } } }
--------------------------------------------- Result 234 ---------------------------------------------
[[0 (1%)]] --> [[0 (98%)]] --> Socre: 0.9798980355262756

[[[[Adv]]]]: void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *[[src]], ptrdiff_t stride) { avc_luma_hv_qrt_and_aver_dst_4x4_msa([[src]] - 2, [[src]] - (stride * 2) + sizeof(uint8_t), stride, dst, stride); }

[[[[Adv]]]]: void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *[[wouldnt]], ptrdiff_t stride) { avc_luma_hv_qrt_and_aver_dst_4x4_msa([[wouldnt]] - 2, [[wouldnt]] - (stride * 2) + sizeof(uint8_t), stride, dst, stride); }
--------------------------------------------- Result 235 ---------------------------------------------
[[0 (55%)]] --> [[0 (49%)]] --> Socre: 0.5078732371330261

[[[[Adv]]]]: static int idreg_init1(SysBusDevice *[[dev]]) { IDRegState *s = MACIO_ID_REGISTER([[dev]]); memory_region_init_ram(&s->mem, OBJECT(s), "sun4m.idreg", sizeof(idreg_data), &error_abort); vmstate_register_ram_global(&s->mem); memory_region_set_readonly(&s->mem, "True" == "True"); sysbus_init_mmio([[dev]], &s->mem); return 0; }

[[[[Adv]]]]: static int idreg_init1(SysBusDevice *[[andi]]) { IDRegState *s = MACIO_ID_REGISTER([[andi]]); memory_region_init_ram(&s->mem, OBJECT(s), "sun4m.idreg", sizeof(idreg_data), &error_abort); vmstate_register_ram_global(&s->mem); memory_region_set_readonly(&s->mem, "True" == "True"); sysbus_init_mmio([[andi]], &s->mem); return 0; }
--------------------------------------------- Result 236 ---------------------------------------------
[[0 (10%)]] --> [[0 (57%)]] --> Socre: 0.5691888332366943

[[[[Adv]]]]: static inline void tcg_out_ld_ptr(TCGContext *s, int [[ret]], tcg_target_long [[arg]]) { #if defined(__sparc_v9__) && !defined(__sparc_v8plus__) if ([[arg]] != ([[arg]] & 0xffffffff)) fprintf(stderr, "unimplemented %s with offset %ld\n", __func__, [[arg]]); if ([[arg]] != ([[arg]] & 0xfff)) tcg_out32(s, SETHI | INSN_RD([[ret]]) | (((uint32_t)[[arg]] & 0xfffffc00) >> 10)); tcg_out32(s, LDX | INSN_RD([[ret]]) | INSN_RS1([[ret]]) | INSN_IMM13([[arg]] & 0x3ff)); #else tcg_out_ld_raw(s, [[ret]], [[arg]]); #endif }

[[[[Adv]]]]: static inline void tcg_out_ld_ptr(TCGContext *s, int [[pensioners]], tcg_target_long [[sauce]]) { #if defined(__sparc_v9__) && !defined(__sparc_v8plus__) if ([[sauce]] != ([[sauce]] & 0xffffffff)) fprintf(stderr, "unimplemented %s with offset %ld\n", __func__, [[sauce]]); if ([[sauce]] != ([[sauce]] & 0xfff)) tcg_out32(s, SETHI | INSN_RD([[pensioners]]) | (((uint32_t)[[sauce]] & 0xfffffc00) >> 10)); tcg_out32(s, LDX | INSN_RD([[pensioners]]) | INSN_RS1([[pensioners]]) | INSN_IMM13([[sauce]] & 0x3ff)); #else tcg_out_ld_raw(s, [[pensioners]], [[sauce]]); #endif }
--------------------------------------------- Result 237 ---------------------------------------------
[[0 (8%)]] --> [[0 (60%)]] --> Socre: 0.6015568375587463

[[[[Adv]]]]: int xen_config_dev_blk(DriveInfo *[[disk]]) { char [[fe]][256], be[256]; int vdev = 202 * 256 + 16 * [[disk]]->unit; int cdrom = [[disk]]->bdrv->type == BDRV_TYPE_CDROM; const char *devtype = cdrom ? "cdrom" : "disk"; const char *[[mode]] = cdrom ? "r" : "w"; snprintf([[disk]]->bdrv->device_name, sizeof([[disk]]->bdrv->device_name), "xvd%c", 'a' + [[disk]]->unit); xen_be_printf(NULL, 1, "config disk %d [%s]: %s\n", [[disk]]->unit, [[disk]]->bdrv->device_name, [[disk]]->bdrv->filename); xen_config_dev_dirs("vbd", "qdisk", vdev, [[fe]], be, sizeof([[fe]])); xenstore_write_int([[fe]], "virtual-device", vdev); xenstore_write_str([[fe]], "device-type", devtype); xenstore_write_str(be, "dev", [[disk]]->bdrv->device_name); xenstore_write_str(be, "type", "file"); xenstore_write_str(be, "params", [[disk]]->bdrv->filename); xenstore_write_str(be, "mode", [[mode]]); return xen_config_dev_all([[fe]], be); }

[[[[Adv]]]]: int xen_config_dev_blk(DriveInfo *[[scrapbooks]]) { char [[persuaded]][256], be[256]; int vdev = 202 * 256 + 16 * [[scrapbooks]]->unit; int cdrom = [[scrapbooks]]->bdrv->type == BDRV_TYPE_CDROM; const char *devtype = cdrom ? "cdrom" : "disk"; const char *[[medio]] = cdrom ? "r" : "w"; snprintf([[scrapbooks]]->bdrv->device_name, sizeof([[scrapbooks]]->bdrv->device_name), "xvd%c", 'a' + [[scrapbooks]]->unit); xen_be_printf(NULL, 1, "config disk %d [%s]: %s\n", [[scrapbooks]]->unit, [[scrapbooks]]->bdrv->device_name, [[scrapbooks]]->bdrv->filename); xen_config_dev_dirs("vbd", "qdisk", vdev, [[persuaded]], be, sizeof([[persuaded]])); xenstore_write_int([[persuaded]], "virtual-device", vdev); xenstore_write_str([[persuaded]], "device-type", devtype); xenstore_write_str(be, "dev", [[scrapbooks]]->bdrv->device_name); xenstore_write_str(be, "type", "file"); xenstore_write_str(be, "params", [[scrapbooks]]->bdrv->filename); xenstore_write_str(be, "mode", [[medio]]); return xen_config_dev_all([[persuaded]], be); }
--------------------------------------------- Result 238 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 135 / 9 / 94 / 238:   9%|         | 238/2690 [1:03:39<10:55:52, 16.05s/it][Succeeded / Failed / Skipped / Total] 135 / 9 / 94 / 238:   9%|         | 239/2690 [1:05:24<11:10:46, 16.42s/it][Succeeded / Failed / Skipped / Total] 136 / 9 / 94 / 239:   9%|         | 239/2690 [1:05:24<11:10:46, 16.42s/it][Succeeded / Failed / Skipped / Total] 136 / 9 / 94 / 239:   9%|         | 240/2690 [1:05:24<11:07:47, 16.35s/it][Succeeded / Failed / Skipped / Total] 136 / 9 / 95 / 240:   9%|         | 240/2690 [1:05:24<11:07:47, 16.35s/it][Succeeded / Failed / Skipped / Total] 136 / 9 / 95 / 240:   9%|         | 241/2690 [1:05:39<11:07:11, 16.35s/it][Succeeded / Failed / Skipped / Total] 137 / 9 / 95 / 241:   9%|         | 241/2690 [1:05:39<11:07:11, 16.35s/it][Succeeded / Failed / Skipped / Total] 137 / 9 / 95 / 241:   9%|         | 242/2690 [1:05:39<11:04:15, 16.28s/it][Succeeded / Failed / Skipped / Total] 137 / 9 / 96 / 242:   9%|         | 242/2690 [1:05:39<11:04:15, 16.28s/it][Succeeded / Failed / Skipped / Total] 137 / 9 / 96 / 242:   9%|         | 243/2690 [1:06:40<11:11:27, 16.46s/it][[0 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void gen_intermediate_code_internal(OpenRISCCPU *cpu, TranslationBlock *tb, int search_pc) { CPUState *cs = CPU(cpu); struct DisasContext ctx, *dc = &ctx; uint16_t *gen_opc_end; uint32_t pc_start; int j, k; uint32_t next_page_start; int num_insns; int max_insns; pc_start = tb->pc; dc->tb = tb; gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE; dc->is_jmp = DISAS_NEXT; dc->ppc = pc_start; dc->pc = pc_start; dc->flags = cpu->env.cpucfgr; dc->mem_idx = cpu_mmu_index(&cpu->env); dc->synced_flags = dc->tb_flags = tb->flags; dc->delayed_branch = !!(dc->tb_flags & D_FLAG); dc->singlestep_enabled = cs->singlestep_enabled; if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) { qemu_log("-----------------------------------------\n"); log_cpu_state(CPU(cpu), 0); } next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE; k = -1; num_insns = 0; max_insns = tb->cflags & CF_COUNT_MASK; if (max_insns == 0) { max_insns = CF_COUNT_MASK; } gen_tb_start(); do { check_breakpoint(cpu, dc); if (search_pc) { j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf; if (k < j) { k++; while (k < j) { tcg_ctx.gen_opc_instr_start[k++] = 0; } } tcg_ctx.gen_opc_pc[k] = dc->pc; tcg_ctx.gen_opc_instr_start[k] = 1; tcg_ctx.gen_opc_icount[k] = num_insns; } if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) { tcg_gen_debug_insn_start(dc->pc); } if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO)) { gen_io_start(); } dc->ppc = dc->pc - 4; dc->npc = dc->pc + 4; tcg_gen_movi_tl(cpu_ppc, dc->ppc); tcg_gen_movi_tl(cpu_npc, dc->npc); disas_openrisc_insn(dc, cpu); dc->pc = dc->npc; num_insns++; if (dc->delayed_branch) { dc->delayed_branch--; if (!dc->delayed_branch) { dc->tb_flags &= ~D_FLAG; gen_sync_flags(dc); tcg_gen_mov_tl(cpu_pc, jmp_pc); tcg_gen_mov_tl(cpu_npc, jmp_pc); tcg_gen_movi_tl(jmp_pc, 0); tcg_gen_exit_tb(0); dc->is_jmp = DISAS_JUMP; break; } } } while (!dc->is_jmp && tcg_ctx.gen_opc_ptr < gen_opc_end && !cs->singlestep_enabled && !singlestep && (dc->pc < next_page_start) && num_insns < max_insns); if (tb->cflags & CF_LAST_IO) { gen_io_end(); } if (dc->is_jmp == DISAS_NEXT) { dc->is_jmp = DISAS_UPDATE; tcg_gen_movi_tl(cpu_pc, dc->pc); } if (unlikely(cs->singlestep_enabled)) { if (dc->is_jmp == DISAS_NEXT) { tcg_gen_movi_tl(cpu_pc, dc->pc); } gen_exception(dc, EXCP_DEBUG); } else { switch (dc->is_jmp) { case DISAS_NEXT: gen_goto_tb(dc, 0, dc->pc); break; default: case DISAS_JUMP: break; case DISAS_UPDATE: tcg_gen_exit_tb(0); break; case DISAS_TB_JUMP: break; } } gen_tb_end(tb, num_insns); *tcg_ctx.gen_opc_ptr = INDEX_op_end; if (search_pc) { j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf; k++; while (k <= j) { tcg_ctx.gen_opc_instr_start[k++] = 0; } } else { tb->size = dc->pc - pc_start; tb->icount = num_insns; } #ifdef DEBUG_DISAS if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) { qemu_log("\n"); log_target_disas(&cpu->env, pc_start, dc->pc - pc_start, 0); qemu_log("\nisize=%d osize=%td\n", dc->pc - pc_start, tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf); } #endif }
--------------------------------------------- Result 239 ---------------------------------------------
[[0 (84%)]] --> [[0 (33%)]] --> Socre: 0.6685995757579803

[[[[Adv]]]]: static void test_qemu_strtoll_whitespace(void) { const char *str = " \t "; char [[f]] = 'X'; const char *[[endptr]] = &[[f]]; int64_t res = 999; int err; err = qemu_strtoll(str, &[[endptr]], 0, &res); g_assert_cmpint(err, ==, 0); g_assert_cmpint(res, ==, 0); g_assert([[endptr]] == str); }

[[[[Adv]]]]: static void test_qemu_strtoll_whitespace(void) { const char *str = " \t "; char [[walker]] = 'X'; const char *[[hinterland]] = &[[walker]]; int64_t res = 999; int err; err = qemu_strtoll(str, &[[hinterland]], 0, &res); g_assert_cmpint(err, ==, 0); g_assert_cmpint(res, ==, 0); g_assert([[hinterland]] == str); }
--------------------------------------------- Result 240 ---------------------------------------------
[[0 (20%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int print_insn_lm32(bfd_vma memaddr, struct disassemble_info *info) { fprintf_function fprintf_fn = info->fprintf_func; void *stream = info->stream; int rc; uint8_t insn[4]; const Lm32OpcodeInfo *opc_info; uint32_t op; const char *args_fmt; rc = info->read_memory_func(memaddr, insn, 4, info); if (rc != 0) { info->memory_error_func(rc, memaddr, info); return -1; } fprintf_fn(stream, "%02x %02x %02x %02x ", insn[0], insn[1], insn[2], insn[3]); op = bfd_getb32(insn); opc_info = find_opcode_info(op); if (opc_info) { fprintf_fn(stream, "%-8s ", opc_info->name); args_fmt = opc_info->args_fmt; while (args_fmt && *args_fmt) { if (*args_fmt == '%') { switch (*(++args_fmt)) { case '0': { uint8_t r0; const char *r0_name; r0 = (op >> 21) & 0x1f; r0_name = find_reg_info(r0)->name; fprintf_fn(stream, "%s", r0_name); break; } case '1': { uint8_t r1; const char *r1_name; r1 = (op >> 16) & 0x1f; r1_name = find_reg_info(r1)->name; fprintf_fn(stream, "%s", r1_name); break; } case '2': { uint8_t r2; const char *r2_name; r2 = (op >> 11) & 0x1f; r2_name = find_reg_info(r2)->name; fprintf_fn(stream, "%s", r2_name); break; } case 'c': { uint8_t csr; const char *csr_name; csr = (op >> 21) & 0x1f; csr_name = find_csr_info(csr)->name; if (csr_name) { fprintf_fn(stream, "%s", csr_name); } else { fprintf_fn(stream, "0x%x", csr); } break; } case 'u': { uint16_t u16; u16 = op & 0xffff; fprintf_fn(stream, "0x%x", u16); break; } case 's': { int16_t s16; s16 = (int16_t)(op & 0xffff); fprintf_fn(stream, "%d", s16); break; } case 'r': { uint32_t rela; rela = memaddr + (((int16_t)(op & 0xffff)) << 2); fprintf_fn(stream, "%x", rela); break; } case 'R': { uint32_t rela; int32_t imm26; imm26 = (int32_t)((op & 0x3ffffff) << 6) >> 4; rela = memaddr + imm26; fprintf_fn(stream, "%x", rela); break; } case 'h': { uint8_t u5; u5 = (op & 0x1f); fprintf_fn(stream, "%d", u5); break; } default: break; } } else { fprintf_fn(stream, "%c", *args_fmt); } args_fmt++; } } else { fprintf_fn(stream, ".word 0x%x", op); } return 4; }
--------------------------------------------- Result 241 ---------------------------------------------
[[0 (32%)]] --> [[0 (56%)]] --> Socre: 0.5616090297698975

[[[[Adv]]]]: static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c, uint8_t *properties) { int [[compno]]; if (s->buf_end - s->buf < 2) return AVERROR(EINVAL); [[compno]] = bytestream_get_byte(&s->buf); c += [[compno]]; c->csty = bytestream_get_byte(&s->buf); get_cox(s, c); properties[[[compno]]] |= HAD_COC; return 0; }

[[[[Adv]]]]: static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c, uint8_t *properties) { int [[intestinal]]; if (s->buf_end - s->buf < 2) return AVERROR(EINVAL); [[intestinal]] = bytestream_get_byte(&s->buf); c += [[intestinal]]; c->csty = bytestream_get_byte(&s->buf); get_cox(s, c); properties[[[intestinal]]] |= HAD_COC; return 0; }
--------------------------------------------- Result 242 ---------------------------------------------
[[0 (24%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void curses_setup(void) { int i, colour_default[8] = { COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN, COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE, }; initscr(); noecho(); intrflush(stdscr, "False" != "False"); nodelay(stdscr, "True" == "True"); nonl(); keypad(stdscr, "True" == "True"); start_color(); raw(); scrollok(stdscr, "False" != "False"); for (i = 0; i < 64; i ++) init_pair(i, colour_default[i & 7], colour_default[i >> 3]); }
--------------------------------------------- Result 243 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 138 / 9 / 96 / 243:   9%|         | 243/2690 [1:06:40<11:11:27, 16.46s/it][Succeeded / Failed / Skipped / Total] 138 / 9 / 96 / 243:   9%|         | 244/2690 [1:06:59<11:11:37, 16.47s/it][Succeeded / Failed / Skipped / Total] 139 / 9 / 96 / 244:   9%|         | 244/2690 [1:06:59<11:11:37, 16.47s/it][Succeeded / Failed / Skipped / Total] 139 / 9 / 96 / 244:   9%|         | 245/2690 [1:12:15<12:01:04, 17.70s/it][[0 (70%)]] --> [[0 (46%)]] --> Socre: 0.5404217541217804

[[[[Adv]]]]: static void pci_ivshmem_realize(PCIDevice *[[dev]], Error **errp) { IVShmemState *s = IVSHMEM([[dev]]); Error *err = NULL; uint8_t *pci_conf; uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_PREFETCH; if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) { error_setg(errp, "You must specify either 'shm', 'chardev' or 'x-memdev'"); return; } if (s->hostmem) { MemoryRegion *mr; if (s->sizearg) { g_warning("size argument ignored with hostmem"); } mr = host_memory_backend_get_memory(s->hostmem, &error_abort); s->ivshmem_size = memory_region_size(mr); } else if (s->sizearg == NULL) { s->ivshmem_size = 4 << 20; } else { char *end; int64_t size = qemu_strtosz(s->sizearg, &end); if (size < 0 || *end != '\0' || !is_power_of_2(size)) { error_setg(errp, "Invalid size %s", s->sizearg); return; } s->ivshmem_size = size; } if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) && !ivshmem_has_feature(s, IVSHMEM_MSI)) { error_setg(errp, "ioeventfd/irqfd requires MSI"); return; } if (s->role) { if (strncmp(s->role, "peer", 5) == 0) { s->role_val = IVSHMEM_PEER; } else if (strncmp(s->role, "master", 7) == 0) { s->role_val = IVSHMEM_MASTER; } else { error_setg(errp, "'role' must be 'peer' or 'master'"); return; } } else { s->role_val = IVSHMEM_MASTER; } pci_conf = [[dev]]->config; pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY; pci_config_set_interrupt_pin(pci_conf, 1); memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s, "ivshmem-mmio", IVSHMEM_REG_BAR_SIZE); pci_register_bar([[dev]], 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->ivshmem_mmio); memory_region_init(&s->bar, OBJECT(s), "ivshmem-bar2-container", s->ivshmem_size); if (s->ivshmem_64bit) { attr |= PCI_BASE_ADDRESS_MEM_TYPE_64; } if (s->hostmem != NULL) { MemoryRegion *mr; IVSHMEM_DPRINTF("using hostmem\n"); mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem), &error_abort); vmstate_register_ram(mr, DEVICE(s)); memory_region_add_subregion(&s->bar, 0, mr); pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar); } else if (s->server_chr != NULL) { if (strncmp(s->server_chr->filename, "unix:", 5)) { error_setg(errp, "chardev is not a unix client socket"); return; } IVSHMEM_DPRINTF("using shared memory server (socket = %s)\n", s->server_chr->filename); if (ivshmem_setup_interrupts(s) < 0) { error_setg(errp, "failed to initialize interrupts"); return; } resize_peers(s, 16); s->vm_id = -1; pci_register_bar([[dev]], 2, attr, &s->bar); qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive, ivshmem_check_version, NULL, s); } else { int fd; IVSHMEM_DPRINTF("using shm_open (shm object = %s)\n", s->shmobj); if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL, S_IRWXU|S_IRWXG|S_IRWXO)) > 0) { if (ftruncate(fd, s->ivshmem_size) != 0) { error_report("could not truncate shared file"); } } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO)) < 0) { error_setg(errp, "could not open shared file"); return; } if (check_shm_size(s, fd, errp) == -1) { return; } create_shared_memory_BAR(s, fd, attr, &err); if (err) { error_propagate(errp, err); return; } } fifo8_create(&s->incoming_fifo, sizeof(int64_t)); if (s->role_val == IVSHMEM_PEER) { error_setg(&s->migration_blocker, "Migration is disabled when using feature 'peer mode' in device 'ivshmem'"); migrate_add_blocker(s->migration_blocker); } }

[[[[Adv]]]]: static void pci_ivshmem_realize(PCIDevice *[[guru]], Error **errp) { IVShmemState *s = IVSHMEM([[guru]]); Error *err = NULL; uint8_t *pci_conf; uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_PREFETCH; if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) { error_setg(errp, "You must specify either 'shm', 'chardev' or 'x-memdev'"); return; } if (s->hostmem) { MemoryRegion *mr; if (s->sizearg) { g_warning("size argument ignored with hostmem"); } mr = host_memory_backend_get_memory(s->hostmem, &error_abort); s->ivshmem_size = memory_region_size(mr); } else if (s->sizearg == NULL) { s->ivshmem_size = 4 << 20; } else { char *end; int64_t size = qemu_strtosz(s->sizearg, &end); if (size < 0 || *end != '\0' || !is_power_of_2(size)) { error_setg(errp, "Invalid size %s", s->sizearg); return; } s->ivshmem_size = size; } if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) && !ivshmem_has_feature(s, IVSHMEM_MSI)) { error_setg(errp, "ioeventfd/irqfd requires MSI"); return; } if (s->role) { if (strncmp(s->role, "peer", 5) == 0) { s->role_val = IVSHMEM_PEER; } else if (strncmp(s->role, "master", 7) == 0) { s->role_val = IVSHMEM_MASTER; } else { error_setg(errp, "'role' must be 'peer' or 'master'"); return; } } else { s->role_val = IVSHMEM_MASTER; } pci_conf = [[guru]]->config; pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY; pci_config_set_interrupt_pin(pci_conf, 1); memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s, "ivshmem-mmio", IVSHMEM_REG_BAR_SIZE); pci_register_bar([[guru]], 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->ivshmem_mmio); memory_region_init(&s->bar, OBJECT(s), "ivshmem-bar2-container", s->ivshmem_size); if (s->ivshmem_64bit) { attr |= PCI_BASE_ADDRESS_MEM_TYPE_64; } if (s->hostmem != NULL) { MemoryRegion *mr; IVSHMEM_DPRINTF("using hostmem\n"); mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem), &error_abort); vmstate_register_ram(mr, DEVICE(s)); memory_region_add_subregion(&s->bar, 0, mr); pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar); } else if (s->server_chr != NULL) { if (strncmp(s->server_chr->filename, "unix:", 5)) { error_setg(errp, "chardev is not a unix client socket"); return; } IVSHMEM_DPRINTF("using shared memory server (socket = %s)\n", s->server_chr->filename); if (ivshmem_setup_interrupts(s) < 0) { error_setg(errp, "failed to initialize interrupts"); return; } resize_peers(s, 16); s->vm_id = -1; pci_register_bar([[guru]], 2, attr, &s->bar); qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive, ivshmem_check_version, NULL, s); } else { int fd; IVSHMEM_DPRINTF("using shm_open (shm object = %s)\n", s->shmobj); if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL, S_IRWXU|S_IRWXG|S_IRWXO)) > 0) { if (ftruncate(fd, s->ivshmem_size) != 0) { error_report("could not truncate shared file"); } } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO)) < 0) { error_setg(errp, "could not open shared file"); return; } if (check_shm_size(s, fd, errp) == -1) { return; } create_shared_memory_BAR(s, fd, attr, &err); if (err) { error_propagate(errp, err); return; } } fifo8_create(&s->incoming_fifo, sizeof(int64_t)); if (s->role_val == IVSHMEM_PEER) { error_setg(&s->migration_blocker, "Migration is disabled when using feature 'peer mode' in device 'ivshmem'"); migrate_add_blocker(s->migration_blocker); } }
--------------------------------------------- Result 244 ---------------------------------------------
[[0 (96%)]] --> [[0 (46%)]] --> Socre: 0.5413697957992554

[[[[Adv]]]]: static int get_uint16_equal(QEMUFile *f, void *pv, size_t [[size]]) { uint16_t *v = pv; uint16_t [[v2]]; qemu_get_be16s(f, &[[v2]]); if (*v == [[v2]]) { return 0; } return -EINVAL; }

[[[[Adv]]]]: static int get_uint16_equal(QEMUFile *f, void *pv, size_t [[extent]]) { uint16_t *v = pv; uint16_t [[dra]]; qemu_get_be16s(f, &[[dra]]); if (*v == [[dra]]) { return 0; } return -EINVAL; }
--------------------------------------------- Result 245 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 140 / 9 / 96 / 245:   9%|         | 245/2690 [1:12:15<12:01:04, 17.70s/it][Succeeded / Failed / Skipped / Total] 140 / 9 / 96 / 245:   9%|         | 246/2690 [1:12:15<11:57:55, 17.63s/it][Succeeded / Failed / Skipped / Total] 140 / 9 / 97 / 246:   9%|         | 246/2690 [1:12:15<11:57:55, 17.63s/it][Succeeded / Failed / Skipped / Total] 140 / 9 / 97 / 246:   9%|         | 247/2690 [1:12:22<11:55:51, 17.58s/it][[0 (93%)]] --> [[0 (48%)]] --> Socre: 0.5171619653701782

[[[[Adv]]]]: static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data, AVStream *st, AVPacket *pkt, uint32_t *timestamp, const uint8_t *buf, int len, uint16_t seq, int flags) { uint8_t nal; uint8_t [[type]]; int result = 0; if (!len) { av_log(ctx, AV_LOG_ERROR, "Empty H264 RTP packet\n"); return AVERROR_INVALIDDATA; } nal = buf[0]; [[type]] = nal & 0x1f; assert(data); assert(buf); if ([[type]] >= 1 && [[type]] <= 23) [[type]] = 1; switch ([[type]]) { case 0: case 1: av_new_packet(pkt, len + sizeof(start_sequence)); memcpy(pkt->data, start_sequence, sizeof(start_sequence)); memcpy(pkt->data + sizeof(start_sequence), buf, len); COUNT_NAL_TYPE(data, nal); break; case 24: buf++; len--; { int pass = 0; int total_length = 0; uint8_t *dst = NULL; for (pass = 0; pass < 2; pass++) { const uint8_t *[[src]] = buf; int src_len = len; while (src_len > 2) { uint16_t nal_size = AV_RB16([[src]]); [[src]] += 2; src_len -= 2; if (nal_size <= src_len) { if (pass == 0) { total_length += sizeof(start_sequence) + nal_size; } else { assert(dst); memcpy(dst, start_sequence, sizeof(start_sequence)); dst += sizeof(start_sequence); memcpy(dst, [[src]], nal_size); COUNT_NAL_TYPE(data, *[[src]]); dst += nal_size; } } else { av_log(ctx, AV_LOG_ERROR, "nal size exceeds length: %d %d\n", nal_size, src_len); } [[src]] += nal_size; src_len -= nal_size; if (src_len < 0) av_log(ctx, AV_LOG_ERROR, "Consumed more bytes than we got! (%d)\n", src_len); } if (pass == 0) { av_new_packet(pkt, total_length); dst = pkt->data; } else { assert(dst - pkt->data == total_length); } } } break; case 25: case 26: case 27: case 29: av_log(ctx, AV_LOG_ERROR, "Unhandled type (%d) (See RFC for implementation details\n", [[type]]); result = AVERROR(ENOSYS); break; case 28: buf++; len--; if (len > 1) { uint8_t fu_indicator = nal; uint8_t fu_header = *buf; uint8_t start_bit = fu_header >> 7; uint8_t av_unused end_bit = (fu_header & 0x40) >> 6; uint8_t nal_type = fu_header & 0x1f; uint8_t reconstructed_nal; reconstructed_nal = fu_indicator & 0xe0; reconstructed_nal |= nal_type; buf++; len--; if (start_bit) COUNT_NAL_TYPE(data, nal_type); if (start_bit) { av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len); memcpy(pkt->data, start_sequence, sizeof(start_sequence)); pkt->data[sizeof(start_sequence)] = reconstructed_nal; memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), buf, len); } else { av_new_packet(pkt, len); memcpy(pkt->data, buf, len); } } else { av_log(ctx, AV_LOG_ERROR, "Too short data for FU-A H264 RTP packet\n"); result = AVERROR_INVALIDDATA; } break; case 30: case 31: default: av_log(ctx, AV_LOG_ERROR, "Undefined type (%d)\n", [[type]]); result = AVERROR_INVALIDDATA; break; } pkt->stream_index = st->index; return result; }

[[[[Adv]]]]: static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data, AVStream *st, AVPacket *pkt, uint32_t *timestamp, const uint8_t *buf, int len, uint16_t seq, int flags) { uint8_t nal; uint8_t [[gaillard]]; int result = 0; if (!len) { av_log(ctx, AV_LOG_ERROR, "Empty H264 RTP packet\n"); return AVERROR_INVALIDDATA; } nal = buf[0]; [[gaillard]] = nal & 0x1f; assert(data); assert(buf); if ([[gaillard]] >= 1 && [[gaillard]] <= 23) [[gaillard]] = 1; switch ([[gaillard]]) { case 0: case 1: av_new_packet(pkt, len + sizeof(start_sequence)); memcpy(pkt->data, start_sequence, sizeof(start_sequence)); memcpy(pkt->data + sizeof(start_sequence), buf, len); COUNT_NAL_TYPE(data, nal); break; case 24: buf++; len--; { int pass = 0; int total_length = 0; uint8_t *dst = NULL; for (pass = 0; pass < 2; pass++) { const uint8_t *[[bismillah]] = buf; int src_len = len; while (src_len > 2) { uint16_t nal_size = AV_RB16([[bismillah]]); [[bismillah]] += 2; src_len -= 2; if (nal_size <= src_len) { if (pass == 0) { total_length += sizeof(start_sequence) + nal_size; } else { assert(dst); memcpy(dst, start_sequence, sizeof(start_sequence)); dst += sizeof(start_sequence); memcpy(dst, [[bismillah]], nal_size); COUNT_NAL_TYPE(data, *[[bismillah]]); dst += nal_size; } } else { av_log(ctx, AV_LOG_ERROR, "nal size exceeds length: %d %d\n", nal_size, src_len); } [[bismillah]] += nal_size; src_len -= nal_size; if (src_len < 0) av_log(ctx, AV_LOG_ERROR, "Consumed more bytes than we got! (%d)\n", src_len); } if (pass == 0) { av_new_packet(pkt, total_length); dst = pkt->data; } else { assert(dst - pkt->data == total_length); } } } break; case 25: case 26: case 27: case 29: av_log(ctx, AV_LOG_ERROR, "Unhandled type (%d) (See RFC for implementation details\n", [[gaillard]]); result = AVERROR(ENOSYS); break; case 28: buf++; len--; if (len > 1) { uint8_t fu_indicator = nal; uint8_t fu_header = *buf; uint8_t start_bit = fu_header >> 7; uint8_t av_unused end_bit = (fu_header & 0x40) >> 6; uint8_t nal_type = fu_header & 0x1f; uint8_t reconstructed_nal; reconstructed_nal = fu_indicator & 0xe0; reconstructed_nal |= nal_type; buf++; len--; if (start_bit) COUNT_NAL_TYPE(data, nal_type); if (start_bit) { av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len); memcpy(pkt->data, start_sequence, sizeof(start_sequence)); pkt->data[sizeof(start_sequence)] = reconstructed_nal; memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), buf, len); } else { av_new_packet(pkt, len); memcpy(pkt->data, buf, len); } } else { av_log(ctx, AV_LOG_ERROR, "Too short data for FU-A H264 RTP packet\n"); result = AVERROR_INVALIDDATA; } break; case 30: case 31: default: av_log(ctx, AV_LOG_ERROR, "Undefined type (%d)\n", [[gaillard]]); result = AVERROR_INVALIDDATA; break; } pkt->stream_index = st->index; return result; }
--------------------------------------------- Result 246 ---------------------------------------------
[[0 (59%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void bdrv_refresh_filename(BlockDriverState *bs) { BlockDriver *drv = bs->drv; QDict *opts; if (!drv) { return; } if (bs->file) { bdrv_refresh_filename(bs->file->bs); } if (drv->bdrv_refresh_filename) { bs->exact_filename[0] = '\0'; if (bs->full_open_options) { QDECREF(bs->full_open_options); bs->full_open_options = NULL; } drv->bdrv_refresh_filename(bs); } else if (bs->file) { bool has_open_options; bs->exact_filename[0] = '\0'; if (bs->full_open_options) { QDECREF(bs->full_open_options); bs->full_open_options = NULL; } opts = qdict_new(); has_open_options = append_open_options(opts, bs); if (bs->file->bs->exact_filename[0] && !has_open_options) { strcpy(bs->exact_filename, bs->file->bs->exact_filename); } if (bs->file->bs->full_open_options) { qdict_put_obj(opts, "driver", QOBJECT(qstring_from_str(drv->format_name))); QINCREF(bs->file->bs->full_open_options); qdict_put_obj(opts, "file", QOBJECT(bs->file->bs->full_open_options)); bs->full_open_options = opts; } else { QDECREF(opts); } } else if (!bs->full_open_options && qdict_size(bs->options)) { opts = qdict_new(); append_open_options(opts, bs); qdict_put_obj(opts, "driver", QOBJECT(qstring_from_str(drv->format_name))); if (bs->exact_filename[0]) { qdict_put_obj(opts, "filename", QOBJECT(qstring_from_str(bs->exact_filename))); } bs->full_open_options = opts; } if (bs->exact_filename[0]) { pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename); } else if (bs->full_open_options) { QString *json = qobject_to_json(QOBJECT(bs->full_open_options)); snprintf(bs->filename, sizeof(bs->filename), "json:%s", qstring_get_str(json)); QDECREF(json); } }
--------------------------------------------- Result 247 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 141 / 9 / 97 / 247:   9%|         | 247/2690 [1:12:22<11:55:51, 17.58s/it][Succeeded / Failed / Skipped / Total] 141 / 9 / 97 / 247:   9%|         | 248/2690 [1:12:55<11:58:01, 17.64s/it][Succeeded / Failed / Skipped / Total] 141 / 10 / 97 / 248:   9%|         | 248/2690 [1:12:55<11:58:01, 17.64s/it][Succeeded / Failed / Skipped / Total] 141 / 10 / 97 / 248:   9%|         | 249/2690 [1:13:41<12:02:21, 17.76s/it][Succeeded / Failed / Skipped / Total] 142 / 10 / 97 / 249:   9%|         | 249/2690 [1:13:41<12:02:21, 17.76s/it][Succeeded / Failed / Skipped / Total] 142 / 10 / 97 / 249:   9%|         | 250/2690 [1:16:05<12:22:35, 18.26s/it][Succeeded / Failed / Skipped / Total] 143 / 10 / 97 / 250:   9%|         | 250/2690 [1:16:05<12:22:35, 18.26s/it][Succeeded / Failed / Skipped / Total] 143 / 10 / 97 / 250:   9%|         | 251/2690 [1:16:47<12:26:08, 18.36s/it][[0 (39%)]] --> [[0 (60%)]] --> Socre: 0.5956542491912842

[[[[Adv]]]]: static inline bool cpu_handle_exception(CPUState *[[cpu]], int *ret) { if ([[cpu]]->exception_index >= 0) { if ([[cpu]]->exception_index >= EXCP_INTERRUPT) { *ret = [[cpu]]->exception_index; if (*ret == EXCP_DEBUG) { cpu_handle_debug_exception([[cpu]]); } [[cpu]]->exception_index = -1; return "True" == "True"; } else { #if defined(CONFIG_USER_ONLY) #if defined(TARGET_I386) CPUClass *cc = CPU_GET_CLASS([[cpu]]); cc->do_interrupt([[cpu]]); #endif *ret = [[cpu]]->exception_index; [[cpu]]->exception_index = -1; return "True" == "True"; #else if (replay_exception()) { CPUClass *cc = CPU_GET_CLASS([[cpu]]); qemu_mutex_lock_iothread(); cc->do_interrupt([[cpu]]); qemu_mutex_unlock_iothread(); [[cpu]]->exception_index = -1; } else if (!replay_has_interrupt()) { *ret = EXCP_INTERRUPT; return "True" == "True"; } #endif } #ifndef CONFIG_USER_ONLY } else if (replay_has_exception() && [[cpu]]->icount_decr.u16.low + [[cpu]]->icount_extra == 0) { cpu_exec_nocache([[cpu]], 1, tb_find([[cpu]], NULL, 0), "True" == "True"); *ret = -1; return "True" == "True"; #endif } return "False" != "False"; }

[[[[Adv]]]]: static inline bool cpu_handle_exception(CPUState *[[supercomputer]], int *ret) { if ([[supercomputer]]->exception_index >= 0) { if ([[supercomputer]]->exception_index >= EXCP_INTERRUPT) { *ret = [[supercomputer]]->exception_index; if (*ret == EXCP_DEBUG) { cpu_handle_debug_exception([[supercomputer]]); } [[supercomputer]]->exception_index = -1; return "True" == "True"; } else { #if defined(CONFIG_USER_ONLY) #if defined(TARGET_I386) CPUClass *cc = CPU_GET_CLASS([[supercomputer]]); cc->do_interrupt([[supercomputer]]); #endif *ret = [[supercomputer]]->exception_index; [[supercomputer]]->exception_index = -1; return "True" == "True"; #else if (replay_exception()) { CPUClass *cc = CPU_GET_CLASS([[supercomputer]]); qemu_mutex_lock_iothread(); cc->do_interrupt([[supercomputer]]); qemu_mutex_unlock_iothread(); [[supercomputer]]->exception_index = -1; } else if (!replay_has_interrupt()) { *ret = EXCP_INTERRUPT; return "True" == "True"; } #endif } #ifndef CONFIG_USER_ONLY } else if (replay_has_exception() && [[supercomputer]]->icount_decr.u16.low + [[supercomputer]]->icount_extra == 0) { cpu_exec_nocache([[supercomputer]], 1, tb_find([[supercomputer]], NULL, 0), "True" == "True"); *ret = -1; return "True" == "True"; #endif } return "False" != "False"; }
--------------------------------------------- Result 248 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx) { #if HAVE_INLINE_ASM if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) { if (ctx->cid_table->bit_depth == 8) ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2; } #endif }

[[[[Adv]]]]: void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx) { #if HAVE_INLINE_ASM if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) { if (ctx->cid_table->bit_depth == 8) ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2; } #endif }
--------------------------------------------- Result 249 ---------------------------------------------
[[0 (1%)]] --> [[0 (63%)]] --> Socre: 0.6331025958061218

[[[[Adv]]]]: uint64_t helper_fdiv(CPUPPCState *[[env]], uint64_t [[arg1]], uint64_t arg2) { CPU_DoubleU [[farg1]], farg2; [[farg1]].ll = [[arg1]]; farg2.ll = arg2; if (unlikely(float64_is_infinity([[farg1]].d) && float64_is_infinity(farg2.d))) { [[farg1]].ll = fload_invalid_op_excp([[env]], POWERPC_EXCP_FP_VXIDI); } else if (unlikely(float64_is_zero([[farg1]].d) && float64_is_zero(farg2.d))) { [[farg1]].ll = fload_invalid_op_excp([[env]], POWERPC_EXCP_FP_VXZDZ); } else { if (unlikely(float64_is_signaling_nan([[farg1]].d) || float64_is_signaling_nan(farg2.d))) { fload_invalid_op_excp([[env]], POWERPC_EXCP_FP_VXSNAN); } [[farg1]].d = float64_div([[farg1]].d, farg2.d, &[[env]]->fp_status); } return [[farg1]].ll; }

[[[[Adv]]]]: uint64_t helper_fdiv(CPUPPCState *[[soria]], uint64_t [[fiances]], uint64_t arg2) { CPU_DoubleU [[sprite]], farg2; [[sprite]].ll = [[fiances]]; farg2.ll = arg2; if (unlikely(float64_is_infinity([[sprite]].d) && float64_is_infinity(farg2.d))) { [[sprite]].ll = fload_invalid_op_excp([[soria]], POWERPC_EXCP_FP_VXIDI); } else if (unlikely(float64_is_zero([[sprite]].d) && float64_is_zero(farg2.d))) { [[sprite]].ll = fload_invalid_op_excp([[soria]], POWERPC_EXCP_FP_VXZDZ); } else { if (unlikely(float64_is_signaling_nan([[sprite]].d) || float64_is_signaling_nan(farg2.d))) { fload_invalid_op_excp([[soria]], POWERPC_EXCP_FP_VXSNAN); } [[sprite]].d = float64_div([[sprite]].d, farg2.d, &[[soria]]->fp_status); } return [[sprite]].ll; }
--------------------------------------------- Result 250 ---------------------------------------------
[[0 (2%)]] --> [[0 (64%)]] --> Socre: 0.6429563760757446

[[[[Adv]]]]: static void test_io_channel_ipv4(bool async) { SocketAddress *listen_addr = g_new0(SocketAddress, 1); SocketAddress *[[connect_addr]] = g_new0(SocketAddress, 1); listen_addr->type = SOCKET_ADDRESS_KIND_INET; listen_addr->u.inet = g_new0(InetSocketAddress, 1); listen_addr->u.inet->host = g_strdup("0.0.0.0"); listen_addr->u.inet->port = NULL; [[connect_addr]]->type = SOCKET_ADDRESS_KIND_INET; [[connect_addr]]->u.inet = g_new0(InetSocketAddress, 1); [[connect_addr]]->u.inet->host = g_strdup("127.0.0.1"); [[connect_addr]]->u.inet->port = NULL; test_io_channel(async, listen_addr, [[connect_addr]]); qapi_free_SocketAddress(listen_addr); qapi_free_SocketAddress([[connect_addr]]); }

[[[[Adv]]]]: static void test_io_channel_ipv4(bool async) { SocketAddress *listen_addr = g_new0(SocketAddress, 1); SocketAddress *[[antnio]] = g_new0(SocketAddress, 1); listen_addr->type = SOCKET_ADDRESS_KIND_INET; listen_addr->u.inet = g_new0(InetSocketAddress, 1); listen_addr->u.inet->host = g_strdup("0.0.0.0"); listen_addr->u.inet->port = NULL; [[antnio]]->type = SOCKET_ADDRESS_KIND_INET; [[antnio]]->u.inet = g_new0(InetSocketAddress, 1); [[antnio]]->u.inet->host = g_strdup("127.0.0.1"); [[antnio]]->u.inet->port = NULL; test_io_channel(async, listen_addr, [[antnio]]); qapi_free_SocketAddress(listen_addr); qapi_free_SocketAddress([[antnio]]); }
--------------------------------------------- Result 251 ---------------------------------------------
[[0 (15%)]] --> [[0 (64%)]] --> Socre: 0.6390910148620605

[[[[Adv]]]]: static void gen_loongson_multimedia(DisasContext *ctx, int rd, int rs, int rt) { const char *opn = "loongson_cp2"; uint32_t opc, shift_max; TCGv_i64 [[t0]], t1; opc = MASK_LMI(ctx->opcode); switch (opc) { case OPC_ADD_CP2: case OPC_SUB_CP2: case OPC_DADD_CP2: case OPC_DSUB_CP2: [[t0]] = tcg_temp_local_new_i64(); t1 = tcg_temp_local_new_i64(); break; default: [[t0]] = tcg_temp_new_i64(); t1 = tcg_temp_new_i64(); break; } gen_load_fpr64(ctx, [[t0]], rs); gen_load_fpr64(ctx, t1, rt); #define LMI_HELPER(UP, LO) \ case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break #define LMI_HELPER_1(UP, LO) \ case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break #define LMI_DIRECT(UP, LO, OP) \ case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break switch (opc) { LMI_HELPER(PADDSH, paddsh); LMI_HELPER(PADDUSH, paddush); LMI_HELPER(PADDH, paddh); LMI_HELPER(PADDW, paddw); LMI_HELPER(PADDSB, paddsb); LMI_HELPER(PADDUSB, paddusb); LMI_HELPER(PADDB, paddb); LMI_HELPER(PSUBSH, psubsh); LMI_HELPER(PSUBUSH, psubush); LMI_HELPER(PSUBH, psubh); LMI_HELPER(PSUBW, psubw); LMI_HELPER(PSUBSB, psubsb); LMI_HELPER(PSUBUSB, psubusb); LMI_HELPER(PSUBB, psubb); LMI_HELPER(PSHUFH, pshufh); LMI_HELPER(PACKSSWH, packsswh); LMI_HELPER(PACKSSHB, packsshb); LMI_HELPER(PACKUSHB, packushb); LMI_HELPER(PUNPCKLHW, punpcklhw); LMI_HELPER(PUNPCKHHW, punpckhhw); LMI_HELPER(PUNPCKLBH, punpcklbh); LMI_HELPER(PUNPCKHBH, punpckhbh); LMI_HELPER(PUNPCKLWD, punpcklwd); LMI_HELPER(PUNPCKHWD, punpckhwd); LMI_HELPER(PAVGH, pavgh); LMI_HELPER(PAVGB, pavgb); LMI_HELPER(PMAXSH, pmaxsh); LMI_HELPER(PMINSH, pminsh); LMI_HELPER(PMAXUB, pmaxub); LMI_HELPER(PMINUB, pminub); LMI_HELPER(PCMPEQW, pcmpeqw); LMI_HELPER(PCMPGTW, pcmpgtw); LMI_HELPER(PCMPEQH, pcmpeqh); LMI_HELPER(PCMPGTH, pcmpgth); LMI_HELPER(PCMPEQB, pcmpeqb); LMI_HELPER(PCMPGTB, pcmpgtb); LMI_HELPER(PSLLW, psllw); LMI_HELPER(PSLLH, psllh); LMI_HELPER(PSRLW, psrlw); LMI_HELPER(PSRLH, psrlh); LMI_HELPER(PSRAW, psraw); LMI_HELPER(PSRAH, psrah); LMI_HELPER(PMULLH, pmullh); LMI_HELPER(PMULHH, pmulhh); LMI_HELPER(PMULHUH, pmulhuh); LMI_HELPER(PMADDHW, pmaddhw); LMI_HELPER(PASUBUB, pasubub); LMI_HELPER_1(BIADD, biadd); LMI_HELPER_1(PMOVMSKB, pmovmskb); LMI_DIRECT(PADDD, paddd, add); LMI_DIRECT(PSUBD, psubd, sub); LMI_DIRECT(XOR_CP2, xor, xor); LMI_DIRECT(NOR_CP2, nor, nor); LMI_DIRECT(AND_CP2, and, and); LMI_DIRECT(PANDN, pandn, andc); LMI_DIRECT(OR, or, or); case OPC_PINSRH_0: tcg_gen_deposit_i64([[t0]], [[t0]], t1, 0, 16); opn = "pinsrh_0"; break; case OPC_PINSRH_1: tcg_gen_deposit_i64([[t0]], [[t0]], t1, 16, 16); opn = "pinsrh_1"; break; case OPC_PINSRH_2: tcg_gen_deposit_i64([[t0]], [[t0]], t1, 32, 16); opn = "pinsrh_2"; break; case OPC_PINSRH_3: tcg_gen_deposit_i64([[t0]], [[t0]], t1, 48, 16); opn = "pinsrh_3"; break; case OPC_PEXTRH: tcg_gen_andi_i64(t1, t1, 3); tcg_gen_shli_i64(t1, t1, 4); tcg_gen_shr_i64([[t0]], [[t0]], t1); tcg_gen_ext16u_i64([[t0]], [[t0]]); opn = "pextrh"; break; case OPC_ADDU_CP2: tcg_gen_add_i64([[t0]], [[t0]], t1); tcg_gen_ext32s_i64([[t0]], [[t0]]); opn = "addu"; break; case OPC_SUBU_CP2: tcg_gen_sub_i64([[t0]], [[t0]], t1); tcg_gen_ext32s_i64([[t0]], [[t0]]); opn = "addu"; break; case OPC_SLL_CP2: opn = "sll"; shift_max = 32; goto do_shift; case OPC_SRL_CP2: opn = "srl"; shift_max = 32; goto do_shift; case OPC_SRA_CP2: opn = "sra"; shift_max = 32; goto do_shift; case OPC_DSLL_CP2: opn = "dsll"; shift_max = 64; goto do_shift; case OPC_DSRL_CP2: opn = "dsrl"; shift_max = 64; goto do_shift; case OPC_DSRA_CP2: opn = "dsra"; shift_max = 64; goto do_shift; do_shift: tcg_gen_andi_i64(t1, t1, shift_max - 1); switch (opc) { case OPC_SLL_CP2: case OPC_DSLL_CP2: tcg_gen_shl_i64([[t0]], [[t0]], t1); break; case OPC_SRA_CP2: case OPC_DSRA_CP2: tcg_gen_sar_i64([[t0]], [[t0]], t1); break; case OPC_SRL_CP2: tcg_gen_ext32u_i64([[t0]], [[t0]]); case OPC_DSRL_CP2: tcg_gen_shr_i64([[t0]], [[t0]], t1); break; } if (shift_max == 32) { tcg_gen_ext32s_i64([[t0]], [[t0]]); } tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max); tcg_gen_neg_i64(t1, t1); tcg_gen_and_i64([[t0]], [[t0]], t1); break; case OPC_ADD_CP2: case OPC_DADD_CP2: { TCGv_i64 t2 = tcg_temp_new_i64(); int lab = gen_new_label(); tcg_gen_mov_i64(t2, [[t0]]); tcg_gen_add_i64([[t0]], t1, t2); if (opc == OPC_ADD_CP2) { tcg_gen_ext32s_i64([[t0]], [[t0]]); } tcg_gen_xor_i64(t1, t1, t2); tcg_gen_xor_i64(t2, t2, [[t0]]); tcg_gen_andc_i64(t1, t2, t1); tcg_temp_free_i64(t2); tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab); generate_exception(ctx, EXCP_OVERFLOW); gen_set_label(lab); opn = (opc == OPC_ADD_CP2 ? "add" : "dadd"); break; } case OPC_SUB_CP2: case OPC_DSUB_CP2: { TCGv_i64 t2 = tcg_temp_new_i64(); int lab = gen_new_label(); tcg_gen_mov_i64(t2, [[t0]]); tcg_gen_sub_i64([[t0]], t1, t2); if (opc == OPC_SUB_CP2) { tcg_gen_ext32s_i64([[t0]], [[t0]]); } tcg_gen_xor_i64(t1, t1, t2); tcg_gen_xor_i64(t2, t2, [[t0]]); tcg_gen_and_i64(t1, t1, t2); tcg_temp_free_i64(t2); tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab); generate_exception(ctx, EXCP_OVERFLOW); gen_set_label(lab); opn = (opc == OPC_SUB_CP2 ? "sub" : "dsub"); break; } case OPC_PMULUW: tcg_gen_ext32u_i64([[t0]], [[t0]]); tcg_gen_ext32u_i64(t1, t1); tcg_gen_mul_i64([[t0]], [[t0]], t1); opn = "pmuluw"; break; case OPC_SEQU_CP2: case OPC_SEQ_CP2: case OPC_SLTU_CP2: case OPC_SLT_CP2: case OPC_SLEU_CP2: case OPC_SLE_CP2: default: MIPS_INVAL(opn); generate_exception(ctx, EXCP_RI); return; } #undef LMI_HELPER #undef LMI_DIRECT gen_store_fpr64(ctx, [[t0]], rd); (void)opn; MIPS_DEBUG("%s %s, %s, %s", opn, fregnames[rd], fregnames[rs], fregnames[rt]); tcg_temp_free_i64([[t0]]); tcg_temp_free_i64(t1); }

[[[[Adv]]]]: static void gen_loongson_multimedia(DisasContext *ctx, int rd, int rs, int rt) { const char *opn = "loongson_cp2"; uint32_t opc, shift_max; TCGv_i64 [[theyre]], t1; opc = MASK_LMI(ctx->opcode); switch (opc) { case OPC_ADD_CP2: case OPC_SUB_CP2: case OPC_DADD_CP2: case OPC_DSUB_CP2: [[theyre]] = tcg_temp_local_new_i64(); t1 = tcg_temp_local_new_i64(); break; default: [[theyre]] = tcg_temp_new_i64(); t1 = tcg_temp_new_i64(); break; } gen_load_fpr64(ctx, [[theyre]], rs); gen_load_fpr64(ctx, t1, rt); #define LMI_HELPER(UP, LO) \ case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break #define LMI_HELPER_1(UP, LO) \ case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break #define LMI_DIRECT(UP, LO, OP) \ case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break switch (opc) { LMI_HELPER(PADDSH, paddsh); LMI_HELPER(PADDUSH, paddush); LMI_HELPER(PADDH, paddh); LMI_HELPER(PADDW, paddw); LMI_HELPER(PADDSB, paddsb); LMI_HELPER(PADDUSB, paddusb); LMI_HELPER(PADDB, paddb); LMI_HELPER(PSUBSH, psubsh); LMI_HELPER(PSUBUSH, psubush); LMI_HELPER(PSUBH, psubh); LMI_HELPER(PSUBW, psubw); LMI_HELPER(PSUBSB, psubsb); LMI_HELPER(PSUBUSB, psubusb); LMI_HELPER(PSUBB, psubb); LMI_HELPER(PSHUFH, pshufh); LMI_HELPER(PACKSSWH, packsswh); LMI_HELPER(PACKSSHB, packsshb); LMI_HELPER(PACKUSHB, packushb); LMI_HELPER(PUNPCKLHW, punpcklhw); LMI_HELPER(PUNPCKHHW, punpckhhw); LMI_HELPER(PUNPCKLBH, punpcklbh); LMI_HELPER(PUNPCKHBH, punpckhbh); LMI_HELPER(PUNPCKLWD, punpcklwd); LMI_HELPER(PUNPCKHWD, punpckhwd); LMI_HELPER(PAVGH, pavgh); LMI_HELPER(PAVGB, pavgb); LMI_HELPER(PMAXSH, pmaxsh); LMI_HELPER(PMINSH, pminsh); LMI_HELPER(PMAXUB, pmaxub); LMI_HELPER(PMINUB, pminub); LMI_HELPER(PCMPEQW, pcmpeqw); LMI_HELPER(PCMPGTW, pcmpgtw); LMI_HELPER(PCMPEQH, pcmpeqh); LMI_HELPER(PCMPGTH, pcmpgth); LMI_HELPER(PCMPEQB, pcmpeqb); LMI_HELPER(PCMPGTB, pcmpgtb); LMI_HELPER(PSLLW, psllw); LMI_HELPER(PSLLH, psllh); LMI_HELPER(PSRLW, psrlw); LMI_HELPER(PSRLH, psrlh); LMI_HELPER(PSRAW, psraw); LMI_HELPER(PSRAH, psrah); LMI_HELPER(PMULLH, pmullh); LMI_HELPER(PMULHH, pmulhh); LMI_HELPER(PMULHUH, pmulhuh); LMI_HELPER(PMADDHW, pmaddhw); LMI_HELPER(PASUBUB, pasubub); LMI_HELPER_1(BIADD, biadd); LMI_HELPER_1(PMOVMSKB, pmovmskb); LMI_DIRECT(PADDD, paddd, add); LMI_DIRECT(PSUBD, psubd, sub); LMI_DIRECT(XOR_CP2, xor, xor); LMI_DIRECT(NOR_CP2, nor, nor); LMI_DIRECT(AND_CP2, and, and); LMI_DIRECT(PANDN, pandn, andc); LMI_DIRECT(OR, or, or); case OPC_PINSRH_0: tcg_gen_deposit_i64([[theyre]], [[theyre]], t1, 0, 16); opn = "pinsrh_0"; break; case OPC_PINSRH_1: tcg_gen_deposit_i64([[theyre]], [[theyre]], t1, 16, 16); opn = "pinsrh_1"; break; case OPC_PINSRH_2: tcg_gen_deposit_i64([[theyre]], [[theyre]], t1, 32, 16); opn = "pinsrh_2"; break; case OPC_PINSRH_3: tcg_gen_deposit_i64([[theyre]], [[theyre]], t1, 48, 16); opn = "pinsrh_3"; break; case OPC_PEXTRH: tcg_gen_andi_i64(t1, t1, 3); tcg_gen_shli_i64(t1, t1, 4); tcg_gen_shr_i64([[theyre]], [[theyre]], t1); tcg_gen_ext16u_i64([[theyre]], [[theyre]]); opn = "pextrh"; break; case OPC_ADDU_CP2: tcg_gen_add_i64([[theyre]], [[theyre]], t1); tcg_gen_ext32s_i64([[theyre]], [[theyre]]); opn = "addu"; break; case OPC_SUBU_CP2: tcg_gen_sub_i64([[theyre]], [[theyre]], t1); tcg_gen_ext32s_i64([[theyre]], [[theyre]]); opn = "addu"; break; case OPC_SLL_CP2: opn = "sll"; shift_max = 32; goto do_shift; case OPC_SRL_CP2: opn = "srl"; shift_max = 32; goto do_shift; case OPC_SRA_CP2: opn = "sra"; shift_max = 32; goto do_shift; case OPC_DSLL_CP2: opn = "dsll"; shift_max = 64; goto do_shift; case OPC_DSRL_CP2: opn = "dsrl"; shift_max = 64; goto do_shift; case OPC_DSRA_CP2: opn = "dsra"; shift_max = 64; goto do_shift; do_shift: tcg_gen_andi_i64(t1, t1, shift_max - 1); switch (opc) { case OPC_SLL_CP2: case OPC_DSLL_CP2: tcg_gen_shl_i64([[theyre]], [[theyre]], t1); break; case OPC_SRA_CP2: case OPC_DSRA_CP2: tcg_gen_sar_i64([[theyre]], [[theyre]], t1); break; case OPC_SRL_CP2: tcg_gen_ext32u_i64([[theyre]], [[theyre]]); case OPC_DSRL_CP2: tcg_gen_shr_i64([[theyre]], [[theyre]], t1); break; } if (shift_max == 32) { tcg_gen_ext32s_i64([[theyre]], [[theyre]]); } tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max); tcg_gen_neg_i64(t1, t1); tcg_gen_and_i64([[theyre]], [[theyre]], t1); break; case OPC_ADD_CP2: case OPC_DADD_CP2: { TCGv_i64 t2 = tcg_temp_new_i64(); int lab = gen_new_label(); tcg_gen_mov_i64(t2, [[theyre]]); tcg_gen_add_i64([[theyre]], t1, t2); if (opc == OPC_ADD_CP2) { tcg_gen_ext32s_i64([[theyre]], [[theyre]]); } tcg_gen_xor_i64(t1, t1, t2); tcg_gen_xor_i64(t2, t2, [[theyre]]); tcg_gen_andc_i64(t1, t2, t1); tcg_temp_free_i64(t2); tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab); generate_exception(ctx, EXCP_OVERFLOW); gen_set_label(lab); opn = (opc == OPC_ADD_CP2 ? "add" : "dadd"); break; } case OPC_SUB_CP2: case OPC_DSUB_CP2: { TCGv_i64 t2 = tcg_temp_new_i64(); int lab = gen_new_label(); tcg_gen_mov_i64(t2, [[theyre]]); tcg_gen_sub_i64([[theyre]], t1, t2); if (opc == OPC_SUB_CP2) { tcg_gen_ext32s_i64([[theyre]], [[theyre]]); } tcg_gen_xor_i64(t1, t1, t2); tcg_gen_xor_i64(t2, t2, [[theyre]]); tcg_gen_and_i64(t1, t1, t2); tcg_temp_free_i64(t2); tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab); generate_exception(ctx, EXCP_OVERFLOW); gen_set_label(lab); opn = (opc == OPC_SUB_CP2 ? "sub" : "dsub"); break; } case OPC_PMULUW: tcg_gen_ext32u_i64([[theyre]], [[theyre]]); tcg_gen_ext32u_i64(t1, t1); tcg_gen_mul_i64([[theyre]], [[theyre]], t1); opn = "pmuluw"; break; case OPC_SEQU_CP2: case OPC_SEQ_CP2: case OPC_SLTU_CP2: case OPC_SLT_CP2: case OPC_SLEU_CP2: case OPC_SLE_CP2: default: MIPS_INVAL(opn); generate_exception(ctx, EXCP_RI); return; } #undef LMI_HELPER #undef LMI_DIRECT gen_store_fpr64(ctx, [[theyre]], rd); (void)opn; MIPS_DEBUG("%s %s, %s, %s", opn, fregnames[rd], fregnames[rs], fregnames[rt]); tcg_temp_free_i64([[theyre]]); tcg_temp_free_i64(t1); }[Succeeded / Failed / Skipped / Total] 144 / 10 / 97 / 251:   9%|         | 251/2690 [1:16:47<12:26:08, 18.36s/it][Succeeded / Failed / Skipped / Total] 144 / 10 / 97 / 251:   9%|         | 252/2690 [1:16:58<12:24:38, 18.33s/it][Succeeded / Failed / Skipped / Total] 145 / 10 / 97 / 252:   9%|         | 252/2690 [1:16:58<12:24:38, 18.33s/it][Succeeded / Failed / Skipped / Total] 145 / 10 / 97 / 252:   9%|         | 253/2690 [1:25:41<13:45:21, 20.32s/it][Succeeded / Failed / Skipped / Total] 145 / 11 / 97 / 253:   9%|         | 253/2690 [1:25:41<13:45:21, 20.32s/it][Succeeded / Failed / Skipped / Total] 145 / 11 / 97 / 253:   9%|         | 254/2690 [1:25:49<13:43:11, 20.28s/it][Succeeded / Failed / Skipped / Total] 146 / 11 / 97 / 254:   9%|         | 254/2690 [1:25:49<13:43:11, 20.28s/it][Succeeded / Failed / Skipped / Total] 146 / 11 / 97 / 254:   9%|         | 255/2690 [1:25:50<13:39:42, 20.20s/it][Succeeded / Failed / Skipped / Total] 146 / 11 / 98 / 255:   9%|         | 255/2690 [1:25:50<13:39:42, 20.20s/it][Succeeded / Failed / Skipped / Total] 146 / 11 / 98 / 255:  10%|         | 256/2690 [1:26:17<13:40:25, 20.22s/it]
--------------------------------------------- Result 252 ---------------------------------------------
[[0 (17%)]] --> [[0 (52%)]] --> Socre: 0.5203940868377686

[[[[Adv]]]]: static void v9fs_stat(void *[[opaque]]) { int32_t [[fid]]; V9fsStat v9stat; ssize_t err = 0; size_t offset = 7; struct stat stbuf; V9fsFidState *fidp; V9fsPDU *pdu = [[opaque]]; V9fsState *s = pdu->s; pdu_unmarshal(pdu, offset, "d", &[[fid]]); trace_v9fs_stat(pdu->tag, pdu->id, [[fid]]); fidp = get_fid(pdu, [[fid]]); if (fidp == NULL) { err = -ENOENT; goto out_nofid; } err = v9fs_co_lstat(pdu, &fidp->path, &stbuf); if (err < 0) { goto out; } err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat); if (err < 0) { goto out; } offset += pdu_marshal(pdu, offset, "wS", 0, &v9stat); err = offset; trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode, v9stat.atime, v9stat.mtime, v9stat.length); v9fs_stat_free(&v9stat); out: put_fid(pdu, fidp); out_nofid: complete_pdu(s, pdu, err); }

[[[[Adv]]]]: static void v9fs_stat(void *[[blurred]]) { int32_t [[breastfed]]; V9fsStat v9stat; ssize_t err = 0; size_t offset = 7; struct stat stbuf; V9fsFidState *fidp; V9fsPDU *pdu = [[blurred]]; V9fsState *s = pdu->s; pdu_unmarshal(pdu, offset, "d", &[[breastfed]]); trace_v9fs_stat(pdu->tag, pdu->id, [[breastfed]]); fidp = get_fid(pdu, [[breastfed]]); if (fidp == NULL) { err = -ENOENT; goto out_nofid; } err = v9fs_co_lstat(pdu, &fidp->path, &stbuf); if (err < 0) { goto out; } err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat); if (err < 0) { goto out; } offset += pdu_marshal(pdu, offset, "wS", 0, &v9stat); err = offset; trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode, v9stat.atime, v9stat.mtime, v9stat.length); v9fs_stat_free(&v9stat); out: put_fid(pdu, fidp); out_nofid: complete_pdu(s, pdu, err); }
--------------------------------------------- Result 253 ---------------------------------------------
[[0 (91%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static av_cold int init_bundles(BinkContext *c) { int bw, bh, blocks; int i; bw = (c->avctx->width + 7) >> 3; bh = (c->avctx->height + 7) >> 3; blocks = bw * bh; for (i = 0; i < BINKB_NB_SRC; i++) { c->bundle[i].data = av_malloc(blocks * 64); if (!c->bundle[i].data) return AVERROR(ENOMEM); c->bundle[i].data_end = c->bundle[i].data + blocks * 64; } return 0; }

[[[[Adv]]]]: static av_cold int init_bundles(BinkContext *c) { int bw, bh, blocks; int i; bw = (c->avctx->width + 7) >> 3; bh = (c->avctx->height + 7) >> 3; blocks = bw * bh; for (i = 0; i < BINKB_NB_SRC; i++) { c->bundle[i].data = av_malloc(blocks * 64); if (!c->bundle[i].data) return AVERROR(ENOMEM); c->bundle[i].data_end = c->bundle[i].data + blocks * 64; } return 0; }
--------------------------------------------- Result 254 ---------------------------------------------
[[0 (60%)]] --> [[0 (42%)]] --> Socre: 0.5762426257133484

[[[[Adv]]]]: static int of_dpa_cmd_add_l2_flood(OfDpa *[[of_dpa]], OfDpaGroup *group, RockerTlv **group_tlvs) { OfDpaGroup *l2_group; RockerTlv **tlvs; int err; int i; if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] || !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) { return -ROCKER_EINVAL; } group->l2_flood.group_count = rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]); tlvs = g_malloc0((group->l2_flood.group_count + 1) * sizeof(RockerTlv *)); if (!tlvs) { return -ROCKER_ENOMEM; } g_free(group->l2_flood.group_ids); group->l2_flood.group_ids = g_malloc0(group->l2_flood.group_count * sizeof(uint32_t)); if (!group->l2_flood.group_ids) { err = -ROCKER_ENOMEM; goto err_out; } rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count, group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]); for (i = 0; i < group->l2_flood.group_count; i++) { group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]); } for (i = 0; i < group->l2_flood.group_count; i++) { l2_group = of_dpa_group_find([[of_dpa]], group->l2_flood.group_ids[i]); if (!l2_group) { continue; } if ((ROCKER_GROUP_TYPE_GET(l2_group->id) == ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) && (ROCKER_GROUP_VLAN_GET(l2_group->id) != ROCKER_GROUP_VLAN_GET(group->id))) { DPRINTF("l2 interface group 0x%08x VLAN doesn't match l2 " "flood group 0x%08x\n", group->l2_flood.group_ids[i], group->id); err = -ROCKER_EINVAL; goto err_out; } } g_free(tlvs); return ROCKER_OK; err_out: group->l2_flood.group_count = 0; g_free(group->l2_flood.group_ids); g_free(tlvs); return err; }

[[[[Adv]]]]: static int of_dpa_cmd_add_l2_flood(OfDpa *[[fargas]], OfDpaGroup *group, RockerTlv **group_tlvs) { OfDpaGroup *l2_group; RockerTlv **tlvs; int err; int i; if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] || !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) { return -ROCKER_EINVAL; } group->l2_flood.group_count = rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]); tlvs = g_malloc0((group->l2_flood.group_count + 1) * sizeof(RockerTlv *)); if (!tlvs) { return -ROCKER_ENOMEM; } g_free(group->l2_flood.group_ids); group->l2_flood.group_ids = g_malloc0(group->l2_flood.group_count * sizeof(uint32_t)); if (!group->l2_flood.group_ids) { err = -ROCKER_ENOMEM; goto err_out; } rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count, group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]); for (i = 0; i < group->l2_flood.group_count; i++) { group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]); } for (i = 0; i < group->l2_flood.group_count; i++) { l2_group = of_dpa_group_find([[fargas]], group->l2_flood.group_ids[i]); if (!l2_group) { continue; } if ((ROCKER_GROUP_TYPE_GET(l2_group->id) == ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) && (ROCKER_GROUP_VLAN_GET(l2_group->id) != ROCKER_GROUP_VLAN_GET(group->id))) { DPRINTF("l2 interface group 0x%08x VLAN doesn't match l2 " "flood group 0x%08x\n", group->l2_flood.group_ids[i], group->id); err = -ROCKER_EINVAL; goto err_out; } } g_free(tlvs); return ROCKER_OK; err_out: group->l2_flood.group_count = 0; g_free(group->l2_flood.group_ids); g_free(tlvs); return err; }
--------------------------------------------- Result 255 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) { const uint64_t fuzz_tag = FUZZ_TAG; FuzzDataBuffer buffer; const uint8_t *last = data; const uint8_t *end = data + size; uint32_t it = 0; if (!c) c = AVCodecInitialize(FFMPEG_CODEC); AVCodecContext* ctx = avcodec_alloc_context3(NULL); if (!ctx) error("Failed memory allocation"); ctx->max_pixels = 4096 * 4096; int res = avcodec_open2(ctx, c, NULL); if (res < 0) return res; FDBCreate(&buffer); int got_frame; AVFrame *frame = av_frame_alloc(); if (!frame) error("Failed memory allocation"); AVPacket avpkt; while (data < end && it < maxiteration) { while (data + sizeof(fuzz_tag) < end) { if (data[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(data) == fuzz_tag) break; data++; } if (data + sizeof(fuzz_tag) > end) data = end; FDBPrepare(&buffer, &avpkt, last, data - last); data += sizeof(fuzz_tag); last = data; while (avpkt.size > 0 && it++ < maxiteration) { av_frame_unref(frame); int ret = decode_handler(ctx, frame, &got_frame, &avpkt); if (it > 20) ctx->error_concealment = 0; if (ret <= 0 || ret > avpkt.size) break; avpkt.data += ret; avpkt.size -= ret; } } av_init_packet(&avpkt); avpkt.data = NULL; avpkt.size = 0; do { got_frame = 0; decode_handler(ctx, frame, &got_frame, &avpkt); } while (got_frame == 1 && it++ < maxiteration); av_frame_free(&frame); avcodec_free_context(&ctx); av_freep(&ctx); FDBDesroy(&buffer); return 0; }
--------------------------------------------- Result 256 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 147 / 11 / 98 / 256:  10%|         | 256/2690 [1:26:17<13:40:25, 20.22s/it][Succeeded / Failed / Skipped / Total] 147 / 11 / 98 / 256:  10%|         | 257/2690 [1:27:28<13:48:06, 20.42s/it][Succeeded / Failed / Skipped / Total] 148 / 11 / 98 / 257:  10%|         | 257/2690 [1:27:28<13:48:06, 20.42s/it][Succeeded / Failed / Skipped / Total] 148 / 11 / 98 / 257:  10%|         | 258/2690 [1:27:44<13:47:02, 20.40s/it][[0 (2%)]] --> [[0 (99%)]] --> Socre: 0.9861133694648743

[[[[Adv]]]]: void disas_a64_insn(CPUARMState *env, DisasContext *s) { uint32_t [[insn]]; [[insn]] = arm_ldl_code(env, s->pc, s->bswap_code); s->insn = [[insn]]; s->pc += 4; switch (([[insn]] >> 24) & 0x1f) { default: unallocated_encoding(s); break; } if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) { s->is_jmp = DISAS_JUMP; } }

[[[[Adv]]]]: void disas_a64_insn(CPUARMState *env, DisasContext *s) { uint32_t [[via]]; [[via]] = arm_ldl_code(env, s->pc, s->bswap_code); s->insn = [[via]]; s->pc += 4; switch (([[via]] >> 24) & 0x1f) { default: unallocated_encoding(s); break; } if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) { s->is_jmp = DISAS_JUMP; } }
--------------------------------------------- Result 257 ---------------------------------------------
[[0 (82%)]] --> [[0 (49%)]] --> Socre: 0.5132562518119812

[[[[Adv]]]]: static inline void RENAME(hyscale)(uint16_t *[[dst]], int dstWidth, uint8_t *src, int [[srcW]], int xInc) { #ifdef HAVE_MMX if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed)) #else if(sws_flags != SWS_FAST_BILINEAR) #endif { RENAME(hScale)([[dst]], dstWidth, src, [[srcW]], xInc, hLumFilter, hLumFilterPos, hLumFilterSize); } else { #ifdef ARCH_X86 #ifdef HAVE_MMX2 int [[i]]; if(canMMX2BeUsed) { asm volatile( "pxor %%mm7, %%mm7 \n\t" "pxor %%mm2, %%mm2 \n\t" "movd %5, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "movq %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "paddw %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "paddw %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "movq %%mm2, "MANGLE(temp0)" \n\t" "movd %4, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "xorl %%eax, %%eax \n\t" "movl %0, %%esi \n\t" "movl %1, %%edi \n\t" "movl %3, %%edx \n\t" "xorl %%ecx, %%ecx \n\t" "xorl %%ebx, %%ebx \n\t" "movw %4, %%bx \n\t" #define FUNNY_Y_CODE \ PREFETCH" 1024(%%esi) \n\t"\ PREFETCH" 1056(%%esi) \n\t"\ PREFETCH" 1088(%%esi) \n\t"\ "call "MANGLE(funnyYCode)" \n\t"\ "movq "MANGLE(temp0)", %%mm2 \n\t"\ "xorl %%ecx, %%ecx \n\t" FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE :: "m" (src), "m" ([[dst]]), "m" (dstWidth), "m" ((xInc*4)>>16), "m" ((xInc*4)&0xFFFF), "m" (xInc&0xFFFF) : "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi" ); for([[i]]=dstWidth-1; ([[i]]*xInc)>>16 >=[[srcW]]-1; [[i]]--) [[dst]][[[i]]] = src[[[srcW]]-1]*128; } else { #endif asm volatile( "xorl %%eax, %%eax \n\t" "xorl %%ebx, %%ebx \n\t" "xorl %%ecx, %%ecx \n\t" ".balign 16 \n\t" "1: \n\t" "movzbl (%0, %%ebx), %%edi \n\t" "movzbl 1(%0, %%ebx), %%esi \n\t" "subl %%edi, %%esi \n\t" "imull %%ecx, %%esi \n\t" "shll $16, %%edi \n\t" "addl %%edi, %%esi \n\t" "movl %1, %%edi \n\t" "shrl $9, %%esi \n\t" "movw %%si, (%%edi, %%eax, 2) \n\t" "addw %4, %%cx \n\t" "adcl %3, %%ebx \n\t" "movzbl (%0, %%ebx), %%edi \n\t" "movzbl 1(%0, %%ebx), %%esi \n\t" "subl %%edi, %%esi \n\t" "imull %%ecx, %%esi \n\t" "shll $16, %%edi \n\t" "addl %%edi, %%esi \n\t" "movl %1, %%edi \n\t" "shrl $9, %%esi \n\t" "movw %%si, 2(%%edi, %%eax, 2) \n\t" "addw %4, %%cx \n\t" "adcl %3, %%ebx \n\t" "addl $2, %%eax \n\t" "cmpl %2, %%eax \n\t" " jb 1b \n\t" :: "r" (src), "m" ([[dst]]), "m" (dstWidth), "m" (xInc>>16), "m" (xInc&0xFFFF) : "%eax", "%ebx", "%ecx", "%edi", "%esi" ); #ifdef HAVE_MMX2 } #endif #else int i; unsigned int xpos=0; for([[i]]=0;[[i]]<dstWidth;[[i]]++) { register unsigned int xx=xpos>>16; register unsigned int xalpha=(xpos&0xFFFF)>>9; [[dst]][[[i]]]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha; xpos+=xInc; } #endif } }

[[[[Adv]]]]: static inline void RENAME(hyscale)(uint16_t *[[wakeup]], int dstWidth, uint8_t *src, int [[danker]], int xInc) { #ifdef HAVE_MMX if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed)) #else if(sws_flags != SWS_FAST_BILINEAR) #endif { RENAME(hScale)([[wakeup]], dstWidth, src, [[danker]], xInc, hLumFilter, hLumFilterPos, hLumFilterSize); } else { #ifdef ARCH_X86 #ifdef HAVE_MMX2 int [[jes]]; if(canMMX2BeUsed) { asm volatile( "pxor %%mm7, %%mm7 \n\t" "pxor %%mm2, %%mm2 \n\t" "movd %5, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "movq %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "paddw %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "paddw %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "movq %%mm2, "MANGLE(temp0)" \n\t" "movd %4, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "xorl %%eax, %%eax \n\t" "movl %0, %%esi \n\t" "movl %1, %%edi \n\t" "movl %3, %%edx \n\t" "xorl %%ecx, %%ecx \n\t" "xorl %%ebx, %%ebx \n\t" "movw %4, %%bx \n\t" #define FUNNY_Y_CODE \ PREFETCH" 1024(%%esi) \n\t"\ PREFETCH" 1056(%%esi) \n\t"\ PREFETCH" 1088(%%esi) \n\t"\ "call "MANGLE(funnyYCode)" \n\t"\ "movq "MANGLE(temp0)", %%mm2 \n\t"\ "xorl %%ecx, %%ecx \n\t" FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE :: "m" (src), "m" ([[wakeup]]), "m" (dstWidth), "m" ((xInc*4)>>16), "m" ((xInc*4)&0xFFFF), "m" (xInc&0xFFFF) : "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi" ); for([[jes]]=dstWidth-1; ([[jes]]*xInc)>>16 >=[[danker]]-1; [[jes]]--) [[wakeup]][[[jes]]] = src[[[danker]]-1]*128; } else { #endif asm volatile( "xorl %%eax, %%eax \n\t" "xorl %%ebx, %%ebx \n\t" "xorl %%ecx, %%ecx \n\t" ".balign 16 \n\t" "1: \n\t" "movzbl (%0, %%ebx), %%edi \n\t" "movzbl 1(%0, %%ebx), %%esi \n\t" "subl %%edi, %%esi \n\t" "imull %%ecx, %%esi \n\t" "shll $16, %%edi \n\t" "addl %%edi, %%esi \n\t" "movl %1, %%edi \n\t" "shrl $9, %%esi \n\t" "movw %%si, (%%edi, %%eax, 2) \n\t" "addw %4, %%cx \n\t" "adcl %3, %%ebx \n\t" "movzbl (%0, %%ebx), %%edi \n\t" "movzbl 1(%0, %%ebx), %%esi \n\t" "subl %%edi, %%esi \n\t" "imull %%ecx, %%esi \n\t" "shll $16, %%edi \n\t" "addl %%edi, %%esi \n\t" "movl %1, %%edi \n\t" "shrl $9, %%esi \n\t" "movw %%si, 2(%%edi, %%eax, 2) \n\t" "addw %4, %%cx \n\t" "adcl %3, %%ebx \n\t" "addl $2, %%eax \n\t" "cmpl %2, %%eax \n\t" " jb 1b \n\t" :: "r" (src), "m" ([[wakeup]]), "m" (dstWidth), "m" (xInc>>16), "m" (xInc&0xFFFF) : "%eax", "%ebx", "%ecx", "%edi", "%esi" ); #ifdef HAVE_MMX2 } #endif #else int i; unsigned int xpos=0; for([[jes]]=0;[[jes]]<dstWidth;[[jes]]++) { register unsigned int xx=xpos>>16; register unsigned int xalpha=(xpos&0xFFFF)>>9; [[wakeup]][[[jes]]]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha; xpos+=xInc; } #endif } }
--------------------------------------------- Result 258 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 149 / 11 / 98 / 258:  10%|         | 258/2690 [1:27:44<13:47:02, 20.40s/it][Succeeded / Failed / Skipped / Total] 149 / 11 / 98 / 258:  10%|         | 259/2690 [1:29:21<13:58:43, 20.70s/it][Succeeded / Failed / Skipped / Total] 150 / 11 / 98 / 259:  10%|         | 259/2690 [1:29:21<13:58:43, 20.70s/it][Succeeded / Failed / Skipped / Total] 150 / 11 / 98 / 259:  10%|         | 260/2690 [1:29:22<13:55:14, 20.62s/it][Succeeded / Failed / Skipped / Total] 150 / 11 / 99 / 260:  10%|         | 260/2690 [1:29:22<13:55:14, 20.62s/it][Succeeded / Failed / Skipped / Total] 150 / 11 / 99 / 260:  10%|         | 261/2690 [1:30:28<14:02:03, 20.80s/it][Succeeded / Failed / Skipped / Total] 151 / 11 / 99 / 261:  10%|         | 261/2690 [1:30:28<14:02:03, 20.80s/it][Succeeded / Failed / Skipped / Total] 151 / 11 / 99 / 261:  10%|         | 262/2690 [1:30:29<13:58:35, 20.72s/it][Succeeded / Failed / Skipped / Total] 151 / 11 / 100 / 262:  10%|         | 262/2690 [1:30:29<13:58:35, 20.72s/it][Succeeded / Failed / Skipped / Total] 151 / 11 / 100 / 262:  10%|         | 263/2690 [1:30:40<13:56:45, 20.69s/it][[0 (6%)]] --> [[0 (51%)]] --> Socre: 0.5130025148391724

[[[[Adv]]]]: static int hdev_open(BlockDriverState *bs, const char *[[filename]], int [[flags]]) { BDRVRawState *s = bs->opaque; int access_flags, create_flags; DWORD [[overlapped]]; char [[device_name]][64]; if (strstart([[filename]], "/dev/cdrom", NULL)) { if (find_cdrom([[device_name]], sizeof([[device_name]])) < 0) return -ENOENT; [[filename]] = [[device_name]]; } else { if ((([[filename]][0] >= 'a' && [[filename]][0] <= 'z') || ([[filename]][0] >= 'A' && [[filename]][0] <= 'Z')) && [[filename]][1] == ':' && [[filename]][2] == '\0') { snprintf([[device_name]], sizeof([[device_name]]), "\\\\.\\%c:", [[filename]][0]); [[filename]] = [[device_name]]; } } s->type = find_device_type(bs, [[filename]]); if (([[flags]] & BDRV_O_ACCESS) == O_RDWR) { access_flags = GENERIC_READ | GENERIC_WRITE; } else { access_flags = GENERIC_READ; } create_flags = OPEN_EXISTING; #ifdef QEMU_TOOL [[overlapped]] = FILE_ATTRIBUTE_NORMAL; #else [[overlapped]] = FILE_FLAG_OVERLAPPED; #endif s->hfile = CreateFile([[filename]], access_flags, FILE_SHARE_READ, NULL, create_flags, [[overlapped]], NULL); if (s->hfile == INVALID_HANDLE_VALUE) return -1; return 0; }

[[[[Adv]]]]: static int hdev_open(BlockDriverState *bs, const char *[[minds]], int [[pavillion]]) { BDRVRawState *s = bs->opaque; int access_flags, create_flags; DWORD [[spaced]]; char [[aiming]][64]; if (strstart([[minds]], "/dev/cdrom", NULL)) { if (find_cdrom([[aiming]], sizeof([[aiming]])) < 0) return -ENOENT; [[minds]] = [[aiming]]; } else { if ((([[minds]][0] >= 'a' && [[minds]][0] <= 'z') || ([[minds]][0] >= 'A' && [[minds]][0] <= 'Z')) && [[minds]][1] == ':' && [[minds]][2] == '\0') { snprintf([[aiming]], sizeof([[aiming]]), "\\\\.\\%c:", [[minds]][0]); [[minds]] = [[aiming]]; } } s->type = find_device_type(bs, [[minds]]); if (([[pavillion]] & BDRV_O_ACCESS) == O_RDWR) { access_flags = GENERIC_READ | GENERIC_WRITE; } else { access_flags = GENERIC_READ; } create_flags = OPEN_EXISTING; #ifdef QEMU_TOOL [[spaced]] = FILE_ATTRIBUTE_NORMAL; #else [[spaced]] = FILE_FLAG_OVERLAPPED; #endif s->hfile = CreateFile([[minds]], access_flags, FILE_SHARE_READ, NULL, create_flags, [[spaced]], NULL); if (s->hfile == INVALID_HANDLE_VALUE) return -1; return 0; }
--------------------------------------------- Result 259 ---------------------------------------------
[[0 (2%)]] --> [[0 (56%)]] --> Socre: 0.5618974566459656

[[[[Adv]]]]: static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data [[arg]]) { S390CPU *cpu = S390_CPU(cs); SigpInfo *[[si]] = [[arg]].host_ptr; if (!s390_has_feat(S390_FEAT_VECTOR)) { set_sigp_status([[si]], SIGP_STAT_INVALID_ORDER); return; } if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) { set_sigp_status([[si]], SIGP_STAT_INCORRECT_STATE); return; } if ([[si]]->param & 0x3ff) { set_sigp_status([[si]], SIGP_STAT_INVALID_PARAMETER); return; } cpu_synchronize_state(cs); if (kvm_s390_store_adtl_status(cpu, [[si]]->param)) { set_sigp_status([[si]], SIGP_STAT_INVALID_PARAMETER); return; } [[si]]->cc = SIGP_CC_ORDER_CODE_ACCEPTED; }

[[[[Adv]]]]: static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data [[pedophilia]]) { S390CPU *cpu = S390_CPU(cs); SigpInfo *[[ti]] = [[pedophilia]].host_ptr; if (!s390_has_feat(S390_FEAT_VECTOR)) { set_sigp_status([[ti]], SIGP_STAT_INVALID_ORDER); return; } if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) { set_sigp_status([[ti]], SIGP_STAT_INCORRECT_STATE); return; } if ([[ti]]->param & 0x3ff) { set_sigp_status([[ti]], SIGP_STAT_INVALID_PARAMETER); return; } cpu_synchronize_state(cs); if (kvm_s390_store_adtl_status(cpu, [[ti]]->param)) { set_sigp_status([[ti]], SIGP_STAT_INVALID_PARAMETER); return; } [[ti]]->cc = SIGP_CC_ORDER_CODE_ACCEPTED; }
--------------------------------------------- Result 260 ---------------------------------------------
[[0 (74%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n) { target_ulong tmp; tmp = ldtul_p(mem_buf); if (n < 32) { env->active_tc.gpr[n] = tmp; return sizeof(target_ulong); } if (env->CP0_Config1 & (1 << CP0C1_FP) && n >= 38 && n < 73) { if (n < 70) { if (env->CP0_Status & (1 << CP0St_FR)) env->active_fpu.fpr[n - 38].d = tmp; else env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp; } switch (n) { case 70: env->active_fpu.fcr31 = tmp & 0xFF83FFFF; RESTORE_ROUNDING_MODE; #ifndef CONFIG_SOFTFLOAT SET_FP_ENABLE(env->active_fpu.fcr31, 0); #endif break; case 71: env->active_fpu.fcr0 = tmp; break; } return sizeof(target_ulong); } switch (n) { case 32: env->CP0_Status = tmp; break; case 33: env->active_tc.LO[0] = tmp; break; case 34: env->active_tc.HI[0] = tmp; break; case 35: env->CP0_BadVAddr = tmp; break; case 36: env->CP0_Cause = tmp; break; case 37: env->active_tc.PC = tmp; break; case 72: break; default: if (n > 89) return 0; break; } return sizeof(target_ulong); }
--------------------------------------------- Result 261 ---------------------------------------------
[[0 (34%)]] --> [[0 (58%)]] --> Socre: 0.5849544405937195

[[[[Adv]]]]: QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *[[opaque]]) { QEMUBH *bh; bh = g_malloc0(sizeof(QEMUBH)); bh->ctx = ctx; bh->cb = cb; bh->opaque = [[opaque]]; qemu_mutex_lock(&ctx->bh_lock); bh->next = ctx->first_bh; smp_wmb(); ctx->first_bh = bh; qemu_mutex_unlock(&ctx->bh_lock); return bh; }

[[[[Adv]]]]: QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *[[blurry]]) { QEMUBH *bh; bh = g_malloc0(sizeof(QEMUBH)); bh->ctx = ctx; bh->cb = cb; bh->opaque = [[blurry]]; qemu_mutex_lock(&ctx->bh_lock); bh->next = ctx->first_bh; smp_wmb(); ctx->first_bh = bh; qemu_mutex_unlock(&ctx->bh_lock); return bh; }
--------------------------------------------- Result 262 ---------------------------------------------
[[0 (84%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void audiogen(void *data, enum AVSampleFormat sample_fmt, int channels, int sample_rate, int nb_samples) { int i, ch, k; double v, f, a, ampa; double tabf1[SWR_CH_MAX]; double tabf2[SWR_CH_MAX]; double taba[SWR_CH_MAX]; unsigned static rnd; #define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v); #define uint_rand(x) (x = x * 1664525 + 1013904223) #define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1) k = 0; a = 0; for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) { v = sin(a) * 0.30; for (ch = 0; ch < channels; ch++) PUT_SAMPLE a += M_PI * 1000.0 * 2.0 / sample_rate; } a = 0; for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) { v = sin(a) * 0.30; for (ch = 0; ch < channels; ch++) PUT_SAMPLE f = 100.0 + (((10000.0 - 100.0) * i) / sample_rate); a += M_PI * f * 2.0 / sample_rate; } for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) { v = dbl_rand(rnd) * 0.30; for (ch = 0; ch < channels; ch++) PUT_SAMPLE } for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) { v = dbl_rand(rnd); for (ch = 0; ch < channels; ch++) PUT_SAMPLE } for (ch = 0; ch < channels; ch++) { taba[ch] = 0; tabf1[ch] = 100 + uint_rand(rnd) % 5000; tabf2[ch] = 100 + uint_rand(rnd) % 5000; } for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) { for (ch = 0; ch < channels; ch++) { v = sin(taba[ch]) * 0.30; PUT_SAMPLE f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * i) / sample_rate); taba[ch] += M_PI * f * 2.0 / sample_rate; } } a = 0; ampa = 0; for (i = 0; i < 2 * sample_rate && k < nb_samples; i++, k++) { for (ch = 0; ch < channels; ch++) { double amp = (1.0 + sin(ampa)) * 0.15; if (ch & 1) amp = 0.30 - amp; v = sin(a) * amp; PUT_SAMPLE a += M_PI * 500.0 * 2.0 / sample_rate; ampa += M_PI * 2.0 / sample_rate; } } }
--------------------------------------------- Result 263 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 152 / 11 / 100 / 263:  10%|         | 263/2690 [1:30:40<13:56:45, 20.69s/it][Succeeded / Failed / Skipped / Total] 152 / 11 / 100 / 263:  10%|         | 264/2690 [1:30:41<13:53:20, 20.61s/it][Succeeded / Failed / Skipped / Total] 152 / 11 / 101 / 264:  10%|         | 264/2690 [1:30:41<13:53:20, 20.61s/it][Succeeded / Failed / Skipped / Total] 152 / 11 / 101 / 264:  10%|         | 265/2690 [1:30:42<13:50:06, 20.54s/it][Succeeded / Failed / Skipped / Total] 153 / 11 / 101 / 265:  10%|         | 265/2690 [1:30:42<13:50:06, 20.54s/it][Succeeded / Failed / Skipped / Total] 153 / 11 / 101 / 265:  10%|         | 266/2690 [1:30:43<13:46:44, 20.46s/it][Succeeded / Failed / Skipped / Total] 153 / 11 / 102 / 266:  10%|         | 266/2690 [1:30:43<13:46:44, 20.46s/it][Succeeded / Failed / Skipped / Total] 153 / 11 / 102 / 266:  10%|         | 267/2690 [1:30:47<13:43:58, 20.40s/it][[0 (59%)]] --> [[0 (39%)]] --> Socre: 0.6143460869789124

[[[[Adv]]]]: static void paint_mouse_pointer(AVFormatContext *[[s1]], struct gdigrab *gdigrab) { CURSORINFO ci = {0}; #define CURSOR_ERROR(str) \ if (!gdigrab->cursor_error_printed) { \ WIN32_API_ERROR(str); \ gdigrab->cursor_error_printed = 1; \ } ci.cbSize = sizeof(ci); if (GetCursorInfo(&ci)) { HCURSOR icon = CopyCursor(ci.hCursor); ICONINFO info; POINT pos; RECT [[clip_rect]] = gdigrab->clip_rect; HWND hwnd = gdigrab->hwnd; info.hbmMask = NULL; info.hbmColor = NULL; if (ci.flags != CURSOR_SHOWING) return; if (!icon) { icon = CopyCursor(LoadCursor(NULL, IDC_ARROW)); } if (!GetIconInfo(icon, &info)) { CURSOR_ERROR("Could not get icon info"); goto icon_error; } pos.x = ci.ptScreenPos.x - [[clip_rect]].left - info.xHotspot; pos.y = ci.ptScreenPos.y - [[clip_rect]].top - info.yHotspot; if (hwnd) { RECT rect; if (GetWindowRect(hwnd, &rect)) { pos.x -= rect.left; pos.y -= rect.top; } else { CURSOR_ERROR("Couldn't get window rectangle"); goto icon_error; } } av_log([[s1]], AV_LOG_DEBUG, "Cursor pos (%li,%li) -> (%li,%li)\n", ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y); if (pos.x >= 0 && pos.x <= [[clip_rect]].right - [[clip_rect]].left && pos.y >= 0 && pos.y <= [[clip_rect]].bottom - [[clip_rect]].top) { if (!DrawIcon(gdigrab->dest_hdc, pos.x, pos.y, icon)) CURSOR_ERROR("Couldn't draw icon"); } icon_error: if (icon) DestroyCursor(icon); } else { CURSOR_ERROR("Couldn't get cursor info"); } }

[[[[Adv]]]]: static void paint_mouse_pointer(AVFormatContext *[[schemes]], struct gdigrab *gdigrab) { CURSORINFO ci = {0}; #define CURSOR_ERROR(str) \ if (!gdigrab->cursor_error_printed) { \ WIN32_API_ERROR(str); \ gdigrab->cursor_error_printed = 1; \ } ci.cbSize = sizeof(ci); if (GetCursorInfo(&ci)) { HCURSOR icon = CopyCursor(ci.hCursor); ICONINFO info; POINT pos; RECT [[qualifiers]] = gdigrab->clip_rect; HWND hwnd = gdigrab->hwnd; info.hbmMask = NULL; info.hbmColor = NULL; if (ci.flags != CURSOR_SHOWING) return; if (!icon) { icon = CopyCursor(LoadCursor(NULL, IDC_ARROW)); } if (!GetIconInfo(icon, &info)) { CURSOR_ERROR("Could not get icon info"); goto icon_error; } pos.x = ci.ptScreenPos.x - [[qualifiers]].left - info.xHotspot; pos.y = ci.ptScreenPos.y - [[qualifiers]].top - info.yHotspot; if (hwnd) { RECT rect; if (GetWindowRect(hwnd, &rect)) { pos.x -= rect.left; pos.y -= rect.top; } else { CURSOR_ERROR("Couldn't get window rectangle"); goto icon_error; } } av_log([[schemes]], AV_LOG_DEBUG, "Cursor pos (%li,%li) -> (%li,%li)\n", ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y); if (pos.x >= 0 && pos.x <= [[qualifiers]].right - [[qualifiers]].left && pos.y >= 0 && pos.y <= [[qualifiers]].bottom - [[qualifiers]].top) { if (!DrawIcon(gdigrab->dest_hdc, pos.x, pos.y, icon)) CURSOR_ERROR("Couldn't draw icon"); } icon_error: if (icon) DestroyCursor(icon); } else { CURSOR_ERROR("Couldn't get cursor info"); } }
--------------------------------------------- Result 264 ---------------------------------------------
[[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void machine_initfn(Object *obj) { MachineState *ms = MACHINE(obj); ms->kernel_irqchip_allowed = "True" == "True"; ms->kvm_shadow_mem = -1; ms->dump_guest_core = "True" == "True"; object_property_add_str(obj, "accel", machine_get_accel, machine_set_accel, NULL); object_property_set_description(obj, "accel", "Accelerator list", NULL); object_property_add_bool(obj, "kernel-irqchip", NULL, machine_set_kernel_irqchip, NULL); object_property_set_description(obj, "kernel-irqchip", "Use KVM in-kernel irqchip", NULL); object_property_add(obj, "kvm-shadow-mem", "int", machine_get_kvm_shadow_mem, machine_set_kvm_shadow_mem, NULL, NULL, NULL); object_property_set_description(obj, "kvm-shadow-mem", "KVM shadow MMU size", NULL); object_property_add_str(obj, "kernel", machine_get_kernel, machine_set_kernel, NULL); object_property_set_description(obj, "kernel", "Linux kernel image file", NULL); object_property_add_str(obj, "initrd", machine_get_initrd, machine_set_initrd, NULL); object_property_set_description(obj, "initrd", "Linux initial ramdisk file", NULL); object_property_add_str(obj, "append", machine_get_append, machine_set_append, NULL); object_property_set_description(obj, "append", "Linux kernel command line", NULL); object_property_add_str(obj, "dtb", machine_get_dtb, machine_set_dtb, NULL); object_property_set_description(obj, "dtb", "Linux kernel device tree file", NULL); object_property_add_str(obj, "dumpdtb", machine_get_dumpdtb, machine_set_dumpdtb, NULL); object_property_set_description(obj, "dumpdtb", "Dump current dtb to a file and quit", NULL); object_property_add(obj, "phandle-start", "int", machine_get_phandle_start, machine_set_phandle_start, NULL, NULL, NULL); object_property_set_description(obj, "phandle-start", "The first phandle ID we may generate dynamically", NULL); object_property_add_str(obj, "dt-compatible", machine_get_dt_compatible, machine_set_dt_compatible, NULL); object_property_set_description(obj, "dt-compatible", "Overrides the \"compatible\" property of the dt root node", NULL); object_property_add_bool(obj, "dump-guest-core", machine_get_dump_guest_core, machine_set_dump_guest_core, NULL); object_property_set_description(obj, "dump-guest-core", "Include guest memory in a core dump", NULL); object_property_add_bool(obj, "mem-merge", machine_get_mem_merge, machine_set_mem_merge, NULL); object_property_set_description(obj, "mem-merge", "Enable/disable memory merge support", NULL); object_property_add_bool(obj, "usb", machine_get_usb, machine_set_usb, NULL); object_property_set_description(obj, "usb", "Set on/off to enable/disable usb", NULL); object_property_add_str(obj, "firmware", machine_get_firmware, machine_set_firmware, NULL); object_property_set_description(obj, "firmware", "Firmware image", NULL); object_property_add_bool(obj, "iommu", machine_get_iommu, machine_set_iommu, NULL); object_property_set_description(obj, "iommu", "Set on/off to enable/disable Intel IOMMU (VT-d)", NULL); ms->sysbus_notifier.notify = machine_init_notify; qemu_add_machine_init_done_notifier(&ms->sysbus_notifier); }
--------------------------------------------- Result 265 ---------------------------------------------
[[0 (52%)]] --> [[0 (48%)]] --> Socre: 0.5225620269775391

[[[[Adv]]]]: void bdrv_delete(BlockDriverState *[[bs]]) { assert(![[bs]]->peer); if ([[bs]]->device_name[0] != '\0') { QTAILQ_REMOVE(&bdrv_states, [[bs]], list); } bdrv_close([[bs]]); if ([[bs]]->file != NULL) { bdrv_delete([[bs]]->file); } assert([[bs]] != bs_snapshots); qemu_free([[bs]]); }

[[[[Adv]]]]: void bdrv_delete(BlockDriverState *[[jsu]]) { assert(![[jsu]]->peer); if ([[jsu]]->device_name[0] != '\0') { QTAILQ_REMOVE(&bdrv_states, [[jsu]], list); } bdrv_close([[jsu]]); if ([[jsu]]->file != NULL) { bdrv_delete([[jsu]]->file); } assert([[jsu]] != bs_snapshots); qemu_free([[jsu]]); }
--------------------------------------------- Result 266 ---------------------------------------------
[[0 (28%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void hmp_migrate_status_cb(void *opaque) { MigrationStatus *status = opaque; MigrationInfo *info; info = qmp_query_migrate(NULL); if (!info->has_status || strcmp(info->status, "active") == 0) { if (info->has_disk) { int progress; if (info->disk->remaining) { progress = info->disk->transferred * 100 / info->disk->total; } else { progress = 100; } monitor_printf(status->mon, "Completed %d %%\r", progress); monitor_flush(status->mon); } timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000); } else { if (status->is_block_migration) { monitor_printf(status->mon, "\n"); } monitor_resume(status->mon); timer_del(status->timer); g_free(status); } qapi_free_MigrationInfo(info); }
--------------------------------------------- Result 267 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 154 / 11 / 102 / 267:  10%|         | 267/2690 [1:30:47<13:43:58, 20.40s/it][Succeeded / Failed / Skipped / Total] 154 / 11 / 102 / 267:  10%|         | 268/2690 [1:30:48<13:40:38, 20.33s/it][Succeeded / Failed / Skipped / Total] 154 / 11 / 103 / 268:  10%|         | 268/2690 [1:30:48<13:40:38, 20.33s/it][Succeeded / Failed / Skipped / Total] 154 / 11 / 103 / 268:  10%|         | 269/2690 [1:30:48<13:37:20, 20.26s/it][Succeeded / Failed / Skipped / Total] 154 / 11 / 104 / 269:  10%|         | 269/2690 [1:30:48<13:37:20, 20.26s/it][Succeeded / Failed / Skipped / Total] 154 / 11 / 104 / 269:  10%|         | 270/2690 [1:30:50<13:34:15, 20.19s/it][Succeeded / Failed / Skipped / Total] 155 / 11 / 104 / 270:  10%|         | 270/2690 [1:30:50<13:34:15, 20.19s/it][Succeeded / Failed / Skipped / Total] 155 / 11 / 104 / 270:  10%|         | 271/2690 [1:30:58<13:32:06, 20.14s/it][Succeeded / Failed / Skipped / Total] 156 / 11 / 104 / 271:  10%|         | 271/2690 [1:30:58<13:32:06, 20.14s/it][Succeeded / Failed / Skipped / Total] 156 / 11 / 104 / 271:  10%|         | 272/2690 [1:32:03<13:38:21, 20.31s/it][Succeeded / Failed / Skipped / Total] 157 / 11 / 104 / 272:  10%|         | 272/2690 [1:32:03<13:38:21, 20.31s/it][Succeeded / Failed / Skipped / Total] 157 / 11 / 104 / 272:  10%|         | 273/2690 [1:32:23<13:38:03, 20.31s/it][[0 (1%)]] --> [[0 (61%)]] --> Socre: 0.60822594165802

[[[[Adv]]]]: static inline void gen_op_mov_v_reg(int ot, TCGv [[t0]], int reg) { switch(ot) { case OT_BYTE: if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) { goto std_case; } else { tcg_gen_shri_tl([[t0]], cpu_regs[reg - 4], 8); tcg_gen_ext8u_tl([[t0]], [[t0]]); } break; default: std_case: tcg_gen_mov_tl([[t0]], cpu_regs[reg]); break; } }

[[[[Adv]]]]: static inline void gen_op_mov_v_reg(int ot, TCGv [[triumphs]], int reg) { switch(ot) { case OT_BYTE: if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) { goto std_case; } else { tcg_gen_shri_tl([[triumphs]], cpu_regs[reg - 4], 8); tcg_gen_ext8u_tl([[triumphs]], [[triumphs]]); } break; default: std_case: tcg_gen_mov_tl([[triumphs]], cpu_regs[reg]); break; } }
--------------------------------------------- Result 268 ---------------------------------------------
[[0 (38%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: coroutine_fn iscsi_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes) { IscsiLun *iscsilun = bs->opaque; struct IscsiTask iTask; struct unmap_list list; int r = 0; if (!is_byte_request_lun_aligned(offset, bytes, iscsilun)) { return -ENOTSUP; } if (!iscsilun->lbp.lbpu) { return 0; } list.lba = offset / iscsilun->block_size; list.num = bytes / iscsilun->block_size; iscsi_co_init_iscsitask(iscsilun, &iTask); qemu_mutex_lock(&iscsilun->mutex); retry: if (iscsi_unmap_task(iscsilun->iscsi, iscsilun->lun, 0, 0, &list, 1, iscsi_co_generic_cb, &iTask) == NULL) { r = -ENOMEM; goto out_unlock; } while (!iTask.complete) { iscsi_set_events(iscsilun); qemu_mutex_unlock(&iscsilun->mutex); qemu_coroutine_yield(); qemu_mutex_lock(&iscsilun->mutex); } if (iTask.task != NULL) { scsi_free_scsi_task(iTask.task); iTask.task = NULL; } if (iTask.do_retry) { iTask.complete = 0; goto retry; } if (iTask.status == SCSI_STATUS_CHECK_CONDITION) { goto out_unlock; } if (iTask.status != SCSI_STATUS_GOOD) { r = iTask.err_code; goto out_unlock; } iscsi_allocmap_set_invalid(iscsilun, offset >> BDRV_SECTOR_BITS, bytes >> BDRV_SECTOR_BITS); out_unlock: qemu_mutex_unlock(&iscsilun->mutex); return r; }
--------------------------------------------- Result 269 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int mips_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw, int mmu_idx) { MIPSCPU *cpu = MIPS_CPU(cs); CPUMIPSState *env = &cpu->env; #if !defined(CONFIG_USER_ONLY) hwaddr physical; int prot; int access_type; #endif int ret = 0; #if 0 log_cpu_state(cs, 0); #endif qemu_log_mask(CPU_LOG_MMU, "%s pc " TARGET_FMT_lx " ad %" VADDR_PRIx " rw %d mmu_idx %d\n", __func__, env->active_tc.PC, address, rw, mmu_idx); #if !defined(CONFIG_USER_ONLY) access_type = ACCESS_INT; ret = get_physical_address(env, &physical, &prot, address, rw, access_type); qemu_log_mask(CPU_LOG_MMU, "%s address=%" VADDR_PRIx " ret %d physical " TARGET_FMT_plx " prot %d\n", __func__, address, ret, physical, prot); if (ret == TLBRET_MATCH) { tlb_set_page(cs, address & TARGET_PAGE_MASK, physical & TARGET_PAGE_MASK, prot | PAGE_EXEC, mmu_idx, TARGET_PAGE_SIZE); ret = 0; } else if (ret < 0) #endif { raise_mmu_exception(env, address, rw, ret); ret = 1; } return ret; }
--------------------------------------------- Result 270 ---------------------------------------------
[[0 (15%)]] --> [[0 (55%)]] --> Socre: 0.5457162857055664

[[[[Adv]]]]: static ModuleTypeList *find_type(module_init_type [[type]]) { ModuleTypeList *l; init_types(); l = &init_type_list[[[type]]]; return l; }

[[[[Adv]]]]: static ModuleTypeList *find_type(module_init_type [[guys]]) { ModuleTypeList *l; init_types(); l = &init_type_list[[[guys]]]; return l; }
--------------------------------------------- Result 271 ---------------------------------------------
[[0 (32%)]] --> [[0 (70%)]] --> Socre: 0.6972346901893616

[[[[Adv]]]]: static int qemu_suspend_requested(void) { int [[r]] = suspend_requested; suspend_requested = 0; return [[r]]; }

[[[[Adv]]]]: static int qemu_suspend_requested(void) { int [[w]] = suspend_requested; suspend_requested = 0; return [[w]]; }
--------------------------------------------- Result 272 ---------------------------------------------
[[0 (9%)]] --> [[0 (53%)]] --> Socre: 0.5266802310943604

[[[[Adv]]]]: int kvm_arch_on_sigbus(int code, void *addr) { #ifdef KVM_CAP_MCE if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) { void *vaddr; ram_addr_t ram_addr; target_phys_addr_t [[paddr]]; vaddr = addr; if (qemu_ram_addr_from_host(vaddr, &ram_addr) || !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr, &[[paddr]])) { fprintf(stderr, "Hardware memory error for memory used by " "QEMU itself instead of guest system!: %p\n", addr); return 0; } kvm_mce_inj_srao_memscrub2(first_cpu, [[paddr]]); } else #endif { if (code == BUS_MCEERR_AO) { return 0; } else if (code == BUS_MCEERR_AR) { hardware_memory_error(); } else { return 1; } } return 0; }

[[[[Adv]]]]: int kvm_arch_on_sigbus(int code, void *addr) { #ifdef KVM_CAP_MCE if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) { void *vaddr; ram_addr_t ram_addr; target_phys_addr_t [[compressor]]; vaddr = addr; if (qemu_ram_addr_from_host(vaddr, &ram_addr) || !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr, &[[compressor]])) { fprintf(stderr, "Hardware memory error for memory used by " "QEMU itself instead of guest system!: %p\n", addr); return 0; } kvm_mce_inj_srao_memscrub2(first_cpu, [[compressor]]); } else #endif { if (code == BUS_MCEERR_AO) { return 0; } else if (code == BUS_MCEERR_AR) { hardware_memory_error(); } else { return 1; } } return 0; }
--------------------------------------------- Result 273 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 158 / 11 / 104 / 273:  10%|         | 273/2690 [1:32:23<13:38:03, 20.31s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 104 / 273:  10%|         | 274/2690 [1:32:24<13:34:48, 20.24s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 105 / 274:  10%|         | 274/2690 [1:32:24<13:34:48, 20.24s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 105 / 274:  10%|         | 275/2690 [1:32:24<13:31:34, 20.16s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 106 / 275:  10%|         | 275/2690 [1:32:24<13:31:34, 20.16s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 106 / 275:  10%|         | 276/2690 [1:32:25<13:28:22, 20.09s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 107 / 276:  10%|         | 276/2690 [1:32:25<13:28:22, 20.09s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 107 / 276:  10%|         | 277/2690 [1:32:25<13:25:11, 20.02s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 108 / 277:  10%|         | 277/2690 [1:32:25<13:25:11, 20.02s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 108 / 277:  10%|         | 278/2690 [1:32:26<13:22:02, 19.95s/it][[0 (13%)]] --> [[0 (56%)]] --> Socre: 0.5561886429786682

[[[[Adv]]]]: int opt_cpuflags(const char *[[opt]], const char *arg) { #define CPUFLAG_MMX2 (AV_CPU_FLAG_MMX | AV_CPU_FLAG_MMX2) #define CPUFLAG_3DNOW (AV_CPU_FLAG_3DNOW | AV_CPU_FLAG_MMX) #define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW) #define CPUFLAG_SSE (AV_CPU_FLAG_SSE | CPUFLAG_MMX2) #define CPUFLAG_SSE2 (AV_CPU_FLAG_SSE2 | CPUFLAG_SSE) #define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2) #define CPUFLAG_SSE3 (AV_CPU_FLAG_SSE3 | CPUFLAG_SSE2) #define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3) #define CPUFLAG_SSSE3 (AV_CPU_FLAG_SSSE3 | CPUFLAG_SSE3) #define CPUFLAG_SSE4 (AV_CPU_FLAG_SSE4 | CPUFLAG_SSSE3) #define CPUFLAG_SSE42 (AV_CPU_FLAG_SSE42 | CPUFLAG_SSE4) #define CPUFLAG_AVX (AV_CPU_FLAG_AVX | CPUFLAG_SSE42) #define CPUFLAG_XOP (AV_CPU_FLAG_XOP | CPUFLAG_AVX) #define CPUFLAG_FMA4 (AV_CPU_FLAG_FMA4 | CPUFLAG_AVX) static const AVOption [[cpuflags_opts]][] = { { "flags" , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = "flags" }, { "altivec" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC }, .unit = "flags" }, { "mmx" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX }, .unit = "flags" }, { "mmx2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2 }, .unit = "flags" }, { "sse" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE }, .unit = "flags" }, { "sse2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2 }, .unit = "flags" }, { "sse2slow", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW }, .unit = "flags" }, { "sse3" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3 }, .unit = "flags" }, { "sse3slow", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW }, .unit = "flags" }, { "ssse3" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3 }, .unit = "flags" }, { "atom" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM }, .unit = "flags" }, { "sse4.1" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4 }, .unit = "flags" }, { "sse4.2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42 }, .unit = "flags" }, { "avx" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX }, .unit = "flags" }, { "xop" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP }, .unit = "flags" }, { "fma4" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4 }, .unit = "flags" }, { "3dnow" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW }, .unit = "flags" }, { "3dnowext", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT }, .unit = "flags" }, { NULL }, }; static const AVClass class = { .class_name = "cpuflags", .item_name = av_default_item_name, .option = [[cpuflags_opts]], .version = LIBAVUTIL_VERSION_INT, }; int flags = av_get_cpu_flags(); int ret; const AVClass *pclass = &class; if ((ret = av_opt_eval_flags(&pclass, &[[cpuflags_opts]][0], arg, &flags)) < 0) return ret; av_force_cpu_flags(flags); return 0; }

[[[[Adv]]]]: int opt_cpuflags(const char *[[wahl]], const char *arg) { #define CPUFLAG_MMX2 (AV_CPU_FLAG_MMX | AV_CPU_FLAG_MMX2) #define CPUFLAG_3DNOW (AV_CPU_FLAG_3DNOW | AV_CPU_FLAG_MMX) #define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW) #define CPUFLAG_SSE (AV_CPU_FLAG_SSE | CPUFLAG_MMX2) #define CPUFLAG_SSE2 (AV_CPU_FLAG_SSE2 | CPUFLAG_SSE) #define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2) #define CPUFLAG_SSE3 (AV_CPU_FLAG_SSE3 | CPUFLAG_SSE2) #define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3) #define CPUFLAG_SSSE3 (AV_CPU_FLAG_SSSE3 | CPUFLAG_SSE3) #define CPUFLAG_SSE4 (AV_CPU_FLAG_SSE4 | CPUFLAG_SSSE3) #define CPUFLAG_SSE42 (AV_CPU_FLAG_SSE42 | CPUFLAG_SSE4) #define CPUFLAG_AVX (AV_CPU_FLAG_AVX | CPUFLAG_SSE42) #define CPUFLAG_XOP (AV_CPU_FLAG_XOP | CPUFLAG_AVX) #define CPUFLAG_FMA4 (AV_CPU_FLAG_FMA4 | CPUFLAG_AVX) static const AVOption [[dialectic]][] = { { "flags" , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = "flags" }, { "altivec" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC }, .unit = "flags" }, { "mmx" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX }, .unit = "flags" }, { "mmx2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2 }, .unit = "flags" }, { "sse" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE }, .unit = "flags" }, { "sse2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2 }, .unit = "flags" }, { "sse2slow", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW }, .unit = "flags" }, { "sse3" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3 }, .unit = "flags" }, { "sse3slow", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW }, .unit = "flags" }, { "ssse3" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3 }, .unit = "flags" }, { "atom" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM }, .unit = "flags" }, { "sse4.1" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4 }, .unit = "flags" }, { "sse4.2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42 }, .unit = "flags" }, { "avx" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX }, .unit = "flags" }, { "xop" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP }, .unit = "flags" }, { "fma4" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4 }, .unit = "flags" }, { "3dnow" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW }, .unit = "flags" }, { "3dnowext", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT }, .unit = "flags" }, { NULL }, }; static const AVClass class = { .class_name = "cpuflags", .item_name = av_default_item_name, .option = [[dialectic]], .version = LIBAVUTIL_VERSION_INT, }; int flags = av_get_cpu_flags(); int ret; const AVClass *pclass = &class; if ((ret = av_opt_eval_flags(&pclass, &[[dialectic]][0], arg, &flags)) < 0) return ret; av_force_cpu_flags(flags); return 0; }
--------------------------------------------- Result 274 ---------------------------------------------
[[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void serial_tx_done(void *opaque) { SerialState *s = opaque; if (s->tx_burst < 0) { uint16_t divider; if (s->divider) divider = s->divider; else divider = 1; s->tx_burst = THROTTLE_TX_INTERVAL * 1000 / (1000000 * 10 / (s->baudbase / divider)); } s->thr_ipending = 1; s->lsr |= UART_LSR_THRE; s->lsr |= UART_LSR_TEMT; serial_update_irq(s); }
--------------------------------------------- Result 275 ---------------------------------------------
[[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd) { QXLDevSurfaceCreate surface; memset(&surface, 0, sizeof(surface)); dprint(1, "%s/%d: %dx%d\n", __func__, ssd->qxl.id, surface_width(ssd->ds), surface_height(ssd->ds)); surface.format = SPICE_SURFACE_FMT_32_xRGB; surface.width = surface_width(ssd->ds); surface.height = surface_height(ssd->ds); surface.stride = -surface.width * 4; surface.mouse_mode = "True" == "True"; surface.flags = 0; surface.type = 0; surface.mem = (uintptr_t)ssd->buf; surface.group_id = MEMSLOT_GROUP_HOST; qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC); }
--------------------------------------------- Result 276 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void init_proc_750fx (CPUPPCState *env) { gen_spr_ne_601(env); gen_spr_7xx(env); spr_register(env, SPR_L2CR, "L2CR", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, NULL, 0x00000000); gen_tbl(env); gen_spr_thrm(env); spr_register(env, SPR_750_THRM4, "THRM4", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_HID0, "HID0", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_HID1, "HID1", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_750FX_HID2, "HID2", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); gen_low_BATs(env); gen_high_BATs(env); init_excp_7x0(env); env->dcache_line_size = 32; env->icache_line_size = 32; ppc6xx_irq_init(env); }
--------------------------------------------- Result 277 ---------------------------------------------
[[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...)) { stream_printf(stream, "Trace file \"%s\" %s.\n", trace_file_name, trace_file_enabled ? "on" : "off"); }
--------------------------------------------- Result 278 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 158 / 11 / 109 / 278:  10%|         | 278/2690 [1:32:26<13:22:02, 19.95s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 109 / 278:  10%|         | 279/2690 [1:32:26<13:18:54, 19.88s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 110 / 279:  10%|         | 279/2690 [1:32:26<13:18:54, 19.88s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 110 / 279:  10%|         | 280/2690 [1:32:27<13:15:47, 19.81s/it][[0 (59%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mkv_write_header(AVFormatContext *s) { MatroskaMuxContext *mkv = s->priv_data; AVIOContext *pb = s->pb; ebml_master ebml_header; AVDictionaryEntry *tag; int ret, i, version = 2; int64_t creation_time; if (!strcmp(s->oformat->name, "webm")) mkv->mode = MODE_WEBM; else mkv->mode = MODE_MATROSKAv2; if (mkv->mode != MODE_WEBM || av_dict_get(s->metadata, "stereo_mode", NULL, 0) || av_dict_get(s->metadata, "alpha_mode", NULL, 0)) version = 4; if (s->nb_streams > MAX_TRACKS) { av_log(s, AV_LOG_ERROR, "At most %d streams are supported for muxing in Matroska\n", MAX_TRACKS); return AVERROR(EINVAL); } for (i = 0; i < s->nb_streams; i++) { if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) { av_log(s, AV_LOG_ERROR, "The Matroska muxer does not yet support muxing %s\n", avcodec_get_name(s->streams[i]->codecpar->codec_id)); return AVERROR_PATCHWELCOME; } if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS || av_dict_get(s->streams[i]->metadata, "stereo_mode", NULL, 0) || av_dict_get(s->streams[i]->metadata, "alpha_mode", NULL, 0)) version = 4; } mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks)); if (!mkv->tracks) { ret = AVERROR(ENOMEM); goto fail; } ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0); put_ebml_uint (pb, EBML_ID_EBMLVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLREADVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLMAXIDLENGTH , 4); put_ebml_uint (pb, EBML_ID_EBMLMAXSIZELENGTH , 8); put_ebml_string (pb, EBML_ID_DOCTYPE , s->oformat->name); put_ebml_uint (pb, EBML_ID_DOCTYPEVERSION , version); put_ebml_uint (pb, EBML_ID_DOCTYPEREADVERSION , 2); end_ebml_master(pb, ebml_header); mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0); mkv->segment_offset = avio_tell(pb); mkv->main_seekhead = mkv_start_seekhead(pb, mkv->segment_offset, 10); if (!mkv->main_seekhead) { ret = AVERROR(ENOMEM); goto fail; } ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb)); if (ret < 0) goto fail; ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0); if (ret < 0) return ret; pb = mkv->info_bc; put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000); if ((tag = av_dict_get(s->metadata, "title", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value); if (!(s->flags & AVFMT_FLAG_BITEXACT)) { put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT); if ((tag = av_dict_get(s->metadata, "encoding_tool", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value); else put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT); if (mkv->mode != MODE_WEBM) { uint32_t segment_uid[4]; AVLFG lfg; av_lfg_init(&lfg, av_get_random_seed()); for (i = 0; i < 4; i++) segment_uid[i] = av_lfg_get(&lfg); put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16); } } else { const char *ident = "Lavf"; put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident); put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident); } if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) { int64_t date_utc = (creation_time - 978307200000000LL) * 1000; uint8_t date_utc_buf[8]; AV_WB64(date_utc_buf, date_utc); put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8); } mkv->duration = 0; mkv->duration_offset = avio_tell(pb); if (!mkv->is_live) { int64_t metadata_duration = get_metadata_duration(s); if (s->duration > 0) { int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE); put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration); av_log(s, AV_LOG_DEBUG, "Write early duration from recording time = %" PRIu64 "\n", scaledDuration); } else if (metadata_duration > 0) { int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE); put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration); av_log(s, AV_LOG_DEBUG, "Write early duration from metadata = %" PRIu64 "\n", scaledDuration); } else { put_ebml_void(pb, 11); } } if ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live) end_ebml_master_crc32_preliminary(s->pb, &mkv->info_bc, mkv, mkv->info); else end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info); pb = s->pb; mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t)); mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t)); ret = mkv_write_tracks(s); if (ret < 0) goto fail; for (i = 0; i < s->nb_chapters; i++) mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id); ret = mkv_write_chapters(s); if (ret < 0) goto fail; if (mkv->mode != MODE_WEBM) { ret = mkv_write_attachments(s); if (ret < 0) goto fail; } ret = mkv_write_tags(s); if (ret < 0) goto fail; if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live) mkv_write_seekhead(pb, mkv); mkv->cues = mkv_start_cues(mkv->segment_offset); if (!mkv->cues) { ret = AVERROR(ENOMEM); goto fail; } if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && mkv->reserve_cues_space) { mkv->cues_pos = avio_tell(pb); put_ebml_void(pb, mkv->reserve_cues_space); } av_init_packet(&mkv->cur_audio_pkt); mkv->cur_audio_pkt.size = 0; mkv->cluster_pos = -1; avio_flush(pb); if (pb->seekable & AVIO_SEEKABLE_NORMAL) { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 5000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 5 * 1024 * 1024; } else { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 1000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 32 * 1024; } return 0; fail: mkv_free(mkv); return ret; }
--------------------------------------------- Result 279 ---------------------------------------------
[[0 (8%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: e1000_can_receive(void *opaque) { E1000State *s = opaque; return (!(s->mac_reg[RCTL] & E1000_RCTL_EN) || s->mac_reg[RDH] != s->mac_reg[RDT]); }
--------------------------------------------- Result 280 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 158 / 11 / 111 / 280:  10%|         | 280/2690 [1:32:27<13:15:47, 19.81s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 111 / 280:  10%|         | 281/2690 [1:32:27<13:12:42, 19.74s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 112 / 281:  10%|         | 281/2690 [1:32:27<13:12:42, 19.74s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 112 / 281:  10%|         | 282/2690 [1:32:33<13:10:21, 19.69s/it][[0 (77%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: av_cold void ff_sws_init_swScale_mmx(SwsContext *c) { int cpu_flags = av_get_cpu_flags(); #if HAVE_INLINE_ASM if (cpu_flags & AV_CPU_FLAG_MMX) sws_init_swScale_MMX(c); #if HAVE_MMXEXT_INLINE if (cpu_flags & AV_CPU_FLAG_MMXEXT) sws_init_swScale_MMX2(c); #endif #endif #if HAVE_YASM #define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \ if (c->srcBpc == 8) { \ hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \ ff_hscale8to19_ ## filtersize ## _ ## opt1; \ } else if (c->srcBpc == 9) { \ hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \ ff_hscale9to19_ ## filtersize ## _ ## opt1; \ } else if (c->srcBpc == 10) { \ hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \ ff_hscale10to19_ ## filtersize ## _ ## opt1; \ } else { \ hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \ ff_hscale16to19_ ## filtersize ## _ ## opt1; \ } \ } while (0) #define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \ switch (filtersize) { \ case 4: ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \ case 8: ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \ default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \ } #define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \ switch(c->dstBpc){ \ case 16: do_16_case; break; \ case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \ case 9: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_ ## opt; break; \ default: if (condition_8bit) vscalefn = ff_yuv2planeX_8_ ## opt; break; \ } #define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \ switch(c->dstBpc){ \ case 16: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2plane1_16_ ## opt1; break; \ case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \ case 9: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_ ## opt2; break; \ default: vscalefn = ff_yuv2plane1_8_ ## opt1; break; \ } #define case_rgb(x, X, opt) \ case PIX_FMT_ ## X: \ c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \ if (!c->chrSrcHSubSample) \ c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \ break #if ARCH_X86_32 if (cpu_flags & AV_CPU_FLAG_MMX) { ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx); ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx); ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT); switch (c->srcFormat) { case PIX_FMT_Y400A: c->lumToYV12 = ff_yuyvToY_mmx; if (c->alpPixBuf) c->alpToYV12 = ff_uyvyToY_mmx; break; case PIX_FMT_YUYV422: c->lumToYV12 = ff_yuyvToY_mmx; c->chrToYV12 = ff_yuyvToUV_mmx; break; case PIX_FMT_UYVY422: c->lumToYV12 = ff_uyvyToY_mmx; c->chrToYV12 = ff_uyvyToUV_mmx; break; case PIX_FMT_NV12: c->chrToYV12 = ff_nv12ToUV_mmx; break; case PIX_FMT_NV21: c->chrToYV12 = ff_nv21ToUV_mmx; break; case_rgb(rgb24, RGB24, mmx); case_rgb(bgr24, BGR24, mmx); case_rgb(bgra, BGRA, mmx); case_rgb(rgba, RGBA, mmx); case_rgb(abgr, ABGR, mmx); case_rgb(argb, ARGB, mmx); default: break; } } if (cpu_flags & AV_CPU_FLAG_MMXEXT) { ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmx2, , 1); } #endif #define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \ switch (filtersize) { \ case 4: ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \ case 8: ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \ default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \ else ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \ break; \ } if (cpu_flags & AV_CPU_FLAG_SSE2) { ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2); ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2); ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, , HAVE_ALIGNED_STACK || ARCH_X86_64); ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1); switch (c->srcFormat) { case PIX_FMT_Y400A: c->lumToYV12 = ff_yuyvToY_sse2; if (c->alpPixBuf) c->alpToYV12 = ff_uyvyToY_sse2; break; case PIX_FMT_YUYV422: c->lumToYV12 = ff_yuyvToY_sse2; c->chrToYV12 = ff_yuyvToUV_sse2; break; case PIX_FMT_UYVY422: c->lumToYV12 = ff_uyvyToY_sse2; c->chrToYV12 = ff_uyvyToUV_sse2; break; case PIX_FMT_NV12: c->chrToYV12 = ff_nv12ToUV_sse2; break; case PIX_FMT_NV21: c->chrToYV12 = ff_nv21ToUV_sse2; break; case_rgb(rgb24, RGB24, sse2); case_rgb(bgr24, BGR24, sse2); case_rgb(bgra, BGRA, sse2); case_rgb(rgba, RGBA, sse2); case_rgb(abgr, ABGR, sse2); case_rgb(argb, ARGB, sse2); default: break; } } if (cpu_flags & AV_CPU_FLAG_SSSE3) { ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3); ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3); switch (c->srcFormat) { case_rgb(rgb24, RGB24, ssse3); case_rgb(bgr24, BGR24, ssse3); default: break; } } if (cpu_flags & AV_CPU_FLAG_SSE4) { ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3); ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3); ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4, if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4, HAVE_ALIGNED_STACK || ARCH_X86_64); if (c->dstBpc == 16 && !isBE(c->dstFormat)) c->yuv2plane1 = ff_yuv2plane1_16_sse4; } if (cpu_flags & AV_CPU_FLAG_AVX) { ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, , HAVE_ALIGNED_STACK || ARCH_X86_64); ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1); switch (c->srcFormat) { case PIX_FMT_YUYV422: c->chrToYV12 = ff_yuyvToUV_avx; break; case PIX_FMT_UYVY422: c->chrToYV12 = ff_uyvyToUV_avx; break; case PIX_FMT_NV12: c->chrToYV12 = ff_nv12ToUV_avx; break; case PIX_FMT_NV21: c->chrToYV12 = ff_nv21ToUV_avx; break; case_rgb(rgb24, RGB24, avx); case_rgb(bgr24, BGR24, avx); case_rgb(bgra, BGRA, avx); case_rgb(rgba, RGBA, avx); case_rgb(abgr, ABGR, avx); case_rgb(argb, ARGB, avx); default: break; } } #endif }
--------------------------------------------- Result 281 ---------------------------------------------
[[0 (8%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static unsigned tget(const uint8_t **p, int type, int le) { switch (type) { case TIFF_BYTE: return *(*p)++; case TIFF_SHORT: return tget_short(p, le); case TIFF_LONG: return tget_long(p, le); default: return UINT_MAX; } }
--------------------------------------------- Result 282 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 159 / 11 / 112 / 282:  10%|         | 282/2690 [1:32:33<13:10:21, 19.69s/it][Succeeded / Failed / Skipped / Total] 159 / 11 / 112 / 282:  11%|         | 283/2690 [1:32:34<13:07:18, 19.63s/it][Succeeded / Failed / Skipped / Total] 159 / 11 / 113 / 283:  11%|         | 283/2690 [1:32:34<13:07:18, 19.63s/it][Succeeded / Failed / Skipped / Total] 159 / 11 / 113 / 283:  11%|         | 284/2690 [1:32:51<13:06:39, 19.62s/it][Succeeded / Failed / Skipped / Total] 160 / 11 / 113 / 284:  11%|         | 284/2690 [1:32:51<13:06:39, 19.62s/it][Succeeded / Failed / Skipped / Total] 160 / 11 / 113 / 284:  11%|         | 285/2690 [1:32:51<13:03:38, 19.55s/it][Succeeded / Failed / Skipped / Total] 160 / 11 / 114 / 285:  11%|         | 285/2690 [1:32:51<13:03:38, 19.55s/it][Succeeded / Failed / Skipped / Total] 160 / 11 / 114 / 285:  11%|         | 286/2690 [1:32:57<13:01:24, 19.50s/it][Succeeded / Failed / Skipped / Total] 161 / 11 / 114 / 286:  11%|         | 286/2690 [1:32:57<13:01:24, 19.50s/it][Succeeded / Failed / Skipped / Total] 161 / 11 / 114 / 286:  11%|         | 287/2690 [1:32:58<12:58:26, 19.44s/it][Succeeded / Failed / Skipped / Total] 161 / 11 / 115 / 287:  11%|         | 287/2690 [1:32:58<12:58:26, 19.44s/it][Succeeded / Failed / Skipped / Total] 161 / 11 / 115 / 287:  11%|         | 288/2690 [1:32:58<12:55:28, 19.37s/it][[0 (59%)]] --> [[0 (50%)]] --> Socre: 0.5008633732795715

[[[[Adv]]]]: static int decode_hq_slice(AVCodecContext *avctx, void *arg) { int i, quant, level, orientation, quant_idx; uint8_t quants[MAX_DWT_LEVELS][4]; DiracContext *[[s]] = avctx->priv_data; DiracSlice *slice = arg; GetBitContext *gb = &slice->gb; skip_bits_long(gb, 8*[[s]]->highquality.prefix_bytes); quant_idx = get_bits(gb, 8); for (level = 0; level < [[s]]->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { quant = FFMAX(quant_idx - [[s]]->lowdelay.quant[level][orientation], 0); quants[level][orientation] = quant; } } for (i = 0; i < 3; i++) { int64_t length = [[s]]->highquality.size_scaler * get_bits(gb, 8); int64_t bits_left = 8 * length; int64_t [[bits_end]] = get_bits_count(gb) + bits_left; if ([[bits_end]] >= INT_MAX) { av_log([[s]]->avctx, AV_LOG_ERROR, "end too far away\n"); return AVERROR_INVALIDDATA; } for (level = 0; level < [[s]]->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { decode_subband([[s]], gb, quants[level][orientation], slice->slice_x, slice->slice_y, [[bits_end]], &[[s]]->plane[i].band[level][orientation], NULL); } } skip_bits_long(gb, [[bits_end]] - get_bits_count(gb)); } return 0; }

[[[[Adv]]]]: static int decode_hq_slice(AVCodecContext *avctx, void *arg) { int i, quant, level, orientation, quant_idx; uint8_t quants[MAX_DWT_LEVELS][4]; DiracContext *[[p]] = avctx->priv_data; DiracSlice *slice = arg; GetBitContext *gb = &slice->gb; skip_bits_long(gb, 8*[[p]]->highquality.prefix_bytes); quant_idx = get_bits(gb, 8); for (level = 0; level < [[p]]->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { quant = FFMAX(quant_idx - [[p]]->lowdelay.quant[level][orientation], 0); quants[level][orientation] = quant; } } for (i = 0; i < 3; i++) { int64_t length = [[p]]->highquality.size_scaler * get_bits(gb, 8); int64_t bits_left = 8 * length; int64_t [[heike]] = get_bits_count(gb) + bits_left; if ([[heike]] >= INT_MAX) { av_log([[p]]->avctx, AV_LOG_ERROR, "end too far away\n"); return AVERROR_INVALIDDATA; } for (level = 0; level < [[p]]->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { decode_subband([[p]], gb, quants[level][orientation], slice->slice_x, slice->slice_y, [[heike]], &[[p]]->plane[i].band[level][orientation], NULL); } } skip_bits_long(gb, [[heike]] - get_bits_count(gb)); } return 0; }
--------------------------------------------- Result 283 ---------------------------------------------
[[0 (6%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int amr_wb_encode_init(AVCodecContext *avctx) { AMRWBContext *s = avctx->priv_data; if (avctx->sample_rate != 16000) { av_log(avctx, AV_LOG_ERROR, "Only 16000Hz sample rate supported\n"); return AVERROR(ENOSYS); } if (avctx->channels != 1) { av_log(avctx, AV_LOG_ERROR, "Only mono supported\n"); return AVERROR(ENOSYS); } s->mode = get_wb_bitrate_mode(avctx->bit_rate, avctx); s->last_bitrate = avctx->bit_rate; avctx->frame_size = 320; avctx->coded_frame = avcodec_alloc_frame(); s->state = E_IF_init(); return 0; }
--------------------------------------------- Result 284 ---------------------------------------------
[[0 (93%)]] --> [[0 (45%)]] --> Socre: 0.5532364249229431

[[[[Adv]]]]: uint32_t div32(uint32_t *[[q_ptr]], uint64_t [[num]], uint32_t den) { *[[q_ptr]] = [[num]] / den; return [[num]] % den; }

[[[[Adv]]]]: uint32_t div32(uint32_t *[[firewood]], uint64_t [[chiffre]], uint32_t den) { *[[firewood]] = [[chiffre]] / den; return [[chiffre]] % den; }
--------------------------------------------- Result 285 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove) { int i; s->dts = s->pts = AV_NOPTS_VALUE; s->pos = -1; s->offset = 0; for (i = 0; i < AV_PARSER_PTS_NB; i++) { if (s->cur_offset + off >= s->cur_frame_offset[i] && (s->frame_offset < s->cur_frame_offset[i] || (!s->frame_offset && !s->next_frame_offset)) && s->cur_frame_end[i]){ s->dts = s->cur_frame_dts[i]; s->pts = s->cur_frame_pts[i]; s->pos = s->cur_frame_pos[i]; s->offset = s->next_frame_offset - s->cur_frame_offset[i]; if (remove) s->cur_frame_offset[i] = INT64_MAX; if (s->cur_offset + off < s->cur_frame_end[i]) break; } } }
--------------------------------------------- Result 286 ---------------------------------------------
[[0 (58%)]] --> [[0 (32%)]] --> Socre: 0.6842207312583923

[[[[Adv]]]]: static void simple_whitespace(void) { int i; struct { const char *encoded; LiteralQObject decoded; } [[test_cases]][] = { { .encoded = " [ 43 , 42 ]", .decoded = QLIT_QLIST(((LiteralQObject[]){ QLIT_QINT(43), QLIT_QINT(42), { } })), }, { .encoded = " [ 43 , { 'h' : 'b' }, [ ], 42 ]", .decoded = QLIT_QLIST(((LiteralQObject[]){ QLIT_QINT(43), QLIT_QDICT(((LiteralQDictEntry[]){ { "h", QLIT_QSTR("b") }, { }})), QLIT_QLIST(((LiteralQObject[]){ { }})), QLIT_QINT(42), { } })), }, { .encoded = " [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]", .decoded = QLIT_QLIST(((LiteralQObject[]){ QLIT_QINT(43), QLIT_QDICT(((LiteralQDictEntry[]){ { "h", QLIT_QSTR("b") }, { "a", QLIT_QINT(32) }, { }})), QLIT_QLIST(((LiteralQObject[]){ { }})), QLIT_QINT(42), { } })), }, { } }; for (i = 0; [[test_cases]][i].encoded; i++) { QObject *obj; QString *str; obj = qobject_from_json([[test_cases]][i].encoded, NULL); g_assert(compare_litqobj_to_qobj(&[[test_cases]][i].decoded, obj) == 1); str = qobject_to_json(obj); qobject_decref(obj); obj = qobject_from_json(qstring_get_str(str), NULL); g_assert(compare_litqobj_to_qobj(&[[test_cases]][i].decoded, obj) == 1); qobject_decref(obj); QDECREF(str); } }

[[[[Adv]]]]: static void simple_whitespace(void) { int i; struct { const char *encoded; LiteralQObject decoded; } [[thermostat]][] = { { .encoded = " [ 43 , 42 ]", .decoded = QLIT_QLIST(((LiteralQObject[]){ QLIT_QINT(43), QLIT_QINT(42), { } })), }, { .encoded = " [ 43 , { 'h' : 'b' }, [ ], 42 ]", .decoded = QLIT_QLIST(((LiteralQObject[]){ QLIT_QINT(43), QLIT_QDICT(((LiteralQDictEntry[]){ { "h", QLIT_QSTR("b") }, { }})), QLIT_QLIST(((LiteralQObject[]){ { }})), QLIT_QINT(42), { } })), }, { .encoded = " [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]", .decoded = QLIT_QLIST(((LiteralQObject[]){ QLIT_QINT(43), QLIT_QDICT(((LiteralQDictEntry[]){ { "h", QLIT_QSTR("b") }, { "a", QLIT_QINT(32) }, { }})), QLIT_QLIST(((LiteralQObject[]){ { }})), QLIT_QINT(42), { } })), }, { } }; for (i = 0; [[thermostat]][i].encoded; i++) { QObject *obj; QString *str; obj = qobject_from_json([[thermostat]][i].encoded, NULL); g_assert(compare_litqobj_to_qobj(&[[thermostat]][i].decoded, obj) == 1); str = qobject_to_json(obj); qobject_decref(obj); obj = qobject_from_json(qstring_get_str(str), NULL); g_assert(compare_litqobj_to_qobj(&[[thermostat]][i].decoded, obj) == 1); qobject_decref(obj); QDECREF(str); } }
--------------------------------------------- Result 287 ---------------------------------------------
[[0 (35%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access) { if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) { if (sregnames[sr].name) { qemu_log("SR %s is not configured\n", sregnames[sr].name); } else { qemu_log("SR %d is not implemented\n", sr); } gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE); } else if (!(sregnames[sr].access & access)) { static const char * const access_text[] = { [SR_R] = "rsr", [SR_W] = "wsr", [SR_X] = "xsr", }; assert(access < ARRAY_SIZE(access_text) && access_text[access]); qemu_log("SR %s is not available for %s\n", sregnames[sr].name, access_text[access]); gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE); } }
--------------------------------------------- Result 288 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 161 / 11 / 116 / 288:  11%|         | 288/2690 [1:32:58<12:55:28, 19.37s/it][Succeeded / Failed / Skipped / Total] 161 / 11 / 116 / 288:  11%|         | 289/2690 [1:33:29<12:56:42, 19.41s/it][Succeeded / Failed / Skipped / Total] 162 / 11 / 116 / 289:  11%|         | 289/2690 [1:33:29<12:56:42, 19.41s/it][Succeeded / Failed / Skipped / Total] 162 / 11 / 116 / 289:  11%|         | 290/2690 [1:33:36<12:54:39, 19.37s/it][Succeeded / Failed / Skipped / Total] 163 / 11 / 116 / 290:  11%|         | 290/2690 [1:33:36<12:54:39, 19.37s/it][Succeeded / Failed / Skipped / Total] 163 / 11 / 116 / 290:  11%|         | 291/2690 [1:35:46<13:09:36, 19.75s/it][[0 (6%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void gen_lswi(DisasContext *ctx) { TCGv t0; TCGv_i32 t1, t2; int nb = NB(ctx->opcode); int start = rD(ctx->opcode); int ra = rA(ctx->opcode); int nr; if (nb == 0) nb = 32; nr = (nb + 3) / 4; if (unlikely(lsw_reg_in_range(start, nr, ra))) { gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX); return; } gen_set_access_type(ctx, ACCESS_INT); gen_update_nip(ctx, ctx->nip - 4); t0 = tcg_temp_new(); gen_addr_register(ctx, t0); t1 = tcg_const_i32(nb); t2 = tcg_const_i32(start); gen_helper_lsw(cpu_env, t0, t1, t2); tcg_temp_free(t0); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); }
--------------------------------------------- Result 289 ---------------------------------------------
[[0 (17%)]] --> [[0 (54%)]] --> Socre: 0.535779595375061

[[[[Adv]]]]: static int decode_frame(AVCodecContext *[[avctx]], const uint8_t *databuf, float **out_samples) { ATRAC3Context *q = [[avctx]]->priv_data; int ret, i; uint8_t *ptr1; if (q->coding_mode == JOINT_STEREO) { init_get_bits(&q->gb, databuf, [[avctx]]->block_align * 8); ret = decode_channel_sound_unit(q, &q->gb, q->units, out_samples[0], 0, JOINT_STEREO); if (ret != 0) return ret; if (databuf == q->decoded_bytes_buffer) { uint8_t *[[ptr2]] = q->decoded_bytes_buffer + [[avctx]]->block_align - 1; ptr1 = q->decoded_bytes_buffer; for (i = 0; i < [[avctx]]->block_align / 2; i++, ptr1++, [[ptr2]]--) FFSWAP(uint8_t, *ptr1, *[[ptr2]]); } else { const uint8_t *[[ptr2]] = databuf + [[avctx]]->block_align - 1; for (i = 0; i < [[avctx]]->block_align; i++) q->decoded_bytes_buffer[i] = *[[ptr2]]--; } ptr1 = q->decoded_bytes_buffer; for (i = 4; *ptr1 == 0xF8; i++, ptr1++) { if (i >= [[avctx]]->block_align) return AVERROR_INVALIDDATA; } init_get_bits8(&q->gb, ptr1, q->decoded_bytes_buffer + [[avctx]]->block_align - ptr1); memmove(q->weighting_delay, &q->weighting_delay[2], 4 * sizeof(*q->weighting_delay)); q->weighting_delay[4] = get_bits1(&q->gb); q->weighting_delay[5] = get_bits(&q->gb, 3); for (i = 0; i < 4; i++) { q->matrix_coeff_index_prev[i] = q->matrix_coeff_index_now[i]; q->matrix_coeff_index_now[i] = q->matrix_coeff_index_next[i]; q->matrix_coeff_index_next[i] = get_bits(&q->gb, 2); } ret = decode_channel_sound_unit(q, &q->gb, &q->units[1], out_samples[1], 1, JOINT_STEREO); if (ret != 0) return ret; reverse_matrixing(out_samples[0], out_samples[1], q->matrix_coeff_index_prev, q->matrix_coeff_index_now); channel_weighting(out_samples[0], out_samples[1], q->weighting_delay); } else { for (i = 0; i < [[avctx]]->channels; i++) { init_get_bits(&q->gb, databuf + i * [[avctx]]->block_align / [[avctx]]->channels, [[avctx]]->block_align * 8 / [[avctx]]->channels); ret = decode_channel_sound_unit(q, &q->gb, &q->units[i], out_samples[i], i, q->coding_mode); if (ret != 0) return ret; } } for (i = 0; i < [[avctx]]->channels; i++) { float *p1 = out_samples[i]; float *p2 = p1 + 256; float *p3 = p2 + 256; float *p4 = p3 + 256; ff_atrac_iqmf(p1, p2, 256, p1, q->units[i].delay_buf1, q->temp_buf); ff_atrac_iqmf(p4, p3, 256, p3, q->units[i].delay_buf2, q->temp_buf); ff_atrac_iqmf(p1, p3, 512, p1, q->units[i].delay_buf3, q->temp_buf); } return 0; }

[[[[Adv]]]]: static int decode_frame(AVCodecContext *[[customer]], const uint8_t *databuf, float **out_samples) { ATRAC3Context *q = [[customer]]->priv_data; int ret, i; uint8_t *ptr1; if (q->coding_mode == JOINT_STEREO) { init_get_bits(&q->gb, databuf, [[customer]]->block_align * 8); ret = decode_channel_sound_unit(q, &q->gb, q->units, out_samples[0], 0, JOINT_STEREO); if (ret != 0) return ret; if (databuf == q->decoded_bytes_buffer) { uint8_t *[[arsonist]] = q->decoded_bytes_buffer + [[customer]]->block_align - 1; ptr1 = q->decoded_bytes_buffer; for (i = 0; i < [[customer]]->block_align / 2; i++, ptr1++, [[arsonist]]--) FFSWAP(uint8_t, *ptr1, *[[arsonist]]); } else { const uint8_t *[[arsonist]] = databuf + [[customer]]->block_align - 1; for (i = 0; i < [[customer]]->block_align; i++) q->decoded_bytes_buffer[i] = *[[arsonist]]--; } ptr1 = q->decoded_bytes_buffer; for (i = 4; *ptr1 == 0xF8; i++, ptr1++) { if (i >= [[customer]]->block_align) return AVERROR_INVALIDDATA; } init_get_bits8(&q->gb, ptr1, q->decoded_bytes_buffer + [[customer]]->block_align - ptr1); memmove(q->weighting_delay, &q->weighting_delay[2], 4 * sizeof(*q->weighting_delay)); q->weighting_delay[4] = get_bits1(&q->gb); q->weighting_delay[5] = get_bits(&q->gb, 3); for (i = 0; i < 4; i++) { q->matrix_coeff_index_prev[i] = q->matrix_coeff_index_now[i]; q->matrix_coeff_index_now[i] = q->matrix_coeff_index_next[i]; q->matrix_coeff_index_next[i] = get_bits(&q->gb, 2); } ret = decode_channel_sound_unit(q, &q->gb, &q->units[1], out_samples[1], 1, JOINT_STEREO); if (ret != 0) return ret; reverse_matrixing(out_samples[0], out_samples[1], q->matrix_coeff_index_prev, q->matrix_coeff_index_now); channel_weighting(out_samples[0], out_samples[1], q->weighting_delay); } else { for (i = 0; i < [[customer]]->channels; i++) { init_get_bits(&q->gb, databuf + i * [[customer]]->block_align / [[customer]]->channels, [[customer]]->block_align * 8 / [[customer]]->channels); ret = decode_channel_sound_unit(q, &q->gb, &q->units[i], out_samples[i], i, q->coding_mode); if (ret != 0) return ret; } } for (i = 0; i < [[customer]]->channels; i++) { float *p1 = out_samples[i]; float *p2 = p1 + 256; float *p3 = p2 + 256; float *p4 = p3 + 256; ff_atrac_iqmf(p1, p2, 256, p1, q->units[i].delay_buf1, q->temp_buf); ff_atrac_iqmf(p4, p3, 256, p3, q->units[i].delay_buf2, q->temp_buf); ff_atrac_iqmf(p1, p3, 512, p1, q->units[i].delay_buf3, q->temp_buf); } return 0; }
--------------------------------------------- Result 290 ---------------------------------------------
[[0 (90%)]] --> [[0 (45%)]] --> Socre: 0.5456770062446594

[[[[Adv]]]]: uint32_t HELPER(shr_cc)(CPUM68KState *[[env]], uint32_t [[val]], uint32_t shift) { uint64_t [[temp]]; uint32_t result; shift &= 63; [[temp]] = (uint64_t)[[val]] << 32 >> shift; result = [[temp]] >> 32; [[env]]->cc_c = ([[temp]] >> 31) & 1; [[env]]->cc_n = result; [[env]]->cc_z = result; [[env]]->cc_v = 0; [[env]]->cc_x = shift ? [[env]]->cc_c : [[env]]->cc_x; return result; }

[[[[Adv]]]]: uint32_t HELPER(shr_cc)(CPUM68KState *[[electrocute]], uint32_t [[vote]], uint32_t shift) { uint64_t [[weather]]; uint32_t result; shift &= 63; [[weather]] = (uint64_t)[[vote]] << 32 >> shift; result = [[weather]] >> 32; [[electrocute]]->cc_c = ([[weather]] >> 31) & 1; [[electrocute]]->cc_n = result; [[electrocute]]->cc_z = result; [[electrocute]]->cc_v = 0; [[electrocute]]->cc_x = shift ? [[electrocute]]->cc_c : [[electrocute]]->cc_x; return result; }
--------------------------------------------- Result 291 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 164 / 11 / 116 / 291:  11%|         | 291/2690 [1:35:46<13:09:36, 19.75s/it][Succeeded / Failed / Skipped / Total] 164 / 11 / 116 / 291:  11%|         | 292/2690 [1:35:47<13:06:38, 19.68s/it][Succeeded / Failed / Skipped / Total] 164 / 11 / 117 / 292:  11%|         | 292/2690 [1:35:47<13:06:38, 19.68s/it][Succeeded / Failed / Skipped / Total] 164 / 11 / 117 / 292:  11%|         | 293/2690 [1:36:28<13:09:14, 19.76s/it][Succeeded / Failed / Skipped / Total] 165 / 11 / 117 / 293:  11%|         | 293/2690 [1:36:28<13:09:14, 19.76s/it][Succeeded / Failed / Skipped / Total] 165 / 11 / 117 / 293:  11%|         | 294/2690 [1:36:52<13:09:33, 19.77s/it][Succeeded / Failed / Skipped / Total] 166 / 11 / 117 / 294:  11%|         | 294/2690 [1:36:52<13:09:33, 19.77s/it][Succeeded / Failed / Skipped / Total] 166 / 11 / 117 / 294:  11%|         | 295/2690 [1:36:53<13:06:37, 19.71s/it][Succeeded / Failed / Skipped / Total] 166 / 11 / 118 / 295:  11%|         | 295/2690 [1:36:53<13:06:37, 19.71s/it][Succeeded / Failed / Skipped / Total] 166 / 11 / 118 / 295:  11%|         | 296/2690 [1:36:55<13:03:58, 19.65s/it][Succeeded / Failed / Skipped / Total] 167 / 11 / 118 / 296:  11%|         | 296/2690 [1:36:55<13:03:58, 19.65s/it][Succeeded / Failed / Skipped / Total] 167 / 11 / 118 / 296:  11%|         | 297/2690 [1:37:10<13:02:55, 19.63s/it][[0 (3%)]] --> [[0 (51%)]] --> Socre: 0.5077700614929199

[[[[Adv]]]]: static int decode_cabac_mb_cbp_luma( H264Context *[[h]]) { int [[cbp_b]], cbp_a, ctx, cbp = 0; cbp_a = [[h]]->slice_table[[[h]]->left_mb_xy[0]] == [[h]]->slice_num ? [[h]]->left_cbp : -1; [[cbp_b]] = [[h]]->slice_table[[[h]]->top_mb_xy] == [[h]]->slice_num ? [[h]]->top_cbp : -1; ctx = !(cbp_a & 0x02) + 2 * !([[cbp_b]] & 0x04); cbp |= get_cabac_noinline(&[[h]]->cabac, &[[h]]->cabac_state[73 + ctx]); ctx = !(cbp & 0x01) + 2 * !([[cbp_b]] & 0x08); cbp |= get_cabac_noinline(&[[h]]->cabac, &[[h]]->cabac_state[73 + ctx]) << 1; ctx = !(cbp_a & 0x08) + 2 * !(cbp & 0x01); cbp |= get_cabac_noinline(&[[h]]->cabac, &[[h]]->cabac_state[73 + ctx]) << 2; ctx = !(cbp & 0x04) + 2 * !(cbp & 0x02); cbp |= get_cabac_noinline(&[[h]]->cabac, &[[h]]->cabac_state[73 + ctx]) << 3; return cbp; }

[[[[Adv]]]]: static int decode_cabac_mb_cbp_luma( H264Context *[[l]]) { int [[sacr]], cbp_a, ctx, cbp = 0; cbp_a = [[l]]->slice_table[[[l]]->left_mb_xy[0]] == [[l]]->slice_num ? [[l]]->left_cbp : -1; [[sacr]] = [[l]]->slice_table[[[l]]->top_mb_xy] == [[l]]->slice_num ? [[l]]->top_cbp : -1; ctx = !(cbp_a & 0x02) + 2 * !([[sacr]] & 0x04); cbp |= get_cabac_noinline(&[[l]]->cabac, &[[l]]->cabac_state[73 + ctx]); ctx = !(cbp & 0x01) + 2 * !([[sacr]] & 0x08); cbp |= get_cabac_noinline(&[[l]]->cabac, &[[l]]->cabac_state[73 + ctx]) << 1; ctx = !(cbp_a & 0x08) + 2 * !(cbp & 0x01); cbp |= get_cabac_noinline(&[[l]]->cabac, &[[l]]->cabac_state[73 + ctx]) << 2; ctx = !(cbp & 0x04) + 2 * !(cbp & 0x02); cbp |= get_cabac_noinline(&[[l]]->cabac, &[[l]]->cabac_state[73 + ctx]) << 3; return cbp; }
--------------------------------------------- Result 292 ---------------------------------------------
[[0 (41%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_qsv_decode_reset(AVCodecContext *avctx, QSVContext *q) { QSVFrame *cur; AVPacket pkt; int ret = 0; mfxVideoParam param = { { 0 } }; if (q->reinit_pending) { close_decoder(q); } else if (q->engine_ready) { ret = MFXVideoDECODE_GetVideoParam(q->session, &param); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "MFX decode get param error %d\n", ret); } ret = MFXVideoDECODE_Reset(q->session, &param); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "MFX decode reset error %d\n", ret); } cur = q->work_frames; while (cur) { q->work_frames = cur->next; av_frame_free(&cur->frame); av_freep(&cur); cur = q->work_frames; } } av_fifo_reset(q->async_fifo); while (av_fifo_size(q->pkt_fifo)) { av_fifo_generic_read(q->pkt_fifo, &pkt, sizeof(pkt), NULL); av_packet_unref(&pkt); } av_fifo_reset(q->input_fifo); }
--------------------------------------------- Result 293 ---------------------------------------------
[[0 (99%)]] --> [[0 (41%)]] --> Socre: 0.5884051322937012

[[[[Adv]]]]: target_ulong helper_sdiv(target_ulong a, target_ulong b) { int64_t [[x0]]; int32_t [[x1]]; [[x0]] = (a & 0xffffffff) | ((int64_t) (env->y) << 32); [[x1]] = (b & 0xffffffff); if ([[x1]] == 0) { raise_exception(TT_DIV_ZERO); } [[x0]] = [[x0]] / [[x1]]; if ((int32_t) [[x0]] != [[x0]]) { env->cc_src2 = 1; return [[x0]] < 0? 0x80000000: 0x7fffffff; } else { env->cc_src2 = 0; return [[x0]]; } }

[[[[Adv]]]]: target_ulong helper_sdiv(target_ulong a, target_ulong b) { int64_t [[anaphylactic]]; int32_t [[destabilizing]]; [[anaphylactic]] = (a & 0xffffffff) | ((int64_t) (env->y) << 32); [[destabilizing]] = (b & 0xffffffff); if ([[destabilizing]] == 0) { raise_exception(TT_DIV_ZERO); } [[anaphylactic]] = [[anaphylactic]] / [[destabilizing]]; if ((int32_t) [[anaphylactic]] != [[anaphylactic]]) { env->cc_src2 = 1; return [[anaphylactic]] < 0? 0x80000000: 0x7fffffff; } else { env->cc_src2 = 0; return [[anaphylactic]]; } }
--------------------------------------------- Result 294 ---------------------------------------------
[[0 (79%)]] --> [[0 (48%)]] --> Socre: 0.5208274126052856

[[[[Adv]]]]: static void xhci_reset(DeviceState *[[dev]]) { XHCIState *[[xhci]] = XHCI([[dev]]); int i; trace_usb_xhci_reset(); if (!([[xhci]]->usbsts & USBSTS_HCH)) { DPRINTF("xhci: reset while running!\n"); } [[xhci]]->usbcmd = 0; [[xhci]]->usbsts = USBSTS_HCH; [[xhci]]->dnctrl = 0; [[xhci]]->crcr_low = 0; [[xhci]]->crcr_high = 0; [[xhci]]->dcbaap_low = 0; [[xhci]]->dcbaap_high = 0; [[xhci]]->config = 0; for (i = 0; i < [[xhci]]->numslots; i++) { xhci_disable_slot([[xhci]], i+1); } for (i = 0; i < [[xhci]]->numports; i++) { xhci_port_update([[xhci]]->ports + i, 0); } for (i = 0; i < [[xhci]]->numintrs; i++) { [[xhci]]->intr[i].iman = 0; [[xhci]]->intr[i].imod = 0; [[xhci]]->intr[i].erstsz = 0; [[xhci]]->intr[i].erstba_low = 0; [[xhci]]->intr[i].erstba_high = 0; [[xhci]]->intr[i].erdp_low = 0; [[xhci]]->intr[i].erdp_high = 0; [[xhci]]->intr[i].msix_used = 0; [[xhci]]->intr[i].er_ep_idx = 0; [[xhci]]->intr[i].er_pcs = 1; [[xhci]]->intr[i].er_full = 0; [[xhci]]->intr[i].ev_buffer_put = 0; [[xhci]]->intr[i].ev_buffer_get = 0; } [[xhci]]->mfindex_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL); xhci_mfwrap_update([[xhci]]); }

[[[[Adv]]]]: static void xhci_reset(DeviceState *[[india]]) { XHCIState *[[vascular]] = XHCI([[india]]); int i; trace_usb_xhci_reset(); if (!([[vascular]]->usbsts & USBSTS_HCH)) { DPRINTF("xhci: reset while running!\n"); } [[vascular]]->usbcmd = 0; [[vascular]]->usbsts = USBSTS_HCH; [[vascular]]->dnctrl = 0; [[vascular]]->crcr_low = 0; [[vascular]]->crcr_high = 0; [[vascular]]->dcbaap_low = 0; [[vascular]]->dcbaap_high = 0; [[vascular]]->config = 0; for (i = 0; i < [[vascular]]->numslots; i++) { xhci_disable_slot([[vascular]], i+1); } for (i = 0; i < [[vascular]]->numports; i++) { xhci_port_update([[vascular]]->ports + i, 0); } for (i = 0; i < [[vascular]]->numintrs; i++) { [[vascular]]->intr[i].iman = 0; [[vascular]]->intr[i].imod = 0; [[vascular]]->intr[i].erstsz = 0; [[vascular]]->intr[i].erstba_low = 0; [[vascular]]->intr[i].erstba_high = 0; [[vascular]]->intr[i].erdp_low = 0; [[vascular]]->intr[i].erdp_high = 0; [[vascular]]->intr[i].msix_used = 0; [[vascular]]->intr[i].er_ep_idx = 0; [[vascular]]->intr[i].er_pcs = 1; [[vascular]]->intr[i].er_full = 0; [[vascular]]->intr[i].ev_buffer_put = 0; [[vascular]]->intr[i].ev_buffer_get = 0; } [[vascular]]->mfindex_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL); xhci_mfwrap_update([[vascular]]); }
--------------------------------------------- Result 295 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def) { int i, ret; ret = -1; *def = NULL; for (i = 0; ppc_defs[i].name != NULL; i++) { if ((pvr & ppc_defs[i].pvr_mask) == (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) { *def = &ppc_defs[i]; ret = 0; break; } } return ret; }
--------------------------------------------- Result 296 ---------------------------------------------
[[0 (11%)]] --> [[0 (52%)]] --> Socre: 0.516562819480896

[[[[Adv]]]]: void helper_tlb_update(uint32_t T0) { #if !defined(CONFIG_USER_ONLY) uint32_t vaddr; uint32_t [[srs]] = env->pregs[PR_SRS]; if ([[srs]] != 1 && [[srs]] != 2) return; vaddr = cris_mmu_tlb_latest_update(env, T0); D(printf("flush old_vaddr=%x vaddr=%x T0=%x\n", vaddr, env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0)); tlb_flush_page(env, vaddr); #endif }

[[[[Adv]]]]: void helper_tlb_update(uint32_t T0) { #if !defined(CONFIG_USER_ONLY) uint32_t vaddr; uint32_t [[militiaman]] = env->pregs[PR_SRS]; if ([[militiaman]] != 1 && [[militiaman]] != 2) return; vaddr = cris_mmu_tlb_latest_update(env, T0); D(printf("flush old_vaddr=%x vaddr=%x T0=%x\n", vaddr, env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0)); tlb_flush_page(env, vaddr); #endif }
--------------------------------------------- Result 297 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 168 / 11 / 118 / 297:  11%|         | 297/2690 [1:37:10<13:02:55, 19.63s/it][Succeeded / Failed / Skipped / Total] 168 / 11 / 118 / 297:  11%|         | 298/2690 [1:37:16<13:00:45, 19.58s/it][Succeeded / Failed / Skipped / Total] 169 / 11 / 118 / 298:  11%|         | 298/2690 [1:37:16<13:00:45, 19.58s/it][Succeeded / Failed / Skipped / Total] 169 / 11 / 118 / 298:  11%|         | 299/2690 [1:37:16<12:57:52, 19.52s/it][Succeeded / Failed / Skipped / Total] 169 / 11 / 119 / 299:  11%|         | 299/2690 [1:37:16<12:57:52, 19.52s/it][Succeeded / Failed / Skipped / Total] 169 / 11 / 119 / 299:  11%|         | 300/2690 [1:37:56<13:00:14, 19.59s/it][Succeeded / Failed / Skipped / Total] 170 / 11 / 119 / 300:  11%|         | 300/2690 [1:37:56<13:00:14, 19.59s/it][Succeeded / Failed / Skipped / Total] 170 / 11 / 119 / 300:  11%|         | 301/2690 [1:37:56<12:57:23, 19.52s/it][Succeeded / Failed / Skipped / Total] 170 / 11 / 120 / 301:  11%|         | 301/2690 [1:37:56<12:57:23, 19.52s/it][Succeeded / Failed / Skipped / Total] 170 / 11 / 120 / 301:  11%|         | 302/2690 [1:38:02<12:55:16, 19.48s/it][[0 (6%)]] --> [[0 (52%)]] --> Socre: 0.5165647864341736

[[[[Adv]]]]: static void patch_pcihp(int slot, uint8_t *[[ssdt_ptr]], uint32_t eject) { [[ssdt_ptr]][ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4); [[ssdt_ptr]][ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot); [[ssdt_ptr]][ACPI_PCIHP_OFFSET_ID] = slot; [[ssdt_ptr]][ACPI_PCIHP_OFFSET_ADR + 2] = slot; assert(!memcmp([[ssdt_ptr]] + ACPI_PCIHP_OFFSET_EJ0, "_EJ0", 4)); if (!eject) { memcpy([[ssdt_ptr]] + ACPI_PCIHP_OFFSET_EJ0, "EJ0_", 4); } }

[[[[Adv]]]]: static void patch_pcihp(int slot, uint8_t *[[oversee]], uint32_t eject) { [[oversee]][ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4); [[oversee]][ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot); [[oversee]][ACPI_PCIHP_OFFSET_ID] = slot; [[oversee]][ACPI_PCIHP_OFFSET_ADR + 2] = slot; assert(!memcmp([[oversee]] + ACPI_PCIHP_OFFSET_EJ0, "_EJ0", 4)); if (!eject) { memcpy([[oversee]] + ACPI_PCIHP_OFFSET_EJ0, "EJ0_", 4); } }
--------------------------------------------- Result 298 ---------------------------------------------
[[0 (25%)]] --> [[0 (58%)]] --> Socre: 0.5834541916847229

[[[[Adv]]]]: static float ssim_plane(uint8_t *main, int main_stride, uint8_t *ref, int [[ref_stride]], int width, int height, void *temp) { int z = 0; int x, y; float [[ssim]] = 0.0; int (*sum0)[4] = temp; int (*sum1)[4] = sum0 + (width >> 2) + 3; width >>= 2; height >>= 2; for (y = 1; y < height; y++) { for (; z <= y; z++) { FFSWAP(void*, sum0, sum1); for (x = 0; x < width; x+=2) ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride, &ref[4 * (x + z * [[ref_stride]])], [[ref_stride]], &sum0[x]); } [[ssim]] += ssim_endn(sum0, sum1, width - 1); } return [[ssim]] / ((height - 1) * (width - 1)); }

[[[[Adv]]]]: static float ssim_plane(uint8_t *main, int main_stride, uint8_t *ref, int [[reelection]], int width, int height, void *temp) { int z = 0; int x, y; float [[fenton]] = 0.0; int (*sum0)[4] = temp; int (*sum1)[4] = sum0 + (width >> 2) + 3; width >>= 2; height >>= 2; for (y = 1; y < height; y++) { for (; z <= y; z++) { FFSWAP(void*, sum0, sum1); for (x = 0; x < width; x+=2) ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride, &ref[4 * (x + z * [[reelection]])], [[reelection]], &sum0[x]); } [[fenton]] += ssim_endn(sum0, sum1, width - 1); } return [[fenton]] / ((height - 1) * (width - 1)); }
--------------------------------------------- Result 299 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void nvme_instance_init(Object *obj) { object_property_add(obj, "bootindex", "int32", nvme_get_bootindex, nvme_set_bootindex, NULL, NULL, NULL); object_property_set_int(obj, -1, "bootindex", NULL); }
--------------------------------------------- Result 300 ---------------------------------------------
[[0 (1%)]] --> [[0 (81%)]] --> Socre: 0.8063178062438965

[[[[Adv]]]]: void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *[[src]], ptrdiff_t stride) { avc_luma_midv_qrt_8w_msa([[src]] - (2 * stride) - 2, stride, dst, stride, 8, 0); }

[[[[Adv]]]]: void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *[[crche]], ptrdiff_t stride) { avc_luma_midv_qrt_8w_msa([[crche]] - (2 * stride) - 2, stride, dst, stride, 8, 0); }
--------------------------------------------- Result 301 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi, int s_bits, int tlb_offset) { TCGReg base = TCG_AREG0; # if CPU_TLB_BITS > 8 # error # endif tcg_out_dat_reg(s, COND_AL, ARITH_MOV, TCG_REG_TMP, 0, addrlo, SHIFT_IMM_LSR(TARGET_PAGE_BITS)); assert((tlb_offset & ~0xffff) == 0); if (tlb_offset > 0xff) { tcg_out_dat_imm(s, COND_AL, ARITH_ADD, TCG_REG_R2, base, (24 << 7) | (tlb_offset >> 8)); tlb_offset &= 0xff; base = TCG_REG_R2; } tcg_out_dat_imm(s, COND_AL, ARITH_AND, TCG_REG_R0, TCG_REG_TMP, CPU_TLB_SIZE - 1); tcg_out_dat_reg(s, COND_AL, ARITH_ADD, TCG_REG_R2, base, TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS)); if (use_armv6_instructions && TARGET_LONG_BITS == 64) { tcg_out_memop_8(s, COND_AL, INSN_LDRD_IMM, TCG_REG_R0, TCG_REG_R2, tlb_offset, 1, 1); } else { tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R0, TCG_REG_R2, tlb_offset, 1, 1); if (TARGET_LONG_BITS == 64) { tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R1, TCG_REG_R2, 4, 1, 0); } } if (s_bits) { tcg_out_dat_imm(s, COND_AL, ARITH_TST, 0, addrlo, (1 << s_bits) - 1); } tcg_out_dat_reg(s, (s_bits ? COND_EQ : COND_AL), ARITH_CMP, 0, TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS)); if (TARGET_LONG_BITS == 64) { tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0, TCG_REG_R1, addrhi, SHIFT_IMM_LSL(0)); } }
--------------------------------------------- Result 302 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 171 / 11 / 120 / 302:  11%|         | 302/2690 [1:38:02<12:55:16, 19.48s/it][Succeeded / Failed / Skipped / Total] 171 / 11 / 120 / 302:  11%|        | 303/2690 [1:38:11<12:53:36, 19.45s/it][[0 (45%)]] --> [[0 (70%)]] --> Socre: 0.7032078504562378

[[[[Adv]]]]: static void qdm2_decode_super_block(QDM2Context *[[q]]) { GetBitContext gb; QDM2SubPacket header, *packet; int i, packet_bytes, sub_packet_size, sub_packets_D; unsigned int next_index = 0; memset([[q]]->tone_level_idx_hi1, 0, sizeof([[q]]->tone_level_idx_hi1)); memset([[q]]->tone_level_idx_mid, 0, sizeof([[q]]->tone_level_idx_mid)); memset([[q]]->tone_level_idx_hi2, 0, sizeof([[q]]->tone_level_idx_hi2)); [[q]]->sub_packets_B = 0; sub_packets_D = 0; average_quantized_coeffs([[q]]); init_get_bits(&gb, [[q]]->compressed_data, [[q]]->compressed_size * 8); qdm2_decode_sub_packet_header(&gb, &header); if (header.type < 2 || header.type >= 8) { [[q]]->has_errors = 1; av_log(NULL, AV_LOG_ERROR, "bad superblock type\n"); return; } [[q]]->superblocktype_2_3 = (header.type == 2 || header.type == 3); packet_bytes = ([[q]]->compressed_size - get_bits_count(&gb) / 8); init_get_bits(&gb, header.data, header.size * 8); if (header.type == 2 || header.type == 4 || header.type == 5) { int csum = 257 * get_bits(&gb, 8); csum += 2 * get_bits(&gb, 8); csum = qdm2_packet_checksum([[q]]->compressed_data, [[q]]->checksum_size, csum); if (csum != 0) { [[q]]->has_errors = 1; av_log(NULL, AV_LOG_ERROR, "bad packet checksum\n"); return; } } [[q]]->sub_packet_list_B[0].packet = NULL; [[q]]->sub_packet_list_D[0].packet = NULL; for (i = 0; i < 6; i++) if (--[[q]]->fft_level_exp[i] < 0) [[q]]->fft_level_exp[i] = 0; for (i = 0; packet_bytes > 0; i++) { int j; if (i >= FF_ARRAY_ELEMS([[q]]->sub_packet_list_A)) { SAMPLES_NEEDED_2("too many packet bytes"); return; } [[q]]->sub_packet_list_A[i].next = NULL; if (i > 0) { [[q]]->sub_packet_list_A[i - 1].next = &[[q]]->sub_packet_list_A[i]; init_get_bits(&gb, header.data, header.size * 8); skip_bits(&gb, next_index * 8); if (next_index >= header.size) break; } packet = &[[q]]->sub_packets[i]; qdm2_decode_sub_packet_header(&gb, packet); next_index = packet->size + get_bits_count(&gb) / 8; sub_packet_size = ((packet->size > 0xff) ? 1 : 0) + packet->size + 2; if (packet->type == 0) break; if (sub_packet_size > packet_bytes) { if (packet->type != 10 && packet->type != 11 && packet->type != 12) break; packet->size += packet_bytes - sub_packet_size; } packet_bytes -= sub_packet_size; [[q]]->sub_packet_list_A[i].packet = packet; if (packet->type == 8) { SAMPLES_NEEDED_2("packet type 8"); return; } else if (packet->type >= 9 && packet->type <= 12) { QDM2_LIST_ADD([[q]]->sub_packet_list_D, sub_packets_D, packet); } else if (packet->type == 13) { for (j = 0; j < 6; j++) [[q]]->fft_level_exp[j] = get_bits(&gb, 6); } else if (packet->type == 14) { for (j = 0; j < 6; j++) [[q]]->fft_level_exp[j] = qdm2_get_vlc(&gb, &fft_level_exp_vlc, 0, 2); } else if (packet->type == 15) { SAMPLES_NEEDED_2("packet type 15") return; } else if (packet->type >= 16 && packet->type < 48 && !fft_subpackets[packet->type - 16]) { QDM2_LIST_ADD([[q]]->sub_packet_list_B, [[q]]->sub_packets_B, packet); } } if ([[q]]->sub_packet_list_D[0].packet != NULL) { process_synthesis_subpackets([[q]], [[q]]->sub_packet_list_D); [[q]]->do_synth_filter = 1; } else if ([[q]]->do_synth_filter) { process_subpacket_10([[q]], NULL); process_subpacket_11([[q]], NULL); process_subpacket_12([[q]], NULL); } }

[[[[Adv]]]]: static void qdm2_decode_super_block(QDM2Context *[[journalistic]]) { GetBitContext gb; QDM2SubPacket header, *packet; int i, packet_bytes, sub_packet_size, sub_packets_D; unsigned int next_index = 0; memset([[journalistic]]->tone_level_idx_hi1, 0, sizeof([[journalistic]]->tone_level_idx_hi1)); memset([[journalistic]]->tone_level_idx_mid, 0, sizeof([[journalistic]]->tone_level_idx_mid)); memset([[journalistic]]->tone_level_idx_hi2, 0, sizeof([[journalistic]]->tone_level_idx_hi2)); [[journalistic]]->sub_packets_B = 0; sub_packets_D = 0; average_quantized_coeffs([[journalistic]]); init_get_bits(&gb, [[journalistic]]->compressed_data, [[journalistic]]->compressed_size * 8); qdm2_decode_sub_packet_header(&gb, &header); if (header.type < 2 || header.type >= 8) { [[journalistic]]->has_errors = 1; av_log(NULL, AV_LOG_ERROR, "bad superblock type\n"); return; } [[journalistic]]->superblocktype_2_3 = (header.type == 2 || header.type == 3); packet_bytes = ([[journalistic]]->compressed_size - get_bits_count(&gb) / 8); init_get_bits(&gb, header.data, header.size * 8); if (header.type == 2 || header.type == 4 || header.type == 5) { int csum = 257 * get_bits(&gb, 8); csum += 2 * get_bits(&gb, 8); csum = qdm2_packet_checksum([[journalistic]]->compressed_data, [[journalistic]]->checksum_size, csum); if (csum != 0) { [[journalistic]]->has_errors = 1; av_log(NULL, AV_LOG_ERROR, "bad packet checksum\n"); return; } } [[journalistic]]->sub_packet_list_B[0].packet = NULL; [[journalistic]]->sub_packet_list_D[0].packet = NULL; for (i = 0; i < 6; i++) if (--[[journalistic]]->fft_level_exp[i] < 0) [[journalistic]]->fft_level_exp[i] = 0; for (i = 0; packet_bytes > 0; i++) { int j; if (i >= FF_ARRAY_ELEMS([[journalistic]]->sub_packet_list_A)) { SAMPLES_NEEDED_2("too many packet bytes"); return; } [[journalistic]]->sub_packet_list_A[i].next = NULL; if (i > 0) { [[journalistic]]->sub_packet_list_A[i - 1].next = &[[journalistic]]->sub_packet_list_A[i]; init_get_bits(&gb, header.data, header.size * 8); skip_bits(&gb, next_index * 8); if (next_index >= header.size) break; } packet = &[[journalistic]]->sub_packets[i]; qdm2_decode_sub_packet_header(&gb, packet); next_index = packet->size + get_bits_count(&gb) / 8; sub_packet_size = ((packet->size > 0xff) ? 1 : 0) + packet->size + 2; if (packet->type == 0) break; if (sub_packet_size > packet_bytes) { if (packet->type != 10 && packet->type != 11 && packet->type != 12) break; packet->size += packet_bytes - sub_packet_size; } packet_bytes -= sub_packet_size; [[journalistic]]->sub_packet_list_A[i].packet = packet; if (packet->type == 8) { SAMPLES_NEEDED_2("packet type 8"); return; } else if (packet->type >= 9 && packet->type <= 12) { QDM2_LIST_ADD([[journalistic]]->sub_packet_list_D, sub_packets_D, packet); } else if (packet->type == 13) { for (j = 0; j < 6; j++) [[journalistic]]->fft_level_exp[j] = get_bits(&gb, 6); } else if (packet->type == 14) { for (j = 0; j < 6; j++) [[journalistic]]->fft_level_exp[j] = qdm2_get_vlc(&gb, &fft_level_exp_vlc, 0, 2); } else if (packet->type == 15) { SAMPLES_NEEDED_2("packet type 15") return; } else if (packet->type >= 16 && packet->type < 48 && !fft_subpackets[packet->type - 16]) { QDM2_LIST_ADD([[journalistic]]->sub_packet_list_B, [[journalistic]]->sub_packets_B, packet); } } if ([[journalistic]]->sub_packet_list_D[0].packet != NULL) { process_synthesis_subpackets([[journalistic]], [[journalistic]]->sub_packet_list_D); [[journalistic]]->do_synth_filter = 1; } else if ([[journalistic]]->do_synth_filter) { process_subpacket_10([[journalistic]], NULL); process_subpacket_11([[journalistic]], NULL); process_subpacket_12([[journalistic]], NULL); } }
--------------------------------------------- Result 303 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 171 / 12 / 120 / 303:  11%|        | 303/2690 [1:38:11<12:53:36, 19.45s/it][Succeeded / Failed / Skipped / Total] 171 / 12 / 120 / 303:  11%|        | 304/2690 [1:38:13<12:50:58, 19.39s/it][Succeeded / Failed / Skipped / Total] 172 / 12 / 120 / 304:  11%|        | 304/2690 [1:38:13<12:50:58, 19.39s/it][Succeeded / Failed / Skipped / Total] 172 / 12 / 120 / 304:  11%|        | 305/2690 [1:38:23<12:49:24, 19.36s/it][Succeeded / Failed / Skipped / Total] 173 / 12 / 120 / 305:  11%|        | 305/2690 [1:38:23<12:49:24, 19.36s/it][Succeeded / Failed / Skipped / Total] 173 / 12 / 120 / 305:  11%|        | 306/2690 [1:38:24<12:46:37, 19.29s/it][Succeeded / Failed / Skipped / Total] 173 / 12 / 121 / 306:  11%|        | 306/2690 [1:38:24<12:46:37, 19.29s/it][Succeeded / Failed / Skipped / Total] 173 / 12 / 121 / 306:  11%|        | 307/2690 [1:38:39<12:45:51, 19.28s/it][Succeeded / Failed / Skipped / Total] 174 / 12 / 121 / 307:  11%|        | 307/2690 [1:38:39<12:45:51, 19.28s/it][Succeeded / Failed / Skipped / Total] 174 / 12 / 121 / 307:  11%|        | 308/2690 [1:38:40<12:43:07, 19.22s/it][[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc) { uint8_t symbols[256]; uint8_t bits[256]; uint16_t codes[256]; int num_lens, num_codes, num_codes_sum, prefix; int i, j, count; prefix = 0; count = 0; num_codes_sum = 0; num_lens = get_bits(gb, 5); for (i = 0; i < num_lens; i++) { num_codes = get_bits(gb, 9); num_codes_sum += num_codes; if (num_codes_sum > 256) { av_log(ctx->avctx, AV_LOG_ERROR, "Too many VLCs (%d) to be read.\n", num_codes_sum); for (j = 0; j < num_codes; j++) { symbols[count] = get_bits(gb, 8); bits[count] = i + 1; codes[count] = prefix++; count++; if (prefix > (65535 - 256)/2) { prefix <<= 1; return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1, codes, 2, 2, symbols, 1, 1, 0);

[[[[Adv]]]]: static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc) { uint8_t symbols[256]; uint8_t bits[256]; uint16_t codes[256]; int num_lens, num_codes, num_codes_sum, prefix; int i, j, count; prefix = 0; count = 0; num_codes_sum = 0; num_lens = get_bits(gb, 5); for (i = 0; i < num_lens; i++) { num_codes = get_bits(gb, 9); num_codes_sum += num_codes; if (num_codes_sum > 256) { av_log(ctx->avctx, AV_LOG_ERROR, "Too many VLCs (%d) to be read.\n", num_codes_sum); for (j = 0; j < num_codes; j++) { symbols[count] = get_bits(gb, 8); bits[count] = i + 1; codes[count] = prefix++; count++; if (prefix > (65535 - 256)/2) { prefix <<= 1; return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1, codes, 2, 2, symbols, 1, 1, 0);
--------------------------------------------- Result 304 ---------------------------------------------
[[0 (83%)]] --> [[0 (38%)]] --> Socre: 0.6225254535675049

[[[[Adv]]]]: static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src, const int16_t *filter, const int16_t *filterPos, int [[filterSize]]) { int i; for (i=0; i<dstW; i++) { int j; int srcPos= filterPos[i]; int val=0; for (j=0; j<[[filterSize]]; j++) { val += ((int)src[srcPos + j])*filter[[[filterSize]]*i + j]; } dst[i] = FFMIN(val>>7, (1<<15)-1); } }

[[[[Adv]]]]: static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src, const int16_t *filter, const int16_t *filterPos, int [[caledonia]]) { int i; for (i=0; i<dstW; i++) { int j; int srcPos= filterPos[i]; int val=0; for (j=0; j<[[caledonia]]; j++) { val += ((int)src[srcPos + j])*filter[[[caledonia]]*i + j]; } dst[i] = FFMIN(val>>7, (1<<15)-1); } }
--------------------------------------------- Result 305 ---------------------------------------------
[[0 (85%)]] --> [[0 (46%)]] --> Socre: 0.5358869135379791

[[[[Adv]]]]: qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned [[iov_cnt]], size_t [[offset]], size_t bytes, bool do_send) { size_t [[done]] = 0; ssize_t ret; while ([[done]] < bytes) { ret = iov_send_recv(sockfd, iov, [[offset]] + [[done]], bytes - [[done]], do_send); if (ret > 0) { [[done]] += ret; } else if (ret < 0) { if (errno == EAGAIN) { qemu_coroutine_yield(); } else if ([[done]] == 0) { return -1; } else { break; } } else if (ret == 0 && !do_send) { break; } } return [[done]]; }

[[[[Adv]]]]: qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned [[leakage]], size_t [[defuse]], size_t bytes, bool do_send) { size_t [[completing]] = 0; ssize_t ret; while ([[completing]] < bytes) { ret = iov_send_recv(sockfd, iov, [[defuse]] + [[completing]], bytes - [[completing]], do_send); if (ret > 0) { [[completing]] += ret; } else if (ret < 0) { if (errno == EAGAIN) { qemu_coroutine_yield(); } else if ([[completing]] == 0) { return -1; } else { break; } } else if (ret == 0 && !do_send) { break; } } return [[completing]]; }
--------------------------------------------- Result 306 ---------------------------------------------
[[0 (12%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qcow2_change_backing_file(BlockDriverState *bs, const char *backing_file, const char *backing_fmt) { return qcow2_update_ext_header(bs, backing_file, backing_fmt); }
--------------------------------------------- Result 307 ---------------------------------------------
[[0 (79%)]] --> [[0 (40%)]] --> Socre: 0.6004995703697205

[[[[Adv]]]]: MigrationState *migrate_get_current(void) { static MigrationState [[current_migration]] = { .state = MIG_STATE_NONE, .bandwidth_limit = MAX_THROTTLE, .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE, .mbps = -1, }; return &[[current_migration]]; }

[[[[Adv]]]]: MigrationState *migrate_get_current(void) { static MigrationState [[laminated]] = { .state = MIG_STATE_NONE, .bandwidth_limit = MAX_THROTTLE, .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE, .mbps = -1, }; return &[[laminated]]; }
--------------------------------------------- Result 308 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 174 / 12 / 122 / 308:  11%|        | 308/2690 [1:38:40<12:43:07, 19.22s/it][Succeeded / Failed / Skipped / Total] 174 / 12 / 122 / 308:  11%|        | 309/2690 [1:38:40<12:40:23, 19.16s/it][Succeeded / Failed / Skipped / Total] 174 / 12 / 123 / 309:  11%|        | 309/2690 [1:38:40<12:40:23, 19.16s/it][Succeeded / Failed / Skipped / Total] 174 / 12 / 123 / 309:  12%|        | 310/2690 [1:40:04<12:48:18, 19.37s/it][[0 (95%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void sun4d_hw_init(const struct sun4d_hwdef *hwdef, ram_addr_t RAM_size, const char *boot_device, DisplayState *ds, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { CPUState *env, *envs[MAX_CPUS]; unsigned int i; void *iounits[MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi; qemu_irq *cpu_irqs[MAX_CPUS], *sbi_irq, *sbi_cpu_irq, *espdma_irq, *ledma_irq; qemu_irq *esp_reset, *le_reset; ram_addr_t ram_offset, prom_offset, tcx_offset; unsigned long kernel_size; int ret; char buf[1024]; int drive_index; void *fw_cfg; if (!cpu_model) cpu_model = hwdef->default_cpu_model; for (i = 0; i < smp_cpus; i++) { env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "qemu: Unable to find Sparc CPU definition\n"); exit(1); } cpu_sparc_set_id(env, i); envs[i] = env; if (i == 0) { qemu_register_reset(main_cpu_reset, env); } else { qemu_register_reset(secondary_cpu_reset, env); env->halted = 1; } cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS); env->prom_addr = hwdef->slavio_base; } for (i = smp_cpus; i < MAX_CPUS; i++) cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS); if ((uint64_t)RAM_size > hwdef->max_mem) { fprintf(stderr, "qemu: Too much memory for this machine: %d, maximum %d\n", (unsigned int)(RAM_size / (1024 * 1024)), (unsigned int)(hwdef->max_mem / (1024 * 1024))); exit(1); } ram_offset = qemu_ram_alloc(RAM_size); cpu_register_physical_memory(0, RAM_size, ram_offset); prom_offset = qemu_ram_alloc(PROM_SIZE_MAX); cpu_register_physical_memory(hwdef->slavio_base, (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) & TARGET_PAGE_MASK, prom_offset | IO_MEM_ROM); if (bios_name == NULL) bios_name = PROM_FILENAME; snprintf(buf, sizeof(buf), "%s/%s", bios_dir, bios_name); ret = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL); if (ret < 0 || ret > PROM_SIZE_MAX) ret = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX); if (ret < 0 || ret > PROM_SIZE_MAX) { fprintf(stderr, "qemu: could not load prom '%s'\n", buf); exit(1); } sbi = sbi_init(hwdef->sbi_base, &sbi_irq, &sbi_cpu_irq, cpu_irqs); for (i = 0; i < MAX_IOUNITS; i++) if (hwdef->iounit_bases[i] != (target_phys_addr_t)-1) iounits[i] = iommu_init(hwdef->iounit_bases[i], hwdef->iounit_version, sbi_irq[hwdef->me_irq]); espdma = sparc32_dma_init(hwdef->espdma_base, sbi_irq[hwdef->esp_irq], iounits[0], &espdma_irq, &esp_reset); ledma = sparc32_dma_init(hwdef->ledma_base, sbi_irq[hwdef->le_irq], iounits[0], &ledma_irq, &le_reset); if (graphic_depth != 8 && graphic_depth != 24) { fprintf(stderr, "qemu: Unsupported depth: %d\n", graphic_depth); exit (1); } tcx_offset = qemu_ram_alloc(hwdef->vram_size); tcx_init(ds, hwdef->tcx_base, phys_ram_base + tcx_offset, tcx_offset, hwdef->vram_size, graphic_width, graphic_height, graphic_depth); if (nd_table[0].model == NULL) nd_table[0].model = "lance"; if (strcmp(nd_table[0].model, "lance") == 0) { lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset); } else if (strcmp(nd_table[0].model, "?") == 0) { fprintf(stderr, "qemu: Supported NICs: lance\n"); exit (1); } else { fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd_table[0].model); exit (1); } nvram = m48t59_init(sbi_irq[0], hwdef->nvram_base, 0, hwdef->nvram_size, 8); slavio_timer_init_all(hwdef->counter_base, sbi_irq[hwdef->clock1_irq], sbi_cpu_irq, smp_cpus); slavio_serial_ms_kbd_init(hwdef->ms_kb_base, sbi_irq[hwdef->ms_kb_irq], nographic, ESCC_CLOCK, 1); escc_init(hwdef->serial_base, sbi_irq[hwdef->ser_irq], serial_hds[1], serial_hds[0], ESCC_CLOCK, 1); if (drive_get_max_bus(IF_SCSI) > 0) { fprintf(stderr, "qemu: too many SCSI bus\n"); exit(1); } main_esp = esp_init(hwdef->esp_base, 2, espdma_memory_read, espdma_memory_write, espdma, *espdma_irq, esp_reset); for (i = 0; i < ESP_MAX_DEVS; i++) { drive_index = drive_get_index(IF_SCSI, 0, i); if (drive_index == -1) continue; esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, i); } kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename, RAM_size); nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, kernel_cmdline, boot_device, RAM_size, kernel_size, graphic_width, graphic_height, graphic_depth, hwdef->nvram_machine_id, "Sun4d"); fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2); fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1); fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size); fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id); }
--------------------------------------------- Result 309 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qemu_rdma_block_for_wrid(RDMAContext *rdma, int wrid_requested) { int num_cq_events = 0, ret = 0; struct ibv_cq *cq; void *cq_ctx; uint64_t wr_id = RDMA_WRID_NONE, wr_id_in; if (ibv_req_notify_cq(rdma->cq, 0)) { return -1; } while (wr_id != wrid_requested) { ret = qemu_rdma_poll(rdma, &wr_id_in); if (ret < 0) { return ret; } wr_id = wr_id_in & RDMA_WRID_TYPE_MASK; if (wr_id == RDMA_WRID_NONE) { break; } if (wr_id != wrid_requested) { DDDPRINTF("A Wanted wrid %s (%d) but got %s (%" PRIu64 ")\n", print_wrid(wrid_requested), wrid_requested, print_wrid(wr_id), wr_id); } } if (wr_id == wrid_requested) { return 0; } while (1) { if (rdma->migration_started_on_destination) { yield_until_fd_readable(rdma->comp_channel->fd); } if (ibv_get_cq_event(rdma->comp_channel, &cq, &cq_ctx)) { perror("ibv_get_cq_event"); goto err_block_for_wrid; } num_cq_events++; if (ibv_req_notify_cq(cq, 0)) { goto err_block_for_wrid; } while (wr_id != wrid_requested) { ret = qemu_rdma_poll(rdma, &wr_id_in); if (ret < 0) { goto err_block_for_wrid; } wr_id = wr_id_in & RDMA_WRID_TYPE_MASK; if (wr_id == RDMA_WRID_NONE) { break; } if (wr_id != wrid_requested) { DDDPRINTF("B Wanted wrid %s (%d) but got %s (%" PRIu64 ")\n", print_wrid(wrid_requested), wrid_requested, print_wrid(wr_id), wr_id); } } if (wr_id == wrid_requested) { goto success_block_for_wrid; } } success_block_for_wrid: if (num_cq_events) { ibv_ack_cq_events(cq, num_cq_events); } return 0; err_block_for_wrid: if (num_cq_events) { ibv_ack_cq_events(cq, num_cq_events); } return ret; }
--------------------------------------------- Result 310 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 175 / 12 / 123 / 310:  12%|        | 310/2690 [1:40:04<12:48:18, 19.37s/it][Succeeded / Failed / Skipped / Total] 175 / 12 / 123 / 310:  12%|        | 311/2690 [1:40:04<12:45:34, 19.31s/it][Succeeded / Failed / Skipped / Total] 175 / 12 / 124 / 311:  12%|        | 311/2690 [1:40:04<12:45:34, 19.31s/it][Succeeded / Failed / Skipped / Total] 175 / 12 / 124 / 311:  12%|        | 312/2690 [1:40:05<12:42:51, 19.25s/it][Succeeded / Failed / Skipped / Total] 175 / 12 / 125 / 312:  12%|        | 312/2690 [1:40:05<12:42:51, 19.25s/it][Succeeded / Failed / Skipped / Total] 175 / 12 / 125 / 312:  12%|        | 313/2690 [1:40:12<12:40:58, 19.21s/it][Succeeded / Failed / Skipped / Total] 176 / 12 / 125 / 313:  12%|        | 313/2690 [1:40:12<12:40:58, 19.21s/it][Succeeded / Failed / Skipped / Total] 176 / 12 / 125 / 313:  12%|        | 314/2690 [1:42:32<12:55:56, 19.59s/it][[0 (99%)]] --> [[0 (46%)]] --> Socre: 0.5444169044494629

[[[[Adv]]]]: static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *dst, int [[src_size]]) { const uint16_t *end; const uint16_t *mm_end; uint8_t *d = dst; const uint16_t *s = (const uint16_t *)src; end = s + [[src_size]]/2; __asm__ volatile(PREFETCH" %0"::"m"(*s):"memory"); __asm__ volatile("pxor %%mm7,%%mm7 \n\t":::"memory"); __asm__ volatile("pcmpeqd %%mm6,%%mm6 \n\t":::"memory"); mm_end = end - 3; while (s < mm_end) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movq %1, %%mm0 \n\t" "movq %1, %%mm1 \n\t" "movq %1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" PACK_RGB32 :"=m"(*d) :"m"(*s),"m"(mask15b),"m"(mask15g),"m"(mask15r) :"memory"); d += 16; s += 4; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while (s < end) { register uint16_t bgr; bgr = *s++; *d++ = (bgr&0x1F)<<3; *d++ = (bgr&0x3E0)>>2; *d++ = (bgr&0x7C00)>>7; *d++ = 255; } }

[[[[Adv]]]]: static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *dst, int [[lactose]]) { const uint16_t *end; const uint16_t *mm_end; uint8_t *d = dst; const uint16_t *s = (const uint16_t *)src; end = s + [[lactose]]/2; __asm__ volatile(PREFETCH" %0"::"m"(*s):"memory"); __asm__ volatile("pxor %%mm7,%%mm7 \n\t":::"memory"); __asm__ volatile("pcmpeqd %%mm6,%%mm6 \n\t":::"memory"); mm_end = end - 3; while (s < mm_end) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movq %1, %%mm0 \n\t" "movq %1, %%mm1 \n\t" "movq %1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" PACK_RGB32 :"=m"(*d) :"m"(*s),"m"(mask15b),"m"(mask15g),"m"(mask15r) :"memory"); d += 16; s += 4; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while (s < end) { register uint16_t bgr; bgr = *s++; *d++ = (bgr&0x1F)<<3; *d++ = (bgr&0x3E0)>>2; *d++ = (bgr&0x7C00)>>7; *d++ = 255; } }
--------------------------------------------- Result 311 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mux_chr_can_read(void *opaque) { CharDriverState *chr = opaque; MuxDriver *d = chr->opaque; if ((d->prod - d->cons) < MUX_BUFFER_SIZE) return 1; if (d->chr_can_read[chr->focus]) return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]); return 0; }
--------------------------------------------- Result 312 ---------------------------------------------
[[0 (7%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *s) { return s->iq_tail == 0; }
--------------------------------------------- Result 313 ---------------------------------------------
[[0 (98%)]] --> [[0 (36%)]] --> Socre: 0.641713410615921

[[[[Adv]]]]: static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *[[dst2]], int dstWidth, const uint8_t *src_in[4], int srcW, int xInc, const int16_t *hChrFilter, const int16_t *hChrFilterPos, int hChrFilterSize, uint8_t *formatConvBuffer, uint32_t *pal) { const uint8_t *src1 = src_in[1], *src2 = src_in[2]; if (c->chrToYV12) { uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16); c->chrToYV12(formatConvBuffer, buf2, src1, src2, srcW, pal); src1= formatConvBuffer; src2= buf2; } else if (c->readChrPlanar) { uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16); c->readChrPlanar(formatConvBuffer, buf2, src_in, srcW); src1= formatConvBuffer; src2= buf2; } if (!c->hcscale_fast) { c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize); c->hcScale(c, [[dst2]], dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize); } else { c->hcscale_fast(c, dst1, [[dst2]], dstWidth, src1, src2, srcW, xInc); } if (c->chrConvertRange) c->chrConvertRange(dst1, [[dst2]], dstWidth); }

[[[[Adv]]]]: static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *[[unwinnable]], int dstWidth, const uint8_t *src_in[4], int srcW, int xInc, const int16_t *hChrFilter, const int16_t *hChrFilterPos, int hChrFilterSize, uint8_t *formatConvBuffer, uint32_t *pal) { const uint8_t *src1 = src_in[1], *src2 = src_in[2]; if (c->chrToYV12) { uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16); c->chrToYV12(formatConvBuffer, buf2, src1, src2, srcW, pal); src1= formatConvBuffer; src2= buf2; } else if (c->readChrPlanar) { uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16); c->readChrPlanar(formatConvBuffer, buf2, src_in, srcW); src1= formatConvBuffer; src2= buf2; } if (!c->hcscale_fast) { c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize); c->hcScale(c, [[unwinnable]], dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize); } else { c->hcscale_fast(c, dst1, [[unwinnable]], dstWidth, src1, src2, srcW, xInc); } if (c->chrConvertRange) c->chrConvertRange(dst1, [[unwinnable]], dstWidth); }
--------------------------------------------- Result 314 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 177 / 12 / 125 / 314:  12%|        | 314/2690 [1:42:32<12:55:56, 19.59s/it][Succeeded / Failed / Skipped / Total] 177 / 12 / 125 / 314:  12%|        | 315/2690 [1:42:33<12:53:12, 19.53s/it][Succeeded / Failed / Skipped / Total] 177 / 12 / 126 / 315:  12%|        | 315/2690 [1:42:33<12:53:12, 19.53s/it][Succeeded / Failed / Skipped / Total] 177 / 12 / 126 / 315:  12%|        | 316/2690 [1:42:33<12:50:29, 19.47s/it][Succeeded / Failed / Skipped / Total] 177 / 12 / 127 / 316:  12%|        | 316/2690 [1:42:33<12:50:29, 19.47s/it][Succeeded / Failed / Skipped / Total] 177 / 12 / 127 / 316:  12%|        | 317/2690 [1:51:41<13:56:03, 21.14s/it][Succeeded / Failed / Skipped / Total] 178 / 12 / 127 / 317:  12%|        | 317/2690 [1:51:41<13:56:03, 21.14s/it][Succeeded / Failed / Skipped / Total] 178 / 12 / 127 / 317:  12%|        | 318/2690 [1:54:28<14:13:51, 21.60s/it][[0 (100%)]] --> [[0 (42%)]] --> Socre: 0.5775856077671051

[[[[Adv]]]]: static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child, int64_t offset, unsigned int bytes, QEMUIOVector *qiov) { BlockDriverState *bs = child->bs; void *bounce_buffer; BlockDriver *[[drv]] = bs->drv; struct iovec iov; QEMUIOVector local_qiov; int64_t cluster_offset; int64_t cluster_bytes; size_t skip_bytes; int ret; int [[max_transfer]] = MIN_NON_ZERO(bs->bl.max_transfer, BDRV_REQUEST_MAX_BYTES); unsigned int progress = 0; bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes); skip_bytes = offset - cluster_offset; trace_bdrv_co_do_copy_on_readv(bs, offset, bytes, cluster_offset, cluster_bytes); bounce_buffer = qemu_try_blockalign(bs, MIN(MIN([[max_transfer]], cluster_bytes), MAX_BOUNCE_BUFFER)); if (bounce_buffer == NULL) { ret = -ENOMEM; goto err; while (cluster_bytes) { int64_t pnum; ret = bdrv_is_allocated(bs, cluster_offset, MIN(cluster_bytes, [[max_transfer]]), &pnum); if (ret < 0) { pnum = MIN(cluster_bytes, [[max_transfer]]); assert(skip_bytes < pnum); if (ret <= 0) { iov.iov_base = bounce_buffer; iov.iov_len = pnum = MIN(pnum, MAX_BOUNCE_BUFFER); qemu_iovec_init_external(&local_qiov, &iov, 1); ret = bdrv_driver_preadv(bs, cluster_offset, pnum, &local_qiov, 0); if (ret < 0) { goto err; bdrv_debug_event(bs, BLKDBG_COR_WRITE); if ([[drv]]->bdrv_co_pwrite_zeroes && buffer_is_zero(bounce_buffer, pnum)) { ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, pnum, 0); } else { ret = bdrv_driver_pwritev(bs, cluster_offset, pnum, &local_qiov, 0); if (ret < 0) { goto err; qemu_iovec_from_buf(qiov, progress, bounce_buffer + skip_bytes, pnum - skip_bytes); } else { qemu_iovec_init(&local_qiov, qiov->niov); qemu_iovec_concat(&local_qiov, qiov, progress, pnum - skip_bytes); ret = bdrv_driver_preadv(bs, offset + progress, local_qiov.size, &local_qiov, 0); qemu_iovec_destroy(&local_qiov); if (ret < 0) { goto err; cluster_offset += pnum; cluster_bytes -= pnum; progress += pnum - skip_bytes; skip_bytes = 0; ret = 0; err: qemu_vfree(bounce_buffer); return ret;

[[[[Adv]]]]: static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child, int64_t offset, unsigned int bytes, QEMUIOVector *qiov) { BlockDriverState *bs = child->bs; void *bounce_buffer; BlockDriver *[[ah]] = bs->drv; struct iovec iov; QEMUIOVector local_qiov; int64_t cluster_offset; int64_t cluster_bytes; size_t skip_bytes; int ret; int [[alamos]] = MIN_NON_ZERO(bs->bl.max_transfer, BDRV_REQUEST_MAX_BYTES); unsigned int progress = 0; bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes); skip_bytes = offset - cluster_offset; trace_bdrv_co_do_copy_on_readv(bs, offset, bytes, cluster_offset, cluster_bytes); bounce_buffer = qemu_try_blockalign(bs, MIN(MIN([[alamos]], cluster_bytes), MAX_BOUNCE_BUFFER)); if (bounce_buffer == NULL) { ret = -ENOMEM; goto err; while (cluster_bytes) { int64_t pnum; ret = bdrv_is_allocated(bs, cluster_offset, MIN(cluster_bytes, [[alamos]]), &pnum); if (ret < 0) { pnum = MIN(cluster_bytes, [[alamos]]); assert(skip_bytes < pnum); if (ret <= 0) { iov.iov_base = bounce_buffer; iov.iov_len = pnum = MIN(pnum, MAX_BOUNCE_BUFFER); qemu_iovec_init_external(&local_qiov, &iov, 1); ret = bdrv_driver_preadv(bs, cluster_offset, pnum, &local_qiov, 0); if (ret < 0) { goto err; bdrv_debug_event(bs, BLKDBG_COR_WRITE); if ([[ah]]->bdrv_co_pwrite_zeroes && buffer_is_zero(bounce_buffer, pnum)) { ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, pnum, 0); } else { ret = bdrv_driver_pwritev(bs, cluster_offset, pnum, &local_qiov, 0); if (ret < 0) { goto err; qemu_iovec_from_buf(qiov, progress, bounce_buffer + skip_bytes, pnum - skip_bytes); } else { qemu_iovec_init(&local_qiov, qiov->niov); qemu_iovec_concat(&local_qiov, qiov, progress, pnum - skip_bytes); ret = bdrv_driver_preadv(bs, offset + progress, local_qiov.size, &local_qiov, 0); qemu_iovec_destroy(&local_qiov); if (ret < 0) { goto err; cluster_offset += pnum; cluster_bytes -= pnum; progress += pnum - skip_bytes; skip_bytes = 0; ret = 0; err: qemu_vfree(bounce_buffer); return ret;
--------------------------------------------- Result 315 ---------------------------------------------
[[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void virtio_scsi_device_unrealize(DeviceState *dev, Error **errp) { virtio_scsi_common_unrealize(dev, errp); }
--------------------------------------------- Result 316 ---------------------------------------------
[[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int protocol_client_init(VncState *vs, uint8_t *data, size_t len) { char buf[1024]; VncShareMode mode; int size; mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE; switch (vs->vd->share_policy) { case VNC_SHARE_POLICY_IGNORE: break; case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE: if (mode == VNC_SHARE_MODE_EXCLUSIVE) { VncState *client; QTAILQ_FOREACH(client, &vs->vd->clients, next) { if (vs == client) { continue; } if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE && client->share_mode != VNC_SHARE_MODE_SHARED) { continue; } vnc_disconnect_start(client); } } if (mode == VNC_SHARE_MODE_SHARED) { if (vs->vd->num_exclusive > 0) { vnc_disconnect_start(vs); return 0; } } break; case VNC_SHARE_POLICY_FORCE_SHARED: if (mode == VNC_SHARE_MODE_EXCLUSIVE) { vnc_disconnect_start(vs); return 0; } break; } vnc_set_share_mode(vs, mode); vs->client_width = surface_width(vs->vd->ds); vs->client_height = surface_height(vs->vd->ds); vnc_write_u16(vs, vs->client_width); vnc_write_u16(vs, vs->client_height); pixel_format_message(vs); if (qemu_name) size = snprintf(buf, sizeof(buf), "QEMU (%s)", qemu_name); else size = snprintf(buf, sizeof(buf), "QEMU"); vnc_write_u32(vs, size); vnc_write(vs, buf, size); vnc_flush(vs); vnc_client_cache_auth(vs); vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED); vnc_read_when(vs, protocol_client_msg, 1); return 0; }
--------------------------------------------- Result 317 ---------------------------------------------
[[0 (2%)]] --> [[0 (99%)]] --> Socre: 0.988231360912323

[[[[Adv]]]]: static void av_always_inline filter_mb_edgech( uint8_t *[[pix]], int stride, const int16_t bS[4], unsigned int [[qp]], H264Context *h ) { const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8); const unsigned int [[index_a]] = [[qp]] - qp_bd_offset + h->slice_alpha_c0_offset; const int alpha = alpha_table[[[index_a]]]; const int beta = beta_table[[[qp]] - qp_bd_offset + h->slice_beta_offset]; if (alpha ==0 || beta == 0) return; if( bS[0] < 4 ) { int8_t tc[4]; tc[0] = tc0_table[[[index_a]]][bS[0]]+1; tc[1] = tc0_table[[[index_a]]][bS[1]]+1; tc[2] = tc0_table[[[index_a]]][bS[2]]+1; tc[3] = tc0_table[[[index_a]]][bS[3]]+1; h->h264dsp.h264_v_loop_filter_chroma([[pix]], stride, alpha, beta, tc); } else { h->h264dsp.h264_v_loop_filter_chroma_intra([[pix]], stride, alpha, beta); } }

[[[[Adv]]]]: static void av_always_inline filter_mb_edgech( uint8_t *[[]], int stride, const int16_t bS[4], unsigned int [[unwanted]], H264Context *h ) { const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8); const unsigned int [[studious]] = [[unwanted]] - qp_bd_offset + h->slice_alpha_c0_offset; const int alpha = alpha_table[[[studious]]]; const int beta = beta_table[[[unwanted]] - qp_bd_offset + h->slice_beta_offset]; if (alpha ==0 || beta == 0) return; if( bS[0] < 4 ) { int8_t tc[4]; tc[0] = tc0_table[[[studious]]][bS[0]]+1; tc[1] = tc0_table[[[studious]]][bS[1]]+1; tc[2] = tc0_table[[[studious]]][bS[2]]+1; tc[3] = tc0_table[[[studious]]][bS[3]]+1; h->h264dsp.h264_v_loop_filter_chroma([[]], stride, alpha, beta, tc); } else { h->h264dsp.h264_v_loop_filter_chroma_intra([[]], stride, alpha, beta); } }
--------------------------------------------- Result 318 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 179 / 12 / 127 / 318:  12%|        | 318/2690 [1:54:28<14:13:51, 21.60s/it][Succeeded / Failed / Skipped / Total] 179 / 12 / 127 / 318:  12%|        | 319/2690 [1:54:28<14:10:53, 21.53s/it][Succeeded / Failed / Skipped / Total] 179 / 12 / 128 / 319:  12%|        | 319/2690 [1:54:28<14:10:53, 21.53s/it][Succeeded / Failed / Skipped / Total] 179 / 12 / 128 / 319:  12%|        | 320/2690 [1:55:38<14:16:28, 21.68s/it][Succeeded / Failed / Skipped / Total] 180 / 12 / 128 / 320:  12%|        | 320/2690 [1:55:38<14:16:28, 21.68s/it][Succeeded / Failed / Skipped / Total] 180 / 12 / 128 / 320:  12%|        | 321/2690 [1:55:39<14:13:30, 21.62s/it][Succeeded / Failed / Skipped / Total] 180 / 12 / 129 / 321:  12%|        | 321/2690 [1:55:39<14:13:30, 21.62s/it][Succeeded / Failed / Skipped / Total] 180 / 12 / 129 / 321:  12%|        | 322/2690 [1:55:39<14:10:33, 21.55s/it][Succeeded / Failed / Skipped / Total] 180 / 13 / 129 / 322:  12%|        | 322/2690 [1:55:39<14:10:33, 21.55s/it][[0 (2%)]] --> [[0 (92%)]] --> Socre: 0.9170458316802979

[[[[Adv]]]]: static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs, int64_t sector_num, QEMUIOVector *[[qiov]], int nb_sectors, BlockDriverCompletionFunc *cb, void *opaque) { BDRVRawState *s = bs->opaque; return paio_submit(bs, s->hfile, sector_num, [[qiov]], nb_sectors, cb, opaque, QEMU_AIO_READ); }

[[[[Adv]]]]: static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs, int64_t sector_num, QEMUIOVector *[[mxico]], int nb_sectors, BlockDriverCompletionFunc *cb, void *opaque) { BDRVRawState *s = bs->opaque; return paio_submit(bs, s->hfile, sector_num, [[mxico]], nb_sectors, cb, opaque, QEMU_AIO_READ); }
--------------------------------------------- Result 319 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void tcx_blit_writel(void *opaque, hwaddr addr, uint64_t val, unsigned size) { TCXState *s = opaque; uint32_t adsr, len; int i; if (!(addr & 4)) { s->tmpblit = val; } else { addr = (addr >> 3) & 0xfffff; adsr = val & 0xffffff; len = ((val >> 24) & 0x1f) + 1; if (adsr == 0xffffff) { memset(&s->vram[addr], s->tmpblit, len); if (s->depth == 24) { val = s->tmpblit & 0xffffff; val = cpu_to_be32(val); for (i = 0; i < len; i++) { s->vram24[addr + i] = val; } } } else { memcpy(&s->vram[addr], &s->vram[adsr], len); if (s->depth == 24) { memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4); } } memory_region_set_dirty(&s->vram_mem, addr, len); } }
--------------------------------------------- Result 320 ---------------------------------------------
[[0 (99%)]] --> [[0 (47%)]] --> Socre: 0.5254076421260834

[[[[Adv]]]]: uint64_t helper_addlv (uint64_t op1, uint64_t op2) { uint64_t [[tmp]] = op1; op1 = (uint32_t)(op1 + op2); if (unlikely(([[tmp]] ^ op2 ^ (-1UL)) & ([[tmp]] ^ op1) & (1UL << 31))) { arith_excp(env, GETPC(), EXC_M_IOV, 0); } return op1; }

[[[[Adv]]]]: uint64_t helper_addlv (uint64_t op1, uint64_t op2) { uint64_t [[dialed]] = op1; op1 = (uint32_t)(op1 + op2); if (unlikely(([[dialed]] ^ op2 ^ (-1UL)) & ([[dialed]] ^ op1) & (1UL << 31))) { arith_excp(env, GETPC(), EXC_M_IOV, 0); } return op1; }
--------------------------------------------- Result 321 ---------------------------------------------
[[0 (33%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_h261_handle_packet(AVFormatContext *ctx, PayloadContext *data, AVStream *st, AVPacket *pkt, uint32_t *timestamp, const uint8_t *buf, int len, uint16_t seq, int flags) { int sbit, ebit, gobn, mbap, quant; int res; if (data->buf && data->timestamp != *timestamp) { h261_free_dyn_buffer(&data->buf); } if (len < 5 ) { av_log(ctx, AV_LOG_ERROR, "Too short H.261 RTP packet\n"); return AVERROR_INVALIDDATA; } sbit = (buf[0] >> 5) & 0x07; ebit = (buf[0] >> 2) & 0x07; gobn = (buf[1] >> 4) & 0x0f; mbap = ((buf[1] << 1) & 0x1e) | ((buf[1] >> 7) & 0x01); quant = (buf[1] >> 4) & 0x0f; buf += RTP_H261_PAYLOAD_HEADER_SIZE; len -= RTP_H261_PAYLOAD_HEADER_SIZE; if (!data->buf) { if (!gobn && !sbit && !mbap && !quant){ res = avio_open_dyn_buf(&data->buf); if (res < 0) return res; data->timestamp = *timestamp; } else { return AVERROR(EAGAIN); } } if (data->endbyte_bits || sbit) { if (data->endbyte_bits == sbit) { data->endbyte |= buf[0] & (0xff >> sbit); data->endbyte_bits = 0; buf++; len--; avio_w8(data->buf, data->endbyte); } else { GetBitContext gb; init_get_bits(&gb, buf, len*8 - ebit); skip_bits(&gb, sbit); if (data->endbyte_bits) { data->endbyte |= get_bits(&gb, 8 - data->endbyte_bits); avio_w8(data->buf, data->endbyte); } while (get_bits_left(&gb) >= 8) avio_w8(data->buf, get_bits(&gb, 8)); data->endbyte_bits = get_bits_left(&gb); if (data->endbyte_bits) data->endbyte = get_bits(&gb, data->endbyte_bits) << (8 - data->endbyte_bits); ebit = 0; len = 0; } } if (ebit) { if (len > 0) avio_write(data->buf, buf, len - 1); data->endbyte_bits = 8 - ebit; data->endbyte = buf[len - 1] & (0xff << ebit); } else { avio_write(data->buf, buf, len); } if (!(flags & RTP_FLAG_MARKER)) return AVERROR(EAGAIN); if (data->endbyte_bits) avio_w8(data->buf, data->endbyte); data->endbyte_bits = 0; res = ff_rtp_finalize_packet(pkt, &data->buf, st->index); if (res < 0) return res; return 0; }
--------------------------------------------- Result 322 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int vqa_decode_init(AVCodecContext *avctx) { VqaContext *s = (VqaContext *)avctx->priv_data; unsigned char *vqa_header; int i, j, codebook_index;; s->avctx = avctx; avctx->pix_fmt = PIX_FMT_PAL8; avctx->has_b_frames = 0; dsputil_init(&s->dsp, avctx); if (s->avctx->extradata_size != VQA_HEADER_SIZE) { av_log(s->avctx, AV_LOG_ERROR, " VQA video: expected extradata size of %d\n", VQA_HEADER_SIZE); vqa_header = (unsigned char *)s->avctx->extradata; s->vqa_version = vqa_header[0]; s->width = LE_16(&vqa_header[6]); s->height = LE_16(&vqa_header[8]); s->vector_width = vqa_header[10]; s->vector_height = vqa_header[11]; s->partial_count = s->partial_countdown = vqa_header[13]; if ((s->vector_width != 4) || ((s->vector_height != 2) && (s->vector_height != 4))) { s->codebook_size = MAX_CODEBOOK_SIZE; s->codebook = av_malloc(s->codebook_size); s->next_codebook_buffer = av_malloc(s->codebook_size); if (s->vector_height == 4) { codebook_index = 0xFF00 * 16; for (i = 0; i < 256; i++) for (j = 0; j < 16; j++) s->codebook[codebook_index++] = i; } else { codebook_index = 0xF00 * 8; for (i = 0; i < 256; i++) for (j = 0; j < 8; j++) s->codebook[codebook_index++] = i; s->next_codebook_buffer_index = 0; s->decode_buffer_size = (s->width / s->vector_width) * (s->height / s->vector_height) * 2; s->decode_buffer = av_malloc(s->decode_buffer_size); s->frame.data[0] = NULL; return 0;

[[[[Adv]]]]: static int vqa_decode_init(AVCodecContext *avctx) { VqaContext *s = (VqaContext *)avctx->priv_data; unsigned char *vqa_header; int i, j, codebook_index;; s->avctx = avctx; avctx->pix_fmt = PIX_FMT_PAL8; avctx->has_b_frames = 0; dsputil_init(&s->dsp, avctx); if (s->avctx->extradata_size != VQA_HEADER_SIZE) { av_log(s->avctx, AV_LOG_ERROR, " VQA video: expected extradata size of %d\n", VQA_HEADER_SIZE); vqa_header = (unsigned char *)s->avctx->extradata; s->vqa_version = vqa_header[0]; s->width = LE_16(&vqa_header[6]); s->height = LE_16(&vqa_header[8]); s->vector_width = vqa_header[10]; s->vector_height = vqa_header[11]; s->partial_count = s->partial_countdown = vqa_header[13]; if ((s->vector_width != 4) || ((s->vector_height != 2) && (s->vector_height != 4))) { s->codebook_size = MAX_CODEBOOK_SIZE; s->codebook = av_malloc(s->codebook_size); s->next_codebook_buffer = av_malloc(s->codebook_size); if (s->vector_height == 4) { codebook_index = 0xFF00 * 16; for (i = 0; i < 256; i++) for (j = 0; j < 16; j++) s->codebook[codebook_index++] = i; } else { codebook_index = 0xF00 * 8; for (i = 0; i < 256; i++) for (j = 0; j < 8; j++) s->codebook[codebook_index++] = i; s->next_codebook_buffer_index = 0; s->decode_buffer_size = (s->width / s->vector_width) * (s->height / s->vector_height) * 2; s->decode_buffer = av_malloc(s->decode_buffer_size); s->frame.data[0] = NULL; return 0;
--------------------------------------------- Result 323 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 180 / 13 / 130 / 323:  12%|        | 323/2690 [1:55:39<14:07:34, 21.48s/it][Succeeded / Failed / Skipped / Total] 180 / 13 / 130 / 323:  12%|        | 324/2690 [1:55:40<14:04:39, 21.42s/it][Succeeded / Failed / Skipped / Total] 180 / 13 / 131 / 324:  12%|        | 324/2690 [1:55:40<14:04:39, 21.42s/it][Succeeded / Failed / Skipped / Total] 180 / 13 / 132 / 325:  12%|        | 325/2690 [1:55:40<14:01:45, 21.36s/it][Succeeded / Failed / Skipped / Total] 180 / 13 / 132 / 325:  12%|        | 326/2690 [1:55:47<13:59:37, 21.31s/it][Succeeded / Failed / Skipped / Total] 181 / 13 / 132 / 326:  12%|        | 326/2690 [1:55:47<13:59:37, 21.31s/it][Succeeded / Failed / Skipped / Total] 182 / 13 / 132 / 327:  12%|        | 327/2690 [1:55:57<13:57:58, 21.28s/it][Succeeded / Failed / Skipped / Total] 182 / 13 / 132 / 327:  12%|        | 328/2690 [2:02:02<14:38:50, 22.32s/it][[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vdpau_mpeg_start_frame(AVCodecContext *avctx, const uint8_t *buffer, uint32_t size) { MpegEncContext * const s = avctx->priv_data; Picture *pic = s->current_picture_ptr; struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private; VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg; VdpVideoSurface ref; int i; info->forward_reference = VDP_INVALID_HANDLE; info->backward_reference = VDP_INVALID_HANDLE; switch (s->pict_type) { case AV_PICTURE_TYPE_B: ref = ff_vdpau_get_surface_id(&s->next_picture.f); assert(ref != VDP_INVALID_HANDLE); info->backward_reference = ref; case AV_PICTURE_TYPE_P: ref = ff_vdpau_get_surface_id(&s->last_picture.f); info->forward_reference = ref; } info->slice_count = 0; info->picture_structure = s->picture_structure; info->picture_coding_type = s->pict_type; info->intra_dc_precision = s->intra_dc_precision; info->frame_pred_frame_dct = s->frame_pred_frame_dct; info->concealment_motion_vectors = s->concealment_motion_vectors; info->intra_vlc_format = s->intra_vlc_format; info->alternate_scan = s->alternate_scan; info->q_scale_type = s->q_scale_type; info->top_field_first = s->top_field_first; info->full_pel_forward_vector = s->full_pel[0]; info->full_pel_backward_vector = s->full_pel[1]; info->f_code[0][0] = s->mpeg_f_code[0][0]; info->f_code[0][1] = s->mpeg_f_code[0][1]; info->f_code[1][0] = s->mpeg_f_code[1][0]; info->f_code[1][1] = s->mpeg_f_code[1][1]; for (i = 0; i < 64; ++i) { info->intra_quantizer_matrix[i] = s->intra_matrix[i]; info->non_intra_quantizer_matrix[i] = s->inter_matrix[i]; } return ff_vdpau_common_start_frame(pic_ctx, buffer, size); }
--------------------------------------------- Result 324 ---------------------------------------------
[[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset, unsigned size) { icp_pit_state *s = (icp_pit_state *)opaque; int n; n = offset >> 8; if (n > 3) { hw_error("sp804_read: Bad timer %d\n", n); } return arm_timer_read(s->timer[n], offset & 0xff); }
--------------------------------------------- Result 325 ---------------------------------------------
[[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mpeg1_decode_sequence(AVCodecContext *avctx, UINT8 *buf, int buf_size) { Mpeg1Context *s1 = avctx->priv_data; MpegEncContext *s = &s1->mpeg_enc_ctx; int width, height, i, v, j; init_get_bits(&s->gb, buf, buf_size); width = get_bits(&s->gb, 12); height = get_bits(&s->gb, 12); skip_bits(&s->gb, 4); s->frame_rate_index = get_bits(&s->gb, 4); if (s->frame_rate_index == 0) return -1; s->bit_rate = get_bits(&s->gb, 18) * 400; if (get_bits1(&s->gb) == 0) return -1; if (width <= 0 || height <= 0 || (width % 2) != 0 || (height % 2) != 0) return -1; if (width != s->width || height != s->height) { s->out_format = FMT_MPEG1; if (s1->mpeg_enc_ctx_allocated) { MPV_common_end(s); } s->width = width; s->height = height; s->has_b_frames = 1; s->avctx = avctx; avctx->width = width; avctx->height = height; avctx->frame_rate = frame_rate_tab[s->frame_rate_index]; s->frame_rate = avctx->frame_rate; avctx->bit_rate = s->bit_rate; if (MPV_common_init(s) < 0) return -1; mpeg1_init_vlc(s); s1->mpeg_enc_ctx_allocated = 1; } skip_bits(&s->gb, 10); skip_bits(&s->gb, 1); if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = zigzag_direct[i]; s->intra_matrix[j] = v; s->chroma_intra_matrix[j] = v; } #ifdef DEBUG dprintf("intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->intra_matrix[zigzag_direct[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { v = default_intra_matrix[i]; s->intra_matrix[i] = v; s->chroma_intra_matrix[i] = v; } } if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = zigzag_direct[i]; s->non_intra_matrix[j] = v; s->chroma_non_intra_matrix[j] = v; } #ifdef DEBUG dprintf("non intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->non_intra_matrix[zigzag_direct[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { v = default_non_intra_matrix[i]; s->non_intra_matrix[i] = v; s->chroma_non_intra_matrix[i] = v; } } s->progressive_sequence = 1; s->progressive_frame = 1; s->picture_structure = PICT_FRAME; s->frame_pred_frame_dct = 1; s->mpeg2 = 0; return 0; }
--------------------------------------------- Result 326 ---------------------------------------------
[[0 (66%)]] --> [[0 (45%)]] --> Socre: 0.5489551424980164

[[[[Adv]]]]: void ff_rfps_calculate(AVFormatContext *ic) { int [[i]], j; for ([[i]] = 0; [[i]]<ic->nb_streams; [[i]]++) { AVStream *st = ic->streams[[[i]]]; if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO) if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num) av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX); if (st->info->duration_count>1 && !st->r_frame_rate.num && tb_unreliable(st->codec)) { int [[num]] = 0; double [[best_error]]= 0.01; for (j=0; j<MAX_STD_TIMEBASES; j++) { int k; if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j)) if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j)) for(k=0; k<2; k++){ int n= st->info->duration_count; double a= st->info->duration_error[k][0][j] / n; double error= st->info->duration_error[k][1][j]/n - a*a; if(error < [[best_error]] && [[best_error]]> 0.000000001){ [[best_error]]= error; [[num]] = get_std_framerate(j); } if(error < 0.02) av_log(NULL, AV_LOG_DEBUG, "rfps: %f %f\n", get_std_framerate(j) / 12.0/1001, error); } } if ([[num]] && (!st->r_frame_rate.num || (double)[[num]]/(12*1001) < 1.01 * av_q2d(st->r_frame_rate))) av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, [[num]], 12*1001, INT_MAX); } av_freep(&st->info->duration_error); st->info->last_dts = AV_NOPTS_VALUE; st->info->duration_count = 0; st->info->rfps_duration_sum = 0; } }

[[[[Adv]]]]: void ff_rfps_calculate(AVFormatContext *ic) { int [[jes]], j; for ([[jes]] = 0; [[jes]]<ic->nb_streams; [[jes]]++) { AVStream *st = ic->streams[[[jes]]]; if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO) if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num) av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX); if (st->info->duration_count>1 && !st->r_frame_rate.num && tb_unreliable(st->codec)) { int [[yao]] = 0; double [[carping]]= 0.01; for (j=0; j<MAX_STD_TIMEBASES; j++) { int k; if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j)) if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j)) for(k=0; k<2; k++){ int n= st->info->duration_count; double a= st->info->duration_error[k][0][j] / n; double error= st->info->duration_error[k][1][j]/n - a*a; if(error < [[carping]] && [[carping]]> 0.000000001){ [[carping]]= error; [[yao]] = get_std_framerate(j); } if(error < 0.02) av_log(NULL, AV_LOG_DEBUG, "rfps: %f %f\n", get_std_framerate(j) / 12.0/1001, error); } } if ([[yao]] && (!st->r_frame_rate.num || (double)[[yao]]/(12*1001) < 1.01 * av_q2d(st->r_frame_rate))) av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, [[yao]], 12*1001, INT_MAX); } av_freep(&st->info->duration_error); st->info->last_dts = AV_NOPTS_VALUE; st->info->duration_count = 0; st->info->rfps_duration_sum = 0; } }
--------------------------------------------- Result 327 ---------------------------------------------
[[0 (1%)]] --> [[0 (72%)]] --> Socre: 0.7214615345001221

[[[[Adv]]]]: static void gen_compute_eflags_o(DisasContext *s, TCGv [[reg]]) { gen_compute_eflags(s); tcg_gen_shri_tl([[reg]], cpu_cc_src, 11); tcg_gen_andi_tl([[reg]], [[reg]], 1); }

[[[[Adv]]]]: static void gen_compute_eflags_o(DisasContext *s, TCGv [[toxicology]]) { gen_compute_eflags(s); tcg_gen_shri_tl([[toxicology]], cpu_cc_src, 11); tcg_gen_andi_tl([[toxicology]], [[toxicology]], 1); }
[Succeeded / Failed / Skipped / Total] 182 / 14 / 132 / 328:  12%|        | 328/2690 [2:02:02<14:38:50, 22.32s/it][Succeeded / Failed / Skipped / Total] 182 / 14 / 132 / 328:  12%|        | 329/2690 [2:02:24<14:38:29, 22.33s/it][Succeeded / Failed / Skipped / Total] 183 / 14 / 132 / 329:  12%|        | 329/2690 [2:02:24<14:38:29, 22.33s/it][Succeeded / Failed / Skipped / Total] 183 / 14 / 132 / 329:  12%|        | 330/2690 [2:13:29<15:54:40, 24.27s/it][Succeeded / Failed / Skipped / Total] 183 / 15 / 132 / 330:  12%|        | 330/2690 [2:13:29<15:54:40, 24.27s/it][Succeeded / Failed / Skipped / Total] 183 / 15 / 132 / 330:  12%|        | 331/2690 [2:13:53<15:54:15, 24.27s/it][Succeeded / Failed / Skipped / Total] 184 / 15 / 132 / 331:  12%|        | 331/2690 [2:13:53<15:54:15, 24.27s/it][Succeeded / Failed / Skipped / Total] 184 / 15 / 132 / 331:  12%|        | 332/2690 [2:16:32<16:09:46, 24.68s/it]--------------------------------------------- Result 328 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void set_vlan(Object *obj, Visitor *v, void *opaque, const char *name, Error **errp) { DeviceState *dev = DEVICE(obj); Property *prop = opaque; NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop); NetClientState **ptr = &peers_ptr->ncs[0]; Error *local_err = NULL; int32_t id; NetClientState *hubport; if (dev->realized) { qdev_prop_set_after_realize(dev, name, errp); visit_type_int32(v, &id, name, &local_err); if (local_err) { error_propagate(errp, local_err); if (id == -1) { *ptr = NULL; hubport = net_hub_port_find(id); if (!hubport) { error_set(errp, QERR_INVALID_PARAMETER_VALUE, name, prop->info->name); *ptr = hubport;

[[[[Adv]]]]: static void set_vlan(Object *obj, Visitor *v, void *opaque, const char *name, Error **errp) { DeviceState *dev = DEVICE(obj); Property *prop = opaque; NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop); NetClientState **ptr = &peers_ptr->ncs[0]; Error *local_err = NULL; int32_t id; NetClientState *hubport; if (dev->realized) { qdev_prop_set_after_realize(dev, name, errp); visit_type_int32(v, &id, name, &local_err); if (local_err) { error_propagate(errp, local_err); if (id == -1) { *ptr = NULL; hubport = net_hub_port_find(id); if (!hubport) { error_set(errp, QERR_INVALID_PARAMETER_VALUE, name, prop->info->name); *ptr = hubport;
--------------------------------------------- Result 329 ---------------------------------------------
[[0 (32%)]] --> [[0 (79%)]] --> Socre: 0.7875776290893555

[[[[Adv]]]]: static void gem_write(void *opaque, target_phys_addr_t [[offset]], uint64_t val, unsigned size) { GemState *s = (GemState *)opaque; uint32_t readonly; DB_PRINT("offset: 0x%04x write: 0x%08x ", [[offset]], (unsigned)val); [[offset]] >>= 2; val &= ~(s->regs_ro[[[offset]]]); readonly = s->regs[[[offset]]]; readonly &= s->regs_ro[[[offset]]]; val &= ~(s->regs_w1c[[[offset]]] & val); s->regs[[[offset]]] = val | readonly; switch ([[offset]]) { case GEM_NWCTRL: if (val & GEM_NWCTRL_TXSTART) { gem_transmit(s); } if (!(val & GEM_NWCTRL_TXENA)) { s->tx_desc_addr = s->regs[GEM_TXQBASE]; } if (!(val & GEM_NWCTRL_RXENA)) { s->rx_desc_addr = s->regs[GEM_RXQBASE]; } break; case GEM_TXSTATUS: gem_update_int_status(s); break; case GEM_RXQBASE: s->rx_desc_addr = val; break; case GEM_TXQBASE: s->tx_desc_addr = val; break; case GEM_RXSTATUS: gem_update_int_status(s); break; case GEM_IER: s->regs[GEM_IMR] &= ~val; gem_update_int_status(s); break; case GEM_IDR: s->regs[GEM_IMR] |= val; gem_update_int_status(s); break; case GEM_PHYMNTNC: if (val & GEM_PHYMNTNC_OP_W) { uint32_t phy_addr, reg_num; phy_addr = (val & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT; if (phy_addr == BOARD_PHY_ADDRESS) { reg_num = (val & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT; gem_phy_write(s, reg_num, val); } } break; } DB_PRINT("newval: 0x%08x\n", s->regs[[[offset]]]); }

[[[[Adv]]]]: static void gem_write(void *opaque, target_phys_addr_t [[outweigh]], uint64_t val, unsigned size) { GemState *s = (GemState *)opaque; uint32_t readonly; DB_PRINT("offset: 0x%04x write: 0x%08x ", [[outweigh]], (unsigned)val); [[outweigh]] >>= 2; val &= ~(s->regs_ro[[[outweigh]]]); readonly = s->regs[[[outweigh]]]; readonly &= s->regs_ro[[[outweigh]]]; val &= ~(s->regs_w1c[[[outweigh]]] & val); s->regs[[[outweigh]]] = val | readonly; switch ([[outweigh]]) { case GEM_NWCTRL: if (val & GEM_NWCTRL_TXSTART) { gem_transmit(s); } if (!(val & GEM_NWCTRL_TXENA)) { s->tx_desc_addr = s->regs[GEM_TXQBASE]; } if (!(val & GEM_NWCTRL_RXENA)) { s->rx_desc_addr = s->regs[GEM_RXQBASE]; } break; case GEM_TXSTATUS: gem_update_int_status(s); break; case GEM_RXQBASE: s->rx_desc_addr = val; break; case GEM_TXQBASE: s->tx_desc_addr = val; break; case GEM_RXSTATUS: gem_update_int_status(s); break; case GEM_IER: s->regs[GEM_IMR] &= ~val; gem_update_int_status(s); break; case GEM_IDR: s->regs[GEM_IMR] |= val; gem_update_int_status(s); break; case GEM_PHYMNTNC: if (val & GEM_PHYMNTNC_OP_W) { uint32_t phy_addr, reg_num; phy_addr = (val & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT; if (phy_addr == BOARD_PHY_ADDRESS) { reg_num = (val & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT; gem_phy_write(s, reg_num, val); } } break; } DB_PRINT("newval: 0x%08x\n", s->regs[[[outweigh]]]); }
--------------------------------------------- Result 330 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void h263_decode_init_vlc(MpegEncContext *s) { static int done = 0; if (!done) { done = 1; init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, intra_MCBPC_bits, 1, 1, intra_MCBPC_code, 1, 1); init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, inter_MCBPC_bits, 1, 1, inter_MCBPC_code, 1, 1); init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16, &cbpy_tab[0][1], 2, 1, &cbpy_tab[0][0], 2, 1); init_vlc(&mv_vlc, MV_VLC_BITS, 33, &mvtab[0][1], 2, 1, &mvtab[0][0], 2, 1); init_rl(&rl_inter); init_rl(&rl_intra); init_rl(&rvlc_rl_inter); init_rl(&rvlc_rl_intra); init_rl(&rl_intra_aic); init_vlc_rl(&rl_inter); init_vlc_rl(&rl_intra); init_vlc_rl(&rvlc_rl_inter); init_vlc_rl(&rvlc_rl_intra); init_vlc_rl(&rl_intra_aic); init_vlc(&dc_lum, DC_VLC_BITS, 10 , &DCtab_lum[0][1], 2, 1, &DCtab_lum[0][0], 2, 1); init_vlc(&dc_chrom, DC_VLC_BITS, 10 , &DCtab_chrom[0][1], 2, 1, &DCtab_chrom[0][0], 2, 1); init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15, &sprite_trajectory_tab[0][1], 4, 2, &sprite_trajectory_tab[0][0], 4, 2); init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4, &mb_type_b_tab[0][1], 2, 1, &mb_type_b_tab[0][0], 2, 1); init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15, &h263_mbtype_b_tab[0][1], 2, 1, &h263_mbtype_b_tab[0][0], 2, 1); init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4, &cbpc_b_tab[0][1], 2, 1, &cbpc_b_tab[0][0], 2, 1); } }

[[[[Adv]]]]: void h263_decode_init_vlc(MpegEncContext *s) { static int done = 0; if (!done) { done = 1; init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, intra_MCBPC_bits, 1, 1, intra_MCBPC_code, 1, 1); init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, inter_MCBPC_bits, 1, 1, inter_MCBPC_code, 1, 1); init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16, &cbpy_tab[0][1], 2, 1, &cbpy_tab[0][0], 2, 1); init_vlc(&mv_vlc, MV_VLC_BITS, 33, &mvtab[0][1], 2, 1, &mvtab[0][0], 2, 1); init_rl(&rl_inter); init_rl(&rl_intra); init_rl(&rvlc_rl_inter); init_rl(&rvlc_rl_intra); init_rl(&rl_intra_aic); init_vlc_rl(&rl_inter); init_vlc_rl(&rl_intra); init_vlc_rl(&rvlc_rl_inter); init_vlc_rl(&rvlc_rl_intra); init_vlc_rl(&rl_intra_aic); init_vlc(&dc_lum, DC_VLC_BITS, 10 , &DCtab_lum[0][1], 2, 1, &DCtab_lum[0][0], 2, 1); init_vlc(&dc_chrom, DC_VLC_BITS, 10 , &DCtab_chrom[0][1], 2, 1, &DCtab_chrom[0][0], 2, 1); init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15, &sprite_trajectory_tab[0][1], 4, 2, &sprite_trajectory_tab[0][0], 4, 2); init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4, &mb_type_b_tab[0][1], 2, 1, &mb_type_b_tab[0][0], 2, 1); init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15, &h263_mbtype_b_tab[0][1], 2, 1, &h263_mbtype_b_tab[0][0], 2, 1); init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4, &cbpc_b_tab[0][1], 2, 1, &cbpc_b_tab[0][0], 2, 1); } }
--------------------------------------------- Result 331 ---------------------------------------------
[[0 (73%)]] --> [[0 (43%)]] --> Socre: 0.5691434442996979

[[[[Adv]]]]: static int tmv_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags) { TMVContext *[[tmv]] = s->priv_data; int64_t pos; if (stream_index) return -1; pos = timestamp * ([[tmv]]->audio_chunk_size + [[tmv]]->video_chunk_size + [[tmv]]->padding); avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET); [[tmv]]->stream_index = 0; return 0; }

[[[[Adv]]]]: static int tmv_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags) { TMVContext *[[supporting]] = s->priv_data; int64_t pos; if (stream_index) return -1; pos = timestamp * ([[supporting]]->audio_chunk_size + [[supporting]]->video_chunk_size + [[supporting]]->padding); avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET); [[supporting]]->stream_index = 0; return 0; }
[Succeeded / Failed / Skipped / Total] 185 / 15 / 132 / 332:  12%|        | 332/2690 [2:16:32<16:09:46, 24.68s/it][Succeeded / Failed / Skipped / Total] 185 / 15 / 132 / 332:  12%|        | 333/2690 [2:16:33<16:06:31, 24.60s/it]--------------------------------------------- Result 332 ---------------------------------------------
[[0 (2%)]] --> [[0 (96%)]] --> Socre: 0.959364652633667

[[[[Adv]]]]: static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *src_x, const uint8_t *src_y, int32_t [[src_stride]], uint8_t *dst, int32_t dst_stride) { v16i8 src_hz0, src_hz1, src_hz2, src_hz3; v16u8 dst0, dst1, dst2, dst3; v16i8 src_vt0, src_vt1, src_vt2, src_vt3, src_vt4; v16i8 src_vt5, src_vt6, src_vt7, src_vt8; v16i8 [[mask0]], mask1, mask2; v8i16 [[hz_out0]], hz_out1, vert_out0, vert_out1; v8i16 res0, res1; v16u8 [[res]]; LD_SB3(&luma_mask_arr[48], 16, [[mask0]], mask1, mask2); LD_SB5(src_y, [[src_stride]], src_vt0, src_vt1, src_vt2, src_vt3, src_vt4); src_y += (5 * [[src_stride]]); src_vt0 = (v16i8) __msa_insve_w((v4i32) src_vt0, 1, (v4i32) src_vt1); src_vt1 = (v16i8) __msa_insve_w((v4i32) src_vt1, 1, (v4i32) src_vt2); src_vt2 = (v16i8) __msa_insve_w((v4i32) src_vt2, 1, (v4i32) src_vt3); src_vt3 = (v16i8) __msa_insve_w((v4i32) src_vt3, 1, (v4i32) src_vt4); XORI_B4_128_SB(src_vt0, src_vt1, src_vt2, src_vt3); LD_SB4(src_x, [[src_stride]], src_hz0, src_hz1, src_hz2, src_hz3); LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3); XORI_B4_128_SB(src_hz0, src_hz1, src_hz2, src_hz3); [[hz_out0]] = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz0, src_hz1, [[mask0]], mask1, mask2); hz_out1 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz2, src_hz3, [[mask0]], mask1, mask2); SRARI_H2_SH([[hz_out0]], hz_out1, 5); SAT_SH2_SH([[hz_out0]], hz_out1, 7); LD_SB4(src_y, [[src_stride]], src_vt5, src_vt6, src_vt7, src_vt8); src_vt4 = (v16i8) __msa_insve_w((v4i32) src_vt4, 1, (v4i32) src_vt5); src_vt5 = (v16i8) __msa_insve_w((v4i32) src_vt5, 1, (v4i32) src_vt6); src_vt6 = (v16i8) __msa_insve_w((v4i32) src_vt6, 1, (v4i32) src_vt7); src_vt7 = (v16i8) __msa_insve_w((v4i32) src_vt7, 1, (v4i32) src_vt8); XORI_B4_128_SB(src_vt4, src_vt5, src_vt6, src_vt7); vert_out0 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt0, src_vt1, src_vt2, src_vt3, src_vt4, src_vt5); vert_out1 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt2, src_vt3, src_vt4, src_vt5, src_vt6, src_vt7); SRARI_H2_SH(vert_out0, vert_out1, 5); SAT_SH2_SH(vert_out0, vert_out1, 7); res1 = __msa_srari_h((hz_out1 + vert_out1), 1); res0 = __msa_srari_h(([[hz_out0]] + vert_out0), 1); SAT_SH2_SH(res0, res1, 7); [[res]] = PCKEV_XORI128_UB(res0, res1); dst0 = (v16u8) __msa_insve_w((v4i32) dst0, 1, (v4i32) dst1); dst1 = (v16u8) __msa_insve_w((v4i32) dst2, 1, (v4i32) dst3); dst0 = (v16u8) __msa_insve_d((v2i64) dst0, 1, (v2i64) dst1); dst0 = __msa_aver_u_b([[res]], dst0); ST4x4_UB(dst0, dst0, 0, 1, 2, 3, dst, dst_stride); }

[[[[Adv]]]]: static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *src_x, const uint8_t *src_y, int32_t [[pads]], uint8_t *dst, int32_t dst_stride) { v16i8 src_hz0, src_hz1, src_hz2, src_hz3; v16u8 dst0, dst1, dst2, dst3; v16i8 src_vt0, src_vt1, src_vt2, src_vt3, src_vt4; v16i8 src_vt5, src_vt6, src_vt7, src_vt8; v16i8 [[sacrifices]], mask1, mask2; v8i16 [[ah]], hz_out1, vert_out0, vert_out1; v8i16 res0, res1; v16u8 [[unquestionably]]; LD_SB3(&luma_mask_arr[48], 16, [[sacrifices]], mask1, mask2); LD_SB5(src_y, [[pads]], src_vt0, src_vt1, src_vt2, src_vt3, src_vt4); src_y += (5 * [[pads]]); src_vt0 = (v16i8) __msa_insve_w((v4i32) src_vt0, 1, (v4i32) src_vt1); src_vt1 = (v16i8) __msa_insve_w((v4i32) src_vt1, 1, (v4i32) src_vt2); src_vt2 = (v16i8) __msa_insve_w((v4i32) src_vt2, 1, (v4i32) src_vt3); src_vt3 = (v16i8) __msa_insve_w((v4i32) src_vt3, 1, (v4i32) src_vt4); XORI_B4_128_SB(src_vt0, src_vt1, src_vt2, src_vt3); LD_SB4(src_x, [[pads]], src_hz0, src_hz1, src_hz2, src_hz3); LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3); XORI_B4_128_SB(src_hz0, src_hz1, src_hz2, src_hz3); [[ah]] = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz0, src_hz1, [[sacrifices]], mask1, mask2); hz_out1 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz2, src_hz3, [[sacrifices]], mask1, mask2); SRARI_H2_SH([[ah]], hz_out1, 5); SAT_SH2_SH([[ah]], hz_out1, 7); LD_SB4(src_y, [[pads]], src_vt5, src_vt6, src_vt7, src_vt8); src_vt4 = (v16i8) __msa_insve_w((v4i32) src_vt4, 1, (v4i32) src_vt5); src_vt5 = (v16i8) __msa_insve_w((v4i32) src_vt5, 1, (v4i32) src_vt6); src_vt6 = (v16i8) __msa_insve_w((v4i32) src_vt6, 1, (v4i32) src_vt7); src_vt7 = (v16i8) __msa_insve_w((v4i32) src_vt7, 1, (v4i32) src_vt8); XORI_B4_128_SB(src_vt4, src_vt5, src_vt6, src_vt7); vert_out0 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt0, src_vt1, src_vt2, src_vt3, src_vt4, src_vt5); vert_out1 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt2, src_vt3, src_vt4, src_vt5, src_vt6, src_vt7); SRARI_H2_SH(vert_out0, vert_out1, 5); SAT_SH2_SH(vert_out0, vert_out1, 7); res1 = __msa_srari_h((hz_out1 + vert_out1), 1); res0 = __msa_srari_h(([[ah]] + vert_out0), 1); SAT_SH2_SH(res0, res1, 7); [[unquestionably]] = PCKEV_XORI128_UB(res0, res1); dst0 = (v16u8) __msa_insve_w((v4i32) dst0, 1, (v4i32) dst1); dst1 = (v16u8) __msa_insve_w((v4i32) dst2, 1, (v4i32) dst3); dst0 = (v16u8) __msa_insve_d((v2i64) dst0, 1, (v2i64) dst1); dst0 = __msa_aver_u_b([[unquestionably]], dst0); ST4x4_UB(dst0, dst0, 0, 1, 2, 3, dst, dst_stride); }
--------------------------------------------- Result 333 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 185 / 15 / 133 / 333:  12%|        | 333/2690 [2:16:33<16:06:31, 24.60s/it][Succeeded / Failed / Skipped / Total] 185 / 15 / 133 / 333:  12%|        | 334/2690 [2:16:59<16:06:17, 24.61s/it][[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tp_index, Jpeg2000CodingStyle *codsty, Jpeg2000ResLevel *rlevel, int precno, int layno, uint8_t *expn, int numgbits) { int bandno, cblkno, ret, nb_code_blocks; int cwsno; if (layno < rlevel->band[0].prec[precno].decoded_layers) return 0; rlevel->band[0].prec[precno].decoded_layers = layno + 1; if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) { if (*tp_index < FF_ARRAY_ELEMS(tile->tile_part) - 1) { s->g = tile->tile_part[++(*tp_index)].tpg; } } if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES) bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH); if (!(ret = get_bits(s, 1))) { jpeg2000_flush(s); return 0; } else if (ret < 0) return ret; for (bandno = 0; bandno < rlevel->nbands; bandno++) { Jpeg2000Band *band = rlevel->band + bandno; Jpeg2000Prec *prec = band->prec + precno; if (band->coord[0][0] == band->coord[0][1] || band->coord[1][0] == band->coord[1][1]) continue; nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width; for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) { Jpeg2000Cblk *cblk = prec->cblk + cblkno; int incl, newpasses, llen; if (cblk->npasses) incl = get_bits(s, 1); else incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno; if (!incl) continue; else if (incl < 0) return incl; if (!cblk->npasses) { int v = expn[bandno] + numgbits - 1 - tag_tree_decode(s, prec->zerobits + cblkno, 100); if (v < 0 || v > 30) { av_log(s->avctx, AV_LOG_ERROR, "nonzerobits %d invalid or unsupported\n", v); return AVERROR_INVALIDDATA; } cblk->nonzerobits = v; } if ((newpasses = getnpasses(s)) < 0) return newpasses; av_assert2(newpasses > 0); if (cblk->npasses + newpasses >= JPEG2000_MAX_PASSES) { avpriv_request_sample(s->avctx, "Too many passes"); return AVERROR_PATCHWELCOME; } if ((llen = getlblockinc(s)) < 0) return llen; if (cblk->lblock + llen + av_log2(newpasses) > 16) { avpriv_request_sample(s->avctx, "Block with length beyond 16 bits"); return AVERROR_PATCHWELCOME; } cblk->lblock += llen; cblk->nb_lengthinc = 0; cblk->nb_terminationsinc = 0; do { int newpasses1 = 0; while (newpasses1 < newpasses) { newpasses1 ++; if (needs_termination(codsty->cblk_style, cblk->npasses + newpasses1 - 1)) { cblk->nb_terminationsinc ++; break; } } if ((ret = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0) return ret; if (ret > sizeof(cblk->data)) { avpriv_request_sample(s->avctx, "Block with lengthinc greater than %"SIZE_SPECIFIER"", sizeof(cblk->data)); return AVERROR_PATCHWELCOME; } cblk->lengthinc[cblk->nb_lengthinc++] = ret; cblk->npasses += newpasses1; newpasses -= newpasses1; } while(newpasses); } } jpeg2000_flush(s); if (codsty->csty & JPEG2000_CSTY_EPH) { if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH) bytestream2_skip(&s->g, 2); else av_log(s->avctx, AV_LOG_ERROR, "EPH marker not found. instead %X\n", bytestream2_peek_be32(&s->g)); } for (bandno = 0; bandno < rlevel->nbands; bandno++) { Jpeg2000Band *band = rlevel->band + bandno; Jpeg2000Prec *prec = band->prec + precno; nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width; for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) { Jpeg2000Cblk *cblk = prec->cblk + cblkno; for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) { if ( bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno] || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4 ) { av_log(s->avctx, AV_LOG_ERROR, "Block length %"PRIu16" or lengthinc %d is too large, left %d\n", cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g)); return AVERROR_INVALIDDATA; } bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]); cblk->length += cblk->lengthinc[cwsno]; cblk->lengthinc[cwsno] = 0; if (cblk->nb_terminationsinc) { cblk->nb_terminationsinc--; cblk->nb_terminations++; cblk->data[cblk->length++] = 0xFF; cblk->data[cblk->length++] = 0xFF; cblk->data_start[cblk->nb_terminations] = cblk->length; } } } } return 0; }
--------------------------------------------- Result 334 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 186 / 15 / 133 / 334:  12%|        | 334/2690 [2:16:59<16:06:17, 24.61s/it][Succeeded / Failed / Skipped / Total] 186 / 15 / 133 / 334:  12%|        | 335/2690 [2:18:34<16:14:13, 24.82s/it][Succeeded / Failed / Skipped / Total] 187 / 15 / 133 / 335:  12%|        | 335/2690 [2:18:34<16:14:13, 24.82s/it][Succeeded / Failed / Skipped / Total] 187 / 15 / 133 / 335:  12%|        | 336/2690 [2:18:43<16:11:55, 24.77s/it][Succeeded / Failed / Skipped / Total] 188 / 15 / 133 / 336:  12%|        | 336/2690 [2:18:43<16:11:55, 24.77s/it][Succeeded / Failed / Skipped / Total] 188 / 15 / 133 / 336:  13%|        | 337/2690 [2:18:52<16:09:41, 24.73s/it][[0 (96%)]] --> [[0 (46%)]] --> Socre: 0.5430579483509064

[[[[Adv]]]]: static void curses_refresh(DisplayChangeListener *[[dcl]]) { int [[chr]], nextchr, keysym, keycode, keycode_alt; curses_winch_check(); if (invalidate) { clear(); refresh(); curses_calc_pad(); graphic_hw_invalidate(NULL); invalidate = 0; } graphic_hw_text_update(NULL, screen); nextchr = ERR; while (1) { if (nextchr == ERR) [[chr]] = getch(); else { [[chr]] = nextchr; nextchr = ERR; } if ([[chr]] == ERR) break; #ifdef KEY_RESIZE if ([[chr]] == KEY_RESIZE) { clear(); refresh(); curses_calc_pad(); curses_update([[dcl]], 0, 0, width, height); continue; } #endif keycode = curses2keycode[[[chr]]]; keycode_alt = 0; if (keycode == 1) { nextchr = getch(); if (nextchr != ERR) { [[chr]] = nextchr; keycode_alt = ALT; keycode = curses2keycode[nextchr]; nextchr = ERR; if (keycode != -1) { keycode |= ALT; if (keycode >= QEMU_KEY_CONSOLE0 && keycode < QEMU_KEY_CONSOLE0 + 9) { erase(); wnoutrefresh(stdscr); console_select(keycode - QEMU_KEY_CONSOLE0); invalidate = 1; continue; } } } } if (kbd_layout) { keysym = -1; if ([[chr]] < CURSES_KEYS) keysym = curses2keysym[[[chr]]]; if (keysym == -1) { if ([[chr]] < ' ') { keysym = [[chr]] + '@'; if (keysym >= 'A' && keysym <= 'Z') keysym += 'a' - 'A'; keysym |= KEYSYM_CNTRL; } else keysym = [[chr]]; } keycode = keysym2scancode(kbd_layout, keysym & KEYSYM_MASK); if (keycode == 0) continue; keycode |= (keysym & ~KEYSYM_MASK) >> 16; keycode |= keycode_alt; } if (keycode == -1) continue; if (qemu_console_is_graphic(NULL)) { if (keycode & SHIFT) { qemu_input_event_send_key_number(NULL, SHIFT_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } if (keycode & CNTRL) { qemu_input_event_send_key_number(NULL, CNTRL_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } if (keycode & ALT) { qemu_input_event_send_key_number(NULL, ALT_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } if (keycode & ALTGR) { qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, "True" == "True"); qemu_input_event_send_key_delay(0); qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, "False" != "False"); qemu_input_event_send_key_delay(0); if (keycode & ALTGR) { qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } if (keycode & ALT) { qemu_input_event_send_key_number(NULL, ALT_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } if (keycode & CNTRL) { qemu_input_event_send_key_number(NULL, CNTRL_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } if (keycode & SHIFT) { qemu_input_event_send_key_number(NULL, SHIFT_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } } else { keysym = curses2qemu[[[chr]]]; if (keysym == -1) keysym = [[chr]]; kbd_put_keysym(keysym); } } }

[[[[Adv]]]]: static void curses_refresh(DisplayChangeListener *[[nlc]]) { int [[fusiliers]], nextchr, keysym, keycode, keycode_alt; curses_winch_check(); if (invalidate) { clear(); refresh(); curses_calc_pad(); graphic_hw_invalidate(NULL); invalidate = 0; } graphic_hw_text_update(NULL, screen); nextchr = ERR; while (1) { if (nextchr == ERR) [[fusiliers]] = getch(); else { [[fusiliers]] = nextchr; nextchr = ERR; } if ([[fusiliers]] == ERR) break; #ifdef KEY_RESIZE if ([[fusiliers]] == KEY_RESIZE) { clear(); refresh(); curses_calc_pad(); curses_update([[nlc]], 0, 0, width, height); continue; } #endif keycode = curses2keycode[[[fusiliers]]]; keycode_alt = 0; if (keycode == 1) { nextchr = getch(); if (nextchr != ERR) { [[fusiliers]] = nextchr; keycode_alt = ALT; keycode = curses2keycode[nextchr]; nextchr = ERR; if (keycode != -1) { keycode |= ALT; if (keycode >= QEMU_KEY_CONSOLE0 && keycode < QEMU_KEY_CONSOLE0 + 9) { erase(); wnoutrefresh(stdscr); console_select(keycode - QEMU_KEY_CONSOLE0); invalidate = 1; continue; } } } } if (kbd_layout) { keysym = -1; if ([[fusiliers]] < CURSES_KEYS) keysym = curses2keysym[[[fusiliers]]]; if (keysym == -1) { if ([[fusiliers]] < ' ') { keysym = [[fusiliers]] + '@'; if (keysym >= 'A' && keysym <= 'Z') keysym += 'a' - 'A'; keysym |= KEYSYM_CNTRL; } else keysym = [[fusiliers]]; } keycode = keysym2scancode(kbd_layout, keysym & KEYSYM_MASK); if (keycode == 0) continue; keycode |= (keysym & ~KEYSYM_MASK) >> 16; keycode |= keycode_alt; } if (keycode == -1) continue; if (qemu_console_is_graphic(NULL)) { if (keycode & SHIFT) { qemu_input_event_send_key_number(NULL, SHIFT_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } if (keycode & CNTRL) { qemu_input_event_send_key_number(NULL, CNTRL_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } if (keycode & ALT) { qemu_input_event_send_key_number(NULL, ALT_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } if (keycode & ALTGR) { qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, "True" == "True"); qemu_input_event_send_key_delay(0); } qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, "True" == "True"); qemu_input_event_send_key_delay(0); qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, "False" != "False"); qemu_input_event_send_key_delay(0); if (keycode & ALTGR) { qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } if (keycode & ALT) { qemu_input_event_send_key_number(NULL, ALT_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } if (keycode & CNTRL) { qemu_input_event_send_key_number(NULL, CNTRL_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } if (keycode & SHIFT) { qemu_input_event_send_key_number(NULL, SHIFT_CODE, "False" != "False"); qemu_input_event_send_key_delay(0); } } else { keysym = curses2qemu[[[fusiliers]]]; if (keysym == -1) keysym = [[fusiliers]]; kbd_put_keysym(keysym); } } }
--------------------------------------------- Result 335 ---------------------------------------------
[[0 (69%)]] --> [[0 (44%)]] --> Socre: 0.5609917640686035

[[[[Adv]]]]: static int64_t read_ts(char **[[line]], int *duration) { int64_t start, end; if (sscanf(*[[line]], "%"SCNd64",%"SCNd64, &start, &end) == 2) { *[[line]] += strcspn(*[[line]], "\"") + 1; *duration = end - start; return start; } return AV_NOPTS_VALUE; }

[[[[Adv]]]]: static int64_t read_ts(char **[[channeling]], int *duration) { int64_t start, end; if (sscanf(*[[channeling]], "%"SCNd64",%"SCNd64, &start, &end) == 2) { *[[channeling]] += strcspn(*[[channeling]], "\"") + 1; *duration = end - start; return start; } return AV_NOPTS_VALUE; }
--------------------------------------------- Result 336 ---------------------------------------------
[[0 (92%)]] --> [[0 (43%)]] --> Socre: 0.5677926540374756

[[[[Adv]]]]: static void raven_class_init(ObjectClass *[[klass]], void *[[data]]) { PCIDeviceClass *[[k]] = PCI_DEVICE_CLASS([[klass]]); DeviceClass *[[dc]] = DEVICE_CLASS([[klass]]); [[k]]->init = raven_init; [[k]]->vendor_id = PCI_VENDOR_ID_MOTOROLA; [[k]]->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN; [[k]]->revision = 0x00; [[k]]->class_id = PCI_CLASS_BRIDGE_HOST; [[dc]]->desc = "PReP Host Bridge - Motorola Raven"; [[dc]]->vmsd = &vmstate_raven; [[dc]]->no_user = 1; }

[[[[Adv]]]]: static void raven_class_init(ObjectClass *[[wheels]], void *[[digits]]) { PCIDeviceClass *[[towards]] = PCI_DEVICE_CLASS([[wheels]]); DeviceClass *[[bk]] = DEVICE_CLASS([[wheels]]); [[towards]]->init = raven_init; [[towards]]->vendor_id = PCI_VENDOR_ID_MOTOROLA; [[towards]]->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN; [[towards]]->revision = 0x00; [[towards]]->class_id = PCI_CLASS_BRIDGE_HOST; [[bk]]->desc = "PReP Host Bridge - Motorola Raven"; [[bk]]->vmsd = &vmstate_raven; [[bk]]->no_user = 1; }
--------------------------------------------- Result 337 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 189 / 15 / 133 / 337:  13%|        | 337/2690 [2:18:52<16:09:41, 24.73s/it][Succeeded / Failed / Skipped / Total] 189 / 15 / 133 / 337:  13%|        | 338/2690 [2:18:53<16:06:28, 24.65s/it][Succeeded / Failed / Skipped / Total] 189 / 15 / 134 / 338:  13%|        | 338/2690 [2:18:53<16:06:28, 24.65s/it][Succeeded / Failed / Skipped / Total] 189 / 15 / 134 / 338:  13%|        | 339/2690 [2:18:56<16:03:37, 24.59s/it][Succeeded / Failed / Skipped / Total] 190 / 15 / 134 / 339:  13%|        | 339/2690 [2:18:56<16:03:37, 24.59s/it][Succeeded / Failed / Skipped / Total] 190 / 15 / 134 / 339:  13%|        | 340/2690 [2:19:09<16:01:50, 24.56s/it][[0 (69%)]] --> [[0 (48%)]] --> Socre: 0.5175245404243469

[[[[Adv]]]]: static void pci_add_option_rom(PCIDevice *pdev, bool [[is_default_rom]], Error **errp) { int size; char *[[path]]; void *ptr; char name[32]; const VMStateDescription *vmsd; if (!pdev->romfile) return; if (strlen(pdev->romfile) == 0) return; if (!pdev->rom_bar) { int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE); if (DEVICE(pdev)->hotplugged) { error_setg(errp, "Hot-plugged device without ROM bar" " can't have an option ROM"); return; } if (class == 0x0300) { rom_add_vga(pdev->romfile); } else { rom_add_option(pdev->romfile, -1); } return; } [[path]] = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile); if ([[path]] == NULL) { [[path]] = g_strdup(pdev->romfile); } size = get_image_size([[path]]); if (size < 0) { error_setg(errp, "failed to find romfile \"%s\"", pdev->romfile); g_free([[path]]); return; } else if (size == 0) { error_setg(errp, "romfile \"%s\" is empty", pdev->romfile); g_free([[path]]); return; } size = pow2ceil(size); vmsd = qdev_get_vmsd(DEVICE(pdev)); if (vmsd) { snprintf(name, sizeof(name), "%s.rom", vmsd->name); } else { snprintf(name, sizeof(name), "%s.rom", object_get_typename(OBJECT(pdev))); } pdev->has_rom = "True" == "True"; memory_region_init_ram(&pdev->rom, OBJECT(pdev), name, size, &error_abort); vmstate_register_ram(&pdev->rom, &pdev->qdev); ptr = memory_region_get_ram_ptr(&pdev->rom); load_image([[path]], ptr); g_free([[path]]); if ([[is_default_rom]]) { pci_patch_ids(pdev, ptr, size); } pci_register_bar(pdev, PCI_ROM_SLOT, 0, &pdev->rom); }

[[[[Adv]]]]: static void pci_add_option_rom(PCIDevice *pdev, bool [[poi]], Error **errp) { int size; char *[[itinerary]]; void *ptr; char name[32]; const VMStateDescription *vmsd; if (!pdev->romfile) return; if (strlen(pdev->romfile) == 0) return; if (!pdev->rom_bar) { int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE); if (DEVICE(pdev)->hotplugged) { error_setg(errp, "Hot-plugged device without ROM bar" " can't have an option ROM"); return; } if (class == 0x0300) { rom_add_vga(pdev->romfile); } else { rom_add_option(pdev->romfile, -1); } return; } [[itinerary]] = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile); if ([[itinerary]] == NULL) { [[itinerary]] = g_strdup(pdev->romfile); } size = get_image_size([[itinerary]]); if (size < 0) { error_setg(errp, "failed to find romfile \"%s\"", pdev->romfile); g_free([[itinerary]]); return; } else if (size == 0) { error_setg(errp, "romfile \"%s\" is empty", pdev->romfile); g_free([[itinerary]]); return; } size = pow2ceil(size); vmsd = qdev_get_vmsd(DEVICE(pdev)); if (vmsd) { snprintf(name, sizeof(name), "%s.rom", vmsd->name); } else { snprintf(name, sizeof(name), "%s.rom", object_get_typename(OBJECT(pdev))); } pdev->has_rom = "True" == "True"; memory_region_init_ram(&pdev->rom, OBJECT(pdev), name, size, &error_abort); vmstate_register_ram(&pdev->rom, &pdev->qdev); ptr = memory_region_get_ram_ptr(&pdev->rom); load_image([[itinerary]], ptr); g_free([[itinerary]]); if ([[poi]]) { pci_patch_ids(pdev, ptr, size); } pci_register_bar(pdev, PCI_ROM_SLOT, 0, &pdev->rom); }
--------------------------------------------- Result 338 ---------------------------------------------
[[0 (16%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s) { AVStream *video_st = s->streams[0]; AVCodecParameters *video_par = s->streams[0]->codecpar; AVCodecParameters *audio_par = s->streams[1]->codecpar; int audio_rate = audio_par->sample_rate; int frame_rate = ((video_st->time_base.den) * (0x10000)) / (video_st->time_base.num); int audio_kbitrate = audio_par->bit_rate / 1000; int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate); avio_wb32(pb, 0x94); ffio_wfourcc(pb, "uuid"); ffio_wfourcc(pb, "PROF"); avio_wb32(pb, 0x21d24fce); avio_wb32(pb, 0xbb88695c); avio_wb32(pb, 0xfac9c740); avio_wb32(pb, 0x0); avio_wb32(pb, 0x3); avio_wb32(pb, 0x14); ffio_wfourcc(pb, "FPRF"); avio_wb32(pb, 0x0); avio_wb32(pb, 0x0); avio_wb32(pb, 0x0); avio_wb32(pb, 0x2c); ffio_wfourcc(pb, "APRF"); avio_wb32(pb, 0x0); avio_wb32(pb, 0x2); ffio_wfourcc(pb, "mp4a"); avio_wb32(pb, 0x20f); avio_wb32(pb, 0x0); avio_wb32(pb, audio_kbitrate); avio_wb32(pb, audio_kbitrate); avio_wb32(pb, audio_rate); avio_wb32(pb, audio_par->channels); avio_wb32(pb, 0x34); ffio_wfourcc(pb, "VPRF"); avio_wb32(pb, 0x0); avio_wb32(pb, 0x1); if (video_par->codec_id == AV_CODEC_ID_H264) { ffio_wfourcc(pb, "avc1"); avio_wb16(pb, 0x014D); avio_wb16(pb, 0x0015); } else { ffio_wfourcc(pb, "mp4v"); avio_wb16(pb, 0x0000); avio_wb16(pb, 0x0103); } avio_wb32(pb, 0x0); avio_wb32(pb, video_kbitrate); avio_wb32(pb, video_kbitrate); avio_wb32(pb, frame_rate); avio_wb32(pb, frame_rate); avio_wb16(pb, video_par->width); avio_wb16(pb, video_par->height); avio_wb32(pb, 0x010001); }
--------------------------------------------- Result 339 ---------------------------------------------
[[0 (53%)]] --> [[0 (36%)]] --> Socre: 0.6379154026508331

[[[[Adv]]]]: static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *[[sphb]], PCIDevice *pdev) { char *path = NULL, *buf = NULL, *host = NULL; host = object_property_get_str(OBJECT(pdev), "host", NULL); if (!host) { goto err_out; } path = g_strdup_printf("/sys/bus/pci/devices/%s/devspec", host); g_free(host); if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) { goto err_out; } g_free(path); path = g_strdup_printf("/proc/device-tree%s/ibm,loc-code", buf); g_free(buf); if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) { goto err_out; } return buf; err_out: g_free(path); return NULL; }

[[[[Adv]]]]: static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *[[judson]], PCIDevice *pdev) { char *path = NULL, *buf = NULL, *host = NULL; host = object_property_get_str(OBJECT(pdev), "host", NULL); if (!host) { goto err_out; } path = g_strdup_printf("/sys/bus/pci/devices/%s/devspec", host); g_free(host); if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) { goto err_out; } g_free(path); path = g_strdup_printf("/proc/device-tree%s/ibm,loc-code", buf); g_free(buf); if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) { goto err_out; } return buf; err_out: g_free(path); return NULL; }
--------------------------------------------- Result 340 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 191 / 15 / 134 / 340:  13%|        | 340/2690 [2:19:09<16:01:50, 24.56s/it][Succeeded / Failed / Skipped / Total] 191 / 15 / 134 / 340:  13%|        | 341/2690 [2:19:37<16:01:47, 24.57s/it][Succeeded / Failed / Skipped / Total] 192 / 15 / 134 / 341:  13%|        | 341/2690 [2:19:37<16:01:47, 24.57s/it][Succeeded / Failed / Skipped / Total] 192 / 15 / 134 / 341:  13%|        | 342/2690 [2:19:37<15:58:38, 24.50s/it][Succeeded / Failed / Skipped / Total] 192 / 15 / 135 / 342:  13%|        | 342/2690 [2:19:37<15:58:38, 24.50s/it][Succeeded / Failed / Skipped / Total] 192 / 15 / 135 / 342:  13%|        | 343/2690 [2:19:42<15:55:56, 24.44s/it][Succeeded / Failed / Skipped / Total] 193 / 15 / 135 / 343:  13%|        | 343/2690 [2:19:42<15:55:56, 24.44s/it][Succeeded / Failed / Skipped / Total] 193 / 15 / 135 / 343:  13%|        | 344/2690 [2:19:47<15:53:20, 24.38s/it][Succeeded / Failed / Skipped / Total] 194 / 15 / 135 / 344:  13%|        | 344/2690 [2:19:47<15:53:20, 24.38s/it][Succeeded / Failed / Skipped / Total] 194 / 15 / 135 / 344:  13%|        | 345/2690 [2:25:20<16:27:53, 25.28s/it][[0 (82%)]] --> [[0 (43%)]] --> Socre: 0.570684164762497

[[[[Adv]]]]: static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize, int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize, uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int [[dstFormat]]) { int i; for (i=0; i<dstW; i++) { int val=1<<18; int j; for (j=0; j<lumFilterSize; j++) val += lumSrc[j][i] * lumFilter[j]; dest[i]= av_clip_uint8(val>>19); } if (!uDest) return; if ([[dstFormat]] == PIX_FMT_NV12) for (i=0; i<chrDstW; i++) { int u=1<<18; int v=1<<18; int j; for (j=0; j<chrFilterSize; j++) { u += chrSrc[j][i] * chrFilter[j]; v += chrSrc[j][i + 2048] * chrFilter[j]; } uDest[2*i]= av_clip_uint8(u>>19); uDest[2*i+1]= av_clip_uint8(v>>19); } else for (i=0; i<chrDstW; i++) { int u=1<<18; int v=1<<18; int j; for (j=0; j<chrFilterSize; j++) { u += chrSrc[j][i] * chrFilter[j]; v += chrSrc[j][i + 2048] * chrFilter[j]; } uDest[2*i]= av_clip_uint8(v>>19); uDest[2*i+1]= av_clip_uint8(u>>19); } }

[[[[Adv]]]]: static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize, int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize, uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int [[calaveras]]) { int i; for (i=0; i<dstW; i++) { int val=1<<18; int j; for (j=0; j<lumFilterSize; j++) val += lumSrc[j][i] * lumFilter[j]; dest[i]= av_clip_uint8(val>>19); } if (!uDest) return; if ([[calaveras]] == PIX_FMT_NV12) for (i=0; i<chrDstW; i++) { int u=1<<18; int v=1<<18; int j; for (j=0; j<chrFilterSize; j++) { u += chrSrc[j][i] * chrFilter[j]; v += chrSrc[j][i + 2048] * chrFilter[j]; } uDest[2*i]= av_clip_uint8(u>>19); uDest[2*i+1]= av_clip_uint8(v>>19); } else for (i=0; i<chrDstW; i++) { int u=1<<18; int v=1<<18; int j; for (j=0; j<chrFilterSize; j++) { u += chrSrc[j][i] * chrFilter[j]; v += chrSrc[j][i + 2048] * chrFilter[j]; } uDest[2*i]= av_clip_uint8(v>>19); uDest[2*i+1]= av_clip_uint8(u>>19); } }
--------------------------------------------- Result 341 ---------------------------------------------
[[0 (80%)]] --> [[0 (47%)]] --> Socre: 0.5306828320026398

[[[[Adv]]]]: static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val) { uint32_t [[qid]]; if (addr & ((1 << 2) - 1)) { return; } if (((addr - 0x1000) >> 2) & 1) { uint16_t new_head = val & 0xffff; int start_sqs; NvmeCQueue *cq; [[qid]] = (addr - (0x1000 + (1 << 2))) >> 3; if (nvme_check_cqid(n, [[qid]])) { return; } cq = n->cq[[[qid]]]; if (new_head >= cq->size) { return; } start_sqs = nvme_cq_full(cq) ? 1 : 0; cq->head = new_head; if (start_sqs) { NvmeSQueue *[[sq]]; QTAILQ_FOREACH([[sq]], &cq->sq_list, entry) { timer_mod([[sq]]->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500); } timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500); } if (cq->tail != cq->head) { nvme_isr_notify(n, cq); } } else { uint16_t new_tail = val & 0xffff; NvmeSQueue *[[sq]]; [[qid]] = (addr - 0x1000) >> 3; if (nvme_check_sqid(n, [[qid]])) { return; } [[sq]] = n->sq[[[qid]]]; if (new_tail >= [[sq]]->size) { return; } [[sq]]->tail = new_tail; timer_mod([[sq]]->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500); } }

[[[[Adv]]]]: static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val) { uint32_t [[diss]]; if (addr & ((1 << 2) - 1)) { return; } if (((addr - 0x1000) >> 2) & 1) { uint16_t new_head = val & 0xffff; int start_sqs; NvmeCQueue *cq; [[diss]] = (addr - (0x1000 + (1 << 2))) >> 3; if (nvme_check_cqid(n, [[diss]])) { return; } cq = n->cq[[[diss]]]; if (new_head >= cq->size) { return; } start_sqs = nvme_cq_full(cq) ? 1 : 0; cq->head = new_head; if (start_sqs) { NvmeSQueue *[[flooring]]; QTAILQ_FOREACH([[flooring]], &cq->sq_list, entry) { timer_mod([[flooring]]->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500); } timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500); } if (cq->tail != cq->head) { nvme_isr_notify(n, cq); } } else { uint16_t new_tail = val & 0xffff; NvmeSQueue *[[flooring]]; [[diss]] = (addr - 0x1000) >> 3; if (nvme_check_sqid(n, [[diss]])) { return; } [[flooring]] = n->sq[[[diss]]]; if (new_tail >= [[flooring]]->size) { return; } [[flooring]]->tail = new_tail; timer_mod([[flooring]]->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500); } }
--------------------------------------------- Result 342 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold void build_modpred(Indeo3DecodeContext *s) { int i, j; s->ModPred = av_malloc(8 * 128); for (i=0; i < 128; ++i) { s->ModPred[i+0*128] = i > 126 ? 254 : 2*(i + 1 - ((i + 1) % 2)); s->ModPred[i+1*128] = i == 7 ? 20 : i == 119 || i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3)); s->ModPred[i+2*128] = i > 125 ? 248 : 2*(i + 2 - ((i + 2) % 4)); s->ModPred[i+3*128] = 2*(i + 1 - ((i - 3) % 5)); s->ModPred[i+4*128] = i == 8 ? 20 : 2*(i + 1 - ((i - 3) % 6)); s->ModPred[i+5*128] = 2*(i + 4 - ((i + 3) % 7)); s->ModPred[i+6*128] = i > 123 ? 240 : 2*(i + 4 - ((i + 4) % 8)); s->ModPred[i+7*128] = 2*(i + 5 - ((i + 4) % 9)); } s->corrector_type = av_malloc(24 * 256); for (i=0; i < 24; ++i) { for (j=0; j < 256; ++j) { s->corrector_type[i*256+j] = j < corrector_type_0[i] ? 1 : j < 248 || (i == 16 && j == 248) ? 0 : corrector_type_2[j - 248]; } } }
--------------------------------------------- Result 343 ---------------------------------------------
[[0 (93%)]] --> [[0 (50%)]] --> Socre: 0.5012601912021637

[[[[Adv]]]]: static void gen_storeq_reg(DisasContext *[[s]], int [[rlow]], int rhigh, TCGv_i64 val) { TCGv [[tmp]]; [[tmp]] = new_tmp(); tcg_gen_trunc_i64_i32([[tmp]], val); store_reg([[s]], [[rlow]], [[tmp]]); [[tmp]] = new_tmp(); tcg_gen_shri_i64(val, val, 32); tcg_gen_trunc_i64_i32([[tmp]], val); store_reg([[s]], rhigh, [[tmp]]); }

[[[[Adv]]]]: static void gen_storeq_reg(DisasContext *[[avec]], int [[chopper]], int rhigh, TCGv_i64 val) { TCGv [[iowa]]; [[iowa]] = new_tmp(); tcg_gen_trunc_i64_i32([[iowa]], val); store_reg([[avec]], [[chopper]], [[iowa]]); [[iowa]] = new_tmp(); tcg_gen_shri_i64(val, val, 32); tcg_gen_trunc_i64_i32([[iowa]], val); store_reg([[avec]], rhigh, [[iowa]]); }
--------------------------------------------- Result 344 ---------------------------------------------
[[0 (63%)]] --> [[0 (50%)]] --> Socre: 0.5033667087554932

[[[[Adv]]]]: static int ccid_bulk_in_copy_to_guest(USBCCIDState *[[s]], uint8_t *data, int [[len]]) { int ret = 0; assert([[len]] > 0); ccid_bulk_in_get([[s]]); if ([[s]]->current_bulk_in != NULL) { ret = MIN([[s]]->current_bulk_in->len - [[s]]->current_bulk_in->pos, [[len]]); memcpy(data, [[s]]->current_bulk_in->data + [[s]]->current_bulk_in->pos, ret); [[s]]->current_bulk_in->pos += ret; if ([[s]]->current_bulk_in->pos == [[s]]->current_bulk_in->len) { ccid_bulk_in_release([[s]]); } } else { ret = USB_RET_NAK; } if (ret > 0) { DPRINTF([[s]], D_MORE_INFO, "%s: %d/%d req/act to guest (BULK_IN)\n", __func__, [[len]], ret); } if (ret != USB_RET_NAK && ret < [[len]]) { DPRINTF([[s]], 1, "%s: returning short (EREMOTEIO) %d < %d\n", __func__, ret, [[len]]); } return ret; }

[[[[Adv]]]]: static int ccid_bulk_in_copy_to_guest(USBCCIDState *[[to]], uint8_t *data, int [[solo]]) { int ret = 0; assert([[solo]] > 0); ccid_bulk_in_get([[to]]); if ([[to]]->current_bulk_in != NULL) { ret = MIN([[to]]->current_bulk_in->len - [[to]]->current_bulk_in->pos, [[solo]]); memcpy(data, [[to]]->current_bulk_in->data + [[to]]->current_bulk_in->pos, ret); [[to]]->current_bulk_in->pos += ret; if ([[to]]->current_bulk_in->pos == [[to]]->current_bulk_in->len) { ccid_bulk_in_release([[to]]); } } else { ret = USB_RET_NAK; } if (ret > 0) { DPRINTF([[to]], D_MORE_INFO, "%s: %d/%d req/act to guest (BULK_IN)\n", __func__, [[solo]], ret); } if (ret != USB_RET_NAK && ret < [[solo]]) { DPRINTF([[to]], 1, "%s: returning short (EREMOTEIO) %d < %d\n", __func__, ret, [[solo]]); } return ret; }
--------------------------------------------- Result 345 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 195 / 15 / 135 / 345:  13%|        | 345/2690 [2:25:20<16:27:53, 25.28s/it][Succeeded / Failed / Skipped / Total] 195 / 15 / 135 / 345:  13%|        | 346/2690 [2:25:24<16:25:01, 25.21s/it][Succeeded / Failed / Skipped / Total] 196 / 15 / 135 / 346:  13%|        | 346/2690 [2:25:24<16:25:01, 25.21s/it][Succeeded / Failed / Skipped / Total] 196 / 15 / 135 / 346:  13%|        | 347/2690 [2:32:50<17:11:58, 26.43s/it][[0 (1%)]] --> [[0 (51%)]] --> Socre: 0.5118902921676636

[[[[Adv]]]]: static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *data_cb_or_cr, uint8_t [[alpha_in]], uint8_t beta_in, uint32_t img_width) { uint16_t out0, out1, out2, out3; v8i16 tmp1; v16u8 alpha, beta, is_less_than; v8i16 p0_or_q0, q0_or_p0; v16u8 p1_or_q1_org, p0_or_q0_org, q0_or_p0_org, q1_or_p1_org; v16i8 zero = { 0 }; v16u8 p0_asub_q0, p1_asub_p0, q1_asub_q0; v16u8 [[is_less_than_alpha]], is_less_than_beta; v8i16 p1_org_r, p0_org_r, q0_org_r, q1_org_r; { v16u8 row0, row1, row2, row3, row4, row5, row6, row7; LOAD_8VECS_UB((data_cb_or_cr - 2), img_width, row0, row1, row2, row3, row4, row5, row6, row7); TRANSPOSE8x4_B_UB(row0, row1, row2, row3, row4, row5, row6, row7, p1_or_q1_org, p0_or_q0_org, q0_or_p0_org, q1_or_p1_org); } alpha = (v16u8) __msa_fill_b([[alpha_in]]); beta = (v16u8) __msa_fill_b(beta_in); p0_asub_q0 = __msa_asub_u_b(p0_or_q0_org, q0_or_p0_org); p1_asub_p0 = __msa_asub_u_b(p1_or_q1_org, p0_or_q0_org); q1_asub_q0 = __msa_asub_u_b(q1_or_p1_org, q0_or_p0_org); [[is_less_than_alpha]] = (p0_asub_q0 < alpha); is_less_than_beta = (p1_asub_p0 < beta); is_less_than = is_less_than_beta & [[is_less_than_alpha]]; is_less_than_beta = (q1_asub_q0 < beta); is_less_than = is_less_than_beta & is_less_than; is_less_than = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) is_less_than); if (!__msa_test_bz_v(is_less_than)) { p1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p1_or_q1_org); p0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p0_or_q0_org); q0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q0_or_p0_org); q1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q1_or_p1_org); AVC_LOOP_FILTER_P0_OR_Q0(p0_org_r, q1_org_r, p1_org_r, p0_or_q0); AVC_LOOP_FILTER_P0_OR_Q0(q0_org_r, p1_org_r, q1_org_r, q0_or_p0); p0_or_q0 = (v8i16) __msa_pckev_b(zero, (v16i8) p0_or_q0); q0_or_p0 = (v8i16) __msa_pckev_b(zero, (v16i8) q0_or_p0); p0_or_q0_org = __msa_bmnz_v(p0_or_q0_org, (v16u8) p0_or_q0, is_less_than); q0_or_p0_org = __msa_bmnz_v(q0_or_p0_org, (v16u8) q0_or_p0, is_less_than); tmp1 = (v8i16) __msa_ilvr_b((v16i8) q0_or_p0_org, (v16i8) p0_or_q0_org); data_cb_or_cr -= 1; out0 = __msa_copy_u_h(tmp1, 0); out1 = __msa_copy_u_h(tmp1, 1); out2 = __msa_copy_u_h(tmp1, 2); out3 = __msa_copy_u_h(tmp1, 3); STORE_HWORD(data_cb_or_cr, out0); data_cb_or_cr += img_width; STORE_HWORD(data_cb_or_cr, out1); data_cb_or_cr += img_width; STORE_HWORD(data_cb_or_cr, out2); data_cb_or_cr += img_width; STORE_HWORD(data_cb_or_cr, out3); data_cb_or_cr += img_width; out0 = __msa_copy_u_h(tmp1, 4); out1 = __msa_copy_u_h(tmp1, 5); out2 = __msa_copy_u_h(tmp1, 6); out3 = __msa_copy_u_h(tmp1, 7); STORE_HWORD(data_cb_or_cr, out0); data_cb_or_cr += img_width; STORE_HWORD(data_cb_or_cr, out1); data_cb_or_cr += img_width; STORE_HWORD(data_cb_or_cr, out2); data_cb_or_cr += img_width; STORE_HWORD(data_cb_or_cr, out3); } }

[[[[Adv]]]]: static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *data_cb_or_cr, uint8_t [[protg]], uint8_t beta_in, uint32_t img_width) { uint16_t out0, out1, out2, out3; v8i16 tmp1; v16u8 alpha, beta, is_less_than; v8i16 p0_or_q0, q0_or_p0; v16u8 p1_or_q1_org, p0_or_q0_org, q0_or_p0_org, q1_or_p1_org; v16i8 zero = { 0 }; v16u8 p0_asub_q0, p1_asub_p0, q1_asub_q0; v16u8 [[metaphorical]], is_less_than_beta; v8i16 p1_org_r, p0_org_r, q0_org_r, q1_org_r; { v16u8 row0, row1, row2, row3, row4, row5, row6, row7; LOAD_8VECS_UB((data_cb_or_cr - 2), img_width, row0, row1, row2, row3, row4, row5, row6, row7); TRANSPOSE8x4_B_UB(row0, row1, row2, row3, row4, row5, row6, row7, p1_or_q1_org, p0_or_q0_org, q0_or_p0_org, q1_or_p1_org); } alpha = (v16u8) __msa_fill_b([[protg]]); beta = (v16u8) __msa_fill_b(beta_in); p0_asub_q0 = __msa_asub_u_b(p0_or_q0_org, q0_or_p0_org); p1_asub_p0 = __msa_asub_u_b(p1_or_q1_org, p0_or_q0_org); q1_asub_q0 = __msa_asub_u_b(q1_or_p1_org, q0_or_p0_org); [[metaphorical]] = (p0_asub_q0 < alpha); is_less_than_beta = (p1_asub_p0 < beta); is_less_than = is_less_than_beta & [[metaphorical]]; is_less_than_beta = (q1_asub_q0 < beta); is_less_than = is_less_than_beta & is_less_than; is_less_than = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) is_less_than); if (!__msa_test_bz_v(is_less_than)) { p1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p1_or_q1_org); p0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p0_or_q0_org); q0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q0_or_p0_org); q1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q1_or_p1_org); AVC_LOOP_FILTER_P0_OR_Q0(p0_org_r, q1_org_r, p1_org_r, p0_or_q0); AVC_LOOP_FILTER_P0_OR_Q0(q0_org_r, p1_org_r, q1_org_r, q0_or_p0); p0_or_q0 = (v8i16) __msa_pckev_b(zero, (v16i8) p0_or_q0); q0_or_p0 = (v8i16) __msa_pckev_b(zero, (v16i8) q0_or_p0); p0_or_q0_org = __msa_bmnz_v(p0_or_q0_org, (v16u8) p0_or_q0, is_less_than); q0_or_p0_org = __msa_bmnz_v(q0_or_p0_org, (v16u8) q0_or_p0, is_less_than); tmp1 = (v8i16) __msa_ilvr_b((v16i8) q0_or_p0_org, (v16i8) p0_or_q0_org); data_cb_or_cr -= 1; out0 = __msa_copy_u_h(tmp1, 0); out1 = __msa_copy_u_h(tmp1, 1); out2 = __msa_copy_u_h(tmp1, 2); out3 = __msa_copy_u_h(tmp1, 3); STORE_HWORD(data_cb_or_cr, out0); data_cb_or_cr += img_width; STORE_HWORD(data_cb_or_cr, out1); data_cb_or_cr += img_width; STORE_HWORD(data_cb_or_cr, out2); data_cb_or_cr += img_width; STORE_HWORD(data_cb_or_cr, out3); data_cb_or_cr += img_width; out0 = __msa_copy_u_h(tmp1, 4); out1 = __msa_copy_u_h(tmp1, 5); out2 = __msa_copy_u_h(tmp1, 6); out3 = __msa_copy_u_h(tmp1, 7); STORE_HWORD(data_cb_or_cr, out0); data_cb_or_cr += img_width; STORE_HWORD(data_cb_or_cr, out1); data_cb_or_cr += img_width; STORE_HWORD(data_cb_or_cr, out2); data_cb_or_cr += img_width; STORE_HWORD(data_cb_or_cr, out3); } }
--------------------------------------------- Result 346 ---------------------------------------------
[[0 (57%)]] --> [[0 (40%)]] --> Socre: 0.598340630531311

[[[[Adv]]]]: static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *[[ctx]], int index, const char *filt_name, const char *args, AVClass *log_ctx) { AVFilter *filt; char inst_name[30]; char tmp_args[256]; int ret; snprintf(inst_name, sizeof(inst_name), "Parsed filter %d %s", index, filt_name); filt = avfilter_get_by_name(filt_name); if (!filt) { av_log(log_ctx, AV_LOG_ERROR, "No such filter: '%s'\n", filt_name); return AVERROR(EINVAL); } ret = avfilter_open(filt_ctx, filt, inst_name); if (!*filt_ctx) { av_log(log_ctx, AV_LOG_ERROR, "Error creating filter '%s'\n", filt_name); return ret; } if ((ret = avfilter_graph_add_filter([[ctx]], *filt_ctx)) < 0) { avfilter_free(*filt_ctx); return ret; } if (!strcmp(filt_name, "scale") && !strstr(args, "flags")) { snprintf(tmp_args, sizeof(tmp_args), "%s:%s", args, [[ctx]]->scale_sws_opts); args = tmp_args; } if ((ret = avfilter_init_filter(*filt_ctx, args, NULL)) < 0) { av_log(log_ctx, AV_LOG_ERROR, "Error initializing filter '%s' with args '%s'\n", filt_name, args); return ret; } return 0; }

[[[[Adv]]]]: static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *[[destruct]], int index, const char *filt_name, const char *args, AVClass *log_ctx) { AVFilter *filt; char inst_name[30]; char tmp_args[256]; int ret; snprintf(inst_name, sizeof(inst_name), "Parsed filter %d %s", index, filt_name); filt = avfilter_get_by_name(filt_name); if (!filt) { av_log(log_ctx, AV_LOG_ERROR, "No such filter: '%s'\n", filt_name); return AVERROR(EINVAL); } ret = avfilter_open(filt_ctx, filt, inst_name); if (!*filt_ctx) { av_log(log_ctx, AV_LOG_ERROR, "Error creating filter '%s'\n", filt_name); return ret; } if ((ret = avfilter_graph_add_filter([[destruct]], *filt_ctx)) < 0) { avfilter_free(*filt_ctx); return ret; } if (!strcmp(filt_name, "scale") && !strstr(args, "flags")) { snprintf(tmp_args, sizeof(tmp_args), "%s:%s", args, [[destruct]]->scale_sws_opts); args = tmp_args; } if ((ret = avfilter_init_filter(*filt_ctx, args, NULL)) < 0) { av_log(log_ctx, AV_LOG_ERROR, "Error initializing filter '%s' with args '%s'\n", filt_name, args); return ret; } return 0; }
--------------------------------------------- Result 347 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 196 / 16 / 135 / 347:  13%|        | 347/2690 [2:32:50<17:11:58, 26.43s/it][Succeeded / Failed / Skipped / Total] 196 / 16 / 135 / 347:  13%|        | 348/2690 [2:32:50<17:08:37, 26.35s/it][Succeeded / Failed / Skipped / Total] 196 / 16 / 136 / 348:  13%|        | 348/2690 [2:32:50<17:08:37, 26.35s/it][Succeeded / Failed / Skipped / Total] 196 / 16 / 136 / 348:  13%|        | 349/2690 [2:32:55<17:05:49, 26.29s/it][[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes, QEMUIOVector *qiov, int flags) { BDRVBlkdebugState *s = bs->opaque; BlkdebugRule *rule = NULL; QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) { uint64_t inject_offset = rule->options.inject.offset; if (inject_offset == -1 || (inject_offset >= offset && inject_offset < offset + bytes)) { break; if (rule && rule->options.inject.error) { return inject_error(bs, rule); return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);

[[[[Adv]]]]: blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes, QEMUIOVector *qiov, int flags) { BDRVBlkdebugState *s = bs->opaque; BlkdebugRule *rule = NULL; QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) { uint64_t inject_offset = rule->options.inject.offset; if (inject_offset == -1 || (inject_offset >= offset && inject_offset < offset + bytes)) { break; if (rule && rule->options.inject.error) { return inject_error(bs, rule); return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);
--------------------------------------------- Result 348 ---------------------------------------------
[[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ppc_spapr_init(ram_addr_t ram_size, const char *boot_device, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { PowerPCCPU *cpu; CPUPPCState *env; int i; MemoryRegion *sysmem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); target_phys_addr_t rma_alloc_size, rma_size; uint32_t initrd_base = 0; long kernel_size = 0, initrd_size = 0; long load_limit, rtas_limit, fw_size; long pteg_shift = 17; char *filename; spapr = g_malloc0(sizeof(*spapr)); QLIST_INIT(&spapr->phbs); cpu_ppc_hypercall = emulate_spapr_hypercall; rma_alloc_size = kvmppc_alloc_rma("ppc_spapr.rma", sysmem); if (rma_alloc_size == -1) { hw_error("qemu: Unable to create RMA\n"); exit(1); } if (rma_alloc_size && (rma_alloc_size < ram_size)) { rma_size = rma_alloc_size; } else { rma_size = ram_size; } rtas_limit = MIN(rma_size, 0x80000000); spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE; spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE; load_limit = spapr->fdt_addr - FW_OVERHEAD; if (cpu_model == NULL) { cpu_model = kvm_enabled() ? "host" : "POWER7"; } for (i = 0; i < smp_cpus; i++) { cpu = cpu_ppc_init(cpu_model); if (cpu == NULL) { fprintf(stderr, "Unable to find PowerPC CPU definition\n"); exit(1); } env = &cpu->env; cpu_ppc_tb_init(env, TIMEBASE_FREQ); qemu_register_reset(spapr_cpu_reset, cpu); env->hreset_vector = 0x60; env->hreset_excp_prefix = 0; env->gpr[3] = env->cpu_index; } spapr->ram_limit = ram_size; if (spapr->ram_limit > rma_alloc_size) { ram_addr_t nonrma_base = rma_alloc_size; ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size; memory_region_init_ram(ram, "ppc_spapr.ram", nonrma_size); vmstate_register_ram_global(ram); memory_region_add_subregion(sysmem, nonrma_base, ram); } spapr->htab_size = 1ULL << (pteg_shift + 7); spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size); for (env = first_cpu; env != NULL; env = env->next_cpu) { env->external_htab = spapr->htab; env->htab_base = -1; env->htab_mask = spapr->htab_size - 1; env->spr[SPR_SDR1] = (unsigned long)spapr->htab | ((pteg_shift + 7) - 18); env->spr[SPR_HIOR] = 0; if (kvm_enabled()) { kvmppc_set_papr(env); } } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, "spapr-rtas.bin"); spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr, rtas_limit - spapr->rtas_addr); if (spapr->rtas_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } if (spapr->rtas_size > RTAS_MAX_SIZE) { hw_error("RTAS too big ! 0x%lx bytes (max is 0x%x)\n", spapr->rtas_size, RTAS_MAX_SIZE); exit(1); } g_free(filename); spapr->icp = xics_system_init(XICS_IRQS); spapr->next_irq = 16; spapr->vio_bus = spapr_vio_bus_init(); for (i = 0; i < MAX_SERIAL_PORTS; i++) { if (serial_hds[i]) { spapr_vty_create(spapr->vio_bus, serial_hds[i]); } } spapr_create_phb(spapr, "pci", SPAPR_PCI_BUID, SPAPR_PCI_MEM_WIN_ADDR, SPAPR_PCI_MEM_WIN_SIZE, SPAPR_PCI_IO_WIN_ADDR); for (i = 0; i < nb_nics; i++) { NICInfo *nd = &nd_table[i]; if (!nd->model) { nd->model = g_strdup("ibmveth"); } if (strcmp(nd->model, "ibmveth") == 0) { spapr_vlan_create(spapr->vio_bus, nd); } else { pci_nic_init_nofail(&nd_table[i], nd->model, NULL); } } for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) { spapr_vscsi_create(spapr->vio_bus); } if (rma_size < (MIN_RMA_SLOF << 20)) { fprintf(stderr, "qemu: pSeries SLOF firmware requires >= " "%ldM guest RMA (Real Mode Area memory)\n", MIN_RMA_SLOF); exit(1); } fprintf(stderr, "sPAPR memory map:\n"); fprintf(stderr, "RTAS : 0x%08lx..%08lx\n", (unsigned long)spapr->rtas_addr, (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1)); fprintf(stderr, "FDT : 0x%08lx..%08lx\n", (unsigned long)spapr->fdt_addr, (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1)); if (kernel_filename) { uint64_t lowaddr = 0; kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0); if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, load_limit - KERNEL_LOAD_ADDR); } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } fprintf(stderr, "Kernel : 0x%08x..%08lx\n", KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1); if (initrd_filename) { initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff; initrd_size = load_image_targphys(initrd_filename, initrd_base, load_limit - initrd_base); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } fprintf(stderr, "Ramdisk : 0x%08lx..%08lx\n", (long)initrd_base, (long)(initrd_base + initrd_size - 1)); } else { initrd_base = 0; initrd_size = 0; } } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME); fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE); if (fw_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } g_free(filename); fprintf(stderr, "Firmware load : 0x%08x..%08lx\n", 0, fw_size); fprintf(stderr, "Firmware runtime : 0x%08lx..%08lx\n", load_limit, (unsigned long)spapr->fdt_addr); spapr->entry_point = 0x100; for (env = first_cpu; env != NULL; env = env->next_cpu) { env->halted = 1; } spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, rma_size, initrd_base, initrd_size, kernel_size, boot_device, kernel_cmdline, pteg_shift + 7); assert(spapr->fdt_skel != NULL); qemu_register_reset(spapr_reset, spapr); }
--------------------------------------------- Result 349 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 197 / 16 / 136 / 349:  13%|        | 349/2690 [2:32:55<17:05:49, 26.29s/it][Succeeded / Failed / Skipped / Total] 197 / 16 / 136 / 349:  13%|        | 350/2690 [2:32:56<17:02:30, 26.22s/it][Succeeded / Failed / Skipped / Total] 197 / 16 / 137 / 350:  13%|        | 350/2690 [2:32:56<17:02:30, 26.22s/it][Succeeded / Failed / Skipped / Total] 197 / 16 / 137 / 350:  13%|        | 351/2690 [2:36:15<17:21:16, 26.71s/it][[0 (39%)]] --> [[0 (76%)]] --> Socre: 0.7618038654327393

[[[[Adv]]]]: static av_cold int sonic_encode_init(AVCodecContext *[[avctx]]) { SonicContext *s = [[avctx]]->priv_data; PutBitContext pb; int i, version = 0; if ([[avctx]]->channels > MAX_CHANNELS) { av_log([[avctx]], AV_LOG_ERROR, "Only mono and stereo streams are supported by now\n"); return AVERROR(EINVAL); } if ([[avctx]]->channels == 2) s->decorrelation = MID_SIDE; else s->decorrelation = 3; if ([[avctx]]->codec->id == AV_CODEC_ID_SONIC_LS) { s->lossless = 1; s->num_taps = 32; s->downsampling = 1; s->quantization = 0.0; } else { s->num_taps = 128; s->downsampling = 2; s->quantization = 1.0; } if ((s->num_taps < 32) || (s->num_taps > 1024) || ((s->num_taps>>5)<<5 != s->num_taps)) { av_log([[avctx]], AV_LOG_ERROR, "Invalid number of taps\n"); return AVERROR_INVALIDDATA; } s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant)); for (i = 0; i < s->num_taps; i++) s->tap_quant[i] = ff_sqrt(i+1); s->channels = [[avctx]]->channels; s->samplerate = [[avctx]]->sample_rate; s->block_align = 2048LL*s->samplerate/(44100*s->downsampling); s->frame_size = s->channels*s->block_align*s->downsampling; s->tail_size = s->num_taps*s->channels; s->tail = av_calloc(s->tail_size, sizeof(*s->tail)); if (!s->tail) return AVERROR(ENOMEM); s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) ); if (!s->predictor_k) return AVERROR(ENOMEM); for (i = 0; i < s->channels; i++) { s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples)); if (!s->coded_samples[i]) return AVERROR(ENOMEM); } s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples)); s->window_size = ((2*s->tail_size)+s->frame_size); s->window = av_calloc(s->window_size, sizeof(*s->window)); if (!s->window) return AVERROR(ENOMEM); [[avctx]]->extradata = av_mallocz(16); if (![[avctx]]->extradata) return AVERROR(ENOMEM); init_put_bits(&pb, [[avctx]]->extradata, 16*8); put_bits(&pb, 2, version); if (version == 1) { put_bits(&pb, 2, s->channels); put_bits(&pb, 4, code_samplerate(s->samplerate)); } put_bits(&pb, 1, s->lossless); if (!s->lossless) put_bits(&pb, 3, SAMPLE_SHIFT); put_bits(&pb, 2, s->decorrelation); put_bits(&pb, 2, s->downsampling); put_bits(&pb, 5, (s->num_taps >> 5)-1); put_bits(&pb, 1, 0); flush_put_bits(&pb); [[avctx]]->extradata_size = put_bits_count(&pb)/8; av_log([[avctx]], AV_LOG_INFO, "Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\n", version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling); [[avctx]]->frame_size = s->block_align*s->downsampling; return 0; }

[[[[Adv]]]]: static av_cold int sonic_encode_init(AVCodecContext *[[referral]]) { SonicContext *s = [[referral]]->priv_data; PutBitContext pb; int i, version = 0; if ([[referral]]->channels > MAX_CHANNELS) { av_log([[referral]], AV_LOG_ERROR, "Only mono and stereo streams are supported by now\n"); return AVERROR(EINVAL); } if ([[referral]]->channels == 2) s->decorrelation = MID_SIDE; else s->decorrelation = 3; if ([[referral]]->codec->id == AV_CODEC_ID_SONIC_LS) { s->lossless = 1; s->num_taps = 32; s->downsampling = 1; s->quantization = 0.0; } else { s->num_taps = 128; s->downsampling = 2; s->quantization = 1.0; } if ((s->num_taps < 32) || (s->num_taps > 1024) || ((s->num_taps>>5)<<5 != s->num_taps)) { av_log([[referral]], AV_LOG_ERROR, "Invalid number of taps\n"); return AVERROR_INVALIDDATA; } s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant)); for (i = 0; i < s->num_taps; i++) s->tap_quant[i] = ff_sqrt(i+1); s->channels = [[referral]]->channels; s->samplerate = [[referral]]->sample_rate; s->block_align = 2048LL*s->samplerate/(44100*s->downsampling); s->frame_size = s->channels*s->block_align*s->downsampling; s->tail_size = s->num_taps*s->channels; s->tail = av_calloc(s->tail_size, sizeof(*s->tail)); if (!s->tail) return AVERROR(ENOMEM); s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) ); if (!s->predictor_k) return AVERROR(ENOMEM); for (i = 0; i < s->channels; i++) { s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples)); if (!s->coded_samples[i]) return AVERROR(ENOMEM); } s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples)); s->window_size = ((2*s->tail_size)+s->frame_size); s->window = av_calloc(s->window_size, sizeof(*s->window)); if (!s->window) return AVERROR(ENOMEM); [[referral]]->extradata = av_mallocz(16); if (![[referral]]->extradata) return AVERROR(ENOMEM); init_put_bits(&pb, [[referral]]->extradata, 16*8); put_bits(&pb, 2, version); if (version == 1) { put_bits(&pb, 2, s->channels); put_bits(&pb, 4, code_samplerate(s->samplerate)); } put_bits(&pb, 1, s->lossless); if (!s->lossless) put_bits(&pb, 3, SAMPLE_SHIFT); put_bits(&pb, 2, s->decorrelation); put_bits(&pb, 2, s->downsampling); put_bits(&pb, 5, (s->num_taps >> 5)-1); put_bits(&pb, 1, 0); flush_put_bits(&pb); [[referral]]->extradata_size = put_bits_count(&pb)/8; av_log([[referral]], AV_LOG_INFO, "Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\n", version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling); [[referral]]->frame_size = s->block_align*s->downsampling; return 0; }
--------------------------------------------- Result 350 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma) { static const int8_t top[7] = { LEFT_DC_PRED8x8, 1, -1, -1 }; static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 }; if (mode > 6U) { av_log(h->avctx, AV_LOG_ERROR, "out of range intra chroma pred mode at %d %d\n", h->mb_x, h->mb_y); return -1; } if (!(h->top_samples_available & 0x8000)) { mode = top[mode]; if (mode < 0) { av_log(h->avctx, AV_LOG_ERROR, "top block unavailable for requested intra mode at %d %d\n", h->mb_x, h->mb_y); return -1; } } if ((h->left_samples_available & 0x8080) != 0x8080) { mode = left[mode]; if (is_chroma && (h->left_samples_available & 0x8080)) { mode = ALZHEIMER_DC_L0T_PRED8x8 + (!(h->left_samples_available & 0x8000)) + 2 * (mode == DC_128_PRED8x8); } if (mode < 0) { av_log(h->avctx, AV_LOG_ERROR, "left block unavailable for requested intra mode at %d %d\n", h->mb_x, h->mb_y); return -1; } } return mode; }
--------------------------------------------- Result 351 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 198 / 16 / 137 / 351:  13%|        | 351/2690 [2:36:15<17:21:16, 26.71s/it][Succeeded / Failed / Skipped / Total] 198 / 16 / 137 / 351:  13%|        | 352/2690 [2:36:33<17:19:48, 26.68s/it][Succeeded / Failed / Skipped / Total] 199 / 16 / 137 / 352:  13%|        | 352/2690 [2:36:33<17:19:48, 26.68s/it][Succeeded / Failed / Skipped / Total] 199 / 16 / 137 / 352:  13%|        | 353/2690 [2:37:07<17:20:14, 26.71s/it][Succeeded / Failed / Skipped / Total] 200 / 16 / 137 / 353:  13%|        | 353/2690 [2:37:07<17:20:14, 26.71s/it][Succeeded / Failed / Skipped / Total] 200 / 16 / 137 / 353:  13%|        | 354/2690 [2:37:31<17:19:26, 26.70s/it][Succeeded / Failed / Skipped / Total] 201 / 16 / 137 / 354:  13%|        | 354/2690 [2:37:31<17:19:26, 26.70s/it][Succeeded / Failed / Skipped / Total] 201 / 16 / 137 / 354:  13%|        | 355/2690 [2:37:38<17:16:51, 26.64s/it][[0 (84%)]] --> [[0 (47%)]] --> Socre: 0.5261022448539734

[[[[Adv]]]]: static void lms_update(WmallDecodeCtx *s, int ich, int ilms, int16_t input, int16_t [[pred]]) { int16_t icoef; int recent = s->cdlms[ich][ilms].recent; int16_t range = 1 << (s->bits_per_sample - 1); int bps = s->bits_per_sample > 16 ? 4 : 2; if (input > [[pred]]) { for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++) s->cdlms[ich][ilms].coefs[icoef] += s->cdlms[ich][ilms].lms_updates[icoef + recent]; } else { for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++) s->cdlms[ich][ilms].coefs[icoef] -= s->cdlms[ich][ilms].lms_updates[icoef]; } s->cdlms[ich][ilms].recent--; s->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1); if (input > [[pred]]) s->cdlms[ich][ilms].lms_updates[recent] = s->update_speed[ich]; else if (input < [[pred]]) s->cdlms[ich][ilms].lms_updates[recent] = -s->update_speed[ich]; s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 4] >>= 2; s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 3] >>= 1; if (s->cdlms[ich][ilms].recent == 0) { memcpy(s->cdlms[ich][ilms].lms_prevvalues + s->cdlms[ich][ilms].order, s->cdlms[ich][ilms].lms_prevvalues, bps * s->cdlms[ich][ilms].order); memcpy(s->cdlms[ich][ilms].lms_updates + s->cdlms[ich][ilms].order, s->cdlms[ich][ilms].lms_updates, bps * s->cdlms[ich][ilms].order); s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order; } }

[[[[Adv]]]]: static void lms_update(WmallDecodeCtx *s, int ich, int ilms, int16_t input, int16_t [[tranquilizer]]) { int16_t icoef; int recent = s->cdlms[ich][ilms].recent; int16_t range = 1 << (s->bits_per_sample - 1); int bps = s->bits_per_sample > 16 ? 4 : 2; if (input > [[tranquilizer]]) { for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++) s->cdlms[ich][ilms].coefs[icoef] += s->cdlms[ich][ilms].lms_updates[icoef + recent]; } else { for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++) s->cdlms[ich][ilms].coefs[icoef] -= s->cdlms[ich][ilms].lms_updates[icoef]; } s->cdlms[ich][ilms].recent--; s->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1); if (input > [[tranquilizer]]) s->cdlms[ich][ilms].lms_updates[recent] = s->update_speed[ich]; else if (input < [[tranquilizer]]) s->cdlms[ich][ilms].lms_updates[recent] = -s->update_speed[ich]; s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 4] >>= 2; s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 3] >>= 1; if (s->cdlms[ich][ilms].recent == 0) { memcpy(s->cdlms[ich][ilms].lms_prevvalues + s->cdlms[ich][ilms].order, s->cdlms[ich][ilms].lms_prevvalues, bps * s->cdlms[ich][ilms].order); memcpy(s->cdlms[ich][ilms].lms_updates + s->cdlms[ich][ilms].order, s->cdlms[ich][ilms].lms_updates, bps * s->cdlms[ich][ilms].order); s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order; } }
--------------------------------------------- Result 352 ---------------------------------------------
[[0 (33%)]] --> [[0 (57%)]] --> Socre: 0.5729406476020813

[[[[Adv]]]]: static void block_job_completed_txn_abort(BlockJob *job) { AioContext *ctx; BlockJobTxn *[[txn]] = job->txn; BlockJob *[[other_job]], *next; if ([[txn]]->aborting) { return; } [[txn]]->aborting = "True" == "True"; QLIST_FOREACH([[other_job]], &[[txn]]->jobs, txn_list) { ctx = blk_get_aio_context([[other_job]]->blk); aio_context_acquire(ctx); } QLIST_FOREACH([[other_job]], &[[txn]]->jobs, txn_list) { if ([[other_job]] == job || [[other_job]]->completed) { if ([[other_job]] != job) { block_job_cancel_async([[other_job]]); } continue; } block_job_cancel_sync([[other_job]]); assert([[other_job]]->completed); } QLIST_FOREACH_SAFE([[other_job]], &[[txn]]->jobs, txn_list, next) { ctx = blk_get_aio_context([[other_job]]->blk); block_job_completed_single([[other_job]]); aio_context_release(ctx); } }

[[[[Adv]]]]: static void block_job_completed_txn_abort(BlockJob *job) { AioContext *ctx; BlockJobTxn *[[motorcyclist]] = job->txn; BlockJob *[[navet]], *next; if ([[motorcyclist]]->aborting) { return; } [[motorcyclist]]->aborting = "True" == "True"; QLIST_FOREACH([[navet]], &[[motorcyclist]]->jobs, txn_list) { ctx = blk_get_aio_context([[navet]]->blk); aio_context_acquire(ctx); } QLIST_FOREACH([[navet]], &[[motorcyclist]]->jobs, txn_list) { if ([[navet]] == job || [[navet]]->completed) { if ([[navet]] != job) { block_job_cancel_async([[navet]]); } continue; } block_job_cancel_sync([[navet]]); assert([[navet]]->completed); } QLIST_FOREACH_SAFE([[navet]], &[[motorcyclist]]->jobs, txn_list, next) { ctx = blk_get_aio_context([[navet]]->blk); block_job_completed_single([[navet]]); aio_context_release(ctx); } }
--------------------------------------------- Result 353 ---------------------------------------------
[[0 (2%)]] --> [[0 (86%)]] --> Socre: 0.8583594560623169

[[[[Adv]]]]: void isa_mmio_setup(MemoryRegion *[[mr]], target_phys_addr_t size) { memory_region_init_io([[mr]], &isa_mmio_ops, NULL, "isa-mmio", size); }

[[[[Adv]]]]: void isa_mmio_setup(MemoryRegion *[[jrg]], target_phys_addr_t size) { memory_region_init_io([[jrg]], &isa_mmio_ops, NULL, "isa-mmio", size); }
--------------------------------------------- Result 354 ---------------------------------------------
[[0 (4%)]] --> [[0 (92%)]] --> Socre: 0.9235805869102478

[[[[Adv]]]]: int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc, SocketAddressLegacy *localAddr, SocketAddressLegacy *remoteAddr, Error **[[errp]]) { int fd; trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr); fd = socket_dgram(remoteAddr, localAddr, [[errp]]); if (fd < 0) { trace_qio_channel_socket_dgram_fail(ioc); return -1; } trace_qio_channel_socket_dgram_complete(ioc, fd); if (qio_channel_socket_set_fd(ioc, fd, [[errp]]) < 0) { close(fd); return -1; } return 0; }

[[[[Adv]]]]: int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc, SocketAddressLegacy *localAddr, SocketAddressLegacy *remoteAddr, Error **[[qubec]]) { int fd; trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr); fd = socket_dgram(remoteAddr, localAddr, [[qubec]]); if (fd < 0) { trace_qio_channel_socket_dgram_fail(ioc); return -1; } trace_qio_channel_socket_dgram_complete(ioc, fd); if (qio_channel_socket_set_fd(ioc, fd, [[qubec]]) < 0) { close(fd); return -1; } return 0; }
--------------------------------------------- Result 355 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 202 / 16 / 137 / 355:  13%|        | 355/2690 [2:37:38<17:16:51, 26.64s/it][Succeeded / Failed / Skipped / Total] 202 / 16 / 137 / 355:  13%|        | 356/2690 [2:37:50<17:14:49, 26.60s/it][Succeeded / Failed / Skipped / Total] 203 / 16 / 137 / 356:  13%|        | 356/2690 [2:37:50<17:14:49, 26.60s/it][Succeeded / Failed / Skipped / Total] 203 / 16 / 137 / 356:  13%|        | 357/2690 [2:40:19<17:27:41, 26.94s/it][Succeeded / Failed / Skipped / Total] 204 / 16 / 137 / 357:  13%|        | 357/2690 [2:40:19<17:27:41, 26.94s/it][Succeeded / Failed / Skipped / Total] 204 / 16 / 137 / 357:  13%|        | 358/2690 [2:41:23<17:31:17, 27.05s/it][Succeeded / Failed / Skipped / Total] 205 / 16 / 137 / 358:  13%|        | 358/2690 [2:41:23<17:31:17, 27.05s/it][Succeeded / Failed / Skipped / Total] 205 / 16 / 137 / 358:  13%|        | 359/2690 [2:41:27<17:28:24, 26.99s/it][[0 (32%)]] --> [[0 (55%)]] --> Socre: 0.547492265701294

[[[[Adv]]]]: static void dec_bit(DisasContext *dc) { TCGv t0, t1; unsigned int [[op]]; int [[mem_index]] = cpu_mmu_index(dc->env); [[op]] = dc->ir & ((1 << 9) - 1); switch ([[op]]) { case 0x21: t0 = tcg_temp_new(); LOG_DIS("src r%d r%d\n", dc->rd, dc->ra); tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1); if (dc->rd) { t1 = tcg_temp_new(); read_carry(dc, t1); tcg_gen_shli_tl(t1, t1, 31); tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1); tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t1); tcg_temp_free(t1); } write_carry(dc, t0); tcg_temp_free(t0); break; case 0x1: case 0x41: t0 = tcg_temp_new(); LOG_DIS("srl r%d r%d\n", dc->rd, dc->ra); tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1); write_carry(dc, t0); tcg_temp_free(t0); if (dc->rd) { if ([[op]] == 0x41) tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1); else tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1); } break; case 0x60: LOG_DIS("ext8s r%d r%d\n", dc->rd, dc->ra); tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]); break; case 0x61: LOG_DIS("ext16s r%d r%d\n", dc->rd, dc->ra); tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]); break; case 0x64: case 0x66: case 0x74: case 0x76: LOG_DIS("wdc r%d\n", dc->ra); if ((dc->tb_flags & MSR_EE_FLAG) && [[mem_index]] == MMU_USER_IDX) { tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN); t_gen_raise_exception(dc, EXCP_HW_EXCP); return; } break; case 0x68: LOG_DIS("wic r%d\n", dc->ra); if ((dc->tb_flags & MSR_EE_FLAG) && [[mem_index]] == MMU_USER_IDX) { tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN); t_gen_raise_exception(dc, EXCP_HW_EXCP); return; } break; case 0xe0: if ((dc->tb_flags & MSR_EE_FLAG) && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK) && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) { tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP); t_gen_raise_exception(dc, EXCP_HW_EXCP); } if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) { gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]); } break; case 0x1e0: LOG_DIS("swapb r%d r%d\n", dc->rd, dc->ra); tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]); break; case 0x1e2: LOG_DIS("swaph r%d r%d\n", dc->rd, dc->ra); tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16); break; default: cpu_abort(dc->env, "unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\n", dc->pc, [[op]], dc->rd, dc->ra, dc->rb); break; } }

[[[[Adv]]]]: static void dec_bit(DisasContext *dc) { TCGv t0, t1; unsigned int [[zit]]; int [[dacia]] = cpu_mmu_index(dc->env); [[zit]] = dc->ir & ((1 << 9) - 1); switch ([[zit]]) { case 0x21: t0 = tcg_temp_new(); LOG_DIS("src r%d r%d\n", dc->rd, dc->ra); tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1); if (dc->rd) { t1 = tcg_temp_new(); read_carry(dc, t1); tcg_gen_shli_tl(t1, t1, 31); tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1); tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t1); tcg_temp_free(t1); } write_carry(dc, t0); tcg_temp_free(t0); break; case 0x1: case 0x41: t0 = tcg_temp_new(); LOG_DIS("srl r%d r%d\n", dc->rd, dc->ra); tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1); write_carry(dc, t0); tcg_temp_free(t0); if (dc->rd) { if ([[zit]] == 0x41) tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1); else tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1); } break; case 0x60: LOG_DIS("ext8s r%d r%d\n", dc->rd, dc->ra); tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]); break; case 0x61: LOG_DIS("ext16s r%d r%d\n", dc->rd, dc->ra); tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]); break; case 0x64: case 0x66: case 0x74: case 0x76: LOG_DIS("wdc r%d\n", dc->ra); if ((dc->tb_flags & MSR_EE_FLAG) && [[dacia]] == MMU_USER_IDX) { tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN); t_gen_raise_exception(dc, EXCP_HW_EXCP); return; } break; case 0x68: LOG_DIS("wic r%d\n", dc->ra); if ((dc->tb_flags & MSR_EE_FLAG) && [[dacia]] == MMU_USER_IDX) { tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN); t_gen_raise_exception(dc, EXCP_HW_EXCP); return; } break; case 0xe0: if ((dc->tb_flags & MSR_EE_FLAG) && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK) && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) { tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP); t_gen_raise_exception(dc, EXCP_HW_EXCP); } if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) { gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]); } break; case 0x1e0: LOG_DIS("swapb r%d r%d\n", dc->rd, dc->ra); tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]); break; case 0x1e2: LOG_DIS("swaph r%d r%d\n", dc->rd, dc->ra); tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16); break; default: cpu_abort(dc->env, "unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\n", dc->pc, [[zit]], dc->rd, dc->ra, dc->rb); break; } }
--------------------------------------------- Result 356 ---------------------------------------------
[[0 (5%)]] --> [[0 (98%)]] --> Socre: 0.982384979724884

[[[[Adv]]]]: int memory_region_get_fd(MemoryRegion *[[mr]]) { if ([[mr]]->alias) { return memory_region_get_fd([[mr]]->alias); } assert([[mr]]->terminates); return qemu_get_ram_fd([[mr]]->ram_addr & TARGET_PAGE_MASK); }

[[[[Adv]]]]: int memory_region_get_fd(MemoryRegion *[[jrg]]) { if ([[jrg]]->alias) { return memory_region_get_fd([[jrg]]->alias); } assert([[jrg]]->terminates); return qemu_get_ram_fd([[jrg]]->ram_addr & TARGET_PAGE_MASK); }
--------------------------------------------- Result 357 ---------------------------------------------
[[0 (86%)]] --> [[0 (49%)]] --> Socre: 0.5148331820964813

[[[[Adv]]]]: static void decode_mclms(WmallDecodeCtx *s) { s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2; s->mclms_scaling = get_bits(&s->gb, 4); if(get_bits1(&s->gb)) { int i; int [[send_coef_bits]]; int cbits = av_log2(s->mclms_scaling + 1); assert(cbits == my_log2(s->mclms_scaling + 1)); if(1 << cbits < s->mclms_scaling + 1) cbits++; [[send_coef_bits]] = (cbits ? get_bits(&s->gb, cbits) : 0) + 2; for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) { s->mclms_coeffs[i] = get_bits(&s->gb, [[send_coef_bits]]); } for(i = 0; i < s->num_channels; i++) { int c; for(c = 0; c < i; c++) { s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, [[send_coef_bits]]); } } } }

[[[[Adv]]]]: static void decode_mclms(WmallDecodeCtx *s) { s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2; s->mclms_scaling = get_bits(&s->gb, 4); if(get_bits1(&s->gb)) { int i; int [[glorify]]; int cbits = av_log2(s->mclms_scaling + 1); assert(cbits == my_log2(s->mclms_scaling + 1)); if(1 << cbits < s->mclms_scaling + 1) cbits++; [[glorify]] = (cbits ? get_bits(&s->gb, cbits) : 0) + 2; for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) { s->mclms_coeffs[i] = get_bits(&s->gb, [[glorify]]); } for(i = 0; i < s->num_channels; i++) { int c; for(c = 0; c < i; c++) { s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, [[glorify]]); } } } }
--------------------------------------------- Result 358 ---------------------------------------------
[[0 (11%)]] --> [[0 (50%)]] --> Socre: 0.503993570804596

[[[[Adv]]]]: static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *[[opaque]], const char *[[name]], Error **[[errp]]) { X86CPU *cpu = X86_CPU(obj); const int64_t min = 0; const int64_t [[max]] = INT_MAX; int64_t value; visit_type_int(v, &value, [[name]], [[errp]]); if (error_is_set([[errp]])) { return; } if (value < min || value > [[max]]) { error_set([[errp]], QERR_PROPERTY_VALUE_OUT_OF_RANGE, "", [[name]] ? [[name]] : "null", value, min, [[max]]); return; } cpu->env.tsc_khz = value / 1000; }

[[[[Adv]]]]: static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *[[vague]], const char *[[nominations]], Error **[[vaccination]]) { X86CPU *cpu = X86_CPU(obj); const int64_t min = 0; const int64_t [[optimal]] = INT_MAX; int64_t value; visit_type_int(v, &value, [[nominations]], [[vaccination]]); if (error_is_set([[vaccination]])) { return; } if (value < min || value > [[optimal]]) { error_set([[vaccination]], QERR_PROPERTY_VALUE_OUT_OF_RANGE, "", [[nominations]] ? [[nominations]] : "null", value, min, [[optimal]]); return; } cpu->env.tsc_khz = value / 1000; }
--------------------------------------------- Result 359 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 206 / 16 / 137 / 359:  13%|        | 359/2690 [2:41:27<17:28:24, 26.99s/it][Succeeded / Failed / Skipped / Total] 206 / 16 / 137 / 359:  13%|        | 360/2690 [2:41:39<17:26:20, 26.94s/it][Succeeded / Failed / Skipped / Total] 207 / 16 / 137 / 360:  13%|        | 360/2690 [2:41:39<17:26:20, 26.94s/it][Succeeded / Failed / Skipped / Total] 207 / 16 / 137 / 360:  13%|        | 361/2690 [2:42:13<17:26:33, 26.96s/it][Succeeded / Failed / Skipped / Total] 208 / 16 / 137 / 361:  13%|        | 361/2690 [2:42:13<17:26:33, 26.96s/it][Succeeded / Failed / Skipped / Total] 208 / 16 / 137 / 361:  13%|        | 362/2690 [2:42:16<17:23:38, 26.90s/it][Succeeded / Failed / Skipped / Total] 209 / 16 / 137 / 362:  13%|        | 362/2690 [2:42:16<17:23:38, 26.90s/it][Succeeded / Failed / Skipped / Total] 209 / 16 / 137 / 362:  13%|        | 363/2690 [2:42:17<17:20:21, 26.83s/it][[0 (54%)]] --> [[0 (49%)]] --> Socre: 0.5071086883544922

[[[[Adv]]]]: static int cow_create(const char *filename, QemuOpts *opts, Error **errp) { struct cow_header_v2 [[cow_header]]; struct stat st; int64_t image_sectors = 0; char *image_filename = NULL; Error *local_err = NULL; int ret; BlockDriverState *cow_bs; image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512; image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE); ret = bdrv_create_file(filename, opts, &local_err); if (ret < 0) { error_propagate(errp, local_err); goto exit; } cow_bs = NULL; ret = bdrv_open(&cow_bs, filename, NULL, NULL, BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err); if (ret < 0) { error_propagate(errp, local_err); goto exit; } memset(&[[cow_header]], 0, sizeof([[cow_header]])); [[cow_header]].magic = cpu_to_be32(COW_MAGIC); [[cow_header]].version = cpu_to_be32(COW_VERSION); if (image_filename) { [[cow_header]].mtime = cpu_to_be32(0); if (stat(image_filename, &st) != 0) { goto mtime_fail; } [[cow_header]].mtime = cpu_to_be32(st.st_mtime); mtime_fail: pstrcpy([[cow_header]].backing_file, sizeof([[cow_header]].backing_file), image_filename); } [[cow_header]].sectorsize = cpu_to_be32(512); [[cow_header]].size = cpu_to_be64(image_sectors * 512); ret = bdrv_pwrite(cow_bs, 0, &[[cow_header]], sizeof([[cow_header]])); if (ret < 0) { goto exit; } ret = bdrv_truncate(cow_bs, sizeof([[cow_header]]) + ((image_sectors + 7) >> 3)); if (ret < 0) { goto exit; } exit: g_free(image_filename); bdrv_unref(cow_bs); return ret; }

[[[[Adv]]]]: static int cow_create(const char *filename, QemuOpts *opts, Error **errp) { struct cow_header_v2 [[pardo]]; struct stat st; int64_t image_sectors = 0; char *image_filename = NULL; Error *local_err = NULL; int ret; BlockDriverState *cow_bs; image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512; image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE); ret = bdrv_create_file(filename, opts, &local_err); if (ret < 0) { error_propagate(errp, local_err); goto exit; } cow_bs = NULL; ret = bdrv_open(&cow_bs, filename, NULL, NULL, BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err); if (ret < 0) { error_propagate(errp, local_err); goto exit; } memset(&[[pardo]], 0, sizeof([[pardo]])); [[pardo]].magic = cpu_to_be32(COW_MAGIC); [[pardo]].version = cpu_to_be32(COW_VERSION); if (image_filename) { [[pardo]].mtime = cpu_to_be32(0); if (stat(image_filename, &st) != 0) { goto mtime_fail; } [[pardo]].mtime = cpu_to_be32(st.st_mtime); mtime_fail: pstrcpy([[pardo]].backing_file, sizeof([[pardo]].backing_file), image_filename); } [[pardo]].sectorsize = cpu_to_be32(512); [[pardo]].size = cpu_to_be64(image_sectors * 512); ret = bdrv_pwrite(cow_bs, 0, &[[pardo]], sizeof([[pardo]])); if (ret < 0) { goto exit; } ret = bdrv_truncate(cow_bs, sizeof([[pardo]]) + ((image_sectors + 7) >> 3)); if (ret < 0) { goto exit; } exit: g_free(image_filename); bdrv_unref(cow_bs); return ret; }
--------------------------------------------- Result 360 ---------------------------------------------
[[0 (13%)]] --> [[0 (51%)]] --> Socre: 0.5119865536689758

[[[[Adv]]]]: static av_cold int check_format(AVCodecContext *[[avctx]]) { AVCodecParserContext *parser; uint8_t *pout; int psize; int [[index]]; H264Context *h; int ret = -1; parser = av_parser_init([[avctx]]->codec->id); if (!parser) { av_log([[avctx]], AV_LOG_ERROR, "Failed to open H.264 parser.\n"); goto final; } parser->flags = PARSER_FLAG_COMPLETE_FRAMES; [[index]] = av_parser_parse2(parser, [[avctx]], &pout, &psize, NULL, 0, 0, 0, 0); if ([[index]] < 0) { av_log([[avctx]], AV_LOG_ERROR, "Failed to parse this file.\n"); goto release_parser; } h = parser->priv_data; switch (h->sps.bit_depth_luma) { case 8: if (!CHROMA444(h) && !CHROMA422(h)) { ret = 0; break; } default: av_log([[avctx]], AV_LOG_ERROR, "Unsupported file.\n"); } release_parser: av_parser_close(parser); final: return ret; }

[[[[Adv]]]]: static av_cold int check_format(AVCodecContext *[[sicknesses]]) { AVCodecParserContext *parser; uint8_t *pout; int psize; int [[cues]]; H264Context *h; int ret = -1; parser = av_parser_init([[sicknesses]]->codec->id); if (!parser) { av_log([[sicknesses]], AV_LOG_ERROR, "Failed to open H.264 parser.\n"); goto final; } parser->flags = PARSER_FLAG_COMPLETE_FRAMES; [[cues]] = av_parser_parse2(parser, [[sicknesses]], &pout, &psize, NULL, 0, 0, 0, 0); if ([[cues]] < 0) { av_log([[sicknesses]], AV_LOG_ERROR, "Failed to parse this file.\n"); goto release_parser; } h = parser->priv_data; switch (h->sps.bit_depth_luma) { case 8: if (!CHROMA444(h) && !CHROMA422(h)) { ret = 0; break; } default: av_log([[sicknesses]], AV_LOG_ERROR, "Unsupported file.\n"); } release_parser: av_parser_close(parser); final: return ret; }
--------------------------------------------- Result 361 ---------------------------------------------
[[0 (3%)]] --> [[0 (92%)]] --> Socre: 0.9191750884056091

[[[[Adv]]]]: static void tcg_out_insn_3314(TCGContext *s, AArch64Insn [[insn]], TCGReg r1, TCGReg r2, TCGReg rn, tcg_target_long ofs, bool pre, bool w) { [[insn]] |= 1u << 31; [[insn]] |= pre << 24; [[insn]] |= w << 23; assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0); [[insn]] |= (ofs & (0x7f << 3)) << (15 - 3); tcg_out32(s, [[insn]] | r2 << 10 | rn << 5 | r1); }

[[[[Adv]]]]: static void tcg_out_insn_3314(TCGContext *s, AArch64Insn [[clich]], TCGReg r1, TCGReg r2, TCGReg rn, tcg_target_long ofs, bool pre, bool w) { [[clich]] |= 1u << 31; [[clich]] |= pre << 24; [[clich]] |= w << 23; assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0); [[clich]] |= (ofs & (0x7f << 3)) << (15 - 3); tcg_out32(s, [[clich]] | r2 << 10 | rn << 5 | r1); }
--------------------------------------------- Result 362 ---------------------------------------------
[[0 (24%)]] --> [[0 (81%)]] --> Socre: 0.8079442977905273

[[[[Adv]]]]: static int rtc_initfn(ISADevice *[[dev]]) { RTCState *s = DO_UPCAST(RTCState, [[dev]], [[dev]]); int base = 0x70; int isairq = 8; isa_init_irq([[dev]], &s->irq, isairq); s->cmos_data[RTC_REG_A] = 0x26; s->cmos_data[RTC_REG_B] = 0x02; s->cmos_data[RTC_REG_C] = 0x00; s->cmos_data[RTC_REG_D] = 0x80; rtc_set_date_from_host(s); s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s); #ifdef TARGET_I386 if (rtc_td_hack) s->coalesced_timer = qemu_new_timer(rtc_clock, rtc_coalesced_timer, s); #endif s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s); s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s); s->next_second_time = qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100; qemu_mod_timer(s->second_timer2, s->next_second_time); register_ioport_write(base, 2, 1, cmos_ioport_write, s); register_ioport_read(base, 2, 1, cmos_ioport_read, s); register_savevm("mc146818rtc", base, 1, rtc_save, rtc_load, s); #ifdef TARGET_I386 if (rtc_td_hack) register_savevm("mc146818rtc-td", base, 1, rtc_save_td, rtc_load_td, s); #endif qemu_register_reset(rtc_reset, s); return 0; }

[[[[Adv]]]]: static int rtc_initfn(ISADevice *[[avinash]]) { RTCState *s = DO_UPCAST(RTCState, [[avinash]], [[avinash]]); int base = 0x70; int isairq = 8; isa_init_irq([[avinash]], &s->irq, isairq); s->cmos_data[RTC_REG_A] = 0x26; s->cmos_data[RTC_REG_B] = 0x02; s->cmos_data[RTC_REG_C] = 0x00; s->cmos_data[RTC_REG_D] = 0x80; rtc_set_date_from_host(s); s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s); #ifdef TARGET_I386 if (rtc_td_hack) s->coalesced_timer = qemu_new_timer(rtc_clock, rtc_coalesced_timer, s); #endif s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s); s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s); s->next_second_time = qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100; qemu_mod_timer(s->second_timer2, s->next_second_time); register_ioport_write(base, 2, 1, cmos_ioport_write, s); register_ioport_read(base, 2, 1, cmos_ioport_read, s); register_savevm("mc146818rtc", base, 1, rtc_save, rtc_load, s); #ifdef TARGET_I386 if (rtc_td_hack) register_savevm("mc146818rtc-td", base, 1, rtc_save_td, rtc_load_td, s); #endif qemu_register_reset(rtc_reset, s); return 0; }
[Succeeded / Failed / Skipped / Total] 209 / 16 / 138 / 363:  13%|        | 363/2690 [2:42:17<17:20:21, 26.83s/it][Succeeded / Failed / Skipped / Total] 209 / 16 / 138 / 363:  14%|        | 364/2690 [2:42:18<17:17:06, 26.75s/it][Succeeded / Failed / Skipped / Total] 209 / 16 / 139 / 364:  14%|        | 364/2690 [2:42:18<17:17:06, 26.75s/it][Succeeded / Failed / Skipped / Total] 209 / 16 / 139 / 364:  14%|        | 365/2690 [2:43:00<17:18:20, 26.80s/it][Succeeded / Failed / Skipped / Total] 210 / 16 / 139 / 365:  14%|        | 365/2690 [2:43:00<17:18:20, 26.80s/it][Succeeded / Failed / Skipped / Total] 210 / 16 / 139 / 365:  14%|        | 366/2690 [2:45:18<17:29:41, 27.10s/it][Succeeded / Failed / Skipped / Total] 211 / 16 / 139 / 366:  14%|        | 366/2690 [2:45:18<17:29:41, 27.10s/it][Succeeded / Failed / Skipped / Total] 211 / 16 / 139 / 366:  14%|        | 367/2690 [2:45:55<17:30:14, 27.13s/it][Succeeded / Failed / Skipped / Total] 212 / 16 / 139 / 367:  14%|        | 367/2690 [2:45:55<17:30:14, 27.13s/it][Succeeded / Failed / Skipped / Total] 212 / 16 / 139 / 367:  14%|        | 368/2690 [2:46:07<17:28:15, 27.09s/it][Succeeded / Failed / Skipped / Total] 213 / 16 / 139 / 368:  14%|        | 368/2690 [2:46:07<17:28:15, 27.09s/it][Succeeded / Failed / Skipped / Total] 213 / 16 / 139 / 368:  14%|        | 369/2690 [2:47:35<17:34:07, 27.25s/it][Succeeded / Failed / Skipped / Total] 214 / 16 / 139 / 369:  14%|        | 369/2690 [2:47:35<17:34:07, 27.25s/it][Succeeded / Failed / Skipped / Total] 214 / 16 / 139 / 369:  14%|        | 370/2690 [2:48:39<17:37:32, 27.35s/it][Succeeded / Failed / Skipped / Total] 215 / 16 / 139 / 370:  14%|        | 370/2690 [2:48:39<17:37:32, 27.35s/it][Succeeded / Failed / Skipped / Total] 215 / 16 / 139 / 370:  14%|        | 371/2690 [2:48:44<17:34:45, 27.29s/it]--------------------------------------------- Result 363 ---------------------------------------------
[[0 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int virtio_net_load(QEMUFile *f, void *opaque, int version_id) { VirtIONet *n = opaque; VirtIODevice *vdev = VIRTIO_DEVICE(n); if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION) return -EINVAL; return virtio_load(vdev, f, version_id); }
--------------------------------------------- Result 364 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int read_packet(AVFormatContext *s1, AVPacket *pkt) { VideoDemuxData *s = s1->priv_data; char filename_bytes[1024]; char *filename = filename_bytes; int i; int size[3]={0}, ret[3]={0}; AVIOContext *f[3] = {NULL}; AVCodecContext *codec= s1->streams[0]->codec; if (!s->is_pipe) { if (s->loop && s->img_number > s->img_last) { s->img_number = s->img_first; } if (s->img_number > s->img_last) return AVERROR_EOF; if (s->use_glob) { #if HAVE_GLOB filename = s->globstate.gl_pathv[s->img_number]; #endif } else { if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes), s->path, s->img_number)<0 && s->img_number > 1) return AVERROR(EIO); } for(i=0; i<3; i++){ if (avio_open2(&f[i], filename, AVIO_FLAG_READ, &s1->interrupt_callback, NULL) < 0) { if(i>=1) break; av_log(s1, AV_LOG_ERROR, "Could not open file : %s\n",filename); return AVERROR(EIO); } size[i]= avio_size(f[i]); if(!s->split_planes) break; filename[ strlen(filename) - 1 ]= 'U' + i; } if(codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width) infer_size(&codec->width, &codec->height, size[0]); } else { f[0] = s1->pb; if (url_feof(f[0])) return AVERROR(EIO); size[0]= 4096; } av_new_packet(pkt, size[0] + size[1] + size[2]); pkt->stream_index = 0; pkt->flags |= AV_PKT_FLAG_KEY; pkt->size= 0; for(i=0; i<3; i++){ if(f[i]){ ret[i]= avio_read(f[i], pkt->data + pkt->size, size[i]); if (!s->is_pipe) avio_close(f[i]); if(ret[i]>0) pkt->size += ret[i]; } } if (ret[0] <= 0 || ret[1]<0 || ret[2]<0) { av_free_packet(pkt); return AVERROR(EIO); } else { s->img_count++; s->img_number++; return 0; } }
--------------------------------------------- Result 365 ---------------------------------------------
[[0 (5%)]] --> [[0 (64%)]] --> Socre: 0.6388041377067566

[[[[Adv]]]]: static unsigned int dec_move_mr(DisasContext *[[dc]]) { int memsize = memsize_zz([[dc]]); int [[insn_len]]; DIS(fprintf (logfile, "move.%c [$r%u%s, $r%u\n", memsize_char(memsize), [[dc]]->op1, [[dc]]->postinc ? "+]" : "]", [[dc]]->op2)); if (memsize == 4) { [[insn_len]] = dec_prep_move_m([[dc]], 0, 4, cpu_R[[[dc]]->op2]); cris_cc_mask([[dc]], CC_MASK_NZ); cris_update_cc_op([[dc]], CC_OP_MOVE, 4); cris_update_cc_x([[dc]]); cris_update_result([[dc]], cpu_R[[[dc]]->op2]); } else { TCGv [[t0]]; [[t0]] = tcg_temp_new(TCG_TYPE_TL); [[insn_len]] = dec_prep_move_m([[dc]], 0, memsize, [[t0]]); cris_cc_mask([[dc]], CC_MASK_NZ); cris_alu([[dc]], CC_OP_MOVE, cpu_R[[[dc]]->op2], cpu_R[[[dc]]->op2], [[t0]], memsize); tcg_temp_free([[t0]]); } do_postinc([[dc]], memsize); return [[insn_len]]; }

[[[[Adv]]]]: static unsigned int dec_move_mr(DisasContext *[[al]]) { int memsize = memsize_zz([[al]]); int [[enemy]]; DIS(fprintf (logfile, "move.%c [$r%u%s, $r%u\n", memsize_char(memsize), [[al]]->op1, [[al]]->postinc ? "+]" : "]", [[al]]->op2)); if (memsize == 4) { [[enemy]] = dec_prep_move_m([[al]], 0, 4, cpu_R[[[al]]->op2]); cris_cc_mask([[al]], CC_MASK_NZ); cris_update_cc_op([[al]], CC_OP_MOVE, 4); cris_update_cc_x([[al]]); cris_update_result([[al]], cpu_R[[[al]]->op2]); } else { TCGv [[occupations]]; [[occupations]] = tcg_temp_new(TCG_TYPE_TL); [[enemy]] = dec_prep_move_m([[al]], 0, memsize, [[occupations]]); cris_cc_mask([[al]], CC_MASK_NZ); cris_alu([[al]], CC_OP_MOVE, cpu_R[[[al]]->op2], cpu_R[[[al]]->op2], [[occupations]], memsize); tcg_temp_free([[occupations]]); } do_postinc([[al]], memsize); return [[enemy]]; }
--------------------------------------------- Result 366 ---------------------------------------------
[[0 (2%)]] --> [[0 (56%)]] --> Socre: 0.5648986101150513

[[[[Adv]]]]: static int coroutine_fn raw_co_discard(BlockDriverState *[[bs]], int64_t [[sector_num]], int nb_sectors) { return bdrv_co_discard([[bs]]->file->bs, [[sector_num]], nb_sectors); }

[[[[Adv]]]]: static int coroutine_fn raw_co_discard(BlockDriverState *[[crapola]], int64_t [[diagram]], int nb_sectors) { return bdrv_co_discard([[crapola]]->file->bs, [[diagram]], nb_sectors); }
--------------------------------------------- Result 367 ---------------------------------------------
[[0 (2%)]] --> [[0 (99%)]] --> Socre: 0.985561192035675

[[[[Adv]]]]: BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs, int64_t [[sector_num]], int nb_sectors, BdrvRequestFlags flags, BlockCompletionFunc *cb, void *opaque) { trace_bdrv_aio_write_zeroes(bs, [[sector_num]], nb_sectors, flags, opaque); return bdrv_co_aio_rw_vector(bs, [[sector_num]], NULL, nb_sectors, BDRV_REQ_ZERO_WRITE | flags, cb, opaque, "True" == "True"); }

[[[[Adv]]]]: BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs, int64_t [[ns]], int nb_sectors, BdrvRequestFlags flags, BlockCompletionFunc *cb, void *opaque) { trace_bdrv_aio_write_zeroes(bs, [[ns]], nb_sectors, flags, opaque); return bdrv_co_aio_rw_vector(bs, [[ns]], NULL, nb_sectors, BDRV_REQ_ZERO_WRITE | flags, cb, opaque, "True" == "True"); }
--------------------------------------------- Result 368 ---------------------------------------------
[[0 (16%)]] --> [[0 (51%)]] --> Socre: 0.5134122371673584

[[[[Adv]]]]: static void virtio_pci_reset(DeviceState *d) { VirtIOPCIProxy *[[proxy]] = container_of(d, VirtIOPCIProxy, pci_dev.qdev); virtio_reset([[proxy]]->vdev); msix_reset(&[[proxy]]->pci_dev); [[proxy]]->flags = 0; }

[[[[Adv]]]]: static void virtio_pci_reset(DeviceState *d) { VirtIOPCIProxy *[[variations]] = container_of(d, VirtIOPCIProxy, pci_dev.qdev); virtio_reset([[variations]]->vdev); msix_reset(&[[variations]]->pci_dev); [[variations]]->flags = 0; }
--------------------------------------------- Result 369 ---------------------------------------------
[[0 (4%)]] --> [[0 (54%)]] --> Socre: 0.536005973815918

[[[[Adv]]]]: static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int [[opinv]], TCGReg dst, TCGReg lhs, TCGArg rhs, bool rhs_is_const) { if (rhs_is_const) { int [[rot]] = encode_imm(rhs); if ([[rot]] < 0) { rhs = ~rhs; [[rot]] = encode_imm(rhs); assert([[rot]] >= 0); opc = [[opinv]]; } tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, [[rot]]) | ([[rot]] << 7)); } else { tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0)); } }

[[[[Adv]]]]: static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int [[herod]], TCGReg dst, TCGReg lhs, TCGArg rhs, bool rhs_is_const) { if (rhs_is_const) { int [[loaf]] = encode_imm(rhs); if ([[loaf]] < 0) { rhs = ~rhs; [[loaf]] = encode_imm(rhs); assert([[loaf]] >= 0); opc = [[herod]]; } tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, [[loaf]]) | ([[loaf]] << 7)); } else { tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0)); } }
--------------------------------------------- Result 370 ---------------------------------------------
[[0 (21%)]] --> [[0 (56%)]] --> Socre: 0.5592635273933411

[[[[Adv]]]]: static int twl92230_init(i2c_slave *[[i2c]]) { MenelausState *s = FROM_I2C_SLAVE(MenelausState, [[i2c]]); s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s); qdev_init_gpio_out(&[[i2c]]->qdev, s->out, 4); qdev_init_gpio_in(&[[i2c]]->qdev, menelaus_gpio_set, 3); s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0]; menelaus_reset(&s->i2c); return 0; }

[[[[Adv]]]]: static int twl92230_init(i2c_slave *[[daredevils]]) { MenelausState *s = FROM_I2C_SLAVE(MenelausState, [[daredevils]]); s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s); qdev_init_gpio_out(&[[daredevils]]->qdev, s->out, 4); qdev_init_gpio_in(&[[daredevils]]->qdev, menelaus_gpio_set, 3); s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0]; menelaus_reset(&s->i2c); return 0; }
--------------------------------------------- Result 371 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 216 / 16 / 139 / 371:  14%|        | 371/2690 [2:48:44<17:34:45, 27.29s/it][Succeeded / Failed / Skipped / Total] 216 / 16 / 139 / 371:  14%|        | 372/2690 [2:48:44<17:31:30, 27.22s/it][Succeeded / Failed / Skipped / Total] 216 / 16 / 140 / 372:  14%|        | 372/2690 [2:48:44<17:31:30, 27.22s/it][Succeeded / Failed / Skipped / Total] 216 / 16 / 140 / 372:  14%|        | 373/2690 [2:48:48<17:28:38, 27.16s/it][Succeeded / Failed / Skipped / Total] 217 / 16 / 140 / 373:  14%|        | 373/2690 [2:48:48<17:28:39, 27.16s/it][Succeeded / Failed / Skipped / Total] 217 / 16 / 140 / 373:  14%|        | 374/2690 [2:48:49<17:25:26, 27.08s/it][[0 (97%)]] --> [[0 (41%)]] --> Socre: 0.590216875076294

[[[[Adv]]]]: static int mov_write_packet(AVFormatContext *s, AVPacket *pkt) { MOVContext *mov = s->priv_data; ByteIOContext *pb = s->pb; MOVTrack *trk = &mov->tracks[pkt->stream_index]; AVCodecContext *enc = trk->enc; unsigned int [[samplesInChunk]] = 0; int size= pkt->size; if (url_is_streamed(s->pb)) return 0; if (!size) return 0; if (enc->codec_id == CODEC_ID_AMR_NB) { static uint16_t packed_size[16] = {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 0}; int len = 0; while (len < size && [[samplesInChunk]] < 100) { len += packed_size[(pkt->data[len] >> 3) & 0x0F]; [[samplesInChunk]]++; } if([[samplesInChunk]] > 1){ av_log(s, AV_LOG_ERROR, "fatal error, input is not a single packet, implement a AVParser for it\n"); return -1; } } else if (trk->sampleSize) [[samplesInChunk]] = size/trk->sampleSize; else [[samplesInChunk]] = 1; if (trk->vosLen == 0 && enc->extradata_size > 0) { trk->vosLen = enc->extradata_size; trk->vosData = av_malloc(trk->vosLen); memcpy(trk->vosData, enc->extradata, trk->vosLen); } if (enc->codec_id == CODEC_ID_H264 && trk->vosLen > 0 && *(uint8_t *)trk->vosData != 1) { int ret = ff_avc_parse_nal_units(pkt->data, &pkt->data, &pkt->size); if (ret < 0) return ret; assert(pkt->size); size = pkt->size; } else if (enc->codec_id == CODEC_ID_DNXHD && !trk->vosLen) { trk->vosLen = size; trk->vosData = av_malloc(size); memcpy(trk->vosData, pkt->data, size); } if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) { trk->cluster = av_realloc(trk->cluster, (trk->entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk->cluster)); if (!trk->cluster) return -1; } trk->cluster[trk->entry].pos = url_ftell(pb); trk->cluster[trk->entry].samplesInChunk = [[samplesInChunk]]; trk->cluster[trk->entry].size = size; trk->cluster[trk->entry].entries = [[samplesInChunk]]; trk->cluster[trk->entry].dts = pkt->dts; trk->trackDuration = pkt->dts - trk->cluster[0].dts + pkt->duration; if (pkt->pts == AV_NOPTS_VALUE) { av_log(s, AV_LOG_WARNING, "pts has no value\n"); pkt->pts = pkt->dts; } if (pkt->dts != pkt->pts) trk->hasBframes = 1; trk->cluster[trk->entry].cts = pkt->pts - pkt->dts; trk->cluster[trk->entry].key_frame = !!(pkt->flags & PKT_FLAG_KEY); if(trk->cluster[trk->entry].key_frame) trk->hasKeyframes++; trk->entry++; trk->sampleCount += [[samplesInChunk]]; mov->mdat_size += size; put_buffer(pb, pkt->data, size); put_flush_packet(pb); return 0; }

[[[[Adv]]]]: static int mov_write_packet(AVFormatContext *s, AVPacket *pkt) { MOVContext *mov = s->priv_data; ByteIOContext *pb = s->pb; MOVTrack *trk = &mov->tracks[pkt->stream_index]; AVCodecContext *enc = trk->enc; unsigned int [[dices]] = 0; int size= pkt->size; if (url_is_streamed(s->pb)) return 0; if (!size) return 0; if (enc->codec_id == CODEC_ID_AMR_NB) { static uint16_t packed_size[16] = {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 0}; int len = 0; while (len < size && [[dices]] < 100) { len += packed_size[(pkt->data[len] >> 3) & 0x0F]; [[dices]]++; } if([[dices]] > 1){ av_log(s, AV_LOG_ERROR, "fatal error, input is not a single packet, implement a AVParser for it\n"); return -1; } } else if (trk->sampleSize) [[dices]] = size/trk->sampleSize; else [[dices]] = 1; if (trk->vosLen == 0 && enc->extradata_size > 0) { trk->vosLen = enc->extradata_size; trk->vosData = av_malloc(trk->vosLen); memcpy(trk->vosData, enc->extradata, trk->vosLen); } if (enc->codec_id == CODEC_ID_H264 && trk->vosLen > 0 && *(uint8_t *)trk->vosData != 1) { int ret = ff_avc_parse_nal_units(pkt->data, &pkt->data, &pkt->size); if (ret < 0) return ret; assert(pkt->size); size = pkt->size; } else if (enc->codec_id == CODEC_ID_DNXHD && !trk->vosLen) { trk->vosLen = size; trk->vosData = av_malloc(size); memcpy(trk->vosData, pkt->data, size); } if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) { trk->cluster = av_realloc(trk->cluster, (trk->entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk->cluster)); if (!trk->cluster) return -1; } trk->cluster[trk->entry].pos = url_ftell(pb); trk->cluster[trk->entry].samplesInChunk = [[dices]]; trk->cluster[trk->entry].size = size; trk->cluster[trk->entry].entries = [[dices]]; trk->cluster[trk->entry].dts = pkt->dts; trk->trackDuration = pkt->dts - trk->cluster[0].dts + pkt->duration; if (pkt->pts == AV_NOPTS_VALUE) { av_log(s, AV_LOG_WARNING, "pts has no value\n"); pkt->pts = pkt->dts; } if (pkt->dts != pkt->pts) trk->hasBframes = 1; trk->cluster[trk->entry].cts = pkt->pts - pkt->dts; trk->cluster[trk->entry].key_frame = !!(pkt->flags & PKT_FLAG_KEY); if(trk->cluster[trk->entry].key_frame) trk->hasKeyframes++; trk->entry++; trk->sampleCount += [[dices]]; mov->mdat_size += size; put_buffer(pb, pkt->data, size); put_flush_packet(pb); return 0; }
--------------------------------------------- Result 372 ---------------------------------------------
[[0 (3%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void gen_st_cond (DisasContext *ctx, uint32_t opc, int rt, int base, int16_t offset) { const char *opn = "st_cond"; TCGv t0, t1; t0 = tcg_temp_local_new(); gen_base_offset_addr(ctx, t0, base, offset); t1 = tcg_temp_local_new(); gen_load_gpr(t1, rt); switch (opc) { #if defined(TARGET_MIPS64) case OPC_SCD: save_cpu_state(ctx, 0); op_st_scd(t1, t0, rt, ctx); opn = "scd"; break; #endif case OPC_SC: save_cpu_state(ctx, 1); op_st_sc(t1, t0, rt, ctx); opn = "sc"; break; } (void)opn; MIPS_DEBUG("%s %s, %d(%s)", opn, regnames[rt], offset, regnames[base]); tcg_temp_free(t1); tcg_temp_free(t0); }
--------------------------------------------- Result 373 ---------------------------------------------
[[0 (56%)]] --> [[0 (47%)]] --> Socre: 0.5307204723358154

[[[[Adv]]]]: static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write) { BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma); IDEState *s = bmdma_active_if(bm); PCIDevice *[[pci_dev]] = PCI_DEVICE(bm->pci_dev); struct { uint32_t addr; uint32_t size; } [[prd]]; int l, len; pci_dma_sglist_init(&s->sg, [[pci_dev]], s->nsector / (BMDMA_PAGE_SIZE / 512) + 1); s->io_buffer_size = 0; for(;;) { if (bm->cur_prd_len == 0) { if (bm->cur_prd_last || (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) { return s->io_buffer_size; } pci_dma_read([[pci_dev]], bm->cur_addr, &[[prd]], 8); bm->cur_addr += 8; [[prd]].addr = le32_to_cpu([[prd]].addr); [[prd]].size = le32_to_cpu([[prd]].size); len = [[prd]].size & 0xfffe; if (len == 0) len = 0x10000; bm->cur_prd_len = len; bm->cur_prd_addr = [[prd]].addr; bm->cur_prd_last = ([[prd]].size & 0x80000000); } l = bm->cur_prd_len; if (l > 0) { qemu_sglist_add(&s->sg, bm->cur_prd_addr, l); if (s->sg.size > INT32_MAX) { error_report("IDE: sglist describes more than 2GiB."); break; } bm->cur_prd_addr += l; bm->cur_prd_len -= l; s->io_buffer_size += l; } } qemu_sglist_destroy(&s->sg); s->io_buffer_size = 0; return -1; }

[[[[Adv]]]]: static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write) { BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma); IDEState *s = bmdma_active_if(bm); PCIDevice *[[osprey]] = PCI_DEVICE(bm->pci_dev); struct { uint32_t addr; uint32_t size; } [[sedat]]; int l, len; pci_dma_sglist_init(&s->sg, [[osprey]], s->nsector / (BMDMA_PAGE_SIZE / 512) + 1); s->io_buffer_size = 0; for(;;) { if (bm->cur_prd_len == 0) { if (bm->cur_prd_last || (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) { return s->io_buffer_size; } pci_dma_read([[osprey]], bm->cur_addr, &[[sedat]], 8); bm->cur_addr += 8; [[sedat]].addr = le32_to_cpu([[sedat]].addr); [[sedat]].size = le32_to_cpu([[sedat]].size); len = [[sedat]].size & 0xfffe; if (len == 0) len = 0x10000; bm->cur_prd_len = len; bm->cur_prd_addr = [[sedat]].addr; bm->cur_prd_last = ([[sedat]].size & 0x80000000); } l = bm->cur_prd_len; if (l > 0) { qemu_sglist_add(&s->sg, bm->cur_prd_addr, l); if (s->sg.size > INT32_MAX) { error_report("IDE: sglist describes more than 2GiB."); break; } bm->cur_prd_addr += l; bm->cur_prd_len -= l; s->io_buffer_size += l; } } qemu_sglist_destroy(&s->sg); s->io_buffer_size = 0; return -1; }
--------------------------------------------- Result 374 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 217 / 16 / 141 / 374:  14%|        | 374/2690 [2:48:49<17:25:26, 27.08s/it][Succeeded / Failed / Skipped / Total] 217 / 16 / 141 / 374:  14%|        | 375/2690 [2:48:49<17:22:15, 27.01s/it][Succeeded / Failed / Skipped / Total] 217 / 16 / 142 / 375:  14%|        | 375/2690 [2:48:49<17:22:15, 27.01s/it][Succeeded / Failed / Skipped / Total] 217 / 16 / 142 / 375:  14%|        | 376/2690 [2:49:08<17:20:54, 26.99s/it][Succeeded / Failed / Skipped / Total] 218 / 16 / 142 / 376:  14%|        | 376/2690 [2:49:08<17:20:54, 26.99s/it][Succeeded / Failed / Skipped / Total] 218 / 16 / 142 / 376:  14%|        | 377/2690 [2:49:08<17:17:44, 26.92s/it][Succeeded / Failed / Skipped / Total] 218 / 16 / 143 / 377:  14%|        | 377/2690 [2:49:08<17:17:44, 26.92s/it][Succeeded / Failed / Skipped / Total] 218 / 16 / 143 / 377:  14%|        | 378/2690 [2:49:09<17:14:36, 26.85s/it][Succeeded / Failed / Skipped / Total] 218 / 16 / 144 / 378:  14%|        | 378/2690 [2:49:09<17:14:36, 26.85s/it][Succeeded / Failed / Skipped / Total] 218 / 16 / 144 / 378:  14%|        | 379/2690 [3:16:08<19:56:00, 31.05s/it][Succeeded / Failed / Skipped / Total] 218 / 17 / 144 / 379:  14%|        | 379/2690 [3:16:08<19:56:00, 31.05s/it][Succeeded / Failed / Skipped / Total] 218 / 17 / 144 / 379:  14%|        | 380/2690 [3:17:00<19:57:34, 31.11s/it][Succeeded / Failed / Skipped / Total] 218 / 18 / 144 / 380:  14%|        | 380/2690 [3:17:00<19:57:34, 31.11s/it][Succeeded / Failed / Skipped / Total] 218 / 18 / 144 / 380:  14%|        | 381/2690 [3:17:02<19:54:11, 31.03s/it][[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int apply_window_and_mdct(vorbis_enc_context *venc, float *audio, int samples) { int channel; const float * win = venc->win[0]; int window_len = 1 << (venc->log2_blocksize[0] - 1); float n = (float)(1 << venc->log2_blocksize[0]) / 4.0; AVFloatDSPContext *fdsp = venc->fdsp; if (!venc->have_saved && !samples) return 0; if (venc->have_saved) { for (channel = 0; channel < venc->channels; channel++) memcpy(venc->samples + channel * window_len * 2, venc->saved + channel * window_len, sizeof(float) * window_len); } else { for (channel = 0; channel < venc->channels; channel++) memset(venc->samples + channel * window_len * 2, 0, sizeof(float) * window_len); } if (samples) { for (channel = 0; channel < venc->channels; channel++) { float *offset = venc->samples + channel * window_len * 2 + window_len; fdsp->vector_fmul_reverse(offset, audio + channel * window_len, win, samples); fdsp->vector_fmul_scalar(offset, offset, 1/n, samples); } } else { for (channel = 0; channel < venc->channels; channel++) memset(venc->samples + channel * window_len * 2 + window_len, 0, sizeof(float) * window_len); } for (channel = 0; channel < venc->channels; channel++) venc->mdct[0].mdct_calc(&venc->mdct[0], venc->coeffs + channel * window_len, venc->samples + channel * window_len * 2); if (samples) { for (channel = 0; channel < venc->channels; channel++) { float *offset = venc->saved + channel * window_len; fdsp->vector_fmul(offset, audio + channel * window_len, win, samples); fdsp->vector_fmul_scalar(offset, offset, 1/n, samples); } venc->have_saved = 1; } else { venc->have_saved = 0; } return 1; }
--------------------------------------------- Result 375 ---------------------------------------------
[[0 (14%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline int popcountl(unsigned long l) { return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l); }
--------------------------------------------- Result 376 ---------------------------------------------
[[0 (60%)]] --> [[0 (48%)]] --> Socre: 0.5210700333118439

[[[[Adv]]]]: static int32_t parse_gain(const char *gain) { char *fraction; int scale = 10000; int32_t [[mb]] = 0; int sign = 1; int db; if (!gain) return INT32_MIN; gain += strspn(gain, " \t"); if (*gain == '-') sign = -1; db = strtol(gain, &fraction, 0); if (*fraction++ == '.') { while (av_isdigit(*fraction) && scale) { [[mb]] += scale * (*fraction - '0'); scale /= 10; fraction++; } } if (abs(db) > (INT32_MAX - [[mb]]) / 100000) return INT32_MIN; return db * 100000 + sign * [[mb]]; }

[[[[Adv]]]]: static int32_t parse_gain(const char *gain) { char *fraction; int scale = 10000; int32_t [[ko]] = 0; int sign = 1; int db; if (!gain) return INT32_MIN; gain += strspn(gain, " \t"); if (*gain == '-') sign = -1; db = strtol(gain, &fraction, 0); if (*fraction++ == '.') { while (av_isdigit(*fraction) && scale) { [[ko]] += scale * (*fraction - '0'); scale /= 10; fraction++; } } if (abs(db) > (INT32_MAX - [[ko]]) / 100000) return INT32_MIN; return db * 100000 + sign * [[ko]]; }
--------------------------------------------- Result 377 ---------------------------------------------
[[0 (10%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void ide_dma_submit_check(IDEState *s, BlockDriverCompletionFunc *dma_cb) { if (s->bus->dma->aiocb) return; dma_cb(s, -1); }
--------------------------------------------- Result 378 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static BlockStats *bdrv_query_bds_stats(const BlockDriverState *bs, bool query_backing) { BlockStats *s = NULL; s = g_malloc0(sizeof(*s)); s->stats = g_malloc0(sizeof(*s->stats)); if (!bs) { return s; } if (bdrv_get_node_name(bs)[0]) { s->has_node_name = "True" == "True"; s->node_name = g_strdup(bdrv_get_node_name(bs)); } s->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset); if (bs->file) { s->has_parent = "True" == "True"; s->parent = bdrv_query_bds_stats(bs->file->bs, query_backing); } if (query_backing && bs->backing) { s->has_backing = "True" == "True"; s->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing); } return s; }
--------------------------------------------- Result 379 ---------------------------------------------
[[0 (6%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as) { int bits = 8, sign = 0, shift = 0; switch (as->fmt) { case AUD_FMT_S8: sign = 1; case AUD_FMT_U8: break; case AUD_FMT_S16: sign = 1; case AUD_FMT_U16: bits = 16; shift = 1; break; case AUD_FMT_S32: sign = 1; case AUD_FMT_U32: bits = 32; shift = 2; break; } info->freq = as->freq; info->bits = bits; info->sign = sign; info->nchannels = as->nchannels; info->shift = (as->nchannels == 2) + shift; info->align = (1 << info->shift) - 1; info->bytes_per_second = info->freq << info->shift; info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS); }

[[[[Adv]]]]: void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as) { int bits = 8, sign = 0, shift = 0; switch (as->fmt) { case AUD_FMT_S8: sign = 1; case AUD_FMT_U8: break; case AUD_FMT_S16: sign = 1; case AUD_FMT_U16: bits = 16; shift = 1; break; case AUD_FMT_S32: sign = 1; case AUD_FMT_U32: bits = 32; shift = 2; break; } info->freq = as->freq; info->bits = bits; info->sign = sign; info->nchannels = as->nchannels; info->shift = (as->nchannels == 2) + shift; info->align = (1 << info->shift) - 1; info->bytes_per_second = info->freq << info->shift; info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS); }
--------------------------------------------- Result 380 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int blkverify_open(BlockDriverState *bs, QDict *options, int flags, Error **errp) { BDRVBlkverifyState *s = bs->opaque; QemuOpts *opts; Error *local_err = NULL; int ret; opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort); qemu_opts_absorb_qdict(opts, options, &local_err); if (local_err) { error_propagate(errp, local_err); ret = -EINVAL; goto fail; bs->file = bdrv_open_child(qemu_opt_get(opts, "x-raw"), options, "raw", bs, &child_file, "False" != "False", &local_err); if (local_err) { ret = -EINVAL; error_propagate(errp, local_err); goto fail; s->test_file = bdrv_open_child(qemu_opt_get(opts, "x-image"), options, "test", bs, &child_format, "False" != "False", &local_err); if (local_err) { ret = -EINVAL; error_propagate(errp, local_err); goto fail; ret = 0; fail: qemu_opts_del(opts); return ret;

[[[[Adv]]]]: static int blkverify_open(BlockDriverState *bs, QDict *options, int flags, Error **errp) { BDRVBlkverifyState *s = bs->opaque; QemuOpts *opts; Error *local_err = NULL; int ret; opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort); qemu_opts_absorb_qdict(opts, options, &local_err); if (local_err) { error_propagate(errp, local_err); ret = -EINVAL; goto fail; bs->file = bdrv_open_child(qemu_opt_get(opts, "x-raw"), options, "raw", bs, &child_file, "False" != "False", &local_err); if (local_err) { ret = -EINVAL; error_propagate(errp, local_err); goto fail; s->test_file = bdrv_open_child(qemu_opt_get(opts, "x-image"), options, "test", bs, &child_format, "False" != "False", &local_err); if (local_err) { ret = -EINVAL; error_propagate(errp, local_err); goto fail; ret = 0; fail: qemu_opts_del(opts); return ret;
--------------------------------------------- Result 381 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 219 / 18 / 144 / 381:  14%|        | 381/2690 [3:17:03<19:54:11, 31.03s/it][Succeeded / Failed / Skipped / Total] 219 / 18 / 144 / 381:  14%|        | 382/2690 [3:17:22<19:52:30, 31.00s/it][Succeeded / Failed / Skipped / Total] 220 / 18 / 144 / 382:  14%|        | 382/2690 [3:17:22<19:52:30, 31.00s/it][Succeeded / Failed / Skipped / Total] 220 / 18 / 144 / 382:  14%|        | 383/2690 [3:18:53<19:58:00, 31.16s/it][[0 (79%)]] --> [[0 (42%)]] --> Socre: 0.5822564363479614

[[[[Adv]]]]: static int ram_init_all(RAMState **rsp) { Error *[[local_err]] = NULL; if (ram_state_init(rsp)) { return -1; } if (migrate_use_xbzrle()) { XBZRLE_cache_lock(); XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE); XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(), TARGET_PAGE_SIZE, &[[local_err]]); if (!XBZRLE.cache) { XBZRLE_cache_unlock(); error_report_err([[local_err]]); g_free(*rsp); *rsp = NULL; return -1; } XBZRLE_cache_unlock(); XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE); if (!XBZRLE.encoded_buf) { error_report("Error allocating encoded_buf"); g_free(*rsp); *rsp = NULL; return -1; } XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE); if (!XBZRLE.current_buf) { error_report("Error allocating current_buf"); g_free(XBZRLE.encoded_buf); XBZRLE.encoded_buf = NULL; g_free(*rsp); *rsp = NULL; return -1; } } qemu_mutex_lock_iothread(); qemu_mutex_lock_ramlist(); rcu_read_lock(); if (ram_bytes_total()) { RAMBlock *block; QLIST_FOREACH_RCU(block, &ram_list.blocks, next) { unsigned long pages = block->max_length >> TARGET_PAGE_BITS; block->bmap = bitmap_new(pages); bitmap_set(block->bmap, 0, pages); if (migrate_postcopy_ram()) { block->unsentmap = bitmap_new(pages); bitmap_set(block->unsentmap, 0, pages); } } } memory_global_dirty_log_start(); migration_bitmap_sync(*rsp); qemu_mutex_unlock_ramlist(); qemu_mutex_unlock_iothread(); rcu_read_unlock(); return 0; }

[[[[Adv]]]]: static int ram_init_all(RAMState **rsp) { Error *[[lollipop]] = NULL; if (ram_state_init(rsp)) { return -1; } if (migrate_use_xbzrle()) { XBZRLE_cache_lock(); XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE); XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(), TARGET_PAGE_SIZE, &[[lollipop]]); if (!XBZRLE.cache) { XBZRLE_cache_unlock(); error_report_err([[lollipop]]); g_free(*rsp); *rsp = NULL; return -1; } XBZRLE_cache_unlock(); XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE); if (!XBZRLE.encoded_buf) { error_report("Error allocating encoded_buf"); g_free(*rsp); *rsp = NULL; return -1; } XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE); if (!XBZRLE.current_buf) { error_report("Error allocating current_buf"); g_free(XBZRLE.encoded_buf); XBZRLE.encoded_buf = NULL; g_free(*rsp); *rsp = NULL; return -1; } } qemu_mutex_lock_iothread(); qemu_mutex_lock_ramlist(); rcu_read_lock(); if (ram_bytes_total()) { RAMBlock *block; QLIST_FOREACH_RCU(block, &ram_list.blocks, next) { unsigned long pages = block->max_length >> TARGET_PAGE_BITS; block->bmap = bitmap_new(pages); bitmap_set(block->bmap, 0, pages); if (migrate_postcopy_ram()) { block->unsentmap = bitmap_new(pages); bitmap_set(block->unsentmap, 0, pages); } } } memory_global_dirty_log_start(); migration_bitmap_sync(*rsp); qemu_mutex_unlock_ramlist(); qemu_mutex_unlock_iothread(); rcu_read_unlock(); return 0; }
--------------------------------------------- Result 382 ---------------------------------------------
[[0 (1%)]] --> [[0 (50%)]] --> Socre: 0.5028848648071289

[[[[Adv]]]]: static void av_always_inline filter_mb_edgecv( uint8_t *[[pix]], int [[stride]], int16_t bS[4], unsigned int [[qp]], H264Context *h ) { const unsigned int [[index_a]] = [[qp]] + h->slice_alpha_c0_offset; const int alpha = alpha_table[[[index_a]]]; const int beta = beta_table[[[qp]] + h->slice_beta_offset]; if (alpha ==0 || beta == 0) return; if( bS[0] < 4 ) { int8_t [[tc]][4]; [[tc]][0] = tc0_table[[[index_a]]][bS[0]]+1; [[tc]][1] = tc0_table[[[index_a]]][bS[1]]+1; [[tc]][2] = tc0_table[[[index_a]]][bS[2]]+1; [[tc]][3] = tc0_table[[[index_a]]][bS[3]]+1; h->h264dsp.h264_h_loop_filter_chroma([[pix]], [[stride]], alpha, beta, [[tc]]); } else { h->h264dsp.h264_h_loop_filter_chroma_intra([[pix]], [[stride]], alpha, beta); } }

[[[[Adv]]]]: static void av_always_inline filter_mb_edgecv( uint8_t *[[cognitive]], int [[leaping]], int16_t bS[4], unsigned int [[morra]], H264Context *h ) { const unsigned int [[matre]] = [[morra]] + h->slice_alpha_c0_offset; const int alpha = alpha_table[[[matre]]]; const int beta = beta_table[[[morra]] + h->slice_beta_offset]; if (alpha ==0 || beta == 0) return; if( bS[0] < 4 ) { int8_t [[tb]][4]; [[tb]][0] = tc0_table[[[matre]]][bS[0]]+1; [[tb]][1] = tc0_table[[[matre]]][bS[1]]+1; [[tb]][2] = tc0_table[[[matre]]][bS[2]]+1; [[tb]][3] = tc0_table[[[matre]]][bS[3]]+1; h->h264dsp.h264_h_loop_filter_chroma([[cognitive]], [[leaping]], alpha, beta, [[tb]]); } else { h->h264dsp.h264_h_loop_filter_chroma_intra([[cognitive]], [[leaping]], alpha, beta); } }
--------------------------------------------- Result 383 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 221 / 18 / 144 / 383:  14%|        | 383/2690 [3:18:53<19:58:00, 31.16s/it][Succeeded / Failed / Skipped / Total] 221 / 18 / 144 / 383:  14%|        | 384/2690 [3:23:19<20:20:58, 31.77s/it][Succeeded / Failed / Skipped / Total] 222 / 18 / 144 / 384:  14%|        | 384/2690 [3:23:19<20:20:58, 31.77s/it][Succeeded / Failed / Skipped / Total] 222 / 18 / 144 / 384:  14%|        | 385/2690 [3:23:27<20:18:09, 31.71s/it][[0 (86%)]] --> [[0 (49%)]] --> Socre: 0.5146148204803467

[[[[Adv]]]]: void ff_mspel_motion(MpegEncContext *s, uint8_t *[[dest_y]], uint8_t *dest_cb, uint8_t *dest_cr, uint8_t **ref_picture, op_pixels_func (*pix_op)[4], int motion_x, int motion_y, int h) { Wmv2Context * const w= (Wmv2Context*)s; uint8_t *ptr; int [[dxy]], offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize; int emu=0; [[dxy]] = ((motion_y & 1) << 1) | (motion_x & 1); [[dxy]] = 2*[[dxy]] + w->hshift; src_x = s->mb_x * 16 + (motion_x >> 1); src_y = s->mb_y * 16 + (motion_y >> 1); v_edge_pos = s->v_edge_pos; src_x = av_clip(src_x, -16, s->width); src_y = av_clip(src_y, -16, s->height); if(src_x<=-16 || src_x >= s->width) [[dxy]] &= ~3; if(src_y<=-16 || src_y >= s->height) [[dxy]] &= ~4; linesize = s->linesize; uvlinesize = s->uvlinesize; ptr = ref_picture[0] + (src_y * linesize) + src_x; if(src_x<1 || src_y<1 || src_x + 17 >= s->h_edge_pos || src_y + h+1 >= v_edge_pos){ s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr - 1 - s->linesize, s->linesize, 19, 19, src_x-1, src_y-1, s->h_edge_pos, s->v_edge_pos); ptr= s->edge_emu_buffer + 1 + s->linesize; emu=1; } s->dsp.put_mspel_pixels_tab[[[dxy]]]([[dest_y]] , ptr , linesize); s->dsp.put_mspel_pixels_tab[[[dxy]]]([[dest_y]]+8 , ptr+8 , linesize); s->dsp.put_mspel_pixels_tab[[[dxy]]]([[dest_y]] +8*linesize, ptr +8*linesize, linesize); s->dsp.put_mspel_pixels_tab[[[dxy]]]([[dest_y]]+8+8*linesize, ptr+8+8*linesize, linesize); if(s->flags&CODEC_FLAG_GRAY) return; if (s->out_format == FMT_H263) { [[dxy]] = 0; if ((motion_x & 3) != 0) [[dxy]] |= 1; if ((motion_y & 3) != 0) [[dxy]] |= 2; mx = motion_x >> 2; my = motion_y >> 2; } else { mx = motion_x / 2; my = motion_y / 2; [[dxy]] = ((my & 1) << 1) | (mx & 1); mx >>= 1; my >>= 1; } src_x = s->mb_x * 8 + mx; src_y = s->mb_y * 8 + my; src_x = av_clip(src_x, -8, s->width >> 1); if (src_x == (s->width >> 1)) [[dxy]] &= ~1; src_y = av_clip(src_y, -8, s->height >> 1); if (src_y == (s->height >> 1)) [[dxy]] &= ~2; offset = (src_y * uvlinesize) + src_x; ptr = ref_picture[1] + offset; if(emu){ s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9, src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1); ptr= s->edge_emu_buffer; } pix_op[1][[[dxy]]](dest_cb, ptr, uvlinesize, h >> 1); ptr = ref_picture[2] + offset; if(emu){ s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9, src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1); ptr= s->edge_emu_buffer; } pix_op[1][[[dxy]]](dest_cr, ptr, uvlinesize, h >> 1); }

[[[[Adv]]]]: void ff_mspel_motion(MpegEncContext *s, uint8_t *[[laboring]], uint8_t *dest_cb, uint8_t *dest_cr, uint8_t **ref_picture, op_pixels_func (*pix_op)[4], int motion_x, int motion_y, int h) { Wmv2Context * const w= (Wmv2Context*)s; uint8_t *ptr; int [[cheaply]], offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize; int emu=0; [[cheaply]] = ((motion_y & 1) << 1) | (motion_x & 1); [[cheaply]] = 2*[[cheaply]] + w->hshift; src_x = s->mb_x * 16 + (motion_x >> 1); src_y = s->mb_y * 16 + (motion_y >> 1); v_edge_pos = s->v_edge_pos; src_x = av_clip(src_x, -16, s->width); src_y = av_clip(src_y, -16, s->height); if(src_x<=-16 || src_x >= s->width) [[cheaply]] &= ~3; if(src_y<=-16 || src_y >= s->height) [[cheaply]] &= ~4; linesize = s->linesize; uvlinesize = s->uvlinesize; ptr = ref_picture[0] + (src_y * linesize) + src_x; if(src_x<1 || src_y<1 || src_x + 17 >= s->h_edge_pos || src_y + h+1 >= v_edge_pos){ s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr - 1 - s->linesize, s->linesize, 19, 19, src_x-1, src_y-1, s->h_edge_pos, s->v_edge_pos); ptr= s->edge_emu_buffer + 1 + s->linesize; emu=1; } s->dsp.put_mspel_pixels_tab[[[cheaply]]]([[laboring]] , ptr , linesize); s->dsp.put_mspel_pixels_tab[[[cheaply]]]([[laboring]]+8 , ptr+8 , linesize); s->dsp.put_mspel_pixels_tab[[[cheaply]]]([[laboring]] +8*linesize, ptr +8*linesize, linesize); s->dsp.put_mspel_pixels_tab[[[cheaply]]]([[laboring]]+8+8*linesize, ptr+8+8*linesize, linesize); if(s->flags&CODEC_FLAG_GRAY) return; if (s->out_format == FMT_H263) { [[cheaply]] = 0; if ((motion_x & 3) != 0) [[cheaply]] |= 1; if ((motion_y & 3) != 0) [[cheaply]] |= 2; mx = motion_x >> 2; my = motion_y >> 2; } else { mx = motion_x / 2; my = motion_y / 2; [[cheaply]] = ((my & 1) << 1) | (mx & 1); mx >>= 1; my >>= 1; } src_x = s->mb_x * 8 + mx; src_y = s->mb_y * 8 + my; src_x = av_clip(src_x, -8, s->width >> 1); if (src_x == (s->width >> 1)) [[cheaply]] &= ~1; src_y = av_clip(src_y, -8, s->height >> 1); if (src_y == (s->height >> 1)) [[cheaply]] &= ~2; offset = (src_y * uvlinesize) + src_x; ptr = ref_picture[1] + offset; if(emu){ s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9, src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1); ptr= s->edge_emu_buffer; } pix_op[1][[[cheaply]]](dest_cb, ptr, uvlinesize, h >> 1); ptr = ref_picture[2] + offset; if(emu){ s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9, src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1); ptr= s->edge_emu_buffer; } pix_op[1][[[cheaply]]](dest_cr, ptr, uvlinesize, h >> 1); }
--------------------------------------------- Result 384 ---------------------------------------------
[[0 (97%)]] --> [[0 (39%)]] --> Socre: 0.6097594499588013

[[[[Adv]]]]: static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *[[dst]], const uint8_t *src, const uint8_t *[[src_end]], int width, int esc_count) { int i = 0; int count; uint8_t [[zero_run]] = 0; const uint8_t *src_start = src; uint8_t mask1 = -(esc_count < 2); uint8_t mask2 = -(esc_count < 3); uint8_t *end = [[dst]] + (width - 2); avpriv_request_sample(l->avctx, "zero_run_line"); return AVERROR_PATCHWELCOME; output_zeros: if (l->zeros_rem) { count = FFMIN(l->zeros_rem, width - i); if (end - [[dst]] < count) { av_log(l->avctx, AV_LOG_ERROR, "Too many zeros remaining.\n"); return AVERROR_INVALIDDATA; } memset([[dst]], 0, count); l->zeros_rem -= count; [[dst]] += count; } while ([[dst]] < end) { i = 0; while (![[zero_run]] && [[dst]] + i < end) { i++; if (i+2 >= [[src_end]] - src) return AVERROR_INVALIDDATA; [[zero_run]] = !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2)); } if ([[zero_run]]) { [[zero_run]] = 0; i += esc_count; memcpy([[dst]], src, i); [[dst]] += i; l->zeros_rem = lag_calc_zero_run(src[i]); src += i + 1; goto output_zeros; } else { memcpy([[dst]], src, i); src += i; [[dst]] += i; } } return src - src_start; }

[[[[Adv]]]]: static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *[[cnt]], const uint8_t *src, const uint8_t *[[tinkering]], int width, int esc_count) { int i = 0; int count; uint8_t [[assumes]] = 0; const uint8_t *src_start = src; uint8_t mask1 = -(esc_count < 2); uint8_t mask2 = -(esc_count < 3); uint8_t *end = [[cnt]] + (width - 2); avpriv_request_sample(l->avctx, "zero_run_line"); return AVERROR_PATCHWELCOME; output_zeros: if (l->zeros_rem) { count = FFMIN(l->zeros_rem, width - i); if (end - [[cnt]] < count) { av_log(l->avctx, AV_LOG_ERROR, "Too many zeros remaining.\n"); return AVERROR_INVALIDDATA; } memset([[cnt]], 0, count); l->zeros_rem -= count; [[cnt]] += count; } while ([[cnt]] < end) { i = 0; while (![[assumes]] && [[cnt]] + i < end) { i++; if (i+2 >= [[tinkering]] - src) return AVERROR_INVALIDDATA; [[assumes]] = !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2)); } if ([[assumes]]) { [[assumes]] = 0; i += esc_count; memcpy([[cnt]], src, i); [[cnt]] += i; l->zeros_rem = lag_calc_zero_run(src[i]); src += i + 1; goto output_zeros; } else { memcpy([[cnt]], src, i); src += i; [[cnt]] += i; } } return src - src_start; }
--------------------------------------------- Result 385 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 223 / 18 / 144 / 385:  14%|        | 385/2690 [3:23:27<20:18:09, 31.71s/it][Succeeded / Failed / Skipped / Total] 223 / 18 / 144 / 385:  14%|        | 386/2690 [3:43:53<22:16:22, 34.80s/it][Succeeded / Failed / Skipped / Total] 224 / 18 / 144 / 386:  14%|        | 386/2690 [3:43:53<22:16:22, 34.80s/it][Succeeded / Failed / Skipped / Total] 224 / 18 / 144 / 386:  14%|        | 387/2690 [3:43:53<22:12:23, 34.71s/it][Succeeded / Failed / Skipped / Total] 224 / 18 / 145 / 387:  14%|        | 387/2690 [3:43:53<22:12:23, 34.71s/it][Succeeded / Failed / Skipped / Total] 224 / 18 / 145 / 387:  14%|        | 388/2690 [3:43:54<22:08:26, 34.62s/it][[0 (53%)]] --> [[0 (46%)]] --> Socre: 0.5410844683647156

[[[[Adv]]]]: static int ffmmal_add_packet(AVCodecContext *[[avctx]], AVPacket *avpkt, int is_extradata) { MMALDecodeContext *ctx = [[avctx]]->priv_data; AVBufferRef *buf = NULL; int size = 0; uint8_t *data = (uint8_t *)""; uint8_t *start; int ret = 0; if (avpkt->size) { if (avpkt->buf) { buf = av_buffer_ref(avpkt->buf); size = avpkt->size; data = avpkt->data; } else { buf = av_buffer_alloc(avpkt->size); if (buf) { memcpy(buf->data, avpkt->data, avpkt->size); size = buf->size; data = buf->data; } } if (!buf) { ret = AVERROR(ENOMEM); goto done; } if (!is_extradata) ctx->packets_sent++; } else { if (!ctx->packets_sent) { ctx->eos_sent = 1; ctx->eos_received = 1; goto done; } } start = data; do { FFBufferEntry *buffer = av_mallocz(sizeof(*buffer)); if (!buffer) { ret = AVERROR(ENOMEM); goto done; } buffer->data = data; buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size); if (is_extradata) buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG; if (data == start) buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START; data += buffer->length; size -= buffer->length; buffer->pts = avpkt->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->pts; buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts; if (!size) buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END; if (!buffer->length) { buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS; ctx->eos_sent = 1; } if (buf) { buffer->ref = av_buffer_ref(buf); if (!buffer->ref) { av_free(buffer); ret = AVERROR(ENOMEM); goto done; } } if (!ctx->waiting_buffers) ctx->waiting_buffers = buffer; if (ctx->waiting_buffers_tail) ctx->waiting_buffers_tail->next = buffer; ctx->waiting_buffers_tail = buffer; } while (size); done: av_buffer_unref(&buf); return ret; }

[[[[Adv]]]]: static int ffmmal_add_packet(AVCodecContext *[[salter]], AVPacket *avpkt, int is_extradata) { MMALDecodeContext *ctx = [[salter]]->priv_data; AVBufferRef *buf = NULL; int size = 0; uint8_t *data = (uint8_t *)""; uint8_t *start; int ret = 0; if (avpkt->size) { if (avpkt->buf) { buf = av_buffer_ref(avpkt->buf); size = avpkt->size; data = avpkt->data; } else { buf = av_buffer_alloc(avpkt->size); if (buf) { memcpy(buf->data, avpkt->data, avpkt->size); size = buf->size; data = buf->data; } } if (!buf) { ret = AVERROR(ENOMEM); goto done; } if (!is_extradata) ctx->packets_sent++; } else { if (!ctx->packets_sent) { ctx->eos_sent = 1; ctx->eos_received = 1; goto done; } } start = data; do { FFBufferEntry *buffer = av_mallocz(sizeof(*buffer)); if (!buffer) { ret = AVERROR(ENOMEM); goto done; } buffer->data = data; buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size); if (is_extradata) buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG; if (data == start) buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START; data += buffer->length; size -= buffer->length; buffer->pts = avpkt->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->pts; buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts; if (!size) buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END; if (!buffer->length) { buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS; ctx->eos_sent = 1; } if (buf) { buffer->ref = av_buffer_ref(buf); if (!buffer->ref) { av_free(buffer); ret = AVERROR(ENOMEM); goto done; } } if (!ctx->waiting_buffers) ctx->waiting_buffers = buffer; if (ctx->waiting_buffers_tail) ctx->waiting_buffers_tail->next = buffer; ctx->waiting_buffers_tail = buffer; } while (size); done: av_buffer_unref(&buf); return ret; }
--------------------------------------------- Result 386 ---------------------------------------------
[[0 (100%)]] --> [[0 (48%)]] --> Socre: 0.5221076011657715

[[[[Adv]]]]: static void write_frame(AVFormatContext *s, AVPacket *pkt, OutputStream *ost) { AVBitStreamFilterContext *[[bsfc]] = ost->bitstream_filters; AVCodecContext *avctx = ost->st->codec; int ret; if ((avctx->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) || (avctx->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0)) pkt->pts = pkt->dts = AV_NOPTS_VALUE; if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && pkt->dts != AV_NOPTS_VALUE) { int64_t max = ost->st->cur_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT); if (ost->st->cur_dts && ost->st->cur_dts != AV_NOPTS_VALUE && max > pkt->dts) { av_log(s, max - pkt->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, "Audio timestamp %"PRId64" < %"PRId64" invalid, cliping\n", pkt->dts, max); pkt->pts = pkt->dts = max; if (!(avctx->codec_type == AVMEDIA_TYPE_VIDEO && avctx->codec)) { if (ost->frame_number >= ost->max_frames) { av_free_packet(pkt); return; ost->frame_number++; while ([[bsfc]]) { AVPacket new_pkt = *pkt; int a = av_bitstream_filter_filter([[bsfc]], avctx, NULL, &new_pkt.data, &new_pkt.size, pkt->data, pkt->size, pkt->flags & AV_PKT_FLAG_KEY); if (a > 0) { av_free_packet(pkt); new_pkt.destruct = av_destruct_packet; } else if (a < 0) { av_log(NULL, AV_LOG_ERROR, "Failed to open bitstream filter %s for stream %d with codec %s", [[bsfc]]->filter->name, pkt->stream_index, avctx->codec ? avctx->codec->name : "copy"); print_error("", a); if (exit_on_error) exit_program(1); *pkt = new_pkt; [[bsfc]] = [[bsfc]]->next; pkt->stream_index = ost->index; ret = av_interleaved_write_frame(s, pkt); if (ret < 0) { print_error("av_interleaved_write_frame()", ret); exit_program(1);

[[[[Adv]]]]: static void write_frame(AVFormatContext *s, AVPacket *pkt, OutputStream *ost) { AVBitStreamFilterContext *[[jger]] = ost->bitstream_filters; AVCodecContext *avctx = ost->st->codec; int ret; if ((avctx->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) || (avctx->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0)) pkt->pts = pkt->dts = AV_NOPTS_VALUE; if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && pkt->dts != AV_NOPTS_VALUE) { int64_t max = ost->st->cur_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT); if (ost->st->cur_dts && ost->st->cur_dts != AV_NOPTS_VALUE && max > pkt->dts) { av_log(s, max - pkt->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, "Audio timestamp %"PRId64" < %"PRId64" invalid, cliping\n", pkt->dts, max); pkt->pts = pkt->dts = max; if (!(avctx->codec_type == AVMEDIA_TYPE_VIDEO && avctx->codec)) { if (ost->frame_number >= ost->max_frames) { av_free_packet(pkt); return; ost->frame_number++; while ([[jger]]) { AVPacket new_pkt = *pkt; int a = av_bitstream_filter_filter([[jger]], avctx, NULL, &new_pkt.data, &new_pkt.size, pkt->data, pkt->size, pkt->flags & AV_PKT_FLAG_KEY); if (a > 0) { av_free_packet(pkt); new_pkt.destruct = av_destruct_packet; } else if (a < 0) { av_log(NULL, AV_LOG_ERROR, "Failed to open bitstream filter %s for stream %d with codec %s", [[jger]]->filter->name, pkt->stream_index, avctx->codec ? avctx->codec->name : "copy"); print_error("", a); if (exit_on_error) exit_program(1); *pkt = new_pkt; [[jger]] = [[jger]]->next; pkt->stream_index = ost->index; ret = av_interleaved_write_frame(s, pkt); if (ret < 0) { print_error("av_interleaved_write_frame()", ret); exit_program(1);
--------------------------------------------- Result 387 ---------------------------------------------
[[0 (27%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *l2_table) { CachedL2Table *entry; entry = qed_find_l2_cache_entry(l2_cache, l2_table->offset); if (entry) { qed_unref_l2_cache_entry(entry); qed_unref_l2_cache_entry(l2_table); return; } if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) { entry = QTAILQ_FIRST(&l2_cache->entries); QTAILQ_REMOVE(&l2_cache->entries, entry, node); l2_cache->n_entries--; qed_unref_l2_cache_entry(entry); } l2_cache->n_entries++; QTAILQ_INSERT_TAIL(&l2_cache->entries, l2_table, node); }
--------------------------------------------- Result 388 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 224 / 18 / 146 / 388:  14%|        | 388/2690 [3:43:54<22:08:26, 34.62s/it][Succeeded / Failed / Skipped / Total] 224 / 18 / 146 / 388:  14%|        | 389/2690 [3:45:06<22:11:31, 34.72s/it][Succeeded / Failed / Skipped / Total] 224 / 19 / 146 / 389:  14%|        | 389/2690 [3:45:06<22:11:31, 34.72s/it][Succeeded / Failed / Skipped / Total] 224 / 19 / 146 / 389:  14%|        | 390/2690 [3:45:06<22:07:35, 34.63s/it][Succeeded / Failed / Skipped / Total] 224 / 19 / 147 / 390:  14%|        | 390/2690 [3:45:06<22:07:35, 34.63s/it][Succeeded / Failed / Skipped / Total] 224 / 19 / 147 / 390:  15%|        | 391/2690 [3:45:11<22:04:05, 34.56s/it][Succeeded / Failed / Skipped / Total] 224 / 20 / 147 / 391:  15%|        | 391/2690 [3:45:11<22:04:05, 34.56s/it][Succeeded / Failed / Skipped / Total] 224 / 20 / 147 / 391:  15%|        | 392/2690 [3:45:24<22:01:26, 34.50s/it][Succeeded / Failed / Skipped / Total] 225 / 20 / 147 / 392:  15%|        | 392/2690 [3:45:24<22:01:26, 34.50s/it][Succeeded / Failed / Skipped / Total] 225 / 20 / 147 / 392:  15%|        | 393/2690 [3:46:18<22:02:45, 34.55s/it][Succeeded / Failed / Skipped / Total] 226 / 20 / 147 / 393:  15%|        | 393/2690 [3:46:18<22:02:45, 34.55s/it][Succeeded / Failed / Skipped / Total] 226 / 20 / 147 / 393:  15%|        | 394/2690 [3:46:22<21:59:08, 34.47s/it][[0 (3%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: av_cold void ff_pixblockdsp_init_x86(PixblockDSPContext *c, AVCodecContext *avctx, unsigned high_bit_depth) { int cpu_flags = av_get_cpu_flags(); if (EXTERNAL_MMX(cpu_flags)) { if (!high_bit_depth) c->get_pixels = ff_get_pixels_mmx; c->diff_pixels = ff_diff_pixels_mmx; } if (EXTERNAL_SSE2(cpu_flags)) { if (!high_bit_depth) c->get_pixels = ff_get_pixels_sse2; c->diff_pixels = ff_diff_pixels_sse2; } }
--------------------------------------------- Result 389 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void bonito_ldma_writel(void *opaque, hwaddr addr, uint64_t val, unsigned size) { PCIBonitoState *s = opaque; ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;

[[[[Adv]]]]: static void bonito_ldma_writel(void *opaque, hwaddr addr, uint64_t val, unsigned size) { PCIBonitoState *s = opaque; ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;
--------------------------------------------- Result 390 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void pkt_dump_internal(void *avcl, FILE *f, int level, const AVPacket *pkt, int dump_payload, AVRational time_base) { HEXDUMP_PRINT("stream #%d:\n", pkt->stream_index); HEXDUMP_PRINT(" keyframe=%d\n", (pkt->flags & AV_PKT_FLAG_KEY) != 0); HEXDUMP_PRINT(" duration=%0.3f\n", pkt->duration * av_q2d(time_base)); HEXDUMP_PRINT(" dts="); if (pkt->dts == AV_NOPTS_VALUE) HEXDUMP_PRINT("N/A"); else HEXDUMP_PRINT("%0.3f", pkt->dts * av_q2d(time_base)); HEXDUMP_PRINT(" pts="); if (pkt->pts == AV_NOPTS_VALUE) HEXDUMP_PRINT("N/A"); else HEXDUMP_PRINT("%0.3f", pkt->pts * av_q2d(time_base)); HEXDUMP_PRINT("\n"); HEXDUMP_PRINT(" size=%d\n", pkt->size); if (dump_payload) av_hex_dump(f, pkt->data, pkt->size); }
--------------------------------------------- Result 391 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void cpu_loop(CPUMIPSState *env) { target_siginfo_t info; int trapnr, ret; unsigned int syscall_num; for(;;) { trapnr = cpu_mips_exec(env); switch(trapnr) { case EXCP_SYSCALL: syscall_num = env->active_tc.gpr[2] - 4000; env->active_tc.PC += 4; if (syscall_num >= sizeof(mips_syscall_args)) { ret = -ENOSYS; } else { int nb_args; abi_ulong sp_reg; abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0; nb_args = mips_syscall_args[syscall_num]; sp_reg = env->active_tc.gpr[29]; switch (nb_args) { case 8: get_user_ual(arg8, sp_reg + 28); case 7: get_user_ual(arg7, sp_reg + 24); case 6: get_user_ual(arg6, sp_reg + 20); case 5: get_user_ual(arg5, sp_reg + 16); default: ret = do_syscall(env, env->active_tc.gpr[2], env->active_tc.gpr[4], env->active_tc.gpr[5], env->active_tc.gpr[6], env->active_tc.gpr[7], arg5, arg6 ); if ((unsigned int)ret >= (unsigned int)(-1133)) { env->active_tc.gpr[7] = 1; ret = -ret; } else { env->active_tc.gpr[7] = 0; env->active_tc.gpr[2] = ret; case EXCP_TLBL: case EXCP_TLBS: info.si_signo = TARGET_SIGSEGV; info.si_errno = 0; info.si_code = TARGET_SEGV_MAPERR; info._sifields._sigfault._addr = env->CP0_BadVAddr; queue_signal(env, info.si_signo, &info); case EXCP_CpU: case EXCP_RI: info.si_signo = TARGET_SIGILL; info.si_errno = 0; info.si_code = 0; queue_signal(env, info.si_signo, &info); case EXCP_INTERRUPT: case EXCP_DEBUG: { int sig; sig = gdb_handlesig (env, TARGET_SIGTRAP); if (sig) { info.si_signo = sig; info.si_errno = 0; info.si_code = TARGET_TRAP_BRKPT; queue_signal(env, info.si_signo, &info); default: fprintf(stderr, "qemu: unhandled CPU exception 0x%x - aborting\n", trapnr); cpu_dump_state(env, stderr, fprintf, 0); abort(); process_pending_signals(env);

[[[[Adv]]]]: void cpu_loop(CPUMIPSState *env) { target_siginfo_t info; int trapnr, ret; unsigned int syscall_num; for(;;) { trapnr = cpu_mips_exec(env); switch(trapnr) { case EXCP_SYSCALL: syscall_num = env->active_tc.gpr[2] - 4000; env->active_tc.PC += 4; if (syscall_num >= sizeof(mips_syscall_args)) { ret = -ENOSYS; } else { int nb_args; abi_ulong sp_reg; abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0; nb_args = mips_syscall_args[syscall_num]; sp_reg = env->active_tc.gpr[29]; switch (nb_args) { case 8: get_user_ual(arg8, sp_reg + 28); case 7: get_user_ual(arg7, sp_reg + 24); case 6: get_user_ual(arg6, sp_reg + 20); case 5: get_user_ual(arg5, sp_reg + 16); default: ret = do_syscall(env, env->active_tc.gpr[2], env->active_tc.gpr[4], env->active_tc.gpr[5], env->active_tc.gpr[6], env->active_tc.gpr[7], arg5, arg6 ); if ((unsigned int)ret >= (unsigned int)(-1133)) { env->active_tc.gpr[7] = 1; ret = -ret; } else { env->active_tc.gpr[7] = 0; env->active_tc.gpr[2] = ret; case EXCP_TLBL: case EXCP_TLBS: info.si_signo = TARGET_SIGSEGV; info.si_errno = 0; info.si_code = TARGET_SEGV_MAPERR; info._sifields._sigfault._addr = env->CP0_BadVAddr; queue_signal(env, info.si_signo, &info); case EXCP_CpU: case EXCP_RI: info.si_signo = TARGET_SIGILL; info.si_errno = 0; info.si_code = 0; queue_signal(env, info.si_signo, &info); case EXCP_INTERRUPT: case EXCP_DEBUG: { int sig; sig = gdb_handlesig (env, TARGET_SIGTRAP); if (sig) { info.si_signo = sig; info.si_errno = 0; info.si_code = TARGET_TRAP_BRKPT; queue_signal(env, info.si_signo, &info); default: fprintf(stderr, "qemu: unhandled CPU exception 0x%x - aborting\n", trapnr); cpu_dump_state(env, stderr, fprintf, 0); abort(); process_pending_signals(env);
--------------------------------------------- Result 392 ---------------------------------------------
[[0 (75%)]] --> [[0 (29%)]] --> Socre: 0.707163542509079

[[[[Adv]]]]: static void init_virtio_dev(TestServer *s) { QPCIBus *[[bus]]; QVirtioPCIDevice *dev; uint32_t features; [[bus]] = qpci_init_pc(NULL); g_assert_nonnull([[bus]]); dev = qvirtio_pci_device_find([[bus]], VIRTIO_ID_NET); g_assert_nonnull(dev); qvirtio_pci_device_enable(dev); qvirtio_reset(&dev->vdev); qvirtio_set_acknowledge(&dev->vdev); qvirtio_set_driver(&dev->vdev); features = qvirtio_get_features(&dev->vdev); features = features & VIRTIO_NET_F_MAC; qvirtio_set_features(&dev->vdev, features); qvirtio_set_driver_ok(&dev->vdev); }

[[[[Adv]]]]: static void init_virtio_dev(TestServer *s) { QPCIBus *[[shuttles]]; QVirtioPCIDevice *dev; uint32_t features; [[shuttles]] = qpci_init_pc(NULL); g_assert_nonnull([[shuttles]]); dev = qvirtio_pci_device_find([[shuttles]], VIRTIO_ID_NET); g_assert_nonnull(dev); qvirtio_pci_device_enable(dev); qvirtio_reset(&dev->vdev); qvirtio_set_acknowledge(&dev->vdev); qvirtio_set_driver(&dev->vdev); features = qvirtio_get_features(&dev->vdev); features = features & VIRTIO_NET_F_MAC; qvirtio_set_features(&dev->vdev, features); qvirtio_set_driver_ok(&dev->vdev); }
--------------------------------------------- Result 393 ---------------------------------------------
[[0 (4%)]] --> [[0 (67%)]] --> Socre: 0.6710075736045837

[[[[Adv]]]]: static void handle_mousewheel(SDL_Event *ev) { struct sdl2_console *[[scon]] = get_scon_from_window(ev->key.windowID); SDL_MouseWheelEvent *wev = &ev->wheel; InputButton btn; if (wev->y > 0) { btn = INPUT_BUTTON_WHEEL_UP; } else if (wev->y < 0) { btn = INPUT_BUTTON_WHEEL_DOWN; } else { return; } qemu_input_queue_btn([[scon]]->dcl.con, btn, "True" == "True"); qemu_input_event_sync(); qemu_input_queue_btn([[scon]]->dcl.con, btn, "False" != "False"); qemu_input_event_sync(); }

[[[[Adv]]]]: static void handle_mousewheel(SDL_Event *ev) { struct sdl2_console *[[corrosion]] = get_scon_from_window(ev->key.windowID); SDL_MouseWheelEvent *wev = &ev->wheel; InputButton btn; if (wev->y > 0) { btn = INPUT_BUTTON_WHEEL_UP; } else if (wev->y < 0) { btn = INPUT_BUTTON_WHEEL_DOWN; } else { return; } qemu_input_queue_btn([[corrosion]]->dcl.con, btn, "True" == "True"); qemu_input_event_sync(); qemu_input_queue_btn([[corrosion]]->dcl.con, btn, "False" != "False"); qemu_input_event_sync(); }
--------------------------------------------- Result 394 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 227 / 20 / 147 / 394:  15%|        | 394/2690 [3:46:22<21:59:08, 34.47s/it][Succeeded / Failed / Skipped / Total] 227 / 20 / 147 / 394:  15%|        | 395/2690 [3:46:22<21:55:16, 34.39s/it][Succeeded / Failed / Skipped / Total] 227 / 20 / 148 / 395:  15%|        | 395/2690 [3:46:22<21:55:16, 34.39s/it][Succeeded / Failed / Skipped / Total] 227 / 20 / 148 / 395:  15%|        | 396/2690 [3:46:45<21:53:33, 34.36s/it][Succeeded / Failed / Skipped / Total] 228 / 20 / 148 / 396:  15%|        | 396/2690 [3:46:45<21:53:33, 34.36s/it][Succeeded / Failed / Skipped / Total] 228 / 20 / 148 / 396:  15%|        | 397/2690 [3:46:52<21:50:21, 34.29s/it][Succeeded / Failed / Skipped / Total] 229 / 20 / 148 / 397:  15%|        | 397/2690 [3:46:52<21:50:21, 34.29s/it][Succeeded / Failed / Skipped / Total] 229 / 20 / 148 / 397:  15%|        | 398/2690 [3:46:52<21:46:32, 34.20s/it][Succeeded / Failed / Skipped / Total] 229 / 20 / 149 / 398:  15%|        | 398/2690 [3:46:52<21:46:32, 34.20s/it][Succeeded / Failed / Skipped / Total] 229 / 20 / 149 / 398:  15%|        | 399/2690 [3:46:53<21:42:44, 34.12s/it][[0 (78%)]] --> [[0 (44%)]] --> Socre: 0.5573440194129944

[[[[Adv]]]]: static void usb_msd_cancel_io(USBDevice *[[dev]], USBPacket *[[p]]) { MSDState *[[s]] = DO_UPCAST(MSDState, [[dev]], [[dev]]); scsi_req_cancel([[s]]->req); }

[[[[Adv]]]]: static void usb_msd_cancel_io(USBDevice *[[sanjay]], USBPacket *[[phosphorus]]) { MSDState *[[of]] = DO_UPCAST(MSDState, [[sanjay]], [[sanjay]]); scsi_req_cancel([[of]]->req); }
--------------------------------------------- Result 395 ---------------------------------------------
[[0 (12%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: ram_addr_t ppc405_set_bootinfo (CPUState *env, ppc4xx_bd_info_t *bd, uint32_t flags) { ram_addr_t bdloc; int i, n; if (bd->bi_memsize >= 0x01000000UL) bdloc = 0x01000000UL - sizeof(struct ppc4xx_bd_info_t); else bdloc = bd->bi_memsize - sizeof(struct ppc4xx_bd_info_t); stl_phys(bdloc + 0x00, bd->bi_memstart); stl_phys(bdloc + 0x04, bd->bi_memsize); stl_phys(bdloc + 0x08, bd->bi_flashstart); stl_phys(bdloc + 0x0C, bd->bi_flashsize); stl_phys(bdloc + 0x10, bd->bi_flashoffset); stl_phys(bdloc + 0x14, bd->bi_sramstart); stl_phys(bdloc + 0x18, bd->bi_sramsize); stl_phys(bdloc + 0x1C, bd->bi_bootflags); stl_phys(bdloc + 0x20, bd->bi_ipaddr); for (i = 0; i < 6; i++) stb_phys(bdloc + 0x24 + i, bd->bi_enetaddr[i]); stw_phys(bdloc + 0x2A, bd->bi_ethspeed); stl_phys(bdloc + 0x2C, bd->bi_intfreq); stl_phys(bdloc + 0x30, bd->bi_busfreq); stl_phys(bdloc + 0x34, bd->bi_baudrate); for (i = 0; i < 4; i++) stb_phys(bdloc + 0x38 + i, bd->bi_s_version[i]); for (i = 0; i < 32; i++) stb_phys(bdloc + 0x3C + i, bd->bi_s_version[i]); stl_phys(bdloc + 0x5C, bd->bi_plb_busfreq); stl_phys(bdloc + 0x60, bd->bi_pci_busfreq); for (i = 0; i < 6; i++) stb_phys(bdloc + 0x64 + i, bd->bi_pci_enetaddr[i]); n = 0x6A; if (flags & 0x00000001) { for (i = 0; i < 6; i++) stb_phys(bdloc + n++, bd->bi_pci_enetaddr2[i]); } stl_phys(bdloc + n, bd->bi_opbfreq); n += 4; for (i = 0; i < 2; i++) { stl_phys(bdloc + n, bd->bi_iic_fast[i]); n += 4; } return bdloc; }
--------------------------------------------- Result 396 ---------------------------------------------
[[0 (15%)]] --> [[0 (68%)]] --> Socre: 0.6772322058677673

[[[[Adv]]]]: static void bdrv_password_cb(Monitor *[[mon]], const char *password, void *opaque) { BlockDriverState *[[bs]] = opaque; int ret = 0; if (bdrv_set_key([[bs]], password) != 0) { monitor_printf([[mon]], "invalid password\n"); ret = -EPERM; } if ([[mon]]->password_completion_cb) [[mon]]->password_completion_cb([[mon]]->password_opaque, ret); monitor_read_command([[mon]], 1); }

[[[[Adv]]]]: static void bdrv_password_cb(Monitor *[[hoy]], const char *password, void *opaque) { BlockDriverState *[[crapola]] = opaque; int ret = 0; if (bdrv_set_key([[crapola]], password) != 0) { monitor_printf([[hoy]], "invalid password\n"); ret = -EPERM; } if ([[hoy]]->password_completion_cb) [[hoy]]->password_completion_cb([[hoy]]->password_opaque, ret); monitor_read_command([[hoy]], 1); }
--------------------------------------------- Result 397 ---------------------------------------------
[[0 (40%)]] --> [[0 (51%)]] --> Socre: 0.5104965567588806

[[[[Adv]]]]: dshow_cycle_devices(AVFormatContext *avctx, ICreateDevEnum *[[devenum]], enum dshowDeviceType devtype, IBaseFilter **pfilter) { struct dshow_ctx *ctx = avctx->priv_data; IBaseFilter *device_filter = NULL; IEnumMoniker *classenum = NULL; IMoniker *m = NULL; const char *[[device_name]] = ctx->device_name[devtype]; int skip = (devtype == VideoDevice) ? ctx->video_device_number : ctx->audio_device_number; int r; const GUID *device_guid[2] = { &CLSID_VideoInputDeviceCategory, &CLSID_AudioInputDeviceCategory }; const char *devtypename = (devtype == VideoDevice) ? "video" : "audio"; r = ICreateDevEnum_CreateClassEnumerator([[devenum]], device_guid[devtype], (IEnumMoniker **) &classenum, 0); if (r != S_OK) { av_log(avctx, AV_LOG_ERROR, "Could not enumerate %s devices.\n", devtypename); return AVERROR(EIO); } while (!device_filter && IEnumMoniker_Next(classenum, 1, &m, NULL) == S_OK) { IPropertyBag *bag = NULL; char *buf = NULL; VARIANT var; r = IMoniker_BindToStorage(m, 0, 0, &IID_IPropertyBag, (void *) &bag); if (r != S_OK) goto fail1; var.vt = VT_BSTR; r = IPropertyBag_Read(bag, L"FriendlyName", &var, NULL); if (r != S_OK) goto fail1; buf = dup_wchar_to_utf8(var.bstrVal); if (pfilter) { if (strcmp([[device_name]], buf)) goto fail1; if (!skip--) IMoniker_BindToObject(m, 0, 0, &IID_IBaseFilter, (void *) &device_filter); } else { av_log(avctx, AV_LOG_INFO, " \"%s\"\n", buf); } fail1: if (buf) av_free(buf); if (bag) IPropertyBag_Release(bag); IMoniker_Release(m); } IEnumMoniker_Release(classenum); if (pfilter) { if (!device_filter) { av_log(avctx, AV_LOG_ERROR, "Could not find %s device.\n", devtypename); return AVERROR(EIO); } *pfilter = device_filter; } return 0; }

[[[[Adv]]]]: dshow_cycle_devices(AVFormatContext *avctx, ICreateDevEnum *[[rapiers]], enum dshowDeviceType devtype, IBaseFilter **pfilter) { struct dshow_ctx *ctx = avctx->priv_data; IBaseFilter *device_filter = NULL; IEnumMoniker *classenum = NULL; IMoniker *m = NULL; const char *[[detriment]] = ctx->device_name[devtype]; int skip = (devtype == VideoDevice) ? ctx->video_device_number : ctx->audio_device_number; int r; const GUID *device_guid[2] = { &CLSID_VideoInputDeviceCategory, &CLSID_AudioInputDeviceCategory }; const char *devtypename = (devtype == VideoDevice) ? "video" : "audio"; r = ICreateDevEnum_CreateClassEnumerator([[rapiers]], device_guid[devtype], (IEnumMoniker **) &classenum, 0); if (r != S_OK) { av_log(avctx, AV_LOG_ERROR, "Could not enumerate %s devices.\n", devtypename); return AVERROR(EIO); } while (!device_filter && IEnumMoniker_Next(classenum, 1, &m, NULL) == S_OK) { IPropertyBag *bag = NULL; char *buf = NULL; VARIANT var; r = IMoniker_BindToStorage(m, 0, 0, &IID_IPropertyBag, (void *) &bag); if (r != S_OK) goto fail1; var.vt = VT_BSTR; r = IPropertyBag_Read(bag, L"FriendlyName", &var, NULL); if (r != S_OK) goto fail1; buf = dup_wchar_to_utf8(var.bstrVal); if (pfilter) { if (strcmp([[detriment]], buf)) goto fail1; if (!skip--) IMoniker_BindToObject(m, 0, 0, &IID_IBaseFilter, (void *) &device_filter); } else { av_log(avctx, AV_LOG_INFO, " \"%s\"\n", buf); } fail1: if (buf) av_free(buf); if (bag) IPropertyBag_Release(bag); IMoniker_Release(m); } IEnumMoniker_Release(classenum); if (pfilter) { if (!device_filter) { av_log(avctx, AV_LOG_ERROR, "Could not find %s device.\n", devtypename); return AVERROR(EIO); } *pfilter = device_filter; } return 0; }
--------------------------------------------- Result 398 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int do_decode(AVCodecContext *avctx, AVPacket *pkt) { int got_frame; int ret; av_assert0(!avctx->internal->buffer_frame->buf[0]); if (!pkt) pkt = avctx->internal->buffer_pkt; avctx->refcounted_frames = 1; if (avctx->internal->draining_done) return AVERROR_EOF; if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) { ret = avcodec_decode_video2(avctx, avctx->internal->buffer_frame, &got_frame, pkt); if (ret >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED)) ret = pkt->size; } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) { ret = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame, &got_frame, pkt); } else { ret = AVERROR(EINVAL); } if (ret == AVERROR(EAGAIN)) ret = pkt->size; if (ret < 0) return ret; if (avctx->internal->draining && !got_frame) avctx->internal->draining_done = 1; if (ret >= pkt->size) { av_packet_unref(avctx->internal->buffer_pkt); } else { int consumed = ret; if (pkt != avctx->internal->buffer_pkt) { av_packet_unref(avctx->internal->buffer_pkt); if ((ret = av_packet_ref(avctx->internal->buffer_pkt, pkt)) < 0) return ret; } avctx->internal->buffer_pkt->data += consumed; avctx->internal->buffer_pkt->size -= consumed; avctx->internal->buffer_pkt->pts = AV_NOPTS_VALUE; avctx->internal->buffer_pkt->dts = AV_NOPTS_VALUE; } if (got_frame) av_assert0(avctx->internal->buffer_frame->buf[0]); return 0; }
--------------------------------------------- Result 399 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 229 / 20 / 150 / 399:  15%|        | 399/2690 [3:46:53<21:42:44, 34.12s/it][Succeeded / Failed / Skipped / Total] 229 / 20 / 150 / 399:  15%|        | 400/2690 [3:46:59<21:39:32, 34.05s/it][Succeeded / Failed / Skipped / Total] 230 / 20 / 150 / 400:  15%|        | 400/2690 [3:46:59<21:39:32, 34.05s/it][Succeeded / Failed / Skipped / Total] 230 / 20 / 150 / 400:  15%|        | 401/2690 [3:47:06<21:36:24, 33.98s/it][Succeeded / Failed / Skipped / Total] 231 / 20 / 150 / 401:  15%|        | 401/2690 [3:47:06<21:36:24, 33.98s/it][Succeeded / Failed / Skipped / Total] 231 / 20 / 150 / 401:  15%|        | 402/2690 [3:48:15<21:39:09, 34.07s/it][[0 (83%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void net_host_device_remove(Monitor *mon, int vlan_id, const char *device) { VLANState *vlan; VLANClientState *vc; vlan = qemu_find_vlan(vlan_id); for(vc = vlan->first_client; vc != NULL; vc = vc->next) if (!strcmp(vc->name, device)) break; if (!vc) { monitor_printf(mon, "can't find device %s\n", device); return; } qemu_del_vlan_client(vc); }
--------------------------------------------- Result 400 ---------------------------------------------
[[0 (26%)]] --> [[0 (99%)]] --> Socre: 0.9874140620231628

[[[[Adv]]]]: static void vfio_bar_write(void *opaque, hwaddr addr, uint64_t data, unsigned size) { VFIOBAR *bar = opaque; union { uint8_t byte; uint16_t word; uint32_t dword; uint64_t qword; } [[buf]]; switch (size) { case 1: [[buf]].byte = data; break; case 2: [[buf]].word = cpu_to_le16(data); break; case 4: [[buf]].dword = cpu_to_le32(data); break; default: hw_error("vfio: unsupported write size, %d bytes\n", size); break; } if (pwrite(bar->fd, &[[buf]], size, bar->fd_offset + addr) != size) { error_report("%s(,0x%"HWADDR_PRIx", 0x%"PRIx64", %d) failed: %m", __func__, addr, data, size); } DPRINTF("%s(BAR%d+0x%"HWADDR_PRIx", 0x%"PRIx64", %d)\n", __func__, bar->nr, addr, data, size); vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr])); }

[[[[Adv]]]]: static void vfio_bar_write(void *opaque, hwaddr addr, uint64_t data, unsigned size) { VFIOBAR *bar = opaque; union { uint8_t byte; uint16_t word; uint32_t dword; uint64_t qword; } [[pr]]; switch (size) { case 1: [[pr]].byte = data; break; case 2: [[pr]].word = cpu_to_le16(data); break; case 4: [[pr]].dword = cpu_to_le32(data); break; default: hw_error("vfio: unsupported write size, %d bytes\n", size); break; } if (pwrite(bar->fd, &[[pr]], size, bar->fd_offset + addr) != size) { error_report("%s(,0x%"HWADDR_PRIx", 0x%"PRIx64", %d) failed: %m", __func__, addr, data, size); } DPRINTF("%s(BAR%d+0x%"HWADDR_PRIx", 0x%"PRIx64", %d)\n", __func__, bar->nr, addr, data, size); vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr])); }
--------------------------------------------- Result 401 ---------------------------------------------
[[0 (41%)]] --> [[0 (58%)]] --> Socre: 0.5824300050735474

[[[[Adv]]]]: static void mcf5208evb_init(QEMUMachineInitArgs *args) { ram_addr_t [[ram_size]] = args->ram_size; const char *cpu_model = args->cpu_model; const char *kernel_filename = args->kernel_filename; CPUM68KState *env; int kernel_size; uint64_t elf_entry; target_phys_addr_t entry; qemu_irq *pic; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); MemoryRegion *sram = g_new(MemoryRegion, 1); if (!cpu_model) cpu_model = "m5208"; env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to find m68k CPU definition\n"); exit(1); } env->vbr = 0; memory_region_init_ram(ram, "mcf5208.ram", [[ram_size]]); vmstate_register_ram_global(ram); memory_region_add_subregion(address_space_mem, 0x40000000, ram); memory_region_init_ram(sram, "mcf5208.sram", 16384); vmstate_register_ram_global(sram); memory_region_add_subregion(address_space_mem, 0x80000000, sram); pic = mcf_intc_init(address_space_mem, 0xfc048000, env); mcf_uart_mm_init(address_space_mem, 0xfc060000, pic[26], serial_hds[0]); mcf_uart_mm_init(address_space_mem, 0xfc064000, pic[27], serial_hds[1]); mcf_uart_mm_init(address_space_mem, 0xfc068000, pic[28], serial_hds[2]); mcf5208_sys_init(address_space_mem, pic); if (nb_nics > 1) { fprintf(stderr, "Too many NICs\n"); exit(1); } if (nd_table[0].used) mcf_fec_init(address_space_mem, &nd_table[0], 0xfc030000, pic + 36); if (!kernel_filename) { fprintf(stderr, "Kernel image must be specified\n"); exit(1); } kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry, NULL, NULL, 1, ELF_MACHINE, 0); entry = elf_entry; if (kernel_size < 0) { kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL); } if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, 0x40000000, [[ram_size]]); entry = 0x40000000; } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } env->pc = entry; }

[[[[Adv]]]]: static void mcf5208evb_init(QEMUMachineInitArgs *args) { ram_addr_t [[dealio]] = args->ram_size; const char *cpu_model = args->cpu_model; const char *kernel_filename = args->kernel_filename; CPUM68KState *env; int kernel_size; uint64_t elf_entry; target_phys_addr_t entry; qemu_irq *pic; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); MemoryRegion *sram = g_new(MemoryRegion, 1); if (!cpu_model) cpu_model = "m5208"; env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to find m68k CPU definition\n"); exit(1); } env->vbr = 0; memory_region_init_ram(ram, "mcf5208.ram", [[dealio]]); vmstate_register_ram_global(ram); memory_region_add_subregion(address_space_mem, 0x40000000, ram); memory_region_init_ram(sram, "mcf5208.sram", 16384); vmstate_register_ram_global(sram); memory_region_add_subregion(address_space_mem, 0x80000000, sram); pic = mcf_intc_init(address_space_mem, 0xfc048000, env); mcf_uart_mm_init(address_space_mem, 0xfc060000, pic[26], serial_hds[0]); mcf_uart_mm_init(address_space_mem, 0xfc064000, pic[27], serial_hds[1]); mcf_uart_mm_init(address_space_mem, 0xfc068000, pic[28], serial_hds[2]); mcf5208_sys_init(address_space_mem, pic); if (nb_nics > 1) { fprintf(stderr, "Too many NICs\n"); exit(1); } if (nd_table[0].used) mcf_fec_init(address_space_mem, &nd_table[0], 0xfc030000, pic + 36); if (!kernel_filename) { fprintf(stderr, "Kernel image must be specified\n"); exit(1); } kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry, NULL, NULL, 1, ELF_MACHINE, 0); entry = elf_entry; if (kernel_size < 0) { kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL); } if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, 0x40000000, [[dealio]]); entry = 0x40000000; } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } env->pc = entry; }
--------------------------------------------- Result 402 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 232 / 20 / 150 / 402:  15%|        | 402/2690 [3:48:15<21:39:09, 34.07s/it][Succeeded / Failed / Skipped / Total] 232 / 20 / 150 / 402:  15%|        | 403/2690 [3:48:33<21:37:05, 34.03s/it][Succeeded / Failed / Skipped / Total] 233 / 20 / 150 / 403:  15%|        | 403/2690 [3:48:33<21:37:05, 34.03s/it][Succeeded / Failed / Skipped / Total] 233 / 20 / 150 / 403:  15%|        | 404/2690 [3:49:13<21:37:05, 34.04s/it][Succeeded / Failed / Skipped / Total] 234 / 20 / 150 / 404:  15%|        | 404/2690 [3:49:13<21:37:05, 34.04s/it][Succeeded / Failed / Skipped / Total] 234 / 20 / 150 / 404:  15%|        | 405/2690 [3:49:21<21:33:59, 33.98s/it][Succeeded / Failed / Skipped / Total] 235 / 20 / 150 / 405:  15%|        | 405/2690 [3:49:21<21:33:59, 33.98s/it][Succeeded / Failed / Skipped / Total] 235 / 20 / 150 / 405:  15%|        | 406/2690 [3:54:47<22:00:48, 34.70s/it][[0 (12%)]] --> [[0 (93%)]] --> Socre: 0.9335436820983887

[[[[Adv]]]]: static QObject *parse_escape(JSONParserContext *[[ctxt]], va_list *[[ap]]) { QObject *[[token]]; const char *[[val]]; if ([[ap]] == NULL) { return NULL; } [[token]] = parser_context_pop_token([[ctxt]]); assert([[token]] && token_get_type([[token]]) == JSON_ESCAPE); [[val]] = token_get_value([[token]]); if (!strcmp([[val]], "%p")) { return va_arg(*[[ap]], QObject *); } else if (!strcmp([[val]], "%i")) { return QOBJECT(qbool_from_bool(va_arg(*[[ap]], int))); } else if (!strcmp([[val]], "%d")) { return QOBJECT(qint_from_int(va_arg(*[[ap]], int))); } else if (!strcmp([[val]], "%ld")) { return QOBJECT(qint_from_int(va_arg(*[[ap]], long))); } else if (!strcmp([[val]], "%lld") || !strcmp([[val]], "%I64d")) { return QOBJECT(qint_from_int(va_arg(*[[ap]], long long))); } else if (!strcmp([[val]], "%s")) { return QOBJECT(qstring_from_str(va_arg(*[[ap]], const char *))); } else if (!strcmp([[val]], "%f")) { return QOBJECT(qfloat_from_double(va_arg(*[[ap]], double))); } return NULL; }

[[[[Adv]]]]: static QObject *parse_escape(JSONParserContext *[[darlings]], va_list *[[hap]]) { QObject *[[symbolise]]; const char *[[alf]]; if ([[hap]] == NULL) { return NULL; } [[symbolise]] = parser_context_pop_token([[darlings]]); assert([[symbolise]] && token_get_type([[symbolise]]) == JSON_ESCAPE); [[alf]] = token_get_value([[symbolise]]); if (!strcmp([[alf]], "%p")) { return va_arg(*[[hap]], QObject *); } else if (!strcmp([[alf]], "%i")) { return QOBJECT(qbool_from_bool(va_arg(*[[hap]], int))); } else if (!strcmp([[alf]], "%d")) { return QOBJECT(qint_from_int(va_arg(*[[hap]], int))); } else if (!strcmp([[alf]], "%ld")) { return QOBJECT(qint_from_int(va_arg(*[[hap]], long))); } else if (!strcmp([[alf]], "%lld") || !strcmp([[alf]], "%I64d")) { return QOBJECT(qint_from_int(va_arg(*[[hap]], long long))); } else if (!strcmp([[alf]], "%s")) { return QOBJECT(qstring_from_str(va_arg(*[[hap]], const char *))); } else if (!strcmp([[alf]], "%f")) { return QOBJECT(qfloat_from_double(va_arg(*[[hap]], double))); } return NULL; }
--------------------------------------------- Result 403 ---------------------------------------------
[[0 (3%)]] --> [[0 (81%)]] --> Socre: 0.8093512654304504

[[[[Adv]]]]: static inline uint64_t ldq_phys_internal(hwaddr [[addr]], enum device_endian endian) { uint8_t *ptr; uint64_t val; MemoryRegionSection *section; section = phys_page_find(address_space_memory.dispatch, [[addr]] >> TARGET_PAGE_BITS); if (!(memory_region_is_ram(section->mr) || memory_region_is_romd(section->mr))) { [[addr]] = memory_region_section_addr(section, [[addr]]); #ifdef TARGET_WORDS_BIGENDIAN val = io_mem_read(section->mr, [[addr]], 4) << 32; val |= io_mem_read(section->mr, [[addr]] + 4, 4); #else val = io_mem_read(section->mr, [[addr]], 4); val |= io_mem_read(section->mr, [[addr]] + 4, 4) << 32; #endif } else { ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK) + memory_region_section_addr(section, [[addr]])); switch (endian) { case DEVICE_LITTLE_ENDIAN: val = ldq_le_p(ptr); break; case DEVICE_BIG_ENDIAN: val = ldq_be_p(ptr); break; default: val = ldq_p(ptr); break; } } return val; }

[[[[Adv]]]]: static inline uint64_t ldq_phys_internal(hwaddr [[]], enum device_endian endian) { uint8_t *ptr; uint64_t val; MemoryRegionSection *section; section = phys_page_find(address_space_memory.dispatch, [[]] >> TARGET_PAGE_BITS); if (!(memory_region_is_ram(section->mr) || memory_region_is_romd(section->mr))) { [[]] = memory_region_section_addr(section, [[]]); #ifdef TARGET_WORDS_BIGENDIAN val = io_mem_read(section->mr, [[]], 4) << 32; val |= io_mem_read(section->mr, [[]] + 4, 4); #else val = io_mem_read(section->mr, [[]], 4); val |= io_mem_read(section->mr, [[]] + 4, 4) << 32; #endif } else { ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK) + memory_region_section_addr(section, [[]])); switch (endian) { case DEVICE_LITTLE_ENDIAN: val = ldq_le_p(ptr); break; case DEVICE_BIG_ENDIAN: val = ldq_be_p(ptr); break; default: val = ldq_p(ptr); break; } } return val; }
--------------------------------------------- Result 404 ---------------------------------------------
[[0 (22%)]] --> [[0 (50%)]] --> Socre: 0.5033870339393616

[[[[Adv]]]]: void main_loop_wait(int nonblocking) { fd_set rfds, wfds, xfds; int [[ret]], nfds; struct timeval tv; int timeout; if (nonblocking) timeout = 0; else { timeout = qemu_calculate_timeout(); qemu_bh_update_timeout(&timeout); } os_host_main_loop_wait(&timeout); tv.tv_sec = timeout / 1000; tv.tv_usec = (timeout % 1000) * 1000; nfds = -1; FD_ZERO(&rfds); FD_ZERO(&wfds); FD_ZERO(&xfds); qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds); slirp_select_fill(&nfds, &rfds, &wfds, &xfds); qemu_mutex_unlock_iothread(); [[ret]] = select(nfds + 1, &rfds, &wfds, &xfds, &tv); qemu_mutex_lock_iothread(); qemu_iohandler_poll(&rfds, &wfds, &xfds, [[ret]]); slirp_select_poll(&rfds, &wfds, &xfds, ([[ret]] < 0)); qemu_run_all_timers(); qemu_bh_poll(); }

[[[[Adv]]]]: void main_loop_wait(int nonblocking) { fd_set rfds, wfds, xfds; int [[reformed]], nfds; struct timeval tv; int timeout; if (nonblocking) timeout = 0; else { timeout = qemu_calculate_timeout(); qemu_bh_update_timeout(&timeout); } os_host_main_loop_wait(&timeout); tv.tv_sec = timeout / 1000; tv.tv_usec = (timeout % 1000) * 1000; nfds = -1; FD_ZERO(&rfds); FD_ZERO(&wfds); FD_ZERO(&xfds); qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds); slirp_select_fill(&nfds, &rfds, &wfds, &xfds); qemu_mutex_unlock_iothread(); [[reformed]] = select(nfds + 1, &rfds, &wfds, &xfds, &tv); qemu_mutex_lock_iothread(); qemu_iohandler_poll(&rfds, &wfds, &xfds, [[reformed]]); slirp_select_poll(&rfds, &wfds, &xfds, ([[reformed]] < 0)); qemu_run_all_timers(); qemu_bh_poll(); }
--------------------------------------------- Result 405 ---------------------------------------------
[[0 (66%)]] --> [[0 (24%)]] --> Socre: 0.7570284008979797

[[[[Adv]]]]: void bdrv_invalidate_cache_all(Error **errp) { BlockDriverState *bs; Error *local_err = NULL; BdrvNextIterator *[[it]] = NULL; while (([[it]] = bdrv_next([[it]], &bs)) != NULL) { AioContext *aio_context = bdrv_get_aio_context(bs); aio_context_acquire(aio_context); bdrv_invalidate_cache(bs, &local_err); aio_context_release(aio_context); if (local_err) { error_propagate(errp, local_err); return; } } }

[[[[Adv]]]]: void bdrv_invalidate_cache_all(Error **errp) { BlockDriverState *bs; Error *local_err = NULL; BdrvNextIterator *[[pt]] = NULL; while (([[pt]] = bdrv_next([[pt]], &bs)) != NULL) { AioContext *aio_context = bdrv_get_aio_context(bs); aio_context_acquire(aio_context); bdrv_invalidate_cache(bs, &local_err); aio_context_release(aio_context); if (local_err) { error_propagate(errp, local_err); return; } } }
--------------------------------------------- Result 406 ---------------------------------------------
[[0 (99%)]] --> [[0 (37%)]] --> Socre: 0.6307860314846039

[[[[Adv]]]]: static int svq1_encode_plane(SVQ1Context *s, int plane, unsigned char *[[src_plane]], unsigned char *ref_plane, unsigned char *decoded_plane, int width, int height, int src_stride, int stride) { const AVFrame *f = s->avctx->coded_frame; int x, y; int i; int block_width, block_height; int level; int threshold[6]; uint8_t *src = s->scratchbuf + stride * 16; const int lambda = (f->quality * f->quality) >> (2 * FF_LAMBDA_SHIFT); threshold[5] = QUALITY_THRESHOLD; for (level = 4; level >= 0; level--) threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER; block_width = (width + 15) / 16; block_height = (height + 15) / 16; if (f->pict_type == AV_PICTURE_TYPE_P) { s->m.avctx = s->avctx; s->m.current_picture_ptr = &s->m.current_picture; s->m.last_picture_ptr = &s->m.last_picture; s->m.last_picture.f.data[0] = ref_plane; s->m.linesize = s->m.last_picture.f.linesize[0] = s->m.new_picture.f.linesize[0] = s->m.current_picture.f.linesize[0] = stride; s->m.width = width; s->m.height = height; s->m.mb_width = block_width; s->m.mb_height = block_height; s->m.mb_stride = s->m.mb_width + 1; s->m.b8_stride = 2 * s->m.mb_width + 1; s->m.f_code = 1; s->m.pict_type = f->pict_type; s->m.me_method = s->avctx->me_method; s->m.me.scene_change_score = 0; s->m.flags = s->avctx->flags; s->m.lambda = f->quality; s->m.qscale = s->m.lambda * 139 + FF_LAMBDA_SCALE * 64 >> FF_LAMBDA_SHIFT + 7; s->m.lambda2 = s->m.lambda * s->m.lambda + FF_LAMBDA_SCALE / 2 >> FF_LAMBDA_SHIFT; if (!s->motion_val8[plane]) { s->motion_val8[plane] = av_mallocz((s->m.b8_stride * block_height * 2 + 2) * 2 * sizeof(int16_t)); s->motion_val16[plane] = av_mallocz((s->m.mb_stride * (block_height + 2) + 1) * 2 * sizeof(int16_t)); } s->m.mb_type = s->mb_type; s->m.current_picture.mb_mean = (uint8_t *)s->dummy; s->m.current_picture.mb_var = (uint16_t *)s->dummy; s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy; s->m.current_picture.mb_type = s->dummy; s->m.current_picture.motion_val[0] = s->motion_val8[plane] + 2; s->m.p_mv_table = s->motion_val16[plane] + s->m.mb_stride + 1; s->m.dsp = s->dsp; ff_init_me(&s->m); s->m.me.dia_size = s->avctx->dia_size; s->m.first_slice_line = 1; for (y = 0; y < block_height; y++) { s->m.new_picture.f.data[0] = src - y * 16 * stride; s->m.mb_y = y; for (i = 0; i < 16 && i + 16 * y < height; i++) { memcpy(&src[i * stride], &[[src_plane]][(i + 16 * y) * src_stride], width); for (x = width; x < 16 * block_width; x++) src[i * stride + x] = src[i * stride + x - 1]; } for (; i < 16 && i + 16 * y < 16 * block_height; i++) memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width); for (x = 0; x < block_width; x++) { s->m.mb_x = x; ff_init_block_index(&s->m); ff_update_block_index(&s->m); ff_estimate_p_frame_motion(&s->m, x, y); } s->m.first_slice_line = 0; } ff_fix_long_p_mvs(&s->m); ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code, CANDIDATE_MB_TYPE_INTER, 0); } s->m.first_slice_line = 1; for (y = 0; y < block_height; y++) { for (i = 0; i < 16 && i + 16 * y < height; i++) { memcpy(&src[i * stride], &[[src_plane]][(i + 16 * y) * src_stride], width); for (x = width; x < 16 * block_width; x++) src[i * stride + x] = src[i * stride + x - 1]; } for (; i < 16 && i + 16 * y < 16 * block_height; i++) memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width); s->m.mb_y = y; for (x = 0; x < block_width; x++) { uint8_t reorder_buffer[3][6][7 * 32]; int count[3][6]; int offset = y * 16 * stride + x * 16; uint8_t *decoded = decoded_plane + offset; uint8_t *ref = ref_plane + offset; int score[4] = { 0, 0, 0, 0 }, best; uint8_t *temp = s->scratchbuf; if (s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb) >> 3) < 3000) { av_log(s->avctx, AV_LOG_ERROR, "encoded frame too large\n"); return -1; } s->m.mb_x = x; ff_init_block_index(&s->m); ff_update_block_index(&s->m); if (f->pict_type == AV_PICTURE_TYPE_I || (s->m.mb_type[x + y * s->m.mb_stride] & CANDIDATE_MB_TYPE_INTRA)) { for (i = 0; i < 6; i++) init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i], 7 * 32); if (f->pict_type == AV_PICTURE_TYPE_P) { const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA]; put_bits(&s->reorder_pb[5], vlc[1], vlc[0]); score[0] = vlc[1] * lambda; } score[0] += encode_block(s, src + 16 * x, NULL, temp, stride, 5, 64, lambda, 1); for (i = 0; i < 6; i++) { count[0][i] = put_bits_count(&s->reorder_pb[i]); flush_put_bits(&s->reorder_pb[i]); } } else score[0] = INT_MAX; best = 0; if (f->pict_type == AV_PICTURE_TYPE_P) { const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER]; int mx, my, pred_x, pred_y, dxy; int16_t *motion_ptr; motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y); if (s->m.mb_type[x + y * s->m.mb_stride] & CANDIDATE_MB_TYPE_INTER) { for (i = 0; i < 6; i++) init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i], 7 * 32); put_bits(&s->reorder_pb[5], vlc[1], vlc[0]); s->m.pb = s->reorder_pb[5]; mx = motion_ptr[0]; my = motion_ptr[1]; assert(mx >= -32 && mx <= 31); assert(my >= -32 && my <= 31); assert(pred_x >= -32 && pred_x <= 31); assert(pred_y >= -32 && pred_y <= 31); ff_h263_encode_motion(&s->m, mx - pred_x, 1); ff_h263_encode_motion(&s->m, my - pred_y, 1); s->reorder_pb[5] = s->m.pb; score[1] += lambda * put_bits_count(&s->reorder_pb[5]); dxy = (mx & 1) + 2 * (my & 1); s->hdsp.put_pixels_tab[0][dxy](temp + 16, ref + (mx >> 1) + stride * (my >> 1), stride, 16); score[1] += encode_block(s, src + 16 * x, temp + 16, decoded, stride, 5, 64, lambda, 0); best = score[1] <= score[0]; vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP]; score[2] = s->dsp.sse[0](NULL, src + 16 * x, ref, stride, 16); score[2] += vlc[1] * lambda; if (score[2] < score[best] && mx == 0 && my == 0) { best = 2; s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16); for (i = 0; i < 6; i++) count[2][i] = 0; put_bits(&s->pb, vlc[1], vlc[0]); } } if (best == 1) { for (i = 0; i < 6; i++) { count[1][i] = put_bits_count(&s->reorder_pb[i]); flush_put_bits(&s->reorder_pb[i]); } } else { motion_ptr[0] = motion_ptr[1] = motion_ptr[2] = motion_ptr[3] = motion_ptr[0 + 2 * s->m.b8_stride] = motion_ptr[1 + 2 * s->m.b8_stride] = motion_ptr[2 + 2 * s->m.b8_stride] = motion_ptr[3 + 2 * s->m.b8_stride] = 0; } } s->rd_total += score[best]; for (i = 5; i >= 0; i--) avpriv_copy_bits(&s->pb, reorder_buffer[best][i], count[best][i]); if (best == 0) s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16); } s->m.first_slice_line = 0; } return 0; }

[[[[Adv]]]]: static int svq1_encode_plane(SVQ1Context *s, int plane, unsigned char *[[ol]], unsigned char *ref_plane, unsigned char *decoded_plane, int width, int height, int src_stride, int stride) { const AVFrame *f = s->avctx->coded_frame; int x, y; int i; int block_width, block_height; int level; int threshold[6]; uint8_t *src = s->scratchbuf + stride * 16; const int lambda = (f->quality * f->quality) >> (2 * FF_LAMBDA_SHIFT); threshold[5] = QUALITY_THRESHOLD; for (level = 4; level >= 0; level--) threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER; block_width = (width + 15) / 16; block_height = (height + 15) / 16; if (f->pict_type == AV_PICTURE_TYPE_P) { s->m.avctx = s->avctx; s->m.current_picture_ptr = &s->m.current_picture; s->m.last_picture_ptr = &s->m.last_picture; s->m.last_picture.f.data[0] = ref_plane; s->m.linesize = s->m.last_picture.f.linesize[0] = s->m.new_picture.f.linesize[0] = s->m.current_picture.f.linesize[0] = stride; s->m.width = width; s->m.height = height; s->m.mb_width = block_width; s->m.mb_height = block_height; s->m.mb_stride = s->m.mb_width + 1; s->m.b8_stride = 2 * s->m.mb_width + 1; s->m.f_code = 1; s->m.pict_type = f->pict_type; s->m.me_method = s->avctx->me_method; s->m.me.scene_change_score = 0; s->m.flags = s->avctx->flags; s->m.lambda = f->quality; s->m.qscale = s->m.lambda * 139 + FF_LAMBDA_SCALE * 64 >> FF_LAMBDA_SHIFT + 7; s->m.lambda2 = s->m.lambda * s->m.lambda + FF_LAMBDA_SCALE / 2 >> FF_LAMBDA_SHIFT; if (!s->motion_val8[plane]) { s->motion_val8[plane] = av_mallocz((s->m.b8_stride * block_height * 2 + 2) * 2 * sizeof(int16_t)); s->motion_val16[plane] = av_mallocz((s->m.mb_stride * (block_height + 2) + 1) * 2 * sizeof(int16_t)); } s->m.mb_type = s->mb_type; s->m.current_picture.mb_mean = (uint8_t *)s->dummy; s->m.current_picture.mb_var = (uint16_t *)s->dummy; s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy; s->m.current_picture.mb_type = s->dummy; s->m.current_picture.motion_val[0] = s->motion_val8[plane] + 2; s->m.p_mv_table = s->motion_val16[plane] + s->m.mb_stride + 1; s->m.dsp = s->dsp; ff_init_me(&s->m); s->m.me.dia_size = s->avctx->dia_size; s->m.first_slice_line = 1; for (y = 0; y < block_height; y++) { s->m.new_picture.f.data[0] = src - y * 16 * stride; s->m.mb_y = y; for (i = 0; i < 16 && i + 16 * y < height; i++) { memcpy(&src[i * stride], &[[ol]][(i + 16 * y) * src_stride], width); for (x = width; x < 16 * block_width; x++) src[i * stride + x] = src[i * stride + x - 1]; } for (; i < 16 && i + 16 * y < 16 * block_height; i++) memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width); for (x = 0; x < block_width; x++) { s->m.mb_x = x; ff_init_block_index(&s->m); ff_update_block_index(&s->m); ff_estimate_p_frame_motion(&s->m, x, y); } s->m.first_slice_line = 0; } ff_fix_long_p_mvs(&s->m); ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code, CANDIDATE_MB_TYPE_INTER, 0); } s->m.first_slice_line = 1; for (y = 0; y < block_height; y++) { for (i = 0; i < 16 && i + 16 * y < height; i++) { memcpy(&src[i * stride], &[[ol]][(i + 16 * y) * src_stride], width); for (x = width; x < 16 * block_width; x++) src[i * stride + x] = src[i * stride + x - 1]; } for (; i < 16 && i + 16 * y < 16 * block_height; i++) memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width); s->m.mb_y = y; for (x = 0; x < block_width; x++) { uint8_t reorder_buffer[3][6][7 * 32]; int count[3][6]; int offset = y * 16 * stride + x * 16; uint8_t *decoded = decoded_plane + offset; uint8_t *ref = ref_plane + offset; int score[4] = { 0, 0, 0, 0 }, best; uint8_t *temp = s->scratchbuf; if (s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb) >> 3) < 3000) { av_log(s->avctx, AV_LOG_ERROR, "encoded frame too large\n"); return -1; } s->m.mb_x = x; ff_init_block_index(&s->m); ff_update_block_index(&s->m); if (f->pict_type == AV_PICTURE_TYPE_I || (s->m.mb_type[x + y * s->m.mb_stride] & CANDIDATE_MB_TYPE_INTRA)) { for (i = 0; i < 6; i++) init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i], 7 * 32); if (f->pict_type == AV_PICTURE_TYPE_P) { const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA]; put_bits(&s->reorder_pb[5], vlc[1], vlc[0]); score[0] = vlc[1] * lambda; } score[0] += encode_block(s, src + 16 * x, NULL, temp, stride, 5, 64, lambda, 1); for (i = 0; i < 6; i++) { count[0][i] = put_bits_count(&s->reorder_pb[i]); flush_put_bits(&s->reorder_pb[i]); } } else score[0] = INT_MAX; best = 0; if (f->pict_type == AV_PICTURE_TYPE_P) { const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER]; int mx, my, pred_x, pred_y, dxy; int16_t *motion_ptr; motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y); if (s->m.mb_type[x + y * s->m.mb_stride] & CANDIDATE_MB_TYPE_INTER) { for (i = 0; i < 6; i++) init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i], 7 * 32); put_bits(&s->reorder_pb[5], vlc[1], vlc[0]); s->m.pb = s->reorder_pb[5]; mx = motion_ptr[0]; my = motion_ptr[1]; assert(mx >= -32 && mx <= 31); assert(my >= -32 && my <= 31); assert(pred_x >= -32 && pred_x <= 31); assert(pred_y >= -32 && pred_y <= 31); ff_h263_encode_motion(&s->m, mx - pred_x, 1); ff_h263_encode_motion(&s->m, my - pred_y, 1); s->reorder_pb[5] = s->m.pb; score[1] += lambda * put_bits_count(&s->reorder_pb[5]); dxy = (mx & 1) + 2 * (my & 1); s->hdsp.put_pixels_tab[0][dxy](temp + 16, ref + (mx >> 1) + stride * (my >> 1), stride, 16); score[1] += encode_block(s, src + 16 * x, temp + 16, decoded, stride, 5, 64, lambda, 0); best = score[1] <= score[0]; vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP]; score[2] = s->dsp.sse[0](NULL, src + 16 * x, ref, stride, 16); score[2] += vlc[1] * lambda; if (score[2] < score[best] && mx == 0 && my == 0) { best = 2; s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16); for (i = 0; i < 6; i++) count[2][i] = 0; put_bits(&s->pb, vlc[1], vlc[0]); } } if (best == 1) { for (i = 0; i < 6; i++) { count[1][i] = put_bits_count(&s->reorder_pb[i]); flush_put_bits(&s->reorder_pb[i]); } } else { motion_ptr[0] = motion_ptr[1] = motion_ptr[2] = motion_ptr[3] = motion_ptr[0 + 2 * s->m.b8_stride] = motion_ptr[1 + 2 * s->m.b8_stride] = motion_ptr[2 + 2 * s->m.b8_stride] = motion_ptr[3 + 2 * s->m.b8_stride] = 0; } } s->rd_total += score[best]; for (i = 5; i >= 0; i--) avpriv_copy_bits(&s->pb, reorder_buffer[best][i], count[best][i]); if (best == 0) s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16); } s->m.first_slice_line = 0; } return 0; }[Succeeded / Failed / Skipped / Total] 236 / 20 / 150 / 406:  15%|        | 406/2690 [3:54:47<22:00:48, 34.70s/it][Succeeded / Failed / Skipped / Total] 236 / 20 / 150 / 406:  15%|        | 407/2690 [3:54:47<21:57:01, 34.61s/it][Succeeded / Failed / Skipped / Total] 236 / 20 / 151 / 407:  15%|        | 407/2690 [3:54:47<21:57:01, 34.61s/it][Succeeded / Failed / Skipped / Total] 236 / 20 / 151 / 407:  15%|        | 408/2690 [3:54:48<21:53:16, 34.53s/it][Succeeded / Failed / Skipped / Total] 236 / 20 / 152 / 408:  15%|        | 408/2690 [3:54:48<21:53:16, 34.53s/it][Succeeded / Failed / Skipped / Total] 236 / 20 / 152 / 408:  15%|        | 409/2690 [3:54:55<21:50:12, 34.46s/it]
--------------------------------------------- Result 407 ---------------------------------------------
[[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static QObject *parse_keyword(JSONParserContext *ctxt) { QObject *token, *ret; JSONParserContext saved_ctxt = parser_context_save(ctxt); token = parser_context_pop_token(ctxt); if (token == NULL) { goto out; } if (token_get_type(token) != JSON_KEYWORD) { goto out; } if (token_is_keyword(token, "true")) { ret = QOBJECT(qbool_from_int("True" == "True")); } else if (token_is_keyword(token, "false")) { ret = QOBJECT(qbool_from_int("False" != "False")); } else { parse_error(ctxt, token, "invalid keyword `%s'", token_get_value(token)); goto out; } return ret; out: parser_context_restore(ctxt, saved_ctxt); return NULL; }
--------------------------------------------- Result 408 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int aac_encode_frame(AVCodecContext *avctx, uint8_t *frame, int buf_size, void *data) { AACEncContext *s = avctx->priv_data; int16_t *samples = s->samples, *samples2, *la; ChannelElement *cpe; int i, j, chans, tag, start_ch; const uint8_t *chan_map = aac_chan_configs[avctx->channels-1]; int chan_el_counter[4]; FFPsyWindowInfo windows[AAC_MAX_CHANNELS]; if (s->last_frame) return 0; if (data) { if (!s->psypp) { memcpy(s->samples + 1024 * avctx->channels, data, 1024 * avctx->channels * sizeof(s->samples[0])); } else { start_ch = 0; samples2 = s->samples + 1024 * avctx->channels; for (i = 0; i < chan_map[0]; i++) { tag = chan_map[i+1]; chans = tag == TYPE_CPE ? 2 : 1; ff_psy_preprocess(s->psypp, (uint16_t*)data + start_ch, samples2 + start_ch, start_ch, chans); start_ch += chans; } } } if (!avctx->frame_number) { memcpy(s->samples, s->samples + 1024 * avctx->channels, 1024 * avctx->channels * sizeof(s->samples[0])); return 0; } start_ch = 0; for (i = 0; i < chan_map[0]; i++) { FFPsyWindowInfo* wi = windows + start_ch; tag = chan_map[i+1]; chans = tag == TYPE_CPE ? 2 : 1; cpe = &s->cpe[i]; for (j = 0; j < chans; j++) { IndividualChannelStream *ics = &cpe->ch[j].ics; int k; int cur_channel = start_ch + j; samples2 = samples + cur_channel; la = samples2 + (448+64) * avctx->channels; if (!data) la = NULL; if (tag == TYPE_LFE) { wi[j].window_type[0] = ONLY_LONG_SEQUENCE; wi[j].window_shape = 0; wi[j].num_windows = 1; wi[j].grouping[0] = 1; } else { wi[j] = ff_psy_suggest_window(&s->psy, samples2, la, cur_channel, ics->window_sequence[0]); } ics->window_sequence[1] = ics->window_sequence[0]; ics->window_sequence[0] = wi[j].window_type[0]; ics->use_kb_window[1] = ics->use_kb_window[0]; ics->use_kb_window[0] = wi[j].window_shape; ics->num_windows = wi[j].num_windows; ics->swb_sizes = s->psy.bands [ics->num_windows == 8]; ics->num_swb = tag == TYPE_LFE ? 12 : s->psy.num_bands[ics->num_windows == 8]; for (k = 0; k < ics->num_windows; k++) ics->group_len[k] = wi[j].grouping[k]; apply_window_and_mdct(avctx, s, &cpe->ch[j], samples2); } start_ch += chans; } do { int frame_bits; init_put_bits(&s->pb, frame, buf_size*8); if ((avctx->frame_number & 0xFF)==1 && !(avctx->flags & CODEC_FLAG_BITEXACT)) put_bitstream_info(avctx, s, LIBAVCODEC_IDENT); start_ch = 0; memset(chan_el_counter, 0, sizeof(chan_el_counter)); for (i = 0; i < chan_map[0]; i++) { FFPsyWindowInfo* wi = windows + start_ch; tag = chan_map[i+1]; chans = tag == TYPE_CPE ? 2 : 1; cpe = &s->cpe[i]; put_bits(&s->pb, 3, tag); put_bits(&s->pb, 4, chan_el_counter[tag]++); for (j = 0; j < chans; j++) { s->cur_channel = start_ch + j; ff_psy_set_band_info(&s->psy, s->cur_channel, cpe->ch[j].coeffs, &wi[j]); s->coder->search_for_quantizers(avctx, s, &cpe->ch[j], s->lambda); } cpe->common_window = 0; if (chans > 1 && wi[0].window_type[0] == wi[1].window_type[0] && wi[0].window_shape == wi[1].window_shape) { cpe->common_window = 1; for (j = 0; j < wi[0].num_windows; j++) { if (wi[0].grouping[j] != wi[1].grouping[j]) { cpe->common_window = 0; break; } } } s->cur_channel = start_ch; if (cpe->common_window && s->coder->search_for_ms) s->coder->search_for_ms(s, cpe, s->lambda); adjust_frame_information(s, cpe, chans); if (chans == 2) { put_bits(&s->pb, 1, cpe->common_window); if (cpe->common_window) { put_ics_info(s, &cpe->ch[0].ics); encode_ms_info(&s->pb, cpe); } } for (j = 0; j < chans; j++) { s->cur_channel = start_ch + j; encode_individual_channel(avctx, s, &cpe->ch[j], cpe->common_window); } start_ch += chans; } frame_bits = put_bits_count(&s->pb); if (frame_bits <= 6144 * avctx->channels - 3) { s->psy.bitres.bits = frame_bits / avctx->channels; break; } s->lambda *= avctx->bit_rate * 1024.0f / avctx->sample_rate / frame_bits; } while (1); put_bits(&s->pb, 3, TYPE_END); flush_put_bits(&s->pb); avctx->frame_bits = put_bits_count(&s->pb); if (!(avctx->flags & CODEC_FLAG_QSCALE)) { float ratio = avctx->bit_rate * 1024.0f / avctx->sample_rate / avctx->frame_bits; s->lambda *= ratio; s->lambda = FFMIN(s->lambda, 65536.f); } if (!data) s->last_frame = 1; memcpy(s->samples, s->samples + 1024 * avctx->channels, 1024 * avctx->channels * sizeof(s->samples[0])); return put_bits_count(&s->pb)>>3; }
--------------------------------------------- Result 409 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 237 / 20 / 152 / 409:  15%|        | 409/2690 [3:54:55<21:50:12, 34.46s/it][Succeeded / Failed / Skipped / Total] 237 / 20 / 152 / 409:  15%|        | 410/2690 [3:54:56<21:46:29, 34.38s/it][[0 (28%)]] --> [[0 (69%)]] --> Socre: 0.6850182414054871

[[[[Adv]]]]: static int dxtory_decode_v2_420(AVCodecContext *avctx, AVFrame *pic, const uint8_t *src, int src_size) { GetByteContext gb; GetBitContext [[gb2]]; int nslices, slice, slice_height, ref_slice_height; int cur_y, next_y; uint32_t off, slice_size; uint8_t *Y, *U, *V; int ret; bytestream2_init(&gb, src, src_size); nslices = bytestream2_get_le16(&gb); off = FFALIGN(nslices * 4 + 2, 16); if (src_size < off) { av_log(avctx, AV_LOG_ERROR, "no slice data\n"); return AVERROR_INVALIDDATA; } if (!nslices || avctx->height % nslices) { avpriv_request_sample(avctx, "%d slices for %dx%d", nslices, avctx->width, avctx->height); return AVERROR_PATCHWELCOME; } ref_slice_height = avctx->height / nslices; if ((avctx->width & 1) || (avctx->height & 1)) { avpriv_request_sample(avctx, "Frame dimensions %dx%d", avctx->width, avctx->height); } avctx->pix_fmt = AV_PIX_FMT_YUV420P; if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) return ret; Y = pic->data[0]; U = pic->data[1]; V = pic->data[2]; cur_y = 0; next_y = ref_slice_height; for (slice = 0; slice < nslices; slice++) { slice_size = bytestream2_get_le32(&gb); slice_height = (next_y & ~1) - (cur_y & ~1); if (slice_size > src_size - off) { av_log(avctx, AV_LOG_ERROR, "invalid slice size %"PRIu32" (only %"PRIu32" bytes left)\n", slice_size, src_size - off); return AVERROR_INVALIDDATA; } if (slice_size <= 16) { av_log(avctx, AV_LOG_ERROR, "invalid slice size %"PRIu32"\n", slice_size); return AVERROR_INVALIDDATA; } if (AV_RL32(src + off) != slice_size - 16) { av_log(avctx, AV_LOG_ERROR, "Slice sizes mismatch: got %"PRIu32" instead of %"PRIu32"\n", AV_RL32(src + off), slice_size - 16); } init_get_bits(&[[gb2]], src + off + 16, (slice_size - 16) * 8); dx2_decode_slice_420(&[[gb2]], avctx->width, slice_height, Y, U, V, pic->linesize[0], pic->linesize[1], pic->linesize[2]); Y += pic->linesize[0] * slice_height; U += pic->linesize[1] * (slice_height >> 1); V += pic->linesize[2] * (slice_height >> 1); off += slice_size; cur_y = next_y; next_y += ref_slice_height; } return 0; }

[[[[Adv]]]]: static int dxtory_decode_v2_420(AVCodecContext *avctx, AVFrame *pic, const uint8_t *src, int src_size) { GetByteContext gb; GetBitContext [[retaken]]; int nslices, slice, slice_height, ref_slice_height; int cur_y, next_y; uint32_t off, slice_size; uint8_t *Y, *U, *V; int ret; bytestream2_init(&gb, src, src_size); nslices = bytestream2_get_le16(&gb); off = FFALIGN(nslices * 4 + 2, 16); if (src_size < off) { av_log(avctx, AV_LOG_ERROR, "no slice data\n"); return AVERROR_INVALIDDATA; } if (!nslices || avctx->height % nslices) { avpriv_request_sample(avctx, "%d slices for %dx%d", nslices, avctx->width, avctx->height); return AVERROR_PATCHWELCOME; } ref_slice_height = avctx->height / nslices; if ((avctx->width & 1) || (avctx->height & 1)) { avpriv_request_sample(avctx, "Frame dimensions %dx%d", avctx->width, avctx->height); } avctx->pix_fmt = AV_PIX_FMT_YUV420P; if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) return ret; Y = pic->data[0]; U = pic->data[1]; V = pic->data[2]; cur_y = 0; next_y = ref_slice_height; for (slice = 0; slice < nslices; slice++) { slice_size = bytestream2_get_le32(&gb); slice_height = (next_y & ~1) - (cur_y & ~1); if (slice_size > src_size - off) { av_log(avctx, AV_LOG_ERROR, "invalid slice size %"PRIu32" (only %"PRIu32" bytes left)\n", slice_size, src_size - off); return AVERROR_INVALIDDATA; } if (slice_size <= 16) { av_log(avctx, AV_LOG_ERROR, "invalid slice size %"PRIu32"\n", slice_size); return AVERROR_INVALIDDATA; } if (AV_RL32(src + off) != slice_size - 16) { av_log(avctx, AV_LOG_ERROR, "Slice sizes mismatch: got %"PRIu32" instead of %"PRIu32"\n", AV_RL32(src + off), slice_size - 16); } init_get_bits(&[[retaken]], src + off + 16, (slice_size - 16) * 8); dx2_decode_slice_420(&[[retaken]], avctx->width, slice_height, Y, U, V, pic->linesize[0], pic->linesize[1], pic->linesize[2]); Y += pic->linesize[0] * slice_height; U += pic->linesize[1] * (slice_height >> 1); V += pic->linesize[2] * (slice_height >> 1); off += slice_size; cur_y = next_y; next_y += ref_slice_height; } return 0; }
--------------------------------------------- Result 410 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 237 / 20 / 153 / 410:  15%|        | 410/2690 [3:54:56<21:46:29, 34.38s/it][Succeeded / Failed / Skipped / Total] 237 / 20 / 153 / 410:  15%|        | 411/2690 [3:54:57<21:42:49, 34.30s/it][[0 (72%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int read_sbr_grid(AACContext *ac, SpectralBandReplication *sbr, GetBitContext *gb, SBRData *ch_data) { int i; unsigned bs_pointer = 0; int abs_bord_trail = 16; int num_rel_lead, num_rel_trail; unsigned bs_num_env_old = ch_data->bs_num_env; ch_data->bs_freq_res[0] = ch_data->bs_freq_res[ch_data->bs_num_env]; ch_data->bs_amp_res = sbr->bs_amp_res_header; ch_data->t_env_num_env_old = ch_data->t_env[bs_num_env_old]; switch (ch_data->bs_frame_class = get_bits(gb, 2)) { case FIXFIX: ch_data->bs_num_env = 1 << get_bits(gb, 2); num_rel_lead = ch_data->bs_num_env - 1; if (ch_data->bs_num_env == 1) ch_data->bs_amp_res = 0; if (ch_data->bs_num_env > 4) { av_log(ac->avccontext, AV_LOG_ERROR, "Invalid bitstream, too many SBR envelopes in FIXFIX type SBR frame: %d\n", ch_data->bs_num_env); return -1; } ch_data->t_env[0] = 0; ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail; abs_bord_trail = (abs_bord_trail + (ch_data->bs_num_env >> 1)) / ch_data->bs_num_env; for (i = 0; i < num_rel_lead; i++) ch_data->t_env[i + 1] = ch_data->t_env[i] + abs_bord_trail; ch_data->bs_freq_res[1] = get_bits1(gb); for (i = 1; i < ch_data->bs_num_env; i++) ch_data->bs_freq_res[i + 1] = ch_data->bs_freq_res[1]; break; case FIXVAR: abs_bord_trail += get_bits(gb, 2); num_rel_trail = get_bits(gb, 2); ch_data->bs_num_env = num_rel_trail + 1; ch_data->t_env[0] = 0; ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail; for (i = 0; i < num_rel_trail; i++) ch_data->t_env[ch_data->bs_num_env - 1 - i] = ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2; bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]); for (i = 0; i < ch_data->bs_num_env; i++) ch_data->bs_freq_res[ch_data->bs_num_env - i] = get_bits1(gb); break; case VARFIX: ch_data->t_env[0] = get_bits(gb, 2); num_rel_lead = get_bits(gb, 2); ch_data->bs_num_env = num_rel_lead + 1; ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail; for (i = 0; i < num_rel_lead; i++) ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2; bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]); get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env); break; case VARVAR: ch_data->t_env[0] = get_bits(gb, 2); abs_bord_trail += get_bits(gb, 2); num_rel_lead = get_bits(gb, 2); num_rel_trail = get_bits(gb, 2); ch_data->bs_num_env = num_rel_lead + num_rel_trail + 1; ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail; if (ch_data->bs_num_env > 5) { av_log(ac->avccontext, AV_LOG_ERROR, "Invalid bitstream, too many SBR envelopes in VARVAR type SBR frame: %d\n", ch_data->bs_num_env); return -1; } for (i = 0; i < num_rel_lead; i++) ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2; for (i = 0; i < num_rel_trail; i++) ch_data->t_env[ch_data->bs_num_env - 1 - i] = ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2; bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]); get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env); break; } if (bs_pointer > ch_data->bs_num_env + 1) { av_log(ac->avccontext, AV_LOG_ERROR, "Invalid bitstream, bs_pointer points to a middle noise border outside the time borders table: %d\n", bs_pointer); return -1; } ch_data->bs_num_noise = (ch_data->bs_num_env > 1) + 1; ch_data->t_q[0] = ch_data->t_env[0]; ch_data->t_q[ch_data->bs_num_noise] = ch_data->t_env[ch_data->bs_num_env]; if (ch_data->bs_num_noise > 1) { unsigned int idx; if (ch_data->bs_frame_class == FIXFIX) { idx = ch_data->bs_num_env >> 1; } else if (ch_data->bs_frame_class & 1) { idx = ch_data->bs_num_env - FFMAX(bs_pointer - 1, 1); } else { if (!bs_pointer) idx = 1; else if (bs_pointer == 1) idx = ch_data->bs_num_env - 1; else idx = bs_pointer - 1; } ch_data->t_q[1] = ch_data->t_env[idx]; } ch_data->e_a[0] = -(ch_data->e_a[1] != bs_num_env_old); ch_data->e_a[1] = -1; if ((ch_data->bs_frame_class & 1) && bs_pointer) { ch_data->e_a[1] = ch_data->bs_num_env + 1 - bs_pointer; } else if ((ch_data->bs_frame_class == 2) && (bs_pointer > 1)) ch_data->e_a[1] = bs_pointer - 1; return 0; }
--------------------------------------------- Result 411 ---------------------------------------------
[[0 (99%)]] --> [[0 (49%)]] --> Socre: 0.5148693323135376

[[[[Adv]]]]: static int decode_entropy_coded_image(WebPContext *s, enum ImageRole role, int w, int h) { ImageContext *[[img]]; HuffReader *[[hg]]; int i, j, ret, x, y, width; [[img]] = &s->image[role]; [[img]]->role = role; if (![[img]]->frame) { [[img]]->frame = av_frame_alloc(); if (![[img]]->frame) return AVERROR(ENOMEM); } [[img]]->frame->format = AV_PIX_FMT_ARGB; [[img]]->frame->width = w; [[img]]->frame->height = h; if (role == IMAGE_ROLE_ARGB && ![[img]]->is_alpha_primary) { ThreadFrame pt = { .f = [[img]]->frame }; ret = ff_thread_get_buffer(s->avctx, &pt, 0); } else ret = av_frame_get_buffer([[img]]->frame, 1); if (ret < 0) return ret; if (get_bits1(&s->gb)) { [[img]]->color_cache_bits = get_bits(&s->gb, 4); if ([[img]]->color_cache_bits < 1 || [[img]]->color_cache_bits > 11) { av_log(s->avctx, AV_LOG_ERROR, "invalid color cache bits: %d\n", [[img]]->color_cache_bits); return AVERROR_INVALIDDATA; } [[img]]->color_cache = av_mallocz_array(1 << [[img]]->color_cache_bits, sizeof(*[[img]]->color_cache)); if (![[img]]->color_cache) return AVERROR(ENOMEM); } else { [[img]]->color_cache_bits = 0; } [[img]]->nb_huffman_groups = 1; if (role == IMAGE_ROLE_ARGB && get_bits1(&s->gb)) { ret = decode_entropy_image(s); if (ret < 0) return ret; [[img]]->nb_huffman_groups = s->nb_huffman_groups; } [[img]]->huffman_groups = av_mallocz_array([[img]]->nb_huffman_groups * HUFFMAN_CODES_PER_META_CODE, sizeof(*[[img]]->huffman_groups)); if (![[img]]->huffman_groups) return AVERROR(ENOMEM); for (i = 0; i < [[img]]->nb_huffman_groups; i++) { [[hg]] = &[[img]]->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE]; for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) { int alphabet_size = alphabet_sizes[j]; if (!j && [[img]]->color_cache_bits > 0) alphabet_size += 1 << [[img]]->color_cache_bits; if (get_bits1(&s->gb)) { read_huffman_code_simple(s, &[[hg]][j]); } else { ret = read_huffman_code_normal(s, &[[hg]][j], alphabet_size); if (ret < 0) return ret; } } } width = [[img]]->frame->width; if (role == IMAGE_ROLE_ARGB && s->reduced_width > 0) width = s->reduced_width; x = 0; y = 0; while (y < [[img]]->frame->height) { int v; [[hg]] = get_huffman_group(s, [[img]], x, y); v = huff_reader_get_symbol(&[[hg]][HUFF_IDX_GREEN], &s->gb); if (v < NUM_LITERAL_CODES) { uint8_t *p = GET_PIXEL([[img]]->frame, x, y); p[2] = v; p[1] = huff_reader_get_symbol(&[[hg]][HUFF_IDX_RED], &s->gb); p[3] = huff_reader_get_symbol(&[[hg]][HUFF_IDX_BLUE], &s->gb); p[0] = huff_reader_get_symbol(&[[hg]][HUFF_IDX_ALPHA], &s->gb); if ([[img]]->color_cache_bits) color_cache_put([[img]], AV_RB32(p)); x++; if (x == width) { x = 0; y++; } } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) { int prefix_code, length, distance, ref_x, ref_y; prefix_code = v - NUM_LITERAL_CODES; if (prefix_code < 4) { length = prefix_code + 1; } else { int extra_bits = (prefix_code - 2) >> 1; int offset = 2 + (prefix_code & 1) << extra_bits; length = offset + get_bits(&s->gb, extra_bits) + 1; } prefix_code = huff_reader_get_symbol(&[[hg]][HUFF_IDX_DIST], &s->gb); if (prefix_code > 39) { av_log(s->avctx, AV_LOG_ERROR, "distance prefix code too large: %d\n", prefix_code); return AVERROR_INVALIDDATA; } if (prefix_code < 4) { distance = prefix_code + 1; } else { int extra_bits = prefix_code - 2 >> 1; int offset = 2 + (prefix_code & 1) << extra_bits; distance = offset + get_bits(&s->gb, extra_bits) + 1; } if (distance <= NUM_SHORT_DISTANCES) { int xi = lz77_distance_offsets[distance - 1][0]; int yi = lz77_distance_offsets[distance - 1][1]; distance = FFMAX(1, xi + yi * width); } else { distance -= NUM_SHORT_DISTANCES; } ref_x = x; ref_y = y; if (distance <= x) { ref_x -= distance; distance = 0; } else { ref_x = 0; distance -= x; } while (distance >= width) { ref_y--; distance -= width; } if (distance > 0) { ref_x = width - distance; ref_y--; } ref_x = FFMAX(0, ref_x); ref_y = FFMAX(0, ref_y); for (i = 0; i < length; i++) { uint8_t *p_ref = GET_PIXEL([[img]]->frame, ref_x, ref_y); uint8_t *p = GET_PIXEL([[img]]->frame, x, y); AV_COPY32(p, p_ref); if ([[img]]->color_cache_bits) color_cache_put([[img]], AV_RB32(p)); x++; ref_x++; if (x == width) { x = 0; y++; } if (ref_x == width) { ref_x = 0; ref_y++; } if (y == [[img]]->frame->height || ref_y == [[img]]->frame->height) break; } } else { uint8_t *p = GET_PIXEL([[img]]->frame, x, y); int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES); if (![[img]]->color_cache_bits) { av_log(s->avctx, AV_LOG_ERROR, "color cache not found\n"); return AVERROR_INVALIDDATA; } if (cache_idx >= 1 << [[img]]->color_cache_bits) { av_log(s->avctx, AV_LOG_ERROR, "color cache index out-of-bounds\n"); return AVERROR_INVALIDDATA; } AV_WB32(p, [[img]]->color_cache[cache_idx]); x++; if (x == width) { x = 0; y++; } } } return 0; }

[[[[Adv]]]]: static int decode_entropy_coded_image(WebPContext *s, enum ImageRole role, int w, int h) { ImageContext *[[derangement]]; HuffReader *[[neptune]]; int i, j, ret, x, y, width; [[derangement]] = &s->image[role]; [[derangement]]->role = role; if (![[derangement]]->frame) { [[derangement]]->frame = av_frame_alloc(); if (![[derangement]]->frame) return AVERROR(ENOMEM); } [[derangement]]->frame->format = AV_PIX_FMT_ARGB; [[derangement]]->frame->width = w; [[derangement]]->frame->height = h; if (role == IMAGE_ROLE_ARGB && ![[derangement]]->is_alpha_primary) { ThreadFrame pt = { .f = [[derangement]]->frame }; ret = ff_thread_get_buffer(s->avctx, &pt, 0); } else ret = av_frame_get_buffer([[derangement]]->frame, 1); if (ret < 0) return ret; if (get_bits1(&s->gb)) { [[derangement]]->color_cache_bits = get_bits(&s->gb, 4); if ([[derangement]]->color_cache_bits < 1 || [[derangement]]->color_cache_bits > 11) { av_log(s->avctx, AV_LOG_ERROR, "invalid color cache bits: %d\n", [[derangement]]->color_cache_bits); return AVERROR_INVALIDDATA; } [[derangement]]->color_cache = av_mallocz_array(1 << [[derangement]]->color_cache_bits, sizeof(*[[derangement]]->color_cache)); if (![[derangement]]->color_cache) return AVERROR(ENOMEM); } else { [[derangement]]->color_cache_bits = 0; } [[derangement]]->nb_huffman_groups = 1; if (role == IMAGE_ROLE_ARGB && get_bits1(&s->gb)) { ret = decode_entropy_image(s); if (ret < 0) return ret; [[derangement]]->nb_huffman_groups = s->nb_huffman_groups; } [[derangement]]->huffman_groups = av_mallocz_array([[derangement]]->nb_huffman_groups * HUFFMAN_CODES_PER_META_CODE, sizeof(*[[derangement]]->huffman_groups)); if (![[derangement]]->huffman_groups) return AVERROR(ENOMEM); for (i = 0; i < [[derangement]]->nb_huffman_groups; i++) { [[neptune]] = &[[derangement]]->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE]; for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) { int alphabet_size = alphabet_sizes[j]; if (!j && [[derangement]]->color_cache_bits > 0) alphabet_size += 1 << [[derangement]]->color_cache_bits; if (get_bits1(&s->gb)) { read_huffman_code_simple(s, &[[neptune]][j]); } else { ret = read_huffman_code_normal(s, &[[neptune]][j], alphabet_size); if (ret < 0) return ret; } } } width = [[derangement]]->frame->width; if (role == IMAGE_ROLE_ARGB && s->reduced_width > 0) width = s->reduced_width; x = 0; y = 0; while (y < [[derangement]]->frame->height) { int v; [[neptune]] = get_huffman_group(s, [[derangement]], x, y); v = huff_reader_get_symbol(&[[neptune]][HUFF_IDX_GREEN], &s->gb); if (v < NUM_LITERAL_CODES) { uint8_t *p = GET_PIXEL([[derangement]]->frame, x, y); p[2] = v; p[1] = huff_reader_get_symbol(&[[neptune]][HUFF_IDX_RED], &s->gb); p[3] = huff_reader_get_symbol(&[[neptune]][HUFF_IDX_BLUE], &s->gb); p[0] = huff_reader_get_symbol(&[[neptune]][HUFF_IDX_ALPHA], &s->gb); if ([[derangement]]->color_cache_bits) color_cache_put([[derangement]], AV_RB32(p)); x++; if (x == width) { x = 0; y++; } } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) { int prefix_code, length, distance, ref_x, ref_y; prefix_code = v - NUM_LITERAL_CODES; if (prefix_code < 4) { length = prefix_code + 1; } else { int extra_bits = (prefix_code - 2) >> 1; int offset = 2 + (prefix_code & 1) << extra_bits; length = offset + get_bits(&s->gb, extra_bits) + 1; } prefix_code = huff_reader_get_symbol(&[[neptune]][HUFF_IDX_DIST], &s->gb); if (prefix_code > 39) { av_log(s->avctx, AV_LOG_ERROR, "distance prefix code too large: %d\n", prefix_code); return AVERROR_INVALIDDATA; } if (prefix_code < 4) { distance = prefix_code + 1; } else { int extra_bits = prefix_code - 2 >> 1; int offset = 2 + (prefix_code & 1) << extra_bits; distance = offset + get_bits(&s->gb, extra_bits) + 1; } if (distance <= NUM_SHORT_DISTANCES) { int xi = lz77_distance_offsets[distance - 1][0]; int yi = lz77_distance_offsets[distance - 1][1]; distance = FFMAX(1, xi + yi * width); } else { distance -= NUM_SHORT_DISTANCES; } ref_x = x; ref_y = y; if (distance <= x) { ref_x -= distance; distance = 0; } else { ref_x = 0; distance -= x; } while (distance >= width) { ref_y--; distance -= width; } if (distance > 0) { ref_x = width - distance; ref_y--; } ref_x = FFMAX(0, ref_x); ref_y = FFMAX(0, ref_y); for (i = 0; i < length; i++) { uint8_t *p_ref = GET_PIXEL([[derangement]]->frame, ref_x, ref_y); uint8_t *p = GET_PIXEL([[derangement]]->frame, x, y); AV_COPY32(p, p_ref); if ([[derangement]]->color_cache_bits) color_cache_put([[derangement]], AV_RB32(p)); x++; ref_x++; if (x == width) { x = 0; y++; } if (ref_x == width) { ref_x = 0; ref_y++; } if (y == [[derangement]]->frame->height || ref_y == [[derangement]]->frame->height) break; } } else { uint8_t *p = GET_PIXEL([[derangement]]->frame, x, y); int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES); if (![[derangement]]->color_cache_bits) { av_log(s->avctx, AV_LOG_ERROR, "color cache not found\n"); return AVERROR_INVALIDDATA; } if (cache_idx >= 1 << [[derangement]]->color_cache_bits) { av_log(s->avctx, AV_LOG_ERROR, "color cache index out-of-bounds\n"); return AVERROR_INVALIDDATA; } AV_WB32(p, [[derangement]]->color_cache[cache_idx]); x++; if (x == width) { x = 0; y++; } } } return 0; }[Succeeded / Failed / Skipped / Total] 238 / 20 / 153 / 411:  15%|        | 411/2690 [3:54:57<21:42:49, 34.30s/it][Succeeded / Failed / Skipped / Total] 238 / 20 / 153 / 411:  15%|        | 412/2690 [3:55:05<21:39:51, 34.24s/it][Succeeded / Failed / Skipped / Total] 239 / 20 / 153 / 412:  15%|        | 412/2690 [3:55:05<21:39:51, 34.24s/it][Succeeded / Failed / Skipped / Total] 239 / 20 / 153 / 412:  15%|        | 413/2690 [3:55:06<21:36:11, 34.16s/it][Succeeded / Failed / Skipped / Total] 239 / 20 / 154 / 413:  15%|        | 413/2690 [3:55:06<21:36:11, 34.16s/it][Succeeded / Failed / Skipped / Total] 239 / 20 / 154 / 413:  15%|        | 414/2690 [3:55:13<21:33:08, 34.09s/it]
--------------------------------------------- Result 412 ---------------------------------------------
[[0 (37%)]] --> [[0 (59%)]] --> Socre: 0.5884639620780945

[[[[Adv]]]]: static int uhci_complete_td(UHCIState *s, UHCI_TD *[[td]], UHCIAsync *async, uint32_t *int_mask) { int len = 0, max_len, err, ret; uint8_t pid; max_len = (([[td]]->token >> 21) + 1) & 0x7ff; pid = [[td]]->token & 0xff; ret = async->packet.result; if ([[td]]->ctrl & TD_CTRL_IOS) [[td]]->ctrl &= ~TD_CTRL_ACTIVE; if (ret < 0) goto out; len = async->packet.result; [[td]]->ctrl = ([[td]]->ctrl & ~0x7ff) | ((len - 1) & 0x7ff); [[td]]->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK); if ([[td]]->ctrl & TD_CTRL_IOC) *int_mask |= 0x01; if (pid == USB_TOKEN_IN) { if (len > max_len) { ret = USB_RET_BABBLE; goto out; } if (([[td]]->ctrl & TD_CTRL_SPD) && len < max_len) { *int_mask |= 0x02; trace_usb_uhci_packet_complete_shortxfer(async->queue->token, async->td); return TD_RESULT_NEXT_QH; } } trace_usb_uhci_packet_complete_success(async->queue->token, async->td); return TD_RESULT_COMPLETE; out: while (!QTAILQ_EMPTY(&async->queue->asyncs)) { UHCIAsync *as = QTAILQ_FIRST(&async->queue->asyncs); uhci_async_unlink(as); uhci_async_cancel(as); } switch(ret) { case USB_RET_STALL: [[td]]->ctrl |= TD_CTRL_STALL; [[td]]->ctrl &= ~TD_CTRL_ACTIVE; s->status |= UHCI_STS_USBERR; if ([[td]]->ctrl & TD_CTRL_IOC) { *int_mask |= 0x01; } uhci_update_irq(s); trace_usb_uhci_packet_complete_stall(async->queue->token, async->td); return TD_RESULT_NEXT_QH; case USB_RET_BABBLE: [[td]]->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL; [[td]]->ctrl &= ~TD_CTRL_ACTIVE; s->status |= UHCI_STS_USBERR; if ([[td]]->ctrl & TD_CTRL_IOC) { *int_mask |= 0x01; } uhci_update_irq(s); trace_usb_uhci_packet_complete_babble(async->queue->token, async->td); return TD_RESULT_STOP_FRAME; case USB_RET_NAK: [[td]]->ctrl |= TD_CTRL_NAK; if (pid == USB_TOKEN_SETUP) break; return TD_RESULT_NEXT_QH; case USB_RET_IOERROR: case USB_RET_NODEV: default: break; } [[td]]->ctrl |= TD_CTRL_TIMEOUT; err = ([[td]]->ctrl >> TD_CTRL_ERROR_SHIFT) & 3; if (err != 0) { err--; if (err == 0) { [[td]]->ctrl &= ~TD_CTRL_ACTIVE; s->status |= UHCI_STS_USBERR; if ([[td]]->ctrl & TD_CTRL_IOC) *int_mask |= 0x01; uhci_update_irq(s); trace_usb_uhci_packet_complete_error(async->queue->token, async->td); } } [[td]]->ctrl = ([[td]]->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) | (err << TD_CTRL_ERROR_SHIFT); return TD_RESULT_NEXT_QH; }

[[[[Adv]]]]: static int uhci_complete_td(UHCIState *s, UHCI_TD *[[tk]], UHCIAsync *async, uint32_t *int_mask) { int len = 0, max_len, err, ret; uint8_t pid; max_len = (([[tk]]->token >> 21) + 1) & 0x7ff; pid = [[tk]]->token & 0xff; ret = async->packet.result; if ([[tk]]->ctrl & TD_CTRL_IOS) [[tk]]->ctrl &= ~TD_CTRL_ACTIVE; if (ret < 0) goto out; len = async->packet.result; [[tk]]->ctrl = ([[tk]]->ctrl & ~0x7ff) | ((len - 1) & 0x7ff); [[tk]]->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK); if ([[tk]]->ctrl & TD_CTRL_IOC) *int_mask |= 0x01; if (pid == USB_TOKEN_IN) { if (len > max_len) { ret = USB_RET_BABBLE; goto out; } if (([[tk]]->ctrl & TD_CTRL_SPD) && len < max_len) { *int_mask |= 0x02; trace_usb_uhci_packet_complete_shortxfer(async->queue->token, async->td); return TD_RESULT_NEXT_QH; } } trace_usb_uhci_packet_complete_success(async->queue->token, async->td); return TD_RESULT_COMPLETE; out: while (!QTAILQ_EMPTY(&async->queue->asyncs)) { UHCIAsync *as = QTAILQ_FIRST(&async->queue->asyncs); uhci_async_unlink(as); uhci_async_cancel(as); } switch(ret) { case USB_RET_STALL: [[tk]]->ctrl |= TD_CTRL_STALL; [[tk]]->ctrl &= ~TD_CTRL_ACTIVE; s->status |= UHCI_STS_USBERR; if ([[tk]]->ctrl & TD_CTRL_IOC) { *int_mask |= 0x01; } uhci_update_irq(s); trace_usb_uhci_packet_complete_stall(async->queue->token, async->td); return TD_RESULT_NEXT_QH; case USB_RET_BABBLE: [[tk]]->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL; [[tk]]->ctrl &= ~TD_CTRL_ACTIVE; s->status |= UHCI_STS_USBERR; if ([[tk]]->ctrl & TD_CTRL_IOC) { *int_mask |= 0x01; } uhci_update_irq(s); trace_usb_uhci_packet_complete_babble(async->queue->token, async->td); return TD_RESULT_STOP_FRAME; case USB_RET_NAK: [[tk]]->ctrl |= TD_CTRL_NAK; if (pid == USB_TOKEN_SETUP) break; return TD_RESULT_NEXT_QH; case USB_RET_IOERROR: case USB_RET_NODEV: default: break; } [[tk]]->ctrl |= TD_CTRL_TIMEOUT; err = ([[tk]]->ctrl >> TD_CTRL_ERROR_SHIFT) & 3; if (err != 0) { err--; if (err == 0) { [[tk]]->ctrl &= ~TD_CTRL_ACTIVE; s->status |= UHCI_STS_USBERR; if ([[tk]]->ctrl & TD_CTRL_IOC) *int_mask |= 0x01; uhci_update_irq(s); trace_usb_uhci_packet_complete_error(async->queue->token, async->td); } } [[tk]]->ctrl = ([[tk]]->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) | (err << TD_CTRL_ERROR_SHIFT); return TD_RESULT_NEXT_QH; }
--------------------------------------------- Result 413 ---------------------------------------------
[[0 (73%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int gif_read_image(GifState *s) { int left, top, width, height, bits_per_pixel, code_size, flags; int is_interleaved, has_local_palette, y, pass, y1, linesize, n, i; uint8_t *ptr, *spal, *palette, *ptr1; left = bytestream_get_le16(&s->bytestream); top = bytestream_get_le16(&s->bytestream); width = bytestream_get_le16(&s->bytestream); height = bytestream_get_le16(&s->bytestream); flags = bytestream_get_byte(&s->bytestream); is_interleaved = flags & 0x40; has_local_palette = flags & 0x80; bits_per_pixel = (flags & 0x07) + 1; av_dlog(s->avctx, "image x=%d y=%d w=%d h=%d\n", left, top, width, height); if (has_local_palette) { bytestream_get_buffer(&s->bytestream, s->local_palette, 3 * (1 << bits_per_pixel)); palette = s->local_palette; } else { palette = s->global_palette; bits_per_pixel = s->bits_per_pixel; } if (left + width > s->screen_width || top + height > s->screen_height) return AVERROR(EINVAL); n = (1 << bits_per_pixel); spal = palette; for(i = 0; i < n; i++) { s->image_palette[i] = (0xffu << 24) | AV_RB24(spal); spal += 3; } for(; i < 256; i++) s->image_palette[i] = (0xffu << 24); if (s->transparent_color_index >= 0) s->image_palette[s->transparent_color_index] = 0; code_size = bytestream_get_byte(&s->bytestream); ff_lzw_decode_init(s->lzw, code_size, s->bytestream, s->bytestream_end - s->bytestream, FF_LZW_GIF); linesize = s->picture.linesize[0]; ptr1 = s->picture.data[0] + top * linesize + left; ptr = ptr1; pass = 0; y1 = 0; for (y = 0; y < height; y++) { ff_lzw_decode(s->lzw, ptr, width); if (is_interleaved) { switch(pass) { default: case 0: case 1: y1 += 8; ptr += linesize * 8; if (y1 >= height) { y1 = pass ? 2 : 4; ptr = ptr1 + linesize * y1; pass++; } break; case 2: y1 += 4; ptr += linesize * 4; if (y1 >= height) { y1 = 1; ptr = ptr1 + linesize; pass++; } break; case 3: y1 += 2; ptr += linesize * 2; break; } } else { ptr += linesize; } } ff_lzw_decode_tail(s->lzw); s->bytestream = ff_lzw_cur_ptr(s->lzw); return 0; }
--------------------------------------------- Result 414 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 240 / 20 / 154 / 414:  15%|        | 414/2690 [3:55:13<21:33:08, 34.09s/it][Succeeded / Failed / Skipped / Total] 240 / 20 / 154 / 414:  15%|        | 415/2690 [3:55:13<21:29:29, 34.01s/it][Succeeded / Failed / Skipped / Total] 240 / 20 / 155 / 415:  15%|        | 415/2690 [3:55:13<21:29:29, 34.01s/it][Succeeded / Failed / Skipped / Total] 240 / 20 / 155 / 415:  15%|        | 416/2690 [3:55:14<21:25:52, 33.93s/it][Succeeded / Failed / Skipped / Total] 240 / 20 / 156 / 416:  15%|        | 416/2690 [3:55:14<21:25:52, 33.93s/it][Succeeded / Failed / Skipped / Total] 240 / 20 / 156 / 416:  16%|        | 417/2690 [3:55:27<21:23:25, 33.88s/it][Succeeded / Failed / Skipped / Total] 241 / 20 / 156 / 417:  16%|        | 417/2690 [3:55:27<21:23:25, 33.88s/it][Succeeded / Failed / Skipped / Total] 241 / 20 / 156 / 417:  16%|        | 418/2690 [3:55:31<21:20:10, 33.81s/it][[0 (28%)]] --> [[0 (53%)]] --> Socre: 0.5315371751785278

[[[[Adv]]]]: static int alac_encode_frame(AVCodecContext *[[avctx]], uint8_t *frame, int buf_size, void *data) { AlacEncodeContext *s = [[avctx]]->priv_data; PutBitContext *pb = &s->pbctx; int i, out_bytes, verbatim_flag = 0; if ([[avctx]]->frame_size > DEFAULT_FRAME_SIZE) { av_log([[avctx]], AV_LOG_ERROR, "input frame size exceeded\n"); return -1; } if (buf_size < 2 * s->max_coded_frame_size) { av_log([[avctx]], AV_LOG_ERROR, "buffer size is too small\n"); return -1; } verbatim: init_put_bits(pb, frame, buf_size); if (s->compression_level == 0 || verbatim_flag) { const int16_t *samples = data; write_frame_header(s, 1); for (i = 0; i < [[avctx]]->frame_size * [[avctx]]->channels; i++) { put_sbits(pb, 16, *samples++); } } else { init_sample_buffers(s, data); write_frame_header(s, 0); write_compressed_frame(s); } put_bits(pb, 3, 7); flush_put_bits(pb); out_bytes = put_bits_count(pb) >> 3; if (out_bytes > s->max_coded_frame_size) { if (verbatim_flag || s->compression_level == 0) { av_log([[avctx]], AV_LOG_ERROR, "error encoding frame\n"); return -1; } verbatim_flag = 1; goto verbatim; } return out_bytes; }

[[[[Adv]]]]: static int alac_encode_frame(AVCodecContext *[[epistle]], uint8_t *frame, int buf_size, void *data) { AlacEncodeContext *s = [[epistle]]->priv_data; PutBitContext *pb = &s->pbctx; int i, out_bytes, verbatim_flag = 0; if ([[epistle]]->frame_size > DEFAULT_FRAME_SIZE) { av_log([[epistle]], AV_LOG_ERROR, "input frame size exceeded\n"); return -1; } if (buf_size < 2 * s->max_coded_frame_size) { av_log([[epistle]], AV_LOG_ERROR, "buffer size is too small\n"); return -1; } verbatim: init_put_bits(pb, frame, buf_size); if (s->compression_level == 0 || verbatim_flag) { const int16_t *samples = data; write_frame_header(s, 1); for (i = 0; i < [[epistle]]->frame_size * [[epistle]]->channels; i++) { put_sbits(pb, 16, *samples++); } } else { init_sample_buffers(s, data); write_frame_header(s, 0); write_compressed_frame(s); } put_bits(pb, 3, 7); flush_put_bits(pb); out_bytes = put_bits_count(pb) >> 3; if (out_bytes > s->max_coded_frame_size) { if (verbatim_flag || s->compression_level == 0) { av_log([[epistle]], AV_LOG_ERROR, "error encoding frame\n"); return -1; } verbatim_flag = 1; goto verbatim; } return out_bytes; }
--------------------------------------------- Result 415 ---------------------------------------------
[[0 (24%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void i440fx_update_memory_mappings(PCII440FXState *d) { int i, r; uint32_t smram; bool smram_enabled; memory_region_transaction_begin(); update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3, &d->pam_regions[0]); for(i = 0; i < 12; i++) { r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3; update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r, &d->pam_regions[i+1]); } smram = d->dev.config[I440FX_SMRAM]; smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40); memory_region_set_enabled(&d->smram_region, !smram_enabled); memory_region_transaction_commit(); }
--------------------------------------------- Result 416 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vmdk_open_vmdk4(BlockDriverState *bs, BlockDriverState *file, int flags) { int ret; uint32_t magic; uint32_t l1_size, l1_entry_sectors; VMDK4Header header; VmdkExtent *extent; int64_t l1_backup_offset = 0; ret = bdrv_pread(file, sizeof(magic), &header, sizeof(header)); if (ret < 0) { return ret; } if (header.capacity == 0) { int64_t desc_offset = le64_to_cpu(header.desc_offset); if (desc_offset) { return vmdk_open_desc_file(bs, flags, desc_offset << 9); } } if (le64_to_cpu(header.gd_offset) == VMDK4_GD_AT_END) { struct { struct { uint64_t val; uint32_t size; uint32_t type; uint8_t pad[512 - 16]; } QEMU_PACKED footer_marker; uint32_t magic; VMDK4Header header; uint8_t pad[512 - 4 - sizeof(VMDK4Header)]; struct { uint64_t val; uint32_t size; uint32_t type; uint8_t pad[512 - 16]; } QEMU_PACKED eos_marker; } QEMU_PACKED footer; ret = bdrv_pread(file, bs->file->total_sectors * 512 - 1536, &footer, sizeof(footer)); if (ret < 0) { return ret; } if (be32_to_cpu(footer.magic) != VMDK4_MAGIC || le32_to_cpu(footer.footer_marker.size) != 0 || le32_to_cpu(footer.footer_marker.type) != MARKER_FOOTER || le64_to_cpu(footer.eos_marker.val) != 0 || le32_to_cpu(footer.eos_marker.size) != 0 || le32_to_cpu(footer.eos_marker.type) != MARKER_END_OF_STREAM) { return -EINVAL; } header = footer.header; } if (le32_to_cpu(header.version) >= 3) { char buf[64]; snprintf(buf, sizeof(buf), "VMDK version %d", le32_to_cpu(header.version)); qerror_report(QERR_UNKNOWN_BLOCK_FORMAT_FEATURE, bs->device_name, "vmdk", buf); return -ENOTSUP; } l1_entry_sectors = le32_to_cpu(header.num_gtes_per_gte) * le64_to_cpu(header.granularity); if (l1_entry_sectors == 0) { return -EINVAL; } l1_size = (le64_to_cpu(header.capacity) + l1_entry_sectors - 1) / l1_entry_sectors; if (le32_to_cpu(header.flags) & VMDK4_FLAG_RGD) { l1_backup_offset = le64_to_cpu(header.rgd_offset) << 9; } extent = vmdk_add_extent(bs, file, "False" != "False", le64_to_cpu(header.capacity), le64_to_cpu(header.gd_offset) << 9, l1_backup_offset, l1_size, le32_to_cpu(header.num_gtes_per_gte), le64_to_cpu(header.granularity)); extent->compressed = le16_to_cpu(header.compressAlgorithm) == VMDK4_COMPRESSION_DEFLATE; extent->has_marker = le32_to_cpu(header.flags) & VMDK4_FLAG_MARKER; extent->version = le32_to_cpu(header.version); extent->has_zero_grain = le32_to_cpu(header.flags) & VMDK4_FLAG_ZERO_GRAIN; ret = vmdk_init_tables(bs, extent); if (ret) { vmdk_free_last_extent(bs); } return ret; }
--------------------------------------------- Result 417 ---------------------------------------------
[[0 (22%)]] --> [[0 (62%)]] --> Socre: 0.6215133666992188

[[[[Adv]]]]: static void cpu_x86_dump_state(FILE *[[f]]) { int eflags; char cc_op_name[32]; eflags = cc_table[CC_OP].compute_all(); eflags |= (DF & DF_MASK); if ((unsigned)env->cc_op < CC_OP_NB) strcpy(cc_op_name, cc_op_str[env->cc_op]); else snprintf(cc_op_name, sizeof(cc_op_name), "[%d]", env->cc_op); fprintf([[f]], "EAX=%08x EBX=%08X ECX=%08x EDX=%08x\n" "ESI=%08x EDI=%08X EBP=%08x ESP=%08x\n" "CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\n" "EIP=%08x\n", env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], env->cc_src, env->cc_dst, cc_op_name, eflags & DF_MASK ? 'D' : '-', eflags & CC_O ? 'O' : '-', eflags & CC_S ? 'S' : '-', eflags & CC_Z ? 'Z' : '-', eflags & CC_A ? 'A' : '-', eflags & CC_P ? 'P' : '-', eflags & CC_C ? 'C' : '-', env->eip); #if 1 fprintf([[f]], "ST0=%f ST1=%f ST2=%f ST3=%f\n", (double)ST0, (double)ST1, (double)ST(2), (double)ST(3)); #endif }

[[[[Adv]]]]: static void cpu_x86_dump_state(FILE *[[grams]]) { int eflags; char cc_op_name[32]; eflags = cc_table[CC_OP].compute_all(); eflags |= (DF & DF_MASK); if ((unsigned)env->cc_op < CC_OP_NB) strcpy(cc_op_name, cc_op_str[env->cc_op]); else snprintf(cc_op_name, sizeof(cc_op_name), "[%d]", env->cc_op); fprintf([[grams]], "EAX=%08x EBX=%08X ECX=%08x EDX=%08x\n" "ESI=%08x EDI=%08X EBP=%08x ESP=%08x\n" "CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\n" "EIP=%08x\n", env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], env->cc_src, env->cc_dst, cc_op_name, eflags & DF_MASK ? 'D' : '-', eflags & CC_O ? 'O' : '-', eflags & CC_S ? 'S' : '-', eflags & CC_Z ? 'Z' : '-', eflags & CC_A ? 'A' : '-', eflags & CC_P ? 'P' : '-', eflags & CC_C ? 'C' : '-', env->eip); #if 1 fprintf([[grams]], "ST0=%f ST1=%f ST2=%f ST3=%f\n", (double)ST0, (double)ST1, (double)ST(2), (double)ST(3)); #endif }
--------------------------------------------- Result 418 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 242 / 20 / 156 / 418:  16%|        | 418/2690 [3:55:31<21:20:10, 33.81s/it][Succeeded / Failed / Skipped / Total] 242 / 20 / 156 / 418:  16%|        | 419/2690 [3:55:34<21:16:49, 33.73s/it][Succeeded / Failed / Skipped / Total] 243 / 20 / 156 / 419:  16%|        | 419/2690 [3:55:34<21:16:49, 33.73s/it][Succeeded / Failed / Skipped / Total] 243 / 20 / 156 / 419:  16%|        | 420/2690 [3:55:37<21:13:29, 33.66s/it][Succeeded / Failed / Skipped / Total] 244 / 20 / 156 / 420:  16%|        | 420/2690 [3:55:37<21:13:29, 33.66s/it][Succeeded / Failed / Skipped / Total] 244 / 20 / 156 / 420:  16%|        | 421/2690 [3:55:45<21:10:39, 33.60s/it][Succeeded / Failed / Skipped / Total] 245 / 20 / 156 / 421:  16%|        | 421/2690 [3:55:45<21:10:39, 33.60s/it][Succeeded / Failed / Skipped / Total] 245 / 20 / 156 / 421:  16%|        | 422/2690 [3:55:49<21:07:24, 33.53s/it][Succeeded / Failed / Skipped / Total] 245 / 21 / 156 / 422:  16%|        | 422/2690 [3:55:49<21:07:24, 33.53s/it][Succeeded / Failed / Skipped / Total] 245 / 21 / 156 / 422:  16%|        | 423/2690 [3:55:58<21:04:42, 33.47s/it][[0 (25%)]] --> [[0 (54%)]] --> Socre: 0.5432839393615723

[[[[Adv]]]]: static bool use_multiport(VirtIOSerial *[[vser]]) { VirtIODevice *[[vdev]] = VIRTIO_DEVICE([[vser]]); return virtio_has_feature([[vdev]], VIRTIO_CONSOLE_F_MULTIPORT); }

[[[[Adv]]]]: static bool use_multiport(VirtIOSerial *[[grandbaby]]) { VirtIODevice *[[fir]] = VIRTIO_DEVICE([[grandbaby]]); return virtio_has_feature([[fir]], VIRTIO_CONSOLE_F_MULTIPORT); }
--------------------------------------------- Result 419 ---------------------------------------------
[[0 (36%)]] --> [[0 (62%)]] --> Socre: 0.6229041814804077

[[[[Adv]]]]: static int poll_filter(OutputStream *ost) { OutputFile *of = output_files[ost->file_index]; AVFrame *[[filtered_frame]] = NULL; int frame_size, ret; if (!ost->filtered_frame && !(ost->filtered_frame = avcodec_alloc_frame())) { return AVERROR(ENOMEM); } else avcodec_get_frame_defaults(ost->filtered_frame); [[filtered_frame]] = ost->filtered_frame; if (ost->enc->type == AVMEDIA_TYPE_AUDIO && !(ost->enc->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE)) ret = av_buffersink_get_samples(ost->filter->filter, [[filtered_frame]], ost->st->codec->frame_size); else ret = av_buffersink_get_frame(ost->filter->filter, [[filtered_frame]]); if (ret < 0) return ret; if ([[filtered_frame]]->pts != AV_NOPTS_VALUE) { [[filtered_frame]]->pts = av_rescale_q([[filtered_frame]]->pts, ost->filter->filter->inputs[0]->time_base, ost->st->codec->time_base) - av_rescale_q(of->start_time, AV_TIME_BASE_Q, ost->st->codec->time_base); } switch (ost->filter->filter->inputs[0]->type) { case AVMEDIA_TYPE_VIDEO: if (!ost->frame_aspect_ratio) ost->st->codec->sample_aspect_ratio = [[filtered_frame]]->sample_aspect_ratio; do_video_out(of->ctx, ost, [[filtered_frame]], &frame_size); if (vstats_filename && frame_size) do_video_stats(ost, frame_size); break; case AVMEDIA_TYPE_AUDIO: do_audio_out(of->ctx, ost, [[filtered_frame]]); break; default: av_assert0(0); } av_frame_unref([[filtered_frame]]); return 0; }

[[[[Adv]]]]: static int poll_filter(OutputStream *ost) { OutputFile *of = output_files[ost->file_index]; AVFrame *[[sweatshops]] = NULL; int frame_size, ret; if (!ost->filtered_frame && !(ost->filtered_frame = avcodec_alloc_frame())) { return AVERROR(ENOMEM); } else avcodec_get_frame_defaults(ost->filtered_frame); [[sweatshops]] = ost->filtered_frame; if (ost->enc->type == AVMEDIA_TYPE_AUDIO && !(ost->enc->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE)) ret = av_buffersink_get_samples(ost->filter->filter, [[sweatshops]], ost->st->codec->frame_size); else ret = av_buffersink_get_frame(ost->filter->filter, [[sweatshops]]); if (ret < 0) return ret; if ([[sweatshops]]->pts != AV_NOPTS_VALUE) { [[sweatshops]]->pts = av_rescale_q([[sweatshops]]->pts, ost->filter->filter->inputs[0]->time_base, ost->st->codec->time_base) - av_rescale_q(of->start_time, AV_TIME_BASE_Q, ost->st->codec->time_base); } switch (ost->filter->filter->inputs[0]->type) { case AVMEDIA_TYPE_VIDEO: if (!ost->frame_aspect_ratio) ost->st->codec->sample_aspect_ratio = [[sweatshops]]->sample_aspect_ratio; do_video_out(of->ctx, ost, [[sweatshops]], &frame_size); if (vstats_filename && frame_size) do_video_stats(ost, frame_size); break; case AVMEDIA_TYPE_AUDIO: do_audio_out(of->ctx, ost, [[sweatshops]]); break; default: av_assert0(0); } av_frame_unref([[sweatshops]]); return 0; }
--------------------------------------------- Result 420 ---------------------------------------------
[[0 (4%)]] --> [[0 (98%)]] --> Socre: 0.9823560118675232

[[[[Adv]]]]: void *memory_region_get_ram_ptr(MemoryRegion *[[mr]]) { if ([[mr]]->alias) { return memory_region_get_ram_ptr([[mr]]->alias) + [[mr]]->alias_offset; } assert([[mr]]->terminates); return qemu_get_ram_ptr([[mr]]->ram_addr & TARGET_PAGE_MASK); }

[[[[Adv]]]]: void *memory_region_get_ram_ptr(MemoryRegion *[[jrgen]]) { if ([[jrgen]]->alias) { return memory_region_get_ram_ptr([[jrgen]]->alias) + [[jrgen]]->alias_offset; } assert([[jrgen]]->terminates); return qemu_get_ram_ptr([[jrgen]]->ram_addr & TARGET_PAGE_MASK); }
--------------------------------------------- Result 421 ---------------------------------------------
[[0 (8%)]] --> [[0 (99%)]] --> Socre: 0.9864229559898376

[[[[Adv]]]]: void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *[[afq]]) { [[afq]]->avctx = avctx; [[afq]]->next_pts = AV_NOPTS_VALUE; [[afq]]->remaining_delay = avctx->delay; [[afq]]->remaining_samples = avctx->delay; [[afq]]->frame_queue = NULL; }

[[[[Adv]]]]: void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *[[divorce]]) { [[divorce]]->avctx = avctx; [[divorce]]->next_pts = AV_NOPTS_VALUE; [[divorce]]->remaining_delay = avctx->delay; [[divorce]]->remaining_samples = avctx->delay; [[divorce]]->frame_queue = NULL; }
--------------------------------------------- Result 422 ---------------------------------------------
[[0 (91%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void control_to_network(RDMAControlHeader *control) { control->type = htonl(control->type); control->len = htonl(control->len); control->repeat = htonl(control->repeat); }

[[[[Adv]]]]: static void control_to_network(RDMAControlHeader *control) { control->type = htonl(control->type); control->len = htonl(control->len); control->repeat = htonl(control->repeat); }
--------------------------------------------- Result 423 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 246 / 21 / 156 / 423:  16%|        | 423/2690 [3:55:58<21:04:42, 33.47s/it][Succeeded / Failed / Skipped / Total] 246 / 21 / 156 / 423:  16%|        | 424/2690 [3:55:59<21:01:12, 33.39s/it][Succeeded / Failed / Skipped / Total] 246 / 21 / 157 / 424:  16%|        | 424/2690 [3:55:59<21:01:12, 33.39s/it][Succeeded / Failed / Skipped / Total] 246 / 21 / 157 / 424:  16%|        | 425/2690 [3:55:59<20:57:44, 33.32s/it][[0 (85%)]] --> [[0 (49%)]] --> Socre: 0.5105604529380798

[[[[Adv]]]]: static inline void RENAME(rgb24tobgr15)(const uint8_t *src, uint8_t *dst, int [[src_size]]) { const uint8_t *s = src; const uint8_t *end; const uint8_t *[[mm_end]]; uint16_t *d = (uint16_t *)dst; end = s + [[src_size]]; __asm__ volatile(PREFETCH" %0"::"m"(*src):"memory"); __asm__ volatile( "movq %0, %%mm7 \n\t" "movq %1, %%mm6 \n\t" ::"m"(red_15mask),"m"(green_15mask)); [[mm_end]] = end - 11; while (s < [[mm_end]]) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movd %1, %%mm0 \n\t" "movd 3%1, %%mm3 \n\t" "punpckldq 6%1, %%mm0 \n\t" "punpckldq 9%1, %%mm3 \n\t" "movq %%mm0, %%mm1 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm3, %%mm4 \n\t" "movq %%mm3, %%mm5 \n\t" "psrlq $3, %%mm0 \n\t" "psrlq $3, %%mm3 \n\t" "pand %2, %%mm0 \n\t" "pand %2, %%mm3 \n\t" "psrlq $6, %%mm1 \n\t" "psrlq $6, %%mm4 \n\t" "pand %%mm6, %%mm1 \n\t" "pand %%mm6, %%mm4 \n\t" "psrlq $9, %%mm2 \n\t" "psrlq $9, %%mm5 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm5 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm2, %%mm0 \n\t" "por %%mm5, %%mm3 \n\t" "psllq $16, %%mm3 \n\t" "por %%mm3, %%mm0 \n\t" MOVNTQ" %%mm0, %0 \n\t" :"=m"(*d):"m"(*s),"m"(blue_15mask):"memory"); d += 4; s += 12; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while (s < end) { const int b = *s++; const int g = *s++; const int r = *s++; *d++ = (b>>3) | ((g&0xF8)<<2) | ((r&0xF8)<<7); } }

[[[[Adv]]]]: static inline void RENAME(rgb24tobgr15)(const uint8_t *src, uint8_t *dst, int [[conservatively]]) { const uint8_t *s = src; const uint8_t *end; const uint8_t *[[pathetically]]; uint16_t *d = (uint16_t *)dst; end = s + [[conservatively]]; __asm__ volatile(PREFETCH" %0"::"m"(*src):"memory"); __asm__ volatile( "movq %0, %%mm7 \n\t" "movq %1, %%mm6 \n\t" ::"m"(red_15mask),"m"(green_15mask)); [[pathetically]] = end - 11; while (s < [[pathetically]]) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movd %1, %%mm0 \n\t" "movd 3%1, %%mm3 \n\t" "punpckldq 6%1, %%mm0 \n\t" "punpckldq 9%1, %%mm3 \n\t" "movq %%mm0, %%mm1 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm3, %%mm4 \n\t" "movq %%mm3, %%mm5 \n\t" "psrlq $3, %%mm0 \n\t" "psrlq $3, %%mm3 \n\t" "pand %2, %%mm0 \n\t" "pand %2, %%mm3 \n\t" "psrlq $6, %%mm1 \n\t" "psrlq $6, %%mm4 \n\t" "pand %%mm6, %%mm1 \n\t" "pand %%mm6, %%mm4 \n\t" "psrlq $9, %%mm2 \n\t" "psrlq $9, %%mm5 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm5 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm2, %%mm0 \n\t" "por %%mm5, %%mm3 \n\t" "psllq $16, %%mm3 \n\t" "por %%mm3, %%mm0 \n\t" MOVNTQ" %%mm0, %0 \n\t" :"=m"(*d):"m"(*s),"m"(blue_15mask):"memory"); d += 4; s += 12; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while (s < end) { const int b = *s++; const int g = *s++; const int r = *s++; *d++ = (b>>3) | ((g&0xF8)<<2) | ((r&0xF8)<<7); } }
--------------------------------------------- Result 424 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static gboolean gd_motion_event(GtkWidget *widget, GdkEventMotion *motion, void *opaque) { GtkDisplayState *s = opaque; int x, y; int mx, my; int fbh, fbw; int ww, wh; fbw = surface_width(s->ds) * s->scale_x; fbh = surface_height(s->ds) * s->scale_y; gdk_drawable_get_size(gtk_widget_get_window(s->drawing_area), &ww, &wh); mx = my = 0; if (ww > fbw) { mx = (ww - fbw) / 2; } if (wh > fbh) { my = (wh - fbh) / 2; } x = (motion->x - mx) / s->scale_x; y = (motion->y - my) / s->scale_y; if (x < 0 || y < 0 || x >= surface_width(s->ds) || y >= surface_height(s->ds)) { return "True" == "True"; } if (qemu_input_is_absolute()) { qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_X, x, surface_width(s->ds)); qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_Y, y, surface_height(s->ds)); qemu_input_event_sync(); } else if (s->last_x != -1 && s->last_y != -1 && gd_is_grab_active(s)) { qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_X, x - s->last_x); qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_Y, y - s->last_y); qemu_input_event_sync(); } s->last_x = x; s->last_y = y; if (!qemu_input_is_absolute() && gd_is_grab_active(s)) { GdkScreen *screen = gtk_widget_get_screen(s->drawing_area); int x = (int)motion->x_root; int y = (int)motion->y_root; if (x == 0) { x += 200; } if (y == 0) { y += 200; } if (x == (gdk_screen_get_width(screen) - 1)) { x -= 200; } if (y == (gdk_screen_get_height(screen) - 1)) { y -= 200; } if (x != (int)motion->x_root || y != (int)motion->y_root) { #if GTK_CHECK_VERSION(3, 0, 0) GdkDevice *dev = gdk_event_get_device((GdkEvent *)motion); gdk_device_warp(dev, screen, x, y); #else GdkDisplay *display = gtk_widget_get_display(widget); gdk_display_warp_pointer(display, screen, x, y); #endif s->last_x = -1; s->last_y = -1; return "False" != "False"; } } return "True" == "True"; }
--------------------------------------------- Result 425 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 246 / 21 / 158 / 425:  16%|        | 425/2690 [3:55:59<20:57:44, 33.32s/it][Succeeded / Failed / Skipped / Total] 246 / 21 / 158 / 425:  16%|        | 426/2690 [3:56:00<20:54:16, 33.24s/it][Succeeded / Failed / Skipped / Total] 246 / 21 / 159 / 426:  16%|        | 426/2690 [3:56:00<20:54:16, 33.24s/it][Succeeded / Failed / Skipped / Total] 246 / 21 / 159 / 426:  16%|        | 427/2690 [3:56:04<20:51:07, 33.17s/it][Succeeded / Failed / Skipped / Total] 247 / 21 / 159 / 427:  16%|        | 427/2690 [3:56:04<20:51:07, 33.17s/it][Succeeded / Failed / Skipped / Total] 247 / 21 / 159 / 427:  16%|        | 428/2690 [3:56:07<20:47:57, 33.10s/it][[0 (65%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile, int level) { VDPAUHWContext *hwctx = avctx->hwaccel_context; VDPAUContext *vdctx = avctx->internal->hwaccel_priv_data; VdpVideoSurfaceQueryCapabilities *surface_query_caps; VdpDecoderQueryCapabilities *decoder_query_caps; VdpDecoderCreate *create; void *func; VdpStatus status; VdpBool supported; uint32_t max_level, max_mb, max_width, max_height; VdpChromaType type; uint32_t width; uint32_t height; vdctx->width = UINT32_MAX; vdctx->height = UINT32_MAX; if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height)) return AVERROR(ENOSYS); if (hwctx) { hwctx->reset = 0; if (hwctx->context.decoder != VDP_INVALID_HANDLE) { vdctx->decoder = hwctx->context.decoder; vdctx->render = hwctx->context.render; vdctx->device = VDP_INVALID_HANDLE; return 0; } vdctx->device = hwctx->device; vdctx->get_proc_address = hwctx->get_proc_address; if (hwctx->flags & AV_HWACCEL_FLAG_IGNORE_LEVEL) level = 0; if (!(hwctx->flags & AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH) && type != VDP_CHROMA_TYPE_420) return AVERROR(ENOSYS); } else { AVHWFramesContext *frames_ctx = NULL; AVVDPAUDeviceContext *dev_ctx; if (avctx->hw_frames_ctx) { frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data; } else if (avctx->hw_device_ctx) { int ret; avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx); if (!avctx->hw_frames_ctx) return AVERROR(ENOMEM); frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data; frames_ctx->format = AV_PIX_FMT_VDPAU; frames_ctx->sw_format = avctx->sw_pix_fmt; frames_ctx->width = avctx->coded_width; frames_ctx->height = avctx->coded_height; ret = av_hwframe_ctx_init(avctx->hw_frames_ctx); if (ret < 0) { av_buffer_unref(&avctx->hw_frames_ctx); return ret; } } if (!frames_ctx) { av_log(avctx, AV_LOG_ERROR, "A hardware frames context is " "required for VDPAU decoding.\n"); return AVERROR(EINVAL); } dev_ctx = frames_ctx->device_ctx->hwctx; vdctx->device = dev_ctx->device; vdctx->get_proc_address = dev_ctx->get_proc_address; if (avctx->hwaccel_flags & AV_HWACCEL_FLAG_IGNORE_LEVEL) level = 0; } if (level < 0) return AVERROR(ENOTSUP); status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES, &func); if (status != VDP_STATUS_OK) return vdpau_error(status); else surface_query_caps = func; status = surface_query_caps(vdctx->device, type, &supported, &max_width, &max_height); if (status != VDP_STATUS_OK) return vdpau_error(status); if (supported != VDP_TRUE || max_width < width || max_height < height) return AVERROR(ENOTSUP); status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES, &func); if (status != VDP_STATUS_OK) return vdpau_error(status); else decoder_query_caps = func; status = decoder_query_caps(vdctx->device, profile, &supported, &max_level, &max_mb, &max_width, &max_height); #ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE if ((status != VDP_STATUS_OK || supported != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) { profile = VDP_DECODER_PROFILE_H264_MAIN; status = decoder_query_caps(vdctx->device, profile, &supported, &max_level, &max_mb, &max_width, &max_height); } #endif if (status != VDP_STATUS_OK) return vdpau_error(status); if (supported != VDP_TRUE || max_level < level || max_width < width || max_height < height) return AVERROR(ENOTSUP); status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE, &func); if (status != VDP_STATUS_OK) return vdpau_error(status); else create = func; status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER, &func); if (status != VDP_STATUS_OK) return vdpau_error(status); else vdctx->render = func; status = create(vdctx->device, profile, width, height, avctx->refs, &vdctx->decoder); if (status == VDP_STATUS_OK) { vdctx->width = avctx->coded_width; vdctx->height = avctx->coded_height; } return vdpau_error(status); }
--------------------------------------------- Result 426 ---------------------------------------------
[[0 (16%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int estimate_qp(MpegEncContext *s, int dry_run){ if (s->next_lambda){ s->current_picture_ptr->f.quality = s->current_picture.f.quality = s->next_lambda; if(!dry_run) s->next_lambda= 0; } else if (!s->fixed_qscale) { s->current_picture_ptr->f.quality = s->current_picture.f.quality = ff_rate_estimate_qscale(s, dry_run); if (s->current_picture.f.quality < 0) return -1; } if(s->adaptive_quant){ switch(s->codec_id){ case AV_CODEC_ID_MPEG4: if (CONFIG_MPEG4_ENCODER) ff_clean_mpeg4_qscales(s); break; case AV_CODEC_ID_H263: case AV_CODEC_ID_H263P: case AV_CODEC_ID_FLV1: if (CONFIG_H263_ENCODER) ff_clean_h263_qscales(s); break; default: ff_init_qscale_tab(s); } s->lambda= s->lambda_table[0]; }else s->lambda = s->current_picture.f.quality; update_qscale(s); return 0; }
--------------------------------------------- Result 427 ---------------------------------------------
[[0 (29%)]] --> [[0 (60%)]] --> Socre: 0.6035434603691101

[[[[Adv]]]]: static void spr_write_tbu (DisasContext *ctx, int sprn, int [[gprn]]) { if (use_icount) { gen_io_start(); } gen_helper_store_tbu(cpu_env, cpu_gpr[[[gprn]]]); if (use_icount) { gen_io_end(); gen_stop_exception(ctx); } }

[[[[Adv]]]]: static void spr_write_tbu (DisasContext *ctx, int sprn, int [[burger]]) { if (use_icount) { gen_io_start(); } gen_helper_store_tbu(cpu_env, cpu_gpr[[[burger]]]); if (use_icount) { gen_io_end(); gen_stop_exception(ctx); } }
--------------------------------------------- Result 428 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 248 / 21 / 159 / 428:  16%|        | 428/2690 [3:56:07<20:47:57, 33.10s/it][Succeeded / Failed / Skipped / Total] 248 / 21 / 159 / 428:  16%|        | 429/2690 [3:56:39<20:47:19, 33.10s/it][Succeeded / Failed / Skipped / Total] 249 / 21 / 159 / 429:  16%|        | 429/2690 [3:56:39<20:47:19, 33.10s/it][Succeeded / Failed / Skipped / Total] 249 / 21 / 159 / 429:  16%|        | 430/2690 [3:56:40<20:43:54, 33.02s/it][Succeeded / Failed / Skipped / Total] 249 / 22 / 159 / 430:  16%|        | 430/2690 [3:56:40<20:43:54, 33.02s/it][Succeeded / Failed / Skipped / Total] 249 / 22 / 159 / 430:  16%|        | 431/2690 [3:56:40<20:40:31, 32.95s/it][Succeeded / Failed / Skipped / Total] 249 / 22 / 160 / 431:  16%|        | 431/2690 [3:56:40<20:40:31, 32.95s/it][Succeeded / Failed / Skipped / Total] 249 / 22 / 160 / 431:  16%|        | 432/2690 [3:56:47<20:37:41, 32.89s/it][Succeeded / Failed / Skipped / Total] 250 / 22 / 160 / 432:  16%|        | 432/2690 [3:56:47<20:37:41, 32.89s/it][Succeeded / Failed / Skipped / Total] 250 / 22 / 160 / 432:  16%|        | 433/2690 [4:01:02<20:56:27, 33.40s/it][[0 (48%)]] --> [[0 (58%)]] --> Socre: 0.5815519690513611

[[[[Adv]]]]: static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev) { #ifdef CONFIG_KVM struct kvm_irqfd [[irqfd]] = { .fd = event_notifier_get_fd(&vdev->intx.interrupt), .gsi = vdev->intx.route.irq, .flags = KVM_IRQFD_FLAG_RESAMPLE, }; struct vfio_irq_set *irq_set; int ret, argsz; int32_t *pfd; if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() || vdev->intx.route.mode != PCI_INTX_ENABLED || !kvm_resamplefds_enabled()) { return; } qemu_set_fd_handler([[irqfd]].fd, NULL, NULL, vdev); vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX); vdev->intx.pending = "False" != "False"; pci_irq_deassert(&vdev->pdev); if (event_notifier_init(&vdev->intx.unmask, 0)) { error_report("vfio: Error: event_notifier_init failed eoi"); goto fail; } [[irqfd]].resamplefd = event_notifier_get_fd(&vdev->intx.unmask); if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &[[irqfd]])) { error_report("vfio: Error: Failed to setup resample irqfd: %m"); goto fail_irqfd; } argsz = sizeof(*irq_set) + sizeof(*pfd); irq_set = g_malloc0(argsz); irq_set->argsz = argsz; irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK; irq_set->index = VFIO_PCI_INTX_IRQ_INDEX; irq_set->start = 0; irq_set->count = 1; pfd = (int32_t *)&irq_set->data; *pfd = [[irqfd]].resamplefd; ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set); g_free(irq_set); if (ret) { error_report("vfio: Error: Failed to setup INTx unmask fd: %m"); goto fail_vfio; } vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX); vdev->intx.kvm_accel = "True" == "True"; trace_vfio_intx_enable_kvm(vdev->vbasedev.name); return; fail_vfio: [[irqfd]].flags = KVM_IRQFD_FLAG_DEASSIGN; kvm_vm_ioctl(kvm_state, KVM_IRQFD, &[[irqfd]]); fail_irqfd: event_notifier_cleanup(&vdev->intx.unmask); fail: qemu_set_fd_handler([[irqfd]].fd, vfio_intx_interrupt, NULL, vdev); vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX); #endif }

[[[[Adv]]]]: static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev) { #ifdef CONFIG_KVM struct kvm_irqfd [[makeup]] = { .fd = event_notifier_get_fd(&vdev->intx.interrupt), .gsi = vdev->intx.route.irq, .flags = KVM_IRQFD_FLAG_RESAMPLE, }; struct vfio_irq_set *irq_set; int ret, argsz; int32_t *pfd; if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() || vdev->intx.route.mode != PCI_INTX_ENABLED || !kvm_resamplefds_enabled()) { return; } qemu_set_fd_handler([[makeup]].fd, NULL, NULL, vdev); vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX); vdev->intx.pending = "False" != "False"; pci_irq_deassert(&vdev->pdev); if (event_notifier_init(&vdev->intx.unmask, 0)) { error_report("vfio: Error: event_notifier_init failed eoi"); goto fail; } [[makeup]].resamplefd = event_notifier_get_fd(&vdev->intx.unmask); if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &[[makeup]])) { error_report("vfio: Error: Failed to setup resample irqfd: %m"); goto fail_irqfd; } argsz = sizeof(*irq_set) + sizeof(*pfd); irq_set = g_malloc0(argsz); irq_set->argsz = argsz; irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK; irq_set->index = VFIO_PCI_INTX_IRQ_INDEX; irq_set->start = 0; irq_set->count = 1; pfd = (int32_t *)&irq_set->data; *pfd = [[makeup]].resamplefd; ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set); g_free(irq_set); if (ret) { error_report("vfio: Error: Failed to setup INTx unmask fd: %m"); goto fail_vfio; } vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX); vdev->intx.kvm_accel = "True" == "True"; trace_vfio_intx_enable_kvm(vdev->vbasedev.name); return; fail_vfio: [[makeup]].flags = KVM_IRQFD_FLAG_DEASSIGN; kvm_vm_ioctl(kvm_state, KVM_IRQFD, &[[makeup]]); fail_irqfd: event_notifier_cleanup(&vdev->intx.unmask); fail: qemu_set_fd_handler([[makeup]].fd, vfio_intx_interrupt, NULL, vdev); vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX); #endif }
--------------------------------------------- Result 429 ---------------------------------------------
[[0 (1%)]] --> [[0 (98%)]] --> Socre: 0.9761146306991577

[[[[Adv]]]]: void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t [[parm]]) { kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, [[parm]], 0 , 1); }

[[[[Adv]]]]: void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t [[lumire]]) { kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, [[lumire]], 0 , 1); }
--------------------------------------------- Result 430 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline void gen_evfsnabs(DisasContext *ctx) { if (unlikely(!ctx->spe_enabled)) { gen_exception(ctx, POWERPC_EXCP_APU); return; } #if defined(TARGET_PPC64) tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL); #else tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000); tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000); #endif }

[[[[Adv]]]]: static inline void gen_evfsnabs(DisasContext *ctx) { if (unlikely(!ctx->spe_enabled)) { gen_exception(ctx, POWERPC_EXCP_APU); return; } #if defined(TARGET_PPC64) tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL); #else tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000); tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000); #endif }
--------------------------------------------- Result 431 ---------------------------------------------
[[0 (59%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags, Error **errp) { BDRVBlkdebugState *s = bs->opaque; QemuOpts *opts; Error *local_err = NULL; int ret; opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort); qemu_opts_absorb_qdict(opts, options, &local_err); if (local_err) { error_propagate(errp, local_err); ret = -EINVAL; goto out; } s->config_file = g_strdup(qemu_opt_get(opts, "config")); ret = read_config(s, s->config_file, options, errp); if (ret) { goto out; } s->state = 1; bs->file = bdrv_open_child(qemu_opt_get(opts, "x-image"), options, "image", bs, &child_file, "False" != "False", &local_err); if (local_err) { ret = -EINVAL; error_propagate(errp, local_err); goto out; } bs->supported_write_flags = BDRV_REQ_FUA & bs->file->bs->supported_write_flags; bs->supported_zero_flags = (BDRV_REQ_FUA | BDRV_REQ_MAY_UNMAP) & bs->file->bs->supported_zero_flags; ret = -EINVAL; s->align = qemu_opt_get_size(opts, "align", 0); if (s->align && (s->align >= INT_MAX || !is_power_of_2(s->align))) { error_setg(errp, "Cannot meet constraints with align %" PRIu64, s->align); goto out; } ret = 0; out: if (ret < 0) { g_free(s->config_file); } qemu_opts_del(opts); return ret; }
--------------------------------------------- Result 432 ---------------------------------------------
[[0 (27%)]] --> [[0 (54%)]] --> Socre: 0.5384207367897034

[[[[Adv]]]]: static void test_qemu_strtoull_full_negative(void) { const char *[[str]] = " \t -321"; uint64_t res = 999; int err; err = qemu_strtoull([[str]], NULL, 0, &res); g_assert_cmpint(err, ==, 0); g_assert_cmpint(res, ==, 18446744073709551295LLU); }

[[[[Adv]]]]: static void test_qemu_strtoull_full_negative(void) { const char *[[cred]] = " \t -321"; uint64_t res = 999; int err; err = qemu_strtoull([[cred]], NULL, 0, &res); g_assert_cmpint(err, ==, 0); g_assert_cmpint(res, ==, 18446744073709551295LLU); }
--------------------------------------------- Result 433 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 251 / 22 / 160 / 433:  16%|        | 433/2690 [4:01:02<20:56:27, 33.40s/it][Succeeded / Failed / Skipped / Total] 251 / 22 / 160 / 433:  16%|        | 434/2690 [4:01:26<20:55:02, 33.38s/it][Succeeded / Failed / Skipped / Total] 252 / 22 / 160 / 434:  16%|        | 434/2690 [4:01:26<20:55:02, 33.38s/it][Succeeded / Failed / Skipped / Total] 252 / 22 / 160 / 434:  16%|        | 435/2690 [4:01:51<20:53:46, 33.36s/it][Succeeded / Failed / Skipped / Total] 253 / 22 / 160 / 435:  16%|        | 435/2690 [4:01:51<20:53:46, 33.36s/it][Succeeded / Failed / Skipped / Total] 253 / 22 / 160 / 435:  16%|        | 436/2690 [4:02:21<20:52:55, 33.35s/it][Succeeded / Failed / Skipped / Total] 254 / 22 / 160 / 436:  16%|        | 436/2690 [4:02:21<20:52:55, 33.35s/it][Succeeded / Failed / Skipped / Total] 254 / 22 / 160 / 436:  16%|        | 437/2690 [4:02:30<20:50:18, 33.30s/it][Succeeded / Failed / Skipped / Total] 255 / 22 / 160 / 437:  16%|        | 437/2690 [4:02:30<20:50:18, 33.30s/it][Succeeded / Failed / Skipped / Total] 255 / 22 / 160 / 437:  16%|        | 438/2690 [4:14:39<21:49:19, 34.88s/it][[0 (72%)]] --> [[0 (49%)]] --> Socre: 0.5065767467021942

[[[[Adv]]]]: static int parse_adaptation_sets(AVFormatContext *[[s]]) { WebMDashMuxContext *w = [[s]]->priv_data; char *p = w->adaptation_sets; char *[[q]]; enum { new_set, parsed_id, parsing_streams } state; if (!w->adaptation_sets) { av_log([[s]], AV_LOG_ERROR, "The 'adaptation_sets' option must be set.\n"); return AVERROR(EINVAL); } state = new_set; while (p < w->adaptation_sets + strlen(w->adaptation_sets)) { if (*p == ' ') continue; else if (state == new_set && !strncmp(p, "id=", 3)) { void *[[mem]] = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1)); if ([[mem]] == NULL) return AVERROR(ENOMEM); w->as = [[mem]]; ++w->nb_as; w->as[w->nb_as - 1].nb_streams = 0; w->as[w->nb_as - 1].streams = NULL; p += 3; [[q]] = w->as[w->nb_as - 1].id; while (*p != ',') *[[q]]++ = *p++; *[[q]] = 0; p++; state = parsed_id; } else if (state == parsed_id && !strncmp(p, "streams=", 8)) { p += 8; state = parsing_streams; } else if (state == parsing_streams) { struct AdaptationSet *as = &w->as[w->nb_as - 1]; [[q]] = p; while (*[[q]] != '\0' && *[[q]] != ',' && *[[q]] != ' ') [[q]]++; as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams); if (as->streams == NULL) return AVERROR(ENOMEM); as->streams[as->nb_streams - 1] = to_integer(p, [[q]] - p + 1); if (as->streams[as->nb_streams - 1] < 0) return -1; if (*[[q]] == '\0') break; if (*[[q]] == ' ') state = new_set; p = ++[[q]]; } else { return -1; } } return 0; }

[[[[Adv]]]]: static int parse_adaptation_sets(AVFormatContext *[[among]]) { WebMDashMuxContext *w = [[among]]->priv_data; char *p = w->adaptation_sets; char *[[pressing]]; enum { new_set, parsed_id, parsing_streams } state; if (!w->adaptation_sets) { av_log([[among]], AV_LOG_ERROR, "The 'adaptation_sets' option must be set.\n"); return AVERROR(EINVAL); } state = new_set; while (p < w->adaptation_sets + strlen(w->adaptation_sets)) { if (*p == ' ') continue; else if (state == new_set && !strncmp(p, "id=", 3)) { void *[[anyways]] = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1)); if ([[anyways]] == NULL) return AVERROR(ENOMEM); w->as = [[anyways]]; ++w->nb_as; w->as[w->nb_as - 1].nb_streams = 0; w->as[w->nb_as - 1].streams = NULL; p += 3; [[pressing]] = w->as[w->nb_as - 1].id; while (*p != ',') *[[pressing]]++ = *p++; *[[pressing]] = 0; p++; state = parsed_id; } else if (state == parsed_id && !strncmp(p, "streams=", 8)) { p += 8; state = parsing_streams; } else if (state == parsing_streams) { struct AdaptationSet *as = &w->as[w->nb_as - 1]; [[pressing]] = p; while (*[[pressing]] != '\0' && *[[pressing]] != ',' && *[[pressing]] != ' ') [[pressing]]++; as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams); if (as->streams == NULL) return AVERROR(ENOMEM); as->streams[as->nb_streams - 1] = to_integer(p, [[pressing]] - p + 1); if (as->streams[as->nb_streams - 1] < 0) return -1; if (*[[pressing]] == '\0') break; if (*[[pressing]] == ' ') state = new_set; p = ++[[pressing]]; } else { return -1; } } return 0; }
--------------------------------------------- Result 434 ---------------------------------------------
[[0 (1%)]] --> [[0 (59%)]] --> Socre: 0.585099458694458

[[[[Adv]]]]: float64 HELPER(ucf64_absd)(float64 [[a]]) { return float64_abs([[a]]); }

[[[[Adv]]]]: float64 HELPER(ucf64_absd)(float64 [[]]) { return float64_abs([[]]); }
--------------------------------------------- Result 435 ---------------------------------------------
[[0 (2%)]] --> [[0 (52%)]] --> Socre: 0.520383894443512

[[[[Adv]]]]: static CharDriverState *qemu_chr_open_null(const char *id, ChardevBackend *backend, ChardevReturn *[[ret]], Error **[[errp]]) { CharDriverState *chr; ChardevCommon *common = backend->u.null; chr = qemu_chr_alloc(common, [[errp]]); if (!chr) { return NULL; } chr->chr_write = null_chr_write; chr->explicit_be_open = "True" == "True"; return chr; }

[[[[Adv]]]]: static CharDriverState *qemu_chr_open_null(const char *id, ChardevBackend *backend, ChardevReturn *[[retiree]], Error **[[o]]) { CharDriverState *chr; ChardevCommon *common = backend->u.null; chr = qemu_chr_alloc(common, [[o]]); if (!chr) { return NULL; } chr->chr_write = null_chr_write; chr->explicit_be_open = "True" == "True"; return chr; }
--------------------------------------------- Result 436 ---------------------------------------------
[[0 (30%)]] --> [[0 (55%)]] --> Socre: 0.5480183959007263

[[[[Adv]]]]: static int packet_enqueue(CompareState *s, int mode) { ConnectionKey [[key]]; Packet *pkt = NULL; Connection *conn; if (mode == PRIMARY_IN) { pkt = packet_new(s->pri_rs.buf, s->pri_rs.packet_len, s->pri_rs.vnet_hdr_len); } else { pkt = packet_new(s->sec_rs.buf, s->sec_rs.packet_len, s->sec_rs.vnet_hdr_len); } if (parse_packet_early(pkt)) { packet_destroy(pkt, NULL); pkt = NULL; return -1; } fill_connection_key(pkt, &[[key]]); conn = connection_get(s->connection_track_table, &[[key]], &s->conn_list); if (!conn->processing) { g_queue_push_tail(&s->conn_list, conn); conn->processing = "True" == "True"; } if (mode == PRIMARY_IN) { if (!colo_insert_packet(&conn->primary_list, pkt)) { error_report("colo compare primary queue size too big," "drop packet"); } } else { if (!colo_insert_packet(&conn->secondary_list, pkt)) { error_report("colo compare secondary queue size too big," "drop packet"); } } return 0; }

[[[[Adv]]]]: static int packet_enqueue(CompareState *s, int mode) { ConnectionKey [[elemental]]; Packet *pkt = NULL; Connection *conn; if (mode == PRIMARY_IN) { pkt = packet_new(s->pri_rs.buf, s->pri_rs.packet_len, s->pri_rs.vnet_hdr_len); } else { pkt = packet_new(s->sec_rs.buf, s->sec_rs.packet_len, s->sec_rs.vnet_hdr_len); } if (parse_packet_early(pkt)) { packet_destroy(pkt, NULL); pkt = NULL; return -1; } fill_connection_key(pkt, &[[elemental]]); conn = connection_get(s->connection_track_table, &[[elemental]], &s->conn_list); if (!conn->processing) { g_queue_push_tail(&s->conn_list, conn); conn->processing = "True" == "True"; } if (mode == PRIMARY_IN) { if (!colo_insert_packet(&conn->primary_list, pkt)) { error_report("colo compare primary queue size too big," "drop packet"); } } else { if (!colo_insert_packet(&conn->secondary_list, pkt)) { error_report("colo compare secondary queue size too big," "drop packet"); } } return 0; }
--------------------------------------------- Result 437 ---------------------------------------------
[[0 (22%)]] --> [[0 (78%)]] --> Socre: 0.7783234715461731

[[[[Adv]]]]: enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag) { int i; for(i=0; i<4 && tags[i]; i++){ enum CodecID [[id]]= codec_get_id(tags[i], tag); if([[id]]!=CODEC_ID_NONE) return [[id]]; } return CODEC_ID_NONE; }

[[[[Adv]]]]: enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag) { int i; for(i=0; i<4 && tags[i]; i++){ enum CodecID [[manipulators]]= codec_get_id(tags[i], tag); if([[manipulators]]!=CODEC_ID_NONE) return [[manipulators]]; } return CODEC_ID_NONE; }
--------------------------------------------- Result 438 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 256 / 22 / 160 / 438:  16%|        | 438/2690 [4:14:39<21:49:19, 34.88s/it][Succeeded / Failed / Skipped / Total] 256 / 22 / 160 / 438:  16%|        | 439/2690 [4:14:39<21:45:48, 34.81s/it][Succeeded / Failed / Skipped / Total] 256 / 22 / 161 / 439:  16%|        | 439/2690 [4:14:39<21:45:48, 34.81s/it][Succeeded / Failed / Skipped / Total] 256 / 22 / 161 / 439:  16%|        | 440/2690 [4:14:47<21:42:55, 34.74s/it][Succeeded / Failed / Skipped / Total] 257 / 22 / 161 / 440:  16%|        | 440/2690 [4:14:47<21:42:55, 34.74s/it][Succeeded / Failed / Skipped / Total] 257 / 22 / 161 / 440:  16%|        | 441/2690 [4:14:48<21:39:25, 34.67s/it][[0 (98%)]] --> [[0 (48%)]] --> Socre: 0.5229424834251404

[[[[Adv]]]]: int av_packet_split_side_data(AVPacket *[[pkt]]){ if (![[pkt]]->side_data_elems && [[pkt]]->size >12 && AV_RB64([[pkt]]->data + [[pkt]]->size - 8) == FF_MERGE_MARKER){ int [[i]]; unsigned int size; uint8_t *p; p = [[pkt]]->data + [[pkt]]->size - 8 - 5; for ([[i]]=1; ; [[i]]++){ size = AV_RB32(p); if (size>INT_MAX || p - [[pkt]]->data < size) return 0; if (p[4]&128) break; p-= size+5; } [[pkt]]->side_data = av_malloc_array([[i]], sizeof(*[[pkt]]->side_data)); if (![[pkt]]->side_data) return AVERROR(ENOMEM); p= [[pkt]]->data + [[pkt]]->size - 8 - 5; for ([[i]]=0; ; [[i]]++){ size= AV_RB32(p); av_assert0(size<=INT_MAX && p - [[pkt]]->data >= size); [[pkt]]->side_data[[[i]]].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE); [[pkt]]->side_data[[[i]]].size = size; [[pkt]]->side_data[[[i]]].type = p[4]&127; if (![[pkt]]->side_data[[[i]]].data) return AVERROR(ENOMEM); memcpy([[pkt]]->side_data[[[i]]].data, p-size, size); [[pkt]]->size -= size + 5; if(p[4]&128) break; p-= size+5; } [[pkt]]->size -= 8; [[pkt]]->side_data_elems = [[i]]+1; return 1; } return 0; }

[[[[Adv]]]]: int av_packet_split_side_data(AVPacket *[[darts]]){ if (![[darts]]->side_data_elems && [[darts]]->size >12 && AV_RB64([[darts]]->data + [[darts]]->size - 8) == FF_MERGE_MARKER){ int [[suis]]; unsigned int size; uint8_t *p; p = [[darts]]->data + [[darts]]->size - 8 - 5; for ([[suis]]=1; ; [[suis]]++){ size = AV_RB32(p); if (size>INT_MAX || p - [[darts]]->data < size) return 0; if (p[4]&128) break; p-= size+5; } [[darts]]->side_data = av_malloc_array([[suis]], sizeof(*[[darts]]->side_data)); if (![[darts]]->side_data) return AVERROR(ENOMEM); p= [[darts]]->data + [[darts]]->size - 8 - 5; for ([[suis]]=0; ; [[suis]]++){ size= AV_RB32(p); av_assert0(size<=INT_MAX && p - [[darts]]->data >= size); [[darts]]->side_data[[[suis]]].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE); [[darts]]->side_data[[[suis]]].size = size; [[darts]]->side_data[[[suis]]].type = p[4]&127; if (![[darts]]->side_data[[[suis]]].data) return AVERROR(ENOMEM); memcpy([[darts]]->side_data[[[suis]]].data, p-size, size); [[darts]]->size -= size + 5; if(p[4]&128) break; p-= size+5; } [[darts]]->size -= 8; [[darts]]->side_data_elems = [[suis]]+1; return 1; } return 0; }
--------------------------------------------- Result 439 ---------------------------------------------
[[0 (60%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int kvm_put_xsave(CPUState *env) { #ifdef KVM_CAP_XSAVE int i, r; struct kvm_xsave* xsave; uint16_t cwd, swd, twd, fop; if (!kvm_has_xsave()) return kvm_put_fpu(env); xsave = qemu_memalign(4096, sizeof(struct kvm_xsave)); memset(xsave, 0, sizeof(struct kvm_xsave)); cwd = swd = twd = fop = 0; swd = env->fpus & ~(7 << 11); swd |= (env->fpstt & 7) << 11; cwd = env->fpuc; for (i = 0; i < 8; ++i) twd |= (!env->fptags[i]) << i; xsave->region[0] = (uint32_t)(swd << 16) + cwd; xsave->region[1] = (uint32_t)(fop << 16) + twd; memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs, sizeof env->fpregs); memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs, sizeof env->xmm_regs); xsave->region[XSAVE_MXCSR] = env->mxcsr; *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv; memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs, sizeof env->ymmh_regs); r = kvm_vcpu_ioctl(env, KVM_SET_XSAVE, xsave); qemu_free(xsave); return r; #else return kvm_put_fpu(env); #endif }
--------------------------------------------- Result 440 ---------------------------------------------
[[0 (62%)]] --> [[0 (46%)]] --> Socre: 0.5430649518966675

[[[[Adv]]]]: static inline void blockCopy(uint8_t dst[], int dstStride, uint8_t [[src]][], int srcStride, int numLines, int levelFix) { int i; if(levelFix) { #ifdef HAVE_MMX asm volatile( "movl %4, %%eax \n\t" "movl %%eax, temp0\n\t" "pushl %0 \n\t" "pushl %1 \n\t" "leal (%2,%2), %%eax \n\t" "leal (%3,%3), %%ebx \n\t" "movq packedYOffset, %%mm2 \n\t" "movq packedYScale, %%mm3 \n\t" "pxor %%mm4, %%mm4 \n\t" #define SCALED_CPY \ "movq (%0), %%mm0 \n\t"\ "movq (%0,%2), %%mm1 \n\t"\ "psubusb %%mm2, %%mm0 \n\t"\ "psubusb %%mm2, %%mm1 \n\t"\ "movq %%mm0, %%mm5 \n\t"\ "punpcklbw %%mm4, %%mm0 \n\t"\ "punpckhbw %%mm4, %%mm5 \n\t"\ "psllw $7, %%mm0 \n\t"\ "psllw $7, %%mm5 \n\t"\ "pmulhw %%mm3, %%mm0 \n\t"\ "pmulhw %%mm3, %%mm5 \n\t"\ "packuswb %%mm5, %%mm0 \n\t"\ "movq %%mm0, (%1) \n\t"\ "movq %%mm1, %%mm5 \n\t"\ "punpcklbw %%mm4, %%mm1 \n\t"\ "punpckhbw %%mm4, %%mm5 \n\t"\ "psllw $7, %%mm1 \n\t"\ "psllw $7, %%mm5 \n\t"\ "pmulhw %%mm3, %%mm1 \n\t"\ "pmulhw %%mm3, %%mm5 \n\t"\ "packuswb %%mm5, %%mm1 \n\t"\ "movq %%mm1, (%1, %3) \n\t"\ "1: \n\t" SCALED_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" SCALED_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" "decl temp0 \n\t" "jnz 1b \n\t" "popl %1 \n\t" "popl %0 \n\t" : : "r" ([[src]]), "r" (dst), "r" (srcStride), "r" (dstStride), "m" (numLines>>2) : "%eax", "%ebx" ); #else for(i=0; i<numLines; i++) memcpy( &(dst[dstStride*i]), &([[src]][srcStride*i]), BLOCK_SIZE); #endif } else { #ifdef HAVE_MMX asm volatile( "movl %4, %%eax \n\t" "movl %%eax, temp0\n\t" "pushl %0 \n\t" "pushl %1 \n\t" "leal (%2,%2), %%eax \n\t" "leal (%3,%3), %%ebx \n\t" "movq packedYOffset, %%mm2 \n\t" "movq packedYScale, %%mm3 \n\t" #define SIMPLE_CPY \ "movq (%0), %%mm0 \n\t"\ "movq (%0,%2), %%mm1 \n\t"\ "movq %%mm0, (%1) \n\t"\ "movq %%mm1, (%1, %3) \n\t"\ "1: \n\t" SIMPLE_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" SIMPLE_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" "decl temp0 \n\t" "jnz 1b \n\t" "popl %1 \n\t" "popl %0 \n\t" : : "r" ([[src]]), "r" (dst), "r" (srcStride), "r" (dstStride), "m" (numLines>>2) : "%eax", "%ebx" ); #else for(i=0; i<numLines; i++) memcpy( &(dst[dstStride*i]), &([[src]][srcStride*i]), BLOCK_SIZE); #endif } }

[[[[Adv]]]]: static inline void blockCopy(uint8_t dst[], int dstStride, uint8_t [[mtro]][], int srcStride, int numLines, int levelFix) { int i; if(levelFix) { #ifdef HAVE_MMX asm volatile( "movl %4, %%eax \n\t" "movl %%eax, temp0\n\t" "pushl %0 \n\t" "pushl %1 \n\t" "leal (%2,%2), %%eax \n\t" "leal (%3,%3), %%ebx \n\t" "movq packedYOffset, %%mm2 \n\t" "movq packedYScale, %%mm3 \n\t" "pxor %%mm4, %%mm4 \n\t" #define SCALED_CPY \ "movq (%0), %%mm0 \n\t"\ "movq (%0,%2), %%mm1 \n\t"\ "psubusb %%mm2, %%mm0 \n\t"\ "psubusb %%mm2, %%mm1 \n\t"\ "movq %%mm0, %%mm5 \n\t"\ "punpcklbw %%mm4, %%mm0 \n\t"\ "punpckhbw %%mm4, %%mm5 \n\t"\ "psllw $7, %%mm0 \n\t"\ "psllw $7, %%mm5 \n\t"\ "pmulhw %%mm3, %%mm0 \n\t"\ "pmulhw %%mm3, %%mm5 \n\t"\ "packuswb %%mm5, %%mm0 \n\t"\ "movq %%mm0, (%1) \n\t"\ "movq %%mm1, %%mm5 \n\t"\ "punpcklbw %%mm4, %%mm1 \n\t"\ "punpckhbw %%mm4, %%mm5 \n\t"\ "psllw $7, %%mm1 \n\t"\ "psllw $7, %%mm5 \n\t"\ "pmulhw %%mm3, %%mm1 \n\t"\ "pmulhw %%mm3, %%mm5 \n\t"\ "packuswb %%mm5, %%mm1 \n\t"\ "movq %%mm1, (%1, %3) \n\t"\ "1: \n\t" SCALED_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" SCALED_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" "decl temp0 \n\t" "jnz 1b \n\t" "popl %1 \n\t" "popl %0 \n\t" : : "r" ([[mtro]]), "r" (dst), "r" (srcStride), "r" (dstStride), "m" (numLines>>2) : "%eax", "%ebx" ); #else for(i=0; i<numLines; i++) memcpy( &(dst[dstStride*i]), &([[mtro]][srcStride*i]), BLOCK_SIZE); #endif } else { #ifdef HAVE_MMX asm volatile( "movl %4, %%eax \n\t" "movl %%eax, temp0\n\t" "pushl %0 \n\t" "pushl %1 \n\t" "leal (%2,%2), %%eax \n\t" "leal (%3,%3), %%ebx \n\t" "movq packedYOffset, %%mm2 \n\t" "movq packedYScale, %%mm3 \n\t" #define SIMPLE_CPY \ "movq (%0), %%mm0 \n\t"\ "movq (%0,%2), %%mm1 \n\t"\ "movq %%mm0, (%1) \n\t"\ "movq %%mm1, (%1, %3) \n\t"\ "1: \n\t" SIMPLE_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" SIMPLE_CPY "addl %%eax, %0 \n\t" "addl %%ebx, %1 \n\t" "decl temp0 \n\t" "jnz 1b \n\t" "popl %1 \n\t" "popl %0 \n\t" : : "r" ([[mtro]]), "r" (dst), "r" (srcStride), "r" (dstStride), "m" (numLines>>2) : "%eax", "%ebx" ); #else for(i=0; i<numLines; i++) memcpy( &(dst[dstStride*i]), &([[mtro]][srcStride*i]), BLOCK_SIZE); #endif } }
--------------------------------------------- Result 441 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 257 / 22 / 162 / 441:  16%|        | 441/2690 [4:14:48<21:39:25, 34.67s/it][Succeeded / Failed / Skipped / Total] 257 / 22 / 162 / 441:  16%|        | 442/2690 [4:14:48<21:35:57, 34.59s/it][Succeeded / Failed / Skipped / Total] 257 / 22 / 163 / 442:  16%|        | 442/2690 [4:14:48<21:35:57, 34.59s/it][Succeeded / Failed / Skipped / Total] 257 / 22 / 163 / 442:  16%|        | 443/2690 [4:14:52<21:32:47, 34.52s/it][Succeeded / Failed / Skipped / Total] 258 / 22 / 163 / 443:  16%|        | 443/2690 [4:14:52<21:32:47, 34.52s/it][Succeeded / Failed / Skipped / Total] 258 / 22 / 163 / 443:  17%|        | 444/2690 [4:14:59<21:29:52, 34.46s/it][[0 (1%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: build_tpm2(GArray *table_data, BIOSLinker *linker) { Acpi20TPM2 *tpm2_ptr; tpm2_ptr = acpi_data_push(table_data, sizeof *tpm2_ptr); tpm2_ptr->platform_class = cpu_to_le16(TPM2_ACPI_CLASS_CLIENT); tpm2_ptr->control_area_address = cpu_to_le64(0); tpm2_ptr->start_method = cpu_to_le32(TPM2_START_METHOD_MMIO); build_header(linker, table_data, (void *)tpm2_ptr, "TPM2", sizeof(*tpm2_ptr), 4, NULL, NULL); }
--------------------------------------------- Result 442 ---------------------------------------------
[[0 (33%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush) { do { int nb_output = 0; int min_poc = INT_MAX; int i, min_idx, ret; if (s->sh.no_output_of_prior_pics_flag == 1) { for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) { HEVCFrame *frame = &s->DPB[i]; if (!(frame->flags & HEVC_FRAME_FLAG_BUMPING) && frame->poc != s->poc && frame->sequence == s->seq_output) { ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT); } } } for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) { HEVCFrame *frame = &s->DPB[i]; if ((frame->flags & HEVC_FRAME_FLAG_OUTPUT) && frame->sequence == s->seq_output) { nb_output++; if (frame->poc < min_poc) { min_poc = frame->poc; min_idx = i; } } } if (!flush && s->seq_output == s->seq_decode && s->sps && nb_output <= s->sps->temporal_layer[s->sps->max_sub_layers - 1].num_reorder_pics) return 0; if (nb_output) { HEVCFrame *frame = &s->DPB[min_idx]; AVFrame *dst = out; AVFrame *src = frame->frame; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format); int pixel_shift = !!(desc->comp[0].depth_minus1 > 7); ret = av_frame_ref(out, src); if (frame->flags & HEVC_FRAME_FLAG_BUMPING) ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT | HEVC_FRAME_FLAG_BUMPING); else ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT); if (ret < 0) return ret; for (i = 0; i < 3; i++) { int hshift = (i > 0) ? desc->log2_chroma_w : 0; int vshift = (i > 0) ? desc->log2_chroma_h : 0; int off = ((frame->window.left_offset >> hshift) << pixel_shift) + (frame->window.top_offset >> vshift) * dst->linesize[i]; dst->data[i] += off; } av_log(s->avctx, AV_LOG_DEBUG, "Output frame with POC %d.\n", frame->poc); return 1; } if (s->seq_output != s->seq_decode) s->seq_output = (s->seq_output + 1) & 0xff; else break; } while (1); return 0; }
--------------------------------------------- Result 443 ---------------------------------------------
[[0 (49%)]] --> [[0 (50%)]] --> Socre: 0.5027388334274292

[[[[Adv]]]]: static int mpegaudio_parse(AVCodecParserContext *s1, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size) { MpegAudioParseContext *s = s1->priv_data; int [[len]], ret; uint32_t header; const uint8_t *buf_ptr; *poutbuf = NULL; *poutbuf_size = 0; buf_ptr = buf; while (buf_size > 0) { [[len]] = s->inbuf_ptr - s->inbuf; if (s->frame_size == 0) { if (s->free_format_next_header != 0) { s->inbuf[0] = s->free_format_next_header >> 24; s->inbuf[1] = s->free_format_next_header >> 16; s->inbuf[2] = s->free_format_next_header >> 8; s->inbuf[3] = s->free_format_next_header; s->inbuf_ptr = s->inbuf + 4; s->free_format_next_header = 0; goto got_header; } [[len]] = MPA_HEADER_SIZE - [[len]]; if ([[len]] > buf_size) [[len]] = buf_size; if ([[len]] > 0) { memcpy(s->inbuf_ptr, buf_ptr, [[len]]); buf_ptr += [[len]]; buf_size -= [[len]]; s->inbuf_ptr += [[len]]; } if ((s->inbuf_ptr - s->inbuf) >= MPA_HEADER_SIZE) { got_header: header = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) | (s->inbuf[2] << 8) | s->inbuf[3]; ret = mpa_decode_header(avctx, header); if (ret < 0) { memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1); s->inbuf_ptr--; dprintf("skip %x\n", header); s->free_format_frame_size = 0; } else { s->frame_size = ret; #if 0 if (decode_header(s, header) == 1) { s->frame_size = -1; } #endif } } } else #if 0 if (s->frame_size == -1) { [[len]] = MPA_MAX_CODED_FRAME_SIZE - [[len]]; if ([[len]] > buf_size) [[len]] = buf_size; if ([[len]] == 0) { s->frame_size = 0; memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1); s->inbuf_ptr--; } else { uint8_t *p, *pend; uint32_t header1; int padding; memcpy(s->inbuf_ptr, buf_ptr, [[len]]); p = s->inbuf_ptr - 3; pend = s->inbuf_ptr + [[len]] - 4; while (p <= pend) { header = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]; header1 = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) | (s->inbuf[2] << 8) | s->inbuf[3]; if ((header & SAME_HEADER_MASK) == (header1 & SAME_HEADER_MASK)) { [[len]] = (p + 4) - s->inbuf_ptr; buf_ptr += [[len]]; buf_size -= [[len]]; s->inbuf_ptr = p; s->free_format_next_header = header; s->free_format_frame_size = s->inbuf_ptr - s->inbuf; padding = (header1 >> 9) & 1; if (s->layer == 1) s->free_format_frame_size -= padding * 4; else s->free_format_frame_size -= padding; dprintf("free frame size=%d padding=%d\n", s->free_format_frame_size, padding); decode_header(s, header1); goto next_data; } p++; } buf_ptr += [[len]]; s->inbuf_ptr += [[len]]; buf_size -= [[len]]; } } else #endif if ([[len]] < s->frame_size) { if (s->frame_size > MPA_MAX_CODED_FRAME_SIZE) s->frame_size = MPA_MAX_CODED_FRAME_SIZE; [[len]] = s->frame_size - [[len]]; if ([[len]] > buf_size) [[len]] = buf_size; memcpy(s->inbuf_ptr, buf_ptr, [[len]]); buf_ptr += [[len]]; s->inbuf_ptr += [[len]]; buf_size -= [[len]]; } if (s->frame_size > 0 && (s->inbuf_ptr - s->inbuf) >= s->frame_size) { *poutbuf = s->inbuf; *poutbuf_size = s->inbuf_ptr - s->inbuf; s->inbuf_ptr = s->inbuf; s->frame_size = 0; break; } } return buf_ptr - buf; }

[[[[Adv]]]]: static int mpegaudio_parse(AVCodecParserContext *s1, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size) { MpegAudioParseContext *s = s1->priv_data; int [[single]], ret; uint32_t header; const uint8_t *buf_ptr; *poutbuf = NULL; *poutbuf_size = 0; buf_ptr = buf; while (buf_size > 0) { [[single]] = s->inbuf_ptr - s->inbuf; if (s->frame_size == 0) { if (s->free_format_next_header != 0) { s->inbuf[0] = s->free_format_next_header >> 24; s->inbuf[1] = s->free_format_next_header >> 16; s->inbuf[2] = s->free_format_next_header >> 8; s->inbuf[3] = s->free_format_next_header; s->inbuf_ptr = s->inbuf + 4; s->free_format_next_header = 0; goto got_header; } [[single]] = MPA_HEADER_SIZE - [[single]]; if ([[single]] > buf_size) [[single]] = buf_size; if ([[single]] > 0) { memcpy(s->inbuf_ptr, buf_ptr, [[single]]); buf_ptr += [[single]]; buf_size -= [[single]]; s->inbuf_ptr += [[single]]; } if ((s->inbuf_ptr - s->inbuf) >= MPA_HEADER_SIZE) { got_header: header = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) | (s->inbuf[2] << 8) | s->inbuf[3]; ret = mpa_decode_header(avctx, header); if (ret < 0) { memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1); s->inbuf_ptr--; dprintf("skip %x\n", header); s->free_format_frame_size = 0; } else { s->frame_size = ret; #if 0 if (decode_header(s, header) == 1) { s->frame_size = -1; } #endif } } } else #if 0 if (s->frame_size == -1) { [[single]] = MPA_MAX_CODED_FRAME_SIZE - [[single]]; if ([[single]] > buf_size) [[single]] = buf_size; if ([[single]] == 0) { s->frame_size = 0; memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1); s->inbuf_ptr--; } else { uint8_t *p, *pend; uint32_t header1; int padding; memcpy(s->inbuf_ptr, buf_ptr, [[single]]); p = s->inbuf_ptr - 3; pend = s->inbuf_ptr + [[single]] - 4; while (p <= pend) { header = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]; header1 = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) | (s->inbuf[2] << 8) | s->inbuf[3]; if ((header & SAME_HEADER_MASK) == (header1 & SAME_HEADER_MASK)) { [[single]] = (p + 4) - s->inbuf_ptr; buf_ptr += [[single]]; buf_size -= [[single]]; s->inbuf_ptr = p; s->free_format_next_header = header; s->free_format_frame_size = s->inbuf_ptr - s->inbuf; padding = (header1 >> 9) & 1; if (s->layer == 1) s->free_format_frame_size -= padding * 4; else s->free_format_frame_size -= padding; dprintf("free frame size=%d padding=%d\n", s->free_format_frame_size, padding); decode_header(s, header1); goto next_data; } p++; } buf_ptr += [[single]]; s->inbuf_ptr += [[single]]; buf_size -= [[single]]; } } else #endif if ([[single]] < s->frame_size) { if (s->frame_size > MPA_MAX_CODED_FRAME_SIZE) s->frame_size = MPA_MAX_CODED_FRAME_SIZE; [[single]] = s->frame_size - [[single]]; if ([[single]] > buf_size) [[single]] = buf_size; memcpy(s->inbuf_ptr, buf_ptr, [[single]]); buf_ptr += [[single]]; s->inbuf_ptr += [[single]]; buf_size -= [[single]]; } if (s->frame_size > 0 && (s->inbuf_ptr - s->inbuf) >= s->frame_size) { *poutbuf = s->inbuf; *poutbuf_size = s->inbuf_ptr - s->inbuf; s->inbuf_ptr = s->inbuf; s->frame_size = 0; break; } } return buf_ptr - buf; }
--------------------------------------------- Result 444 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 259 / 22 / 163 / 444:  17%|        | 444/2690 [4:14:59<21:29:52, 34.46s/it][Succeeded / Failed / Skipped / Total] 259 / 22 / 163 / 444:  17%|        | 445/2690 [4:16:21<21:33:19, 34.57s/it][Succeeded / Failed / Skipped / Total] 260 / 22 / 163 / 445:  17%|        | 445/2690 [4:16:21<21:33:19, 34.57s/it][Succeeded / Failed / Skipped / Total] 260 / 22 / 163 / 445:  17%|        | 446/2690 [4:16:34<21:30:53, 34.52s/it][Succeeded / Failed / Skipped / Total] 261 / 22 / 163 / 446:  17%|        | 446/2690 [4:16:34<21:30:53, 34.52s/it][Succeeded / Failed / Skipped / Total] 261 / 22 / 163 / 446:  17%|        | 447/2690 [4:16:57<21:29:23, 34.49s/it][Succeeded / Failed / Skipped / Total] 262 / 22 / 163 / 447:  17%|        | 447/2690 [4:16:57<21:29:23, 34.49s/it][Succeeded / Failed / Skipped / Total] 262 / 22 / 163 / 447:  17%|        | 448/2690 [4:16:57<21:25:58, 34.42s/it][[0 (42%)]] --> [[0 (57%)]] --> Socre: 0.5732803344726562

[[[[Adv]]]]: JNIEnv *ff_jni_attach_env(int *attached, void *[[log_ctx]]) { int ret = 0; JNIEnv *env = NULL; *attached = 0; pthread_mutex_lock(&lock); if (java_vm == NULL && (java_vm = av_jni_get_java_vm([[log_ctx]])) == NULL) { av_log([[log_ctx]], AV_LOG_INFO, "Retrieving current Java virtual machine using Android JniInvocation wrapper\n"); if (check_jni_invocation([[log_ctx]]) == 0) { if ((java_vm = get_java_vm(NULL, [[log_ctx]])) != NULL || (java_vm = get_java_vm("libdvm.so", [[log_ctx]])) != NULL || (java_vm = get_java_vm("libart.so", [[log_ctx]])) != NULL) { av_log([[log_ctx]], AV_LOG_INFO, "Found Java virtual machine using Android JniInvocation wrapper\n"); } } } pthread_mutex_unlock(&lock); if (!java_vm) { av_log([[log_ctx]], AV_LOG_ERROR, "Could not retrieve a Java virtual machine\n"); return NULL; } ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6); switch(ret) { case JNI_EDETACHED: if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) { av_log([[log_ctx]], AV_LOG_ERROR, "Failed to attach the JNI environment to the current thread\n"); env = NULL; } else { *attached = 1; } break; case JNI_OK: break; case JNI_EVERSION: av_log([[log_ctx]], AV_LOG_ERROR, "The specified JNI version is not supported\n"); break; default: av_log([[log_ctx]], AV_LOG_ERROR, "Failed to get the JNI environment attached to this thread"); break; } return env; }

[[[[Adv]]]]: JNIEnv *ff_jni_attach_env(int *attached, void *[[conscientious]]) { int ret = 0; JNIEnv *env = NULL; *attached = 0; pthread_mutex_lock(&lock); if (java_vm == NULL && (java_vm = av_jni_get_java_vm([[conscientious]])) == NULL) { av_log([[conscientious]], AV_LOG_INFO, "Retrieving current Java virtual machine using Android JniInvocation wrapper\n"); if (check_jni_invocation([[conscientious]]) == 0) { if ((java_vm = get_java_vm(NULL, [[conscientious]])) != NULL || (java_vm = get_java_vm("libdvm.so", [[conscientious]])) != NULL || (java_vm = get_java_vm("libart.so", [[conscientious]])) != NULL) { av_log([[conscientious]], AV_LOG_INFO, "Found Java virtual machine using Android JniInvocation wrapper\n"); } } } pthread_mutex_unlock(&lock); if (!java_vm) { av_log([[conscientious]], AV_LOG_ERROR, "Could not retrieve a Java virtual machine\n"); return NULL; } ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6); switch(ret) { case JNI_EDETACHED: if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) { av_log([[conscientious]], AV_LOG_ERROR, "Failed to attach the JNI environment to the current thread\n"); env = NULL; } else { *attached = 1; } break; case JNI_OK: break; case JNI_EVERSION: av_log([[conscientious]], AV_LOG_ERROR, "The specified JNI version is not supported\n"); break; default: av_log([[conscientious]], AV_LOG_ERROR, "Failed to get the JNI environment attached to this thread"); break; } return env; }
--------------------------------------------- Result 445 ---------------------------------------------
[[0 (53%)]] --> [[0 (43%)]] --> Socre: 0.5730485916137695

[[[[Adv]]]]: static int perform_cow(BlockDriverState *[[bs]], QCowL2Meta *m) { BDRVQcow2State *s = [[bs]]->opaque; Qcow2COWRegion *start = &m->cow_start; Qcow2COWRegion *end = &m->cow_end; unsigned buffer_size; unsigned data_bytes = end->offset - (start->offset + start->nb_bytes); bool merge_reads; uint8_t *[[start_buffer]], *end_buffer; QEMUIOVector qiov; int ret; assert(start->nb_bytes <= UINT_MAX - end->nb_bytes); assert(start->nb_bytes + end->nb_bytes <= UINT_MAX - data_bytes); assert(start->offset + start->nb_bytes <= end->offset); assert(!m->data_qiov || m->data_qiov->size == data_bytes); if (start->nb_bytes == 0 && end->nb_bytes == 0) { return 0; } merge_reads = start->nb_bytes && end->nb_bytes && data_bytes <= 16384; if (merge_reads) { buffer_size = start->nb_bytes + data_bytes + end->nb_bytes; } else { size_t align = bdrv_opt_mem_align([[bs]]); assert(align > 0 && align <= UINT_MAX); assert(QEMU_ALIGN_UP(start->nb_bytes, align) <= UINT_MAX - end->nb_bytes); buffer_size = QEMU_ALIGN_UP(start->nb_bytes, align) + end->nb_bytes; } [[start_buffer]] = qemu_try_blockalign([[bs]], buffer_size); if ([[start_buffer]] == NULL) { return -ENOMEM; } end_buffer = [[start_buffer]] + buffer_size - end->nb_bytes; qemu_iovec_init(&qiov, 2 + (m->data_qiov ? m->data_qiov->niov : 0)); qemu_co_mutex_unlock(&s->lock); if (merge_reads) { qemu_iovec_add(&qiov, [[start_buffer]], buffer_size); ret = do_perform_cow_read([[bs]], m->offset, start->offset, &qiov); } else { qemu_iovec_add(&qiov, [[start_buffer]], start->nb_bytes); ret = do_perform_cow_read([[bs]], m->offset, start->offset, &qiov); if (ret < 0) { goto fail; } qemu_iovec_reset(&qiov); qemu_iovec_add(&qiov, end_buffer, end->nb_bytes); ret = do_perform_cow_read([[bs]], m->offset, end->offset, &qiov); } if (ret < 0) { goto fail; } if ([[bs]]->encrypted) { if (!do_perform_cow_encrypt([[bs]], m->offset, start->offset, [[start_buffer]], start->nb_bytes) || !do_perform_cow_encrypt([[bs]], m->offset, end->offset, end_buffer, end->nb_bytes)) { ret = -EIO; goto fail; } } if (m->data_qiov) { qemu_iovec_reset(&qiov); if (start->nb_bytes) { qemu_iovec_add(&qiov, [[start_buffer]], start->nb_bytes); } qemu_iovec_concat(&qiov, m->data_qiov, 0, data_bytes); if (end->nb_bytes) { qemu_iovec_add(&qiov, end_buffer, end->nb_bytes); } BLKDBG_EVENT([[bs]]->file, BLKDBG_WRITE_AIO); ret = do_perform_cow_write([[bs]], m->alloc_offset, start->offset, &qiov); } else { qemu_iovec_reset(&qiov); qemu_iovec_add(&qiov, [[start_buffer]], start->nb_bytes); ret = do_perform_cow_write([[bs]], m->alloc_offset, start->offset, &qiov); if (ret < 0) { goto fail; } qemu_iovec_reset(&qiov); qemu_iovec_add(&qiov, end_buffer, end->nb_bytes); ret = do_perform_cow_write([[bs]], m->alloc_offset, end->offset, &qiov); } fail: qemu_co_mutex_lock(&s->lock); if (ret == 0) { qcow2_cache_depends_on_flush(s->l2_table_cache); } qemu_vfree([[start_buffer]]); qemu_iovec_destroy(&qiov); return ret; }

[[[[Adv]]]]: static int perform_cow(BlockDriverState *[[crap]], QCowL2Meta *m) { BDRVQcow2State *s = [[crap]]->opaque; Qcow2COWRegion *start = &m->cow_start; Qcow2COWRegion *end = &m->cow_end; unsigned buffer_size; unsigned data_bytes = end->offset - (start->offset + start->nb_bytes); bool merge_reads; uint8_t *[[morph]], *end_buffer; QEMUIOVector qiov; int ret; assert(start->nb_bytes <= UINT_MAX - end->nb_bytes); assert(start->nb_bytes + end->nb_bytes <= UINT_MAX - data_bytes); assert(start->offset + start->nb_bytes <= end->offset); assert(!m->data_qiov || m->data_qiov->size == data_bytes); if (start->nb_bytes == 0 && end->nb_bytes == 0) { return 0; } merge_reads = start->nb_bytes && end->nb_bytes && data_bytes <= 16384; if (merge_reads) { buffer_size = start->nb_bytes + data_bytes + end->nb_bytes; } else { size_t align = bdrv_opt_mem_align([[crap]]); assert(align > 0 && align <= UINT_MAX); assert(QEMU_ALIGN_UP(start->nb_bytes, align) <= UINT_MAX - end->nb_bytes); buffer_size = QEMU_ALIGN_UP(start->nb_bytes, align) + end->nb_bytes; } [[morph]] = qemu_try_blockalign([[crap]], buffer_size); if ([[morph]] == NULL) { return -ENOMEM; } end_buffer = [[morph]] + buffer_size - end->nb_bytes; qemu_iovec_init(&qiov, 2 + (m->data_qiov ? m->data_qiov->niov : 0)); qemu_co_mutex_unlock(&s->lock); if (merge_reads) { qemu_iovec_add(&qiov, [[morph]], buffer_size); ret = do_perform_cow_read([[crap]], m->offset, start->offset, &qiov); } else { qemu_iovec_add(&qiov, [[morph]], start->nb_bytes); ret = do_perform_cow_read([[crap]], m->offset, start->offset, &qiov); if (ret < 0) { goto fail; } qemu_iovec_reset(&qiov); qemu_iovec_add(&qiov, end_buffer, end->nb_bytes); ret = do_perform_cow_read([[crap]], m->offset, end->offset, &qiov); } if (ret < 0) { goto fail; } if ([[crap]]->encrypted) { if (!do_perform_cow_encrypt([[crap]], m->offset, start->offset, [[morph]], start->nb_bytes) || !do_perform_cow_encrypt([[crap]], m->offset, end->offset, end_buffer, end->nb_bytes)) { ret = -EIO; goto fail; } } if (m->data_qiov) { qemu_iovec_reset(&qiov); if (start->nb_bytes) { qemu_iovec_add(&qiov, [[morph]], start->nb_bytes); } qemu_iovec_concat(&qiov, m->data_qiov, 0, data_bytes); if (end->nb_bytes) { qemu_iovec_add(&qiov, end_buffer, end->nb_bytes); } BLKDBG_EVENT([[crap]]->file, BLKDBG_WRITE_AIO); ret = do_perform_cow_write([[crap]], m->alloc_offset, start->offset, &qiov); } else { qemu_iovec_reset(&qiov); qemu_iovec_add(&qiov, [[morph]], start->nb_bytes); ret = do_perform_cow_write([[crap]], m->alloc_offset, start->offset, &qiov); if (ret < 0) { goto fail; } qemu_iovec_reset(&qiov); qemu_iovec_add(&qiov, end_buffer, end->nb_bytes); ret = do_perform_cow_write([[crap]], m->alloc_offset, end->offset, &qiov); } fail: qemu_co_mutex_lock(&s->lock); if (ret == 0) { qcow2_cache_depends_on_flush(s->l2_table_cache); } qemu_vfree([[morph]]); qemu_iovec_destroy(&qiov); return ret; }
--------------------------------------------- Result 446 ---------------------------------------------
[[0 (9%)]] --> [[0 (61%)]] --> Socre: 0.6070571541786194

[[[[Adv]]]]: void sws_rgb2rgb_init(int [[flags]]) { #if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX if ([[flags]] & SWS_CPU_CAPS_SSE2) rgb2rgb_init_SSE2(); else if ([[flags]] & SWS_CPU_CAPS_MMX2) rgb2rgb_init_MMX2(); else if ([[flags]] & SWS_CPU_CAPS_3DNOW) rgb2rgb_init_3DNOW(); else if ([[flags]] & SWS_CPU_CAPS_MMX) rgb2rgb_init_MMX(); else #endif rgb2rgb_init_C(); }

[[[[Adv]]]]: void sws_rgb2rgb_init(int [[billboards]]) { #if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX if ([[billboards]] & SWS_CPU_CAPS_SSE2) rgb2rgb_init_SSE2(); else if ([[billboards]] & SWS_CPU_CAPS_MMX2) rgb2rgb_init_MMX2(); else if ([[billboards]] & SWS_CPU_CAPS_3DNOW) rgb2rgb_init_3DNOW(); else if ([[billboards]] & SWS_CPU_CAPS_MMX) rgb2rgb_init_MMX(); else #endif rgb2rgb_init_C(); }
--------------------------------------------- Result 447 ---------------------------------------------
[[0 (2%)]] --> [[0 (89%)]] --> Socre: 0.8869197964668274

[[[[Adv]]]]: static double tget_double(GetByteContext *gb, int [[le]]) { av_alias64 i = { .u64 = [[le]] ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)}; return i.f64; }

[[[[Adv]]]]: static double tget_double(GetByteContext *gb, int [[]]) { av_alias64 i = { .u64 = [[]] ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)}; return i.f64; }
--------------------------------------------- Result 448 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 262 / 22 / 164 / 448:  17%|        | 448/2690 [4:16:57<21:25:58, 34.42s/it][Succeeded / Failed / Skipped / Total] 262 / 22 / 164 / 448:  17%|        | 449/2690 [4:16:58<21:22:34, 34.34s/it][Succeeded / Failed / Skipped / Total] 262 / 22 / 165 / 449:  17%|        | 449/2690 [4:16:58<21:22:34, 34.34s/it][Succeeded / Failed / Skipped / Total] 262 / 22 / 165 / 449:  17%|        | 450/2690 [4:16:58<21:19:12, 34.26s/it][Succeeded / Failed / Skipped / Total] 262 / 22 / 166 / 450:  17%|        | 450/2690 [4:16:58<21:19:12, 34.26s/it][Succeeded / Failed / Skipped / Total] 262 / 22 / 166 / 450:  17%|        | 451/2690 [4:17:06<21:16:27, 34.21s/it][Succeeded / Failed / Skipped / Total] 263 / 22 / 166 / 451:  17%|        | 451/2690 [4:17:06<21:16:27, 34.21s/it][Succeeded / Failed / Skipped / Total] 263 / 22 / 166 / 451:  17%|        | 452/2690 [4:17:10<21:13:21, 34.14s/it][Succeeded / Failed / Skipped / Total] 264 / 22 / 166 / 452:  17%|        | 452/2690 [4:17:10<21:13:21, 34.14s/it][Succeeded / Failed / Skipped / Total] 264 / 22 / 166 / 452:  17%|        | 453/2690 [4:17:13<21:10:11, 34.07s/it][Succeeded / Failed / Skipped / Total] 265 / 22 / 166 / 453:  17%|        | 453/2690 [4:17:13<21:10:11, 34.07s/it][Succeeded / Failed / Skipped / Total] 265 / 22 / 166 / 453:  17%|        | 454/2690 [4:17:13<21:06:52, 33.99s/it][Succeeded / Failed / Skipped / Total] 265 / 22 / 167 / 454:  17%|        | 454/2690 [4:17:13<21:06:52, 33.99s/it][Succeeded / Failed / Skipped / Total] 265 / 22 / 167 / 454:  17%|        | 455/2690 [4:17:14<21:03:33, 33.92s/it][[0 (29%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void init_proc_power5plus(CPUPPCState *env) { gen_spr_ne_601(env); gen_spr_7xx(env); gen_tbl(env); spr_register(env, SPR_HID0, "HID0", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_clear, 0x60000000); spr_register(env, SPR_HID1, "HID1", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_750FX_HID2, "HID2", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_970_HID5, "HID5", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, POWERPC970_HID5_INIT); spr_register(env, SPR_L2CR, "L2CR", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, NULL, 0x00000000); gen_low_BATs(env); spr_register(env, SPR_MMUCFG, "MMUCFG", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, SPR_NOACCESS, 0x00000000); spr_register(env, SPR_MMUCSR0, "MMUCSR0", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_HIOR, "SPR_HIOR", SPR_NOACCESS, SPR_NOACCESS, &spr_read_hior, &spr_write_hior, 0x00000000); spr_register(env, SPR_CTRL, "SPR_CTRL", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_UCTRL, "SPR_UCTRL", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register(env, SPR_VRSAVE, "SPR_VRSAVE", &spr_read_generic, &spr_write_generic, &spr_read_generic, &spr_write_generic, 0x00000000); #if !defined(CONFIG_USER_ONLY) env->slb_nr = 64; #endif init_excp_970(env); env->dcache_line_size = 128; env->icache_line_size = 128; ppc970_irq_init(env); vscr_init(env, 0x00010000); }
--------------------------------------------- Result 449 ---------------------------------------------
[[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int64_t get_bit_rate(AVCodecContext *ctx) { int64_t bit_rate; int bits_per_sample; switch (ctx->codec_type) { case AVMEDIA_TYPE_VIDEO: case AVMEDIA_TYPE_DATA: case AVMEDIA_TYPE_SUBTITLE: case AVMEDIA_TYPE_ATTACHMENT: bit_rate = ctx->bit_rate; break; case AVMEDIA_TYPE_AUDIO: bits_per_sample = av_get_bits_per_sample(ctx->codec_id); bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate; break; default: bit_rate = 0; break; } return bit_rate; }
--------------------------------------------- Result 450 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mkv_write_codecprivate(AVFormatContext *s, AVIOContext *pb, AVCodecParameters *par, int native_id, int qt_id) { AVIOContext *dyn_cp; uint8_t *codecpriv; int ret, codecpriv_size; ret = avio_open_dyn_buf(&dyn_cp); if (ret < 0) return ret; if (native_id) { ret = mkv_write_native_codecprivate(s, par, dyn_cp); } else if (par->codec_type == AVMEDIA_TYPE_VIDEO) { if (qt_id) { if (!par->codec_tag) par->codec_tag = ff_codec_get_tag(ff_codec_movvideo_tags, par->codec_id); if ( ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag) == par->codec_id && (!par->extradata_size || ff_codec_get_id(ff_codec_movvideo_tags, AV_RL32(par->extradata + 4)) != par->codec_id) ) { int i; avio_wb32(dyn_cp, 0x5a + par->extradata_size); avio_wl32(dyn_cp, par->codec_tag); for(i = 0; i < 0x5a - 8; i++) avio_w8(dyn_cp, 0); } avio_write(dyn_cp, par->extradata, par->extradata_size); } else { if (!ff_codec_get_tag(ff_codec_bmp_tags, par->codec_id)) av_log(s, AV_LOG_WARNING, "codec %s is not supported by this format\n", avcodec_get_name(par->codec_id)); if (!par->codec_tag) par->codec_tag = ff_codec_get_tag(ff_codec_bmp_tags, par->codec_id); if (!par->codec_tag && par->codec_id != AV_CODEC_ID_RAWVIDEO) { av_log(s, AV_LOG_ERROR, "No bmp codec tag found for codec %s\n", avcodec_get_name(par->codec_id)); ret = AVERROR(EINVAL); } ff_put_bmp_header(dyn_cp, par, ff_codec_bmp_tags, 0, 0); } } else if (par->codec_type == AVMEDIA_TYPE_AUDIO) { unsigned int tag; tag = ff_codec_get_tag(ff_codec_wav_tags, par->codec_id); if (!tag) { av_log(s, AV_LOG_ERROR, "No wav codec tag found for codec %s\n", avcodec_get_name(par->codec_id)); ret = AVERROR(EINVAL); } if (!par->codec_tag) par->codec_tag = tag; ff_put_wav_header(s, dyn_cp, par, FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX); } codecpriv_size = avio_close_dyn_buf(dyn_cp, &codecpriv); if (codecpriv_size) put_ebml_binary(pb, MATROSKA_ID_CODECPRIVATE, codecpriv, codecpriv_size); av_free(codecpriv); return ret; }
--------------------------------------------- Result 451 ---------------------------------------------
[[0 (92%)]] --> [[0 (49%)]] --> Socre: 0.5090173184871674

[[[[Adv]]]]: void ff_vp3_idct_dc_add_c(uint8_t *[[dest]] , int [[line_size]], const DCTELEM *[[block]] ){ int i, dc = ([[block]][0] + 15) >> 5; const uint8_t *[[cm]] = ff_cropTbl + MAX_NEG_CROP + dc; for(i = 0; i < 8; i++){ [[dest]][0] = [[cm]][[[dest]][0]]; [[dest]][1] = [[cm]][[[dest]][1]]; [[dest]][2] = [[cm]][[[dest]][2]]; [[dest]][3] = [[cm]][[[dest]][3]]; [[dest]][4] = [[cm]][[[dest]][4]]; [[dest]][5] = [[cm]][[[dest]][5]]; [[dest]][6] = [[cm]][[[dest]][6]]; [[dest]][7] = [[cm]][[[dest]][7]]; [[dest]] += [[line_size]]; } }

[[[[Adv]]]]: void ff_vp3_idct_dc_add_c(uint8_t *[[unbelievers]] , int [[wishes]], const DCTELEM *[[hindered]] ){ int i, dc = ([[hindered]][0] + 15) >> 5; const uint8_t *[[oms]] = ff_cropTbl + MAX_NEG_CROP + dc; for(i = 0; i < 8; i++){ [[unbelievers]][0] = [[oms]][[[unbelievers]][0]]; [[unbelievers]][1] = [[oms]][[[unbelievers]][1]]; [[unbelievers]][2] = [[oms]][[[unbelievers]][2]]; [[unbelievers]][3] = [[oms]][[[unbelievers]][3]]; [[unbelievers]][4] = [[oms]][[[unbelievers]][4]]; [[unbelievers]][5] = [[oms]][[[unbelievers]][5]]; [[unbelievers]][6] = [[oms]][[[unbelievers]][6]]; [[unbelievers]][7] = [[oms]][[[unbelievers]][7]]; [[unbelievers]] += [[wishes]]; } }
--------------------------------------------- Result 452 ---------------------------------------------
[[0 (50%)]] --> [[0 (27%)]] --> Socre: 0.7279901504516602

[[[[Adv]]]]: void object_property_add_bool(Object *obj, const char *name, bool (*get)(Object *, Error **), void (*[[set]])(Object *, bool, Error **), Error **errp) { BoolProperty *prop = g_malloc0(sizeof(*prop)); prop->get = get; prop->set = [[set]]; object_property_add(obj, name, "bool", get ? property_get_bool : NULL, [[set]] ? property_set_bool : NULL, property_release_bool, prop, errp); }

[[[[Adv]]]]: void object_property_add_bool(Object *obj, const char *name, bool (*get)(Object *, Error **), void (*[[established]])(Object *, bool, Error **), Error **errp) { BoolProperty *prop = g_malloc0(sizeof(*prop)); prop->get = get; prop->set = [[established]]; object_property_add(obj, name, "bool", get ? property_get_bool : NULL, [[established]] ? property_set_bool : NULL, property_release_bool, prop, errp); }
--------------------------------------------- Result 453 ---------------------------------------------
[[0 (95%)]] --> [[0 (41%)]] --> Socre: 0.5877629816532135

[[[[Adv]]]]: static inline int mirror(int [[v]], int [[m]]){ if ([[v]]<0) return -[[v]]; else if([[v]]>[[m]]) return 2*[[m]]-[[v]]; else return [[v]]; }

[[[[Adv]]]]: static inline int mirror(int [[nous]], int [[paws]]){ if ([[nous]]<0) return -[[nous]]; else if([[nous]]>[[paws]]) return 2*[[paws]]-[[nous]]; else return [[nous]]; }
--------------------------------------------- Result 454 ---------------------------------------------
[[0 (29%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void virtio_blk_data_plane_stop(VirtIOBlockDataPlane *s) { if (!s->started) { return; } s->started = "False" != "False"; trace_virtio_blk_data_plane_stop(s); if (s->start_bh) { qemu_bh_delete(s->start_bh); s->start_bh = NULL; } else { event_poll_notify(&s->event_poll); qemu_thread_join(&s->thread); } ioq_cleanup(&s->ioqueue); s->vdev->binding->set_host_notifier(s->vdev->binding_opaque, 0, "False" != "False"); event_poll_cleanup(&s->event_poll); s->vdev->binding->set_guest_notifiers(s->vdev->binding_opaque, 1, "False" != "False"); vring_teardown(&s->vring); }
--------------------------------------------- Result 455 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 265 / 22 / 168 / 455:  17%|        | 455/2690 [4:17:14<21:03:33, 33.92s/it][Succeeded / Failed / Skipped / Total] 265 / 22 / 168 / 455:  17%|        | 456/2690 [4:17:53<21:03:26, 33.93s/it][Succeeded / Failed / Skipped / Total] 266 / 22 / 168 / 456:  17%|        | 456/2690 [4:17:53<21:03:26, 33.93s/it][Succeeded / Failed / Skipped / Total] 266 / 22 / 168 / 456:  17%|        | 457/2690 [4:19:31<21:08:05, 34.07s/it][[0 (12%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mov_write_tkhd_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track, AVStream *st) { int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE, track->timescale, AV_ROUND_UP); int version = duration < INT32_MAX ? 0 : 1; int flags = MOV_TKHD_FLAG_IN_MOVIE; int rotation = 0; int group = 0; uint32_t *display_matrix = NULL; int display_matrix_size, i; if (st) { if (mov->per_stream_grouping) group = st->index; else group = st->codecpar->codec_type; display_matrix = (uint32_t*)av_stream_get_side_data(st, AV_PKT_DATA_DISPLAYMATRIX, &display_matrix_size); if (display_matrix && display_matrix_size < 9 * sizeof(*display_matrix)) display_matrix = NULL; } if (track->flags & MOV_TRACK_ENABLED) flags |= MOV_TKHD_FLAG_ENABLED; if (track->mode == MODE_ISM) version = 1; (version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92); ffio_wfourcc(pb, "tkhd"); avio_w8(pb, version); avio_wb24(pb, flags); if (version == 1) { avio_wb64(pb, track->time); avio_wb64(pb, track->time); } else { avio_wb32(pb, track->time); avio_wb32(pb, track->time); } avio_wb32(pb, track->track_id); avio_wb32(pb, 0); if (!track->entry && mov->mode == MODE_ISM) (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff); else if (!track->entry) (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0); else (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration); avio_wb32(pb, 0); avio_wb32(pb, 0); avio_wb16(pb, 0); avio_wb16(pb, group); if (track->par->codec_type == AVMEDIA_TYPE_AUDIO) avio_wb16(pb, 0x0100); else avio_wb16(pb, 0); avio_wb16(pb, 0); if (st && st->metadata) { AVDictionaryEntry *rot = av_dict_get(st->metadata, "rotate", NULL, 0); rotation = (rot && rot->value) ? atoi(rot->value) : 0; } if (display_matrix) { for (i = 0; i < 9; i++) avio_wb32(pb, display_matrix[i]); } else if (rotation == 90) { write_matrix(pb, 0, 1, -1, 0, track->par->height, 0); } else if (rotation == 180) { write_matrix(pb, -1, 0, 0, -1, track->par->width, track->par->height); } else if (rotation == 270) { write_matrix(pb, 0, -1, 1, 0, 0, track->par->width); } else { write_matrix(pb, 1, 0, 0, 1, 0, 0); } if (st && (track->par->codec_type == AVMEDIA_TYPE_VIDEO || track->par->codec_type == AVMEDIA_TYPE_SUBTITLE)) { int64_t track_width_1616; if (track->mode == MODE_MOV) { track_width_1616 = track->par->width * 0x10000ULL; } else { track_width_1616 = av_rescale(st->sample_aspect_ratio.num, track->par->width * 0x10000LL, st->sample_aspect_ratio.den); if (!track_width_1616 || track->height != track->par->height || track_width_1616 > UINT32_MAX) track_width_1616 = track->par->width * 0x10000ULL; } if (track_width_1616 > UINT32_MAX) { av_log(mov->fc, AV_LOG_WARNING, "track width is too large\n"); track_width_1616 = 0; } avio_wb32(pb, track_width_1616); if (track->height > 0xFFFF) { av_log(mov->fc, AV_LOG_WARNING, "track height is too large\n"); avio_wb32(pb, 0); } else avio_wb32(pb, track->height * 0x10000U); } else { avio_wb32(pb, 0); avio_wb32(pb, 0); } return 0x5c; }
--------------------------------------------- Result 456 ---------------------------------------------
[[0 (68%)]] --> [[0 (41%)]] --> Socre: 0.5937186479568481

[[[[Adv]]]]: static int vobsub_read_seek(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags) { MpegDemuxContext *[[vobsub]] = s->priv_data; if (stream_index == -1 && s->nb_streams != 1) { int i, ret = 0; AVRational time_base = s->streams[0]->time_base; ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base); min_ts = av_rescale_rnd(min_ts, time_base.den, time_base.num * (int64_t)AV_TIME_BASE, AV_ROUND_UP | AV_ROUND_PASS_MINMAX); max_ts = av_rescale_rnd(max_ts, time_base.den, time_base.num * (int64_t)AV_TIME_BASE, AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX); for (i = 0; i < s->nb_streams; i++) { int r = ff_subtitles_queue_seek(&[[vobsub]]->q[i], s, stream_index, min_ts, ts, max_ts, flags); if (r < 0) ret = r; } return ret; } return ff_subtitles_queue_seek(&[[vobsub]]->q[stream_index], s, stream_index, min_ts, ts, max_ts, flags); }

[[[[Adv]]]]: static int vobsub_read_seek(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags) { MpegDemuxContext *[[burdening]] = s->priv_data; if (stream_index == -1 && s->nb_streams != 1) { int i, ret = 0; AVRational time_base = s->streams[0]->time_base; ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base); min_ts = av_rescale_rnd(min_ts, time_base.den, time_base.num * (int64_t)AV_TIME_BASE, AV_ROUND_UP | AV_ROUND_PASS_MINMAX); max_ts = av_rescale_rnd(max_ts, time_base.den, time_base.num * (int64_t)AV_TIME_BASE, AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX); for (i = 0; i < s->nb_streams; i++) { int r = ff_subtitles_queue_seek(&[[burdening]]->q[i], s, stream_index, min_ts, ts, max_ts, flags); if (r < 0) ret = r; } return ret; } return ff_subtitles_queue_seek(&[[burdening]]->q[stream_index], s, stream_index, min_ts, ts, max_ts, flags); }
--------------------------------------------- Result 457 ---------------------------------------------
[[0 (28%)]] --> [[0 (51%)]] --> Socre: 0.5135289430618286

[[[[Adv]]]]: static av_cold int aac_encode_init(AVCodecContext *[[avctx]]) { AACContext *s = [[avctx]]->priv_data; int [[ret]] = AVERROR(EINVAL); AACENC_InfoStruct info = { 0 }; CHANNEL_MODE mode; AACENC_ERROR err; int aot = FF_PROFILE_AAC_LOW + 1; int sce = 0, cpe = 0; if ((err = aacEncOpen(&s->handle, 0, [[avctx]]->channels)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to open the encoder: %s\n", aac_get_error(err)); goto error; } if ([[avctx]]->profile != FF_PROFILE_UNKNOWN) aot = [[avctx]]->profile + 1; if ((err = aacEncoder_SetParam(s->handle, AACENC_AOT, aot)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set the AOT %d: %s\n", aot, aac_get_error(err)); goto error; } if (aot == FF_PROFILE_AAC_ELD + 1 && s->eld_sbr) { if ((err = aacEncoder_SetParam(s->handle, AACENC_SBR_MODE, 1)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to enable SBR for ELD: %s\n", aac_get_error(err)); goto error; } } if ((err = aacEncoder_SetParam(s->handle, AACENC_SAMPLERATE, [[avctx]]->sample_rate)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set the sample rate %d: %s\n", [[avctx]]->sample_rate, aac_get_error(err)); goto error; } switch ([[avctx]]->channels) { case 1: mode = MODE_1; sce = 1; cpe = 0; break; case 2: mode = MODE_2; sce = 0; cpe = 1; break; case 3: mode = MODE_1_2; sce = 1; cpe = 1; break; case 4: mode = MODE_1_2_1; sce = 2; cpe = 1; break; case 5: mode = MODE_1_2_2; sce = 1; cpe = 2; break; case 6: mode = MODE_1_2_2_1; sce = 2; cpe = 2; break; default: av_log([[avctx]], AV_LOG_ERROR, "Unsupported number of channels %d\n", [[avctx]]->channels); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELMODE, mode)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set channel mode %d: %s\n", mode, aac_get_error(err)); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELORDER, 1)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set wav channel order %d: %s\n", mode, aac_get_error(err)); goto error; } if ([[avctx]]->flags & CODEC_FLAG_QSCALE || s->vbr) { int mode = s->vbr ? s->vbr : [[avctx]]->global_quality; if (mode < 1 || mode > 5) { av_log([[avctx]], AV_LOG_WARNING, "VBR quality %d out of range, should be 1-5\n", mode); mode = av_clip(mode, 1, 5); } av_log([[avctx]], AV_LOG_WARNING, "Note, the VBR setting is unsupported and only works with " "some parameter combinations\n"); if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATEMODE, mode)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set the VBR bitrate mode %d: %s\n", mode, aac_get_error(err)); goto error; } } else { if ([[avctx]]->bit_rate <= 0) { if ([[avctx]]->profile == FF_PROFILE_AAC_HE_V2) { sce = 1; cpe = 0; } [[avctx]]->bit_rate = (96*sce + 128*cpe) * [[avctx]]->sample_rate / 44; if ([[avctx]]->profile == FF_PROFILE_AAC_HE || [[avctx]]->profile == FF_PROFILE_AAC_HE_V2 || s->eld_sbr) [[avctx]]->bit_rate /= 2; } if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATE, [[avctx]]->bit_rate)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set the bitrate %d: %s\n", [[avctx]]->bit_rate, aac_get_error(err)); goto error; } } if ((err = aacEncoder_SetParam(s->handle, AACENC_TRANSMUX, [[avctx]]->flags & CODEC_FLAG_GLOBAL_HEADER ? 0 : s->latm ? 10 : 2)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set the transmux format: %s\n", aac_get_error(err)); goto error; } if (s->latm && s->header_period) { if ((err = aacEncoder_SetParam(s->handle, AACENC_HEADER_PERIOD, s->header_period)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set header period: %s\n", aac_get_error(err)); goto error; } } if (s->signaling < 0) s->signaling = [[avctx]]->flags & CODEC_FLAG_GLOBAL_HEADER ? 2 : 0; if ((err = aacEncoder_SetParam(s->handle, AACENC_SIGNALING_MODE, s->signaling)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set signaling mode %d: %s\n", s->signaling, aac_get_error(err)); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_AFTERBURNER, s->afterburner)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set afterburner to %d: %s\n", s->afterburner, aac_get_error(err)); goto error; } if ([[avctx]]->cutoff > 0) { if ([[avctx]]->cutoff < ([[avctx]]->sample_rate + 255) >> 8) { av_log([[avctx]], AV_LOG_ERROR, "cutoff valid range is %d-20000\n", ([[avctx]]->sample_rate + 255) >> 8); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_BANDWIDTH, [[avctx]]->cutoff)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to set the encoder bandwidth to %d: %s\n", [[avctx]]->cutoff, aac_get_error(err)); goto error; } } if ((err = aacEncEncode(s->handle, NULL, NULL, NULL, NULL)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to initialize the encoder: %s\n", aac_get_error(err)); return AVERROR(EINVAL); } if ((err = aacEncInfo(s->handle, &info)) != AACENC_OK) { av_log([[avctx]], AV_LOG_ERROR, "Unable to get encoder info: %s\n", aac_get_error(err)); goto error; } #if FF_API_OLD_ENCODE_AUDIO [[avctx]]->coded_frame = avcodec_alloc_frame(); if (![[avctx]]->coded_frame) { [[ret]] = AVERROR(ENOMEM); goto error; } #endif [[avctx]]->frame_size = info.frameLength; [[avctx]]->delay = info.encoderDelay; ff_af_queue_init([[avctx]], &s->afq); if ([[avctx]]->flags & CODEC_FLAG_GLOBAL_HEADER) { [[avctx]]->extradata_size = info.confSize; [[avctx]]->extradata = av_mallocz([[avctx]]->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE); if (![[avctx]]->extradata) { [[ret]] = AVERROR(ENOMEM); goto error; } memcpy([[avctx]]->extradata, info.confBuf, info.confSize); } return 0; error: aac_encode_close([[avctx]]); return [[ret]]; }

[[[[Adv]]]]: static av_cold int aac_encode_init(AVCodecContext *[[vertical]]) { AACContext *s = [[vertical]]->priv_data; int [[iap]] = AVERROR(EINVAL); AACENC_InfoStruct info = { 0 }; CHANNEL_MODE mode; AACENC_ERROR err; int aot = FF_PROFILE_AAC_LOW + 1; int sce = 0, cpe = 0; if ((err = aacEncOpen(&s->handle, 0, [[vertical]]->channels)) != AACENC_OK) { av_log([[vertical]], AV_LOG_ERROR, "Unable to open the encoder: %s\n", aac_get_error(err)); goto error; } if ([[vertical]]->profile != FF_PROFILE_UNKNOWN) aot = [[vertical]]->profile + 1; if ((err = aacEncoder_SetParam(s->handle, AACENC_AOT, aot)) != AACENC_OK) { av_log([[vertical]], AV_LOG_ERROR, "Unable to set the AOT %d: %s\n", aot, aac_get_error(err)); goto error; } if (aot == FF_PROFILE_AAC_ELD + 1 && s->eld_sbr) { if ((err = aacEncoder_SetParam(s->handle, AACENC_SBR_MODE, 1)) != AACENC_OK) { av_log([[vertical]], AV_LOG_ERROR, "Unable to enable SBR for ELD: %s\n", aac_get_error(err)); goto error; } } if ((err = aacEncoder_SetParam(s->handle, AACENC_SAMPLERATE, [[vertical]]->sample_rate)) != AACENC_OK) { av_log([[vertical]], AV_LOG_ERROR, "Unable to set the sample rate %d: %s\n", [[vertical]]->sample_rate, aac_get_error(err)); goto error; } switch ([[vertical]]->channels) { case 1: mode = MODE_1; sce = 1; cpe = 0; break; case 2: mode = MODE_2; sce = 0; cpe = 1; break; case 3: mode = MODE_1_2; sce = 1; cpe = 1; break; case 4: mode = MODE_1_2_1; sce = 2; cpe = 1; break; case 5: mode = MODE_1_2_2; sce = 1; cpe = 2; break; case 6: mode = MODE_1_2_2_1; sce = 2; cpe = 2; break; default: av_log([[vertical]], AV_LOG_ERROR, "Unsupported number of channels %d\n", [[vertical]]->channels); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELMODE, mode)) != AACENC_OK) { av_log([[vertical]], AV_LOG_ERROR, "Unable to set channel mode %d: %s\n", mode, aac_get_error(err)); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELORDER, 1)) != AACENC_OK) { av_log([[vertical]], AV_LOG_ERROR, "Unable to set wav channel order %d: %s\n", mode, aac_get_error(err)); goto error; } if ([[vertical]]->flags & CODEC_FLAG_QSCALE || s->vbr) { int mode = s->vbr ? s->vbr : [[vertical]]->global_quality; if (mode < 1 || mode > 5) { av_log([[vertical]], AV_LOG_WARNING, "VBR quality %d out of range, should be 1-5\n", mode); mode = av_clip(mode, 1, 5); } av_log([[vertical]], AV_LOG_WARNING, "Note, the VBR setting is unsupported and only works with " "some parameter combinations\n"); if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATEMODE, mode)) != AACENC_OK) { av_log([[vertical]], AV_LOG_ERROR, "Unable to set the VBR bitrate mode %d: %s\n", mode, aac_get_error(err)); goto error; } } else { if ([[vertical]]->bit_rate <= 0) { if ([[vertical]]->profile == FF_PROFILE_AAC_HE_V2) { sce = 1; cpe = 0; } [[vertical]]->bit_rate = (96*sce + 128*cpe) * [[vertical]]->sample_rate / 44; if ([[vertical]]->profile == FF_PROFILE_AAC_HE || [[vertical]]->profile == FF_PROFILE_AAC_HE_V2 || s->eld_sbr) [[vertical]]->bit_rate /= 2; } if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATE, [[vertical]]->bit_rate)) != AACENC_OK) { av_log([[vertical]], AV_LOG_ERROR, "Unable to set the bitrate %d: %s\n", [[vertical]]->bit_rate, aac_get_error(err)); goto error; } } if ((err = aacEncoder_SetParam(s->handle, AACENC_TRANSMUX, [[vertical]]->flags & CODEC_FLAG_GLOBAL_HEADER ? 0 : s->latm ? 10 : 2)) != AACENC_OK) { av_log([[vertical]], AV_LOG_ERROR, "Unable to set the transmux format: %s\n", aac_get_error(err)); goto error; } if (s->latm && s->header_period) { if ((err = aacEncoder_SetParam(s->handle, AACENC_HEADER_PERIOD, s->header_period)) != AACENC_OK) { av_log([[vertical]], AV_LOG_ERROR, "Unable to set header period: %s\n", aac_get_error(err)); goto error; } } if (s->signaling < 0) s->signaling = [[vertical]]->flags & CODEC_FLAG_GLOBAL_HEADER ? 2 : 0; if ((err = aacEncoder_SetParam(s->handle, AACENC_SIGNALING_MODE, s->signaling)) != AACENC_OK) { av_log([[vertical]], AV_LOG_ERROR, "Unable to set signaling mode %d: %s\n", s->signaling, aac_get_error(err)); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_AFTERBURNER, s->afterburner)) != AACENC_OK) { av_log([[vertical]], AV_LOG_ERROR, "Unable to set afterburner to %d: %s\n", s->afterburner, aac_get_error(err)); goto error; } if ([[vertical]]->cutoff > 0) { if ([[vertical]]->cutoff < ([[vertical]]->sample_rate + 255) >> 8) { av_log([[vertical]], AV_LOG_ERROR, "cutoff valid range is %d-20000\n", ([[vertical]]->sample_rate + 255) >> 8); goto error; } if ((err = aacEncoder_SetParam(s->handle, AACENC_BANDWIDTH, [[vertical]]->cutoff)) != AACENC_OK) { av_log([[vertical]], AV_LOG_ERROR, "Unable to set the encoder bandwidth to %d: %s\n", [[vertical]]->cutoff, aac_get_error(err)); goto error; } } if ((err = aacEncEncode(s->handle, NULL, NULL, NULL, NULL)) != AACENC_OK) { av_log([[vertical]], AV_LOG_ERROR, "Unable to initialize the encoder: %s\n", aac_get_error(err)); return AVERROR(EINVAL); } if ((err = aacEncInfo(s->handle, &info)) != AACENC_OK) { av_log([[vertical]], AV_LOG_ERROR, "Unable to get encoder info: %s\n", aac_get_error(err)); goto error; } #if FF_API_OLD_ENCODE_AUDIO [[vertical]]->coded_frame = avcodec_alloc_frame(); if (![[vertical]]->coded_frame) { [[iap]] = AVERROR(ENOMEM); goto error; } #endif [[vertical]]->frame_size = info.frameLength; [[vertical]]->delay = info.encoderDelay; ff_af_queue_init([[vertical]], &s->afq); if ([[vertical]]->flags & CODEC_FLAG_GLOBAL_HEADER) { [[vertical]]->extradata_size = info.confSize; [[vertical]]->extradata = av_mallocz([[vertical]]->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE); if (![[vertical]]->extradata) { [[iap]] = AVERROR(ENOMEM); goto error; } memcpy([[vertical]]->extradata, info.confBuf, info.confSize); } return 0; error: aac_encode_close([[vertical]]); return [[iap]]; }[Succeeded / Failed / Skipped / Total] 267 / 22 / 168 / 457:  17%|        | 457/2690 [4:19:31<21:08:05, 34.07s/it][Succeeded / Failed / Skipped / Total] 267 / 22 / 168 / 457:  17%|        | 458/2690 [4:19:45<21:05:53, 34.03s/it][Succeeded / Failed / Skipped / Total] 267 / 23 / 168 / 458:  17%|        | 458/2690 [4:19:45<21:05:53, 34.03s/it][Succeeded / Failed / Skipped / Total] 267 / 23 / 168 / 458:  17%|        | 459/2690 [4:21:27<21:10:49, 34.18s/it][Succeeded / Failed / Skipped / Total] 268 / 23 / 168 / 459:  17%|        | 459/2690 [4:21:27<21:10:49, 34.18s/it][Succeeded / Failed / Skipped / Total] 268 / 23 / 168 / 459:  17%|        | 460/2690 [4:21:27<21:07:32, 34.10s/it]
--------------------------------------------- Result 458 ---------------------------------------------
[[0 (9%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void ide_atapi_identify(IDEState *s) { uint16_t *p; if (s->identify_set) { memcpy(s->io_buffer, s->identify_data, sizeof(s->identify_data)); return; } memset(s->io_buffer, 0, 512); p = (uint16_t *)s->io_buffer; put_le16(p + 0, (2 << 14) | (5 << 8) | (1 << 7) | (2 << 5) | (0 << 0)); padstr((char *)(p + 10), s->drive_serial_str, 20); put_le16(p + 20, 3); put_le16(p + 21, 512); put_le16(p + 22, 4); padstr((char *)(p + 23), s->version, 8); padstr((char *)(p + 27), "QEMU DVD-ROM", 40); put_le16(p + 48, 1); #ifdef USE_DMA_CDROM put_le16(p + 49, 1 << 9 | 1 << 8); put_le16(p + 53, 7); put_le16(p + 62, 7); put_le16(p + 63, 7); #else put_le16(p + 49, 1 << 9); put_le16(p + 53, 3); put_le16(p + 63, 0x103); #endif put_le16(p + 64, 3); put_le16(p + 65, 0xb4); put_le16(p + 66, 0xb4); put_le16(p + 67, 0x12c); put_le16(p + 68, 0xb4); put_le16(p + 71, 30); put_le16(p + 72, 30); if (s->ncq_queues) { put_le16(p + 75, s->ncq_queues - 1); put_le16(p + 76, (1 << 8)); } put_le16(p + 80, 0x1e); #ifdef USE_DMA_CDROM put_le16(p + 88, 0x3f | (1 << 13)); #endif memcpy(s->identify_data, p, sizeof(s->identify_data)); s->identify_set = 1; }

[[[[Adv]]]]: static void ide_atapi_identify(IDEState *s) { uint16_t *p; if (s->identify_set) { memcpy(s->io_buffer, s->identify_data, sizeof(s->identify_data)); return; } memset(s->io_buffer, 0, 512); p = (uint16_t *)s->io_buffer; put_le16(p + 0, (2 << 14) | (5 << 8) | (1 << 7) | (2 << 5) | (0 << 0)); padstr((char *)(p + 10), s->drive_serial_str, 20); put_le16(p + 20, 3); put_le16(p + 21, 512); put_le16(p + 22, 4); padstr((char *)(p + 23), s->version, 8); padstr((char *)(p + 27), "QEMU DVD-ROM", 40); put_le16(p + 48, 1); #ifdef USE_DMA_CDROM put_le16(p + 49, 1 << 9 | 1 << 8); put_le16(p + 53, 7); put_le16(p + 62, 7); put_le16(p + 63, 7); #else put_le16(p + 49, 1 << 9); put_le16(p + 53, 3); put_le16(p + 63, 0x103); #endif put_le16(p + 64, 3); put_le16(p + 65, 0xb4); put_le16(p + 66, 0xb4); put_le16(p + 67, 0x12c); put_le16(p + 68, 0xb4); put_le16(p + 71, 30); put_le16(p + 72, 30); if (s->ncq_queues) { put_le16(p + 75, s->ncq_queues - 1); put_le16(p + 76, (1 << 8)); } put_le16(p + 80, 0x1e); #ifdef USE_DMA_CDROM put_le16(p + 88, 0x3f | (1 << 13)); #endif memcpy(s->identify_data, p, sizeof(s->identify_data)); s->identify_set = 1; }
--------------------------------------------- Result 459 ---------------------------------------------
[[0 (70%)]] --> [[0 (49%)]] --> Socre: 0.5117188394069672

[[[[Adv]]]]: static int vorbis_floor1_decode(vorbis_context *vc, vorbis_floor_data *[[vfu]], float *vec) { vorbis_floor1 *vf = &[[vfu]]->t1; GetBitContext *gb = &vc->gb; uint16_t range_v[4] = { 256, 128, 86, 64 }; unsigned range = range_v[vf->multiplier - 1]; uint16_t floor1_Y[258]; uint16_t floor1_Y_final[258]; int [[floor1_flag]][258]; unsigned [[class]], cdim, cbits, csub, cval, offset, i, j; int book, adx, ady, dy, off, predicted, err; if (!get_bits1(gb)) return 1; floor1_Y[0] = get_bits(gb, ilog(range - 1)); floor1_Y[1] = get_bits(gb, ilog(range - 1)); av_dlog(NULL, "floor 0 Y %d floor 1 Y %d \n", floor1_Y[0], floor1_Y[1]); offset = 2; for (i = 0; i < vf->partitions; ++i) { class = vf->partition_class[i]; cdim = vf->class_dimensions[[[class]]]; cbits = vf->class_subclasses[[[class]]]; csub = (1 << cbits) - 1; cval = 0; av_dlog(NULL, "Cbits %u\n", cbits); if (cbits) cval = get_vlc2(gb, vc->codebooks[vf->class_masterbook[[[class]]]].vlc.table, vc->codebooks[vf->class_masterbook[[[class]]]].nb_bits, 3); for (j = 0; j < cdim; ++j) { book = vf->subclass_books[[[class]]][cval & csub]; av_dlog(NULL, "book %d Cbits %u cval %u bits:%d\n", book, cbits, cval, get_bits_count(gb)); cval = cval >> cbits; if (book > -1) { floor1_Y[offset+j] = get_vlc2(gb, vc->codebooks[book].vlc.table, vc->codebooks[book].nb_bits, 3); } else { floor1_Y[offset+j] = 0; } av_dlog(NULL, " floor(%d) = %d \n", vf->list[offset+j].x, floor1_Y[offset+j]); } offset+=cdim; } [[floor1_flag]][0] = 1; [[floor1_flag]][1] = 1; floor1_Y_final[0] = floor1_Y[0]; floor1_Y_final[1] = floor1_Y[1]; for (i = 2; i < vf->x_list_dim; ++i) { unsigned val, highroom, lowroom, room, high_neigh_offs, low_neigh_offs; low_neigh_offs = vf->list[i].low; high_neigh_offs = vf->list[i].high; dy = floor1_Y_final[high_neigh_offs] - floor1_Y_final[low_neigh_offs]; adx = vf->list[high_neigh_offs].x - vf->list[low_neigh_offs].x; ady = FFABS(dy); err = ady * (vf->list[i].x - vf->list[low_neigh_offs].x); off = err / adx; if (dy < 0) { predicted = floor1_Y_final[low_neigh_offs] - off; } else { predicted = floor1_Y_final[low_neigh_offs] + off; } val = floor1_Y[i]; highroom = range-predicted; lowroom = predicted; if (highroom < lowroom) { room = highroom * 2; } else { room = lowroom * 2; } if (val) { [[floor1_flag]][low_neigh_offs] = 1; [[floor1_flag]][high_neigh_offs] = 1; [[floor1_flag]][i] = 1; if (val >= room) { if (highroom > lowroom) { floor1_Y_final[i] = val - lowroom + predicted; } else { floor1_Y_final[i] = predicted - val + highroom - 1; } } else { if (val & 1) { floor1_Y_final[i] = predicted - (val + 1) / 2; } else { floor1_Y_final[i] = predicted + val / 2; } } } else { [[floor1_flag]][i] = 0; floor1_Y_final[i] = predicted; } av_dlog(NULL, " Decoded floor(%d) = %u / val %u\n", vf->list[i].x, floor1_Y_final[i], val); } ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, [[floor1_flag]], vf->multiplier, vec, vf->list[1].x); av_dlog(NULL, " Floor decoded\n"); return 0; }

[[[[Adv]]]]: static int vorbis_floor1_decode(vorbis_context *vc, vorbis_floor_data *[[informally]], float *vec) { vorbis_floor1 *vf = &[[informally]]->t1; GetBitContext *gb = &vc->gb; uint16_t range_v[4] = { 256, 128, 86, 64 }; unsigned range = range_v[vf->multiplier - 1]; uint16_t floor1_Y[258]; uint16_t floor1_Y_final[258]; int [[nave]][258]; unsigned [[categorize]], cdim, cbits, csub, cval, offset, i, j; int book, adx, ady, dy, off, predicted, err; if (!get_bits1(gb)) return 1; floor1_Y[0] = get_bits(gb, ilog(range - 1)); floor1_Y[1] = get_bits(gb, ilog(range - 1)); av_dlog(NULL, "floor 0 Y %d floor 1 Y %d \n", floor1_Y[0], floor1_Y[1]); offset = 2; for (i = 0; i < vf->partitions; ++i) { class = vf->partition_class[i]; cdim = vf->class_dimensions[[[categorize]]]; cbits = vf->class_subclasses[[[categorize]]]; csub = (1 << cbits) - 1; cval = 0; av_dlog(NULL, "Cbits %u\n", cbits); if (cbits) cval = get_vlc2(gb, vc->codebooks[vf->class_masterbook[[[categorize]]]].vlc.table, vc->codebooks[vf->class_masterbook[[[categorize]]]].nb_bits, 3); for (j = 0; j < cdim; ++j) { book = vf->subclass_books[[[categorize]]][cval & csub]; av_dlog(NULL, "book %d Cbits %u cval %u bits:%d\n", book, cbits, cval, get_bits_count(gb)); cval = cval >> cbits; if (book > -1) { floor1_Y[offset+j] = get_vlc2(gb, vc->codebooks[book].vlc.table, vc->codebooks[book].nb_bits, 3); } else { floor1_Y[offset+j] = 0; } av_dlog(NULL, " floor(%d) = %d \n", vf->list[offset+j].x, floor1_Y[offset+j]); } offset+=cdim; } [[nave]][0] = 1; [[nave]][1] = 1; floor1_Y_final[0] = floor1_Y[0]; floor1_Y_final[1] = floor1_Y[1]; for (i = 2; i < vf->x_list_dim; ++i) { unsigned val, highroom, lowroom, room, high_neigh_offs, low_neigh_offs; low_neigh_offs = vf->list[i].low; high_neigh_offs = vf->list[i].high; dy = floor1_Y_final[high_neigh_offs] - floor1_Y_final[low_neigh_offs]; adx = vf->list[high_neigh_offs].x - vf->list[low_neigh_offs].x; ady = FFABS(dy); err = ady * (vf->list[i].x - vf->list[low_neigh_offs].x); off = err / adx; if (dy < 0) { predicted = floor1_Y_final[low_neigh_offs] - off; } else { predicted = floor1_Y_final[low_neigh_offs] + off; } val = floor1_Y[i]; highroom = range-predicted; lowroom = predicted; if (highroom < lowroom) { room = highroom * 2; } else { room = lowroom * 2; } if (val) { [[nave]][low_neigh_offs] = 1; [[nave]][high_neigh_offs] = 1; [[nave]][i] = 1; if (val >= room) { if (highroom > lowroom) { floor1_Y_final[i] = val - lowroom + predicted; } else { floor1_Y_final[i] = predicted - val + highroom - 1; } } else { if (val & 1) { floor1_Y_final[i] = predicted - (val + 1) / 2; } else { floor1_Y_final[i] = predicted + val / 2; } } } else { [[nave]][i] = 0; floor1_Y_final[i] = predicted; } av_dlog(NULL, " Decoded floor(%d) = %u / val %u\n", vf->list[i].x, floor1_Y_final[i], val); } ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, [[nave]], vf->multiplier, vec, vf->list[1].x); av_dlog(NULL, " Floor decoded\n"); return 0; }
--------------------------------------------- Result 460 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 268 / 23 / 169 / 460:  17%|        | 460/2690 [4:21:27<21:07:32, 34.10s/it][Succeeded / Failed / Skipped / Total] 268 / 23 / 169 / 460:  17%|        | 461/2690 [4:21:28<21:04:15, 34.03s/it][Succeeded / Failed / Skipped / Total] 268 / 23 / 170 / 461:  17%|        | 461/2690 [4:21:28<21:04:15, 34.03s/it][Succeeded / Failed / Skipped / Total] 268 / 23 / 170 / 461:  17%|        | 462/2690 [4:22:02<21:03:43, 34.03s/it][Succeeded / Failed / Skipped / Total] 268 / 24 / 170 / 462:  17%|        | 462/2690 [4:22:02<21:03:43, 34.03s/it][Succeeded / Failed / Skipped / Total] 268 / 24 / 170 / 462:  17%|        | 463/2690 [4:22:06<21:00:43, 33.97s/it][Succeeded / Failed / Skipped / Total] 269 / 24 / 170 / 463:  17%|        | 463/2690 [4:22:06<21:00:43, 33.97s/it][Succeeded / Failed / Skipped / Total] 269 / 24 / 170 / 463:  17%|        | 464/2690 [4:22:22<20:58:43, 33.93s/it][Succeeded / Failed / Skipped / Total] 270 / 24 / 170 / 464:  17%|        | 464/2690 [4:22:22<20:58:43, 33.93s/it][Succeeded / Failed / Skipped / Total] 270 / 24 / 170 / 464:  17%|        | 465/2690 [4:22:23<20:55:29, 33.86s/it][Succeeded / Failed / Skipped / Total] 270 / 24 / 171 / 465:  17%|        | 465/2690 [4:22:23<20:55:29, 33.86s/it][Succeeded / Failed / Skipped / Total] 270 / 24 / 171 / 465:  17%|        | 466/2690 [4:22:30<20:52:50, 33.80s/it][[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void pc_init1(QEMUMachineInitArgs *args, int pci_enabled, int kvmclock_enabled) { MemoryRegion *system_memory = get_system_memory(); MemoryRegion *system_io = get_system_io(); int i; ram_addr_t below_4g_mem_size, above_4g_mem_size; PCIBus *pci_bus; ISABus *isa_bus; PCII440FXState *i440fx_state; int piix3_devfn = -1; qemu_irq *cpu_irq; qemu_irq *gsi; qemu_irq *i8259; qemu_irq *smi_irq; GSIState *gsi_state; DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; BusState *idebus[MAX_IDE_BUS]; ISADevice *rtc_state; ISADevice *floppy; MemoryRegion *ram_memory; MemoryRegion *pci_memory; MemoryRegion *rom_memory; DeviceState *icc_bridge; FWCfgState *fw_cfg = NULL; PcGuestInfo *guest_info; if (xen_enabled() && xen_hvm_init(&ram_memory) != 0) { fprintf(stderr, "xen hardware virtual machine initialisation failed\n"); exit(1); } icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE); object_property_add_child(qdev_get_machine(), "icc-bridge", OBJECT(icc_bridge), NULL); pc_cpus_init(args->cpu_model, icc_bridge); if (kvm_enabled() && kvmclock_enabled) { kvmclock_create(); } if (args->ram_size >= 0xe0000000) { ram_addr_t lowmem = gigabyte_align ? 0xc0000000 : 0xe0000000; above_4g_mem_size = args->ram_size - lowmem; below_4g_mem_size = lowmem; } else { above_4g_mem_size = 0; below_4g_mem_size = args->ram_size; } if (pci_enabled) { pci_memory = g_new(MemoryRegion, 1); memory_region_init(pci_memory, NULL, "pci", UINT64_MAX); rom_memory = pci_memory; } else { pci_memory = NULL; rom_memory = system_memory; } guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size); guest_info->has_acpi_build = has_acpi_build; guest_info->has_pci_info = has_pci_info; guest_info->isapc_ram_fw = !pci_enabled; if (smbios_defaults) { smbios_set_defaults("QEMU", "Standard PC (i440FX + PIIX, 1996)", args->machine->name); } if (!xen_enabled()) { fw_cfg = pc_memory_init(system_memory, args->kernel_filename, args->kernel_cmdline, args->initrd_filename, below_4g_mem_size, above_4g_mem_size, rom_memory, &ram_memory, guest_info); } gsi_state = g_malloc0(sizeof(*gsi_state)); if (kvm_irqchip_in_kernel()) { kvm_pc_setup_irq_routing(pci_enabled); gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state, GSI_NUM_PINS); } else { gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS); } if (pci_enabled) { pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi, system_memory, system_io, args->ram_size, below_4g_mem_size, above_4g_mem_size, pci_memory, ram_memory); } else { pci_bus = NULL; i440fx_state = NULL; isa_bus = isa_bus_new(NULL, system_io); no_hpet = 1; } isa_bus_irqs(isa_bus, gsi); if (kvm_irqchip_in_kernel()) { i8259 = kvm_i8259_init(isa_bus); } else if (xen_enabled()) { i8259 = xen_interrupt_controller_init(); } else { cpu_irq = pc_allocate_cpu_irq(); i8259 = i8259_init(isa_bus, cpu_irq[0]); } for (i = 0; i < ISA_NUM_IRQS; i++) { gsi_state->i8259_irq[i] = i8259[i]; } if (pci_enabled) { ioapic_init_gsi(gsi_state, "i440fx"); } qdev_init_nofail(icc_bridge); pc_register_ferr_irq(gsi[13]); pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL); pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, xen_enabled(), 0x4); pc_nic_init(isa_bus, pci_bus); ide_drive_get(hd, MAX_IDE_BUS); if (pci_enabled) { PCIDevice *dev; if (xen_enabled()) { dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1); } else { dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1); } idebus[0] = qdev_get_child_bus(&dev->qdev, "ide.0"); idebus[1] = qdev_get_child_bus(&dev->qdev, "ide.1"); } else { for(i = 0; i < MAX_IDE_BUS; i++) { ISADevice *dev; char busname[] = "ide.0"; dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i], ide_irq[i], hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]); busname[4] = '0' + i; idebus[i] = qdev_get_child_bus(DEVICE(dev), busname); } } pc_cmos_init(below_4g_mem_size, above_4g_mem_size, args->boot_order, floppy, idebus[0], idebus[1], rtc_state); if (pci_enabled && usb_enabled("False" != "False")) { pci_create_simple(pci_bus, piix3_devfn + 2, "piix3-usb-uhci"); } if (pci_enabled && acpi_enabled) { I2CBus *smbus; smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1); smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100, gsi[9], *smi_irq, kvm_enabled(), fw_cfg); smbus_eeprom_init(smbus, 8, NULL, 0); } if (pci_enabled) { pc_pci_device_init(pci_bus); } }
--------------------------------------------- Result 461 ---------------------------------------------
[[0 (77%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: uint32_t wm8750_adc_dat(void *opaque) { WM8750State *s = (WM8750State *) opaque; uint32_t *data; if (s->idx_in >= sizeof(s->data_in)) wm8750_in_load(s); data = (uint32_t *) &s->data_in[s->idx_in]; s->req_in -= 4; s->idx_in += 4; return *data; }
--------------------------------------------- Result 462 ---------------------------------------------
[[0 (5%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static QmpInputVisitor *to_qiv(Visitor *v) { return container_of(v, QmpInputVisitor, visitor); }

[[[[Adv]]]]: static QmpInputVisitor *to_qiv(Visitor *v) { return container_of(v, QmpInputVisitor, visitor); }
--------------------------------------------- Result 463 ---------------------------------------------
[[0 (38%)]] --> [[0 (53%)]] --> Socre: 0.5300366878509521

[[[[Adv]]]]: static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt) { #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS struct video_data *s = s1->priv_data; AVFrame *[[frame]] = s1->streams[0]->codec->coded_frame; FF_ENABLE_DEPRECATION_WARNINGS #endif int res; av_init_packet(pkt); if ((res = mmap_read_frame(s1, pkt)) < 0) { return res; } #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS if ([[frame]] && s->interlaced) { [[frame]]->interlaced_frame = 1; [[frame]]->top_field_first = s->top_field_first; } FF_ENABLE_DEPRECATION_WARNINGS #endif return pkt->size; }

[[[[Adv]]]]: static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt) { #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS struct video_data *s = s1->priv_data; AVFrame *[[layout]] = s1->streams[0]->codec->coded_frame; FF_ENABLE_DEPRECATION_WARNINGS #endif int res; av_init_packet(pkt); if ((res = mmap_read_frame(s1, pkt)) < 0) { return res; } #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS if ([[layout]] && s->interlaced) { [[layout]]->interlaced_frame = 1; [[layout]]->top_field_first = s->top_field_first; } FF_ENABLE_DEPRECATION_WARNINGS #endif return pkt->size; }
--------------------------------------------- Result 464 ---------------------------------------------
[[0 (96%)]] --> [[0 (47%)]] --> Socre: 0.531172901391983

[[[[Adv]]]]: static void bonito_pcihost_class_init(ObjectClass *klass, void *[[data]]) { DeviceClass *dc = DEVICE_CLASS(klass); SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass); k->init = bonito_pcihost_initfn; dc->no_user = 1; }

[[[[Adv]]]]: static void bonito_pcihost_class_init(ObjectClass *klass, void *[[detail]]) { DeviceClass *dc = DEVICE_CLASS(klass); SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass); k->init = bonito_pcihost_initfn; dc->no_user = 1; }
--------------------------------------------- Result 465 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) { uint32_t v, spf; MPADecodeHeader c; int vbrtag_size = 0; MP3DecContext *mp3 = s->priv_data; ffio_init_checksum(s->pb, ff_crcA001_update, 0); v = avio_rb32(s->pb); if(ff_mpa_check_header(v) < 0) return -1; if (avpriv_mpegaudio_decode_header(&c, v) == 0) vbrtag_size = c.frame_size; if(c.layer != 3) return -1; spf = c.lsf ? 576 : 1152; mp3->frames = 0; mp3->size = 0; mp3_parse_info_tag(s, st, &c, spf); mp3_parse_vbri_tag(s, st, base); if (!mp3->frames && !mp3->size) return -1; avio_seek(s->pb, base + vbrtag_size, SEEK_SET); if (mp3->frames) st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate}, st->time_base); if (mp3->size && mp3->frames && !mp3->is_cbr) st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf); return 0; }
--------------------------------------------- Result 466 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 271 / 24 / 171 / 466:  17%|        | 466/2690 [4:22:30<20:52:50, 33.80s/it][Succeeded / Failed / Skipped / Total] 271 / 24 / 171 / 466:  17%|        | 467/2690 [4:22:37<20:50:07, 33.74s/it][Succeeded / Failed / Skipped / Total] 272 / 24 / 171 / 467:  17%|        | 467/2690 [4:22:37<20:50:07, 33.74s/it][Succeeded / Failed / Skipped / Total] 272 / 24 / 171 / 467:  17%|        | 468/2690 [4:22:47<20:47:41, 33.69s/it][[0 (1%)]] --> [[0 (89%)]] --> Socre: 0.8903273940086365

[[[[Adv]]]]: void memory_region_iommu_replay_all(MemoryRegion *[[mr]]) { IOMMUNotifier *notifier; IOMMU_NOTIFIER_FOREACH(notifier, mr) { memory_region_iommu_replay([[mr]], notifier, "False" != "False"); } }

[[[[Adv]]]]: void memory_region_iommu_replay_all(MemoryRegion *[[jrgen]]) { IOMMUNotifier *notifier; IOMMU_NOTIFIER_FOREACH(notifier, mr) { memory_region_iommu_replay([[jrgen]], notifier, "False" != "False"); } }
--------------------------------------------- Result 467 ---------------------------------------------
[[0 (5%)]] --> [[0 (56%)]] --> Socre: 0.5607489347457886

[[[[Adv]]]]: static int usb_uhci_piix3_initfn(PCIDevice *dev) { UHCIState *s = DO_UPCAST(UHCIState, dev, dev); uint8_t *[[pci_conf]] = s->dev.config; pci_config_set_vendor_id([[pci_conf]], PCI_VENDOR_ID_INTEL); pci_config_set_device_id([[pci_conf]], PCI_DEVICE_ID_INTEL_82371SB_2); return usb_uhci_common_initfn(s); }

[[[[Adv]]]]: static int usb_uhci_piix3_initfn(PCIDevice *dev) { UHCIState *s = DO_UPCAST(UHCIState, dev, dev); uint8_t *[[consolidated]] = s->dev.config; pci_config_set_vendor_id([[consolidated]], PCI_VENDOR_ID_INTEL); pci_config_set_device_id([[consolidated]], PCI_DEVICE_ID_INTEL_82371SB_2); return usb_uhci_common_initfn(s); }
--------------------------------------------- Result 468 ---------------------------------------------
[[0 (49%)]] --> [[0 (54%)]] --> Socre: 0.5438423752784729

[[[[Adv]]]]: static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service) { MpegTSWrite *ts = s->priv_data; uint8_t data[1012], *q, *desc_length_ptr, *program_info_length_ptr; int val, stream_type, i; q = data; put16(&q, 0xe000 | service->pcr_pid); program_info_length_ptr = q; q += 2; val = 0xf000 | (q - program_info_length_ptr - 2); program_info_length_ptr[0] = val >> 8; program_info_length_ptr[1] = val; for(i = 0; i < s->nb_streams; i++) { AVStream *st = s->streams[i]; MpegTSWriteStream *[[ts_st]] = st->priv_data; AVDictionaryEntry *lang = av_dict_get(st->metadata, "language", NULL,0); switch(st->codec->codec_id) { case AV_CODEC_ID_MPEG1VIDEO: case AV_CODEC_ID_MPEG2VIDEO: stream_type = STREAM_TYPE_VIDEO_MPEG2; break; case AV_CODEC_ID_MPEG4: stream_type = STREAM_TYPE_VIDEO_MPEG4; break; case AV_CODEC_ID_H264: stream_type = STREAM_TYPE_VIDEO_H264; break; case AV_CODEC_ID_CAVS: stream_type = STREAM_TYPE_VIDEO_CAVS; break; case AV_CODEC_ID_DIRAC: stream_type = STREAM_TYPE_VIDEO_DIRAC; break; case AV_CODEC_ID_MP2: case AV_CODEC_ID_MP3: stream_type = STREAM_TYPE_AUDIO_MPEG1; break; case AV_CODEC_ID_AAC: stream_type = (ts->flags & MPEGTS_FLAG_AAC_LATM) ? STREAM_TYPE_AUDIO_AAC_LATM : STREAM_TYPE_AUDIO_AAC; break; case AV_CODEC_ID_AAC_LATM: stream_type = STREAM_TYPE_AUDIO_AAC_LATM; break; case AV_CODEC_ID_AC3: stream_type = STREAM_TYPE_AUDIO_AC3; break; default: stream_type = STREAM_TYPE_PRIVATE_DATA; break; } *q++ = stream_type; put16(&q, 0xe000 | [[ts_st]]->pid); desc_length_ptr = q; q += 2; switch(st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: if(st->codec->codec_id==AV_CODEC_ID_EAC3){ *q++=0x7a; *q++=1; *q++=0; } if(st->codec->codec_id==AV_CODEC_ID_S302M){ *q++ = 0x05; *q++ = 4; *q++ = 'B'; *q++ = 'S'; *q++ = 'S'; *q++ = 'D'; } if (lang) { char *p; char *next = lang->value; uint8_t *len_ptr; *q++ = 0x0a; len_ptr = q++; *len_ptr = 0; for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) { next = strchr(p, ','); if (strlen(p) != 3 && (!next || next != p + 3)) continue; *q++ = *p++; *q++ = *p++; *q++ = *p++; if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS) *q++ = 0x01; else if (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) *q++ = 0x02; else if (st->disposition & AV_DISPOSITION_VISUAL_IMPAIRED) *q++ = 0x03; else *q++ = 0; *len_ptr += 4; } if (*len_ptr == 0) q -= 2; } break; case AVMEDIA_TYPE_SUBTITLE: { const char default_language[] = "und"; const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language; if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) { uint8_t *len_ptr; int extradata_copied = 0; *q++ = 0x59; len_ptr = q++; while (strlen(language) >= 3 && (sizeof(data) - (q - data)) >= 8) { *q++ = *language++; *q++ = *language++; *q++ = *language++; if (*language != '\0') language++; if (st->codec->extradata_size - extradata_copied >= 5) { *q++ = st->codec->extradata[extradata_copied + 4]; memcpy(q, st->codec->extradata + extradata_copied, 4); extradata_copied += 5; q += 4; } else { *q++ = (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10; if ((st->codec->extradata_size == 4) && (extradata_copied == 0)) { memcpy(q, st->codec->extradata, 4); extradata_copied += 4; q += 4; } else { put16(&q, 1); put16(&q, 1); } } } *len_ptr = q - len_ptr - 1; } else if (st->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) { uint8_t *len_ptr = NULL; int extradata_copied = 0; *q++ = 0x56; len_ptr = q++; while (strlen(language) >= 3) { *q++ = *language++; *q++ = *language++; *q++ = *language++; if (*language != '\0') language++; if (st->codec->extradata_size - 1 > extradata_copied) { memcpy(q, st->codec->extradata + extradata_copied, 2); extradata_copied += 2; q += 2; } else { *q++ = 0x08; *q++ = 0x00; } } *len_ptr = q - len_ptr - 1; } } break; case AVMEDIA_TYPE_VIDEO: if (stream_type == STREAM_TYPE_VIDEO_DIRAC) { *q++ = 0x05; *q++ = 4; *q++ = 'd'; *q++ = 'r'; *q++ = 'a'; *q++ = 'c'; } break; case AVMEDIA_TYPE_DATA: if (st->codec->codec_id == AV_CODEC_ID_SMPTE_KLV) { *q++ = 0x05; *q++ = 4; *q++ = 'K'; *q++ = 'L'; *q++ = 'V'; *q++ = 'A'; } break; } val = 0xf000 | (q - desc_length_ptr - 2); desc_length_ptr[0] = val >> 8; desc_length_ptr[1] = val; } mpegts_write_section1(&service->pmt, PMT_TID, service->sid, ts->tables_version, 0, 0, data, q - data); }

[[[[Adv]]]]: static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service) { MpegTSWrite *ts = s->priv_data; uint8_t data[1012], *q, *desc_length_ptr, *program_info_length_ptr; int val, stream_type, i; q = data; put16(&q, 0xe000 | service->pcr_pid); program_info_length_ptr = q; q += 2; val = 0xf000 | (q - program_info_length_ptr - 2); program_info_length_ptr[0] = val >> 8; program_info_length_ptr[1] = val; for(i = 0; i < s->nb_streams; i++) { AVStream *st = s->streams[i]; MpegTSWriteStream *[[nowt]] = st->priv_data; AVDictionaryEntry *lang = av_dict_get(st->metadata, "language", NULL,0); switch(st->codec->codec_id) { case AV_CODEC_ID_MPEG1VIDEO: case AV_CODEC_ID_MPEG2VIDEO: stream_type = STREAM_TYPE_VIDEO_MPEG2; break; case AV_CODEC_ID_MPEG4: stream_type = STREAM_TYPE_VIDEO_MPEG4; break; case AV_CODEC_ID_H264: stream_type = STREAM_TYPE_VIDEO_H264; break; case AV_CODEC_ID_CAVS: stream_type = STREAM_TYPE_VIDEO_CAVS; break; case AV_CODEC_ID_DIRAC: stream_type = STREAM_TYPE_VIDEO_DIRAC; break; case AV_CODEC_ID_MP2: case AV_CODEC_ID_MP3: stream_type = STREAM_TYPE_AUDIO_MPEG1; break; case AV_CODEC_ID_AAC: stream_type = (ts->flags & MPEGTS_FLAG_AAC_LATM) ? STREAM_TYPE_AUDIO_AAC_LATM : STREAM_TYPE_AUDIO_AAC; break; case AV_CODEC_ID_AAC_LATM: stream_type = STREAM_TYPE_AUDIO_AAC_LATM; break; case AV_CODEC_ID_AC3: stream_type = STREAM_TYPE_AUDIO_AC3; break; default: stream_type = STREAM_TYPE_PRIVATE_DATA; break; } *q++ = stream_type; put16(&q, 0xe000 | [[nowt]]->pid); desc_length_ptr = q; q += 2; switch(st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: if(st->codec->codec_id==AV_CODEC_ID_EAC3){ *q++=0x7a; *q++=1; *q++=0; } if(st->codec->codec_id==AV_CODEC_ID_S302M){ *q++ = 0x05; *q++ = 4; *q++ = 'B'; *q++ = 'S'; *q++ = 'S'; *q++ = 'D'; } if (lang) { char *p; char *next = lang->value; uint8_t *len_ptr; *q++ = 0x0a; len_ptr = q++; *len_ptr = 0; for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) { next = strchr(p, ','); if (strlen(p) != 3 && (!next || next != p + 3)) continue; *q++ = *p++; *q++ = *p++; *q++ = *p++; if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS) *q++ = 0x01; else if (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) *q++ = 0x02; else if (st->disposition & AV_DISPOSITION_VISUAL_IMPAIRED) *q++ = 0x03; else *q++ = 0; *len_ptr += 4; } if (*len_ptr == 0) q -= 2; } break; case AVMEDIA_TYPE_SUBTITLE: { const char default_language[] = "und"; const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language; if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) { uint8_t *len_ptr; int extradata_copied = 0; *q++ = 0x59; len_ptr = q++; while (strlen(language) >= 3 && (sizeof(data) - (q - data)) >= 8) { *q++ = *language++; *q++ = *language++; *q++ = *language++; if (*language != '\0') language++; if (st->codec->extradata_size - extradata_copied >= 5) { *q++ = st->codec->extradata[extradata_copied + 4]; memcpy(q, st->codec->extradata + extradata_copied, 4); extradata_copied += 5; q += 4; } else { *q++ = (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10; if ((st->codec->extradata_size == 4) && (extradata_copied == 0)) { memcpy(q, st->codec->extradata, 4); extradata_copied += 4; q += 4; } else { put16(&q, 1); put16(&q, 1); } } } *len_ptr = q - len_ptr - 1; } else if (st->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) { uint8_t *len_ptr = NULL; int extradata_copied = 0; *q++ = 0x56; len_ptr = q++; while (strlen(language) >= 3) { *q++ = *language++; *q++ = *language++; *q++ = *language++; if (*language != '\0') language++; if (st->codec->extradata_size - 1 > extradata_copied) { memcpy(q, st->codec->extradata + extradata_copied, 2); extradata_copied += 2; q += 2; } else { *q++ = 0x08; *q++ = 0x00; } } *len_ptr = q - len_ptr - 1; } } break; case AVMEDIA_TYPE_VIDEO: if (stream_type == STREAM_TYPE_VIDEO_DIRAC) { *q++ = 0x05; *q++ = 4; *q++ = 'd'; *q++ = 'r'; *q++ = 'a'; *q++ = 'c'; } break; case AVMEDIA_TYPE_DATA: if (st->codec->codec_id == AV_CODEC_ID_SMPTE_KLV) { *q++ = 0x05; *q++ = 4; *q++ = 'K'; *q++ = 'L'; *q++ = 'V'; *q++ = 'A'; } break; } val = 0xf000 | (q - desc_length_ptr - 2); desc_length_ptr[0] = val >> 8; desc_length_ptr[1] = val; } mpegts_write_section1(&service->pmt, PMT_TID, service->sid, ts->tables_version, 0, 0, data, q - data); }[Succeeded / Failed / Skipped / Total] 273 / 24 / 171 / 468:  17%|        | 468/2690 [4:22:47<20:47:41, 33.69s/it][Succeeded / Failed / Skipped / Total] 273 / 24 / 171 / 468:  17%|        | 469/2690 [4:23:13<20:46:32, 33.68s/it][Succeeded / Failed / Skipped / Total] 274 / 24 / 171 / 469:  17%|        | 469/2690 [4:23:13<20:46:32, 33.68s/it][Succeeded / Failed / Skipped / Total] 274 / 24 / 171 / 469:  17%|        | 470/2690 [4:23:21<20:43:56, 33.62s/it][Succeeded / Failed / Skipped / Total] 274 / 25 / 171 / 470:  17%|        | 470/2690 [4:23:21<20:43:56, 33.62s/it][Succeeded / Failed / Skipped / Total] 274 / 25 / 171 / 470:  18%|        | 471/2690 [4:23:22<20:40:49, 33.55s/it]
--------------------------------------------- Result 469 ---------------------------------------------
[[0 (3%)]] --> [[0 (55%)]] --> Socre: 0.5492586493492126

[[[[Adv]]]]: static unsigned int dec_addi_r(DisasContext *dc) { TCGv [[t0]]; DIS(fprintf (logfile, "addi.%c $r%u, $r%u\n", memsize_char(memsize_zz(dc)), dc->op2, dc->op1)); cris_cc_mask(dc, 0); [[t0]] = tcg_temp_new(TCG_TYPE_TL); tcg_gen_shl_tl([[t0]], cpu_R[dc->op2], tcg_const_tl(dc->zzsize)); tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], [[t0]]); tcg_temp_free([[t0]]); return 2; }

[[[[Adv]]]]: static unsigned int dec_addi_r(DisasContext *dc) { TCGv [[grampa]]; DIS(fprintf (logfile, "addi.%c $r%u, $r%u\n", memsize_char(memsize_zz(dc)), dc->op2, dc->op1)); cris_cc_mask(dc, 0); [[grampa]] = tcg_temp_new(TCG_TYPE_TL); tcg_gen_shl_tl([[grampa]], cpu_R[dc->op2], tcg_const_tl(dc->zzsize)); tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], [[grampa]]); tcg_temp_free([[grampa]]); return 2; }
--------------------------------------------- Result 470 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int smacker_read_header(AVFormatContext *s) { AVIOContext *pb = s->pb; SmackerContext *smk = s->priv_data; AVStream *st, *ast[7]; int i, ret; int tbase; smk->magic = avio_rl32(pb); if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4')) smk->width = avio_rl32(pb); smk->height = avio_rl32(pb); smk->frames = avio_rl32(pb); smk->pts_inc = (int32_t)avio_rl32(pb); smk->flags = avio_rl32(pb); if(smk->flags & SMACKER_FLAG_RING_FRAME) smk->frames++; for(i = 0; i < 7; i++) smk->audio[i] = avio_rl32(pb); smk->treesize = avio_rl32(pb); if(smk->treesize >= UINT_MAX/4){ av_log(s, AV_LOG_ERROR, "treesize too large\n"); smk->mmap_size = avio_rl32(pb); smk->mclr_size = avio_rl32(pb); smk->full_size = avio_rl32(pb); smk->type_size = avio_rl32(pb); for(i = 0; i < 7; i++) { smk->rates[i] = avio_rl24(pb); smk->aflags[i] = avio_r8(pb); smk->pad = avio_rl32(pb); if(smk->frames > 0xFFFFFF) { av_log(s, AV_LOG_ERROR, "Too many frames: %"PRIu32"\n", smk->frames); smk->frm_size = av_malloc_array(smk->frames, sizeof(*smk->frm_size)); smk->frm_flags = av_malloc(smk->frames); if (!smk->frm_size || !smk->frm_flags) { av_freep(&smk->frm_size); av_freep(&smk->frm_flags); return AVERROR(ENOMEM); smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2')); for(i = 0; i < smk->frames; i++) { smk->frm_size[i] = avio_rl32(pb); for(i = 0; i < smk->frames; i++) { smk->frm_flags[i] = avio_r8(pb); st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); smk->videoindex = st->index; st->codec->width = smk->width; st->codec->height = smk->height; st->codec->pix_fmt = AV_PIX_FMT_PAL8; st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->codec->codec_id = AV_CODEC_ID_SMACKVIDEO; st->codec->codec_tag = smk->magic; if(smk->pts_inc < 0) smk->pts_inc = -smk->pts_inc; else smk->pts_inc *= 100; tbase = 100000; av_reduce(&tbase, &smk->pts_inc, tbase, smk->pts_inc, (1UL<<31)-1); avpriv_set_pts_info(st, 33, smk->pts_inc, tbase); st->duration = smk->frames; for(i = 0; i < 7; i++) { smk->indexes[i] = -1; if (smk->rates[i]) { ast[i] = avformat_new_stream(s, NULL); if (!ast[i]) return AVERROR(ENOMEM); smk->indexes[i] = ast[i]->index; ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO; if (smk->aflags[i] & SMK_AUD_BINKAUD) { ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT; } else if (smk->aflags[i] & SMK_AUD_USEDCT) { ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT; } else if (smk->aflags[i] & SMK_AUD_PACKED){ ast[i]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO; ast[i]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A'); } else { ast[i]->codec->codec_id = AV_CODEC_ID_PCM_U8; if (smk->aflags[i] & SMK_AUD_STEREO) { ast[i]->codec->channels = 2; ast[i]->codec->channel_layout = AV_CH_LAYOUT_STEREO; } else { ast[i]->codec->channels = 1; ast[i]->codec->channel_layout = AV_CH_LAYOUT_MONO; ast[i]->codec->sample_rate = smk->rates[i]; ast[i]->codec->bits_per_coded_sample = (smk->aflags[i] & SMK_AUD_16BITS) ? 16 : 8; if(ast[i]->codec->bits_per_coded_sample == 16 && ast[i]->codec->codec_id == AV_CODEC_ID_PCM_U8) ast[i]->codec->codec_id = AV_CODEC_ID_PCM_S16LE; avpriv_set_pts_info(ast[i], 64, 1, ast[i]->codec->sample_rate * ast[i]->codec->channels * ast[i]->codec->bits_per_coded_sample / 8); if(ff_alloc_extradata(st->codec, smk->treesize + 16)){ av_log(s, AV_LOG_ERROR, "Cannot allocate %"PRIu32" bytes of extradata\n", smk->treesize + 16); av_freep(&smk->frm_size); av_freep(&smk->frm_flags); return AVERROR(ENOMEM); ret = avio_read(pb, st->codec->extradata + 16, st->codec->extradata_size - 16); if(ret != st->codec->extradata_size - 16){ av_freep(&smk->frm_size); av_freep(&smk->frm_flags); return AVERROR(EIO); ((int32_t*)st->codec->extradata)[0] = av_le2ne32(smk->mmap_size); ((int32_t*)st->codec->extradata)[1] = av_le2ne32(smk->mclr_size); ((int32_t*)st->codec->extradata)[2] = av_le2ne32(smk->full_size); ((int32_t*)st->codec->extradata)[3] = av_le2ne32(smk->type_size); smk->curstream = -1; smk->nextpos = avio_tell(pb); return 0;

[[[[Adv]]]]: static int smacker_read_header(AVFormatContext *s) { AVIOContext *pb = s->pb; SmackerContext *smk = s->priv_data; AVStream *st, *ast[7]; int i, ret; int tbase; smk->magic = avio_rl32(pb); if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4')) smk->width = avio_rl32(pb); smk->height = avio_rl32(pb); smk->frames = avio_rl32(pb); smk->pts_inc = (int32_t)avio_rl32(pb); smk->flags = avio_rl32(pb); if(smk->flags & SMACKER_FLAG_RING_FRAME) smk->frames++; for(i = 0; i < 7; i++) smk->audio[i] = avio_rl32(pb); smk->treesize = avio_rl32(pb); if(smk->treesize >= UINT_MAX/4){ av_log(s, AV_LOG_ERROR, "treesize too large\n"); smk->mmap_size = avio_rl32(pb); smk->mclr_size = avio_rl32(pb); smk->full_size = avio_rl32(pb); smk->type_size = avio_rl32(pb); for(i = 0; i < 7; i++) { smk->rates[i] = avio_rl24(pb); smk->aflags[i] = avio_r8(pb); smk->pad = avio_rl32(pb); if(smk->frames > 0xFFFFFF) { av_log(s, AV_LOG_ERROR, "Too many frames: %"PRIu32"\n", smk->frames); smk->frm_size = av_malloc_array(smk->frames, sizeof(*smk->frm_size)); smk->frm_flags = av_malloc(smk->frames); if (!smk->frm_size || !smk->frm_flags) { av_freep(&smk->frm_size); av_freep(&smk->frm_flags); return AVERROR(ENOMEM); smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2')); for(i = 0; i < smk->frames; i++) { smk->frm_size[i] = avio_rl32(pb); for(i = 0; i < smk->frames; i++) { smk->frm_flags[i] = avio_r8(pb); st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); smk->videoindex = st->index; st->codec->width = smk->width; st->codec->height = smk->height; st->codec->pix_fmt = AV_PIX_FMT_PAL8; st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->codec->codec_id = AV_CODEC_ID_SMACKVIDEO; st->codec->codec_tag = smk->magic; if(smk->pts_inc < 0) smk->pts_inc = -smk->pts_inc; else smk->pts_inc *= 100; tbase = 100000; av_reduce(&tbase, &smk->pts_inc, tbase, smk->pts_inc, (1UL<<31)-1); avpriv_set_pts_info(st, 33, smk->pts_inc, tbase); st->duration = smk->frames; for(i = 0; i < 7; i++) { smk->indexes[i] = -1; if (smk->rates[i]) { ast[i] = avformat_new_stream(s, NULL); if (!ast[i]) return AVERROR(ENOMEM); smk->indexes[i] = ast[i]->index; ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO; if (smk->aflags[i] & SMK_AUD_BINKAUD) { ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT; } else if (smk->aflags[i] & SMK_AUD_USEDCT) { ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT; } else if (smk->aflags[i] & SMK_AUD_PACKED){ ast[i]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO; ast[i]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A'); } else { ast[i]->codec->codec_id = AV_CODEC_ID_PCM_U8; if (smk->aflags[i] & SMK_AUD_STEREO) { ast[i]->codec->channels = 2; ast[i]->codec->channel_layout = AV_CH_LAYOUT_STEREO; } else { ast[i]->codec->channels = 1; ast[i]->codec->channel_layout = AV_CH_LAYOUT_MONO; ast[i]->codec->sample_rate = smk->rates[i]; ast[i]->codec->bits_per_coded_sample = (smk->aflags[i] & SMK_AUD_16BITS) ? 16 : 8; if(ast[i]->codec->bits_per_coded_sample == 16 && ast[i]->codec->codec_id == AV_CODEC_ID_PCM_U8) ast[i]->codec->codec_id = AV_CODEC_ID_PCM_S16LE; avpriv_set_pts_info(ast[i], 64, 1, ast[i]->codec->sample_rate * ast[i]->codec->channels * ast[i]->codec->bits_per_coded_sample / 8); if(ff_alloc_extradata(st->codec, smk->treesize + 16)){ av_log(s, AV_LOG_ERROR, "Cannot allocate %"PRIu32" bytes of extradata\n", smk->treesize + 16); av_freep(&smk->frm_size); av_freep(&smk->frm_flags); return AVERROR(ENOMEM); ret = avio_read(pb, st->codec->extradata + 16, st->codec->extradata_size - 16); if(ret != st->codec->extradata_size - 16){ av_freep(&smk->frm_size); av_freep(&smk->frm_flags); return AVERROR(EIO); ((int32_t*)st->codec->extradata)[0] = av_le2ne32(smk->mmap_size); ((int32_t*)st->codec->extradata)[1] = av_le2ne32(smk->mclr_size); ((int32_t*)st->codec->extradata)[2] = av_le2ne32(smk->full_size); ((int32_t*)st->codec->extradata)[3] = av_le2ne32(smk->type_size); smk->curstream = -1; smk->nextpos = avio_tell(pb); return 0;
--------------------------------------------- Result 471 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 275 / 25 / 171 / 471:  18%|        | 471/2690 [4:23:22<20:40:49, 33.55s/it][Succeeded / Failed / Skipped / Total] 275 / 25 / 171 / 471:  18%|        | 472/2690 [4:25:08<20:45:58, 33.71s/it][Succeeded / Failed / Skipped / Total] 276 / 25 / 171 / 472:  18%|        | 472/2690 [4:25:08<20:45:58, 33.71s/it][Succeeded / Failed / Skipped / Total] 276 / 25 / 171 / 472:  18%|        | 473/2690 [4:25:13<20:43:07, 33.64s/it][Succeeded / Failed / Skipped / Total] 277 / 25 / 171 / 473:  18%|        | 473/2690 [4:25:13<20:43:07, 33.64s/it][Succeeded / Failed / Skipped / Total] 277 / 25 / 171 / 473:  18%|        | 474/2690 [4:25:22<20:40:40, 33.59s/it][[0 (14%)]] --> [[0 (72%)]] --> Socre: 0.7150512337684631

[[[[Adv]]]]: static void gen_trap (DisasContext *ctx, uint32_t opc, int rs, int rt, int16_t imm) { int [[cond]]; TCGv t0 = tcg_temp_new(); TCGv t1 = tcg_temp_new(); [[cond]] = 0; switch (opc) { case OPC_TEQ: case OPC_TGE: case OPC_TGEU: case OPC_TLT: case OPC_TLTU: case OPC_TNE: if (rs != rt) { gen_load_gpr(t0, rs); gen_load_gpr(t1, rt); [[cond]] = 1; } break; case OPC_TEQI: case OPC_TGEI: case OPC_TGEIU: case OPC_TLTI: case OPC_TLTIU: case OPC_TNEI: if (rs != 0 || imm != 0) { gen_load_gpr(t0, rs); tcg_gen_movi_tl(t1, (int32_t)imm); [[cond]] = 1; } break; } if ([[cond]] == 0) { switch (opc) { case OPC_TEQ: case OPC_TEQI: case OPC_TGE: case OPC_TGEI: case OPC_TGEU: case OPC_TGEIU: generate_exception(ctx, EXCP_TRAP); break; case OPC_TLT: case OPC_TLTI: case OPC_TLTU: case OPC_TLTIU: case OPC_TNE: case OPC_TNEI: break; } } else { int l1 = gen_new_label(); switch (opc) { case OPC_TEQ: case OPC_TEQI: tcg_gen_brcond_tl(TCG_COND_NE, t0, t1, l1); break; case OPC_TGE: case OPC_TGEI: tcg_gen_brcond_tl(TCG_COND_LT, t0, t1, l1); break; case OPC_TGEU: case OPC_TGEIU: tcg_gen_brcond_tl(TCG_COND_LTU, t0, t1, l1); break; case OPC_TLT: case OPC_TLTI: tcg_gen_brcond_tl(TCG_COND_GE, t0, t1, l1); break; case OPC_TLTU: case OPC_TLTIU: tcg_gen_brcond_tl(TCG_COND_GEU, t0, t1, l1); break; case OPC_TNE: case OPC_TNEI: tcg_gen_brcond_tl(TCG_COND_EQ, t0, t1, l1); break; } generate_exception(ctx, EXCP_TRAP); gen_set_label(l1); } tcg_temp_free(t0); tcg_temp_free(t1); }

[[[[Adv]]]]: static void gen_trap (DisasContext *ctx, uint32_t opc, int rs, int rt, int16_t imm) { int [[ortiz]]; TCGv t0 = tcg_temp_new(); TCGv t1 = tcg_temp_new(); [[ortiz]] = 0; switch (opc) { case OPC_TEQ: case OPC_TGE: case OPC_TGEU: case OPC_TLT: case OPC_TLTU: case OPC_TNE: if (rs != rt) { gen_load_gpr(t0, rs); gen_load_gpr(t1, rt); [[ortiz]] = 1; } break; case OPC_TEQI: case OPC_TGEI: case OPC_TGEIU: case OPC_TLTI: case OPC_TLTIU: case OPC_TNEI: if (rs != 0 || imm != 0) { gen_load_gpr(t0, rs); tcg_gen_movi_tl(t1, (int32_t)imm); [[ortiz]] = 1; } break; } if ([[ortiz]] == 0) { switch (opc) { case OPC_TEQ: case OPC_TEQI: case OPC_TGE: case OPC_TGEI: case OPC_TGEU: case OPC_TGEIU: generate_exception(ctx, EXCP_TRAP); break; case OPC_TLT: case OPC_TLTI: case OPC_TLTU: case OPC_TLTIU: case OPC_TNE: case OPC_TNEI: break; } } else { int l1 = gen_new_label(); switch (opc) { case OPC_TEQ: case OPC_TEQI: tcg_gen_brcond_tl(TCG_COND_NE, t0, t1, l1); break; case OPC_TGE: case OPC_TGEI: tcg_gen_brcond_tl(TCG_COND_LT, t0, t1, l1); break; case OPC_TGEU: case OPC_TGEIU: tcg_gen_brcond_tl(TCG_COND_LTU, t0, t1, l1); break; case OPC_TLT: case OPC_TLTI: tcg_gen_brcond_tl(TCG_COND_GE, t0, t1, l1); break; case OPC_TLTU: case OPC_TLTIU: tcg_gen_brcond_tl(TCG_COND_GEU, t0, t1, l1); break; case OPC_TNE: case OPC_TNEI: tcg_gen_brcond_tl(TCG_COND_EQ, t0, t1, l1); break; } generate_exception(ctx, EXCP_TRAP); gen_set_label(l1); } tcg_temp_free(t0); tcg_temp_free(t1); }
--------------------------------------------- Result 472 ---------------------------------------------
[[0 (11%)]] --> [[0 (59%)]] --> Socre: 0.5885618329048157

[[[[Adv]]]]: static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset, unsigned size) { PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque; uint32_t ret; int [[bank]]; if (offset >= 0x200) return 0; [[bank]] = pxa2xx_gpio_regs[offset].bank; switch (pxa2xx_gpio_regs[offset].reg) { case GPDR: return s->dir[[[bank]]]; case GPSR: qemu_log_mask(LOG_GUEST_ERROR, "pxa2xx GPIO: read from write only register GPSR\n"); return 0; case GPCR: qemu_log_mask(LOG_GUEST_ERROR, "pxa2xx GPIO: read from write only register GPCR\n"); return 0; case GRER: return s->rising[[[bank]]]; case GFER: return s->falling[[[bank]]]; case GAFR_L: return s->gafr[[[bank]] * 2]; case GAFR_U: return s->gafr[[[bank]] * 2 + 1]; case GPLR: ret = (s->olevel[[[bank]]] & s->dir[[[bank]]]) | (s->ilevel[[[bank]]] & ~s->dir[[[bank]]]); qemu_irq_raise(s->read_notify); return ret; case GEDR: return s->status[[[bank]]]; default: hw_error("%s: Bad offset " REG_FMT "\n", __FUNCTION__, offset); } return 0; }

[[[[Adv]]]]: static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset, unsigned size) { PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque; uint32_t ret; int [[westerly]]; if (offset >= 0x200) return 0; [[westerly]] = pxa2xx_gpio_regs[offset].bank; switch (pxa2xx_gpio_regs[offset].reg) { case GPDR: return s->dir[[[westerly]]]; case GPSR: qemu_log_mask(LOG_GUEST_ERROR, "pxa2xx GPIO: read from write only register GPSR\n"); return 0; case GPCR: qemu_log_mask(LOG_GUEST_ERROR, "pxa2xx GPIO: read from write only register GPCR\n"); return 0; case GRER: return s->rising[[[westerly]]]; case GFER: return s->falling[[[westerly]]]; case GAFR_L: return s->gafr[[[westerly]] * 2]; case GAFR_U: return s->gafr[[[westerly]] * 2 + 1]; case GPLR: ret = (s->olevel[[[westerly]]] & s->dir[[[westerly]]]) | (s->ilevel[[[westerly]]] & ~s->dir[[[westerly]]]); qemu_irq_raise(s->read_notify); return ret; case GEDR: return s->status[[[westerly]]]; default: hw_error("%s: Bad offset " REG_FMT "\n", __FUNCTION__, offset); } return 0; }
--------------------------------------------- Result 473 ---------------------------------------------
[[0 (20%)]] --> [[0 (76%)]] --> Socre: 0.7639708518981934

[[[[Adv]]]]: static int64_t migration_set_rate_limit(void *[[opaque]], int64_t [[new_rate]]) { MigrationState *s = [[opaque]]; if (qemu_file_get_error(s->file)) { goto out; } s->xfer_limit = [[new_rate]]; out: return s->xfer_limit; }

[[[[Adv]]]]: static int64_t migration_set_rate_limit(void *[[blurred]], int64_t [[rexroth]]) { MigrationState *s = [[blurred]]; if (qemu_file_get_error(s->file)) { goto out; } s->xfer_limit = [[rexroth]]; out: return s->xfer_limit; }
--------------------------------------------- Result 474 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 278 / 25 / 171 / 474:  18%|        | 474/2690 [4:25:22<20:40:40, 33.59s/it][Succeeded / Failed / Skipped / Total] 278 / 25 / 171 / 474:  18%|        | 475/2690 [4:26:19<20:41:55, 33.64s/it][Succeeded / Failed / Skipped / Total] 279 / 25 / 171 / 475:  18%|        | 475/2690 [4:26:19<20:41:55, 33.64s/it][Succeeded / Failed / Skipped / Total] 279 / 25 / 171 / 475:  18%|        | 476/2690 [4:27:56<20:46:18, 33.78s/it][Succeeded / Failed / Skipped / Total] 280 / 25 / 171 / 476:  18%|        | 476/2690 [4:27:56<20:46:18, 33.78s/it][Succeeded / Failed / Skipped / Total] 280 / 25 / 171 / 476:  18%|        | 477/2690 [4:27:59<20:43:21, 33.71s/it][Succeeded / Failed / Skipped / Total] 281 / 25 / 171 / 477:  18%|        | 477/2690 [4:27:59<20:43:21, 33.71s/it][Succeeded / Failed / Skipped / Total] 281 / 25 / 171 / 477:  18%|        | 478/2690 [4:28:00<20:40:13, 33.64s/it][Succeeded / Failed / Skipped / Total] 281 / 25 / 172 / 478:  18%|        | 478/2690 [4:28:00<20:40:13, 33.64s/it][Succeeded / Failed / Skipped / Total] 281 / 25 / 172 / 478:  18%|        | 479/2690 [4:28:07<20:37:36, 33.58s/it][Succeeded / Failed / Skipped / Total] 282 / 25 / 172 / 479:  18%|        | 479/2690 [4:28:07<20:37:36, 33.58s/it][Succeeded / Failed / Skipped / Total] 282 / 25 / 172 / 479:  18%|        | 480/2690 [4:28:07<20:34:30, 33.52s/it][Succeeded / Failed / Skipped / Total] 282 / 25 / 173 / 480:  18%|        | 480/2690 [4:28:07<20:34:30, 33.52s/it][Succeeded / Failed / Skipped / Total] 282 / 25 / 173 / 480:  18%|        | 481/2690 [4:28:08<20:31:25, 33.45s/it][[0 (18%)]] --> [[0 (58%)]] --> Socre: 0.577619194984436

[[[[Adv]]]]: static void reverse_matrixing(float *su1, float *su2, int *prev_code, int *[[curr_code]]) { int i, nsample, band; float mc1_l, mc1_r, mc2_l, mc2_r; for (i = 0, band = 0; band < 4 * 256; band += 256, i++) { int s1 = prev_code[i]; int s2 = [[curr_code]][i]; nsample = 0; if (s1 != s2) { mc1_l = matrix_coeffs[s1 * 2 ]; mc1_r = matrix_coeffs[s1 * 2 + 1]; mc2_l = matrix_coeffs[s2 * 2 ]; mc2_r = matrix_coeffs[s2 * 2 + 1]; for (; nsample < 8; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) + c2 * INTERPOLATE(mc1_r, mc2_r, nsample); su1[band + nsample] = c2; su2[band + nsample] = c1 * 2.0 - c2; } } switch (s2) { case 0: for (; nsample < 256; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; su1[band + nsample] = c2 * 2.0; su2[band + nsample] = (c1 - c2) * 2.0; } break; case 1: for (; nsample < 256; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; su1[band + nsample] = (c1 + c2) * 2.0; su2[band + nsample] = c2 * -2.0; } break; case 2: case 3: for (; nsample < 256; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; su1[band + nsample] = c1 + c2; su2[band + nsample] = c1 - c2; } break; default: assert(0); } } }

[[[[Adv]]]]: static void reverse_matrixing(float *su1, float *su2, int *prev_code, int *[[valkyrie]]) { int i, nsample, band; float mc1_l, mc1_r, mc2_l, mc2_r; for (i = 0, band = 0; band < 4 * 256; band += 256, i++) { int s1 = prev_code[i]; int s2 = [[valkyrie]][i]; nsample = 0; if (s1 != s2) { mc1_l = matrix_coeffs[s1 * 2 ]; mc1_r = matrix_coeffs[s1 * 2 + 1]; mc2_l = matrix_coeffs[s2 * 2 ]; mc2_r = matrix_coeffs[s2 * 2 + 1]; for (; nsample < 8; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) + c2 * INTERPOLATE(mc1_r, mc2_r, nsample); su1[band + nsample] = c2; su2[band + nsample] = c1 * 2.0 - c2; } } switch (s2) { case 0: for (; nsample < 256; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; su1[band + nsample] = c2 * 2.0; su2[band + nsample] = (c1 - c2) * 2.0; } break; case 1: for (; nsample < 256; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; su1[band + nsample] = (c1 + c2) * 2.0; su2[band + nsample] = c2 * -2.0; } break; case 2: case 3: for (; nsample < 256; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; su1[band + nsample] = c1 + c2; su2[band + nsample] = c1 - c2; } break; default: assert(0); } } }
--------------------------------------------- Result 475 ---------------------------------------------
[[0 (6%)]] --> [[0 (98%)]] --> Socre: 0.9800394177436829

[[[[Adv]]]]: static void scsi_disk_reset(DeviceState *dev) { SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev); uint64_t [[nb_sectors]]; scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET)); bdrv_get_geometry(s->qdev.conf.bs, &[[nb_sectors]]); [[nb_sectors]] /= s->qdev.blocksize / 512; if ([[nb_sectors]]) { [[nb_sectors]]--; } s->qdev.max_lba = [[nb_sectors]]; s->tray_locked = 0; s->tray_open = 0; }

[[[[Adv]]]]: static void scsi_disk_reset(DeviceState *dev) { SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev); uint64_t [[tambin]]; scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET)); bdrv_get_geometry(s->qdev.conf.bs, &[[tambin]]); [[tambin]] /= s->qdev.blocksize / 512; if ([[tambin]]) { [[tambin]]--; } s->qdev.max_lba = [[tambin]]; s->tray_locked = 0; s->tray_open = 0; }
--------------------------------------------- Result 476 ---------------------------------------------
[[0 (64%)]] --> [[0 (48%)]] --> Socre: 0.5246350765228271

[[[[Adv]]]]: static int read_part_of_packet(AVFormatContext *s, int64_t *pts, int *len, int *strid, int read_packet) { AVIOContext *pb = s->pb; PVAContext *[[pvactx]] = s->priv_data; int [[syncword]], streamid, reserved, flags, length, pts_flag; int64_t pva_pts = AV_NOPTS_VALUE, startpos; int ret; recover: startpos = avio_tell(pb); [[syncword]] = avio_rb16(pb); streamid = avio_r8(pb); avio_r8(pb); reserved = avio_r8(pb); flags = avio_r8(pb); length = avio_rb16(pb); pts_flag = flags & 0x10; if ([[syncword]] != PVA_MAGIC) { pva_log(s, AV_LOG_ERROR, "invalid syncword\n"); return AVERROR(EIO); } if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) { pva_log(s, AV_LOG_ERROR, "invalid streamid\n"); return AVERROR(EIO); } if (reserved != 0x55) { pva_log(s, AV_LOG_WARNING, "expected reserved byte to be 0x55\n"); } if (length > PVA_MAX_PAYLOAD_LENGTH) { pva_log(s, AV_LOG_ERROR, "invalid payload length %u\n", length); return AVERROR(EIO); } if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) { pva_pts = avio_rb32(pb); length -= 4; } else if (streamid == PVA_AUDIO_PAYLOAD) { if (![[pvactx]]->continue_pes) { int pes_signal, pes_header_data_length, pes_packet_length, pes_flags; unsigned char pes_header_data[256]; pes_signal = avio_rb24(pb); avio_r8(pb); pes_packet_length = avio_rb16(pb); pes_flags = avio_rb16(pb); pes_header_data_length = avio_r8(pb); if (pes_signal != 1 || pes_header_data_length == 0) { pva_log(s, AV_LOG_WARNING, "expected non empty signaled PES packet, " "trying to recover\n"); avio_skip(pb, length - 9); if (!read_packet) return AVERROR(EIO); goto recover; } ret = avio_read(pb, pes_header_data, pes_header_data_length); if (ret != pes_header_data_length) return ret < 0 ? ret : AVERROR_INVALIDDATA; length -= 9 + pes_header_data_length; pes_packet_length -= 3 + pes_header_data_length; [[pvactx]]->continue_pes = pes_packet_length; if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) pva_pts = ff_parse_pes_pts(pes_header_data); } [[pvactx]]->continue_pes -= length; if ([[pvactx]]->continue_pes < 0) { pva_log(s, AV_LOG_WARNING, "audio data corruption\n"); [[pvactx]]->continue_pes = 0; } } if (pva_pts != AV_NOPTS_VALUE) av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME); *pts = pva_pts; *len = length; *strid = streamid; return 0; }

[[[[Adv]]]]: static int read_part_of_packet(AVFormatContext *s, int64_t *pts, int *len, int *strid, int read_packet) { AVIOContext *pb = s->pb; PVAContext *[[neely]] = s->priv_data; int [[vigorously]], streamid, reserved, flags, length, pts_flag; int64_t pva_pts = AV_NOPTS_VALUE, startpos; int ret; recover: startpos = avio_tell(pb); [[vigorously]] = avio_rb16(pb); streamid = avio_r8(pb); avio_r8(pb); reserved = avio_r8(pb); flags = avio_r8(pb); length = avio_rb16(pb); pts_flag = flags & 0x10; if ([[vigorously]] != PVA_MAGIC) { pva_log(s, AV_LOG_ERROR, "invalid syncword\n"); return AVERROR(EIO); } if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) { pva_log(s, AV_LOG_ERROR, "invalid streamid\n"); return AVERROR(EIO); } if (reserved != 0x55) { pva_log(s, AV_LOG_WARNING, "expected reserved byte to be 0x55\n"); } if (length > PVA_MAX_PAYLOAD_LENGTH) { pva_log(s, AV_LOG_ERROR, "invalid payload length %u\n", length); return AVERROR(EIO); } if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) { pva_pts = avio_rb32(pb); length -= 4; } else if (streamid == PVA_AUDIO_PAYLOAD) { if (![[neely]]->continue_pes) { int pes_signal, pes_header_data_length, pes_packet_length, pes_flags; unsigned char pes_header_data[256]; pes_signal = avio_rb24(pb); avio_r8(pb); pes_packet_length = avio_rb16(pb); pes_flags = avio_rb16(pb); pes_header_data_length = avio_r8(pb); if (pes_signal != 1 || pes_header_data_length == 0) { pva_log(s, AV_LOG_WARNING, "expected non empty signaled PES packet, " "trying to recover\n"); avio_skip(pb, length - 9); if (!read_packet) return AVERROR(EIO); goto recover; } ret = avio_read(pb, pes_header_data, pes_header_data_length); if (ret != pes_header_data_length) return ret < 0 ? ret : AVERROR_INVALIDDATA; length -= 9 + pes_header_data_length; pes_packet_length -= 3 + pes_header_data_length; [[neely]]->continue_pes = pes_packet_length; if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) pva_pts = ff_parse_pes_pts(pes_header_data); } [[neely]]->continue_pes -= length; if ([[neely]]->continue_pes < 0) { pva_log(s, AV_LOG_WARNING, "audio data corruption\n"); [[neely]]->continue_pes = 0; } } if (pva_pts != AV_NOPTS_VALUE) av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME); *pts = pva_pts; *len = length; *strid = streamid; return 0; }
--------------------------------------------- Result 477 ---------------------------------------------
[[0 (88%)]] --> [[0 (36%)]] --> Socre: 0.6374263763427734

[[[[Adv]]]]: static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){ int i; int [[dc0]]; [[dc0]]=0; for(i=0;i<8; i++) [[dc0]]+= src[i-stride]; [[dc0]]= 0x01010101*(([[dc0]] + 4)>>3); for(i=0; i<8; i++){ ((uint32_t*)(src+i*stride))[0]= ((uint32_t*)(src+i*stride))[1]= [[dc0]]; } }

[[[[Adv]]]]: static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){ int i; int [[jujitsu]]; [[jujitsu]]=0; for(i=0;i<8; i++) [[jujitsu]]+= src[i-stride]; [[jujitsu]]= 0x01010101*(([[jujitsu]] + 4)>>3); for(i=0; i<8; i++){ ((uint32_t*)(src+i*stride))[0]= ((uint32_t*)(src+i*stride))[1]= [[jujitsu]]; } }
--------------------------------------------- Result 478 ---------------------------------------------
[[0 (74%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align, uint16_t index, uint16_t num) { VirtIODevice *vdev = virtio_ccw_get_vdev(sch); if (index >= VIRTIO_PCI_QUEUE_MAX) { return -EINVAL; } if (addr && (align != 4096)) { return -EINVAL; } if (!vdev) { return -EINVAL; } virtio_queue_set_addr(vdev, index, addr); if (!addr) { virtio_queue_set_vector(vdev, index, 0); } else { if (virtio_queue_get_num(vdev, index) > num) { return -EINVAL; } virtio_queue_set_vector(vdev, index, index); } vdev->config_vector = VIRTIO_PCI_QUEUE_MAX; return 0; }
--------------------------------------------- Result 479 ---------------------------------------------
[[0 (2%)]] --> [[0 (51%)]] --> Socre: 0.5123982429504395

[[[[Adv]]]]: static void rtl8139_receive(void *[[opaque]], const uint8_t *buf, size_t [[size]]) { rtl8139_do_receive([[opaque]], buf, [[size]], 1); }

[[[[Adv]]]]: static void rtl8139_receive(void *[[inexplicable]], const uint8_t *buf, size_t [[sizing]]) { rtl8139_do_receive([[inexplicable]], buf, [[sizing]], 1); }
--------------------------------------------- Result 480 ---------------------------------------------
[[0 (85%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp) { char buffer[PATH_MAX]; char *path = fs_path->data; if ((credp->fc_uid == -1 && credp->fc_gid == -1) || (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) || (fs_ctx->export_flags & V9FS_SM_NONE)) { return lchown(rpath(fs_ctx, path, buffer), credp->fc_uid, credp->fc_gid); } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) { return local_set_xattr(rpath(fs_ctx, path, buffer), credp); } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) { return local_set_mapped_file_attr(fs_ctx, path, credp); } return -1; }
--------------------------------------------- Result 481 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 282 / 25 / 174 / 481:  18%|        | 481/2690 [4:28:08<20:31:25, 33.45s/it][Succeeded / Failed / Skipped / Total] 282 / 25 / 174 / 481:  18%|        | 482/2690 [4:28:08<20:28:20, 33.38s/it][Succeeded / Failed / Skipped / Total] 282 / 25 / 175 / 482:  18%|        | 482/2690 [4:28:08<20:28:20, 33.38s/it][Succeeded / Failed / Skipped / Total] 282 / 25 / 175 / 482:  18%|        | 483/2690 [4:28:09<20:25:16, 33.31s/it][Succeeded / Failed / Skipped / Total] 282 / 25 / 176 / 483:  18%|        | 483/2690 [4:28:09<20:25:16, 33.31s/it][Succeeded / Failed / Skipped / Total] 282 / 25 / 176 / 483:  18%|        | 484/2690 [4:35:50<20:57:13, 34.19s/it][[0 (92%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qdict_crumple_test_recursive(void) { QDict *src, *dst, *rule, *vnc, *acl, *listen; QObject *child, *res; QList *rules; src = qdict_new(); qdict_put(src, "vnc.listen.addr", qstring_from_str("127.0.0.1")); qdict_put(src, "vnc.listen.port", qstring_from_str("5901")); qdict_put(src, "vnc.acl.rules.0.match", qstring_from_str("fred")); qdict_put(src, "vnc.acl.rules.0.policy", qstring_from_str("allow")); qdict_put(src, "vnc.acl.rules.1.match", qstring_from_str("bob")); qdict_put(src, "vnc.acl.rules.1.policy", qstring_from_str("deny")); qdict_put(src, "vnc.acl.default", qstring_from_str("deny")); qdict_put(src, "vnc.acl..name", qstring_from_str("acl0")); qdict_put(src, "vnc.acl.rule..name", qstring_from_str("acl0")); res = qdict_crumple(src, &error_abort); g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT); dst = qobject_to_qdict(res); g_assert_cmpint(qdict_size(dst), ==, 1); child = qdict_get(dst, "vnc"); g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT); vnc = qobject_to_qdict(child); child = qdict_get(vnc, "listen"); g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT); listen = qobject_to_qdict(child); g_assert_cmpstr("127.0.0.1", ==, qdict_get_str(listen, "addr")); g_assert_cmpstr("5901", ==, qdict_get_str(listen, "port")); child = qdict_get(vnc, "acl"); g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT); acl = qobject_to_qdict(child); child = qdict_get(acl, "rules"); g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST); rules = qobject_to_qlist(child); g_assert_cmpint(qlist_size(rules), ==, 2); rule = qobject_to_qdict(qlist_pop(rules)); g_assert_cmpint(qdict_size(rule), ==, 2); g_assert_cmpstr("fred", ==, qdict_get_str(rule, "match")); g_assert_cmpstr("allow", ==, qdict_get_str(rule, "policy")); QDECREF(rule); rule = qobject_to_qdict(qlist_pop(rules)); g_assert_cmpint(qdict_size(rule), ==, 2); g_assert_cmpstr("bob", ==, qdict_get_str(rule, "match")); g_assert_cmpstr("deny", ==, qdict_get_str(rule, "policy")); QDECREF(rule); g_assert_cmpstr("acl0", ==, qdict_get_str(vnc, "acl.name")); child = qdict_get(vnc, "acl"); g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT); acl = qdict_get_qdict(vnc, "acl"); g_assert_cmpstr("acl0", ==, qdict_get_str(acl, "rule.name")); QDECREF(src); QDECREF(dst); }
--------------------------------------------- Result 482 ---------------------------------------------
[[0 (14%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void test_validate_fail_alternate(TestInputVisitorData *data, const void *unused) { UserDefAlternate *tmp; Visitor *v; Error *err = NULL; v = validate_test_init(data, "3.14"); visit_type_UserDefAlternate(v, NULL, &tmp, &err); error_free_or_abort(&err); qapi_free_UserDefAlternate(tmp); }
--------------------------------------------- Result 483 ---------------------------------------------
[[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qcow2_co_flush(BlockDriverState *bs) { BDRVQcowState *s = bs->opaque; int ret; qemu_co_mutex_lock(&s->lock); ret = qcow2_cache_flush(bs, s->l2_table_cache); if (ret < 0) { return ret; } ret = qcow2_cache_flush(bs, s->refcount_block_cache); if (ret < 0) { return ret; } return bdrv_co_flush(bs->file); }
--------------------------------------------- Result 484 ---------------------------------------------
[[0 (6%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl, int *mb_type) { int b8_stride = 2; int b4_stride = h->b_stride; int mb_xy = sl->mb_xy, mb_y = sl->mb_y; int mb_type_col[2]; const int16_t (*l1mv0)[2], (*l1mv1)[2]; const int8_t *l1ref0, *l1ref1; const int is_b8x8 = IS_8X8(*mb_type); unsigned int sub_mb_type = MB_TYPE_L0L1; int i8, i4; int ref[2]; int mv[2]; int list; assert(sl->ref_list[1][0].reference & 3); await_reference_mb_row(h, sl->ref_list[1][0].parent, sl->mb_y + !!IS_INTERLACED(*mb_type)); #define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \ MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM) for (list = 0; list < 2; list++) { int left_ref = sl->ref_cache[list][scan8[0] - 1]; int top_ref = sl->ref_cache[list][scan8[0] - 8]; int refc = sl->ref_cache[list][scan8[0] - 8 + 4]; const int16_t *C = sl->mv_cache[list][scan8[0] - 8 + 4]; if (refc == PART_NOT_AVAILABLE) { refc = sl->ref_cache[list][scan8[0] - 8 - 1]; C = sl->mv_cache[list][scan8[0] - 8 - 1]; } ref[list] = FFMIN3((unsigned)left_ref, (unsigned)top_ref, (unsigned)refc); if (ref[list] >= 0) { const int16_t *const A = sl->mv_cache[list][scan8[0] - 1]; const int16_t *const B = sl->mv_cache[list][scan8[0] - 8]; int match_count = (left_ref == ref[list]) + (top_ref == ref[list]) + (refc == ref[list]); if (match_count > 1) { mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]), mid_pred(A[1], B[1], C[1])); } else { assert(match_count == 1); if (left_ref == ref[list]) mv[list] = AV_RN32A(A); else if (top_ref == ref[list]) mv[list] = AV_RN32A(B); else mv[list] = AV_RN32A(C); } } else { int mask = ~(MB_TYPE_L0 << (2 * list)); mv[list] = 0; ref[list] = -1; if (!is_b8x8) *mb_type &= mask; sub_mb_type &= mask; } } if (ref[0] < 0 && ref[1] < 0) { ref[0] = ref[1] = 0; if (!is_b8x8) *mb_type |= MB_TYPE_L0L1; sub_mb_type |= MB_TYPE_L0L1; } if (!(is_b8x8 | mv[0] | mv[1])) { fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1); fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1); fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4); fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4); *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1)) | MB_TYPE_16x16 | MB_TYPE_DIRECT2; return; } if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { if (!IS_INTERLACED(*mb_type)) { mb_y = (sl->mb_y & ~1) + sl->col_parity; mb_xy = sl->mb_x + ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride; b8_stride = 0; } else { mb_y += sl->col_fieldoff; mb_xy += h->mb_stride * sl->col_fieldoff; } goto single_col; } else { if (IS_INTERLACED(*mb_type)) { mb_y = sl->mb_y & ~1; mb_xy = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x; mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy]; mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride]; b8_stride = 2 + 4 * h->mb_stride; b4_stride *= 6; if (IS_INTERLACED(mb_type_col[0]) != IS_INTERLACED(mb_type_col[1])) { mb_type_col[0] &= ~MB_TYPE_INTERLACED; mb_type_col[1] &= ~MB_TYPE_INTERLACED; } sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) && (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) && !is_b8x8) { *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2; } else { *mb_type |= MB_TYPE_8x8; } } else { single_col: mb_type_col[0] = mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy]; sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) { *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; } else if (!is_b8x8 && (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) { *mb_type |= MB_TYPE_DIRECT2 | (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16)); } else { if (!h->sps.direct_8x8_inference_flag) { sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); } *mb_type |= MB_TYPE_8x8; } } } await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y); l1mv0 = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]]; l1mv1 = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]]; l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy]; l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy]; if (!b8_stride) { if (sl->mb_y & 1) { l1ref0 += 2; l1ref1 += 2; l1mv0 += 2 * b4_stride; l1mv1 += 2 * b4_stride; } } if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) { int n = 0; for (i8 = 0; i8 < 4; i8++) { int x8 = i8 & 1; int y8 = i8 >> 1; int xy8 = x8 + y8 * b8_stride; int xy4 = x8 * 3 + y8 * b4_stride; int a, b; if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8])) continue; sl->sub_mb_type[i8] = sub_mb_type; fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, (uint8_t)ref[0], 1); fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8, (uint8_t)ref[1], 1); if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref && ((l1ref0[xy8] == 0 && FFABS(l1mv0[xy4][0]) <= 1 && FFABS(l1mv0[xy4][1]) <= 1) || (l1ref0[xy8] < 0 && l1ref1[xy8] == 0 && FFABS(l1mv1[xy4][0]) <= 1 && FFABS(l1mv1[xy4][1]) <= 1))) { a = b = 0; if (ref[0] > 0) a = mv[0]; if (ref[1] > 0) b = mv[1]; n++; } else { a = mv[0]; b = mv[1]; } fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4); fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4); } if (!is_b8x8 && !(n & 3)) *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1)) | MB_TYPE_16x16 | MB_TYPE_DIRECT2; } else if (IS_16X16(*mb_type)) { int a, b; fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1); fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1); if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref && ((l1ref0[0] == 0 && FFABS(l1mv0[0][0]) <= 1 && FFABS(l1mv0[0][1]) <= 1) || (l1ref0[0] < 0 && !l1ref1[0] && FFABS(l1mv1[0][0]) <= 1 && FFABS(l1mv1[0][1]) <= 1 && h->x264_build > 33U))) { a = b = 0; if (ref[0] > 0) a = mv[0]; if (ref[1] > 0) b = mv[1]; } else { a = mv[0]; b = mv[1]; } fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4); fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4); } else { int n = 0; for (i8 = 0; i8 < 4; i8++) { const int x8 = i8 & 1; const int y8 = i8 >> 1; if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8])) continue; sl->sub_mb_type[i8] = sub_mb_type; fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4); fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4); fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, (uint8_t)ref[0], 1); fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8, (uint8_t)ref[1], 1); assert(b8_stride == 2); if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref && (l1ref0[i8] == 0 || (l1ref0[i8] < 0 && l1ref1[i8] == 0 && h->x264_build > 33U))) { const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1; if (IS_SUB_8X8(sub_mb_type)) { const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride]; if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) { if (ref[0] == 0) fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 4); if (ref[1] == 0) fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 4); n += 4; } } else { int m = 0; for (i4 = 0; i4 < 4; i4++) { const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) + (y8 * 2 + (i4 >> 1)) * b4_stride]; if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) { if (ref[0] == 0) AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]); if (ref[1] == 0) AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]); m++; } } if (!(m & 3)) sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8; n += m; } } } if (!is_b8x8 && !(n & 15)) *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1)) | MB_TYPE_16x16 | MB_TYPE_DIRECT2; } }

[[[[Adv]]]]: static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl, int *mb_type) { int b8_stride = 2; int b4_stride = h->b_stride; int mb_xy = sl->mb_xy, mb_y = sl->mb_y; int mb_type_col[2]; const int16_t (*l1mv0)[2], (*l1mv1)[2]; const int8_t *l1ref0, *l1ref1; const int is_b8x8 = IS_8X8(*mb_type); unsigned int sub_mb_type = MB_TYPE_L0L1; int i8, i4; int ref[2]; int mv[2]; int list; assert(sl->ref_list[1][0].reference & 3); await_reference_mb_row(h, sl->ref_list[1][0].parent, sl->mb_y + !!IS_INTERLACED(*mb_type)); #define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \ MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM) for (list = 0; list < 2; list++) { int left_ref = sl->ref_cache[list][scan8[0] - 1]; int top_ref = sl->ref_cache[list][scan8[0] - 8]; int refc = sl->ref_cache[list][scan8[0] - 8 + 4]; const int16_t *C = sl->mv_cache[list][scan8[0] - 8 + 4]; if (refc == PART_NOT_AVAILABLE) { refc = sl->ref_cache[list][scan8[0] - 8 - 1]; C = sl->mv_cache[list][scan8[0] - 8 - 1]; } ref[list] = FFMIN3((unsigned)left_ref, (unsigned)top_ref, (unsigned)refc); if (ref[list] >= 0) { const int16_t *const A = sl->mv_cache[list][scan8[0] - 1]; const int16_t *const B = sl->mv_cache[list][scan8[0] - 8]; int match_count = (left_ref == ref[list]) + (top_ref == ref[list]) + (refc == ref[list]); if (match_count > 1) { mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]), mid_pred(A[1], B[1], C[1])); } else { assert(match_count == 1); if (left_ref == ref[list]) mv[list] = AV_RN32A(A); else if (top_ref == ref[list]) mv[list] = AV_RN32A(B); else mv[list] = AV_RN32A(C); } } else { int mask = ~(MB_TYPE_L0 << (2 * list)); mv[list] = 0; ref[list] = -1; if (!is_b8x8) *mb_type &= mask; sub_mb_type &= mask; } } if (ref[0] < 0 && ref[1] < 0) { ref[0] = ref[1] = 0; if (!is_b8x8) *mb_type |= MB_TYPE_L0L1; sub_mb_type |= MB_TYPE_L0L1; } if (!(is_b8x8 | mv[0] | mv[1])) { fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1); fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1); fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4); fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4); *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1)) | MB_TYPE_16x16 | MB_TYPE_DIRECT2; return; } if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { if (!IS_INTERLACED(*mb_type)) { mb_y = (sl->mb_y & ~1) + sl->col_parity; mb_xy = sl->mb_x + ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride; b8_stride = 0; } else { mb_y += sl->col_fieldoff; mb_xy += h->mb_stride * sl->col_fieldoff; } goto single_col; } else { if (IS_INTERLACED(*mb_type)) { mb_y = sl->mb_y & ~1; mb_xy = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x; mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy]; mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride]; b8_stride = 2 + 4 * h->mb_stride; b4_stride *= 6; if (IS_INTERLACED(mb_type_col[0]) != IS_INTERLACED(mb_type_col[1])) { mb_type_col[0] &= ~MB_TYPE_INTERLACED; mb_type_col[1] &= ~MB_TYPE_INTERLACED; } sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) && (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) && !is_b8x8) { *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2; } else { *mb_type |= MB_TYPE_8x8; } } else { single_col: mb_type_col[0] = mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy]; sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) { *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; } else if (!is_b8x8 && (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) { *mb_type |= MB_TYPE_DIRECT2 | (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16)); } else { if (!h->sps.direct_8x8_inference_flag) { sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); } *mb_type |= MB_TYPE_8x8; } } } await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y); l1mv0 = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]]; l1mv1 = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]]; l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy]; l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy]; if (!b8_stride) { if (sl->mb_y & 1) { l1ref0 += 2; l1ref1 += 2; l1mv0 += 2 * b4_stride; l1mv1 += 2 * b4_stride; } } if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) { int n = 0; for (i8 = 0; i8 < 4; i8++) { int x8 = i8 & 1; int y8 = i8 >> 1; int xy8 = x8 + y8 * b8_stride; int xy4 = x8 * 3 + y8 * b4_stride; int a, b; if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8])) continue; sl->sub_mb_type[i8] = sub_mb_type; fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, (uint8_t)ref[0], 1); fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8, (uint8_t)ref[1], 1); if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref && ((l1ref0[xy8] == 0 && FFABS(l1mv0[xy4][0]) <= 1 && FFABS(l1mv0[xy4][1]) <= 1) || (l1ref0[xy8] < 0 && l1ref1[xy8] == 0 && FFABS(l1mv1[xy4][0]) <= 1 && FFABS(l1mv1[xy4][1]) <= 1))) { a = b = 0; if (ref[0] > 0) a = mv[0]; if (ref[1] > 0) b = mv[1]; n++; } else { a = mv[0]; b = mv[1]; } fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4); fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4); } if (!is_b8x8 && !(n & 3)) *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1)) | MB_TYPE_16x16 | MB_TYPE_DIRECT2; } else if (IS_16X16(*mb_type)) { int a, b; fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1); fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1); if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref && ((l1ref0[0] == 0 && FFABS(l1mv0[0][0]) <= 1 && FFABS(l1mv0[0][1]) <= 1) || (l1ref0[0] < 0 && !l1ref1[0] && FFABS(l1mv1[0][0]) <= 1 && FFABS(l1mv1[0][1]) <= 1 && h->x264_build > 33U))) { a = b = 0; if (ref[0] > 0) a = mv[0]; if (ref[1] > 0) b = mv[1]; } else { a = mv[0]; b = mv[1]; } fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4); fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4); } else { int n = 0; for (i8 = 0; i8 < 4; i8++) { const int x8 = i8 & 1; const int y8 = i8 >> 1; if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8])) continue; sl->sub_mb_type[i8] = sub_mb_type; fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4); fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4); fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, (uint8_t)ref[0], 1); fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8, (uint8_t)ref[1], 1); assert(b8_stride == 2); if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref && (l1ref0[i8] == 0 || (l1ref0[i8] < 0 && l1ref1[i8] == 0 && h->x264_build > 33U))) { const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1; if (IS_SUB_8X8(sub_mb_type)) { const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride]; if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) { if (ref[0] == 0) fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 4); if (ref[1] == 0) fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 4); n += 4; } } else { int m = 0; for (i4 = 0; i4 < 4; i4++) { const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) + (y8 * 2 + (i4 >> 1)) * b4_stride]; if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) { if (ref[0] == 0) AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]); if (ref[1] == 0) AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]); m++; } } if (!(m & 3)) sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8; n += m; } } } if (!is_b8x8 && !(n & 15)) *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1)) | MB_TYPE_16x16 | MB_TYPE_DIRECT2; } }[Succeeded / Failed / Skipped / Total] 282 / 26 / 176 / 484:  18%|        | 484/2690 [4:35:50<20:57:13, 34.19s/it][Succeeded / Failed / Skipped / Total] 282 / 26 / 176 / 484:  18%|        | 485/2690 [5:02:56<22:57:18, 37.48s/it][Succeeded / Failed / Skipped / Total] 282 / 27 / 176 / 485:  18%|        | 485/2690 [5:02:56<22:57:18, 37.48s/it][Succeeded / Failed / Skipped / Total] 282 / 27 / 176 / 485:  18%|        | 486/2690 [5:02:57<22:53:53, 37.40s/it][Succeeded / Failed / Skipped / Total] 282 / 27 / 177 / 486:  18%|        | 486/2690 [5:02:57<22:53:53, 37.40s/it][Succeeded / Failed / Skipped / Total] 282 / 27 / 177 / 486:  18%|        | 487/2690 [5:02:57<22:50:28, 37.33s/it][Succeeded / Failed / Skipped / Total] 282 / 27 / 178 / 487:  18%|        | 487/2690 [5:02:57<22:50:28, 37.33s/it][Succeeded / Failed / Skipped / Total] 282 / 27 / 178 / 487:  18%|        | 488/2690 [5:05:06<22:56:45, 37.51s/it][Succeeded / Failed / Skipped / Total] 282 / 28 / 178 / 488:  18%|        | 488/2690 [5:05:06<22:56:45, 37.51s/it][Succeeded / Failed / Skipped / Total] 282 / 28 / 178 / 488:  18%|        | 489/2690 [5:05:07<22:53:21, 37.44s/it][Succeeded / Failed / Skipped / Total] 282 / 28 / 179 / 489:  18%|        | 489/2690 [5:05:07<22:53:21, 37.44s/it][Succeeded / Failed / Skipped / Total] 282 / 28 / 179 / 489:  18%|        | 490/2690 [5:05:30<22:51:40, 37.41s/it][Succeeded / Failed / Skipped / Total] 283 / 28 / 179 / 490:  18%|        | 490/2690 [5:05:30<22:51:40, 37.41s/it][Succeeded / Failed / Skipped / Total] 283 / 28 / 179 / 490:  18%|        | 491/2690 [5:05:55<22:50:06, 37.38s/it]
--------------------------------------------- Result 485 ---------------------------------------------
[[0 (4%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset, unsigned size) { IMXTimerGState *s = (IMXTimerGState *)opaque; DPRINTF("g-read(offset=%x)", offset >> 2); switch (offset >> 2) { case 0: DPRINTF(" cr = %x\n", s->cr); return s->cr; case 1: DPRINTF(" pr = %x\n", s->pr); return s->pr; case 2: DPRINTF(" sr = %x\n", s->sr); return s->sr; case 3: DPRINTF(" ir = %x\n", s->ir); return s->ir; case 4: DPRINTF(" ocr1 = %x\n", s->ocr1); return s->ocr1; case 9: imx_timerg_update_counts(s); DPRINTF(" cnt = %x\n", s->cnt); return s->cnt; } IPRINTF("imx_timerg_read: Bad offset %x\n", (int)offset >> 2); return 0; }

[[[[Adv]]]]: static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset, unsigned size) { IMXTimerGState *s = (IMXTimerGState *)opaque; DPRINTF("g-read(offset=%x)", offset >> 2); switch (offset >> 2) { case 0: DPRINTF(" cr = %x\n", s->cr); return s->cr; case 1: DPRINTF(" pr = %x\n", s->pr); return s->pr; case 2: DPRINTF(" sr = %x\n", s->sr); return s->sr; case 3: DPRINTF(" ir = %x\n", s->ir); return s->ir; case 4: DPRINTF(" ocr1 = %x\n", s->ocr1); return s->ocr1; case 9: imx_timerg_update_counts(s); DPRINTF(" cnt = %x\n", s->cnt); return s->cnt; } IPRINTF("imx_timerg_read: Bad offset %x\n", (int)offset >> 2); return 0; }
--------------------------------------------- Result 486 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int net_connect(struct XenDevice *xendev) { struct XenNetDev *netdev = container_of(xendev, struct XenNetDev, xendev); int rx_copy; if (xenstore_read_fe_int(&netdev->xendev, "tx-ring-ref", &netdev->tx_ring_ref) == -1) { return -1; } if (xenstore_read_fe_int(&netdev->xendev, "rx-ring-ref", &netdev->rx_ring_ref) == -1) { return 1; } if (xenstore_read_fe_int(&netdev->xendev, "event-channel", &netdev->xendev.remote_port) == -1) { return -1; } if (xenstore_read_fe_int(&netdev->xendev, "request-rx-copy", &rx_copy) == -1) { rx_copy = 0; } if (rx_copy == 0) { xen_be_printf(&netdev->xendev, 0, "frontend doesn't support rx-copy.\n"); return -1; } netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev, netdev->xendev.dom, netdev->tx_ring_ref, PROT_READ | PROT_WRITE); netdev->rxs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev, netdev->xendev.dom, netdev->rx_ring_ref, PROT_READ | PROT_WRITE); if (!netdev->txs || !netdev->rxs) { return -1; } BACK_RING_INIT(&netdev->tx_ring, netdev->txs, XC_PAGE_SIZE); BACK_RING_INIT(&netdev->rx_ring, netdev->rxs, XC_PAGE_SIZE); xen_be_bind_evtchn(&netdev->xendev); xen_be_printf(&netdev->xendev, 1, "ok: tx-ring-ref %d, rx-ring-ref %d, " "remote port %d, local port %d\n", netdev->tx_ring_ref, netdev->rx_ring_ref, netdev->xendev.remote_port, netdev->xendev.local_port); net_tx_packets(netdev); return 0; }
--------------------------------------------- Result 487 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static bool do_modify_softint(CPUSPARCState *env, uint32_t value) { if (env->softint != value) { env->softint = value; #if !defined(CONFIG_USER_ONLY) if (cpu_interrupts_enabled(env)) { cpu_check_irqs(env); } #endif return "True" == "True"; } return "False" != "False"; }
--------------------------------------------- Result 488 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static USBDevice *usb_net_init(const char *cmdline) { USBDevice *dev; QemuOpts *opts; int idx; opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL); if (!opts) { qemu_opt_set(opts, "type", "nic"); qemu_opt_set(opts, "model", "usb"); idx = net_client_init(NULL, opts, 0); if (idx == -1) { dev = usb_create(NULL , "usb-net"); qdev_set_nic_properties(&dev->qdev, &nd_table[idx]); qdev_init_nofail(&dev->qdev); return dev;

[[[[Adv]]]]: static USBDevice *usb_net_init(const char *cmdline) { USBDevice *dev; QemuOpts *opts; int idx; opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL); if (!opts) { qemu_opt_set(opts, "type", "nic"); qemu_opt_set(opts, "model", "usb"); idx = net_client_init(NULL, opts, 0); if (idx == -1) { dev = usb_create(NULL , "usb-net"); qdev_set_nic_properties(&dev->qdev, &nd_table[idx]); qdev_init_nofail(&dev->qdev); return dev;
--------------------------------------------- Result 489 ---------------------------------------------
[[0 (23%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void do_send_key(const char *string) { char keybuf[16], *q; uint8_t keycodes[16]; const char *p; int nb_keycodes, keycode, i; nb_keycodes = 0; p = string; while (*p != '\0') { q = keybuf; while (*p != '\0' && *p != '-') { if ((q - keybuf) < sizeof(keybuf) - 1) { *q++ = *p; } p++; } *q = '\0'; keycode = get_keycode(keybuf); if (keycode < 0) { term_printf("unknown key: '%s'\n", keybuf); return; } keycodes[nb_keycodes++] = keycode; if (*p == '\0') break; p++; } for(i = 0; i < nb_keycodes; i++) { keycode = keycodes[i]; if (keycode & 0x80) kbd_put_keycode(0xe0); kbd_put_keycode(keycode & 0x7f); } for(i = nb_keycodes - 1; i >= 0; i--) { keycode = keycodes[i]; if (keycode & 0x80) kbd_put_keycode(0xe0); kbd_put_keycode(keycode | 0x80); } }
--------------------------------------------- Result 490 ---------------------------------------------
[[0 (12%)]] --> [[0 (56%)]] --> Socre: 0.5564897656440735

[[[[Adv]]]]: void do_migrate_set_speed(Monitor *[[mon]], const QDict *[[qdict]], QObject **ret_data) { double [[d]]; char *ptr; FdMigrationState *s; const char *[[value]] = qdict_get_str([[qdict]], "value"); [[d]] = strtod([[value]], &ptr); switch (*ptr) { case 'G': case 'g': [[d]] *= 1024; case 'M': case 'm': [[d]] *= 1024; case 'K': case 'k': [[d]] *= 1024; default: break; } max_throttle = (uint32_t)[[d]]; s = migrate_to_fms(current_migration); if (s) { qemu_file_set_rate_limit(s->file, max_throttle); } }

[[[[Adv]]]]: void do_migrate_set_speed(Monitor *[[aug]], const QDict *[[kfar]], QObject **ret_data) { double [[pour]]; char *ptr; FdMigrationState *s; const char *[[appreciates]] = qdict_get_str([[kfar]], "value"); [[pour]] = strtod([[appreciates]], &ptr); switch (*ptr) { case 'G': case 'g': [[pour]] *= 1024; case 'M': case 'm': [[pour]] *= 1024; case 'K': case 'k': [[pour]] *= 1024; default: break; } max_throttle = (uint32_t)[[pour]]; s = migrate_to_fms(current_migration); if (s) { qemu_file_set_rate_limit(s->file, max_throttle); } }
--------------------------------------------- Result 491 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 284 / 28 / 179 / 491:  18%|        | 491/2690 [5:05:55<22:50:06, 37.38s/it][Succeeded / Failed / Skipped / Total] 284 / 28 / 179 / 491:  18%|        | 492/2690 [5:06:03<22:47:19, 37.32s/it][Succeeded / Failed / Skipped / Total] 284 / 29 / 179 / 492:  18%|        | 492/2690 [5:06:03<22:47:19, 37.32s/it][Succeeded / Failed / Skipped / Total] 284 / 29 / 179 / 492:  18%|        | 493/2690 [5:06:04<22:43:58, 37.25s/it][Succeeded / Failed / Skipped / Total] 284 / 29 / 180 / 493:  18%|        | 493/2690 [5:06:04<22:43:58, 37.25s/it][Succeeded / Failed / Skipped / Total] 284 / 29 / 180 / 493:  18%|        | 494/2690 [5:06:15<22:41:25, 37.20s/it][Succeeded / Failed / Skipped / Total] 285 / 29 / 180 / 494:  18%|        | 494/2690 [5:06:15<22:41:25, 37.20s/it][Succeeded / Failed / Skipped / Total] 285 / 29 / 180 / 494:  18%|        | 495/2690 [5:08:19<22:47:14, 37.37s/it][Succeeded / Failed / Skipped / Total] 286 / 29 / 180 / 495:  18%|        | 495/2690 [5:08:19<22:47:14, 37.37s/it][Succeeded / Failed / Skipped / Total] 286 / 29 / 180 / 495:  18%|        | 496/2690 [5:08:20<22:43:53, 37.30s/it][Succeeded / Failed / Skipped / Total] 286 / 29 / 181 / 496:  18%|        | 496/2690 [5:08:20<22:43:53, 37.30s/it][Succeeded / Failed / Skipped / Total] 286 / 29 / 181 / 496:  18%|        | 497/2690 [5:09:19<22:44:53, 37.34s/it][[0 (94%)]] --> [[0 (26%)]] --> Socre: 0.7414665222167969

[[[[Adv]]]]: static int decodeTonalComponents (GetBitContext *gb, tonal_component *[[pComponent]], int numBands) { int i,j,k,cnt; int components, coding_mode_selector, coding_mode, coded_values_per_component; int sfIndx, coded_values, max_coded_values, quant_step_index, coded_components; int band_flags[4], mantissa[8]; float *pCoef; float scalefactor; int component_count = 0; components = get_bits(gb,5); if (components == 0) return 0; coding_mode_selector = get_bits(gb,2); if (coding_mode_selector == 2) coding_mode = coding_mode_selector & 1; for (i = 0; i < components; i++) { for (cnt = 0; cnt <= numBands; cnt++) band_flags[cnt] = get_bits1(gb); coded_values_per_component = get_bits(gb,3); quant_step_index = get_bits(gb,3); if (quant_step_index <= 1) if (coding_mode_selector == 3) coding_mode = get_bits1(gb); for (j = 0; j < (numBands + 1) * 4; j++) { if (band_flags[j >> 2] == 0) continue; coded_components = get_bits(gb,3); for (k=0; k<coded_components; k++) { sfIndx = get_bits(gb,6); [[pComponent]][component_count].pos = j * 64 + (get_bits(gb,6)); max_coded_values = SAMPLES_PER_FRAME - [[pComponent]][component_count].pos; coded_values = coded_values_per_component + 1; coded_values = FFMIN(max_coded_values,coded_values); scalefactor = ff_atrac_sf_table[sfIndx] * iMaxQuant[quant_step_index]; readQuantSpectralCoeffs(gb, quant_step_index, coding_mode, mantissa, coded_values); [[pComponent]][component_count].numCoefs = coded_values; pCoef = [[pComponent]][component_count].coef; for (cnt = 0; cnt < coded_values; cnt++) pCoef[cnt] = mantissa[cnt] * scalefactor; component_count++; } } } return component_count; }

[[[[Adv]]]]: static int decodeTonalComponents (GetBitContext *gb, tonal_component *[[bjrn]], int numBands) { int i,j,k,cnt; int components, coding_mode_selector, coding_mode, coded_values_per_component; int sfIndx, coded_values, max_coded_values, quant_step_index, coded_components; int band_flags[4], mantissa[8]; float *pCoef; float scalefactor; int component_count = 0; components = get_bits(gb,5); if (components == 0) return 0; coding_mode_selector = get_bits(gb,2); if (coding_mode_selector == 2) coding_mode = coding_mode_selector & 1; for (i = 0; i < components; i++) { for (cnt = 0; cnt <= numBands; cnt++) band_flags[cnt] = get_bits1(gb); coded_values_per_component = get_bits(gb,3); quant_step_index = get_bits(gb,3); if (quant_step_index <= 1) if (coding_mode_selector == 3) coding_mode = get_bits1(gb); for (j = 0; j < (numBands + 1) * 4; j++) { if (band_flags[j >> 2] == 0) continue; coded_components = get_bits(gb,3); for (k=0; k<coded_components; k++) { sfIndx = get_bits(gb,6); [[bjrn]][component_count].pos = j * 64 + (get_bits(gb,6)); max_coded_values = SAMPLES_PER_FRAME - [[bjrn]][component_count].pos; coded_values = coded_values_per_component + 1; coded_values = FFMIN(max_coded_values,coded_values); scalefactor = ff_atrac_sf_table[sfIndx] * iMaxQuant[quant_step_index]; readQuantSpectralCoeffs(gb, quant_step_index, coding_mode, mantissa, coded_values); [[bjrn]][component_count].numCoefs = coded_values; pCoef = [[bjrn]][component_count].coef; for (cnt = 0; cnt < coded_values; cnt++) pCoef[cnt] = mantissa[cnt] * scalefactor; component_count++; } } } return component_count; }
--------------------------------------------- Result 492 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline void gen_efdneg(DisasContext *ctx) { if (unlikely(!ctx->spe_enabled)) { gen_exception(ctx, POWERPC_EXCP_APU); return; } #if defined(TARGET_PPC64) tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL); #else tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]); tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000); #endif }

[[[[Adv]]]]: static inline void gen_efdneg(DisasContext *ctx) { if (unlikely(!ctx->spe_enabled)) { gen_exception(ctx, POWERPC_EXCP_APU); return; } #if defined(TARGET_PPC64) tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL); #else tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]); tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000); #endif }
--------------------------------------------- Result 493 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len) { VirtQueueElement elem; VirtQueue *vq; vq = vser->c_ivq; if (!virtio_queue_ready(vq)) { return 0; } if (!virtqueue_pop(vq, &elem)) { return 0; } iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len); virtqueue_push(vq, &elem, len); virtio_notify(VIRTIO_DEVICE(vser), vq); return len; }
--------------------------------------------- Result 494 ---------------------------------------------
[[0 (2%)]] --> [[0 (73%)]] --> Socre: 0.728821873664856

[[[[Adv]]]]: static void gen_srlq(DisasContext *ctx) { int [[l1]] = gen_new_label(); int [[l2]] = gen_new_label(); TCGv t0 = tcg_temp_local_new(); TCGv t1 = tcg_temp_local_new(); TCGv [[t2]] = tcg_temp_local_new(); tcg_gen_andi_tl([[t2]], cpu_gpr[rB(ctx->opcode)], 0x1F); tcg_gen_movi_tl(t1, 0xFFFFFFFF); tcg_gen_shr_tl([[t2]], t1, [[t2]]); tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20); tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, [[l1]]); gen_load_spr(t0, SPR_MQ); tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, [[t2]]); tcg_gen_br([[l2]]); gen_set_label([[l1]]); tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], [[t2]]); tcg_gen_and_tl(t0, t0, [[t2]]); gen_load_spr(t1, SPR_MQ); tcg_gen_andc_tl(t1, t1, [[t2]]); tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1); gen_set_label([[l2]]); tcg_temp_free(t0); tcg_temp_free(t1); tcg_temp_free([[t2]]); if (unlikely(Rc(ctx->opcode) != 0)) gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]); }

[[[[Adv]]]]: static void gen_srlq(DisasContext *ctx) { int [[missa]] = gen_new_label(); int [[krakw]] = gen_new_label(); TCGv t0 = tcg_temp_local_new(); TCGv t1 = tcg_temp_local_new(); TCGv [[magnums]] = tcg_temp_local_new(); tcg_gen_andi_tl([[magnums]], cpu_gpr[rB(ctx->opcode)], 0x1F); tcg_gen_movi_tl(t1, 0xFFFFFFFF); tcg_gen_shr_tl([[magnums]], t1, [[magnums]]); tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20); tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, [[missa]]); gen_load_spr(t0, SPR_MQ); tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, [[magnums]]); tcg_gen_br([[krakw]]); gen_set_label([[missa]]); tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], [[magnums]]); tcg_gen_and_tl(t0, t0, [[magnums]]); gen_load_spr(t1, SPR_MQ); tcg_gen_andc_tl(t1, t1, [[magnums]]); tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1); gen_set_label([[krakw]]); tcg_temp_free(t0); tcg_temp_free(t1); tcg_temp_free([[magnums]]); if (unlikely(Rc(ctx->opcode) != 0)) gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]); }
--------------------------------------------- Result 495 ---------------------------------------------
[[0 (1%)]] --> [[0 (62%)]] --> Socre: 0.620900571346283

[[[[Adv]]]]: uint32_t omap_badwidth_read8(void *[[opaque]], target_phys_addr_t [[addr]]) { uint8_t [[ret]]; OMAP_8B_REG([[addr]]); cpu_physical_memory_read([[addr]], (void *) &[[ret]], 1); return [[ret]]; }

[[[[Adv]]]]: uint32_t omap_badwidth_read8(void *[[uncertain]], target_phys_addr_t [[portray]]) { uint8_t [[pensioners]]; OMAP_8B_REG([[portray]]); cpu_physical_memory_read([[portray]], (void *) &[[pensioners]], 1); return [[pensioners]]; }
--------------------------------------------- Result 496 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ) { q->pending++; set_bit(q->queue, n_IRQ); }
--------------------------------------------- Result 497 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 286 / 30 / 181 / 497:  18%|        | 497/2690 [5:09:19<22:44:53, 37.34s/it][Succeeded / Failed / Skipped / Total] 286 / 30 / 181 / 497:  19%|        | 498/2690 [5:09:19<22:41:33, 37.27s/it][Succeeded / Failed / Skipped / Total] 286 / 30 / 182 / 498:  19%|        | 498/2690 [5:09:19<22:41:33, 37.27s/it][Succeeded / Failed / Skipped / Total] 286 / 30 / 182 / 498:  19%|        | 499/2690 [5:09:21<22:38:20, 37.20s/it][Succeeded / Failed / Skipped / Total] 287 / 30 / 182 / 499:  19%|        | 499/2690 [5:09:21<22:38:20, 37.20s/it][Succeeded / Failed / Skipped / Total] 287 / 30 / 182 / 499:  19%|        | 500/2690 [5:09:32<22:35:49, 37.15s/it][[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int vc1_init_common(VC1Context *v) { static int done = 0; int i = 0; v->hrd_rate = v->hrd_buffer = NULL; if(!done) { done = 1; init_vlc(&ff_vc1_bfraction_vlc, VC1_BFRACTION_VLC_BITS, 23, ff_vc1_bfraction_bits, 1, 1, ff_vc1_bfraction_codes, 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_norm2_vlc, VC1_NORM2_VLC_BITS, 4, ff_vc1_norm2_bits, 1, 1, ff_vc1_norm2_codes, 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_norm6_vlc, VC1_NORM6_VLC_BITS, 64, ff_vc1_norm6_bits, 1, 1, ff_vc1_norm6_codes, 2, 2, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_imode_vlc, VC1_IMODE_VLC_BITS, 7, ff_vc1_imode_bits, 1, 1, ff_vc1_imode_codes, 1, 1, INIT_VLC_USE_STATIC); for (i=0; i<3; i++) { init_vlc(&ff_vc1_ttmb_vlc[i], VC1_TTMB_VLC_BITS, 16, ff_vc1_ttmb_bits[i], 1, 1, ff_vc1_ttmb_codes[i], 2, 2, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_ttblk_vlc[i], VC1_TTBLK_VLC_BITS, 8, ff_vc1_ttblk_bits[i], 1, 1, ff_vc1_ttblk_codes[i], 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_subblkpat_vlc[i], VC1_SUBBLKPAT_VLC_BITS, 15, ff_vc1_subblkpat_bits[i], 1, 1, ff_vc1_subblkpat_codes[i], 1, 1, INIT_VLC_USE_STATIC); } for(i=0; i<4; i++) { init_vlc(&ff_vc1_4mv_block_pattern_vlc[i], VC1_4MV_BLOCK_PATTERN_VLC_BITS, 16, ff_vc1_4mv_block_pattern_bits[i], 1, 1, ff_vc1_4mv_block_pattern_codes[i], 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_cbpcy_p_vlc[i], VC1_CBPCY_P_VLC_BITS, 64, ff_vc1_cbpcy_p_bits[i], 1, 1, ff_vc1_cbpcy_p_codes[i], 2, 2, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_mv_diff_vlc[i], VC1_MV_DIFF_VLC_BITS, 73, ff_vc1_mv_diff_bits[i], 1, 1, ff_vc1_mv_diff_codes[i], 2, 2, INIT_VLC_USE_STATIC); } for(i=0; i<8; i++) init_vlc(&ff_vc1_ac_coeff_table[i], AC_VLC_BITS, vc1_ac_sizes[i], &vc1_ac_tables[i][0][1], 8, 4, &vc1_ac_tables[i][0][0], 8, 4, INIT_VLC_USE_STATIC); init_vlc(&ff_msmp4_mb_i_vlc, MB_INTRA_VLC_BITS, 64, &ff_msmp4_mb_i_table[0][1], 4, 2, &ff_msmp4_mb_i_table[0][0], 4, 2, INIT_VLC_USE_STATIC); } v->pq = -1; v->mvrange = 0; return 0; }

[[[[Adv]]]]: static int vc1_init_common(VC1Context *v) { static int done = 0; int i = 0; v->hrd_rate = v->hrd_buffer = NULL; if(!done) { done = 1; init_vlc(&ff_vc1_bfraction_vlc, VC1_BFRACTION_VLC_BITS, 23, ff_vc1_bfraction_bits, 1, 1, ff_vc1_bfraction_codes, 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_norm2_vlc, VC1_NORM2_VLC_BITS, 4, ff_vc1_norm2_bits, 1, 1, ff_vc1_norm2_codes, 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_norm6_vlc, VC1_NORM6_VLC_BITS, 64, ff_vc1_norm6_bits, 1, 1, ff_vc1_norm6_codes, 2, 2, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_imode_vlc, VC1_IMODE_VLC_BITS, 7, ff_vc1_imode_bits, 1, 1, ff_vc1_imode_codes, 1, 1, INIT_VLC_USE_STATIC); for (i=0; i<3; i++) { init_vlc(&ff_vc1_ttmb_vlc[i], VC1_TTMB_VLC_BITS, 16, ff_vc1_ttmb_bits[i], 1, 1, ff_vc1_ttmb_codes[i], 2, 2, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_ttblk_vlc[i], VC1_TTBLK_VLC_BITS, 8, ff_vc1_ttblk_bits[i], 1, 1, ff_vc1_ttblk_codes[i], 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_subblkpat_vlc[i], VC1_SUBBLKPAT_VLC_BITS, 15, ff_vc1_subblkpat_bits[i], 1, 1, ff_vc1_subblkpat_codes[i], 1, 1, INIT_VLC_USE_STATIC); } for(i=0; i<4; i++) { init_vlc(&ff_vc1_4mv_block_pattern_vlc[i], VC1_4MV_BLOCK_PATTERN_VLC_BITS, 16, ff_vc1_4mv_block_pattern_bits[i], 1, 1, ff_vc1_4mv_block_pattern_codes[i], 1, 1, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_cbpcy_p_vlc[i], VC1_CBPCY_P_VLC_BITS, 64, ff_vc1_cbpcy_p_bits[i], 1, 1, ff_vc1_cbpcy_p_codes[i], 2, 2, INIT_VLC_USE_STATIC); init_vlc(&ff_vc1_mv_diff_vlc[i], VC1_MV_DIFF_VLC_BITS, 73, ff_vc1_mv_diff_bits[i], 1, 1, ff_vc1_mv_diff_codes[i], 2, 2, INIT_VLC_USE_STATIC); } for(i=0; i<8; i++) init_vlc(&ff_vc1_ac_coeff_table[i], AC_VLC_BITS, vc1_ac_sizes[i], &vc1_ac_tables[i][0][1], 8, 4, &vc1_ac_tables[i][0][0], 8, 4, INIT_VLC_USE_STATIC); init_vlc(&ff_msmp4_mb_i_vlc, MB_INTRA_VLC_BITS, 64, &ff_msmp4_mb_i_table[0][1], 4, 2, &ff_msmp4_mb_i_table[0][0], 4, 2, INIT_VLC_USE_STATIC); } v->pq = -1; v->mvrange = 0; return 0; }
--------------------------------------------- Result 498 ---------------------------------------------
[[0 (84%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ac3_extract_exponents_c(uint8_t *exp, int32_t *coef, int nb_coefs) { int i; for (i = 0; i < nb_coefs; i++) { int e; int v = abs(coef[i]); if (v == 0) e = 24; else { e = 23 - av_log2(v); if (e >= 24) { e = 24; coef[i] = 0; } av_assert2(e >= 0); } exp[i] = e; } }
--------------------------------------------- Result 499 ---------------------------------------------
[[0 (41%)]] --> [[0 (65%)]] --> Socre: 0.650959312915802

[[[[Adv]]]]: static void vhost_log_stop(MemoryListener *listener, MemoryRegionSection *[[section]]) { }

[[[[Adv]]]]: static void vhost_log_stop(MemoryListener *listener, MemoryRegionSection *[[clauses]]) { }
--------------------------------------------- Result 500 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 288 / 30 / 182 / 500:  19%|        | 500/2690 [5:09:32<22:35:49, 37.15s/it][Succeeded / Failed / Skipped / Total] 288 / 30 / 182 / 500:  19%|        | 501/2690 [5:09:41<22:33:07, 37.09s/it][Succeeded / Failed / Skipped / Total] 289 / 30 / 182 / 501:  19%|        | 501/2690 [5:09:41<22:33:07, 37.09s/it][Succeeded / Failed / Skipped / Total] 289 / 30 / 182 / 501:  19%|        | 502/2690 [5:10:37<22:33:54, 37.13s/it][[0 (32%)]] --> [[0 (61%)]] --> Socre: 0.610505223274231

[[[[Adv]]]]: static void spapr_hotplug_req_event(sPAPRDRConnector *[[drc]], uint8_t [[hp_action]]) { struct hp_log_full *new_hp; struct rtas_error_log *hdr; struct rtas_event_log_v6 *v6hdr; struct rtas_event_log_v6_maina *maina; struct rtas_event_log_v6_mainb *[[mainb]]; struct rtas_event_log_v6_hp *hp; sPAPRDRConnectorClass *[[drck]] = SPAPR_DR_CONNECTOR_GET_CLASS([[drc]]); sPAPRDRConnectorType [[drc_type]] = [[drck]]->get_type([[drc]]); new_hp = g_malloc0(sizeof(struct hp_log_full)); hdr = &new_hp->hdr; v6hdr = &new_hp->v6hdr; maina = &new_hp->maina; [[mainb]] = &new_hp->mainb; hp = &new_hp->hp; hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6 | RTAS_LOG_SEVERITY_EVENT | RTAS_LOG_DISPOSITION_NOT_RECOVERED | RTAS_LOG_OPTIONAL_PART_PRESENT | RTAS_LOG_INITIATOR_HOTPLUG | RTAS_LOG_TYPE_HOTPLUG); hdr->extended_length = cpu_to_be32(sizeof(*new_hp) - sizeof(new_hp->hdr)); spapr_init_v6hdr(v6hdr); spapr_init_maina(maina, 3 ); [[mainb]]->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB); [[mainb]]->hdr.section_length = cpu_to_be16(sizeof(*[[mainb]])); [[mainb]]->subsystem_id = 0x80; [[mainb]]->event_severity = 0x00; [[mainb]]->event_subtype = 0x00; hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG); hp->hdr.section_length = cpu_to_be16(sizeof(*hp)); hp->hdr.section_version = 1; hp->hotplug_action = [[hp_action]]; switch ([[drc_type]]) { case SPAPR_DR_CONNECTOR_TYPE_PCI: hp->drc.index = cpu_to_be32([[drck]]->get_index([[drc]])); hp->hotplug_identifier = RTAS_LOG_V6_HP_ID_DRC_INDEX; hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI; break; default: g_assert("False" != "False"); return; } rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp); qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq)); }

[[[[Adv]]]]: static void spapr_hotplug_req_event(sPAPRDRConnector *[[kubik]], uint8_t [[insinuated]]) { struct hp_log_full *new_hp; struct rtas_error_log *hdr; struct rtas_event_log_v6 *v6hdr; struct rtas_event_log_v6_maina *maina; struct rtas_event_log_v6_mainb *[[dragoons]]; struct rtas_event_log_v6_hp *hp; sPAPRDRConnectorClass *[[escorting]] = SPAPR_DR_CONNECTOR_GET_CLASS([[kubik]]); sPAPRDRConnectorType [[gremlins]] = [[escorting]]->get_type([[kubik]]); new_hp = g_malloc0(sizeof(struct hp_log_full)); hdr = &new_hp->hdr; v6hdr = &new_hp->v6hdr; maina = &new_hp->maina; [[dragoons]] = &new_hp->mainb; hp = &new_hp->hp; hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6 | RTAS_LOG_SEVERITY_EVENT | RTAS_LOG_DISPOSITION_NOT_RECOVERED | RTAS_LOG_OPTIONAL_PART_PRESENT | RTAS_LOG_INITIATOR_HOTPLUG | RTAS_LOG_TYPE_HOTPLUG); hdr->extended_length = cpu_to_be32(sizeof(*new_hp) - sizeof(new_hp->hdr)); spapr_init_v6hdr(v6hdr); spapr_init_maina(maina, 3 ); [[dragoons]]->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB); [[dragoons]]->hdr.section_length = cpu_to_be16(sizeof(*[[dragoons]])); [[dragoons]]->subsystem_id = 0x80; [[dragoons]]->event_severity = 0x00; [[dragoons]]->event_subtype = 0x00; hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG); hp->hdr.section_length = cpu_to_be16(sizeof(*hp)); hp->hdr.section_version = 1; hp->hotplug_action = [[insinuated]]; switch ([[gremlins]]) { case SPAPR_DR_CONNECTOR_TYPE_PCI: hp->drc.index = cpu_to_be32([[escorting]]->get_index([[kubik]])); hp->hotplug_identifier = RTAS_LOG_V6_HP_ID_DRC_INDEX; hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI; break; default: g_assert("False" != "False"); return; } rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp); qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq)); }
--------------------------------------------- Result 501 ---------------------------------------------
[[0 (3%)]] --> [[0 (98%)]] --> Socre: 0.9777073860168457

[[[[Adv]]]]: static TCGReg tcg_out_tlb_load(TCGContext *[[s]], TCGReg addr, int mem_index, TCGMemOp s_bits, int which) { const TCGReg r0 = TCG_REG_O0; const TCGReg r1 = TCG_REG_O1; const TCGReg r2 = TCG_REG_O2; int tlb_ofs; tcg_out_arithi([[s]], r1, addr, TARGET_PAGE_BITS, SHIFT_SRL); tcg_out_movi([[s]], TCG_TYPE_TL, TCG_REG_T1, TARGET_PAGE_MASK | ((1 << s_bits) - 1)); tcg_out_arithi([[s]], r1, r1, CPU_TLB_SIZE - 1, ARITH_AND); tcg_out_arith([[s]], r0, addr, TCG_REG_T1, ARITH_AND); tcg_out_arithi([[s]], r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL); tcg_out_arith([[s]], r1, TCG_AREG0, r1, ARITH_ADD); tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]); if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) { tcg_out_addi([[s]], r1, tlb_ofs & ~0x3ff); tlb_ofs &= 0x3ff; } tcg_out_ld([[s]], TCG_TYPE_TL, r2, r1, tlb_ofs + which); tcg_out_ld([[s]], TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend)); tcg_out_cmp([[s]], r0, r2, 0); if (SPARC64 && TARGET_LONG_BITS == 32) { tcg_out_arithi([[s]], r0, addr, 0, SHIFT_SRL); return r0; } return addr; }

[[[[Adv]]]]: static TCGReg tcg_out_tlb_load(TCGContext *[[nth]], TCGReg addr, int mem_index, TCGMemOp s_bits, int which) { const TCGReg r0 = TCG_REG_O0; const TCGReg r1 = TCG_REG_O1; const TCGReg r2 = TCG_REG_O2; int tlb_ofs; tcg_out_arithi([[nth]], r1, addr, TARGET_PAGE_BITS, SHIFT_SRL); tcg_out_movi([[nth]], TCG_TYPE_TL, TCG_REG_T1, TARGET_PAGE_MASK | ((1 << s_bits) - 1)); tcg_out_arithi([[nth]], r1, r1, CPU_TLB_SIZE - 1, ARITH_AND); tcg_out_arith([[nth]], r0, addr, TCG_REG_T1, ARITH_AND); tcg_out_arithi([[nth]], r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL); tcg_out_arith([[nth]], r1, TCG_AREG0, r1, ARITH_ADD); tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]); if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) { tcg_out_addi([[nth]], r1, tlb_ofs & ~0x3ff); tlb_ofs &= 0x3ff; } tcg_out_ld([[nth]], TCG_TYPE_TL, r2, r1, tlb_ofs + which); tcg_out_ld([[nth]], TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend)); tcg_out_cmp([[nth]], r0, r2, 0); if (SPARC64 && TARGET_LONG_BITS == 32) { tcg_out_arithi([[nth]], r0, addr, 0, SHIFT_SRL); return r0; } return addr; }
--------------------------------------------- Result 502 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 290 / 30 / 182 / 502:  19%|        | 502/2690 [5:10:37<22:33:54, 37.13s/it][Succeeded / Failed / Skipped / Total] 290 / 30 / 182 / 502:  19%|        | 503/2690 [5:10:38<22:30:38, 37.05s/it][Succeeded / Failed / Skipped / Total] 290 / 30 / 183 / 503:  19%|        | 503/2690 [5:10:38<22:30:38, 37.05s/it][Succeeded / Failed / Skipped / Total] 290 / 30 / 183 / 503:  19%|        | 504/2690 [5:10:41<22:27:31, 36.99s/it][Succeeded / Failed / Skipped / Total] 291 / 30 / 183 / 504:  19%|        | 504/2690 [5:10:41<22:27:31, 36.99s/it][Succeeded / Failed / Skipped / Total] 291 / 30 / 183 / 504:  19%|        | 505/2690 [5:10:41<22:24:16, 36.91s/it][Succeeded / Failed / Skipped / Total] 291 / 30 / 184 / 505:  19%|        | 505/2690 [5:10:41<22:24:16, 36.91s/it][Succeeded / Failed / Skipped / Total] 291 / 30 / 184 / 505:  19%|        | 506/2690 [5:10:41<22:21:02, 36.84s/it][Succeeded / Failed / Skipped / Total] 291 / 30 / 185 / 506:  19%|        | 506/2690 [5:10:41<22:21:02, 36.84s/it][Succeeded / Failed / Skipped / Total] 291 / 30 / 185 / 506:  19%|        | 507/2690 [5:11:10<22:19:51, 36.83s/it][[0 (78%)]] --> [[0 (49%)]] --> Socre: 0.51453697681427

[[[[Adv]]]]: static int matroska_decode_buffer(uint8_t** buf, int* buf_size, MatroskaTrack *track) { MatroskaTrackEncoding *[[encodings]] = track->encodings.elem; uint8_t* data = *buf; int isize = *buf_size; uint8_t* [[pkt_data]] = NULL; int pkt_size = isize; int result = 0; int olen; if (pkt_size >= 10000000) return -1; switch ([[encodings]][0].compression.algo) { case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP: return [[encodings]][0].compression.settings.size; case MATROSKA_TRACK_ENCODING_COMP_LZO: do { olen = pkt_size *= 3; [[pkt_data]] = av_realloc([[pkt_data]], pkt_size+AV_LZO_OUTPUT_PADDING); result = av_lzo1x_decode([[pkt_data]], &olen, data, &isize); } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000); if (result) goto failed; pkt_size -= olen; break; #if CONFIG_ZLIB case MATROSKA_TRACK_ENCODING_COMP_ZLIB: { z_stream zstream = {0}; if (inflateInit(&zstream) != Z_OK) return -1; zstream.next_in = data; zstream.avail_in = isize; do { pkt_size *= 3; [[pkt_data]] = av_realloc([[pkt_data]], pkt_size); zstream.avail_out = pkt_size - zstream.total_out; zstream.next_out = [[pkt_data]] + zstream.total_out; result = inflate(&zstream, Z_NO_FLUSH); } while (result==Z_OK && pkt_size<10000000); pkt_size = zstream.total_out; inflateEnd(&zstream); if (result != Z_STREAM_END) goto failed; break; } #endif #if CONFIG_BZLIB case MATROSKA_TRACK_ENCODING_COMP_BZLIB: { bz_stream bzstream = {0}; if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK) return -1; bzstream.next_in = data; bzstream.avail_in = isize; do { pkt_size *= 3; [[pkt_data]] = av_realloc([[pkt_data]], pkt_size); bzstream.avail_out = pkt_size - bzstream.total_out_lo32; bzstream.next_out = [[pkt_data]] + bzstream.total_out_lo32; result = BZ2_bzDecompress(&bzstream); } while (result==BZ_OK && pkt_size<10000000); pkt_size = bzstream.total_out_lo32; BZ2_bzDecompressEnd(&bzstream); if (result != BZ_STREAM_END) goto failed; break; } #endif default: return -1; } *buf = [[pkt_data]]; *buf_size = pkt_size; return 0; failed: av_free([[pkt_data]]); return -1; }

[[[[Adv]]]]: static int matroska_decode_buffer(uint8_t** buf, int* buf_size, MatroskaTrack *track) { MatroskaTrackEncoding *[[lublin]] = track->encodings.elem; uint8_t* data = *buf; int isize = *buf_size; uint8_t* [[iscariot]] = NULL; int pkt_size = isize; int result = 0; int olen; if (pkt_size >= 10000000) return -1; switch ([[lublin]][0].compression.algo) { case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP: return [[lublin]][0].compression.settings.size; case MATROSKA_TRACK_ENCODING_COMP_LZO: do { olen = pkt_size *= 3; [[iscariot]] = av_realloc([[iscariot]], pkt_size+AV_LZO_OUTPUT_PADDING); result = av_lzo1x_decode([[iscariot]], &olen, data, &isize); } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000); if (result) goto failed; pkt_size -= olen; break; #if CONFIG_ZLIB case MATROSKA_TRACK_ENCODING_COMP_ZLIB: { z_stream zstream = {0}; if (inflateInit(&zstream) != Z_OK) return -1; zstream.next_in = data; zstream.avail_in = isize; do { pkt_size *= 3; [[iscariot]] = av_realloc([[iscariot]], pkt_size); zstream.avail_out = pkt_size - zstream.total_out; zstream.next_out = [[iscariot]] + zstream.total_out; result = inflate(&zstream, Z_NO_FLUSH); } while (result==Z_OK && pkt_size<10000000); pkt_size = zstream.total_out; inflateEnd(&zstream); if (result != Z_STREAM_END) goto failed; break; } #endif #if CONFIG_BZLIB case MATROSKA_TRACK_ENCODING_COMP_BZLIB: { bz_stream bzstream = {0}; if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK) return -1; bzstream.next_in = data; bzstream.avail_in = isize; do { pkt_size *= 3; [[iscariot]] = av_realloc([[iscariot]], pkt_size); bzstream.avail_out = pkt_size - bzstream.total_out_lo32; bzstream.next_out = [[iscariot]] + bzstream.total_out_lo32; result = BZ2_bzDecompress(&bzstream); } while (result==BZ_OK && pkt_size<10000000); pkt_size = bzstream.total_out_lo32; BZ2_bzDecompressEnd(&bzstream); if (result != BZ_STREAM_END) goto failed; break; } #endif default: return -1; } *buf = [[iscariot]]; *buf_size = pkt_size; return 0; failed: av_free([[iscariot]]); return -1; }
--------------------------------------------- Result 503 ---------------------------------------------
[[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: SwsFunc yuv2rgb_get_func_ptr (SwsContext *c) { #if defined(HAVE_MMX2) || defined(HAVE_MMX) if(c->flags & SWS_CPU_CAPS_MMX2){ switch(c->dstFormat){ case PIX_FMT_RGB32: return yuv420_rgb32_MMX2; case PIX_FMT_BGR24: return yuv420_rgb24_MMX2; case PIX_FMT_BGR565: return yuv420_rgb16_MMX2; case PIX_FMT_BGR555: return yuv420_rgb15_MMX2; } } if(c->flags & SWS_CPU_CAPS_MMX){ switch(c->dstFormat){ case PIX_FMT_RGB32: return yuv420_rgb32_MMX; case PIX_FMT_BGR24: return yuv420_rgb24_MMX; case PIX_FMT_BGR565: return yuv420_rgb16_MMX; case PIX_FMT_BGR555: return yuv420_rgb15_MMX; } } #endif #ifdef HAVE_MLIB { SwsFunc t= yuv2rgb_init_mlib(c); if(t) return t; } #endif #ifdef HAVE_ALTIVEC if (c->flags & SWS_CPU_CAPS_ALTIVEC) { SwsFunc t = yuv2rgb_init_altivec(c); if(t) return t; } #endif av_log(c, AV_LOG_WARNING, "No accelerated colorspace conversion found\n"); switch(c->dstFormat){ case PIX_FMT_BGR32: case PIX_FMT_RGB32: return yuv2rgb_c_32; case PIX_FMT_RGB24: return yuv2rgb_c_24_rgb; case PIX_FMT_BGR24: return yuv2rgb_c_24_bgr; case PIX_FMT_RGB565: case PIX_FMT_BGR565: case PIX_FMT_RGB555: case PIX_FMT_BGR555: return yuv2rgb_c_16; case PIX_FMT_RGB8: case PIX_FMT_BGR8: return yuv2rgb_c_8_ordered_dither; case PIX_FMT_RGB4: case PIX_FMT_BGR4: return yuv2rgb_c_4_ordered_dither; case PIX_FMT_RGB4_BYTE: case PIX_FMT_BGR4_BYTE: return yuv2rgb_c_4b_ordered_dither; case PIX_FMT_MONOBLACK: return yuv2rgb_c_1_ordered_dither; default: assert(0); } return NULL; }
--------------------------------------------- Result 504 ---------------------------------------------
[[0 (50%)]] --> [[0 (44%)]] --> Socre: 0.5600932538509369

[[[[Adv]]]]: static void vnc_set_share_mode(VncState *vs, VncShareMode mode) { #ifdef _VNC_DEBUG static const char *[[mn]][] = { [0] = "undefined", [VNC_SHARE_MODE_CONNECTING] = "connecting", [VNC_SHARE_MODE_SHARED] = "shared", [VNC_SHARE_MODE_EXCLUSIVE] = "exclusive", [VNC_SHARE_MODE_DISCONNECTED] = "disconnected", }; fprintf(stderr, "%s/%d: %s -> %s\n", __func__, vs->csock, [[mn]][vs->share_mode], [[mn]][mode]); #endif if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) { vs->vd->num_exclusive--; } vs->share_mode = mode; if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) { vs->vd->num_exclusive++; } }

[[[[Adv]]]]: static void vnc_set_share_mode(VncState *vs, VncShareMode mode) { #ifdef _VNC_DEBUG static const char *[[minneapolis]][] = { [0] = "undefined", [VNC_SHARE_MODE_CONNECTING] = "connecting", [VNC_SHARE_MODE_SHARED] = "shared", [VNC_SHARE_MODE_EXCLUSIVE] = "exclusive", [VNC_SHARE_MODE_DISCONNECTED] = "disconnected", }; fprintf(stderr, "%s/%d: %s -> %s\n", __func__, vs->csock, [[minneapolis]][vs->share_mode], [[minneapolis]][mode]); #endif if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) { vs->vd->num_exclusive--; } vs->share_mode = mode; if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) { vs->vd->num_exclusive++; } }
--------------------------------------------- Result 505 ---------------------------------------------
[[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size) { uint32_t scratch = 0; const uint8_t *buf_end = buf + buf_size; for (; buf < buf_end - 3; buf += 4) scratch ^= *((const uint32_t*)buf); scratch = xor_32_to_8(scratch); for (; buf < buf_end; buf++) return scratch; }
--------------------------------------------- Result 506 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_er_frame_start(ERContext *s) { if (!s->avctx->err_recognition) return; memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END, s->mb_stride * s->mb_height * sizeof(uint8_t)); s->error_count = 3 * s->mb_num; s->error_occurred = 0; }
--------------------------------------------- Result 507 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 292 / 30 / 185 / 507:  19%|        | 507/2690 [5:11:10<22:19:51, 36.83s/it][Succeeded / Failed / Skipped / Total] 292 / 30 / 185 / 507:  19%|        | 508/2690 [5:11:11<22:16:39, 36.75s/it][Succeeded / Failed / Skipped / Total] 292 / 30 / 186 / 508:  19%|        | 508/2690 [5:11:11<22:16:39, 36.75s/it][Succeeded / Failed / Skipped / Total] 292 / 30 / 186 / 508:  19%|        | 509/2690 [5:11:50<22:16:11, 36.76s/it][Succeeded / Failed / Skipped / Total] 293 / 30 / 186 / 509:  19%|        | 509/2690 [5:11:50<22:16:11, 36.76s/it][Succeeded / Failed / Skipped / Total] 293 / 30 / 186 / 509:  19%|        | 510/2690 [5:12:45<22:16:51, 36.79s/it][[0 (4%)]] --> [[0 (80%)]] --> Socre: 0.8009800314903259

[[[[Adv]]]]: void ich9_pm_init(PCIDevice *[[lpc_pci]], ICH9LPCPMRegs *[[pm]], qemu_irq [[sci_irq]]) { memory_region_init(&[[pm]]->io, OBJECT([[lpc_pci]]), "ich9-pm", ICH9_PMIO_SIZE); memory_region_set_enabled(&[[pm]]->io, "False" != "False"); memory_region_add_subregion(pci_address_space_io([[lpc_pci]]), 0, &[[pm]]->io); acpi_pm_tmr_init(&[[pm]]->acpi_regs, ich9_pm_update_sci_fn, &[[pm]]->io); acpi_pm1_evt_init(&[[pm]]->acpi_regs, ich9_pm_update_sci_fn, &[[pm]]->io); acpi_pm1_cnt_init(&[[pm]]->acpi_regs, &[[pm]]->io, [[pm]]->s4_val); acpi_gpe_init(&[[pm]]->acpi_regs, ICH9_PMIO_GPE0_LEN); memory_region_init_io(&[[pm]]->io_gpe, OBJECT([[lpc_pci]]), &ich9_gpe_ops, [[pm]], "acpi-gpe0", ICH9_PMIO_GPE0_LEN); memory_region_add_subregion(&[[pm]]->io, ICH9_PMIO_GPE0_STS, &[[pm]]->io_gpe); memory_region_init_io(&[[pm]]->io_smi, OBJECT([[lpc_pci]]), &ich9_smi_ops, [[pm]], "acpi-smi", 8); memory_region_add_subregion(&[[pm]]->io, ICH9_PMIO_SMI_EN, &[[pm]]->io_smi); [[pm]]->irq = [[sci_irq]]; qemu_register_reset(pm_reset, [[pm]]); [[pm]]->powerdown_notifier.notify = pm_powerdown_req; qemu_register_powerdown_notifier(&[[pm]]->powerdown_notifier); acpi_cpu_hotplug_init(pci_address_space_io([[lpc_pci]]), OBJECT([[lpc_pci]]), &[[pm]]->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE); if ([[pm]]->acpi_memory_hotplug.is_enabled) { acpi_memory_hotplug_init(pci_address_space_io([[lpc_pci]]), OBJECT([[lpc_pci]]), &[[pm]]->acpi_memory_hotplug); } }

[[[[Adv]]]]: void ich9_pm_init(PCIDevice *[[norwood]], ICH9LPCPMRegs *[[nuit]], qemu_irq [[jalapeo]]) { memory_region_init(&[[nuit]]->io, OBJECT([[norwood]]), "ich9-pm", ICH9_PMIO_SIZE); memory_region_set_enabled(&[[nuit]]->io, "False" != "False"); memory_region_add_subregion(pci_address_space_io([[norwood]]), 0, &[[nuit]]->io); acpi_pm_tmr_init(&[[nuit]]->acpi_regs, ich9_pm_update_sci_fn, &[[nuit]]->io); acpi_pm1_evt_init(&[[nuit]]->acpi_regs, ich9_pm_update_sci_fn, &[[nuit]]->io); acpi_pm1_cnt_init(&[[nuit]]->acpi_regs, &[[nuit]]->io, [[nuit]]->s4_val); acpi_gpe_init(&[[nuit]]->acpi_regs, ICH9_PMIO_GPE0_LEN); memory_region_init_io(&[[nuit]]->io_gpe, OBJECT([[norwood]]), &ich9_gpe_ops, [[nuit]], "acpi-gpe0", ICH9_PMIO_GPE0_LEN); memory_region_add_subregion(&[[nuit]]->io, ICH9_PMIO_GPE0_STS, &[[nuit]]->io_gpe); memory_region_init_io(&[[nuit]]->io_smi, OBJECT([[norwood]]), &ich9_smi_ops, [[nuit]], "acpi-smi", 8); memory_region_add_subregion(&[[nuit]]->io, ICH9_PMIO_SMI_EN, &[[nuit]]->io_smi); [[nuit]]->irq = [[jalapeo]]; qemu_register_reset(pm_reset, [[nuit]]); [[nuit]]->powerdown_notifier.notify = pm_powerdown_req; qemu_register_powerdown_notifier(&[[nuit]]->powerdown_notifier); acpi_cpu_hotplug_init(pci_address_space_io([[norwood]]), OBJECT([[norwood]]), &[[nuit]]->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE); if ([[nuit]]->acpi_memory_hotplug.is_enabled) { acpi_memory_hotplug_init(pci_address_space_io([[norwood]]), OBJECT([[norwood]]), &[[nuit]]->acpi_memory_hotplug); } }
--------------------------------------------- Result 508 ---------------------------------------------
[[0 (90%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt, const char *filename, void *logctx, unsigned int offset, unsigned int max_probe_size) { AVProbeData pd = { filename ? filename : "", NULL, -offset }; unsigned char *buf = NULL; int ret = 0, probe_size; if (!max_probe_size) { max_probe_size = PROBE_BUF_MAX; } else if (max_probe_size > PROBE_BUF_MAX) { max_probe_size = PROBE_BUF_MAX; } else if (max_probe_size < PROBE_BUF_MIN) { return AVERROR(EINVAL); } if (offset >= max_probe_size) { return AVERROR(EINVAL); } for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt; probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) { int score = probe_size < max_probe_size ? AVPROBE_SCORE_RETRY : 0; int buf_offset = (probe_size == PROBE_BUF_MIN) ? 0 : probe_size>>1; void *buftmp; if (probe_size < offset) { continue; } buftmp = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE); if(!buftmp){ av_free(buf); return AVERROR(ENOMEM); } buf=buftmp; if ((ret = avio_read(pb, buf + buf_offset, probe_size - buf_offset)) < 0) { if (ret != AVERROR_EOF) { av_free(buf); return ret; } score = 0; ret = 0; } pd.buf_size += ret; pd.buf = &buf[offset]; memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE); *fmt = av_probe_input_format2(&pd, 1, &score); if(*fmt){ if(score <= AVPROBE_SCORE_RETRY){ av_log(logctx, AV_LOG_WARNING, "Format %s detected only with low score of %d, misdetection possible!\n", (*fmt)->name, score); }else av_log(logctx, AV_LOG_DEBUG, "Format %s probed with size=%d and score=%d\n", (*fmt)->name, probe_size, score); } } if (!*fmt) { av_free(buf); return AVERROR_INVALIDDATA; } ret = ffio_rewind_with_probe_data(pb, &buf, pd.buf_size); return ret; }
--------------------------------------------- Result 509 ---------------------------------------------
[[0 (69%)]] --> [[0 (47%)]] --> Socre: 0.5337728559970856

[[[[Adv]]]]: static void slirp_smb(SlirpState* s, Monitor *mon, const char *[[exported_dir]], struct in_addr vserver_addr) { static int instance; char smb_conf[128]; char [[smb_cmdline]][128]; FILE *f; snprintf(s->smb_dir, sizeof(s->smb_dir), "/tmp/qemu-smb.%ld-%d", (long)getpid(), instance++); if (mkdir(s->smb_dir, 0700) < 0) { config_error(mon, "could not create samba server dir '%s'\n", s->smb_dir); return; } snprintf(smb_conf, sizeof(smb_conf), "%s/%s", s->smb_dir, "smb.conf"); f = fopen(smb_conf, "w"); if (!f) { slirp_smb_cleanup(s); config_error(mon, "could not create samba server " "configuration file '%s'\n", smb_conf); return; } fprintf(f, "[global]\n" "private dir=%s\n" "smb ports=0\n" "socket address=127.0.0.1\n" "pid directory=%s\n" "lock directory=%s\n" "log file=%s/log.smbd\n" "smb passwd file=%s/smbpasswd\n" "security = share\n" "[qemu]\n" "path=%s\n" "read only=no\n" "guest ok=yes\n", s->smb_dir, s->smb_dir, s->smb_dir, s->smb_dir, s->smb_dir, [[exported_dir]] ); fclose(f); snprintf([[smb_cmdline]], sizeof([[smb_cmdline]]), "%s -s %s", SMBD_COMMAND, smb_conf); if (slirp_add_exec(s->slirp, 0, [[smb_cmdline]], &vserver_addr, 139) < 0) { slirp_smb_cleanup(s); config_error(mon, "conflicting/invalid smbserver address\n"); } }

[[[[Adv]]]]: static void slirp_smb(SlirpState* s, Monitor *mon, const char *[[hypo]], struct in_addr vserver_addr) { static int instance; char smb_conf[128]; char [[drumroll]][128]; FILE *f; snprintf(s->smb_dir, sizeof(s->smb_dir), "/tmp/qemu-smb.%ld-%d", (long)getpid(), instance++); if (mkdir(s->smb_dir, 0700) < 0) { config_error(mon, "could not create samba server dir '%s'\n", s->smb_dir); return; } snprintf(smb_conf, sizeof(smb_conf), "%s/%s", s->smb_dir, "smb.conf"); f = fopen(smb_conf, "w"); if (!f) { slirp_smb_cleanup(s); config_error(mon, "could not create samba server " "configuration file '%s'\n", smb_conf); return; } fprintf(f, "[global]\n" "private dir=%s\n" "smb ports=0\n" "socket address=127.0.0.1\n" "pid directory=%s\n" "lock directory=%s\n" "log file=%s/log.smbd\n" "smb passwd file=%s/smbpasswd\n" "security = share\n" "[qemu]\n" "path=%s\n" "read only=no\n" "guest ok=yes\n", s->smb_dir, s->smb_dir, s->smb_dir, s->smb_dir, s->smb_dir, [[hypo]] ); fclose(f); snprintf([[drumroll]], sizeof([[drumroll]]), "%s -s %s", SMBD_COMMAND, smb_conf); if (slirp_add_exec(s->slirp, 0, [[drumroll]], &vserver_addr, 139) < 0) { slirp_smb_cleanup(s); config_error(mon, "conflicting/invalid smbserver address\n"); } }
--------------------------------------------- Result 510 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 294 / 30 / 186 / 510:  19%|        | 510/2690 [5:12:45<22:16:51, 36.79s/it][Succeeded / Failed / Skipped / Total] 294 / 30 / 186 / 510:  19%|        | 511/2690 [5:12:45<22:13:40, 36.72s/it][Succeeded / Failed / Skipped / Total] 294 / 30 / 187 / 511:  19%|        | 511/2690 [5:12:45<22:13:40, 36.72s/it][Succeeded / Failed / Skipped / Total] 294 / 30 / 187 / 511:  19%|        | 512/2690 [5:12:51<22:10:54, 36.66s/it][Succeeded / Failed / Skipped / Total] 295 / 30 / 187 / 512:  19%|        | 512/2690 [5:12:51<22:10:54, 36.66s/it][Succeeded / Failed / Skipped / Total] 295 / 30 / 187 / 512:  19%|        | 513/2690 [5:12:52<22:07:44, 36.59s/it][Succeeded / Failed / Skipped / Total] 295 / 30 / 188 / 513:  19%|        | 513/2690 [5:12:52<22:07:44, 36.59s/it][Succeeded / Failed / Skipped / Total] 295 / 30 / 188 / 513:  19%|        | 514/2690 [5:12:57<22:04:51, 36.53s/it][[0 (20%)]] --> [[0 (51%)]] --> Socre: 0.5096138715744019

[[[[Adv]]]]: static int curl_sock_cb(CURL *curl, curl_socket_t fd, int [[action]], void *s, void *sp) { DPRINTF("CURL (AIO): Sock action %d on fd %d\n", [[action]], fd); switch ([[action]]) { case CURL_POLL_IN: qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s); break; case CURL_POLL_OUT: qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s); break; case CURL_POLL_INOUT: qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s); break; case CURL_POLL_REMOVE: qemu_aio_set_fd_handler(fd, NULL, NULL, NULL); break; } return 0; }

[[[[Adv]]]]: static int curl_sock_cb(CURL *curl, curl_socket_t fd, int [[intervention]], void *s, void *sp) { DPRINTF("CURL (AIO): Sock action %d on fd %d\n", [[intervention]], fd); switch ([[intervention]]) { case CURL_POLL_IN: qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s); break; case CURL_POLL_OUT: qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s); break; case CURL_POLL_INOUT: qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s); break; case CURL_POLL_REMOVE: qemu_aio_set_fd_handler(fd, NULL, NULL, NULL); break; } return 0; }
--------------------------------------------- Result 511 ---------------------------------------------
[[0 (55%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void *slavio_intctl_init(target_phys_addr_t addr, target_phys_addr_t addrg, const uint32_t *intbit_to_level, qemu_irq **irq, qemu_irq **cpu_irq, unsigned int cputimer) { int slavio_intctl_io_memory, slavio_intctlm_io_memory, i; SLAVIO_INTCTLState *s; s = qemu_mallocz(sizeof(SLAVIO_INTCTLState)); if (!s) return NULL; s->intbit_to_level = intbit_to_level; for (i = 0; i < MAX_CPUS; i++) { slavio_intctl_io_memory = cpu_register_io_memory(0, slavio_intctl_mem_read, slavio_intctl_mem_write, s); cpu_register_physical_memory(addr + i * TARGET_PAGE_SIZE, INTCTL_SIZE, slavio_intctl_io_memory); } slavio_intctlm_io_memory = cpu_register_io_memory(0, slavio_intctlm_mem_read, slavio_intctlm_mem_write, s); cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory); register_savevm("slavio_intctl", addr, 1, slavio_intctl_save, slavio_intctl_load, s); qemu_register_reset(slavio_intctl_reset, s); *irq = qemu_allocate_irqs(slavio_set_irq, s, 32); *cpu_irq = qemu_allocate_irqs(slavio_set_timer_irq_cpu, s, MAX_CPUS); s->cputimer_bit = 1 << s->intbit_to_level[cputimer]; slavio_intctl_reset(s); return s; }
--------------------------------------------- Result 512 ---------------------------------------------
[[0 (32%)]] --> [[0 (54%)]] --> Socre: 0.5444313883781433

[[[[Adv]]]]: static void start_children(FFStream *feed) { if (no_launch) return; for (; feed; feed = feed->next) { if (feed->child_argv && !feed->pid) { feed->pid_start = time(0); feed->pid = fork(); if (feed->pid < 0) { http_log("Unable to create children\n"); exit(1); } if (!feed->pid) { char pathname[1024]; char *slash; int [[i]]; av_strlcpy(pathname, my_program_name, sizeof(pathname)); slash = strrchr(pathname, '/'); if (!slash) slash = pathname; else slash++; strcpy(slash, "ffmpeg"); http_log("Launch command line: "); http_log("%s ", pathname); for ([[i]] = 1; feed->child_argv[[[i]]] && feed->child_argv[[[i]]][0]; [[i]]++) http_log("%s ", feed->child_argv[[[i]]]); http_log("\n"); for ([[i]] = 3; [[i]] < 256; [[i]]++) close([[i]]); if (!ffserver_debug) { [[i]] = open("/dev/null", O_RDWR); if ([[i]] != -1) { dup2([[i]], 0); dup2([[i]], 1); dup2([[i]], 2); close([[i]]); } } chdir(my_program_dir); signal(SIGPIPE, SIG_DFL); execvp(pathname, feed->child_argv); _exit(1); } } } }

[[[[Adv]]]]: static void start_children(FFStream *feed) { if (no_launch) return; for (; feed; feed = feed->next) { if (feed->child_argv && !feed->pid) { feed->pid_start = time(0); feed->pid = fork(); if (feed->pid < 0) { http_log("Unable to create children\n"); exit(1); } if (!feed->pid) { char pathname[1024]; char *slash; int [[johnson]]; av_strlcpy(pathname, my_program_name, sizeof(pathname)); slash = strrchr(pathname, '/'); if (!slash) slash = pathname; else slash++; strcpy(slash, "ffmpeg"); http_log("Launch command line: "); http_log("%s ", pathname); for ([[johnson]] = 1; feed->child_argv[[[johnson]]] && feed->child_argv[[[johnson]]][0]; [[johnson]]++) http_log("%s ", feed->child_argv[[[johnson]]]); http_log("\n"); for ([[johnson]] = 3; [[johnson]] < 256; [[johnson]]++) close([[johnson]]); if (!ffserver_debug) { [[johnson]] = open("/dev/null", O_RDWR); if ([[johnson]] != -1) { dup2([[johnson]], 0); dup2([[johnson]], 1); dup2([[johnson]], 2); close([[johnson]]); } } chdir(my_program_dir); signal(SIGPIPE, SIG_DFL); execvp(pathname, feed->child_argv); _exit(1); } } } }
--------------------------------------------- Result 513 ---------------------------------------------
[[0 (29%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp) { MOVContext *mov = s->priv_data; int i, j; if (!mov->fragment_index_complete) return 0; for (i = 0; i < mov->fragment_index_count; i++) { if (mov->fragment_index_data[i]->track_id == st->id) { MOVFragmentIndex *index = index = mov->fragment_index_data[i]; for (j = index->item_count - 1; j >= 0; j--) { if (index->items[j].time <= timestamp) { if (index->items[j].headers_read) return 0; return mov_switch_root(s, index->items[j].moof_offset); } } } } return 0; }
--------------------------------------------- Result 514 ---------------------------------------------
[[0 (41%)]] --> [[0 (84%)]] --> Socre: 0.8383812308311462

[[[[Adv]]]]: av_cold int MPV_common_init(MpegEncContext *s) { int [[y_size]], c_size, yc_size, i, mb_array_size, mv_table_size, x, y, threads; if(s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence) s->mb_height = (s->height + 31) / 32 * 2; else if (s->codec_id != CODEC_ID_H264) s->mb_height = (s->height + 15) / 16; if(s->avctx->pix_fmt == PIX_FMT_NONE){ av_log(s->avctx, AV_LOG_ERROR, "decoding to PIX_FMT_NONE is not supported.\n"); return -1; } if((s->encoding || (s->avctx->active_thread_type & FF_THREAD_SLICE)) && (s->avctx->thread_count > MAX_THREADS || (s->avctx->thread_count > s->mb_height && s->mb_height))){ av_log(s->avctx, AV_LOG_ERROR, "too many threads\n"); return -1; } if((s->width || s->height) && av_image_check_size(s->width, s->height, 0, s->avctx)) return -1; dsputil_init(&s->dsp, s->avctx); ff_dct_common_init(s); s->flags= s->avctx->flags; s->flags2= s->avctx->flags2; if (s->width && s->height) { s->mb_width = (s->width + 15) / 16; s->mb_stride = s->mb_width + 1; s->b8_stride = s->mb_width*2 + 1; s->b4_stride = s->mb_width*4 + 1; mb_array_size= s->mb_height * s->mb_stride; mv_table_size= (s->mb_height+2) * s->mb_stride + 1; avcodec_get_chroma_sub_sample(s->avctx->pix_fmt,&(s->chroma_x_shift), &(s->chroma_y_shift) ); s->h_edge_pos= s->mb_width*16; s->v_edge_pos= s->mb_height*16; s->mb_num = s->mb_width * s->mb_height; s->block_wrap[0]= s->block_wrap[1]= s->block_wrap[2]= s->block_wrap[3]= s->b8_stride; s->block_wrap[4]= s->block_wrap[5]= s->mb_stride; [[y_size]] = s->b8_stride * (2 * s->mb_height + 1); c_size = s->mb_stride * (s->mb_height + 1); yc_size = [[y_size]] + 2 * c_size; s->codec_tag = ff_toupper4(s->avctx->codec_tag); s->stream_codec_tag = ff_toupper4(s->avctx->stream_codec_tag); s->avctx->coded_frame= (AVFrame*)&s->current_picture; FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_index2xy, (s->mb_num+1)*sizeof(int), fail) for(y=0; y<s->mb_height; y++){ for(x=0; x<s->mb_width; x++){ s->mb_index2xy[ x + y*s->mb_width ] = x + y*s->mb_stride; } } s->mb_index2xy[ s->mb_height*s->mb_width ] = (s->mb_height-1)*s->mb_stride + s->mb_width; if (s->encoding) { FF_ALLOCZ_OR_GOTO(s->avctx, s->p_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_direct_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) s->p_mv_table = s->p_mv_table_base + s->mb_stride + 1; s->b_forw_mv_table = s->b_forw_mv_table_base + s->mb_stride + 1; s->b_back_mv_table = s->b_back_mv_table_base + s->mb_stride + 1; s->b_bidir_forw_mv_table= s->b_bidir_forw_mv_table_base + s->mb_stride + 1; s->b_bidir_back_mv_table= s->b_bidir_back_mv_table_base + s->mb_stride + 1; s->b_direct_mv_table = s->b_direct_mv_table_base + s->mb_stride + 1; if(s->msmpeg4_version){ FF_ALLOCZ_OR_GOTO(s->avctx, s->ac_stats, 2*2*(MAX_LEVEL+1)*(MAX_RUN+1)*2*sizeof(int), fail); } FF_ALLOCZ_OR_GOTO(s->avctx, s->avctx->stats_out, 256, fail); FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_type , mb_array_size * sizeof(uint16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->lambda_table, mb_array_size * sizeof(int), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix , 64*32 * sizeof(int), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix , 64*32 * sizeof(int), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix16, 64*32*2 * sizeof(uint16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix16, 64*32*2 * sizeof(uint16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->reordered_input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail) if(s->avctx->noise_reduction){ FF_ALLOCZ_OR_GOTO(s->avctx, s->dct_offset, 2 * 64 * sizeof(uint16_t), fail) } } } s->picture_count = MAX_PICTURE_COUNT * FFMAX(1, s->avctx->thread_count); FF_ALLOCZ_OR_GOTO(s->avctx, s->picture, s->picture_count * sizeof(Picture), fail) for(i = 0; i < s->picture_count; i++) { avcodec_get_frame_defaults((AVFrame *)&s->picture[i]); } if (s->width && s->height) { FF_ALLOCZ_OR_GOTO(s->avctx, s->error_status_table, mb_array_size*sizeof(uint8_t), fail) if(s->codec_id==CODEC_ID_MPEG4 || (s->flags & CODEC_FLAG_INTERLACED_ME)){ for(i=0; i<2; i++){ int j, k; for(j=0; j<2; j++){ for(k=0; k<2; k++){ FF_ALLOCZ_OR_GOTO(s->avctx, s->b_field_mv_table_base[i][j][k], mv_table_size * 2 * sizeof(int16_t), fail) s->b_field_mv_table[i][j][k] = s->b_field_mv_table_base[i][j][k] + s->mb_stride + 1; } FF_ALLOCZ_OR_GOTO(s->avctx, s->b_field_select_table [i][j], mb_array_size * 2 * sizeof(uint8_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_mv_table_base[i][j], mv_table_size * 2 * sizeof(int16_t), fail) s->p_field_mv_table[i][j] = s->p_field_mv_table_base[i][j]+ s->mb_stride + 1; } FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_select_table[i], mb_array_size * 2 * sizeof(uint8_t), fail) } } if (s->out_format == FMT_H263) { FF_ALLOCZ_OR_GOTO(s->avctx, s->coded_block_base, [[y_size]], fail); s->coded_block= s->coded_block_base + s->b8_stride + 1; FF_ALLOCZ_OR_GOTO(s->avctx, s->cbp_table , mb_array_size * sizeof(uint8_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->pred_dir_table, mb_array_size * sizeof(uint8_t), fail) } if (s->h263_pred || s->h263_plus || !s->encoding) { FF_ALLOCZ_OR_GOTO(s->avctx, s->dc_val_base, yc_size * sizeof(int16_t), fail); s->dc_val[0] = s->dc_val_base + s->b8_stride + 1; s->dc_val[1] = s->dc_val_base + [[y_size]] + s->mb_stride + 1; s->dc_val[2] = s->dc_val[1] + c_size; for(i=0;i<yc_size;i++) s->dc_val_base[i] = 1024; } FF_ALLOCZ_OR_GOTO(s->avctx, s->mbintra_table, mb_array_size, fail); memset(s->mbintra_table, 1, mb_array_size); FF_ALLOCZ_OR_GOTO(s->avctx, s->mbskip_table, mb_array_size+2, fail); FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail); s->parse_context.state= -1; if((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){ s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH); s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH); s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH); } } s->context_initialized = 1; s->thread_context[0]= s; if (s->width && s->height) { if (s->encoding || (HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_SLICE)) { threads = s->avctx->thread_count; for(i=1; i<threads; i++){ s->thread_context[i]= av_malloc(sizeof(MpegEncContext)); memcpy(s->thread_context[i], s, sizeof(MpegEncContext)); } for(i=0; i<threads; i++){ if(init_duplicate_context(s->thread_context[i], s) < 0) goto fail; s->thread_context[i]->start_mb_y= (s->mb_height*(i ) + s->avctx->thread_count/2) / s->avctx->thread_count; s->thread_context[i]->end_mb_y = (s->mb_height*(i+1) + s->avctx->thread_count/2) / s->avctx->thread_count; } } else { if(init_duplicate_context(s, s) < 0) goto fail; s->start_mb_y = 0; s->end_mb_y = s->mb_height; } } return 0; fail: MPV_common_end(s); return -1; }

[[[[Adv]]]]: av_cold int MPV_common_init(MpegEncContext *s) { int [[pap]], c_size, yc_size, i, mb_array_size, mv_table_size, x, y, threads; if(s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence) s->mb_height = (s->height + 31) / 32 * 2; else if (s->codec_id != CODEC_ID_H264) s->mb_height = (s->height + 15) / 16; if(s->avctx->pix_fmt == PIX_FMT_NONE){ av_log(s->avctx, AV_LOG_ERROR, "decoding to PIX_FMT_NONE is not supported.\n"); return -1; } if((s->encoding || (s->avctx->active_thread_type & FF_THREAD_SLICE)) && (s->avctx->thread_count > MAX_THREADS || (s->avctx->thread_count > s->mb_height && s->mb_height))){ av_log(s->avctx, AV_LOG_ERROR, "too many threads\n"); return -1; } if((s->width || s->height) && av_image_check_size(s->width, s->height, 0, s->avctx)) return -1; dsputil_init(&s->dsp, s->avctx); ff_dct_common_init(s); s->flags= s->avctx->flags; s->flags2= s->avctx->flags2; if (s->width && s->height) { s->mb_width = (s->width + 15) / 16; s->mb_stride = s->mb_width + 1; s->b8_stride = s->mb_width*2 + 1; s->b4_stride = s->mb_width*4 + 1; mb_array_size= s->mb_height * s->mb_stride; mv_table_size= (s->mb_height+2) * s->mb_stride + 1; avcodec_get_chroma_sub_sample(s->avctx->pix_fmt,&(s->chroma_x_shift), &(s->chroma_y_shift) ); s->h_edge_pos= s->mb_width*16; s->v_edge_pos= s->mb_height*16; s->mb_num = s->mb_width * s->mb_height; s->block_wrap[0]= s->block_wrap[1]= s->block_wrap[2]= s->block_wrap[3]= s->b8_stride; s->block_wrap[4]= s->block_wrap[5]= s->mb_stride; [[pap]] = s->b8_stride * (2 * s->mb_height + 1); c_size = s->mb_stride * (s->mb_height + 1); yc_size = [[pap]] + 2 * c_size; s->codec_tag = ff_toupper4(s->avctx->codec_tag); s->stream_codec_tag = ff_toupper4(s->avctx->stream_codec_tag); s->avctx->coded_frame= (AVFrame*)&s->current_picture; FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_index2xy, (s->mb_num+1)*sizeof(int), fail) for(y=0; y<s->mb_height; y++){ for(x=0; x<s->mb_width; x++){ s->mb_index2xy[ x + y*s->mb_width ] = x + y*s->mb_stride; } } s->mb_index2xy[ s->mb_height*s->mb_width ] = (s->mb_height-1)*s->mb_stride + s->mb_width; if (s->encoding) { FF_ALLOCZ_OR_GOTO(s->avctx, s->p_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->b_direct_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail) s->p_mv_table = s->p_mv_table_base + s->mb_stride + 1; s->b_forw_mv_table = s->b_forw_mv_table_base + s->mb_stride + 1; s->b_back_mv_table = s->b_back_mv_table_base + s->mb_stride + 1; s->b_bidir_forw_mv_table= s->b_bidir_forw_mv_table_base + s->mb_stride + 1; s->b_bidir_back_mv_table= s->b_bidir_back_mv_table_base + s->mb_stride + 1; s->b_direct_mv_table = s->b_direct_mv_table_base + s->mb_stride + 1; if(s->msmpeg4_version){ FF_ALLOCZ_OR_GOTO(s->avctx, s->ac_stats, 2*2*(MAX_LEVEL+1)*(MAX_RUN+1)*2*sizeof(int), fail); } FF_ALLOCZ_OR_GOTO(s->avctx, s->avctx->stats_out, 256, fail); FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_type , mb_array_size * sizeof(uint16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->lambda_table, mb_array_size * sizeof(int), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix , 64*32 * sizeof(int), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix , 64*32 * sizeof(int), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix16, 64*32*2 * sizeof(uint16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix16, 64*32*2 * sizeof(uint16_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->reordered_input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail) if(s->avctx->noise_reduction){ FF_ALLOCZ_OR_GOTO(s->avctx, s->dct_offset, 2 * 64 * sizeof(uint16_t), fail) } } } s->picture_count = MAX_PICTURE_COUNT * FFMAX(1, s->avctx->thread_count); FF_ALLOCZ_OR_GOTO(s->avctx, s->picture, s->picture_count * sizeof(Picture), fail) for(i = 0; i < s->picture_count; i++) { avcodec_get_frame_defaults((AVFrame *)&s->picture[i]); } if (s->width && s->height) { FF_ALLOCZ_OR_GOTO(s->avctx, s->error_status_table, mb_array_size*sizeof(uint8_t), fail) if(s->codec_id==CODEC_ID_MPEG4 || (s->flags & CODEC_FLAG_INTERLACED_ME)){ for(i=0; i<2; i++){ int j, k; for(j=0; j<2; j++){ for(k=0; k<2; k++){ FF_ALLOCZ_OR_GOTO(s->avctx, s->b_field_mv_table_base[i][j][k], mv_table_size * 2 * sizeof(int16_t), fail) s->b_field_mv_table[i][j][k] = s->b_field_mv_table_base[i][j][k] + s->mb_stride + 1; } FF_ALLOCZ_OR_GOTO(s->avctx, s->b_field_select_table [i][j], mb_array_size * 2 * sizeof(uint8_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_mv_table_base[i][j], mv_table_size * 2 * sizeof(int16_t), fail) s->p_field_mv_table[i][j] = s->p_field_mv_table_base[i][j]+ s->mb_stride + 1; } FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_select_table[i], mb_array_size * 2 * sizeof(uint8_t), fail) } } if (s->out_format == FMT_H263) { FF_ALLOCZ_OR_GOTO(s->avctx, s->coded_block_base, [[pap]], fail); s->coded_block= s->coded_block_base + s->b8_stride + 1; FF_ALLOCZ_OR_GOTO(s->avctx, s->cbp_table , mb_array_size * sizeof(uint8_t), fail) FF_ALLOCZ_OR_GOTO(s->avctx, s->pred_dir_table, mb_array_size * sizeof(uint8_t), fail) } if (s->h263_pred || s->h263_plus || !s->encoding) { FF_ALLOCZ_OR_GOTO(s->avctx, s->dc_val_base, yc_size * sizeof(int16_t), fail); s->dc_val[0] = s->dc_val_base + s->b8_stride + 1; s->dc_val[1] = s->dc_val_base + [[pap]] + s->mb_stride + 1; s->dc_val[2] = s->dc_val[1] + c_size; for(i=0;i<yc_size;i++) s->dc_val_base[i] = 1024; } FF_ALLOCZ_OR_GOTO(s->avctx, s->mbintra_table, mb_array_size, fail); memset(s->mbintra_table, 1, mb_array_size); FF_ALLOCZ_OR_GOTO(s->avctx, s->mbskip_table, mb_array_size+2, fail); FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail); s->parse_context.state= -1; if((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){ s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH); s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH); s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH); } } s->context_initialized = 1; s->thread_context[0]= s; if (s->width && s->height) { if (s->encoding || (HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_SLICE)) { threads = s->avctx->thread_count; for(i=1; i<threads; i++){ s->thread_context[i]= av_malloc(sizeof(MpegEncContext)); memcpy(s->thread_context[i], s, sizeof(MpegEncContext)); } for(i=0; i<threads; i++){ if(init_duplicate_context(s->thread_context[i], s) < 0) goto fail; s->thread_context[i]->start_mb_y= (s->mb_height*(i ) + s->avctx->thread_count/2) / s->avctx->thread_count; s->thread_context[i]->end_mb_y = (s->mb_height*(i+1) + s->avctx->thread_count/2) / s->avctx->thread_count; } } else { if(init_duplicate_context(s, s) < 0) goto fail; s->start_mb_y = 0; s->end_mb_y = s->mb_height; } } return 0; fail: MPV_common_end(s); return -1; }[Succeeded / Failed / Skipped / Total] 296 / 30 / 188 / 514:  19%|        | 514/2690 [5:12:57<22:04:51, 36.53s/it][Succeeded / Failed / Skipped / Total] 296 / 30 / 188 / 514:  19%|        | 515/2690 [5:13:00<22:01:53, 36.47s/it][Succeeded / Failed / Skipped / Total] 297 / 30 / 188 / 515:  19%|        | 515/2690 [5:13:00<22:01:53, 36.47s/it][Succeeded / Failed / Skipped / Total] 297 / 30 / 188 / 515:  19%|        | 516/2690 [5:13:00<21:58:45, 36.40s/it][Succeeded / Failed / Skipped / Total] 297 / 30 / 189 / 516:  19%|        | 516/2690 [5:13:00<21:58:45, 36.40s/it][Succeeded / Failed / Skipped / Total] 297 / 30 / 189 / 516:  19%|        | 517/2690 [5:13:11<21:56:22, 36.35s/it][Succeeded / Failed / Skipped / Total] 298 / 30 / 189 / 517:  19%|        | 517/2690 [5:13:11<21:56:22, 36.35s/it][Succeeded / Failed / Skipped / Total] 298 / 30 / 189 / 517:  19%|        | 518/2690 [5:13:19<21:53:46, 36.29s/it]
--------------------------------------------- Result 515 ---------------------------------------------
[[0 (80%)]] --> [[0 (45%)]] --> Socre: 0.5478448867797852

[[[[Adv]]]]: static int mxf_read_track(MXFTrack *[[track]], ByteIOContext *pb, int [[tag]]) { switch([[tag]]) { case 0x4801: [[track]]->track_id = get_be32(pb); break; case 0x4804: get_buffer(pb, [[track]]->track_number, 4); break; case 0x4B01: [[track]]->edit_rate.den = get_be32(pb); [[track]]->edit_rate.num = get_be32(pb); break; case 0x4803: get_buffer(pb, [[track]]->sequence_ref, 16); break; } return 0; }

[[[[Adv]]]]: static int mxf_read_track(MXFTrack *[[locate]], ByteIOContext *pb, int [[bookmark]]) { switch([[bookmark]]) { case 0x4801: [[locate]]->track_id = get_be32(pb); break; case 0x4804: get_buffer(pb, [[locate]]->track_number, 4); break; case 0x4B01: [[locate]]->edit_rate.den = get_be32(pb); [[locate]]->edit_rate.num = get_be32(pb); break; case 0x4803: get_buffer(pb, [[locate]]->sequence_ref, 16); break; } return 0; }
--------------------------------------------- Result 516 ---------------------------------------------
[[0 (19%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ra144_encode_frame(AVCodecContext *avctx, uint8_t *frame, int buf_size, void *data) { static const uint8_t sizes[LPC_ORDER] = {64, 32, 32, 16, 16, 8, 8, 8, 8, 4}; static const uint8_t bit_sizes[LPC_ORDER] = {6, 5, 5, 4, 4, 3, 3, 3, 3, 2}; RA144Context *ractx; PutBitContext pb; int32_t lpc_data[NBLOCKS * BLOCKSIZE]; int32_t lpc_coefs[LPC_ORDER][MAX_LPC_ORDER]; int shift[LPC_ORDER]; int16_t block_coefs[NBLOCKS][LPC_ORDER]; int lpc_refl[LPC_ORDER]; unsigned int refl_rms[NBLOCKS]; int energy = 0; int i, idx; if (buf_size < FRAMESIZE) { av_log(avctx, AV_LOG_ERROR, "output buffer too small\n"); return 0; } ractx = avctx->priv_data; for (i = 0; i < (2 * BLOCKSIZE + BLOCKSIZE / 2); i++) { lpc_data[i] = ractx->curr_block[BLOCKSIZE + BLOCKSIZE / 2 + i]; energy += (lpc_data[i] * lpc_data[i]) >> 4; } for (i = 2 * BLOCKSIZE + BLOCKSIZE / 2; i < NBLOCKS * BLOCKSIZE; i++) { lpc_data[i] = *((int16_t *)data + i - 2 * BLOCKSIZE - BLOCKSIZE / 2) >> 2; energy += (lpc_data[i] * lpc_data[i]) >> 4; } energy = ff_energy_tab[quantize(ff_t_sqrt(energy >> 5) >> 10, ff_energy_tab, 32)]; ff_lpc_calc_coefs(&ractx->lpc_ctx, lpc_data, NBLOCKS * BLOCKSIZE, LPC_ORDER, LPC_ORDER, 16, lpc_coefs, shift, FF_LPC_TYPE_LEVINSON, 0, ORDER_METHOD_EST, 12, 0); for (i = 0; i < LPC_ORDER; i++) block_coefs[NBLOCKS - 1][i] = -(lpc_coefs[LPC_ORDER - 1][i] << (12 - shift[LPC_ORDER - 1])); if (ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx)) { ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[1]); ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx); } init_put_bits(&pb, frame, buf_size); for (i = 0; i < LPC_ORDER; i++) { idx = quantize(lpc_refl[i], ff_lpc_refl_cb[i], sizes[i]); put_bits(&pb, bit_sizes[i], idx); lpc_refl[i] = ff_lpc_refl_cb[i][idx]; } ractx->lpc_refl_rms[0] = ff_rms(lpc_refl); ff_eval_coefs(ractx->lpc_coef[0], lpc_refl); refl_rms[0] = ff_interp(ractx, block_coefs[0], 1, 1, ractx->old_energy); refl_rms[1] = ff_interp(ractx, block_coefs[1], 2, energy <= ractx->old_energy, ff_t_sqrt(energy * ractx->old_energy) >> 12); refl_rms[2] = ff_interp(ractx, block_coefs[2], 3, 0, energy); refl_rms[3] = ff_rescale_rms(ractx->lpc_refl_rms[0], energy); ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[0]); put_bits(&pb, 5, quantize(energy, ff_energy_tab, 32)); for (i = 0; i < NBLOCKS; i++) ra144_encode_subblock(ractx, ractx->curr_block + i * BLOCKSIZE, block_coefs[i], refl_rms[i], &pb); flush_put_bits(&pb); ractx->old_energy = energy; ractx->lpc_refl_rms[1] = ractx->lpc_refl_rms[0]; FFSWAP(unsigned int *, ractx->lpc_coef[0], ractx->lpc_coef[1]); for (i = 0; i < NBLOCKS * BLOCKSIZE; i++) ractx->curr_block[i] = *((int16_t *)data + i) >> 2; return FRAMESIZE; }
--------------------------------------------- Result 517 ---------------------------------------------
[[0 (28%)]] --> [[0 (60%)]] --> Socre: 0.6041932106018066

[[[[Adv]]]]: static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned [[cumFreq]], unsigned freq, unsigned total_freq) { int t = rc->range * (uint64_t)[[cumFreq]] / total_freq; rc->code1 += t + 1; rc->range = rc->range * (uint64_t)(freq + [[cumFreq]]) / total_freq - (t + 1); while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) { unsigned byte = bytestream2_get_byte(gb); rc->code = (rc->code << 8) | byte; rc->code1 <<= 8; rc->range <<= 8; } }

[[[[Adv]]]]: static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned [[faithfull]], unsigned freq, unsigned total_freq) { int t = rc->range * (uint64_t)[[faithfull]] / total_freq; rc->code1 += t + 1; rc->range = rc->range * (uint64_t)(freq + [[faithfull]]) / total_freq - (t + 1); while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) { unsigned byte = bytestream2_get_byte(gb); rc->code = (rc->code << 8) | byte; rc->code1 <<= 8; rc->range <<= 8; } }
--------------------------------------------- Result 518 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 299 / 30 / 189 / 518:  19%|        | 518/2690 [5:13:19<21:53:46, 36.29s/it][Succeeded / Failed / Skipped / Total] 299 / 30 / 189 / 518:  19%|        | 519/2690 [5:13:19<21:50:40, 36.22s/it][Succeeded / Failed / Skipped / Total] 299 / 30 / 190 / 519:  19%|        | 519/2690 [5:13:19<21:50:40, 36.22s/it][Succeeded / Failed / Skipped / Total] 299 / 30 / 190 / 519:  19%|        | 520/2690 [5:13:28<21:48:11, 36.17s/it][Succeeded / Failed / Skipped / Total] 300 / 30 / 190 / 520:  19%|        | 520/2690 [5:13:28<21:48:11, 36.17s/it][Succeeded / Failed / Skipped / Total] 300 / 30 / 190 / 520:  19%|        | 521/2690 [5:13:29<21:45:06, 36.10s/it][Succeeded / Failed / Skipped / Total] 300 / 30 / 191 / 521:  19%|        | 521/2690 [5:13:29<21:45:06, 36.10s/it][Succeeded / Failed / Skipped / Total] 300 / 30 / 191 / 521:  19%|        | 522/2690 [5:17:03<21:56:50, 36.44s/it][[0 (48%)]] --> [[0 (75%)]] --> Socre: 0.7495366334915161

[[[[Adv]]]]: static int dmg_open(BlockDriverState *[[bs]], const char *[[filename]], int flags) { BDRVDMGState *s = [[bs]]->opaque; off_t [[info_begin]],info_end,last_in_offset,last_out_offset; uint32_t count; uint32_t max_compressed_size=1,max_sectors_per_chunk=1,i; int64_t offset; s->fd = open([[filename]], O_RDONLY | O_BINARY); if (s->fd < 0) return -errno; [[bs]]->read_only = 1; s->n_chunks = 0; s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL; offset = lseek(s->fd, -0x1d8, SEEK_END); if (offset < 0) { goto fail; } [[info_begin]] = read_off(s->fd, offset); if ([[info_begin]] == 0) { goto fail; } if (read_uint32(s->fd, [[info_begin]]) != 0x100) { goto fail; } count = read_uint32(s->fd, [[info_begin]] + 4); if (count == 0) { goto fail; } info_end = [[info_begin]] + count; offset = [[info_begin]] + 0x100; last_in_offset = last_out_offset = 0; while (offset < info_end) { uint32_t type; count = read_uint32(s->fd, offset); if(count==0) goto fail; offset += 4; type = read_uint32(s->fd, offset); if (type == 0x6d697368 && count >= 244) { int new_size, chunk_count; offset += 4; offset += 200; chunk_count = (count-204)/40; new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count); s->types = qemu_realloc(s->types, new_size/2); s->offsets = qemu_realloc(s->offsets, new_size); s->lengths = qemu_realloc(s->lengths, new_size); s->sectors = qemu_realloc(s->sectors, new_size); s->sectorcounts = qemu_realloc(s->sectorcounts, new_size); for(i=s->n_chunks;i<s->n_chunks+chunk_count;i++) { s->types[i] = read_uint32(s->fd, offset); offset += 4; if(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) { if(s->types[i]==0xffffffff) { last_in_offset = s->offsets[i-1]+s->lengths[i-1]; last_out_offset = s->sectors[i-1]+s->sectorcounts[i-1]; } chunk_count--; i--; offset += 36; continue; } offset += 4; s->sectors[i] = last_out_offset+read_off(s->fd, offset); offset += 8; s->sectorcounts[i] = read_off(s->fd, offset); offset += 8; s->offsets[i] = last_in_offset+read_off(s->fd, offset); offset += 8; s->lengths[i] = read_off(s->fd, offset); offset += 8; if(s->lengths[i]>max_compressed_size) max_compressed_size = s->lengths[i]; if(s->sectorcounts[i]>max_sectors_per_chunk) max_sectors_per_chunk = s->sectorcounts[i]; } s->n_chunks+=chunk_count; } } s->compressed_chunk = qemu_malloc(max_compressed_size+1); s->uncompressed_chunk = qemu_malloc(512*max_sectors_per_chunk); if(inflateInit(&s->zstream) != Z_OK) goto fail; s->current_chunk = s->n_chunks; return 0; fail: close(s->fd); return -1; }

[[[[Adv]]]]: static int dmg_open(BlockDriverState *[[uruguayan]], const char *[[galicia]], int flags) { BDRVDMGState *s = [[uruguayan]]->opaque; off_t [[semester]],info_end,last_in_offset,last_out_offset; uint32_t count; uint32_t max_compressed_size=1,max_sectors_per_chunk=1,i; int64_t offset; s->fd = open([[galicia]], O_RDONLY | O_BINARY); if (s->fd < 0) return -errno; [[uruguayan]]->read_only = 1; s->n_chunks = 0; s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL; offset = lseek(s->fd, -0x1d8, SEEK_END); if (offset < 0) { goto fail; } [[semester]] = read_off(s->fd, offset); if ([[semester]] == 0) { goto fail; } if (read_uint32(s->fd, [[semester]]) != 0x100) { goto fail; } count = read_uint32(s->fd, [[semester]] + 4); if (count == 0) { goto fail; } info_end = [[semester]] + count; offset = [[semester]] + 0x100; last_in_offset = last_out_offset = 0; while (offset < info_end) { uint32_t type; count = read_uint32(s->fd, offset); if(count==0) goto fail; offset += 4; type = read_uint32(s->fd, offset); if (type == 0x6d697368 && count >= 244) { int new_size, chunk_count; offset += 4; offset += 200; chunk_count = (count-204)/40; new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count); s->types = qemu_realloc(s->types, new_size/2); s->offsets = qemu_realloc(s->offsets, new_size); s->lengths = qemu_realloc(s->lengths, new_size); s->sectors = qemu_realloc(s->sectors, new_size); s->sectorcounts = qemu_realloc(s->sectorcounts, new_size); for(i=s->n_chunks;i<s->n_chunks+chunk_count;i++) { s->types[i] = read_uint32(s->fd, offset); offset += 4; if(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) { if(s->types[i]==0xffffffff) { last_in_offset = s->offsets[i-1]+s->lengths[i-1]; last_out_offset = s->sectors[i-1]+s->sectorcounts[i-1]; } chunk_count--; i--; offset += 36; continue; } offset += 4; s->sectors[i] = last_out_offset+read_off(s->fd, offset); offset += 8; s->sectorcounts[i] = read_off(s->fd, offset); offset += 8; s->offsets[i] = last_in_offset+read_off(s->fd, offset); offset += 8; s->lengths[i] = read_off(s->fd, offset); offset += 8; if(s->lengths[i]>max_compressed_size) max_compressed_size = s->lengths[i]; if(s->sectorcounts[i]>max_sectors_per_chunk) max_sectors_per_chunk = s->sectorcounts[i]; } s->n_chunks+=chunk_count; } } s->compressed_chunk = qemu_malloc(max_compressed_size+1); s->uncompressed_chunk = qemu_malloc(512*max_sectors_per_chunk); if(inflateInit(&s->zstream) != Z_OK) goto fail; s->current_chunk = s->n_chunks; return 0; fail: close(s->fd); return -1; }
--------------------------------------------- Result 519 ---------------------------------------------
[[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt) { assert(pkt); return pkt->vlan_stripped; }
--------------------------------------------- Result 520 ---------------------------------------------
[[0 (62%)]] --> [[0 (33%)]] --> Socre: 0.6686452329158783

[[[[Adv]]]]: static Visitor *validate_test_init_raw(TestInputVisitorData *data, const char *json_string) { Visitor *[[v]]; data->obj = qobject_from_json(json_string); g_assert(data->obj != NULL); data->qiv = qmp_input_visitor_new_strict(data->obj); g_assert(data->qiv != NULL); [[v]] = qmp_input_get_visitor(data->qiv); g_assert([[v]] != NULL); return [[v]]; }

[[[[Adv]]]]: static Visitor *validate_test_init_raw(TestInputVisitorData *data, const char *json_string) { Visitor *[[pour]]; data->obj = qobject_from_json(json_string); g_assert(data->obj != NULL); data->qiv = qmp_input_visitor_new_strict(data->obj); g_assert(data->qiv != NULL); [[pour]] = qmp_input_get_visitor(data->qiv); g_assert([[pour]] != NULL); return [[pour]]; }
--------------------------------------------- Result 521 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int connect_namedsocket(const char *path) { int sockfd, size; struct sockaddr_un helper; sockfd = socket(AF_UNIX, SOCK_STREAM, 0); if (sockfd < 0) { fprintf(stderr, "socket %s\n", strerror(errno)); return -1; } strcpy(helper.sun_path, path); helper.sun_family = AF_UNIX; size = strlen(helper.sun_path) + sizeof(helper.sun_family); if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) { fprintf(stderr, "socket error\n"); return -1; } unlink(path); return sockfd; }
--------------------------------------------- Result 522 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 301 / 30 / 191 / 522:  19%|        | 522/2690 [5:17:03<21:56:50, 36.44s/it][Succeeded / Failed / Skipped / Total] 301 / 30 / 191 / 522:  19%|        | 523/2690 [5:17:59<21:57:34, 36.48s/it][Succeeded / Failed / Skipped / Total] 302 / 30 / 191 / 523:  19%|        | 523/2690 [5:17:59<21:57:34, 36.48s/it][Succeeded / Failed / Skipped / Total] 302 / 30 / 191 / 523:  19%|        | 524/2690 [5:18:00<21:54:29, 36.41s/it][[0 (80%)]] --> [[0 (49%)]] --> Socre: 0.5125963985919952

[[[[Adv]]]]: int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p) { int ret = 0; if (av_strstart(p, "pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,", &p)) { AVIOContext pb; RTSPState *rt = s->priv_data; AVDictionary *[[opts]] = NULL; int len = strlen(p) * 6 / 8; char *[[buf]] = av_mallocz(len); AVInputFormat *[[iformat]]; if (![[buf]]) return AVERROR(ENOMEM); av_base64_decode([[buf]], p, len); if (rtp_asf_fix_header([[buf]], len) < 0) av_log(s, AV_LOG_ERROR, "Failed to fix invalid RTSP-MS/ASF min_pktsize\n"); init_packetizer(&pb, [[buf]], len); if (rt->asf_ctx) { avformat_close_input(&rt->asf_ctx); } if (!([[iformat]] = av_find_input_format("asf"))) return AVERROR_DEMUXER_NOT_FOUND; rt->asf_ctx = avformat_alloc_context(); if (!rt->asf_ctx) { av_free([[buf]]); return AVERROR(ENOMEM); } rt->asf_ctx->pb = &pb; av_dict_set(&[[opts]], "no_resync_search", "1", 0); if ((ret = ff_copy_whiteblacklists(rt->asf_ctx, s)) < 0) { av_dict_free(&[[opts]]); return ret; } ret = avformat_open_input(&rt->asf_ctx, "", [[iformat]], &[[opts]]); av_dict_free(&[[opts]]); if (ret < 0) { av_free([[buf]]); return ret; } av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0); rt->asf_pb_pos = avio_tell(&pb); av_free([[buf]]); rt->asf_ctx->pb = NULL; } return ret; }

[[[[Adv]]]]: int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p) { int ret = 0; if (av_strstart(p, "pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,", &p)) { AVIOContext pb; RTSPState *rt = s->priv_data; AVDictionary *[[tragic]] = NULL; int len = strlen(p) * 6 / 8; char *[[voudrais]] = av_mallocz(len); AVInputFormat *[[blades]]; if (![[voudrais]]) return AVERROR(ENOMEM); av_base64_decode([[voudrais]], p, len); if (rtp_asf_fix_header([[voudrais]], len) < 0) av_log(s, AV_LOG_ERROR, "Failed to fix invalid RTSP-MS/ASF min_pktsize\n"); init_packetizer(&pb, [[voudrais]], len); if (rt->asf_ctx) { avformat_close_input(&rt->asf_ctx); } if (!([[blades]] = av_find_input_format("asf"))) return AVERROR_DEMUXER_NOT_FOUND; rt->asf_ctx = avformat_alloc_context(); if (!rt->asf_ctx) { av_free([[voudrais]]); return AVERROR(ENOMEM); } rt->asf_ctx->pb = &pb; av_dict_set(&[[tragic]], "no_resync_search", "1", 0); if ((ret = ff_copy_whiteblacklists(rt->asf_ctx, s)) < 0) { av_dict_free(&[[tragic]]); return ret; } ret = avformat_open_input(&rt->asf_ctx, "", [[blades]], &[[tragic]]); av_dict_free(&[[tragic]]); if (ret < 0) { av_free([[voudrais]]); return ret; } av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0); rt->asf_pb_pos = avio_tell(&pb); av_free([[voudrais]]); rt->asf_ctx->pb = NULL; } return ret; }
--------------------------------------------- Result 523 ---------------------------------------------
[[0 (15%)]] --> [[0 (72%)]] --> Socre: 0.7176904082298279

[[[[Adv]]]]: static av_cold int dnxhd_encode_init(AVCodecContext *[[avctx]]) { DNXHDEncContext *[[ctx]] = [[avctx]]->priv_data; int i, index, bit_depth, ret; switch ([[avctx]]->pix_fmt) { case AV_PIX_FMT_YUV422P: bit_depth = 8; break; case AV_PIX_FMT_YUV422P10: bit_depth = 10; break; default: av_log([[avctx]], AV_LOG_ERROR, "pixel format is incompatible with DNxHD\n"); return AVERROR(EINVAL); } [[ctx]]->cid = ff_dnxhd_find_cid([[avctx]], bit_depth); if (![[ctx]]->cid) { av_log([[avctx]], AV_LOG_ERROR, "video parameters incompatible with DNxHD\n"); return AVERROR(EINVAL); } av_log([[avctx]], AV_LOG_DEBUG, "cid %d\n", [[ctx]]->cid); index = ff_dnxhd_get_cid_table([[ctx]]->cid); if (index < 0) return index; [[ctx]]->cid_table = &ff_dnxhd_cid_table[index]; [[ctx]]->m.avctx = [[avctx]]; [[ctx]]->m.mb_intra = 1; [[ctx]]->m.h263_aic = 1; [[avctx]]->bits_per_raw_sample = [[ctx]]->cid_table->bit_depth; ff_blockdsp_init(&[[ctx]]->bdsp, [[avctx]]); ff_fdctdsp_init(&[[ctx]]->m.fdsp, [[avctx]]); ff_mpv_idct_init(&[[ctx]]->m); ff_mpegvideoencdsp_init(&[[ctx]]->m.mpvencdsp, [[avctx]]); ff_pixblockdsp_init(&[[ctx]]->m.pdsp, [[avctx]]); if (![[ctx]]->m.dct_quantize) [[ctx]]->m.dct_quantize = ff_dct_quantize_c; if ([[ctx]]->cid_table->bit_depth == 10) { [[ctx]]->m.dct_quantize = dnxhd_10bit_dct_quantize; [[ctx]]->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym; [[ctx]]->block_width_l2 = 4; } else { [[ctx]]->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym; [[ctx]]->block_width_l2 = 3; } if (ARCH_X86) ff_dnxhdenc_init_x86([[ctx]]); [[ctx]]->m.mb_height = ([[avctx]]->height + 15) / 16; [[ctx]]->m.mb_width = ([[avctx]]->width + 15) / 16; if ([[avctx]]->flags & AV_CODEC_FLAG_INTERLACED_DCT) { [[ctx]]->interlaced = 1; [[ctx]]->m.mb_height /= 2; } [[ctx]]->m.mb_num = [[ctx]]->m.mb_height * [[ctx]]->m.mb_width; #if FF_API_QUANT_BIAS FF_DISABLE_DEPRECATION_WARNINGS if ([[ctx]]->intra_quant_bias == FF_DEFAULT_QUANT_BIAS && [[avctx]]->intra_quant_bias != FF_DEFAULT_QUANT_BIAS) [[ctx]]->intra_quant_bias = [[avctx]]->intra_quant_bias; FF_ENABLE_DEPRECATION_WARNINGS #endif if ((ret = dnxhd_init_qmat([[ctx]], [[ctx]]->intra_quant_bias, 0)) < 0) return ret; if ([[ctx]]->nitris_compat) [[ctx]]->min_padding = 1600; if ((ret = dnxhd_init_vlc([[ctx]])) < 0) return ret; if ((ret = dnxhd_init_rc([[ctx]])) < 0) return ret; FF_ALLOCZ_OR_GOTO([[ctx]]->m.avctx, [[ctx]]->slice_size, [[ctx]]->m.mb_height * sizeof(uint32_t), fail); FF_ALLOCZ_OR_GOTO([[ctx]]->m.avctx, [[ctx]]->slice_offs, [[ctx]]->m.mb_height * sizeof(uint32_t), fail); FF_ALLOCZ_OR_GOTO([[ctx]]->m.avctx, [[ctx]]->mb_bits, [[ctx]]->m.mb_num * sizeof(uint16_t), fail); FF_ALLOCZ_OR_GOTO([[ctx]]->m.avctx, [[ctx]]->mb_qscale, [[ctx]]->m.mb_num * sizeof(uint8_t), fail); #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS [[avctx]]->coded_frame->key_frame = 1; [[avctx]]->coded_frame->pict_type = AV_PICTURE_TYPE_I; FF_ENABLE_DEPRECATION_WARNINGS #endif if ([[avctx]]->thread_count > MAX_THREADS) { av_log([[avctx]], AV_LOG_ERROR, "too many threads\n"); return AVERROR(EINVAL); } [[ctx]]->thread[0] = [[ctx]]; for (i = 1; i < [[avctx]]->thread_count; i++) { [[ctx]]->thread[i] = av_malloc(sizeof(DNXHDEncContext)); memcpy([[ctx]]->thread[i], [[ctx]], sizeof(DNXHDEncContext)); } return 0; fail: return AVERROR(ENOMEM); }

[[[[Adv]]]]: static av_cold int dnxhd_encode_init(AVCodecContext *[[assortment]]) { DNXHDEncContext *[[cmd]] = [[peaceful]]->priv_data; int i, index, bit_depth, ret; switch ([[peaceful]]->pix_fmt) { case AV_PIX_FMT_YUV422P: bit_depth = 8; break; case AV_PIX_FMT_YUV422P10: bit_depth = 10; break; default: av_log([[peaceful]], AV_LOG_ERROR, "pixel format is incompatible with DNxHD\n"); return AVERROR(EINVAL); } [[cmd]]->cid = ff_dnxhd_find_cid([[peaceful]], bit_depth); if (![[cmd]]->cid) { av_log([[peaceful]], AV_LOG_ERROR, "video parameters incompatible with DNxHD\n"); return AVERROR(EINVAL); } av_log([[peaceful]], AV_LOG_DEBUG, "cid %d\n", [[cmd]]->cid); index = ff_dnxhd_get_cid_table([[cmd]]->cid); if (index < 0) return index; [[cmd]]->cid_table = &ff_dnxhd_cid_table[index]; [[cmd]]->m.avctx = [[peaceful]]; [[cmd]]->m.mb_intra = 1; [[cmd]]->m.h263_aic = 1; [[peaceful]]->bits_per_raw_sample = [[cmd]]->cid_table->bit_depth; ff_blockdsp_init(&[[cmd]]->bdsp, [[peaceful]]); ff_fdctdsp_init(&[[cmd]]->m.fdsp, [[peaceful]]); ff_mpv_idct_init(&[[cmd]]->m); ff_mpegvideoencdsp_init(&[[cmd]]->m.mpvencdsp, [[peaceful]]); ff_pixblockdsp_init(&[[cmd]]->m.pdsp, [[peaceful]]); if (![[cmd]]->m.dct_quantize) [[cmd]]->m.dct_quantize = ff_dct_quantize_c; if ([[cmd]]->cid_table->bit_depth == 10) { [[cmd]]->m.dct_quantize = dnxhd_10bit_dct_quantize; [[cmd]]->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym; [[cmd]]->block_width_l2 = 4; } else { [[cmd]]->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym; [[cmd]]->block_width_l2 = 3; } if (ARCH_X86) ff_dnxhdenc_init_x86([[cmd]]); [[cmd]]->m.mb_height = ([[peaceful]]->height + 15) / 16; [[cmd]]->m.mb_width = ([[peaceful]]->width + 15) / 16; if ([[peaceful]]->flags & AV_CODEC_FLAG_INTERLACED_DCT) { [[cmd]]->interlaced = 1; [[cmd]]->m.mb_height /= 2; } [[cmd]]->m.mb_num = [[cmd]]->m.mb_height * [[cmd]]->m.mb_width; #if FF_API_QUANT_BIAS FF_DISABLE_DEPRECATION_WARNINGS if ([[cmd]]->intra_quant_bias == FF_DEFAULT_QUANT_BIAS && [[peaceful]]->intra_quant_bias != FF_DEFAULT_QUANT_BIAS) [[cmd]]->intra_quant_bias = [[peaceful]]->intra_quant_bias; FF_ENABLE_DEPRECATION_WARNINGS #endif if ((ret = dnxhd_init_qmat([[cmd]], [[cmd]]->intra_quant_bias, 0)) < 0) return ret; if ([[cmd]]->nitris_compat) [[cmd]]->min_padding = 1600; if ((ret = dnxhd_init_vlc([[cmd]])) < 0) return ret; if ((ret = dnxhd_init_rc([[cmd]])) < 0) return ret; FF_ALLOCZ_OR_GOTO([[cmd]]->m.avctx, [[cmd]]->slice_size, [[cmd]]->m.mb_height * sizeof(uint32_t), fail); FF_ALLOCZ_OR_GOTO([[cmd]]->m.avctx, [[cmd]]->slice_offs, [[cmd]]->m.mb_height * sizeof(uint32_t), fail); FF_ALLOCZ_OR_GOTO([[cmd]]->m.avctx, [[cmd]]->mb_bits, [[cmd]]->m.mb_num * sizeof(uint16_t), fail); FF_ALLOCZ_OR_GOTO([[cmd]]->m.avctx, [[cmd]]->mb_qscale, [[cmd]]->m.mb_num * sizeof(uint8_t), fail); #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS [[peaceful]]->coded_frame->key_frame = 1; [[peaceful]]->coded_frame->pict_type = AV_PICTURE_TYPE_I; FF_ENABLE_DEPRECATION_WARNINGS #endif if ([[peaceful]]->thread_count > MAX_THREADS) { av_log([[peaceful]], AV_LOG_ERROR, "too many threads\n"); return AVERROR(EINVAL); } [[cmd]]->thread[0] = [[cmd]]; for (i = 1; i < [[peaceful]]->thread_count; i++) { [[cmd]]->thread[i] = av_malloc(sizeof(DNXHDEncContext)); memcpy([[cmd]]->thread[i], [[cmd]], sizeof(DNXHDEncContext)); } return 0; fail: return AVERROR(ENOMEM); }
--------------------------------------------- Result 524 ---------------------------------------------
[[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vc1_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size, n_slices = 0, i; VC1Context *v = avctx->priv_data; MpegEncContext *s = &v->s; AVFrame *pict = data; uint8_t *buf2 = NULL; const uint8_t *buf_start = buf, *buf_start_second_field = NULL; int mb_height, n_slices1=-1; struct { uint8_t *buf; GetBitContext gb; int mby_start; } *slices = NULL, *tmp; v->second_field = 0; if(s->flags & CODEC_FLAG_LOW_DELAY) s->low_delay = 1; if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == VC1_CODE_ENDOFSEQ)) { if (s->low_delay == 0 && s->next_picture_ptr) { *pict = s->next_picture_ptr->f; s->next_picture_ptr = NULL; *data_size = sizeof(AVFrame); } return buf_size; } if (s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) { if (v->profile < PROFILE_ADVANCED) avctx->pix_fmt = AV_PIX_FMT_VDPAU_WMV3; else avctx->pix_fmt = AV_PIX_FMT_VDPAU_VC1; } if (avctx->codec_id == AV_CODEC_ID_VC1 || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) { int buf_size2 = 0; buf2 = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); if (IS_MARKER(AV_RB32(buf))) { const uint8_t *start, *end, *next; int size; next = buf; for (start = buf, end = buf + buf_size; next < end; start = next) { next = find_next_marker(start + 4, end); size = next - start - 4; if (size <= 0) continue; switch (AV_RB32(start)) { case VC1_CODE_FRAME: if (avctx->hwaccel || s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) buf_start = start; buf_size2 = vc1_unescape_buffer(start + 4, size, buf2); break; case VC1_CODE_FIELD: { int buf_size3; if (avctx->hwaccel || s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) buf_start_second_field = start; tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1)); if (!tmp) goto err; slices = tmp; slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); if (!slices[n_slices].buf) goto err; buf_size3 = vc1_unescape_buffer(start + 4, size, slices[n_slices].buf); init_get_bits(&slices[n_slices].gb, slices[n_slices].buf, buf_size3 << 3); slices[n_slices].mby_start = s->mb_height >> 1; n_slices1 = n_slices - 1; n_slices++; break; } case VC1_CODE_ENTRYPOINT: buf_size2 = vc1_unescape_buffer(start + 4, size, buf2); init_get_bits(&s->gb, buf2, buf_size2 * 8); ff_vc1_decode_entry_point(avctx, v, &s->gb); break; case VC1_CODE_SLICE: { int buf_size3; tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1)); if (!tmp) goto err; slices = tmp; slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); if (!slices[n_slices].buf) goto err; buf_size3 = vc1_unescape_buffer(start + 4, size, slices[n_slices].buf); init_get_bits(&slices[n_slices].gb, slices[n_slices].buf, buf_size3 << 3); slices[n_slices].mby_start = get_bits(&slices[n_slices].gb, 9); n_slices++; break; } } } } else if (v->interlace && ((buf[0] & 0xC0) == 0xC0)) { const uint8_t *divider; int buf_size3; divider = find_next_marker(buf, buf + buf_size); if ((divider == (buf + buf_size)) || AV_RB32(divider) != VC1_CODE_FIELD) { av_log(avctx, AV_LOG_ERROR, "Error in WVC1 interlaced frame\n"); goto err; } else { if (avctx->hwaccel || s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) buf_start_second_field = divider; tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1)); if (!tmp) goto err; slices = tmp; slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); if (!slices[n_slices].buf) goto err; buf_size3 = vc1_unescape_buffer(divider + 4, buf + buf_size - divider - 4, slices[n_slices].buf); init_get_bits(&slices[n_slices].gb, slices[n_slices].buf, buf_size3 << 3); slices[n_slices].mby_start = s->mb_height >> 1; n_slices1 = n_slices - 1; n_slices++; } buf_size2 = vc1_unescape_buffer(buf, divider - buf, buf2); } else { buf_size2 = vc1_unescape_buffer(buf, buf_size, buf2); } init_get_bits(&s->gb, buf2, buf_size2*8); } else init_get_bits(&s->gb, buf, buf_size*8); if (v->res_sprite) { v->new_sprite = !get_bits1(&s->gb); v->two_sprites = get_bits1(&s->gb); if (avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) { if (v->new_sprite) { avctx->width = avctx->coded_width = v->sprite_width; avctx->height = avctx->coded_height = v->sprite_height; } else { goto image; } } } if (s->context_initialized && (s->width != avctx->coded_width || s->height != avctx->coded_height)) { ff_vc1_decode_end(avctx); } if (!s->context_initialized) { if (ff_msmpeg4_decode_init(avctx) < 0 || ff_vc1_decode_init_alloc_tables(v) < 0) goto err; s->low_delay = !avctx->has_b_frames || v->res_sprite; if (v->profile == PROFILE_ADVANCED) { s->h_edge_pos = avctx->coded_width; s->v_edge_pos = avctx->coded_height; } } if (s->current_picture_ptr == NULL || s->current_picture_ptr->f.data[0]) { int i = ff_find_unused_picture(s, 0); if (i < 0) goto err; s->current_picture_ptr = &s->picture[i]; } v->pic_header_flag = 0; if (v->profile < PROFILE_ADVANCED) { if (ff_vc1_parse_frame_header(v, &s->gb) < 0) { goto err; } } else { if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) { goto err; } } if (avctx->debug & FF_DEBUG_PICT_INFO) av_log(v->s.avctx, AV_LOG_DEBUG, "pict_type: %c\n", av_get_picture_type_char(s->pict_type)); if ((avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) && s->pict_type != AV_PICTURE_TYPE_I) { av_log(v->s.avctx, AV_LOG_ERROR, "Sprite decoder: expected I-frame\n"); goto err; } if ((s->mb_height >> v->field_mode) == 0) { av_log(v->s.avctx, AV_LOG_ERROR, "image too short\n"); goto err; } s->current_picture_ptr->f.repeat_pict = 0; if (v->rff) { s->current_picture_ptr->f.repeat_pict = 1; } else if (v->rptfrm) { s->current_picture_ptr->f.repeat_pict = v->rptfrm * 2; } s->current_picture.f.pict_type = s->pict_type; s->current_picture.f.key_frame = s->pict_type == AV_PICTURE_TYPE_I; if (s->last_picture_ptr == NULL && (s->pict_type == AV_PICTURE_TYPE_B || s->dropable)) { goto err; } if ((avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B) || (avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I) || avctx->skip_frame >= AVDISCARD_ALL) { goto end; } if (s->next_p_frame_damaged) { if (s->pict_type == AV_PICTURE_TYPE_B) goto end; else s->next_p_frame_damaged = 0; } if (ff_MPV_frame_start(s, avctx) < 0) { goto err; } v->s.current_picture_ptr->f.interlaced_frame = (v->fcm != PROGRESSIVE); v->s.current_picture_ptr->f.top_field_first = v->tff; s->me.qpel_put = s->dsp.put_qpel_pixels_tab; s->me.qpel_avg = s->dsp.avg_qpel_pixels_tab; if ((CONFIG_VC1_VDPAU_DECODER) &&s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) ff_vdpau_vc1_decode_picture(s, buf_start, (buf + buf_size) - buf_start); else if (avctx->hwaccel) { if (v->field_mode && buf_start_second_field) { s->picture_structure = PICT_BOTTOM_FIELD - v->tff; if (avctx->hwaccel->start_frame(avctx, buf_start, buf_start_second_field - buf_start) < 0) goto err; if (avctx->hwaccel->decode_slice(avctx, buf_start, buf_start_second_field - buf_start) < 0) goto err; if (avctx->hwaccel->end_frame(avctx) < 0) goto err; s->gb = slices[n_slices1 + 1].gb; s->picture_structure = PICT_TOP_FIELD + v->tff; v->second_field = 1; v->pic_header_flag = 0; if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) { av_log(avctx, AV_LOG_ERROR, "parsing header for second field failed"); goto err; } v->s.current_picture_ptr->f.pict_type = v->s.pict_type; if (avctx->hwaccel->start_frame(avctx, buf_start_second_field, (buf + buf_size) - buf_start_second_field) < 0) goto err; if (avctx->hwaccel->decode_slice(avctx, buf_start_second_field, (buf + buf_size) - buf_start_second_field) < 0) goto err; if (avctx->hwaccel->end_frame(avctx) < 0) goto err; } else { s->picture_structure = PICT_FRAME; if (avctx->hwaccel->start_frame(avctx, buf_start, (buf + buf_size) - buf_start) < 0) goto err; if (avctx->hwaccel->decode_slice(avctx, buf_start, (buf + buf_size) - buf_start) < 0) goto err; if (avctx->hwaccel->end_frame(avctx) < 0) goto err; } } else { if (v->fcm == ILACE_FRAME && s->pict_type == AV_PICTURE_TYPE_B) goto err; ff_er_frame_start(s); v->bits = buf_size * 8; v->end_mb_x = s->mb_width; if (v->field_mode) { uint8_t *tmp[2]; s->current_picture.f.linesize[0] <<= 1; s->current_picture.f.linesize[1] <<= 1; s->current_picture.f.linesize[2] <<= 1; s->linesize <<= 1; s->uvlinesize <<= 1; tmp[0] = v->mv_f_last[0]; tmp[1] = v->mv_f_last[1]; v->mv_f_last[0] = v->mv_f_next[0]; v->mv_f_last[1] = v->mv_f_next[1]; v->mv_f_next[0] = v->mv_f[0]; v->mv_f_next[1] = v->mv_f[1]; v->mv_f[0] = tmp[0]; v->mv_f[1] = tmp[1]; } mb_height = s->mb_height >> v->field_mode; for (i = 0; i <= n_slices; i++) { if (i > 0 && slices[i - 1].mby_start >= mb_height) { if (v->field_mode <= 0) { av_log(v->s.avctx, AV_LOG_ERROR, "Slice %d starts beyond " "picture boundary (%d >= %d)\n", i, slices[i - 1].mby_start, mb_height); continue; } v->second_field = 1; v->blocks_off = s->mb_width * s->mb_height << 1; v->mb_off = s->mb_stride * s->mb_height >> 1; } else { v->second_field = 0; v->blocks_off = 0; v->mb_off = 0; } if (i) { v->pic_header_flag = 0; if (v->field_mode && i == n_slices1 + 2) { if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) { av_log(v->s.avctx, AV_LOG_ERROR, "Field header damaged\n"); continue; } } else if (get_bits1(&s->gb)) { v->pic_header_flag = 1; if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) { av_log(v->s.avctx, AV_LOG_ERROR, "Slice header damaged\n"); continue; } } } s->start_mb_y = (i == 0) ? 0 : FFMAX(0, slices[i-1].mby_start % mb_height); if (!v->field_mode || v->second_field) s->end_mb_y = (i == n_slices ) ? mb_height : FFMIN(mb_height, slices[i].mby_start % mb_height); else s->end_mb_y = (i <= n_slices1 + 1) ? mb_height : FFMIN(mb_height, slices[i].mby_start % mb_height); if (s->end_mb_y <= s->start_mb_y) { av_log(v->s.avctx, AV_LOG_ERROR, "end mb y %d %d invalid\n", s->end_mb_y, s->start_mb_y); continue; } ff_vc1_decode_blocks(v); if (i != n_slices) s->gb = slices[i].gb; } if (v->field_mode) { v->second_field = 0; if (s->pict_type == AV_PICTURE_TYPE_B) { memcpy(v->mv_f_base, v->mv_f_next_base, 2 * (s->b8_stride * (s->mb_height * 2 + 1) + s->mb_stride * (s->mb_height + 1) * 2)); } s->current_picture.f.linesize[0] >>= 1; s->current_picture.f.linesize[1] >>= 1; s->current_picture.f.linesize[2] >>= 1; s->linesize >>= 1; s->uvlinesize >>= 1; } av_dlog(s->avctx, "Consumed %i/%i bits\n", get_bits_count(&s->gb), s->gb.size_in_bits); if(s->error_occurred && s->pict_type == AV_PICTURE_TYPE_B) goto err; if(!v->field_mode) ff_er_frame_end(s); } ff_MPV_frame_end(s); if (avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) { image: avctx->width = avctx->coded_width = v->output_width; avctx->height = avctx->coded_height = v->output_height; if (avctx->skip_frame >= AVDISCARD_NONREF) goto end; #if CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER if (vc1_decode_sprites(v, &s->gb)) goto err; #endif *pict = v->sprite_output_frame; *data_size = sizeof(AVFrame); } else { if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) { *pict = s->current_picture_ptr->f; } else if (s->last_picture_ptr != NULL) { *pict = s->last_picture_ptr->f; } if (s->last_picture_ptr || s->low_delay) { *data_size = sizeof(AVFrame); ff_print_debug_info(s, pict); } } end: av_free(buf2); for (i = 0; i < n_slices; i++) av_free(slices[i].buf); av_free(slices); return buf_size; err: av_free(buf2); for (i = 0; i < n_slices; i++) av_free(slices[i].buf); av_free(slices); return -1; }[Succeeded / Failed / Skipped / Total] 302 / 30 / 192 / 524:  19%|        | 524/2690 [5:18:00<21:54:29, 36.41s/it][Succeeded / Failed / Skipped / Total] 302 / 30 / 192 / 524:  20%|        | 525/2690 [5:18:26<21:53:12, 36.39s/it][Succeeded / Failed / Skipped / Total] 303 / 30 / 192 / 525:  20%|        | 525/2690 [5:18:26<21:53:12, 36.39s/it][Succeeded / Failed / Skipped / Total] 303 / 30 / 192 / 525:  20%|        | 526/2690 [5:18:27<21:50:08, 36.33s/it][Succeeded / Failed / Skipped / Total] 303 / 30 / 193 / 526:  20%|        | 526/2690 [5:18:27<21:50:08, 36.33s/it][Succeeded / Failed / Skipped / Total] 303 / 30 / 193 / 526:  20%|        | 527/2690 [5:18:27<21:47:05, 36.26s/it][Succeeded / Failed / Skipped / Total] 303 / 30 / 194 / 527:  20%|        | 527/2690 [5:18:27<21:47:05, 36.26s/it][Succeeded / Failed / Skipped / Total] 303 / 30 / 194 / 527:  20%|        | 528/2690 [5:18:30<21:44:10, 36.19s/it][Succeeded / Failed / Skipped / Total] 304 / 30 / 194 / 528:  20%|        | 528/2690 [5:18:30<21:44:10, 36.19s/it][Succeeded / Failed / Skipped / Total] 304 / 30 / 194 / 528:  20%|        | 529/2690 [5:18:34<21:41:25, 36.13s/it][Succeeded / Failed / Skipped / Total] 305 / 30 / 194 / 529:  20%|        | 529/2690 [5:18:34<21:41:25, 36.13s/it][Succeeded / Failed / Skipped / Total] 305 / 30 / 194 / 529:  20%|        | 530/2690 [5:25:37<22:07:02, 36.86s/it]
--------------------------------------------- Result 525 ---------------------------------------------
[[0 (7%)]] --> [[0 (63%)]] --> Socre: 0.6303824186325073

[[[[Adv]]]]: void blk_apply_root_state(BlockBackend *[[blk]], BlockDriverState *bs) { bs->detect_zeroes = [[blk]]->root_state.detect_zeroes; }

[[[[Adv]]]]: void blk_apply_root_state(BlockBackend *[[hemorrhaging]], BlockDriverState *bs) { bs->detect_zeroes = [[hemorrhaging]]->root_state.detect_zeroes; }
--------------------------------------------- Result 526 ---------------------------------------------
[[0 (65%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: vcard_emul_mirror_card(VReader *vreader) { PK11GenericObject *firstObj, *thisObj; int cert_count; unsigned char **certs; int *cert_len; VCardKey **keys; PK11SlotInfo *slot; VCard *card; slot = vcard_emul_reader_get_slot(vreader); if (slot == NULL) { return NULL; } firstObj = PK11_FindGenericObjects(slot, CKO_CERTIFICATE); if (firstObj == NULL) { return NULL; } cert_count = 0; for (thisObj = firstObj; thisObj; thisObj = PK11_GetNextGenericObject(thisObj)) { cert_count++; } if (cert_count == 0) { PK11_DestroyGenericObjects(firstObj); return NULL; } vcard_emul_alloc_arrays(&certs, &cert_len, &keys, cert_count); cert_count = 0; for (thisObj = firstObj; thisObj; thisObj = PK11_GetNextGenericObject(thisObj)) { SECItem derCert; CERTCertificate *cert; SECStatus rv; rv = PK11_ReadRawAttribute(PK11_TypeGeneric, thisObj, CKA_VALUE, &derCert); if (rv != SECSuccess) { continue; } cert = CERT_NewTempCertificate(CERT_GetDefaultCertDB(), &derCert, NULL, PR_FALSE, PR_TRUE); SECITEM_FreeItem(&derCert, PR_FALSE); if (cert == NULL) { continue; } certs[cert_count] = cert->derCert.data; cert_len[cert_count] = cert->derCert.len; keys[cert_count] = vcard_emul_make_key(slot, cert); cert_count++; CERT_DestroyCertificate(cert); } card = vcard_emul_make_card(vreader, certs, cert_len, keys, cert_count); g_free(certs); g_free(cert_len); g_free(keys); return card; }
--------------------------------------------- Result 527 ---------------------------------------------
[[0 (73%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static uint64_t megasas_fw_time(void) { struct tm curtime; uint64_t bcd_time; qemu_get_timedate(&curtime, 0); bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 | ((uint64_t)curtime.tm_min & 0xff) << 40 | ((uint64_t)curtime.tm_hour & 0xff) << 32 | ((uint64_t)curtime.tm_mday & 0xff) << 24 | ((uint64_t)curtime.tm_mon & 0xff) << 16 | ((uint64_t)(curtime.tm_year + 1900) & 0xffff); return bcd_time; }
--------------------------------------------- Result 528 ---------------------------------------------
[[0 (57%)]] --> [[0 (49%)]] --> Socre: 0.5089440941810608

[[[[Adv]]]]: static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie) { OfDpaFlow *flow; int64_t [[now]] = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000; flow = g_new0(OfDpaFlow, 1); if (!flow) { return NULL; } flow->cookie = cookie; flow->mask.tbl_id = 0xffffffff; flow->stats.install_time = flow->stats.refresh_time = [[now]]; return flow; }

[[[[Adv]]]]: static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie) { OfDpaFlow *flow; int64_t [[longer]] = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000; flow = g_new0(OfDpaFlow, 1); if (!flow) { return NULL; } flow->cookie = cookie; flow->mask.tbl_id = 0xffffffff; flow->stats.install_time = flow->stats.refresh_time = [[longer]]; return flow; }
--------------------------------------------- Result 529 ---------------------------------------------
[[0 (49%)]] --> [[0 (55%)]] --> Socre: 0.5503632426261902

[[[[Adv]]]]: static int rtp_open(URLContext *h, const char *uri, int flags) { RTPContext *s; int port, is_output, ttl, local_port; char hostname[256]; char buf[1024]; char path[1024]; const char *[[p]]; is_output = (flags & URL_WRONLY); s = av_mallocz(sizeof(RTPContext)); if (!s) return AVERROR(ENOMEM); h->priv_data = s; url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port, path, sizeof(path), uri); ttl = -1; local_port = -1; [[p]] = strchr(uri, '?'); if ([[p]]) { if (find_info_tag(buf, sizeof(buf), "ttl", [[p]])) { ttl = strtol(buf, NULL, 10); } if (find_info_tag(buf, sizeof(buf), "localport", [[p]])) { local_port = strtol(buf, NULL, 10); } } build_udp_url(buf, sizeof(buf), hostname, port, local_port, ttl); if (url_open(&s->rtp_hd, buf, flags) < 0) goto fail; local_port = udp_get_local_port(s->rtp_hd); build_udp_url(buf, sizeof(buf), hostname, port + 1, local_port + 1, ttl); if (url_open(&s->rtcp_hd, buf, flags) < 0) goto fail; s->rtp_fd = udp_get_file_handle(s->rtp_hd); s->rtcp_fd = udp_get_file_handle(s->rtcp_hd); h->max_packet_size = url_get_max_packet_size(s->rtp_hd); h->is_streamed = 1; return 0; fail: if (s->rtp_hd) url_close(s->rtp_hd); if (s->rtcp_hd) url_close(s->rtcp_hd); av_free(s); return AVERROR(EIO); }

[[[[Adv]]]]: static int rtp_open(URLContext *h, const char *uri, int flags) { RTPContext *s; int port, is_output, ttl, local_port; char hostname[256]; char buf[1024]; char path[1024]; const char *[[s]]; is_output = (flags & URL_WRONLY); s = av_mallocz(sizeof(RTPContext)); if (!s) return AVERROR(ENOMEM); h->priv_data = s; url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port, path, sizeof(path), uri); ttl = -1; local_port = -1; [[s]] = strchr(uri, '?'); if ([[s]]) { if (find_info_tag(buf, sizeof(buf), "ttl", [[s]])) { ttl = strtol(buf, NULL, 10); } if (find_info_tag(buf, sizeof(buf), "localport", [[s]])) { local_port = strtol(buf, NULL, 10); } } build_udp_url(buf, sizeof(buf), hostname, port, local_port, ttl); if (url_open(&s->rtp_hd, buf, flags) < 0) goto fail; local_port = udp_get_local_port(s->rtp_hd); build_udp_url(buf, sizeof(buf), hostname, port + 1, local_port + 1, ttl); if (url_open(&s->rtcp_hd, buf, flags) < 0) goto fail; s->rtp_fd = udp_get_file_handle(s->rtp_hd); s->rtcp_fd = udp_get_file_handle(s->rtcp_hd); h->max_packet_size = url_get_max_packet_size(s->rtp_hd); h->is_streamed = 1; return 0; fail: if (s->rtp_hd) url_close(s->rtp_hd); if (s->rtcp_hd) url_close(s->rtcp_hd); av_free(s); return AVERROR(EIO); }
--------------------------------------------- Result 530 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 306 / 30 / 194 / 530:  20%|        | 530/2690 [5:25:37<22:07:02, 36.86s/it][Succeeded / Failed / Skipped / Total] 306 / 30 / 194 / 530:  20%|        | 531/2690 [5:25:37<22:03:57, 36.79s/it][Succeeded / Failed / Skipped / Total] 306 / 30 / 195 / 531:  20%|        | 531/2690 [5:25:37<22:03:57, 36.79s/it][Succeeded / Failed / Skipped / Total] 306 / 30 / 195 / 531:  20%|        | 532/2690 [5:25:38<22:00:53, 36.73s/it][[0 (7%)]] --> [[0 (55%)]] --> Socre: 0.5498683452606201

[[[[Adv]]]]: void tlb_set_page(CPUState *[[env]], target_ulong [[vaddr]], target_phys_addr_t paddr, int prot, int [[mmu_idx]], target_ulong size) { PhysPageDesc *p; unsigned long pd; unsigned int index; target_ulong address; target_ulong code_address; unsigned long addend; CPUTLBEntry *te; CPUWatchpoint *[[wp]]; target_phys_addr_t iotlb; assert(size >= TARGET_PAGE_SIZE); if (size != TARGET_PAGE_SIZE) { tlb_add_large_page([[env]], [[vaddr]], size); } p = phys_page_find(paddr >> TARGET_PAGE_BITS); if (!p) { pd = IO_MEM_UNASSIGNED; } else { pd = p->phys_offset; } #if defined(DEBUG_TLB) printf("tlb_set_page: vaddr=" TARGET_FMT_lx " paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\n", [[vaddr]], (int)paddr, prot, [[mmu_idx]], is_softmmu, pd); #endif address = [[vaddr]]; if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) { address |= TLB_MMIO; } addend = (unsigned long)qemu_get_ram_ptr(pd & TARGET_PAGE_MASK); if ((pd & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) { iotlb = pd & TARGET_PAGE_MASK; if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM) iotlb |= IO_MEM_NOTDIRTY; else iotlb |= IO_MEM_ROM; } else { iotlb = (pd & ~TARGET_PAGE_MASK); if (p) { iotlb += p->region_offset; } else { iotlb += paddr; } } code_address = address; QTAILQ_FOREACH([[wp]], &[[env]]->watchpoints, entry) { if ([[vaddr]] == ([[wp]]->vaddr & TARGET_PAGE_MASK)) { iotlb = io_mem_watch + paddr; address |= TLB_MMIO; } } index = ([[vaddr]] >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1); [[env]]->iotlb[[[mmu_idx]]][index] = iotlb - [[vaddr]]; te = &[[env]]->tlb_table[[[mmu_idx]]][index]; te->addend = addend - [[vaddr]]; if (prot & PAGE_READ) { te->addr_read = address; } else { te->addr_read = -1; } if (prot & PAGE_EXEC) { te->addr_code = code_address; } else { te->addr_code = -1; } if (prot & PAGE_WRITE) { if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM || (pd & IO_MEM_ROMD)) { te->addr_write = address | TLB_MMIO; } else if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM && !cpu_physical_memory_is_dirty(pd)) { te->addr_write = address | TLB_NOTDIRTY; } else { te->addr_write = address; } } else { te->addr_write = -1; } }

[[[[Adv]]]]: void tlb_set_page(CPUState *[[vivian]], target_ulong [[compressed]], target_phys_addr_t paddr, int prot, int [[amlie]], target_ulong size) { PhysPageDesc *p; unsigned long pd; unsigned int index; target_ulong address; target_ulong code_address; unsigned long addend; CPUTLBEntry *te; CPUWatchpoint *[[tunics]]; target_phys_addr_t iotlb; assert(size >= TARGET_PAGE_SIZE); if (size != TARGET_PAGE_SIZE) { tlb_add_large_page([[vivian]], [[compressed]], size); } p = phys_page_find(paddr >> TARGET_PAGE_BITS); if (!p) { pd = IO_MEM_UNASSIGNED; } else { pd = p->phys_offset; } #if defined(DEBUG_TLB) printf("tlb_set_page: vaddr=" TARGET_FMT_lx " paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\n", [[compressed]], (int)paddr, prot, [[amlie]], is_softmmu, pd); #endif address = [[compressed]]; if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) { address |= TLB_MMIO; } addend = (unsigned long)qemu_get_ram_ptr(pd & TARGET_PAGE_MASK); if ((pd & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) { iotlb = pd & TARGET_PAGE_MASK; if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM) iotlb |= IO_MEM_NOTDIRTY; else iotlb |= IO_MEM_ROM; } else { iotlb = (pd & ~TARGET_PAGE_MASK); if (p) { iotlb += p->region_offset; } else { iotlb += paddr; } } code_address = address; QTAILQ_FOREACH([[tunics]], &[[vivian]]->watchpoints, entry) { if ([[compressed]] == ([[tunics]]->vaddr & TARGET_PAGE_MASK)) { iotlb = io_mem_watch + paddr; address |= TLB_MMIO; } } index = ([[compressed]] >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1); [[vivian]]->iotlb[[[amlie]]][index] = iotlb - [[compressed]]; te = &[[vivian]]->tlb_table[[[amlie]]][index]; te->addend = addend - [[compressed]]; if (prot & PAGE_READ) { te->addr_read = address; } else { te->addr_read = -1; } if (prot & PAGE_EXEC) { te->addr_code = code_address; } else { te->addr_code = -1; } if (prot & PAGE_WRITE) { if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM || (pd & IO_MEM_ROMD)) { te->addr_write = address | TLB_MMIO; } else if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM && !cpu_physical_memory_is_dirty(pd)) { te->addr_write = address | TLB_NOTDIRTY; } else { te->addr_write = address; } } else { te->addr_write = -1; } }
--------------------------------------------- Result 531 ---------------------------------------------
[[0 (23%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: QObject *json_parser_parse_err(QList *tokens, va_list *ap, Error **errp) { JSONParserContext ctxt = {}; QList *working = qlist_copy(tokens); QObject *result; result = parse_value(&ctxt, &working, ap); QDECREF(working); error_propagate(errp, ctxt.err); return result; }
--------------------------------------------- Result 532 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 306 / 30 / 196 / 532:  20%|        | 532/2690 [5:25:38<22:00:53, 36.73s/it][Succeeded / Failed / Skipped / Total] 306 / 30 / 196 / 532:  20%|        | 533/2690 [5:27:55<22:07:06, 36.92s/it][Succeeded / Failed / Skipped / Total] 307 / 30 / 196 / 533:  20%|        | 533/2690 [5:27:55<22:07:06, 36.92s/it][Succeeded / Failed / Skipped / Total] 307 / 30 / 196 / 533:  20%|        | 534/2690 [5:27:56<22:04:02, 36.85s/it][[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int init_directories(BDRVVVFATState* s, const char *dirname, int heads, int secs, Error **errp) { bootsector_t* bootsector; mapping_t* mapping; unsigned int i; unsigned int cluster; memset(&(s->first_sectors[0]),0,0x40*0x200); s->cluster_size=s->sectors_per_cluster*0x200; s->cluster_buffer=g_malloc(s->cluster_size); i = 1+s->sectors_per_cluster*0x200*8/s->fat_type; s->sectors_per_fat=(s->sector_count+i)/i; s->offset_to_fat = s->offset_to_bootsector + 1; s->offset_to_root_dir = s->offset_to_fat + s->sectors_per_fat * 2; array_init(&(s->mapping),sizeof(mapping_t)); array_init(&(s->directory),sizeof(direntry_t)); { direntry_t* entry=array_get_next(&(s->directory)); entry->attributes=0x28; memcpy(entry->name, s->volume_label, sizeof(entry->name)); } init_fat(s); s->cluster_count=sector2cluster(s, s->sector_count); mapping = array_get_next(&(s->mapping)); mapping->begin = 0; mapping->dir_index = 0; mapping->info.dir.parent_mapping_index = -1; mapping->first_mapping_index = -1; mapping->path = g_strdup(dirname); i = strlen(mapping->path); if (i > 0 && mapping->path[i - 1] == '/') mapping->path[i - 1] = '\0'; mapping->mode = MODE_DIRECTORY; mapping->read_only = 0; s->path = mapping->path; for (i = 0, cluster = 0; i < s->mapping.next; i++) { int fix_fat = (i != 0); mapping = array_get(&(s->mapping), i); if (mapping->mode & MODE_DIRECTORY) { mapping->begin = cluster; if(read_directory(s, i)) { error_setg(errp, "Could not read directory %s", mapping->path); return -1; } mapping = array_get(&(s->mapping), i); } else { assert(mapping->mode == MODE_UNDEFINED); mapping->mode=MODE_NORMAL; mapping->begin = cluster; if (mapping->end > 0) { direntry_t* direntry = array_get(&(s->directory), mapping->dir_index); mapping->end = cluster + 1 + (mapping->end-1)/s->cluster_size; set_begin_of_direntry(direntry, mapping->begin); } else { mapping->end = cluster + 1; fix_fat = 0; } } assert(mapping->begin < mapping->end); cluster = mapping->end; if(cluster > s->cluster_count) { error_setg(errp, "Directory does not fit in FAT%d (capacity %.2f MB)", s->fat_type, s->sector_count / 2000.0); return -1; } if (fix_fat) { int j; for(j = mapping->begin; j < mapping->end - 1; j++) fat_set(s, j, j+1); fat_set(s, mapping->end - 1, s->max_fat_value); } } mapping = array_get(&(s->mapping), 0); s->sectors_of_root_directory = mapping->end * s->sectors_per_cluster; s->last_cluster_of_root_directory = mapping->end; fat_set(s,0,s->max_fat_value); fat_set(s,1,s->max_fat_value); s->current_mapping = NULL; bootsector = (bootsector_t *)(s->first_sectors + s->offset_to_bootsector * 0x200); bootsector->jump[0]=0xeb; bootsector->jump[1]=0x3e; bootsector->jump[2]=0x90; memcpy(bootsector->name,"QEMU ",8); bootsector->sector_size=cpu_to_le16(0x200); bootsector->sectors_per_cluster=s->sectors_per_cluster; bootsector->reserved_sectors=cpu_to_le16(1); bootsector->number_of_fats=0x2; bootsector->root_entries=cpu_to_le16(s->sectors_of_root_directory*0x10); bootsector->total_sectors16=s->sector_count>0xffff?0:cpu_to_le16(s->sector_count); bootsector->media_type = (s->offset_to_bootsector > 0 ? 0xf8 : 0xf0); s->fat.pointer[0] = bootsector->media_type; bootsector->sectors_per_fat=cpu_to_le16(s->sectors_per_fat); bootsector->sectors_per_track = cpu_to_le16(secs); bootsector->number_of_heads = cpu_to_le16(heads); bootsector->hidden_sectors = cpu_to_le32(s->offset_to_bootsector); bootsector->total_sectors=cpu_to_le32(s->sector_count>0xffff?s->sector_count:0); bootsector->u.fat16.drive_number = s->offset_to_bootsector == 0 ? 0 : 0x80; bootsector->u.fat16.signature=0x29; bootsector->u.fat16.id=cpu_to_le32(0xfabe1afd); memcpy(bootsector->u.fat16.volume_label, s->volume_label, sizeof(bootsector->u.fat16.volume_label)); memcpy(bootsector->u.fat16.fat_type, s->fat_type == 12 ? "FAT12 " : "FAT16 ", 8); bootsector->magic[0]=0x55; bootsector->magic[1]=0xaa; return 0; }
--------------------------------------------- Result 533 ---------------------------------------------
[[0 (2%)]] --> [[0 (92%)]] --> Socre: 0.9201558232307434

[[[[Adv]]]]: void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *[[irqs]]) { pxa2xx_timer_info *s = pxa2xx_timer_init(base, [[irqs]]); s->freq = PXA25X_FREQ; s->tm4 = NULL; }

[[[[Adv]]]]: void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *[[muse]]) { pxa2xx_timer_info *s = pxa2xx_timer_init(base, [[muse]]); s->freq = PXA25X_FREQ; s->tm4 = NULL; }
--------------------------------------------- Result 534 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 307 / 30 / 197 / 534:  20%|        | 534/2690 [5:27:56<22:04:02, 36.85s/it][Succeeded / Failed / Skipped / Total] 307 / 30 / 197 / 534:  20%|        | 535/2690 [5:29:31<22:07:20, 36.96s/it][[0 (81%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: struct omap_mpu_state_s *omap2420_mpu_init(unsigned long sdram_size, const char *core) { struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) g_malloc0(sizeof(struct omap_mpu_state_s)); ram_addr_t sram_base, q2_base; qemu_irq *cpu_irq; qemu_irq dma_irqs[4]; DriveInfo *dinfo; int i; SysBusDevice *busdev; struct omap_target_agent_s *ta; s->mpu_model = omap2420; s->env = cpu_init(core ?: "arm1136-r2"); if (!s->env) { fprintf(stderr, "Unable to find CPU definition\n"); exit(1); } s->sdram_size = sdram_size; s->sram_size = OMAP242X_SRAM_SIZE; s->wakeup = qemu_allocate_irqs(omap_mpu_wakeup, s, 1)[0]; omap_clk_init(s); cpu_register_physical_memory(OMAP2_Q2_BASE, s->sdram_size, (q2_base = qemu_ram_alloc(NULL, "omap2.dram", s->sdram_size)) | IO_MEM_RAM); cpu_register_physical_memory(OMAP2_SRAM_BASE, s->sram_size, (sram_base = qemu_ram_alloc(NULL, "omap2.sram", s->sram_size)) | IO_MEM_RAM); s->l4 = omap_l4_init(OMAP2_L4_BASE, 54); cpu_irq = arm_pic_init_cpu(s->env); s->ih[0] = omap2_inth_init(0x480fe000, 0x1000, 3, &s->irq[0], cpu_irq[ARM_PIC_CPU_IRQ], cpu_irq[ARM_PIC_CPU_FIQ], omap_findclk(s, "mpu_intc_fclk"), omap_findclk(s, "mpu_intc_iclk")); s->prcm = omap_prcm_init(omap_l4tao(s->l4, 3), s->irq[0][OMAP_INT_24XX_PRCM_MPU_IRQ], NULL, NULL, s); s->sysc = omap_sysctl_init(omap_l4tao(s->l4, 1), omap_findclk(s, "omapctrl_iclk"), s); for (i = 0; i < 4; i ++) dma_irqs[i] = s->irq[omap2_dma_irq_map[i].ih][omap2_dma_irq_map[i].intr]; s->dma = omap_dma4_init(0x48056000, dma_irqs, s, 256, 32, omap_findclk(s, "sdma_iclk"), omap_findclk(s, "sdma_fclk")); s->port->addr_valid = omap2_validate_addr; soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(q2_base), OMAP2_Q2_BASE, s->sdram_size); soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(sram_base), OMAP2_SRAM_BASE, s->sram_size); s->uart[0] = omap2_uart_init(omap_l4ta(s->l4, 19), s->irq[0][OMAP_INT_24XX_UART1_IRQ], omap_findclk(s, "uart1_fclk"), omap_findclk(s, "uart1_iclk"), s->drq[OMAP24XX_DMA_UART1_TX], s->drq[OMAP24XX_DMA_UART1_RX], "uart1", serial_hds[0]); s->uart[1] = omap2_uart_init(omap_l4ta(s->l4, 20), s->irq[0][OMAP_INT_24XX_UART2_IRQ], omap_findclk(s, "uart2_fclk"), omap_findclk(s, "uart2_iclk"), s->drq[OMAP24XX_DMA_UART2_TX], s->drq[OMAP24XX_DMA_UART2_RX], "uart2", serial_hds[0] ? serial_hds[1] : NULL); s->uart[2] = omap2_uart_init(omap_l4ta(s->l4, 21), s->irq[0][OMAP_INT_24XX_UART3_IRQ], omap_findclk(s, "uart3_fclk"), omap_findclk(s, "uart3_iclk"), s->drq[OMAP24XX_DMA_UART3_TX], s->drq[OMAP24XX_DMA_UART3_RX], "uart3", serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL); s->gptimer[0] = omap_gp_timer_init(omap_l4ta(s->l4, 7), s->irq[0][OMAP_INT_24XX_GPTIMER1], omap_findclk(s, "wu_gpt1_clk"), omap_findclk(s, "wu_l4_iclk")); s->gptimer[1] = omap_gp_timer_init(omap_l4ta(s->l4, 8), s->irq[0][OMAP_INT_24XX_GPTIMER2], omap_findclk(s, "core_gpt2_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[2] = omap_gp_timer_init(omap_l4ta(s->l4, 22), s->irq[0][OMAP_INT_24XX_GPTIMER3], omap_findclk(s, "core_gpt3_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[3] = omap_gp_timer_init(omap_l4ta(s->l4, 23), s->irq[0][OMAP_INT_24XX_GPTIMER4], omap_findclk(s, "core_gpt4_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[4] = omap_gp_timer_init(omap_l4ta(s->l4, 24), s->irq[0][OMAP_INT_24XX_GPTIMER5], omap_findclk(s, "core_gpt5_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[5] = omap_gp_timer_init(omap_l4ta(s->l4, 25), s->irq[0][OMAP_INT_24XX_GPTIMER6], omap_findclk(s, "core_gpt6_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[6] = omap_gp_timer_init(omap_l4ta(s->l4, 26), s->irq[0][OMAP_INT_24XX_GPTIMER7], omap_findclk(s, "core_gpt7_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[7] = omap_gp_timer_init(omap_l4ta(s->l4, 27), s->irq[0][OMAP_INT_24XX_GPTIMER8], omap_findclk(s, "core_gpt8_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[8] = omap_gp_timer_init(omap_l4ta(s->l4, 28), s->irq[0][OMAP_INT_24XX_GPTIMER9], omap_findclk(s, "core_gpt9_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[9] = omap_gp_timer_init(omap_l4ta(s->l4, 29), s->irq[0][OMAP_INT_24XX_GPTIMER10], omap_findclk(s, "core_gpt10_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[10] = omap_gp_timer_init(omap_l4ta(s->l4, 30), s->irq[0][OMAP_INT_24XX_GPTIMER11], omap_findclk(s, "core_gpt11_clk"), omap_findclk(s, "core_l4_iclk")); s->gptimer[11] = omap_gp_timer_init(omap_l4ta(s->l4, 31), s->irq[0][OMAP_INT_24XX_GPTIMER12], omap_findclk(s, "core_gpt12_clk"), omap_findclk(s, "core_l4_iclk")); omap_tap_init(omap_l4ta(s->l4, 2), s); s->synctimer = omap_synctimer_init(omap_l4tao(s->l4, 2), s, omap_findclk(s, "clk32-kHz"), omap_findclk(s, "core_l4_iclk")); s->i2c[0] = omap2_i2c_init(omap_l4tao(s->l4, 5), s->irq[0][OMAP_INT_24XX_I2C1_IRQ], &s->drq[OMAP24XX_DMA_I2C1_TX], omap_findclk(s, "i2c1.fclk"), omap_findclk(s, "i2c1.iclk")); s->i2c[1] = omap2_i2c_init(omap_l4tao(s->l4, 6), s->irq[0][OMAP_INT_24XX_I2C2_IRQ], &s->drq[OMAP24XX_DMA_I2C2_TX], omap_findclk(s, "i2c2.fclk"), omap_findclk(s, "i2c2.iclk")); s->gpio = qdev_create(NULL, "omap2-gpio"); qdev_prop_set_int32(s->gpio, "mpu_model", s->mpu_model); qdev_prop_set_ptr(s->gpio, "iclk", omap_findclk(s, "gpio_iclk")); qdev_prop_set_ptr(s->gpio, "fclk0", omap_findclk(s, "gpio1_dbclk")); qdev_prop_set_ptr(s->gpio, "fclk1", omap_findclk(s, "gpio2_dbclk")); qdev_prop_set_ptr(s->gpio, "fclk2", omap_findclk(s, "gpio3_dbclk")); qdev_prop_set_ptr(s->gpio, "fclk3", omap_findclk(s, "gpio4_dbclk")); if (s->mpu_model == omap2430) { qdev_prop_set_ptr(s->gpio, "fclk4", omap_findclk(s, "gpio5_dbclk")); } qdev_init_nofail(s->gpio); busdev = sysbus_from_qdev(s->gpio); sysbus_connect_irq(busdev, 0, s->irq[0][OMAP_INT_24XX_GPIO_BANK1]); sysbus_connect_irq(busdev, 3, s->irq[0][OMAP_INT_24XX_GPIO_BANK2]); sysbus_connect_irq(busdev, 6, s->irq[0][OMAP_INT_24XX_GPIO_BANK3]); sysbus_connect_irq(busdev, 9, s->irq[0][OMAP_INT_24XX_GPIO_BANK4]); ta = omap_l4ta(s->l4, 3); sysbus_mmio_map(busdev, 0, omap_l4_region_base(ta, 1)); sysbus_mmio_map(busdev, 1, omap_l4_region_base(ta, 0)); sysbus_mmio_map(busdev, 2, omap_l4_region_base(ta, 2)); sysbus_mmio_map(busdev, 3, omap_l4_region_base(ta, 4)); sysbus_mmio_map(busdev, 4, omap_l4_region_base(ta, 5)); s->sdrc = omap_sdrc_init(0x68009000); s->gpmc = omap_gpmc_init(s, 0x6800a000, s->irq[0][OMAP_INT_24XX_GPMC_IRQ], s->drq[OMAP24XX_DMA_GPMC]); dinfo = drive_get(IF_SD, 0, 0); if (!dinfo) { fprintf(stderr, "qemu: missing SecureDigital device\n"); exit(1); } s->mmc = omap2_mmc_init(omap_l4tao(s->l4, 9), dinfo->bdrv, s->irq[0][OMAP_INT_24XX_MMC_IRQ], &s->drq[OMAP24XX_DMA_MMC1_TX], omap_findclk(s, "mmc_fclk"), omap_findclk(s, "mmc_iclk")); s->mcspi[0] = omap_mcspi_init(omap_l4ta(s->l4, 35), 4, s->irq[0][OMAP_INT_24XX_MCSPI1_IRQ], &s->drq[OMAP24XX_DMA_SPI1_TX0], omap_findclk(s, "spi1_fclk"), omap_findclk(s, "spi1_iclk")); s->mcspi[1] = omap_mcspi_init(omap_l4ta(s->l4, 36), 2, s->irq[0][OMAP_INT_24XX_MCSPI2_IRQ], &s->drq[OMAP24XX_DMA_SPI2_TX0], omap_findclk(s, "spi2_fclk"), omap_findclk(s, "spi2_iclk")); s->dss = omap_dss_init(omap_l4ta(s->l4, 10), 0x68000800, s->irq[0][OMAP_INT_24XX_DSS_IRQ], s->drq[OMAP24XX_DMA_DSS], omap_findclk(s, "dss_clk1"), omap_findclk(s, "dss_clk2"), omap_findclk(s, "dss_54m_clk"), omap_findclk(s, "dss_l3_iclk"), omap_findclk(s, "dss_l4_iclk")); omap_sti_init(omap_l4ta(s->l4, 18), 0x54000000, s->irq[0][OMAP_INT_24XX_STI], omap_findclk(s, "emul_ck"), serial_hds[0] && serial_hds[1] && serial_hds[2] ? serial_hds[3] : NULL); s->eac = omap_eac_init(omap_l4ta(s->l4, 32), s->irq[0][OMAP_INT_24XX_EAC_IRQ], &s->drq[OMAP24XX_DMA_EAC_AC_RD], omap_findclk(s, "func_96m_clk"), omap_findclk(s, "core_l4_iclk")); qemu_register_reset(omap2_mpu_reset, s); return s; }
--------------------------------------------- Result 535 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 307 / 31 / 197 / 535:  20%|        | 535/2690 [5:29:31<22:07:20, 36.96s/it][Succeeded / Failed / Skipped / Total] 307 / 31 / 197 / 535:  20%|        | 536/2690 [5:29:32<22:04:17, 36.89s/it][Succeeded / Failed / Skipped / Total] 307 / 31 / 198 / 536:  20%|        | 536/2690 [5:29:32<22:04:17, 36.89s/it][Succeeded / Failed / Skipped / Total] 307 / 31 / 198 / 536:  20%|        | 537/2690 [5:29:38<22:01:36, 36.83s/it][Succeeded / Failed / Skipped / Total] 308 / 31 / 198 / 537:  20%|        | 537/2690 [5:29:38<22:01:36, 36.83s/it][Succeeded / Failed / Skipped / Total] 308 / 31 / 198 / 537:  20%|        | 538/2690 [5:29:55<21:59:43, 36.80s/it][[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame) { int y; unsigned char P[2]; for (y = 0; y < 8; y++) { if (!(y & 3)) { P[0] = bytestream2_get_byte(&s->stream_ptr); P[1] = bytestream2_get_byte(&s->stream_ptr); memset(s->pixel_ptr, P[0], 4); memset(s->pixel_ptr + 4, P[1], 4); s->pixel_ptr += s->stride; return 0;

[[[[Adv]]]]: static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame) { int y; unsigned char P[2]; for (y = 0; y < 8; y++) { if (!(y & 3)) { P[0] = bytestream2_get_byte(&s->stream_ptr); P[1] = bytestream2_get_byte(&s->stream_ptr); memset(s->pixel_ptr, P[0], 4); memset(s->pixel_ptr + 4, P[1], 4); s->pixel_ptr += s->stride; return 0;
--------------------------------------------- Result 536 ---------------------------------------------
[[0 (79%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int nbd_negotiate_handle_info(NBDClient *client, uint32_t length, uint32_t opt, uint16_t myflags, Error **errp) { int rc; char name[NBD_MAX_NAME_SIZE + 1]; NBDExport *exp; uint16_t requests; uint16_t request; uint32_t namelen; bool sendname = "False" != "False"; bool blocksize = "False" != "False"; uint32_t sizes[3]; char buf[sizeof(uint64_t) + sizeof(uint16_t)]; const char *msg; if (length < sizeof(namelen) + sizeof(requests)) { msg = "overall request too short"; goto invalid; } if (nbd_read(client->ioc, &namelen, sizeof(namelen), errp) < 0) { return -EIO; } be32_to_cpus(&namelen); length -= sizeof(namelen); if (namelen > length - sizeof(requests) || (length - namelen) % 2) { msg = "name length is incorrect"; goto invalid; } if (nbd_read(client->ioc, name, namelen, errp) < 0) { return -EIO; } name[namelen] = '\0'; length -= namelen; trace_nbd_negotiate_handle_export_name_request(name); if (nbd_read(client->ioc, &requests, sizeof(requests), errp) < 0) { return -EIO; } be16_to_cpus(&requests); length -= sizeof(requests); trace_nbd_negotiate_handle_info_requests(requests); if (requests != length / sizeof(request)) { msg = "incorrect number of requests for overall length"; goto invalid; } while (requests--) { if (nbd_read(client->ioc, &request, sizeof(request), errp) < 0) { return -EIO; } be16_to_cpus(&request); length -= sizeof(request); trace_nbd_negotiate_handle_info_request(request, nbd_info_lookup(request)); switch (request) { case NBD_INFO_NAME: sendname = "True" == "True"; break; case NBD_INFO_BLOCK_SIZE: blocksize = "True" == "True"; break; } } exp = nbd_export_find(name); if (!exp) { return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_UNKNOWN, opt, errp, "export '%s' not present", name); } if (sendname) { rc = nbd_negotiate_send_info(client, opt, NBD_INFO_NAME, length, name, errp); if (rc < 0) { return rc; } } if (exp->description) { size_t len = strlen(exp->description); rc = nbd_negotiate_send_info(client, opt, NBD_INFO_DESCRIPTION, len, exp->description, errp); if (rc < 0) { return rc; } } sizes[0] = (opt == NBD_OPT_INFO || blocksize) ? BDRV_SECTOR_SIZE : 1; sizes[1] = 4096; sizes[2] = MIN(blk_get_max_transfer(exp->blk), NBD_MAX_BUFFER_SIZE); trace_nbd_negotiate_handle_info_block_size(sizes[0], sizes[1], sizes[2]); cpu_to_be32s(&sizes[0]); cpu_to_be32s(&sizes[1]); cpu_to_be32s(&sizes[2]); rc = nbd_negotiate_send_info(client, opt, NBD_INFO_BLOCK_SIZE, sizeof(sizes), sizes, errp); if (rc < 0) { return rc; } trace_nbd_negotiate_new_style_size_flags(exp->size, exp->nbdflags | myflags); stq_be_p(buf, exp->size); stw_be_p(buf + 8, exp->nbdflags | myflags); rc = nbd_negotiate_send_info(client, opt, NBD_INFO_EXPORT, sizeof(buf), buf, errp); if (rc < 0) { return rc; } if (opt == NBD_OPT_INFO && !blocksize) { return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_BLOCK_SIZE_REQD, opt, errp, "request NBD_INFO_BLOCK_SIZE to " "use this export"); } rc = nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, opt, errp); if (rc < 0) { return rc; } if (opt == NBD_OPT_GO) { client->exp = exp; QTAILQ_INSERT_TAIL(&client->exp->clients, client, next); nbd_export_get(client->exp); rc = 1; } return rc; invalid: if (nbd_drop(client->ioc, length, errp) < 0) { return -EIO; } return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_INVALID, opt, errp, "%s", msg); }
--------------------------------------------- Result 537 ---------------------------------------------
[[0 (48%)]] --> [[0 (60%)]] --> Socre: 0.5958663821220398

[[[[Adv]]]]: static int scsi_req_stream_length(SCSICommand *[[cmd]], SCSIDevice *dev, uint8_t *buf) { switch (buf[0]) { case ERASE_12: case ERASE_16: [[cmd]]->xfer = 0; break; case READ_6: case READ_REVERSE: case RECOVER_BUFFERED_DATA: case WRITE_6: [[cmd]]->len = 6; [[cmd]]->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16); if (buf[1] & 0x01) { [[cmd]]->xfer *= dev->blocksize; } break; case READ_16: case READ_REVERSE_16: case VERIFY_16: case WRITE_16: [[cmd]]->len = 16; [[cmd]]->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16); if (buf[1] & 0x01) { [[cmd]]->xfer *= dev->blocksize; } break; case REWIND: case LOAD_UNLOAD: [[cmd]]->len = 6; [[cmd]]->xfer = 0; break; case SPACE_16: [[cmd]]->xfer = buf[13] | (buf[12] << 8); break; case READ_POSITION: [[cmd]]->xfer = buf[8] | (buf[7] << 8); break; case FORMAT_UNIT: [[cmd]]->xfer = buf[4] | (buf[3] << 8); break; default: return scsi_req_length([[cmd]], dev, buf); } return 0; }

[[[[Adv]]]]: static int scsi_req_stream_length(SCSICommand *[[cam]], SCSIDevice *dev, uint8_t *buf) { switch (buf[0]) { case ERASE_12: case ERASE_16: [[cam]]->xfer = 0; break; case READ_6: case READ_REVERSE: case RECOVER_BUFFERED_DATA: case WRITE_6: [[cam]]->len = 6; [[cam]]->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16); if (buf[1] & 0x01) { [[cam]]->xfer *= dev->blocksize; } break; case READ_16: case READ_REVERSE_16: case VERIFY_16: case WRITE_16: [[cam]]->len = 16; [[cam]]->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16); if (buf[1] & 0x01) { [[cam]]->xfer *= dev->blocksize; } break; case REWIND: case LOAD_UNLOAD: [[cam]]->len = 6; [[cam]]->xfer = 0; break; case SPACE_16: [[cam]]->xfer = buf[13] | (buf[12] << 8); break; case READ_POSITION: [[cam]]->xfer = buf[8] | (buf[7] << 8); break; case FORMAT_UNIT: [[cam]]->xfer = buf[4] | (buf[3] << 8); break; default: return scsi_req_length([[cam]], dev, buf); } return 0; }
--------------------------------------------- Result 538 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 309 / 31 / 198 / 538:  20%|        | 538/2690 [5:29:55<21:59:43, 36.80s/it][Succeeded / Failed / Skipped / Total] 309 / 31 / 198 / 538:  20%|        | 539/2690 [5:31:25<22:02:38, 36.89s/it][[0 (9%)]] --> [[0 (57%)]] --> Socre: 0.570819079875946

[[[[Adv]]]]: static void gen_tst_cc (DisasContext *dc, TCGv cc, int cond) { int [[arith_opt]], move_opt; [[arith_opt]] = arith_cc(dc) && !dc->flags_uptodate; move_opt = (dc->cc_op == CC_OP_MOVE) && dc->flags_uptodate; switch (cond) { case CC_EQ: if ([[arith_opt]] || move_opt) { int l1; l1 = gen_new_label(); tcg_gen_movi_tl(cc, 0); tcg_gen_brcondi_tl(TCG_COND_NE, cc_result, 0, l1); tcg_gen_movi_tl(cc, 1); gen_set_label(l1); } else { cris_evaluate_flags(dc); tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], Z_FLAG); } break; case CC_NE: if ([[arith_opt]] || move_opt) tcg_gen_mov_tl(cc, cc_result); else { cris_evaluate_flags(dc); tcg_gen_xori_tl(cc, cpu_PR[PR_CCS], Z_FLAG); tcg_gen_andi_tl(cc, cc, Z_FLAG); } break; case CC_CS: cris_evaluate_flags(dc); tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], C_FLAG); break; case CC_CC: cris_evaluate_flags(dc); tcg_gen_xori_tl(cc, cpu_PR[PR_CCS], C_FLAG); tcg_gen_andi_tl(cc, cc, C_FLAG); break; case CC_VS: cris_evaluate_flags(dc); tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], V_FLAG); break; case CC_VC: cris_evaluate_flags(dc); tcg_gen_xori_tl(cc, cpu_PR[PR_CCS], V_FLAG); tcg_gen_andi_tl(cc, cc, V_FLAG); break; case CC_PL: if ([[arith_opt]] || move_opt) { int bits = 31; if (dc->cc_size == 1) bits = 7; else if (dc->cc_size == 2) bits = 15; tcg_gen_shri_tl(cc, cc_result, bits); tcg_gen_xori_tl(cc, cc, 1); } else { cris_evaluate_flags(dc); tcg_gen_xori_tl(cc, cpu_PR[PR_CCS], N_FLAG); tcg_gen_andi_tl(cc, cc, N_FLAG); } break; case CC_MI: if ([[arith_opt]] || move_opt) { int bits = 31; if (dc->cc_size == 1) bits = 7; else if (dc->cc_size == 2) bits = 15; tcg_gen_shri_tl(cc, cc_result, 31); } else { cris_evaluate_flags(dc); tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], N_FLAG); } break; case CC_LS: cris_evaluate_flags(dc); tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], C_FLAG | Z_FLAG); break; case CC_HI: cris_evaluate_flags(dc); { TCGv tmp; tmp = tcg_temp_new(TCG_TYPE_TL); tcg_gen_xori_tl(tmp, cpu_PR[PR_CCS], C_FLAG | Z_FLAG); tcg_gen_shli_tl(cc, tmp, 2); tcg_gen_and_tl(cc, tmp, cc); tcg_gen_andi_tl(cc, cc, Z_FLAG); tcg_temp_free(tmp); } break; case CC_GE: cris_evaluate_flags(dc); tcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2); tcg_gen_xor_tl(cc, cpu_PR[PR_CCS], cc); tcg_gen_andi_tl(cc, cc, N_FLAG); tcg_gen_xori_tl(cc, cc, N_FLAG); break; case CC_LT: cris_evaluate_flags(dc); tcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2); tcg_gen_xor_tl(cc, cpu_PR[PR_CCS], cc); tcg_gen_andi_tl(cc, cc, N_FLAG); break; case CC_GT: cris_evaluate_flags(dc); { TCGv n, z; n = tcg_temp_new(TCG_TYPE_TL); z = tcg_temp_new(TCG_TYPE_TL); tcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2); tcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1); tcg_gen_xori_tl(z, z, 2); tcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]); tcg_gen_xori_tl(n, n, 2); tcg_gen_and_tl(cc, z, n); tcg_gen_andi_tl(cc, cc, 2); tcg_temp_free(n); tcg_temp_free(z); } break; case CC_LE: cris_evaluate_flags(dc); { TCGv n, z; n = tcg_temp_new(TCG_TYPE_TL); z = tcg_temp_new(TCG_TYPE_TL); tcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2); tcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1); tcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]); tcg_gen_or_tl(cc, z, n); tcg_gen_andi_tl(cc, cc, 2); tcg_temp_free(n); tcg_temp_free(z); } break; case CC_P: cris_evaluate_flags(dc); tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], P_FLAG); break; case CC_A: tcg_gen_movi_tl(cc, 1); break; default: BUG(); break; }; }

[[[[Adv]]]]: static void gen_tst_cc (DisasContext *dc, TCGv cc, int cond) { int [[elfi]], move_opt; [[elfi]] = arith_cc(dc) && !dc->flags_uptodate; move_opt = (dc->cc_op == CC_OP_MOVE) && dc->flags_uptodate; switch (cond) { case CC_EQ: if ([[elfi]] || move_opt) { int l1; l1 = gen_new_label(); tcg_gen_movi_tl(cc, 0); tcg_gen_brcondi_tl(TCG_COND_NE, cc_result, 0, l1); tcg_gen_movi_tl(cc, 1); gen_set_label(l1); } else { cris_evaluate_flags(dc); tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], Z_FLAG); } break; case CC_NE: if ([[elfi]] || move_opt) tcg_gen_mov_tl(cc, cc_result); else { cris_evaluate_flags(dc); tcg_gen_xori_tl(cc, cpu_PR[PR_CCS], Z_FLAG); tcg_gen_andi_tl(cc, cc, Z_FLAG); } break; case CC_CS: cris_evaluate_flags(dc); tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], C_FLAG); break; case CC_CC: cris_evaluate_flags(dc); tcg_gen_xori_tl(cc, cpu_PR[PR_CCS], C_FLAG); tcg_gen_andi_tl(cc, cc, C_FLAG); break; case CC_VS: cris_evaluate_flags(dc); tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], V_FLAG); break; case CC_VC: cris_evaluate_flags(dc); tcg_gen_xori_tl(cc, cpu_PR[PR_CCS], V_FLAG); tcg_gen_andi_tl(cc, cc, V_FLAG); break; case CC_PL: if ([[elfi]] || move_opt) { int bits = 31; if (dc->cc_size == 1) bits = 7; else if (dc->cc_size == 2) bits = 15; tcg_gen_shri_tl(cc, cc_result, bits); tcg_gen_xori_tl(cc, cc, 1); } else { cris_evaluate_flags(dc); tcg_gen_xori_tl(cc, cpu_PR[PR_CCS], N_FLAG); tcg_gen_andi_tl(cc, cc, N_FLAG); } break; case CC_MI: if ([[elfi]] || move_opt) { int bits = 31; if (dc->cc_size == 1) bits = 7; else if (dc->cc_size == 2) bits = 15; tcg_gen_shri_tl(cc, cc_result, 31); } else { cris_evaluate_flags(dc); tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], N_FLAG); } break; case CC_LS: cris_evaluate_flags(dc); tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], C_FLAG | Z_FLAG); break; case CC_HI: cris_evaluate_flags(dc); { TCGv tmp; tmp = tcg_temp_new(TCG_TYPE_TL); tcg_gen_xori_tl(tmp, cpu_PR[PR_CCS], C_FLAG | Z_FLAG); tcg_gen_shli_tl(cc, tmp, 2); tcg_gen_and_tl(cc, tmp, cc); tcg_gen_andi_tl(cc, cc, Z_FLAG); tcg_temp_free(tmp); } break; case CC_GE: cris_evaluate_flags(dc); tcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2); tcg_gen_xor_tl(cc, cpu_PR[PR_CCS], cc); tcg_gen_andi_tl(cc, cc, N_FLAG); tcg_gen_xori_tl(cc, cc, N_FLAG); break; case CC_LT: cris_evaluate_flags(dc); tcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2); tcg_gen_xor_tl(cc, cpu_PR[PR_CCS], cc); tcg_gen_andi_tl(cc, cc, N_FLAG); break; case CC_GT: cris_evaluate_flags(dc); { TCGv n, z; n = tcg_temp_new(TCG_TYPE_TL); z = tcg_temp_new(TCG_TYPE_TL); tcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2); tcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1); tcg_gen_xori_tl(z, z, 2); tcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]); tcg_gen_xori_tl(n, n, 2); tcg_gen_and_tl(cc, z, n); tcg_gen_andi_tl(cc, cc, 2); tcg_temp_free(n); tcg_temp_free(z); } break; case CC_LE: cris_evaluate_flags(dc); { TCGv n, z; n = tcg_temp_new(TCG_TYPE_TL); z = tcg_temp_new(TCG_TYPE_TL); tcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2); tcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1); tcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]); tcg_gen_or_tl(cc, z, n); tcg_gen_andi_tl(cc, cc, 2); tcg_temp_free(n); tcg_temp_free(z); } break; case CC_P: cris_evaluate_flags(dc); tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], P_FLAG); break; case CC_A: tcg_gen_movi_tl(cc, 1); break; default: BUG(); break; }; }
--------------------------------------------- Result 539 ---------------------------------------------
[[0 (40%)]] --> [[0 (84%)]] --> Socre: 0.8380216956138611

[[[[Adv]]]]: void do_smm_enter(X86CPU *cpu) { CPUX86State *env = &cpu->env; CPUState *cs = CPU(cpu); target_ulong [[sm_state]]; SegmentCache *dt; int i, offset; qemu_log_mask(CPU_LOG_INT, "SMM: enter\n"); log_cpu_state_mask(CPU_LOG_INT, CPU(cpu), CPU_DUMP_CCOP); env->hflags |= HF_SMM_MASK; if (env->hflags2 & HF2_NMI_MASK) { env->hflags2 |= HF2_SMM_INSIDE_NMI_MASK; } else { env->hflags2 |= HF2_NMI_MASK; } cpu_smm_update(env); [[sm_state]] = env->smbase + 0x8000; #ifdef TARGET_X86_64 for (i = 0; i < 6; i++) { dt = &env->segs[i]; offset = 0x7e00 + i * 16; x86_stw_phys(cs, [[sm_state]] + offset, dt->selector); x86_stw_phys(cs, [[sm_state]] + offset + 2, (dt->flags >> 8) & 0xf0ff); x86_stl_phys(cs, [[sm_state]] + offset + 4, dt->limit); x86_stq_phys(cs, [[sm_state]] + offset + 8, dt->base); } x86_stq_phys(cs, [[sm_state]] + 0x7e68, env->gdt.base); x86_stl_phys(cs, [[sm_state]] + 0x7e64, env->gdt.limit); x86_stw_phys(cs, [[sm_state]] + 0x7e70, env->ldt.selector); x86_stq_phys(cs, [[sm_state]] + 0x7e78, env->ldt.base); x86_stl_phys(cs, [[sm_state]] + 0x7e74, env->ldt.limit); x86_stw_phys(cs, [[sm_state]] + 0x7e72, (env->ldt.flags >> 8) & 0xf0ff); x86_stq_phys(cs, [[sm_state]] + 0x7e88, env->idt.base); x86_stl_phys(cs, [[sm_state]] + 0x7e84, env->idt.limit); x86_stw_phys(cs, [[sm_state]] + 0x7e90, env->tr.selector); x86_stq_phys(cs, [[sm_state]] + 0x7e98, env->tr.base); x86_stl_phys(cs, [[sm_state]] + 0x7e94, env->tr.limit); x86_stw_phys(cs, [[sm_state]] + 0x7e92, (env->tr.flags >> 8) & 0xf0ff); x86_stq_phys(cs, [[sm_state]] + 0x7ed0, env->efer); x86_stq_phys(cs, [[sm_state]] + 0x7ff8, env->regs[R_EAX]); x86_stq_phys(cs, [[sm_state]] + 0x7ff0, env->regs[R_ECX]); x86_stq_phys(cs, [[sm_state]] + 0x7fe8, env->regs[R_EDX]); x86_stq_phys(cs, [[sm_state]] + 0x7fe0, env->regs[R_EBX]); x86_stq_phys(cs, [[sm_state]] + 0x7fd8, env->regs[R_ESP]); x86_stq_phys(cs, [[sm_state]] + 0x7fd0, env->regs[R_EBP]); x86_stq_phys(cs, [[sm_state]] + 0x7fc8, env->regs[R_ESI]); x86_stq_phys(cs, [[sm_state]] + 0x7fc0, env->regs[R_EDI]); for (i = 8; i < 16; i++) { x86_stq_phys(cs, [[sm_state]] + 0x7ff8 - i * 8, env->regs[i]); } x86_stq_phys(cs, [[sm_state]] + 0x7f78, env->eip); x86_stl_phys(cs, [[sm_state]] + 0x7f70, cpu_compute_eflags(env)); x86_stl_phys(cs, [[sm_state]] + 0x7f68, env->dr[6]); x86_stl_phys(cs, [[sm_state]] + 0x7f60, env->dr[7]); x86_stl_phys(cs, [[sm_state]] + 0x7f48, env->cr[4]); x86_stq_phys(cs, [[sm_state]] + 0x7f50, env->cr[3]); x86_stl_phys(cs, [[sm_state]] + 0x7f58, env->cr[0]); x86_stl_phys(cs, [[sm_state]] + 0x7efc, SMM_REVISION_ID); x86_stl_phys(cs, [[sm_state]] + 0x7f00, env->smbase); #else x86_stl_phys(cs, [[sm_state]] + 0x7ffc, env->cr[0]); x86_stl_phys(cs, [[sm_state]] + 0x7ff8, env->cr[3]); x86_stl_phys(cs, [[sm_state]] + 0x7ff4, cpu_compute_eflags(env)); x86_stl_phys(cs, [[sm_state]] + 0x7ff0, env->eip); x86_stl_phys(cs, [[sm_state]] + 0x7fec, env->regs[R_EDI]); x86_stl_phys(cs, [[sm_state]] + 0x7fe8, env->regs[R_ESI]); x86_stl_phys(cs, [[sm_state]] + 0x7fe4, env->regs[R_EBP]); x86_stl_phys(cs, [[sm_state]] + 0x7fe0, env->regs[R_ESP]); x86_stl_phys(cs, [[sm_state]] + 0x7fdc, env->regs[R_EBX]); x86_stl_phys(cs, [[sm_state]] + 0x7fd8, env->regs[R_EDX]); x86_stl_phys(cs, [[sm_state]] + 0x7fd4, env->regs[R_ECX]); x86_stl_phys(cs, [[sm_state]] + 0x7fd0, env->regs[R_EAX]); x86_stl_phys(cs, [[sm_state]] + 0x7fcc, env->dr[6]); x86_stl_phys(cs, [[sm_state]] + 0x7fc8, env->dr[7]); x86_stl_phys(cs, [[sm_state]] + 0x7fc4, env->tr.selector); x86_stl_phys(cs, [[sm_state]] + 0x7f64, env->tr.base); x86_stl_phys(cs, [[sm_state]] + 0x7f60, env->tr.limit); x86_stl_phys(cs, [[sm_state]] + 0x7f5c, (env->tr.flags >> 8) & 0xf0ff); x86_stl_phys(cs, [[sm_state]] + 0x7fc0, env->ldt.selector); x86_stl_phys(cs, [[sm_state]] + 0x7f80, env->ldt.base); x86_stl_phys(cs, [[sm_state]] + 0x7f7c, env->ldt.limit); x86_stl_phys(cs, [[sm_state]] + 0x7f78, (env->ldt.flags >> 8) & 0xf0ff); x86_stl_phys(cs, [[sm_state]] + 0x7f74, env->gdt.base); x86_stl_phys(cs, [[sm_state]] + 0x7f70, env->gdt.limit); x86_stl_phys(cs, [[sm_state]] + 0x7f58, env->idt.base); x86_stl_phys(cs, [[sm_state]] + 0x7f54, env->idt.limit); for (i = 0; i < 6; i++) { dt = &env->segs[i]; if (i < 3) { offset = 0x7f84 + i * 12; } else { offset = 0x7f2c + (i - 3) * 12; } x86_stl_phys(cs, [[sm_state]] + 0x7fa8 + i * 4, dt->selector); x86_stl_phys(cs, [[sm_state]] + offset + 8, dt->base); x86_stl_phys(cs, [[sm_state]] + offset + 4, dt->limit); x86_stl_phys(cs, [[sm_state]] + offset, (dt->flags >> 8) & 0xf0ff); } x86_stl_phys(cs, [[sm_state]] + 0x7f14, env->cr[4]); x86_stl_phys(cs, [[sm_state]] + 0x7efc, SMM_REVISION_ID); x86_stl_phys(cs, [[sm_state]] + 0x7ef8, env->smbase); #endif #ifdef TARGET_X86_64 cpu_load_efer(env, 0); #endif cpu_load_eflags(env, 0, ~(CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C | DF_MASK)); env->eip = 0x00008000; cpu_x86_update_cr0(env, env->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK | CR0_PG_MASK)); cpu_x86_update_cr4(env, 0); env->dr[7] = 0x00000400; cpu_x86_load_seg_cache(env, R_CS, (env->smbase >> 4) & 0xffff, env->smbase, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache(env, R_SS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); }

[[[[Adv]]]]: void do_smm_enter(X86CPU *cpu) { CPUX86State *env = &cpu->env; CPUState *cs = CPU(cpu); target_ulong [[spiked]]; SegmentCache *dt; int i, offset; qemu_log_mask(CPU_LOG_INT, "SMM: enter\n"); log_cpu_state_mask(CPU_LOG_INT, CPU(cpu), CPU_DUMP_CCOP); env->hflags |= HF_SMM_MASK; if (env->hflags2 & HF2_NMI_MASK) { env->hflags2 |= HF2_SMM_INSIDE_NMI_MASK; } else { env->hflags2 |= HF2_NMI_MASK; } cpu_smm_update(env); [[spiked]] = env->smbase + 0x8000; #ifdef TARGET_X86_64 for (i = 0; i < 6; i++) { dt = &env->segs[i]; offset = 0x7e00 + i * 16; x86_stw_phys(cs, [[spiked]] + offset, dt->selector); x86_stw_phys(cs, [[spiked]] + offset + 2, (dt->flags >> 8) & 0xf0ff); x86_stl_phys(cs, [[spiked]] + offset + 4, dt->limit); x86_stq_phys(cs, [[spiked]] + offset + 8, dt->base); } x86_stq_phys(cs, [[spiked]] + 0x7e68, env->gdt.base); x86_stl_phys(cs, [[spiked]] + 0x7e64, env->gdt.limit); x86_stw_phys(cs, [[spiked]] + 0x7e70, env->ldt.selector); x86_stq_phys(cs, [[spiked]] + 0x7e78, env->ldt.base); x86_stl_phys(cs, [[spiked]] + 0x7e74, env->ldt.limit); x86_stw_phys(cs, [[spiked]] + 0x7e72, (env->ldt.flags >> 8) & 0xf0ff); x86_stq_phys(cs, [[spiked]] + 0x7e88, env->idt.base); x86_stl_phys(cs, [[spiked]] + 0x7e84, env->idt.limit); x86_stw_phys(cs, [[spiked]] + 0x7e90, env->tr.selector); x86_stq_phys(cs, [[spiked]] + 0x7e98, env->tr.base); x86_stl_phys(cs, [[spiked]] + 0x7e94, env->tr.limit); x86_stw_phys(cs, [[spiked]] + 0x7e92, (env->tr.flags >> 8) & 0xf0ff); x86_stq_phys(cs, [[spiked]] + 0x7ed0, env->efer); x86_stq_phys(cs, [[spiked]] + 0x7ff8, env->regs[R_EAX]); x86_stq_phys(cs, [[spiked]] + 0x7ff0, env->regs[R_ECX]); x86_stq_phys(cs, [[spiked]] + 0x7fe8, env->regs[R_EDX]); x86_stq_phys(cs, [[spiked]] + 0x7fe0, env->regs[R_EBX]); x86_stq_phys(cs, [[spiked]] + 0x7fd8, env->regs[R_ESP]); x86_stq_phys(cs, [[spiked]] + 0x7fd0, env->regs[R_EBP]); x86_stq_phys(cs, [[spiked]] + 0x7fc8, env->regs[R_ESI]); x86_stq_phys(cs, [[spiked]] + 0x7fc0, env->regs[R_EDI]); for (i = 8; i < 16; i++) { x86_stq_phys(cs, [[spiked]] + 0x7ff8 - i * 8, env->regs[i]); } x86_stq_phys(cs, [[spiked]] + 0x7f78, env->eip); x86_stl_phys(cs, [[spiked]] + 0x7f70, cpu_compute_eflags(env)); x86_stl_phys(cs, [[spiked]] + 0x7f68, env->dr[6]); x86_stl_phys(cs, [[spiked]] + 0x7f60, env->dr[7]); x86_stl_phys(cs, [[spiked]] + 0x7f48, env->cr[4]); x86_stq_phys(cs, [[spiked]] + 0x7f50, env->cr[3]); x86_stl_phys(cs, [[spiked]] + 0x7f58, env->cr[0]); x86_stl_phys(cs, [[spiked]] + 0x7efc, SMM_REVISION_ID); x86_stl_phys(cs, [[spiked]] + 0x7f00, env->smbase); #else x86_stl_phys(cs, [[spiked]] + 0x7ffc, env->cr[0]); x86_stl_phys(cs, [[spiked]] + 0x7ff8, env->cr[3]); x86_stl_phys(cs, [[spiked]] + 0x7ff4, cpu_compute_eflags(env)); x86_stl_phys(cs, [[spiked]] + 0x7ff0, env->eip); x86_stl_phys(cs, [[spiked]] + 0x7fec, env->regs[R_EDI]); x86_stl_phys(cs, [[spiked]] + 0x7fe8, env->regs[R_ESI]); x86_stl_phys(cs, [[spiked]] + 0x7fe4, env->regs[R_EBP]); x86_stl_phys(cs, [[spiked]] + 0x7fe0, env->regs[R_ESP]); x86_stl_phys(cs, [[spiked]] + 0x7fdc, env->regs[R_EBX]); x86_stl_phys(cs, [[spiked]] + 0x7fd8, env->regs[R_EDX]); x86_stl_phys(cs, [[spiked]] + 0x7fd4, env->regs[R_ECX]); x86_stl_phys(cs, [[spiked]] + 0x7fd0, env->regs[R_EAX]); x86_stl_phys(cs, [[spiked]] + 0x7fcc, env->dr[6]); x86_stl_phys(cs, [[spiked]] + 0x7fc8, env->dr[7]); x86_stl_phys(cs, [[spiked]] + 0x7fc4, env->tr.selector); x86_stl_phys(cs, [[spiked]] + 0x7f64, env->tr.base); x86_stl_phys(cs, [[spiked]] + 0x7f60, env->tr.limit); x86_stl_phys(cs, [[spiked]] + 0x7f5c, (env->tr.flags >> 8) & 0xf0ff); x86_stl_phys(cs, [[spiked]] + 0x7fc0, env->ldt.selector); x86_stl_phys(cs, [[spiked]] + 0x7f80, env->ldt.base); x86_stl_phys(cs, [[spiked]] + 0x7f7c, env->ldt.limit); x86_stl_phys(cs, [[spiked]] + 0x7f78, (env->ldt.flags >> 8) & 0xf0ff); x86_stl_phys(cs, [[spiked]] + 0x7f74, env->gdt.base); x86_stl_phys(cs, [[spiked]] + 0x7f70, env->gdt.limit); x86_stl_phys(cs, [[spiked]] + 0x7f58, env->idt.base); x86_stl_phys(cs, [[spiked]] + 0x7f54, env->idt.limit); for (i = 0; i < 6; i++) { dt = &env->segs[i]; if (i < 3) { offset = 0x7f84 + i * 12; } else { offset = 0x7f2c + (i - 3) * 12; } x86_stl_phys(cs, [[spiked]] + 0x7fa8 + i * 4, dt->selector); x86_stl_phys(cs, [[spiked]] + offset + 8, dt->base); x86_stl_phys(cs, [[spiked]] + offset + 4, dt->limit); x86_stl_phys(cs, [[spiked]] + offset, (dt->flags >> 8) & 0xf0ff); } x86_stl_phys(cs, [[spiked]] + 0x7f14, env->cr[4]); x86_stl_phys(cs, [[spiked]] + 0x7efc, SMM_REVISION_ID); x86_stl_phys(cs, [[spiked]] + 0x7ef8, env->smbase); #endif #ifdef TARGET_X86_64 cpu_load_efer(env, 0); #endif cpu_load_eflags(env, 0, ~(CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C | DF_MASK)); env->eip = 0x00008000; cpu_x86_update_cr0(env, env->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK | CR0_PG_MASK)); cpu_x86_update_cr4(env, 0); env->dr[7] = 0x00000400; cpu_x86_load_seg_cache(env, R_CS, (env->smbase >> 4) & 0xffff, env->smbase, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache(env, R_SS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffffffff, DESC_P_MASK | DESC_S_MASK | DESC_W_MASK | DESC_A_MASK); }[Succeeded / Failed / Skipped / Total] 310 / 31 / 198 / 539:  20%|        | 539/2690 [5:31:25<22:02:38, 36.89s/it][Succeeded / Failed / Skipped / Total] 310 / 31 / 198 / 539:  20%|        | 540/2690 [5:31:26<21:59:37, 36.83s/it][Succeeded / Failed / Skipped / Total] 310 / 31 / 199 / 540:  20%|        | 540/2690 [5:31:26<21:59:37, 36.83s/it][Succeeded / Failed / Skipped / Total] 310 / 31 / 199 / 540:  20%|        | 541/2690 [5:32:38<22:01:19, 36.89s/it][Succeeded / Failed / Skipped / Total] 311 / 31 / 199 / 541:  20%|        | 541/2690 [5:32:38<22:01:19, 36.89s/it][Succeeded / Failed / Skipped / Total] 311 / 31 / 199 / 541:  20%|        | 542/2690 [5:33:59<22:03:37, 36.97s/it]
--------------------------------------------- Result 540 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model, const char *default_devaddr) { const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr; PCIDevice *pci_dev; DeviceState *dev; int i; i = qemu_check_nic_model_list(nd, pci_nic_models, default_model); pci_dev = pci_create(pci_nic_names[i], devaddr); dev = &pci_dev->qdev; if (nd->id) dev->id = qemu_strdup(nd->id); dev->nd = nd; qdev_init(dev); nd->private = dev; return pci_dev; }
--------------------------------------------- Result 541 ---------------------------------------------
[[0 (84%)]] --> [[0 (38%)]] --> Socre: 0.6207389533519745

[[[[Adv]]]]: void ff_mlp_init_x86(DSPContext* c, AVCodecContext *[[avctx]]) { #if HAVE_7REGS && HAVE_TEN_OPERANDS c->mlp_filter_channel = mlp_filter_channel_x86; #endif }

[[[[Adv]]]]: void ff_mlp_init_x86(DSPContext* c, AVCodecContext *[[transposed]]) { #if HAVE_7REGS && HAVE_TEN_OPERANDS c->mlp_filter_channel = mlp_filter_channel_x86; #endif }
--------------------------------------------- Result 542 ---------------------------------------------
[[0 (3%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static uint64_t exynos4210_fimd_read(void *opaque, target_phys_addr_t offset, unsigned size) { Exynos4210fimdState *s = (Exynos4210fimdState *)opaque; int w, i; uint32_t ret = 0; DPRINT_L2("read offset 0x%08x\n", offset); switch (offset) { case FIMD_VIDCON0 ... FIMD_VIDCON3: return s->vidcon[(offset - FIMD_VIDCON0) >> 2]; case FIMD_VIDTCON_START ... FIMD_VIDTCON_END: return s->vidtcon[(offset - FIMD_VIDTCON_START) >> 2]; case FIMD_WINCON_START ... FIMD_WINCON_END: return s->window[(offset - FIMD_WINCON_START) >> 2].wincon; case FIMD_SHADOWCON: return s->shadowcon; case FIMD_WINCHMAP: return s->winchmap; case FIMD_VIDOSD_START ... FIMD_VIDOSD_END: w = (offset - FIMD_VIDOSD_START) >> 4; i = ((offset - FIMD_VIDOSD_START) & 0xF) >> 2; switch (i) { case 0: ret = ((s->window[w].lefttop_x & FIMD_VIDOSD_COORD_MASK) << FIMD_VIDOSD_HOR_SHIFT) | (s->window[w].lefttop_y & FIMD_VIDOSD_COORD_MASK); break; case 1: ret = ((s->window[w].rightbot_x & FIMD_VIDOSD_COORD_MASK) << FIMD_VIDOSD_HOR_SHIFT) | (s->window[w].rightbot_y & FIMD_VIDOSD_COORD_MASK); break; case 2: if (w == 0) { ret = s->window[w].osdsize; } else { ret = (pack_upper_4(s->window[w].alpha_val[0]) << FIMD_VIDOSD_AEN0_SHIFT) | pack_upper_4(s->window[w].alpha_val[1]); } break; case 3: if (w != 1 && w != 2) { DPRINT_ERROR("bad read offset 0x%08x\n", offset); return 0xBAADBAAD; } ret = s->window[w].osdsize; break; } return ret; case FIMD_VIDWADD0_START ... FIMD_VIDWADD0_END: w = (offset - FIMD_VIDWADD0_START) >> 3; i = ((offset - FIMD_VIDWADD0_START) >> 2) & 1; return s->window[w].buf_start[i]; case FIMD_VIDWADD1_START ... FIMD_VIDWADD1_END: w = (offset - FIMD_VIDWADD1_START) >> 3; i = ((offset - FIMD_VIDWADD1_START) >> 2) & 1; return s->window[w].buf_end[i]; case FIMD_VIDWADD2_START ... FIMD_VIDWADD2_END: w = (offset - FIMD_VIDWADD2_START) >> 2; return s->window[w].virtpage_width | (s->window[w].virtpage_offsize << FIMD_VIDWADD2_OFFSIZE_SHIFT); case FIMD_VIDINTCON0 ... FIMD_VIDINTCON1: return s->vidintcon[(offset - FIMD_VIDINTCON0) >> 2]; case FIMD_WKEYCON_START ... FIMD_WKEYCON_END: w = ((offset - FIMD_WKEYCON_START) >> 3) + 1; i = ((offset - FIMD_WKEYCON_START) >> 2) & 1; return s->window[w].keycon[i]; case FIMD_WKEYALPHA_START ... FIMD_WKEYALPHA_END: w = ((offset - FIMD_WKEYALPHA_START) >> 2) + 1; return s->window[w].keyalpha; case FIMD_DITHMODE: return s->dithmode; case FIMD_WINMAP_START ... FIMD_WINMAP_END: return s->window[(offset - FIMD_WINMAP_START) >> 2].winmap; case FIMD_WPALCON_HIGH ... FIMD_WPALCON_LOW: return s->wpalcon[(offset - FIMD_WPALCON_HIGH) >> 2]; case FIMD_TRIGCON: return s->trigcon; case FIMD_I80IFCON_START ... FIMD_I80IFCON_END: return s->i80ifcon[(offset - FIMD_I80IFCON_START) >> 2]; case FIMD_COLORGAINCON: return s->colorgaincon; case FIMD_LDI_CMDCON0 ... FIMD_LDI_CMDCON1: return s->ldi_cmdcon[(offset - FIMD_LDI_CMDCON0) >> 2]; case FIMD_SIFCCON0 ... FIMD_SIFCCON2: i = (offset - FIMD_SIFCCON0) >> 2; return s->sifccon[i]; case FIMD_HUECOEFCR_START ... FIMD_HUECOEFCR_END: i = (offset - FIMD_HUECOEFCR_START) >> 2; return s->huecoef_cr[i]; case FIMD_HUECOEFCB_START ... FIMD_HUECOEFCB_END: i = (offset - FIMD_HUECOEFCB_START) >> 2; return s->huecoef_cb[i]; case FIMD_HUEOFFSET: return s->hueoffset; case FIMD_VIDWALPHA_START ... FIMD_VIDWALPHA_END: w = ((offset - FIMD_VIDWALPHA_START) >> 3); i = ((offset - FIMD_VIDWALPHA_START) >> 2) & 1; return s->window[w].alpha_val[i] & (w == 0 ? 0xFFFFFF : FIMD_VIDALPHA_ALPHA_LOWER); case FIMD_BLENDEQ_START ... FIMD_BLENDEQ_END: return s->window[(offset - FIMD_BLENDEQ_START) >> 2].blendeq; case FIMD_BLENDCON: return s->blendcon; case FIMD_WRTQOSCON_START ... FIMD_WRTQOSCON_END: return s->window[(offset - FIMD_WRTQOSCON_START) >> 2].rtqoscon; case FIMD_I80IFCMD_START ... FIMD_I80IFCMD_END: return s->i80ifcmd[(offset - FIMD_I80IFCMD_START) >> 2]; case FIMD_VIDW0ADD0_B2 ... FIMD_VIDW4ADD0_B2: if (offset & 0x0004) { break; } return s->window[(offset - FIMD_VIDW0ADD0_B2) >> 3].buf_start[2]; case FIMD_SHD_ADD0_START ... FIMD_SHD_ADD0_END: if (offset & 0x0004) { break; } return s->window[(offset - FIMD_SHD_ADD0_START) >> 3].shadow_buf_start; case FIMD_SHD_ADD1_START ... FIMD_SHD_ADD1_END: if (offset & 0x0004) { break; } return s->window[(offset - FIMD_SHD_ADD1_START) >> 3].shadow_buf_end; case FIMD_SHD_ADD2_START ... FIMD_SHD_ADD2_END: return s->window[(offset - FIMD_SHD_ADD2_START) >> 2].shadow_buf_size; case FIMD_PAL_MEM_START ... FIMD_PAL_MEM_END: w = (offset - FIMD_PAL_MEM_START) >> 10; i = ((offset - FIMD_PAL_MEM_START) >> 2) & 0xFF; return s->window[w].palette[i]; case FIMD_PALMEM_AL_START ... FIMD_PALMEM_AL_END: w = (offset - FIMD_PALMEM_AL_START) >> 10; i = ((offset - FIMD_PALMEM_AL_START) >> 2) & 0xFF; return s->window[w].palette[i]; } DPRINT_ERROR("bad read offset 0x%08x\n", offset); return 0xBAADBAAD; }

[[[[Adv]]]]: static uint64_t exynos4210_fimd_read(void *opaque, target_phys_addr_t offset, unsigned size) { Exynos4210fimdState *s = (Exynos4210fimdState *)opaque; int w, i; uint32_t ret = 0; DPRINT_L2("read offset 0x%08x\n", offset); switch (offset) { case FIMD_VIDCON0 ... FIMD_VIDCON3: return s->vidcon[(offset - FIMD_VIDCON0) >> 2]; case FIMD_VIDTCON_START ... FIMD_VIDTCON_END: return s->vidtcon[(offset - FIMD_VIDTCON_START) >> 2]; case FIMD_WINCON_START ... FIMD_WINCON_END: return s->window[(offset - FIMD_WINCON_START) >> 2].wincon; case FIMD_SHADOWCON: return s->shadowcon; case FIMD_WINCHMAP: return s->winchmap; case FIMD_VIDOSD_START ... FIMD_VIDOSD_END: w = (offset - FIMD_VIDOSD_START) >> 4; i = ((offset - FIMD_VIDOSD_START) & 0xF) >> 2; switch (i) { case 0: ret = ((s->window[w].lefttop_x & FIMD_VIDOSD_COORD_MASK) << FIMD_VIDOSD_HOR_SHIFT) | (s->window[w].lefttop_y & FIMD_VIDOSD_COORD_MASK); break; case 1: ret = ((s->window[w].rightbot_x & FIMD_VIDOSD_COORD_MASK) << FIMD_VIDOSD_HOR_SHIFT) | (s->window[w].rightbot_y & FIMD_VIDOSD_COORD_MASK); break; case 2: if (w == 0) { ret = s->window[w].osdsize; } else { ret = (pack_upper_4(s->window[w].alpha_val[0]) << FIMD_VIDOSD_AEN0_SHIFT) | pack_upper_4(s->window[w].alpha_val[1]); } break; case 3: if (w != 1 && w != 2) { DPRINT_ERROR("bad read offset 0x%08x\n", offset); return 0xBAADBAAD; } ret = s->window[w].osdsize; break; } return ret; case FIMD_VIDWADD0_START ... FIMD_VIDWADD0_END: w = (offset - FIMD_VIDWADD0_START) >> 3; i = ((offset - FIMD_VIDWADD0_START) >> 2) & 1; return s->window[w].buf_start[i]; case FIMD_VIDWADD1_START ... FIMD_VIDWADD1_END: w = (offset - FIMD_VIDWADD1_START) >> 3; i = ((offset - FIMD_VIDWADD1_START) >> 2) & 1; return s->window[w].buf_end[i]; case FIMD_VIDWADD2_START ... FIMD_VIDWADD2_END: w = (offset - FIMD_VIDWADD2_START) >> 2; return s->window[w].virtpage_width | (s->window[w].virtpage_offsize << FIMD_VIDWADD2_OFFSIZE_SHIFT); case FIMD_VIDINTCON0 ... FIMD_VIDINTCON1: return s->vidintcon[(offset - FIMD_VIDINTCON0) >> 2]; case FIMD_WKEYCON_START ... FIMD_WKEYCON_END: w = ((offset - FIMD_WKEYCON_START) >> 3) + 1; i = ((offset - FIMD_WKEYCON_START) >> 2) & 1; return s->window[w].keycon[i]; case FIMD_WKEYALPHA_START ... FIMD_WKEYALPHA_END: w = ((offset - FIMD_WKEYALPHA_START) >> 2) + 1; return s->window[w].keyalpha; case FIMD_DITHMODE: return s->dithmode; case FIMD_WINMAP_START ... FIMD_WINMAP_END: return s->window[(offset - FIMD_WINMAP_START) >> 2].winmap; case FIMD_WPALCON_HIGH ... FIMD_WPALCON_LOW: return s->wpalcon[(offset - FIMD_WPALCON_HIGH) >> 2]; case FIMD_TRIGCON: return s->trigcon; case FIMD_I80IFCON_START ... FIMD_I80IFCON_END: return s->i80ifcon[(offset - FIMD_I80IFCON_START) >> 2]; case FIMD_COLORGAINCON: return s->colorgaincon; case FIMD_LDI_CMDCON0 ... FIMD_LDI_CMDCON1: return s->ldi_cmdcon[(offset - FIMD_LDI_CMDCON0) >> 2]; case FIMD_SIFCCON0 ... FIMD_SIFCCON2: i = (offset - FIMD_SIFCCON0) >> 2; return s->sifccon[i]; case FIMD_HUECOEFCR_START ... FIMD_HUECOEFCR_END: i = (offset - FIMD_HUECOEFCR_START) >> 2; return s->huecoef_cr[i]; case FIMD_HUECOEFCB_START ... FIMD_HUECOEFCB_END: i = (offset - FIMD_HUECOEFCB_START) >> 2; return s->huecoef_cb[i]; case FIMD_HUEOFFSET: return s->hueoffset; case FIMD_VIDWALPHA_START ... FIMD_VIDWALPHA_END: w = ((offset - FIMD_VIDWALPHA_START) >> 3); i = ((offset - FIMD_VIDWALPHA_START) >> 2) & 1; return s->window[w].alpha_val[i] & (w == 0 ? 0xFFFFFF : FIMD_VIDALPHA_ALPHA_LOWER); case FIMD_BLENDEQ_START ... FIMD_BLENDEQ_END: return s->window[(offset - FIMD_BLENDEQ_START) >> 2].blendeq; case FIMD_BLENDCON: return s->blendcon; case FIMD_WRTQOSCON_START ... FIMD_WRTQOSCON_END: return s->window[(offset - FIMD_WRTQOSCON_START) >> 2].rtqoscon; case FIMD_I80IFCMD_START ... FIMD_I80IFCMD_END: return s->i80ifcmd[(offset - FIMD_I80IFCMD_START) >> 2]; case FIMD_VIDW0ADD0_B2 ... FIMD_VIDW4ADD0_B2: if (offset & 0x0004) { break; } return s->window[(offset - FIMD_VIDW0ADD0_B2) >> 3].buf_start[2]; case FIMD_SHD_ADD0_START ... FIMD_SHD_ADD0_END: if (offset & 0x0004) { break; } return s->window[(offset - FIMD_SHD_ADD0_START) >> 3].shadow_buf_start; case FIMD_SHD_ADD1_START ... FIMD_SHD_ADD1_END: if (offset & 0x0004) { break; } return s->window[(offset - FIMD_SHD_ADD1_START) >> 3].shadow_buf_end; case FIMD_SHD_ADD2_START ... FIMD_SHD_ADD2_END: return s->window[(offset - FIMD_SHD_ADD2_START) >> 2].shadow_buf_size; case FIMD_PAL_MEM_START ... FIMD_PAL_MEM_END: w = (offset - FIMD_PAL_MEM_START) >> 10; i = ((offset - FIMD_PAL_MEM_START) >> 2) & 0xFF; return s->window[w].palette[i]; case FIMD_PALMEM_AL_START ... FIMD_PALMEM_AL_END: w = (offset - FIMD_PALMEM_AL_START) >> 10; i = ((offset - FIMD_PALMEM_AL_START) >> 2) & 0xFF; return s->window[w].palette[i]; } DPRINT_ERROR("bad read offset 0x%08x\n", offset); return 0xBAADBAAD; }[Succeeded / Failed / Skipped / Total] 311 / 32 / 199 / 542:  20%|        | 542/2690 [5:33:59<22:03:37, 36.97s/it][Succeeded / Failed / Skipped / Total] 311 / 32 / 199 / 542:  20%|        | 543/2690 [5:33:59<22:00:35, 36.91s/it][Succeeded / Failed / Skipped / Total] 311 / 32 / 200 / 543:  20%|        | 543/2690 [5:33:59<22:00:35, 36.91s/it][Succeeded / Failed / Skipped / Total] 311 / 32 / 200 / 543:  20%|        | 544/2690 [5:34:13<21:58:27, 36.86s/it][Succeeded / Failed / Skipped / Total] 312 / 32 / 200 / 544:  20%|        | 544/2690 [5:34:13<21:58:27, 36.86s/it][Succeeded / Failed / Skipped / Total] 312 / 32 / 200 / 544:  20%|        | 545/2690 [5:34:13<21:55:27, 36.80s/it][Succeeded / Failed / Skipped / Total] 312 / 32 / 201 / 545:  20%|        | 545/2690 [5:34:13<21:55:27, 36.80s/it][Succeeded / Failed / Skipped / Total] 312 / 32 / 201 / 545:  20%|        | 546/2690 [5:34:20<21:52:53, 36.74s/it][Succeeded / Failed / Skipped / Total] 313 / 32 / 201 / 546:  20%|        | 546/2690 [5:34:20<21:52:53, 36.74s/it][Succeeded / Failed / Skipped / Total] 313 / 32 / 201 / 546:  20%|        | 547/2690 [5:34:23<21:50:03, 36.68s/it]
--------------------------------------------- Result 543 ---------------------------------------------
[[0 (27%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_h264_flush_change(H264Context *h) { int i, j; h->next_outputed_poc = INT_MIN; h->prev_interlaced_frame = 1; idr(h); h->poc.prev_frame_num = -1; if (h->cur_pic_ptr) { h->cur_pic_ptr->reference = 0; for (j=i=0; h->delayed_pic[i]; i++) if (h->delayed_pic[i] != h->cur_pic_ptr) h->delayed_pic[j++] = h->delayed_pic[i]; h->delayed_pic[j] = NULL; } ff_h264_unref_picture(h, &h->last_pic_for_ec); h->first_field = 0; ff_h264_sei_uninit(&h->sei); h->recovery_frame = -1; h->frame_recovered = 0; h->current_slice = 0; h->mmco_reset = 1; for (i = 0; i < h->nb_slice_ctx; i++) h->slice_ctx[i].list_count = 0; }
--------------------------------------------- Result 544 ---------------------------------------------
[[0 (20%)]] --> [[0 (59%)]] --> Socre: 0.5936000943183899

[[[[Adv]]]]: static int av_set_number2(void *obj, const char *name, double num, int [[den]], int64_t intnum, const AVOption **o_out) { const AVOption *[[o]] = av_opt_find(obj, name, NULL, 0, 0); void *dst; if (o_out) *o_out= [[o]]; if (![[o]] || [[o]]->offset<=0) return AVERROR_OPTION_NOT_FOUND; if ([[o]]->max*[[den]] < num*intnum || [[o]]->min*[[den]] > num*intnum) { av_log(obj, AV_LOG_ERROR, "Value %lf for parameter '%s' out of range\n", num, name); return AVERROR(ERANGE); } dst= ((uint8_t*)obj) + [[o]]->offset; switch ([[o]]->type) { case FF_OPT_TYPE_FLAGS: case FF_OPT_TYPE_INT: *(int *)dst= llrint(num/[[den]])*intnum; break; case FF_OPT_TYPE_INT64: *(int64_t *)dst= llrint(num/[[den]])*intnum; break; case FF_OPT_TYPE_FLOAT: *(float *)dst= num*intnum/[[den]]; break; case FF_OPT_TYPE_DOUBLE:*(double *)dst= num*intnum/[[den]]; break; case FF_OPT_TYPE_RATIONAL: if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, [[den]]}; else *(AVRational*)dst= av_d2q(num*intnum/[[den]], 1<<24); break; default: return AVERROR(EINVAL); } return 0; }

[[[[Adv]]]]: static int av_set_number2(void *obj, const char *name, double num, int [[barbershop]], int64_t intnum, const AVOption **o_out) { const AVOption *[[australians]] = av_opt_find(obj, name, NULL, 0, 0); void *dst; if (o_out) *o_out= [[australians]]; if (![[australians]] || [[australians]]->offset<=0) return AVERROR_OPTION_NOT_FOUND; if ([[australians]]->max*[[barbershop]] < num*intnum || [[australians]]->min*[[barbershop]] > num*intnum) { av_log(obj, AV_LOG_ERROR, "Value %lf for parameter '%s' out of range\n", num, name); return AVERROR(ERANGE); } dst= ((uint8_t*)obj) + [[australians]]->offset; switch ([[australians]]->type) { case FF_OPT_TYPE_FLAGS: case FF_OPT_TYPE_INT: *(int *)dst= llrint(num/[[barbershop]])*intnum; break; case FF_OPT_TYPE_INT64: *(int64_t *)dst= llrint(num/[[barbershop]])*intnum; break; case FF_OPT_TYPE_FLOAT: *(float *)dst= num*intnum/[[barbershop]]; break; case FF_OPT_TYPE_DOUBLE:*(double *)dst= num*intnum/[[barbershop]]; break; case FF_OPT_TYPE_RATIONAL: if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, [[barbershop]]}; else *(AVRational*)dst= av_d2q(num*intnum/[[barbershop]], 1<<24); break; default: return AVERROR(EINVAL); } return 0; }
--------------------------------------------- Result 545 ---------------------------------------------
[[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qxl_realize_common(PCIQXLDevice *qxl, Error **errp) { uint8_t* config = qxl->pci.config; uint32_t pci_device_rev; uint32_t io_size; qxl->mode = QXL_MODE_UNDEFINED; qxl->generation = 1; qxl->num_memslots = NUM_MEMSLOTS; qemu_mutex_init(&qxl->track_lock); qemu_mutex_init(&qxl->async_lock); qxl->current_async = QXL_UNDEFINED_IO; qxl->guest_bug = 0; switch (qxl->revision) { case 1: pci_device_rev = QXL_REVISION_STABLE_V04; io_size = 8; break; case 2: pci_device_rev = QXL_REVISION_STABLE_V06; io_size = 16; break; case 3: pci_device_rev = QXL_REVISION_STABLE_V10; io_size = 32; break; case 4: pci_device_rev = QXL_REVISION_STABLE_V12; io_size = pow2ceil(QXL_IO_RANGE_SIZE); break; default: error_setg(errp, "Invalid revision %d for qxl device (max %d)", qxl->revision, QXL_DEFAULT_REVISION); return; } pci_set_byte(&config[PCI_REVISION_ID], pci_device_rev); pci_set_byte(&config[PCI_INTERRUPT_PIN], 1); qxl->rom_size = qxl_rom_size(); memory_region_init_ram(&qxl->rom_bar, OBJECT(qxl), "qxl.vrom", qxl->rom_size, &error_abort); vmstate_register_ram(&qxl->rom_bar, &qxl->pci.qdev); init_qxl_rom(qxl); init_qxl_ram(qxl); qxl->guest_surfaces.cmds = g_new0(QXLPHYSICAL, qxl->ssd.num_surfaces); memory_region_init_ram(&qxl->vram_bar, OBJECT(qxl), "qxl.vram", qxl->vram_size, &error_abort); vmstate_register_ram(&qxl->vram_bar, &qxl->pci.qdev); memory_region_init_alias(&qxl->vram32_bar, OBJECT(qxl), "qxl.vram32", &qxl->vram_bar, 0, qxl->vram32_size); memory_region_init_io(&qxl->io_bar, OBJECT(qxl), &qxl_io_ops, qxl, "qxl-ioports", io_size); if (qxl->id == 0) { vga_dirty_log_start(&qxl->vga); } memory_region_set_flush_coalesced(&qxl->io_bar); pci_register_bar(&qxl->pci, QXL_IO_RANGE_INDEX, PCI_BASE_ADDRESS_SPACE_IO, &qxl->io_bar); pci_register_bar(&qxl->pci, QXL_ROM_RANGE_INDEX, PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->rom_bar); pci_register_bar(&qxl->pci, QXL_RAM_RANGE_INDEX, PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vga.vram); pci_register_bar(&qxl->pci, QXL_VRAM_RANGE_INDEX, PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vram32_bar); if (qxl->vram32_size < qxl->vram_size) { pci_register_bar(&qxl->pci, QXL_VRAM64_RANGE_INDEX, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_64 | PCI_BASE_ADDRESS_MEM_PREFETCH, &qxl->vram_bar); } dprint(qxl, 1, "ram/%s: %d MB [region 0]\n", qxl->id == 0 ? "pri" : "sec", qxl->vga.vram_size / (1024*1024)); dprint(qxl, 1, "vram/32: %d MB [region 1]\n", qxl->vram32_size / (1024*1024)); dprint(qxl, 1, "vram/64: %d MB %s\n", qxl->vram_size / (1024*1024), qxl->vram32_size < qxl->vram_size ? "[region 4]" : "[unmapped]"); qxl->ssd.qxl.base.sif = &qxl_interface.base; if (qemu_spice_add_display_interface(&qxl->ssd.qxl, qxl->vga.con) != 0) { error_setg(errp, "qxl interface %d.%d not supported by spice-server", SPICE_INTERFACE_QXL_MAJOR, SPICE_INTERFACE_QXL_MINOR); return; } qemu_add_vm_change_state_handler(qxl_vm_change_state_handler, qxl); qxl->update_irq = qemu_bh_new(qxl_update_irq_bh, qxl); qxl_reset_state(qxl); qxl->update_area_bh = qemu_bh_new(qxl_render_update_area_bh, qxl); qxl->ssd.cursor_bh = qemu_bh_new(qemu_spice_cursor_refresh_bh, &qxl->ssd); }
--------------------------------------------- Result 546 ---------------------------------------------
[[0 (75%)]] --> [[0 (37%)]] --> Socre: 0.6308825016021729

[[[[Adv]]]]: static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *[[block]]) { int i; int dc = [[block]][0]; const uint8_t *[[cm]]; dc = ( 3 * dc + 1) >> 1; dc = (17 * dc + 64) >> 7; [[cm]] = ff_cropTbl + MAX_NEG_CROP + dc; for(i = 0; i < 4; i++){ dest[0] = [[cm]][dest[0]]; dest[1] = [[cm]][dest[1]]; dest[2] = [[cm]][dest[2]]; dest[3] = [[cm]][dest[3]]; dest[4] = [[cm]][dest[4]]; dest[5] = [[cm]][dest[5]]; dest[6] = [[cm]][dest[6]]; dest[7] = [[cm]][dest[7]]; dest += linesize; } }

[[[[Adv]]]]: static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *[[impair]]) { int i; int dc = [[impair]][0]; const uint8_t *[[mmh]]; dc = ( 3 * dc + 1) >> 1; dc = (17 * dc + 64) >> 7; [[mmh]] = ff_cropTbl + MAX_NEG_CROP + dc; for(i = 0; i < 4; i++){ dest[0] = [[mmh]][dest[0]]; dest[1] = [[mmh]][dest[1]]; dest[2] = [[mmh]][dest[2]]; dest[3] = [[mmh]][dest[3]]; dest[4] = [[mmh]][dest[4]]; dest[5] = [[mmh]][dest[5]]; dest[6] = [[mmh]][dest[6]]; dest[7] = [[mmh]][dest[7]]; dest += linesize; } }
--------------------------------------------- Result 547 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 314 / 32 / 201 / 547:  20%|        | 547/2690 [5:34:23<21:50:03, 36.68s/it][Succeeded / Failed / Skipped / Total] 314 / 32 / 201 / 547:  20%|        | 548/2690 [5:35:31<21:51:30, 36.74s/it][Succeeded / Failed / Skipped / Total] 315 / 32 / 201 / 548:  20%|        | 548/2690 [5:35:31<21:51:30, 36.74s/it][Succeeded / Failed / Skipped / Total] 315 / 32 / 201 / 548:  20%|        | 549/2690 [5:36:25<21:52:00, 36.77s/it][Succeeded / Failed / Skipped / Total] 316 / 32 / 201 / 549:  20%|        | 549/2690 [5:36:25<21:52:00, 36.77s/it][Succeeded / Failed / Skipped / Total] 316 / 32 / 201 / 549:  20%|        | 550/2690 [5:36:32<21:49:28, 36.71s/it][Succeeded / Failed / Skipped / Total] 317 / 32 / 201 / 550:  20%|        | 550/2690 [5:36:32<21:49:28, 36.71s/it][Succeeded / Failed / Skipped / Total] 317 / 32 / 201 / 550:  20%|        | 551/2690 [5:36:33<21:46:31, 36.65s/it][Succeeded / Failed / Skipped / Total] 317 / 32 / 202 / 551:  20%|        | 551/2690 [5:36:33<21:46:31, 36.65s/it][Succeeded / Failed / Skipped / Total] 317 / 32 / 202 / 551:  21%|        | 552/2690 [5:36:40<21:44:00, 36.60s/it][Succeeded / Failed / Skipped / Total] 318 / 32 / 202 / 552:  21%|        | 552/2690 [5:36:40<21:44:00, 36.60s/it][Succeeded / Failed / Skipped / Total] 318 / 32 / 202 / 552:  21%|        | 553/2690 [5:36:41<21:41:04, 36.53s/it][Succeeded / Failed / Skipped / Total] 318 / 32 / 203 / 553:  21%|        | 553/2690 [5:36:41<21:41:04, 36.53s/it][Succeeded / Failed / Skipped / Total] 318 / 32 / 203 / 553:  21%|        | 554/2690 [5:36:41<21:38:09, 36.46s/it][[0 (59%)]] --> [[0 (41%)]] --> Socre: 0.5861800909042358

[[[[Adv]]]]: static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int [[r]]) { switch(mode){ case 0: return src[0]; case 1: return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - [[r]]) >> 6; case 2: return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - [[r]]) >> 4; case 3: return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - [[r]]) >> 6; } return 0; }

[[[[Adv]]]]: static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int [[reddy]]) { switch(mode){ case 0: return src[0]; case 1: return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - [[reddy]]) >> 6; case 2: return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - [[reddy]]) >> 4; case 3: return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - [[reddy]]) >> 6; } return 0; }
--------------------------------------------- Result 548 ---------------------------------------------
[[0 (68%)]] --> [[0 (40%)]] --> Socre: 0.5977494716644287

[[[[Adv]]]]: static uint64_t openpic_tmr_read(void *[[opaque]], hwaddr addr, unsigned len) { OpenPICState *opp = [[opaque]]; uint32_t retval = -1; int idx; DPRINTF("%s: addr %08x\n", __func__, addr); if (addr & 0xF) { goto out; } idx = (addr >> 6) & 0x3; if (addr == 0x0) { retval = opp->tifr; goto out; } switch (addr & 0x30) { case 0x00: retval = opp->timers[idx].ticc; break; case 0x10: retval = opp->timers[idx].tibc; break; case 0x20: retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx); break; case 0x30: retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx); break; } out: DPRINTF("%s: => %08x\n", __func__, retval); return retval; }

[[[[Adv]]]]: static uint64_t openpic_tmr_read(void *[[perplexing]], hwaddr addr, unsigned len) { OpenPICState *opp = [[perplexing]]; uint32_t retval = -1; int idx; DPRINTF("%s: addr %08x\n", __func__, addr); if (addr & 0xF) { goto out; } idx = (addr >> 6) & 0x3; if (addr == 0x0) { retval = opp->tifr; goto out; } switch (addr & 0x30) { case 0x00: retval = opp->timers[idx].ticc; break; case 0x10: retval = opp->timers[idx].tibc; break; case 0x20: retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx); break; case 0x30: retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx); break; } out: DPRINTF("%s: => %08x\n", __func__, retval); return retval; }
--------------------------------------------- Result 549 ---------------------------------------------
[[0 (2%)]] --> [[0 (98%)]] --> Socre: 0.978846549987793

[[[[Adv]]]]: static void gen_exception_insn(DisasContext *s, int offset, int [[excp]]) { gen_a64_set_pc_im(s->pc - offset); gen_exception([[excp]]); s->is_jmp = DISAS_JUMP; }

[[[[Adv]]]]: static void gen_exception_insn(DisasContext *s, int offset, int [[doa]]) { gen_a64_set_pc_im(s->pc - offset); gen_exception([[doa]]); s->is_jmp = DISAS_JUMP; }
--------------------------------------------- Result 550 ---------------------------------------------
[[0 (48%)]] --> [[0 (67%)]] --> Socre: 0.6707459688186646

[[[[Adv]]]]: static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp) { const QDictEntry *ent; const char *[[arg_name]]; const QObject *arg_obj; bool has_exec_key = "False" != "False"; QDict *dict = NULL; if (qobject_type(request) != QTYPE_QDICT) { error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, "request is not a dictionary"); return NULL; } dict = qobject_to_qdict(request); for (ent = qdict_first(dict); ent; ent = qdict_next(dict, ent)) { [[arg_name]] = qdict_entry_key(ent); arg_obj = qdict_entry_value(ent); if (!strcmp([[arg_name]], "execute")) { if (qobject_type(arg_obj) != QTYPE_QSTRING) { error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, "execute", "string"); return NULL; } has_exec_key = "True" == "True"; } else if (strcmp([[arg_name]], "arguments")) { error_setg(errp, QERR_QMP_EXTRA_MEMBER, [[arg_name]]); return NULL; } } if (!has_exec_key) { error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, "execute"); return NULL; } return dict; }

[[[[Adv]]]]: static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp) { const QDictEntry *ent; const char *[[ropes]]; const QObject *arg_obj; bool has_exec_key = "False" != "False"; QDict *dict = NULL; if (qobject_type(request) != QTYPE_QDICT) { error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, "request is not a dictionary"); return NULL; } dict = qobject_to_qdict(request); for (ent = qdict_first(dict); ent; ent = qdict_next(dict, ent)) { [[ropes]] = qdict_entry_key(ent); arg_obj = qdict_entry_value(ent); if (!strcmp([[ropes]], "execute")) { if (qobject_type(arg_obj) != QTYPE_QSTRING) { error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, "execute", "string"); return NULL; } has_exec_key = "True" == "True"; } else if (strcmp([[ropes]], "arguments")) { error_setg(errp, QERR_QMP_EXTRA_MEMBER, [[ropes]]); return NULL; } } if (!has_exec_key) { error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, "execute"); return NULL; } return dict; }
--------------------------------------------- Result 551 ---------------------------------------------
[[0 (59%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void sha1_transform(uint32_t state[5], const uint8_t buffer[64]) { uint32_t block[80]; unsigned int i, a, b, c, d, e; a = state[0]; b = state[1]; c = state[2]; d = state[3]; e = state[4]; #if CONFIG_SMALL for (i = 0; i < 80; i++) { int t; if (i < 16) t = AV_RB32(buffer + 4 * i); else t = rol(block[i-3] ^ block[i-8] ^ block[i-14] ^ block[i-16], 1); block[i] = t; t += e + rol(a, 5); if (i < 40) { if (i < 20) t += ((b&(c^d))^d) + 0x5A827999; else t += ( b^c ^d) + 0x6ED9EBA1; } else { if (i < 60) t += (((b|c)&d)|(b&c)) + 0x8F1BBCDC; else t += ( b^c ^d) + 0xCA62C1D6; } e = d; d = c; c = rol(b, 30); b = a; a = t; } #else for (i = 0; i < 15; i += 5) { R0(a, b, c, d, e, 0 + i); R0(e, a, b, c, d, 1 + i); R0(d, e, a, b, c, 2 + i); R0(c, d, e, a, b, 3 + i); R0(b, c, d, e, a, 4 + i); } R0(a, b, c, d, e, 15); R1(e, a, b, c, d, 16); R1(d, e, a, b, c, 17); R1(c, d, e, a, b, 18); R1(b, c, d, e, a, 19); for (i = 20; i < 40; i += 5) { R2(a, b, c, d, e, 0 + i); R2(e, a, b, c, d, 1 + i); R2(d, e, a, b, c, 2 + i); R2(c, d, e, a, b, 3 + i); R2(b, c, d, e, a, 4 + i); } for (; i < 60; i += 5) { R3(a, b, c, d, e, 0 + i); R3(e, a, b, c, d, 1 + i); R3(d, e, a, b, c, 2 + i); R3(c, d, e, a, b, 3 + i); R3(b, c, d, e, a, 4 + i); } for (; i < 80; i += 5) { R4(a, b, c, d, e, 0 + i); R4(e, a, b, c, d, 1 + i); R4(d, e, a, b, c, 2 + i); R4(c, d, e, a, b, 3 + i); R4(b, c, d, e, a, 4 + i); } #endif state[0] += a; state[1] += b; state[2] += c; state[3] += d; state[4] += e; }
--------------------------------------------- Result 552 ---------------------------------------------
[[0 (97%)]] --> [[0 (47%)]] --> Socre: 0.5290342569351196

[[[[Adv]]]]: static int get_int64(QEMUFile *f, void *[[pv]], size_t size) { int64_t *[[v]] = [[pv]]; qemu_get_sbe64s(f, [[v]]); return 0; }

[[[[Adv]]]]: static int get_int64(QEMUFile *f, void *[[audi]], size_t size) { int64_t *[[across]] = [[audi]]; qemu_get_sbe64s(f, [[across]]); return 0; }
--------------------------------------------- Result 553 ---------------------------------------------
[[0 (19%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void acpi_build_update(void *build_opaque, uint32_t offset) { AcpiBuildState *build_state = build_opaque; AcpiBuildTables tables; if (!build_state || build_state->patched) { return; } build_state->patched = 1; acpi_build_tables_init(&tables); acpi_build(build_state->guest_info, &tables); assert(acpi_data_len(tables.table_data) == build_state->table_size); memcpy(build_state->table_ram, tables.table_data->data, build_state->table_size); acpi_build_tables_cleanup(&tables, "True" == "True"); }
--------------------------------------------- Result 554 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 318 / 32 / 204 / 554:  21%|        | 554/2690 [5:36:41<21:38:09, 36.46s/it][Succeeded / Failed / Skipped / Total] 318 / 32 / 204 / 554:  21%|        | 555/2690 [5:36:44<21:35:21, 36.40s/it][Succeeded / Failed / Skipped / Total] 319 / 32 / 204 / 555:  21%|        | 555/2690 [5:36:44<21:35:21, 36.40s/it][Succeeded / Failed / Skipped / Total] 319 / 32 / 204 / 555:  21%|        | 556/2690 [5:38:26<21:38:58, 36.52s/it][Succeeded / Failed / Skipped / Total] 320 / 32 / 204 / 556:  21%|        | 556/2690 [5:38:26<21:38:58, 36.52s/it][Succeeded / Failed / Skipped / Total] 320 / 32 / 204 / 556:  21%|        | 557/2690 [5:38:43<21:37:07, 36.49s/it][Succeeded / Failed / Skipped / Total] 321 / 32 / 204 / 557:  21%|        | 557/2690 [5:38:43<21:37:07, 36.49s/it][Succeeded / Failed / Skipped / Total] 321 / 32 / 204 / 557:  21%|        | 558/2690 [5:40:43<21:41:50, 36.64s/it][Succeeded / Failed / Skipped / Total] 322 / 32 / 204 / 558:  21%|        | 558/2690 [5:40:43<21:41:50, 36.64s/it][Succeeded / Failed / Skipped / Total] 322 / 32 / 204 / 558:  21%|        | 559/2690 [5:40:44<21:38:56, 36.57s/it][Succeeded / Failed / Skipped / Total] 322 / 32 / 205 / 559:  21%|        | 559/2690 [5:40:44<21:38:56, 36.57s/it][Succeeded / Failed / Skipped / Total] 322 / 32 / 205 / 559:  21%|        | 560/2690 [5:40:47<21:36:12, 36.51s/it][[0 (6%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int amr_nb_encode_init(AVCodecContext *avctx) { AMRContext *s = avctx->priv_data; if (avctx->sample_rate != 8000) { av_log(avctx, AV_LOG_ERROR, "Only 8000Hz sample rate supported\n"); return AVERROR(ENOSYS); } if (avctx->channels != 1) { av_log(avctx, AV_LOG_ERROR, "Only mono supported\n"); return AVERROR(ENOSYS); } avctx->frame_size = 160; avctx->coded_frame = avcodec_alloc_frame(); s->enc_state = Encoder_Interface_init(s->enc_dtx); if (!s->enc_state) { av_log(avctx, AV_LOG_ERROR, "Encoder_Interface_init error\n"); return -1; } s->enc_mode = get_bitrate_mode(avctx->bit_rate, avctx); s->enc_bitrate = avctx->bit_rate; return 0; }
--------------------------------------------- Result 555 ---------------------------------------------
[[0 (61%)]] --> [[0 (36%)]] --> Socre: 0.6365082263946533

[[[[Adv]]]]: static int get_num(ByteIOContext *pb, int *len) { int [[n]], n1; [[n]] = get_be16(pb); (*len)-=2; if ([[n]] >= 0x4000) { return [[n]] - 0x4000; } else { n1 = get_be16(pb); (*len)-=2; return ([[n]] << 16) | n1; } }

[[[[Adv]]]]: static int get_num(ByteIOContext *pb, int *len) { int [[no]], n1; [[no]] = get_be16(pb); (*len)-=2; if ([[no]] >= 0x4000) { return [[no]] - 0x4000; } else { n1 = get_be16(pb); (*len)-=2; return ([[no]] << 16) | n1; } }
--------------------------------------------- Result 556 ---------------------------------------------
[[0 (15%)]] --> [[0 (54%)]] --> Socre: 0.5398346185684204

[[[[Adv]]]]: CPUState *ppc440ep_init(MemoryRegion *[[address_space_mem]], ram_addr_t *[[ram_size]], PCIBus **pcip, const unsigned int [[pci_irq_nrs]][4], int do_init, const char *cpu_model) { MemoryRegion *ram_memories = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories)); target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS]; target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS]; CPUState *env; qemu_irq *pic; qemu_irq *irqs; qemu_irq *pci_irqs; if (cpu_model == NULL) { cpu_model = "440-Xilinx"; } env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to initialize CPU!\n"); exit(1); } ppc_booke_timers_init(env, 400000000, 0); ppc_dcr_init(env, NULL, NULL); irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB); irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT]; irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT]; pic = ppcuic_init(env, irqs, 0x0C0, 0, 1); memset(ram_bases, 0, sizeof(ram_bases)); memset(ram_sizes, 0, sizeof(ram_sizes)); *[[ram_size]] = ppc4xx_sdram_adjust(*[[ram_size]], PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, ppc440ep_sdram_bank_sizes); ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, do_init); pci_irqs = g_malloc(sizeof(qemu_irq) * 4); pci_irqs[0] = pic[[[pci_irq_nrs]][0]]; pci_irqs[1] = pic[[[pci_irq_nrs]][1]]; pci_irqs[2] = pic[[[pci_irq_nrs]][2]]; pci_irqs[3] = pic[[[pci_irq_nrs]][3]]; *pcip = ppc4xx_pci_init(env, pci_irqs, PPC440EP_PCI_CONFIG, PPC440EP_PCI_INTACK, PPC440EP_PCI_SPECIAL, PPC440EP_PCI_REGS); if (!*pcip) printf("couldn't create PCI controller!\n"); isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN); if (serial_hds[0] != NULL) { serial_mm_init([[address_space_mem]], 0xef600300, 0, pic[0], PPC_SERIAL_MM_BAUDBASE, serial_hds[0], DEVICE_BIG_ENDIAN); } if (serial_hds[1] != NULL) { serial_mm_init([[address_space_mem]], 0xef600400, 0, pic[1], PPC_SERIAL_MM_BAUDBASE, serial_hds[1], DEVICE_BIG_ENDIAN); } return env; }

[[[[Adv]]]]: CPUState *ppc440ep_init(MemoryRegion *[[fertilised]], ram_addr_t *[[bitterness]], PCIBus **pcip, const unsigned int [[beasties]][4], int do_init, const char *cpu_model) { MemoryRegion *ram_memories = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories)); target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS]; target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS]; CPUState *env; qemu_irq *pic; qemu_irq *irqs; qemu_irq *pci_irqs; if (cpu_model == NULL) { cpu_model = "440-Xilinx"; } env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to initialize CPU!\n"); exit(1); } ppc_booke_timers_init(env, 400000000, 0); ppc_dcr_init(env, NULL, NULL); irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB); irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT]; irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT]; pic = ppcuic_init(env, irqs, 0x0C0, 0, 1); memset(ram_bases, 0, sizeof(ram_bases)); memset(ram_sizes, 0, sizeof(ram_sizes)); *[[bitterness]] = ppc4xx_sdram_adjust(*[[bitterness]], PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, ppc440ep_sdram_bank_sizes); ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, do_init); pci_irqs = g_malloc(sizeof(qemu_irq) * 4); pci_irqs[0] = pic[[[beasties]][0]]; pci_irqs[1] = pic[[[beasties]][1]]; pci_irqs[2] = pic[[[beasties]][2]]; pci_irqs[3] = pic[[[beasties]][3]]; *pcip = ppc4xx_pci_init(env, pci_irqs, PPC440EP_PCI_CONFIG, PPC440EP_PCI_INTACK, PPC440EP_PCI_SPECIAL, PPC440EP_PCI_REGS); if (!*pcip) printf("couldn't create PCI controller!\n"); isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN); if (serial_hds[0] != NULL) { serial_mm_init([[fertilised]], 0xef600300, 0, pic[0], PPC_SERIAL_MM_BAUDBASE, serial_hds[0], DEVICE_BIG_ENDIAN); } if (serial_hds[1] != NULL) { serial_mm_init([[fertilised]], 0xef600400, 0, pic[1], PPC_SERIAL_MM_BAUDBASE, serial_hds[1], DEVICE_BIG_ENDIAN); } return env; }
--------------------------------------------- Result 557 ---------------------------------------------
[[0 (4%)]] --> [[0 (64%)]] --> Socre: 0.6350001692771912

[[[[Adv]]]]: static int piix4_initfn(PCIDevice *dev) { PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev); uint8_t *[[pci_conf]]; isa_bus_new(&d->dev.qdev); [[pci_conf]] = d->dev.config; pci_config_set_vendor_id([[pci_conf]], PCI_VENDOR_ID_INTEL); pci_config_set_device_id([[pci_conf]], PCI_DEVICE_ID_INTEL_82371AB_0); pci_config_set_class([[pci_conf]], PCI_CLASS_BRIDGE_ISA); piix4_dev = &d->dev; qemu_register_reset(piix4_reset, d); return 0; }

[[[[Adv]]]]: static int piix4_initfn(PCIDevice *dev) { PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev); uint8_t *[[subtitles]]; isa_bus_new(&d->dev.qdev); [[subtitles]] = d->dev.config; pci_config_set_vendor_id([[subtitles]], PCI_VENDOR_ID_INTEL); pci_config_set_device_id([[subtitles]], PCI_DEVICE_ID_INTEL_82371AB_0); pci_config_set_class([[subtitles]], PCI_CLASS_BRIDGE_ISA); piix4_dev = &d->dev; qemu_register_reset(piix4_reset, d); return 0; }
--------------------------------------------- Result 558 ---------------------------------------------
[[0 (87%)]] --> [[0 (34%)]] --> Socre: 0.6623342633247375

[[[[Adv]]]]: static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int [[stride]]) { int i; pixel *dst = (pixel *) _dst; dctcoef *src = (dctcoef *) _src; [[stride]] /= sizeof(pixel); for (i = 0; i < 8; i++) { dst[0] += src[0]; dst[1] += src[1]; dst[2] += src[2]; dst[3] += src[3]; dst[4] += src[4]; dst[5] += src[5]; dst[6] += src[6]; dst[7] += src[7]; dst += [[stride]]; src += 8; } memset(_src, 0, sizeof(dctcoef) * 64); }

[[[[Adv]]]]: static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int [[phased]]) { int i; pixel *dst = (pixel *) _dst; dctcoef *src = (dctcoef *) _src; [[phased]] /= sizeof(pixel); for (i = 0; i < 8; i++) { dst[0] += src[0]; dst[1] += src[1]; dst[2] += src[2]; dst[3] += src[3]; dst[4] += src[4]; dst[5] += src[5]; dst[6] += src[6]; dst[7] += src[7]; dst += [[phased]]; src += 8; } memset(_src, 0, sizeof(dctcoef) * 64); }
--------------------------------------------- Result 559 ---------------------------------------------
[[0 (9%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int output_frame(H264Context *h, AVFrame *dst, AVFrame *src) { int i; int ret = av_frame_ref(dst, src); if (ret < 0) return ret; if (!h->sps.crop) return 0; for (i = 0; i < 3; i++) { int hshift = (i > 0) ? h->chroma_x_shift : 0; int vshift = (i > 0) ? h->chroma_y_shift : 0; int off = ((h->sps.crop_left >> hshift) << h->pixel_shift) + (h->sps.crop_top >> vshift) * dst->linesize[i]; dst->data[i] += off; } return 0; }
[Succeeded / Failed / Skipped / Total] 323 / 32 / 205 / 560:  21%|        | 560/2690 [5:40:47<21:36:12, 36.51s/it][Succeeded / Failed / Skipped / Total] 323 / 32 / 205 / 560:  21%|        | 561/2690 [5:40:47<21:33:19, 36.45s/it][Succeeded / Failed / Skipped / Total] 323 / 32 / 206 / 561:  21%|        | 561/2690 [5:40:47<21:33:19, 36.45s/it][Succeeded / Failed / Skipped / Total] 323 / 32 / 206 / 561:  21%|        | 562/2690 [5:40:55<21:30:52, 36.40s/it][Succeeded / Failed / Skipped / Total] 324 / 32 / 206 / 562:  21%|        | 562/2690 [5:40:55<21:30:52, 36.40s/it][Succeeded / Failed / Skipped / Total] 324 / 32 / 206 / 562:  21%|        | 563/2690 [5:45:25<21:45:00, 36.81s/it][Succeeded / Failed / Skipped / Total] 325 / 32 / 206 / 563:  21%|        | 563/2690 [5:45:25<21:45:00, 36.81s/it][Succeeded / Failed / Skipped / Total] 325 / 32 / 206 / 563:  21%|        | 564/2690 [5:56:17<22:23:00, 37.90s/it]--------------------------------------------- Result 560 ---------------------------------------------
[[0 (58%)]] --> [[0 (41%)]] --> Socre: 0.5853019654750824

[[[[Adv]]]]: void throttle_account(ThrottleState *ts, bool is_write, uint64_t [[size]]) { double units = 1.0; if (ts->cfg.op_size && [[size]] > ts->cfg.op_size) { units = (double) [[size]] / ts->cfg.op_size; } ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += [[size]]; ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units; if (is_write) { ts->cfg.buckets[THROTTLE_BPS_WRITE].level += [[size]]; ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units; } else { ts->cfg.buckets[THROTTLE_BPS_READ].level += [[size]]; ts->cfg.buckets[THROTTLE_OPS_READ].level += units; } }

[[[[Adv]]]]: void throttle_account(ThrottleState *ts, bool is_write, uint64_t [[amplitude]]) { double units = 1.0; if (ts->cfg.op_size && [[amplitude]] > ts->cfg.op_size) { units = (double) [[amplitude]] / ts->cfg.op_size; } ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += [[amplitude]]; ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units; if (is_write) { ts->cfg.buckets[THROTTLE_BPS_WRITE].level += [[amplitude]]; ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units; } else { ts->cfg.buckets[THROTTLE_BPS_READ].level += [[amplitude]]; ts->cfg.buckets[THROTTLE_OPS_READ].level += units; } }
--------------------------------------------- Result 561 ---------------------------------------------
[[0 (20%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void bdrv_remove_aio_context_notifier(BlockDriverState *bs, void (*attached_aio_context)(AioContext *, void *), void (*detach_aio_context)(void *), void *opaque) { BdrvAioNotifier *ban, *ban_next; QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) { if (ban->attached_aio_context == attached_aio_context && ban->detach_aio_context == detach_aio_context && ban->opaque == opaque) { QLIST_REMOVE(ban, list); g_free(ban); return; } } abort(); }
--------------------------------------------- Result 562 ---------------------------------------------
[[0 (74%)]] --> [[0 (27%)]] --> Socre: 0.730062872171402

[[[[Adv]]]]: static void gen_addq_lo(DisasContext *s, TCGv_i64 [[val]], int rlow) { TCGv_i64 tmp; TCGv [[tmp2]]; tmp = tcg_temp_new_i64(); [[tmp2]] = load_reg(s, rlow); tcg_gen_extu_i32_i64(tmp, [[tmp2]]); dead_tmp([[tmp2]]); tcg_gen_add_i64([[val]], [[val]], tmp); tcg_temp_free_i64(tmp); }

[[[[Adv]]]]: static void gen_addq_lo(DisasContext *s, TCGv_i64 [[decided]], int rlow) { TCGv_i64 tmp; TCGv [[eustace]]; tmp = tcg_temp_new_i64(); [[eustace]] = load_reg(s, rlow); tcg_gen_extu_i32_i64(tmp, [[eustace]]); dead_tmp([[eustace]]); tcg_gen_add_i64([[decided]], [[decided]], tmp); tcg_temp_free_i64(tmp); }
--------------------------------------------- Result 563 ---------------------------------------------
[[0 (88%)]] --> [[0 (40%)]] --> Socre: 0.6047063171863556

[[[[Adv]]]]: static void test_bmdma_simple_rw(void) { QPCIDevice *[[dev]]; void *[[bmdma_base]], *ide_base; uint8_t status; uint8_t *buf; uint8_t *[[cmpbuf]]; size_t len = 512; uintptr_t [[guest_buf]] = guest_alloc(guest_malloc, len); PrdtEntry [[prdt]][] = { { .addr = cpu_to_le32([[guest_buf]]), .size = cpu_to_le32(len | PRDT_EOT), }, }; [[dev]] = get_pci_device(&[[bmdma_base]], &ide_base); buf = g_malloc(len); [[cmpbuf]] = g_malloc(len); memset(buf, 0x55, len); memwrite([[guest_buf]], buf, len); status = send_dma_request(CMD_WRITE_DMA, 0, 1, [[prdt]], ARRAY_SIZE([[prdt]]), NULL); g_assert_cmphex(status, ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[dev]], ide_base + reg_status), DF | ERR); memset(buf, 0xaa, len); memwrite([[guest_buf]], buf, len); status = send_dma_request(CMD_WRITE_DMA, 1, 1, [[prdt]], ARRAY_SIZE([[prdt]]), NULL); g_assert_cmphex(status, ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[dev]], ide_base + reg_status), DF | ERR); memset([[cmpbuf]], 0x55, len); status = send_dma_request(CMD_READ_DMA, 0, 1, [[prdt]], ARRAY_SIZE([[prdt]]), NULL); g_assert_cmphex(status, ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[dev]], ide_base + reg_status), DF | ERR); memread([[guest_buf]], buf, len); g_assert(memcmp(buf, [[cmpbuf]], len) == 0); memset([[cmpbuf]], 0xaa, len); status = send_dma_request(CMD_READ_DMA, 1, 1, [[prdt]], ARRAY_SIZE([[prdt]]), NULL); g_assert_cmphex(status, ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[dev]], ide_base + reg_status), DF | ERR); memread([[guest_buf]], buf, len); g_assert(memcmp(buf, [[cmpbuf]], len) == 0); g_free(buf); g_free([[cmpbuf]]); }

[[[[Adv]]]]: static void test_bmdma_simple_rw(void) { QPCIDevice *[[vijay]]; void *[[tye]], *ide_base; uint8_t status; uint8_t *buf; uint8_t *[[sald]]; size_t len = 512; uintptr_t [[dearly]] = guest_alloc(guest_malloc, len); PrdtEntry [[farmington]][] = { { .addr = cpu_to_le32([[dearly]]), .size = cpu_to_le32(len | PRDT_EOT), }, }; [[vijay]] = get_pci_device(&[[tye]], &ide_base); buf = g_malloc(len); [[sald]] = g_malloc(len); memset(buf, 0x55, len); memwrite([[dearly]], buf, len); status = send_dma_request(CMD_WRITE_DMA, 0, 1, [[farmington]], ARRAY_SIZE([[farmington]]), NULL); g_assert_cmphex(status, ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[vijay]], ide_base + reg_status), DF | ERR); memset(buf, 0xaa, len); memwrite([[dearly]], buf, len); status = send_dma_request(CMD_WRITE_DMA, 1, 1, [[farmington]], ARRAY_SIZE([[farmington]]), NULL); g_assert_cmphex(status, ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[vijay]], ide_base + reg_status), DF | ERR); memset([[sald]], 0x55, len); status = send_dma_request(CMD_READ_DMA, 0, 1, [[farmington]], ARRAY_SIZE([[farmington]]), NULL); g_assert_cmphex(status, ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[vijay]], ide_base + reg_status), DF | ERR); memread([[dearly]], buf, len); g_assert(memcmp(buf, [[sald]], len) == 0); memset([[sald]], 0xaa, len); status = send_dma_request(CMD_READ_DMA, 1, 1, [[farmington]], ARRAY_SIZE([[farmington]]), NULL); g_assert_cmphex(status, ==, BM_STS_INTR); assert_bit_clear(qpci_io_readb([[vijay]], ide_base + reg_status), DF | ERR); memread([[dearly]], buf, len); g_assert(memcmp(buf, [[sald]], len) == 0); g_free(buf); g_free([[sald]]); }
--------------------------------------------- Result 564 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 325 / 33 / 206 / 564:  21%|        | 564/2690 [5:56:17<22:23:00, 37.90s/it][Succeeded / Failed / Skipped / Total] 325 / 33 / 206 / 564:  21%|        | 565/2690 [5:56:26<22:20:34, 37.85s/it][Succeeded / Failed / Skipped / Total] 326 / 33 / 206 / 565:  21%|        | 565/2690 [5:56:26<22:20:34, 37.85s/it][Succeeded / Failed / Skipped / Total] 326 / 33 / 206 / 565:  21%|        | 566/2690 [5:56:26<22:17:36, 37.79s/it][Succeeded / Failed / Skipped / Total] 326 / 33 / 207 / 566:  21%|        | 566/2690 [5:56:26<22:17:36, 37.79s/it][Succeeded / Failed / Skipped / Total] 326 / 33 / 207 / 566:  21%|        | 567/2690 [5:56:27<22:14:39, 37.72s/it][[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void colo_process_checkpoint(MigrationState *s) { QIOChannelBuffer *bioc; QEMUFile *fb = NULL; int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST); Error *local_err = NULL; int ret; failover_init_state(); s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file); if (!s->rp_state.from_dst_file) { error_report("Open QEMUFile from_dst_file failed"); colo_receive_check_message(s->rp_state.from_dst_file, COLO_MESSAGE_CHECKPOINT_READY, &local_err); if (local_err) { bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE); fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc)); object_unref(OBJECT(bioc)); qemu_mutex_lock_iothread(); vm_start(); qemu_mutex_unlock_iothread(); trace_colo_vm_state_change("stop", "run"); while (s->state == MIGRATION_STATUS_COLO) { current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST); if (current_time - checkpoint_time < s->parameters.x_checkpoint_delay) { int64_t delay_ms; delay_ms = s->parameters.x_checkpoint_delay - (current_time - checkpoint_time); g_usleep(delay_ms * 1000); ret = colo_do_checkpoint_transaction(s, bioc, fb); if (ret < 0) { checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST); out: if (local_err) { error_report_err(local_err); if (fb) { qemu_fclose(fb); if (s->rp_state.from_dst_file) { qemu_fclose(s->rp_state.from_dst_file);

[[[[Adv]]]]: static void colo_process_checkpoint(MigrationState *s) { QIOChannelBuffer *bioc; QEMUFile *fb = NULL; int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST); Error *local_err = NULL; int ret; failover_init_state(); s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file); if (!s->rp_state.from_dst_file) { error_report("Open QEMUFile from_dst_file failed"); colo_receive_check_message(s->rp_state.from_dst_file, COLO_MESSAGE_CHECKPOINT_READY, &local_err); if (local_err) { bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE); fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc)); object_unref(OBJECT(bioc)); qemu_mutex_lock_iothread(); vm_start(); qemu_mutex_unlock_iothread(); trace_colo_vm_state_change("stop", "run"); while (s->state == MIGRATION_STATUS_COLO) { current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST); if (current_time - checkpoint_time < s->parameters.x_checkpoint_delay) { int64_t delay_ms; delay_ms = s->parameters.x_checkpoint_delay - (current_time - checkpoint_time); g_usleep(delay_ms * 1000); ret = colo_do_checkpoint_transaction(s, bioc, fb); if (ret < 0) { checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST); out: if (local_err) { error_report_err(local_err); if (fb) { qemu_fclose(fb); if (s->rp_state.from_dst_file) { qemu_fclose(s->rp_state.from_dst_file);
--------------------------------------------- Result 565 ---------------------------------------------
[[0 (64%)]] --> [[0 (48%)]] --> Socre: 0.523793488740921

[[[[Adv]]]]: static inline void RENAME(yuv2rgb555_2)(SwsContext *[[c]], const uint16_t *buf0, const uint16_t *buf1, const uint16_t *ubuf0, const uint16_t *ubuf1, const uint16_t *vbuf0, const uint16_t *vbuf1, const uint16_t *abuf0, const uint16_t *abuf1, uint8_t *dest, int dstW, int yalpha, int uvalpha, int y) { x86_reg uv_off = [[c]]->uv_off << 1; __asm__ volatile( "mov %%"REG_b", "ESP_OFFSET"(%5) \n\t" "mov %4, %%"REG_b" \n\t" "push %%"REG_BP" \n\t" YSCALEYUV2RGB(%%REGBP, %5, %6) "pxor %%mm7, %%mm7 \n\t" #ifdef DITHER1XBPP "paddusb "BLUE_DITHER"(%5), %%mm2 \n\t" "paddusb "GREEN_DITHER"(%5), %%mm4 \n\t" "paddusb "RED_DITHER"(%5), %%mm5 \n\t" #endif WRITERGB15(%%REGb, 8280(%5), %%REGBP) "pop %%"REG_BP" \n\t" "mov "ESP_OFFSET"(%5), %%"REG_b" \n\t" :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest), "a" (&[[c]]->redDither), "m"(uv_off) ); }

[[[[Adv]]]]: static inline void RENAME(yuv2rgb555_2)(SwsContext *[[jaime]], const uint16_t *buf0, const uint16_t *buf1, const uint16_t *ubuf0, const uint16_t *ubuf1, const uint16_t *vbuf0, const uint16_t *vbuf1, const uint16_t *abuf0, const uint16_t *abuf1, uint8_t *dest, int dstW, int yalpha, int uvalpha, int y) { x86_reg uv_off = [[jaime]]->uv_off << 1; __asm__ volatile( "mov %%"REG_b", "ESP_OFFSET"(%5) \n\t" "mov %4, %%"REG_b" \n\t" "push %%"REG_BP" \n\t" YSCALEYUV2RGB(%%REGBP, %5, %6) "pxor %%mm7, %%mm7 \n\t" #ifdef DITHER1XBPP "paddusb "BLUE_DITHER"(%5), %%mm2 \n\t" "paddusb "GREEN_DITHER"(%5), %%mm4 \n\t" "paddusb "RED_DITHER"(%5), %%mm5 \n\t" #endif WRITERGB15(%%REGb, 8280(%5), %%REGBP) "pop %%"REG_BP" \n\t" "mov "ESP_OFFSET"(%5), %%"REG_b" \n\t" :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest), "a" (&[[jaime]]->redDither), "m"(uv_off) ); }
--------------------------------------------- Result 566 ---------------------------------------------
[[0 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s) { VirtIOBlockReq *req = virtio_blk_alloc_request(s); if (!virtqueue_pop(s->vq, &req->elem)) { virtio_blk_free_request(req); return NULL; } return req; }
--------------------------------------------- Result 567 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 326 / 33 / 208 / 567:  21%|        | 567/2690 [5:56:27<22:14:39, 37.72s/it][Succeeded / Failed / Skipped / Total] 326 / 33 / 208 / 567:  21%|        | 568/2690 [5:56:27<22:11:42, 37.65s/it][Succeeded / Failed / Skipped / Total] 326 / 33 / 209 / 568:  21%|        | 568/2690 [5:56:27<22:11:42, 37.65s/it][Succeeded / Failed / Skipped / Total] 326 / 33 / 209 / 568:  21%|        | 569/2690 [5:56:33<22:09:08, 37.60s/it][Succeeded / Failed / Skipped / Total] 327 / 33 / 209 / 569:  21%|        | 569/2690 [5:56:33<22:09:08, 37.60s/it][Succeeded / Failed / Skipped / Total] 327 / 33 / 209 / 569:  21%|        | 570/2690 [5:58:49<22:14:34, 37.77s/it][Succeeded / Failed / Skipped / Total] 328 / 33 / 209 / 570:  21%|        | 570/2690 [5:58:49<22:14:34, 37.77s/it][Succeeded / Failed / Skipped / Total] 328 / 33 / 209 / 570:  21%|        | 571/2690 [5:58:50<22:11:38, 37.71s/it][[0 (57%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int output_packet(InputStream *ist, const AVPacket *pkt) { int ret = 0, i; int got_output; AVPacket avpkt; if (!ist->saw_first_ts) { ist->dts = ist->st->avg_frame_rate.num ? - ist->st->codec->has_b_frames * AV_TIME_BASE / av_q2d(ist->st->avg_frame_rate) : 0; ist->pts = 0; if (pkt != NULL && pkt->pts != AV_NOPTS_VALUE && !ist->decoding_needed) { ist->dts += av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q); ist->pts = ist->dts; } ist->saw_first_ts = 1; } if (ist->next_dts == AV_NOPTS_VALUE) ist->next_dts = ist->dts; if (ist->next_pts == AV_NOPTS_VALUE) ist->next_pts = ist->pts; if (pkt == NULL) { av_init_packet(&avpkt); avpkt.data = NULL; avpkt.size = 0; goto handle_eof; } else { avpkt = *pkt; } if (pkt->dts != AV_NOPTS_VALUE) { ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q); if (ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed) ist->next_pts = ist->pts = ist->dts; } while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) { int duration; handle_eof: ist->pts = ist->next_pts; ist->dts = ist->next_dts; if (avpkt.size && avpkt.size != pkt->size) { av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING, "Multiple frames in a packet from stream %d\n", pkt->stream_index); ist->showed_multi_packet_warning = 1; } switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: ret = decode_audio (ist, &avpkt, &got_output); break; case AVMEDIA_TYPE_VIDEO: ret = decode_video (ist, &avpkt, &got_output); if (avpkt.duration) { duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q); } else if(ist->st->codec->time_base.num != 0 && ist->st->codec->time_base.den != 0) { int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame; duration = ((int64_t)AV_TIME_BASE * ist->st->codec->time_base.num * ticks) / ist->st->codec->time_base.den; } else duration = 0; if(ist->dts != AV_NOPTS_VALUE && duration) { ist->next_dts += duration; }else ist->next_dts = AV_NOPTS_VALUE; if (got_output) ist->next_pts += duration; break; case AVMEDIA_TYPE_SUBTITLE: ret = transcode_subtitles(ist, &avpkt, &got_output); break; default: return -1; } if (ret < 0) return ret; avpkt.dts= avpkt.pts= AV_NOPTS_VALUE; if (pkt) { if(ist->st->codec->codec_type != AVMEDIA_TYPE_AUDIO) ret = avpkt.size; avpkt.data += ret; avpkt.size -= ret; } if (!got_output) { continue; } } if (!ist->decoding_needed) { rate_emu_sleep(ist); ist->dts = ist->next_dts; switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) / ist->st->codec->sample_rate; break; case AVMEDIA_TYPE_VIDEO: if (pkt->duration) { ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q); } else if(ist->st->codec->time_base.num != 0) { int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame; ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->time_base.num * ticks) / ist->st->codec->time_base.den; } break; } ist->pts = ist->dts; ist->next_pts = ist->next_dts; } for (i = 0; pkt && i < nb_output_streams; i++) { OutputStream *ost = output_streams[i]; if (!check_output_constraints(ist, ost) || ost->encoding_needed) continue; do_streamcopy(ist, ost, pkt); } return 0; }
--------------------------------------------- Result 568 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qemu_system_reset(void) { QEMUResetEntry *re, *nre; QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) { re->func(re->opaque); } }
--------------------------------------------- Result 569 ---------------------------------------------
[[0 (45%)]] --> [[0 (75%)]] --> Socre: 0.7463303208351135

[[[[Adv]]]]: static void sd_reset(SDState *sd, BlockDriverState *bdrv) { uint64_t size; uint64_t [[sect]]; if (bdrv) { bdrv_get_geometry(bdrv, &[[sect]]); } else { [[sect]] = 0; } size = [[sect]] << 9; [[sect]] = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1; sd->state = sd_idle_state; sd->rca = 0x0000; sd_set_ocr(sd); sd_set_scr(sd); sd_set_cid(sd); sd_set_csd(sd, size); sd_set_cardstatus(sd); sd_set_sdstatus(sd); sd->bdrv = bdrv; if (sd->wp_groups) g_free(sd->wp_groups); sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0; sd->wp_groups = (int *) g_malloc0(sizeof(int) * [[sect]]); memset(sd->function_group, 0, sizeof(int) * 6); sd->erase_start = 0; sd->erase_end = 0; sd->size = size; sd->blk_len = 0x200; sd->pwd_len = 0; sd->expecting_acmd = 0; }

[[[[Adv]]]]: static void sd_reset(SDState *sd, BlockDriverState *bdrv) { uint64_t size; uint64_t [[chap]]; if (bdrv) { bdrv_get_geometry(bdrv, &[[chap]]); } else { [[chap]] = 0; } size = [[chap]] << 9; [[chap]] = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1; sd->state = sd_idle_state; sd->rca = 0x0000; sd_set_ocr(sd); sd_set_scr(sd); sd_set_cid(sd); sd_set_csd(sd, size); sd_set_cardstatus(sd); sd_set_sdstatus(sd); sd->bdrv = bdrv; if (sd->wp_groups) g_free(sd->wp_groups); sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0; sd->wp_groups = (int *) g_malloc0(sizeof(int) * [[chap]]); memset(sd->function_group, 0, sizeof(int) * 6); sd->erase_start = 0; sd->erase_end = 0; sd->size = size; sd->blk_len = 0x200; sd->pwd_len = 0; sd->expecting_acmd = 0; }
--------------------------------------------- Result 570 ---------------------------------------------
[[0 (3%)]] --> [[0 (55%)]] --> Socre: 0.5497472286224365

[[[[Adv]]]]: static void phys_page_set(AddressSpaceDispatch *d, target_phys_addr_t index, target_phys_addr_t [[nb]], uint16_t leaf) { phys_map_node_reserve(3 * P_L2_LEVELS); phys_page_set_level(&d->phys_map, &index, &[[nb]], leaf, P_L2_LEVELS - 1); }

[[[[Adv]]]]: static void phys_page_set(AddressSpaceDispatch *d, target_phys_addr_t index, target_phys_addr_t [[ol]], uint16_t leaf) { phys_map_node_reserve(3 * P_L2_LEVELS); phys_page_set_level(&d->phys_map, &index, &[[ol]], leaf, P_L2_LEVELS - 1); }
--------------------------------------------- Result 571 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 328 / 33 / 210 / 571:  21%|        | 571/2690 [5:58:50<22:11:38, 37.71s/it][Succeeded / Failed / Skipped / Total] 328 / 33 / 210 / 571:  21%|       | 572/2690 [5:58:50<22:08:43, 37.64s/it][Succeeded / Failed / Skipped / Total] 328 / 33 / 211 / 572:  21%|       | 572/2690 [5:58:50<22:08:43, 37.64s/it][Succeeded / Failed / Skipped / Total] 328 / 33 / 211 / 572:  21%|       | 573/2690 [5:59:00<22:06:24, 37.59s/it][[0 (70%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *const_args) { int c; switch (opc) { case INDEX_op_exit_tb: if (check_fit_tl(args[0], 13)) { tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN); tcg_out_movi_imm13(s, TCG_REG_O0, args[0]); } else { tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_I0, args[0] & ~0x3ff); tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN); tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0, args[0] & 0x3ff, ARITH_OR); } break; case INDEX_op_goto_tb: if (s->tb_jmp_offset) { uint32_t old_insn = *(uint32_t *)s->code_ptr; s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf; tcg_out32(s, CALL | (old_insn & ~INSN_OP(-1))); } else { tcg_out_ld_ptr(s, TCG_REG_T1, (uintptr_t)(s->tb_next + args[0])); tcg_out_arithi(s, TCG_REG_G0, TCG_REG_T1, 0, JMPL); } tcg_out_nop(s); s->tb_next_offset[args[0]] = s->code_ptr - s->code_buf; break; case INDEX_op_call: if (const_args[0]) { tcg_out_calli(s, args[0]); } else { tcg_out_arithi(s, TCG_REG_O7, args[0], 0, JMPL); } tcg_out_nop(s); break; case INDEX_op_br: tcg_out_bpcc(s, COND_A, BPCC_PT, args[0]); tcg_out_nop(s); break; case INDEX_op_movi_i32: tcg_out_movi(s, TCG_TYPE_I32, args[0], (uint32_t)args[1]); break; #define OP_32_64(x) \ glue(glue(case INDEX_op_, x), _i32): \ glue(glue(case INDEX_op_, x), _i64) OP_32_64(ld8u): tcg_out_ldst(s, args[0], args[1], args[2], LDUB); break; OP_32_64(ld8s): tcg_out_ldst(s, args[0], args[1], args[2], LDSB); break; OP_32_64(ld16u): tcg_out_ldst(s, args[0], args[1], args[2], LDUH); break; OP_32_64(ld16s): tcg_out_ldst(s, args[0], args[1], args[2], LDSH); break; case INDEX_op_ld_i32: case INDEX_op_ld32u_i64: tcg_out_ldst(s, args[0], args[1], args[2], LDUW); break; OP_32_64(st8): tcg_out_ldst(s, args[0], args[1], args[2], STB); break; OP_32_64(st16): tcg_out_ldst(s, args[0], args[1], args[2], STH); break; case INDEX_op_st_i32: case INDEX_op_st32_i64: tcg_out_ldst(s, args[0], args[1], args[2], STW); break; OP_32_64(add): c = ARITH_ADD; goto gen_arith; OP_32_64(sub): c = ARITH_SUB; goto gen_arith; OP_32_64(and): c = ARITH_AND; goto gen_arith; OP_32_64(andc): c = ARITH_ANDN; goto gen_arith; OP_32_64(or): c = ARITH_OR; goto gen_arith; OP_32_64(orc): c = ARITH_ORN; goto gen_arith; OP_32_64(xor): c = ARITH_XOR; goto gen_arith; case INDEX_op_shl_i32: c = SHIFT_SLL; do_shift32: tcg_out_arithc(s, args[0], args[1], args[2] & 31, const_args[2], c); break; case INDEX_op_shr_i32: c = SHIFT_SRL; goto do_shift32; case INDEX_op_sar_i32: c = SHIFT_SRA; goto do_shift32; case INDEX_op_mul_i32: c = ARITH_UMUL; goto gen_arith; OP_32_64(neg): c = ARITH_SUB; goto gen_arith1; OP_32_64(not): c = ARITH_ORN; goto gen_arith1; case INDEX_op_div_i32: tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 0); break; case INDEX_op_divu_i32: tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 1); break; case INDEX_op_brcond_i32: tcg_out_brcond_i32(s, args[2], args[0], args[1], const_args[1], args[3]); break; case INDEX_op_setcond_i32: tcg_out_setcond_i32(s, args[3], args[0], args[1], args[2], const_args[2]); break; case INDEX_op_movcond_i32: tcg_out_movcond_i32(s, args[5], args[0], args[1], args[2], const_args[2], args[3], const_args[3]); break; case INDEX_op_add2_i32: tcg_out_addsub2(s, args[0], args[1], args[2], args[3], args[4], const_args[4], args[5], const_args[5], ARITH_ADDCC, ARITH_ADDX); break; case INDEX_op_sub2_i32: tcg_out_addsub2(s, args[0], args[1], args[2], args[3], args[4], const_args[4], args[5], const_args[5], ARITH_SUBCC, ARITH_SUBX); break; case INDEX_op_mulu2_i32: c = ARITH_UMUL; goto do_mul2; case INDEX_op_muls2_i32: c = ARITH_SMUL; do_mul2: tcg_out_arithc(s, args[0], args[2], args[3], const_args[3], c); if (SPARC64 || args[0] <= TCG_REG_O7) { tcg_out_arithi(s, args[1], args[0], 32, SHIFT_SRLX); } else { tcg_out_rdy(s, args[1]); } break; case INDEX_op_qemu_ld_i32: tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], "False" != "False"); break; case INDEX_op_qemu_ld_i64: tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], "True" == "True"); break; case INDEX_op_qemu_st_i32: tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]); break; case INDEX_op_qemu_st_i64: tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]); break; case INDEX_op_movi_i64: tcg_out_movi(s, TCG_TYPE_I64, args[0], args[1]); break; case INDEX_op_ld32s_i64: tcg_out_ldst(s, args[0], args[1], args[2], LDSW); break; case INDEX_op_ld_i64: tcg_out_ldst(s, args[0], args[1], args[2], LDX); break; case INDEX_op_st_i64: tcg_out_ldst(s, args[0], args[1], args[2], STX); break; case INDEX_op_shl_i64: c = SHIFT_SLLX; do_shift64: tcg_out_arithc(s, args[0], args[1], args[2] & 63, const_args[2], c); break; case INDEX_op_shr_i64: c = SHIFT_SRLX; goto do_shift64; case INDEX_op_sar_i64: c = SHIFT_SRAX; goto do_shift64; case INDEX_op_mul_i64: c = ARITH_MULX; goto gen_arith; case INDEX_op_div_i64: c = ARITH_SDIVX; goto gen_arith; case INDEX_op_divu_i64: c = ARITH_UDIVX; goto gen_arith; case INDEX_op_ext32s_i64: tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRA); break; case INDEX_op_ext32u_i64: tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRL); break; case INDEX_op_trunc_shr_i32: if (args[2] == 0) { tcg_out_mov(s, TCG_TYPE_I32, args[0], args[1]); } else { tcg_out_arithi(s, args[0], args[1], args[2], SHIFT_SRLX); } break; case INDEX_op_brcond_i64: tcg_out_brcond_i64(s, args[2], args[0], args[1], const_args[1], args[3]); break; case INDEX_op_setcond_i64: tcg_out_setcond_i64(s, args[3], args[0], args[1], args[2], const_args[2]); break; case INDEX_op_movcond_i64: tcg_out_movcond_i64(s, args[5], args[0], args[1], args[2], const_args[2], args[3], const_args[3]); break; gen_arith: tcg_out_arithc(s, args[0], args[1], args[2], const_args[2], c); break; gen_arith1: tcg_out_arithc(s, args[0], TCG_REG_G0, args[1], const_args[1], c); break; default: fprintf(stderr, "unknown opcode 0x%x\n", opc); tcg_abort(); } }
--------------------------------------------- Result 572 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int eightsvx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame_ptr, AVPacket *avpkt) { EightSvxContext *esc = avctx->priv_data; int n, out_data_size; int ch, ret; uint8_t *src; if (!esc->samples && avpkt) { int packet_size = avpkt->size; if (packet_size % avctx->channels) { av_log(avctx, AV_LOG_WARNING, "Packet with odd size, ignoring last byte\n"); if (packet_size < avctx->channels) return packet_size; packet_size -= packet_size % avctx->channels; } esc->samples_size = !esc->table ? packet_size : avctx->channels + (packet_size-avctx->channels) * 2; if (!(esc->samples = av_malloc(esc->samples_size))) return AVERROR(ENOMEM); if (esc->table) { const uint8_t *buf = avpkt->data; uint8_t *dst; int buf_size = avpkt->size; int i, n = esc->samples_size; if (buf_size < 2) { av_log(avctx, AV_LOG_ERROR, "packet size is too small\n"); return AVERROR(EINVAL); } dst = esc->samples; for (i = 0; i < avctx->channels; i++) { *(dst++) = buf[0]+128; delta_decode(dst, buf + 1, buf_size / avctx->channels - 1, (buf[0]+128)&0xFF, esc->table); buf += buf_size / avctx->channels; dst += n / avctx->channels - 1; } } else { raw_decode(esc->samples, avpkt->data, esc->samples_size); } } av_assert1(!(esc->samples_size % avctx->channels || esc->samples_idx % avctx->channels)); esc->frame.nb_samples = FFMIN(MAX_FRAME_SIZE, esc->samples_size - esc->samples_idx) / avctx->channels; if ((ret = avctx->get_buffer(avctx, &esc->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } *got_frame_ptr = 1; *(AVFrame *)data = esc->frame; out_data_size = esc->frame.nb_samples; for (ch = 0; ch<avctx->channels; ch++) { src = esc->samples + esc->samples_idx / avctx->channels + ch * esc->samples_size / avctx->channels; memcpy(esc->frame.data[ch], src, out_data_size); } out_data_size *= avctx->channels; esc->samples_idx += out_data_size; return esc->table ? (avctx->frame_number == 0)*2 + out_data_size / 2 : out_data_size; }
--------------------------------------------- Result 573 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 329 / 33 / 211 / 573:  21%|       | 573/2690 [5:59:00<22:06:24, 37.59s/it][Succeeded / Failed / Skipped / Total] 329 / 33 / 211 / 573:  21%|       | 574/2690 [6:11:02<22:47:49, 38.79s/it][Succeeded / Failed / Skipped / Total] 329 / 34 / 211 / 574:  21%|       | 574/2690 [6:11:02<22:47:49, 38.79s/it][Succeeded / Failed / Skipped / Total] 329 / 34 / 211 / 574:  21%|       | 575/2690 [6:11:03<22:44:49, 38.72s/it][Succeeded / Failed / Skipped / Total] 329 / 34 / 212 / 575:  21%|       | 575/2690 [6:11:03<22:44:49, 38.72s/it][Succeeded / Failed / Skipped / Total] 329 / 34 / 212 / 575:  21%|       | 576/2690 [6:11:03<22:41:50, 38.65s/it][[0 (48%)]] --> [[0 (56%)]] --> Socre: 0.5631594657897949

[[[[Adv]]]]: static int virtio_serial_load(QEMUFile *f, void *opaque, int [[version_id]]) { VirtIOSerial *s = opaque; VirtIOSerialPort *port; uint32_t [[max_nr_ports]], nr_active_ports, ports_map; unsigned int i; int ret; if ([[version_id]] > 3) { return -EINVAL; } ret = virtio_load(&s->vdev, f); if (ret) { return ret; } if ([[version_id]] < 2) { return 0; } qemu_get_be16s(f, &s->config.cols); qemu_get_be16s(f, &s->config.rows); qemu_get_be32s(f, &[[max_nr_ports]]); tswap32s(&[[max_nr_ports]]); if ([[max_nr_ports]] > tswap32(s->config.max_nr_ports)) { return -EINVAL; } for (i = 0; i < ([[max_nr_ports]] + 31) / 32; i++) { qemu_get_be32s(f, &ports_map); if (ports_map != s->ports_map[i]) { return -EINVAL; } } qemu_get_be32s(f, &nr_active_ports); for (i = 0; i < nr_active_ports; i++) { uint32_t id; bool host_connected; id = qemu_get_be32(f); port = find_port_by_id(s, id); if (!port) { return -EINVAL; } port->guest_connected = qemu_get_byte(f); host_connected = qemu_get_byte(f); if (host_connected != port->host_connected) { send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN, port->host_connected); } if ([[version_id]] > 2) { uint32_t elem_popped; qemu_get_be32s(f, &elem_popped); if (elem_popped) { qemu_get_be32s(f, &port->iov_idx); qemu_get_be64s(f, &port->iov_offset); qemu_get_buffer(f, (unsigned char *)&port->elem, sizeof(port->elem)); virtqueue_map_sg(port->elem.in_sg, port->elem.in_addr, port->elem.in_num, 1); virtqueue_map_sg(port->elem.out_sg, port->elem.out_addr, port->elem.out_num, 1); virtio_serial_throttle_port(port, "False" != "False"); } } } return 0; }

[[[[Adv]]]]: static int virtio_serial_load(QEMUFile *f, void *opaque, int [[cassidy]]) { VirtIOSerial *s = opaque; VirtIOSerialPort *port; uint32_t [[fing]], nr_active_ports, ports_map; unsigned int i; int ret; if ([[cassidy]] > 3) { return -EINVAL; } ret = virtio_load(&s->vdev, f); if (ret) { return ret; } if ([[cassidy]] < 2) { return 0; } qemu_get_be16s(f, &s->config.cols); qemu_get_be16s(f, &s->config.rows); qemu_get_be32s(f, &[[fing]]); tswap32s(&[[fing]]); if ([[fing]] > tswap32(s->config.max_nr_ports)) { return -EINVAL; } for (i = 0; i < ([[fing]] + 31) / 32; i++) { qemu_get_be32s(f, &ports_map); if (ports_map != s->ports_map[i]) { return -EINVAL; } } qemu_get_be32s(f, &nr_active_ports); for (i = 0; i < nr_active_ports; i++) { uint32_t id; bool host_connected; id = qemu_get_be32(f); port = find_port_by_id(s, id); if (!port) { return -EINVAL; } port->guest_connected = qemu_get_byte(f); host_connected = qemu_get_byte(f); if (host_connected != port->host_connected) { send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN, port->host_connected); } if ([[cassidy]] > 2) { uint32_t elem_popped; qemu_get_be32s(f, &elem_popped); if (elem_popped) { qemu_get_be32s(f, &port->iov_idx); qemu_get_be64s(f, &port->iov_offset); qemu_get_buffer(f, (unsigned char *)&port->elem, sizeof(port->elem)); virtqueue_map_sg(port->elem.in_sg, port->elem.in_addr, port->elem.in_num, 1); virtqueue_map_sg(port->elem.out_sg, port->elem.out_addr, port->elem.out_num, 1); virtio_serial_throttle_port(port, "False" != "False"); } } } return 0; }
--------------------------------------------- Result 574 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int av_read_packet(AVFormatContext *s, AVPacket *pkt) { int ret, i; AVStream *st; for(;;){ AVPacketList *pktl = s->raw_packet_buffer; if (pktl) { *pkt = pktl->pkt; if(s->streams[pkt->stream_index]->codec->codec_id != CODEC_ID_PROBE || !s->streams[pkt->stream_index]->probe_packets || s->raw_packet_buffer_remaining_size < pkt->size){ AVProbeData *pd = &s->streams[pkt->stream_index]->probe_data; av_freep(&pd->buf); pd->buf_size = 0; s->raw_packet_buffer = pktl->next; s->raw_packet_buffer_remaining_size += pkt->size; av_free(pktl); return 0; av_init_packet(pkt); ret= s->iformat->read_packet(s, pkt); if (ret < 0) { if (!pktl || ret == AVERROR(EAGAIN)) return ret; for (i = 0; i < s->nb_streams; i++) s->streams[i]->probe_packets = 0; st= s->streams[pkt->stream_index]; switch(st->codec->codec_type){ case AVMEDIA_TYPE_VIDEO: if(s->video_codec_id) st->codec->codec_id= s->video_codec_id; break; case AVMEDIA_TYPE_AUDIO: if(s->audio_codec_id) st->codec->codec_id= s->audio_codec_id; break; case AVMEDIA_TYPE_SUBTITLE: if(s->subtitle_codec_id)st->codec->codec_id= s->subtitle_codec_id; break; if(!pktl && (st->codec->codec_id != CODEC_ID_PROBE || !st->probe_packets)) return ret; add_to_pktbuf(&s->raw_packet_buffer, pkt, &s->raw_packet_buffer_end); s->raw_packet_buffer_remaining_size -= pkt->size; if(st->codec->codec_id == CODEC_ID_PROBE){ AVProbeData *pd = &st->probe_data; av_log(s, AV_LOG_DEBUG, "probing stream %d\n", st->index); --st->probe_packets; pd->buf = av_realloc(pd->buf, pd->buf_size+pkt->size+AVPROBE_PADDING_SIZE); memcpy(pd->buf+pd->buf_size, pkt->data, pkt->size); pd->buf_size += pkt->size; memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE); if(av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)){ set_codec_from_probe_data(s, st, pd, st->probe_packets > 0 ? AVPROBE_SCORE_MAX/4 : 0); if(st->codec->codec_id != CODEC_ID_PROBE){ pd->buf_size=0; av_freep(&pd->buf); av_log(s, AV_LOG_DEBUG, "probed stream %d\n", st->index);

[[[[Adv]]]]: int av_read_packet(AVFormatContext *s, AVPacket *pkt) { int ret, i; AVStream *st; for(;;){ AVPacketList *pktl = s->raw_packet_buffer; if (pktl) { *pkt = pktl->pkt; if(s->streams[pkt->stream_index]->codec->codec_id != CODEC_ID_PROBE || !s->streams[pkt->stream_index]->probe_packets || s->raw_packet_buffer_remaining_size < pkt->size){ AVProbeData *pd = &s->streams[pkt->stream_index]->probe_data; av_freep(&pd->buf); pd->buf_size = 0; s->raw_packet_buffer = pktl->next; s->raw_packet_buffer_remaining_size += pkt->size; av_free(pktl); return 0; av_init_packet(pkt); ret= s->iformat->read_packet(s, pkt); if (ret < 0) { if (!pktl || ret == AVERROR(EAGAIN)) return ret; for (i = 0; i < s->nb_streams; i++) s->streams[i]->probe_packets = 0; st= s->streams[pkt->stream_index]; switch(st->codec->codec_type){ case AVMEDIA_TYPE_VIDEO: if(s->video_codec_id) st->codec->codec_id= s->video_codec_id; break; case AVMEDIA_TYPE_AUDIO: if(s->audio_codec_id) st->codec->codec_id= s->audio_codec_id; break; case AVMEDIA_TYPE_SUBTITLE: if(s->subtitle_codec_id)st->codec->codec_id= s->subtitle_codec_id; break; if(!pktl && (st->codec->codec_id != CODEC_ID_PROBE || !st->probe_packets)) return ret; add_to_pktbuf(&s->raw_packet_buffer, pkt, &s->raw_packet_buffer_end); s->raw_packet_buffer_remaining_size -= pkt->size; if(st->codec->codec_id == CODEC_ID_PROBE){ AVProbeData *pd = &st->probe_data; av_log(s, AV_LOG_DEBUG, "probing stream %d\n", st->index); --st->probe_packets; pd->buf = av_realloc(pd->buf, pd->buf_size+pkt->size+AVPROBE_PADDING_SIZE); memcpy(pd->buf+pd->buf_size, pkt->data, pkt->size); pd->buf_size += pkt->size; memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE); if(av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)){ set_codec_from_probe_data(s, st, pd, st->probe_packets > 0 ? AVPROBE_SCORE_MAX/4 : 0); if(st->codec->codec_id != CODEC_ID_PROBE){ pd->buf_size=0; av_freep(&pd->buf); av_log(s, AV_LOG_DEBUG, "probed stream %d\n", st->index);
--------------------------------------------- Result 575 ---------------------------------------------
[[0 (89%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint) { #if defined(TARGET_HAS_ICE) QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry); breakpoint_invalidate(cpu, breakpoint->pc); g_free(breakpoint); #endif }
--------------------------------------------- Result 576 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 329 / 34 / 213 / 576:  21%|       | 576/2690 [6:11:03<22:41:50, 38.65s/it][Succeeded / Failed / Skipped / Total] 329 / 34 / 213 / 576:  21%|       | 577/2690 [6:11:19<22:39:48, 38.61s/it][Succeeded / Failed / Skipped / Total] 330 / 34 / 213 / 577:  21%|       | 577/2690 [6:11:19<22:39:48, 38.61s/it][Succeeded / Failed / Skipped / Total] 330 / 34 / 213 / 577:  21%|       | 578/2690 [6:11:23<22:37:01, 38.55s/it][Succeeded / Failed / Skipped / Total] 331 / 34 / 213 / 578:  21%|       | 578/2690 [6:11:23<22:37:01, 38.55s/it][Succeeded / Failed / Skipped / Total] 331 / 34 / 213 / 578:  22%|       | 579/2690 [6:11:23<22:34:04, 38.49s/it][Succeeded / Failed / Skipped / Total] 331 / 34 / 214 / 579:  22%|       | 579/2690 [6:11:23<22:34:04, 38.49s/it][Succeeded / Failed / Skipped / Total] 331 / 34 / 214 / 579:  22%|       | 580/2690 [6:11:27<22:31:21, 38.43s/it][[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int flv_write_trailer(AVFormatContext *s) { int64_t file_size; AVIOContext *pb = s->pb; FLVContext *flv = s->priv_data; int i; for (i = 0; i < s->nb_streams; i++) { AVCodecContext *enc = s->streams[i]->codec; FLVStreamContext *sc = s->streams[i]->priv_data; if (enc->codec_type == AVMEDIA_TYPE_VIDEO && enc->codec_id == AV_CODEC_ID_H264) put_avc_eos_tag(pb, sc->last_ts); } file_size = avio_tell(pb); avio_seek(pb, flv->duration_offset, SEEK_SET); put_amf_double(pb, flv->duration / (double)1000); avio_seek(pb, flv->filesize_offset, SEEK_SET); put_amf_double(pb, file_size); avio_seek(pb, file_size, SEEK_SET); return 0; }
--------------------------------------------- Result 577 ---------------------------------------------
[[0 (63%)]] --> [[0 (50%)]] --> Socre: 0.5013367533683777

[[[[Adv]]]]: static const void *boston_fdt_filter(void *opaque, const void *fdt_orig, const void *match_data, hwaddr *load_addr) { BostonState *[[s]] = BOSTON(opaque); MachineState *machine = [[s]]->mach; const char *cmdline; int err; void *[[fdt]]; size_t fdt_sz, ram_low_sz, ram_high_sz; fdt_sz = fdt_totalsize(fdt_orig) * 2; [[fdt]] = g_malloc0(fdt_sz); err = fdt_open_into(fdt_orig, [[fdt]], fdt_sz); if (err) { fprintf(stderr, "unable to open FDT\n"); return NULL; } cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0]) ? machine->kernel_cmdline : " "; err = qemu_fdt_setprop_string([[fdt]], "/chosen", "bootargs", cmdline); if (err < 0) { fprintf(stderr, "couldn't set /chosen/bootargs\n"); return NULL; } ram_low_sz = MIN(256 * M_BYTE, machine->ram_size); ram_high_sz = machine->ram_size - ram_low_sz; qemu_fdt_setprop_sized_cells([[fdt]], "/memory@0", "reg", 1, 0x00000000, 1, ram_low_sz, 1, 0x90000000, 1, ram_high_sz); [[fdt]] = g_realloc([[fdt]], fdt_totalsize([[fdt]])); qemu_fdt_dumpdtb([[fdt]], fdt_sz); [[s]]->fdt_base = *load_addr; return [[fdt]]; }

[[[[Adv]]]]: static const void *boston_fdt_filter(void *opaque, const void *fdt_orig, const void *match_data, hwaddr *load_addr) { BostonState *[[dans]] = BOSTON(opaque); MachineState *machine = [[dans]]->mach; const char *cmdline; int err; void *[[parkes]]; size_t fdt_sz, ram_low_sz, ram_high_sz; fdt_sz = fdt_totalsize(fdt_orig) * 2; [[parkes]] = g_malloc0(fdt_sz); err = fdt_open_into(fdt_orig, [[parkes]], fdt_sz); if (err) { fprintf(stderr, "unable to open FDT\n"); return NULL; } cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0]) ? machine->kernel_cmdline : " "; err = qemu_fdt_setprop_string([[parkes]], "/chosen", "bootargs", cmdline); if (err < 0) { fprintf(stderr, "couldn't set /chosen/bootargs\n"); return NULL; } ram_low_sz = MIN(256 * M_BYTE, machine->ram_size); ram_high_sz = machine->ram_size - ram_low_sz; qemu_fdt_setprop_sized_cells([[parkes]], "/memory@0", "reg", 1, 0x00000000, 1, ram_low_sz, 1, 0x90000000, 1, ram_high_sz); [[parkes]] = g_realloc([[parkes]], fdt_totalsize([[parkes]])); qemu_fdt_dumpdtb([[parkes]], fdt_sz); [[dans]]->fdt_base = *load_addr; return [[parkes]]; }
--------------------------------------------- Result 578 ---------------------------------------------
[[0 (54%)]] --> [[0 (49%)]] --> Socre: 0.5140722393989563

[[[[Adv]]]]: static int mov_read_cmov(MOVContext *c, AVIOContext *[[pb]], MOVAtom atom) { #if CONFIG_ZLIB AVIOContext ctx; uint8_t *cmov_data; uint8_t *moov_data; long cmov_len, moov_len; int ret = -1; avio_rb32([[pb]]); if (avio_rl32([[pb]]) != MKTAG('d','c','o','m')) return AVERROR_INVALIDDATA; if (avio_rl32([[pb]]) != MKTAG('z','l','i','b')) { av_log(c->fc, AV_LOG_ERROR, "unknown compression for cmov atom !"); return AVERROR_INVALIDDATA; } avio_rb32([[pb]]); if (avio_rl32([[pb]]) != MKTAG('c','m','v','d')) return AVERROR_INVALIDDATA; moov_len = avio_rb32([[pb]]); cmov_len = atom.size - 6 * 4; cmov_data = av_malloc(cmov_len); if (!cmov_data) return AVERROR(ENOMEM); moov_data = av_malloc(moov_len); if (!moov_data) { av_free(cmov_data); return AVERROR(ENOMEM); } avio_read([[pb]], cmov_data, cmov_len); if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK) goto free_and_return; if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0) goto free_and_return; atom.type = MKTAG('m','o','o','v'); atom.size = moov_len; ret = mov_read_default(c, &ctx, atom); free_and_return: av_free(moov_data); av_free(cmov_data); return ret; #else av_log(c->fc, AV_LOG_ERROR, "this file requires zlib support compiled in\n"); return AVERROR(ENOSYS); #endif }

[[[[Adv]]]]: static int mov_read_cmov(MOVContext *c, AVIOContext *[[sm]], MOVAtom atom) { #if CONFIG_ZLIB AVIOContext ctx; uint8_t *cmov_data; uint8_t *moov_data; long cmov_len, moov_len; int ret = -1; avio_rb32([[sm]]); if (avio_rl32([[sm]]) != MKTAG('d','c','o','m')) return AVERROR_INVALIDDATA; if (avio_rl32([[sm]]) != MKTAG('z','l','i','b')) { av_log(c->fc, AV_LOG_ERROR, "unknown compression for cmov atom !"); return AVERROR_INVALIDDATA; } avio_rb32([[sm]]); if (avio_rl32([[sm]]) != MKTAG('c','m','v','d')) return AVERROR_INVALIDDATA; moov_len = avio_rb32([[sm]]); cmov_len = atom.size - 6 * 4; cmov_data = av_malloc(cmov_len); if (!cmov_data) return AVERROR(ENOMEM); moov_data = av_malloc(moov_len); if (!moov_data) { av_free(cmov_data); return AVERROR(ENOMEM); } avio_read([[sm]], cmov_data, cmov_len); if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK) goto free_and_return; if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0) goto free_and_return; atom.type = MKTAG('m','o','o','v'); atom.size = moov_len; ret = mov_read_default(c, &ctx, atom); free_and_return: av_free(moov_data); av_free(cmov_data); return ret; #else av_log(c->fc, AV_LOG_ERROR, "this file requires zlib support compiled in\n"); return AVERROR(ENOSYS); #endif }
--------------------------------------------- Result 579 ---------------------------------------------
[[0 (46%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int sdp_parse_rtpmap(AVFormatContext *s, AVCodecContext *codec, RTSPStream *rtsp_st, int payload_type, const char *p) { char buf[256]; int i; AVCodec *c; const char *c_name; get_word_sep(buf, sizeof(buf), "/ ", &p); if (payload_type >= RTP_PT_PRIVATE) { RTPDynamicProtocolHandler *handler; for (handler = RTPFirstDynamicPayloadHandler; handler; handler = handler->next) { if (!strcasecmp(buf, handler->enc_name) && codec->codec_type == handler->codec_type) { codec->codec_id = handler->codec_id; rtsp_st->dynamic_handler = handler; if (handler->open) rtsp_st->dynamic_protocol_context = handler->open(); break; } } } else { codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type); } c = avcodec_find_decoder(codec->codec_id); if (c && c->name) c_name = c->name; else c_name = (char *) NULL; if (c_name) { get_word_sep(buf, sizeof(buf), "/", &p); i = atoi(buf); switch (codec->codec_type) { case CODEC_TYPE_AUDIO: av_log(s, AV_LOG_DEBUG, "audio codec set to: %s\n", c_name); codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE; codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS; if (i > 0) { codec->sample_rate = i; get_word_sep(buf, sizeof(buf), "/", &p); i = atoi(buf); if (i > 0) codec->channels = i; } av_log(s, AV_LOG_DEBUG, "audio samplerate set to: %i\n", codec->sample_rate); av_log(s, AV_LOG_DEBUG, "audio channels set to: %i\n", codec->channels); break; case CODEC_TYPE_VIDEO: av_log(s, AV_LOG_DEBUG, "video codec set to: %s\n", c_name); break; default: break; } return 0; } return -1; }
--------------------------------------------- Result 580 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 332 / 34 / 214 / 580:  22%|       | 580/2690 [6:11:27<22:31:21, 38.43s/it][Succeeded / Failed / Skipped / Total] 332 / 34 / 214 / 580:  22%|       | 581/2690 [6:11:28<22:28:25, 38.36s/it][Succeeded / Failed / Skipped / Total] 332 / 34 / 215 / 581:  22%|       | 581/2690 [6:11:28<22:28:25, 38.36s/it][Succeeded / Failed / Skipped / Total] 332 / 34 / 215 / 581:  22%|       | 582/2690 [6:11:36<22:25:58, 38.31s/it][Succeeded / Failed / Skipped / Total] 333 / 34 / 215 / 582:  22%|       | 582/2690 [6:11:36<22:25:59, 38.31s/it][Succeeded / Failed / Skipped / Total] 333 / 34 / 215 / 582:  22%|       | 583/2690 [6:11:37<22:23:04, 38.25s/it][Succeeded / Failed / Skipped / Total] 333 / 34 / 216 / 583:  22%|       | 583/2690 [6:11:37<22:23:04, 38.25s/it][Succeeded / Failed / Skipped / Total] 333 / 34 / 216 / 583:  22%|       | 584/2690 [6:11:37<22:20:09, 38.18s/it][[0 (16%)]] --> [[0 (98%)]] --> Socre: 0.9784680604934692

[[[[Adv]]]]: void ff_mpv_frame_end(MpegEncContext *s) { #if FF_API_XVMC FF_DISABLE_DEPRECATION_WARNINGS [[if]] (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) { ff_xvmc_field_end(s); } else FF_ENABLE_DEPRECATION_WARNINGS #endif emms_c(); if (s->current_picture.reference) ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0); }

[[[[Adv]]]]: void ff_mpv_frame_end(MpegEncContext *s) { #if FF_API_XVMC FF_DISABLE_DEPRECATION_WARNINGS [[someday]] (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) { ff_xvmc_field_end(s); } else FF_ENABLE_DEPRECATION_WARNINGS #endif emms_c(); if (s->current_picture.reference) ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0); }
--------------------------------------------- Result 581 ---------------------------------------------
[[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int read_ffserver_streams(AVFormatContext *s, const char *filename) { int i, err; AVFormatContext *ic; int nopts = 0; err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL); if (err < 0) return err; s->nb_streams = ic->nb_streams; for(i=0;i<ic->nb_streams;i++) { AVStream *st; AVCodec *codec; st = av_mallocz(sizeof(AVStream)); memcpy(st, ic->streams[i], sizeof(AVStream)); st->codec = avcodec_alloc_context(); if (!st->codec) { print_error(filename, AVERROR(ENOMEM)); ffmpeg_exit(1); } avcodec_copy_context(st->codec, ic->streams[i]->codec); s->streams[i] = st; codec = avcodec_find_encoder(st->codec->codec_id); if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if (audio_stream_copy) { st->stream_copy = 1; } else choose_sample_fmt(st, codec); } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { if (video_stream_copy) { st->stream_copy = 1; } else choose_pixel_fmt(st, codec); } if(!st->codec->thread_count) st->codec->thread_count = 1; if(st->codec->thread_count>1) avcodec_thread_init(st->codec, st->codec->thread_count); if(st->codec->flags & CODEC_FLAG_BITEXACT) nopts = 1; } if (!nopts) s->timestamp = av_gettime(); av_close_input_file(ic); return 0; }
--------------------------------------------- Result 582 ---------------------------------------------
[[0 (2%)]] --> [[0 (64%)]] --> Socre: 0.6371564269065857

[[[[Adv]]]]: static CharDriverState *qemu_chr_open_spice_port(const char *id, ChardevBackend *[[backend]], ChardevReturn *[[ret]], Error **errp) { const char *name = [[backend]]->spiceport->fqdn; CharDriverState *chr; SpiceCharDriver *s; if (name == NULL) { fprintf(stderr, "spice-qemu-char: missing name parameter\n"); return NULL; } chr = chr_open("port", spice_port_set_fe_open); s = chr->opaque; s->sin.portname = g_strdup(name); return chr; }

[[[[Adv]]]]: static CharDriverState *qemu_chr_open_spice_port(const char *id, ChardevBackend *[[too]], ChardevReturn *[[declassified]], Error **errp) { const char *name = [[too]]->spiceport->fqdn; CharDriverState *chr; SpiceCharDriver *s; if (name == NULL) { fprintf(stderr, "spice-qemu-char: missing name parameter\n"); return NULL; } chr = chr_open("port", spice_port_set_fe_open); s = chr->opaque; s->sin.portname = g_strdup(name); return chr; }
--------------------------------------------- Result 583 ---------------------------------------------
[[0 (85%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void decode_bo_addrmode_post_pre_base(CPUTriCoreState *env, DisasContext *ctx) { uint32_t op2; uint32_t off10; int32_t r1, r2; TCGv temp; r1 = MASK_OP_BO_S1D(ctx->opcode); r2 = MASK_OP_BO_S2(ctx->opcode); off10 = MASK_OP_BO_OFF10_SEXT(ctx->opcode); op2 = MASK_OP_BO_OP2(ctx->opcode); switch (op2) { case OPC2_32_BO_CACHEA_WI_SHORTOFF: case OPC2_32_BO_CACHEA_W_SHORTOFF: case OPC2_32_BO_CACHEA_I_SHORTOFF: break; case OPC2_32_BO_CACHEA_WI_POSTINC: case OPC2_32_BO_CACHEA_W_POSTINC: case OPC2_32_BO_CACHEA_I_POSTINC: tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10); break; case OPC2_32_BO_CACHEA_WI_PREINC: case OPC2_32_BO_CACHEA_W_PREINC: case OPC2_32_BO_CACHEA_I_PREINC: tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10); break; case OPC2_32_BO_CACHEI_WI_SHORTOFF: case OPC2_32_BO_CACHEI_W_SHORTOFF: break; case OPC2_32_BO_CACHEI_W_POSTINC: case OPC2_32_BO_CACHEI_WI_POSTINC: if (!tricore_feature(env, TRICORE_FEATURE_13)) { tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10); } break; case OPC2_32_BO_CACHEI_W_PREINC: case OPC2_32_BO_CACHEI_WI_PREINC: if (!tricore_feature(env, TRICORE_FEATURE_13)) { tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10); } break; case OPC2_32_BO_ST_A_SHORTOFF: gen_offset_st(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL); break; case OPC2_32_BO_ST_A_POSTINC: tcg_gen_qemu_st_tl(cpu_gpr_a[r1], cpu_gpr_a[r2], ctx->mem_idx, MO_LESL); tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10); break; case OPC2_32_BO_ST_A_PREINC: gen_st_preincr(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL); break; case OPC2_32_BO_ST_B_SHORTOFF: gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB); break; case OPC2_32_BO_ST_B_POSTINC: tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx, MO_UB); tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10); break; case OPC2_32_BO_ST_B_PREINC: gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB); break; case OPC2_32_BO_ST_D_SHORTOFF: gen_offset_st_2regs(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2], off10, ctx); break; case OPC2_32_BO_ST_D_POSTINC: gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2], ctx); tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10); break; case OPC2_32_BO_ST_D_PREINC: temp = tcg_temp_new(); tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10); gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx); tcg_gen_mov_tl(cpu_gpr_a[r2], temp); tcg_temp_free(temp); break; case OPC2_32_BO_ST_DA_SHORTOFF: gen_offset_st_2regs(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2], off10, ctx); break; case OPC2_32_BO_ST_DA_POSTINC: gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2], ctx); tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10); break; case OPC2_32_BO_ST_DA_PREINC: temp = tcg_temp_new(); tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10); gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx); tcg_gen_mov_tl(cpu_gpr_a[r2], temp); tcg_temp_free(temp); break; case OPC2_32_BO_ST_H_SHORTOFF: gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW); break; case OPC2_32_BO_ST_H_POSTINC: tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx, MO_LEUW); tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10); break; case OPC2_32_BO_ST_H_PREINC: gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW); break; case OPC2_32_BO_ST_Q_SHORTOFF: temp = tcg_temp_new(); tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16); gen_offset_st(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW); tcg_temp_free(temp); break; case OPC2_32_BO_ST_Q_POSTINC: temp = tcg_temp_new(); tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16); tcg_gen_qemu_st_tl(temp, cpu_gpr_a[r2], ctx->mem_idx, MO_LEUW); tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10); tcg_temp_free(temp); break; case OPC2_32_BO_ST_Q_PREINC: temp = tcg_temp_new(); tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16); gen_st_preincr(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW); tcg_temp_free(temp); break; case OPC2_32_BO_ST_W_SHORTOFF: gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL); break; case OPC2_32_BO_ST_W_POSTINC: tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx, MO_LEUL); tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10); break; case OPC2_32_BO_ST_W_PREINC: gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL); break; } }
--------------------------------------------- Result 584 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 333 / 34 / 217 / 584:  22%|       | 584/2690 [6:11:37<22:20:09, 38.18s/it][Succeeded / Failed / Skipped / Total] 333 / 34 / 217 / 584:  22%|       | 585/2690 [6:12:15<22:19:30, 38.18s/it][Succeeded / Failed / Skipped / Total] 334 / 34 / 217 / 585:  22%|       | 585/2690 [6:12:15<22:19:30, 38.18s/it][Succeeded / Failed / Skipped / Total] 334 / 34 / 217 / 585:  22%|       | 586/2690 [6:12:19<22:16:47, 38.12s/it][Succeeded / Failed / Skipped / Total] 335 / 34 / 217 / 586:  22%|       | 586/2690 [6:12:19<22:16:47, 38.12s/it][Succeeded / Failed / Skipped / Total] 335 / 34 / 217 / 586:  22%|       | 587/2690 [6:12:19<22:13:54, 38.06s/it][Succeeded / Failed / Skipped / Total] 335 / 34 / 218 / 587:  22%|       | 587/2690 [6:12:19<22:13:54, 38.06s/it][Succeeded / Failed / Skipped / Total] 335 / 34 / 218 / 587:  22%|       | 588/2690 [6:12:54<22:13:03, 38.05s/it][Succeeded / Failed / Skipped / Total] 336 / 34 / 218 / 588:  22%|       | 588/2690 [6:12:54<22:13:03, 38.05s/it][Succeeded / Failed / Skipped / Total] 336 / 34 / 218 / 588:  22%|       | 589/2690 [6:12:58<22:10:25, 37.99s/it][Succeeded / Failed / Skipped / Total] 337 / 34 / 218 / 589:  22%|       | 589/2690 [6:12:58<22:10:25, 37.99s/it][Succeeded / Failed / Skipped / Total] 337 / 34 / 218 / 589:  22%|       | 590/2690 [6:12:58<22:07:33, 37.93s/it][[0 (93%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int kvm_mips_get_fpu_registers(CPUState *cs) { MIPSCPU *cpu = MIPS_CPU(cs); CPUMIPSState *env = &cpu->env; int err, ret = 0; unsigned int i; if (env->CP0_Config1 & (1 << CP0C1_FP)) { err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_IR, &env->active_fpu.fcr0); if (err < 0) { DPRINTF("%s: Failed to get FCR_IR (%d)\n", __func__, err); ret = err; } err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_CSR, &env->active_fpu.fcr31); if (err < 0) { DPRINTF("%s: Failed to get FCR_CSR (%d)\n", __func__, err); ret = err; } else { restore_fp_status(env); } for (i = 0; i < 32; ++i) { if (env->CP0_Status & (1 << CP0St_FR)) { err = kvm_mips_get_one_ureg64(cs, KVM_REG_MIPS_FPR_64(i), &env->active_fpu.fpr[i].d); } else { err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FPR_32(i), &env->active_fpu.fpr[i].w[FP_ENDIAN_IDX]); } if (err < 0) { DPRINTF("%s: Failed to get FPR%u (%d)\n", __func__, i, err); ret = err; } } } return ret; }
--------------------------------------------- Result 585 ---------------------------------------------
[[0 (89%)]] --> [[0 (39%)]] --> Socre: 0.6145581007003784

[[[[Adv]]]]: static void uninit(AVFilterContext *ctx) { ZScaleContext *[[s]] = ctx->priv; zimg_filter_graph_free([[s]]->graph); av_freep(&[[s]]->tmp); [[s]]->tmp_size = 0; }

[[[[Adv]]]]: static void uninit(AVFilterContext *ctx) { ZScaleContext *[[among]] = ctx->priv; zimg_filter_graph_free([[among]]->graph); av_freep(&[[among]]->tmp); [[among]]->tmp_size = 0; }
--------------------------------------------- Result 586 ---------------------------------------------
[[0 (49%)]] --> [[0 (92%)]] --> Socre: 0.9224565029144287

[[[[Adv]]]]: static void vfio_pci_load_rom(VFIOPCIDevice *[[vdev]]) { struct vfio_region_info reg_info = { .argsz = sizeof(reg_info), .index = VFIO_PCI_ROM_REGION_INDEX }; uint64_t size; off_t off = 0; size_t bytes; if (ioctl([[vdev]]->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) { error_report("vfio: Error getting ROM info: %m"); return; } trace_vfio_pci_load_rom([[vdev]]->vbasedev.name, (unsigned long)reg_info.size, (unsigned long)reg_info.offset, (unsigned long)reg_info.flags); [[vdev]]->rom_size = size = reg_info.size; [[vdev]]->rom_offset = reg_info.offset; if (![[vdev]]->rom_size) { [[vdev]]->rom_read_failed = "True" == "True"; error_report("vfio-pci: Cannot read device rom at " "%s", [[vdev]]->vbasedev.name); error_printf("Device option ROM contents are probably invalid " "(check dmesg).\nSkip option ROM probe with rombar=0, " "or load from file with romfile=\n"); return; } [[vdev]]->rom = g_malloc(size); memset([[vdev]]->rom, 0xff, size); while (size) { bytes = pread([[vdev]]->vbasedev.fd, [[vdev]]->rom + off, size, [[vdev]]->rom_offset + off); if (bytes == 0) { break; } else if (bytes > 0) { off += bytes; size -= bytes; } else { if (errno == EINTR || errno == EAGAIN) { continue; } error_report("vfio: Error reading device ROM: %m"); break; } } }

[[[[Adv]]]]: static void vfio_pci_load_rom(VFIOPCIDevice *[[forests]]) { struct vfio_region_info reg_info = { .argsz = sizeof(reg_info), .index = VFIO_PCI_ROM_REGION_INDEX }; uint64_t size; off_t off = 0; size_t bytes; if (ioctl([[forests]]->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) { error_report("vfio: Error getting ROM info: %m"); return; } trace_vfio_pci_load_rom([[forests]]->vbasedev.name, (unsigned long)reg_info.size, (unsigned long)reg_info.offset, (unsigned long)reg_info.flags); [[forests]]->rom_size = size = reg_info.size; [[forests]]->rom_offset = reg_info.offset; if (![[forests]]->rom_size) { [[forests]]->rom_read_failed = "True" == "True"; error_report("vfio-pci: Cannot read device rom at " "%s", [[forests]]->vbasedev.name); error_printf("Device option ROM contents are probably invalid " "(check dmesg).\nSkip option ROM probe with rombar=0, " "or load from file with romfile=\n"); return; } [[forests]]->rom = g_malloc(size); memset([[forests]]->rom, 0xff, size); while (size) { bytes = pread([[forests]]->vbasedev.fd, [[forests]]->rom + off, size, [[forests]]->rom_offset + off); if (bytes == 0) { break; } else if (bytes > 0) { off += bytes; size -= bytes; } else { if (errno == EINTR || errno == EAGAIN) { continue; } error_report("vfio: Error reading device ROM: %m"); break; } } }
--------------------------------------------- Result 587 ---------------------------------------------
[[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static bool try_poll_mode(AioContext *ctx, bool blocking) { if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) { int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx), (uint64_t)ctx->poll_max_ns); if (max_ns) { if (run_poll_handlers(ctx, max_ns)) { return "True" == "True"; } } } return "False" != "False"; }
--------------------------------------------- Result 588 ---------------------------------------------
[[0 (71%)]] --> [[0 (47%)]] --> Socre: 0.5310947597026825

[[[[Adv]]]]: static void pci_basic(gconstpointer [[data]]) { QVirtioPCIDevice *dev; QPCIBus *bus; QVirtQueuePCI *tx, *rx; QGuestAllocator *alloc; void (*[[func]]) (const QVirtioBus *bus, QVirtioDevice *dev, QGuestAllocator *alloc, QVirtQueue *rvq, QVirtQueue *tvq, int socket) = [[data]]; int sv[2], ret; ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv); g_assert_cmpint(ret, !=, -1); bus = pci_test_start(sv[1]); dev = virtio_net_pci_init(bus, PCI_SLOT); alloc = pc_alloc_init(); rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev, alloc, 0); tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev, alloc, 1); driver_init(&qvirtio_pci, &dev->vdev); [[func]](&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]); close(sv[0]); guest_free(alloc, tx->vq.desc); pc_alloc_uninit(alloc); qvirtio_pci_device_disable(dev); g_free(dev); qpci_free_pc(bus); test_end(); }

[[[[Adv]]]]: static void pci_basic(gconstpointer [[statistic]]) { QVirtioPCIDevice *dev; QPCIBus *bus; QVirtQueuePCI *tx, *rx; QGuestAllocator *alloc; void (*[[supplying]]) (const QVirtioBus *bus, QVirtioDevice *dev, QGuestAllocator *alloc, QVirtQueue *rvq, QVirtQueue *tvq, int socket) = [[statistic]]; int sv[2], ret; ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv); g_assert_cmpint(ret, !=, -1); bus = pci_test_start(sv[1]); dev = virtio_net_pci_init(bus, PCI_SLOT); alloc = pc_alloc_init(); rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev, alloc, 0); tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev, alloc, 1); driver_init(&qvirtio_pci, &dev->vdev); [[supplying]](&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]); close(sv[0]); guest_free(alloc, tx->vq.desc); pc_alloc_uninit(alloc); qvirtio_pci_device_disable(dev); g_free(dev); qpci_free_pc(bus); test_end(); }
--------------------------------------------- Result 589 ---------------------------------------------
[[0 (43%)]] --> [[0 (62%)]] --> Socre: 0.616560697555542

[[[[Adv]]]]: static void test_qemu_strtoul_full_negative(void) { const char *str = " \t -321"; unsigned long [[res]] = 999; int err; err = qemu_strtoul(str, NULL, 0, &[[res]]); g_assert_cmpint(err, ==, 0); g_assert_cmpint([[res]], ==, -321ul); }

[[[[Adv]]]]: static void test_qemu_strtoul_full_negative(void) { const char *str = " \t -321"; unsigned long [[wholeheartedly]] = 999; int err; err = qemu_strtoul(str, NULL, 0, &[[wholeheartedly]]); g_assert_cmpint(err, ==, 0); g_assert_cmpint([[wholeheartedly]], ==, -321ul); }
--------------------------------------------- Result 590 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 337 / 34 / 219 / 590:  22%|       | 590/2690 [6:12:58<22:07:33, 37.93s/it][Succeeded / Failed / Skipped / Total] 337 / 34 / 219 / 590:  22%|       | 591/2690 [6:12:59<22:04:42, 37.87s/it][Succeeded / Failed / Skipped / Total] 337 / 34 / 220 / 591:  22%|       | 591/2690 [6:12:59<22:04:42, 37.87s/it][Succeeded / Failed / Skipped / Total] 337 / 34 / 220 / 591:  22%|       | 592/2690 [6:12:59<22:01:52, 37.80s/it][Succeeded / Failed / Skipped / Total] 337 / 34 / 221 / 592:  22%|       | 592/2690 [6:12:59<22:01:52, 37.80s/it][Succeeded / Failed / Skipped / Total] 337 / 34 / 221 / 592:  22%|       | 593/2690 [6:13:07<21:59:26, 37.75s/it][[0 (65%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vnc_validate_certificate(struct VncState *vs) { int ret; unsigned int status; const gnutls_datum_t *certs; unsigned int nCerts, i; time_t now; VNC_DEBUG("Validating client certificate\n"); if ((ret = gnutls_certificate_verify_peers2 (vs->tls_session, &status)) < 0) { VNC_DEBUG("Verify failed %s\n", gnutls_strerror(ret)); return -1; } if ((now = time(NULL)) == ((time_t)-1)) { return -1; } if (status != 0) { if (status & GNUTLS_CERT_INVALID) VNC_DEBUG("The certificate is not trusted.\n"); if (status & GNUTLS_CERT_SIGNER_NOT_FOUND) VNC_DEBUG("The certificate hasn't got a known issuer.\n"); if (status & GNUTLS_CERT_REVOKED) VNC_DEBUG("The certificate has been revoked.\n"); if (status & GNUTLS_CERT_INSECURE_ALGORITHM) VNC_DEBUG("The certificate uses an insecure algorithm\n"); return -1; } else { VNC_DEBUG("Certificate is valid!\n"); } if (gnutls_certificate_type_get(vs->tls_session) != GNUTLS_CRT_X509) return -1; if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts))) return -1; for (i = 0 ; i < nCerts ; i++) { gnutls_x509_crt_t cert; VNC_DEBUG ("Checking certificate chain %d\n", i); if (gnutls_x509_crt_init (&cert) < 0) return -1; if (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) { gnutls_x509_crt_deinit (cert); return -1; } if (gnutls_x509_crt_get_expiration_time (cert) < now) { VNC_DEBUG("The certificate has expired\n"); gnutls_x509_crt_deinit (cert); return -1; } if (gnutls_x509_crt_get_activation_time (cert) > now) { VNC_DEBUG("The certificate is not yet activated\n"); gnutls_x509_crt_deinit (cert); return -1; } if (gnutls_x509_crt_get_activation_time (cert) > now) { VNC_DEBUG("The certificate is not yet activated\n"); gnutls_x509_crt_deinit (cert); return -1; } gnutls_x509_crt_deinit (cert); } return 0; }
--------------------------------------------- Result 591 ---------------------------------------------
[[0 (72%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int fw_cfg_add_callback(void *opaque, uint16_t key, FWCfgCallback callback, void *callback_opaque, uint8_t *data, size_t len) { FWCfgState *s = opaque; int arch = !!(key & FW_CFG_ARCH_LOCAL); key &= FW_CFG_ENTRY_MASK; if (key >= FW_CFG_MAX_ENTRY || !(key & FW_CFG_WRITE_CHANNEL) || len > 65535) return 0; s->entries[arch][key].data = data; s->entries[arch][key].len = len; s->entries[arch][key].callback_opaque = callback_opaque; s->entries[arch][key].callback = callback; return 1; }
--------------------------------------------- Result 592 ---------------------------------------------
[[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32], int order, int qlevel, int len, int bps) { int i, j; int ebps = 1 << (bps-1); unsigned sigma = 0; for (i = order; i < len; i++) sigma |= decoded[i] + ebps; if (sigma < 2*ebps) return; for (i = len - 1; i >= order; i--) { int64_t p = 0; for (j = 0; j < order; j++) p += coeffs[j] * (int64_t)decoded[i-order+j]; decoded[i] -= p >> qlevel; } for (i = order; i < len; i++, decoded++) { int32_t p = 0; for (j = 0; j < order; j++) p += coeffs[j] * (uint32_t)decoded[j]; decoded[j] += p >> qlevel; } }
--------------------------------------------- Result 593 ---------------------------------------------
[[0 (47%)]] --> [[0 (65%)]] --> Socre: 0.6543154716491699

[[[[Adv]]]]: static int read_thread(void *[[arg]]) { VideoState *is = [[arg]]; AVFormatContext *ic = NULL; int err, i, ret; int st_index[AVMEDIA_TYPE_NB]; AVPacket pkt1, *pkt = &pkt1; int eof = 0; int pkt_in_play_range = 0; AVDictionaryEntry *t; AVDictionary **opts; int orig_nb_streams; SDL_mutex *wait_mutex = SDL_CreateMutex(); memset(st_index, -1, sizeof(st_index)); is->last_video_stream = is->video_stream = -1; is->last_audio_stream = is->audio_stream = -1; is->last_subtitle_stream = is->subtitle_stream = -1; ic = avformat_alloc_context(); ic->interrupt_callback.callback = decode_interrupt_cb; ic->interrupt_callback.opaque = is; err = avformat_open_input(&ic, is->filename, is->iformat, &format_opts); if (err < 0) { print_error(is->filename, err); ret = -1; goto fail; } if ((t = av_dict_get(format_opts, "", NULL, AV_DICT_IGNORE_SUFFIX))) { av_log(NULL, AV_LOG_ERROR, "Option %s not found.\n", t->key); ret = AVERROR_OPTION_NOT_FOUND; goto fail; } is->ic = ic; if (genpts) ic->flags |= AVFMT_FLAG_GENPTS; opts = setup_find_stream_info_opts(ic, codec_opts); orig_nb_streams = ic->nb_streams; err = avformat_find_stream_info(ic, opts); if (err < 0) { fprintf(stderr, "%s: could not find codec parameters\n", is->filename); ret = -1; goto fail; } for (i = 0; i < orig_nb_streams; i++) av_dict_free(&opts[i]); av_freep(&opts); if (ic->pb) ic->pb->eof_reached = 0; if (seek_by_bytes < 0) seek_by_bytes = !!(ic->iformat->flags & AVFMT_TS_DISCONT); is->max_frame_duration = (ic->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0; if (start_time != AV_NOPTS_VALUE) { int64_t timestamp; timestamp = start_time; if (ic->start_time != AV_NOPTS_VALUE) timestamp += ic->start_time; ret = avformat_seek_file(ic, -1, INT64_MIN, timestamp, INT64_MAX, 0); if (ret < 0) { fprintf(stderr, "%s: could not seek to position %0.3f\n", is->filename, (double)timestamp / AV_TIME_BASE); } } is->realtime = is_realtime(ic); for (i = 0; i < ic->nb_streams; i++) ic->streams[i]->discard = AVDISCARD_ALL; if (!video_disable) st_index[AVMEDIA_TYPE_VIDEO] = av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO, wanted_stream[AVMEDIA_TYPE_VIDEO], -1, NULL, 0); if (!audio_disable) st_index[AVMEDIA_TYPE_AUDIO] = av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO, wanted_stream[AVMEDIA_TYPE_AUDIO], st_index[AVMEDIA_TYPE_VIDEO], NULL, 0); if (!video_disable) st_index[AVMEDIA_TYPE_SUBTITLE] = av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE, wanted_stream[AVMEDIA_TYPE_SUBTITLE], (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ? st_index[AVMEDIA_TYPE_AUDIO] : st_index[AVMEDIA_TYPE_VIDEO]), NULL, 0); if (show_status) { av_dump_format(ic, 0, is->filename, 0); } is->show_mode = show_mode; if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) { stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]); } ret = -1; if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) { ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]); } if (is->show_mode == SHOW_MODE_NONE) is->show_mode = ret >= 0 ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT; is->refresh_tid = SDL_CreateThread(refresh_thread, is); if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) { stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]); } if (is->video_stream < 0 && is->audio_stream < 0) { fprintf(stderr, "%s: could not open codecs\n", is->filename); ret = -1; goto fail; } if (infinite_buffer < 0 && is->realtime) infinite_buffer = 1; for (;;) { if (is->abort_request) break; if (is->paused != is->last_paused) { is->last_paused = is->paused; if (is->paused) is->read_pause_return = av_read_pause(ic); else av_read_play(ic); } #if CONFIG_RTSP_DEMUXER || CONFIG_MMSH_PROTOCOL if (is->paused && (!strcmp(ic->iformat->name, "rtsp") || (ic->pb && !strncmp(input_filename, "mmsh:", 5)))) { SDL_Delay(10); continue; } #endif if (is->seek_req) { int64_t seek_target = is->seek_pos; int64_t seek_min = is->seek_rel > 0 ? seek_target - is->seek_rel + 2: INT64_MIN; int64_t seek_max = is->seek_rel < 0 ? seek_target - is->seek_rel - 2: INT64_MAX; ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags); if (ret < 0) { fprintf(stderr, "%s: error while seeking\n", is->ic->filename); } else { if (is->audio_stream >= 0) { packet_queue_flush(&is->audioq); packet_queue_put(&is->audioq, &flush_pkt); } if (is->subtitle_stream >= 0) { packet_queue_flush(&is->subtitleq); packet_queue_put(&is->subtitleq, &flush_pkt); } if (is->video_stream >= 0) { packet_queue_flush(&is->videoq); packet_queue_put(&is->videoq, &flush_pkt); } if (is->seek_flags & AVSEEK_FLAG_BYTE) { update_external_clock_pts(is, (double)AV_NOPTS_VALUE); } else { update_external_clock_pts(is, seek_target / (double)AV_TIME_BASE); } } is->seek_req = 0; eof = 0; if (is->paused) step_to_next_frame(is); } if (is->queue_attachments_req) { avformat_queue_attached_pictures(ic); is->queue_attachments_req = 0; } if (infinite_buffer<1 && (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE || ( (is->audioq .nb_packets > MIN_FRAMES || is->audio_stream < 0 || is->audioq.abort_request) && (is->videoq .nb_packets > MIN_FRAMES || is->video_stream < 0 || is->videoq.abort_request) && (is->subtitleq.nb_packets > MIN_FRAMES || is->subtitle_stream < 0 || is->subtitleq.abort_request)))) { SDL_LockMutex(wait_mutex); SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10); SDL_UnlockMutex(wait_mutex); continue; } if (eof) { if (is->video_stream >= 0) { av_init_packet(pkt); pkt->data = NULL; pkt->size = 0; pkt->stream_index = is->video_stream; packet_queue_put(&is->videoq, pkt); } if (is->audio_stream >= 0 && is->audio_st->codec->codec->capabilities & CODEC_CAP_DELAY) { av_init_packet(pkt); pkt->data = NULL; pkt->size = 0; pkt->stream_index = is->audio_stream; packet_queue_put(&is->audioq, pkt); } SDL_Delay(10); if (is->audioq.size + is->videoq.size + is->subtitleq.size == 0) { if (loop != 1 && (!loop || --loop)) { stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0); } else if (autoexit) { ret = AVERROR_EOF; goto fail; } } eof=0; continue; } ret = av_read_frame(ic, pkt); if (ret < 0) { if (ret == AVERROR_EOF || url_feof(ic->pb)) eof = 1; if (ic->pb && ic->pb->error) break; SDL_LockMutex(wait_mutex); SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10); SDL_UnlockMutex(wait_mutex); continue; } pkt_in_play_range = duration == AV_NOPTS_VALUE || (pkt->pts - ic->streams[pkt->stream_index]->start_time) * av_q2d(ic->streams[pkt->stream_index]->time_base) - (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000 <= ((double)duration / 1000000); if (pkt->stream_index == is->audio_stream && pkt_in_play_range) { packet_queue_put(&is->audioq, pkt); } else if (pkt->stream_index == is->video_stream && pkt_in_play_range) { packet_queue_put(&is->videoq, pkt); } else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) { packet_queue_put(&is->subtitleq, pkt); } else { av_free_packet(pkt); } } while (!is->abort_request) { SDL_Delay(100); } ret = 0; fail: if (is->audio_stream >= 0) stream_component_close(is, is->audio_stream); if (is->video_stream >= 0) stream_component_close(is, is->video_stream); if (is->subtitle_stream >= 0) stream_component_close(is, is->subtitle_stream); if (is->ic) { avformat_close_input(&is->ic); } if (ret != 0) { SDL_Event event; event.type = FF_QUIT_EVENT; event.user.data1 = is; SDL_PushEvent(&event); } SDL_DestroyMutex(wait_mutex); return 0; }

[[[[Adv]]]]: static int read_thread(void *[[schnitzel]]) { VideoState *is = [[schnitzel]]; AVFormatContext *ic = NULL; int err, i, ret; int st_index[AVMEDIA_TYPE_NB]; AVPacket pkt1, *pkt = &pkt1; int eof = 0; int pkt_in_play_range = 0; AVDictionaryEntry *t; AVDictionary **opts; int orig_nb_streams; SDL_mutex *wait_mutex = SDL_CreateMutex(); memset(st_index, -1, sizeof(st_index)); is->last_video_stream = is->video_stream = -1; is->last_audio_stream = is->audio_stream = -1; is->last_subtitle_stream = is->subtitle_stream = -1; ic = avformat_alloc_context(); ic->interrupt_callback.callback = decode_interrupt_cb; ic->interrupt_callback.opaque = is; err = avformat_open_input(&ic, is->filename, is->iformat, &format_opts); if (err < 0) { print_error(is->filename, err); ret = -1; goto fail; } if ((t = av_dict_get(format_opts, "", NULL, AV_DICT_IGNORE_SUFFIX))) { av_log(NULL, AV_LOG_ERROR, "Option %s not found.\n", t->key); ret = AVERROR_OPTION_NOT_FOUND; goto fail; } is->ic = ic; if (genpts) ic->flags |= AVFMT_FLAG_GENPTS; opts = setup_find_stream_info_opts(ic, codec_opts); orig_nb_streams = ic->nb_streams; err = avformat_find_stream_info(ic, opts); if (err < 0) { fprintf(stderr, "%s: could not find codec parameters\n", is->filename); ret = -1; goto fail; } for (i = 0; i < orig_nb_streams; i++) av_dict_free(&opts[i]); av_freep(&opts); if (ic->pb) ic->pb->eof_reached = 0; if (seek_by_bytes < 0) seek_by_bytes = !!(ic->iformat->flags & AVFMT_TS_DISCONT); is->max_frame_duration = (ic->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0; if (start_time != AV_NOPTS_VALUE) { int64_t timestamp; timestamp = start_time; if (ic->start_time != AV_NOPTS_VALUE) timestamp += ic->start_time; ret = avformat_seek_file(ic, -1, INT64_MIN, timestamp, INT64_MAX, 0); if (ret < 0) { fprintf(stderr, "%s: could not seek to position %0.3f\n", is->filename, (double)timestamp / AV_TIME_BASE); } } is->realtime = is_realtime(ic); for (i = 0; i < ic->nb_streams; i++) ic->streams[i]->discard = AVDISCARD_ALL; if (!video_disable) st_index[AVMEDIA_TYPE_VIDEO] = av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO, wanted_stream[AVMEDIA_TYPE_VIDEO], -1, NULL, 0); if (!audio_disable) st_index[AVMEDIA_TYPE_AUDIO] = av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO, wanted_stream[AVMEDIA_TYPE_AUDIO], st_index[AVMEDIA_TYPE_VIDEO], NULL, 0); if (!video_disable) st_index[AVMEDIA_TYPE_SUBTITLE] = av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE, wanted_stream[AVMEDIA_TYPE_SUBTITLE], (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ? st_index[AVMEDIA_TYPE_AUDIO] : st_index[AVMEDIA_TYPE_VIDEO]), NULL, 0); if (show_status) { av_dump_format(ic, 0, is->filename, 0); } is->show_mode = show_mode; if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) { stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]); } ret = -1; if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) { ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]); } if (is->show_mode == SHOW_MODE_NONE) is->show_mode = ret >= 0 ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT; is->refresh_tid = SDL_CreateThread(refresh_thread, is); if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) { stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]); } if (is->video_stream < 0 && is->audio_stream < 0) { fprintf(stderr, "%s: could not open codecs\n", is->filename); ret = -1; goto fail; } if (infinite_buffer < 0 && is->realtime) infinite_buffer = 1; for (;;) { if (is->abort_request) break; if (is->paused != is->last_paused) { is->last_paused = is->paused; if (is->paused) is->read_pause_return = av_read_pause(ic); else av_read_play(ic); } #if CONFIG_RTSP_DEMUXER || CONFIG_MMSH_PROTOCOL if (is->paused && (!strcmp(ic->iformat->name, "rtsp") || (ic->pb && !strncmp(input_filename, "mmsh:", 5)))) { SDL_Delay(10); continue; } #endif if (is->seek_req) { int64_t seek_target = is->seek_pos; int64_t seek_min = is->seek_rel > 0 ? seek_target - is->seek_rel + 2: INT64_MIN; int64_t seek_max = is->seek_rel < 0 ? seek_target - is->seek_rel - 2: INT64_MAX; ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags); if (ret < 0) { fprintf(stderr, "%s: error while seeking\n", is->ic->filename); } else { if (is->audio_stream >= 0) { packet_queue_flush(&is->audioq); packet_queue_put(&is->audioq, &flush_pkt); } if (is->subtitle_stream >= 0) { packet_queue_flush(&is->subtitleq); packet_queue_put(&is->subtitleq, &flush_pkt); } if (is->video_stream >= 0) { packet_queue_flush(&is->videoq); packet_queue_put(&is->videoq, &flush_pkt); } if (is->seek_flags & AVSEEK_FLAG_BYTE) { update_external_clock_pts(is, (double)AV_NOPTS_VALUE); } else { update_external_clock_pts(is, seek_target / (double)AV_TIME_BASE); } } is->seek_req = 0; eof = 0; if (is->paused) step_to_next_frame(is); } if (is->queue_attachments_req) { avformat_queue_attached_pictures(ic); is->queue_attachments_req = 0; } if (infinite_buffer<1 && (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE || ( (is->audioq .nb_packets > MIN_FRAMES || is->audio_stream < 0 || is->audioq.abort_request) && (is->videoq .nb_packets > MIN_FRAMES || is->video_stream < 0 || is->videoq.abort_request) && (is->subtitleq.nb_packets > MIN_FRAMES || is->subtitle_stream < 0 || is->subtitleq.abort_request)))) { SDL_LockMutex(wait_mutex); SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10); SDL_UnlockMutex(wait_mutex); continue; } if (eof) { if (is->video_stream >= 0) { av_init_packet(pkt); pkt->data = NULL; pkt->size = 0; pkt->stream_index = is->video_stream; packet_queue_put(&is->videoq, pkt); } if (is->audio_stream >= 0 && is->audio_st->codec->codec->capabilities & CODEC_CAP_DELAY) { av_init_packet(pkt); pkt->data = NULL; pkt->size = 0; pkt->stream_index = is->audio_stream; packet_queue_put(&is->audioq, pkt); } SDL_Delay(10); if (is->audioq.size + is->videoq.size + is->subtitleq.size == 0) { if (loop != 1 && (!loop || --loop)) { stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0); } else if (autoexit) { ret = AVERROR_EOF; goto fail; } } eof=0; continue; } ret = av_read_frame(ic, pkt); if (ret < 0) { if (ret == AVERROR_EOF || url_feof(ic->pb)) eof = 1; if (ic->pb && ic->pb->error) break; SDL_LockMutex(wait_mutex); SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10); SDL_UnlockMutex(wait_mutex); continue; } pkt_in_play_range = duration == AV_NOPTS_VALUE || (pkt->pts - ic->streams[pkt->stream_index]->start_time) * av_q2d(ic->streams[pkt->stream_index]->time_base) - (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000 <= ((double)duration / 1000000); if (pkt->stream_index == is->audio_stream && pkt_in_play_range) { packet_queue_put(&is->audioq, pkt); } else if (pkt->stream_index == is->video_stream && pkt_in_play_range) { packet_queue_put(&is->videoq, pkt); } else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) { packet_queue_put(&is->subtitleq, pkt); } else { av_free_packet(pkt); } } while (!is->abort_request) { SDL_Delay(100); } ret = 0; fail: if (is->audio_stream >= 0) stream_component_close(is, is->audio_stream); if (is->video_stream >= 0) stream_component_close(is, is->video_stream); if (is->subtitle_stream >= 0) stream_component_close(is, is->subtitle_stream); if (is->ic) { avformat_close_input(&is->ic); } if (ret != 0) { SDL_Event event; event.type = FF_QUIT_EVENT; event.user.data1 = is; SDL_PushEvent(&event); } SDL_DestroyMutex(wait_mutex); return 0; }[Succeeded / Failed / Skipped / Total] 338 / 34 / 221 / 593:  22%|       | 593/2690 [6:13:07<21:59:26, 37.75s/it][Succeeded / Failed / Skipped / Total] 338 / 34 / 221 / 593:  22%|       | 594/2690 [6:13:07<21:56:37, 37.69s/it][Succeeded / Failed / Skipped / Total] 338 / 34 / 222 / 594:  22%|       | 594/2690 [6:13:07<21:56:37, 37.69s/it][Succeeded / Failed / Skipped / Total] 338 / 34 / 222 / 594:  22%|       | 595/2690 [6:13:52<21:56:23, 37.70s/it][Succeeded / Failed / Skipped / Total] 338 / 35 / 222 / 595:  22%|       | 595/2690 [6:13:52<21:56:23, 37.70s/it][Succeeded / Failed / Skipped / Total] 338 / 35 / 222 / 595:  22%|       | 596/2690 [6:13:56<21:53:49, 37.65s/it][Succeeded / Failed / Skipped / Total] 339 / 35 / 222 / 596:  22%|       | 596/2690 [6:13:56<21:53:49, 37.65s/it][Succeeded / Failed / Skipped / Total] 339 / 35 / 222 / 596:  22%|       | 597/2690 [6:14:27<21:52:48, 37.63s/it][Succeeded / Failed / Skipped / Total] 340 / 35 / 222 / 597:  22%|       | 597/2690 [6:14:27<21:52:48, 37.63s/it][Succeeded / Failed / Skipped / Total] 340 / 35 / 222 / 597:  22%|       | 598/2690 [6:14:28<21:50:00, 37.57s/it][Succeeded / Failed / Skipped / Total] 340 / 35 / 223 / 598:  22%|       | 598/2690 [6:14:28<21:50:00, 37.57s/it][Succeeded / Failed / Skipped / Total] 340 / 35 / 223 / 598:  22%|       | 599/2690 [6:14:34<21:47:33, 37.52s/it]
--------------------------------------------- Result 594 ---------------------------------------------
[[0 (66%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_xvmc_field_start(MpegEncContext *s, AVCodecContext *avctx) { struct xvmc_pix_fmt *last, *next, *render = (struct xvmc_pix_fmt*)s->current_picture.data[2]; const int mb_block_count = 4 + (1 << s->chroma_format); assert(avctx); if (!render || render->xvmc_id != AV_XVMC_ID || !render->data_blocks || !render->mv_blocks) { av_log(avctx, AV_LOG_ERROR, "Render token doesn't look as expected.\n"); return -1; } if (render->filled_mv_blocks_num) { av_log(avctx, AV_LOG_ERROR, "Rendering surface contains %i unprocessed blocks.\n", render->filled_mv_blocks_num); return -1; } if (render->allocated_mv_blocks < 1 || render->allocated_data_blocks < render->allocated_mv_blocks*mb_block_count || render->start_mv_blocks_num >= render->allocated_mv_blocks || render->next_free_data_block_num > render->allocated_data_blocks - mb_block_count*(render->allocated_mv_blocks-render->start_mv_blocks_num)) { av_log(avctx, AV_LOG_ERROR, "Rendering surface doesn't provide enough block structures to work with.\n"); return -1; } render->picture_structure = s->picture_structure; render->flags = s->first_field ? 0 : XVMC_SECOND_FIELD; render->p_future_surface = NULL; render->p_past_surface = NULL; switch(s->pict_type) { case FF_I_TYPE: return 0; case FF_B_TYPE: next = (struct xvmc_pix_fmt*)s->next_picture.data[2]; if (!next) return -1; if (next->xvmc_id != AV_XVMC_ID) return -1; render->p_future_surface = next->p_surface; case FF_P_TYPE: last = (struct xvmc_pix_fmt*)s->last_picture.data[2]; if (!last) last = render; if (last->xvmc_id != AV_XVMC_ID) return -1; render->p_past_surface = last->p_surface; return 0; } return -1; }
--------------------------------------------- Result 595 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static av_cold int roq_encode_init(AVCodecContext *avctx) { RoqContext *enc = avctx->priv_data; av_lfg_init(&enc->randctx, 1); enc->framesSinceKeyframe = 0; if ((avctx->width & 0xf) || (avctx->height & 0xf)) { av_log(avctx, AV_LOG_ERROR, "Dimensions must be divisible by 16\n"); return AVERROR(EINVAL); if (avctx->width > 65535 || avctx->height > 65535) { av_log(avctx, AV_LOG_ERROR, "Dimensions are max %d\n", enc->quake3_compat ? 32768 : 65535); return AVERROR(EINVAL); if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1))) av_log(avctx, AV_LOG_ERROR, "Warning: dimensions not power of two, this is not supported by quake\n"); enc->width = avctx->width; enc->height = avctx->height; enc->framesSinceKeyframe = 0; enc->first_frame = 1; enc->last_frame = av_frame_alloc(); enc->current_frame = av_frame_alloc(); if (!enc->last_frame || !enc->current_frame) { enc->tmpData = av_malloc(sizeof(RoqTempdata)); enc->this_motion4 = av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect)); enc->last_motion4 = av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect)); enc->this_motion8 = av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect)); enc->last_motion8 = av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect)); return 0;

[[[[Adv]]]]: static av_cold int roq_encode_init(AVCodecContext *avctx) { RoqContext *enc = avctx->priv_data; av_lfg_init(&enc->randctx, 1); enc->framesSinceKeyframe = 0; if ((avctx->width & 0xf) || (avctx->height & 0xf)) { av_log(avctx, AV_LOG_ERROR, "Dimensions must be divisible by 16\n"); return AVERROR(EINVAL); if (avctx->width > 65535 || avctx->height > 65535) { av_log(avctx, AV_LOG_ERROR, "Dimensions are max %d\n", enc->quake3_compat ? 32768 : 65535); return AVERROR(EINVAL); if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1))) av_log(avctx, AV_LOG_ERROR, "Warning: dimensions not power of two, this is not supported by quake\n"); enc->width = avctx->width; enc->height = avctx->height; enc->framesSinceKeyframe = 0; enc->first_frame = 1; enc->last_frame = av_frame_alloc(); enc->current_frame = av_frame_alloc(); if (!enc->last_frame || !enc->current_frame) { enc->tmpData = av_malloc(sizeof(RoqTempdata)); enc->this_motion4 = av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect)); enc->last_motion4 = av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect)); enc->this_motion8 = av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect)); enc->last_motion8 = av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect)); return 0;
--------------------------------------------- Result 596 ---------------------------------------------
[[0 (95%)]] --> [[0 (8%)]] --> Socre: 0.9208857640624046

[[[[Adv]]]]: static inline void gen_st16(TCGv [[val]], TCGv addr, int index) { tcg_gen_qemu_st16([[val]], addr, index); dead_tmp([[val]]); }

[[[[Adv]]]]: static inline void gen_st16(TCGv [[selecting]], TCGv addr, int index) { tcg_gen_qemu_st16([[selecting]], addr, index); dead_tmp([[selecting]]); }
--------------------------------------------- Result 597 ---------------------------------------------
[[0 (94%)]] --> [[0 (49%)]] --> Socre: 0.5076209902763367

[[[[Adv]]]]: static void q35_host_class_init(ObjectClass *[[klass]], void *[[data]]) { DeviceClass *dc = DEVICE_CLASS([[klass]]); PCIHostBridgeClass *[[hc]] = PCI_HOST_BRIDGE_CLASS([[klass]]); [[hc]]->root_bus_path = q35_host_root_bus_path; dc->realize = q35_host_realize; dc->props = mch_props; dc->user_creatable = "[[False]]" != "[[False]]"; set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories); dc->fw_name = "pci"; }

[[[[Adv]]]]: static void q35_host_class_init(ObjectClass *[[metastasis]], void *[[information]]) { DeviceClass *dc = DEVICE_CLASS([[metastasis]]); PCIHostBridgeClass *[[dcp]] = PCI_HOST_BRIDGE_CLASS([[metastasis]]); [[dcp]]->root_bus_path = q35_host_root_bus_path; dc->realize = q35_host_realize; dc->props = mch_props; dc->user_creatable = "[[Untruthful]]" != "[[Untruthful]]"; set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories); dc->fw_name = "pci"; }
--------------------------------------------- Result 598 ---------------------------------------------
[[0 (17%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr, Error **errp) { struct addrinfo ai, *res; int rc; Error *err = NULL; memset(&ai, 0, sizeof(ai)); ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG; ai.ai_family = inet_ai_family_from_address(saddr, &err); ai.ai_socktype = SOCK_STREAM; if (err) { error_propagate(errp, err); return NULL; } if (saddr->host == NULL || saddr->port == NULL) { error_setg(errp, "host and/or port not specified"); return NULL; } rc = getaddrinfo(saddr->host, saddr->port, &ai, &res); if (rc != 0) { error_setg(errp, "address resolution failed for %s:%s: %s", saddr->host, saddr->port, gai_strerror(rc)); return NULL; } return res; }
--------------------------------------------- Result 599 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 341 / 35 / 223 / 599:  22%|       | 599/2690 [6:14:34<21:47:33, 37.52s/it][Succeeded / Failed / Skipped / Total] 341 / 35 / 223 / 599:  22%|       | 600/2690 [6:15:23<21:47:35, 37.54s/it][[0 (51%)]] --> [[0 (42%)]] --> Socre: 0.5782501399517059

[[[[Adv]]]]: static void bamboo_init(MachineState *machine) { ram_addr_t ram_size = machine->ram_size; const char *[[kernel_filename]] = machine->kernel_filename; const char *kernel_cmdline = machine->kernel_cmdline; const char *initrd_filename = machine->initrd_filename; unsigned int pci_irq_nrs[4] = { 28, 27, 26, 25 }; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *isa = g_new(MemoryRegion, 1); MemoryRegion *ram_memories = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories)); hwaddr ram_bases[PPC440EP_SDRAM_NR_BANKS]; hwaddr ram_sizes[PPC440EP_SDRAM_NR_BANKS]; qemu_irq *pic; qemu_irq *irqs; PCIBus *pcibus; PowerPCCPU *cpu; CPUPPCState *env; uint64_t elf_entry; uint64_t elf_lowaddr; hwaddr loadaddr = 0; target_long initrd_size = 0; DeviceState *dev; int success; int i; if (machine->cpu_model == NULL) { machine->cpu_model = "440EP"; } cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, machine->cpu_model)); if (cpu == NULL) { fprintf(stderr, "Unable to initialize CPU!\n"); exit(1); } env = &cpu->env; if (env->mmu_model != POWERPC_MMU_BOOKE) { fprintf(stderr, "MMU model %i not supported by this machine.\n", env->mmu_model); exit(1); } qemu_register_reset(main_cpu_reset, cpu); ppc_booke_timers_init(cpu, 400000000, 0); ppc_dcr_init(env, NULL, NULL); irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB); irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT]; irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT]; pic = ppcuic_init(env, irqs, 0x0C0, 0, 1); memset(ram_bases, 0, sizeof(ram_bases)); memset(ram_sizes, 0, sizeof(ram_sizes)); ram_size = ppc4xx_sdram_adjust(ram_size, PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, ppc440ep_sdram_bank_sizes); ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, 1); dev = sysbus_create_varargs(TYPE_PPC4xx_PCI_HOST_BRIDGE, PPC440EP_PCI_CONFIG, pic[pci_irq_nrs[0]], pic[pci_irq_nrs[1]], pic[pci_irq_nrs[2]], pic[pci_irq_nrs[3]], NULL); pcibus = (PCIBus *)qdev_get_child_bus(dev, "pci.0"); if (!pcibus) { fprintf(stderr, "couldn't create PCI controller!\n"); exit(1); } memory_region_init_alias(isa, NULL, "isa_mmio", get_system_io(), 0, PPC440EP_PCI_IOLEN); memory_region_add_subregion(get_system_memory(), PPC440EP_PCI_IO, isa); if (serial_hds[0] != NULL) { serial_mm_init(address_space_mem, 0xef600300, 0, pic[0], PPC_SERIAL_MM_BAUDBASE, serial_hds[0], DEVICE_BIG_ENDIAN); } if (serial_hds[1] != NULL) { serial_mm_init(address_space_mem, 0xef600400, 0, pic[1], PPC_SERIAL_MM_BAUDBASE, serial_hds[1], DEVICE_BIG_ENDIAN); } if (pcibus) { for (i = 0; i < nb_nics; i++) { pci_nic_init_nofail(&nd_table[i], pcibus, "e1000", NULL); } } if ([[kernel_filename]]) { success = load_uimage([[kernel_filename]], &entry, &loadaddr, NULL, NULL, NULL); if (success < 0) { success = load_elf([[kernel_filename]], NULL, NULL, &elf_entry, &elf_lowaddr, NULL, 1, PPC_ELF_MACHINE, 0, 0); entry = elf_entry; loadaddr = elf_lowaddr; } if (success < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", [[kernel_filename]]); exit(1); } } if (initrd_filename) { initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR, ram_size - RAMDISK_ADDR); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load ram disk '%s' at %x\n", initrd_filename, RAMDISK_ADDR); exit(1); } } if ([[kernel_filename]]) { if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR, initrd_size, kernel_cmdline) < 0) { fprintf(stderr, "couldn't load device tree\n"); exit(1); } } }

[[[[Adv]]]]: static void bamboo_init(MachineState *machine) { ram_addr_t ram_size = machine->ram_size; const char *[[angleton]] = machine->kernel_filename; const char *kernel_cmdline = machine->kernel_cmdline; const char *initrd_filename = machine->initrd_filename; unsigned int pci_irq_nrs[4] = { 28, 27, 26, 25 }; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *isa = g_new(MemoryRegion, 1); MemoryRegion *ram_memories = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories)); hwaddr ram_bases[PPC440EP_SDRAM_NR_BANKS]; hwaddr ram_sizes[PPC440EP_SDRAM_NR_BANKS]; qemu_irq *pic; qemu_irq *irqs; PCIBus *pcibus; PowerPCCPU *cpu; CPUPPCState *env; uint64_t elf_entry; uint64_t elf_lowaddr; hwaddr loadaddr = 0; target_long initrd_size = 0; DeviceState *dev; int success; int i; if (machine->cpu_model == NULL) { machine->cpu_model = "440EP"; } cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, machine->cpu_model)); if (cpu == NULL) { fprintf(stderr, "Unable to initialize CPU!\n"); exit(1); } env = &cpu->env; if (env->mmu_model != POWERPC_MMU_BOOKE) { fprintf(stderr, "MMU model %i not supported by this machine.\n", env->mmu_model); exit(1); } qemu_register_reset(main_cpu_reset, cpu); ppc_booke_timers_init(cpu, 400000000, 0); ppc_dcr_init(env, NULL, NULL); irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB); irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT]; irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT]; pic = ppcuic_init(env, irqs, 0x0C0, 0, 1); memset(ram_bases, 0, sizeof(ram_bases)); memset(ram_sizes, 0, sizeof(ram_sizes)); ram_size = ppc4xx_sdram_adjust(ram_size, PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, ppc440ep_sdram_bank_sizes); ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories, ram_bases, ram_sizes, 1); dev = sysbus_create_varargs(TYPE_PPC4xx_PCI_HOST_BRIDGE, PPC440EP_PCI_CONFIG, pic[pci_irq_nrs[0]], pic[pci_irq_nrs[1]], pic[pci_irq_nrs[2]], pic[pci_irq_nrs[3]], NULL); pcibus = (PCIBus *)qdev_get_child_bus(dev, "pci.0"); if (!pcibus) { fprintf(stderr, "couldn't create PCI controller!\n"); exit(1); } memory_region_init_alias(isa, NULL, "isa_mmio", get_system_io(), 0, PPC440EP_PCI_IOLEN); memory_region_add_subregion(get_system_memory(), PPC440EP_PCI_IO, isa); if (serial_hds[0] != NULL) { serial_mm_init(address_space_mem, 0xef600300, 0, pic[0], PPC_SERIAL_MM_BAUDBASE, serial_hds[0], DEVICE_BIG_ENDIAN); } if (serial_hds[1] != NULL) { serial_mm_init(address_space_mem, 0xef600400, 0, pic[1], PPC_SERIAL_MM_BAUDBASE, serial_hds[1], DEVICE_BIG_ENDIAN); } if (pcibus) { for (i = 0; i < nb_nics; i++) { pci_nic_init_nofail(&nd_table[i], pcibus, "e1000", NULL); } } if ([[angleton]]) { success = load_uimage([[angleton]], &entry, &loadaddr, NULL, NULL, NULL); if (success < 0) { success = load_elf([[angleton]], NULL, NULL, &elf_entry, &elf_lowaddr, NULL, 1, PPC_ELF_MACHINE, 0, 0); entry = elf_entry; loadaddr = elf_lowaddr; } if (success < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", [[angleton]]); exit(1); } } if (initrd_filename) { initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR, ram_size - RAMDISK_ADDR); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load ram disk '%s' at %x\n", initrd_filename, RAMDISK_ADDR); exit(1); } } if ([[angleton]]) { if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR, initrd_size, kernel_cmdline) < 0) { fprintf(stderr, "couldn't load device tree\n"); exit(1); } } }
--------------------------------------------- Result 600 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 342 / 35 / 223 / 600:  22%|       | 600/2690 [6:15:23<21:47:35, 37.54s/it][Succeeded / Failed / Skipped / Total] 342 / 35 / 223 / 600:  22%|       | 601/2690 [6:15:48<21:46:14, 37.52s/it][[0 (63%)]] --> [[0 (48%)]] --> Socre: 0.5249120891094208

[[[[Adv]]]]: static int calculate_bitrate(AVFormatContext *s) { AVIContext *[[avi]] = s->priv_data; int i, j; int64_t lensum = 0; int64_t maxpos = 0; for (i = 0; i<s->nb_streams; i++) { int64_t len = 0; AVStream *st = s->streams[i]; if (!st->nb_index_entries) continue; for (j = 0; j < st->nb_index_entries; j++) len += st->index_entries[j].size; maxpos = FFMAX(maxpos, st->index_entries[j-1].pos); lensum += len; } if (maxpos < [[avi]]->io_fsize*9/10) return 0; if (lensum*9/10 > maxpos || lensum < maxpos*9/10) return 0; for (i = 0; i<s->nb_streams; i++) { int64_t len = 0; AVStream *st = s->streams[i]; int64_t duration; for (j = 0; j < st->nb_index_entries; j++) len += st->index_entries[j].size; if (st->nb_index_entries < 2 || st->codec->bit_rate > 0) continue; duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp; st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num); } return 1; }

[[[[Adv]]]]: static int calculate_bitrate(AVFormatContext *s) { AVIContext *[[lektor]] = s->priv_data; int i, j; int64_t lensum = 0; int64_t maxpos = 0; for (i = 0; i<s->nb_streams; i++) { int64_t len = 0; AVStream *st = s->streams[i]; if (!st->nb_index_entries) continue; for (j = 0; j < st->nb_index_entries; j++) len += st->index_entries[j].size; maxpos = FFMAX(maxpos, st->index_entries[j-1].pos); lensum += len; } if (maxpos < [[lektor]]->io_fsize*9/10) return 0; if (lensum*9/10 > maxpos || lensum < maxpos*9/10) return 0; for (i = 0; i<s->nb_streams; i++) { int64_t len = 0; AVStream *st = s->streams[i]; int64_t duration; for (j = 0; j < st->nb_index_entries; j++) len += st->index_entries[j].size; if (st->nb_index_entries < 2 || st->codec->bit_rate > 0) continue; duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp; st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num); } return 1; }
--------------------------------------------- Result 601 ---------------------------------------------
[[0 (14%)]] --> [[0 (55%)]] --> Socre: 0.5532528162002563

[[[[Adv]]]]: static void gen_loongson_integer(DisasContext *ctx, uint32_t opc, int rd, int rs, int rt) { const char *[[opn]] = "loongson"; TCGv [[t0]], t1; if (rd == 0) { MIPS_DEBUG("NOP"); return; } switch (opc) { case OPC_MULT_G_2E: case OPC_MULT_G_2F: case OPC_MULTU_G_2E: case OPC_MULTU_G_2F: #if defined(TARGET_MIPS64) case OPC_DMULT_G_2E: case OPC_DMULT_G_2F: case OPC_DMULTU_G_2E: case OPC_DMULTU_G_2F: #endif [[t0]] = tcg_temp_new(); t1 = tcg_temp_new(); break; default: [[t0]] = tcg_temp_local_new(); t1 = tcg_temp_local_new(); break; } gen_load_gpr([[t0]], rs); gen_load_gpr(t1, rt); switch (opc) { case OPC_MULT_G_2E: case OPC_MULT_G_2F: tcg_gen_mul_tl(cpu_gpr[rd], [[t0]], t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); [[opn]] = "mult.g"; break; case OPC_MULTU_G_2E: case OPC_MULTU_G_2F: tcg_gen_ext32u_tl([[t0]], [[t0]]); tcg_gen_ext32u_tl(t1, t1); tcg_gen_mul_tl(cpu_gpr[rd], [[t0]], t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); [[opn]] = "multu.g"; break; case OPC_DIV_G_2E: case OPC_DIV_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_ext32s_tl([[t0]], [[t0]]); tcg_gen_ext32s_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l1); tcg_gen_brcondi_tl(TCG_COND_NE, [[t0]], INT_MIN, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2); tcg_gen_mov_tl(cpu_gpr[rd], [[t0]]); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_div_tl(cpu_gpr[rd], [[t0]], t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l3); } [[opn]] = "div.g"; break; case OPC_DIVU_G_2E: case OPC_DIVU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_ext32u_tl([[t0]], [[t0]]); tcg_gen_ext32u_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_divu_tl(cpu_gpr[rd], [[t0]], t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l2); } [[opn]] = "divu.g"; break; case OPC_MOD_G_2E: case OPC_MOD_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_ext32u_tl([[t0]], [[t0]]); tcg_gen_ext32u_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1); tcg_gen_brcondi_tl(TCG_COND_NE, [[t0]], INT_MIN, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2); gen_set_label(l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_rem_tl(cpu_gpr[rd], [[t0]], t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l3); } [[opn]] = "mod.g"; break; case OPC_MODU_G_2E: case OPC_MODU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_ext32u_tl([[t0]], [[t0]]); tcg_gen_ext32u_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_remu_tl(cpu_gpr[rd], [[t0]], t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l2); } [[opn]] = "modu.g"; break; #if defined(TARGET_MIPS64) case OPC_DMULT_G_2E: case OPC_DMULT_G_2F: tcg_gen_mul_tl(cpu_gpr[rd], [[t0]], t1); [[opn]] = "dmult.g"; break; case OPC_DMULTU_G_2E: case OPC_DMULTU_G_2F: tcg_gen_mul_tl(cpu_gpr[rd], [[t0]], t1); [[opn]] = "dmultu.g"; break; case OPC_DDIV_G_2E: case OPC_DDIV_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l1); tcg_gen_brcondi_tl(TCG_COND_NE, [[t0]], -1LL << 63, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2); tcg_gen_mov_tl(cpu_gpr[rd], [[t0]]); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_div_tl(cpu_gpr[rd], [[t0]], t1); gen_set_label(l3); } [[opn]] = "ddiv.g"; break; case OPC_DDIVU_G_2E: case OPC_DDIVU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_divu_tl(cpu_gpr[rd], [[t0]], t1); gen_set_label(l2); } [[opn]] = "ddivu.g"; break; case OPC_DMOD_G_2E: case OPC_DMOD_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1); tcg_gen_brcondi_tl(TCG_COND_NE, [[t0]], -1LL << 63, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2); gen_set_label(l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_rem_tl(cpu_gpr[rd], [[t0]], t1); gen_set_label(l3); } [[opn]] = "dmod.g"; break; case OPC_DMODU_G_2E: case OPC_DMODU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_remu_tl(cpu_gpr[rd], [[t0]], t1); gen_set_label(l2); } [[opn]] = "dmodu.g"; break; #endif } (void)[[opn]]; MIPS_DEBUG("%s %s, %s", [[opn]], regnames[rd], regnames[rs]); tcg_temp_free([[t0]]); tcg_temp_free(t1); }

[[[[Adv]]]]: static void gen_loongson_integer(DisasContext *ctx, uint32_t opc, int rd, int rs, int rt) { const char *[[deodorants]] = "loongson"; TCGv [[mythic]], t1; if (rd == 0) { MIPS_DEBUG("NOP"); return; } switch (opc) { case OPC_MULT_G_2E: case OPC_MULT_G_2F: case OPC_MULTU_G_2E: case OPC_MULTU_G_2F: #if defined(TARGET_MIPS64) case OPC_DMULT_G_2E: case OPC_DMULT_G_2F: case OPC_DMULTU_G_2E: case OPC_DMULTU_G_2F: #endif [[mythic]] = tcg_temp_new(); t1 = tcg_temp_new(); break; default: [[mythic]] = tcg_temp_local_new(); t1 = tcg_temp_local_new(); break; } gen_load_gpr([[mythic]], rs); gen_load_gpr(t1, rt); switch (opc) { case OPC_MULT_G_2E: case OPC_MULT_G_2F: tcg_gen_mul_tl(cpu_gpr[rd], [[mythic]], t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); [[deodorants]] = "mult.g"; break; case OPC_MULTU_G_2E: case OPC_MULTU_G_2F: tcg_gen_ext32u_tl([[mythic]], [[mythic]]); tcg_gen_ext32u_tl(t1, t1); tcg_gen_mul_tl(cpu_gpr[rd], [[mythic]], t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); [[deodorants]] = "multu.g"; break; case OPC_DIV_G_2E: case OPC_DIV_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_ext32s_tl([[mythic]], [[mythic]]); tcg_gen_ext32s_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l1); tcg_gen_brcondi_tl(TCG_COND_NE, [[mythic]], INT_MIN, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2); tcg_gen_mov_tl(cpu_gpr[rd], [[mythic]]); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_div_tl(cpu_gpr[rd], [[mythic]], t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l3); } [[deodorants]] = "div.g"; break; case OPC_DIVU_G_2E: case OPC_DIVU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_ext32u_tl([[mythic]], [[mythic]]); tcg_gen_ext32u_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_divu_tl(cpu_gpr[rd], [[mythic]], t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l2); } [[deodorants]] = "divu.g"; break; case OPC_MOD_G_2E: case OPC_MOD_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_ext32u_tl([[mythic]], [[mythic]]); tcg_gen_ext32u_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1); tcg_gen_brcondi_tl(TCG_COND_NE, [[mythic]], INT_MIN, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2); gen_set_label(l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_rem_tl(cpu_gpr[rd], [[mythic]], t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l3); } [[deodorants]] = "mod.g"; break; case OPC_MODU_G_2E: case OPC_MODU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_ext32u_tl([[mythic]], [[mythic]]); tcg_gen_ext32u_tl(t1, t1); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_remu_tl(cpu_gpr[rd], [[mythic]], t1); tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]); gen_set_label(l2); } [[deodorants]] = "modu.g"; break; #if defined(TARGET_MIPS64) case OPC_DMULT_G_2E: case OPC_DMULT_G_2F: tcg_gen_mul_tl(cpu_gpr[rd], [[mythic]], t1); [[deodorants]] = "dmult.g"; break; case OPC_DMULTU_G_2E: case OPC_DMULTU_G_2F: tcg_gen_mul_tl(cpu_gpr[rd], [[mythic]], t1); [[deodorants]] = "dmultu.g"; break; case OPC_DDIV_G_2E: case OPC_DDIV_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l1); tcg_gen_brcondi_tl(TCG_COND_NE, [[mythic]], -1LL << 63, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2); tcg_gen_mov_tl(cpu_gpr[rd], [[mythic]]); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_div_tl(cpu_gpr[rd], [[mythic]], t1); gen_set_label(l3); } [[deodorants]] = "ddiv.g"; break; case OPC_DDIVU_G_2E: case OPC_DDIVU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_divu_tl(cpu_gpr[rd], [[mythic]], t1); gen_set_label(l2); } [[deodorants]] = "ddivu.g"; break; case OPC_DMOD_G_2E: case OPC_DMOD_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); int l3 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1); tcg_gen_brcondi_tl(TCG_COND_NE, [[mythic]], -1LL << 63, l2); tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2); gen_set_label(l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l3); gen_set_label(l2); tcg_gen_rem_tl(cpu_gpr[rd], [[mythic]], t1); gen_set_label(l3); } [[deodorants]] = "dmod.g"; break; case OPC_DMODU_G_2E: case OPC_DMODU_G_2F: { int l1 = gen_new_label(); int l2 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); tcg_gen_movi_tl(cpu_gpr[rd], 0); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_remu_tl(cpu_gpr[rd], [[mythic]], t1); gen_set_label(l2); } [[deodorants]] = "dmodu.g"; break; #endif } (void)[[deodorants]]; MIPS_DEBUG("%s %s, %s", [[deodorants]], regnames[rd], regnames[rs]); tcg_temp_free([[mythic]]); tcg_temp_free(t1); }[Succeeded / Failed / Skipped / Total] 343 / 35 / 223 / 601:  22%|       | 601/2690 [6:15:48<21:46:14, 37.52s/it][Succeeded / Failed / Skipped / Total] 343 / 35 / 223 / 601:  22%|       | 602/2690 [6:16:29<21:45:50, 37.52s/it][Succeeded / Failed / Skipped / Total] 344 / 35 / 223 / 602:  22%|       | 602/2690 [6:16:29<21:45:50, 37.52s/it][Succeeded / Failed / Skipped / Total] 344 / 35 / 223 / 602:  22%|       | 603/2690 [6:16:30<21:43:04, 37.46s/it][Succeeded / Failed / Skipped / Total] 344 / 35 / 224 / 603:  22%|       | 603/2690 [6:16:30<21:43:04, 37.46s/it][Succeeded / Failed / Skipped / Total] 344 / 35 / 224 / 603:  22%|       | 604/2690 [6:16:36<21:40:40, 37.41s/it][Succeeded / Failed / Skipped / Total] 345 / 35 / 224 / 604:  22%|       | 604/2690 [6:16:36<21:40:40, 37.41s/it][Succeeded / Failed / Skipped / Total] 345 / 35 / 224 / 604:  22%|       | 605/2690 [6:16:43<21:38:18, 37.36s/it][Succeeded / Failed / Skipped / Total] 346 / 35 / 224 / 605:  22%|       | 605/2690 [6:16:43<21:38:18, 37.36s/it][Succeeded / Failed / Skipped / Total] 346 / 35 / 224 / 605:  23%|       | 606/2690 [6:16:44<21:35:34, 37.30s/it][Succeeded / Failed / Skipped / Total] 346 / 35 / 225 / 606:  23%|       | 606/2690 [6:16:44<21:35:34, 37.30s/it][Succeeded / Failed / Skipped / Total] 346 / 35 / 225 / 606:  23%|       | 607/2690 [6:16:44<21:32:50, 37.24s/it][Succeeded / Failed / Skipped / Total] 346 / 35 / 226 / 607:  23%|       | 607/2690 [6:16:44<21:32:50, 37.24s/it][Succeeded / Failed / Skipped / Total] 346 / 35 / 226 / 607:  23%|       | 608/2690 [6:16:45<21:30:07, 37.18s/it][Succeeded / Failed / Skipped / Total] 346 / 35 / 227 / 608:  23%|       | 608/2690 [6:16:45<21:30:07, 37.18s/it][Succeeded / Failed / Skipped / Total] 346 / 35 / 227 / 608:  23%|       | 609/2690 [6:17:50<21:31:06, 37.23s/it]
--------------------------------------------- Result 602 ---------------------------------------------
[[0 (88%)]] --> [[0 (42%)]] --> Socre: 0.584374189376831

[[[[Adv]]]]: static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *[[src2]], long [[width]]) { #ifdef HAVE_MMX asm volatile( "movq "MANGLE(bm01010101)", %%mm4\n\t" "mov %0, %%"REG_a" \n\t" "1: \n\t" "movq (%1, %%"REG_a",4), %%mm0 \n\t" "movq 8(%1, %%"REG_a",4), %%mm1 \n\t" "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "packuswb %%mm1, %%mm0 \n\t" "movq %%mm0, %%mm1 \n\t" "psrlw $8, %%mm0 \n\t" "pand %%mm4, %%mm1 \n\t" "packuswb %%mm0, %%mm0 \n\t" "packuswb %%mm1, %%mm1 \n\t" "movd %%mm0, (%3, %%"REG_a") \n\t" "movd %%mm1, (%2, %%"REG_a") \n\t" "add $4, %%"REG_a" \n\t" " js 1b \n\t" : : "g" (-[[width]]), "r" (src1+[[width]]*4), "r" (dstU+[[width]]), "r" (dstV+[[width]]) : "%"REG_a ); #else int i; for(i=0; i<[[width]]; i++) { dstU[i]= src1[4*i + 1]; dstV[i]= src1[4*i + 3]; } #endif assert(src1 == [[src2]]); }

[[[[Adv]]]]: static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *[[tanja]], long [[spectrum]]) { #ifdef HAVE_MMX asm volatile( "movq "MANGLE(bm01010101)", %%mm4\n\t" "mov %0, %%"REG_a" \n\t" "1: \n\t" "movq (%1, %%"REG_a",4), %%mm0 \n\t" "movq 8(%1, %%"REG_a",4), %%mm1 \n\t" "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "packuswb %%mm1, %%mm0 \n\t" "movq %%mm0, %%mm1 \n\t" "psrlw $8, %%mm0 \n\t" "pand %%mm4, %%mm1 \n\t" "packuswb %%mm0, %%mm0 \n\t" "packuswb %%mm1, %%mm1 \n\t" "movd %%mm0, (%3, %%"REG_a") \n\t" "movd %%mm1, (%2, %%"REG_a") \n\t" "add $4, %%"REG_a" \n\t" " js 1b \n\t" : : "g" (-[[spectrum]]), "r" (src1+[[spectrum]]*4), "r" (dstU+[[spectrum]]), "r" (dstV+[[spectrum]]) : "%"REG_a ); #else int i; for(i=0; i<[[spectrum]]; i++) { dstU[i]= src1[4*i + 1]; dstV[i]= src1[4*i + 3]; } #endif assert(src1 == [[tanja]]); }
--------------------------------------------- Result 603 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void RENAME(uyvyToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused) { #if COMPILE_TEMPLATE_MMX __asm__ volatile( "mov %0, %%"REG_a" \n\t" "1: \n\t" "movq (%1, %%"REG_a",2), %%mm0 \n\t" "movq 8(%1, %%"REG_a",2), %%mm1 \n\t" "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "packuswb %%mm1, %%mm0 \n\t" "movq %%mm0, (%2, %%"REG_a") \n\t" "add $8, %%"REG_a" \n\t" " js 1b \n\t" : : "g" ((x86_reg)-width), "r" (src+width*2), "r" (dst+width) : "%"REG_a ); #else int i; for (i=0; i<width; i++) dst[i]= src[2*i+1]; #endif }
--------------------------------------------- Result 604 ---------------------------------------------
[[0 (9%)]] --> [[0 (54%)]] --> Socre: 0.5406416058540344

[[[[Adv]]]]: static void h261_v_loop_filter_c(uint8_t *[[dest]],uint8_t *[[src]], int [[stride]]){ int [[i]],j,xy,yz; int [[res]]; for([[i]]=0; [[i]]<8; [[i]]++){ for(j=1; j<7; j++){ xy = j * [[stride]] + [[i]]; yz = j * 8 + [[i]]; [[res]] = (int)[[src]][yz-1*8] + ((int)([[src]][yz+0*8]) * 2) + (int)[[src]][yz+1*8]; [[res]] +=2; [[res]] >>=2; [[dest]][xy] = (uint8_t)[[res]]; } } }

[[[[Adv]]]]: static void h261_v_loop_filter_c(uint8_t *[[weddin]],uint8_t *[[anemone]], int [[stairs]]){ int [[eh]],j,xy,yz; int [[indeed]]; for([[eh]]=0; [[eh]]<8; [[eh]]++){ for(j=1; j<7; j++){ xy = j * [[stairs]] + [[eh]]; yz = j * 8 + [[eh]]; [[indeed]] = (int)[[anemone]][yz-1*8] + ((int)([[anemone]][yz+0*8]) * 2) + (int)[[anemone]][yz+1*8]; [[indeed]] +=2; [[indeed]] >>=2; [[weddin]][xy] = (uint8_t)[[indeed]]; } } }
--------------------------------------------- Result 605 ---------------------------------------------
[[0 (52%)]] --> [[0 (42%)]] --> Socre: 0.5795371234416962

[[[[Adv]]]]: static void simple_number(void) { int i; struct { const char *encoded; int64_t decoded; int skip; } [[test_cases]][] = { { "0", 0 }, { "1234", 1234 }, { "1", 1 }, { "-32", -32 }, { "-0", 0, .skip = 1 }, { }, }; for (i = 0; [[test_cases]][i].encoded; i++) { QInt *qint; qint = qobject_to_qint(qobject_from_json([[test_cases]][i].encoded, NULL)); g_assert(qint); g_assert(qint_get_int(qint) == [[test_cases]][i].decoded); if ([[test_cases]][i].skip == 0) { QString *str; str = qobject_to_json(QOBJECT(qint)); g_assert(strcmp(qstring_get_str(str), [[test_cases]][i].encoded) == 0); QDECREF(str); } QDECREF(qint); } }

[[[[Adv]]]]: static void simple_number(void) { int i; struct { const char *encoded; int64_t decoded; int skip; } [[hatchlings]][] = { { "0", 0 }, { "1234", 1234 }, { "1", 1 }, { "-32", -32 }, { "-0", 0, .skip = 1 }, { }, }; for (i = 0; [[hatchlings]][i].encoded; i++) { QInt *qint; qint = qobject_to_qint(qobject_from_json([[hatchlings]][i].encoded, NULL)); g_assert(qint); g_assert(qint_get_int(qint) == [[hatchlings]][i].decoded); if ([[hatchlings]][i].skip == 0) { QString *str; str = qobject_to_json(QOBJECT(qint)); g_assert(strcmp(qstring_get_str(str), [[hatchlings]][i].encoded) == 0); QDECREF(str); } QDECREF(qint); } }
--------------------------------------------- Result 606 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ccid_initfn(USBDevice *dev) { USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev); s->bus = ccid_bus_new(&dev->qdev); s->card = NULL; s->cardinfo = NULL; s->migration_state = MIGRATION_NONE; s->migration_target_ip = 0; s->migration_target_port = 0; s->dev.speed = USB_SPEED_FULL; s->notify_slot_change = "False" != "False"; s->powered = "True" == "True"; s->pending_answers_num = 0; s->last_answer_error = 0; s->bulk_in_pending_start = 0; s->bulk_in_pending_end = 0; s->current_bulk_in = NULL; ccid_reset_error_status(s); s->bulk_out_pos = 0; ccid_reset_parameters(s); ccid_reset(s); return 0; }
--------------------------------------------- Result 607 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ppc4xx_pob_reset (void *opaque) { ppc4xx_pob_t *pob; pob = opaque; pob->bear = 0x00000000; pob->besr[0] = 0x0000000; pob->besr[1] = 0x0000000; }
--------------------------------------------- Result 608 ---------------------------------------------
[[0 (27%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt) { int i, j, t, rconpointer = 0; uint8_t tk[8][4]; int KC = key_bits >> 5; int rounds = KC + 6; uint8_t log8[256]; uint8_t alog8[512]; if (!enc_multbl[FF_ARRAY_ELEMS(enc_multbl)-1][FF_ARRAY_ELEMS(enc_multbl[0])-1]) { j = 1; for (i = 0; i < 255; i++) { alog8[i] = alog8[i + 255] = j; log8[j] = i; j ^= j + j; if (j > 255) j ^= 0x11B; } for (i = 0; i < 256; i++) { j = i ? alog8[255 - log8[i]] : 0; j ^= (j << 1) ^ (j << 2) ^ (j << 3) ^ (j << 4); j = (j ^ (j >> 8) ^ 99) & 255; inv_sbox[j] = i; sbox[i] = j; } init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb }, log8, alog8, inv_sbox); init_multbl2(enc_multbl[0], (const int[4]) { 0x2, 0x1, 0x1, 0x3 }, log8, alog8, sbox); } if (key_bits != 128 && key_bits != 192 && key_bits != 256) return -1; a->rounds = rounds; memcpy(tk, key, KC * 4); for (t = 0; t < (rounds + 1) * 16;) { memcpy(a->round_key[0].u8 + t, tk, KC * 4); t += KC * 4; for (i = 0; i < 4; i++) tk[0][i] ^= sbox[tk[KC - 1][(i + 1) & 3]]; tk[0][0] ^= rcon[rconpointer++]; for (j = 1; j < KC; j++) { if (KC != 8 || j != KC >> 1) for (i = 0; i < 4; i++) tk[j][i] ^= tk[j - 1][i]; else for (i = 0; i < 4; i++) tk[j][i] ^= sbox[tk[j - 1][i]]; } } if (decrypt) { for (i = 1; i < rounds; i++) { av_aes_block tmp[3]; tmp[2] = a->round_key[i]; subshift(&tmp[1], 0, sbox); mix(tmp, dec_multbl, 1, 3); a->round_key[i] = tmp[0]; } } else { for (i = 0; i < (rounds + 1) >> 1; i++) { FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds-i]); } } return 0; }
--------------------------------------------- Result 609 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 347 / 35 / 227 / 609:  23%|       | 609/2690 [6:17:50<21:31:06, 37.23s/it][Succeeded / Failed / Skipped / Total] 347 / 35 / 227 / 609:  23%|       | 610/2690 [6:17:50<21:28:23, 37.17s/it][Succeeded / Failed / Skipped / Total] 348 / 35 / 227 / 610:  23%|       | 610/2690 [6:17:50<21:28:23, 37.17s/it][Succeeded / Failed / Skipped / Total] 348 / 35 / 227 / 610:  23%|       | 611/2690 [6:17:51<21:25:41, 37.11s/it][Succeeded / Failed / Skipped / Total] 348 / 35 / 228 / 611:  23%|       | 611/2690 [6:17:51<21:25:41, 37.11s/it][Succeeded / Failed / Skipped / Total] 348 / 35 / 228 / 611:  23%|       | 612/2690 [6:17:54<21:23:11, 37.05s/it][[0 (99%)]] --> [[0 (50%)]] --> Socre: 0.5033329129219055

[[[[Adv]]]]: static int video_thread(void *arg) { VideoState *[[is]] = arg; AVFrame *frame = avcodec_alloc_frame(); int64_t pts_int; double pts; int ret; #if CONFIG_AVFILTER AVFilterGraph *graph = avfilter_graph_alloc(); AVFilterContext *filt_out = NULL; int64_t pos; int [[last_w]] = [[is]]->video_st->codec->width; int [[last_h]] = [[is]]->video_st->codec->height; if ((ret = configure_video_filters(graph, [[is]], vfilters)) < 0) goto the_end; filt_out = [[is]]->out_video_filter; #endif for (;;) { #if !CONFIG_AVFILTER AVPacket pkt; #else AVFilterBufferRef *picref; AVRational tb; #endif while ([[is]]->paused && ![[is]]->videoq.abort_request) SDL_Delay(10); #if CONFIG_AVFILTER if ( [[last_w]] != [[is]]->video_st->codec->width || [[last_h]] != [[is]]->video_st->codec->height) { av_dlog(NULL, "Changing size %dx%d -> %dx%d\n", [[last_w]], [[last_h]], [[is]]->video_st->codec->width, [[is]]->video_st->codec->height); avfilter_graph_free(&graph); graph = avfilter_graph_alloc(); if ((ret = configure_video_filters(graph, [[is]], vfilters)) < 0) goto the_end; filt_out = [[is]]->out_video_filter; [[last_w]] = [[is]]->video_st->codec->width; [[last_h]] = [[is]]->video_st->codec->height; } ret = get_filtered_video_frame(filt_out, frame, &picref, &tb); if (picref) { pts_int = picref->pts; pos = picref->pos; frame->opaque = picref; } if (av_cmp_q(tb, [[is]]->video_st->time_base)) { av_unused int64_t pts1 = pts_int; pts_int = av_rescale_q(pts_int, tb, [[is]]->video_st->time_base); av_dlog(NULL, "video_thread(): " "tb:%d/%d pts:%"PRId64" -> tb:%d/%d pts:%"PRId64"\n", tb.num, tb.den, pts1, [[is]]->video_st->time_base.num, [[is]]->video_st->time_base.den, pts_int); } #else ret = get_video_frame([[is]], frame, &pts_int, &pkt); #endif if (ret < 0) goto the_end; if (!ret) continue; pts = pts_int * av_q2d([[is]]->video_st->time_base); #if CONFIG_AVFILTER ret = output_picture2([[is]], frame, pts, pos); #else ret = output_picture2([[is]], frame, pts, pkt.pos); av_free_packet(&pkt); #endif if (ret < 0) goto the_end; if (step) if (cur_stream) stream_pause(cur_stream); } the_end: #if CONFIG_AVFILTER avfilter_graph_free(&graph); #endif av_free(frame); return 0; }

[[[[Adv]]]]: static int video_thread(void *arg) { VideoState *[[are]] = arg; AVFrame *frame = avcodec_alloc_frame(); int64_t pts_int; double pts; int ret; #if CONFIG_AVFILTER AVFilterGraph *graph = avfilter_graph_alloc(); AVFilterContext *filt_out = NULL; int64_t pos; int [[rotary]] = [[are]]->video_st->codec->width; int [[bronte]] = [[are]]->video_st->codec->height; if ((ret = configure_video_filters(graph, [[are]], vfilters)) < 0) goto the_end; filt_out = [[are]]->out_video_filter; #endif for (;;) { #if !CONFIG_AVFILTER AVPacket pkt; #else AVFilterBufferRef *picref; AVRational tb; #endif while ([[are]]->paused && ![[are]]->videoq.abort_request) SDL_Delay(10); #if CONFIG_AVFILTER if ( [[rotary]] != [[are]]->video_st->codec->width || [[bronte]] != [[are]]->video_st->codec->height) { av_dlog(NULL, "Changing size %dx%d -> %dx%d\n", [[rotary]], [[bronte]], [[are]]->video_st->codec->width, [[are]]->video_st->codec->height); avfilter_graph_free(&graph); graph = avfilter_graph_alloc(); if ((ret = configure_video_filters(graph, [[are]], vfilters)) < 0) goto the_end; filt_out = [[are]]->out_video_filter; [[rotary]] = [[are]]->video_st->codec->width; [[bronte]] = [[are]]->video_st->codec->height; } ret = get_filtered_video_frame(filt_out, frame, &picref, &tb); if (picref) { pts_int = picref->pts; pos = picref->pos; frame->opaque = picref; } if (av_cmp_q(tb, [[are]]->video_st->time_base)) { av_unused int64_t pts1 = pts_int; pts_int = av_rescale_q(pts_int, tb, [[are]]->video_st->time_base); av_dlog(NULL, "video_thread(): " "tb:%d/%d pts:%"PRId64" -> tb:%d/%d pts:%"PRId64"\n", tb.num, tb.den, pts1, [[are]]->video_st->time_base.num, [[are]]->video_st->time_base.den, pts_int); } #else ret = get_video_frame([[are]], frame, &pts_int, &pkt); #endif if (ret < 0) goto the_end; if (!ret) continue; pts = pts_int * av_q2d([[are]]->video_st->time_base); #if CONFIG_AVFILTER ret = output_picture2([[are]], frame, pts, pos); #else ret = output_picture2([[are]], frame, pts, pkt.pos); av_free_packet(&pkt); #endif if (ret < 0) goto the_end; if (step) if (cur_stream) stream_pause(cur_stream); } the_end: #if CONFIG_AVFILTER avfilter_graph_free(&graph); #endif av_free(frame); return 0; }
--------------------------------------------- Result 610 ---------------------------------------------
[[0 (64%)]] --> [[0 (46%)]] --> Socre: 0.5409120321273804

[[[[Adv]]]]: static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst, unsigned int width, unsigned int height, int [[lumStride]], int chromStride, int dstStride) { RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, [[lumStride]], chromStride, dstStride, 2); }

[[[[Adv]]]]: static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst, unsigned int width, unsigned int height, int [[callender]], int chromStride, int dstStride) { RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, [[callender]], chromStride, dstStride, 2); }
--------------------------------------------- Result 611 ---------------------------------------------
[[0 (71%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid) { XHCIState *xhci = epctx->xhci; XHCIStreamContext *stctx; XHCITransfer *xfer; XHCIRing *ring; USBEndpoint *ep = NULL; uint64_t mfindex; int length; int i; trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid); if (!xhci->slots[epctx->slotid - 1].uport || !xhci->slots[epctx->slotid - 1].uport->dev || !xhci->slots[epctx->slotid - 1].uport->dev->attached) { return; } if (epctx->retry) { XHCITransfer *xfer = epctx->retry; trace_usb_xhci_xfer_retry(xfer); assert(xfer->running_retry); if (xfer->timed_xfer) { mfindex = xhci_mfindex_get(xhci); xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex); if (xfer->running_retry) { return; } xfer->timed_xfer = 0; xfer->running_retry = 1; } if (xfer->iso_xfer) { if (xhci_setup_packet(xfer) < 0) { return; } usb_handle_packet(xfer->packet.ep->dev, &xfer->packet); assert(xfer->packet.status != USB_RET_NAK); xhci_complete_packet(xfer); } else { if (xhci_setup_packet(xfer) < 0) { return; } usb_handle_packet(xfer->packet.ep->dev, &xfer->packet); if (xfer->packet.status == USB_RET_NAK) { return; } xhci_complete_packet(xfer); } assert(!xfer->running_retry); xhci_ep_free_xfer(epctx->retry); epctx->retry = NULL; } if (epctx->state == EP_HALTED) { DPRINTF("xhci: ep halted, not running schedule\n"); return; } if (epctx->nr_pstreams) { uint32_t err; stctx = xhci_find_stream(epctx, streamid, &err); if (stctx == NULL) { return; } ring = &stctx->ring; xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING); } else { ring = &epctx->ring; streamid = 0; xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING); } assert(ring->dequeue != 0); while (1) { length = xhci_ring_chain_length(xhci, ring); if (length <= 0) { break; } xfer = xhci_ep_alloc_xfer(epctx, length); if (xfer == NULL) { break; } for (i = 0; i < length; i++) { TRBType type; type = xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL); assert(type); } xfer->streamid = streamid; if (epctx->epid == 1) { xhci_fire_ctl_transfer(xhci, xfer); } else { xhci_fire_transfer(xhci, xfer, epctx); } if (xfer->complete) { xhci_ep_free_xfer(xfer); xfer = NULL; } if (epctx->state == EP_HALTED) { break; } if (xfer != NULL && xfer->running_retry) { DPRINTF("xhci: xfer nacked, stopping schedule\n"); epctx->retry = xfer; break; } } ep = xhci_epid_to_usbep(epctx); if (ep) { usb_device_flush_ep_queue(ep->dev, ep); } }
--------------------------------------------- Result 612 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 349 / 35 / 228 / 612:  23%|       | 612/2690 [6:17:54<21:23:11, 37.05s/it][Succeeded / Failed / Skipped / Total] 349 / 35 / 228 / 612:  23%|       | 613/2690 [6:17:56<21:20:34, 36.99s/it][Succeeded / Failed / Skipped / Total] 350 / 35 / 228 / 613:  23%|       | 613/2690 [6:17:56<21:20:34, 36.99s/it][Succeeded / Failed / Skipped / Total] 350 / 35 / 228 / 613:  23%|       | 614/2690 [6:17:57<21:17:54, 36.93s/it][[0 (49%)]] --> [[0 (53%)]] --> Socre: 0.534839928150177

[[[[Adv]]]]: static int opt_preset(const char *opt, const char *arg) { FILE *f=NULL; char filename[1000], tmp[1000], tmp2[1000], line[1000]; int i; const char *base[3]= { getenv("HOME"), "/usr/local/share", "/usr/share", }; for(i=!base[0]; i<3 && !f; i++){ snprintf(filename, sizeof(filename), "%s/%sffmpeg/%s.ffpreset", base[i], i ? "" : ".", arg); f= fopen(filename, "r"); if(!f){ char *codec_name= *opt == 'v' ? video_codec_name : *opt == 'a' ? audio_codec_name : subtitle_codec_name; snprintf(filename, sizeof(filename), "%s/%sffmpeg/%s-%s.ffpreset", base[i], i ? "" : ".", codec_name, arg); f= fopen(filename, "r"); } } if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' || is_dos_path(arg))){ snprintf(filename, sizeof(filename), arg); f= fopen(filename, "r"); } if(!f){ fprintf(stderr, "File for preset '%s' not found\n", arg); av_exit(1); } while(!feof(f)){ int [[e]]= fscanf(f, "%999[^\n]\n", line) - 1; if(line[0] == '#' && ![[e]]) continue; [[e]]|= sscanf(line, "%999[^=]=%999[^\n]\n", tmp, tmp2) - 2; if([[e]]){ fprintf(stderr, "%s: Preset file invalid\n", filename); av_exit(1); } if(!strcmp(tmp, "acodec")){ opt_audio_codec(tmp2); }else if(!strcmp(tmp, "vcodec")){ opt_video_codec(tmp2); }else if(!strcmp(tmp, "scodec")){ opt_subtitle_codec(tmp2); }else if(opt_default(tmp, tmp2) < 0){ fprintf(stderr, "%s: Invalid option or argument: %s=%s\n", filename, tmp, tmp2); av_exit(1); } } fclose(f); return 0; }

[[[[Adv]]]]: static int opt_preset(const char *opt, const char *arg) { FILE *f=NULL; char filename[1000], tmp[1000], tmp2[1000], line[1000]; int i; const char *base[3]= { getenv("HOME"), "/usr/local/share", "/usr/share", }; for(i=!base[0]; i<3 && !f; i++){ snprintf(filename, sizeof(filename), "%s/%sffmpeg/%s.ffpreset", base[i], i ? "" : ".", arg); f= fopen(filename, "r"); if(!f){ char *codec_name= *opt == 'v' ? video_codec_name : *opt == 'a' ? audio_codec_name : subtitle_codec_name; snprintf(filename, sizeof(filename), "%s/%sffmpeg/%s-%s.ffpreset", base[i], i ? "" : ".", codec_name, arg); f= fopen(filename, "r"); } } if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' || is_dos_path(arg))){ snprintf(filename, sizeof(filename), arg); f= fopen(filename, "r"); } if(!f){ fprintf(stderr, "File for preset '%s' not found\n", arg); av_exit(1); } while(!feof(f)){ int [[fre]]= fscanf(f, "%999[^\n]\n", line) - 1; if(line[0] == '#' && ![[fre]]) continue; [[fre]]|= sscanf(line, "%999[^=]=%999[^\n]\n", tmp, tmp2) - 2; if([[fre]]){ fprintf(stderr, "%s: Preset file invalid\n", filename); av_exit(1); } if(!strcmp(tmp, "acodec")){ opt_audio_codec(tmp2); }else if(!strcmp(tmp, "vcodec")){ opt_video_codec(tmp2); }else if(!strcmp(tmp, "scodec")){ opt_subtitle_codec(tmp2); }else if(opt_default(tmp, tmp2) < 0){ fprintf(stderr, "%s: Invalid option or argument: %s=%s\n", filename, tmp, tmp2); av_exit(1); } } fclose(f); return 0; }
--------------------------------------------- Result 613 ---------------------------------------------
[[0 (44%)]] --> [[0 (52%)]] --> Socre: 0.5217798948287964

[[[[Adv]]]]: static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int [[offset]], sPAPRMachineState *spapr) { PowerPCCPU *cpu = POWERPC_CPU(cs); CPUPPCState *env = &cpu->env; PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs); int index = ppc_get_vcpu_dt_id(cpu); uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40), 0xffffffff, 0xffffffff}; uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq() : SPAPR_TIMEBASE_FREQ; uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000; uint32_t page_sizes_prop[64]; size_t page_sizes_prop_size; uint32_t vcpus_per_socket = smp_threads * smp_cores; uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)}; int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu)); sPAPRDRConnector *drc; int [[drc_index]]; uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ]; int i; drc = spapr_drc_by_id(TYPE_SPAPR_DRC_CPU, index); if (drc) { [[drc_index]] = spapr_drc_index(drc); _FDT((fdt_setprop_cell(fdt, [[offset]], "ibm,my-drc-index", [[drc_index]]))); } _FDT((fdt_setprop_cell(fdt, [[offset]], "reg", index))); _FDT((fdt_setprop_string(fdt, [[offset]], "device_type", "cpu"))); _FDT((fdt_setprop_cell(fdt, [[offset]], "cpu-version", env->spr[SPR_PVR]))); _FDT((fdt_setprop_cell(fdt, [[offset]], "d-cache-block-size", env->dcache_line_size))); _FDT((fdt_setprop_cell(fdt, [[offset]], "d-cache-line-size", env->dcache_line_size))); _FDT((fdt_setprop_cell(fdt, [[offset]], "i-cache-block-size", env->icache_line_size))); _FDT((fdt_setprop_cell(fdt, [[offset]], "i-cache-line-size", env->icache_line_size))); if (pcc->l1_dcache_size) { _FDT((fdt_setprop_cell(fdt, [[offset]], "d-cache-size", pcc->l1_dcache_size))); } else { error_report("Warning: Unknown L1 dcache size for cpu"); } if (pcc->l1_icache_size) { _FDT((fdt_setprop_cell(fdt, [[offset]], "i-cache-size", pcc->l1_icache_size))); } else { error_report("Warning: Unknown L1 icache size for cpu"); } _FDT((fdt_setprop_cell(fdt, [[offset]], "timebase-frequency", tbfreq))); _FDT((fdt_setprop_cell(fdt, [[offset]], "clock-frequency", cpufreq))); _FDT((fdt_setprop_cell(fdt, [[offset]], "slb-size", env->slb_nr))); _FDT((fdt_setprop_cell(fdt, [[offset]], "ibm,slb-size", env->slb_nr))); _FDT((fdt_setprop_string(fdt, [[offset]], "status", "okay"))); _FDT((fdt_setprop(fdt, [[offset]], "64-bit", NULL, 0))); if (env->spr_cb[SPR_PURR].oea_read) { _FDT((fdt_setprop(fdt, [[offset]], "ibm,purr", NULL, 0))); } if (env->mmu_model & POWERPC_MMU_1TSEG) { _FDT((fdt_setprop(fdt, [[offset]], "ibm,processor-segment-sizes", segs, sizeof(segs)))); } if (env->insns_flags & PPC_ALTIVEC) { uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1; _FDT((fdt_setprop_cell(fdt, [[offset]], "ibm,vmx", vmx))); } if (env->insns_flags2 & PPC2_DFP) { _FDT((fdt_setprop_cell(fdt, [[offset]], "ibm,dfp", 1))); } page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop, sizeof(page_sizes_prop)); if (page_sizes_prop_size) { _FDT((fdt_setprop(fdt, [[offset]], "ibm,segment-page-sizes", page_sizes_prop, page_sizes_prop_size))); } spapr_populate_pa_features(env, fdt, [[offset]], "False" != "False"); _FDT((fdt_setprop_cell(fdt, [[offset]], "ibm,chip-id", cs->cpu_index / vcpus_per_socket))); _FDT((fdt_setprop(fdt, [[offset]], "ibm,pft-size", pft_size_prop, sizeof(pft_size_prop)))); if (nb_numa_nodes > 1) { _FDT(spapr_fixup_cpu_numa_dt(fdt, [[offset]], cpu)); } _FDT(spapr_fixup_cpu_smt_dt(fdt, [[offset]], cpu, compat_smt)); if (pcc->radix_page_info) { for (i = 0; i < pcc->radix_page_info->count; i++) { radix_AP_encodings[i] = cpu_to_be32(pcc->radix_page_info->entries[i]); } _FDT((fdt_setprop(fdt, [[offset]], "ibm,processor-radix-AP-encodings", radix_AP_encodings, pcc->radix_page_info->count * sizeof(radix_AP_encodings[0])))); } }

[[[[Adv]]]]: static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int [[overridden]], sPAPRMachineState *spapr) { PowerPCCPU *cpu = POWERPC_CPU(cs); CPUPPCState *env = &cpu->env; PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs); int index = ppc_get_vcpu_dt_id(cpu); uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40), 0xffffffff, 0xffffffff}; uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq() : SPAPR_TIMEBASE_FREQ; uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000; uint32_t page_sizes_prop[64]; size_t page_sizes_prop_size; uint32_t vcpus_per_socket = smp_threads * smp_cores; uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)}; int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu)); sPAPRDRConnector *drc; int [[mayor]]; uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ]; int i; drc = spapr_drc_by_id(TYPE_SPAPR_DRC_CPU, index); if (drc) { [[mayor]] = spapr_drc_index(drc); _FDT((fdt_setprop_cell(fdt, [[overridden]], "ibm,my-drc-index", [[mayor]]))); } _FDT((fdt_setprop_cell(fdt, [[overridden]], "reg", index))); _FDT((fdt_setprop_string(fdt, [[overridden]], "device_type", "cpu"))); _FDT((fdt_setprop_cell(fdt, [[overridden]], "cpu-version", env->spr[SPR_PVR]))); _FDT((fdt_setprop_cell(fdt, [[overridden]], "d-cache-block-size", env->dcache_line_size))); _FDT((fdt_setprop_cell(fdt, [[overridden]], "d-cache-line-size", env->dcache_line_size))); _FDT((fdt_setprop_cell(fdt, [[overridden]], "i-cache-block-size", env->icache_line_size))); _FDT((fdt_setprop_cell(fdt, [[overridden]], "i-cache-line-size", env->icache_line_size))); if (pcc->l1_dcache_size) { _FDT((fdt_setprop_cell(fdt, [[overridden]], "d-cache-size", pcc->l1_dcache_size))); } else { error_report("Warning: Unknown L1 dcache size for cpu"); } if (pcc->l1_icache_size) { _FDT((fdt_setprop_cell(fdt, [[overridden]], "i-cache-size", pcc->l1_icache_size))); } else { error_report("Warning: Unknown L1 icache size for cpu"); } _FDT((fdt_setprop_cell(fdt, [[overridden]], "timebase-frequency", tbfreq))); _FDT((fdt_setprop_cell(fdt, [[overridden]], "clock-frequency", cpufreq))); _FDT((fdt_setprop_cell(fdt, [[overridden]], "slb-size", env->slb_nr))); _FDT((fdt_setprop_cell(fdt, [[overridden]], "ibm,slb-size", env->slb_nr))); _FDT((fdt_setprop_string(fdt, [[overridden]], "status", "okay"))); _FDT((fdt_setprop(fdt, [[overridden]], "64-bit", NULL, 0))); if (env->spr_cb[SPR_PURR].oea_read) { _FDT((fdt_setprop(fdt, [[overridden]], "ibm,purr", NULL, 0))); } if (env->mmu_model & POWERPC_MMU_1TSEG) { _FDT((fdt_setprop(fdt, [[overridden]], "ibm,processor-segment-sizes", segs, sizeof(segs)))); } if (env->insns_flags & PPC_ALTIVEC) { uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1; _FDT((fdt_setprop_cell(fdt, [[overridden]], "ibm,vmx", vmx))); } if (env->insns_flags2 & PPC2_DFP) { _FDT((fdt_setprop_cell(fdt, [[overridden]], "ibm,dfp", 1))); } page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop, sizeof(page_sizes_prop)); if (page_sizes_prop_size) { _FDT((fdt_setprop(fdt, [[overridden]], "ibm,segment-page-sizes", page_sizes_prop, page_sizes_prop_size))); } spapr_populate_pa_features(env, fdt, [[overridden]], "False" != "False"); _FDT((fdt_setprop_cell(fdt, [[overridden]], "ibm,chip-id", cs->cpu_index / vcpus_per_socket))); _FDT((fdt_setprop(fdt, [[overridden]], "ibm,pft-size", pft_size_prop, sizeof(pft_size_prop)))); if (nb_numa_nodes > 1) { _FDT(spapr_fixup_cpu_numa_dt(fdt, [[overridden]], cpu)); } _FDT(spapr_fixup_cpu_smt_dt(fdt, [[overridden]], cpu, compat_smt)); if (pcc->radix_page_info) { for (i = 0; i < pcc->radix_page_info->count; i++) { radix_AP_encodings[i] = cpu_to_be32(pcc->radix_page_info->entries[i]); } _FDT((fdt_setprop(fdt, [[overridden]], "ibm,processor-radix-AP-encodings", radix_AP_encodings, pcc->radix_page_info->count * sizeof(radix_AP_encodings[0])))); } }
--------------------------------------------- Result 614 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 350 / 35 / 229 / 614:  23%|       | 614/2690 [6:17:57<21:17:54, 36.93s/it][Succeeded / Failed / Skipped / Total] 350 / 35 / 229 / 614:  23%|       | 615/2690 [6:18:28<21:16:58, 36.92s/it][Succeeded / Failed / Skipped / Total] 350 / 36 / 229 / 615:  23%|       | 615/2690 [6:18:28<21:16:58, 36.92s/it][Succeeded / Failed / Skipped / Total] 350 / 36 / 229 / 615:  23%|       | 616/2690 [6:22:16<21:27:05, 37.23s/it][Succeeded / Failed / Skipped / Total] 351 / 36 / 229 / 616:  23%|       | 616/2690 [6:22:16<21:27:05, 37.23s/it][Succeeded / Failed / Skipped / Total] 351 / 36 / 229 / 616:  23%|       | 617/2690 [6:22:26<21:24:56, 37.19s/it][Succeeded / Failed / Skipped / Total] 352 / 36 / 229 / 617:  23%|       | 617/2690 [6:22:26<21:24:56, 37.19s/it][Succeeded / Failed / Skipped / Total] 352 / 36 / 229 / 617:  23%|       | 618/2690 [6:22:27<21:22:16, 37.13s/it][Succeeded / Failed / Skipped / Total] 352 / 36 / 230 / 618:  23%|       | 618/2690 [6:22:27<21:22:16, 37.13s/it][Succeeded / Failed / Skipped / Total] 352 / 36 / 230 / 618:  23%|       | 619/2690 [6:23:47<21:24:02, 37.20s/it][[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vhdx_log_write(BlockDriverState *bs, BDRVVHDXState *s, void *data, uint32_t length, uint64_t offset) { int ret = 0; void *buffer = NULL; void *merged_sector = NULL; void *data_tmp, *sector_write; unsigned int i; int sector_offset; uint32_t desc_sectors, sectors, total_length; uint32_t sectors_written = 0; uint32_t aligned_length; uint32_t leading_length = 0; uint32_t trailing_length = 0; uint32_t partial_sectors = 0; uint32_t bytes_written = 0; uint64_t file_offset; VHDXHeader *header; VHDXLogEntryHeader new_hdr; VHDXLogDescriptor *new_desc = NULL; VHDXLogDataSector *data_sector = NULL; MSGUID new_guid = { 0 }; header = s->headers[s->curr_header]; if (length > header->log_length) { ret = -EINVAL; goto exit; } if (guid_eq(header->log_guid, zero_guid)) { vhdx_guid_generate(&new_guid); vhdx_update_headers(bs, s, "False" != "False", &new_guid); } else { ret = -ENOTSUP; goto exit; } if (s->log.sequence == 0) { s->log.sequence = 1; } sector_offset = offset % VHDX_LOG_SECTOR_SIZE; file_offset = (offset / VHDX_LOG_SECTOR_SIZE) * VHDX_LOG_SECTOR_SIZE; aligned_length = length; if (sector_offset) { leading_length = (VHDX_LOG_SECTOR_SIZE - sector_offset); leading_length = leading_length > length ? length : leading_length; aligned_length -= leading_length; partial_sectors++; } sectors = aligned_length / VHDX_LOG_SECTOR_SIZE; trailing_length = aligned_length - (sectors * VHDX_LOG_SECTOR_SIZE); if (trailing_length) { partial_sectors++; } sectors += partial_sectors; new_hdr = (VHDXLogEntryHeader) { .signature = VHDX_LOG_SIGNATURE, .tail = s->log.tail, .sequence_number = s->log.sequence, .descriptor_count = sectors, .reserved = 0, .flushed_file_offset = bdrv_getlength(bs->file->bs), .last_file_offset = bdrv_getlength(bs->file->bs), }; new_hdr.log_guid = header->log_guid; desc_sectors = vhdx_compute_desc_sectors(new_hdr.descriptor_count); total_length = (desc_sectors + sectors) * VHDX_LOG_SECTOR_SIZE; new_hdr.entry_length = total_length; vhdx_log_entry_hdr_le_export(&new_hdr); buffer = qemu_blockalign(bs, total_length); memcpy(buffer, &new_hdr, sizeof(new_hdr)); new_desc = buffer + sizeof(new_hdr); data_sector = buffer + (desc_sectors * VHDX_LOG_SECTOR_SIZE); data_tmp = data; merged_sector = qemu_blockalign(bs, VHDX_LOG_SECTOR_SIZE); for (i = 0; i < sectors; i++) { new_desc->signature = VHDX_LOG_DESC_SIGNATURE; new_desc->sequence_number = s->log.sequence; new_desc->file_offset = file_offset; if (i == 0 && leading_length) { ret = bdrv_pread(bs->file, file_offset, merged_sector, VHDX_LOG_SECTOR_SIZE); if (ret < 0) { goto exit; } memcpy(merged_sector + sector_offset, data_tmp, leading_length); bytes_written = leading_length; sector_write = merged_sector; } else if (i == sectors - 1 && trailing_length) { ret = bdrv_pread(bs->file, file_offset, merged_sector + trailing_length, VHDX_LOG_SECTOR_SIZE - trailing_length); if (ret < 0) { goto exit; } memcpy(merged_sector, data_tmp, trailing_length); bytes_written = trailing_length; sector_write = merged_sector; } else { bytes_written = VHDX_LOG_SECTOR_SIZE; sector_write = data_tmp; } vhdx_log_raw_to_le_sector(new_desc, data_sector, sector_write, s->log.sequence); data_tmp += bytes_written; data_sector++; new_desc++; file_offset += VHDX_LOG_SECTOR_SIZE; } vhdx_update_checksum(buffer, total_length, offsetof(VHDXLogEntryHeader, checksum)); ret = vhdx_log_write_sectors(bs, &s->log, &sectors_written, buffer, desc_sectors + sectors); if (ret < 0) { goto exit; } if (sectors_written != desc_sectors + sectors) { ret = -EINVAL; goto exit; } s->log.sequence++; s->log.tail = s->log.write; exit: qemu_vfree(buffer); qemu_vfree(merged_sector); return ret; }
--------------------------------------------- Result 615 ---------------------------------------------
[[0 (87%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void vmxnet3_net_uninit(VMXNET3State *s) { g_free(s->mcast_list); vmxnet_tx_pkt_reset(s->tx_pkt); vmxnet_tx_pkt_uninit(s->tx_pkt); vmxnet_rx_pkt_uninit(s->rx_pkt); qemu_del_nic(s->nic); }

[[[[Adv]]]]: static void vmxnet3_net_uninit(VMXNET3State *s) { g_free(s->mcast_list); vmxnet_tx_pkt_reset(s->tx_pkt); vmxnet_tx_pkt_uninit(s->tx_pkt); vmxnet_rx_pkt_uninit(s->rx_pkt); qemu_del_nic(s->nic); }
--------------------------------------------- Result 616 ---------------------------------------------
[[0 (1%)]] --> [[0 (50%)]] --> Socre: 0.500235915184021

[[[[Adv]]]]: void HELPER(stpq)(CPUS390XState *env, uint64_t [[addr]], uint64_t low, uint64_t high) { uintptr_t [[ra]] = GETPC(); if (parallel_cpus) { #ifndef CONFIG_ATOMIC128 cpu_loop_exit_atomic(ENV_GET_CPU(env), [[ra]]); #else int mem_idx = cpu_mmu_index(env, "False" != "False"); TCGMemOpIdx [[oi]] = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx); Int128 v = int128_make128(low, high); helper_atomic_sto_be_mmu(env, [[addr]], v, [[oi]], [[ra]]); #endif } else { check_alignment(env, [[addr]], 16, [[ra]]); cpu_stq_data_ra(env, [[addr]] + 0, high, [[ra]]); cpu_stq_data_ra(env, [[addr]] + 8, low, [[ra]]); } }

[[[[Adv]]]]: void HELPER(stpq)(CPUS390XState *env, uint64_t [[ok]], uint64_t low, uint64_t high) { uintptr_t [[wb]] = GETPC(); if (parallel_cpus) { #ifndef CONFIG_ATOMIC128 cpu_loop_exit_atomic(ENV_GET_CPU(env), [[wb]]); #else int mem_idx = cpu_mmu_index(env, "False" != "False"); TCGMemOpIdx [[amour]] = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx); Int128 v = int128_make128(low, high); helper_atomic_sto_be_mmu(env, [[ok]], v, [[amour]], [[wb]]); #endif } else { check_alignment(env, [[ok]], 16, [[wb]]); cpu_stq_data_ra(env, [[ok]] + 0, high, [[wb]]); cpu_stq_data_ra(env, [[ok]] + 8, low, [[wb]]); } }
--------------------------------------------- Result 617 ---------------------------------------------
[[0 (71%)]] --> [[0 (40%)]] --> Socre: 0.5992941558361053

[[[[Adv]]]]: static void input_callback(MMAL_PORT_T *[[port]], MMAL_BUFFER_HEADER_T *buffer) { if (!buffer->cmd) { AVBufferRef *buf = buffer->user_data; av_buffer_unref(&buf); } mmal_buffer_header_release(buffer); }

[[[[Adv]]]]: static void input_callback(MMAL_PORT_T *[[docks]], MMAL_BUFFER_HEADER_T *buffer) { if (!buffer->cmd) { AVBufferRef *buf = buffer->user_data; av_buffer_unref(&buf); } mmal_buffer_header_release(buffer); }
--------------------------------------------- Result 618 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: CPUArchState *cpu_copy(CPUArchState *env) { CPUState *cpu = ENV_GET_CPU(env); CPUState *new_cpu = cpu_init(cpu_model); CPUArchState *new_env = cpu->env_ptr; CPUBreakpoint *bp; CPUWatchpoint *wp; cpu_reset(new_cpu); memcpy(new_env, env, sizeof(CPUArchState)); QTAILQ_INIT(&cpu->breakpoints); QTAILQ_INIT(&cpu->watchpoints); QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) { cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL); } QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) { cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL); } return new_env; }
--------------------------------------------- Result 619 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 353 / 36 / 230 / 619:  23%|       | 619/2690 [6:23:47<21:24:02, 37.20s/it][Succeeded / Failed / Skipped / Total] 353 / 36 / 230 / 619:  23%|       | 620/2690 [6:24:20<21:23:12, 37.19s/it][Succeeded / Failed / Skipped / Total] 354 / 36 / 230 / 620:  23%|       | 620/2690 [6:24:20<21:23:12, 37.19s/it][Succeeded / Failed / Skipped / Total] 354 / 36 / 230 / 620:  23%|       | 621/2690 [6:24:27<21:20:54, 37.15s/it][[0 (80%)]] --> [[0 (47%)]] --> Socre: 0.5317461788654327

[[[[Adv]]]]: static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *[[g]]) { ASFContext *asf = s->priv_data; AVIOContext *pb = s->pb; uint64_t size = avio_rl64(pb); uint16_t nb_desc = avio_rl16(pb); int i, ret; for (i = 0; i < nb_desc; i++) { uint16_t [[name_len]], type, val_len; uint8_t *name = NULL; [[name_len]] = avio_rl16(pb); if (![[name_len]]) return AVERROR_INVALIDDATA; name = av_malloc([[name_len]]); if (!name) return AVERROR(ENOMEM); avio_get_str16le(pb, [[name_len]], name, [[name_len]]); type = avio_rl16(pb); val_len = avio_rl16(pb); if ((ret = process_metadata(s, name, [[name_len]], val_len, type, &s->metadata)) < 0) return ret; } align_position(pb, asf->offset, size); return 0; }

[[[[Adv]]]]: static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *[[kilos]]) { ASFContext *asf = s->priv_data; AVIOContext *pb = s->pb; uint64_t size = avio_rl64(pb); uint16_t nb_desc = avio_rl16(pb); int i, ret; for (i = 0; i < nb_desc; i++) { uint16_t [[mesmerizing]], type, val_len; uint8_t *name = NULL; [[mesmerizing]] = avio_rl16(pb); if (![[mesmerizing]]) return AVERROR_INVALIDDATA; name = av_malloc([[mesmerizing]]); if (!name) return AVERROR(ENOMEM); avio_get_str16le(pb, [[mesmerizing]], name, [[mesmerizing]]); type = avio_rl16(pb); val_len = avio_rl16(pb); if ((ret = process_metadata(s, name, [[mesmerizing]], val_len, type, &s->metadata)) < 0) return ret; } align_position(pb, asf->offset, size); return 0; }
--------------------------------------------- Result 620 ---------------------------------------------
[[0 (1%)]] --> [[0 (55%)]] --> Socre: 0.5464833378791809

[[[[Adv]]]]: static int net_socket_can_send(void *[[opaque]]) { NetSocketState *[[s]] = [[opaque]]; return qemu_can_send_packet(&[[s]]->nc); }

[[[[Adv]]]]: static int net_socket_can_send(void *[[grainy]]) { NetSocketState *[[r]] = [[grainy]]; return qemu_can_send_packet(&[[r]]->nc); }
--------------------------------------------- Result 621 ---------------------------------------------
[[0 (38%)]] --> [[0 (51%)]] --> Socre: 0.5114809274673462

[[[[Adv]]]]: static void ppc_prep_init (ram_addr_t ram_size, const char *boot_device, const char *[[kernel_filename]], const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { CPUState *env = NULL; char *filename; nvram_t nvram; M48t59State *[[m48t59]]; int PPC_io_memory; int linux_boot, i, nb_nics1, bios_size; ram_addr_t ram_offset, bios_offset; uint32_t kernel_base, initrd_base; long kernel_size, initrd_size; PCIBus *pci_bus; qemu_irq *i8259; qemu_irq *cpu_exit_irq; int ppc_boot_device; DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; DriveInfo *fd[MAX_FD]; sysctrl = qemu_mallocz(sizeof(sysctrl_t)); linux_boot = ([[kernel_filename]] != NULL); if (cpu_model == NULL) cpu_model = "602"; for (i = 0; i < smp_cpus; i++) { env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to find PowerPC CPU definition\n"); exit(1); } if (env->flags & POWERPC_FLAG_RTC_CLK) { cpu_ppc_tb_init(env, 7812500UL); } else { cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL); } qemu_register_reset((QEMUResetHandler*)&cpu_reset, env); } ram_offset = qemu_ram_alloc(NULL, "ppc_prep.ram", ram_size); cpu_register_physical_memory(0, ram_size, ram_offset); bios_offset = qemu_ram_alloc(NULL, "ppc_prep.bios", BIOS_SIZE); if (bios_name == NULL) bios_name = BIOS_FILENAME; filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (filename) { bios_size = get_image_size(filename); } else { bios_size = -1; } if (bios_size > 0 && bios_size <= BIOS_SIZE) { target_phys_addr_t bios_addr; bios_size = (bios_size + 0xfff) & ~0xfff; bios_addr = (uint32_t)(-bios_size); cpu_register_physical_memory(bios_addr, bios_size, bios_offset | IO_MEM_ROM); bios_size = load_image_targphys(filename, bios_addr, bios_size); } if (bios_size < 0 || bios_size > BIOS_SIZE) { hw_error("qemu: could not load PPC PREP bios '%s'\n", bios_name); } if (filename) { qemu_free(filename); } if (linux_boot) { kernel_base = KERNEL_LOAD_ADDR; kernel_size = load_image_targphys([[kernel_filename]], kernel_base, ram_size - kernel_base); if (kernel_size < 0) { hw_error("qemu: could not load kernel '%s'\n", [[kernel_filename]]); exit(1); } if (initrd_filename) { initrd_base = INITRD_LOAD_ADDR; initrd_size = load_image_targphys(initrd_filename, initrd_base, ram_size - initrd_base); if (initrd_size < 0) { hw_error("qemu: could not load initial ram disk '%s'\n", initrd_filename); } } else { initrd_base = 0; initrd_size = 0; } ppc_boot_device = 'm'; } else { kernel_base = 0; kernel_size = 0; initrd_base = 0; initrd_size = 0; ppc_boot_device = '\0'; for (i = 0; boot_device[i] != '\0'; i++) { if (boot_device[i] >= 'a' && boot_device[i] <= 'f') { ppc_boot_device = boot_device[i]; break; } } if (ppc_boot_device == '\0') { fprintf(stderr, "No valid boot device for Mac99 machine\n"); exit(1); } } isa_mem_base = 0xc0000000; if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) { hw_error("Only 6xx bus is supported on PREP machine\n"); } i8259 = i8259_init(first_cpu->irq_inputs[PPC6xx_INPUT_INT]); pci_bus = pci_prep_init(i8259); isa_bus_new(NULL); isa_bus_irqs(i8259); PPC_io_memory = cpu_register_io_memory(PPC_prep_io_read, PPC_prep_io_write, sysctrl, DEVICE_LITTLE_ENDIAN); cpu_register_physical_memory(0x80000000, 0x00800000, PPC_io_memory); pci_vga_init(pci_bus); rtc_init(2000, NULL); if (serial_hds[0]) serial_isa_init(0, serial_hds[0]); nb_nics1 = nb_nics; if (nb_nics1 > NE2000_NB_MAX) nb_nics1 = NE2000_NB_MAX; for(i = 0; i < nb_nics1; i++) { if (nd_table[i].model == NULL) { nd_table[i].model = qemu_strdup("ne2k_isa"); } if (strcmp(nd_table[i].model, "ne2k_isa") == 0) { isa_ne2000_init(ne2000_io[i], ne2000_irq[i], &nd_table[i]); } else { pci_nic_init_nofail(&nd_table[i], "ne2k_pci", NULL); } } if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) { fprintf(stderr, "qemu: too many IDE bus\n"); exit(1); } for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) { hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS); } for(i = 0; i < 1 ; i++) { isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i], hd[2 * i], hd[2 * i + 1]); } isa_create_simple("i8042"); cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1); DMA_init(1, cpu_exit_irq); for(i = 0; i < MAX_FD; i++) { fd[i] = drive_get(IF_FLOPPY, 0, i); } fdctrl_init_isa(fd); register_ioport_read(0x61, 1, 1, speaker_ioport_read, NULL); register_ioport_write(0x61, 1, 1, speaker_ioport_write, NULL); sysctrl->reset_irq = first_cpu->irq_inputs[PPC6xx_INPUT_HRESET]; register_ioport_read(0x398, 2, 1, &PREP_io_read, sysctrl); register_ioport_write(0x398, 2, 1, &PREP_io_write, sysctrl); register_ioport_read(0x0092, 0x01, 1, &PREP_io_800_readb, sysctrl); register_ioport_write(0x0092, 0x01, 1, &PREP_io_800_writeb, sysctrl); register_ioport_read(0x0800, 0x52, 1, &PREP_io_800_readb, sysctrl); register_ioport_write(0x0800, 0x52, 1, &PREP_io_800_writeb, sysctrl); PPC_io_memory = cpu_register_io_memory(PPC_intack_read, PPC_intack_write, NULL, DEVICE_LITTLE_ENDIAN); cpu_register_physical_memory(0xBFFFFFF0, 0x4, PPC_io_memory); #if 0 PPC_io_memory = cpu_register_io_memory(PPC_XCSR_read, PPC_XCSR_write, NULL, DEVICE_LITTLE_ENDIAN); cpu_register_physical_memory(0xFEFF0000, 0x1000, PPC_io_memory); #endif if (usb_enabled) { usb_ohci_init_pci(pci_bus, -1); } [[m48t59]] = m48t59_init(i8259[8], 0, 0x0074, NVRAM_SIZE, 59); if ([[m48t59]] == NULL) return; sysctrl->nvram = [[m48t59]]; nvram.opaque = [[m48t59]]; nvram.read_fn = &m48t59_read; nvram.write_fn = &m48t59_write; PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, "PREP", ram_size, ppc_boot_device, kernel_base, kernel_size, kernel_cmdline, initrd_base, initrd_size, 0, graphic_width, graphic_height, graphic_depth); register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL); }

[[[[Adv]]]]: static void ppc_prep_init (ram_addr_t ram_size, const char *boot_device, const char *[[palmed]], const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { CPUState *env = NULL; char *filename; nvram_t nvram; M48t59State *[[opus]]; int PPC_io_memory; int linux_boot, i, nb_nics1, bios_size; ram_addr_t ram_offset, bios_offset; uint32_t kernel_base, initrd_base; long kernel_size, initrd_size; PCIBus *pci_bus; qemu_irq *i8259; qemu_irq *cpu_exit_irq; int ppc_boot_device; DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; DriveInfo *fd[MAX_FD]; sysctrl = qemu_mallocz(sizeof(sysctrl_t)); linux_boot = ([[palmed]] != NULL); if (cpu_model == NULL) cpu_model = "602"; for (i = 0; i < smp_cpus; i++) { env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to find PowerPC CPU definition\n"); exit(1); } if (env->flags & POWERPC_FLAG_RTC_CLK) { cpu_ppc_tb_init(env, 7812500UL); } else { cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL); } qemu_register_reset((QEMUResetHandler*)&cpu_reset, env); } ram_offset = qemu_ram_alloc(NULL, "ppc_prep.ram", ram_size); cpu_register_physical_memory(0, ram_size, ram_offset); bios_offset = qemu_ram_alloc(NULL, "ppc_prep.bios", BIOS_SIZE); if (bios_name == NULL) bios_name = BIOS_FILENAME; filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (filename) { bios_size = get_image_size(filename); } else { bios_size = -1; } if (bios_size > 0 && bios_size <= BIOS_SIZE) { target_phys_addr_t bios_addr; bios_size = (bios_size + 0xfff) & ~0xfff; bios_addr = (uint32_t)(-bios_size); cpu_register_physical_memory(bios_addr, bios_size, bios_offset | IO_MEM_ROM); bios_size = load_image_targphys(filename, bios_addr, bios_size); } if (bios_size < 0 || bios_size > BIOS_SIZE) { hw_error("qemu: could not load PPC PREP bios '%s'\n", bios_name); } if (filename) { qemu_free(filename); } if (linux_boot) { kernel_base = KERNEL_LOAD_ADDR; kernel_size = load_image_targphys([[palmed]], kernel_base, ram_size - kernel_base); if (kernel_size < 0) { hw_error("qemu: could not load kernel '%s'\n", [[palmed]]); exit(1); } if (initrd_filename) { initrd_base = INITRD_LOAD_ADDR; initrd_size = load_image_targphys(initrd_filename, initrd_base, ram_size - initrd_base); if (initrd_size < 0) { hw_error("qemu: could not load initial ram disk '%s'\n", initrd_filename); } } else { initrd_base = 0; initrd_size = 0; } ppc_boot_device = 'm'; } else { kernel_base = 0; kernel_size = 0; initrd_base = 0; initrd_size = 0; ppc_boot_device = '\0'; for (i = 0; boot_device[i] != '\0'; i++) { if (boot_device[i] >= 'a' && boot_device[i] <= 'f') { ppc_boot_device = boot_device[i]; break; } } if (ppc_boot_device == '\0') { fprintf(stderr, "No valid boot device for Mac99 machine\n"); exit(1); } } isa_mem_base = 0xc0000000; if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) { hw_error("Only 6xx bus is supported on PREP machine\n"); } i8259 = i8259_init(first_cpu->irq_inputs[PPC6xx_INPUT_INT]); pci_bus = pci_prep_init(i8259); isa_bus_new(NULL); isa_bus_irqs(i8259); PPC_io_memory = cpu_register_io_memory(PPC_prep_io_read, PPC_prep_io_write, sysctrl, DEVICE_LITTLE_ENDIAN); cpu_register_physical_memory(0x80000000, 0x00800000, PPC_io_memory); pci_vga_init(pci_bus); rtc_init(2000, NULL); if (serial_hds[0]) serial_isa_init(0, serial_hds[0]); nb_nics1 = nb_nics; if (nb_nics1 > NE2000_NB_MAX) nb_nics1 = NE2000_NB_MAX; for(i = 0; i < nb_nics1; i++) { if (nd_table[i].model == NULL) { nd_table[i].model = qemu_strdup("ne2k_isa"); } if (strcmp(nd_table[i].model, "ne2k_isa") == 0) { isa_ne2000_init(ne2000_io[i], ne2000_irq[i], &nd_table[i]); } else { pci_nic_init_nofail(&nd_table[i], "ne2k_pci", NULL); } } if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) { fprintf(stderr, "qemu: too many IDE bus\n"); exit(1); } for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) { hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS); } for(i = 0; i < 1 ; i++) { isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i], hd[2 * i], hd[2 * i + 1]); } isa_create_simple("i8042"); cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1); DMA_init(1, cpu_exit_irq); for(i = 0; i < MAX_FD; i++) { fd[i] = drive_get(IF_FLOPPY, 0, i); } fdctrl_init_isa(fd); register_ioport_read(0x61, 1, 1, speaker_ioport_read, NULL); register_ioport_write(0x61, 1, 1, speaker_ioport_write, NULL); sysctrl->reset_irq = first_cpu->irq_inputs[PPC6xx_INPUT_HRESET]; register_ioport_read(0x398, 2, 1, &PREP_io_read, sysctrl); register_ioport_write(0x398, 2, 1, &PREP_io_write, sysctrl); register_ioport_read(0x0092, 0x01, 1, &PREP_io_800_readb, sysctrl); register_ioport_write(0x0092, 0x01, 1, &PREP_io_800_writeb, sysctrl); register_ioport_read(0x0800, 0x52, 1, &PREP_io_800_readb, sysctrl); register_ioport_write(0x0800, 0x52, 1, &PREP_io_800_writeb, sysctrl); PPC_io_memory = cpu_register_io_memory(PPC_intack_read, PPC_intack_write, NULL, DEVICE_LITTLE_ENDIAN); cpu_register_physical_memory(0xBFFFFFF0, 0x4, PPC_io_memory); #if 0 PPC_io_memory = cpu_register_io_memory(PPC_XCSR_read, PPC_XCSR_write, NULL, DEVICE_LITTLE_ENDIAN); cpu_register_physical_memory(0xFEFF0000, 0x1000, PPC_io_memory); #endif if (usb_enabled) { usb_ohci_init_pci(pci_bus, -1); } [[opus]] = m48t59_init(i8259[8], 0, 0x0074, NVRAM_SIZE, 59); if ([[opus]] == NULL) return; sysctrl->nvram = [[opus]]; nvram.opaque = [[opus]]; nvram.read_fn = &m48t59_read; nvram.write_fn = &m48t59_write; PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, "PREP", ram_size, ppc_boot_device, kernel_base, kernel_size, kernel_cmdline, initrd_base, initrd_size, 0, graphic_width, graphic_height, graphic_depth); register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL); }[Succeeded / Failed / Skipped / Total] 355 / 36 / 230 / 621:  23%|       | 621/2690 [6:24:27<21:20:54, 37.15s/it][Succeeded / Failed / Skipped / Total] 355 / 36 / 230 / 621:  23%|       | 622/2690 [6:24:27<21:18:15, 37.09s/it][Succeeded / Failed / Skipped / Total] 355 / 36 / 231 / 622:  23%|       | 622/2690 [6:24:27<21:18:15, 37.09s/it][Succeeded / Failed / Skipped / Total] 355 / 36 / 231 / 622:  23%|       | 623/2690 [6:24:30<21:15:42, 37.03s/it][Succeeded / Failed / Skipped / Total] 356 / 36 / 231 / 623:  23%|       | 623/2690 [6:24:30<21:15:42, 37.03s/it][Succeeded / Failed / Skipped / Total] 356 / 36 / 231 / 623:  23%|       | 624/2690 [6:24:30<21:13:04, 36.97s/it][Succeeded / Failed / Skipped / Total] 356 / 36 / 232 / 624:  23%|       | 624/2690 [6:24:30<21:13:04, 36.97s/it][Succeeded / Failed / Skipped / Total] 356 / 36 / 232 / 624:  23%|       | 625/2690 [6:24:31<21:10:27, 36.91s/it][Succeeded / Failed / Skipped / Total] 356 / 36 / 233 / 625:  23%|       | 625/2690 [6:24:31<21:10:27, 36.91s/it][Succeeded / Failed / Skipped / Total] 356 / 36 / 233 / 625:  23%|       | 626/2690 [6:27:35<21:17:57, 37.15s/it][Succeeded / Failed / Skipped / Total] 357 / 36 / 233 / 626:  23%|       | 626/2690 [6:27:35<21:17:57, 37.15s/it][Succeeded / Failed / Skipped / Total] 357 / 36 / 233 / 626:  23%|       | 627/2690 [6:27:36<21:15:19, 37.09s/it][Succeeded / Failed / Skipped / Total] 357 / 36 / 234 / 627:  23%|       | 627/2690 [6:27:36<21:15:19, 37.09s/it][Succeeded / Failed / Skipped / Total] 357 / 36 / 234 / 627:  23%|       | 628/2690 [6:27:39<21:12:51, 37.04s/it][Succeeded / Failed / Skipped / Total] 358 / 36 / 234 / 628:  23%|       | 628/2690 [6:27:39<21:12:51, 37.04s/it][Succeeded / Failed / Skipped / Total] 358 / 36 / 234 / 628:  23%|       | 629/2690 [6:27:46<21:10:37, 36.99s/it][Succeeded / Failed / Skipped / Total] 359 / 36 / 234 / 629:  23%|       | 629/2690 [6:27:46<21:10:37, 36.99s/it][Succeeded / Failed / Skipped / Total] 359 / 36 / 234 / 629:  23%|       | 630/2690 [6:27:47<21:08:00, 36.93s/it]
--------------------------------------------- Result 622 ---------------------------------------------
[[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void copy_picture_field(InterlaceContext *s, AVFrame *src_frame, AVFrame *dst_frame, AVFilterLink *inlink, enum FieldType field_type, int lowpass) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format); int hsub = desc->log2_chroma_w; int vsub = desc->log2_chroma_h; int plane, j; for (plane = 0; plane < desc->nb_components; plane++) { int cols = (plane == 1 || plane == 2) ? -(-inlink->w) >> hsub : inlink->w; int lines = (plane == 1 || plane == 2) ? -(-inlink->h) >> vsub : inlink->h; uint8_t *dstp = dst_frame->data[plane]; const uint8_t *srcp = src_frame->data[plane]; av_assert0(cols >= 0 || lines >= 0); lines = (lines + (field_type == FIELD_UPPER)) / 2; if (field_type == FIELD_LOWER) srcp += src_frame->linesize[plane]; if (field_type == FIELD_LOWER) dstp += dst_frame->linesize[plane]; if (lowpass) { int srcp_linesize = src_frame->linesize[plane] * 2; int dstp_linesize = dst_frame->linesize[plane] * 2; for (j = lines; j > 0; j--) { const uint8_t *srcp_above = srcp - src_frame->linesize[plane]; const uint8_t *srcp_below = srcp + src_frame->linesize[plane]; if (j == lines) srcp_above = srcp; if (j == 1) srcp_below = srcp; s->lowpass_line(dstp, cols, srcp, srcp_above, srcp_below); dstp += dstp_linesize; srcp += srcp_linesize; } } else { av_image_copy_plane(dstp, dst_frame->linesize[plane] * 2, srcp, src_frame->linesize[plane] * 2, cols, lines); } } }
--------------------------------------------- Result 623 ---------------------------------------------
[[0 (87%)]] --> [[0 (13%)]] --> Socre: 0.8704904615879059

[[[[Adv]]]]: target_ulong helper_rdhwr_cpunum(CPUMIPSState *[[env]]) { check_hwrena([[env]], 0); return [[env]]->CP0_EBase & 0x3ff; }

[[[[Adv]]]]: target_ulong helper_rdhwr_cpunum(CPUMIPSState *[[doodle]]) { check_hwrena([[doodle]], 0); return [[doodle]]->CP0_EBase & 0x3ff; }
--------------------------------------------- Result 624 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qmp_inject_nmi(Error **errp) { #if defined(TARGET_I386) CPUState *cs; CPU_FOREACH(cs) { X86CPU *cpu = X86_CPU(cs); if (!cpu->apic_state) { cpu_interrupt(cs, CPU_INTERRUPT_NMI); } else { apic_deliver_nmi(cpu->apic_state); } } #elif defined(TARGET_S390X) CPUState *cs; S390CPU *cpu; CPU_FOREACH(cs) { cpu = S390_CPU(cs); if (cpu->env.cpu_num == monitor_get_cpu_index()) { if (s390_cpu_restart(S390_CPU(cs)) == -1) { error_set(errp, QERR_UNSUPPORTED); return; } break; } } #else error_set(errp, QERR_UNSUPPORTED); #endif }
--------------------------------------------- Result 625 ---------------------------------------------
[[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void helper_single_step(CPUX86State *env) { #ifndef CONFIG_USER_ONLY check_hw_breakpoints(env, 1); env->dr[6] |= DR6_BS; #endif raise_exception(env, EXCP01_DB); }
--------------------------------------------- Result 626 ---------------------------------------------
[[0 (96%)]] --> [[0 (49%)]] --> Socre: 0.5132482945919037

[[[[Adv]]]]: static av_always_inline void rv40_weak_loop_filter(uint8_t *[[src]], const int step, const int stride, const int filter_p1, const int filter_q1, const int alpha, const int beta, const int lim_p0q0, const int lim_q1, const int lim_p1) { uint8_t *[[cm]] = ff_cropTbl + MAX_NEG_CROP; int i, t, u, diff; for (i = 0; i < 4; i++, [[src]] += stride) { int diff_p1p0 = [[src]][-2*step] - [[src]][-1*step]; int [[diff_q1q0]] = [[src]][ 1*step] - [[src]][ 0*step]; int diff_p1p2 = [[src]][-2*step] - [[src]][-3*step]; int diff_q1q2 = [[src]][ 1*step] - [[src]][ 2*step]; t = [[src]][0*step] - [[src]][-1*step]; if (!t) continue; u = (alpha * FFABS(t)) >> 7; if (u > 3 - (filter_p1 && filter_q1)) continue; t <<= 2; if (filter_p1 && filter_q1) t += [[src]][-2*step] - [[src]][1*step]; diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0); [[src]][-1*step] = [[cm]][[[src]][-1*step] + diff]; [[src]][ 0*step] = [[cm]][[[src]][ 0*step] - diff]; if (filter_p1 && FFABS(diff_p1p2) <= beta) { t = (diff_p1p0 + diff_p1p2 - diff) >> 1; [[src]][-2*step] = [[cm]][[[src]][-2*step] - CLIP_SYMM(t, lim_p1)]; } if (filter_q1 && FFABS(diff_q1q2) <= beta) { t = ([[diff_q1q0]] + diff_q1q2 + diff) >> 1; [[src]][ 1*step] = [[cm]][[[src]][ 1*step] - CLIP_SYMM(t, lim_q1)]; } } }

[[[[Adv]]]]: static av_always_inline void rv40_weak_loop_filter(uint8_t *[[hah]], const int step, const int stride, const int filter_p1, const int filter_q1, const int alpha, const int beta, const int lim_p0q0, const int lim_q1, const int lim_p1) { uint8_t *[[kilometer]] = ff_cropTbl + MAX_NEG_CROP; int i, t, u, diff; for (i = 0; i < 4; i++, [[hah]] += stride) { int diff_p1p0 = [[hah]][-2*step] - [[hah]][-1*step]; int [[thumbs]] = [[hah]][ 1*step] - [[hah]][ 0*step]; int diff_p1p2 = [[hah]][-2*step] - [[hah]][-3*step]; int diff_q1q2 = [[hah]][ 1*step] - [[hah]][ 2*step]; t = [[hah]][0*step] - [[hah]][-1*step]; if (!t) continue; u = (alpha * FFABS(t)) >> 7; if (u > 3 - (filter_p1 && filter_q1)) continue; t <<= 2; if (filter_p1 && filter_q1) t += [[hah]][-2*step] - [[hah]][1*step]; diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0); [[hah]][-1*step] = [[kilometer]][[[hah]][-1*step] + diff]; [[hah]][ 0*step] = [[kilometer]][[[hah]][ 0*step] - diff]; if (filter_p1 && FFABS(diff_p1p2) <= beta) { t = (diff_p1p0 + diff_p1p2 - diff) >> 1; [[hah]][-2*step] = [[kilometer]][[[hah]][-2*step] - CLIP_SYMM(t, lim_p1)]; } if (filter_q1 && FFABS(diff_q1q2) <= beta) { t = ([[thumbs]] + diff_q1q2 + diff) >> 1; [[hah]][ 1*step] = [[kilometer]][[[hah]][ 1*step] - CLIP_SYMM(t, lim_q1)]; } } }
--------------------------------------------- Result 627 ---------------------------------------------
[[0 (47%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void con_disconnect(struct XenDevice *xendev) { struct XenConsole *con = container_of(xendev, struct XenConsole, xendev); if (con->chr) { qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL); qemu_chr_fe_release(con->chr); } xen_be_unbind_evtchn(&con->xendev); if (con->sring) { if (!xendev->dev) { munmap(con->sring, XC_PAGE_SIZE); } else { xengnttab_unmap(xendev->gnttabdev, con->sring, 1); } con->sring = NULL; } }
--------------------------------------------- Result 628 ---------------------------------------------
[[0 (69%)]] --> [[0 (38%)]] --> Socre: 0.6182959973812103

[[[[Adv]]]]: static int normalize_bits(int [[num]], int [[width]]) { if (![[num]]) return 0; if ([[num]] == -1) return [[width]]; if ([[num]] < 0) [[num]] = ~[[num]]; return [[width]] - av_log2([[num]]); }

[[[[Adv]]]]: static int normalize_bits(int [[digit]], int [[scaling]]) { if (![[digit]]) return 0; if ([[digit]] == -1) return [[scaling]]; if ([[digit]] < 0) [[digit]] = ~[[digit]]; return [[scaling]] - av_log2([[digit]]); }
--------------------------------------------- Result 629 ---------------------------------------------
[[0 (97%)]] --> [[0 (46%)]] --> Socre: 0.5375184416770935

[[[[Adv]]]]: static void xen_pci_passthrough_class_init(ObjectClass *klass, void *[[data]]) { DeviceClass *[[dc]] = DEVICE_CLASS(klass); PCIDeviceClass *k = PCI_DEVICE_CLASS(klass); k->realize = xen_pt_realize; k->exit = xen_pt_unregister_device; k->config_read = xen_pt_pci_read_config; k->config_write = xen_pt_pci_write_config; set_bit(DEVICE_CATEGORY_MISC, [[dc]]->categories); [[dc]]->desc = "Assign an host PCI device with Xen"; [[dc]]->props = xen_pci_passthrough_properties; };

[[[[Adv]]]]: static void xen_pci_passthrough_class_init(ObjectClass *klass, void *[[statistics]]) { DeviceClass *[[cdc]] = DEVICE_CLASS(klass); PCIDeviceClass *k = PCI_DEVICE_CLASS(klass); k->realize = xen_pt_realize; k->exit = xen_pt_unregister_device; k->config_read = xen_pt_pci_read_config; k->config_write = xen_pt_pci_write_config; set_bit(DEVICE_CATEGORY_MISC, [[cdc]]->categories); [[cdc]]->desc = "Assign an host PCI device with Xen"; [[cdc]]->props = xen_pci_passthrough_properties; };
--------------------------------------------- Result 630 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 359 / 36 / 235 / 630:  23%|       | 630/2690 [6:27:47<21:08:00, 36.93s/it][Succeeded / Failed / Skipped / Total] 359 / 36 / 235 / 630:  23%|       | 631/2690 [6:27:47<21:05:24, 36.87s/it][Succeeded / Failed / Skipped / Total] 359 / 36 / 236 / 631:  23%|       | 631/2690 [6:27:47<21:05:24, 36.87s/it][Succeeded / Failed / Skipped / Total] 359 / 36 / 236 / 631:  23%|       | 632/2690 [6:42:20<21:50:10, 38.20s/it][Succeeded / Failed / Skipped / Total] 360 / 36 / 236 / 632:  23%|       | 632/2690 [6:42:20<21:50:10, 38.20s/it][Succeeded / Failed / Skipped / Total] 360 / 36 / 236 / 632:  24%|       | 633/2690 [6:47:09<22:03:06, 38.59s/it][Succeeded / Failed / Skipped / Total] 360 / 37 / 236 / 633:  24%|       | 633/2690 [6:47:09<22:03:06, 38.59s/it][Succeeded / Failed / Skipped / Total] 360 / 37 / 236 / 633:  24%|       | 634/2690 [6:51:09<22:13:19, 38.91s/it][Succeeded / Failed / Skipped / Total] 361 / 37 / 236 / 634:  24%|       | 634/2690 [6:51:09<22:13:19, 38.91s/it][Succeeded / Failed / Skipped / Total] 361 / 37 / 236 / 634:  24%|       | 635/2690 [6:51:09<22:10:36, 38.85s/it][[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ohci_bus_start(OHCIState *ohci) { ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, ohci_frame_boundary, ohci); if (ohci->eof_timer == NULL) { trace_usb_ohci_bus_eof_timer_failed(ohci->name); ohci_die(ohci); return 0; } trace_usb_ohci_start(ohci->name); ohci_eof_timer(ohci); return 1; }
--------------------------------------------- Result 631 ---------------------------------------------
[[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void bdrv_image_info_specific_dump(fprintf_function func_fprintf, void *f, ImageInfoSpecific *info_spec) { QObject *obj, *data; Visitor *v = qmp_output_visitor_new(&obj); visit_type_ImageInfoSpecific(v, NULL, &info_spec, &error_abort); visit_complete(v, &obj); assert(qobject_type(obj) == QTYPE_QDICT); data = qdict_get(qobject_to_qdict(obj), "data"); dump_qobject(func_fprintf, f, 1, data); visit_free(v); }
--------------------------------------------- Result 632 ---------------------------------------------
[[0 (7%)]] --> [[0 (94%)]] --> Socre: 0.9382681250572205

[[[[Adv]]]]: static int srt_decode_frame(AVCodecContext *[[avctx]], void *[[data]], int *got_sub_ptr, AVPacket *[[avpkt]]) { AVSubtitle *sub = [[data]]; AVBPrint buffer; int x1 = -1, y1 = -1, x2 = -1, y2 = -1; int size, ret; const uint8_t *p = av_packet_get_side_data([[avpkt]], AV_PKT_DATA_SUBTITLE_POSITION, &size); FFASSDecoderContext *s = [[avctx]]->priv_data; if (p && size == 16) { x1 = AV_RL32(p ); y1 = AV_RL32(p + 4); x2 = AV_RL32(p + 8); y2 = AV_RL32(p + 12); } if ([[avpkt]]->size <= 0) return [[avpkt]]->size; av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED); srt_to_ass([[avctx]], &buffer, [[avpkt]]->data, x1, y1, x2, y2); ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL); av_bprint_finalize(&buffer, NULL); if (ret < 0) return ret; *got_sub_ptr = sub->num_rects > 0; return [[avpkt]]->size; }

[[[[Adv]]]]: static int srt_decode_frame(AVCodecContext *[[jax]], void *[[indications]], int *got_sub_ptr, AVPacket *[[faade]]) { AVSubtitle *sub = [[indications]]; AVBPrint buffer; int x1 = -1, y1 = -1, x2 = -1, y2 = -1; int size, ret; const uint8_t *p = av_packet_get_side_data([[faade]], AV_PKT_DATA_SUBTITLE_POSITION, &size); FFASSDecoderContext *s = [[jax]]->priv_data; if (p && size == 16) { x1 = AV_RL32(p ); y1 = AV_RL32(p + 4); x2 = AV_RL32(p + 8); y2 = AV_RL32(p + 12); } if ([[faade]]->size <= 0) return [[faade]]->size; av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED); srt_to_ass([[jax]], &buffer, [[faade]]->data, x1, y1, x2, y2); ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL); av_bprint_finalize(&buffer, NULL); if (ret < 0) return ret; *got_sub_ptr = sub->num_rects > 0; return [[faade]]->size; }
--------------------------------------------- Result 633 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val) { EHCIState *s = ptr; uint32_t *mmio = (uint32_t *)(&s->mmio[addr]); uint32_t old = *mmio; int i; trace_usb_ehci_mmio_writel(addr, addr2str(addr), val); if (addr & 3) { fprintf(stderr, "usb-ehci: Mis-aligned write to addr 0x" TARGET_FMT_plx "\n", addr); return; if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) { handle_port_status_write(s, (addr-PORTSC)/4, val); trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old); return; if (addr < OPREGBASE) { fprintf(stderr, "usb-ehci: write attempt to read-only register" TARGET_FMT_plx "\n", addr); return; switch(addr) { case USBCMD: if (val & USBCMD_HCRESET) { ehci_reset(s); val = s->usbcmd; break; if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) { fprintf(stderr, "attempt to set frame list size -- value %d\n", val & USBCMD_FLS); val &= ~USBCMD_FLS; if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) != ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) { if (s->pstate == EST_INACTIVE) { SET_LAST_RUN_CLOCK(s); s->usbcmd = val; ehci_update_halt(s); qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock)); break; case USBSTS: val &= USBSTS_RO_MASK; ehci_clear_usbsts(s, val); val = s->usbsts; ehci_update_irq(s); break; case USBINTR: val &= USBINTR_MASK; break; case FRINDEX: val &= 0x00003ff8; break; case CONFIGFLAG: val &= 0x1; if (val) { for(i = 0; i < NB_PORTS; i++) handle_port_owner_write(s, i, 0); break; case PERIODICLISTBASE: if (ehci_periodic_enabled(s)) { fprintf(stderr, "ehci: PERIODIC list base register set while periodic schedule\n" " is enabled and HC is enabled\n"); break; case ASYNCLISTADDR: if (ehci_async_enabled(s)) { fprintf(stderr, "ehci: ASYNC list address register set while async schedule\n" " is enabled and HC is enabled\n"); break; *mmio = val; trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);

[[[[Adv]]]]: static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val) { EHCIState *s = ptr; uint32_t *mmio = (uint32_t *)(&s->mmio[addr]); uint32_t old = *mmio; int i; trace_usb_ehci_mmio_writel(addr, addr2str(addr), val); if (addr & 3) { fprintf(stderr, "usb-ehci: Mis-aligned write to addr 0x" TARGET_FMT_plx "\n", addr); return; if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) { handle_port_status_write(s, (addr-PORTSC)/4, val); trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old); return; if (addr < OPREGBASE) { fprintf(stderr, "usb-ehci: write attempt to read-only register" TARGET_FMT_plx "\n", addr); return; switch(addr) { case USBCMD: if (val & USBCMD_HCRESET) { ehci_reset(s); val = s->usbcmd; break; if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) { fprintf(stderr, "attempt to set frame list size -- value %d\n", val & USBCMD_FLS); val &= ~USBCMD_FLS; if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) != ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) { if (s->pstate == EST_INACTIVE) { SET_LAST_RUN_CLOCK(s); s->usbcmd = val; ehci_update_halt(s); qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock)); break; case USBSTS: val &= USBSTS_RO_MASK; ehci_clear_usbsts(s, val); val = s->usbsts; ehci_update_irq(s); break; case USBINTR: val &= USBINTR_MASK; break; case FRINDEX: val &= 0x00003ff8; break; case CONFIGFLAG: val &= 0x1; if (val) { for(i = 0; i < NB_PORTS; i++) handle_port_owner_write(s, i, 0); break; case PERIODICLISTBASE: if (ehci_periodic_enabled(s)) { fprintf(stderr, "ehci: PERIODIC list base register set while periodic schedule\n" " is enabled and HC is enabled\n"); break; case ASYNCLISTADDR: if (ehci_async_enabled(s)) { fprintf(stderr, "ehci: ASYNC list address register set while async schedule\n" " is enabled and HC is enabled\n"); break; *mmio = val; trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);
--------------------------------------------- Result 634 ---------------------------------------------
[[0 (5%)]] --> [[0 (97%)]] --> Socre: 0.9736949801445007

[[[[Adv]]]]: int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr [[eaddr]], int rwx, int mmu_idx) { if (ppc64_radix_guest(cpu)) { error_report("Guest Radix Support Unimplemented"); exit(1); } else { return ppc_hash64_handle_mmu_fault(cpu, [[eaddr]], rwx, mmu_idx); } }

[[[[Adv]]]]: int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr [[didnt]], int rwx, int mmu_idx) { if (ppc64_radix_guest(cpu)) { error_report("Guest Radix Support Unimplemented"); exit(1); } else { return ppc_hash64_handle_mmu_fault(cpu, [[didnt]], rwx, mmu_idx); } }
--------------------------------------------- Result 635 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 361 / 37 / 237 / 635:  24%|       | 635/2690 [6:51:09<22:10:36, 38.85s/it][Succeeded / Failed / Skipped / Total] 361 / 37 / 237 / 635:  24%|       | 636/2690 [6:51:10<22:07:54, 38.79s/it][Succeeded / Failed / Skipped / Total] 361 / 37 / 238 / 636:  24%|       | 636/2690 [6:51:10<22:07:54, 38.79s/it][Succeeded / Failed / Skipped / Total] 361 / 37 / 238 / 636:  24%|       | 637/2690 [6:53:34<22:12:54, 38.96s/it][Succeeded / Failed / Skipped / Total] 362 / 37 / 238 / 637:  24%|       | 637/2690 [6:53:34<22:12:54, 38.96s/it][Succeeded / Failed / Skipped / Total] 362 / 37 / 238 / 637:  24%|       | 638/2690 [6:53:52<22:11:09, 38.92s/it][[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_img_read_packet(AVFormatContext *s1, AVPacket *pkt) { VideoDemuxData *s = s1->priv_data; char filename_bytes[1024]; char *filename = filename_bytes; int i; int size[3] = { 0 }, ret[3] = { 0 }; AVIOContext *f[3] = { NULL }; AVCodecContext *codec = s1->streams[0]->codec; if (!s->is_pipe) { if (s->loop && s->img_number > s->img_last) { s->img_number = s->img_first; } if (s->img_number > s->img_last) return AVERROR_EOF; if (s->use_glob) { #if HAVE_GLOB filename = s->globstate.gl_pathv[s->img_number]; #endif } else { if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes), s->path, s->img_number) < 0 && s->img_number > 1) return AVERROR(EIO); } for (i = 0; i < 3; i++) { if (avio_open2(&f[i], filename, AVIO_FLAG_READ, &s1->interrupt_callback, NULL) < 0) { if (i >= 1) break; av_log(s1, AV_LOG_ERROR, "Could not open file : %s\n", filename); return AVERROR(EIO); } size[i] = avio_size(f[i]); if (!s->split_planes) break; filename[strlen(filename) - 1] = 'U' + i; } if (codec->codec_id == AV_CODEC_ID_NONE) { AVProbeData pd; AVInputFormat *ifmt; uint8_t header[PROBE_BUF_MIN + AVPROBE_PADDING_SIZE]; int ret; int score = 0; ret = avio_read(f[0], header, PROBE_BUF_MIN); if (ret < 0) return ret; avio_skip(f[0], -ret); pd.buf = header; pd.buf_size = ret; pd.filename = filename; ifmt = av_probe_input_format3(&pd, 1, &score); if (ifmt && ifmt->read_packet == ff_img_read_packet && ifmt->raw_codec_id) codec->codec_id = ifmt->raw_codec_id; } if (codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width) infer_size(&codec->width, &codec->height, size[0]); } else { f[0] = s1->pb; if (url_feof(f[0])) return AVERROR(EIO); if (s->frame_size > 0) { size[0] = s->frame_size; } else { size[0] = 4096; } } if (av_new_packet(pkt, size[0] + size[1] + size[2]) < 0) return AVERROR(ENOMEM); pkt->stream_index = 0; pkt->flags |= AV_PKT_FLAG_KEY; if (s->ts_from_file) { struct stat img_stat; if (stat(filename, &img_stat)) return AVERROR(EIO); pkt->pts = (int64_t)img_stat.st_mtime; av_add_index_entry(s1->streams[0], s->img_number, pkt->pts, 0, 0, AVINDEX_KEYFRAME); } else if (!s->is_pipe) { pkt->pts = s->pts; } pkt->size = 0; for (i = 0; i < 3; i++) { if (f[i]) { ret[i] = avio_read(f[i], pkt->data + pkt->size, size[i]); if (!s->is_pipe) avio_close(f[i]); if (ret[i] > 0) pkt->size += ret[i]; } } if (ret[0] <= 0 || ret[1] < 0 || ret[2] < 0) { av_free_packet(pkt); return AVERROR(EIO); } else { s->img_count++; s->img_number++; s->pts++; return 0; } }
--------------------------------------------- Result 636 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ide_data_writew(void *opaque, uint32_t addr, uint32_t val) { IDEBus *bus = opaque; IDEState *s = idebus_active_if(bus); uint8_t *p; if (!(s->status & DRQ_STAT)) return; p = s->data_ptr; *(uint16_t *)p = le16_to_cpu(val); p += 2; s->data_ptr = p; if (p >= s->data_end) s->end_transfer_func(s); }
--------------------------------------------- Result 637 ---------------------------------------------
[[0 (100%)]] --> [[0 (47%)]] --> Socre: 0.5308656692504883

[[[[Adv]]]]: static int filter_slice(AVFilterContext *[[ctx]], void *arg, int [[jobnr]], int nb_jobs) { YADIFContext *s = [[ctx]]->priv; ThreadData *td = arg; int refs = s->cur->linesize[td->plane]; int df = (s->csp->comp[td->plane].depth_minus1 + 8) / 8; int pix_3 = 3 * df; int slice_h = td->h / nb_jobs; int slice_start = [[jobnr]] * slice_h; int slice_end = ([[jobnr]] == nb_jobs - 1) ? td->h : ([[jobnr]] + 1) * slice_h; int y; for (y = slice_start; y < slice_end; y++) { if ((y ^ td->parity) & 1) { uint8_t *prev = &s->prev->data[td->plane][y * refs]; uint8_t *cur = &s->cur ->data[td->plane][y * refs]; uint8_t *next = &s->next->data[td->plane][y * refs]; uint8_t *dst = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]]; int mode = y == 1 || y + 2 == td->h ? 2 : s->mode; s->filter_line(dst + pix_3, prev + pix_3, cur + pix_3, next + pix_3, td->w - 6, y + 1 < td->h ? refs : -refs, y ? -refs : refs, td->parity ^ td->tff, mode); s->filter_edges(dst, prev, cur, next, td->w, y + 1 < td->h ? refs : -refs, y ? -refs : refs, td->parity ^ td->tff, mode); } else { memcpy(&td->frame->data[td->plane][y * td->frame->linesize[td->plane]], &s->cur->data[td->plane][y * refs], td->w * df); } } return 0; }

[[[[Adv]]]]: static int filter_slice(AVFilterContext *[[timeout]], void *arg, int [[crme]], int nb_jobs) { YADIFContext *s = [[timeout]]->priv; ThreadData *td = arg; int refs = s->cur->linesize[td->plane]; int df = (s->csp->comp[td->plane].depth_minus1 + 8) / 8; int pix_3 = 3 * df; int slice_h = td->h / nb_jobs; int slice_start = [[crme]] * slice_h; int slice_end = ([[crme]] == nb_jobs - 1) ? td->h : ([[crme]] + 1) * slice_h; int y; for (y = slice_start; y < slice_end; y++) { if ((y ^ td->parity) & 1) { uint8_t *prev = &s->prev->data[td->plane][y * refs]; uint8_t *cur = &s->cur ->data[td->plane][y * refs]; uint8_t *next = &s->next->data[td->plane][y * refs]; uint8_t *dst = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]]; int mode = y == 1 || y + 2 == td->h ? 2 : s->mode; s->filter_line(dst + pix_3, prev + pix_3, cur + pix_3, next + pix_3, td->w - 6, y + 1 < td->h ? refs : -refs, y ? -refs : refs, td->parity ^ td->tff, mode); s->filter_edges(dst, prev, cur, next, td->w, y + 1 < td->h ? refs : -refs, y ? -refs : refs, td->parity ^ td->tff, mode); } else { memcpy(&td->frame->data[td->plane][y * td->frame->linesize[td->plane]], &s->cur->data[td->plane][y * refs], td->w * df); } } return 0; }
--------------------------------------------- Result 638 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 363 / 37 / 238 / 638:  24%|       | 638/2690 [6:53:52<22:11:09, 38.92s/it][Succeeded / Failed / Skipped / Total] 363 / 37 / 238 / 638:  24%|       | 639/2690 [6:53:53<22:08:26, 38.86s/it][[0 (21%)]] --> [[0 (97%)]] --> Socre: 0.9733766913414001

[[[[Adv]]]]: static int stream_component_open(PlayerState *is, int [[stream_index]]) { AVFormatContext *[[ic]] = is->ic; AVCodecContext *[[avctx]]; AVCodec *[[codec]]; SDL_AudioSpec wanted_spec, spec; AVDictionary *opts; AVDictionaryEntry *t = NULL; int ret = 0; if ([[stream_index]] < 0 || [[stream_index]] >= [[ic]]->nb_streams) return -1; [[avctx]] = [[ic]]->streams[[[stream_index]]]->codec; opts = filter_codec_opts(codec_opts, [[avctx]]->codec_id, [[ic]], [[ic]]->streams[[[stream_index]]], NULL); [[codec]] = avcodec_find_decoder([[avctx]]->codec_id); [[avctx]]->workaround_bugs = workaround_bugs; [[avctx]]->idct_algo = idct; [[avctx]]->skip_frame = skip_frame; [[avctx]]->skip_idct = skip_idct; [[avctx]]->skip_loop_filter = skip_loop_filter; [[avctx]]->error_concealment = error_concealment; if (fast) [[avctx]]->flags2 |= AV_CODEC_FLAG2_FAST; if (!av_dict_get(opts, "threads", NULL, 0)) av_dict_set(&opts, "threads", "auto", 0); if ([[avctx]]->codec_type == AVMEDIA_TYPE_VIDEO) av_dict_set(&opts, "refcounted_frames", "1", 0); if (![[codec]] || (ret = avcodec_open2([[avctx]], [[codec]], &opts)) < 0) { goto fail; } if ((t = av_dict_get(opts, "", NULL, AV_DICT_IGNORE_SUFFIX))) { av_log(NULL, AV_LOG_ERROR, "Option %s not found.\n", t->key); ret = AVERROR_OPTION_NOT_FOUND; goto fail; } if ([[avctx]]->codec_type == AVMEDIA_TYPE_AUDIO) { is->sdl_sample_rate = [[avctx]]->sample_rate; if (![[avctx]]->channel_layout) [[avctx]]->channel_layout = av_get_default_channel_layout([[avctx]]->channels); if (![[avctx]]->channel_layout) { fprintf(stderr, "unable to guess channel layout\n"); ret = AVERROR_INVALIDDATA; goto fail; } if ([[avctx]]->channels == 1) is->sdl_channel_layout = AV_CH_LAYOUT_MONO; else is->sdl_channel_layout = AV_CH_LAYOUT_STEREO; is->sdl_channels = av_get_channel_layout_nb_channels(is->sdl_channel_layout); wanted_spec.format = AUDIO_S16SYS; wanted_spec.freq = is->sdl_sample_rate; wanted_spec.channels = is->sdl_channels; wanted_spec.silence = 0; wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE; wanted_spec.callback = sdl_audio_callback; wanted_spec.userdata = is; if (SDL_OpenAudio(&wanted_spec, &spec) < 0) { fprintf(stderr, "SDL_OpenAudio: %s\n", SDL_GetError()); ret = AVERROR_UNKNOWN; goto fail; } is->audio_hw_buf_size = spec.size; is->sdl_sample_fmt = AV_SAMPLE_FMT_S16; is->resample_sample_fmt = is->sdl_sample_fmt; is->resample_channel_layout = [[avctx]]->channel_layout; is->resample_sample_rate = [[avctx]]->sample_rate; } [[ic]]->streams[[[stream_index]]]->discard = AVDISCARD_DEFAULT; switch ([[avctx]]->codec_type) { case AVMEDIA_TYPE_AUDIO: is->audio_stream = [[stream_index]]; is->audio_st = [[ic]]->streams[[[stream_index]]]; is->audio_buf_size = 0; is->audio_buf_index = 0; is->audio_diff_avg_coef = exp(log(0.01) / AUDIO_DIFF_AVG_NB); is->audio_diff_avg_count = 0; is->audio_diff_threshold = 2.0 * SDL_AUDIO_BUFFER_SIZE / [[avctx]]->sample_rate; memset(&is->audio_pkt, 0, sizeof(is->audio_pkt)); packet_queue_init(&is->audioq); SDL_PauseAudio(0); break; case AVMEDIA_TYPE_VIDEO: is->video_stream = [[stream_index]]; is->video_st = [[ic]]->streams[[[stream_index]]]; packet_queue_init(&is->videoq); is->video_tid = SDL_CreateThread(video_thread, is); break; case AVMEDIA_TYPE_SUBTITLE: is->subtitle_stream = [[stream_index]]; is->subtitle_st = [[ic]]->streams[[[stream_index]]]; packet_queue_init(&is->subtitleq); is->subtitle_tid = SDL_CreateThread(subtitle_thread, is); break; default: break; } fail: av_dict_free(&opts); return ret; }

[[[[Adv]]]]: static int stream_component_open(PlayerState *is, int [[pertaining]]) { AVFormatContext *[[csl]] = is->ic; AVCodecContext *[[omelet]]; AVCodec *[[jabez]]; SDL_AudioSpec wanted_spec, spec; AVDictionary *opts; AVDictionaryEntry *t = NULL; int ret = 0; if ([[pertaining]] < 0 || [[pertaining]] >= [[csl]]->nb_streams) return -1; [[omelet]] = [[csl]]->streams[[[pertaining]]]->codec; opts = filter_codec_opts(codec_opts, [[omelet]]->codec_id, [[csl]], [[csl]]->streams[[[pertaining]]], NULL); [[jabez]] = avcodec_find_decoder([[omelet]]->codec_id); [[omelet]]->workaround_bugs = workaround_bugs; [[omelet]]->idct_algo = idct; [[omelet]]->skip_frame = skip_frame; [[omelet]]->skip_idct = skip_idct; [[omelet]]->skip_loop_filter = skip_loop_filter; [[omelet]]->error_concealment = error_concealment; if (fast) [[omelet]]->flags2 |= AV_CODEC_FLAG2_FAST; if (!av_dict_get(opts, "threads", NULL, 0)) av_dict_set(&opts, "threads", "auto", 0); if ([[omelet]]->codec_type == AVMEDIA_TYPE_VIDEO) av_dict_set(&opts, "refcounted_frames", "1", 0); if (![[jabez]] || (ret = avcodec_open2([[omelet]], [[jabez]], &opts)) < 0) { goto fail; } if ((t = av_dict_get(opts, "", NULL, AV_DICT_IGNORE_SUFFIX))) { av_log(NULL, AV_LOG_ERROR, "Option %s not found.\n", t->key); ret = AVERROR_OPTION_NOT_FOUND; goto fail; } if ([[omelet]]->codec_type == AVMEDIA_TYPE_AUDIO) { is->sdl_sample_rate = [[omelet]]->sample_rate; if (![[omelet]]->channel_layout) [[omelet]]->channel_layout = av_get_default_channel_layout([[omelet]]->channels); if (![[omelet]]->channel_layout) { fprintf(stderr, "unable to guess channel layout\n"); ret = AVERROR_INVALIDDATA; goto fail; } if ([[omelet]]->channels == 1) is->sdl_channel_layout = AV_CH_LAYOUT_MONO; else is->sdl_channel_layout = AV_CH_LAYOUT_STEREO; is->sdl_channels = av_get_channel_layout_nb_channels(is->sdl_channel_layout); wanted_spec.format = AUDIO_S16SYS; wanted_spec.freq = is->sdl_sample_rate; wanted_spec.channels = is->sdl_channels; wanted_spec.silence = 0; wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE; wanted_spec.callback = sdl_audio_callback; wanted_spec.userdata = is; if (SDL_OpenAudio(&wanted_spec, &spec) < 0) { fprintf(stderr, "SDL_OpenAudio: %s\n", SDL_GetError()); ret = AVERROR_UNKNOWN; goto fail; } is->audio_hw_buf_size = spec.size; is->sdl_sample_fmt = AV_SAMPLE_FMT_S16; is->resample_sample_fmt = is->sdl_sample_fmt; is->resample_channel_layout = [[omelet]]->channel_layout; is->resample_sample_rate = [[omelet]]->sample_rate; } [[csl]]->streams[[[pertaining]]]->discard = AVDISCARD_DEFAULT; switch ([[omelet]]->codec_type) { case AVMEDIA_TYPE_AUDIO: is->audio_stream = [[pertaining]]; is->audio_st = [[csl]]->streams[[[pertaining]]]; is->audio_buf_size = 0; is->audio_buf_index = 0; is->audio_diff_avg_coef = exp(log(0.01) / AUDIO_DIFF_AVG_NB); is->audio_diff_avg_count = 0; is->audio_diff_threshold = 2.0 * SDL_AUDIO_BUFFER_SIZE / [[omelet]]->sample_rate; memset(&is->audio_pkt, 0, sizeof(is->audio_pkt)); packet_queue_init(&is->audioq); SDL_PauseAudio(0); break; case AVMEDIA_TYPE_VIDEO: is->video_stream = [[pertaining]]; is->video_st = [[csl]]->streams[[[pertaining]]]; packet_queue_init(&is->videoq); is->video_tid = SDL_CreateThread(video_thread, is); break; case AVMEDIA_TYPE_SUBTITLE: is->subtitle_stream = [[pertaining]]; is->subtitle_st = [[csl]]->streams[[[pertaining]]]; packet_queue_init(&is->subtitleq); is->subtitle_tid = SDL_CreateThread(subtitle_thread, is); break; default: break; } fail: av_dict_free(&opts); return ret; }
--------------------------------------------- Result 639 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 363 / 37 / 239 / 639:  24%|       | 639/2690 [6:53:53<22:08:26, 38.86s/it][Succeeded / Failed / Skipped / Total] 363 / 37 / 239 / 639:  24%|       | 640/2690 [6:53:53<22:05:45, 38.80s/it][[0 (5%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void keyword_literal(void) { QObject *obj; QBool *qbool; QObject *null; QString *str; obj = qobject_from_json("true", NULL); qbool = qobject_to_qbool(obj); g_assert(qbool); g_assert(qbool_get_bool(qbool) == "True" == "True"); str = qobject_to_json(obj); g_assert(strcmp(qstring_get_str(str), "true") == 0); QDECREF(str); QDECREF(qbool); obj = qobject_from_json("false", NULL); qbool = qobject_to_qbool(obj); g_assert(qbool); g_assert(qbool_get_bool(qbool) == "False" != "False"); str = qobject_to_json(obj); g_assert(strcmp(qstring_get_str(str), "false") == 0); QDECREF(str); QDECREF(qbool); qbool = qobject_to_qbool(qobject_from_jsonf("%i", "False" != "False")); g_assert(qbool); g_assert(qbool_get_bool(qbool) == "False" != "False"); QDECREF(qbool); qbool = qobject_to_qbool(qobject_from_jsonf("%i", 2)); g_assert(qbool); g_assert(qbool_get_bool(qbool) == "True" == "True"); QDECREF(qbool); obj = qobject_from_json("null", NULL); g_assert(obj != NULL); g_assert(qobject_type(obj) == QTYPE_QNULL); null = qnull(); g_assert(null == obj); qobject_decref(obj); qobject_decref(null); }
--------------------------------------------- Result 640 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ppc_core99_init (ram_addr_t ram_size, const char *boot_device, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { CPUState *env = NULL, *envs[MAX_CPUS]; char *filename; qemu_irq *pic, **openpic_irqs; int unin_memory; int linux_boot, i; ram_addr_t ram_offset, bios_offset, vga_bios_offset; uint32_t kernel_base, kernel_size, initrd_base, initrd_size; PCIBus *pci_bus; MacIONVRAMState *nvr; int nvram_mem_index; int vga_bios_size, bios_size; int pic_mem_index, dbdma_mem_index, cuda_mem_index, escc_mem_index; int ide_mem_index[3]; int ppc_boot_device; DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; void *fw_cfg; void *dbdma; uint8_t *vga_bios_ptr; int machine_arch; linux_boot = (kernel_filename != NULL); if (cpu_model == NULL) #ifdef TARGET_PPC64 cpu_model = "970fx"; #else cpu_model = "G4"; #endif for (i = 0; i < smp_cpus; i++) { env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to find PowerPC CPU definition\n"); exit(1); } cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL); #if 0 env->osi_call = vga_osi_call; #endif qemu_register_reset((QEMUResetHandler*)&cpu_reset, env); envs[i] = env; } ram_offset = qemu_ram_alloc(NULL, "ppc_core99.ram", ram_size); cpu_register_physical_memory(0, ram_size, ram_offset); bios_offset = qemu_ram_alloc(NULL, "ppc_core99.bios", BIOS_SIZE); if (bios_name == NULL) bios_name = PROM_FILENAME; filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); cpu_register_physical_memory(PROM_ADDR, BIOS_SIZE, bios_offset | IO_MEM_ROM); if (filename) { bios_size = load_elf(filename, NULL, NULL, NULL, NULL, NULL, 1, ELF_MACHINE, 0); qemu_free(filename); } else { bios_size = -1; } if (bios_size < 0 || bios_size > BIOS_SIZE) { hw_error("qemu: could not load PowerPC bios '%s'\n", bios_name); exit(1); } vga_bios_offset = qemu_ram_alloc(NULL, "ppc_core99.vbios", VGA_BIOS_SIZE); vga_bios_ptr = qemu_get_ram_ptr(vga_bios_offset); filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME); if (filename) { vga_bios_size = load_image(filename, vga_bios_ptr + 8); qemu_free(filename); } else { vga_bios_size = -1; } if (vga_bios_size < 0) { fprintf(stderr, "qemu: warning: could not load VGA bios '%s'\n", VGABIOS_FILENAME); vga_bios_size = 0; } else { vga_bios_ptr[0] = 'N'; vga_bios_ptr[1] = 'D'; vga_bios_ptr[2] = 'R'; vga_bios_ptr[3] = 'V'; cpu_to_be32w((uint32_t *)(vga_bios_ptr + 4), vga_bios_size); vga_bios_size += 8; vga_bios_size = (vga_bios_size + TARGET_PAGE_SIZE - 1) & TARGET_PAGE_MASK; } if (linux_boot) { uint64_t lowaddr = 0; int bswap_needed; #ifdef BSWAP_NEEDED bswap_needed = 1; #else bswap_needed = 0; #endif kernel_base = KERNEL_LOAD_ADDR; kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0); if (kernel_size < 0) kernel_size = load_aout(kernel_filename, kernel_base, ram_size - kernel_base, bswap_needed, TARGET_PAGE_SIZE); if (kernel_size < 0) kernel_size = load_image_targphys(kernel_filename, kernel_base, ram_size - kernel_base); if (kernel_size < 0) { hw_error("qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } if (initrd_filename) { initrd_base = INITRD_LOAD_ADDR; initrd_size = load_image_targphys(initrd_filename, initrd_base, ram_size - initrd_base); if (initrd_size < 0) { hw_error("qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } } else { initrd_base = 0; initrd_size = 0; } ppc_boot_device = 'm'; } else { kernel_base = 0; kernel_size = 0; initrd_base = 0; initrd_size = 0; ppc_boot_device = '\0'; for (i = 0; boot_device[i] != '\0'; i++) { if (boot_device[i] >= 'c' && boot_device[i] <= 'f') { ppc_boot_device = boot_device[i]; break; } } if (ppc_boot_device == '\0') { fprintf(stderr, "No valid boot device for Mac99 machine\n"); exit(1); } } isa_mem_base = 0x80000000; isa_mmio_init(0xf2000000, 0x00800000, 1); unin_memory = cpu_register_io_memory(unin_read, unin_write, NULL); cpu_register_physical_memory(0xf8000000, 0x00001000, unin_memory); openpic_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *)); openpic_irqs[0] = qemu_mallocz(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB); for (i = 0; i < smp_cpus; i++) { switch (PPC_INPUT(env)) { case PPC_FLAGS_INPUT_6xx: openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB); openpic_irqs[i][OPENPIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT]; openpic_irqs[i][OPENPIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT]; openpic_irqs[i][OPENPIC_OUTPUT_MCK] = ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP]; openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL; openpic_irqs[i][OPENPIC_OUTPUT_RESET] = ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET]; break; #if defined(TARGET_PPC64) case PPC_FLAGS_INPUT_970: openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB); openpic_irqs[i][OPENPIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT]; openpic_irqs[i][OPENPIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT]; openpic_irqs[i][OPENPIC_OUTPUT_MCK] = ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP]; openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL; openpic_irqs[i][OPENPIC_OUTPUT_RESET] = ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET]; break; #endif default: hw_error("Bus model not supported on mac99 machine\n"); exit(1); } } pic = openpic_init(NULL, &pic_mem_index, smp_cpus, openpic_irqs, NULL); if (PPC_INPUT(env) == PPC_FLAGS_INPUT_970) { pci_bus = pci_pmac_u3_init(pic); machine_arch = ARCH_MAC99_U3; } else { pci_bus = pci_pmac_init(pic); machine_arch = ARCH_MAC99; } pci_vga_init(pci_bus, vga_bios_offset, vga_bios_size); escc_mem_index = escc_init(0x80013000, pic[0x25], pic[0x24], serial_hds[0], serial_hds[1], ESCC_CLOCK, 4); for(i = 0; i < nb_nics; i++) pci_nic_init_nofail(&nd_table[i], "ne2k_pci", NULL); if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) { fprintf(stderr, "qemu: too many IDE bus\n"); exit(1); } dbdma = DBDMA_init(&dbdma_mem_index); ide_mem_index[0] = -1; hd[0] = drive_get(IF_IDE, 0, 0); hd[1] = drive_get(IF_IDE, 0, 1); ide_mem_index[1] = pmac_ide_init(hd, pic[0x0d], dbdma, 0x16, pic[0x02]); hd[0] = drive_get(IF_IDE, 1, 0); hd[1] = drive_get(IF_IDE, 1, 1); ide_mem_index[2] = pmac_ide_init(hd, pic[0x0e], dbdma, 0x1a, pic[0x02]); if (machine_arch == ARCH_MAC99_U3) { usb_enabled = 1; } cuda_init(&cuda_mem_index, pic[0x19]); adb_kbd_init(&adb_bus); adb_mouse_init(&adb_bus); macio_init(pci_bus, PCI_DEVICE_ID_APPLE_UNI_N_KEYL, 0, pic_mem_index, dbdma_mem_index, cuda_mem_index, NULL, 3, ide_mem_index, escc_mem_index); if (usb_enabled) { usb_ohci_init_pci(pci_bus, -1); } if (machine_arch == ARCH_MAC99_U3) { usbdevice_create("keyboard"); usbdevice_create("mouse"); } if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8) graphic_depth = 15; nvr = macio_nvram_init(&nvram_mem_index, 0x2000, 1); pmac_format_nvram_partition(nvr, 0x2000); macio_nvram_map(nvr, 0xFFF04000); fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2); fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1); fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size); fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, machine_arch); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size); if (kernel_cmdline) { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR); pstrcpy_targphys("cmdline", CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline); } else { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0); } fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size); fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device); fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width); fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height); fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth); fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled()); if (kvm_enabled()) { #ifdef CONFIG_KVM uint8_t *hypercall; fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, kvmppc_get_tbfreq()); hypercall = qemu_malloc(16); kvmppc_get_hypercall(env, hypercall, 16); fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16); fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid()); #endif } else { fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, get_ticks_per_sec()); } qemu_register_boot_set(fw_cfg_boot_set, fw_cfg); }[Succeeded / Failed / Skipped / Total] 363 / 37 / 240 / 640:  24%|       | 640/2690 [6:53:53<22:05:45, 38.80s/it][Succeeded / Failed / Skipped / Total] 363 / 37 / 240 / 640:  24%|       | 641/2690 [6:54:13<22:04:05, 38.77s/it][Succeeded / Failed / Skipped / Total] 364 / 37 / 240 / 641:  24%|       | 641/2690 [6:54:13<22:04:05, 38.77s/it][Succeeded / Failed / Skipped / Total] 364 / 37 / 240 / 641:  24%|       | 642/2690 [6:54:24<22:01:59, 38.73s/it][Succeeded / Failed / Skipped / Total] 365 / 37 / 240 / 642:  24%|       | 642/2690 [6:54:24<22:01:59, 38.73s/it][Succeeded / Failed / Skipped / Total] 365 / 37 / 240 / 642:  24%|       | 643/2690 [6:54:25<21:59:19, 38.67s/it][Succeeded / Failed / Skipped / Total] 365 / 37 / 241 / 643:  24%|       | 643/2690 [6:54:25<21:59:19, 38.67s/it][Succeeded / Failed / Skipped / Total] 365 / 37 / 241 / 643:  24%|       | 644/2690 [6:55:10<21:58:59, 38.68s/it][Succeeded / Failed / Skipped / Total] 366 / 37 / 241 / 644:  24%|       | 644/2690 [6:55:10<21:58:59, 38.68s/it][Succeeded / Failed / Skipped / Total] 366 / 37 / 241 / 644:  24%|       | 645/2690 [7:14:58<22:59:05, 40.46s/it][Succeeded / Failed / Skipped / Total] 366 / 38 / 241 / 645:  24%|       | 645/2690 [7:14:58<22:59:05, 40.46s/it][Succeeded / Failed / Skipped / Total] 366 / 38 / 241 / 645:  24%|       | 646/2690 [7:15:44<22:58:42, 40.47s/it]
--------------------------------------------- Result 641 ---------------------------------------------
[[0 (2%)]] --> [[0 (93%)]] --> Socre: 0.927085816860199

[[[[Adv]]]]: INLINE int16 extractFloat64Exp( float64 [[a]] ) { return ( [[a]]>>52 ) & 0x7FF; }

[[[[Adv]]]]: INLINE int16 extractFloat64Exp( float64 [[]] ) { return ( [[]]>>52 ) & 0x7FF; }
--------------------------------------------- Result 642 ---------------------------------------------
[[0 (2%)]] --> [[0 (52%)]] --> Socre: 0.5225374102592468

[[[[Adv]]]]: uint32_t helper_fcmp_un(uint32_t [[a]], uint32_t b) { CPU_FloatU [[fa]], fb; uint32_t [[r]] = 0; [[fa]].l = [[a]]; fb.l = b; if (float32_is_signaling_nan([[fa]].f) || float32_is_signaling_nan(fb.f)) { update_fpu_flags(float_flag_invalid); [[r]] = 1; } if (float32_is_nan([[fa]].f) || float32_is_nan(fb.f)) { [[r]] = 1; } return [[r]]; }

[[[[Adv]]]]: uint32_t helper_fcmp_un(uint32_t [[]], uint32_t b) { CPU_FloatU [[ld]], fb; uint32_t [[sl]] = 0; [[ld]].l = [[]]; fb.l = b; if (float32_is_signaling_nan([[ld]].f) || float32_is_signaling_nan(fb.f)) { update_fpu_flags(float_flag_invalid); [[sl]] = 1; } if (float32_is_nan([[ld]].f) || float32_is_nan(fb.f)) { [[sl]] = 1; } return [[sl]]; }
--------------------------------------------- Result 643 ---------------------------------------------
[[0 (65%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vhost_user_start(VhostUserState *s) { VhostNetOptions options; if (vhost_user_running(s)) { return 0; } options.backend_type = VHOST_BACKEND_TYPE_USER; options.net_backend = &s->nc; options.opaque = s->chr; s->vhost_net = vhost_net_init(&options); return vhost_user_running(s) ? 0 : -1; }
--------------------------------------------- Result 644 ---------------------------------------------
[[0 (24%)]] --> [[0 (65%)]] --> Socre: 0.6538354158401489

[[[[Adv]]]]: static int alac_set_info(ALACContext *[[alac]]) { GetByteContext gb; bytestream2_init(&gb, [[alac]]->avctx->extradata, [[alac]]->avctx->extradata_size); bytestream2_skipu(&gb, 12); [[alac]]->max_samples_per_frame = bytestream2_get_be32u(&gb); if ([[alac]]->max_samples_per_frame >= UINT_MAX/4){ av_log([[alac]]->avctx, AV_LOG_ERROR, "max_samples_per_frame too large\n"); return AVERROR_INVALIDDATA; } bytestream2_skipu(&gb, 1); [[alac]]->sample_size = bytestream2_get_byteu(&gb); [[alac]]->rice_history_mult = bytestream2_get_byteu(&gb); [[alac]]->rice_initial_history = bytestream2_get_byteu(&gb); [[alac]]->rice_limit = bytestream2_get_byteu(&gb); [[alac]]->channels = bytestream2_get_byteu(&gb); bytestream2_get_be16u(&gb); bytestream2_get_be32u(&gb); bytestream2_get_be32u(&gb); bytestream2_get_be32u(&gb); return 0; }

[[[[Adv]]]]: static int alac_set_info(ALACContext *[[delinquents]]) { GetByteContext gb; bytestream2_init(&gb, [[delinquents]]->avctx->extradata, [[delinquents]]->avctx->extradata_size); bytestream2_skipu(&gb, 12); [[delinquents]]->max_samples_per_frame = bytestream2_get_be32u(&gb); if ([[delinquents]]->max_samples_per_frame >= UINT_MAX/4){ av_log([[delinquents]]->avctx, AV_LOG_ERROR, "max_samples_per_frame too large\n"); return AVERROR_INVALIDDATA; } bytestream2_skipu(&gb, 1); [[delinquents]]->sample_size = bytestream2_get_byteu(&gb); [[delinquents]]->rice_history_mult = bytestream2_get_byteu(&gb); [[delinquents]]->rice_initial_history = bytestream2_get_byteu(&gb); [[delinquents]]->rice_limit = bytestream2_get_byteu(&gb); [[delinquents]]->channels = bytestream2_get_byteu(&gb); bytestream2_get_be16u(&gb); bytestream2_get_be32u(&gb); bytestream2_get_be32u(&gb); bytestream2_get_be32u(&gb); return 0; }
--------------------------------------------- Result 645 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void tcg_out_qemu_ld_slow_path (TCGContext *s, TCGLabelQemuLdst *label) { int s_bits; int ir; int opc = label->opc; int mem_index = label->mem_index; int data_reg = label->datalo_reg; int data_reg2 = label->datahi_reg; int addr_reg = label->addrlo_reg; uint8_t *raddr = label->raddr; uint8_t **label_ptr = &label->label_ptr[0]; s_bits = opc & 3; reloc_pc14 (label_ptr[0], (tcg_target_long) s->code_ptr); ir = 3; tcg_out_mov (s, TCG_TYPE_I32, ir++, TCG_AREG0); #if TARGET_LONG_BITS == 32 tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg); #else #ifdef TCG_TARGET_CALL_ALIGN_ARGS ir |= 1; #endif tcg_out_mov (s, TCG_TYPE_I32, ir++, label->addrhi_reg); tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg); #endif tcg_out_movi (s, TCG_TYPE_I32, ir, mem_index); tcg_out_call (s, (tcg_target_long) qemu_ld_helpers[s_bits], 1); tcg_out32 (s, B | 8); tcg_out32 (s, (tcg_target_long) raddr); switch (opc) { case 0|4: tcg_out32 (s, EXTSB | RA (data_reg) | RS (3)); break; case 1|4: tcg_out32 (s, EXTSH | RA (data_reg) | RS (3)); break; case 0: case 1: case 2: if (data_reg != 3) tcg_out_mov (s, TCG_TYPE_I32, data_reg, 3); break; case 3: if (data_reg == 3) { if (data_reg2 == 4) { tcg_out_mov (s, TCG_TYPE_I32, 0, 4); tcg_out_mov (s, TCG_TYPE_I32, 4, 3); tcg_out_mov (s, TCG_TYPE_I32, 3, 0); } else { tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3); tcg_out_mov (s, TCG_TYPE_I32, 3, 4); } } else { if (data_reg != 4) tcg_out_mov (s, TCG_TYPE_I32, data_reg, 4); if (data_reg2 != 3) tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3); } break; } tcg_out_b (s, 0, (tcg_target_long) raddr); }

[[[[Adv]]]]: static void tcg_out_qemu_ld_slow_path (TCGContext *s, TCGLabelQemuLdst *label) { int s_bits; int ir; int opc = label->opc; int mem_index = label->mem_index; int data_reg = label->datalo_reg; int data_reg2 = label->datahi_reg; int addr_reg = label->addrlo_reg; uint8_t *raddr = label->raddr; uint8_t **label_ptr = &label->label_ptr[0]; s_bits = opc & 3; reloc_pc14 (label_ptr[0], (tcg_target_long) s->code_ptr); ir = 3; tcg_out_mov (s, TCG_TYPE_I32, ir++, TCG_AREG0); #if TARGET_LONG_BITS == 32 tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg); #else #ifdef TCG_TARGET_CALL_ALIGN_ARGS ir |= 1; #endif tcg_out_mov (s, TCG_TYPE_I32, ir++, label->addrhi_reg); tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg); #endif tcg_out_movi (s, TCG_TYPE_I32, ir, mem_index); tcg_out_call (s, (tcg_target_long) qemu_ld_helpers[s_bits], 1); tcg_out32 (s, B | 8); tcg_out32 (s, (tcg_target_long) raddr); switch (opc) { case 0|4: tcg_out32 (s, EXTSB | RA (data_reg) | RS (3)); break; case 1|4: tcg_out32 (s, EXTSH | RA (data_reg) | RS (3)); break; case 0: case 1: case 2: if (data_reg != 3) tcg_out_mov (s, TCG_TYPE_I32, data_reg, 3); break; case 3: if (data_reg == 3) { if (data_reg2 == 4) { tcg_out_mov (s, TCG_TYPE_I32, 0, 4); tcg_out_mov (s, TCG_TYPE_I32, 4, 3); tcg_out_mov (s, TCG_TYPE_I32, 3, 0); } else { tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3); tcg_out_mov (s, TCG_TYPE_I32, 3, 4); } } else { if (data_reg != 4) tcg_out_mov (s, TCG_TYPE_I32, data_reg, 4); if (data_reg2 != 3) tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3); } break; } tcg_out_b (s, 0, (tcg_target_long) raddr); }
--------------------------------------------- Result 646 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 367 / 38 / 241 / 646:  24%|       | 646/2690 [7:15:44<22:58:42, 40.47s/it][Succeeded / Failed / Skipped / Total] 367 / 38 / 241 / 646:  24%|       | 647/2690 [7:17:02<23:00:02, 40.53s/it][Succeeded / Failed / Skipped / Total] 368 / 38 / 241 / 647:  24%|       | 647/2690 [7:17:02<23:00:02, 40.53s/it][Succeeded / Failed / Skipped / Total] 368 / 38 / 241 / 647:  24%|       | 648/2690 [7:18:34<23:02:02, 40.61s/it][Succeeded / Failed / Skipped / Total] 369 / 38 / 241 / 648:  24%|       | 648/2690 [7:18:34<23:02:02, 40.61s/it][Succeeded / Failed / Skipped / Total] 369 / 38 / 241 / 648:  24%|       | 649/2690 [7:18:34<22:59:15, 40.55s/it][Succeeded / Failed / Skipped / Total] 369 / 38 / 242 / 649:  24%|       | 649/2690 [7:18:34<22:59:15, 40.55s/it][Succeeded / Failed / Skipped / Total] 369 / 38 / 242 / 649:  24%|       | 650/2690 [7:18:44<22:56:58, 40.50s/it][[0 (7%)]] --> [[0 (50%)]] --> Socre: 0.5035131573677063

[[[[Adv]]]]: static void test_dealloc_types(void) { UserDefOne *[[ud1test]], *ud1a, *ud1b; UserDefOneList *[[ud1list]]; [[ud1test]] = g_malloc0(sizeof(UserDefOne)); [[ud1test]]->base = g_new0(UserDefZero, 1); [[ud1test]]->base->integer = 42; [[ud1test]]->string = g_strdup("hi there 42"); qapi_free_UserDefOne([[ud1test]]); ud1a = g_malloc0(sizeof(UserDefOne)); ud1a->base = g_new0(UserDefZero, 1); ud1a->base->integer = 43; ud1a->string = g_strdup("hi there 43"); ud1b = g_malloc0(sizeof(UserDefOne)); ud1b->base = g_new0(UserDefZero, 1); ud1b->base->integer = 44; ud1b->string = g_strdup("hi there 44"); [[ud1list]] = g_malloc0(sizeof(UserDefOneList)); [[ud1list]]->value = ud1a; [[ud1list]]->next = g_malloc0(sizeof(UserDefOneList)); [[ud1list]]->next->value = ud1b; qapi_free_UserDefOneList([[ud1list]]); }

[[[[Adv]]]]: static void test_dealloc_types(void) { UserDefOne *[[amore]], *ud1a, *ud1b; UserDefOneList *[[creeped]]; [[amore]] = g_malloc0(sizeof(UserDefOne)); [[amore]]->base = g_new0(UserDefZero, 1); [[amore]]->base->integer = 42; [[amore]]->string = g_strdup("hi there 42"); qapi_free_UserDefOne([[amore]]); ud1a = g_malloc0(sizeof(UserDefOne)); ud1a->base = g_new0(UserDefZero, 1); ud1a->base->integer = 43; ud1a->string = g_strdup("hi there 43"); ud1b = g_malloc0(sizeof(UserDefOne)); ud1b->base = g_new0(UserDefZero, 1); ud1b->base->integer = 44; ud1b->string = g_strdup("hi there 44"); [[creeped]] = g_malloc0(sizeof(UserDefOneList)); [[creeped]]->value = ud1a; [[creeped]]->next = g_malloc0(sizeof(UserDefOneList)); [[creeped]]->next->value = ud1b; qapi_free_UserDefOneList([[creeped]]); }
--------------------------------------------- Result 647 ---------------------------------------------
[[0 (5%)]] --> [[0 (97%)]] --> Socre: 0.9731733202934265

[[[[Adv]]]]: void net_checksum_calculate(uint8_t *data, int length) { int [[hlen]], plen, proto, csum_offset; uint16_t csum; if ((data[14] & 0xf0) != 0x40) return; [[hlen]] = (data[14] & 0x0f) * 4; plen = (data[16] << 8 | data[17]) - [[hlen]]; proto = data[23]; switch (proto) { case PROTO_TCP: csum_offset = 16; break; case PROTO_UDP: csum_offset = 6; break; default: return; } if (plen < csum_offset+2) return; data[14+[[hlen]]+csum_offset] = 0; data[14+[[hlen]]+csum_offset+1] = 0; csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+[[hlen]]); data[14+[[hlen]]+csum_offset] = csum >> 8; data[14+[[hlen]]+csum_offset+1] = csum & 0xff; }

[[[[Adv]]]]: void net_checksum_calculate(uint8_t *data, int length) { int [[frdric]], plen, proto, csum_offset; uint16_t csum; if ((data[14] & 0xf0) != 0x40) return; [[frdric]] = (data[14] & 0x0f) * 4; plen = (data[16] << 8 | data[17]) - [[frdric]]; proto = data[23]; switch (proto) { case PROTO_TCP: csum_offset = 16; break; case PROTO_UDP: csum_offset = 6; break; default: return; } if (plen < csum_offset+2) return; data[14+[[frdric]]+csum_offset] = 0; data[14+[[frdric]]+csum_offset+1] = 0; csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+[[frdric]]); data[14+[[frdric]]+csum_offset] = csum >> 8; data[14+[[frdric]]+csum_offset+1] = csum & 0xff; }
--------------------------------------------- Result 648 ---------------------------------------------
[[0 (33%)]] --> [[0 (54%)]] --> Socre: 0.5407139658927917

[[[[Adv]]]]: static void x86_cpu_parse_featurestr(const char *typename, char *[[features]], Error **errp) { char *featurestr; static bool cpu_globals_initialized; bool ambiguous = "False" != "False"; if (cpu_globals_initialized) { return; } cpu_globals_initialized = "True" == "True"; if (![[features]]) { return; } for (featurestr = strtok([[features]], ","); featurestr; featurestr = strtok(NULL, ",")) { const char *name; const char *val = NULL; char *eq = NULL; char num[32]; GlobalProperty *[[prop]]; if (featurestr[0] == '+') { plus_features = g_list_append(plus_features, g_strdup(featurestr + 1)); continue; } else if (featurestr[0] == '-') { minus_features = g_list_append(minus_features, g_strdup(featurestr + 1)); continue; } eq = strchr(featurestr, '='); if (eq) { *eq++ = 0; val = eq; } else { val = "on"; } feat2prop(featurestr); name = featurestr; if (g_list_find_custom(plus_features, name, compare_string)) { error_report("warning: Ambiguous CPU model string. " "Don't mix both \"+%s\" and \"%s=%s\"", name, name, val); ambiguous = "True" == "True"; } if (g_list_find_custom(minus_features, name, compare_string)) { error_report("warning: Ambiguous CPU model string. " "Don't mix both \"-%s\" and \"%s=%s\"", name, name, val); ambiguous = "True" == "True"; } if (!strcmp(name, "tsc-freq")) { int64_t tsc_freq; tsc_freq = qemu_strtosz_metric(val, NULL); if (tsc_freq < 0) { error_setg(errp, "bad numerical value %s", val); return; } snprintf(num, sizeof(num), "%" PRId64, tsc_freq); val = num; name = "tsc-frequency"; } [[prop]] = g_new0(typeof(*[[prop]]), 1); [[prop]]->driver = typename; [[prop]]->property = g_strdup(name); [[prop]]->value = g_strdup(val); [[prop]]->errp = &error_fatal; qdev_prop_register_global([[prop]]); } if (ambiguous) { error_report("warning: Compatibility of ambiguous CPU model " "strings won't be kept on future QEMU versions"); } }

[[[[Adv]]]]: static void x86_cpu_parse_featurestr(const char *typename, char *[[distinctive]], Error **errp) { char *featurestr; static bool cpu_globals_initialized; bool ambiguous = "False" != "False"; if (cpu_globals_initialized) { return; } cpu_globals_initialized = "True" == "True"; if (![[distinctive]]) { return; } for (featurestr = strtok([[distinctive]], ","); featurestr; featurestr = strtok(NULL, ",")) { const char *name; const char *val = NULL; char *eq = NULL; char num[32]; GlobalProperty *[[accomplices]]; if (featurestr[0] == '+') { plus_features = g_list_append(plus_features, g_strdup(featurestr + 1)); continue; } else if (featurestr[0] == '-') { minus_features = g_list_append(minus_features, g_strdup(featurestr + 1)); continue; } eq = strchr(featurestr, '='); if (eq) { *eq++ = 0; val = eq; } else { val = "on"; } feat2prop(featurestr); name = featurestr; if (g_list_find_custom(plus_features, name, compare_string)) { error_report("warning: Ambiguous CPU model string. " "Don't mix both \"+%s\" and \"%s=%s\"", name, name, val); ambiguous = "True" == "True"; } if (g_list_find_custom(minus_features, name, compare_string)) { error_report("warning: Ambiguous CPU model string. " "Don't mix both \"-%s\" and \"%s=%s\"", name, name, val); ambiguous = "True" == "True"; } if (!strcmp(name, "tsc-freq")) { int64_t tsc_freq; tsc_freq = qemu_strtosz_metric(val, NULL); if (tsc_freq < 0) { error_setg(errp, "bad numerical value %s", val); return; } snprintf(num, sizeof(num), "%" PRId64, tsc_freq); val = num; name = "tsc-frequency"; } [[accomplices]] = g_new0(typeof(*[[accomplices]]), 1); [[accomplices]]->driver = typename; [[accomplices]]->property = g_strdup(name); [[accomplices]]->value = g_strdup(val); [[accomplices]]->errp = &error_fatal; qdev_prop_register_global([[accomplices]]); } if (ambiguous) { error_report("warning: Compatibility of ambiguous CPU model " "strings won't be kept on future QEMU versions"); } }
--------------------------------------------- Result 649 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s, VirtQueue *vq, EventNotifierHandler *handler, int n) { BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s))); VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus); VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring); int rc; rc = k->set_host_notifier(qbus->parent, n, "True" == "True"); if (rc != 0) { fprintf(stderr, "virtio-scsi: Failed to set host notifier (%d)\n", rc); exit(1); } r->host_notifier = *virtio_queue_get_host_notifier(vq); r->guest_notifier = *virtio_queue_get_guest_notifier(vq); aio_set_event_notifier(s->ctx, &r->host_notifier, handler); r->parent = s; if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) { fprintf(stderr, "virtio-scsi: VRing setup failed\n"); exit(1); } return r; }
--------------------------------------------- Result 650 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 370 / 38 / 242 / 650:  24%|       | 650/2690 [7:18:44<22:56:58, 40.50s/it][Succeeded / Failed / Skipped / Total] 370 / 38 / 242 / 650:  24%|       | 651/2690 [7:18:58<22:54:55, 40.46s/it][Succeeded / Failed / Skipped / Total] 371 / 38 / 242 / 651:  24%|       | 651/2690 [7:18:58<22:54:55, 40.46s/it][Succeeded / Failed / Skipped / Total] 371 / 38 / 242 / 651:  24%|       | 652/2690 [7:27:38<23:19:14, 41.19s/it][Succeeded / Failed / Skipped / Total] 371 / 39 / 242 / 652:  24%|       | 652/2690 [7:27:38<23:19:14, 41.19s/it][Succeeded / Failed / Skipped / Total] 371 / 39 / 242 / 652:  24%|       | 653/2690 [7:32:17<23:30:54, 41.56s/it][[0 (59%)]] --> [[0 (39%)]] --> Socre: 0.6064485311508179

[[[[Adv]]]]: void qemu_net_queue_purge(NetQueue *[[queue]], NetClientState *from) { NetPacket *packet, *next; QTAILQ_FOREACH_SAFE(packet, &[[queue]]->packets, entry, next) { if (packet->sender == from) { QTAILQ_REMOVE(&[[queue]]->packets, packet, entry); g_free(packet); } } }

[[[[Adv]]]]: void qemu_net_queue_purge(NetQueue *[[jizz]], NetClientState *from) { NetPacket *packet, *next; QTAILQ_FOREACH_SAFE(packet, &[[jizz]]->packets, entry, next) { if (packet->sender == from) { QTAILQ_REMOVE(&[[jizz]]->packets, packet, entry); g_free(packet); } } }
--------------------------------------------- Result 651 ---------------------------------------------
[[0 (60%)]] --> [[0 (24%)]] --> Socre: 0.7646797746419907

[[[[Adv]]]]: static ssize_t vnc_client_read_tls(gnutls_session_t *[[session]], uint8_t *data, size_t datalen) { ssize_t ret = gnutls_read(*[[session]], data, datalen); if (ret < 0) { if (ret == GNUTLS_E_AGAIN) { errno = EAGAIN; } else { errno = EIO; } ret = -1; } return ret; }

[[[[Adv]]]]: static ssize_t vnc_client_read_tls(gnutls_session_t *[[lecturing]], uint8_t *data, size_t datalen) { ssize_t ret = gnutls_read(*[[lecturing]], data, datalen); if (ret < 0) { if (ret == GNUTLS_E_AGAIN) { errno = EAGAIN; } else { errno = EIO; } ret = -1; } return ret; }
--------------------------------------------- Result 652 ---------------------------------------------
[[0 (85%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static float get_band_cost_UPAIR7_mips(struct AACEncContext *s, PutBitContext *pb, const float *in, const float *scaled, int size, int scale_idx, int cb, const float lambda, const float uplim, int *bits) { const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512]; const float IQ = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512]; int i; float cost = 0; int qc1, qc2, qc3, qc4; int curbits = 0; uint8_t *p_bits = (uint8_t *)ff_aac_spectral_bits[cb-1]; float *p_codes = (float *)ff_aac_codebook_vectors[cb-1]; for (i = 0; i < size; i += 4) { const float *vec, *vec2; int curidx, curidx2, sign1, count1, sign2, count2; int *in_int = (int *)&in[i]; float *in_pos = (float *)&in[i]; float di0, di1, di2, di3; int t0, t1, t2, t3, t4; qc1 = scaled[i ] * Q34 + ROUND_STANDARD; qc2 = scaled[i+1] * Q34 + ROUND_STANDARD; qc3 = scaled[i+2] * Q34 + ROUND_STANDARD; qc4 = scaled[i+3] * Q34 + ROUND_STANDARD; __asm__ volatile ( ".set push \n\t" ".set noreorder \n\t" "ori %[t4], $zero, 7 \n\t" "ori %[sign1], $zero, 0 \n\t" "ori %[sign2], $zero, 0 \n\t" "slt %[t0], %[t4], %[qc1] \n\t" "slt %[t1], %[t4], %[qc2] \n\t" "slt %[t2], %[t4], %[qc3] \n\t" "slt %[t3], %[t4], %[qc4] \n\t" "movn %[qc1], %[t4], %[t0] \n\t" "movn %[qc2], %[t4], %[t1] \n\t" "movn %[qc3], %[t4], %[t2] \n\t" "movn %[qc4], %[t4], %[t3] \n\t" "lw %[t0], 0(%[in_int]) \n\t" "lw %[t1], 4(%[in_int]) \n\t" "lw %[t2], 8(%[in_int]) \n\t" "lw %[t3], 12(%[in_int]) \n\t" "slt %[t0], %[t0], $zero \n\t" "movn %[sign1], %[t0], %[qc1] \n\t" "slt %[t2], %[t2], $zero \n\t" "movn %[sign2], %[t2], %[qc3] \n\t" "slt %[t1], %[t1], $zero \n\t" "sll %[t0], %[sign1], 1 \n\t" "or %[t0], %[t0], %[t1] \n\t" "movn %[sign1], %[t0], %[qc2] \n\t" "slt %[t3], %[t3], $zero \n\t" "sll %[t0], %[sign2], 1 \n\t" "or %[t0], %[t0], %[t3] \n\t" "movn %[sign2], %[t0], %[qc4] \n\t" "slt %[count1], $zero, %[qc1] \n\t" "slt %[t1], $zero, %[qc2] \n\t" "slt %[count2], $zero, %[qc3] \n\t" "slt %[t2], $zero, %[qc4] \n\t" "addu %[count1], %[count1], %[t1] \n\t" "addu %[count2], %[count2], %[t2] \n\t" ".set pop \n\t" : [qc1]"+r"(qc1), [qc2]"+r"(qc2), [qc3]"+r"(qc3), [qc4]"+r"(qc4), [sign1]"=&r"(sign1), [count1]"=&r"(count1), [sign2]"=&r"(sign2), [count2]"=&r"(count2), [t0]"=&r"(t0), [t1]"=&r"(t1), [t2]"=&r"(t2), [t3]"=&r"(t3), [t4]"=&r"(t4) : [in_int]"r"(in_int) : "memory" ); curidx = 8 * qc1; curidx += qc2; curidx2 = 8 * qc3; curidx2 += qc4; curbits += p_bits[curidx]; curbits += upair7_sign_bits[curidx]; vec = &p_codes[curidx*2]; curbits += p_bits[curidx2]; curbits += upair7_sign_bits[curidx2]; vec2 = &p_codes[curidx2*2]; __asm__ volatile ( ".set push \n\t" ".set noreorder \n\t" "lwc1 %[di0], 0(%[in_pos]) \n\t" "lwc1 %[di1], 4(%[in_pos]) \n\t" "lwc1 %[di2], 8(%[in_pos]) \n\t" "lwc1 %[di3], 12(%[in_pos]) \n\t" "abs.s %[di0], %[di0] \n\t" "abs.s %[di1], %[di1] \n\t" "abs.s %[di2], %[di2] \n\t" "abs.s %[di3], %[di3] \n\t" "lwc1 $f0, 0(%[vec]) \n\t" "lwc1 $f1, 4(%[vec]) \n\t" "lwc1 $f2, 0(%[vec2]) \n\t" "lwc1 $f3, 4(%[vec2]) \n\t" "nmsub.s %[di0], %[di0], $f0, %[IQ] \n\t" "nmsub.s %[di1], %[di1], $f1, %[IQ] \n\t" "nmsub.s %[di2], %[di2], $f2, %[IQ] \n\t" "nmsub.s %[di3], %[di3], $f3, %[IQ] \n\t" ".set pop \n\t" : [di0]"=&f"(di0), [di1]"=&f"(di1), [di2]"=&f"(di2), [di3]"=&f"(di3) : [in_pos]"r"(in_pos), [vec]"r"(vec), [vec2]"r"(vec2), [IQ]"f"(IQ) : "$f0", "$f1", "$f2", "$f3", "memory" ); cost += di0 * di0 + di1 * di1 + di2 * di2 + di3 * di3; } if (bits) *bits = curbits; return cost * lambda + curbits; }

[[[[Adv]]]]: static float get_band_cost_UPAIR7_mips(struct AACEncContext *s, PutBitContext *pb, const float *in, const float *scaled, int size, int scale_idx, int cb, const float lambda, const float uplim, int *bits) { const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512]; const float IQ = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512]; int i; float cost = 0; int qc1, qc2, qc3, qc4; int curbits = 0; uint8_t *p_bits = (uint8_t *)ff_aac_spectral_bits[cb-1]; float *p_codes = (float *)ff_aac_codebook_vectors[cb-1]; for (i = 0; i < size; i += 4) { const float *vec, *vec2; int curidx, curidx2, sign1, count1, sign2, count2; int *in_int = (int *)&in[i]; float *in_pos = (float *)&in[i]; float di0, di1, di2, di3; int t0, t1, t2, t3, t4; qc1 = scaled[i ] * Q34 + ROUND_STANDARD; qc2 = scaled[i+1] * Q34 + ROUND_STANDARD; qc3 = scaled[i+2] * Q34 + ROUND_STANDARD; qc4 = scaled[i+3] * Q34 + ROUND_STANDARD; __asm__ volatile ( ".set push \n\t" ".set noreorder \n\t" "ori %[t4], $zero, 7 \n\t" "ori %[sign1], $zero, 0 \n\t" "ori %[sign2], $zero, 0 \n\t" "slt %[t0], %[t4], %[qc1] \n\t" "slt %[t1], %[t4], %[qc2] \n\t" "slt %[t2], %[t4], %[qc3] \n\t" "slt %[t3], %[t4], %[qc4] \n\t" "movn %[qc1], %[t4], %[t0] \n\t" "movn %[qc2], %[t4], %[t1] \n\t" "movn %[qc3], %[t4], %[t2] \n\t" "movn %[qc4], %[t4], %[t3] \n\t" "lw %[t0], 0(%[in_int]) \n\t" "lw %[t1], 4(%[in_int]) \n\t" "lw %[t2], 8(%[in_int]) \n\t" "lw %[t3], 12(%[in_int]) \n\t" "slt %[t0], %[t0], $zero \n\t" "movn %[sign1], %[t0], %[qc1] \n\t" "slt %[t2], %[t2], $zero \n\t" "movn %[sign2], %[t2], %[qc3] \n\t" "slt %[t1], %[t1], $zero \n\t" "sll %[t0], %[sign1], 1 \n\t" "or %[t0], %[t0], %[t1] \n\t" "movn %[sign1], %[t0], %[qc2] \n\t" "slt %[t3], %[t3], $zero \n\t" "sll %[t0], %[sign2], 1 \n\t" "or %[t0], %[t0], %[t3] \n\t" "movn %[sign2], %[t0], %[qc4] \n\t" "slt %[count1], $zero, %[qc1] \n\t" "slt %[t1], $zero, %[qc2] \n\t" "slt %[count2], $zero, %[qc3] \n\t" "slt %[t2], $zero, %[qc4] \n\t" "addu %[count1], %[count1], %[t1] \n\t" "addu %[count2], %[count2], %[t2] \n\t" ".set pop \n\t" : [qc1]"+r"(qc1), [qc2]"+r"(qc2), [qc3]"+r"(qc3), [qc4]"+r"(qc4), [sign1]"=&r"(sign1), [count1]"=&r"(count1), [sign2]"=&r"(sign2), [count2]"=&r"(count2), [t0]"=&r"(t0), [t1]"=&r"(t1), [t2]"=&r"(t2), [t3]"=&r"(t3), [t4]"=&r"(t4) : [in_int]"r"(in_int) : "memory" ); curidx = 8 * qc1; curidx += qc2; curidx2 = 8 * qc3; curidx2 += qc4; curbits += p_bits[curidx]; curbits += upair7_sign_bits[curidx]; vec = &p_codes[curidx*2]; curbits += p_bits[curidx2]; curbits += upair7_sign_bits[curidx2]; vec2 = &p_codes[curidx2*2]; __asm__ volatile ( ".set push \n\t" ".set noreorder \n\t" "lwc1 %[di0], 0(%[in_pos]) \n\t" "lwc1 %[di1], 4(%[in_pos]) \n\t" "lwc1 %[di2], 8(%[in_pos]) \n\t" "lwc1 %[di3], 12(%[in_pos]) \n\t" "abs.s %[di0], %[di0] \n\t" "abs.s %[di1], %[di1] \n\t" "abs.s %[di2], %[di2] \n\t" "abs.s %[di3], %[di3] \n\t" "lwc1 $f0, 0(%[vec]) \n\t" "lwc1 $f1, 4(%[vec]) \n\t" "lwc1 $f2, 0(%[vec2]) \n\t" "lwc1 $f3, 4(%[vec2]) \n\t" "nmsub.s %[di0], %[di0], $f0, %[IQ] \n\t" "nmsub.s %[di1], %[di1], $f1, %[IQ] \n\t" "nmsub.s %[di2], %[di2], $f2, %[IQ] \n\t" "nmsub.s %[di3], %[di3], $f3, %[IQ] \n\t" ".set pop \n\t" : [di0]"=&f"(di0), [di1]"=&f"(di1), [di2]"=&f"(di2), [di3]"=&f"(di3) : [in_pos]"r"(in_pos), [vec]"r"(vec), [vec2]"r"(vec2), [IQ]"f"(IQ) : "$f0", "$f1", "$f2", "$f3", "memory" ); cost += di0 * di0 + di1 * di1 + di2 * di2 + di3 * di3; } if (bits) *bits = curbits; return cost * lambda + curbits; }
--------------------------------------------- Result 653 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 371 / 40 / 242 / 653:  24%|       | 653/2690 [7:32:17<23:30:54, 41.56s/it][Succeeded / Failed / Skipped / Total] 371 / 40 / 242 / 653:  24%|       | 654/2690 [7:32:21<23:28:16, 41.50s/it][Succeeded / Failed / Skipped / Total] 372 / 40 / 242 / 654:  24%|       | 654/2690 [7:32:21<23:28:16, 41.50s/it][Succeeded / Failed / Skipped / Total] 372 / 40 / 242 / 654:  24%|       | 655/2690 [7:32:22<23:25:27, 41.44s/it][Succeeded / Failed / Skipped / Total] 372 / 40 / 243 / 655:  24%|       | 655/2690 [7:32:22<23:25:27, 41.44s/it][Succeeded / Failed / Skipped / Total] 372 / 40 / 243 / 655:  24%|       | 656/2690 [7:32:22<23:22:38, 41.38s/it][Succeeded / Failed / Skipped / Total] 372 / 40 / 244 / 656:  24%|       | 656/2690 [7:32:22<23:22:38, 41.38s/it][Succeeded / Failed / Skipped / Total] 372 / 40 / 244 / 656:  24%|       | 657/2690 [7:32:36<23:20:32, 41.33s/it][Succeeded / Failed / Skipped / Total] 373 / 40 / 244 / 657:  24%|       | 657/2690 [7:32:36<23:20:32, 41.33s/it][Succeeded / Failed / Skipped / Total] 373 / 40 / 244 / 657:  24%|       | 658/2690 [7:32:37<23:17:45, 41.27s/it][Succeeded / Failed / Skipped / Total] 373 / 40 / 245 / 658:  24%|       | 658/2690 [7:32:37<23:17:45, 41.27s/it][Succeeded / Failed / Skipped / Total] 373 / 40 / 245 / 658:  24%|       | 659/2690 [7:33:54<23:18:54, 41.33s/it][[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int idcin_read_packet(AVFormatContext *s, AVPacket *pkt) { int ret; unsigned int command; unsigned int chunk_size; IdcinDemuxContext *idcin = s->priv_data; AVIOContext *pb = s->pb; int i; int palette_scale; unsigned char r, g, b; unsigned char palette_buffer[768]; uint32_t palette[256]; if (s->pb->eof_reached) return AVERROR(EIO); if (idcin->next_chunk_is_video) { command = avio_rl32(pb); if (command == 2) { return AVERROR(EIO); } else if (command == 1) { if (avio_read(pb, palette_buffer, 768) != 768) return AVERROR(EIO); palette_scale = 2; for (i = 0; i < 768; i++) if (palette_buffer[i] > 63) { palette_scale = 0; break; for (i = 0; i < 256; i++) { r = palette_buffer[i * 3 ] << palette_scale; g = palette_buffer[i * 3 + 1] << palette_scale; b = palette_buffer[i * 3 + 2] << palette_scale; palette[i] = (r << 16) | (g << 8) | (b); chunk_size = avio_rl32(pb); avio_skip(pb, 4); chunk_size -= 4; ret= av_get_packet(pb, pkt, chunk_size); if (ret < 0) return ret; if (command == 1) { uint8_t *pal; pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE); if (ret < 0) return ret; memcpy(pal, palette, AVPALETTE_SIZE); pkt->flags |= AV_PKT_FLAG_KEY; pkt->stream_index = idcin->video_stream_index; pkt->duration = 1; } else { if (idcin->current_audio_chunk) chunk_size = idcin->audio_chunk_size2; else chunk_size = idcin->audio_chunk_size1; ret= av_get_packet(pb, pkt, chunk_size); if (ret < 0) return ret; pkt->stream_index = idcin->audio_stream_index; pkt->duration = chunk_size / idcin->block_align; idcin->current_audio_chunk ^= 1; if (idcin->audio_present) idcin->next_chunk_is_video ^= 1; return ret;

[[[[Adv]]]]: static int idcin_read_packet(AVFormatContext *s, AVPacket *pkt) { int ret; unsigned int command; unsigned int chunk_size; IdcinDemuxContext *idcin = s->priv_data; AVIOContext *pb = s->pb; int i; int palette_scale; unsigned char r, g, b; unsigned char palette_buffer[768]; uint32_t palette[256]; if (s->pb->eof_reached) return AVERROR(EIO); if (idcin->next_chunk_is_video) { command = avio_rl32(pb); if (command == 2) { return AVERROR(EIO); } else if (command == 1) { if (avio_read(pb, palette_buffer, 768) != 768) return AVERROR(EIO); palette_scale = 2; for (i = 0; i < 768; i++) if (palette_buffer[i] > 63) { palette_scale = 0; break; for (i = 0; i < 256; i++) { r = palette_buffer[i * 3 ] << palette_scale; g = palette_buffer[i * 3 + 1] << palette_scale; b = palette_buffer[i * 3 + 2] << palette_scale; palette[i] = (r << 16) | (g << 8) | (b); chunk_size = avio_rl32(pb); avio_skip(pb, 4); chunk_size -= 4; ret= av_get_packet(pb, pkt, chunk_size); if (ret < 0) return ret; if (command == 1) { uint8_t *pal; pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE); if (ret < 0) return ret; memcpy(pal, palette, AVPALETTE_SIZE); pkt->flags |= AV_PKT_FLAG_KEY; pkt->stream_index = idcin->video_stream_index; pkt->duration = 1; } else { if (idcin->current_audio_chunk) chunk_size = idcin->audio_chunk_size2; else chunk_size = idcin->audio_chunk_size1; ret= av_get_packet(pb, pkt, chunk_size); if (ret < 0) return ret; pkt->stream_index = idcin->audio_stream_index; pkt->duration = chunk_size / idcin->block_align; idcin->current_audio_chunk ^= 1; if (idcin->audio_present) idcin->next_chunk_is_video ^= 1; return ret;
--------------------------------------------- Result 654 ---------------------------------------------
[[0 (46%)]] --> [[0 (50%)]] --> Socre: 0.5036380290985107

[[[[Adv]]]]: static void stream_close(VideoState *[[is]]) { VideoPicture *vp; int i; [[is]]->abort_request = 1; SDL_WaitThread([[is]]->read_tid, NULL); SDL_WaitThread([[is]]->refresh_tid, NULL); packet_queue_destroy(&[[is]]->videoq); packet_queue_destroy(&[[is]]->audioq); packet_queue_destroy(&[[is]]->subtitleq); for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) { vp = &[[is]]->pictq[i]; #if CONFIG_AVFILTER avfilter_unref_bufferp(&vp->picref); #endif if (vp->bmp) { SDL_FreeYUVOverlay(vp->bmp); vp->bmp = NULL; } } SDL_DestroyMutex([[is]]->pictq_mutex); SDL_DestroyCond([[is]]->pictq_cond); SDL_DestroyMutex([[is]]->subpq_mutex); SDL_DestroyCond([[is]]->subpq_cond); SDL_DestroyCond([[is]]->continue_read_thread); #if !CONFIG_AVFILTER sws_freeContext([[is]]->img_convert_ctx); #endif av_free([[is]]); }

[[[[Adv]]]]: static void stream_close(VideoState *[[se]]) { VideoPicture *vp; int i; [[se]]->abort_request = 1; SDL_WaitThread([[se]]->read_tid, NULL); SDL_WaitThread([[se]]->refresh_tid, NULL); packet_queue_destroy(&[[se]]->videoq); packet_queue_destroy(&[[se]]->audioq); packet_queue_destroy(&[[se]]->subtitleq); for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) { vp = &[[se]]->pictq[i]; #if CONFIG_AVFILTER avfilter_unref_bufferp(&vp->picref); #endif if (vp->bmp) { SDL_FreeYUVOverlay(vp->bmp); vp->bmp = NULL; } } SDL_DestroyMutex([[se]]->pictq_mutex); SDL_DestroyCond([[se]]->pictq_cond); SDL_DestroyMutex([[se]]->subpq_mutex); SDL_DestroyCond([[se]]->subpq_cond); SDL_DestroyCond([[se]]->continue_read_thread); #if !CONFIG_AVFILTER sws_freeContext([[se]]->img_convert_ctx); #endif av_free([[se]]); }
--------------------------------------------- Result 655 ---------------------------------------------
[[0 (38%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void init_gain_table(COOKContext *q) { int i; q->gain_size_factor = q->samples_per_channel/8; for (i=0 ; i<23 ; i++) { q->gain_table[i] = pow((double)q->pow2tab[i+52] , (1.0/(double)q->gain_size_factor)); } memset(&q->gain_copy, 0, sizeof(COOKgain)); memset(&q->gain_current, 0, sizeof(COOKgain)); memset(&q->gain_now, 0, sizeof(COOKgain)); memset(&q->gain_previous, 0, sizeof(COOKgain)); }
--------------------------------------------- Result 656 ---------------------------------------------
[[0 (47%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qpa_fini_out (HWVoiceOut *hw) { void *ret; PAVoiceOut *pa = (PAVoiceOut *) hw; audio_pt_lock (&pa->pt, AUDIO_FUNC); pa->done = 1; audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC); audio_pt_join (&pa->pt, &ret, AUDIO_FUNC); if (pa->s) { pa_simple_free (pa->s); pa->s = NULL; } audio_pt_fini (&pa->pt, AUDIO_FUNC); g_free (pa->pcm_buf); pa->pcm_buf = NULL; }
--------------------------------------------- Result 657 ---------------------------------------------
[[0 (7%)]] --> [[0 (62%)]] --> Socre: 0.6195015907287598

[[[[Adv]]]]: static int scsi_device_init(SCSIDevice *s) { SCSIDeviceClass *[[sc]] = SCSI_DEVICE_GET_CLASS(s); if ([[sc]]->init) { return [[sc]]->init(s); } return 0; }

[[[[Adv]]]]: static int scsi_device_init(SCSIDevice *s) { SCSIDeviceClass *[[dc]] = SCSI_DEVICE_GET_CLASS(s); if ([[dc]]->init) { return [[dc]]->init(s); } return 0; }
--------------------------------------------- Result 658 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num, int nb_sectors, int dirty) { int64_t start, end; unsigned long val, idx, bit; start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK; end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK; for (; start <= end; start++) { idx = start / (sizeof(unsigned long) * 8); bit = start % (sizeof(unsigned long) * 8); val = bs->dirty_bitmap[idx]; if (dirty) { val |= 1 << bit; } else { val &= ~(1 << bit); } bs->dirty_bitmap[idx] = val; } }
--------------------------------------------- Result 659 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 374 / 40 / 245 / 659:  24%|       | 659/2690 [7:33:54<23:18:54, 41.33s/it][Succeeded / Failed / Skipped / Total] 374 / 40 / 245 / 659:  25%|       | 660/2690 [7:36:49<23:25:03, 41.53s/it][Succeeded / Failed / Skipped / Total] 375 / 40 / 245 / 660:  25%|       | 660/2690 [7:36:49<23:25:03, 41.53s/it][Succeeded / Failed / Skipped / Total] 375 / 40 / 245 / 660:  25%|       | 661/2690 [7:37:00<23:22:49, 41.48s/it][Succeeded / Failed / Skipped / Total] 376 / 40 / 245 / 661:  25%|       | 661/2690 [7:37:00<23:22:49, 41.48s/it][Succeeded / Failed / Skipped / Total] 376 / 40 / 245 / 661:  25%|       | 662/2690 [7:39:08<23:26:32, 41.61s/it][[0 (6%)]] --> [[0 (61%)]] --> Socre: 0.6131308674812317

[[[[Adv]]]]: static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *[[pkt]], int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx) { size_t fetched = 0; struct iovec *src = [[pkt]]->vec; *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM; while (fetched < [[pkt]]->virt_hdr.gso_size) { if (*dst_idx == NET_MAX_FRAG_SG_LIST) { break; } if (*src_idx == ([[pkt]]->payload_frags + NET_TX_PKT_PL_START_FRAG)) { break; } dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset; dst[*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset, [[pkt]]->virt_hdr.gso_size - fetched); *src_offset += dst[*dst_idx].iov_len; fetched += dst[*dst_idx].iov_len; if (*src_offset == src[*src_idx].iov_len) { *src_offset = 0; (*src_idx)++; } (*dst_idx)++; } return fetched; }

[[[[Adv]]]]: static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *[[betrayers]], int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx) { size_t fetched = 0; struct iovec *src = [[betrayers]]->vec; *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM; while (fetched < [[betrayers]]->virt_hdr.gso_size) { if (*dst_idx == NET_MAX_FRAG_SG_LIST) { break; } if (*src_idx == ([[betrayers]]->payload_frags + NET_TX_PKT_PL_START_FRAG)) { break; } dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset; dst[*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset, [[betrayers]]->virt_hdr.gso_size - fetched); *src_offset += dst[*dst_idx].iov_len; fetched += dst[*dst_idx].iov_len; if (*src_offset == src[*src_idx].iov_len) { *src_offset = 0; (*src_idx)++; } (*dst_idx)++; } return fetched; }
--------------------------------------------- Result 660 ---------------------------------------------
[[0 (88%)]] --> [[0 (33%)]] --> Socre: 0.6687254905700684

[[[[Adv]]]]: static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s, int16_t *block, int n) { int level, i, j, run; RLTable *rl = &ff_rl_mpeg1; uint8_t * const [[scantable]] = s->intra_scantable.permutated; const int qscale = s->qscale; OPEN_READER(re, &s->gb); i = -1; UPDATE_CACHE(re, &s->gb); if (((int32_t)GET_CACHE(re, &s->gb)) < 0) { level = (3 * qscale) >> 1; if (GET_CACHE(re, &s->gb) & 0x40000000) level = -level; block[0] = level; i++; SKIP_BITS(re, &s->gb, 2); if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF) goto end; } for (;;) { GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0); if (level != 0) { i += run; j = [[scantable]][i]; level = ((level * 2 + 1) * qscale) >> 1; level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1); SKIP_BITS(re, &s->gb, 1); } else { run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6); UPDATE_CACHE(re, &s->gb); level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12); i += run; j = [[scantable]][i]; if (level < 0) { level = ((-level * 2 + 1) * qscale) >> 1; level = -level; } else { level = ((level * 2 + 1) * qscale) >> 1; } } block[j] = level; if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF) break; UPDATE_CACHE(re, &s->gb); } end: LAST_SKIP_BITS(re, &s->gb, 2); CLOSE_READER(re, &s->gb); s->block_last_index[n] = i; return 0; }

[[[[Adv]]]]: static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s, int16_t *block, int n) { int level, i, j, run; RLTable *rl = &ff_rl_mpeg1; uint8_t * const [[corazn]] = s->intra_scantable.permutated; const int qscale = s->qscale; OPEN_READER(re, &s->gb); i = -1; UPDATE_CACHE(re, &s->gb); if (((int32_t)GET_CACHE(re, &s->gb)) < 0) { level = (3 * qscale) >> 1; if (GET_CACHE(re, &s->gb) & 0x40000000) level = -level; block[0] = level; i++; SKIP_BITS(re, &s->gb, 2); if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF) goto end; } for (;;) { GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0); if (level != 0) { i += run; j = [[corazn]][i]; level = ((level * 2 + 1) * qscale) >> 1; level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1); SKIP_BITS(re, &s->gb, 1); } else { run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6); UPDATE_CACHE(re, &s->gb); level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12); i += run; j = [[corazn]][i]; if (level < 0) { level = ((-level * 2 + 1) * qscale) >> 1; level = -level; } else { level = ((level * 2 + 1) * qscale) >> 1; } } block[j] = level; if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF) break; UPDATE_CACHE(re, &s->gb); } end: LAST_SKIP_BITS(re, &s->gb, 2); CLOSE_READER(re, &s->gb); s->block_last_index[n] = i; return 0; }
--------------------------------------------- Result 661 ---------------------------------------------
[[0 (83%)]] --> [[0 (31%)]] --> Socre: 0.6913461089134216

[[[[Adv]]]]: static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps) { int [[ret]], i; frame->width = s->avctx->width + 2; frame->height = s->avctx->height + 2; if (([[ret]] = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0) return [[ret]]; for (i = 0; frame->data[i]; i++) { int offset = frame->linesize[i] + (1 << sps->pixel_shift); frame->data[i] += offset; } frame->width = s->avctx->width; frame->height = s->avctx->height; return 0; }

[[[[Adv]]]]: static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps) { int [[declassified]], i; frame->width = s->avctx->width + 2; frame->height = s->avctx->height + 2; if (([[declassified]] = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0) return [[declassified]]; for (i = 0; frame->data[i]; i++) { int offset = frame->linesize[i] + (1 << sps->pixel_shift); frame->data[i] += offset; } frame->width = s->avctx->width; frame->height = s->avctx->height; return 0; }
--------------------------------------------- Result 662 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 377 / 40 / 245 / 662:  25%|       | 662/2690 [7:39:08<23:26:32, 41.61s/it][Succeeded / Failed / Skipped / Total] 377 / 40 / 245 / 662:  25%|       | 663/2690 [7:39:18<23:24:14, 41.57s/it][[0 (1%)]] --> [[0 (64%)]] --> Socre: 0.6406626105308533

[[[[Adv]]]]: static void avc_luma_vt_16w_msa(const uint8_t *[[src]], int32_t src_stride, uint8_t *dst, int32_t dst_stride, int32_t height) { int32_t [[loop_cnt]]; int16_t filt_const0 = 0xfb01; int16_t filt_const1 = 0x1414; int16_t filt_const2 = 0x1fb; v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8; v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r; v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l; v16i8 src65_l, src87_l; v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l; v16u8 res0, res1, res2, res3; v16i8 filt0, filt1, filt2; filt0 = (v16i8) __msa_fill_h(filt_const0); filt1 = (v16i8) __msa_fill_h(filt_const1); filt2 = (v16i8) __msa_fill_h(filt_const2); LD_SB5([[src]], src_stride, src0, src1, src2, src3, src4); [[src]] += (5 * src_stride); XORI_B5_128_SB(src0, src1, src2, src3, src4); ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3, src10_r, src21_r, src32_r, src43_r); ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3, src10_l, src21_l, src32_l, src43_l); for ([[loop_cnt]] = (height >> 2); [[loop_cnt]]--;) { LD_SB4([[src]], src_stride, src5, src6, src7, src8); [[src]] += (4 * src_stride); XORI_B4_128_SB(src5, src6, src7, src8); ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_r, src65_r, src76_r, src87_r); ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_l, src65_l, src76_l, src87_l); out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, filt0, filt1, filt2); out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2); out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2); out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, filt0, filt1, filt2); out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2); out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2); out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2); out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2); SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5); SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7); SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5); SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7); PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l, out3_r, res0, res1, res2, res3); XORI_B4_128_UB(res0, res1, res2, res3); ST_UB4(res0, res1, res2, res3, dst, dst_stride); dst += (4 * dst_stride); src10_r = src54_r; src32_r = src76_r; src21_r = src65_r; src43_r = src87_r; src10_l = src54_l; src32_l = src76_l; src21_l = src65_l; src43_l = src87_l; src4 = src8; } }

[[[[Adv]]]]: static void avc_luma_vt_16w_msa(const uint8_t *[[creepiest]], int32_t src_stride, uint8_t *dst, int32_t dst_stride, int32_t height) { int32_t [[breastplate]]; int16_t filt_const0 = 0xfb01; int16_t filt_const1 = 0x1414; int16_t filt_const2 = 0x1fb; v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8; v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r; v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l; v16i8 src65_l, src87_l; v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l; v16u8 res0, res1, res2, res3; v16i8 filt0, filt1, filt2; filt0 = (v16i8) __msa_fill_h(filt_const0); filt1 = (v16i8) __msa_fill_h(filt_const1); filt2 = (v16i8) __msa_fill_h(filt_const2); LD_SB5([[creepiest]], src_stride, src0, src1, src2, src3, src4); [[creepiest]] += (5 * src_stride); XORI_B5_128_SB(src0, src1, src2, src3, src4); ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3, src10_r, src21_r, src32_r, src43_r); ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3, src10_l, src21_l, src32_l, src43_l); for ([[breastplate]] = (height >> 2); [[breastplate]]--;) { LD_SB4([[creepiest]], src_stride, src5, src6, src7, src8); [[creepiest]] += (4 * src_stride); XORI_B4_128_SB(src5, src6, src7, src8); ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_r, src65_r, src76_r, src87_r); ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_l, src65_l, src76_l, src87_l); out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, filt0, filt1, filt2); out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2); out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2); out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, filt0, filt1, filt2); out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2); out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2); out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2); out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2); SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5); SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7); SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5); SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7); PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l, out3_r, res0, res1, res2, res3); XORI_B4_128_UB(res0, res1, res2, res3); ST_UB4(res0, res1, res2, res3, dst, dst_stride); dst += (4 * dst_stride); src10_r = src54_r; src32_r = src76_r; src21_r = src65_r; src43_r = src87_r; src10_l = src54_l; src32_l = src76_l; src21_l = src65_l; src43_l = src87_l; src4 = src8; } }
--------------------------------------------- Result 663 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 378 / 40 / 245 / 663:  25%|       | 663/2690 [7:39:18<23:24:14, 41.57s/it][Succeeded / Failed / Skipped / Total] 378 / 40 / 245 / 663:  25%|       | 664/2690 [7:39:18<23:21:27, 41.50s/it][[0 (36%)]] --> [[0 (97%)]] --> Socre: 0.9688801765441895

[[[[Adv]]]]: static int img_commit(int argc, char **argv) { int c, ret, flags; const char *filename, *fmt, *cache, *base; BlockBackend *blk; BlockDriverState *bs, *base_bs; bool progress = "False" != "False", quiet = "False" != "False", drop = "False" != "False"; bool writethrough; Error *local_err = NULL; CommonBlockJobCBInfo cbi; bool image_opts = "False" != "False"; AioContext *aio_context; fmt = NULL; cache = BDRV_DEFAULT_CACHE; base = NULL; for(;;) { static const struct option long_options[] = { {"help", no_argument, 0, 'h'}, {"object", required_argument, 0, OPTION_OBJECT}, {"image-opts", no_argument, 0, OPTION_IMAGE_OPTS}, {0, 0, 0, 0} }; c = getopt_long(argc, argv, "f:ht:b:dpq", long_options, NULL); if (c == -1) { break; } switch(c) { case '?': case 'h': help(); break; case 'f': fmt = optarg; break; case 't': cache = optarg; break; case 'b': base = optarg; drop = "[[True]]" == "[[True]]"; break; case 'd': drop = "[[True]]" == "[[True]]"; break; case 'p': progress = "[[True]]" == "[[True]]"; break; case 'q': quiet = "[[True]]" == "[[True]]"; break; case OPTION_OBJECT: { QemuOpts *opts; opts = qemu_opts_parse_noisily(&qemu_object_opts, optarg, "[[True]]" == "[[True]]"); if (!opts) { return 1; } } break; case OPTION_IMAGE_OPTS: image_opts = "[[True]]" == "[[True]]"; break; } } if (quiet) { progress = "False" != "False"; } if (optind != argc - 1) { error_exit("Expecting one image file name"); } filename = argv[optind++]; if (qemu_opts_foreach(&qemu_object_opts, user_creatable_add_opts_foreach, NULL, NULL)) { return 1; } flags = BDRV_O_RDWR | BDRV_O_UNMAP; ret = bdrv_parse_cache_mode(cache, &flags, &writethrough); if (ret < 0) { error_report("Invalid cache option: %s", cache); return 1; } blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet); if (!blk) { return 1; } bs = blk_bs(blk); qemu_progress_init(progress, 1.f); qemu_progress_print(0.f, 100); if (base) { base_bs = bdrv_find_backing_image(bs, base); if (!base_bs) { error_setg(&local_err, QERR_BASE_NOT_FOUND, base); goto done; } } else { base_bs = backing_bs(bs); if (!base_bs) { error_setg(&local_err, "Image does not have a backing file"); goto done; } } cbi = (CommonBlockJobCBInfo){ .errp = &local_err, .bs = bs, }; aio_context = bdrv_get_aio_context(bs); aio_context_acquire(aio_context); commit_active_start("commit", bs, base_bs, BLOCK_JOB_DEFAULT, 0, BLOCKDEV_ON_ERROR_REPORT, common_block_job_cb, &cbi, &local_err, "False" != "False"); aio_context_release(aio_context); if (local_err) { goto done; } if (!drop) { bdrv_ref(bs); } run_block_job(bs->job, &local_err); if (local_err) { goto unref_backing; } if (!drop && bs->drv->bdrv_make_empty) { ret = bs->drv->bdrv_make_empty(bs); if (ret) { error_setg_errno(&local_err, -ret, "Could not empty %s", filename); goto unref_backing; } } unref_backing: if (!drop) { bdrv_unref(bs); } done: qemu_progress_end(); blk_unref(blk); if (local_err) { error_report_err(local_err); return 1; } qprintf(quiet, "Image committed.\n"); return 0; }

[[[[Adv]]]]: static int img_commit(int argc, char **argv) { int c, ret, flags; const char *filename, *fmt, *cache, *base; BlockBackend *blk; BlockDriverState *bs, *base_bs; bool progress = "False" != "False", quiet = "False" != "False", drop = "False" != "False"; bool writethrough; Error *local_err = NULL; CommonBlockJobCBInfo cbi; bool image_opts = "False" != "False"; AioContext *aio_context; fmt = NULL; cache = BDRV_DEFAULT_CACHE; base = NULL; for(;;) { static const struct option long_options[] = { {"help", no_argument, 0, 'h'}, {"object", required_argument, 0, OPTION_OBJECT}, {"image-opts", no_argument, 0, OPTION_IMAGE_OPTS}, {0, 0, 0, 0} }; c = getopt_long(argc, argv, "f:ht:b:dpq", long_options, NULL); if (c == -1) { break; } switch(c) { case '?': case 'h': help(); break; case 'f': fmt = optarg; break; case 't': cache = optarg; break; case 'b': base = optarg; drop = "[[Heartfelt]]" == "[[Heartfelt]]"; break; case 'd': drop = "[[Heartfelt]]" == "[[Heartfelt]]"; break; case 'p': progress = "[[Heartfelt]]" == "[[Heartfelt]]"; break; case 'q': quiet = "[[Heartfelt]]" == "[[Heartfelt]]"; break; case OPTION_OBJECT: { QemuOpts *opts; opts = qemu_opts_parse_noisily(&qemu_object_opts, optarg, "[[Heartfelt]]" == "[[Heartfelt]]"); if (!opts) { return 1; } } break; case OPTION_IMAGE_OPTS: image_opts = "[[Heartfelt]]" == "[[Heartfelt]]"; break; } } if (quiet) { progress = "False" != "False"; } if (optind != argc - 1) { error_exit("Expecting one image file name"); } filename = argv[optind++]; if (qemu_opts_foreach(&qemu_object_opts, user_creatable_add_opts_foreach, NULL, NULL)) { return 1; } flags = BDRV_O_RDWR | BDRV_O_UNMAP; ret = bdrv_parse_cache_mode(cache, &flags, &writethrough); if (ret < 0) { error_report("Invalid cache option: %s", cache); return 1; } blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet); if (!blk) { return 1; } bs = blk_bs(blk); qemu_progress_init(progress, 1.f); qemu_progress_print(0.f, 100); if (base) { base_bs = bdrv_find_backing_image(bs, base); if (!base_bs) { error_setg(&local_err, QERR_BASE_NOT_FOUND, base); goto done; } } else { base_bs = backing_bs(bs); if (!base_bs) { error_setg(&local_err, "Image does not have a backing file"); goto done; } } cbi = (CommonBlockJobCBInfo){ .errp = &local_err, .bs = bs, }; aio_context = bdrv_get_aio_context(bs); aio_context_acquire(aio_context); commit_active_start("commit", bs, base_bs, BLOCK_JOB_DEFAULT, 0, BLOCKDEV_ON_ERROR_REPORT, common_block_job_cb, &cbi, &local_err, "False" != "False"); aio_context_release(aio_context); if (local_err) { goto done; } if (!drop) { bdrv_ref(bs); } run_block_job(bs->job, &local_err); if (local_err) { goto unref_backing; } if (!drop && bs->drv->bdrv_make_empty) { ret = bs->drv->bdrv_make_empty(bs); if (ret) { error_setg_errno(&local_err, -ret, "Could not empty %s", filename); goto unref_backing; } } unref_backing: if (!drop) { bdrv_unref(bs); } done: qemu_progress_end(); blk_unref(blk); if (local_err) { error_report_err(local_err); return 1; } qprintf(quiet, "Image committed.\n"); return 0; }
--------------------------------------------- Result 664 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 378 / 40 / 246 / 664:  25%|       | 664/2690 [7:39:18<23:21:27, 41.50s/it][Succeeded / Failed / Skipped / Total] 378 / 40 / 246 / 664:  25%|       | 665/2690 [7:39:19<23:18:41, 41.44s/it][Succeeded / Failed / Skipped / Total] 378 / 40 / 247 / 665:  25%|       | 665/2690 [7:39:19<23:18:41, 41.44s/it][Succeeded / Failed / Skipped / Total] 378 / 40 / 247 / 665:  25%|       | 666/2690 [7:39:24<23:16:08, 41.39s/it][[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: unsigned long setup_arg_pages(void * mh, char ** argv, char ** env) { unsigned long stack_base, error, size; int i; int * stack; int argc, envc; size = stack_size; error = target_mmap(0, size + qemu_host_page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); if (error == -1) qerror("stk mmap"); target_mprotect(error + size, qemu_host_page_size, PROT_NONE); stack_base = error + size; stack = (void*)stack_base; stack--; *stack = 0; stack--; DPRINTF("pushing apple %s (0x%x)\n", (char*)argv[0], (int)argv[0]); stl(stack, (int) argv[0]); stack--; stl(stack, 0); stack--; for(envc = 0; env[envc]; envc++); for(i = envc-1; i >= 0; i--) { DPRINTF("pushing env %s (0x%x)\n", (char*)env[i], (int)env[i]); stl(stack, (int)env[i]); stack--; page_set_flags((int)env[i], (int)(env[i]+strlen(env[i])), PROT_READ | PAGE_VALID); } if(interp_prefix[0]) { char *dyld_root; asprintf(&dyld_root, "DYLD_ROOT_PATH=%s", interp_prefix); page_set_flags((int)dyld_root, (int)(dyld_root+strlen(interp_prefix)+1), PROT_READ | PAGE_VALID); stl(stack, (int)dyld_root); stack--; } #ifdef DONT_USE_DYLD_SHARED_MAP { char *shared_map_mode; asprintf(&shared_map_mode, "DYLD_SHARED_REGION=avoid"); page_set_flags((int)shared_map_mode, (int)(shared_map_mode+strlen(shared_map_mode)+1), PROT_READ | PAGE_VALID); stl(stack, (int)shared_map_mode); stack--; } #endif #ifdef ACTIVATE_DYLD_TRACE char * extra_env_static[] = {"DYLD_DEBUG_TRACE=yes", "DYLD_PREBIND_DEBUG=3", "DYLD_UNKNOW_TRACE=yes", "DYLD_PRINT_INITIALIZERS=yes", "DYLD_PRINT_SEGMENTS=yes", "DYLD_PRINT_REBASINGS=yes", "DYLD_PRINT_BINDINGS=yes", "DYLD_PRINT_INITIALIZERS=yes", "DYLD_PRINT_WARNINGS=yes" }; char ** extra_env = malloc(sizeof(extra_env_static)); bcopy(extra_env_static, extra_env, sizeof(extra_env_static)); page_set_flags((int)extra_env, (int)((void*)extra_env+sizeof(extra_env_static)), PROT_READ | PAGE_VALID); for(i = 0; i<9; i++) { DPRINTF("pushing (extra) env %s (0x%x)\n", (char*)extra_env[i], (int)extra_env[i]); stl(stack, (int) extra_env[i]); stack--; } #endif stl(stack, 0); stack--; for(argc = 0; argv[argc]; argc++); for(i = argc-1; i >= 0; i--) { DPRINTF("pushing arg %s (0x%x)\n", (char*)argv[i], (int)argv[i]); stl(stack, (int) argv[i]); stack--; page_set_flags((int)argv[i], (int)(argv[i]+strlen(argv[i])), PROT_READ | PAGE_VALID); } DPRINTF("pushing argc %d \n", argc); stl(stack, argc); stack--; DPRINTF("pushing mh 0x%x \n", (int)mh); stl(stack, (int) mh); return (unsigned long)stack; }
--------------------------------------------- Result 665 ---------------------------------------------
[[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int sd_do_command(SDState *sd, SDRequest *req, uint8_t *response) { uint32_t last_status = sd->card_status; sd_rsp_type_t rtype; int rsplen; if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) { return 0; } if (sd_req_crc_validate(req)) { sd->card_status |= COM_CRC_ERROR; rtype = sd_illegal; goto send_response; } sd->card_status &= ~CARD_STATUS_B; sd_set_status(sd); if (last_status & CARD_IS_LOCKED) { if (!cmd_valid_while_locked(sd, req)) { sd->card_status |= ILLEGAL_COMMAND; fprintf(stderr, "SD: Card is locked\n"); rtype = sd_illegal; goto send_response; } } if (last_status & APP_CMD) { rtype = sd_app_command(sd, *req); sd->card_status &= ~APP_CMD; } else rtype = sd_normal_command(sd, *req); if (rtype == sd_illegal) { sd->card_status |= ILLEGAL_COMMAND; } sd->current_cmd = req->cmd; send_response: switch (rtype) { case sd_r1: case sd_r1b: sd_response_r1_make(sd, response, last_status); rsplen = 4; break; case sd_r2_i: memcpy(response, sd->cid, sizeof(sd->cid)); rsplen = 16; break; case sd_r2_s: memcpy(response, sd->csd, sizeof(sd->csd)); rsplen = 16; break; case sd_r3: sd_response_r3_make(sd, response); rsplen = 4; break; case sd_r6: sd_response_r6_make(sd, response); rsplen = 4; break; case sd_r7: sd_response_r7_make(sd, response); rsplen = 4; break; case sd_r0: case sd_illegal: default: rsplen = 0; break; } #ifdef DEBUG_SD if (rsplen) { int i; DPRINTF("Response:"); for (i = 0; i < rsplen; i++) printf(" %02x", response[i]); printf(" state %d\n", sd->state); } else { DPRINTF("No response %d\n", sd->state); } #endif return rsplen; }
--------------------------------------------- Result 666 ---------------------------------------------
[[0 (39%)]] --> [[0 (93%)]] --> Socre: 0.9341883659362793

[[[[Adv]]]]: void cpu_x86_cpuid(CPUX86State *[[env]], uint32_t index, uint32_t count, uint32_t *eax, uint32_t *ebx, uint32_t *ecx, uint32_t *edx) { X86CPU *cpu = x86_env_get_cpu([[env]]); CPUState *cs = CPU(cpu); uint32_t pkg_offset; if (index & 0x80000000) { if (index > [[env]]->cpuid_xlevel) { if ([[env]]->cpuid_xlevel2 > 0) { if (index > [[env]]->cpuid_xlevel2) { index = [[env]]->cpuid_xlevel2; } else if (index < 0xC0000000) { index = [[env]]->cpuid_xlevel; } } else { index = [[env]]->cpuid_level; } } } else { if (index > [[env]]->cpuid_level) index = [[env]]->cpuid_level; } switch(index) { case 0: *eax = [[env]]->cpuid_level; *ebx = [[env]]->cpuid_vendor1; *edx = [[env]]->cpuid_vendor2; *ecx = [[env]]->cpuid_vendor3; break; case 1: *eax = [[env]]->cpuid_version; *ebx = (cpu->apic_id << 24) | 8 << 8; *ecx = [[env]]->features[FEAT_1_ECX]; if ((*ecx & CPUID_EXT_XSAVE) && ([[env]]->cr[4] & CR4_OSXSAVE_MASK)) { *ecx |= CPUID_EXT_OSXSAVE; } *edx = [[env]]->features[FEAT_1_EDX]; if (cs->nr_cores * cs->nr_threads > 1) { *ebx |= (cs->nr_cores * cs->nr_threads) << 16; *edx |= CPUID_HT; } break; case 2: if (cpu->cache_info_passthrough) { host_cpuid(index, 0, eax, ebx, ecx, edx); break; } *eax = 1; *ebx = 0; if (!cpu->enable_l3_cache) { *ecx = 0; } else { *ecx = L3_N_DESCRIPTOR; } *edx = (L1D_DESCRIPTOR << 16) | \ (L1I_DESCRIPTOR << 8) | \ (L2_DESCRIPTOR); break; case 4: if (cpu->cache_info_passthrough) { host_cpuid(index, count, eax, ebx, ecx, edx); *eax &= ~0xFC000000; } else { *eax = 0; switch (count) { case 0: *eax |= CPUID_4_TYPE_DCACHE | \ CPUID_4_LEVEL(1) | \ CPUID_4_SELF_INIT_LEVEL; *ebx = (L1D_LINE_SIZE - 1) | \ ((L1D_PARTITIONS - 1) << 12) | \ ((L1D_ASSOCIATIVITY - 1) << 22); *ecx = L1D_SETS - 1; *edx = CPUID_4_NO_INVD_SHARING; break; case 1: *eax |= CPUID_4_TYPE_ICACHE | \ CPUID_4_LEVEL(1) | \ CPUID_4_SELF_INIT_LEVEL; *ebx = (L1I_LINE_SIZE - 1) | \ ((L1I_PARTITIONS - 1) << 12) | \ ((L1I_ASSOCIATIVITY - 1) << 22); *ecx = L1I_SETS - 1; *edx = CPUID_4_NO_INVD_SHARING; break; case 2: *eax |= CPUID_4_TYPE_UNIFIED | \ CPUID_4_LEVEL(2) | \ CPUID_4_SELF_INIT_LEVEL; if (cs->nr_threads > 1) { *eax |= (cs->nr_threads - 1) << 14; } *ebx = (L2_LINE_SIZE - 1) | \ ((L2_PARTITIONS - 1) << 12) | \ ((L2_ASSOCIATIVITY - 1) << 22); *ecx = L2_SETS - 1; *edx = CPUID_4_NO_INVD_SHARING; break; case 3: if (!cpu->enable_l3_cache) { *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; break; } *eax |= CPUID_4_TYPE_UNIFIED | \ CPUID_4_LEVEL(3) | \ CPUID_4_SELF_INIT_LEVEL; pkg_offset = apicid_pkg_offset(cs->nr_cores, cs->nr_threads); *eax |= ((1 << pkg_offset) - 1) << 14; *ebx = (L3_N_LINE_SIZE - 1) | \ ((L3_N_PARTITIONS - 1) << 12) | \ ((L3_N_ASSOCIATIVITY - 1) << 22); *ecx = L3_N_SETS - 1; *edx = CPUID_4_INCLUSIVE | CPUID_4_COMPLEX_IDX; break; default: *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; break; } } if ((*eax & 31) && cs->nr_cores > 1) { *eax |= (cs->nr_cores - 1) << 26; } break; case 5: *eax = 0; *ebx = 0; *ecx = CPUID_MWAIT_EMX | CPUID_MWAIT_IBE; *edx = 0; break; case 6: *eax = [[env]]->features[FEAT_6_EAX]; *ebx = 0; *ecx = 0; *edx = 0; break; case 7: if (count == 0) { *eax = 0; *ebx = [[env]]->features[FEAT_7_0_EBX]; *ecx = [[env]]->features[FEAT_7_0_ECX]; if ((*ecx & CPUID_7_0_ECX_PKU) && [[env]]->cr[4] & CR4_PKE_MASK) { *ecx |= CPUID_7_0_ECX_OSPKE; } *edx = 0; } else { *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; } break; case 9: *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; break; case 0xA: if (kvm_enabled() && cpu->enable_pmu) { KVMState *s = cs->kvm_state; *eax = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EAX); *ebx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EBX); *ecx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_ECX); *edx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EDX); } else { *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; } break; case 0xB: if (!cpu->enable_cpuid_0xb) { *eax = *ebx = *ecx = *edx = 0; break; } *ecx = count & 0xff; *edx = cpu->apic_id; switch (count) { case 0: *eax = apicid_core_offset(cs->nr_cores, cs->nr_threads); *ebx = cs->nr_threads; *ecx |= CPUID_TOPOLOGY_LEVEL_SMT; break; case 1: *eax = apicid_pkg_offset(cs->nr_cores, cs->nr_threads); *ebx = cs->nr_cores * cs->nr_threads; *ecx |= CPUID_TOPOLOGY_LEVEL_CORE; break; default: *eax = 0; *ebx = 0; *ecx |= CPUID_TOPOLOGY_LEVEL_INVALID; } assert(!(*eax & ~0x1f)); *ebx &= 0xffff; break; case 0xD: { KVMState *s = cs->kvm_state; uint64_t ena_mask; int i; *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; if (!([[env]]->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) { break; } if (kvm_enabled()) { ena_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX); ena_mask <<= 32; ena_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX); } else { ena_mask = -1; } if (count == 0) { *ecx = 0x240; for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) { const ExtSaveArea *esa = &x86_ext_save_areas[i]; if (([[env]]->features[esa->feature] & esa->bits) == esa->bits && ((ena_mask >> i) & 1) != 0) { if (i < 32) { *eax |= 1u << i; } else { *edx |= 1u << (i - 32); } *ecx = MAX(*ecx, esa->offset + esa->size); } } *eax |= ena_mask & (XSTATE_FP_MASK | XSTATE_SSE_MASK); *ebx = *ecx; } else if (count == 1) { *eax = [[env]]->features[FEAT_XSAVE]; } else if (count < ARRAY_SIZE(x86_ext_save_areas)) { const ExtSaveArea *esa = &x86_ext_save_areas[count]; if (([[env]]->features[esa->feature] & esa->bits) == esa->bits && ((ena_mask >> count) & 1) != 0) { *eax = esa->size; *ebx = esa->offset; } } break; } case 0x80000000: *eax = [[env]]->cpuid_xlevel; *ebx = [[env]]->cpuid_vendor1; *edx = [[env]]->cpuid_vendor2; *ecx = [[env]]->cpuid_vendor3; break; case 0x80000001: *eax = [[env]]->cpuid_version; *ebx = 0; *ecx = [[env]]->features[FEAT_8000_0001_ECX]; *edx = [[env]]->features[FEAT_8000_0001_EDX]; if (cs->nr_cores * cs->nr_threads > 1) { if ([[env]]->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 || [[env]]->cpuid_vendor2 != CPUID_VENDOR_INTEL_2 || [[env]]->cpuid_vendor3 != CPUID_VENDOR_INTEL_3) { *ecx |= 1 << 1; } } break; case 0x80000002: case 0x80000003: case 0x80000004: *eax = [[env]]->cpuid_model[(index - 0x80000002) * 4 + 0]; *ebx = [[env]]->cpuid_model[(index - 0x80000002) * 4 + 1]; *ecx = [[env]]->cpuid_model[(index - 0x80000002) * 4 + 2]; *edx = [[env]]->cpuid_model[(index - 0x80000002) * 4 + 3]; break; case 0x80000005: if (cpu->cache_info_passthrough) { host_cpuid(index, 0, eax, ebx, ecx, edx); break; } *eax = (L1_DTLB_2M_ASSOC << 24) | (L1_DTLB_2M_ENTRIES << 16) | \ (L1_ITLB_2M_ASSOC << 8) | (L1_ITLB_2M_ENTRIES); *ebx = (L1_DTLB_4K_ASSOC << 24) | (L1_DTLB_4K_ENTRIES << 16) | \ (L1_ITLB_4K_ASSOC << 8) | (L1_ITLB_4K_ENTRIES); *ecx = (L1D_SIZE_KB_AMD << 24) | (L1D_ASSOCIATIVITY_AMD << 16) | \ (L1D_LINES_PER_TAG << 8) | (L1D_LINE_SIZE); *edx = (L1I_SIZE_KB_AMD << 24) | (L1I_ASSOCIATIVITY_AMD << 16) | \ (L1I_LINES_PER_TAG << 8) | (L1I_LINE_SIZE); break; case 0x80000006: if (cpu->cache_info_passthrough) { host_cpuid(index, 0, eax, ebx, ecx, edx); break; } *eax = (AMD_ENC_ASSOC(L2_DTLB_2M_ASSOC) << 28) | \ (L2_DTLB_2M_ENTRIES << 16) | \ (AMD_ENC_ASSOC(L2_ITLB_2M_ASSOC) << 12) | \ (L2_ITLB_2M_ENTRIES); *ebx = (AMD_ENC_ASSOC(L2_DTLB_4K_ASSOC) << 28) | \ (L2_DTLB_4K_ENTRIES << 16) | \ (AMD_ENC_ASSOC(L2_ITLB_4K_ASSOC) << 12) | \ (L2_ITLB_4K_ENTRIES); *ecx = (L2_SIZE_KB_AMD << 16) | \ (AMD_ENC_ASSOC(L2_ASSOCIATIVITY) << 12) | \ (L2_LINES_PER_TAG << 8) | (L2_LINE_SIZE); if (!cpu->enable_l3_cache) { *edx = ((L3_SIZE_KB / 512) << 18) | \ (AMD_ENC_ASSOC(L3_ASSOCIATIVITY) << 12) | \ (L3_LINES_PER_TAG << 8) | (L3_LINE_SIZE); } else { *edx = ((L3_N_SIZE_KB_AMD / 512) << 18) | \ (AMD_ENC_ASSOC(L3_N_ASSOCIATIVITY) << 12) | \ (L3_N_LINES_PER_TAG << 8) | (L3_N_LINE_SIZE); } break; case 0x80000007: *eax = 0; *ebx = 0; *ecx = 0; *edx = [[env]]->features[FEAT_8000_0007_EDX]; break; case 0x80000008: if ([[env]]->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) { *eax = 0x00003000 + cpu->phys_bits; } else { *eax = cpu->phys_bits; } *ebx = 0; *ecx = 0; *edx = 0; if (cs->nr_cores * cs->nr_threads > 1) { *ecx |= (cs->nr_cores * cs->nr_threads) - 1; } break; case 0x8000000A: if ([[env]]->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) { *eax = 0x00000001; *ebx = 0x00000010; *ecx = 0; *edx = [[env]]->features[FEAT_SVM]; } else { *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; } break; case 0xC0000000: *eax = [[env]]->cpuid_xlevel2; *ebx = 0; *ecx = 0; *edx = 0; break; case 0xC0000001: *eax = [[env]]->cpuid_version; *ebx = 0; *ecx = 0; *edx = [[env]]->features[FEAT_C000_0001_EDX]; break; case 0xC0000002: case 0xC0000003: case 0xC0000004: *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; break; default: *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; break; } }

[[[[Adv]]]]: void cpu_x86_cpuid(CPUX86State *[[brigitte]], uint32_t index, uint32_t count, uint32_t *eax, uint32_t *ebx, uint32_t *ecx, uint32_t *edx) { X86CPU *cpu = x86_env_get_cpu([[brigitte]]); CPUState *cs = CPU(cpu); uint32_t pkg_offset; if (index & 0x80000000) { if (index > [[brigitte]]->cpuid_xlevel) { if ([[brigitte]]->cpuid_xlevel2 > 0) { if (index > [[brigitte]]->cpuid_xlevel2) { index = [[brigitte]]->cpuid_xlevel2; } else if (index < 0xC0000000) { index = [[brigitte]]->cpuid_xlevel; } } else { index = [[brigitte]]->cpuid_level; } } } else { if (index > [[brigitte]]->cpuid_level) index = [[brigitte]]->cpuid_level; } switch(index) { case 0: *eax = [[brigitte]]->cpuid_level; *ebx = [[brigitte]]->cpuid_vendor1; *edx = [[brigitte]]->cpuid_vendor2; *ecx = [[brigitte]]->cpuid_vendor3; break; case 1: *eax = [[brigitte]]->cpuid_version; *ebx = (cpu->apic_id << 24) | 8 << 8; *ecx = [[brigitte]]->features[FEAT_1_ECX]; if ((*ecx & CPUID_EXT_XSAVE) && ([[brigitte]]->cr[4] & CR4_OSXSAVE_MASK)) { *ecx |= CPUID_EXT_OSXSAVE; } *edx = [[brigitte]]->features[FEAT_1_EDX]; if (cs->nr_cores * cs->nr_threads > 1) { *ebx |= (cs->nr_cores * cs->nr_threads) << 16; *edx |= CPUID_HT; } break; case 2: if (cpu->cache_info_passthrough) { host_cpuid(index, 0, eax, ebx, ecx, edx); break; } *eax = 1; *ebx = 0; if (!cpu->enable_l3_cache) { *ecx = 0; } else { *ecx = L3_N_DESCRIPTOR; } *edx = (L1D_DESCRIPTOR << 16) | \ (L1I_DESCRIPTOR << 8) | \ (L2_DESCRIPTOR); break; case 4: if (cpu->cache_info_passthrough) { host_cpuid(index, count, eax, ebx, ecx, edx); *eax &= ~0xFC000000; } else { *eax = 0; switch (count) { case 0: *eax |= CPUID_4_TYPE_DCACHE | \ CPUID_4_LEVEL(1) | \ CPUID_4_SELF_INIT_LEVEL; *ebx = (L1D_LINE_SIZE - 1) | \ ((L1D_PARTITIONS - 1) << 12) | \ ((L1D_ASSOCIATIVITY - 1) << 22); *ecx = L1D_SETS - 1; *edx = CPUID_4_NO_INVD_SHARING; break; case 1: *eax |= CPUID_4_TYPE_ICACHE | \ CPUID_4_LEVEL(1) | \ CPUID_4_SELF_INIT_LEVEL; *ebx = (L1I_LINE_SIZE - 1) | \ ((L1I_PARTITIONS - 1) << 12) | \ ((L1I_ASSOCIATIVITY - 1) << 22); *ecx = L1I_SETS - 1; *edx = CPUID_4_NO_INVD_SHARING; break; case 2: *eax |= CPUID_4_TYPE_UNIFIED | \ CPUID_4_LEVEL(2) | \ CPUID_4_SELF_INIT_LEVEL; if (cs->nr_threads > 1) { *eax |= (cs->nr_threads - 1) << 14; } *ebx = (L2_LINE_SIZE - 1) | \ ((L2_PARTITIONS - 1) << 12) | \ ((L2_ASSOCIATIVITY - 1) << 22); *ecx = L2_SETS - 1; *edx = CPUID_4_NO_INVD_SHARING; break; case 3: if (!cpu->enable_l3_cache) { *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; break; } *eax |= CPUID_4_TYPE_UNIFIED | \ CPUID_4_LEVEL(3) | \ CPUID_4_SELF_INIT_LEVEL; pkg_offset = apicid_pkg_offset(cs->nr_cores, cs->nr_threads); *eax |= ((1 << pkg_offset) - 1) << 14; *ebx = (L3_N_LINE_SIZE - 1) | \ ((L3_N_PARTITIONS - 1) << 12) | \ ((L3_N_ASSOCIATIVITY - 1) << 22); *ecx = L3_N_SETS - 1; *edx = CPUID_4_INCLUSIVE | CPUID_4_COMPLEX_IDX; break; default: *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; break; } } if ((*eax & 31) && cs->nr_cores > 1) { *eax |= (cs->nr_cores - 1) << 26; } break; case 5: *eax = 0; *ebx = 0; *ecx = CPUID_MWAIT_EMX | CPUID_MWAIT_IBE; *edx = 0; break; case 6: *eax = [[brigitte]]->features[FEAT_6_EAX]; *ebx = 0; *ecx = 0; *edx = 0; break; case 7: if (count == 0) { *eax = 0; *ebx = [[brigitte]]->features[FEAT_7_0_EBX]; *ecx = [[brigitte]]->features[FEAT_7_0_ECX]; if ((*ecx & CPUID_7_0_ECX_PKU) && [[brigitte]]->cr[4] & CR4_PKE_MASK) { *ecx |= CPUID_7_0_ECX_OSPKE; } *edx = 0; } else { *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; } break; case 9: *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; break; case 0xA: if (kvm_enabled() && cpu->enable_pmu) { KVMState *s = cs->kvm_state; *eax = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EAX); *ebx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EBX); *ecx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_ECX); *edx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EDX); } else { *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; } break; case 0xB: if (!cpu->enable_cpuid_0xb) { *eax = *ebx = *ecx = *edx = 0; break; } *ecx = count & 0xff; *edx = cpu->apic_id; switch (count) { case 0: *eax = apicid_core_offset(cs->nr_cores, cs->nr_threads); *ebx = cs->nr_threads; *ecx |= CPUID_TOPOLOGY_LEVEL_SMT; break; case 1: *eax = apicid_pkg_offset(cs->nr_cores, cs->nr_threads); *ebx = cs->nr_cores * cs->nr_threads; *ecx |= CPUID_TOPOLOGY_LEVEL_CORE; break; default: *eax = 0; *ebx = 0; *ecx |= CPUID_TOPOLOGY_LEVEL_INVALID; } assert(!(*eax & ~0x1f)); *ebx &= 0xffff; break; case 0xD: { KVMState *s = cs->kvm_state; uint64_t ena_mask; int i; *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; if (!([[brigitte]]->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) { break; } if (kvm_enabled()) { ena_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX); ena_mask <<= 32; ena_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX); } else { ena_mask = -1; } if (count == 0) { *ecx = 0x240; for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) { const ExtSaveArea *esa = &x86_ext_save_areas[i]; if (([[brigitte]]->features[esa->feature] & esa->bits) == esa->bits && ((ena_mask >> i) & 1) != 0) { if (i < 32) { *eax |= 1u << i; } else { *edx |= 1u << (i - 32); } *ecx = MAX(*ecx, esa->offset + esa->size); } } *eax |= ena_mask & (XSTATE_FP_MASK | XSTATE_SSE_MASK); *ebx = *ecx; } else if (count == 1) { *eax = [[brigitte]]->features[FEAT_XSAVE]; } else if (count < ARRAY_SIZE(x86_ext_save_areas)) { const ExtSaveArea *esa = &x86_ext_save_areas[count]; if (([[brigitte]]->features[esa->feature] & esa->bits) == esa->bits && ((ena_mask >> count) & 1) != 0) { *eax = esa->size; *ebx = esa->offset; } } break; } case 0x80000000: *eax = [[brigitte]]->cpuid_xlevel; *ebx = [[brigitte]]->cpuid_vendor1; *edx = [[brigitte]]->cpuid_vendor2; *ecx = [[brigitte]]->cpuid_vendor3; break; case 0x80000001: *eax = [[brigitte]]->cpuid_version; *ebx = 0; *ecx = [[brigitte]]->features[FEAT_8000_0001_ECX]; *edx = [[brigitte]]->features[FEAT_8000_0001_EDX]; if (cs->nr_cores * cs->nr_threads > 1) { if ([[brigitte]]->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 || [[brigitte]]->cpuid_vendor2 != CPUID_VENDOR_INTEL_2 || [[brigitte]]->cpuid_vendor3 != CPUID_VENDOR_INTEL_3) { *ecx |= 1 << 1; } } break; case 0x80000002: case 0x80000003: case 0x80000004: *eax = [[brigitte]]->cpuid_model[(index - 0x80000002) * 4 + 0]; *ebx = [[brigitte]]->cpuid_model[(index - 0x80000002) * 4 + 1]; *ecx = [[brigitte]]->cpuid_model[(index - 0x80000002) * 4 + 2]; *edx = [[brigitte]]->cpuid_model[(index - 0x80000002) * 4 + 3]; break; case 0x80000005: if (cpu->cache_info_passthrough) { host_cpuid(index, 0, eax, ebx, ecx, edx); break; } *eax = (L1_DTLB_2M_ASSOC << 24) | (L1_DTLB_2M_ENTRIES << 16) | \ (L1_ITLB_2M_ASSOC << 8) | (L1_ITLB_2M_ENTRIES); *ebx = (L1_DTLB_4K_ASSOC << 24) | (L1_DTLB_4K_ENTRIES << 16) | \ (L1_ITLB_4K_ASSOC << 8) | (L1_ITLB_4K_ENTRIES); *ecx = (L1D_SIZE_KB_AMD << 24) | (L1D_ASSOCIATIVITY_AMD << 16) | \ (L1D_LINES_PER_TAG << 8) | (L1D_LINE_SIZE); *edx = (L1I_SIZE_KB_AMD << 24) | (L1I_ASSOCIATIVITY_AMD << 16) | \ (L1I_LINES_PER_TAG << 8) | (L1I_LINE_SIZE); break; case 0x80000006: if (cpu->cache_info_passthrough) { host_cpuid(index, 0, eax, ebx, ecx, edx); break; } *eax = (AMD_ENC_ASSOC(L2_DTLB_2M_ASSOC) << 28) | \ (L2_DTLB_2M_ENTRIES << 16) | \ (AMD_ENC_ASSOC(L2_ITLB_2M_ASSOC) << 12) | \ (L2_ITLB_2M_ENTRIES); *ebx = (AMD_ENC_ASSOC(L2_DTLB_4K_ASSOC) << 28) | \ (L2_DTLB_4K_ENTRIES << 16) | \ (AMD_ENC_ASSOC(L2_ITLB_4K_ASSOC) << 12) | \ (L2_ITLB_4K_ENTRIES); *ecx = (L2_SIZE_KB_AMD << 16) | \ (AMD_ENC_ASSOC(L2_ASSOCIATIVITY) << 12) | \ (L2_LINES_PER_TAG << 8) | (L2_LINE_SIZE); if (!cpu->enable_l3_cache) { *edx = ((L3_SIZE_KB / 512) << 18) | \ (AMD_ENC_ASSOC(L3_ASSOCIATIVITY) << 12) | \ (L3_LINES_PER_TAG << 8) | (L3_LINE_SIZE); } else { *edx = ((L3_N_SIZE_KB_AMD / 512) << 18) | \ (AMD_ENC_ASSOC(L3_N_ASSOCIATIVITY) << 12) | \ (L3_N_LINES_PER_TAG << 8) | (L3_N_LINE_SIZE); } break; case 0x80000007: *eax = 0; *ebx = 0; *ecx = 0; *edx = [[brigitte]]->features[FEAT_8000_0007_EDX]; break; case 0x80000008: if ([[brigitte]]->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) { *eax = 0x00003000 + cpu->phys_bits; } else { *eax = cpu->phys_bits; } *ebx = 0; *ecx = 0; *edx = 0; if (cs->nr_cores * cs->nr_threads > 1) { *ecx |= (cs->nr_cores * cs->nr_threads) - 1; } break; case 0x8000000A: if ([[brigitte]]->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) { *eax = 0x00000001; *ebx = 0x00000010; *ecx = 0; *edx = [[brigitte]]->features[FEAT_SVM]; } else { *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; } break; case 0xC0000000: *eax = [[brigitte]]->cpuid_xlevel2; *ebx = 0; *ecx = 0; *edx = 0; break; case 0xC0000001: *eax = [[brigitte]]->cpuid_version; *ebx = 0; *ecx = 0; *edx = [[brigitte]]->features[FEAT_C000_0001_EDX]; break; case 0xC0000002: case 0xC0000003: case 0xC0000004: *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; break; default: *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; break; } }[Succeeded / Failed / Skipped / Total] 379 / 40 / 247 / 666:  25%|       | 666/2690 [7:39:24<23:16:08, 41.39s/it][Succeeded / Failed / Skipped / Total] 379 / 40 / 247 / 666:  25%|       | 667/2690 [7:39:24<23:13:23, 41.33s/it][Succeeded / Failed / Skipped / Total] 379 / 40 / 248 / 667:  25%|       | 667/2690 [7:39:24<23:13:23, 41.33s/it][Succeeded / Failed / Skipped / Total] 379 / 40 / 248 / 667:  25%|       | 668/2690 [7:39:59<23:12:22, 41.32s/it][Succeeded / Failed / Skipped / Total] 380 / 40 / 248 / 668:  25%|       | 668/2690 [7:39:59<23:12:22, 41.32s/it][Succeeded / Failed / Skipped / Total] 380 / 40 / 248 / 668:  25%|       | 669/2690 [7:40:08<23:10:03, 41.27s/it][Succeeded / Failed / Skipped / Total] 381 / 40 / 248 / 669:  25%|       | 669/2690 [7:40:08<23:10:03, 41.27s/it][Succeeded / Failed / Skipped / Total] 381 / 40 / 248 / 669:  25%|       | 670/2690 [7:40:15<23:07:38, 41.22s/it][Succeeded / Failed / Skipped / Total] 382 / 40 / 248 / 670:  25%|       | 670/2690 [7:40:15<23:07:38, 41.22s/it][Succeeded / Failed / Skipped / Total] 382 / 40 / 248 / 670:  25%|       | 671/2690 [7:40:19<23:05:04, 41.16s/it][Succeeded / Failed / Skipped / Total] 383 / 40 / 248 / 671:  25%|       | 671/2690 [7:40:19<23:05:04, 41.16s/it][Succeeded / Failed / Skipped / Total] 383 / 40 / 248 / 671:  25%|       | 672/2690 [7:40:23<23:02:31, 41.11s/it][Succeeded / Failed / Skipped / Total] 384 / 40 / 248 / 672:  25%|       | 672/2690 [7:40:23<23:02:31, 41.11s/it][Succeeded / Failed / Skipped / Total] 384 / 40 / 248 / 672:  25%|       | 673/2690 [7:40:23<22:59:48, 41.05s/it]
--------------------------------------------- Result 667 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void prepare_app_arguments(int *argc_ptr, char ***argv_ptr) { char *argstr_flat; wchar_t **argv_w; int i, buffsize = 0, offset = 0; if (win32_argv_utf8) { *argc_ptr = win32_argc; *argv_ptr = win32_argv_utf8; return; } win32_argc = 0; argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc); if (win32_argc <= 0 || !argv_w) return; for (i = 0; i < win32_argc; i++) buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1, NULL, 0, NULL, NULL); win32_argv_utf8 = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize); argstr_flat = (char *)win32_argv_utf8 + sizeof(char *) * (win32_argc + 1); if (win32_argv_utf8 == NULL) { LocalFree(argv_w); return; } for (i = 0; i < win32_argc; i++) { win32_argv_utf8[i] = &argstr_flat[offset]; offset += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1, &argstr_flat[offset], buffsize - offset, NULL, NULL); } win32_argv_utf8[i] = NULL; LocalFree(argv_w); *argc_ptr = win32_argc; *argv_ptr = win32_argv_utf8; }
--------------------------------------------- Result 668 ---------------------------------------------
[[0 (3%)]] --> [[0 (65%)]] --> Socre: 0.6481145620346069

[[[[Adv]]]]: static inline void gen_neon_addl_saturate(TCGv [[op0]], TCGv op1, int size) { switch (size) { case 1: gen_helper_neon_addl_saturate_s32([[op0]], cpu_env, [[op0]], op1); break; case 2: gen_helper_neon_addl_saturate_s64([[op0]], cpu_env, [[op0]], op1); break; default: abort(); } }

[[[[Adv]]]]: static inline void gen_neon_addl_saturate(TCGv [[reconnaissance]], TCGv op1, int size) { switch (size) { case 1: gen_helper_neon_addl_saturate_s32([[reconnaissance]], cpu_env, [[reconnaissance]], op1); break; case 2: gen_helper_neon_addl_saturate_s64([[reconnaissance]], cpu_env, [[reconnaissance]], op1); break; default: abort(); } }
--------------------------------------------- Result 669 ---------------------------------------------
[[0 (4%)]] --> [[0 (97%)]] --> Socre: 0.9747603535652161

[[[[Adv]]]]: int MP3lame_encode_frame(AVCodecContext *avctx, unsigned char *frame, int buf_size, void *data) { Mp3AudioContext *s = avctx->priv_data; int [[num]], i; if (s->stereo) { [[num]] = lame_encode_buffer_interleaved(s->gfp, data, MPA_FRAME_SIZE, frame, buf_size); } else { [[num]] = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE, frame, buf_size); } return [[num]]; }

[[[[Adv]]]]: int MP3lame_encode_frame(AVCodecContext *avctx, unsigned char *frame, int buf_size, void *data) { Mp3AudioContext *s = avctx->priv_data; int [[voil]], i; if (s->stereo) { [[voil]] = lame_encode_buffer_interleaved(s->gfp, data, MPA_FRAME_SIZE, frame, buf_size); } else { [[voil]] = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE, frame, buf_size); } return [[voil]]; }
--------------------------------------------- Result 670 ---------------------------------------------
[[0 (62%)]] --> [[0 (50%)]] --> Socre: 0.5032914280891418

[[[[Adv]]]]: int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *[[buf]], int len) { int [[offset]] = 0, counter = 10; int res; if (!s->chr_sync_read) { return 0; } if (s->replay && replay_mode == REPLAY_MODE_PLAY) { return replay_char_read_all_load([[buf]]); } while ([[offset]] < len) { do { res = s->chr_sync_read(s, [[buf]] + [[offset]], len - [[offset]]); if (res == -1 && errno == EAGAIN) { g_usleep(100); } } while (res == -1 && errno == EAGAIN); if (res == 0) { break; } if (res < 0) { if (s->replay && replay_mode == REPLAY_MODE_RECORD) { replay_char_read_all_save_error(res); } return res; } [[offset]] += res; if (!counter--) { break; } } if (s->replay && replay_mode == REPLAY_MODE_RECORD) { replay_char_read_all_save_buf([[buf]], [[offset]]); } return [[offset]]; }

[[[[Adv]]]]: int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *[[goyim]], int len) { int [[neutralizing]] = 0, counter = 10; int res; if (!s->chr_sync_read) { return 0; } if (s->replay && replay_mode == REPLAY_MODE_PLAY) { return replay_char_read_all_load([[goyim]]); } while ([[neutralizing]] < len) { do { res = s->chr_sync_read(s, [[goyim]] + [[neutralizing]], len - [[neutralizing]]); if (res == -1 && errno == EAGAIN) { g_usleep(100); } } while (res == -1 && errno == EAGAIN); if (res == 0) { break; } if (res < 0) { if (s->replay && replay_mode == REPLAY_MODE_RECORD) { replay_char_read_all_save_error(res); } return res; } [[neutralizing]] += res; if (!counter--) { break; } } if (s->replay && replay_mode == REPLAY_MODE_RECORD) { replay_char_read_all_save_buf([[goyim]], [[neutralizing]]); } return [[neutralizing]]; }
--------------------------------------------- Result 671 ---------------------------------------------
[[0 (54%)]] --> [[0 (49%)]] --> Socre: 0.5111997425556183

[[[[Adv]]]]: static int decode_b_picture_secondary_header(VC9Context *[[v]]) { GetBitContext *gb = &[[v]]->s.gb; int status; bitplane_decoding(&[[v]]->skip_mb_plane, [[v]]); if (status < 0) return -1; #if TRACE if ([[v]]->mv_mode == MV_PMODE_MIXED_MV) { status = bitplane_decoding(&[[v]]->mv_type_mb_plane, [[v]]); if (status < 0) return -1; #if TRACE av_log([[v]]->s.avctx, AV_LOG_DEBUG, "MB MV Type plane encoding: " "Imode: %i, Invert: %i\n", status>>1, status&1); #endif } status = bitplane_decoding(&[[v]]->direct_mb_plane, [[v]]); if (status < 0) return -1; #if TRACE av_log([[v]]->s.avctx, AV_LOG_DEBUG, "MB Direct plane encoding: " "Imode: %i, Invert: %i\n", status>>1, status&1); #endif av_log([[v]]->s.avctx, AV_LOG_DEBUG, "Skip MB plane encoding: " "Imode: %i, Invert: %i\n", status>>1, status&1); #endif [[v]]->s.mv_table_index = get_bits(gb, 2); [[v]]->cbpcy_vlc = &vc9_cbpcy_p_vlc[get_bits(gb, 2)]; if ([[v]]->dquant) { vop_dquant_decoding([[v]]); } if ([[v]]->vstransform) { [[v]]->ttmbf = get_bits(gb, 1); if ([[v]]->ttmbf) { [[v]]->ttfrm = get_bits(gb, 2); av_log([[v]]->s.avctx, AV_LOG_INFO, "Transform used: %ix%i\n", ([[v]]->ttfrm & 2) ? 4 : 8, ([[v]]->ttfrm & 1) ? 4 : 8); } } return 0; }

[[[[Adv]]]]: static int decode_b_picture_secondary_header(VC9Context *[[vs]]) { GetBitContext *gb = &[[vs]]->s.gb; int status; bitplane_decoding(&[[vs]]->skip_mb_plane, [[vs]]); if (status < 0) return -1; #if TRACE if ([[vs]]->mv_mode == MV_PMODE_MIXED_MV) { status = bitplane_decoding(&[[vs]]->mv_type_mb_plane, [[vs]]); if (status < 0) return -1; #if TRACE av_log([[vs]]->s.avctx, AV_LOG_DEBUG, "MB MV Type plane encoding: " "Imode: %i, Invert: %i\n", status>>1, status&1); #endif } status = bitplane_decoding(&[[vs]]->direct_mb_plane, [[vs]]); if (status < 0) return -1; #if TRACE av_log([[vs]]->s.avctx, AV_LOG_DEBUG, "MB Direct plane encoding: " "Imode: %i, Invert: %i\n", status>>1, status&1); #endif av_log([[vs]]->s.avctx, AV_LOG_DEBUG, "Skip MB plane encoding: " "Imode: %i, Invert: %i\n", status>>1, status&1); #endif [[vs]]->s.mv_table_index = get_bits(gb, 2); [[vs]]->cbpcy_vlc = &vc9_cbpcy_p_vlc[get_bits(gb, 2)]; if ([[vs]]->dquant) { vop_dquant_decoding([[vs]]); } if ([[vs]]->vstransform) { [[vs]]->ttmbf = get_bits(gb, 1); if ([[vs]]->ttmbf) { [[vs]]->ttfrm = get_bits(gb, 2); av_log([[vs]]->s.avctx, AV_LOG_INFO, "Transform used: %ix%i\n", ([[vs]]->ttfrm & 2) ? 4 : 8, ([[vs]]->ttfrm & 1) ? 4 : 8); } } return 0; }
--------------------------------------------- Result 672 ---------------------------------------------
[[0 (67%)]] --> [[0 (42%)]] --> Socre: 0.578835666179657

[[[[Adv]]]]: static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv) { int [[i]]; for ([[i]] = 0; [[i]] < s->nb_streams; [[i]]++) { MXFTrack *track = s->streams[[[i]]]->priv_data; if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number))) return [[i]]; } return s->nb_streams == 1 ? 0 : -1; }

[[[[Adv]]]]: static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv) { int [[know]]; for ([[know]] = 0; [[know]] < s->nb_streams; [[know]]++) { MXFTrack *track = s->streams[[[know]]]->priv_data; if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number))) return [[know]]; } return s->nb_streams == 1 ? 0 : -1; }
[Succeeded / Failed / Skipped / Total] 384 / 40 / 249 / 673:  25%|       | 673/2690 [7:40:23<22:59:48, 41.05s/it][Succeeded / Failed / Skipped / Total] 384 / 40 / 249 / 673:  25%|       | 674/2690 [7:44:21<23:08:55, 41.34s/it][Succeeded / Failed / Skipped / Total] 385 / 40 / 249 / 674:  25%|       | 674/2690 [7:44:21<23:08:55, 41.34s/it][Succeeded / Failed / Skipped / Total] 385 / 40 / 249 / 674:  25%|       | 675/2690 [7:44:21<23:06:11, 41.28s/it]--------------------------------------------- Result 673 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void vc1_mc_1mv(VC1Context *v, int dir) { MpegEncContext *s = &v->s; H264ChromaContext *h264chroma = &v->h264chroma; uint8_t *srcY, *srcU, *srcV; int dxy, mx, my, uvmx, uvmy, src_x, src_y, uvsrc_x, uvsrc_y; int v_edge_pos = s->v_edge_pos >> v->field_mode; int i; uint8_t (*luty)[256], (*lutuv)[256]; int use_ic; if ((!v->field_mode || (v->ref_field_type[dir] == 1 && v->cur_field_type == 1)) && !v->s.last_picture.f.data[0]) return; mx = s->mv[dir][0][0]; my = s->mv[dir][0][1]; if (s->pict_type == AV_PICTURE_TYPE_P) { for (i = 0; i < 4; i++) { s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][0] = mx; s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][1] = my; } } uvmx = (mx + ((mx & 3) == 3)) >> 1; uvmy = (my + ((my & 3) == 3)) >> 1; v->luma_mv[s->mb_x][0] = uvmx; v->luma_mv[s->mb_x][1] = uvmy; if (v->field_mode && v->cur_field_type != v->ref_field_type[dir]) { my = my - 2 + 4 * v->cur_field_type; uvmy = uvmy - 2 + 4 * v->cur_field_type; } if (v->fastuvmc && (v->fcm != ILACE_FRAME)) { uvmx = uvmx + ((uvmx < 0) ? (uvmx & 1) : -(uvmx & 1)); uvmy = uvmy + ((uvmy < 0) ? (uvmy & 1) : -(uvmy & 1)); } if (!dir) { if (v->field_mode && (v->cur_field_type != v->ref_field_type[dir]) && v->second_field) { srcY = s->current_picture.f.data[0]; srcU = s->current_picture.f.data[1]; srcV = s->current_picture.f.data[2]; luty = v->curr_luty; lutuv = v->curr_lutuv; use_ic = v->curr_use_ic; } else { srcY = s->last_picture.f.data[0]; srcU = s->last_picture.f.data[1]; srcV = s->last_picture.f.data[2]; luty = v->last_luty; lutuv = v->last_lutuv; use_ic = v->last_use_ic; } } else { srcY = s->next_picture.f.data[0]; srcU = s->next_picture.f.data[1]; srcV = s->next_picture.f.data[2]; luty = v->next_luty; lutuv = v->next_lutuv; use_ic = v->next_use_ic; } if (!srcY || !srcU) { av_log(v->s.avctx, AV_LOG_ERROR, "Referenced frame missing.\n"); return; } src_x = s->mb_x * 16 + (mx >> 2); src_y = s->mb_y * 16 + (my >> 2); uvsrc_x = s->mb_x * 8 + (uvmx >> 2); uvsrc_y = s->mb_y * 8 + (uvmy >> 2); if (v->profile != PROFILE_ADVANCED) { src_x = av_clip( src_x, -16, s->mb_width * 16); src_y = av_clip( src_y, -16, s->mb_height * 16); uvsrc_x = av_clip(uvsrc_x, -8, s->mb_width * 8); uvsrc_y = av_clip(uvsrc_y, -8, s->mb_height * 8); } else { src_x = av_clip( src_x, -17, s->avctx->coded_width); src_y = av_clip( src_y, -18, s->avctx->coded_height + 1); uvsrc_x = av_clip(uvsrc_x, -8, s->avctx->coded_width >> 1); uvsrc_y = av_clip(uvsrc_y, -8, s->avctx->coded_height >> 1); } srcY += src_y * s->linesize + src_x; srcU += uvsrc_y * s->uvlinesize + uvsrc_x; srcV += uvsrc_y * s->uvlinesize + uvsrc_x; if (v->field_mode && v->ref_field_type[dir]) { srcY += s->current_picture_ptr->f.linesize[0]; srcU += s->current_picture_ptr->f.linesize[1]; srcV += s->current_picture_ptr->f.linesize[2]; } if (s->flags & CODEC_FLAG_GRAY) { srcU = s->edge_emu_buffer + 18 * s->linesize; srcV = s->edge_emu_buffer + 18 * s->linesize; } if (v->rangeredfrm || use_ic || s->h_edge_pos < 22 || v_edge_pos < 22 || (unsigned)(src_x - s->mspel) > s->h_edge_pos - (mx&3) - 16 - s->mspel * 3 || (unsigned)(src_y - 1) > v_edge_pos - (my&3) - 16 - 3) { uint8_t *uvbuf = s->edge_emu_buffer + 19 * s->linesize; srcY -= s->mspel * (1 + s->linesize); s->vdsp.emulated_edge_mc(s->edge_emu_buffer, srcY, s->linesize, s->linesize, 17 + s->mspel * 2, 17 + s->mspel * 2, src_x - s->mspel, src_y - s->mspel, s->h_edge_pos, v_edge_pos); srcY = s->edge_emu_buffer; s->vdsp.emulated_edge_mc(uvbuf, srcU, s->uvlinesize, s->uvlinesize, 8 + 1, 8 + 1, uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, v_edge_pos >> 1); s->vdsp.emulated_edge_mc(uvbuf + 16, srcV, s->uvlinesize, s->uvlinesize, 8 + 1, 8 + 1, uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, v_edge_pos >> 1); srcU = uvbuf; srcV = uvbuf + 16; if (v->rangeredfrm) { int i, j; uint8_t *src, *src2; src = srcY; for (j = 0; j < 17 + s->mspel * 2; j++) { for (i = 0; i < 17 + s->mspel * 2; i++) src[i] = ((src[i] - 128) >> 1) + 128; src += s->linesize; } src = srcU; src2 = srcV; for (j = 0; j < 9; j++) { for (i = 0; i < 9; i++) { src[i] = ((src[i] - 128) >> 1) + 128; src2[i] = ((src2[i] - 128) >> 1) + 128; } src += s->uvlinesize; src2 += s->uvlinesize; } } if (use_ic) { int i, j; uint8_t *src, *src2; src = srcY; for (j = 0; j < 17 + s->mspel * 2; j++) { int f = v->field_mode ? v->ref_field_type[dir] : ((j + src_y - s->mspel) & 1) ; for (i = 0; i < 17 + s->mspel * 2; i++) src[i] = luty[f][src[i]]; src += s->linesize; } src = srcU; src2 = srcV; for (j = 0; j < 9; j++) { int f = v->field_mode ? v->ref_field_type[dir] : ((j + uvsrc_y) & 1); for (i = 0; i < 9; i++) { src[i] = lutuv[f][src[i]]; src2[i] = lutuv[f][src2[i]]; } src += s->uvlinesize; src2 += s->uvlinesize; } } srcY += s->mspel * (1 + s->linesize); } if (s->mspel) { dxy = ((my & 3) << 2) | (mx & 3); v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] , srcY , s->linesize, v->rnd); v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8, srcY + 8, s->linesize, v->rnd); srcY += s->linesize * 8; v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize , srcY , s->linesize, v->rnd); v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize + 8, srcY + 8, s->linesize, v->rnd); } else { dxy = (my & 2) | ((mx & 2) >> 1); if (!v->rnd) s->hdsp.put_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16); else s->hdsp.put_no_rnd_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16); } if (s->flags & CODEC_FLAG_GRAY) return; uvmx = (uvmx & 3) << 1; uvmy = (uvmy & 3) << 1; if (!v->rnd) { h264chroma->put_h264_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy); h264chroma->put_h264_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy); } else { v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy); v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy); } }
--------------------------------------------- Result 674 ---------------------------------------------
[[0 (3%)]] --> [[0 (71%)]] --> Socre: 0.7118016481399536

[[[[Adv]]]]: static void lsi_ram_write(void *opaque, target_phys_addr_t [[addr]], uint64_t val, unsigned size) { LSIState *s = opaque; uint32_t newval; uint32_t mask; int shift; newval = s->script_ram[[[addr]] >> 2]; shift = ([[addr]] & 3) * 8; mask = ((uint64_t)1 << (size * 8)) - 1; newval &= ~(mask << shift); newval |= val << shift; s->script_ram[[[addr]] >> 2] = newval; }

[[[[Adv]]]]: static void lsi_ram_write(void *opaque, target_phys_addr_t [[soire]], uint64_t val, unsigned size) { LSIState *s = opaque; uint32_t newval; uint32_t mask; int shift; newval = s->script_ram[[[soire]] >> 2]; shift = ([[soire]] & 3) * 8; mask = ((uint64_t)1 << (size * 8)) - 1; newval &= ~(mask << shift); newval |= val << shift; s->script_ram[[[soire]] >> 2] = newval; }
--------------------------------------------- Result 675 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 385 / 40 / 250 / 675:  25%|       | 675/2690 [7:44:21<23:06:11, 41.28s/it][Succeeded / Failed / Skipped / Total] 385 / 40 / 250 / 675:  25%|       | 676/2690 [7:47:42<23:13:26, 41.51s/it][Succeeded / Failed / Skipped / Total] 386 / 40 / 250 / 676:  25%|       | 676/2690 [7:47:42<23:13:26, 41.51s/it][Succeeded / Failed / Skipped / Total] 386 / 40 / 250 / 676:  25%|       | 677/2690 [7:47:42<23:10:42, 41.45s/it][Succeeded / Failed / Skipped / Total] 386 / 40 / 251 / 677:  25%|       | 677/2690 [7:47:42<23:10:42, 41.45s/it][Succeeded / Failed / Skipped / Total] 386 / 40 / 251 / 677:  25%|       | 678/2690 [7:47:48<23:08:15, 41.40s/it][Succeeded / Failed / Skipped / Total] 387 / 40 / 251 / 678:  25%|       | 678/2690 [7:47:48<23:08:15, 41.40s/it][Succeeded / Failed / Skipped / Total] 387 / 40 / 251 / 678:  25%|       | 679/2690 [7:47:55<23:05:50, 41.35s/it][[0 (81%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mtv_read_header(AVFormatContext *s) { MTVDemuxContext *mtv = s->priv_data; AVIOContext *pb = s->pb; AVStream *st; unsigned int audio_subsegments; avio_skip(pb, 3); mtv->file_size = avio_rl32(pb); mtv->segments = avio_rl32(pb); avio_skip(pb, 32); mtv->audio_identifier = avio_rl24(pb); mtv->audio_br = avio_rl16(pb); mtv->img_colorfmt = avio_rl24(pb); mtv->img_bpp = avio_r8(pb); mtv->img_width = avio_rl16(pb); mtv->img_height = avio_rl16(pb); mtv->img_segment_size = avio_rl16(pb); if(mtv->img_bpp>>3){ if(!mtv->img_width && mtv->img_height) mtv->img_width=mtv->img_segment_size / (mtv->img_bpp>>3) / mtv->img_height; if(!mtv->img_height && mtv->img_width) mtv->img_height=mtv->img_segment_size / (mtv->img_bpp>>3) / mtv->img_width; } if(!mtv->img_height || !mtv->img_width || !mtv->img_segment_size){ av_log(s, AV_LOG_ERROR, "width or height or segment_size is invalid and I cannot calculate them from other information\n"); return AVERROR(EINVAL); } avio_skip(pb, 4); audio_subsegments = avio_rl16(pb); if (audio_subsegments == 0) { avpriv_request_sample(s, "MTV files without audio"); return AVERROR_PATCHWELCOME; } mtv->full_segment_size = audio_subsegments * (MTV_AUDIO_PADDING_SIZE + MTV_ASUBCHUNK_DATA_SIZE) + mtv->img_segment_size; mtv->video_fps = (mtv->audio_br / 4) / audio_subsegments; st = avformat_new_stream(s, NULL); if(!st) return AVERROR(ENOMEM); avpriv_set_pts_info(st, 64, 1, mtv->video_fps); st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->codec->codec_id = AV_CODEC_ID_RAWVIDEO; st->codec->pix_fmt = AV_PIX_FMT_RGB565BE; st->codec->width = mtv->img_width; st->codec->height = mtv->img_height; st->codec->sample_rate = mtv->video_fps; st->codec->extradata = av_strdup("BottomUp"); st->codec->extradata_size = 9; st = avformat_new_stream(s, NULL); if(!st) return AVERROR(ENOMEM); avpriv_set_pts_info(st, 64, 1, AUDIO_SAMPLING_RATE); st->codec->codec_type = AVMEDIA_TYPE_AUDIO; st->codec->codec_id = AV_CODEC_ID_MP3; st->codec->bit_rate = mtv->audio_br; st->need_parsing = AVSTREAM_PARSE_FULL; if(avio_seek(pb, MTV_HEADER_SIZE, SEEK_SET) != MTV_HEADER_SIZE) return AVERROR(EIO); return 0; }
--------------------------------------------- Result 676 ---------------------------------------------
[[0 (86%)]] --> [[0 (46%)]] --> Socre: 0.5355807542800903

[[[[Adv]]]]: static bool qht_insert__locked(struct qht *ht, struct qht_map *map, struct qht_bucket *head, void *p, uint32_t hash, bool *needs_resize) { struct qht_bucket *[[b]] = head; struct qht_bucket *[[prev]] = NULL; struct qht_bucket *new = NULL; int i; do { for (i = 0; i < QHT_BUCKET_ENTRIES; i++) { if ([[b]]->pointers[i]) { if (unlikely([[b]]->pointers[i] == p)) { return "False" != "False"; } } else { goto found; } } [[prev]] = [[b]]; [[b]] = [[b]]->next; } while ([[b]]); [[b]] = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*[[b]])); memset([[b]], 0, sizeof(*[[b]])); new = b; i = 0; atomic_inc(&map->n_added_buckets); if (unlikely(qht_map_needs_resize(map)) && needs_resize) { *needs_resize = "True" == "True"; } found: seqlock_write_begin(&head->sequence); if (new) { atomic_rcu_set(&[[prev]]->next, [[b]]); } [[b]]->hashes[i] = hash; atomic_set(&[[b]]->pointers[i], p); seqlock_write_end(&head->sequence); return "True" == "True"; }

[[[[Adv]]]]: static bool qht_insert__locked(struct qht *ht, struct qht_map *map, struct qht_bucket *head, void *p, uint32_t hash, bool *needs_resize) { struct qht_bucket *[[segundo]] = head; struct qht_bucket *[[inertial]] = NULL; struct qht_bucket *new = NULL; int i; do { for (i = 0; i < QHT_BUCKET_ENTRIES; i++) { if ([[segundo]]->pointers[i]) { if (unlikely([[segundo]]->pointers[i] == p)) { return "False" != "False"; } } else { goto found; } } [[inertial]] = [[segundo]]; [[segundo]] = [[segundo]]->next; } while ([[segundo]]); [[segundo]] = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*[[segundo]])); memset([[segundo]], 0, sizeof(*[[segundo]])); new = b; i = 0; atomic_inc(&map->n_added_buckets); if (unlikely(qht_map_needs_resize(map)) && needs_resize) { *needs_resize = "True" == "True"; } found: seqlock_write_begin(&head->sequence); if (new) { atomic_rcu_set(&[[inertial]]->next, [[segundo]]); } [[segundo]]->hashes[i] = hash; atomic_set(&[[segundo]]->pointers[i], p); seqlock_write_end(&head->sequence); return "True" == "True"; }
--------------------------------------------- Result 677 ---------------------------------------------
[[0 (35%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup) { pkt->data = NULL; pkt->side_data = NULL; if (pkt->buf) { AVBufferRef *ref = av_buffer_ref(src->buf); if (!ref) return AVERROR(ENOMEM); pkt->buf = ref; pkt->data = ref->data; } else { DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF); } #if FF_API_DESTRUCT_PACKET FF_DISABLE_DEPRECATION_WARNINGS pkt->destruct = dummy_destruct_packet; FF_ENABLE_DEPRECATION_WARNINGS #endif if (pkt->side_data_elems && dup) pkt->side_data = src->side_data; if (pkt->side_data_elems && !dup) { return av_copy_packet_side_data(pkt, src); } return 0; failed_alloc: av_destruct_packet(pkt); return AVERROR(ENOMEM); }
--------------------------------------------- Result 678 ---------------------------------------------
[[0 (18%)]] --> [[0 (73%)]] --> Socre: 0.7290678024291992

[[[[Adv]]]]: static void virtio_crypto_instance_init(Object *obj) { VirtIOCrypto *[[vcrypto]] = VIRTIO_CRYPTO(obj); [[vcrypto]]->config_size = sizeof(struct virtio_crypto_config); object_property_add_link(obj, "cryptodev", TYPE_CRYPTODEV_BACKEND, (Object **)&[[vcrypto]]->conf.cryptodev, virtio_crypto_check_cryptodev_is_used, OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL); }

[[[[Adv]]]]: static void virtio_crypto_instance_init(Object *obj) { VirtIOCrypto *[[toothpicks]] = VIRTIO_CRYPTO(obj); [[toothpicks]]->config_size = sizeof(struct virtio_crypto_config); object_property_add_link(obj, "cryptodev", TYPE_CRYPTODEV_BACKEND, (Object **)&[[toothpicks]]->conf.cryptodev, virtio_crypto_check_cryptodev_is_used, OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL); }
--------------------------------------------- Result 679 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 388 / 40 / 251 / 679:  25%|       | 679/2690 [7:47:55<23:05:50, 41.35s/it][Succeeded / Failed / Skipped / Total] 388 / 40 / 251 / 679:  25%|       | 680/2690 [7:47:59<23:03:20, 41.29s/it][Succeeded / Failed / Skipped / Total] 389 / 40 / 251 / 680:  25%|       | 680/2690 [7:47:59<23:03:20, 41.29s/it][Succeeded / Failed / Skipped / Total] 389 / 40 / 251 / 680:  25%|       | 681/2690 [7:48:00<23:00:38, 41.23s/it][Succeeded / Failed / Skipped / Total] 389 / 40 / 252 / 681:  25%|       | 681/2690 [7:48:00<23:00:38, 41.23s/it][Succeeded / Failed / Skipped / Total] 389 / 40 / 252 / 681:  25%|       | 682/2690 [7:51:12<23:07:23, 41.46s/it][[0 (12%)]] --> [[0 (97%)]] --> Socre: 0.9727419018745422

[[[[Adv]]]]: int cpu_sh4_handle_mmu_fault(CPUState * [[env]], target_ulong address, int rw, int mmu_idx, int is_softmmu) { target_ulong physical; int prot, ret, access_type; access_type = ACCESS_INT; ret = get_physical_address([[env]], &physical, &prot, address, rw, access_type); if (ret != MMU_OK) { [[env]]->tea = address; switch (ret) { case MMU_ITLB_MISS: case MMU_DTLB_MISS_READ: [[env]]->exception_index = 0x040; break; case MMU_DTLB_MULTIPLE: case MMU_ITLB_MULTIPLE: [[env]]->exception_index = 0x140; break; case MMU_ITLB_VIOLATION: [[env]]->exception_index = 0x0a0; break; case MMU_DTLB_MISS_WRITE: [[env]]->exception_index = 0x060; break; case MMU_DTLB_INITIAL_WRITE: [[env]]->exception_index = 0x080; break; case MMU_DTLB_VIOLATION_READ: [[env]]->exception_index = 0x0a0; break; case MMU_DTLB_VIOLATION_WRITE: [[env]]->exception_index = 0x0c0; break; case MMU_IADDR_ERROR: case MMU_DADDR_ERROR_READ: [[env]]->exception_index = 0x0c0; break; case MMU_DADDR_ERROR_WRITE: [[env]]->exception_index = 0x100; break; default: assert(0); } return 1; } address &= TARGET_PAGE_MASK; physical &= TARGET_PAGE_MASK; return tlb_set_page([[env]], address, physical, prot, mmu_idx, is_softmmu); }

[[[[Adv]]]]: int cpu_sh4_handle_mmu_fault(CPUState * [[snip]], target_ulong address, int rw, int mmu_idx, int is_softmmu) { target_ulong physical; int prot, ret, access_type; access_type = ACCESS_INT; ret = get_physical_address([[snip]], &physical, &prot, address, rw, access_type); if (ret != MMU_OK) { [[snip]]->tea = address; switch (ret) { case MMU_ITLB_MISS: case MMU_DTLB_MISS_READ: [[snip]]->exception_index = 0x040; break; case MMU_DTLB_MULTIPLE: case MMU_ITLB_MULTIPLE: [[snip]]->exception_index = 0x140; break; case MMU_ITLB_VIOLATION: [[snip]]->exception_index = 0x0a0; break; case MMU_DTLB_MISS_WRITE: [[snip]]->exception_index = 0x060; break; case MMU_DTLB_INITIAL_WRITE: [[snip]]->exception_index = 0x080; break; case MMU_DTLB_VIOLATION_READ: [[snip]]->exception_index = 0x0a0; break; case MMU_DTLB_VIOLATION_WRITE: [[snip]]->exception_index = 0x0c0; break; case MMU_IADDR_ERROR: case MMU_DADDR_ERROR_READ: [[snip]]->exception_index = 0x0c0; break; case MMU_DADDR_ERROR_WRITE: [[snip]]->exception_index = 0x100; break; default: assert(0); } return 1; } address &= TARGET_PAGE_MASK; physical &= TARGET_PAGE_MASK; return tlb_set_page([[snip]], address, physical, prot, mmu_idx, is_softmmu); }
--------------------------------------------- Result 680 ---------------------------------------------
[[0 (69%)]] --> [[0 (42%)]] --> Socre: 0.5806016325950623

[[[[Adv]]]]: static int virtio_blk_device_exit(DeviceState *dev) { VirtIODevice *[[vdev]] = VIRTIO_DEVICE(dev); VirtIOBlock *[[s]] = VIRTIO_BLK(dev); #ifdef CONFIG_VIRTIO_BLK_DATA_PLANE remove_migration_state_change_notifier(&[[s]]->migration_state_notifier); virtio_blk_data_plane_destroy([[s]]->dataplane); [[s]]->dataplane = NULL; #endif qemu_del_vm_change_state_handler([[s]]->change); unregister_savevm(dev, "virtio-blk", [[s]]); blockdev_mark_auto_del([[s]]->bs); virtio_cleanup([[vdev]]); return 0; }

[[[[Adv]]]]: static int virtio_blk_device_exit(DeviceState *dev) { VirtIODevice *[[firework]] = VIRTIO_DEVICE(dev); VirtIOBlock *[[either]] = VIRTIO_BLK(dev); #ifdef CONFIG_VIRTIO_BLK_DATA_PLANE remove_migration_state_change_notifier(&[[either]]->migration_state_notifier); virtio_blk_data_plane_destroy([[either]]->dataplane); [[either]]->dataplane = NULL; #endif qemu_del_vm_change_state_handler([[either]]->change); unregister_savevm(dev, "virtio-blk", [[either]]); blockdev_mark_auto_del([[either]]->bs); virtio_cleanup([[firework]]); return 0; }
--------------------------------------------- Result 681 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name, void *opaque, Error **errp) { uint64_t value; MemoryRegion *mr; PCDIMMDevice *dimm = PC_DIMM(obj); PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj); mr = ddc->get_memory_region(dimm); value = memory_region_size(mr); visit_type_uint64(v, name, &value, errp); }
--------------------------------------------- Result 682 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 390 / 40 / 252 / 682:  25%|       | 682/2690 [7:51:12<23:07:23, 41.46s/it][Succeeded / Failed / Skipped / Total] 390 / 40 / 252 / 682:  25%|       | 683/2690 [7:51:13<23:04:41, 41.40s/it][Succeeded / Failed / Skipped / Total] 390 / 40 / 253 / 683:  25%|       | 683/2690 [7:51:13<23:04:41, 41.40s/it][Succeeded / Failed / Skipped / Total] 390 / 40 / 253 / 683:  25%|       | 684/2690 [7:51:20<23:02:19, 41.35s/it][[0 (1%)]] --> [[0 (66%)]] --> Socre: 0.6638049483299255

[[[[Adv]]]]: static void avc_luma_vt_and_aver_dst_16x16_msa(const uint8_t *src, int32_t src_stride, uint8_t *dst, int32_t [[dst_stride]]) { int32_t loop_cnt; int16_t [[filt_const0]] = 0xfb01; int16_t [[filt_const1]] = 0x1414; int16_t filt_const2 = 0x1fb; v16u8 dst0, dst1, dst2, dst3; v16i8 [[src0]], src1, src2, src3, src4, src5, src6, src7, src8; v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r; v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l; v16i8 src65_l, src87_l; v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l; v16i8 filt0, filt1, filt2; v16u8 res0, res1, res2, res3; filt0 = (v16i8) __msa_fill_h([[filt_const0]]); filt1 = (v16i8) __msa_fill_h([[filt_const1]]); filt2 = (v16i8) __msa_fill_h(filt_const2); LD_SB5(src, src_stride, [[src0]], src1, src2, src3, src4); src += (5 * src_stride); XORI_B5_128_SB([[src0]], src1, src2, src3, src4); ILVR_B4_SB(src1, [[src0]], src2, src1, src3, src2, src4, src3, src10_r, src21_r, src32_r, src43_r); ILVL_B4_SB(src1, [[src0]], src2, src1, src3, src2, src4, src3, src10_l, src21_l, src32_l, src43_l); for (loop_cnt = 4; loop_cnt--;) { LD_SB4(src, src_stride, src5, src6, src7, src8); src += (4 * src_stride); XORI_B4_128_SB(src5, src6, src7, src8); ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_r, src65_r, src76_r, src87_r); ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_l, src65_l, src76_l, src87_l); out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, filt0, filt1, filt2); out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2); out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2); out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, filt0, filt1, filt2); out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2); out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2); out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2); out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2); SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5); SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5); SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7); SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7); LD_UB4(dst, [[dst_stride]], dst0, dst1, dst2, dst3); PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l, out3_r, res0, res1, res2, res3); XORI_B4_128_UB(res0, res1, res2, res3); AVER_UB4_UB(res0, dst0, res1, dst1, res2, dst2, res3, dst3, res0, res1, res2, res3); ST_UB4(res0, res1, res2, res3, dst, [[dst_stride]]); dst += (4 * [[dst_stride]]); src10_r = src54_r; src32_r = src76_r; src21_r = src65_r; src43_r = src87_r; src10_l = src54_l; src32_l = src76_l; src21_l = src65_l; src43_l = src87_l; src4 = src8; } }

[[[[Adv]]]]: static void avc_luma_vt_and_aver_dst_16x16_msa(const uint8_t *src, int32_t src_stride, uint8_t *dst, int32_t [[disappointing]]) { int32_t loop_cnt; int16_t [[repelling]] = 0xfb01; int16_t [[thereon]] = 0x1414; int16_t filt_const2 = 0x1fb; v16u8 dst0, dst1, dst2, dst3; v16i8 [[caf]], src1, src2, src3, src4, src5, src6, src7, src8; v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r; v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l; v16i8 src65_l, src87_l; v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l; v16i8 filt0, filt1, filt2; v16u8 res0, res1, res2, res3; filt0 = (v16i8) __msa_fill_h([[repelling]]); filt1 = (v16i8) __msa_fill_h([[thereon]]); filt2 = (v16i8) __msa_fill_h(filt_const2); LD_SB5(src, src_stride, [[caf]], src1, src2, src3, src4); src += (5 * src_stride); XORI_B5_128_SB([[caf]], src1, src2, src3, src4); ILVR_B4_SB(src1, [[caf]], src2, src1, src3, src2, src4, src3, src10_r, src21_r, src32_r, src43_r); ILVL_B4_SB(src1, [[caf]], src2, src1, src3, src2, src4, src3, src10_l, src21_l, src32_l, src43_l); for (loop_cnt = 4; loop_cnt--;) { LD_SB4(src, src_stride, src5, src6, src7, src8); src += (4 * src_stride); XORI_B4_128_SB(src5, src6, src7, src8); ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_r, src65_r, src76_r, src87_r); ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7, src54_l, src65_l, src76_l, src87_l); out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, filt0, filt1, filt2); out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2); out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2); out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, filt0, filt1, filt2); out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2); out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2); out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2); out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2); SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5); SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5); SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7); SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7); LD_UB4(dst, [[disappointing]], dst0, dst1, dst2, dst3); PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l, out3_r, res0, res1, res2, res3); XORI_B4_128_UB(res0, res1, res2, res3); AVER_UB4_UB(res0, dst0, res1, dst1, res2, dst2, res3, dst3, res0, res1, res2, res3); ST_UB4(res0, res1, res2, res3, dst, [[disappointing]]); dst += (4 * [[disappointing]]); src10_r = src54_r; src32_r = src76_r; src21_r = src65_r; src43_r = src87_r; src10_l = src54_l; src32_l = src76_l; src21_l = src65_l; src43_l = src87_l; src4 = src8; } }
--------------------------------------------- Result 683 ---------------------------------------------
[[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd) { SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, req->dev); SCSIGenericReq *r = DO_UPCAST(SCSIGenericReq, req, req); int ret; if (cmd[0] != REQUEST_SENSE && req->lun != s->qdev.lun) { DPRINTF("Unimplemented LUN %d\n", req->lun); scsi_req_build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED)); scsi_req_complete(&r->req, CHECK_CONDITION); return 0; } if (-1 == scsi_req_parse(&r->req, cmd)) { BADF("Unsupported command length, command %x\n", cmd[0]); scsi_command_complete(r, -EINVAL); return 0; } scsi_req_fixup(&r->req); DPRINTF("Command: lun=%d tag=0x%x len %zd data=0x%02x", lun, tag, r->req.cmd.xfer, cmd[0]); #ifdef DEBUG_SCSI { int i; for (i = 1; i < r->req.cmd.len; i++) { printf(" 0x%02x", cmd[i]); } printf("\n"); } #endif if (r->req.cmd.xfer == 0) { if (r->buf != NULL) qemu_free(r->buf); r->buflen = 0; r->buf = NULL; ret = execute_command(s->bs, r, SG_DXFER_NONE, scsi_command_complete); if (ret < 0) { scsi_command_complete(r, ret); return 0; } return 0; } if (r->buflen != r->req.cmd.xfer) { if (r->buf != NULL) qemu_free(r->buf); r->buf = qemu_malloc(r->req.cmd.xfer); r->buflen = r->req.cmd.xfer; } memset(r->buf, 0, r->buflen); r->len = r->req.cmd.xfer; if (r->req.cmd.mode == SCSI_XFER_TO_DEV) { r->len = 0; return -r->req.cmd.xfer; } else { return r->req.cmd.xfer; } }
--------------------------------------------- Result 684 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 391 / 40 / 253 / 684:  25%|       | 684/2690 [7:51:20<23:02:19, 41.35s/it][Succeeded / Failed / Skipped / Total] 391 / 40 / 253 / 684:  25%|       | 685/2690 [7:51:25<22:59:50, 41.29s/it][Succeeded / Failed / Skipped / Total] 392 / 40 / 253 / 685:  25%|       | 685/2690 [7:51:25<22:59:50, 41.29s/it][Succeeded / Failed / Skipped / Total] 392 / 40 / 253 / 685:  26%|       | 686/2690 [7:51:25<22:57:10, 41.23s/it][[0 (23%)]] --> [[0 (51%)]] --> Socre: 0.5112298130989075

[[[[Adv]]]]: void ip6_input(struct mbuf *m) { struct ip6 *[[ip6]]; DEBUG_CALL("ip6_input"); DEBUG_ARG("m = %lx", (long)m); DEBUG_ARG("m_len = %d", m->m_len); if (m->m_len < sizeof(struct ip6)) { goto bad; } [[ip6]] = mtod(m, struct [[ip6]] *); if ([[ip6]]->ip_v != IP6VERSION) { goto bad; } if ([[ip6]]->ip_hl == 0) { goto bad; } switch ([[ip6]]->ip_nh) { case IPPROTO_TCP: break; case IPPROTO_UDP: break; case IPPROTO_ICMPV6: icmp6_input(m); break; default: m_free(m); } return; bad: m_free(m); }

[[[[Adv]]]]: void ip6_input(struct mbuf *m) { struct ip6 *[[painstaking]]; DEBUG_CALL("ip6_input"); DEBUG_ARG("m = %lx", (long)m); DEBUG_ARG("m_len = %d", m->m_len); if (m->m_len < sizeof(struct ip6)) { goto bad; } [[painstaking]] = mtod(m, struct [[painstaking]] *); if ([[painstaking]]->ip_v != IP6VERSION) { goto bad; } if ([[painstaking]]->ip_hl == 0) { goto bad; } switch ([[painstaking]]->ip_nh) { case IPPROTO_TCP: break; case IPPROTO_UDP: break; case IPPROTO_ICMPV6: icmp6_input(m); break; default: m_free(m); } return; bad: m_free(m); }
--------------------------------------------- Result 685 ---------------------------------------------
[[0 (39%)]] --> [[0 (79%)]] --> Socre: 0.7873016595840454

[[[[Adv]]]]: static int write_dump_pages(DumpState *s) { int ret = 0; DataCache page_desc, page_data; size_t len_buf_out, size_out; #ifdef CONFIG_LZO lzo_bytep wrkmem = NULL; #endif uint8_t *buf_out = NULL; off_t offset_desc, offset_data; PageDescriptor pd, pd_zero; uint8_t *[[buf]]; int endian = s->dump_info.d_endian; GuestPhysBlock *block_iter = NULL; uint64_t [[pfn_iter]]; offset_desc = s->offset_page; offset_data = offset_desc + sizeof(PageDescriptor) * s->num_dumpable; prepare_data_cache(&page_desc, s, offset_desc); prepare_data_cache(&page_data, s, offset_data); len_buf_out = get_len_buf_out(s->page_size, s->flag_compress); if (len_buf_out == 0) { dump_error(s, "dump: failed to get length of output buffer.\n"); goto out; } #ifdef CONFIG_LZO wrkmem = g_malloc(LZO1X_1_MEM_COMPRESS); #endif buf_out = g_malloc(len_buf_out); pd_zero.size = cpu_convert_to_target32(s->page_size, endian); pd_zero.flags = cpu_convert_to_target32(0, endian); pd_zero.offset = cpu_convert_to_target64(offset_data, endian); pd_zero.page_flags = cpu_convert_to_target64(0, endian); [[buf]] = g_malloc0(s->page_size); ret = write_cache(&page_data, [[buf]], s->page_size, "False" != "False"); g_free([[buf]]); if (ret < 0) { dump_error(s, "dump: failed to write page data(zero page).\n"); goto out; } offset_data += s->page_size; while (get_next_page(&block_iter, &[[pfn_iter]], &[[buf]], s)) { if (is_zero_page([[buf]], s->page_size)) { ret = write_cache(&page_desc, &pd_zero, sizeof(PageDescriptor), "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page desc.\n"); goto out; } } else { size_out = len_buf_out; if ((s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) && (compress2(buf_out, (uLongf *)&size_out, [[buf]], s->page_size, Z_BEST_SPEED) == Z_OK) && (size_out < s->page_size)) { pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_ZLIB, endian); pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, buf_out, size_out, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } #ifdef CONFIG_LZO } else if ((s->flag_compress & DUMP_DH_COMPRESSED_LZO) && (lzo1x_1_compress([[buf]], s->page_size, buf_out, (lzo_uint *)&size_out, wrkmem) == LZO_E_OK) && (size_out < s->page_size)) { pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_LZO, endian); pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, buf_out, size_out, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } #endif #ifdef CONFIG_SNAPPY } else if ((s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) && (snappy_compress((char *)[[buf]], s->page_size, (char *)buf_out, &size_out) == SNAPPY_OK) && (size_out < s->page_size)) { pd.flags = cpu_convert_to_target32( DUMP_DH_COMPRESSED_SNAPPY, endian); pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, buf_out, size_out, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } #endif } else { pd.flags = cpu_convert_to_target32(0, endian); size_out = s->page_size; pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, [[buf]], s->page_size, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } } pd.page_flags = cpu_convert_to_target64(0, endian); pd.offset = cpu_convert_to_target64(offset_data, endian); offset_data += size_out; ret = write_cache(&page_desc, &pd, sizeof(PageDescriptor), "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page desc.\n"); goto out; } } } ret = write_cache(&page_desc, NULL, 0, "True" == "True"); if (ret < 0) { dump_error(s, "dump: failed to sync cache for page_desc.\n"); goto out; } ret = write_cache(&page_data, NULL, 0, "True" == "True"); if (ret < 0) { dump_error(s, "dump: failed to sync cache for page_data.\n"); goto out; } out: free_data_cache(&page_desc); free_data_cache(&page_data); #ifdef CONFIG_LZO g_free(wrkmem); #endif g_free(buf_out); return ret; }

[[[[Adv]]]]: static int write_dump_pages(DumpState *s) { int ret = 0; DataCache page_desc, page_data; size_t len_buf_out, size_out; #ifdef CONFIG_LZO lzo_bytep wrkmem = NULL; #endif uint8_t *buf_out = NULL; off_t offset_desc, offset_data; PageDescriptor pd, pd_zero; uint8_t *[[hanu]]; int endian = s->dump_info.d_endian; GuestPhysBlock *block_iter = NULL; uint64_t [[nancy]]; offset_desc = s->offset_page; offset_data = offset_desc + sizeof(PageDescriptor) * s->num_dumpable; prepare_data_cache(&page_desc, s, offset_desc); prepare_data_cache(&page_data, s, offset_data); len_buf_out = get_len_buf_out(s->page_size, s->flag_compress); if (len_buf_out == 0) { dump_error(s, "dump: failed to get length of output buffer.\n"); goto out; } #ifdef CONFIG_LZO wrkmem = g_malloc(LZO1X_1_MEM_COMPRESS); #endif buf_out = g_malloc(len_buf_out); pd_zero.size = cpu_convert_to_target32(s->page_size, endian); pd_zero.flags = cpu_convert_to_target32(0, endian); pd_zero.offset = cpu_convert_to_target64(offset_data, endian); pd_zero.page_flags = cpu_convert_to_target64(0, endian); [[hanu]] = g_malloc0(s->page_size); ret = write_cache(&page_data, [[hanu]], s->page_size, "False" != "False"); g_free([[hanu]]); if (ret < 0) { dump_error(s, "dump: failed to write page data(zero page).\n"); goto out; } offset_data += s->page_size; while (get_next_page(&block_iter, &[[nancy]], &[[hanu]], s)) { if (is_zero_page([[hanu]], s->page_size)) { ret = write_cache(&page_desc, &pd_zero, sizeof(PageDescriptor), "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page desc.\n"); goto out; } } else { size_out = len_buf_out; if ((s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) && (compress2(buf_out, (uLongf *)&size_out, [[hanu]], s->page_size, Z_BEST_SPEED) == Z_OK) && (size_out < s->page_size)) { pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_ZLIB, endian); pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, buf_out, size_out, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } #ifdef CONFIG_LZO } else if ((s->flag_compress & DUMP_DH_COMPRESSED_LZO) && (lzo1x_1_compress([[hanu]], s->page_size, buf_out, (lzo_uint *)&size_out, wrkmem) == LZO_E_OK) && (size_out < s->page_size)) { pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_LZO, endian); pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, buf_out, size_out, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } #endif #ifdef CONFIG_SNAPPY } else if ((s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) && (snappy_compress((char *)[[hanu]], s->page_size, (char *)buf_out, &size_out) == SNAPPY_OK) && (size_out < s->page_size)) { pd.flags = cpu_convert_to_target32( DUMP_DH_COMPRESSED_SNAPPY, endian); pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, buf_out, size_out, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } #endif } else { pd.flags = cpu_convert_to_target32(0, endian); size_out = s->page_size; pd.size = cpu_convert_to_target32(size_out, endian); ret = write_cache(&page_data, [[hanu]], s->page_size, "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page data.\n"); goto out; } } pd.page_flags = cpu_convert_to_target64(0, endian); pd.offset = cpu_convert_to_target64(offset_data, endian); offset_data += size_out; ret = write_cache(&page_desc, &pd, sizeof(PageDescriptor), "False" != "False"); if (ret < 0) { dump_error(s, "dump: failed to write page desc.\n"); goto out; } } } ret = write_cache(&page_desc, NULL, 0, "True" == "True"); if (ret < 0) { dump_error(s, "dump: failed to sync cache for page_desc.\n"); goto out; } ret = write_cache(&page_data, NULL, 0, "True" == "True"); if (ret < 0) { dump_error(s, "dump: failed to sync cache for page_data.\n"); goto out; } out: free_data_cache(&page_desc); free_data_cache(&page_data); #ifdef CONFIG_LZO g_free(wrkmem); #endif g_free(buf_out); return ret; }
[Succeeded / Failed / Skipped / Total] 392 / 40 / 254 / 686:  26%|       | 686/2690 [7:51:25<22:57:10, 41.23s/it][Succeeded / Failed / Skipped / Total] 392 / 40 / 254 / 686:  26%|       | 687/2690 [7:54:35<23:03:42, 41.45s/it][Succeeded / Failed / Skipped / Total] 393 / 40 / 254 / 687:  26%|       | 687/2690 [7:54:35<23:03:42, 41.45s/it][Succeeded / Failed / Skipped / Total] 393 / 40 / 254 / 687:  26%|       | 688/2690 [7:56:03<23:05:17, 41.52s/it][Succeeded / Failed / Skipped / Total] 393 / 41 / 254 / 688:  26%|       | 688/2690 [7:56:03<23:05:17, 41.52s/it][Succeeded / Failed / Skipped / Total] 393 / 41 / 254 / 688:  26%|       | 689/2690 [7:56:04<23:02:37, 41.46s/it][Succeeded / Failed / Skipped / Total] 393 / 41 / 255 / 689:  26%|       | 689/2690 [7:56:04<23:02:37, 41.46s/it][Succeeded / Failed / Skipped / Total] 393 / 41 / 255 / 689:  26%|       | 690/2690 [7:56:05<22:59:57, 41.40s/it]--------------------------------------------- Result 686 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void do_ext_interrupt(CPUS390XState *env) { S390CPU *cpu = s390_env_get_cpu(env); uint64_t mask, addr; LowCore *lowcore; ExtQueue *q; if (!(env->psw.mask & PSW_MASK_EXT)) { cpu_abort(CPU(cpu), "Ext int w/o ext mask\n"); } lowcore = cpu_map_lowcore(env); if (env->pending_int & INTERRUPT_EXT_CLOCK_COMPARATOR) { lowcore->ext_int_code = cpu_to_be16(EXT_CLOCK_COMP); lowcore->cpu_addr = 0; env->pending_int &= ~INTERRUPT_EXT_CLOCK_COMPARATOR; } else if (env->pending_int & INTERRUPT_EXT_CPU_TIMER) { lowcore->ext_int_code = cpu_to_be16(EXT_CPU_TIMER); lowcore->cpu_addr = 0; env->pending_int &= ~INTERRUPT_EXT_CPU_TIMER; } else if (env->pending_int & INTERRUPT_EXT_SERVICE) { g_assert(env->ext_index >= 0); q = &env->ext_queue[env->ext_index]; lowcore->ext_int_code = cpu_to_be16(q->code); lowcore->ext_params = cpu_to_be32(q->param); lowcore->ext_params2 = cpu_to_be64(q->param64); lowcore->cpu_addr = cpu_to_be16(env->core_id | VIRTIO_SUBCODE_64); env->ext_index--; if (env->ext_index == -1) { env->pending_int &= ~INTERRUPT_EXT_SERVICE; } } else { g_assert_not_reached(); } mask = be64_to_cpu(lowcore->external_new_psw.mask); addr = be64_to_cpu(lowcore->external_new_psw.addr); lowcore->external_old_psw.mask = cpu_to_be64(get_psw_mask(env)); lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr); cpu_unmap_lowcore(lowcore); DPRINTF("%s: %" PRIx64 " %" PRIx64 "\n", __func__, env->psw.mask, env->psw.addr); load_psw(env, mask, addr); }
--------------------------------------------- Result 687 ---------------------------------------------
[[0 (99%)]] --> [[0 (47%)]] --> Socre: 0.5271643102169037

[[[[Adv]]]]: static int slice_end(AVCodecContext *[[avctx]], AVFrame *[[pict]]) { Mpeg1Context *s1 = [[avctx]]->priv_data; MpegEncContext *s = &s1->mpeg_enc_ctx; if (!s1->mpeg_enc_ctx_allocated || !s->current_picture_ptr) return 0; if (s->avctx->hwaccel) { if (s->avctx->hwaccel->end_frame(s->avctx) < 0) av_log([[avctx]], AV_LOG_ERROR, "hardware accelerator failed to decode picture\n"); } #if FF_API_XVMC FF_DISABLE_DEPRECATION_WARNINGS if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) ff_xvmc_field_end(s); FF_ENABLE_DEPRECATION_WARNINGS #endif if ( !s->first_field) { ff_er_frame_end(&s->er); ff_MPV_frame_end(s); if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) { int ret = av_frame_ref([[pict]], &s->current_picture_ptr->f); if (ret < 0) return ret; ff_print_debug_info(s, s->current_picture_ptr); } else { if ([[avctx]]->active_thread_type & FF_THREAD_FRAME) s->picture_number++; if (s->last_picture_ptr != NULL) { int ret = av_frame_ref([[pict]], &s->last_picture_ptr->f); if (ret < 0) return ret; ff_print_debug_info(s, s->last_picture_ptr); } } return 1; } else { return 0; } }

[[[[Adv]]]]: static int slice_end(AVCodecContext *[[parley]], AVFrame *[[lpez]]) { Mpeg1Context *s1 = [[parley]]->priv_data; MpegEncContext *s = &s1->mpeg_enc_ctx; if (!s1->mpeg_enc_ctx_allocated || !s->current_picture_ptr) return 0; if (s->avctx->hwaccel) { if (s->avctx->hwaccel->end_frame(s->avctx) < 0) av_log([[parley]], AV_LOG_ERROR, "hardware accelerator failed to decode picture\n"); } #if FF_API_XVMC FF_DISABLE_DEPRECATION_WARNINGS if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) ff_xvmc_field_end(s); FF_ENABLE_DEPRECATION_WARNINGS #endif if ( !s->first_field) { ff_er_frame_end(&s->er); ff_MPV_frame_end(s); if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) { int ret = av_frame_ref([[lpez]], &s->current_picture_ptr->f); if (ret < 0) return ret; ff_print_debug_info(s, s->current_picture_ptr); } else { if ([[parley]]->active_thread_type & FF_THREAD_FRAME) s->picture_number++; if (s->last_picture_ptr != NULL) { int ret = av_frame_ref([[lpez]], &s->last_picture_ptr->f); if (ret < 0) return ret; ff_print_debug_info(s, s->last_picture_ptr); } } return 1; } else { return 0; } }
--------------------------------------------- Result 688 ---------------------------------------------
[[0 (98%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int http_prepare_data(HTTPContext *c) { int i; switch(c->state) { case HTTPSTATE_SEND_DATA_HEADER: memset(&c->fmt_ctx, 0, sizeof(c->fmt_ctx)); if (c->stream->feed) { c->fmt_ctx.oformat = c->stream->fmt; c->fmt_ctx.nb_streams = c->stream->nb_streams; for(i=0;i<c->fmt_ctx.nb_streams;i++) { AVStream *st; st = av_mallocz(sizeof(AVStream)); c->fmt_ctx.streams[i] = st; if (c->stream->feed == c->stream) memcpy(st, c->stream->streams[i], sizeof(AVStream)); else memcpy(st, c->stream->feed->streams[c->stream->feed_streams[i]], sizeof(AVStream)); st->codec.frame_number = 0; } c->got_key_frame = 0; } else { c->fmt_ctx.oformat = c->stream->fmt; c->fmt_ctx.nb_streams = c->fmt_in->nb_streams; for(i=0;i<c->fmt_ctx.nb_streams;i++) { AVStream *st; st = av_mallocz(sizeof(AVStream)); c->fmt_ctx.streams[i] = st; memcpy(st, c->fmt_in->streams[i], sizeof(AVStream)); st->codec.frame_number = 0; } c->got_key_frame = 0; } init_put_byte(&c->fmt_ctx.pb, c->pbuffer, PACKET_MAX_SIZE, 1, c, NULL, http_write_packet, NULL); c->fmt_ctx.pb.is_streamed = 1; av_write_header(&c->fmt_ctx); c->state = HTTPSTATE_SEND_DATA; c->last_packet_sent = 0; break; case HTTPSTATE_SEND_DATA: #if 0 fifo_total_size = http_fifo_write_count - c->last_http_fifo_write_count; if (fifo_total_size >= ((3 * FIFO_MAX_SIZE) / 4)) { c->rptr = http_fifo.wptr; c->got_key_frame = 0; } start_rptr = c->rptr; if (fifo_read(&http_fifo, (UINT8 *)&hdr, sizeof(hdr), &c->rptr) < 0) return 0; payload_size = ntohs(hdr.payload_size); payload = av_malloc(payload_size); if (fifo_read(&http_fifo, payload, payload_size, &c->rptr) < 0) { av_free(payload); c->rptr = start_rptr; return 0; } c->last_http_fifo_write_count = http_fifo_write_count - fifo_size(&http_fifo, c->rptr); if (c->stream->stream_type != STREAM_TYPE_MASTER) { ret = 0; for(i=0;i<c->fmt_ctx.nb_streams;i++) { AVStream *st = c->fmt_ctx.streams[i]; if (test_header(&hdr, &st->codec)) { if (st->codec.key_frame) c->got_key_frame |= 1 << i; if (c->got_key_frame & (1 << i)) { ret = c->fmt_ctx.format->write_packet(&c->fmt_ctx, i, payload, payload_size); } break; } } if (ret) { c->state = HTTPSTATE_SEND_DATA_TRAILER; } } else { char *q; q = c->buffer; memcpy(q, &hdr, sizeof(hdr)); q += sizeof(hdr); memcpy(q, payload, payload_size); q += payload_size; c->buffer_ptr = c->buffer; c->buffer_end = q; } av_free(payload); #endif { AVPacket pkt; if (c->stream->feed) { ffm_set_write_index(c->fmt_in, c->stream->feed->feed_write_index, c->stream->feed->feed_size); } if (av_read_packet(c->fmt_in, &pkt) < 0) { if (c->stream->feed && c->stream->feed->feed_opened) { c->state = HTTPSTATE_WAIT_FEED; return 1; } else { c->state = HTTPSTATE_SEND_DATA_TRAILER; } } else { if (c->stream->feed) { for(i=0;i<c->stream->nb_streams;i++) { if (c->stream->feed_streams[i] == pkt.stream_index) { pkt.stream_index = i; if (pkt.flags & PKT_FLAG_KEY) { c->got_key_frame |= 1 << i; } if (!c->stream->send_on_key || ((c->got_key_frame + 1) >> c->stream->nb_streams)) { goto send_it; } } } } else { AVCodecContext *codec; send_it: codec = &c->fmt_ctx.streams[pkt.stream_index]->codec; codec->key_frame = ((pkt.flags & PKT_FLAG_KEY) != 0); #ifdef PJSG if (codec->codec_type == CODEC_TYPE_AUDIO) { codec->frame_size = (codec->sample_rate * pkt.duration + 500000) / 1000000; } #endif if (av_write_packet(&c->fmt_ctx, &pkt, 0)) c->state = HTTPSTATE_SEND_DATA_TRAILER; codec->frame_number++; } av_free_packet(&pkt); } } break; default: case HTTPSTATE_SEND_DATA_TRAILER: if (c->last_packet_sent) return -1; av_write_trailer(&c->fmt_ctx); c->last_packet_sent = 1; break; } return 0; }

[[[[Adv]]]]: static int http_prepare_data(HTTPContext *c) { int i; switch(c->state) { case HTTPSTATE_SEND_DATA_HEADER: memset(&c->fmt_ctx, 0, sizeof(c->fmt_ctx)); if (c->stream->feed) { c->fmt_ctx.oformat = c->stream->fmt; c->fmt_ctx.nb_streams = c->stream->nb_streams; for(i=0;i<c->fmt_ctx.nb_streams;i++) { AVStream *st; st = av_mallocz(sizeof(AVStream)); c->fmt_ctx.streams[i] = st; if (c->stream->feed == c->stream) memcpy(st, c->stream->streams[i], sizeof(AVStream)); else memcpy(st, c->stream->feed->streams[c->stream->feed_streams[i]], sizeof(AVStream)); st->codec.frame_number = 0; } c->got_key_frame = 0; } else { c->fmt_ctx.oformat = c->stream->fmt; c->fmt_ctx.nb_streams = c->fmt_in->nb_streams; for(i=0;i<c->fmt_ctx.nb_streams;i++) { AVStream *st; st = av_mallocz(sizeof(AVStream)); c->fmt_ctx.streams[i] = st; memcpy(st, c->fmt_in->streams[i], sizeof(AVStream)); st->codec.frame_number = 0; } c->got_key_frame = 0; } init_put_byte(&c->fmt_ctx.pb, c->pbuffer, PACKET_MAX_SIZE, 1, c, NULL, http_write_packet, NULL); c->fmt_ctx.pb.is_streamed = 1; av_write_header(&c->fmt_ctx); c->state = HTTPSTATE_SEND_DATA; c->last_packet_sent = 0; break; case HTTPSTATE_SEND_DATA: #if 0 fifo_total_size = http_fifo_write_count - c->last_http_fifo_write_count; if (fifo_total_size >= ((3 * FIFO_MAX_SIZE) / 4)) { c->rptr = http_fifo.wptr; c->got_key_frame = 0; } start_rptr = c->rptr; if (fifo_read(&http_fifo, (UINT8 *)&hdr, sizeof(hdr), &c->rptr) < 0) return 0; payload_size = ntohs(hdr.payload_size); payload = av_malloc(payload_size); if (fifo_read(&http_fifo, payload, payload_size, &c->rptr) < 0) { av_free(payload); c->rptr = start_rptr; return 0; } c->last_http_fifo_write_count = http_fifo_write_count - fifo_size(&http_fifo, c->rptr); if (c->stream->stream_type != STREAM_TYPE_MASTER) { ret = 0; for(i=0;i<c->fmt_ctx.nb_streams;i++) { AVStream *st = c->fmt_ctx.streams[i]; if (test_header(&hdr, &st->codec)) { if (st->codec.key_frame) c->got_key_frame |= 1 << i; if (c->got_key_frame & (1 << i)) { ret = c->fmt_ctx.format->write_packet(&c->fmt_ctx, i, payload, payload_size); } break; } } if (ret) { c->state = HTTPSTATE_SEND_DATA_TRAILER; } } else { char *q; q = c->buffer; memcpy(q, &hdr, sizeof(hdr)); q += sizeof(hdr); memcpy(q, payload, payload_size); q += payload_size; c->buffer_ptr = c->buffer; c->buffer_end = q; } av_free(payload); #endif { AVPacket pkt; if (c->stream->feed) { ffm_set_write_index(c->fmt_in, c->stream->feed->feed_write_index, c->stream->feed->feed_size); } if (av_read_packet(c->fmt_in, &pkt) < 0) { if (c->stream->feed && c->stream->feed->feed_opened) { c->state = HTTPSTATE_WAIT_FEED; return 1; } else { c->state = HTTPSTATE_SEND_DATA_TRAILER; } } else { if (c->stream->feed) { for(i=0;i<c->stream->nb_streams;i++) { if (c->stream->feed_streams[i] == pkt.stream_index) { pkt.stream_index = i; if (pkt.flags & PKT_FLAG_KEY) { c->got_key_frame |= 1 << i; } if (!c->stream->send_on_key || ((c->got_key_frame + 1) >> c->stream->nb_streams)) { goto send_it; } } } } else { AVCodecContext *codec; send_it: codec = &c->fmt_ctx.streams[pkt.stream_index]->codec; codec->key_frame = ((pkt.flags & PKT_FLAG_KEY) != 0); #ifdef PJSG if (codec->codec_type == CODEC_TYPE_AUDIO) { codec->frame_size = (codec->sample_rate * pkt.duration + 500000) / 1000000; } #endif if (av_write_packet(&c->fmt_ctx, &pkt, 0)) c->state = HTTPSTATE_SEND_DATA_TRAILER; codec->frame_number++; } av_free_packet(&pkt); } } break; default: case HTTPSTATE_SEND_DATA_TRAILER: if (c->last_packet_sent) return -1; av_write_trailer(&c->fmt_ctx); c->last_packet_sent = 1; break; } return 0; }
--------------------------------------------- Result 689 ---------------------------------------------
[[0 (23%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence) { offset_t offset1; offset_t pos= s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer)); if (whence != SEEK_CUR && whence != SEEK_SET) return -EINVAL; if (whence == SEEK_CUR) { offset1 = pos + (s->buf_ptr - s->buffer); if (offset == 0) return offset1; offset += offset1; } offset1 = offset - pos; if (!s->must_flush && offset1 >= 0 && offset1 < (s->buf_end - s->buffer)) { s->buf_ptr = s->buffer + offset1; } else { if (!s->seek) return -EPIPE; #ifdef CONFIG_MUXERS if (s->write_flag) { flush_buffer(s); s->must_flush = 1; } else #endif { s->buf_end = s->buffer; } s->buf_ptr = s->buffer; if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE) return -EPIPE; s->pos = offset; } s->eof_reached = 0; return offset; }
[Succeeded / Failed / Skipped / Total] 393 / 41 / 256 / 690:  26%|       | 690/2690 [7:56:05<22:59:57, 41.40s/it][Succeeded / Failed / Skipped / Total] 393 / 41 / 256 / 690:  26%|       | 691/2690 [7:57:30<23:01:22, 41.46s/it][Succeeded / Failed / Skipped / Total] 394 / 41 / 256 / 691:  26%|       | 691/2690 [7:57:30<23:01:22, 41.46s/it][Succeeded / Failed / Skipped / Total] 394 / 41 / 256 / 691:  26%|       | 692/2690 [7:57:30<22:58:43, 41.40s/it][Succeeded / Failed / Skipped / Total] 394 / 41 / 257 / 692:  26%|       | 692/2690 [7:57:30<22:58:43, 41.40s/it][Succeeded / Failed / Skipped / Total] 394 / 41 / 257 / 692:  26%|       | 693/2690 [7:57:38<22:56:23, 41.35s/it]--------------------------------------------- Result 690 ---------------------------------------------
[[0 (76%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ppc_translate_init(void) { int i; char* p; size_t cpu_reg_names_size; static int done_init = 0; if (done_init) return; cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, "env"); p = cpu_reg_names; cpu_reg_names_size = sizeof(cpu_reg_names); for (i = 0; i < 8; i++) { snprintf(p, cpu_reg_names_size, "crf%d", i); cpu_crf[i] = tcg_global_mem_new_i32(TCG_AREG0, offsetof(CPUState, crf[i]), p); p += 5; cpu_reg_names_size -= 5; } for (i = 0; i < 32; i++) { snprintf(p, cpu_reg_names_size, "r%d", i); cpu_gpr[i] = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, gpr[i]), p); p += (i < 10) ? 3 : 4; cpu_reg_names_size -= (i < 10) ? 3 : 4; #if !defined(TARGET_PPC64) snprintf(p, cpu_reg_names_size, "r%dH", i); cpu_gprh[i] = tcg_global_mem_new_i32(TCG_AREG0, offsetof(CPUState, gprh[i]), p); p += (i < 10) ? 4 : 5; cpu_reg_names_size -= (i < 10) ? 4 : 5; #endif snprintf(p, cpu_reg_names_size, "fp%d", i); cpu_fpr[i] = tcg_global_mem_new_i64(TCG_AREG0, offsetof(CPUState, fpr[i]), p); p += (i < 10) ? 4 : 5; cpu_reg_names_size -= (i < 10) ? 4 : 5; snprintf(p, cpu_reg_names_size, "avr%dH", i); #ifdef HOST_WORDS_BIGENDIAN cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0, offsetof(CPUState, avr[i].u64[0]), p); #else cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0, offsetof(CPUState, avr[i].u64[1]), p); #endif p += (i < 10) ? 6 : 7; cpu_reg_names_size -= (i < 10) ? 6 : 7; snprintf(p, cpu_reg_names_size, "avr%dL", i); #ifdef HOST_WORDS_BIGENDIAN cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0, offsetof(CPUState, avr[i].u64[1]), p); #else cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0, offsetof(CPUState, avr[i].u64[0]), p); #endif p += (i < 10) ? 6 : 7; cpu_reg_names_size -= (i < 10) ? 6 : 7; } cpu_nip = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, nip), "nip"); cpu_msr = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, msr), "msr"); cpu_ctr = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, ctr), "ctr"); cpu_lr = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, lr), "lr"); cpu_xer = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, xer), "xer"); cpu_reserve = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, reserve), "reserve"); cpu_fpscr = tcg_global_mem_new_i32(TCG_AREG0, offsetof(CPUState, fpscr), "fpscr"); cpu_access_type = tcg_global_mem_new_i32(TCG_AREG0, offsetof(CPUState, access_type), "access_type"); #define GEN_HELPER 2 #include "helper.h" done_init = 1; }
--------------------------------------------- Result 691 ---------------------------------------------
[[0 (8%)]] --> [[0 (53%)]] --> Socre: 0.534783661365509

[[[[Adv]]]]: static void verdex_init(MachineState *machine) { const char *cpu_model = machine->cpu_model; PXA2xxState *cpu; DriveInfo *[[dinfo]]; int be; MemoryRegion *[[address_space_mem]] = get_system_memory(); uint32_t verdex_rom = 0x02000000; uint32_t verdex_ram = 0x10000000; cpu = pxa270_init([[address_space_mem]], verdex_ram, cpu_model ?: "pxa270-c0"); [[dinfo]] = drive_get(IF_PFLASH, 0, 0); if (![[dinfo]] && !qtest_enabled()) { fprintf(stderr, "A flash image must be given with the " "'pflash' parameter\n"); exit(1); } #ifdef TARGET_WORDS_BIGENDIAN be = 1; #else be = 0; #endif if (!pflash_cfi01_register(0x00000000, NULL, "verdex.rom", verdex_rom, [[dinfo]] ? blk_bs(blk_by_legacy_dinfo([[dinfo]])) : NULL, sector_len, verdex_rom / sector_len, 2, 0, 0, 0, 0, be)) { fprintf(stderr, "qemu: Error registering flash memory.\n"); exit(1); } smc91c111_init(&nd_table[0], 0x04000300, qdev_get_gpio_in(cpu->gpio, 99)); }

[[[[Adv]]]]: static void verdex_init(MachineState *machine) { const char *cpu_model = machine->cpu_model; PXA2xxState *cpu; DriveInfo *[[incompetents]]; int be; MemoryRegion *[[tantra]] = get_system_memory(); uint32_t verdex_rom = 0x02000000; uint32_t verdex_ram = 0x10000000; cpu = pxa270_init([[tantra]], verdex_ram, cpu_model ?: "pxa270-c0"); [[incompetents]] = drive_get(IF_PFLASH, 0, 0); if (![[incompetents]] && !qtest_enabled()) { fprintf(stderr, "A flash image must be given with the " "'pflash' parameter\n"); exit(1); } #ifdef TARGET_WORDS_BIGENDIAN be = 1; #else be = 0; #endif if (!pflash_cfi01_register(0x00000000, NULL, "verdex.rom", verdex_rom, [[incompetents]] ? blk_bs(blk_by_legacy_dinfo([[incompetents]])) : NULL, sector_len, verdex_rom / sector_len, 2, 0, 0, 0, 0, be)) { fprintf(stderr, "qemu: Error registering flash memory.\n"); exit(1); } smc91c111_init(&nd_table[0], 0x04000300, qdev_get_gpio_in(cpu->gpio, 99)); }
--------------------------------------------- Result 692 ---------------------------------------------
[[0 (32%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp) { int i; size_t pagesize = getpagesize(); memory = (memory + pagesize - 1) & -pagesize; for (i = 0; i < memory / pagesize; i++) { memset(area + pagesize * i, 0, 1); } }
--------------------------------------------- Result 693 ---------------------------------------------
[[0 (97%)]] --> [[0 (22%)]] --> Socre: 0.7783710062503815

[[[[Adv]]]]: static int cuvid_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { CuvidContext *ctx = avctx->priv_data; AVHWDeviceContext *device_ctx = (AVHWDeviceContext*)ctx->hwdevice->data; AVCUDADeviceContext *device_hwctx = device_ctx->hwctx; CUcontext dummy, cuda_ctx = device_hwctx->cuda_ctx; AVFrame *frame = data; CUVIDSOURCEDATAPACKET cupkt; AVPacket [[filter_packet]] = { 0 }; AVPacket filtered_packet = { 0 }; CUdeviceptr mapped_frame = 0; int ret = 0, eret = 0; if (ctx->bsf && avpkt->size) { if ((ret = av_packet_ref(&[[filter_packet]], avpkt)) < 0) { av_log(avctx, AV_LOG_ERROR, "av_packet_ref failed\n"); return ret; } if ((ret = av_bsf_send_packet(ctx->bsf, &[[filter_packet]])) < 0) { av_log(avctx, AV_LOG_ERROR, "av_bsf_send_packet failed\n"); av_packet_unref(&[[filter_packet]]); return ret; } if ((ret = av_bsf_receive_packet(ctx->bsf, &filtered_packet)) < 0) { av_log(avctx, AV_LOG_ERROR, "av_bsf_receive_packet failed\n"); return ret; } avpkt = &filtered_packet; } ret = CHECK_CU(cuCtxPushCurrent(cuda_ctx)); if (ret < 0) { av_packet_unref(&filtered_packet); return ret; } memset(&cupkt, 0, sizeof(cupkt)); if (avpkt->size) { cupkt.payload_size = avpkt->size; cupkt.payload = avpkt->data; if (avpkt->pts != AV_NOPTS_VALUE) { cupkt.flags = CUVID_PKT_TIMESTAMP; if (avctx->pkt_timebase.num && avctx->pkt_timebase.den) cupkt.timestamp = av_rescale_q(avpkt->pts, avctx->pkt_timebase, (AVRational){1, 10000000}); else cupkt.timestamp = avpkt->pts; } } else { cupkt.flags = CUVID_PKT_ENDOFSTREAM; } ret = CHECK_CU(cuvidParseVideoData(ctx->cuparser, &cupkt)); av_packet_unref(&filtered_packet); if (ret < 0) { if (ctx->internal_error) ret = ctx->internal_error; goto error; } if (av_fifo_size(ctx->frame_queue)) { CUVIDPARSERDISPINFO dispinfo; CUVIDPROCPARAMS params; unsigned int pitch = 0; int offset = 0; int i; av_fifo_generic_read(ctx->frame_queue, &dispinfo, sizeof(CUVIDPARSERDISPINFO), NULL); memset(&params, 0, sizeof(params)); params.progressive_frame = dispinfo.progressive_frame; params.second_field = 0; params.top_field_first = dispinfo.top_field_first; ret = CHECK_CU(cuvidMapVideoFrame(ctx->cudecoder, dispinfo.picture_index, &mapped_frame, &pitch, &params)); if (ret < 0) goto error; if (avctx->pix_fmt == AV_PIX_FMT_CUDA) { ret = av_hwframe_get_buffer(ctx->hwframe, frame, 0); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "av_hwframe_get_buffer failed\n"); goto error; } ret = ff_decode_frame_props(avctx, frame); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "ff_decode_frame_props failed\n"); goto error; } for (i = 0; i < 2; i++) { CUDA_MEMCPY2D cpy = { .srcMemoryType = CU_MEMORYTYPE_DEVICE, .dstMemoryType = CU_MEMORYTYPE_DEVICE, .srcDevice = mapped_frame, .dstDevice = (CUdeviceptr)frame->data[i], .srcPitch = pitch, .dstPitch = frame->linesize[i], .srcY = offset, .WidthInBytes = FFMIN(pitch, frame->linesize[i]), .Height = avctx->coded_height >> (i ? 1 : 0), }; ret = CHECK_CU(cuMemcpy2D(&cpy)); if (ret < 0) goto error; offset += avctx->coded_height; } } else if (avctx->pix_fmt == AV_PIX_FMT_NV12) { AVFrame *tmp_frame = av_frame_alloc(); if (!tmp_frame) { av_log(avctx, AV_LOG_ERROR, "av_frame_alloc failed\n"); ret = AVERROR(ENOMEM); goto error; } tmp_frame->format = AV_PIX_FMT_CUDA; tmp_frame->hw_frames_ctx = av_buffer_ref(ctx->hwframe); tmp_frame->data[0] = (uint8_t*)mapped_frame; tmp_frame->linesize[0] = pitch; tmp_frame->data[1] = (uint8_t*)(mapped_frame + avctx->coded_height * pitch); tmp_frame->linesize[1] = pitch; tmp_frame->width = avctx->width; tmp_frame->height = avctx->height; ret = ff_get_buffer(avctx, frame, 0); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "ff_get_buffer failed\n"); av_frame_free(&tmp_frame); goto error; } ret = av_hwframe_transfer_data(frame, tmp_frame, 0); if (ret) { av_log(avctx, AV_LOG_ERROR, "av_hwframe_transfer_data failed\n"); av_frame_free(&tmp_frame); goto error; } av_frame_free(&tmp_frame); } else { ret = AVERROR_BUG; goto error; } frame->width = avctx->width; frame->height = avctx->height; if (avctx->pkt_timebase.num && avctx->pkt_timebase.den) frame->pts = av_rescale_q(dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkt_timebase); else frame->pts = dispinfo.timestamp; frame->pkt_pts = frame->pts; av_frame_set_pkt_pos(frame, -1); av_frame_set_pkt_duration(frame, 0); av_frame_set_pkt_size(frame, -1); frame->interlaced_frame = !dispinfo.progressive_frame; if (!dispinfo.progressive_frame) frame->top_field_first = dispinfo.top_field_first; *got_frame = 1; } else { *got_frame = 0; } error: if (mapped_frame) eret = CHECK_CU(cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame)); eret = CHECK_CU(cuCtxPopCurrent(&dummy)); if (eret < 0) return eret; else return ret; }

[[[[Adv]]]]: static int cuvid_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { CuvidContext *ctx = avctx->priv_data; AVHWDeviceContext *device_ctx = (AVHWDeviceContext*)ctx->hwdevice->data; AVCUDADeviceContext *device_hwctx = device_ctx->hwctx; CUcontext dummy, cuda_ctx = device_hwctx->cuda_ctx; AVFrame *frame = data; CUVIDSOURCEDATAPACKET cupkt; AVPacket [[harmless]] = { 0 }; AVPacket filtered_packet = { 0 }; CUdeviceptr mapped_frame = 0; int ret = 0, eret = 0; if (ctx->bsf && avpkt->size) { if ((ret = av_packet_ref(&[[harmless]], avpkt)) < 0) { av_log(avctx, AV_LOG_ERROR, "av_packet_ref failed\n"); return ret; } if ((ret = av_bsf_send_packet(ctx->bsf, &[[harmless]])) < 0) { av_log(avctx, AV_LOG_ERROR, "av_bsf_send_packet failed\n"); av_packet_unref(&[[harmless]]); return ret; } if ((ret = av_bsf_receive_packet(ctx->bsf, &filtered_packet)) < 0) { av_log(avctx, AV_LOG_ERROR, "av_bsf_receive_packet failed\n"); return ret; } avpkt = &filtered_packet; } ret = CHECK_CU(cuCtxPushCurrent(cuda_ctx)); if (ret < 0) { av_packet_unref(&filtered_packet); return ret; } memset(&cupkt, 0, sizeof(cupkt)); if (avpkt->size) { cupkt.payload_size = avpkt->size; cupkt.payload = avpkt->data; if (avpkt->pts != AV_NOPTS_VALUE) { cupkt.flags = CUVID_PKT_TIMESTAMP; if (avctx->pkt_timebase.num && avctx->pkt_timebase.den) cupkt.timestamp = av_rescale_q(avpkt->pts, avctx->pkt_timebase, (AVRational){1, 10000000}); else cupkt.timestamp = avpkt->pts; } } else { cupkt.flags = CUVID_PKT_ENDOFSTREAM; } ret = CHECK_CU(cuvidParseVideoData(ctx->cuparser, &cupkt)); av_packet_unref(&filtered_packet); if (ret < 0) { if (ctx->internal_error) ret = ctx->internal_error; goto error; } if (av_fifo_size(ctx->frame_queue)) { CUVIDPARSERDISPINFO dispinfo; CUVIDPROCPARAMS params; unsigned int pitch = 0; int offset = 0; int i; av_fifo_generic_read(ctx->frame_queue, &dispinfo, sizeof(CUVIDPARSERDISPINFO), NULL); memset(&params, 0, sizeof(params)); params.progressive_frame = dispinfo.progressive_frame; params.second_field = 0; params.top_field_first = dispinfo.top_field_first; ret = CHECK_CU(cuvidMapVideoFrame(ctx->cudecoder, dispinfo.picture_index, &mapped_frame, &pitch, &params)); if (ret < 0) goto error; if (avctx->pix_fmt == AV_PIX_FMT_CUDA) { ret = av_hwframe_get_buffer(ctx->hwframe, frame, 0); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "av_hwframe_get_buffer failed\n"); goto error; } ret = ff_decode_frame_props(avctx, frame); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "ff_decode_frame_props failed\n"); goto error; } for (i = 0; i < 2; i++) { CUDA_MEMCPY2D cpy = { .srcMemoryType = CU_MEMORYTYPE_DEVICE, .dstMemoryType = CU_MEMORYTYPE_DEVICE, .srcDevice = mapped_frame, .dstDevice = (CUdeviceptr)frame->data[i], .srcPitch = pitch, .dstPitch = frame->linesize[i], .srcY = offset, .WidthInBytes = FFMIN(pitch, frame->linesize[i]), .Height = avctx->coded_height >> (i ? 1 : 0), }; ret = CHECK_CU(cuMemcpy2D(&cpy)); if (ret < 0) goto error; offset += avctx->coded_height; } } else if (avctx->pix_fmt == AV_PIX_FMT_NV12) { AVFrame *tmp_frame = av_frame_alloc(); if (!tmp_frame) { av_log(avctx, AV_LOG_ERROR, "av_frame_alloc failed\n"); ret = AVERROR(ENOMEM); goto error; } tmp_frame->format = AV_PIX_FMT_CUDA; tmp_frame->hw_frames_ctx = av_buffer_ref(ctx->hwframe); tmp_frame->data[0] = (uint8_t*)mapped_frame; tmp_frame->linesize[0] = pitch; tmp_frame->data[1] = (uint8_t*)(mapped_frame + avctx->coded_height * pitch); tmp_frame->linesize[1] = pitch; tmp_frame->width = avctx->width; tmp_frame->height = avctx->height; ret = ff_get_buffer(avctx, frame, 0); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "ff_get_buffer failed\n"); av_frame_free(&tmp_frame); goto error; } ret = av_hwframe_transfer_data(frame, tmp_frame, 0); if (ret) { av_log(avctx, AV_LOG_ERROR, "av_hwframe_transfer_data failed\n"); av_frame_free(&tmp_frame); goto error; } av_frame_free(&tmp_frame); } else { ret = AVERROR_BUG; goto error; } frame->width = avctx->width; frame->height = avctx->height; if (avctx->pkt_timebase.num && avctx->pkt_timebase.den) frame->pts = av_rescale_q(dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkt_timebase); else frame->pts = dispinfo.timestamp; frame->pkt_pts = frame->pts; av_frame_set_pkt_pos(frame, -1); av_frame_set_pkt_duration(frame, 0); av_frame_set_pkt_size(frame, -1); frame->interlaced_frame = !dispinfo.progressive_frame; if (!dispinfo.progressive_frame) frame->top_field_first = dispinfo.top_field_first; *got_frame = 1; } else { *got_frame = 0; } error: if (mapped_frame) eret = CHECK_CU(cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame)); eret = CHECK_CU(cuCtxPopCurrent(&dummy)); if (eret < 0) return eret; else return ret; }[Succeeded / Failed / Skipped / Total] 395 / 41 / 257 / 693:  26%|       | 693/2690 [7:57:38<22:56:23, 41.35s/it][Succeeded / Failed / Skipped / Total] 395 / 41 / 257 / 693:  26%|       | 694/2690 [7:58:33<22:56:20, 41.37s/it][Succeeded / Failed / Skipped / Total] 396 / 41 / 257 / 694:  26%|       | 694/2690 [7:58:33<22:56:20, 41.37s/it][Succeeded / Failed / Skipped / Total] 396 / 41 / 257 / 694:  26%|       | 695/2690 [7:59:10<22:55:29, 41.37s/it][Succeeded / Failed / Skipped / Total] 397 / 41 / 257 / 695:  26%|       | 695/2690 [7:59:10<22:55:29, 41.37s/it][Succeeded / Failed / Skipped / Total] 397 / 41 / 257 / 695:  26%|       | 696/2690 [7:59:11<22:52:51, 41.31s/it][Succeeded / Failed / Skipped / Total] 397 / 41 / 258 / 696:  26%|       | 696/2690 [7:59:11<22:52:51, 41.31s/it][Succeeded / Failed / Skipped / Total] 397 / 41 / 258 / 696:  26%|       | 697/2690 [8:01:01<22:55:26, 41.41s/it]
--------------------------------------------- Result 694 ---------------------------------------------
[[0 (4%)]] --> [[0 (98%)]] --> Socre: 0.9752910733222961

[[[[Adv]]]]: static void gen_mtfsfi(DisasContext *ctx) { int bf, sh; TCGv_i64 t0; TCGv_i32 [[t1]]; if (unlikely(!ctx->fpu_enabled)) { gen_exception(ctx, POWERPC_EXCP_FPU); return; } bf = crbD(ctx->opcode) >> 2; sh = 7 - bf; gen_update_nip(ctx, ctx->nip - 4); gen_reset_fpstatus(); t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh)); [[t1]] = tcg_const_i32(1 << sh); gen_helper_store_fpscr(cpu_env, t0, [[t1]]); tcg_temp_free_i64(t0); tcg_temp_free_i32([[t1]]); if (unlikely(Rc(ctx->opcode) != 0)) { tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr); tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX); } gen_helper_float_check_status(cpu_env); }

[[[[Adv]]]]: static void gen_mtfsfi(DisasContext *ctx) { int bf, sh; TCGv_i64 t0; TCGv_i32 [[]]; if (unlikely(!ctx->fpu_enabled)) { gen_exception(ctx, POWERPC_EXCP_FPU); return; } bf = crbD(ctx->opcode) >> 2; sh = 7 - bf; gen_update_nip(ctx, ctx->nip - 4); gen_reset_fpstatus(); t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh)); [[]] = tcg_const_i32(1 << sh); gen_helper_store_fpscr(cpu_env, t0, [[]]); tcg_temp_free_i64(t0); tcg_temp_free_i32([[]]); if (unlikely(Rc(ctx->opcode) != 0)) { tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr); tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX); } gen_helper_float_check_status(cpu_env); }
--------------------------------------------- Result 695 ---------------------------------------------
[[0 (14%)]] --> [[0 (52%)]] --> Socre: 0.5242906808853149

[[[[Adv]]]]: static void ide_identify(IDEState *s) { uint16_t *[[p]]; unsigned int [[oldsize]]; memset(s->io_buffer, 0, 512); [[p]] = (uint16_t *)s->io_buffer; stw([[p]] + 0, 0x0040); stw([[p]] + 1, s->cylinders); stw([[p]] + 3, s->heads); stw([[p]] + 4, 512 * s->sectors); stw([[p]] + 5, 512); stw([[p]] + 6, s->sectors); stw([[p]] + 20, 3); stw([[p]] + 21, 512); stw([[p]] + 22, 4); padstr((uint8_t *)([[p]] + 27), "QEMU HARDDISK", 40); #if MAX_MULT_SECTORS > 1 stw([[p]] + 47, MAX_MULT_SECTORS); #endif stw([[p]] + 48, 1); stw([[p]] + 49, 1 << 9); stw([[p]] + 51, 0x200); stw([[p]] + 52, 0x200); stw([[p]] + 54, s->cylinders); stw([[p]] + 55, s->heads); stw([[p]] + 56, s->sectors); [[oldsize]] = s->cylinders * s->heads * s->sectors; stw([[p]] + 57, [[oldsize]]); stw([[p]] + 58, [[oldsize]] >> 16); if (s->mult_sectors) stw([[p]] + 59, 0x100 | s->mult_sectors); stw([[p]] + 60, s->nb_sectors); stw([[p]] + 61, s->nb_sectors >> 16); stw([[p]] + 80, (1 << 1) | (1 << 2)); stw([[p]] + 82, (1 << 14)); stw([[p]] + 83, (1 << 14)); stw([[p]] + 84, (1 << 14)); stw([[p]] + 85, (1 << 14)); stw([[p]] + 86, 0); stw([[p]] + 87, (1 << 14)); }

[[[[Adv]]]]: static void ide_identify(IDEState *s) { uint16_t *[[r]]; unsigned int [[horrific]]; memset(s->io_buffer, 0, 512); [[r]] = (uint16_t *)s->io_buffer; stw([[r]] + 0, 0x0040); stw([[r]] + 1, s->cylinders); stw([[r]] + 3, s->heads); stw([[r]] + 4, 512 * s->sectors); stw([[r]] + 5, 512); stw([[r]] + 6, s->sectors); stw([[r]] + 20, 3); stw([[r]] + 21, 512); stw([[r]] + 22, 4); padstr((uint8_t *)([[r]] + 27), "QEMU HARDDISK", 40); #if MAX_MULT_SECTORS > 1 stw([[r]] + 47, MAX_MULT_SECTORS); #endif stw([[r]] + 48, 1); stw([[r]] + 49, 1 << 9); stw([[r]] + 51, 0x200); stw([[r]] + 52, 0x200); stw([[r]] + 54, s->cylinders); stw([[r]] + 55, s->heads); stw([[r]] + 56, s->sectors); [[horrific]] = s->cylinders * s->heads * s->sectors; stw([[r]] + 57, [[horrific]]); stw([[r]] + 58, [[horrific]] >> 16); if (s->mult_sectors) stw([[r]] + 59, 0x100 | s->mult_sectors); stw([[r]] + 60, s->nb_sectors); stw([[r]] + 61, s->nb_sectors >> 16); stw([[r]] + 80, (1 << 1) | (1 << 2)); stw([[r]] + 82, (1 << 14)); stw([[r]] + 83, (1 << 14)); stw([[r]] + 84, (1 << 14)); stw([[r]] + 85, (1 << 14)); stw([[r]] + 86, 0); stw([[r]] + 87, (1 << 14)); }
--------------------------------------------- Result 696 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int encode_apng(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pict, int *got_packet) { PNGEncContext *s = avctx->priv_data; int ret; int enc_row_size; size_t max_packet_size; APNGFctlChunk fctl_chunk = {0}; if (pict && avctx->codec_id == AV_CODEC_ID_APNG && s->color_type == PNG_COLOR_TYPE_PALETTE) { uint32_t checksum = ~av_crc(av_crc_get_table(AV_CRC_32_IEEE_LE), ~0U, pict->data[1], 256 * sizeof(uint32_t)); if (avctx->frame_number == 0) { s->palette_checksum = checksum; } else if (checksum != s->palette_checksum) { av_log(avctx, AV_LOG_ERROR, "Input contains more than one unique palette. APNG does not support multiple palettes.\n"); return -1; } } enc_row_size = deflateBound(&s->zstream, (avctx->width * s->bits_per_pixel + 7) >> 3); max_packet_size = AV_INPUT_BUFFER_MIN_SIZE + avctx->height * ( enc_row_size + (4 + 12) * (((int64_t)enc_row_size + IOBUF_SIZE - 1) / IOBUF_SIZE) ); if (max_packet_size > INT_MAX) return AVERROR(ENOMEM); if (avctx->frame_number == 0) { if (!pict) return AVERROR(EINVAL); s->bytestream = avctx->extradata = av_malloc(FF_MIN_BUFFER_SIZE); if (!avctx->extradata) return AVERROR(ENOMEM); ret = encode_headers(avctx, pict); if (ret < 0) return ret; avctx->extradata_size = s->bytestream - avctx->extradata; s->last_frame_packet = av_malloc(max_packet_size); if (!s->last_frame_packet) return AVERROR(ENOMEM); } else if (s->last_frame) { ret = ff_alloc_packet2(avctx, pkt, max_packet_size, 0); if (ret < 0) return ret; memcpy(pkt->data, s->last_frame_packet, s->last_frame_packet_size); pkt->size = s->last_frame_packet_size; pkt->pts = pkt->dts = s->last_frame->pts; } if (pict) { s->bytestream_start = s->bytestream = s->last_frame_packet; s->bytestream_end = s->bytestream + max_packet_size; fctl_chunk.sequence_number = s->sequence_number; ++s->sequence_number; s->bytestream += 26 + 12; ret = apng_encode_frame(avctx, pict, &fctl_chunk, &s->last_frame_fctl); if (ret < 0) return ret; fctl_chunk.delay_num = 0; fctl_chunk.delay_den = 0; } else { s->last_frame_fctl.dispose_op = APNG_DISPOSE_OP_NONE; } if (s->last_frame) { uint8_t* last_fctl_chunk_start = pkt->data; uint8_t buf[26]; AV_WB32(buf + 0, s->last_frame_fctl.sequence_number); AV_WB32(buf + 4, s->last_frame_fctl.width); AV_WB32(buf + 8, s->last_frame_fctl.height); AV_WB32(buf + 12, s->last_frame_fctl.x_offset); AV_WB32(buf + 16, s->last_frame_fctl.y_offset); AV_WB16(buf + 20, s->last_frame_fctl.delay_num); AV_WB16(buf + 22, s->last_frame_fctl.delay_den); buf[24] = s->last_frame_fctl.dispose_op; buf[25] = s->last_frame_fctl.blend_op; png_write_chunk(&last_fctl_chunk_start, MKTAG('f', 'c', 'T', 'L'), buf, 26); *got_packet = 1; } if (pict) { if (!s->last_frame) { s->last_frame = av_frame_alloc(); if (!s->last_frame) return AVERROR(ENOMEM); } else if (s->last_frame_fctl.dispose_op != APNG_DISPOSE_OP_PREVIOUS) { if (!s->prev_frame) { s->prev_frame = av_frame_alloc(); if (!s->prev_frame) return AVERROR(ENOMEM); s->prev_frame->format = pict->format; s->prev_frame->width = pict->width; s->prev_frame->height = pict->height; if ((ret = av_frame_get_buffer(s->prev_frame, 32)) < 0) return ret; } memcpy(s->prev_frame->data[0], s->last_frame->data[0], s->last_frame->linesize[0] * s->last_frame->height); if (s->last_frame_fctl.dispose_op == APNG_DISPOSE_OP_BACKGROUND) { uint32_t y; uint8_t bpp = (s->bits_per_pixel + 7) >> 3; for (y = s->last_frame_fctl.y_offset; y < s->last_frame_fctl.y_offset + s->last_frame_fctl.height; ++y) { size_t row_start = s->last_frame->linesize[0] * y + bpp * s->last_frame_fctl.x_offset; memset(s->prev_frame->data[0] + row_start, 0, bpp * s->last_frame_fctl.width); } } } av_frame_unref(s->last_frame); ret = av_frame_ref(s->last_frame, (AVFrame*)pict); if (ret < 0) return ret; s->last_frame_fctl = fctl_chunk; s->last_frame_packet_size = s->bytestream - s->bytestream_start; } else { av_frame_free(&s->last_frame); } return 0; }
--------------------------------------------- Result 697 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 398 / 41 / 258 / 697:  26%|       | 697/2690 [8:01:01<22:55:26, 41.41s/it][Succeeded / Failed / Skipped / Total] 398 / 41 / 258 / 697:  26%|       | 698/2690 [8:01:01<22:52:48, 41.35s/it][Succeeded / Failed / Skipped / Total] 398 / 41 / 259 / 698:  26%|       | 698/2690 [8:01:01<22:52:48, 41.35s/it][Succeeded / Failed / Skipped / Total] 398 / 41 / 259 / 698:  26%|       | 699/2690 [8:01:06<22:50:22, 41.30s/it][[0 (6%)]] --> [[0 (59%)]] --> Socre: 0.5905436277389526

[[[[Adv]]]]: BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num, QEMUIOVector *qiov, int nb_sectors, BlockDriverCompletionFunc *cb, void *opaque) { BlockDriver *drv = bs->drv; BlockDriverAIOCB *[[ret]]; trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque); if (!drv) return NULL; if (bdrv_check_request(bs, sector_num, nb_sectors)) return NULL; [[ret]] = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors, cb, opaque); if ([[ret]]) { bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE; bs->rd_ops ++; } return [[ret]]; }

[[[[Adv]]]]: BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num, QEMUIOVector *qiov, int nb_sectors, BlockDriverCompletionFunc *cb, void *opaque) { BlockDriver *drv = bs->drv; BlockDriverAIOCB *[[boomers]]; trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque); if (!drv) return NULL; if (bdrv_check_request(bs, sector_num, nb_sectors)) return NULL; [[boomers]] = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors, cb, opaque); if ([[boomers]]) { bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE; bs->rd_ops ++; } return [[boomers]]; }
--------------------------------------------- Result 698 ---------------------------------------------
[[0 (85%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void migrate_set_downtime(QTestState *who, const char *value) { QDict *rsp; gchar *cmd; cmd = g_strdup_printf("{ 'execute': 'migrate_set_downtime'," "'arguments': { 'value': %s } }", value); rsp = qtest_qmp(who, cmd); g_free(cmd); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); }
--------------------------------------------- Result 699 ---------------------------------------------
[[0 (47%)]] --> [[0 (51%)]] --> Socre: 0.5057558417320251

[[[[Adv]]]]: target_ulong do_arm_semihosting(CPUARMState *env) { ARMCPU *cpu = arm_env_get_cpu(env); CPUState *cs = CPU(cpu); target_ulong [[args]]; target_ulong arg0, arg1, arg2, arg3; char * s; int nr; uint32_t ret; uint32_t len; #ifdef CONFIG_USER_ONLY TaskState *ts = cs->opaque; #else CPUARMState *ts = env; #endif if (is_a64(env)) { nr = env->xregs[0] & 0xffffffffU; [[args]] = env->xregs[1]; } else { nr = env->regs[0]; [[args]] = env->regs[1]; } switch (nr) { case TARGET_SYS_OPEN: GET_ARG(0); GET_ARG(1); GET_ARG(2); s = lock_user_string(arg0); if (!s) { return (uint32_t)-1; } if (arg1 >= 12) { unlock_user(s, arg0, 0); return (uint32_t)-1; } if (strcmp(s, ":tt") == 0) { int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO; unlock_user(s, arg0, 0); return result_fileno; } if (use_gdb_syscalls()) { ret = arm_gdb_syscall(cpu, arm_semi_cb, "open,%s,%x,1a4", arg0, (int)arg2+1, gdb_open_modeflags[arg1]); } else { ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644)); } unlock_user(s, arg0, 0); return ret; case TARGET_SYS_CLOSE: GET_ARG(0); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "close,%x", arg0); } else { return set_swi_errno(ts, close(arg0)); } case TARGET_SYS_WRITEC: { char c; if (get_user_u8(c, [[args]])) return (uint32_t)-1; if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "write,2,%x,1", [[args]]); } else { return write(STDERR_FILENO, &c, 1); } } case TARGET_SYS_WRITE0: if (!(s = lock_user_string([[args]]))) return (uint32_t)-1; len = strlen(s); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "write,2,%x,%x", [[args]], len); } else { ret = write(STDERR_FILENO, s, len); } unlock_user(s, [[args]], 0); return ret; case TARGET_SYS_WRITE: GET_ARG(0); GET_ARG(1); GET_ARG(2); len = arg2; if (use_gdb_syscalls()) { arm_semi_syscall_len = len; return arm_gdb_syscall(cpu, arm_semi_cb, "write,%x,%x,%x", arg0, arg1, len); } else { s = lock_user(VERIFY_READ, arg1, len, 1); if (!s) { return (uint32_t)-1; } ret = set_swi_errno(ts, write(arg0, s, len)); unlock_user(s, arg1, 0); if (ret == (uint32_t)-1) return -1; return len - ret; } case TARGET_SYS_READ: GET_ARG(0); GET_ARG(1); GET_ARG(2); len = arg2; if (use_gdb_syscalls()) { arm_semi_syscall_len = len; return arm_gdb_syscall(cpu, arm_semi_cb, "read,%x,%x,%x", arg0, arg1, len); } else { s = lock_user(VERIFY_WRITE, arg1, len, 0); if (!s) { return (uint32_t)-1; } do { ret = set_swi_errno(ts, read(arg0, s, len)); } while (ret == -1 && errno == EINTR); unlock_user(s, arg1, len); if (ret == (uint32_t)-1) return -1; return len - ret; } case TARGET_SYS_READC: return 0; case TARGET_SYS_ISTTY: GET_ARG(0); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "isatty,%x", arg0); } else { return isatty(arg0); } case TARGET_SYS_SEEK: GET_ARG(0); GET_ARG(1); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "lseek,%x,%x,0", arg0, arg1); } else { ret = set_swi_errno(ts, lseek(arg0, arg1, SEEK_SET)); if (ret == (uint32_t)-1) return -1; return 0; } case TARGET_SYS_FLEN: GET_ARG(0); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_flen_cb, "fstat,%x,%x", arg0, arm_flen_buf(cpu)); } else { struct stat buf; ret = set_swi_errno(ts, fstat(arg0, &buf)); if (ret == (uint32_t)-1) return -1; return buf.st_size; } case TARGET_SYS_TMPNAM: return -1; case TARGET_SYS_REMOVE: GET_ARG(0); GET_ARG(1); if (use_gdb_syscalls()) { ret = arm_gdb_syscall(cpu, arm_semi_cb, "unlink,%s", arg0, (int)arg1+1); } else { s = lock_user_string(arg0); if (!s) { return (uint32_t)-1; } ret = set_swi_errno(ts, remove(s)); unlock_user(s, arg0, 0); } return ret; case TARGET_SYS_RENAME: GET_ARG(0); GET_ARG(1); GET_ARG(2); GET_ARG(3); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "rename,%s,%s", arg0, (int)arg1+1, arg2, (int)arg3+1); } else { char *s2; s = lock_user_string(arg0); s2 = lock_user_string(arg2); if (!s || !s2) ret = (uint32_t)-1; else ret = set_swi_errno(ts, rename(s, s2)); if (s2) unlock_user(s2, arg2, 0); if (s) unlock_user(s, arg0, 0); return ret; } case TARGET_SYS_CLOCK: return clock() / (CLOCKS_PER_SEC / 100); case TARGET_SYS_TIME: return set_swi_errno(ts, time(NULL)); case TARGET_SYS_SYSTEM: GET_ARG(0); GET_ARG(1); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "system,%s", arg0, (int)arg1+1); } else { s = lock_user_string(arg0); if (!s) { return (uint32_t)-1; } ret = set_swi_errno(ts, system(s)); unlock_user(s, arg0, 0); return ret; } case TARGET_SYS_ERRNO: #ifdef CONFIG_USER_ONLY return ts->swi_errno; #else return syscall_err; #endif case TARGET_SYS_GET_CMDLINE: { char *output_buffer; size_t input_size; size_t output_size; int status = 0; #if !defined(CONFIG_USER_ONLY) const char *cmdline; #endif GET_ARG(0); GET_ARG(1); input_size = arg1; #if !defined(CONFIG_USER_ONLY) cmdline = semihosting_get_cmdline(); if (cmdline == NULL) { cmdline = ""; } output_size = strlen(cmdline) + 1; #else unsigned int i; output_size = ts->info->arg_end - ts->info->arg_start; if (!output_size) { output_size = 1; } #endif if (output_size > input_size) { return -1; } if (SET_ARG(1, output_size - 1)) { return -1; } output_buffer = lock_user(VERIFY_WRITE, arg0, output_size, 0); if (!output_buffer) { return -1; } #if !defined(CONFIG_USER_ONLY) pstrcpy(output_buffer, output_size, cmdline); #else if (output_size == 1) { output_buffer[0] = '\0'; goto out; } if (copy_from_user(output_buffer, ts->info->arg_start, output_size)) { status = -1; goto out; } for (i = 0; i < output_size - 1; i++) { if (output_buffer[i] == 0) { output_buffer[i] = ' '; } } out: #endif unlock_user(output_buffer, arg0, output_size); return status; } case TARGET_SYS_HEAPINFO: { target_ulong retvals[4]; uint32_t limit; int i; GET_ARG(0); #ifdef CONFIG_USER_ONLY if (!ts->heap_limit) { abi_ulong ret; ts->heap_base = do_brk(0); limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE; for (;;) { ret = do_brk(limit); if (ret >= limit) { break; } limit = (ts->heap_base >> 1) + (limit >> 1); } ts->heap_limit = limit; } retvals[0] = ts->heap_base; retvals[1] = ts->heap_limit; retvals[2] = ts->stack_base; retvals[3] = 0; #else limit = ram_size; retvals[0] = limit / 2; retvals[1] = limit; retvals[2] = limit; retvals[3] = 0; #endif for (i = 0; i < ARRAY_SIZE(retvals); i++) { bool fail; if (is_a64(env)) { fail = put_user_u64(retvals[i], arg0 + i * 8); } else { fail = put_user_u32(retvals[i], arg0 + i * 4); } if (fail) { return -1; } } return 0; } case TARGET_SYS_EXIT: if (is_a64(env)) { GET_ARG(0); GET_ARG(1); if (arg0 == ADP_Stopped_ApplicationExit) { ret = arg1; } else { ret = 1; } } else { ret = ([[args]] == ADP_Stopped_ApplicationExit) ? 0 : 1; } gdb_exit(env, ret); exit(ret); case TARGET_SYS_SYNCCACHE: if (is_a64(env)) { return 0; } default: fprintf(stderr, "qemu: Unsupported SemiHosting SWI 0x%02x\n", nr); cpu_dump_state(cs, stderr, fprintf, 0); abort(); } }

[[[[Adv]]]]: target_ulong do_arm_semihosting(CPUARMState *env) { ARMCPU *cpu = arm_env_get_cpu(env); CPUState *cs = CPU(cpu); target_ulong [[baskin]]; target_ulong arg0, arg1, arg2, arg3; char * s; int nr; uint32_t ret; uint32_t len; #ifdef CONFIG_USER_ONLY TaskState *ts = cs->opaque; #else CPUARMState *ts = env; #endif if (is_a64(env)) { nr = env->xregs[0] & 0xffffffffU; [[baskin]] = env->xregs[1]; } else { nr = env->regs[0]; [[baskin]] = env->regs[1]; } switch (nr) { case TARGET_SYS_OPEN: GET_ARG(0); GET_ARG(1); GET_ARG(2); s = lock_user_string(arg0); if (!s) { return (uint32_t)-1; } if (arg1 >= 12) { unlock_user(s, arg0, 0); return (uint32_t)-1; } if (strcmp(s, ":tt") == 0) { int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO; unlock_user(s, arg0, 0); return result_fileno; } if (use_gdb_syscalls()) { ret = arm_gdb_syscall(cpu, arm_semi_cb, "open,%s,%x,1a4", arg0, (int)arg2+1, gdb_open_modeflags[arg1]); } else { ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644)); } unlock_user(s, arg0, 0); return ret; case TARGET_SYS_CLOSE: GET_ARG(0); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "close,%x", arg0); } else { return set_swi_errno(ts, close(arg0)); } case TARGET_SYS_WRITEC: { char c; if (get_user_u8(c, [[baskin]])) return (uint32_t)-1; if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "write,2,%x,1", [[baskin]]); } else { return write(STDERR_FILENO, &c, 1); } } case TARGET_SYS_WRITE0: if (!(s = lock_user_string([[baskin]]))) return (uint32_t)-1; len = strlen(s); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "write,2,%x,%x", [[baskin]], len); } else { ret = write(STDERR_FILENO, s, len); } unlock_user(s, [[baskin]], 0); return ret; case TARGET_SYS_WRITE: GET_ARG(0); GET_ARG(1); GET_ARG(2); len = arg2; if (use_gdb_syscalls()) { arm_semi_syscall_len = len; return arm_gdb_syscall(cpu, arm_semi_cb, "write,%x,%x,%x", arg0, arg1, len); } else { s = lock_user(VERIFY_READ, arg1, len, 1); if (!s) { return (uint32_t)-1; } ret = set_swi_errno(ts, write(arg0, s, len)); unlock_user(s, arg1, 0); if (ret == (uint32_t)-1) return -1; return len - ret; } case TARGET_SYS_READ: GET_ARG(0); GET_ARG(1); GET_ARG(2); len = arg2; if (use_gdb_syscalls()) { arm_semi_syscall_len = len; return arm_gdb_syscall(cpu, arm_semi_cb, "read,%x,%x,%x", arg0, arg1, len); } else { s = lock_user(VERIFY_WRITE, arg1, len, 0); if (!s) { return (uint32_t)-1; } do { ret = set_swi_errno(ts, read(arg0, s, len)); } while (ret == -1 && errno == EINTR); unlock_user(s, arg1, len); if (ret == (uint32_t)-1) return -1; return len - ret; } case TARGET_SYS_READC: return 0; case TARGET_SYS_ISTTY: GET_ARG(0); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "isatty,%x", arg0); } else { return isatty(arg0); } case TARGET_SYS_SEEK: GET_ARG(0); GET_ARG(1); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "lseek,%x,%x,0", arg0, arg1); } else { ret = set_swi_errno(ts, lseek(arg0, arg1, SEEK_SET)); if (ret == (uint32_t)-1) return -1; return 0; } case TARGET_SYS_FLEN: GET_ARG(0); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_flen_cb, "fstat,%x,%x", arg0, arm_flen_buf(cpu)); } else { struct stat buf; ret = set_swi_errno(ts, fstat(arg0, &buf)); if (ret == (uint32_t)-1) return -1; return buf.st_size; } case TARGET_SYS_TMPNAM: return -1; case TARGET_SYS_REMOVE: GET_ARG(0); GET_ARG(1); if (use_gdb_syscalls()) { ret = arm_gdb_syscall(cpu, arm_semi_cb, "unlink,%s", arg0, (int)arg1+1); } else { s = lock_user_string(arg0); if (!s) { return (uint32_t)-1; } ret = set_swi_errno(ts, remove(s)); unlock_user(s, arg0, 0); } return ret; case TARGET_SYS_RENAME: GET_ARG(0); GET_ARG(1); GET_ARG(2); GET_ARG(3); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "rename,%s,%s", arg0, (int)arg1+1, arg2, (int)arg3+1); } else { char *s2; s = lock_user_string(arg0); s2 = lock_user_string(arg2); if (!s || !s2) ret = (uint32_t)-1; else ret = set_swi_errno(ts, rename(s, s2)); if (s2) unlock_user(s2, arg2, 0); if (s) unlock_user(s, arg0, 0); return ret; } case TARGET_SYS_CLOCK: return clock() / (CLOCKS_PER_SEC / 100); case TARGET_SYS_TIME: return set_swi_errno(ts, time(NULL)); case TARGET_SYS_SYSTEM: GET_ARG(0); GET_ARG(1); if (use_gdb_syscalls()) { return arm_gdb_syscall(cpu, arm_semi_cb, "system,%s", arg0, (int)arg1+1); } else { s = lock_user_string(arg0); if (!s) { return (uint32_t)-1; } ret = set_swi_errno(ts, system(s)); unlock_user(s, arg0, 0); return ret; } case TARGET_SYS_ERRNO: #ifdef CONFIG_USER_ONLY return ts->swi_errno; #else return syscall_err; #endif case TARGET_SYS_GET_CMDLINE: { char *output_buffer; size_t input_size; size_t output_size; int status = 0; #if !defined(CONFIG_USER_ONLY) const char *cmdline; #endif GET_ARG(0); GET_ARG(1); input_size = arg1; #if !defined(CONFIG_USER_ONLY) cmdline = semihosting_get_cmdline(); if (cmdline == NULL) { cmdline = ""; } output_size = strlen(cmdline) + 1; #else unsigned int i; output_size = ts->info->arg_end - ts->info->arg_start; if (!output_size) { output_size = 1; } #endif if (output_size > input_size) { return -1; } if (SET_ARG(1, output_size - 1)) { return -1; } output_buffer = lock_user(VERIFY_WRITE, arg0, output_size, 0); if (!output_buffer) { return -1; } #if !defined(CONFIG_USER_ONLY) pstrcpy(output_buffer, output_size, cmdline); #else if (output_size == 1) { output_buffer[0] = '\0'; goto out; } if (copy_from_user(output_buffer, ts->info->arg_start, output_size)) { status = -1; goto out; } for (i = 0; i < output_size - 1; i++) { if (output_buffer[i] == 0) { output_buffer[i] = ' '; } } out: #endif unlock_user(output_buffer, arg0, output_size); return status; } case TARGET_SYS_HEAPINFO: { target_ulong retvals[4]; uint32_t limit; int i; GET_ARG(0); #ifdef CONFIG_USER_ONLY if (!ts->heap_limit) { abi_ulong ret; ts->heap_base = do_brk(0); limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE; for (;;) { ret = do_brk(limit); if (ret >= limit) { break; } limit = (ts->heap_base >> 1) + (limit >> 1); } ts->heap_limit = limit; } retvals[0] = ts->heap_base; retvals[1] = ts->heap_limit; retvals[2] = ts->stack_base; retvals[3] = 0; #else limit = ram_size; retvals[0] = limit / 2; retvals[1] = limit; retvals[2] = limit; retvals[3] = 0; #endif for (i = 0; i < ARRAY_SIZE(retvals); i++) { bool fail; if (is_a64(env)) { fail = put_user_u64(retvals[i], arg0 + i * 8); } else { fail = put_user_u32(retvals[i], arg0 + i * 4); } if (fail) { return -1; } } return 0; } case TARGET_SYS_EXIT: if (is_a64(env)) { GET_ARG(0); GET_ARG(1); if (arg0 == ADP_Stopped_ApplicationExit) { ret = arg1; } else { ret = 1; } } else { ret = ([[baskin]] == ADP_Stopped_ApplicationExit) ? 0 : 1; } gdb_exit(env, ret); exit(ret); case TARGET_SYS_SYNCCACHE: if (is_a64(env)) { return 0; } default: fprintf(stderr, "qemu: Unsupported SemiHosting SWI 0x%02x\n", nr); cpu_dump_state(cs, stderr, fprintf, 0); abort(); } }[Succeeded / Failed / Skipped / Total] 399 / 41 / 259 / 699:  26%|       | 699/2690 [8:01:06<22:50:22, 41.30s/it][Succeeded / Failed / Skipped / Total] 399 / 41 / 259 / 699:  26%|       | 700/2690 [8:01:45<22:49:34, 41.29s/it][Succeeded / Failed / Skipped / Total] 400 / 41 / 259 / 700:  26%|       | 700/2690 [8:01:45<22:49:34, 41.29s/it][Succeeded / Failed / Skipped / Total] 400 / 41 / 259 / 700:  26%|       | 701/2690 [8:02:58<22:50:22, 41.34s/it][Succeeded / Failed / Skipped / Total] 401 / 41 / 259 / 701:  26%|       | 701/2690 [8:02:58<22:50:22, 41.34s/it][Succeeded / Failed / Skipped / Total] 401 / 41 / 259 / 701:  26%|       | 702/2690 [8:03:02<22:47:55, 41.29s/it][Succeeded / Failed / Skipped / Total] 402 / 41 / 259 / 702:  26%|       | 702/2690 [8:03:02<22:47:55, 41.29s/it][Succeeded / Failed / Skipped / Total] 402 / 41 / 259 / 702:  26%|       | 703/2690 [8:03:02<22:45:18, 41.23s/it][Succeeded / Failed / Skipped / Total] 402 / 41 / 260 / 703:  26%|       | 703/2690 [8:03:02<22:45:18, 41.23s/it][Succeeded / Failed / Skipped / Total] 402 / 41 / 260 / 703:  26%|       | 704/2690 [8:03:10<22:43:04, 41.18s/it]
--------------------------------------------- Result 700 ---------------------------------------------
[[0 (24%)]] --> [[0 (52%)]] --> Socre: 0.5205501317977905

[[[[Adv]]]]: static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb, void *logctx, int size) { uint8_t *[[user_data]]; int [[e]], build, i; if (size < 16 || size >= INT_MAX - 16) return AVERROR_INVALIDDATA; [[user_data]] = av_malloc(16 + size + 1); if (![[user_data]]) return AVERROR(ENOMEM); for (i = 0; i < size + 16; i++) [[user_data]][i] = get_bits(gb, 8); [[user_data]][i] = 0; [[e]] = sscanf([[user_data]] + 16, "x264 - core %d", &build); if ([[e]] == 1 && build > 0) h->x264_build = build; if ([[e]] == 1 && build == 1 && !strncmp([[user_data]]+16, "x264 - core 0000", 16)) h->x264_build = 67; if (strlen([[user_data]] + 16) > 0) av_log(logctx, AV_LOG_DEBUG, "user data:\"%s\"\n", [[user_data]] + 16); av_free([[user_data]]); return 0; }

[[[[Adv]]]]: static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb, void *logctx, int size) { uint8_t *[[manuscript]]; int [[w]], build, i; if (size < 16 || size >= INT_MAX - 16) return AVERROR_INVALIDDATA; [[manuscript]] = av_malloc(16 + size + 1); if (![[manuscript]]) return AVERROR(ENOMEM); for (i = 0; i < size + 16; i++) [[manuscript]][i] = get_bits(gb, 8); [[manuscript]][i] = 0; [[w]] = sscanf([[manuscript]] + 16, "x264 - core %d", &build); if ([[w]] == 1 && build > 0) h->x264_build = build; if ([[w]] == 1 && build == 1 && !strncmp([[manuscript]]+16, "x264 - core 0000", 16)) h->x264_build = 67; if (strlen([[manuscript]] + 16) > 0) av_log(logctx, AV_LOG_DEBUG, "user data:\"%s\"\n", [[manuscript]] + 16); av_free([[manuscript]]); return 0; }
--------------------------------------------- Result 701 ---------------------------------------------
[[0 (25%)]] --> [[0 (51%)]] --> Socre: 0.5125893354415894

[[[[Adv]]]]: void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref) { void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *); AVFilterPad *[[dst]] = link->dstpad; int [[i]]; FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1); if (!(filter_samples = [[dst]]->filter_samples)) filter_samples = avfilter_default_filter_samples; if (([[dst]]->min_perms & samplesref->perms) != [[dst]]->min_perms || [[dst]]->rej_perms & samplesref->perms) { av_log(link->dst, AV_LOG_DEBUG, "Copying audio data in avfilter (have perms %x, need %x, reject %x)\n", samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms); link->cur_buf = avfilter_default_get_audio_buffer(link, [[dst]]->min_perms, samplesref->audio->nb_samples); link->cur_buf->pts = samplesref->pts; link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate; for ([[i]] = 0; samplesref->data[[[i]]]; [[i]]++) memcpy(link->cur_buf->data[[[i]]], samplesref->data[[[i]]], samplesref->linesize[0]); avfilter_unref_buffer(samplesref); } else link->cur_buf = samplesref; filter_samples(link, link->cur_buf); }

[[[[Adv]]]]: void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref) { void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *); AVFilterPad *[[cnt]] = link->dstpad; int [[johnson]]; FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1); if (!(filter_samples = [[cnt]]->filter_samples)) filter_samples = avfilter_default_filter_samples; if (([[cnt]]->min_perms & samplesref->perms) != [[cnt]]->min_perms || [[cnt]]->rej_perms & samplesref->perms) { av_log(link->dst, AV_LOG_DEBUG, "Copying audio data in avfilter (have perms %x, need %x, reject %x)\n", samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms); link->cur_buf = avfilter_default_get_audio_buffer(link, [[cnt]]->min_perms, samplesref->audio->nb_samples); link->cur_buf->pts = samplesref->pts; link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate; for ([[johnson]] = 0; samplesref->data[[[johnson]]]; [[johnson]]++) memcpy(link->cur_buf->data[[[johnson]]], samplesref->data[[[johnson]]], samplesref->linesize[0]); avfilter_unref_buffer(samplesref); } else link->cur_buf = samplesref; filter_samples(link, link->cur_buf); }
--------------------------------------------- Result 702 ---------------------------------------------
[[0 (42%)]] --> [[0 (51%)]] --> Socre: 0.507710874080658

[[[[Adv]]]]: static qemu_irq *ppce500_init_mpic(PPCE500Params *params, MemoryRegion *ccsr, qemu_irq **irqs) { qemu_irq *[[mpic]]; DeviceState *dev; SysBusDevice *s; int i, j, k; [[mpic]] = g_new(qemu_irq, 256); dev = qdev_create(NULL, "openpic"); qdev_prop_set_uint32(dev, "nb_cpus", smp_cpus); qdev_prop_set_uint32(dev, "model", params->mpic_version); qdev_init_nofail(dev); s = SYS_BUS_DEVICE(dev); k = 0; for (i = 0; i < smp_cpus; i++) { for (j = 0; j < OPENPIC_OUTPUT_NB; j++) { sysbus_connect_irq(s, k++, irqs[i][j]); } } for (i = 0; i < 256; i++) { [[mpic]][i] = qdev_get_gpio_in(dev, i); } memory_region_add_subregion(ccsr, MPC8544_MPIC_REGS_OFFSET, s->mmio[0].memory); return [[mpic]]; }

[[[[Adv]]]]: static qemu_irq *ppce500_init_mpic(PPCE500Params *params, MemoryRegion *ccsr, qemu_irq **irqs) { qemu_irq *[[councilor]]; DeviceState *dev; SysBusDevice *s; int i, j, k; [[councilor]] = g_new(qemu_irq, 256); dev = qdev_create(NULL, "openpic"); qdev_prop_set_uint32(dev, "nb_cpus", smp_cpus); qdev_prop_set_uint32(dev, "model", params->mpic_version); qdev_init_nofail(dev); s = SYS_BUS_DEVICE(dev); k = 0; for (i = 0; i < smp_cpus; i++) { for (j = 0; j < OPENPIC_OUTPUT_NB; j++) { sysbus_connect_irq(s, k++, irqs[i][j]); } } for (i = 0; i < 256; i++) { [[councilor]][i] = qdev_get_gpio_in(dev, i); } memory_region_add_subregion(ccsr, MPC8544_MPIC_REGS_OFFSET, s->mmio[0].memory); return [[councilor]]; }
--------------------------------------------- Result 703 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: CharDriverState *qemu_chr_new(const char *label, const char *filename, void (*init)(struct CharDriverState *s)) { const char *p; CharDriverState *chr; QemuOpts *opts; Error *err = NULL; if (strstart(filename, "chardev:", &p)) { return qemu_chr_find(p); } opts = qemu_chr_parse_compat(label, filename); if (!opts) return NULL; chr = qemu_chr_new_from_opts(opts, init, &err); if (err) { error_report_err(err); } if (chr && qemu_opt_get_bool(opts, "mux", 0)) { qemu_chr_fe_claim_no_fail(chr); monitor_init(chr, MONITOR_USE_READLINE); } return chr; }
--------------------------------------------- Result 704 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 403 / 41 / 260 / 704:  26%|       | 704/2690 [8:03:10<22:43:04, 41.18s/it][Succeeded / Failed / Skipped / Total] 403 / 41 / 260 / 704:  26%|       | 705/2690 [8:03:19<22:40:51, 41.13s/it][Succeeded / Failed / Skipped / Total] 404 / 41 / 260 / 705:  26%|       | 705/2690 [8:03:19<22:40:51, 41.13s/it][Succeeded / Failed / Skipped / Total] 404 / 41 / 260 / 705:  26%|       | 706/2690 [8:03:20<22:38:16, 41.08s/it][Succeeded / Failed / Skipped / Total] 404 / 41 / 261 / 706:  26%|       | 706/2690 [8:03:20<22:38:16, 41.08s/it][Succeeded / Failed / Skipped / Total] 404 / 41 / 261 / 706:  26%|       | 707/2690 [8:03:29<22:36:05, 41.03s/it][[0 (23%)]] --> [[0 (63%)]] --> Socre: 0.6313230991363525

[[[[Adv]]]]: static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *[[peer]], const char *model, const char *[[name]], const char *ifname, const char *script, const char *downscript, const char *vhostfdname, int [[vnet_hdr]], int fd) { TAPState *s; s = net_tap_fd_init([[peer]], model, [[name]], fd, [[vnet_hdr]]); if (!s) { close(fd); return -1; } if (tap_set_sndbuf(s->fd, tap) < 0) { return -1; } if (tap->has_fd || tap->has_fds) { snprintf(s->nc.info_str, sizeof(s->nc.info_str), "fd=%d", fd); } else if (tap->has_helper) { snprintf(s->nc.info_str, sizeof(s->nc.info_str), "helper=%s", tap->helper); } else { snprintf(s->nc.info_str, sizeof(s->nc.info_str), "ifname=%s,script=%s,downscript=%s", ifname, script, downscript); if (strcmp(downscript, "no") != 0) { snprintf(s->down_script, sizeof(s->down_script), "%s", downscript); snprintf(s->down_script_arg, sizeof(s->down_script_arg), "%s", ifname); } } if (tap->has_vhost ? tap->vhost : vhostfdname || (tap->has_vhostforce && tap->vhostforce)) { int vhostfd; if (tap->has_vhostfd) { vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname); if (vhostfd == -1) { return -1; } } else { vhostfd = -1; } s->vhost_net = vhost_net_init(&s->nc, vhostfd, tap->has_vhostforce && tap->vhostforce); if (!s->vhost_net) { error_report("vhost-net requested but could not be initialized"); return -1; } } else if (tap->has_vhostfd || tap->has_vhostfds) { error_report("vhostfd= is not valid without vhost"); return -1; } return 0; }

[[[[Adv]]]]: static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *[[brah]], const char *model, const char *[[alphabetically]], const char *ifname, const char *script, const char *downscript, const char *vhostfdname, int [[ajit]], int fd) { TAPState *s; s = net_tap_fd_init([[brah]], model, [[alphabetically]], fd, [[ajit]]); if (!s) { close(fd); return -1; } if (tap_set_sndbuf(s->fd, tap) < 0) { return -1; } if (tap->has_fd || tap->has_fds) { snprintf(s->nc.info_str, sizeof(s->nc.info_str), "fd=%d", fd); } else if (tap->has_helper) { snprintf(s->nc.info_str, sizeof(s->nc.info_str), "helper=%s", tap->helper); } else { snprintf(s->nc.info_str, sizeof(s->nc.info_str), "ifname=%s,script=%s,downscript=%s", ifname, script, downscript); if (strcmp(downscript, "no") != 0) { snprintf(s->down_script, sizeof(s->down_script), "%s", downscript); snprintf(s->down_script_arg, sizeof(s->down_script_arg), "%s", ifname); } } if (tap->has_vhost ? tap->vhost : vhostfdname || (tap->has_vhostforce && tap->vhostforce)) { int vhostfd; if (tap->has_vhostfd) { vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname); if (vhostfd == -1) { return -1; } } else { vhostfd = -1; } s->vhost_net = vhost_net_init(&s->nc, vhostfd, tap->has_vhostforce && tap->vhostforce); if (!s->vhost_net) { error_report("vhost-net requested but could not be initialized"); return -1; } } else if (tap->has_vhostfd || tap->has_vhostfds) { error_report("vhostfd= is not valid without vhost"); return -1; } return 0; }
--------------------------------------------- Result 705 ---------------------------------------------
[[0 (43%)]] --> [[0 (55%)]] --> Socre: 0.5549519062042236

[[[[Adv]]]]: int qdev_prop_check_globals(void) { GList *l; int ret = 0; for (l = global_props; l; l = l->next) { GlobalProperty *[[prop]] = l->data; ObjectClass *oc; DeviceClass *dc; if ([[prop]]->used) { continue; } if (![[prop]]->user_provided) { continue; } oc = object_class_by_name([[prop]]->driver); oc = object_class_dynamic_cast(oc, TYPE_DEVICE); if (!oc) { error_report("Warning: global %s.%s has invalid class name", [[prop]]->driver, [[prop]]->property); ret = 1; continue; } dc = DEVICE_CLASS(oc); if (!dc->hotpluggable && ![[prop]]->used) { error_report("Warning: global %s.%s=%s not used", [[prop]]->driver, [[prop]]->property, [[prop]]->value); ret = 1; continue; } } return ret; }

[[[[Adv]]]]: int qdev_prop_check_globals(void) { GList *l; int ret = 0; for (l = global_props; l; l = l->next) { GlobalProperty *[[accomplice]] = l->data; ObjectClass *oc; DeviceClass *dc; if ([[accomplice]]->used) { continue; } if (![[accomplice]]->user_provided) { continue; } oc = object_class_by_name([[accomplice]]->driver); oc = object_class_dynamic_cast(oc, TYPE_DEVICE); if (!oc) { error_report("Warning: global %s.%s has invalid class name", [[accomplice]]->driver, [[accomplice]]->property); ret = 1; continue; } dc = DEVICE_CLASS(oc); if (!dc->hotpluggable && ![[accomplice]]->used) { error_report("Warning: global %s.%s=%s not used", [[accomplice]]->driver, [[accomplice]]->property, [[accomplice]]->value); ret = 1; continue; } } return ret; }
--------------------------------------------- Result 706 ---------------------------------------------
[[0 (71%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qesd_init_out (HWVoiceOut *hw, audsettings_t *as) { ESDVoiceOut *esd = (ESDVoiceOut *) hw; audsettings_t obt_as = *as; int esdfmt = ESD_STREAM | ESD_PLAY; int err; sigset_t set, old_set; sigfillset (&set); esdfmt |= (as->nchannels == 2) ? ESD_STEREO : ESD_MONO; switch (as->fmt) { case AUD_FMT_S8: case AUD_FMT_U8: esdfmt |= ESD_BITS8; obt_as.fmt = AUD_FMT_U8; break; case AUD_FMT_S32: case AUD_FMT_U32: dolog ("Will use 16 instead of 32 bit samples\n"); case AUD_FMT_S16: case AUD_FMT_U16: deffmt: esdfmt |= ESD_BITS16; obt_as.fmt = AUD_FMT_S16; break; default: dolog ("Internal logic error: Bad audio format %d\n", as->fmt); goto deffmt; } obt_as.endianness = AUDIO_HOST_ENDIANNESS; audio_pcm_init_info (&hw->info, &obt_as); hw->samples = conf.samples; esd->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift); if (!esd->pcm_buf) { dolog ("Could not allocate buffer (%d bytes)\n", hw->samples << hw->info.shift); return -1; } esd->fd = -1; err = pthread_sigmask (SIG_BLOCK, &set, &old_set); if (err) { qesd_logerr (err, "pthread_sigmask failed\n"); goto fail1; } esd->fd = esd_play_stream (esdfmt, as->freq, conf.dac_host, NULL); if (esd->fd < 0) { qesd_logerr (errno, "esd_play_stream failed\n"); goto fail2; } if (audio_pt_init (&esd->pt, qesd_thread_out, esd, AUDIO_CAP, AUDIO_FUNC)) { goto fail3; } err = pthread_sigmask (SIG_SETMASK, &old_set, NULL); if (err) { qesd_logerr (err, "pthread_sigmask(restore) failed\n"); } return 0; fail3: if (close (esd->fd)) { qesd_logerr (errno, "%s: close on esd socket(%d) failed\n", AUDIO_FUNC, esd->fd); } esd->fd = -1; fail2: err = pthread_sigmask (SIG_SETMASK, &old_set, NULL); if (err) { qesd_logerr (err, "pthread_sigmask(restore) failed\n"); } fail1: qemu_free (esd->pcm_buf); esd->pcm_buf = NULL; return -1; }
--------------------------------------------- Result 707 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 405 / 41 / 261 / 707:  26%|       | 707/2690 [8:03:29<22:36:05, 41.03s/it][Succeeded / Failed / Skipped / Total] 405 / 41 / 261 / 707:  26%|       | 708/2690 [8:03:29<22:33:31, 40.97s/it][Succeeded / Failed / Skipped / Total] 405 / 41 / 262 / 708:  26%|       | 708/2690 [8:03:29<22:33:31, 40.97s/it][Succeeded / Failed / Skipped / Total] 405 / 41 / 262 / 708:  26%|       | 709/2690 [8:03:35<22:31:11, 40.92s/it][[0 (89%)]] --> [[0 (40%)]] --> Socre: 0.5995535254478455

[[[[Adv]]]]: static void monitor_find_completion(const char *cmdline) { const char *cmdname; char *args[MAX_ARGS]; int nb_args, i, len; const char *ptype, *str; const mon_cmd_t *[[cmd]]; const KeyDef *key; parse_cmdline(cmdline, &nb_args, args); #ifdef DEBUG_COMPLETION for(i = 0; i < nb_args; i++) { monitor_printf(cur_mon, "arg%d = '%s'\n", i, (char *)args[i]); } #endif len = strlen(cmdline); if (len > 0 && qemu_isspace(cmdline[len - 1])) { if (nb_args >= MAX_ARGS) return; args[nb_args++] = qemu_strdup(""); } if (nb_args <= 1) { if (nb_args == 0) cmdname = ""; else cmdname = args[0]; readline_set_completion_index(cur_mon->rs, strlen(cmdname)); for([[cmd]] = mon_cmds; [[cmd]]->name != NULL; [[cmd]]++) { cmd_completion(cmdname, [[cmd]]->name); } } else { for([[cmd]] = mon_cmds; [[cmd]]->name != NULL; [[cmd]]++) { if (compare_cmd(args[0], [[cmd]]->name)) goto found; } return; found: ptype = next_arg_type([[cmd]]->args_type); for(i = 0; i < nb_args - 2; i++) { if (*ptype != '\0') { ptype = next_arg_type(ptype); while (*ptype == '?') ptype = next_arg_type(ptype); } } str = args[nb_args - 1]; if (*ptype == '-' && ptype[1] != '\0') { ptype += 2; } switch(*ptype) { case 'F': readline_set_completion_index(cur_mon->rs, strlen(str)); file_completion(str); break; case 'B': readline_set_completion_index(cur_mon->rs, strlen(str)); bdrv_iterate(block_completion_it, (void *)str); break; case 's': if (!strcmp([[cmd]]->name, "info")) { readline_set_completion_index(cur_mon->rs, strlen(str)); for([[cmd]] = info_cmds; [[cmd]]->name != NULL; [[cmd]]++) { cmd_completion(str, [[cmd]]->name); } } else if (!strcmp([[cmd]]->name, "sendkey")) { char *sep = strrchr(str, '-'); if (sep) str = sep + 1; readline_set_completion_index(cur_mon->rs, strlen(str)); for(key = key_defs; key->name != NULL; key++) { cmd_completion(str, key->name); } } else if (!strcmp([[cmd]]->name, "help|?")) { readline_set_completion_index(cur_mon->rs, strlen(str)); for ([[cmd]] = mon_cmds; [[cmd]]->name != NULL; [[cmd]]++) { cmd_completion(str, [[cmd]]->name); } } break; default: break; } } for(i = 0; i < nb_args; i++) qemu_free(args[i]); }

[[[[Adv]]]]: static void monitor_find_completion(const char *cmdline) { const char *cmdname; char *args[MAX_ARGS]; int nb_args, i, len; const char *ptype, *str; const mon_cmd_t *[[jk]]; const KeyDef *key; parse_cmdline(cmdline, &nb_args, args); #ifdef DEBUG_COMPLETION for(i = 0; i < nb_args; i++) { monitor_printf(cur_mon, "arg%d = '%s'\n", i, (char *)args[i]); } #endif len = strlen(cmdline); if (len > 0 && qemu_isspace(cmdline[len - 1])) { if (nb_args >= MAX_ARGS) return; args[nb_args++] = qemu_strdup(""); } if (nb_args <= 1) { if (nb_args == 0) cmdname = ""; else cmdname = args[0]; readline_set_completion_index(cur_mon->rs, strlen(cmdname)); for([[jk]] = mon_cmds; [[jk]]->name != NULL; [[jk]]++) { cmd_completion(cmdname, [[jk]]->name); } } else { for([[jk]] = mon_cmds; [[jk]]->name != NULL; [[jk]]++) { if (compare_cmd(args[0], [[jk]]->name)) goto found; } return; found: ptype = next_arg_type([[jk]]->args_type); for(i = 0; i < nb_args - 2; i++) { if (*ptype != '\0') { ptype = next_arg_type(ptype); while (*ptype == '?') ptype = next_arg_type(ptype); } } str = args[nb_args - 1]; if (*ptype == '-' && ptype[1] != '\0') { ptype += 2; } switch(*ptype) { case 'F': readline_set_completion_index(cur_mon->rs, strlen(str)); file_completion(str); break; case 'B': readline_set_completion_index(cur_mon->rs, strlen(str)); bdrv_iterate(block_completion_it, (void *)str); break; case 's': if (!strcmp([[jk]]->name, "info")) { readline_set_completion_index(cur_mon->rs, strlen(str)); for([[jk]] = info_cmds; [[jk]]->name != NULL; [[jk]]++) { cmd_completion(str, [[jk]]->name); } } else if (!strcmp([[jk]]->name, "sendkey")) { char *sep = strrchr(str, '-'); if (sep) str = sep + 1; readline_set_completion_index(cur_mon->rs, strlen(str)); for(key = key_defs; key->name != NULL; key++) { cmd_completion(str, key->name); } } else if (!strcmp([[jk]]->name, "help|?")) { readline_set_completion_index(cur_mon->rs, strlen(str)); for ([[jk]] = mon_cmds; [[jk]]->name != NULL; [[jk]]++) { cmd_completion(str, [[jk]]->name); } } break; default: break; } } for(i = 0; i < nb_args; i++) qemu_free(args[i]); }
--------------------------------------------- Result 708 ---------------------------------------------
[[0 (66%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void sd_response_r1_make(SDState *sd, uint8_t *response, uint32_t last_status) { uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND; uint32_t status; status = (sd->card_status & ~mask) | (last_status & mask); sd->card_status &= ~CARD_STATUS_C | APP_CMD; response[0] = (status >> 24) & 0xff; response[1] = (status >> 16) & 0xff; response[2] = (status >> 8) & 0xff; response[3] = (status >> 0) & 0xff; }
--------------------------------------------- Result 709 ---------------------------------------------
[[0 (44%)]] --> [[0 (52%)]] --> Socre: 0.5182660222053528

[[[[Adv]]]]: static int mpc8_decode_frame(AVCodecContext * avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int [[buf_size]] = avpkt->size; MPCContext *c = avctx->priv_data; GetBitContext gb2, *gb = &gb2; int i, j, k, ch, cnt, res, t; Band *bands = c->bands; int [[off]]; int maxband, keyframe; int last[2]; keyframe = c->cur_frame == 0; if(keyframe){ memset(c->Q, 0, sizeof(c->Q)); c->last_bits_used = 0; } init_get_bits(gb, buf, [[buf_size]] * 8); skip_bits(gb, c->last_bits_used & 7); if(keyframe) maxband = mpc8_get_mod_golomb(gb, c->maxbands + 1); else{ maxband = c->last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2); if(maxband > 32) maxband -= 33; } c->last_max_band = maxband; if(maxband){ last[0] = last[1] = 0; for(i = maxband - 1; i >= 0; i--){ for(ch = 0; ch < 2; ch++){ last[ch] = get_vlc2(gb, res_vlc[last[ch] > 2].table, MPC8_RES_BITS, 2) + last[ch]; if(last[ch] > 15) last[ch] -= 17; bands[i].res[ch] = last[ch]; } } if(c->MSS){ int mask; cnt = 0; for(i = 0; i < maxband; i++) if(bands[i].res[0] || bands[i].res[1]) cnt++; t = mpc8_get_mod_golomb(gb, cnt); mask = mpc8_get_mask(gb, cnt, t); for(i = maxband - 1; i >= 0; i--) if(bands[i].res[0] || bands[i].res[1]){ bands[i].msf = mask & 1; mask >>= 1; } } } for(i = maxband; i < c->maxbands; i++) bands[i].res[0] = bands[i].res[1] = 0; if(keyframe){ for(i = 0; i < 32; i++) c->oldDSCF[0][i] = c->oldDSCF[1][i] = 1; } for(i = 0; i < maxband; i++){ if(bands[i].res[0] || bands[i].res[1]){ cnt = !!bands[i].res[0] + !!bands[i].res[1] - 1; if(cnt >= 0){ t = get_vlc2(gb, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1); if(bands[i].res[0]) bands[i].scfi[0] = t >> (2 * cnt); if(bands[i].res[1]) bands[i].scfi[1] = t & 3; } } } for(i = 0; i < maxband; i++){ for(ch = 0; ch < 2; ch++){ if(!bands[i].res[ch]) continue; if(c->oldDSCF[ch][i]){ bands[i].scf_idx[ch][0] = get_bits(gb, 7) - 6; c->oldDSCF[ch][i] = 0; }else{ t = get_vlc2(gb, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2); if(t == 64) t += get_bits(gb, 6); bands[i].scf_idx[ch][0] = ((bands[i].scf_idx[ch][2] + t - 25) & 0x7F) - 6; } for(j = 0; j < 2; j++){ if((bands[i].scfi[ch] << j) & 2) bands[i].scf_idx[ch][j + 1] = bands[i].scf_idx[ch][j]; else{ t = get_vlc2(gb, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2); if(t == 31) t = 64 + get_bits(gb, 6); bands[i].scf_idx[ch][j + 1] = ((bands[i].scf_idx[ch][j] + t - 25) & 0x7F) - 6; } } } } for(i = 0, [[off]] = 0; i < maxband; i++, [[off]] += SAMPLES_PER_BAND){ for(ch = 0; ch < 2; ch++){ res = bands[i].res[ch]; switch(res){ case -1: for(j = 0; j < SAMPLES_PER_BAND; j++) c->Q[ch][[[off]] + j] = (av_lfg_get(&c->rnd) & 0x3FC) - 510; break; case 0: break; case 1: for(j = 0; j < SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){ cnt = get_vlc2(gb, q1_vlc.table, MPC8_Q1_BITS, 2); t = mpc8_get_mask(gb, 18, cnt); for(k = 0; k < SAMPLES_PER_BAND / 2; k++, t <<= 1) c->Q[ch][[[off]] + j + k] = (t & 0x20000) ? (get_bits1(gb) << 1) - 1 : 0; } break; case 2: cnt = 6; for(j = 0; j < SAMPLES_PER_BAND; j += 3){ t = get_vlc2(gb, q2_vlc[cnt > 3].table, MPC8_Q2_BITS, 2); c->Q[ch][[[off]] + j + 0] = mpc8_idx50[t]; c->Q[ch][[[off]] + j + 1] = mpc8_idx51[t]; c->Q[ch][[[off]] + j + 2] = mpc8_idx52[t]; cnt = (cnt >> 1) + mpc8_huffq2[t]; } break; case 3: case 4: for(j = 0; j < SAMPLES_PER_BAND; j += 2){ t = get_vlc2(gb, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3]; c->Q[ch][[[off]] + j + 1] = t >> 4; c->Q[ch][[[off]] + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF); } break; case 5: case 6: case 7: case 8: cnt = 2 * mpc8_thres[res]; for(j = 0; j < SAMPLES_PER_BAND; j++){ t = get_vlc2(gb, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5]; c->Q[ch][[[off]] + j] = t; cnt = (cnt >> 1) + FFABS(c->Q[ch][[[off]] + j]); } break; default: for(j = 0; j < SAMPLES_PER_BAND; j++){ c->Q[ch][[[off]] + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2); if(res != 9){ c->Q[ch][[[off]] + j] <<= res - 9; c->Q[ch][[[off]] + j] |= get_bits(gb, res - 9); } c->Q[ch][[[off]] + j] -= (1 << (res - 2)) - 1; } } } } ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels); c->cur_frame++; c->last_bits_used = get_bits_count(gb); if(c->cur_frame >= c->frames) c->cur_frame = 0; *data_size = MPC_FRAME_SIZE * 2 * avctx->channels; return c->cur_frame ? c->last_bits_used >> 3 : [[buf_size]]; }

[[[[Adv]]]]: static int mpc8_decode_frame(AVCodecContext * avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int [[hereto]] = avpkt->size; MPCContext *c = avctx->priv_data; GetBitContext gb2, *gb = &gb2; int i, j, k, ch, cnt, res, t; Band *bands = c->bands; int [[disabling]]; int maxband, keyframe; int last[2]; keyframe = c->cur_frame == 0; if(keyframe){ memset(c->Q, 0, sizeof(c->Q)); c->last_bits_used = 0; } init_get_bits(gb, buf, [[hereto]] * 8); skip_bits(gb, c->last_bits_used & 7); if(keyframe) maxband = mpc8_get_mod_golomb(gb, c->maxbands + 1); else{ maxband = c->last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2); if(maxband > 32) maxband -= 33; } c->last_max_band = maxband; if(maxband){ last[0] = last[1] = 0; for(i = maxband - 1; i >= 0; i--){ for(ch = 0; ch < 2; ch++){ last[ch] = get_vlc2(gb, res_vlc[last[ch] > 2].table, MPC8_RES_BITS, 2) + last[ch]; if(last[ch] > 15) last[ch] -= 17; bands[i].res[ch] = last[ch]; } } if(c->MSS){ int mask; cnt = 0; for(i = 0; i < maxband; i++) if(bands[i].res[0] || bands[i].res[1]) cnt++; t = mpc8_get_mod_golomb(gb, cnt); mask = mpc8_get_mask(gb, cnt, t); for(i = maxband - 1; i >= 0; i--) if(bands[i].res[0] || bands[i].res[1]){ bands[i].msf = mask & 1; mask >>= 1; } } } for(i = maxband; i < c->maxbands; i++) bands[i].res[0] = bands[i].res[1] = 0; if(keyframe){ for(i = 0; i < 32; i++) c->oldDSCF[0][i] = c->oldDSCF[1][i] = 1; } for(i = 0; i < maxband; i++){ if(bands[i].res[0] || bands[i].res[1]){ cnt = !!bands[i].res[0] + !!bands[i].res[1] - 1; if(cnt >= 0){ t = get_vlc2(gb, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1); if(bands[i].res[0]) bands[i].scfi[0] = t >> (2 * cnt); if(bands[i].res[1]) bands[i].scfi[1] = t & 3; } } } for(i = 0; i < maxband; i++){ for(ch = 0; ch < 2; ch++){ if(!bands[i].res[ch]) continue; if(c->oldDSCF[ch][i]){ bands[i].scf_idx[ch][0] = get_bits(gb, 7) - 6; c->oldDSCF[ch][i] = 0; }else{ t = get_vlc2(gb, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2); if(t == 64) t += get_bits(gb, 6); bands[i].scf_idx[ch][0] = ((bands[i].scf_idx[ch][2] + t - 25) & 0x7F) - 6; } for(j = 0; j < 2; j++){ if((bands[i].scfi[ch] << j) & 2) bands[i].scf_idx[ch][j + 1] = bands[i].scf_idx[ch][j]; else{ t = get_vlc2(gb, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2); if(t == 31) t = 64 + get_bits(gb, 6); bands[i].scf_idx[ch][j + 1] = ((bands[i].scf_idx[ch][j] + t - 25) & 0x7F) - 6; } } } } for(i = 0, [[disabling]] = 0; i < maxband; i++, [[disabling]] += SAMPLES_PER_BAND){ for(ch = 0; ch < 2; ch++){ res = bands[i].res[ch]; switch(res){ case -1: for(j = 0; j < SAMPLES_PER_BAND; j++) c->Q[ch][[[disabling]] + j] = (av_lfg_get(&c->rnd) & 0x3FC) - 510; break; case 0: break; case 1: for(j = 0; j < SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){ cnt = get_vlc2(gb, q1_vlc.table, MPC8_Q1_BITS, 2); t = mpc8_get_mask(gb, 18, cnt); for(k = 0; k < SAMPLES_PER_BAND / 2; k++, t <<= 1) c->Q[ch][[[disabling]] + j + k] = (t & 0x20000) ? (get_bits1(gb) << 1) - 1 : 0; } break; case 2: cnt = 6; for(j = 0; j < SAMPLES_PER_BAND; j += 3){ t = get_vlc2(gb, q2_vlc[cnt > 3].table, MPC8_Q2_BITS, 2); c->Q[ch][[[disabling]] + j + 0] = mpc8_idx50[t]; c->Q[ch][[[disabling]] + j + 1] = mpc8_idx51[t]; c->Q[ch][[[disabling]] + j + 2] = mpc8_idx52[t]; cnt = (cnt >> 1) + mpc8_huffq2[t]; } break; case 3: case 4: for(j = 0; j < SAMPLES_PER_BAND; j += 2){ t = get_vlc2(gb, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3]; c->Q[ch][[[disabling]] + j + 1] = t >> 4; c->Q[ch][[[disabling]] + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF); } break; case 5: case 6: case 7: case 8: cnt = 2 * mpc8_thres[res]; for(j = 0; j < SAMPLES_PER_BAND; j++){ t = get_vlc2(gb, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5]; c->Q[ch][[[disabling]] + j] = t; cnt = (cnt >> 1) + FFABS(c->Q[ch][[[disabling]] + j]); } break; default: for(j = 0; j < SAMPLES_PER_BAND; j++){ c->Q[ch][[[disabling]] + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2); if(res != 9){ c->Q[ch][[[disabling]] + j] <<= res - 9; c->Q[ch][[[disabling]] + j] |= get_bits(gb, res - 9); } c->Q[ch][[[disabling]] + j] -= (1 << (res - 2)) - 1; } } } } ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels); c->cur_frame++; c->last_bits_used = get_bits_count(gb); if(c->cur_frame >= c->frames) c->cur_frame = 0; *data_size = MPC_FRAME_SIZE * 2 * avctx->channels; return c->cur_frame ? c->last_bits_used >> 3 : [[hereto]]; }[Succeeded / Failed / Skipped / Total] 406 / 41 / 262 / 709:  26%|       | 709/2690 [8:03:35<22:31:11, 40.92s/it][Succeeded / Failed / Skipped / Total] 406 / 41 / 262 / 709:  26%|       | 710/2690 [8:03:40<22:28:50, 40.87s/it][Succeeded / Failed / Skipped / Total] 407 / 41 / 262 / 710:  26%|       | 710/2690 [8:03:40<22:28:50, 40.87s/it][Succeeded / Failed / Skipped / Total] 407 / 41 / 262 / 710:  26%|       | 711/2690 [8:03:41<22:26:17, 40.82s/it][Succeeded / Failed / Skipped / Total] 407 / 41 / 263 / 711:  26%|       | 711/2690 [8:03:41<22:26:17, 40.82s/it][Succeeded / Failed / Skipped / Total] 407 / 41 / 263 / 711:  26%|       | 712/2690 [8:06:04<22:30:21, 40.96s/it][Succeeded / Failed / Skipped / Total] 407 / 42 / 263 / 712:  26%|       | 712/2690 [8:06:04<22:30:21, 40.96s/it][Succeeded / Failed / Skipped / Total] 407 / 42 / 263 / 712:  27%|       | 713/2690 [8:06:05<22:27:48, 40.90s/it][Succeeded / Failed / Skipped / Total] 407 / 42 / 264 / 713:  27%|       | 713/2690 [8:06:05<22:27:48, 40.90s/it][Succeeded / Failed / Skipped / Total] 407 / 42 / 264 / 713:  27%|       | 714/2690 [8:06:12<22:25:35, 40.86s/it]
--------------------------------------------- Result 710 ---------------------------------------------
[[0 (14%)]] --> [[0 (53%)]] --> Socre: 0.5341324210166931

[[[[Adv]]]]: DeviceState *qdev_try_create(BusState *bus, const char *[[name]]) { DeviceState *dev; if (object_class_by_name([[name]]) == NULL) { return NULL; } dev = DEVICE(object_new([[name]])); if (!dev) { return NULL; } if (!bus) { bus = sysbus_get_default(); } qdev_set_parent_bus(dev, bus); qdev_prop_set_globals(dev); return dev; }

[[[[Adv]]]]: DeviceState *qdev_try_create(BusState *bus, const char *[[appointments]]) { DeviceState *dev; if (object_class_by_name([[appointments]]) == NULL) { return NULL; } dev = DEVICE(object_new([[appointments]])); if (!dev) { return NULL; } if (!bus) { bus = sysbus_get_default(); } qdev_set_parent_bus(dev, bus); qdev_prop_set_globals(dev); return dev; }
--------------------------------------------- Result 711 ---------------------------------------------
[[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: Visitor *qobject_input_visitor_new_keyval(QObject *obj) { QObjectInputVisitor *v = qobject_input_visitor_base_new(obj); v->visitor.type_int64 = qobject_input_type_int64_keyval; v->visitor.type_uint64 = qobject_input_type_uint64_keyval; v->visitor.type_bool = qobject_input_type_bool_keyval; v->visitor.type_str = qobject_input_type_str; v->visitor.type_number = qobject_input_type_number_keyval; v->visitor.type_any = qobject_input_type_any; v->visitor.type_null = qobject_input_type_null; v->visitor.type_size = qobject_input_type_size_keyval; return &v->visitor; }
--------------------------------------------- Result 712 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void sdhci_send_command(SDHCIState *s) { SDRequest request; uint8_t response[16]; int rlen; s->errintsts = 0; s->acmd12errsts = 0; request.cmd = s->cmdreg >> 8; request.arg = s->argument; DPRINT_L1("sending CMD%u ARG[0x%08x]\n", request.cmd, request.arg); rlen = sdbus_do_command(&s->sdbus, &request, response); if (s->cmdreg & SDHC_CMD_RESPONSE) { if (rlen == 4) { s->rspreg[0] = (response[0] << 24) | (response[1] << 16) | (response[2] << 8) | response[3]; s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0; DPRINT_L1("Response: RSPREG[31..0]=0x%08x\n", s->rspreg[0]); } else if (rlen == 16) { s->rspreg[0] = (response[11] << 24) | (response[12] << 16) | (response[13] << 8) | response[14]; s->rspreg[1] = (response[7] << 24) | (response[8] << 16) | (response[9] << 8) | response[10]; s->rspreg[2] = (response[3] << 24) | (response[4] << 16) | (response[5] << 8) | response[6]; s->rspreg[3] = (response[0] << 16) | (response[1] << 8) | response[2]; DPRINT_L1("Response received:\n RSPREG[127..96]=0x%08x, RSPREG[95.." "64]=0x%08x,\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\n", s->rspreg[3], s->rspreg[2], s->rspreg[1], s->rspreg[0]); } else { ERRPRINT("Timeout waiting for command response\n"); if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) { s->errintsts |= SDHC_EIS_CMDTIMEOUT; s->norintsts |= SDHC_NIS_ERR; } } if ((s->norintstsen & SDHC_NISEN_TRSCMP) && (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) { s->norintsts |= SDHC_NIS_TRSCMP; } } if (s->norintstsen & SDHC_NISEN_CMDCMP) { s->norintsts |= SDHC_NIS_CMDCMP; } sdhci_update_irq(s); if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) { s->data_count = 0; sdhci_data_transfer(s); } }

[[[[Adv]]]]: static void sdhci_send_command(SDHCIState *s) { SDRequest request; uint8_t response[16]; int rlen; s->errintsts = 0; s->acmd12errsts = 0; request.cmd = s->cmdreg >> 8; request.arg = s->argument; DPRINT_L1("sending CMD%u ARG[0x%08x]\n", request.cmd, request.arg); rlen = sdbus_do_command(&s->sdbus, &request, response); if (s->cmdreg & SDHC_CMD_RESPONSE) { if (rlen == 4) { s->rspreg[0] = (response[0] << 24) | (response[1] << 16) | (response[2] << 8) | response[3]; s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0; DPRINT_L1("Response: RSPREG[31..0]=0x%08x\n", s->rspreg[0]); } else if (rlen == 16) { s->rspreg[0] = (response[11] << 24) | (response[12] << 16) | (response[13] << 8) | response[14]; s->rspreg[1] = (response[7] << 24) | (response[8] << 16) | (response[9] << 8) | response[10]; s->rspreg[2] = (response[3] << 24) | (response[4] << 16) | (response[5] << 8) | response[6]; s->rspreg[3] = (response[0] << 16) | (response[1] << 8) | response[2]; DPRINT_L1("Response received:\n RSPREG[127..96]=0x%08x, RSPREG[95.." "64]=0x%08x,\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\n", s->rspreg[3], s->rspreg[2], s->rspreg[1], s->rspreg[0]); } else { ERRPRINT("Timeout waiting for command response\n"); if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) { s->errintsts |= SDHC_EIS_CMDTIMEOUT; s->norintsts |= SDHC_NIS_ERR; } } if ((s->norintstsen & SDHC_NISEN_TRSCMP) && (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) { s->norintsts |= SDHC_NIS_TRSCMP; } } if (s->norintstsen & SDHC_NISEN_CMDCMP) { s->norintsts |= SDHC_NIS_CMDCMP; } sdhci_update_irq(s); if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) { s->data_count = 0; sdhci_data_transfer(s); } }
--------------------------------------------- Result 713 ---------------------------------------------
[[0 (83%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold void init_coef_vlc(VLC *vlc, uint16_t **prun_table, float **plevel_table, uint16_t **pint_table, const CoefVLCTable *vlc_table) { int n = vlc_table->n; const uint8_t *table_bits = vlc_table->huffbits; const uint32_t *table_codes = vlc_table->huffcodes; const uint16_t *levels_table = vlc_table->levels; uint16_t *run_table, *level_table, *int_table; float *flevel_table; int i, l, j, k, level; init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0); run_table = av_malloc(n * sizeof(uint16_t)); level_table = av_malloc(n * sizeof(uint16_t)); flevel_table = av_malloc(n * sizeof(*flevel_table)); int_table = av_malloc(n * sizeof(uint16_t)); i = 2; level = 1; k = 0; while (i < n) { int_table[k] = i; l = levels_table[k++]; for (j = 0; j < l; j++) { run_table[i] = j; level_table[i] = level; flevel_table[i] = level; i++; } level++; } *prun_table = run_table; *plevel_table = flevel_table; *pint_table = int_table; av_free(level_table); }
--------------------------------------------- Result 714 ---------------------------------------------
[[0 (27%)]] --> [[0 (54%)]] --> Socre: 0.5396760106086731

[[[[Adv]]]]: static inline int parse_nal_units(AVCodecParserContext *s, AVCodecContext *avctx, const uint8_t *buf, int buf_size) { H264ParseContext *p = s->priv_data; const uint8_t *buf_end = buf + buf_size; H2645NAL nal = { NULL }; unsigned int pps_id; unsigned int slice_type; int state = -1, got_reset = 0; int field_poc[2]; int [[ret]]; s->pict_type = AV_PICTURE_TYPE_I; s->key_frame = 0; s->picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN; ff_h264_sei_uninit(&p->sei); if (!buf_size) return 0; for (;;) { const SPS *sps; int src_length, consumed; buf = avpriv_find_start_code(buf, buf_end, &state); if (buf >= buf_end) break; --buf; src_length = buf_end - buf; switch (state & 0x1f) { case H264_NAL_SLICE: case H264_NAL_IDR_SLICE: if ((state & 0x1f) == H264_NAL_IDR_SLICE || ((state >> 5) & 0x3) == 0) { if (src_length > 60) src_length = 60; } else { if (src_length > 1000) src_length = 1000; } break; } consumed = ff_h2645_extract_rbsp(buf, src_length, &nal); if (consumed < 0) break; [[ret]] = init_get_bits(&nal.gb, nal.data, nal.size * 8); if ([[ret]] < 0) goto fail; get_bits1(&nal.gb); nal.ref_idc = get_bits(&nal.gb, 2); nal.type = get_bits(&nal.gb, 5); switch (nal.type) { case H264_NAL_SPS: ff_h264_decode_seq_parameter_set(&nal.gb, avctx, &p->ps); break; case H264_NAL_PPS: ff_h264_decode_picture_parameter_set(&nal.gb, avctx, &p->ps, nal.size_bits); break; case H264_NAL_SEI: ff_h264_sei_decode(&p->sei, &nal.gb, &p->ps, avctx); break; case H264_NAL_IDR_SLICE: s->key_frame = 1; p->poc.prev_frame_num = 0; p->poc.prev_frame_num_offset = 0; p->poc.prev_poc_msb = p->poc.prev_poc_lsb = 0; case H264_NAL_SLICE: get_ue_golomb(&nal.gb); slice_type = get_ue_golomb_31(&nal.gb); s->pict_type = ff_h264_golomb_to_pict_type[slice_type % 5]; if (p->sei.recovery_point.recovery_frame_cnt >= 0) { s->key_frame = 1; } pps_id = get_ue_golomb(&nal.gb); if (pps_id >= MAX_PPS_COUNT) { av_log(avctx, AV_LOG_ERROR, "pps_id %u out of range\n", pps_id); goto fail; } if (!p->ps.pps_list[pps_id]) { av_log(avctx, AV_LOG_ERROR, "non-existing PPS %u referenced\n", pps_id); goto fail; } p->ps.pps = (const PPS*)p->ps.pps_list[pps_id]->data; if (!p->ps.sps_list[p->ps.pps->sps_id]) { av_log(avctx, AV_LOG_ERROR, "non-existing SPS %u referenced\n", p->ps.pps->sps_id); goto fail; } p->ps.sps = (SPS*)p->ps.sps_list[p->ps.pps->sps_id]->data; sps = p->ps.sps; p->poc.frame_num = get_bits(&nal.gb, sps->log2_max_frame_num); s->coded_width = 16 * sps->mb_width; s->coded_height = 16 * sps->mb_height; s->width = s->coded_width - (sps->crop_right + sps->crop_left); s->height = s->coded_height - (sps->crop_top + sps->crop_bottom); if (s->width <= 0 || s->height <= 0) { s->width = s->coded_width; s->height = s->coded_height; } switch (sps->bit_depth_luma) { case 9: if (sps->chroma_format_idc == 3) s->format = AV_PIX_FMT_YUV444P9; else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P9; else s->format = AV_PIX_FMT_YUV420P9; break; case 10: if (sps->chroma_format_idc == 3) s->format = AV_PIX_FMT_YUV444P10; else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P10; else s->format = AV_PIX_FMT_YUV420P10; break; case 8: if (sps->chroma_format_idc == 3) s->format = AV_PIX_FMT_YUV444P; else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P; else s->format = AV_PIX_FMT_YUV420P; break; default: s->format = AV_PIX_FMT_NONE; } avctx->profile = ff_h264_get_profile(sps); avctx->level = sps->level_idc; if (sps->frame_mbs_only_flag) { p->picture_structure = PICT_FRAME; } else { if (get_bits1(&nal.gb)) { p->picture_structure = PICT_TOP_FIELD + get_bits1(&nal.gb); } else { p->picture_structure = PICT_FRAME; } } if (nal.type == H264_NAL_IDR_SLICE) get_ue_golomb(&nal.gb); if (sps->poc_type == 0) { p->poc.poc_lsb = get_bits(&nal.gb, sps->log2_max_poc_lsb); if (p->ps.pps->pic_order_present == 1 && p->picture_structure == PICT_FRAME) p->poc.delta_poc_bottom = get_se_golomb(&nal.gb); } if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) { p->poc.delta_poc[0] = get_se_golomb(&nal.gb); if (p->ps.pps->pic_order_present == 1 && p->picture_structure == PICT_FRAME) p->poc.delta_poc[1] = get_se_golomb(&nal.gb); } field_poc[0] = field_poc[1] = INT_MAX; ff_h264_init_poc(field_poc, &s->output_picture_number, sps, &p->poc, p->picture_structure, nal.ref_idc); if (nal.ref_idc && nal.type != H264_NAL_IDR_SLICE) { got_reset = scan_mmco_reset(s, &nal.gb, avctx); if (got_reset < 0) goto fail; } p->poc.prev_frame_num = got_reset ? 0 : p->poc.frame_num; p->poc.prev_frame_num_offset = got_reset ? 0 : p->poc.frame_num_offset; if (nal.ref_idc != 0) { if (!got_reset) { p->poc.prev_poc_msb = p->poc.poc_msb; p->poc.prev_poc_lsb = p->poc.poc_lsb; } else { p->poc.prev_poc_msb = 0; p->poc.prev_poc_lsb = p->picture_structure == PICT_BOTTOM_FIELD ? 0 : field_poc[0]; } } if (sps->pic_struct_present_flag) { switch (p->sei.picture_timing.pic_struct) { case SEI_PIC_STRUCT_TOP_FIELD: case SEI_PIC_STRUCT_BOTTOM_FIELD: s->repeat_pict = 0; break; case SEI_PIC_STRUCT_FRAME: case SEI_PIC_STRUCT_TOP_BOTTOM: case SEI_PIC_STRUCT_BOTTOM_TOP: s->repeat_pict = 1; break; case SEI_PIC_STRUCT_TOP_BOTTOM_TOP: case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM: s->repeat_pict = 2; break; case SEI_PIC_STRUCT_FRAME_DOUBLING: s->repeat_pict = 3; break; case SEI_PIC_STRUCT_FRAME_TRIPLING: s->repeat_pict = 5; break; default: s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0; break; } } else { s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0; } if (p->picture_structure == PICT_FRAME) { s->picture_structure = AV_PICTURE_STRUCTURE_FRAME; if (sps->pic_struct_present_flag) { switch (p->sei.picture_timing.pic_struct) { case SEI_PIC_STRUCT_TOP_BOTTOM: case SEI_PIC_STRUCT_TOP_BOTTOM_TOP: s->field_order = AV_FIELD_TT; break; case SEI_PIC_STRUCT_BOTTOM_TOP: case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM: s->field_order = AV_FIELD_BB; break; default: s->field_order = AV_FIELD_PROGRESSIVE; break; } } else { if (field_poc[0] < field_poc[1]) s->field_order = AV_FIELD_TT; else if (field_poc[0] > field_poc[1]) s->field_order = AV_FIELD_BB; else s->field_order = AV_FIELD_PROGRESSIVE; } } else { if (p->picture_structure == PICT_TOP_FIELD) s->picture_structure = AV_PICTURE_STRUCTURE_TOP_FIELD; else s->picture_structure = AV_PICTURE_STRUCTURE_BOTTOM_FIELD; s->field_order = AV_FIELD_UNKNOWN; } av_freep(&nal.rbsp_buffer); return 0; } buf += consumed; } av_log(avctx, AV_LOG_ERROR, "missing picture in access unit\n"); fail: av_freep(&nal.rbsp_buffer); return -1; }

[[[[Adv]]]]: static inline int parse_nal_units(AVCodecParserContext *s, AVCodecContext *avctx, const uint8_t *buf, int buf_size) { H264ParseContext *p = s->priv_data; const uint8_t *buf_end = buf + buf_size; H2645NAL nal = { NULL }; unsigned int pps_id; unsigned int slice_type; int state = -1, got_reset = 0; int field_poc[2]; int [[reform]]; s->pict_type = AV_PICTURE_TYPE_I; s->key_frame = 0; s->picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN; ff_h264_sei_uninit(&p->sei); if (!buf_size) return 0; for (;;) { const SPS *sps; int src_length, consumed; buf = avpriv_find_start_code(buf, buf_end, &state); if (buf >= buf_end) break; --buf; src_length = buf_end - buf; switch (state & 0x1f) { case H264_NAL_SLICE: case H264_NAL_IDR_SLICE: if ((state & 0x1f) == H264_NAL_IDR_SLICE || ((state >> 5) & 0x3) == 0) { if (src_length > 60) src_length = 60; } else { if (src_length > 1000) src_length = 1000; } break; } consumed = ff_h2645_extract_rbsp(buf, src_length, &nal); if (consumed < 0) break; [[reform]] = init_get_bits(&nal.gb, nal.data, nal.size * 8); if ([[reform]] < 0) goto fail; get_bits1(&nal.gb); nal.ref_idc = get_bits(&nal.gb, 2); nal.type = get_bits(&nal.gb, 5); switch (nal.type) { case H264_NAL_SPS: ff_h264_decode_seq_parameter_set(&nal.gb, avctx, &p->ps); break; case H264_NAL_PPS: ff_h264_decode_picture_parameter_set(&nal.gb, avctx, &p->ps, nal.size_bits); break; case H264_NAL_SEI: ff_h264_sei_decode(&p->sei, &nal.gb, &p->ps, avctx); break; case H264_NAL_IDR_SLICE: s->key_frame = 1; p->poc.prev_frame_num = 0; p->poc.prev_frame_num_offset = 0; p->poc.prev_poc_msb = p->poc.prev_poc_lsb = 0; case H264_NAL_SLICE: get_ue_golomb(&nal.gb); slice_type = get_ue_golomb_31(&nal.gb); s->pict_type = ff_h264_golomb_to_pict_type[slice_type % 5]; if (p->sei.recovery_point.recovery_frame_cnt >= 0) { s->key_frame = 1; } pps_id = get_ue_golomb(&nal.gb); if (pps_id >= MAX_PPS_COUNT) { av_log(avctx, AV_LOG_ERROR, "pps_id %u out of range\n", pps_id); goto fail; } if (!p->ps.pps_list[pps_id]) { av_log(avctx, AV_LOG_ERROR, "non-existing PPS %u referenced\n", pps_id); goto fail; } p->ps.pps = (const PPS*)p->ps.pps_list[pps_id]->data; if (!p->ps.sps_list[p->ps.pps->sps_id]) { av_log(avctx, AV_LOG_ERROR, "non-existing SPS %u referenced\n", p->ps.pps->sps_id); goto fail; } p->ps.sps = (SPS*)p->ps.sps_list[p->ps.pps->sps_id]->data; sps = p->ps.sps; p->poc.frame_num = get_bits(&nal.gb, sps->log2_max_frame_num); s->coded_width = 16 * sps->mb_width; s->coded_height = 16 * sps->mb_height; s->width = s->coded_width - (sps->crop_right + sps->crop_left); s->height = s->coded_height - (sps->crop_top + sps->crop_bottom); if (s->width <= 0 || s->height <= 0) { s->width = s->coded_width; s->height = s->coded_height; } switch (sps->bit_depth_luma) { case 9: if (sps->chroma_format_idc == 3) s->format = AV_PIX_FMT_YUV444P9; else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P9; else s->format = AV_PIX_FMT_YUV420P9; break; case 10: if (sps->chroma_format_idc == 3) s->format = AV_PIX_FMT_YUV444P10; else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P10; else s->format = AV_PIX_FMT_YUV420P10; break; case 8: if (sps->chroma_format_idc == 3) s->format = AV_PIX_FMT_YUV444P; else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P; else s->format = AV_PIX_FMT_YUV420P; break; default: s->format = AV_PIX_FMT_NONE; } avctx->profile = ff_h264_get_profile(sps); avctx->level = sps->level_idc; if (sps->frame_mbs_only_flag) { p->picture_structure = PICT_FRAME; } else { if (get_bits1(&nal.gb)) { p->picture_structure = PICT_TOP_FIELD + get_bits1(&nal.gb); } else { p->picture_structure = PICT_FRAME; } } if (nal.type == H264_NAL_IDR_SLICE) get_ue_golomb(&nal.gb); if (sps->poc_type == 0) { p->poc.poc_lsb = get_bits(&nal.gb, sps->log2_max_poc_lsb); if (p->ps.pps->pic_order_present == 1 && p->picture_structure == PICT_FRAME) p->poc.delta_poc_bottom = get_se_golomb(&nal.gb); } if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) { p->poc.delta_poc[0] = get_se_golomb(&nal.gb); if (p->ps.pps->pic_order_present == 1 && p->picture_structure == PICT_FRAME) p->poc.delta_poc[1] = get_se_golomb(&nal.gb); } field_poc[0] = field_poc[1] = INT_MAX; ff_h264_init_poc(field_poc, &s->output_picture_number, sps, &p->poc, p->picture_structure, nal.ref_idc); if (nal.ref_idc && nal.type != H264_NAL_IDR_SLICE) { got_reset = scan_mmco_reset(s, &nal.gb, avctx); if (got_reset < 0) goto fail; } p->poc.prev_frame_num = got_reset ? 0 : p->poc.frame_num; p->poc.prev_frame_num_offset = got_reset ? 0 : p->poc.frame_num_offset; if (nal.ref_idc != 0) { if (!got_reset) { p->poc.prev_poc_msb = p->poc.poc_msb; p->poc.prev_poc_lsb = p->poc.poc_lsb; } else { p->poc.prev_poc_msb = 0; p->poc.prev_poc_lsb = p->picture_structure == PICT_BOTTOM_FIELD ? 0 : field_poc[0]; } } if (sps->pic_struct_present_flag) { switch (p->sei.picture_timing.pic_struct) { case SEI_PIC_STRUCT_TOP_FIELD: case SEI_PIC_STRUCT_BOTTOM_FIELD: s->repeat_pict = 0; break; case SEI_PIC_STRUCT_FRAME: case SEI_PIC_STRUCT_TOP_BOTTOM: case SEI_PIC_STRUCT_BOTTOM_TOP: s->repeat_pict = 1; break; case SEI_PIC_STRUCT_TOP_BOTTOM_TOP: case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM: s->repeat_pict = 2; break; case SEI_PIC_STRUCT_FRAME_DOUBLING: s->repeat_pict = 3; break; case SEI_PIC_STRUCT_FRAME_TRIPLING: s->repeat_pict = 5; break; default: s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0; break; } } else { s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0; } if (p->picture_structure == PICT_FRAME) { s->picture_structure = AV_PICTURE_STRUCTURE_FRAME; if (sps->pic_struct_present_flag) { switch (p->sei.picture_timing.pic_struct) { case SEI_PIC_STRUCT_TOP_BOTTOM: case SEI_PIC_STRUCT_TOP_BOTTOM_TOP: s->field_order = AV_FIELD_TT; break; case SEI_PIC_STRUCT_BOTTOM_TOP: case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM: s->field_order = AV_FIELD_BB; break; default: s->field_order = AV_FIELD_PROGRESSIVE; break; } } else { if (field_poc[0] < field_poc[1]) s->field_order = AV_FIELD_TT; else if (field_poc[0] > field_poc[1]) s->field_order = AV_FIELD_BB; else s->field_order = AV_FIELD_PROGRESSIVE; } } else { if (p->picture_structure == PICT_TOP_FIELD) s->picture_structure = AV_PICTURE_STRUCTURE_TOP_FIELD; else s->picture_structure = AV_PICTURE_STRUCTURE_BOTTOM_FIELD; s->field_order = AV_FIELD_UNKNOWN; } av_freep(&nal.rbsp_buffer); return 0; } buf += consumed; } av_log(avctx, AV_LOG_ERROR, "missing picture in access unit\n"); fail: av_freep(&nal.rbsp_buffer); return -1; }[Succeeded / Failed / Skipped / Total] 408 / 42 / 264 / 714:  27%|       | 714/2690 [8:06:12<22:25:35, 40.86s/it][Succeeded / Failed / Skipped / Total] 408 / 42 / 264 / 714:  27%|       | 715/2690 [8:06:13<22:23:02, 40.80s/it]
--------------------------------------------- Result 715 ---------------------------------------------
[[0 (17%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_always_inline void FUNC(intra_pred)(HEVCContext *s, int x0, int y0, int log2_size, int c_idx) { #define PU(x) \ ((x) >> s->ps.sps->log2_min_pu_size) #define MVF(x, y) \ (s->ref->tab_mvf[(x) + (y) * min_pu_width]) #define MVF_PU(x, y) \ MVF(PU(x0 + ((x) << hshift)), PU(y0 + ((y) << vshift))) #define IS_INTRA(x, y) \ (MVF_PU(x, y).pred_flag == PF_INTRA) #define MIN_TB_ADDR_ZS(x, y) \ s->ps.pps->min_tb_addr_zs[(y) * (s->ps.sps->tb_mask+2) + (x)] #define EXTEND(ptr, val, len) \ do { \ pixel4 pix = PIXEL_SPLAT_X4(val); \ for (i = 0; i < (len); i += 4) \ AV_WN4P(ptr + i, pix); \ } while (0) #define EXTEND_RIGHT_CIP(ptr, start, length) \ for (i = start; i < (start) + (length); i += 4) \ if (!IS_INTRA(i, -1)) \ AV_WN4P(&ptr[i], a); \ else \ a = PIXEL_SPLAT_X4(ptr[i+3]) #define EXTEND_LEFT_CIP(ptr, start, length) \ for (i = start; i > (start) - (length); i--) \ if (!IS_INTRA(i - 1, -1)) \ ptr[i - 1] = ptr[i] #define EXTEND_UP_CIP(ptr, start, length) \ for (i = (start); i > (start) - (length); i -= 4) \ if (!IS_INTRA(-1, i - 3)) \ AV_WN4P(&ptr[i - 3], a); \ else \ a = PIXEL_SPLAT_X4(ptr[i - 3]) #define EXTEND_DOWN_CIP(ptr, start, length) \ for (i = start; i < (start) + (length); i += 4) \ if (!IS_INTRA(-1, i)) \ AV_WN4P(&ptr[i], a); \ else \ a = PIXEL_SPLAT_X4(ptr[i + 3]) HEVCLocalContext *lc = s->HEVClc; int i; int hshift = s->ps.sps->hshift[c_idx]; int vshift = s->ps.sps->vshift[c_idx]; int size = (1 << log2_size); int size_in_luma_h = size << hshift; int size_in_tbs_h = size_in_luma_h >> s->ps.sps->log2_min_tb_size; int size_in_luma_v = size << vshift; int size_in_tbs_v = size_in_luma_v >> s->ps.sps->log2_min_tb_size; int x = x0 >> hshift; int y = y0 >> vshift; int x_tb = (x0 >> s->ps.sps->log2_min_tb_size) & s->ps.sps->tb_mask; int y_tb = (y0 >> s->ps.sps->log2_min_tb_size) & s->ps.sps->tb_mask; int cur_tb_addr = MIN_TB_ADDR_ZS(x_tb, y_tb); ptrdiff_t stride = s->frame->linesize[c_idx] / sizeof(pixel); pixel *src = (pixel*)s->frame->data[c_idx] + x + y * stride; int min_pu_width = s->ps.sps->min_pu_width; enum IntraPredMode mode = c_idx ? lc->tu.intra_pred_mode_c : lc->tu.intra_pred_mode; pixel4 a; pixel left_array[2 * MAX_TB_SIZE + 1]; pixel filtered_left_array[2 * MAX_TB_SIZE + 1]; pixel top_array[2 * MAX_TB_SIZE + 1]; pixel filtered_top_array[2 * MAX_TB_SIZE + 1]; pixel *left = left_array + 1; pixel *top = top_array + 1; pixel *filtered_left = filtered_left_array + 1; pixel *filtered_top = filtered_top_array + 1; int cand_bottom_left = lc->na.cand_bottom_left && cur_tb_addr > MIN_TB_ADDR_ZS( x_tb - 1, (y_tb + size_in_tbs_v) & s->ps.sps->tb_mask); int cand_left = lc->na.cand_left; int cand_up_left = lc->na.cand_up_left; int cand_up = lc->na.cand_up; int cand_up_right = lc->na.cand_up_right && cur_tb_addr > MIN_TB_ADDR_ZS((x_tb + size_in_tbs_h) & s->ps.sps->tb_mask, y_tb - 1); int bottom_left_size = (FFMIN(y0 + 2 * size_in_luma_v, s->ps.sps->height) - (y0 + size_in_luma_v)) >> vshift; int top_right_size = (FFMIN(x0 + 2 * size_in_luma_h, s->ps.sps->width) - (x0 + size_in_luma_h)) >> hshift; if (s->ps.pps->constrained_intra_pred_flag == 1) { int size_in_luma_pu_v = PU(size_in_luma_v); int size_in_luma_pu_h = PU(size_in_luma_h); int on_pu_edge_x = !av_mod_uintp2(x0, s->ps.sps->log2_min_pu_size); int on_pu_edge_y = !av_mod_uintp2(y0, s->ps.sps->log2_min_pu_size); if (!size_in_luma_pu_h) size_in_luma_pu_h++; if (cand_bottom_left == 1 && on_pu_edge_x) { int x_left_pu = PU(x0 - 1); int y_bottom_pu = PU(y0 + size_in_luma_v); int max = FFMIN(size_in_luma_pu_v, s->ps.sps->min_pu_height - y_bottom_pu); cand_bottom_left = 0; for (i = 0; i < max; i += 2) cand_bottom_left |= (MVF(x_left_pu, y_bottom_pu + i).pred_flag == PF_INTRA); } if (cand_left == 1 && on_pu_edge_x) { int x_left_pu = PU(x0 - 1); int y_left_pu = PU(y0); int max = FFMIN(size_in_luma_pu_v, s->ps.sps->min_pu_height - y_left_pu); cand_left = 0; for (i = 0; i < max; i += 2) cand_left |= (MVF(x_left_pu, y_left_pu + i).pred_flag == PF_INTRA); } if (cand_up_left == 1) { int x_left_pu = PU(x0 - 1); int y_top_pu = PU(y0 - 1); cand_up_left = MVF(x_left_pu, y_top_pu).pred_flag == PF_INTRA; } if (cand_up == 1 && on_pu_edge_y) { int x_top_pu = PU(x0); int y_top_pu = PU(y0 - 1); int max = FFMIN(size_in_luma_pu_h, s->ps.sps->min_pu_width - x_top_pu); cand_up = 0; for (i = 0; i < max; i += 2) cand_up |= (MVF(x_top_pu + i, y_top_pu).pred_flag == PF_INTRA); } if (cand_up_right == 1 && on_pu_edge_y) { int y_top_pu = PU(y0 - 1); int x_right_pu = PU(x0 + size_in_luma_h); int max = FFMIN(size_in_luma_pu_h, s->ps.sps->min_pu_width - x_right_pu); cand_up_right = 0; for (i = 0; i < max; i += 2) cand_up_right |= (MVF(x_right_pu + i, y_top_pu).pred_flag == PF_INTRA); } memset(left, 128, 2 * MAX_TB_SIZE*sizeof(pixel)); memset(top , 128, 2 * MAX_TB_SIZE*sizeof(pixel)); top[-1] = 128; } if (cand_up_left) { left[-1] = POS(-1, -1); top[-1] = left[-1]; } if (cand_up) memcpy(top, src - stride, size * sizeof(pixel)); if (cand_up_right) { memcpy(top + size, src - stride + size, size * sizeof(pixel)); EXTEND(top + size + top_right_size, POS(size + top_right_size - 1, -1), size - top_right_size); } if (cand_left) for (i = 0; i < size; i++) left[i] = POS(-1, i); if (cand_bottom_left) { for (i = size; i < size + bottom_left_size; i++) left[i] = POS(-1, i); EXTEND(left + size + bottom_left_size, POS(-1, size + bottom_left_size - 1), size - bottom_left_size); } if (s->ps.pps->constrained_intra_pred_flag == 1) { if (cand_bottom_left || cand_left || cand_up_left || cand_up || cand_up_right) { int size_max_x = x0 + ((2 * size) << hshift) < s->ps.sps->width ? 2 * size : (s->ps.sps->width - x0) >> hshift; int size_max_y = y0 + ((2 * size) << vshift) < s->ps.sps->height ? 2 * size : (s->ps.sps->height - y0) >> vshift; int j = size + (cand_bottom_left? bottom_left_size: 0) -1; if (!cand_up_right) { size_max_x = x0 + ((size) << hshift) < s->ps.sps->width ? size : (s->ps.sps->width - x0) >> hshift; } if (!cand_bottom_left) { size_max_y = y0 + (( size) << vshift) < s->ps.sps->height ? size : (s->ps.sps->height - y0) >> vshift; } if (cand_bottom_left || cand_left || cand_up_left) { while (j > -1 && !IS_INTRA(-1, j)) j--; if (!IS_INTRA(-1, j)) { j = 0; while (j < size_max_x && !IS_INTRA(j, -1)) j++; EXTEND_LEFT_CIP(top, j, j + 1); left[-1] = top[-1]; } } else { j = 0; while (j < size_max_x && !IS_INTRA(j, -1)) j++; if (j > 0) if (x0 > 0) { EXTEND_LEFT_CIP(top, j, j + 1); } else { EXTEND_LEFT_CIP(top, j, j); top[-1] = top[0]; } left[-1] = top[-1]; } left[-1] = top[-1]; if (cand_bottom_left || cand_left) { a = PIXEL_SPLAT_X4(left[-1]); EXTEND_DOWN_CIP(left, 0, size_max_y); } if (!cand_left) EXTEND(left, left[-1], size); if (!cand_bottom_left) EXTEND(left + size, left[size - 1], size); if (x0 != 0 && y0 != 0) { a = PIXEL_SPLAT_X4(left[size_max_y - 1]); EXTEND_UP_CIP(left, size_max_y - 1, size_max_y); if (!IS_INTRA(-1, - 1)) left[-1] = left[0]; } else if (x0 == 0) { EXTEND(left, 0, size_max_y); } else { a = PIXEL_SPLAT_X4(left[size_max_y - 1]); EXTEND_UP_CIP(left, size_max_y - 1, size_max_y); } top[-1] = left[-1]; if (y0 != 0) { a = PIXEL_SPLAT_X4(left[-1]); EXTEND_RIGHT_CIP(top, 0, size_max_x); } } } if (!cand_bottom_left) { if (cand_left) { EXTEND(left + size, left[size - 1], size); } else if (cand_up_left) { EXTEND(left, left[-1], 2 * size); cand_left = 1; } else if (cand_up) { left[-1] = top[0]; EXTEND(left, left[-1], 2 * size); cand_up_left = 1; cand_left = 1; } else if (cand_up_right) { EXTEND(top, top[size], size); left[-1] = top[size]; EXTEND(left, left[-1], 2 * size); cand_up = 1; cand_up_left = 1; cand_left = 1; } else { left[-1] = (1 << (BIT_DEPTH - 1)); EXTEND(top, left[-1], 2 * size); EXTEND(left, left[-1], 2 * size); } } if (!cand_left) EXTEND(left, left[size], size); if (!cand_up_left) { left[-1] = left[0]; } if (!cand_up) EXTEND(top, left[-1], size); if (!cand_up_right) EXTEND(top + size, top[size - 1], size); top[-1] = left[-1]; if (!s->ps.sps->intra_smoothing_disabled_flag && (c_idx == 0 || s->ps.sps->chroma_format_idc == 3)) { if (mode != INTRA_DC && size != 4){ int intra_hor_ver_dist_thresh[] = { 7, 1, 0 }; int min_dist_vert_hor = FFMIN(FFABS((int)(mode - 26U)), FFABS((int)(mode - 10U))); if (min_dist_vert_hor > intra_hor_ver_dist_thresh[log2_size - 3]) { int threshold = 1 << (BIT_DEPTH - 5); if (s->ps.sps->sps_strong_intra_smoothing_enable_flag && c_idx == 0 && log2_size == 5 && FFABS(top[-1] + top[63] - 2 * top[31]) < threshold && FFABS(left[-1] + left[63] - 2 * left[31]) < threshold) { filtered_top[-1] = top[-1]; filtered_top[63] = top[63]; for (i = 0; i < 63; i++) filtered_top[i] = ((64 - (i + 1)) * top[-1] + (i + 1) * top[63] + 32) >> 6; for (i = 0; i < 63; i++) left[i] = ((64 - (i + 1)) * left[-1] + (i + 1) * left[63] + 32) >> 6; top = filtered_top; } else { filtered_left[2 * size - 1] = left[2 * size - 1]; filtered_top[2 * size - 1] = top[2 * size - 1]; for (i = 2 * size - 2; i >= 0; i--) filtered_left[i] = (left[i + 1] + 2 * left[i] + left[i - 1] + 2) >> 2; filtered_top[-1] = filtered_left[-1] = (left[0] + 2 * left[-1] + top[0] + 2) >> 2; for (i = 2 * size - 2; i >= 0; i--) filtered_top[i] = (top[i + 1] + 2 * top[i] + top[i - 1] + 2) >> 2; left = filtered_left; top = filtered_top; } } } } switch (mode) { case INTRA_PLANAR: s->hpc.pred_planar[log2_size - 2]((uint8_t *)src, (uint8_t *)top, (uint8_t *)left, stride); break; case INTRA_DC: s->hpc.pred_dc((uint8_t *)src, (uint8_t *)top, (uint8_t *)left, stride, log2_size, c_idx); break; default: s->hpc.pred_angular[log2_size - 2]((uint8_t *)src, (uint8_t *)top, (uint8_t *)left, stride, c_idx, mode); break; } }[Succeeded / Failed / Skipped / Total] 408 / 42 / 265 / 715:  27%|       | 715/2690 [8:06:13<22:23:02, 40.80s/it][Succeeded / Failed / Skipped / Total] 408 / 42 / 265 / 715:  27%|       | 716/2690 [8:06:18<22:20:45, 40.75s/it][Succeeded / Failed / Skipped / Total] 409 / 42 / 265 / 716:  27%|       | 716/2690 [8:06:18<22:20:45, 40.75s/it][Succeeded / Failed / Skipped / Total] 409 / 42 / 265 / 716:  27%|       | 717/2690 [8:06:30<22:18:45, 40.71s/it][Succeeded / Failed / Skipped / Total] 410 / 42 / 265 / 717:  27%|       | 717/2690 [8:06:30<22:18:45, 40.71s/it][Succeeded / Failed / Skipped / Total] 410 / 42 / 265 / 717:  27%|       | 718/2690 [8:07:19<22:18:27, 40.72s/it][Succeeded / Failed / Skipped / Total] 411 / 42 / 265 / 718:  27%|       | 718/2690 [8:07:19<22:18:27, 40.72s/it][Succeeded / Failed / Skipped / Total] 411 / 42 / 265 / 718:  27%|       | 719/2690 [8:07:20<22:15:56, 40.67s/it][Succeeded / Failed / Skipped / Total] 411 / 42 / 266 / 719:  27%|       | 719/2690 [8:07:20<22:15:56, 40.67s/it][Succeeded / Failed / Skipped / Total] 411 / 42 / 266 / 719:  27%|       | 720/2690 [8:07:29<22:13:49, 40.62s/it][Succeeded / Failed / Skipped / Total] 412 / 42 / 266 / 720:  27%|       | 720/2690 [8:07:29<22:13:49, 40.62s/it][Succeeded / Failed / Skipped / Total] 412 / 42 / 266 / 720:  27%|       | 721/2690 [8:07:29<22:11:19, 40.57s/it][Succeeded / Failed / Skipped / Total] 412 / 42 / 267 / 721:  27%|       | 721/2690 [8:07:29<22:11:19, 40.57s/it][Succeeded / Failed / Skipped / Total] 412 / 42 / 267 / 721:  27%|       | 722/2690 [8:08:11<22:10:40, 40.57s/it]
--------------------------------------------- Result 716 ---------------------------------------------
[[0 (43%)]] --> [[0 (59%)]] --> Socre: 0.5941529870033264

[[[[Adv]]]]: static void end_last_frame(AVFilterContext *ctx) { TileContext *tile = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; AVFilterBufferRef *[[out_buf]] = outlink->out_buf; outlink->out_buf = NULL; ff_start_frame(outlink, [[out_buf]]); while (tile->current < tile->nb_frames) draw_blank_frame(ctx, [[out_buf]]); ff_draw_slice(outlink, 0, [[out_buf]]->video->h, 1); ff_end_frame(outlink); tile->current = 0; }

[[[[Adv]]]]: static void end_last_frame(AVFilterContext *ctx) { TileContext *tile = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; AVFilterBufferRef *[[obscura]] = outlink->out_buf; outlink->out_buf = NULL; ff_start_frame(outlink, [[obscura]]); while (tile->current < tile->nb_frames) draw_blank_frame(ctx, [[obscura]]); ff_draw_slice(outlink, 0, [[obscura]]->video->h, 1); ff_end_frame(outlink); tile->current = 0; }
--------------------------------------------- Result 717 ---------------------------------------------
[[0 (19%)]] --> [[0 (54%)]] --> Socre: 0.5413292050361633

[[[[Adv]]]]: void av_register_output_format(AVOutputFormat *[[format]]) { AVOutputFormat **p = &first_oformat; while (*p != NULL) p = &(*p)->next; *p = [[format]]; [[format]]->next = NULL; }

[[[[Adv]]]]: void av_register_output_format(AVOutputFormat *[[modeling]]) { AVOutputFormat **p = &first_oformat; while (*p != NULL) p = &(*p)->next; *p = [[modeling]]; [[modeling]]->next = NULL; }
--------------------------------------------- Result 718 ---------------------------------------------
[[0 (86%)]] --> [[0 (49%)]] --> Socre: 0.5086190402507782

[[[[Adv]]]]: static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *[[src2]], int width) { #if defined (HAVE_MMX2) || defined (HAVE_3DNOW) asm volatile( "movq "MANGLE(bm01010101)", %%mm4\n\t" "mov %0, %%"REG_a" \n\t" "1: \n\t" "movq (%1, %%"REG_a",4), %%mm0 \n\t" "movq 8(%1, %%"REG_a",4), %%mm1 \n\t" "movq (%2, %%"REG_a",4), %%mm2 \n\t" "movq 8(%2, %%"REG_a",4), %%mm3 \n\t" PAVGB(%%mm2, %%mm0) PAVGB(%%mm3, %%mm1) "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "packuswb %%mm1, %%mm0 \n\t" "movq %%mm0, %%mm1 \n\t" "psrlw $8, %%mm0 \n\t" "pand %%mm4, %%mm1 \n\t" "packuswb %%mm0, %%mm0 \n\t" "packuswb %%mm1, %%mm1 \n\t" "movd %%mm0, (%4, %%"REG_a") \n\t" "movd %%mm1, (%3, %%"REG_a") \n\t" "add $4, %%"REG_a" \n\t" " js 1b \n\t" : : "g" ((long)-width), "r" (src1+width*4), "r" ([[src2]]+width*4), "r" (dstU+width), "r" (dstV+width) : "%"REG_a ); #else int i; for(i=0; i<width; i++) { dstU[i]= (src1[4*i + 1] + [[src2]][4*i + 1])>>1; dstV[i]= (src1[4*i + 3] + [[src2]][4*i + 3])>>1; } #endif }

[[[[Adv]]]]: static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *[[splintering]], int width) { #if defined (HAVE_MMX2) || defined (HAVE_3DNOW) asm volatile( "movq "MANGLE(bm01010101)", %%mm4\n\t" "mov %0, %%"REG_a" \n\t" "1: \n\t" "movq (%1, %%"REG_a",4), %%mm0 \n\t" "movq 8(%1, %%"REG_a",4), %%mm1 \n\t" "movq (%2, %%"REG_a",4), %%mm2 \n\t" "movq 8(%2, %%"REG_a",4), %%mm3 \n\t" PAVGB(%%mm2, %%mm0) PAVGB(%%mm3, %%mm1) "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "packuswb %%mm1, %%mm0 \n\t" "movq %%mm0, %%mm1 \n\t" "psrlw $8, %%mm0 \n\t" "pand %%mm4, %%mm1 \n\t" "packuswb %%mm0, %%mm0 \n\t" "packuswb %%mm1, %%mm1 \n\t" "movd %%mm0, (%4, %%"REG_a") \n\t" "movd %%mm1, (%3, %%"REG_a") \n\t" "add $4, %%"REG_a" \n\t" " js 1b \n\t" : : "g" ((long)-width), "r" (src1+width*4), "r" ([[splintering]]+width*4), "r" (dstU+width), "r" (dstV+width) : "%"REG_a ); #else int i; for(i=0; i<width; i++) { dstU[i]= (src1[4*i + 1] + [[splintering]][4*i + 1])>>1; dstV[i]= (src1[4*i + 3] + [[splintering]][4*i + 3])>>1; } #endif }
--------------------------------------------- Result 719 ---------------------------------------------
[[0 (79%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame, int perms) { AVFilterBufferRef *picref = avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms, frame->width, frame->height, frame->format); if (!picref) return NULL; avfilter_copy_frame_props(picref, frame); return picref; }
--------------------------------------------- Result 720 ---------------------------------------------
[[0 (83%)]] --> [[0 (34%)]] --> Socre: 0.6573566794395447

[[[[Adv]]]]: void *g_realloc(void *[[ptr]], size_t size) { size_t old_size, copy; void *new_ptr; if (![[ptr]]) return g_malloc(size); old_size = *(size_t *)((char *)[[ptr]] - 16); copy = old_size < size ? old_size : size; new_ptr = g_malloc(size); memcpy(new_ptr, [[ptr]], copy); g_free([[ptr]]); return new_ptr; }

[[[[Adv]]]]: void *g_realloc(void *[[driveling]], size_t size) { size_t old_size, copy; void *new_ptr; if (![[driveling]]) return g_malloc(size); old_size = *(size_t *)((char *)[[driveling]] - 16); copy = old_size < size ? old_size : size; new_ptr = g_malloc(size); memcpy(new_ptr, [[driveling]], copy); g_free([[driveling]]); return new_ptr; }
--------------------------------------------- Result 721 ---------------------------------------------
[[0 (16%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc) { AVStream *st; OutputStream *ost; AVCodecContext *audio_enc; ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO); st = ost->st; audio_enc = st->codec; audio_enc->codec_type = AVMEDIA_TYPE_AUDIO; if (!ost->stream_copy) { char *sample_fmt = NULL; MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st); MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st); if (sample_fmt && (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) { av_log(NULL, AV_LOG_FATAL, "Invalid sample format '%s'\n", sample_fmt); exit_program(1); } MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st); } return ost; }
--------------------------------------------- Result 722 ---------------------------------------------
[[0 (96%)]] --> [[0 (49%)]] --> Socre: 0.5139960050582886

[[[[Adv]]]]: static void decode_32Bit_opc(CPUTriCoreState *[[env]], DisasContext *ctx) { int op1; int32_t r1, r2, r3; int32_t address, const16; int8_t b, const4; int32_t bpos; TCGv [[temp]], temp2, temp3; op1 = MASK_OP_MAJOR(ctx->opcode); if (unlikely((op1 & 0x7f) == OPCM_32_BRN_JTT)) { op1 = OPCM_32_BRN_JTT; } switch (op1) { case OPCM_32_ABS_LDW: decode_abs_ldw([[env]], ctx); case OPCM_32_ABS_LDB: decode_abs_ldb([[env]], ctx); case OPCM_32_ABS_LDMST_SWAP: decode_abs_ldst_swap([[env]], ctx); case OPCM_32_ABS_LDST_CONTEXT: decode_abs_ldst_context([[env]], ctx); case OPCM_32_ABS_STORE: decode_abs_store([[env]], ctx); case OPCM_32_ABS_STOREB_H: decode_abs_storeb_h([[env]], ctx); case OPC1_32_ABS_STOREQ: address = MASK_OP_ABS_OFF18(ctx->opcode); r1 = MASK_OP_ABS_S1D(ctx->opcode); [[temp]] = tcg_const_i32(EA_ABS_FORMAT(address)); temp2 = tcg_temp_new(); tcg_gen_shri_tl(temp2, cpu_gpr_d[r1], 16); tcg_gen_qemu_st_tl(temp2, [[temp]], ctx->mem_idx, MO_LEUW); tcg_temp_free(temp2); tcg_temp_free([[temp]]); case OPC1_32_ABS_LD_Q: address = MASK_OP_ABS_OFF18(ctx->opcode); r1 = MASK_OP_ABS_S1D(ctx->opcode); [[temp]] = tcg_const_i32(EA_ABS_FORMAT(address)); tcg_gen_qemu_ld_tl(cpu_gpr_d[r1], [[temp]], ctx->mem_idx, MO_LEUW); tcg_gen_shli_tl(cpu_gpr_d[r1], cpu_gpr_d[r1], 16); tcg_temp_free([[temp]]); case OPC1_32_ABS_LEA: address = MASK_OP_ABS_OFF18(ctx->opcode); r1 = MASK_OP_ABS_S1D(ctx->opcode); tcg_gen_movi_tl(cpu_gpr_a[r1], EA_ABS_FORMAT(address)); case OPC1_32_ABSB_ST_T: address = MASK_OP_ABS_OFF18(ctx->opcode); b = MASK_OP_ABSB_B(ctx->opcode); bpos = MASK_OP_ABSB_BPOS(ctx->opcode); [[temp]] = tcg_const_i32(EA_ABS_FORMAT(address)); temp2 = tcg_temp_new(); tcg_gen_qemu_ld_tl(temp2, [[temp]], ctx->mem_idx, MO_UB); tcg_gen_andi_tl(temp2, temp2, ~(0x1u << bpos)); tcg_gen_ori_tl(temp2, temp2, (b << bpos)); tcg_gen_qemu_st_tl(temp2, [[temp]], ctx->mem_idx, MO_UB); tcg_temp_free([[temp]]); tcg_temp_free(temp2); case OPC1_32_B_CALL: case OPC1_32_B_CALLA: case OPC1_32_B_J: case OPC1_32_B_JA: case OPC1_32_B_JL: case OPC1_32_B_JLA: address = MASK_OP_B_DISP24(ctx->opcode); gen_compute_branch(ctx, op1, 0, 0, 0, address); case OPCM_32_BIT_ANDACC: decode_bit_andacc([[env]], ctx); case OPCM_32_BIT_LOGICAL_T1: decode_bit_logical_t([[env]], ctx); case OPCM_32_BIT_INSERT: decode_bit_insert([[env]], ctx); case OPCM_32_BIT_LOGICAL_T2: decode_bit_logical_t2([[env]], ctx); case OPCM_32_BIT_ORAND: decode_bit_orand([[env]], ctx); case OPCM_32_BIT_SH_LOGIC1: decode_bit_sh_logic1([[env]], ctx); case OPCM_32_BIT_SH_LOGIC2: decode_bit_sh_logic2([[env]], ctx); case OPCM_32_BO_ADDRMODE_POST_PRE_BASE: decode_bo_addrmode_post_pre_base([[env]], ctx); case OPCM_32_BO_ADDRMODE_BITREVERSE_CIRCULAR: decode_bo_addrmode_bitreverse_circular([[env]], ctx); case OPCM_32_BO_ADDRMODE_LD_POST_PRE_BASE: decode_bo_addrmode_ld_post_pre_base([[env]], ctx); case OPCM_32_BO_ADDRMODE_LD_BITREVERSE_CIRCULAR: decode_bo_addrmode_ld_bitreverse_circular([[env]], ctx); case OPCM_32_BO_ADDRMODE_STCTX_POST_PRE_BASE: decode_bo_addrmode_stctx_post_pre_base([[env]], ctx); case OPCM_32_BO_ADDRMODE_LDMST_BITREVERSE_CIRCULAR: decode_bo_addrmode_ldmst_bitreverse_circular([[env]], ctx); case OPC1_32_BOL_LD_A_LONGOFF: case OPC1_32_BOL_LD_W_LONGOFF: case OPC1_32_BOL_LEA_LONGOFF: case OPC1_32_BOL_ST_W_LONGOFF: case OPC1_32_BOL_ST_A_LONGOFF: decode_bol_opc([[env]], ctx, op1); case OPCM_32_BRC_EQ_NEQ: case OPCM_32_BRC_GE: case OPCM_32_BRC_JLT: case OPCM_32_BRC_JNE: const4 = MASK_OP_BRC_CONST4_SEXT(ctx->opcode); address = MASK_OP_BRC_DISP15_SEXT(ctx->opcode); r1 = MASK_OP_BRC_S1(ctx->opcode); gen_compute_branch(ctx, op1, r1, 0, const4, address); case OPCM_32_BRN_JTT: address = MASK_OP_BRN_DISP15_SEXT(ctx->opcode); r1 = MASK_OP_BRN_S1(ctx->opcode); gen_compute_branch(ctx, op1, r1, 0, 0, address); case OPCM_32_BRR_EQ_NEQ: case OPCM_32_BRR_ADDR_EQ_NEQ: case OPCM_32_BRR_GE: case OPCM_32_BRR_JLT: case OPCM_32_BRR_JNE: case OPCM_32_BRR_JNZ: case OPCM_32_BRR_LOOP: address = MASK_OP_BRR_DISP15_SEXT(ctx->opcode); r2 = MASK_OP_BRR_S2(ctx->opcode); r1 = MASK_OP_BRR_S1(ctx->opcode); gen_compute_branch(ctx, op1, r1, r2, 0, address); case OPCM_32_RC_LOGICAL_SHIFT: decode_rc_logical_shift([[env]], ctx); case OPCM_32_RC_ACCUMULATOR: decode_rc_accumulator([[env]], ctx); case OPCM_32_RC_SERVICEROUTINE: decode_rc_serviceroutine([[env]], ctx); case OPCM_32_RC_MUL: decode_rc_mul([[env]], ctx); case OPCM_32_RCPW_MASK_INSERT: decode_rcpw_insert([[env]], ctx); case OPC1_32_RCRR_INSERT: r1 = MASK_OP_RCRR_S1(ctx->opcode); r2 = MASK_OP_RCRR_S3(ctx->opcode); r3 = MASK_OP_RCRR_D(ctx->opcode); const16 = MASK_OP_RCRR_CONST4(ctx->opcode); [[temp]] = tcg_const_i32(const16); temp2 = tcg_temp_new(); temp3 = tcg_temp_new(); tcg_gen_andi_tl(temp2, cpu_gpr_d[r3+1], 0x1f); tcg_gen_andi_tl(temp3, cpu_gpr_d[r3], 0x1f); gen_insert(cpu_gpr_d[r2], cpu_gpr_d[r1], [[temp]], temp2, temp3); tcg_temp_free([[temp]]); tcg_temp_free(temp2); tcg_temp_free(temp3); case OPCM_32_RCRW_MASK_INSERT: decode_rcrw_insert([[env]], ctx); case OPCM_32_RCR_COND_SELECT: decode_rcr_cond_select([[env]], ctx); case OPCM_32_RCR_MADD: decode_rcr_madd([[env]], ctx); case OPCM_32_RCR_MSUB: decode_rcr_msub([[env]], ctx); case OPC1_32_RLC_ADDI: case OPC1_32_RLC_ADDIH: case OPC1_32_RLC_ADDIH_A: case OPC1_32_RLC_MFCR: case OPC1_32_RLC_MOV: case OPC1_32_RLC_MOV_64: case OPC1_32_RLC_MOV_U: case OPC1_32_RLC_MOV_H: case OPC1_32_RLC_MOVH_A: case OPC1_32_RLC_MTCR: decode_rlc_opc([[env]], ctx, op1); } }

[[[[Adv]]]]: static void decode_32Bit_opc(CPUTriCoreState *[[bovs]], DisasContext *ctx) { int op1; int32_t r1, r2, r3; int32_t address, const16; int8_t b, const4; int32_t bpos; TCGv [[temporal]], temp2, temp3; op1 = MASK_OP_MAJOR(ctx->opcode); if (unlikely((op1 & 0x7f) == OPCM_32_BRN_JTT)) { op1 = OPCM_32_BRN_JTT; } switch (op1) { case OPCM_32_ABS_LDW: decode_abs_ldw([[bovs]], ctx); case OPCM_32_ABS_LDB: decode_abs_ldb([[bovs]], ctx); case OPCM_32_ABS_LDMST_SWAP: decode_abs_ldst_swap([[bovs]], ctx); case OPCM_32_ABS_LDST_CONTEXT: decode_abs_ldst_context([[bovs]], ctx); case OPCM_32_ABS_STORE: decode_abs_store([[bovs]], ctx); case OPCM_32_ABS_STOREB_H: decode_abs_storeb_h([[bovs]], ctx); case OPC1_32_ABS_STOREQ: address = MASK_OP_ABS_OFF18(ctx->opcode); r1 = MASK_OP_ABS_S1D(ctx->opcode); [[temporal]] = tcg_const_i32(EA_ABS_FORMAT(address)); temp2 = tcg_temp_new(); tcg_gen_shri_tl(temp2, cpu_gpr_d[r1], 16); tcg_gen_qemu_st_tl(temp2, [[temporal]], ctx->mem_idx, MO_LEUW); tcg_temp_free(temp2); tcg_temp_free([[temporal]]); case OPC1_32_ABS_LD_Q: address = MASK_OP_ABS_OFF18(ctx->opcode); r1 = MASK_OP_ABS_S1D(ctx->opcode); [[temporal]] = tcg_const_i32(EA_ABS_FORMAT(address)); tcg_gen_qemu_ld_tl(cpu_gpr_d[r1], [[temporal]], ctx->mem_idx, MO_LEUW); tcg_gen_shli_tl(cpu_gpr_d[r1], cpu_gpr_d[r1], 16); tcg_temp_free([[temporal]]); case OPC1_32_ABS_LEA: address = MASK_OP_ABS_OFF18(ctx->opcode); r1 = MASK_OP_ABS_S1D(ctx->opcode); tcg_gen_movi_tl(cpu_gpr_a[r1], EA_ABS_FORMAT(address)); case OPC1_32_ABSB_ST_T: address = MASK_OP_ABS_OFF18(ctx->opcode); b = MASK_OP_ABSB_B(ctx->opcode); bpos = MASK_OP_ABSB_BPOS(ctx->opcode); [[temporal]] = tcg_const_i32(EA_ABS_FORMAT(address)); temp2 = tcg_temp_new(); tcg_gen_qemu_ld_tl(temp2, [[temporal]], ctx->mem_idx, MO_UB); tcg_gen_andi_tl(temp2, temp2, ~(0x1u << bpos)); tcg_gen_ori_tl(temp2, temp2, (b << bpos)); tcg_gen_qemu_st_tl(temp2, [[temporal]], ctx->mem_idx, MO_UB); tcg_temp_free([[temporal]]); tcg_temp_free(temp2); case OPC1_32_B_CALL: case OPC1_32_B_CALLA: case OPC1_32_B_J: case OPC1_32_B_JA: case OPC1_32_B_JL: case OPC1_32_B_JLA: address = MASK_OP_B_DISP24(ctx->opcode); gen_compute_branch(ctx, op1, 0, 0, 0, address); case OPCM_32_BIT_ANDACC: decode_bit_andacc([[bovs]], ctx); case OPCM_32_BIT_LOGICAL_T1: decode_bit_logical_t([[bovs]], ctx); case OPCM_32_BIT_INSERT: decode_bit_insert([[bovs]], ctx); case OPCM_32_BIT_LOGICAL_T2: decode_bit_logical_t2([[bovs]], ctx); case OPCM_32_BIT_ORAND: decode_bit_orand([[bovs]], ctx); case OPCM_32_BIT_SH_LOGIC1: decode_bit_sh_logic1([[bovs]], ctx); case OPCM_32_BIT_SH_LOGIC2: decode_bit_sh_logic2([[bovs]], ctx); case OPCM_32_BO_ADDRMODE_POST_PRE_BASE: decode_bo_addrmode_post_pre_base([[bovs]], ctx); case OPCM_32_BO_ADDRMODE_BITREVERSE_CIRCULAR: decode_bo_addrmode_bitreverse_circular([[bovs]], ctx); case OPCM_32_BO_ADDRMODE_LD_POST_PRE_BASE: decode_bo_addrmode_ld_post_pre_base([[bovs]], ctx); case OPCM_32_BO_ADDRMODE_LD_BITREVERSE_CIRCULAR: decode_bo_addrmode_ld_bitreverse_circular([[bovs]], ctx); case OPCM_32_BO_ADDRMODE_STCTX_POST_PRE_BASE: decode_bo_addrmode_stctx_post_pre_base([[bovs]], ctx); case OPCM_32_BO_ADDRMODE_LDMST_BITREVERSE_CIRCULAR: decode_bo_addrmode_ldmst_bitreverse_circular([[bovs]], ctx); case OPC1_32_BOL_LD_A_LONGOFF: case OPC1_32_BOL_LD_W_LONGOFF: case OPC1_32_BOL_LEA_LONGOFF: case OPC1_32_BOL_ST_W_LONGOFF: case OPC1_32_BOL_ST_A_LONGOFF: decode_bol_opc([[bovs]], ctx, op1); case OPCM_32_BRC_EQ_NEQ: case OPCM_32_BRC_GE: case OPCM_32_BRC_JLT: case OPCM_32_BRC_JNE: const4 = MASK_OP_BRC_CONST4_SEXT(ctx->opcode); address = MASK_OP_BRC_DISP15_SEXT(ctx->opcode); r1 = MASK_OP_BRC_S1(ctx->opcode); gen_compute_branch(ctx, op1, r1, 0, const4, address); case OPCM_32_BRN_JTT: address = MASK_OP_BRN_DISP15_SEXT(ctx->opcode); r1 = MASK_OP_BRN_S1(ctx->opcode); gen_compute_branch(ctx, op1, r1, 0, 0, address); case OPCM_32_BRR_EQ_NEQ: case OPCM_32_BRR_ADDR_EQ_NEQ: case OPCM_32_BRR_GE: case OPCM_32_BRR_JLT: case OPCM_32_BRR_JNE: case OPCM_32_BRR_JNZ: case OPCM_32_BRR_LOOP: address = MASK_OP_BRR_DISP15_SEXT(ctx->opcode); r2 = MASK_OP_BRR_S2(ctx->opcode); r1 = MASK_OP_BRR_S1(ctx->opcode); gen_compute_branch(ctx, op1, r1, r2, 0, address); case OPCM_32_RC_LOGICAL_SHIFT: decode_rc_logical_shift([[bovs]], ctx); case OPCM_32_RC_ACCUMULATOR: decode_rc_accumulator([[bovs]], ctx); case OPCM_32_RC_SERVICEROUTINE: decode_rc_serviceroutine([[bovs]], ctx); case OPCM_32_RC_MUL: decode_rc_mul([[bovs]], ctx); case OPCM_32_RCPW_MASK_INSERT: decode_rcpw_insert([[bovs]], ctx); case OPC1_32_RCRR_INSERT: r1 = MASK_OP_RCRR_S1(ctx->opcode); r2 = MASK_OP_RCRR_S3(ctx->opcode); r3 = MASK_OP_RCRR_D(ctx->opcode); const16 = MASK_OP_RCRR_CONST4(ctx->opcode); [[temporal]] = tcg_const_i32(const16); temp2 = tcg_temp_new(); temp3 = tcg_temp_new(); tcg_gen_andi_tl(temp2, cpu_gpr_d[r3+1], 0x1f); tcg_gen_andi_tl(temp3, cpu_gpr_d[r3], 0x1f); gen_insert(cpu_gpr_d[r2], cpu_gpr_d[r1], [[temporal]], temp2, temp3); tcg_temp_free([[temporal]]); tcg_temp_free(temp2); tcg_temp_free(temp3); case OPCM_32_RCRW_MASK_INSERT: decode_rcrw_insert([[bovs]], ctx); case OPCM_32_RCR_COND_SELECT: decode_rcr_cond_select([[bovs]], ctx); case OPCM_32_RCR_MADD: decode_rcr_madd([[bovs]], ctx); case OPCM_32_RCR_MSUB: decode_rcr_msub([[bovs]], ctx); case OPC1_32_RLC_ADDI: case OPC1_32_RLC_ADDIH: case OPC1_32_RLC_ADDIH_A: case OPC1_32_RLC_MFCR: case OPC1_32_RLC_MOV: case OPC1_32_RLC_MOV_64: case OPC1_32_RLC_MOV_U: case OPC1_32_RLC_MOV_H: case OPC1_32_RLC_MOVH_A: case OPC1_32_RLC_MTCR: decode_rlc_opc([[bovs]], ctx, op1); } }[Succeeded / Failed / Skipped / Total] 413 / 42 / 267 / 722:  27%|       | 722/2690 [8:08:11<22:10:40, 40.57s/it][Succeeded / Failed / Skipped / Total] 413 / 42 / 267 / 722:  27%|       | 723/2690 [8:08:11<22:08:11, 40.51s/it][Succeeded / Failed / Skipped / Total] 413 / 42 / 268 / 723:  27%|       | 723/2690 [8:08:11<22:08:11, 40.51s/it][Succeeded / Failed / Skipped / Total] 413 / 42 / 268 / 723:  27%|       | 724/2690 [8:08:12<22:05:42, 40.46s/it]
--------------------------------------------- Result 723 ---------------------------------------------
[[0 (47%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ioport_write(void *opaque, uint32_t addr, uint32_t val) { PCIQXLDevice *d = opaque; uint32_t io_port = addr - d->io_base; switch (io_port) { case QXL_IO_RESET: case QXL_IO_SET_MODE: case QXL_IO_MEMSLOT_ADD: case QXL_IO_MEMSLOT_DEL: case QXL_IO_CREATE_PRIMARY: break; default: if (d->mode == QXL_MODE_NATIVE || d->mode == QXL_MODE_COMPAT) break; dprint(d, 1, "%s: unexpected port 0x%x in vga mode\n", __FUNCTION__, io_port); return; } switch (io_port) { case QXL_IO_UPDATE_AREA: { QXLRect update = d->ram->update_area; qemu_mutex_unlock_iothread(); d->ssd.worker->update_area(d->ssd.worker, d->ram->update_surface, &update, NULL, 0, 0); qemu_mutex_lock_iothread(); break; } case QXL_IO_NOTIFY_CMD: d->ssd.worker->wakeup(d->ssd.worker); break; case QXL_IO_NOTIFY_CURSOR: d->ssd.worker->wakeup(d->ssd.worker); break; case QXL_IO_UPDATE_IRQ: qxl_set_irq(d); break; case QXL_IO_NOTIFY_OOM: if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) { break; } pthread_yield(); if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) { break; } d->oom_running = 1; d->ssd.worker->oom(d->ssd.worker); d->oom_running = 0; break; case QXL_IO_SET_MODE: dprint(d, 1, "QXL_SET_MODE %d\n", val); qxl_set_mode(d, val, 0); break; case QXL_IO_LOG: if (d->guestdebug) { fprintf(stderr, "qxl/guest: %s", d->ram->log_buf); } break; case QXL_IO_RESET: dprint(d, 1, "QXL_IO_RESET\n"); qxl_hard_reset(d, 0); break; case QXL_IO_MEMSLOT_ADD: PANIC_ON(val >= NUM_MEMSLOTS); PANIC_ON(d->guest_slots[val].active); d->guest_slots[val].slot = d->ram->mem_slot; qxl_add_memslot(d, val, 0); break; case QXL_IO_MEMSLOT_DEL: qxl_del_memslot(d, val); break; case QXL_IO_CREATE_PRIMARY: PANIC_ON(val != 0); dprint(d, 1, "QXL_IO_CREATE_PRIMARY\n"); d->guest_primary.surface = d->ram->create_surface; qxl_create_guest_primary(d, 0); break; case QXL_IO_DESTROY_PRIMARY: PANIC_ON(val != 0); dprint(d, 1, "QXL_IO_DESTROY_PRIMARY\n"); qxl_destroy_primary(d); break; case QXL_IO_DESTROY_SURFACE_WAIT: d->ssd.worker->destroy_surface_wait(d->ssd.worker, val); break; case QXL_IO_DESTROY_ALL_SURFACES: d->ssd.worker->destroy_surfaces(d->ssd.worker); break; default: fprintf(stderr, "%s: ioport=0x%x, abort()\n", __FUNCTION__, io_port); abort(); } }
--------------------------------------------- Result 724 ---------------------------------------------
[[0 (85%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int h264_slice_header_parse(H264Context *h, H264SliceContext *sl) { const SPS *sps; const PPS *pps; unsigned int first_mb_in_slice; unsigned int pps_id; int ret; unsigned int slice_type, tmp, i; int last_pic_structure, last_pic_droppable; int needs_reinit = 0; int field_pic_flag, bottom_field_flag; int frame_num, droppable, picture_structure; int mb_aff_frame = 0; first_mb_in_slice = get_ue_golomb(&sl->gb); if (first_mb_in_slice == 0) { if (h->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) { ff_h264_field_end(h, sl, 1); } h->current_slice = 0; if (!h->first_field) { if (h->cur_pic_ptr && !h->droppable) { ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, h->picture_structure == PICT_BOTTOM_FIELD); } h->cur_pic_ptr = NULL; } } slice_type = get_ue_golomb_31(&sl->gb); if (slice_type > 9) { av_log(h->avctx, AV_LOG_ERROR, "slice type %d too large at %d\n", slice_type, first_mb_in_slice); return AVERROR_INVALIDDATA; } if (slice_type > 4) { slice_type -= 5; sl->slice_type_fixed = 1; } else sl->slice_type_fixed = 0; slice_type = ff_h264_golomb_to_pict_type[slice_type]; sl->slice_type = slice_type; sl->slice_type_nos = slice_type & 3; if (h->nal_unit_type == NAL_IDR_SLICE && sl->slice_type_nos != AV_PICTURE_TYPE_I) { av_log(h->avctx, AV_LOG_ERROR, "A non-intra slice in an IDR NAL unit.\n"); return AVERROR_INVALIDDATA; } pps_id = get_ue_golomb(&sl->gb); if (pps_id >= MAX_PPS_COUNT) { av_log(h->avctx, AV_LOG_ERROR, "pps_id %u out of range\n", pps_id); return AVERROR_INVALIDDATA; } if (!h->ps.pps_list[pps_id]) { av_log(h->avctx, AV_LOG_ERROR, "non-existing PPS %u referenced\n", pps_id); return AVERROR_INVALIDDATA; } if (!h->setup_finished) { h->ps.pps = (const PPS*)h->ps.pps_list[pps_id]->data; } else if (h->ps.pps != (const PPS*)h->ps.pps_list[pps_id]->data) { av_log(h->avctx, AV_LOG_ERROR, "PPS changed between slices\n"); return AVERROR_INVALIDDATA; } if (!h->ps.sps_list[h->ps.pps->sps_id]) { av_log(h->avctx, AV_LOG_ERROR, "non-existing SPS %u referenced\n", h->ps.pps->sps_id); return AVERROR_INVALIDDATA; } if (h->ps.sps != (const SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data) { h->ps.sps = (SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data; if (h->bit_depth_luma != h->ps.sps->bit_depth_luma || h->chroma_format_idc != h->ps.sps->chroma_format_idc) needs_reinit = 1; } pps = h->ps.pps; sps = h->ps.sps; if (!h->setup_finished) { h->avctx->profile = ff_h264_get_profile(sps); h->avctx->level = sps->level_idc; h->avctx->refs = sps->ref_frame_count; if (h->mb_width != sps->mb_width || h->mb_height != sps->mb_height * (2 - sps->frame_mbs_only_flag)) needs_reinit = 1; h->mb_width = sps->mb_width; h->mb_height = sps->mb_height * (2 - sps->frame_mbs_only_flag); h->mb_num = h->mb_width * h->mb_height; h->mb_stride = h->mb_width + 1; h->b_stride = h->mb_width * 4; h->chroma_y_shift = sps->chroma_format_idc <= 1; h->width = 16 * h->mb_width; h->height = 16 * h->mb_height; ret = init_dimensions(h); if (ret < 0) return ret; if (sps->video_signal_type_present_flag) { h->avctx->color_range = sps->full_range ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; if (sps->colour_description_present_flag) { if (h->avctx->colorspace != sps->colorspace) needs_reinit = 1; h->avctx->color_primaries = sps->color_primaries; h->avctx->color_trc = sps->color_trc; h->avctx->colorspace = sps->colorspace; } } } if (h->context_initialized && needs_reinit) { h->context_initialized = 0; if (sl != h->slice_ctx) { av_log(h->avctx, AV_LOG_ERROR, "changing width %d -> %d / height %d -> %d on " "slice %d\n", h->width, h->avctx->coded_width, h->height, h->avctx->coded_height, h->current_slice + 1); return AVERROR_INVALIDDATA; } ff_h264_flush_change(h); if ((ret = get_pixel_format(h)) < 0) return ret; h->avctx->pix_fmt = ret; av_log(h->avctx, AV_LOG_INFO, "Reinit context to %dx%d, " "pix_fmt: %d\n", h->width, h->height, h->avctx->pix_fmt); if ((ret = h264_slice_header_init(h)) < 0) { av_log(h->avctx, AV_LOG_ERROR, "h264_slice_header_init() failed\n"); return ret; } } if (!h->context_initialized) { if (sl != h->slice_ctx) { av_log(h->avctx, AV_LOG_ERROR, "Cannot (re-)initialize context during parallel decoding.\n"); return AVERROR_PATCHWELCOME; } if ((ret = get_pixel_format(h)) < 0) return ret; h->avctx->pix_fmt = ret; if ((ret = h264_slice_header_init(h)) < 0) { av_log(h->avctx, AV_LOG_ERROR, "h264_slice_header_init() failed\n"); return ret; } } frame_num = get_bits(&sl->gb, sps->log2_max_frame_num); if (!h->setup_finished) h->poc.frame_num = frame_num; sl->mb_mbaff = 0; last_pic_structure = h->picture_structure; last_pic_droppable = h->droppable; droppable = h->nal_ref_idc == 0; if (sps->frame_mbs_only_flag) { picture_structure = PICT_FRAME; } else { field_pic_flag = get_bits1(&sl->gb); if (field_pic_flag) { bottom_field_flag = get_bits1(&sl->gb); picture_structure = PICT_TOP_FIELD + bottom_field_flag; } else { picture_structure = PICT_FRAME; mb_aff_frame = sps->mb_aff; } } if (!h->setup_finished) { h->droppable = droppable; h->picture_structure = picture_structure; h->mb_aff_frame = mb_aff_frame; } sl->mb_field_decoding_flag = h->picture_structure != PICT_FRAME; if (h->current_slice != 0) { if (last_pic_structure != picture_structure || last_pic_droppable != droppable) { av_log(h->avctx, AV_LOG_ERROR, "Changing field mode (%d -> %d) between slices is not allowed\n", last_pic_structure, h->picture_structure); return AVERROR_INVALIDDATA; } else if (!h->cur_pic_ptr) { av_log(h->avctx, AV_LOG_ERROR, "unset cur_pic_ptr on slice %d\n", h->current_slice + 1); return AVERROR_INVALIDDATA; } } else { if (h->poc.frame_num != h->poc.prev_frame_num) { int unwrap_prev_frame_num = h->poc.prev_frame_num; int max_frame_num = 1 << sps->log2_max_frame_num; if (unwrap_prev_frame_num > h->poc.frame_num) unwrap_prev_frame_num -= max_frame_num; if ((h->poc.frame_num - unwrap_prev_frame_num) > sps->ref_frame_count) { unwrap_prev_frame_num = (h->poc.frame_num - sps->ref_frame_count) - 1; if (unwrap_prev_frame_num < 0) unwrap_prev_frame_num += max_frame_num; h->poc.prev_frame_num = unwrap_prev_frame_num; } } if (h->first_field) { assert(h->cur_pic_ptr); assert(h->cur_pic_ptr->f->buf[0]); assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF); if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) { if (!last_pic_droppable && last_pic_structure != PICT_FRAME) { ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, last_pic_structure == PICT_TOP_FIELD); } } else { if (h->cur_pic_ptr->frame_num != h->poc.frame_num) { if (!last_pic_droppable && last_pic_structure != PICT_FRAME) { ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, last_pic_structure == PICT_TOP_FIELD); } } else { if (!((last_pic_structure == PICT_TOP_FIELD && h->picture_structure == PICT_BOTTOM_FIELD) || (last_pic_structure == PICT_BOTTOM_FIELD && h->picture_structure == PICT_TOP_FIELD))) { av_log(h->avctx, AV_LOG_ERROR, "Invalid field mode combination %d/%d\n", last_pic_structure, h->picture_structure); h->picture_structure = last_pic_structure; h->droppable = last_pic_droppable; return AVERROR_INVALIDDATA; } else if (last_pic_droppable != h->droppable) { avpriv_request_sample(h->avctx, "Found reference and non-reference fields in the same frame, which"); h->picture_structure = last_pic_structure; h->droppable = last_pic_droppable; return AVERROR_PATCHWELCOME; } } } } while (h->poc.frame_num != h->poc.prev_frame_num && h->poc.frame_num != (h->poc.prev_frame_num + 1) % (1 << sps->log2_max_frame_num)) { H264Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL; av_log(h->avctx, AV_LOG_DEBUG, "Frame num gap %d %d\n", h->poc.frame_num, h->poc.prev_frame_num); ret = initialize_cur_frame(h); if (ret < 0) { h->first_field = 0; return ret; } h->poc.prev_frame_num++; h->poc.prev_frame_num %= 1 << sps->log2_max_frame_num; h->cur_pic_ptr->frame_num = h->poc.prev_frame_num; ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0); ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1); ret = ff_generate_sliding_window_mmcos(h, 1); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) return ret; ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) return ret; if (h->short_ref_count) { if (prev && h->short_ref[0]->f->width == prev->f->width && h->short_ref[0]->f->height == prev->f->height && h->short_ref[0]->f->format == prev->f->format) { av_image_copy(h->short_ref[0]->f->data, h->short_ref[0]->f->linesize, (const uint8_t **)prev->f->data, prev->f->linesize, prev->f->format, h->mb_width * 16, h->mb_height * 16); h->short_ref[0]->poc = prev->poc + 2; } h->short_ref[0]->frame_num = h->poc.prev_frame_num; } } if (h->first_field) { assert(h->cur_pic_ptr); assert(h->cur_pic_ptr->f->buf[0]); assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF); if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) { h->cur_pic_ptr = NULL; h->first_field = FIELD_PICTURE(h); } else { if (h->cur_pic_ptr->frame_num != h->poc.frame_num) { h->first_field = 1; h->cur_pic_ptr = NULL; } else { h->first_field = 0; } } } else { h->first_field = FIELD_PICTURE(h); } if (!FIELD_PICTURE(h) || h->first_field) { if (h264_frame_start(h) < 0) { h->first_field = 0; return AVERROR_INVALIDDATA; } } else { release_unused_pictures(h, 0); } } assert(h->mb_num == h->mb_width * h->mb_height); if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num || first_mb_in_slice >= h->mb_num) { av_log(h->avctx, AV_LOG_ERROR, "first_mb_in_slice overflow\n"); return AVERROR_INVALIDDATA; } sl->resync_mb_x = sl->mb_x = first_mb_in_slice % h->mb_width; sl->resync_mb_y = sl->mb_y = (first_mb_in_slice / h->mb_width) << FIELD_OR_MBAFF_PICTURE(h); if (h->picture_structure == PICT_BOTTOM_FIELD) sl->resync_mb_y = sl->mb_y = sl->mb_y + 1; assert(sl->mb_y < h->mb_height); if (h->picture_structure == PICT_FRAME) { h->curr_pic_num = h->poc.frame_num; h->max_pic_num = 1 << sps->log2_max_frame_num; } else { h->curr_pic_num = 2 * h->poc.frame_num + 1; h->max_pic_num = 1 << (sps->log2_max_frame_num + 1); } if (h->nal_unit_type == NAL_IDR_SLICE) get_ue_golomb(&sl->gb); if (sps->poc_type == 0) { int poc_lsb = get_bits(&sl->gb, sps->log2_max_poc_lsb); if (!h->setup_finished) h->poc.poc_lsb = poc_lsb; if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) { int delta_poc_bottom = get_se_golomb(&sl->gb); if (!h->setup_finished) h->poc.delta_poc_bottom = delta_poc_bottom; } } if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) { int delta_poc = get_se_golomb(&sl->gb); if (!h->setup_finished) h->poc.delta_poc[0] = delta_poc; if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) { delta_poc = get_se_golomb(&sl->gb); if (!h->setup_finished) h->poc.delta_poc[1] = delta_poc; } } if (!h->setup_finished) ff_h264_init_poc(h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc, sps, &h->poc, h->picture_structure, h->nal_ref_idc); if (pps->redundant_pic_cnt_present) sl->redundant_pic_count = get_ue_golomb(&sl->gb); if (sl->slice_type_nos == AV_PICTURE_TYPE_B) sl->direct_spatial_mv_pred = get_bits1(&sl->gb); ret = ff_h264_parse_ref_count(&sl->list_count, sl->ref_count, &sl->gb, pps, sl->slice_type_nos, h->picture_structure); if (ret < 0) return ret; if (sl->slice_type_nos != AV_PICTURE_TYPE_I) { ret = ff_h264_decode_ref_pic_list_reordering(h, sl); if (ret < 0) { sl->ref_count[1] = sl->ref_count[0] = 0; return ret; } } sl->pwt.use_weight = 0; for (i = 0; i < 2; i++) { sl->pwt.luma_weight_flag[i] = 0; sl->pwt.chroma_weight_flag[i] = 0; } if ((pps->weighted_pred && sl->slice_type_nos == AV_PICTURE_TYPE_P) || (pps->weighted_bipred_idc == 1 && sl->slice_type_nos == AV_PICTURE_TYPE_B)) ff_h264_pred_weight_table(&sl->gb, sps, sl->ref_count, sl->slice_type_nos, &sl->pwt); if (h->nal_ref_idc) { ret = ff_h264_decode_ref_pic_marking(h, &sl->gb, !(h->avctx->active_thread_type & FF_THREAD_FRAME) || h->current_slice == 0); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) return AVERROR_INVALIDDATA; } if (sl->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) { tmp = get_ue_golomb_31(&sl->gb); if (tmp > 2) { av_log(h->avctx, AV_LOG_ERROR, "cabac_init_idc %u overflow\n", tmp); return AVERROR_INVALIDDATA; } sl->cabac_init_idc = tmp; } sl->last_qscale_diff = 0; tmp = pps->init_qp + get_se_golomb(&sl->gb); if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) { av_log(h->avctx, AV_LOG_ERROR, "QP %u out of range\n", tmp); return AVERROR_INVALIDDATA; } sl->qscale = tmp; sl->chroma_qp[0] = get_chroma_qp(h, 0, sl->qscale); sl->chroma_qp[1] = get_chroma_qp(h, 1, sl->qscale); if (sl->slice_type == AV_PICTURE_TYPE_SP) get_bits1(&sl->gb); if (sl->slice_type == AV_PICTURE_TYPE_SP || sl->slice_type == AV_PICTURE_TYPE_SI) get_se_golomb(&sl->gb); sl->deblocking_filter = 1; sl->slice_alpha_c0_offset = 0; sl->slice_beta_offset = 0; if (pps->deblocking_filter_parameters_present) { tmp = get_ue_golomb_31(&sl->gb); if (tmp > 2) { av_log(h->avctx, AV_LOG_ERROR, "deblocking_filter_idc %u out of range\n", tmp); return AVERROR_INVALIDDATA; } sl->deblocking_filter = tmp; if (sl->deblocking_filter < 2) sl->deblocking_filter ^= 1; if (sl->deblocking_filter) { sl->slice_alpha_c0_offset = get_se_golomb(&sl->gb) * 2; sl->slice_beta_offset = get_se_golomb(&sl->gb) * 2; if (sl->slice_alpha_c0_offset > 12 || sl->slice_alpha_c0_offset < -12 || sl->slice_beta_offset > 12 || sl->slice_beta_offset < -12) { av_log(h->avctx, AV_LOG_ERROR, "deblocking filter parameters %d %d out of range\n", sl->slice_alpha_c0_offset, sl->slice_beta_offset); return AVERROR_INVALIDDATA; } } } return 0; }[Succeeded / Failed / Skipped / Total] 413 / 42 / 269 / 724:  27%|       | 724/2690 [8:08:12<22:05:42, 40.46s/it][Succeeded / Failed / Skipped / Total] 413 / 42 / 269 / 724:  27%|       | 725/2690 [8:08:50<22:04:56, 40.46s/it][Succeeded / Failed / Skipped / Total] 414 / 42 / 269 / 725:  27%|       | 725/2690 [8:08:50<22:04:56, 40.46s/it][Succeeded / Failed / Skipped / Total] 414 / 42 / 269 / 725:  27%|       | 726/2690 [8:08:51<22:02:27, 40.40s/it][Succeeded / Failed / Skipped / Total] 414 / 42 / 270 / 726:  27%|       | 726/2690 [8:08:51<22:02:27, 40.40s/it][Succeeded / Failed / Skipped / Total] 414 / 42 / 270 / 726:  27%|       | 727/2690 [8:09:13<22:00:58, 40.38s/it][Succeeded / Failed / Skipped / Total] 415 / 42 / 270 / 727:  27%|       | 727/2690 [8:09:13<22:00:58, 40.38s/it][Succeeded / Failed / Skipped / Total] 415 / 42 / 270 / 727:  27%|       | 728/2690 [8:09:17<21:58:39, 40.33s/it][Succeeded / Failed / Skipped / Total] 416 / 42 / 270 / 728:  27%|       | 728/2690 [8:09:17<21:58:39, 40.33s/it][Succeeded / Failed / Skipped / Total] 416 / 42 / 270 / 728:  27%|       | 729/2690 [8:21:16<22:28:26, 41.26s/it]
--------------------------------------------- Result 725 ---------------------------------------------
[[0 (4%)]] --> [[0 (72%)]] --> Socre: 0.7173205614089966

[[[[Adv]]]]: int ffurl_shutdown(URLContext *[[h]], int flags) { if (![[h]]->prot->url_shutdown) return AVERROR(EINVAL); return [[h]]->prot->url_shutdown([[h]], flags); }

[[[[Adv]]]]: int ffurl_shutdown(URLContext *[[grams]], int flags) { if (![[grams]]->prot->url_shutdown) return AVERROR(EINVAL); return [[grams]]->prot->url_shutdown([[grams]], flags); }
--------------------------------------------- Result 726 ---------------------------------------------
[[0 (36%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void i82378_init(DeviceState *dev, I82378State *s) { ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, "isa.0")); ISADevice *pit; qemu_irq *out0_irq; qdev_init_gpio_out(dev, s->out, 2); qdev_init_gpio_in(dev, i82378_request_pic_irq, 16); out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1); s->i8259 = i8259_init(isabus, *out0_irq); isa_bus_irqs(isabus, s->i8259); pit = pit_init(isabus, 0x40, 0, NULL); pcspk_init(isabus, pit); DMA_init(1, &s->out[1]); isa_create_simple(isabus, "i82374"); isa_create_simple(isabus, "mc146818rtc"); }
--------------------------------------------- Result 727 ---------------------------------------------
[[0 (11%)]] --> [[0 (99%)]] --> Socre: 0.9925442934036255

[[[[Adv]]]]: static void realview_init(ram_addr_t ram_size, int vga_ram_size, const char *boot_device, DisplayState *ds, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { CPUState *[[env]]; qemu_irq *pic; void *scsi_hba; PCIBus *pci_bus; NICInfo *nd; int n; int done_smc = 0; qemu_irq cpu_irq[4]; int ncpu; int index; if (!cpu_model) cpu_model = "arm926"; if (strcmp(cpu_model, "arm11mpcore") == 0) { ncpu = 4; } else { ncpu = 1; } for (n = 0; n < ncpu; n++) { [[env]] = cpu_init(cpu_model); if (![[env]]) { fprintf(stderr, "Unable to find CPU definition\n"); exit(1); } pic = arm_pic_init_cpu([[env]]); cpu_irq[n] = pic[ARM_PIC_CPU_IRQ]; if (n > 0) { [[env]]->regs[15] = 0x80000000; } } cpu_register_physical_memory(0, ram_size, IO_MEM_RAM); arm_sysctl_init(0x10000000, 0xc1400400); if (ncpu == 1) { pic = realview_gic_init(0x10040000, cpu_irq[0]); } else { pic = mpcore_irq_init(cpu_irq); } pl050_init(0x10006000, pic[20], 0); pl050_init(0x10007000, pic[21], 1); pl011_init(0x10009000, pic[12], serial_hds[0], PL011_ARM); pl011_init(0x1000a000, pic[13], serial_hds[1], PL011_ARM); pl011_init(0x1000b000, pic[14], serial_hds[2], PL011_ARM); pl011_init(0x1000c000, pic[15], serial_hds[3], PL011_ARM); pl080_init(0x10030000, pic[24], 2); sp804_init(0x10011000, pic[4]); sp804_init(0x10012000, pic[5]); pl110_init(ds, 0x10020000, pic[23], 1); index = drive_get_index(IF_SD, 0, 0); if (index == -1) { fprintf(stderr, "qemu: missing SecureDigital card\n"); exit(1); } pl181_init(0x10005000, drives_table[index].bdrv, pic[17], pic[18]); pl031_init(0x10017000, pic[10]); pci_bus = pci_vpb_init(pic, 48, 1); if (usb_enabled) { usb_ohci_init_pci(pci_bus, 3, -1); } if (drive_get_max_bus(IF_SCSI) > 0) { fprintf(stderr, "qemu: too many SCSI bus\n"); exit(1); } scsi_hba = lsi_scsi_init(pci_bus, -1); for (n = 0; n < LSI_MAX_DEVS; n++) { index = drive_get_index(IF_SCSI, 0, n); if (index == -1) continue; lsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n); } for(n = 0; n < nb_nics; n++) { nd = &nd_table[n]; if (!nd->model) nd->model = done_smc ? "rtl8139" : "smc91c111"; if (strcmp(nd->model, "smc91c111") == 0) { smc91c111_init(nd, 0x4e000000, pic[28]); } else { pci_nic_init(pci_bus, nd, -1); } } realview_binfo.ram_size = ram_size; realview_binfo.kernel_filename = kernel_filename; realview_binfo.kernel_cmdline = kernel_cmdline; realview_binfo.initrd_filename = initrd_filename; realview_binfo.nb_cpus = ncpu; arm_load_kernel(first_cpu, &realview_binfo); cpu_register_physical_memory(0x80000000, 0x1000, IO_MEM_RAM + ram_size); }

[[[[Adv]]]]: static void realview_init(ram_addr_t ram_size, int vga_ram_size, const char *boot_device, DisplayState *ds, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { CPUState *[[elly]]; qemu_irq *pic; void *scsi_hba; PCIBus *pci_bus; NICInfo *nd; int n; int done_smc = 0; qemu_irq cpu_irq[4]; int ncpu; int index; if (!cpu_model) cpu_model = "arm926"; if (strcmp(cpu_model, "arm11mpcore") == 0) { ncpu = 4; } else { ncpu = 1; } for (n = 0; n < ncpu; n++) { [[elly]] = cpu_init(cpu_model); if (![[elly]]) { fprintf(stderr, "Unable to find CPU definition\n"); exit(1); } pic = arm_pic_init_cpu([[elly]]); cpu_irq[n] = pic[ARM_PIC_CPU_IRQ]; if (n > 0) { [[elly]]->regs[15] = 0x80000000; } } cpu_register_physical_memory(0, ram_size, IO_MEM_RAM); arm_sysctl_init(0x10000000, 0xc1400400); if (ncpu == 1) { pic = realview_gic_init(0x10040000, cpu_irq[0]); } else { pic = mpcore_irq_init(cpu_irq); } pl050_init(0x10006000, pic[20], 0); pl050_init(0x10007000, pic[21], 1); pl011_init(0x10009000, pic[12], serial_hds[0], PL011_ARM); pl011_init(0x1000a000, pic[13], serial_hds[1], PL011_ARM); pl011_init(0x1000b000, pic[14], serial_hds[2], PL011_ARM); pl011_init(0x1000c000, pic[15], serial_hds[3], PL011_ARM); pl080_init(0x10030000, pic[24], 2); sp804_init(0x10011000, pic[4]); sp804_init(0x10012000, pic[5]); pl110_init(ds, 0x10020000, pic[23], 1); index = drive_get_index(IF_SD, 0, 0); if (index == -1) { fprintf(stderr, "qemu: missing SecureDigital card\n"); exit(1); } pl181_init(0x10005000, drives_table[index].bdrv, pic[17], pic[18]); pl031_init(0x10017000, pic[10]); pci_bus = pci_vpb_init(pic, 48, 1); if (usb_enabled) { usb_ohci_init_pci(pci_bus, 3, -1); } if (drive_get_max_bus(IF_SCSI) > 0) { fprintf(stderr, "qemu: too many SCSI bus\n"); exit(1); } scsi_hba = lsi_scsi_init(pci_bus, -1); for (n = 0; n < LSI_MAX_DEVS; n++) { index = drive_get_index(IF_SCSI, 0, n); if (index == -1) continue; lsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n); } for(n = 0; n < nb_nics; n++) { nd = &nd_table[n]; if (!nd->model) nd->model = done_smc ? "rtl8139" : "smc91c111"; if (strcmp(nd->model, "smc91c111") == 0) { smc91c111_init(nd, 0x4e000000, pic[28]); } else { pci_nic_init(pci_bus, nd, -1); } } realview_binfo.ram_size = ram_size; realview_binfo.kernel_filename = kernel_filename; realview_binfo.kernel_cmdline = kernel_cmdline; realview_binfo.initrd_filename = initrd_filename; realview_binfo.nb_cpus = ncpu; arm_load_kernel(first_cpu, &realview_binfo); cpu_register_physical_memory(0x80000000, 0x1000, IO_MEM_RAM + ram_size); }
--------------------------------------------- Result 728 ---------------------------------------------
[[0 (47%)]] --> [[0 (62%)]] --> Socre: 0.6205168962478638

[[[[Adv]]]]: QString *qstring_from_substr(const char *[[str]], int start, int end) { QString *qstring; qstring = g_malloc(sizeof(*qstring)); qstring->length = end - start + 1; qstring->capacity = qstring->length; qstring->string = g_malloc(qstring->capacity + 1); memcpy(qstring->string, [[str]] + start, qstring->length); qstring->string[qstring->length] = 0; QOBJECT_INIT(qstring, &qstring_type); return qstring; }

[[[[Adv]]]]: QString *qstring_from_substr(const char *[[shielding]], int start, int end) { QString *qstring; qstring = g_malloc(sizeof(*qstring)); qstring->length = end - start + 1; qstring->capacity = qstring->length; qstring->string = g_malloc(qstring->capacity + 1); memcpy(qstring->string, [[shielding]] + start, qstring->length); qstring->string[qstring->length] = 0; QOBJECT_INIT(qstring, &qstring_type); return qstring; }
--------------------------------------------- Result 729 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 417 / 42 / 270 / 729:  27%|       | 729/2690 [8:21:16<22:28:26, 41.26s/it][Succeeded / Failed / Skipped / Total] 417 / 42 / 270 / 729:  27%|       | 730/2690 [8:21:25<22:26:17, 41.21s/it][[0 (100%)]] --> [[0 (48%)]] --> Socre: 0.5249391198158264

[[[[Adv]]]]: static int pcx_decode_frame(AVCodecContext *[[avctx]], void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; AVFrame *const p = data; int compressed, xmin, ymin, xmax, ymax; unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x, bytes_per_scanline; uint8_t *[[ptr]]; const uint8_t *buf_end = buf + buf_size; const uint8_t *bufstart = buf; uint8_t *[[scanline]]; int ret = -1; if (buf[0] != 0x0a || buf[1] > 5) { av_log([[avctx]], AV_LOG_ERROR, "this is not PCX encoded data\n"); compressed = buf[2]; xmin = AV_RL16(buf + 4); ymin = AV_RL16(buf + 6); xmax = AV_RL16(buf + 8); ymax = AV_RL16(buf + 10); if (xmax < xmin || ymax < ymin) { av_log([[avctx]], AV_LOG_ERROR, "invalid image dimensions\n"); w = xmax - xmin + 1; h = ymax - ymin + 1; bits_per_pixel = buf[3]; bytes_per_line = AV_RL16(buf + 66); nplanes = buf[65]; bytes_per_scanline = nplanes * bytes_per_line; if (bytes_per_scanline < (w * bits_per_pixel * nplanes + 7) / 8 || (!compressed && bytes_per_scanline > buf_size / h)) { av_log([[avctx]], AV_LOG_ERROR, "PCX data is corrupted\n"); switch ((nplanes << 8) + bits_per_pixel) { case 0x0308: [[avctx]]->pix_fmt = AV_PIX_FMT_RGB24; break; case 0x0108: case 0x0104: case 0x0102: case 0x0101: case 0x0401: case 0x0301: case 0x0201: [[avctx]]->pix_fmt = AV_PIX_FMT_PAL8; break; default: av_log([[avctx]], AV_LOG_ERROR, "invalid PCX file\n"); buf += 128; if ((ret = ff_set_dimensions([[avctx]], w, h)) < 0) return ret; if ((ret = ff_get_buffer([[avctx]], p, 0)) < 0) { av_log([[avctx]], AV_LOG_ERROR, "get_buffer() failed\n"); return ret; p->pict_type = AV_PICTURE_TYPE_I; [[ptr]] = p->data[0]; stride = p->linesize[0]; [[scanline]] = av_malloc(bytes_per_scanline + AV_INPUT_BUFFER_PADDING_SIZE); if (![[scanline]]) return AVERROR(ENOMEM); if (nplanes == 3 && bits_per_pixel == 8) { for (y = 0; y < h; y++) { buf = pcx_rle_decode(buf, buf_end, [[scanline]], bytes_per_scanline, compressed); for (x = 0; x < w; x++) { [[ptr]][3 * x] = [[scanline]][x]; [[ptr]][3 * x + 1] = [[scanline]][x + bytes_per_line]; [[ptr]][3 * x + 2] = [[scanline]][x + (bytes_per_line << 1)]; [[ptr]] += stride; } else if (nplanes == 1 && bits_per_pixel == 8) { const uint8_t *palstart = bufstart + buf_size - 769; if (buf_size < 769) { av_log([[avctx]], AV_LOG_ERROR, "File is too short\n"); ret = [[avctx]]->err_recognition & AV_EF_EXPLODE ? AVERROR_INVALIDDATA : buf_size; goto end; for (y = 0; y < h; y++, [[ptr]] += stride) { buf = pcx_rle_decode(buf, buf_end, [[scanline]], bytes_per_scanline, compressed); memcpy([[ptr]], [[scanline]], w); if (buf != palstart) { av_log([[avctx]], AV_LOG_WARNING, "image data possibly corrupted\n"); buf = palstart; if (*buf++ != 12) { av_log([[avctx]], AV_LOG_ERROR, "expected palette after image data\n"); ret = [[avctx]]->err_recognition & AV_EF_EXPLODE ? AVERROR_INVALIDDATA : buf_size; goto end; } else if (nplanes == 1) { GetBitContext s; for (y = 0; y < h; y++) { init_get_bits(&s, [[scanline]], bytes_per_scanline << 3); buf = pcx_rle_decode(buf, buf_end, [[scanline]], bytes_per_scanline, compressed); for (x = 0; x < w; x++) [[ptr]][x] = get_bits(&s, bits_per_pixel); [[ptr]] += stride; } else { int i; for (y = 0; y < h; y++) { buf = pcx_rle_decode(buf, buf_end, [[scanline]], bytes_per_scanline, compressed); for (x = 0; x < w; x++) { int m = 0x80 >> (x & 7), v = 0; for (i = nplanes - 1; i >= 0; i--) { v <<= 1; v += !!([[scanline]][i * bytes_per_line + (x >> 3)] & m); [[ptr]][x] = v; [[ptr]] += stride; if (nplanes == 1 && bits_per_pixel == 8) { pcx_palette(&buf, (uint32_t *)p->data[1], 256); } else if (bits_per_pixel < 8) { const uint8_t *palette = bufstart + 16; pcx_palette(&palette, (uint32_t *)p->data[1], 16); *got_frame = 1; ret = buf - bufstart; end: av_free([[scanline]]); return ret;

[[[[Adv]]]]: static int pcx_decode_frame(AVCodecContext *[[esp]], void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; AVFrame *const p = data; int compressed, xmin, ymin, xmax, ymax; unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x, bytes_per_scanline; uint8_t *[[flatness]]; const uint8_t *buf_end = buf + buf_size; const uint8_t *bufstart = buf; uint8_t *[[nmero]]; int ret = -1; if (buf[0] != 0x0a || buf[1] > 5) { av_log([[esp]], AV_LOG_ERROR, "this is not PCX encoded data\n"); compressed = buf[2]; xmin = AV_RL16(buf + 4); ymin = AV_RL16(buf + 6); xmax = AV_RL16(buf + 8); ymax = AV_RL16(buf + 10); if (xmax < xmin || ymax < ymin) { av_log([[esp]], AV_LOG_ERROR, "invalid image dimensions\n"); w = xmax - xmin + 1; h = ymax - ymin + 1; bits_per_pixel = buf[3]; bytes_per_line = AV_RL16(buf + 66); nplanes = buf[65]; bytes_per_scanline = nplanes * bytes_per_line; if (bytes_per_scanline < (w * bits_per_pixel * nplanes + 7) / 8 || (!compressed && bytes_per_scanline > buf_size / h)) { av_log([[esp]], AV_LOG_ERROR, "PCX data is corrupted\n"); switch ((nplanes << 8) + bits_per_pixel) { case 0x0308: [[esp]]->pix_fmt = AV_PIX_FMT_RGB24; break; case 0x0108: case 0x0104: case 0x0102: case 0x0101: case 0x0401: case 0x0301: case 0x0201: [[esp]]->pix_fmt = AV_PIX_FMT_PAL8; break; default: av_log([[esp]], AV_LOG_ERROR, "invalid PCX file\n"); buf += 128; if ((ret = ff_set_dimensions([[esp]], w, h)) < 0) return ret; if ((ret = ff_get_buffer([[esp]], p, 0)) < 0) { av_log([[esp]], AV_LOG_ERROR, "get_buffer() failed\n"); return ret; p->pict_type = AV_PICTURE_TYPE_I; [[flatness]] = p->data[0]; stride = p->linesize[0]; [[nmero]] = av_malloc(bytes_per_scanline + AV_INPUT_BUFFER_PADDING_SIZE); if (![[nmero]]) return AVERROR(ENOMEM); if (nplanes == 3 && bits_per_pixel == 8) { for (y = 0; y < h; y++) { buf = pcx_rle_decode(buf, buf_end, [[nmero]], bytes_per_scanline, compressed); for (x = 0; x < w; x++) { [[flatness]][3 * x] = [[nmero]][x]; [[flatness]][3 * x + 1] = [[nmero]][x + bytes_per_line]; [[flatness]][3 * x + 2] = [[nmero]][x + (bytes_per_line << 1)]; [[flatness]] += stride; } else if (nplanes == 1 && bits_per_pixel == 8) { const uint8_t *palstart = bufstart + buf_size - 769; if (buf_size < 769) { av_log([[esp]], AV_LOG_ERROR, "File is too short\n"); ret = [[esp]]->err_recognition & AV_EF_EXPLODE ? AVERROR_INVALIDDATA : buf_size; goto end; for (y = 0; y < h; y++, [[flatness]] += stride) { buf = pcx_rle_decode(buf, buf_end, [[nmero]], bytes_per_scanline, compressed); memcpy([[flatness]], [[nmero]], w); if (buf != palstart) { av_log([[esp]], AV_LOG_WARNING, "image data possibly corrupted\n"); buf = palstart; if (*buf++ != 12) { av_log([[esp]], AV_LOG_ERROR, "expected palette after image data\n"); ret = [[esp]]->err_recognition & AV_EF_EXPLODE ? AVERROR_INVALIDDATA : buf_size; goto end; } else if (nplanes == 1) { GetBitContext s; for (y = 0; y < h; y++) { init_get_bits(&s, [[nmero]], bytes_per_scanline << 3); buf = pcx_rle_decode(buf, buf_end, [[nmero]], bytes_per_scanline, compressed); for (x = 0; x < w; x++) [[flatness]][x] = get_bits(&s, bits_per_pixel); [[flatness]] += stride; } else { int i; for (y = 0; y < h; y++) { buf = pcx_rle_decode(buf, buf_end, [[nmero]], bytes_per_scanline, compressed); for (x = 0; x < w; x++) { int m = 0x80 >> (x & 7), v = 0; for (i = nplanes - 1; i >= 0; i--) { v <<= 1; v += !!([[nmero]][i * bytes_per_line + (x >> 3)] & m); [[flatness]][x] = v; [[flatness]] += stride; if (nplanes == 1 && bits_per_pixel == 8) { pcx_palette(&buf, (uint32_t *)p->data[1], 256); } else if (bits_per_pixel < 8) { const uint8_t *palette = bufstart + 16; pcx_palette(&palette, (uint32_t *)p->data[1], 16); *got_frame = 1; ret = buf - bufstart; end: av_free([[nmero]]); return ret;
--------------------------------------------- Result 730 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 418 / 42 / 270 / 730:  27%|       | 730/2690 [8:21:25<22:26:17, 41.21s/it][Succeeded / Failed / Skipped / Total] 418 / 42 / 270 / 730:  27%|       | 731/2690 [8:21:25<22:23:46, 41.16s/it][Succeeded / Failed / Skipped / Total] 418 / 42 / 271 / 731:  27%|       | 731/2690 [8:21:25<22:23:46, 41.16s/it][Succeeded / Failed / Skipped / Total] 418 / 42 / 271 / 731:  27%|       | 732/2690 [8:21:35<22:21:41, 41.11s/it][Succeeded / Failed / Skipped / Total] 419 / 42 / 271 / 732:  27%|       | 732/2690 [8:21:35<22:21:41, 41.11s/it][Succeeded / Failed / Skipped / Total] 419 / 42 / 271 / 732:  27%|       | 733/2690 [8:21:36<22:19:11, 41.06s/it][Succeeded / Failed / Skipped / Total] 419 / 42 / 272 / 733:  27%|       | 733/2690 [8:21:36<22:19:11, 41.06s/it][Succeeded / Failed / Skipped / Total] 419 / 42 / 272 / 733:  27%|       | 734/2690 [8:25:58<22:28:22, 41.36s/it][Succeeded / Failed / Skipped / Total] 420 / 42 / 272 / 734:  27%|       | 734/2690 [8:25:59<22:28:23, 41.36s/it][Succeeded / Failed / Skipped / Total] 420 / 42 / 272 / 734:  27%|       | 735/2690 [8:25:59<22:25:52, 41.31s/it][[0 (9%)]] --> [[0 (51%)]] --> Socre: 0.5117387175559998

[[[[Adv]]]]: static int coroutine_fn is_allocated_base(BlockDriverState *top, BlockDriverState *base, int64_t [[sector_num]], int [[nb_sectors]], int *[[pnum]]) { BlockDriverState *[[intermediate]]; int ret, n; ret = bdrv_co_is_allocated(top, [[sector_num]], [[nb_sectors]], &n); if (ret) { *[[pnum]] = n; return ret; } [[intermediate]] = top->backing_hd; while ([[intermediate]] != base) { int [[pnum_inter]]; ret = bdrv_co_is_allocated([[intermediate]], [[sector_num]], [[nb_sectors]], &[[pnum_inter]]); if (ret < 0) { return ret; } else if (ret) { *[[pnum]] = [[pnum_inter]]; return 0; } if (n > [[pnum_inter]]) { n = [[pnum_inter]]; } [[intermediate]] = [[intermediate]]->backing_hd; } *[[pnum]] = n; return 1; }

[[[[Adv]]]]: static int coroutine_fn is_allocated_base(BlockDriverState *top, BlockDriverState *base, int64_t [[kado]], int [[magruder]], int *[[magnifico]]) { BlockDriverState *[[traders]]; int ret, n; ret = bdrv_co_is_allocated(top, [[kado]], [[magruder]], &n); if (ret) { *[[magnifico]] = n; return ret; } [[traders]] = top->backing_hd; while ([[traders]] != base) { int [[johannes]]; ret = bdrv_co_is_allocated([[traders]], [[kado]], [[magruder]], &[[johannes]]); if (ret < 0) { return ret; } else if (ret) { *[[magnifico]] = [[johannes]]; return 0; } if (n > [[johannes]]) { n = [[johannes]]; } [[traders]] = [[traders]]->backing_hd; } *[[magnifico]] = n; return 1; }
--------------------------------------------- Result 731 ---------------------------------------------
[[0 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static DisplayType select_display(const char *p) { Error *err = NULL; const char *opts; DisplayType display = DT_DEFAULT; if (strstart(p, "sdl", &opts)) { #ifdef CONFIG_SDL display = DT_SDL; while (*opts) { const char *nextopt; if (strstart(opts, ",frame=", &nextopt)) { opts = nextopt; if (strstart(opts, "on", &nextopt)) { no_frame = 0; } else if (strstart(opts, "off", &nextopt)) { no_frame = 1; } else { goto invalid_sdl_args; } } else if (strstart(opts, ",alt_grab=", &nextopt)) { opts = nextopt; if (strstart(opts, "on", &nextopt)) { alt_grab = 1; } else if (strstart(opts, "off", &nextopt)) { alt_grab = 0; } else { goto invalid_sdl_args; } } else if (strstart(opts, ",ctrl_grab=", &nextopt)) { opts = nextopt; if (strstart(opts, "on", &nextopt)) { ctrl_grab = 1; } else if (strstart(opts, "off", &nextopt)) { ctrl_grab = 0; } else { goto invalid_sdl_args; } } else if (strstart(opts, ",window_close=", &nextopt)) { opts = nextopt; if (strstart(opts, "on", &nextopt)) { no_quit = 0; } else if (strstart(opts, "off", &nextopt)) { no_quit = 1; } else { goto invalid_sdl_args; } } else if (strstart(opts, ",gl=", &nextopt)) { opts = nextopt; if (strstart(opts, "on", &nextopt)) { request_opengl = 1; } else if (strstart(opts, "off", &nextopt)) { request_opengl = 0; } else { goto invalid_sdl_args; } } else { invalid_sdl_args: fprintf(stderr, "Invalid SDL option string: %s\n", p); exit(1); } opts = nextopt; } #else fprintf(stderr, "SDL support is disabled\n"); exit(1); #endif } else if (strstart(p, "vnc", &opts)) { #ifdef CONFIG_VNC if (*opts == '=') { if (vnc_parse(opts + 1, &err) == NULL) { error_report_err(err); exit(1); } } else { fprintf(stderr, "VNC requires a display argument vnc=<display>\n"); exit(1); } #else fprintf(stderr, "VNC support is disabled\n"); exit(1); #endif } else if (strstart(p, "curses", &opts)) { #ifdef CONFIG_CURSES display = DT_CURSES; #else fprintf(stderr, "Curses support is disabled\n"); exit(1); #endif } else if (strstart(p, "gtk", &opts)) { #ifdef CONFIG_GTK display = DT_GTK; while (*opts) { const char *nextopt; if (strstart(opts, ",grab_on_hover=", &nextopt)) { opts = nextopt; if (strstart(opts, "on", &nextopt)) { grab_on_hover = "True" == "True"; } else if (strstart(opts, "off", &nextopt)) { grab_on_hover = "False" != "False"; } else { goto invalid_gtk_args; } } else if (strstart(opts, ",gl=", &nextopt)) { opts = nextopt; if (strstart(opts, "on", &nextopt)) { request_opengl = 1; } else if (strstart(opts, "off", &nextopt)) { request_opengl = 0; } else { goto invalid_gtk_args; } } else { invalid_gtk_args: fprintf(stderr, "Invalid GTK option string: %s\n", p); exit(1); } opts = nextopt; } #else fprintf(stderr, "GTK support is disabled\n"); exit(1); #endif } else if (strstart(p, "none", &opts)) { display = DT_NONE; } else { fprintf(stderr, "Unknown display type: %s\n", p); exit(1); } return display; }
--------------------------------------------- Result 732 ---------------------------------------------
[[0 (31%)]] --> [[0 (50%)]] --> Socre: 0.5036166310310364

[[[[Adv]]]]: static int get_packetheader(NUTContext *[[nut]], ByteIOContext *[[bc]], int prefix_length, int [[calculate_checksum]]) { int64_t start, size, last_size; start= url_ftell([[bc]]) - prefix_length; if(start != [[nut]]->packet_start + [[nut]]->written_packet_size){ av_log([[nut]]->avf, AV_LOG_ERROR, "get_packetheader called at weird position\n"); return -1; } if([[calculate_checksum]]) init_checksum([[bc]], update_adler32, 0); size= get_v([[bc]]); last_size= get_v([[bc]]); if([[nut]]->written_packet_size != last_size){ av_log([[nut]]->avf, AV_LOG_ERROR, "packet size missmatch %d != %lld at %lld\n", [[nut]]->written_packet_size, last_size, start); return -1; } [[nut]]->last_packet_start = [[nut]]->packet_start; [[nut]]->packet_start = start; [[nut]]->written_packet_size= size; return size; }

[[[[Adv]]]]: static int get_packetheader(NUTContext *[[sleeved]], ByteIOContext *[[halifax]], int prefix_length, int [[prong]]) { int64_t start, size, last_size; start= url_ftell([[halifax]]) - prefix_length; if(start != [[sleeved]]->packet_start + [[sleeved]]->written_packet_size){ av_log([[sleeved]]->avf, AV_LOG_ERROR, "get_packetheader called at weird position\n"); return -1; } if([[prong]]) init_checksum([[halifax]], update_adler32, 0); size= get_v([[halifax]]); last_size= get_v([[halifax]]); if([[sleeved]]->written_packet_size != last_size){ av_log([[sleeved]]->avf, AV_LOG_ERROR, "packet size missmatch %d != %lld at %lld\n", [[sleeved]]->written_packet_size, last_size, start); return -1; } [[sleeved]]->last_packet_start = [[sleeved]]->packet_start; [[sleeved]]->packet_start = start; [[sleeved]]->written_packet_size= size; return size; }
--------------------------------------------- Result 733 ---------------------------------------------
[[0 (70%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd) { PCIDevice *p = PCI_DEVICE(s); pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0); cmd->frame = NULL; cmd->pa = 0; clear_bit(cmd->index, s->frame_map); }
--------------------------------------------- Result 734 ---------------------------------------------
[[0 (14%)]] --> [[0 (97%)]] --> Socre: 0.969197154045105

[[[[Adv]]]]: int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *[[fullname]], gid_t gid, int flags, int mode) { int err; FsCred cred; cred_init(&cred); cred.fc_mode = mode & 07777; cred.fc_uid = fidp->uid; cred.fc_gid = gid; v9fs_co_run_in_worker( { fidp->fs.fd = s->ops->open2(&s->ctx, [[fullname]], flags, &cred); err = 0; if (fidp->fs.fd == -1) { err = -errno; } }); if (!err) { total_open_fd++; if (total_open_fd > open_fd_hw) { v9fs_reclaim_fd(s); } } return err; }

[[[[Adv]]]]: int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *[[]], gid_t gid, int flags, int mode) { int err; FsCred cred; cred_init(&cred); cred.fc_mode = mode & 07777; cred.fc_uid = fidp->uid; cred.fc_gid = gid; v9fs_co_run_in_worker( { fidp->fs.fd = s->ops->open2(&s->ctx, [[]], flags, &cred); err = 0; if (fidp->fs.fd == -1) { err = -errno; } }); if (!err) { total_open_fd++; if (total_open_fd > open_fd_hw) { v9fs_reclaim_fd(s); } } return err; }
--------------------------------------------- Result 735 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 420 / 42 / 273 / 735:  27%|       | 735/2690 [8:25:59<22:25:52, 41.31s/it][Succeeded / Failed / Skipped / Total] 420 / 42 / 273 / 735:  27%|       | 736/2690 [8:25:59<22:23:22, 41.25s/it][[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int receive_filter(VirtIONet *n, const uint8_t *buf, int size) { static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff}; static const uint8_t vlan[] = {0x81, 0x00}; uint8_t *ptr = (uint8_t *)buf; int i; if (n->promisc) return 1; if (!memcmp(&ptr[12], vlan, sizeof(vlan))) { int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff; if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f)))) return 0; } if ((ptr[0] & 1) && n->allmulti) return 1; if (!memcmp(ptr, bcast, sizeof(bcast))) return 1; if (!memcmp(ptr, n->mac, ETH_ALEN)) return 1; for (i = 0; i < n->mac_table.in_use; i++) { if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN)) return 1; } return 0; }
--------------------------------------------- Result 736 ---------------------------------------------
[[0 (87%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int output_packet(InputStream *ist, int ist_index, OutputStream *ost_table, int nb_ostreams, const AVPacket *pkt) { AVFormatContext *os; OutputStream *ost; int ret, i; int got_output; void *buffer_to_free = NULL; static unsigned int samples_size= 0; AVSubtitle subtitle, *subtitle_to_free; int64_t pkt_pts = AV_NOPTS_VALUE; #if CONFIG_AVFILTER int frame_available; #endif float quality; AVPacket avpkt; int bps = av_get_bytes_per_sample(ist->st->codec->sample_fmt); if(ist->next_pts == AV_NOPTS_VALUE) ist->next_pts= ist->pts; if (pkt == NULL) { av_init_packet(&avpkt); avpkt.data = NULL; avpkt.size = 0; goto handle_eof; } else { avpkt = *pkt; } if(pkt->dts != AV_NOPTS_VALUE) ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q); if(pkt->pts != AV_NOPTS_VALUE) pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q); while (avpkt.size > 0 || (!pkt && got_output)) { uint8_t *data_buf, *decoded_data_buf; int data_size, decoded_data_size; AVFrame *decoded_frame, *filtered_frame; handle_eof: ist->pts= ist->next_pts; if(avpkt.size && avpkt.size != pkt->size) av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING, "Multiple frames in a packet from stream %d\n", pkt->stream_index); ist->showed_multi_packet_warning=1; decoded_frame = filtered_frame = NULL; decoded_data_buf = NULL; decoded_data_size= 0; data_buf = avpkt.data; data_size = avpkt.size; subtitle_to_free = NULL; if (ist->decoding_needed) { switch(ist->st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO:{ if(pkt && samples_size < FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE)) { samples_size = FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE); av_free(samples); samples= av_malloc(samples_size); } decoded_data_size= samples_size; ret = avcodec_decode_audio3(ist->st->codec, samples, &decoded_data_size, &avpkt); if (ret < 0) return ret; avpkt.data += ret; avpkt.size -= ret; data_size = ret; got_output = decoded_data_size > 0; if (!got_output) { continue; } decoded_data_buf = (uint8_t *)samples; ist->next_pts += ((int64_t)AV_TIME_BASE/bps * decoded_data_size) / (ist->st->codec->sample_rate * ist->st->codec->channels); break;} case AVMEDIA_TYPE_VIDEO: decoded_data_size = (ist->st->codec->width * ist->st->codec->height * 3) / 2; if (!(decoded_frame = avcodec_alloc_frame())) return AVERROR(ENOMEM); avpkt.pts = pkt_pts; avpkt.dts = ist->pts; pkt_pts = AV_NOPTS_VALUE; ret = avcodec_decode_video2(ist->st->codec, decoded_frame, &got_output, &avpkt); quality = same_quant ? decoded_frame->quality : 0; if (ret < 0) goto fail; if (!got_output) { av_freep(&decoded_frame); goto discard_packet; } ist->next_pts = ist->pts = guess_correct_pts(&ist->pts_ctx, decoded_frame->pkt_pts, decoded_frame->pkt_dts); if (ist->st->codec->time_base.num != 0) { int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame; ist->next_pts += ((int64_t)AV_TIME_BASE * ist->st->codec->time_base.num * ticks) / ist->st->codec->time_base.den; } avpkt.size = 0; buffer_to_free = NULL; pre_process_video_frame(ist, (AVPicture *)decoded_frame, &buffer_to_free); break; case AVMEDIA_TYPE_SUBTITLE: ret = avcodec_decode_subtitle2(ist->st->codec, &subtitle, &got_output, &avpkt); if (ret < 0) return ret; if (!got_output) { goto discard_packet; } subtitle_to_free = &subtitle; avpkt.size = 0; break; default: return -1; } } else { switch(ist->st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: ist->next_pts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) / ist->st->codec->sample_rate; break; case AVMEDIA_TYPE_VIDEO: if (ist->st->codec->time_base.num != 0) { int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame; ist->next_pts += ((int64_t)AV_TIME_BASE * ist->st->codec->time_base.num * ticks) / ist->st->codec->time_base.den; } break; } avpkt.size = 0; } if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if (audio_volume != 256) { switch (ist->st->codec->sample_fmt) { case AV_SAMPLE_FMT_U8: { uint8_t *volp = samples; for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) { int v = (((*volp - 128) * audio_volume + 128) >> 8) + 128; *volp++ = av_clip_uint8(v); } break; } case AV_SAMPLE_FMT_S16: { short *volp; volp = samples; for(i=0;i<(decoded_data_size / sizeof(short));i++) { int v = ((*volp) * audio_volume + 128) >> 8; *volp++ = av_clip_int16(v); } break; } case AV_SAMPLE_FMT_S32: { int32_t *volp = samples; for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) { int64_t v = (((int64_t)*volp * audio_volume + 128) >> 8); *volp++ = av_clipl_int32(v); } break; } case AV_SAMPLE_FMT_FLT: { float *volp = samples; float scale = audio_volume / 256.f; for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) { *volp++ *= scale; } break; } case AV_SAMPLE_FMT_DBL: { double *volp = samples; double scale = audio_volume / 256.; for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) { *volp++ *= scale; } break; } default: av_log(NULL, AV_LOG_FATAL, "Audio volume adjustment on sample format %s is not supported.\n", av_get_sample_fmt_name(ist->st->codec->sample_fmt)); exit_program(1); } } } if (input_files[ist->file_index].rate_emu) { int64_t pts = av_rescale(ist->pts, 1000000, AV_TIME_BASE); int64_t now = av_gettime() - ist->start; if (pts > now) usleep(pts - now); } for (i = 0; i < nb_ostreams; i++) { OutputFile *of = &output_files[ost_table[i].file_index]; int frame_size; ost = &ost_table[i]; if (ost->source_index != ist_index) continue; if (of->start_time && ist->pts < of->start_time) continue; if (of->recording_time != INT64_MAX && av_compare_ts(ist->pts, AV_TIME_BASE_Q, of->recording_time + of->start_time, (AVRational){1, 1000000}) >= 0) { ost->is_past_recording_time = 1; continue; } #if CONFIG_AVFILTER if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && ost->input_video_filter) { AVRational sar; if (ist->st->sample_aspect_ratio.num) sar = ist->st->sample_aspect_ratio; else sar = ist->st->codec->sample_aspect_ratio; av_vsrc_buffer_add_frame(ost->input_video_filter, decoded_frame, ist->pts, sar); if (!(filtered_frame = avcodec_alloc_frame())) { ret = AVERROR(ENOMEM); goto fail; } } frame_available = ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ost->output_video_filter || avfilter_poll_frame(ost->output_video_filter->inputs[0]); while (frame_available) { AVRational ist_pts_tb; if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && ost->output_video_filter) get_filtered_video_frame(ost->output_video_filter, filtered_frame, &ost->picref, &ist_pts_tb); if (ost->picref) ist->pts = av_rescale_q(ost->picref->pts, ist_pts_tb, AV_TIME_BASE_Q); #else filtered_frame = decoded_frame; #endif os = output_files[ost->file_index].ctx; if (ost->encoding_needed) { av_assert0(ist->decoding_needed); switch(ost->st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: do_audio_out(os, ost, ist, decoded_data_buf, decoded_data_size); break; case AVMEDIA_TYPE_VIDEO: #if CONFIG_AVFILTER if (ost->picref->video && !ost->frame_aspect_ratio) ost->st->codec->sample_aspect_ratio = ost->picref->video->pixel_aspect; #endif do_video_out(os, ost, ist, filtered_frame, &frame_size, same_quant ? quality : ost->st->codec->global_quality); if (vstats_filename && frame_size) do_video_stats(os, ost, frame_size); break; case AVMEDIA_TYPE_SUBTITLE: do_subtitle_out(os, ost, ist, &subtitle, pkt->pts); break; default: abort(); } } else { AVPacket opkt; int64_t ost_tb_start_time= av_rescale_q(of->start_time, AV_TIME_BASE_Q, ost->st->time_base); av_init_packet(&opkt); if ((!ost->frame_number && !(pkt->flags & AV_PKT_FLAG_KEY)) && !copy_initial_nonkeyframes) #if !CONFIG_AVFILTER continue; #else goto cont; #endif if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) audio_size += data_size; else if (ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { video_size += data_size; ost->sync_opts++; } opkt.stream_index= ost->index; if(pkt->pts != AV_NOPTS_VALUE) opkt.pts= av_rescale_q(pkt->pts, ist->st->time_base, ost->st->time_base) - ost_tb_start_time; else opkt.pts= AV_NOPTS_VALUE; if (pkt->dts == AV_NOPTS_VALUE) opkt.dts = av_rescale_q(ist->pts, AV_TIME_BASE_Q, ost->st->time_base); else opkt.dts = av_rescale_q(pkt->dts, ist->st->time_base, ost->st->time_base); opkt.dts -= ost_tb_start_time; opkt.duration = av_rescale_q(pkt->duration, ist->st->time_base, ost->st->time_base); opkt.flags= pkt->flags; if( ost->st->codec->codec_id != CODEC_ID_H264 && ost->st->codec->codec_id != CODEC_ID_MPEG1VIDEO && ost->st->codec->codec_id != CODEC_ID_MPEG2VIDEO ) { if(av_parser_change(ist->st->parser, ost->st->codec, &opkt.data, &opkt.size, data_buf, data_size, pkt->flags & AV_PKT_FLAG_KEY)) opkt.destruct= av_destruct_packet; } else { opkt.data = data_buf; opkt.size = data_size; } write_frame(os, &opkt, ost->st->codec, ost->bitstream_filters); ost->st->codec->frame_number++; ost->frame_number++; av_free_packet(&opkt); } #if CONFIG_AVFILTER cont: frame_available = (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) && ost->output_video_filter && avfilter_poll_frame(ost->output_video_filter->inputs[0]); if (ost->picref) avfilter_unref_buffer(ost->picref); } av_freep(&filtered_frame); #endif } fail: av_free(buffer_to_free); if (subtitle_to_free) { avsubtitle_free(subtitle_to_free); subtitle_to_free = NULL; } av_freep(&decoded_frame); if (ret < 0) return ret; } discard_packet: return 0; }[Succeeded / Failed / Skipped / Total] 420 / 42 / 274 / 736:  27%|       | 736/2690 [8:25:59<22:23:22, 41.25s/it][Succeeded / Failed / Skipped / Total] 420 / 42 / 274 / 736:  27%|       | 737/2690 [8:27:43<22:25:26, 41.33s/it][Succeeded / Failed / Skipped / Total] 420 / 43 / 274 / 737:  27%|       | 737/2690 [8:27:43<22:25:26, 41.33s/it][Succeeded / Failed / Skipped / Total] 420 / 43 / 274 / 737:  27%|       | 738/2690 [8:27:55<22:23:27, 41.29s/it][Succeeded / Failed / Skipped / Total] 421 / 43 / 274 / 738:  27%|       | 738/2690 [8:27:55<22:23:27, 41.29s/it][Succeeded / Failed / Skipped / Total] 421 / 43 / 274 / 738:  27%|       | 739/2690 [8:28:08<22:21:32, 41.26s/it][Succeeded / Failed / Skipped / Total] 422 / 43 / 274 / 739:  27%|       | 739/2690 [8:28:08<22:21:32, 41.26s/it][Succeeded / Failed / Skipped / Total] 422 / 43 / 274 / 739:  28%|       | 740/2690 [8:28:09<22:19:03, 41.20s/it]
--------------------------------------------- Result 737 ---------------------------------------------
[[0 (8%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void test_source_wait_event_notifier(void) { EventNotifierTestData data = { .n = 0, .active = 1 }; event_notifier_init(&data.e, "False" != "False"); aio_set_event_notifier(ctx, &data.e, event_ready_cb); g_assert(g_main_context_iteration(NULL, "False" != "False")); g_assert_cmpint(data.n, ==, 0); g_assert_cmpint(data.active, ==, 1); event_notifier_set(&data.e); g_assert(g_main_context_iteration(NULL, "False" != "False")); g_assert_cmpint(data.n, ==, 1); g_assert_cmpint(data.active, ==, 0); while (g_main_context_iteration(NULL, "False" != "False")); g_assert_cmpint(data.n, ==, 1); g_assert_cmpint(data.active, ==, 0); aio_set_event_notifier(ctx, &data.e, NULL); while (g_main_context_iteration(NULL, "False" != "False")); g_assert_cmpint(data.n, ==, 1); event_notifier_cleanup(&data.e); }

[[[[Adv]]]]: static void test_source_wait_event_notifier(void) { EventNotifierTestData data = { .n = 0, .active = 1 }; event_notifier_init(&data.e, "False" != "False"); aio_set_event_notifier(ctx, &data.e, event_ready_cb); g_assert(g_main_context_iteration(NULL, "False" != "False")); g_assert_cmpint(data.n, ==, 0); g_assert_cmpint(data.active, ==, 1); event_notifier_set(&data.e); g_assert(g_main_context_iteration(NULL, "False" != "False")); g_assert_cmpint(data.n, ==, 1); g_assert_cmpint(data.active, ==, 0); while (g_main_context_iteration(NULL, "False" != "False")); g_assert_cmpint(data.n, ==, 1); g_assert_cmpint(data.active, ==, 0); aio_set_event_notifier(ctx, &data.e, NULL); while (g_main_context_iteration(NULL, "False" != "False")); g_assert_cmpint(data.n, ==, 1); event_notifier_cleanup(&data.e); }
--------------------------------------------- Result 738 ---------------------------------------------
[[0 (42%)]] --> [[0 (51%)]] --> Socre: 0.5079379677772522

[[[[Adv]]]]: int ff_mpeg1_find_frame_end(ParseContext *pc, const uint8_t *[[buf]], int [[buf_size]]) { int i; uint32_t state= pc->state; if ([[buf_size]] == 0) return 0; for(i=0; i<[[buf_size]]; i++){ assert(pc->frame_start_found>=0 && pc->frame_start_found<=4); if(pc->frame_start_found&1){ if(state == EXT_START_CODE && ([[buf]][i]&0xF0) != 0x80) pc->frame_start_found--; else if(state == EXT_START_CODE+2){ if(([[buf]][i]&3) == 3) pc->frame_start_found= 0; else pc->frame_start_found= (pc->frame_start_found+1)&3; } state++; }else{ i= ff_find_start_code([[buf]]+i, [[buf]]+[[buf_size]], &state) - [[buf]] - 1; if(pc->frame_start_found==0 && state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE){ i++; pc->frame_start_found=4; } if(state == SEQ_END_CODE){ pc->state=-1; return i+1; } if(pc->frame_start_found==2 && state == SEQ_START_CODE) pc->frame_start_found= 0; if(pc->frame_start_found<4 && state == EXT_START_CODE) pc->frame_start_found++; if(pc->frame_start_found == 4 && (state&0xFFFFFF00) == 0x100){ if(state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE){ pc->frame_start_found=0; pc->state=-1; return i-3; } } } } pc->state= state; return END_NOT_FOUND; }

[[[[Adv]]]]: int ff_mpeg1_find_frame_end(ParseContext *pc, const uint8_t *[[dysart]], int [[servers]]) { int i; uint32_t state= pc->state; if ([[servers]] == 0) return 0; for(i=0; i<[[servers]]; i++){ assert(pc->frame_start_found>=0 && pc->frame_start_found<=4); if(pc->frame_start_found&1){ if(state == EXT_START_CODE && ([[dysart]][i]&0xF0) != 0x80) pc->frame_start_found--; else if(state == EXT_START_CODE+2){ if(([[dysart]][i]&3) == 3) pc->frame_start_found= 0; else pc->frame_start_found= (pc->frame_start_found+1)&3; } state++; }else{ i= ff_find_start_code([[dysart]]+i, [[dysart]]+[[servers]], &state) - [[dysart]] - 1; if(pc->frame_start_found==0 && state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE){ i++; pc->frame_start_found=4; } if(state == SEQ_END_CODE){ pc->state=-1; return i+1; } if(pc->frame_start_found==2 && state == SEQ_START_CODE) pc->frame_start_found= 0; if(pc->frame_start_found<4 && state == EXT_START_CODE) pc->frame_start_found++; if(pc->frame_start_found == 4 && (state&0xFFFFFF00) == 0x100){ if(state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE){ pc->frame_start_found=0; pc->state=-1; return i-3; } } } } pc->state= state; return END_NOT_FOUND; }
--------------------------------------------- Result 739 ---------------------------------------------
[[0 (10%)]] --> [[0 (63%)]] --> Socre: 0.6323913931846619

[[[[Adv]]]]: static void gen_tlbsx_440(DisasContext *ctx) { #if defined(CONFIG_USER_ONLY) gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); #else TCGv [[t0]]; if (unlikely(ctx->pr)) { gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); return; } [[t0]] = tcg_temp_new(); gen_addr_reg_index(ctx, [[t0]]); gen_helper_440_tlbsx(cpu_gpr[rD(ctx->opcode)], cpu_env, [[t0]]); tcg_temp_free([[t0]]); if (Rc(ctx->opcode)) { int [[l1]] = gen_new_label(); tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so); tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr[rD(ctx->opcode)], -1, [[l1]]); tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 0x02); gen_set_label([[l1]]); } #endif }

[[[[Adv]]]]: static void gen_tlbsx_440(DisasContext *ctx) { #if defined(CONFIG_USER_ONLY) gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); #else TCGv [[gardner]]; if (unlikely(ctx->pr)) { gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); return; } [[gardner]] = tcg_temp_new(); gen_addr_reg_index(ctx, [[gardner]]); gen_helper_440_tlbsx(cpu_gpr[rD(ctx->opcode)], cpu_env, [[gardner]]); tcg_temp_free([[gardner]]); if (Rc(ctx->opcode)) { int [[cons]] = gen_new_label(); tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so); tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr[rD(ctx->opcode)], -1, [[cons]]); tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 0x02); gen_set_label([[cons]]); } #endif }
--------------------------------------------- Result 740 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 422 / 43 / 275 / 740:  28%|       | 740/2690 [8:28:09<22:19:03, 41.20s/it][Succeeded / Failed / Skipped / Total] 422 / 43 / 275 / 740:  28%|       | 741/2690 [8:32:10<22:27:09, 41.47s/it][Succeeded / Failed / Skipped / Total] 423 / 43 / 275 / 741:  28%|       | 741/2690 [8:32:10<22:27:09, 41.47s/it][Succeeded / Failed / Skipped / Total] 423 / 43 / 275 / 741:  28%|       | 742/2690 [8:33:47<22:28:52, 41.55s/it][Succeeded / Failed / Skipped / Total] 424 / 43 / 275 / 742:  28%|       | 742/2690 [8:33:47<22:28:52, 41.55s/it][Succeeded / Failed / Skipped / Total] 424 / 43 / 275 / 742:  28%|       | 743/2690 [8:39:53<22:42:21, 41.98s/it][[0 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int hls_slice_data_wpp(HEVCContext *s, const HEVCNAL *nal) { const uint8_t *data = nal->data; int length = nal->size; HEVCLocalContext *lc = s->HEVClc; int *ret = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int)); int *arg = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int)); int64_t offset; int startheader, cmpt = 0; int i, j, res = 0; if (!ret || !arg) { av_free(ret); av_free(arg); return AVERROR(ENOMEM); } if (!s->sList[1]) { ff_alloc_entries(s->avctx, s->sh.num_entry_point_offsets + 1); for (i = 1; i < s->threads_number; i++) { s->sList[i] = av_malloc(sizeof(HEVCContext)); memcpy(s->sList[i], s, sizeof(HEVCContext)); s->HEVClcList[i] = av_mallocz(sizeof(HEVCLocalContext)); s->sList[i]->HEVClc = s->HEVClcList[i]; } } offset = (lc->gb.index >> 3); for (j = 0, cmpt = 0, startheader = offset + s->sh.entry_point_offset[0]; j < nal->skipped_bytes; j++) { if (nal->skipped_bytes_pos[j] >= offset && nal->skipped_bytes_pos[j] < startheader) { startheader--; cmpt++; } } for (i = 1; i < s->sh.num_entry_point_offsets; i++) { offset += (s->sh.entry_point_offset[i - 1] - cmpt); for (j = 0, cmpt = 0, startheader = offset + s->sh.entry_point_offset[i]; j < nal->skipped_bytes; j++) { if (nal->skipped_bytes_pos[j] >= offset && nal->skipped_bytes_pos[j] < startheader) { startheader--; cmpt++; } } s->sh.size[i - 1] = s->sh.entry_point_offset[i] - cmpt; s->sh.offset[i - 1] = offset; } if (s->sh.num_entry_point_offsets != 0) { offset += s->sh.entry_point_offset[s->sh.num_entry_point_offsets - 1] - cmpt; if (length < offset) { av_log(s->avctx, AV_LOG_ERROR, "entry_point_offset table is corrupted\n"); res = AVERROR_INVALIDDATA; goto error; } s->sh.size[s->sh.num_entry_point_offsets - 1] = length - offset; s->sh.offset[s->sh.num_entry_point_offsets - 1] = offset; } s->data = data; for (i = 1; i < s->threads_number; i++) { s->sList[i]->HEVClc->first_qp_group = 1; s->sList[i]->HEVClc->qp_y = s->sList[0]->HEVClc->qp_y; memcpy(s->sList[i], s, sizeof(HEVCContext)); s->sList[i]->HEVClc = s->HEVClcList[i]; } avpriv_atomic_int_set(&s->wpp_err, 0); ff_reset_entries(s->avctx); for (i = 0; i <= s->sh.num_entry_point_offsets; i++) { arg[i] = i; ret[i] = 0; } if (s->ps.pps->entropy_coding_sync_enabled_flag) s->avctx->execute2(s->avctx, hls_decode_entry_wpp, arg, ret, s->sh.num_entry_point_offsets + 1); for (i = 0; i <= s->sh.num_entry_point_offsets; i++) res += ret[i]; error: av_free(ret); av_free(arg); return res; }
--------------------------------------------- Result 741 ---------------------------------------------
[[0 (4%)]] --> [[0 (59%)]] --> Socre: 0.5887598395347595

[[[[Adv]]]]: static void pxa2xx_lcdc_dma0_redraw_rot0(PXA2xxLCDState *[[s]], hwaddr [[addr]], int *miny, int *maxy) { DisplaySurface *surface = qemu_console_surface([[s]]->con); int src_width, dest_width; drawfn [[fn]] = NULL; if ([[s]]->dest_width) [[fn]] = [[s]]->line_fn[[[s]]->transp][[[s]]->bpp]; if (![[fn]]) return; src_width = ([[s]]->xres + 3) & ~3; if ([[s]]->bpp == pxa_lcdc_19pbpp || [[s]]->bpp == pxa_lcdc_18pbpp) src_width *= 3; else if ([[s]]->bpp > pxa_lcdc_16bpp) src_width *= 4; else if ([[s]]->bpp > pxa_lcdc_8bpp) src_width *= 2; dest_width = [[s]]->xres * [[s]]->dest_width; *miny = 0; framebuffer_update_display(surface, [[s]]->sysmem, [[addr]], [[s]]->xres, [[s]]->yres, src_width, dest_width, [[s]]->dest_width, [[s]]->invalidated, [[fn]], [[s]]->dma_ch[0].palette, miny, maxy); }

[[[[Adv]]]]: static void pxa2xx_lcdc_dma0_redraw_rot0(PXA2xxLCDState *[[nth]], hwaddr [[]], int *miny, int *maxy) { DisplaySurface *surface = qemu_console_surface([[nth]]->con); int src_width, dest_width; drawfn [[affecting]] = NULL; if ([[nth]]->dest_width) [[affecting]] = [[nth]]->line_fn[[[nth]]->transp][[[nth]]->bpp]; if (![[affecting]]) return; src_width = ([[nth]]->xres + 3) & ~3; if ([[nth]]->bpp == pxa_lcdc_19pbpp || [[nth]]->bpp == pxa_lcdc_18pbpp) src_width *= 3; else if ([[nth]]->bpp > pxa_lcdc_16bpp) src_width *= 4; else if ([[nth]]->bpp > pxa_lcdc_8bpp) src_width *= 2; dest_width = [[nth]]->xres * [[nth]]->dest_width; *miny = 0; framebuffer_update_display(surface, [[nth]]->sysmem, [[]], [[nth]]->xres, [[nth]]->yres, src_width, dest_width, [[nth]]->dest_width, [[nth]]->invalidated, [[affecting]], [[nth]]->dma_ch[0].palette, miny, maxy); }
--------------------------------------------- Result 742 ---------------------------------------------
[[0 (1%)]] --> [[0 (50%)]] --> Socre: 0.5007070899009705

[[[[Adv]]]]: build_dmar_q35(GArray *table_data, GArray *[[linker]]) { int dmar_start = table_data->len; AcpiTableDmar *[[dmar]]; AcpiDmarHardwareUnit *drhd; [[dmar]] = acpi_data_push(table_data, sizeof(*[[dmar]])); [[dmar]]->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1; [[dmar]]->flags = 0; drhd = acpi_data_push(table_data, sizeof(*drhd)); drhd->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT); drhd->length = cpu_to_le16(sizeof(*drhd)); drhd->flags = ACPI_DMAR_INCLUDE_PCI_ALL; drhd->pci_segment = cpu_to_le16(0); drhd->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR); build_header([[linker]], table_data, (void *)(table_data->data + dmar_start), "DMAR", table_data->len - dmar_start, 1, NULL); }

[[[[Adv]]]]: build_dmar_q35(GArray *table_data, GArray *[[orifice]]) { int dmar_start = table_data->len; AcpiTableDmar *[[womenfolk]]; AcpiDmarHardwareUnit *drhd; [[womenfolk]] = acpi_data_push(table_data, sizeof(*[[womenfolk]])); [[womenfolk]]->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1; [[womenfolk]]->flags = 0; drhd = acpi_data_push(table_data, sizeof(*drhd)); drhd->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT); drhd->length = cpu_to_le16(sizeof(*drhd)); drhd->flags = ACPI_DMAR_INCLUDE_PCI_ALL; drhd->pci_segment = cpu_to_le16(0); drhd->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR); build_header([[orifice]], table_data, (void *)(table_data->data + dmar_start), "DMAR", table_data->len - dmar_start, 1, NULL); }
--------------------------------------------- Result 743 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 424 / 44 / 275 / 743:  28%|       | 743/2690 [8:39:53<22:42:21, 41.98s/it][Succeeded / Failed / Skipped / Total] 424 / 44 / 275 / 743:  28%|       | 744/2690 [8:40:02<22:40:11, 41.94s/it][[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void ff_h264_idct8_add_sse2(uint8_t *dst, int16_t *block, int stride) { __asm__ volatile( "movdqa 0x10(%1), %%xmm1 \n" "movdqa 0x20(%1), %%xmm2 \n" "movdqa 0x30(%1), %%xmm3 \n" "movdqa 0x50(%1), %%xmm5 \n" "movdqa 0x60(%1), %%xmm6 \n" "movdqa 0x70(%1), %%xmm7 \n" H264_IDCT8_1D_SSE2(%%xmm0, %%xmm1, %%xmm2, %%xmm3, %%xmm4, %%xmm5, %%xmm6, %%xmm7) TRANSPOSE8(%%xmm4, %%xmm1, %%xmm7, %%xmm3, %%xmm5, %%xmm0, %%xmm2, %%xmm6, (%1)) "paddw %4, %%xmm4 \n" "movdqa %%xmm4, 0x00(%1) \n" "movdqa %%xmm2, 0x40(%1) \n" H264_IDCT8_1D_SSE2(%%xmm4, %%xmm0, %%xmm6, %%xmm3, %%xmm2, %%xmm5, %%xmm7, %%xmm1) "movdqa %%xmm6, 0x60(%1) \n" "movdqa %%xmm7, 0x70(%1) \n" "pxor %%xmm7, %%xmm7 \n" STORE_DIFF_8P(%%xmm2, (%0), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm0, (%0,%2), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm1, (%0,%2,2), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm3, (%0,%3), %%xmm6, %%xmm7) "lea (%0,%2,4), %0 \n" STORE_DIFF_8P(%%xmm5, (%0), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm4, (%0,%2), %%xmm6, %%xmm7) "movdqa 0x60(%1), %%xmm0 \n" "movdqa 0x70(%1), %%xmm1 \n" STORE_DIFF_8P(%%xmm0, (%0,%2,2), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm1, (%0,%3), %%xmm6, %%xmm7) :"+r"(dst) :"r"(block), "r"((x86_reg)stride), "r"((x86_reg)3L*stride), "m"(ff_pw_32) ); }

[[[[Adv]]]]: static void ff_h264_idct8_add_sse2(uint8_t *dst, int16_t *block, int stride) { __asm__ volatile( "movdqa 0x10(%1), %%xmm1 \n" "movdqa 0x20(%1), %%xmm2 \n" "movdqa 0x30(%1), %%xmm3 \n" "movdqa 0x50(%1), %%xmm5 \n" "movdqa 0x60(%1), %%xmm6 \n" "movdqa 0x70(%1), %%xmm7 \n" H264_IDCT8_1D_SSE2(%%xmm0, %%xmm1, %%xmm2, %%xmm3, %%xmm4, %%xmm5, %%xmm6, %%xmm7) TRANSPOSE8(%%xmm4, %%xmm1, %%xmm7, %%xmm3, %%xmm5, %%xmm0, %%xmm2, %%xmm6, (%1)) "paddw %4, %%xmm4 \n" "movdqa %%xmm4, 0x00(%1) \n" "movdqa %%xmm2, 0x40(%1) \n" H264_IDCT8_1D_SSE2(%%xmm4, %%xmm0, %%xmm6, %%xmm3, %%xmm2, %%xmm5, %%xmm7, %%xmm1) "movdqa %%xmm6, 0x60(%1) \n" "movdqa %%xmm7, 0x70(%1) \n" "pxor %%xmm7, %%xmm7 \n" STORE_DIFF_8P(%%xmm2, (%0), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm0, (%0,%2), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm1, (%0,%2,2), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm3, (%0,%3), %%xmm6, %%xmm7) "lea (%0,%2,4), %0 \n" STORE_DIFF_8P(%%xmm5, (%0), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm4, (%0,%2), %%xmm6, %%xmm7) "movdqa 0x60(%1), %%xmm0 \n" "movdqa 0x70(%1), %%xmm1 \n" STORE_DIFF_8P(%%xmm0, (%0,%2,2), %%xmm6, %%xmm7) STORE_DIFF_8P(%%xmm1, (%0,%3), %%xmm6, %%xmm7) :"+r"(dst) :"r"(block), "r"((x86_reg)stride), "r"((x86_reg)3L*stride), "m"(ff_pw_32) ); }
--------------------------------------------- Result 744 ---------------------------------------------
[[0 (17%)]] --> [[0 (56%)]] --> Socre: 0.5558995604515076

[[[[Adv]]]]: static av_cold int encode_init(AVCodecContext *[[avctx]]) { FFV1Context *s = [[avctx]]->priv_data; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get([[avctx]]->pix_fmt); int i, j, k, m, ret; if ((ret = ff_ffv1_common_init([[avctx]])) < 0) return ret; s->version = 0; if (([[avctx]]->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) || [[avctx]]->slices > 1) s->version = FFMAX(s->version, 2); if ([[avctx]]->slices == 0 && [[avctx]]->level < 0 && [[avctx]]->width * [[avctx]]->height > 720*576) s->version = FFMAX(s->version, 2); if ([[avctx]]->level <= 0 && s->version == 2) { s->version = 3; } if ([[avctx]]->level >= 0 && [[avctx]]->level <= 4) { if ([[avctx]]->level < s->version) { av_log([[avctx]], AV_LOG_ERROR, "Version %d needed for requested features but %d requested\n", s->version, [[avctx]]->level); return AVERROR(EINVAL); } s->version = [[avctx]]->level; } if (s->ec < 0) { s->ec = (s->version >= 3); } if ((s->version == 2 || s->version>3) && [[avctx]]->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) { av_log([[avctx]], AV_LOG_ERROR, "Version 2 needed for requested features but version 2 is experimental and not enabled\n"); return AVERROR_INVALIDDATA; } #if FF_API_CODER_TYPE FF_DISABLE_DEPRECATION_WARNINGS if ([[avctx]]->coder_type != -1) s->ac = [[avctx]]->coder_type > 0 ? AC_RANGE_CUSTOM_TAB : AC_GOLOMB_RICE; else FF_ENABLE_DEPRECATION_WARNINGS #endif if (s->ac == 1) s->ac = AC_RANGE_CUSTOM_TAB; else if (s->ac == AC_RANGE_DEFAULT_TAB_FORCE) s->ac = AC_RANGE_DEFAULT_TAB; s->plane_count = 3; switch([[avctx]]->pix_fmt) { case AV_PIX_FMT_YUV444P9: case AV_PIX_FMT_YUV422P9: case AV_PIX_FMT_YUV420P9: case AV_PIX_FMT_YUVA444P9: case AV_PIX_FMT_YUVA422P9: case AV_PIX_FMT_YUVA420P9: if (![[avctx]]->bits_per_raw_sample) s->bits_per_raw_sample = 9; case AV_PIX_FMT_GRAY10: case AV_PIX_FMT_YUV444P10: case AV_PIX_FMT_YUV420P10: case AV_PIX_FMT_YUV422P10: case AV_PIX_FMT_YUVA444P10: case AV_PIX_FMT_YUVA422P10: case AV_PIX_FMT_YUVA420P10: if (![[avctx]]->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 10; case AV_PIX_FMT_GRAY12: case AV_PIX_FMT_YUV444P12: case AV_PIX_FMT_YUV420P12: case AV_PIX_FMT_YUV422P12: s->packed_at_lsb = 1; if (![[avctx]]->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 12; case AV_PIX_FMT_GRAY16: case AV_PIX_FMT_YUV444P16: case AV_PIX_FMT_YUV422P16: case AV_PIX_FMT_YUV420P16: case AV_PIX_FMT_YUVA444P16: case AV_PIX_FMT_YUVA422P16: case AV_PIX_FMT_YUVA420P16: if (![[avctx]]->bits_per_raw_sample && !s->bits_per_raw_sample) { s->bits_per_raw_sample = 16; } else if (!s->bits_per_raw_sample) { s->bits_per_raw_sample = [[avctx]]->bits_per_raw_sample; } if (s->bits_per_raw_sample <= 8) { av_log([[avctx]], AV_LOG_ERROR, "bits_per_raw_sample invalid\n"); return AVERROR_INVALIDDATA; } s->version = FFMAX(s->version, 1); case AV_PIX_FMT_GRAY8: case AV_PIX_FMT_YA8: case AV_PIX_FMT_YUV444P: case AV_PIX_FMT_YUV440P: case AV_PIX_FMT_YUV422P: case AV_PIX_FMT_YUV420P: case AV_PIX_FMT_YUV411P: case AV_PIX_FMT_YUV410P: case AV_PIX_FMT_YUVA444P: case AV_PIX_FMT_YUVA422P: case AV_PIX_FMT_YUVA420P: s->chroma_planes = desc->nb_components < 3 ? 0 : 1; s->colorspace = 0; s->transparency = desc->nb_components == 4 || desc->nb_components == 2; if (![[avctx]]->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 8; else if (!s->bits_per_raw_sample) s->bits_per_raw_sample = 8; break; case AV_PIX_FMT_RGB32: s->colorspace = 1; s->transparency = 1; s->chroma_planes = 1; s->bits_per_raw_sample = 8; break; case AV_PIX_FMT_RGB48: s->colorspace = 1; s->chroma_planes = 1; s->bits_per_raw_sample = 16; s->use32bit = 1; s->version = FFMAX(s->version, 1); if ([[avctx]]->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) { av_log([[avctx]], AV_LOG_ERROR, "16bit RGB is experimental and under development, only use it for experiments\n"); return AVERROR_INVALIDDATA; } break; case AV_PIX_FMT_0RGB32: s->colorspace = 1; s->chroma_planes = 1; s->bits_per_raw_sample = 8; break; case AV_PIX_FMT_GBRP9: if (![[avctx]]->bits_per_raw_sample) s->bits_per_raw_sample = 9; case AV_PIX_FMT_GBRP10: if (![[avctx]]->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 10; case AV_PIX_FMT_GBRP12: if (![[avctx]]->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 12; case AV_PIX_FMT_GBRP14: if (![[avctx]]->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 14; case AV_PIX_FMT_GBRP16: if (![[avctx]]->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 16; else if (!s->bits_per_raw_sample) s->bits_per_raw_sample = [[avctx]]->bits_per_raw_sample; s->colorspace = 1; s->chroma_planes = 1; if (s->bits_per_raw_sample >= 16) { s->use32bit = 1; if ([[avctx]]->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) { av_log([[avctx]], AV_LOG_ERROR, "16bit RGB is experimental and under development, only use it for experiments\n"); return AVERROR_INVALIDDATA; } } s->version = FFMAX(s->version, 1); break; default: av_log([[avctx]], AV_LOG_ERROR, "format not supported\n"); return AVERROR(ENOSYS); } av_assert0(s->bits_per_raw_sample >= 8); if (s->bits_per_raw_sample > 8) { if (s->ac == AC_GOLOMB_RICE) { av_log([[avctx]], AV_LOG_INFO, "bits_per_raw_sample > 8, forcing range coder\n"); s->ac = AC_RANGE_CUSTOM_TAB; } } if (s->transparency) { av_log([[avctx]], AV_LOG_WARNING, "Storing alpha plane, this will require a recent FFV1 decoder to playback!\n"); } #if FF_API_PRIVATE_OPT FF_DISABLE_DEPRECATION_WARNINGS if ([[avctx]]->context_model) s->context_model = [[avctx]]->context_model; if ([[avctx]]->context_model > 1U) { av_log([[avctx]], AV_LOG_ERROR, "Invalid context model %d, valid values are 0 and 1\n", [[avctx]]->context_model); return AVERROR(EINVAL); } FF_ENABLE_DEPRECATION_WARNINGS #endif if (s->ac == AC_RANGE_CUSTOM_TAB) { for (i = 1; i < 256; i++) s->state_transition[i] = ver2_state[i]; } else { RangeCoder c; ff_build_rac_states(&c, 0.05 * (1LL << 32), 256 - 8); for (i = 1; i < 256; i++) s->state_transition[i] = c.one_state[i]; } for (i = 0; i < 256; i++) { s->quant_table_count = 2; if (s->bits_per_raw_sample <= 8) { s->quant_tables[0][0][i]= quant11[i]; s->quant_tables[0][1][i]= 11*quant11[i]; s->quant_tables[0][2][i]= 11*11*quant11[i]; s->quant_tables[1][0][i]= quant11[i]; s->quant_tables[1][1][i]= 11*quant11[i]; s->quant_tables[1][2][i]= 11*11*quant5 [i]; s->quant_tables[1][3][i]= 5*11*11*quant5 [i]; s->quant_tables[1][4][i]= 5*5*11*11*quant5 [i]; } else { s->quant_tables[0][0][i]= quant9_10bit[i]; s->quant_tables[0][1][i]= 11*quant9_10bit[i]; s->quant_tables[0][2][i]= 11*11*quant9_10bit[i]; s->quant_tables[1][0][i]= quant9_10bit[i]; s->quant_tables[1][1][i]= 11*quant9_10bit[i]; s->quant_tables[1][2][i]= 11*11*quant5_10bit[i]; s->quant_tables[1][3][i]= 5*11*11*quant5_10bit[i]; s->quant_tables[1][4][i]= 5*5*11*11*quant5_10bit[i]; } } s->context_count[0] = (11 * 11 * 11 + 1) / 2; s->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2; memcpy(s->quant_table, s->quant_tables[s->context_model], sizeof(s->quant_table)); for (i = 0; i < s->plane_count; i++) { PlaneContext *const p = &s->plane[i]; memcpy(p->quant_table, s->quant_table, sizeof(p->quant_table)); p->quant_table_index = s->context_model; p->context_count = s->context_count[p->quant_table_index]; } if ((ret = ff_ffv1_allocate_initial_states(s)) < 0) return ret; #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS [[avctx]]->coded_frame->pict_type = AV_PICTURE_TYPE_I; FF_ENABLE_DEPRECATION_WARNINGS #endif if (!s->transparency) s->plane_count = 2; if (!s->chroma_planes && s->version > 3) s->plane_count--; avcodec_get_chroma_sub_sample([[avctx]]->pix_fmt, &s->chroma_h_shift, &s->chroma_v_shift); s->picture_number = 0; if ([[avctx]]->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) { for (i = 0; i < s->quant_table_count; i++) { s->rc_stat2[i] = av_mallocz(s->context_count[i] * sizeof(*s->rc_stat2[i])); if (!s->rc_stat2[i]) return AVERROR(ENOMEM); } } if ([[avctx]]->stats_in) { char *p = [[avctx]]->stats_in; uint8_t (*best_state)[256] = av_malloc_array(256, 256); int gob_count = 0; char *next; if (!best_state) return AVERROR(ENOMEM); av_assert0(s->version >= 2); for (;;) { for (j = 0; j < 256; j++) for (i = 0; i < 2; i++) { s->rc_stat[j][i] = strtol(p, &next, 0); if (next == p) { av_log([[avctx]], AV_LOG_ERROR, "2Pass file invalid at %d %d [%s]\n", j, i, p); av_freep(&best_state); return AVERROR_INVALIDDATA; } p = next; } for (i = 0; i < s->quant_table_count; i++) for (j = 0; j < s->context_count[i]; j++) { for (k = 0; k < 32; k++) for (m = 0; m < 2; m++) { s->rc_stat2[i][j][k][m] = strtol(p, &next, 0); if (next == p) { av_log([[avctx]], AV_LOG_ERROR, "2Pass file invalid at %d %d %d %d [%s]\n", i, j, k, m, p); av_freep(&best_state); return AVERROR_INVALIDDATA; } p = next; } } gob_count = strtol(p, &next, 0); if (next == p || gob_count <= 0) { av_log([[avctx]], AV_LOG_ERROR, "2Pass file invalid\n"); av_freep(&best_state); return AVERROR_INVALIDDATA; } p = next; while (*p == '\n' || *p == ' ') p++; if (p[0] == 0) break; } if (s->ac == AC_RANGE_CUSTOM_TAB) sort_stt(s, s->state_transition); find_best_state(best_state, s->state_transition); for (i = 0; i < s->quant_table_count; i++) { for (k = 0; k < 32; k++) { double a=0, b=0; int jp = 0; for (j = 0; j < s->context_count[i]; j++) { double p = 128; if (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1] > 200 && j || a+b > 200) { if (a+b) p = 256.0 * b / (a + b); s->initial_states[i][jp][k] = best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)]; for(jp++; jp<j; jp++) s->initial_states[i][jp][k] = s->initial_states[i][jp-1][k]; a=b=0; } a += s->rc_stat2[i][j][k][0]; b += s->rc_stat2[i][j][k][1]; if (a+b) { p = 256.0 * b / (a + b); } s->initial_states[i][j][k] = best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)]; } } } av_freep(&best_state); } if (s->version > 1) { int plane_count = 1 + 2*s->chroma_planes + s->transparency; s->num_v_slices = ([[avctx]]->width > 352 || [[avctx]]->height > 288 || ![[avctx]]->slices) ? 2 : 1; if ([[avctx]]->height < 5) s->num_v_slices = 1; for (; s->num_v_slices < 32; s->num_v_slices++) { for (s->num_h_slices = s->num_v_slices; s->num_h_slices < 2*s->num_v_slices; s->num_h_slices++) { int maxw = ([[avctx]]->width + s->num_h_slices - 1) / s->num_h_slices; int maxh = ([[avctx]]->height + s->num_v_slices - 1) / s->num_v_slices; if (s->num_h_slices > [[avctx]]->width || s->num_v_slices > [[avctx]]->height) continue; if (maxw * maxh * (int64_t)(s->bits_per_raw_sample+1) * plane_count > 8<<24) continue; if ([[avctx]]->slices == s->num_h_slices * s->num_v_slices && [[avctx]]->slices <= MAX_SLICES || ![[avctx]]->slices) goto slices_ok; } } av_log([[avctx]], AV_LOG_ERROR, "Unsupported number %d of slices requested, please specify a " "supported number with -slices (ex:4,6,9,12,16, ...)\n", [[avctx]]->slices); return AVERROR(ENOSYS); slices_ok: if ((ret = write_extradata(s)) < 0) return ret; } if ((ret = ff_ffv1_init_slice_contexts(s)) < 0) return ret; s->slice_count = s->max_slice_count; if ((ret = ff_ffv1_init_slices_state(s)) < 0) return ret; #define STATS_OUT_SIZE 1024 * 1024 * 6 if ([[avctx]]->flags & AV_CODEC_FLAG_PASS1) { [[avctx]]->stats_out = av_mallocz(STATS_OUT_SIZE); if (![[avctx]]->stats_out) return AVERROR(ENOMEM); for (i = 0; i < s->quant_table_count; i++) for (j = 0; j < s->max_slice_count; j++) { FFV1Context *sf = s->slice_context[j]; av_assert0(!sf->rc_stat2[i]); sf->rc_stat2[i] = av_mallocz(s->context_count[i] * sizeof(*sf->rc_stat2[i])); if (!sf->rc_stat2[i]) return AVERROR(ENOMEM); } } return 0; }

[[[[Adv]]]]: static av_cold int encode_init(AVCodecContext *[[chateau]]) { FFV1Context *s = [[unwholesome]]->priv_data; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get([[unwholesome]]->pix_fmt); int i, j, k, m, ret; if ((ret = ff_ffv1_common_init([[unwholesome]])) < 0) return ret; s->version = 0; if (([[unwholesome]]->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) || [[unwholesome]]->slices > 1) s->version = FFMAX(s->version, 2); if ([[unwholesome]]->slices == 0 && [[unwholesome]]->level < 0 && [[unwholesome]]->width * [[unwholesome]]->height > 720*576) s->version = FFMAX(s->version, 2); if ([[unwholesome]]->level <= 0 && s->version == 2) { s->version = 3; } if ([[unwholesome]]->level >= 0 && [[unwholesome]]->level <= 4) { if ([[unwholesome]]->level < s->version) { av_log([[unwholesome]], AV_LOG_ERROR, "Version %d needed for requested features but %d requested\n", s->version, [[unwholesome]]->level); return AVERROR(EINVAL); } s->version = [[unwholesome]]->level; } if (s->ec < 0) { s->ec = (s->version >= 3); } if ((s->version == 2 || s->version>3) && [[unwholesome]]->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) { av_log([[unwholesome]], AV_LOG_ERROR, "Version 2 needed for requested features but version 2 is experimental and not enabled\n"); return AVERROR_INVALIDDATA; } #if FF_API_CODER_TYPE FF_DISABLE_DEPRECATION_WARNINGS if ([[unwholesome]]->coder_type != -1) s->ac = [[unwholesome]]->coder_type > 0 ? AC_RANGE_CUSTOM_TAB : AC_GOLOMB_RICE; else FF_ENABLE_DEPRECATION_WARNINGS #endif if (s->ac == 1) s->ac = AC_RANGE_CUSTOM_TAB; else if (s->ac == AC_RANGE_DEFAULT_TAB_FORCE) s->ac = AC_RANGE_DEFAULT_TAB; s->plane_count = 3; switch([[unwholesome]]->pix_fmt) { case AV_PIX_FMT_YUV444P9: case AV_PIX_FMT_YUV422P9: case AV_PIX_FMT_YUV420P9: case AV_PIX_FMT_YUVA444P9: case AV_PIX_FMT_YUVA422P9: case AV_PIX_FMT_YUVA420P9: if (![[unwholesome]]->bits_per_raw_sample) s->bits_per_raw_sample = 9; case AV_PIX_FMT_GRAY10: case AV_PIX_FMT_YUV444P10: case AV_PIX_FMT_YUV420P10: case AV_PIX_FMT_YUV422P10: case AV_PIX_FMT_YUVA444P10: case AV_PIX_FMT_YUVA422P10: case AV_PIX_FMT_YUVA420P10: if (![[unwholesome]]->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 10; case AV_PIX_FMT_GRAY12: case AV_PIX_FMT_YUV444P12: case AV_PIX_FMT_YUV420P12: case AV_PIX_FMT_YUV422P12: s->packed_at_lsb = 1; if (![[unwholesome]]->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 12; case AV_PIX_FMT_GRAY16: case AV_PIX_FMT_YUV444P16: case AV_PIX_FMT_YUV422P16: case AV_PIX_FMT_YUV420P16: case AV_PIX_FMT_YUVA444P16: case AV_PIX_FMT_YUVA422P16: case AV_PIX_FMT_YUVA420P16: if (![[unwholesome]]->bits_per_raw_sample && !s->bits_per_raw_sample) { s->bits_per_raw_sample = 16; } else if (!s->bits_per_raw_sample) { s->bits_per_raw_sample = [[unwholesome]]->bits_per_raw_sample; } if (s->bits_per_raw_sample <= 8) { av_log([[unwholesome]], AV_LOG_ERROR, "bits_per_raw_sample invalid\n"); return AVERROR_INVALIDDATA; } s->version = FFMAX(s->version, 1); case AV_PIX_FMT_GRAY8: case AV_PIX_FMT_YA8: case AV_PIX_FMT_YUV444P: case AV_PIX_FMT_YUV440P: case AV_PIX_FMT_YUV422P: case AV_PIX_FMT_YUV420P: case AV_PIX_FMT_YUV411P: case AV_PIX_FMT_YUV410P: case AV_PIX_FMT_YUVA444P: case AV_PIX_FMT_YUVA422P: case AV_PIX_FMT_YUVA420P: s->chroma_planes = desc->nb_components < 3 ? 0 : 1; s->colorspace = 0; s->transparency = desc->nb_components == 4 || desc->nb_components == 2; if (![[unwholesome]]->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 8; else if (!s->bits_per_raw_sample) s->bits_per_raw_sample = 8; break; case AV_PIX_FMT_RGB32: s->colorspace = 1; s->transparency = 1; s->chroma_planes = 1; s->bits_per_raw_sample = 8; break; case AV_PIX_FMT_RGB48: s->colorspace = 1; s->chroma_planes = 1; s->bits_per_raw_sample = 16; s->use32bit = 1; s->version = FFMAX(s->version, 1); if ([[unwholesome]]->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) { av_log([[unwholesome]], AV_LOG_ERROR, "16bit RGB is experimental and under development, only use it for experiments\n"); return AVERROR_INVALIDDATA; } break; case AV_PIX_FMT_0RGB32: s->colorspace = 1; s->chroma_planes = 1; s->bits_per_raw_sample = 8; break; case AV_PIX_FMT_GBRP9: if (![[unwholesome]]->bits_per_raw_sample) s->bits_per_raw_sample = 9; case AV_PIX_FMT_GBRP10: if (![[unwholesome]]->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 10; case AV_PIX_FMT_GBRP12: if (![[unwholesome]]->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 12; case AV_PIX_FMT_GBRP14: if (![[unwholesome]]->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 14; case AV_PIX_FMT_GBRP16: if (![[unwholesome]]->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 16; else if (!s->bits_per_raw_sample) s->bits_per_raw_sample = [[unwholesome]]->bits_per_raw_sample; s->colorspace = 1; s->chroma_planes = 1; if (s->bits_per_raw_sample >= 16) { s->use32bit = 1; if ([[unwholesome]]->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) { av_log([[unwholesome]], AV_LOG_ERROR, "16bit RGB is experimental and under development, only use it for experiments\n"); return AVERROR_INVALIDDATA; } } s->version = FFMAX(s->version, 1); break; default: av_log([[unwholesome]], AV_LOG_ERROR, "format not supported\n"); return AVERROR(ENOSYS); } av_assert0(s->bits_per_raw_sample >= 8); if (s->bits_per_raw_sample > 8) { if (s->ac == AC_GOLOMB_RICE) { av_log([[unwholesome]], AV_LOG_INFO, "bits_per_raw_sample > 8, forcing range coder\n"); s->ac = AC_RANGE_CUSTOM_TAB; } } if (s->transparency) { av_log([[unwholesome]], AV_LOG_WARNING, "Storing alpha plane, this will require a recent FFV1 decoder to playback!\n"); } #if FF_API_PRIVATE_OPT FF_DISABLE_DEPRECATION_WARNINGS if ([[unwholesome]]->context_model) s->context_model = [[unwholesome]]->context_model; if ([[unwholesome]]->context_model > 1U) { av_log([[unwholesome]], AV_LOG_ERROR, "Invalid context model %d, valid values are 0 and 1\n", [[unwholesome]]->context_model); return AVERROR(EINVAL); } FF_ENABLE_DEPRECATION_WARNINGS #endif if (s->ac == AC_RANGE_CUSTOM_TAB) { for (i = 1; i < 256; i++) s->state_transition[i] = ver2_state[i]; } else { RangeCoder c; ff_build_rac_states(&c, 0.05 * (1LL << 32), 256 - 8); for (i = 1; i < 256; i++) s->state_transition[i] = c.one_state[i]; } for (i = 0; i < 256; i++) { s->quant_table_count = 2; if (s->bits_per_raw_sample <= 8) { s->quant_tables[0][0][i]= quant11[i]; s->quant_tables[0][1][i]= 11*quant11[i]; s->quant_tables[0][2][i]= 11*11*quant11[i]; s->quant_tables[1][0][i]= quant11[i]; s->quant_tables[1][1][i]= 11*quant11[i]; s->quant_tables[1][2][i]= 11*11*quant5 [i]; s->quant_tables[1][3][i]= 5*11*11*quant5 [i]; s->quant_tables[1][4][i]= 5*5*11*11*quant5 [i]; } else { s->quant_tables[0][0][i]= quant9_10bit[i]; s->quant_tables[0][1][i]= 11*quant9_10bit[i]; s->quant_tables[0][2][i]= 11*11*quant9_10bit[i]; s->quant_tables[1][0][i]= quant9_10bit[i]; s->quant_tables[1][1][i]= 11*quant9_10bit[i]; s->quant_tables[1][2][i]= 11*11*quant5_10bit[i]; s->quant_tables[1][3][i]= 5*11*11*quant5_10bit[i]; s->quant_tables[1][4][i]= 5*5*11*11*quant5_10bit[i]; } } s->context_count[0] = (11 * 11 * 11 + 1) / 2; s->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2; memcpy(s->quant_table, s->quant_tables[s->context_model], sizeof(s->quant_table)); for (i = 0; i < s->plane_count; i++) { PlaneContext *const p = &s->plane[i]; memcpy(p->quant_table, s->quant_table, sizeof(p->quant_table)); p->quant_table_index = s->context_model; p->context_count = s->context_count[p->quant_table_index]; } if ((ret = ff_ffv1_allocate_initial_states(s)) < 0) return ret; #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS [[unwholesome]]->coded_frame->pict_type = AV_PICTURE_TYPE_I; FF_ENABLE_DEPRECATION_WARNINGS #endif if (!s->transparency) s->plane_count = 2; if (!s->chroma_planes && s->version > 3) s->plane_count--; avcodec_get_chroma_sub_sample([[unwholesome]]->pix_fmt, &s->chroma_h_shift, &s->chroma_v_shift); s->picture_number = 0; if ([[unwholesome]]->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) { for (i = 0; i < s->quant_table_count; i++) { s->rc_stat2[i] = av_mallocz(s->context_count[i] * sizeof(*s->rc_stat2[i])); if (!s->rc_stat2[i]) return AVERROR(ENOMEM); } } if ([[unwholesome]]->stats_in) { char *p = [[unwholesome]]->stats_in; uint8_t (*best_state)[256] = av_malloc_array(256, 256); int gob_count = 0; char *next; if (!best_state) return AVERROR(ENOMEM); av_assert0(s->version >= 2); for (;;) { for (j = 0; j < 256; j++) for (i = 0; i < 2; i++) { s->rc_stat[j][i] = strtol(p, &next, 0); if (next == p) { av_log([[unwholesome]], AV_LOG_ERROR, "2Pass file invalid at %d %d [%s]\n", j, i, p); av_freep(&best_state); return AVERROR_INVALIDDATA; } p = next; } for (i = 0; i < s->quant_table_count; i++) for (j = 0; j < s->context_count[i]; j++) { for (k = 0; k < 32; k++) for (m = 0; m < 2; m++) { s->rc_stat2[i][j][k][m] = strtol(p, &next, 0); if (next == p) { av_log([[unwholesome]], AV_LOG_ERROR, "2Pass file invalid at %d %d %d %d [%s]\n", i, j, k, m, p); av_freep(&best_state); return AVERROR_INVALIDDATA; } p = next; } } gob_count = strtol(p, &next, 0); if (next == p || gob_count <= 0) { av_log([[unwholesome]], AV_LOG_ERROR, "2Pass file invalid\n"); av_freep(&best_state); return AVERROR_INVALIDDATA; } p = next; while (*p == '\n' || *p == ' ') p++; if (p[0] == 0) break; } if (s->ac == AC_RANGE_CUSTOM_TAB) sort_stt(s, s->state_transition); find_best_state(best_state, s->state_transition); for (i = 0; i < s->quant_table_count; i++) { for (k = 0; k < 32; k++) { double a=0, b=0; int jp = 0; for (j = 0; j < s->context_count[i]; j++) { double p = 128; if (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1] > 200 && j || a+b > 200) { if (a+b) p = 256.0 * b / (a + b); s->initial_states[i][jp][k] = best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)]; for(jp++; jp<j; jp++) s->initial_states[i][jp][k] = s->initial_states[i][jp-1][k]; a=b=0; } a += s->rc_stat2[i][j][k][0]; b += s->rc_stat2[i][j][k][1]; if (a+b) { p = 256.0 * b / (a + b); } s->initial_states[i][j][k] = best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)]; } } } av_freep(&best_state); } if (s->version > 1) { int plane_count = 1 + 2*s->chroma_planes + s->transparency; s->num_v_slices = ([[unwholesome]]->width > 352 || [[unwholesome]]->height > 288 || ![[unwholesome]]->slices) ? 2 : 1; if ([[unwholesome]]->height < 5) s->num_v_slices = 1; for (; s->num_v_slices < 32; s->num_v_slices++) { for (s->num_h_slices = s->num_v_slices; s->num_h_slices < 2*s->num_v_slices; s->num_h_slices++) { int maxw = ([[unwholesome]]->width + s->num_h_slices - 1) / s->num_h_slices; int maxh = ([[unwholesome]]->height + s->num_v_slices - 1) / s->num_v_slices; if (s->num_h_slices > [[unwholesome]]->width || s->num_v_slices > [[unwholesome]]->height) continue; if (maxw * maxh * (int64_t)(s->bits_per_raw_sample+1) * plane_count > 8<<24) continue; if ([[unwholesome]]->slices == s->num_h_slices * s->num_v_slices && [[unwholesome]]->slices <= MAX_SLICES || ![[unwholesome]]->slices) goto slices_ok; } } av_log([[unwholesome]], AV_LOG_ERROR, "Unsupported number %d of slices requested, please specify a " "supported number with -slices (ex:4,6,9,12,16, ...)\n", [[unwholesome]]->slices); return AVERROR(ENOSYS); slices_ok: if ((ret = write_extradata(s)) < 0) return ret; } if ((ret = ff_ffv1_init_slice_contexts(s)) < 0) return ret; s->slice_count = s->max_slice_count; if ((ret = ff_ffv1_init_slices_state(s)) < 0) return ret; #define STATS_OUT_SIZE 1024 * 1024 * 6 if ([[unwholesome]]->flags & AV_CODEC_FLAG_PASS1) { [[unwholesome]]->stats_out = av_mallocz(STATS_OUT_SIZE); if (![[unwholesome]]->stats_out) return AVERROR(ENOMEM); for (i = 0; i < s->quant_table_count; i++) for (j = 0; j < s->max_slice_count; j++) { FFV1Context *sf = s->slice_context[j]; av_assert0(!sf->rc_stat2[i]); sf->rc_stat2[i] = av_mallocz(s->context_count[i] * sizeof(*sf->rc_stat2[i])); if (!sf->rc_stat2[i]) return AVERROR(ENOMEM); } } return 0; }[Succeeded / Failed / Skipped / Total] 425 / 44 / 275 / 744:  28%|       | 744/2690 [8:40:02<22:40:11, 41.94s/it][Succeeded / Failed / Skipped / Total] 425 / 44 / 275 / 744:  28%|       | 745/2690 [8:40:04<22:37:46, 41.89s/it][Succeeded / Failed / Skipped / Total] 426 / 44 / 275 / 745:  28%|       | 745/2690 [8:40:04<22:37:46, 41.89s/it][Succeeded / Failed / Skipped / Total] 426 / 44 / 275 / 745:  28%|       | 746/2690 [8:48:58<22:58:26, 42.54s/it][Succeeded / Failed / Skipped / Total] 427 / 44 / 275 / 746:  28%|       | 746/2690 [8:48:58<22:58:26, 42.54s/it][Succeeded / Failed / Skipped / Total] 427 / 44 / 275 / 746:  28%|       | 747/2690 [8:49:38<22:57:39, 42.54s/it][Succeeded / Failed / Skipped / Total] 428 / 44 / 275 / 747:  28%|       | 747/2690 [8:49:38<22:57:39, 42.54s/it][Succeeded / Failed / Skipped / Total] 428 / 44 / 275 / 747:  28%|       | 748/2690 [8:49:39<22:55:07, 42.49s/it][Succeeded / Failed / Skipped / Total] 428 / 44 / 276 / 748:  28%|       | 748/2690 [8:49:39<22:55:07, 42.49s/it][Succeeded / Failed / Skipped / Total] 428 / 44 / 276 / 748:  28%|       | 749/2690 [8:49:39<22:52:35, 42.43s/it][Succeeded / Failed / Skipped / Total] 428 / 44 / 277 / 749:  28%|       | 749/2690 [8:49:39<22:52:35, 42.43s/it][Succeeded / Failed / Skipped / Total] 428 / 44 / 277 / 749:  28%|       | 750/2690 [8:50:04<22:51:06, 42.41s/it]
--------------------------------------------- Result 745 ---------------------------------------------
[[0 (69%)]] --> [[0 (37%)]] --> Socre: 0.628672182559967

[[[[Adv]]]]: static int qemu_rdma_get_fd(void *opaque) { QEMUFileRDMA *[[rfile]] = opaque; RDMAContext *rdma = [[rfile]]->rdma; return rdma->comp_channel->fd; }

[[[[Adv]]]]: static int qemu_rdma_get_fd(void *opaque) { QEMUFileRDMA *[[dealt]] = opaque; RDMAContext *rdma = [[dealt]]->rdma; return rdma->comp_channel->fd; }
--------------------------------------------- Result 746 ---------------------------------------------
[[0 (100%)]] --> [[0 (37%)]] --> Socre: 0.6251291036605835

[[[[Adv]]]]: static int bochs_open(BlockDriverState *bs, QDict *[[options]], int flags, Error **[[errp]]) { BDRVBochsState *s = bs->opaque; uint32_t i; struct bochs_header [[bochs]]; int ret; bs->read_only = 1; ret = bdrv_pread(bs->file, 0, &[[bochs]], sizeof([[bochs]])); if (ret < 0) { return ret; if (strcmp([[bochs]].magic, HEADER_MAGIC) || strcmp([[bochs]].type, REDOLOG_TYPE) || strcmp([[bochs]].subtype, GROWING_TYPE) || ((le32_to_cpu([[bochs]].version) != HEADER_VERSION) && (le32_to_cpu([[bochs]].version) != HEADER_V1))) { error_setg([[errp]], "Image not in Bochs format"); return -EINVAL; if (le32_to_cpu([[bochs]].version) == HEADER_V1) { bs->total_sectors = le64_to_cpu([[bochs]].extra.redolog_v1.disk) / 512; } else { bs->total_sectors = le64_to_cpu([[bochs]].extra.redolog.disk) / 512; s->catalog_size = le32_to_cpu([[bochs]].catalog); s->catalog_bitmap = g_malloc(s->catalog_size * 4); ret = bdrv_pread(bs->file, le32_to_cpu([[bochs]].header), s->catalog_bitmap, s->catalog_size * 4); if (ret < 0) { goto fail; for (i = 0; i < s->catalog_size; i++) le32_to_cpus(&s->catalog_bitmap[i]); s->data_offset = le32_to_cpu([[bochs]].header) + (s->catalog_size * 4); s->bitmap_blocks = 1 + (le32_to_cpu([[bochs]].bitmap) - 1) / 512; s->extent_blocks = 1 + (le32_to_cpu([[bochs]].extent) - 1) / 512; s->extent_size = le32_to_cpu([[bochs]].extent); if (s->catalog_size < bs->total_sectors / s->extent_size) { error_setg([[errp]], "Catalog size is too small for this disk size"); ret = -EINVAL; goto fail; qemu_co_mutex_init(&s->lock); return 0; fail: g_free(s->catalog_bitmap); return ret;

[[[[Adv]]]]: static int bochs_open(BlockDriverState *bs, QDict *[[surrogates]], int flags, Error **[[]]) { BDRVBochsState *s = bs->opaque; uint32_t i; struct bochs_header [[vinny]]; int ret; bs->read_only = 1; ret = bdrv_pread(bs->file, 0, &[[vinny]], sizeof([[vinny]])); if (ret < 0) { return ret; if (strcmp([[vinny]].magic, HEADER_MAGIC) || strcmp([[vinny]].type, REDOLOG_TYPE) || strcmp([[vinny]].subtype, GROWING_TYPE) || ((le32_to_cpu([[vinny]].version) != HEADER_VERSION) && (le32_to_cpu([[vinny]].version) != HEADER_V1))) { error_setg([[]], "Image not in Bochs format"); return -EINVAL; if (le32_to_cpu([[vinny]].version) == HEADER_V1) { bs->total_sectors = le64_to_cpu([[vinny]].extra.redolog_v1.disk) / 512; } else { bs->total_sectors = le64_to_cpu([[vinny]].extra.redolog.disk) / 512; s->catalog_size = le32_to_cpu([[vinny]].catalog); s->catalog_bitmap = g_malloc(s->catalog_size * 4); ret = bdrv_pread(bs->file, le32_to_cpu([[vinny]].header), s->catalog_bitmap, s->catalog_size * 4); if (ret < 0) { goto fail; for (i = 0; i < s->catalog_size; i++) le32_to_cpus(&s->catalog_bitmap[i]); s->data_offset = le32_to_cpu([[vinny]].header) + (s->catalog_size * 4); s->bitmap_blocks = 1 + (le32_to_cpu([[vinny]].bitmap) - 1) / 512; s->extent_blocks = 1 + (le32_to_cpu([[vinny]].extent) - 1) / 512; s->extent_size = le32_to_cpu([[vinny]].extent); if (s->catalog_size < bs->total_sectors / s->extent_size) { error_setg([[]], "Catalog size is too small for this disk size"); ret = -EINVAL; goto fail; qemu_co_mutex_init(&s->lock); return 0; fail: g_free(s->catalog_bitmap); return ret;
--------------------------------------------- Result 747 ---------------------------------------------
[[0 (87%)]] --> [[0 (25%)]] --> Socre: 0.7509641349315643

[[[[Adv]]]]: yuv2rgb_2_c_template(SwsContext *c, const int16_t *buf[2], const int16_t *[[ubuf]][2], const int16_t *vbuf[2], const int16_t *abuf[2], uint8_t *dest, int dstW, int yalpha, int uvalpha, int y, enum PixelFormat target, int hasAlpha) { const int16_t *buf0 = buf[0], *buf1 = buf[1], *ubuf0 = [[ubuf]][0], *ubuf1 = [[ubuf]][1], *vbuf0 = vbuf[0], *vbuf1 = vbuf[1], *abuf0 = abuf[0], *abuf1 = abuf[1]; int yalpha1 = 4095 - yalpha; int uvalpha1 = 4095 - uvalpha; int i; for (i = 0; i < (dstW >> 1); i++) { int Y1 = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19; int Y2 = (buf0[i * 2 + 1] * yalpha1 + buf1[i * 2 + 1] * yalpha) >> 19; int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha) >> 19; int V = (vbuf0[i] * uvalpha1 + vbuf1[i] * uvalpha) >> 19; int A1, A2; const void *r = c->table_rV[V], *g = (c->table_gU[U] + c->table_gV[V]), *b = c->table_bU[U]; if (hasAlpha) { A1 = (abuf0[i * 2 ] * yalpha1 + abuf1[i * 2 ] * yalpha) >> 19; A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19; } yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0, r, g, b, y, target, hasAlpha); } }

[[[[Adv]]]]: yuv2rgb_2_c_template(SwsContext *c, const int16_t *buf[2], const int16_t *[[lecturers]][2], const int16_t *vbuf[2], const int16_t *abuf[2], uint8_t *dest, int dstW, int yalpha, int uvalpha, int y, enum PixelFormat target, int hasAlpha) { const int16_t *buf0 = buf[0], *buf1 = buf[1], *ubuf0 = [[lecturers]][0], *ubuf1 = [[lecturers]][1], *vbuf0 = vbuf[0], *vbuf1 = vbuf[1], *abuf0 = abuf[0], *abuf1 = abuf[1]; int yalpha1 = 4095 - yalpha; int uvalpha1 = 4095 - uvalpha; int i; for (i = 0; i < (dstW >> 1); i++) { int Y1 = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19; int Y2 = (buf0[i * 2 + 1] * yalpha1 + buf1[i * 2 + 1] * yalpha) >> 19; int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha) >> 19; int V = (vbuf0[i] * uvalpha1 + vbuf1[i] * uvalpha) >> 19; int A1, A2; const void *r = c->table_rV[V], *g = (c->table_gU[U] + c->table_gV[V]), *b = c->table_bU[U]; if (hasAlpha) { A1 = (abuf0[i * 2 ] * yalpha1 + abuf1[i * 2 ] * yalpha) >> 19; A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19; } yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0, r, g, b, y, target, hasAlpha); } }
--------------------------------------------- Result 748 ---------------------------------------------
[[0 (29%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int minimum_frame_bits(VC2EncContext *s) { int slice_x, slice_y, bits = 0; s->size_scaler = 64; for (slice_y = 0; slice_y < s->num_y; slice_y++) { for (slice_x = 0; slice_x < s->num_x; slice_x++) { bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil); } } return bits; }
--------------------------------------------- Result 749 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void fd_coroutine_enter(void *opaque) { FDYieldUntilData *data = opaque; qemu_set_fd_handler(data->fd, NULL, NULL, NULL); qemu_coroutine_enter(data->co, NULL); }
--------------------------------------------- Result 750 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 429 / 44 / 277 / 750:  28%|       | 750/2690 [8:50:04<22:51:06, 42.41s/it][Succeeded / Failed / Skipped / Total] 429 / 44 / 277 / 750:  28%|       | 751/2690 [8:50:47<22:50:27, 42.41s/it][[0 (92%)]] --> [[0 (48%)]] --> Socre: 0.5212339162826538

[[[[Adv]]]]: static void qcow_aio_write_cb(void *[[opaque]], int [[ret]]) { QCowAIOCB *[[acb]] = [[opaque]]; BlockDriverState *bs = [[acb]]->common.bs; BDRVQcowState *s = bs->opaque; int index_in_cluster; uint64_t cluster_offset; const uint8_t *src_buf; int n_end; [[acb]]->hd_aiocb = NULL; if ([[ret]] < 0) { fail: [[acb]]->common.cb([[acb]]->common.opaque, [[ret]]); qemu_aio_release([[acb]]); return; } [[acb]]->nb_sectors -= [[acb]]->n; [[acb]]->sector_num += [[acb]]->n; [[acb]]->buf += [[acb]]->n * 512; if ([[acb]]->nb_sectors == 0) { [[acb]]->common.cb([[acb]]->common.opaque, 0); qemu_aio_release([[acb]]); return; } index_in_cluster = [[acb]]->sector_num & (s->cluster_sectors - 1); n_end = index_in_cluster + [[acb]]->nb_sectors; if (s->crypt_method && n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors; cluster_offset = alloc_cluster_offset(bs, [[acb]]->sector_num << 9, index_in_cluster, n_end, &[[acb]]->n); if (!cluster_offset || (cluster_offset & 511) != 0) { [[ret]] = -EIO; goto fail; } if (s->crypt_method) { if (![[acb]]->cluster_data) { [[acb]]->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size); if (![[acb]]->cluster_data) { [[ret]] = -ENOMEM; goto fail; } } encrypt_sectors(s, [[acb]]->sector_num, [[acb]]->cluster_data, [[acb]]->buf, [[acb]]->n, 1, &s->aes_encrypt_key); src_buf = [[acb]]->cluster_data; } else { src_buf = [[acb]]->buf; } [[acb]]->hd_aiocb = bdrv_aio_write(s->hd, (cluster_offset >> 9) + index_in_cluster, src_buf, [[acb]]->n, qcow_aio_write_cb, [[acb]]); if ([[acb]]->hd_aiocb == NULL) goto fail; }

[[[[Adv]]]]: static void qcow_aio_write_cb(void *[[fuzzy]], int [[withdraws]]) { QCowAIOCB *[[imitators]] = [[fuzzy]]; BlockDriverState *bs = [[imitators]]->common.bs; BDRVQcowState *s = bs->opaque; int index_in_cluster; uint64_t cluster_offset; const uint8_t *src_buf; int n_end; [[imitators]]->hd_aiocb = NULL; if ([[withdraws]] < 0) { fail: [[imitators]]->common.cb([[imitators]]->common.opaque, [[withdraws]]); qemu_aio_release([[imitators]]); return; } [[imitators]]->nb_sectors -= [[imitators]]->n; [[imitators]]->sector_num += [[imitators]]->n; [[imitators]]->buf += [[imitators]]->n * 512; if ([[imitators]]->nb_sectors == 0) { [[imitators]]->common.cb([[imitators]]->common.opaque, 0); qemu_aio_release([[imitators]]); return; } index_in_cluster = [[imitators]]->sector_num & (s->cluster_sectors - 1); n_end = index_in_cluster + [[imitators]]->nb_sectors; if (s->crypt_method && n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors; cluster_offset = alloc_cluster_offset(bs, [[imitators]]->sector_num << 9, index_in_cluster, n_end, &[[imitators]]->n); if (!cluster_offset || (cluster_offset & 511) != 0) { [[withdraws]] = -EIO; goto fail; } if (s->crypt_method) { if (![[imitators]]->cluster_data) { [[imitators]]->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size); if (![[imitators]]->cluster_data) { [[withdraws]] = -ENOMEM; goto fail; } } encrypt_sectors(s, [[imitators]]->sector_num, [[imitators]]->cluster_data, [[imitators]]->buf, [[imitators]]->n, 1, &s->aes_encrypt_key); src_buf = [[imitators]]->cluster_data; } else { src_buf = [[imitators]]->buf; } [[imitators]]->hd_aiocb = bdrv_aio_write(s->hd, (cluster_offset >> 9) + index_in_cluster, src_buf, [[imitators]]->n, qcow_aio_write_cb, [[imitators]]); if ([[imitators]]->hd_aiocb == NULL) goto fail; }
--------------------------------------------- Result 751 ---------------------------------------------
[[0 (36%)]] --> [[0 (51%)]] --> Socre: 0.5059947967529297

[[[[Adv]]]]: static int opt_input_file(const char *opt, const char *filename) { AVFormatContext *[[ic]]; AVInputFormat *file_iformat = NULL; int [[err]], i, ret, rfps, rfps_base; int64_t timestamp; uint8_t buf[128]; AVDictionary **opts; int orig_nb_streams; if (last_asked_format) { if (!(file_iformat = av_find_input_format(last_asked_format))) { fprintf(stderr, "Unknown input format: '%s'\n", last_asked_format); ffmpeg_exit(1); } last_asked_format = NULL; } if (!strcmp(filename, "-")) filename = "pipe:"; using_stdin |= !strncmp(filename, "pipe:", 5) || !strcmp(filename, "/dev/stdin"); [[ic]] = avformat_alloc_context(); if (![[ic]]) { print_error(filename, AVERROR(ENOMEM)); ffmpeg_exit(1); } if (audio_sample_rate) { snprintf(buf, sizeof(buf), "%d", audio_sample_rate); av_dict_set(&format_opts, "sample_rate", buf, 0); } if (audio_channels) { snprintf(buf, sizeof(buf), "%d", audio_channels); av_dict_set(&format_opts, "channels", buf, 0); } if (frame_rate.num) { snprintf(buf, sizeof(buf), "%d/%d", frame_rate.num, frame_rate.den); av_dict_set(&format_opts, "framerate", buf, 0); } if (frame_width && frame_height) { snprintf(buf, sizeof(buf), "%dx%d", frame_width, frame_height); av_dict_set(&format_opts, "video_size", buf, 0); } if (frame_pix_fmt != PIX_FMT_NONE) av_dict_set(&format_opts, "pixel_format", av_get_pix_fmt_name(frame_pix_fmt), 0); [[ic]]->video_codec_id = find_codec_or_die(video_codec_name , AVMEDIA_TYPE_VIDEO , 0); [[ic]]->audio_codec_id = find_codec_or_die(audio_codec_name , AVMEDIA_TYPE_AUDIO , 0); [[ic]]->subtitle_codec_id= find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0); [[ic]]->flags |= AVFMT_FLAG_NONBLOCK; [[err]] = avformat_open_input(&[[ic]], filename, file_iformat, &format_opts); if ([[err]] < 0) { print_error(filename, [[err]]); ffmpeg_exit(1); } assert_avoptions(format_opts); if(opt_programid) { int i, j; int found=0; for(i=0; i<[[ic]]->nb_streams; i++){ [[ic]]->streams[i]->discard= AVDISCARD_ALL; } for(i=0; i<[[ic]]->nb_programs; i++){ AVProgram *p= [[ic]]->programs[i]; if(p->id != opt_programid){ p->discard = AVDISCARD_ALL; }else{ found=1; for(j=0; j<p->nb_stream_indexes; j++){ [[ic]]->streams[p->stream_index[j]]->discard= AVDISCARD_DEFAULT; } } } if(!found){ fprintf(stderr, "Specified program id not found\n"); ffmpeg_exit(1); } opt_programid=0; } if (loop_input) { av_log(NULL, AV_LOG_WARNING, "-loop_input is deprecated, use -loop 1\n"); [[ic]]->loop_input = loop_input; } opts = setup_find_stream_info_opts([[ic]], codec_opts); orig_nb_streams = [[ic]]->nb_streams; ret = avformat_find_stream_info([[ic]], opts); if (ret < 0 && verbose >= 0) { fprintf(stderr, "%s: could not find codec parameters\n", filename); av_close_input_file([[ic]]); ffmpeg_exit(1); } timestamp = start_time; if ([[ic]]->start_time != AV_NOPTS_VALUE) timestamp += [[ic]]->start_time; if (start_time != 0) { ret = av_seek_frame([[ic]], -1, timestamp, AVSEEK_FLAG_BACKWARD); if (ret < 0) { fprintf(stderr, "%s: could not seek to position %0.3f\n", filename, (double)timestamp / AV_TIME_BASE); } start_time = 0; } for(i=0;i<[[ic]]->nb_streams;i++) { AVStream *st = [[ic]]->streams[i]; AVCodecContext *dec = st->codec; InputStream *ist; dec->thread_count = thread_count; input_streams = grow_array(input_streams, sizeof(*input_streams), &nb_input_streams, nb_input_streams + 1); ist = &input_streams[nb_input_streams - 1]; ist->st = st; ist->file_index = nb_input_files; ist->discard = 1; ist->opts = filter_codec_opts(codec_opts, ist->st->codec->codec_id, 0); if (i < nb_ts_scale) ist->ts_scale = ts_scale[i]; switch (dec->codec_type) { case AVMEDIA_TYPE_AUDIO: ist->dec = avcodec_find_decoder_by_name(audio_codec_name); if(!ist->dec) ist->dec = avcodec_find_decoder(dec->codec_id); if(audio_disable) st->discard= AVDISCARD_ALL; break; case AVMEDIA_TYPE_VIDEO: ist->dec= avcodec_find_decoder_by_name(video_codec_name); if(!ist->dec) ist->dec = avcodec_find_decoder(dec->codec_id); rfps = [[ic]]->streams[i]->r_frame_rate.num; rfps_base = [[ic]]->streams[i]->r_frame_rate.den; if (dec->lowres) { dec->flags |= CODEC_FLAG_EMU_EDGE; } if(me_threshold) dec->debug |= FF_DEBUG_MV; if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) { if (verbose >= 0) fprintf(stderr,"\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\n", i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num, (float)rfps / rfps_base, rfps, rfps_base); } if(video_disable) st->discard= AVDISCARD_ALL; else if(video_discard) st->discard= video_discard; break; case AVMEDIA_TYPE_DATA: break; case AVMEDIA_TYPE_SUBTITLE: ist->dec = avcodec_find_decoder_by_name(subtitle_codec_name); if(!ist->dec) ist->dec = avcodec_find_decoder(dec->codec_id); if(subtitle_disable) st->discard = AVDISCARD_ALL; break; case AVMEDIA_TYPE_ATTACHMENT: case AVMEDIA_TYPE_UNKNOWN: break; default: abort(); } } if (verbose >= 0) av_dump_format([[ic]], nb_input_files, filename, 0); input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1); input_files[nb_input_files - 1].ctx = [[ic]]; input_files[nb_input_files - 1].ist_index = nb_input_streams - [[ic]]->nb_streams; input_files[nb_input_files - 1].ts_offset = input_ts_offset - (copy_ts ? 0 : timestamp); top_field_first = -1; frame_rate = (AVRational){0, 0}; frame_pix_fmt = PIX_FMT_NONE; frame_height = 0; frame_width = 0; audio_sample_rate = 0; audio_channels = 0; audio_sample_fmt = AV_SAMPLE_FMT_NONE; av_freep(&ts_scale); nb_ts_scale = 0; for (i = 0; i < orig_nb_streams; i++) av_dict_free(&opts[i]); av_freep(&opts); av_freep(&video_codec_name); av_freep(&audio_codec_name); av_freep(&subtitle_codec_name); uninit_opts(); init_opts(); return 0; }

[[[[Adv]]]]: static int opt_input_file(const char *opt, const char *filename) { AVFormatContext *[[squealer]]; AVInputFormat *file_iformat = NULL; int [[brm]], i, ret, rfps, rfps_base; int64_t timestamp; uint8_t buf[128]; AVDictionary **opts; int orig_nb_streams; if (last_asked_format) { if (!(file_iformat = av_find_input_format(last_asked_format))) { fprintf(stderr, "Unknown input format: '%s'\n", last_asked_format); ffmpeg_exit(1); } last_asked_format = NULL; } if (!strcmp(filename, "-")) filename = "pipe:"; using_stdin |= !strncmp(filename, "pipe:", 5) || !strcmp(filename, "/dev/stdin"); [[squealer]] = avformat_alloc_context(); if (![[squealer]]) { print_error(filename, AVERROR(ENOMEM)); ffmpeg_exit(1); } if (audio_sample_rate) { snprintf(buf, sizeof(buf), "%d", audio_sample_rate); av_dict_set(&format_opts, "sample_rate", buf, 0); } if (audio_channels) { snprintf(buf, sizeof(buf), "%d", audio_channels); av_dict_set(&format_opts, "channels", buf, 0); } if (frame_rate.num) { snprintf(buf, sizeof(buf), "%d/%d", frame_rate.num, frame_rate.den); av_dict_set(&format_opts, "framerate", buf, 0); } if (frame_width && frame_height) { snprintf(buf, sizeof(buf), "%dx%d", frame_width, frame_height); av_dict_set(&format_opts, "video_size", buf, 0); } if (frame_pix_fmt != PIX_FMT_NONE) av_dict_set(&format_opts, "pixel_format", av_get_pix_fmt_name(frame_pix_fmt), 0); [[squealer]]->video_codec_id = find_codec_or_die(video_codec_name , AVMEDIA_TYPE_VIDEO , 0); [[squealer]]->audio_codec_id = find_codec_or_die(audio_codec_name , AVMEDIA_TYPE_AUDIO , 0); [[squealer]]->subtitle_codec_id= find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0); [[squealer]]->flags |= AVFMT_FLAG_NONBLOCK; [[brm]] = avformat_open_input(&[[squealer]], filename, file_iformat, &format_opts); if ([[brm]] < 0) { print_error(filename, [[brm]]); ffmpeg_exit(1); } assert_avoptions(format_opts); if(opt_programid) { int i, j; int found=0; for(i=0; i<[[squealer]]->nb_streams; i++){ [[squealer]]->streams[i]->discard= AVDISCARD_ALL; } for(i=0; i<[[squealer]]->nb_programs; i++){ AVProgram *p= [[squealer]]->programs[i]; if(p->id != opt_programid){ p->discard = AVDISCARD_ALL; }else{ found=1; for(j=0; j<p->nb_stream_indexes; j++){ [[squealer]]->streams[p->stream_index[j]]->discard= AVDISCARD_DEFAULT; } } } if(!found){ fprintf(stderr, "Specified program id not found\n"); ffmpeg_exit(1); } opt_programid=0; } if (loop_input) { av_log(NULL, AV_LOG_WARNING, "-loop_input is deprecated, use -loop 1\n"); [[squealer]]->loop_input = loop_input; } opts = setup_find_stream_info_opts([[squealer]], codec_opts); orig_nb_streams = [[squealer]]->nb_streams; ret = avformat_find_stream_info([[squealer]], opts); if (ret < 0 && verbose >= 0) { fprintf(stderr, "%s: could not find codec parameters\n", filename); av_close_input_file([[squealer]]); ffmpeg_exit(1); } timestamp = start_time; if ([[squealer]]->start_time != AV_NOPTS_VALUE) timestamp += [[squealer]]->start_time; if (start_time != 0) { ret = av_seek_frame([[squealer]], -1, timestamp, AVSEEK_FLAG_BACKWARD); if (ret < 0) { fprintf(stderr, "%s: could not seek to position %0.3f\n", filename, (double)timestamp / AV_TIME_BASE); } start_time = 0; } for(i=0;i<[[squealer]]->nb_streams;i++) { AVStream *st = [[squealer]]->streams[i]; AVCodecContext *dec = st->codec; InputStream *ist; dec->thread_count = thread_count; input_streams = grow_array(input_streams, sizeof(*input_streams), &nb_input_streams, nb_input_streams + 1); ist = &input_streams[nb_input_streams - 1]; ist->st = st; ist->file_index = nb_input_files; ist->discard = 1; ist->opts = filter_codec_opts(codec_opts, ist->st->codec->codec_id, 0); if (i < nb_ts_scale) ist->ts_scale = ts_scale[i]; switch (dec->codec_type) { case AVMEDIA_TYPE_AUDIO: ist->dec = avcodec_find_decoder_by_name(audio_codec_name); if(!ist->dec) ist->dec = avcodec_find_decoder(dec->codec_id); if(audio_disable) st->discard= AVDISCARD_ALL; break; case AVMEDIA_TYPE_VIDEO: ist->dec= avcodec_find_decoder_by_name(video_codec_name); if(!ist->dec) ist->dec = avcodec_find_decoder(dec->codec_id); rfps = [[squealer]]->streams[i]->r_frame_rate.num; rfps_base = [[squealer]]->streams[i]->r_frame_rate.den; if (dec->lowres) { dec->flags |= CODEC_FLAG_EMU_EDGE; } if(me_threshold) dec->debug |= FF_DEBUG_MV; if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) { if (verbose >= 0) fprintf(stderr,"\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\n", i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num, (float)rfps / rfps_base, rfps, rfps_base); } if(video_disable) st->discard= AVDISCARD_ALL; else if(video_discard) st->discard= video_discard; break; case AVMEDIA_TYPE_DATA: break; case AVMEDIA_TYPE_SUBTITLE: ist->dec = avcodec_find_decoder_by_name(subtitle_codec_name); if(!ist->dec) ist->dec = avcodec_find_decoder(dec->codec_id); if(subtitle_disable) st->discard = AVDISCARD_ALL; break; case AVMEDIA_TYPE_ATTACHMENT: case AVMEDIA_TYPE_UNKNOWN: break; default: abort(); } } if (verbose >= 0) av_dump_format([[squealer]], nb_input_files, filename, 0); input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1); input_files[nb_input_files - 1].ctx = [[squealer]]; input_files[nb_input_files - 1].ist_index = nb_input_streams - [[squealer]]->nb_streams; input_files[nb_input_files - 1].ts_offset = input_ts_offset - (copy_ts ? 0 : timestamp); top_field_first = -1; frame_rate = (AVRational){0, 0}; frame_pix_fmt = PIX_FMT_NONE; frame_height = 0; frame_width = 0; audio_sample_rate = 0; audio_channels = 0; audio_sample_fmt = AV_SAMPLE_FMT_NONE; av_freep(&ts_scale); nb_ts_scale = 0; for (i = 0; i < orig_nb_streams; i++) av_dict_free(&opts[i]); av_freep(&opts); av_freep(&video_codec_name); av_freep(&audio_codec_name); av_freep(&subtitle_codec_name); uninit_opts(); init_opts(); return 0; }[Succeeded / Failed / Skipped / Total] 430 / 44 / 277 / 751:  28%|       | 751/2690 [8:50:47<22:50:27, 42.41s/it][Succeeded / Failed / Skipped / Total] 430 / 44 / 277 / 751:  28%|       | 752/2690 [8:50:51<22:48:06, 42.36s/it][Succeeded / Failed / Skipped / Total] 431 / 44 / 277 / 752:  28%|       | 752/2690 [8:50:51<22:48:06, 42.36s/it][Succeeded / Failed / Skipped / Total] 431 / 44 / 277 / 752:  28%|       | 753/2690 [8:50:52<22:45:36, 42.30s/it][Succeeded / Failed / Skipped / Total] 431 / 44 / 278 / 753:  28%|       | 753/2690 [8:50:52<22:45:36, 42.30s/it][Succeeded / Failed / Skipped / Total] 431 / 44 / 278 / 753:  28%|       | 754/2690 [8:57:21<22:59:44, 42.76s/it]
--------------------------------------------- Result 752 ---------------------------------------------
[[0 (48%)]] --> [[0 (91%)]] --> Socre: 0.9088507890701294

[[[[Adv]]]]: static int usb_hub_handle_control(USBDevice *dev, USBPacket *p, int request, int value, int index, int length, uint8_t *data) { USBHubState *s = (USBHubState *)[[dev]]; int ret; ret = usb_desc_handle_control([[dev]], p, request, value, index, length, data); if (ret >= 0) { return ret; } switch(request) { case EndpointOutRequest | USB_REQ_CLEAR_FEATURE: if (value == 0 && index != 0x81) { goto fail; } ret = 0; break; case DeviceRequest | USB_REQ_GET_INTERFACE: data[0] = 0; ret = 1; break; case DeviceOutRequest | USB_REQ_SET_INTERFACE: ret = 0; break; case GetHubStatus: data[0] = 0; data[1] = 0; data[2] = 0; data[3] = 0; ret = 4; break; case GetPortStatus: { unsigned int n = index - 1; USBHubPort *port; if (n >= NUM_PORTS) { goto fail; } port = &s->ports[n]; data[0] = port->wPortStatus; data[1] = port->wPortStatus >> 8; data[2] = port->wPortChange; data[3] = port->wPortChange >> 8; ret = 4; } break; case SetHubFeature: case ClearHubFeature: if (value == 0 || value == 1) { } else { goto fail; } ret = 0; break; case SetPortFeature: { unsigned int n = index - 1; USBHubPort *port; USBDevice *[[dev]]; if (n >= NUM_PORTS) { goto fail; } port = &s->ports[n]; [[dev]] = port->port.dev; switch(value) { case PORT_SUSPEND: port->wPortStatus |= PORT_STAT_SUSPEND; break; case PORT_RESET: if ([[dev]]) { usb_send_msg([[dev]], USB_MSG_RESET); port->wPortChange |= PORT_STAT_C_RESET; port->wPortStatus |= PORT_STAT_ENABLE; } break; case PORT_POWER: break; default: goto fail; } ret = 0; } break; case ClearPortFeature: { unsigned int n = index - 1; USBHubPort *port; if (n >= NUM_PORTS) { goto fail; } port = &s->ports[n]; switch(value) { case PORT_ENABLE: port->wPortStatus &= ~PORT_STAT_ENABLE; break; case PORT_C_ENABLE: port->wPortChange &= ~PORT_STAT_C_ENABLE; break; case PORT_SUSPEND: port->wPortStatus &= ~PORT_STAT_SUSPEND; break; case PORT_C_SUSPEND: port->wPortChange &= ~PORT_STAT_C_SUSPEND; break; case PORT_C_CONNECTION: port->wPortChange &= ~PORT_STAT_C_CONNECTION; break; case PORT_C_OVERCURRENT: port->wPortChange &= ~PORT_STAT_C_OVERCURRENT; break; case PORT_C_RESET: port->wPortChange &= ~PORT_STAT_C_RESET; break; default: goto fail; } ret = 0; } break; case GetHubDescriptor: { unsigned int n, limit, var_hub_size = 0; memcpy(data, qemu_hub_hub_descriptor, sizeof(qemu_hub_hub_descriptor)); data[2] = NUM_PORTS; limit = ((NUM_PORTS + 1 + 7) / 8) + 7; for (n = 7; n < limit; n++) { data[n] = 0x00; var_hub_size++; } limit = limit + ((NUM_PORTS + 7) / 8); for (;n < limit; n++) { data[n] = 0xff; var_hub_size++; } ret = sizeof(qemu_hub_hub_descriptor) + var_hub_size; data[0] = ret; break; } default: fail: ret = USB_RET_STALL; break; } return ret; }

[[[[Adv]]]]: static int usb_hub_handle_control(USBDevice *dev, USBPacket *p, int request, int value, int index, int length, uint8_t *data) { USBHubState *s = (USBHubState *)[[kumar]]; int ret; ret = usb_desc_handle_control([[kumar]], p, request, value, index, length, data); if (ret >= 0) { return ret; } switch(request) { case EndpointOutRequest | USB_REQ_CLEAR_FEATURE: if (value == 0 && index != 0x81) { goto fail; } ret = 0; break; case DeviceRequest | USB_REQ_GET_INTERFACE: data[0] = 0; ret = 1; break; case DeviceOutRequest | USB_REQ_SET_INTERFACE: ret = 0; break; case GetHubStatus: data[0] = 0; data[1] = 0; data[2] = 0; data[3] = 0; ret = 4; break; case GetPortStatus: { unsigned int n = index - 1; USBHubPort *port; if (n >= NUM_PORTS) { goto fail; } port = &s->ports[n]; data[0] = port->wPortStatus; data[1] = port->wPortStatus >> 8; data[2] = port->wPortChange; data[3] = port->wPortChange >> 8; ret = 4; } break; case SetHubFeature: case ClearHubFeature: if (value == 0 || value == 1) { } else { goto fail; } ret = 0; break; case SetPortFeature: { unsigned int n = index - 1; USBHubPort *port; USBDevice *[[kumar]]; if (n >= NUM_PORTS) { goto fail; } port = &s->ports[n]; [[kumar]] = port->port.dev; switch(value) { case PORT_SUSPEND: port->wPortStatus |= PORT_STAT_SUSPEND; break; case PORT_RESET: if ([[kumar]]) { usb_send_msg([[kumar]], USB_MSG_RESET); port->wPortChange |= PORT_STAT_C_RESET; port->wPortStatus |= PORT_STAT_ENABLE; } break; case PORT_POWER: break; default: goto fail; } ret = 0; } break; case ClearPortFeature: { unsigned int n = index - 1; USBHubPort *port; if (n >= NUM_PORTS) { goto fail; } port = &s->ports[n]; switch(value) { case PORT_ENABLE: port->wPortStatus &= ~PORT_STAT_ENABLE; break; case PORT_C_ENABLE: port->wPortChange &= ~PORT_STAT_C_ENABLE; break; case PORT_SUSPEND: port->wPortStatus &= ~PORT_STAT_SUSPEND; break; case PORT_C_SUSPEND: port->wPortChange &= ~PORT_STAT_C_SUSPEND; break; case PORT_C_CONNECTION: port->wPortChange &= ~PORT_STAT_C_CONNECTION; break; case PORT_C_OVERCURRENT: port->wPortChange &= ~PORT_STAT_C_OVERCURRENT; break; case PORT_C_RESET: port->wPortChange &= ~PORT_STAT_C_RESET; break; default: goto fail; } ret = 0; } break; case GetHubDescriptor: { unsigned int n, limit, var_hub_size = 0; memcpy(data, qemu_hub_hub_descriptor, sizeof(qemu_hub_hub_descriptor)); data[2] = NUM_PORTS; limit = ((NUM_PORTS + 1 + 7) / 8) + 7; for (n = 7; n < limit; n++) { data[n] = 0x00; var_hub_size++; } limit = limit + ((NUM_PORTS + 7) / 8); for (;n < limit; n++) { data[n] = 0xff; var_hub_size++; } ret = sizeof(qemu_hub_hub_descriptor) + var_hub_size; data[0] = ret; break; } default: fail: ret = USB_RET_STALL; break; } return ret; }
--------------------------------------------- Result 753 ---------------------------------------------
[[0 (93%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mxf_write_packet(AVFormatContext *s, AVPacket *pkt) { MXFContext *mxf = s->priv_data; AVIOContext *pb = s->pb; AVStream *st = s->streams[pkt->stream_index]; MXFStreamContext *sc = st->priv_data; MXFIndexEntry ie = {0}; if (!mxf->edit_unit_byte_count && !(mxf->edit_units_count % EDIT_UNITS_PER_BODY)) { mxf->index_entries = av_realloc(mxf->index_entries, (mxf->edit_units_count + EDIT_UNITS_PER_BODY)*sizeof(*mxf->index_entries)); if (!mxf->index_entries) { av_log(s, AV_LOG_ERROR, "could not allocate index entries\n"); return -1; } } if (st->codec->codec_id == AV_CODEC_ID_MPEG2VIDEO) { if (!mxf_parse_mpeg2_frame(s, st, pkt, &ie)) { av_log(s, AV_LOG_ERROR, "could not get mpeg2 profile and level\n"); return -1; } } if (!mxf->header_written) { if (mxf->edit_unit_byte_count) { mxf_write_partition(s, 1, 2, header_open_partition_key, 1); mxf_write_klv_fill(s); mxf_write_index_table_segment(s); } else { mxf_write_partition(s, 0, 0, header_open_partition_key, 1); } mxf->header_written = 1; } if (st->index == 0) { if (!mxf->edit_unit_byte_count && (!mxf->edit_units_count || mxf->edit_units_count > EDIT_UNITS_PER_BODY) && !(ie.flags & 0x33)) { mxf_write_klv_fill(s); mxf_write_partition(s, 1, 2, body_partition_key, 0); mxf_write_klv_fill(s); mxf_write_index_table_segment(s); } mxf_write_klv_fill(s); mxf_write_system_item(s); if (!mxf->edit_unit_byte_count) { mxf->index_entries[mxf->edit_units_count].offset = mxf->body_offset; mxf->index_entries[mxf->edit_units_count].flags = ie.flags; mxf->index_entries[mxf->edit_units_count].temporal_ref = ie.temporal_ref; mxf->body_offset += KAG_SIZE; } mxf->edit_units_count++; } else if (!mxf->edit_unit_byte_count && st->index == 1) { mxf->index_entries[mxf->edit_units_count-1].slice_offset = mxf->body_offset - mxf->index_entries[mxf->edit_units_count-1].offset; } mxf_write_klv_fill(s); avio_write(pb, sc->track_essence_element_key, 16); if (s->oformat == &ff_mxf_d10_muxer) { if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) mxf_write_d10_video_packet(s, st, pkt); else mxf_write_d10_audio_packet(s, st, pkt); } else { klv_encode_ber4_length(pb, pkt->size); avio_write(pb, pkt->data, pkt->size); mxf->body_offset += 16+4+pkt->size + klv_fill_size(16+4+pkt->size); } avio_flush(pb); return 0; }
--------------------------------------------- Result 754 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 432 / 44 / 278 / 754:  28%|       | 754/2690 [8:57:21<22:59:44, 42.76s/it][Succeeded / Failed / Skipped / Total] 432 / 44 / 278 / 754:  28%|       | 755/2690 [8:58:19<22:59:40, 42.78s/it][Succeeded / Failed / Skipped / Total] 432 / 45 / 278 / 755:  28%|       | 755/2690 [8:58:19<22:59:40, 42.78s/it][Succeeded / Failed / Skipped / Total] 432 / 45 / 278 / 755:  28%|       | 756/2690 [8:58:28<22:57:32, 42.74s/it][[0 (3%)]] --> [[0 (50%)]] --> Socre: 0.5013473033905029

[[[[Adv]]]]: int cpu_arm_handle_mmu_fault (CPUState *[[env]], target_ulong address, int access_type, int mmu_idx, int [[is_softmmu]]) { uint32_t phys_addr; target_ulong page_size; int prot; int [[ret]], is_user; is_user = mmu_idx == MMU_USER_IDX; [[ret]] = get_phys_addr([[env]], address, access_type, is_user, &phys_addr, &prot, &page_size); if ([[ret]] == 0) { phys_addr &= ~(uint32_t)0x3ff; address &= ~(uint32_t)0x3ff; tlb_set_page ([[env]], address, phys_addr, prot | PAGE_EXEC, mmu_idx, page_size); return 0; } if (access_type == 2) { [[env]]->cp15.c5_insn = [[ret]]; [[env]]->cp15.c6_insn = address; [[env]]->exception_index = EXCP_PREFETCH_ABORT; } else { [[env]]->cp15.c5_data = [[ret]]; if (access_type == 1 && arm_feature([[env]], ARM_FEATURE_V6)) [[env]]->cp15.c5_data |= (1 << 11); [[env]]->cp15.c6_data = address; [[env]]->exception_index = EXCP_DATA_ABORT; } return 1; }

[[[[Adv]]]]: int cpu_arm_handle_mmu_fault (CPUState *[[ascended]], target_ulong address, int access_type, int mmu_idx, int [[wabble]]) { uint32_t phys_addr; target_ulong page_size; int prot; int [[pensioner]], is_user; is_user = mmu_idx == MMU_USER_IDX; [[pensioner]] = get_phys_addr([[ascended]], address, access_type, is_user, &phys_addr, &prot, &page_size); if ([[pensioner]] == 0) { phys_addr &= ~(uint32_t)0x3ff; address &= ~(uint32_t)0x3ff; tlb_set_page ([[ascended]], address, phys_addr, prot | PAGE_EXEC, mmu_idx, page_size); return 0; } if (access_type == 2) { [[ascended]]->cp15.c5_insn = [[pensioner]]; [[ascended]]->cp15.c6_insn = address; [[ascended]]->exception_index = EXCP_PREFETCH_ABORT; } else { [[ascended]]->cp15.c5_data = [[pensioner]]; if (access_type == 1 && arm_feature([[ascended]], ARM_FEATURE_V6)) [[ascended]]->cp15.c5_data |= (1 << 11); [[ascended]]->cp15.c6_data = address; [[ascended]]->exception_index = EXCP_DATA_ABORT; } return 1; }
--------------------------------------------- Result 755 ---------------------------------------------
[[0 (90%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *s, PutBitContext *pb, const float *in, float *out, const float *scaled, int size, int scale_idx, int cb, const float lambda, const float uplim, int *bits, const float ROUNDING) { const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512]; const float IQ = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512]; int i; int qc1, qc2, qc3, qc4; uint8_t *p_bits = (uint8_t *)ff_aac_spectral_bits[cb-1]; uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[cb-1]; float *p_vec = (float *)ff_aac_codebook_vectors[cb-1]; abs_pow34_v(s->scoefs, in, size); scaled = s->scoefs; for (i = 0; i < size; i += 4) { int curidx, curidx2; int *in_int = (int *)&in[i]; uint8_t v_bits; unsigned int v_codes; int t0, t1, t2, t3, t4, t5, t6, t7; const float *vec1, *vec2; qc1 = scaled[i ] * Q34 + ROUND_STANDARD; qc2 = scaled[i+1] * Q34 + ROUND_STANDARD; qc3 = scaled[i+2] * Q34 + ROUND_STANDARD; qc4 = scaled[i+3] * Q34 + ROUND_STANDARD; __asm__ volatile ( ".set push \n\t" ".set noreorder \n\t" "ori %[t4], $zero, 4 \n\t" "slt %[t0], %[t4], %[qc1] \n\t" "slt %[t1], %[t4], %[qc2] \n\t" "slt %[t2], %[t4], %[qc3] \n\t" "slt %[t3], %[t4], %[qc4] \n\t" "movn %[qc1], %[t4], %[t0] \n\t" "movn %[qc2], %[t4], %[t1] \n\t" "movn %[qc3], %[t4], %[t2] \n\t" "movn %[qc4], %[t4], %[t3] \n\t" "lw %[t0], 0(%[in_int]) \n\t" "lw %[t1], 4(%[in_int]) \n\t" "lw %[t2], 8(%[in_int]) \n\t" "lw %[t3], 12(%[in_int]) \n\t" "srl %[t0], %[t0], 31 \n\t" "srl %[t1], %[t1], 31 \n\t" "srl %[t2], %[t2], 31 \n\t" "srl %[t3], %[t3], 31 \n\t" "subu %[t4], $zero, %[qc1] \n\t" "subu %[t5], $zero, %[qc2] \n\t" "subu %[t6], $zero, %[qc3] \n\t" "subu %[t7], $zero, %[qc4] \n\t" "movn %[qc1], %[t4], %[t0] \n\t" "movn %[qc2], %[t5], %[t1] \n\t" "movn %[qc3], %[t6], %[t2] \n\t" "movn %[qc4], %[t7], %[t3] \n\t" ".set pop \n\t" : [qc1]"+r"(qc1), [qc2]"+r"(qc2), [qc3]"+r"(qc3), [qc4]"+r"(qc4), [t0]"=&r"(t0), [t1]"=&r"(t1), [t2]"=&r"(t2), [t3]"=&r"(t3), [t4]"=&r"(t4), [t5]"=&r"(t5), [t6]"=&r"(t6), [t7]"=&r"(t7) : [in_int]"r"(in_int) : "memory" ); curidx = 9 * qc1; curidx += qc2 + 40; curidx2 = 9 * qc3; curidx2 += qc4 + 40; v_codes = (p_codes[curidx] << p_bits[curidx2]) | (p_codes[curidx2]); v_bits = p_bits[curidx] + p_bits[curidx2]; put_bits(pb, v_bits, v_codes); if (out) { vec1 = &p_vec[curidx*2 ]; vec2 = &p_vec[curidx2*2]; out[i+0] = vec1[0] * IQ; out[i+1] = vec1[1] * IQ; out[i+2] = vec2[0] * IQ; out[i+3] = vec2[1] * IQ; } } }

[[[[Adv]]]]: static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *s, PutBitContext *pb, const float *in, float *out, const float *scaled, int size, int scale_idx, int cb, const float lambda, const float uplim, int *bits, const float ROUNDING) { const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512]; const float IQ = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512]; int i; int qc1, qc2, qc3, qc4; uint8_t *p_bits = (uint8_t *)ff_aac_spectral_bits[cb-1]; uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[cb-1]; float *p_vec = (float *)ff_aac_codebook_vectors[cb-1]; abs_pow34_v(s->scoefs, in, size); scaled = s->scoefs; for (i = 0; i < size; i += 4) { int curidx, curidx2; int *in_int = (int *)&in[i]; uint8_t v_bits; unsigned int v_codes; int t0, t1, t2, t3, t4, t5, t6, t7; const float *vec1, *vec2; qc1 = scaled[i ] * Q34 + ROUND_STANDARD; qc2 = scaled[i+1] * Q34 + ROUND_STANDARD; qc3 = scaled[i+2] * Q34 + ROUND_STANDARD; qc4 = scaled[i+3] * Q34 + ROUND_STANDARD; __asm__ volatile ( ".set push \n\t" ".set noreorder \n\t" "ori %[t4], $zero, 4 \n\t" "slt %[t0], %[t4], %[qc1] \n\t" "slt %[t1], %[t4], %[qc2] \n\t" "slt %[t2], %[t4], %[qc3] \n\t" "slt %[t3], %[t4], %[qc4] \n\t" "movn %[qc1], %[t4], %[t0] \n\t" "movn %[qc2], %[t4], %[t1] \n\t" "movn %[qc3], %[t4], %[t2] \n\t" "movn %[qc4], %[t4], %[t3] \n\t" "lw %[t0], 0(%[in_int]) \n\t" "lw %[t1], 4(%[in_int]) \n\t" "lw %[t2], 8(%[in_int]) \n\t" "lw %[t3], 12(%[in_int]) \n\t" "srl %[t0], %[t0], 31 \n\t" "srl %[t1], %[t1], 31 \n\t" "srl %[t2], %[t2], 31 \n\t" "srl %[t3], %[t3], 31 \n\t" "subu %[t4], $zero, %[qc1] \n\t" "subu %[t5], $zero, %[qc2] \n\t" "subu %[t6], $zero, %[qc3] \n\t" "subu %[t7], $zero, %[qc4] \n\t" "movn %[qc1], %[t4], %[t0] \n\t" "movn %[qc2], %[t5], %[t1] \n\t" "movn %[qc3], %[t6], %[t2] \n\t" "movn %[qc4], %[t7], %[t3] \n\t" ".set pop \n\t" : [qc1]"+r"(qc1), [qc2]"+r"(qc2), [qc3]"+r"(qc3), [qc4]"+r"(qc4), [t0]"=&r"(t0), [t1]"=&r"(t1), [t2]"=&r"(t2), [t3]"=&r"(t3), [t4]"=&r"(t4), [t5]"=&r"(t5), [t6]"=&r"(t6), [t7]"=&r"(t7) : [in_int]"r"(in_int) : "memory" ); curidx = 9 * qc1; curidx += qc2 + 40; curidx2 = 9 * qc3; curidx2 += qc4 + 40; v_codes = (p_codes[curidx] << p_bits[curidx2]) | (p_codes[curidx2]); v_bits = p_bits[curidx] + p_bits[curidx2]; put_bits(pb, v_bits, v_codes); if (out) { vec1 = &p_vec[curidx*2 ]; vec2 = &p_vec[curidx2*2]; out[i+0] = vec1[0] * IQ; out[i+1] = vec1[1] * IQ; out[i+2] = vec2[0] * IQ; out[i+3] = vec2[1] * IQ; } } }
--------------------------------------------- Result 756 ---------------------------------------------
[[0 (32%)]] --> [[0 (63%)]] --> Socre: 0.6269984245300293

[[[[Adv]]]]: static int binkb_decode_plane(BinkContext *c, AVFrame *frame, BitstreamContext *bc, int plane_idx, int is_key, int is_chroma) { int blk, ret; int i, j, bx, by; uint8_t *dst, *ref, *ref_start, *ref_end; int v, col[2]; const uint8_t *scan; int xoff, yoff; LOCAL_ALIGNED_16(int16_t, block, [64]); LOCAL_ALIGNED_16(int32_t, dctblock, [64]); int [[coordmap]][64]; int ybias = is_key ? -15 : 0; int qp; const int stride = frame->linesize[plane_idx]; int bw = is_chroma ? (c->avctx->width + 15) >> 4 : (c->avctx->width + 7) >> 3; int bh = is_chroma ? (c->avctx->height + 15) >> 4 : (c->avctx->height + 7) >> 3; binkb_init_bundles(c); ref_start = frame->data[plane_idx]; ref_end = frame->data[plane_idx] + (bh * frame->linesize[plane_idx] + bw) * 8; for (i = 0; i < 64; i++) [[coordmap]][i] = (i & 7) + (i >> 3) * stride; for (by = 0; by < bh; by++) { for (i = 0; i < BINKB_NB_SRC; i++) { if ((ret = binkb_read_bundle(c, bc, i)) < 0) return ret; } dst = frame->data[plane_idx] + 8*by*stride; for (bx = 0; bx < bw; bx++, dst += 8) { blk = binkb_get_value(c, BINKB_SRC_BLOCK_TYPES); switch (blk) { case 0: break; case 1: scan = bink_patterns[bitstream_read(bc, 4)]; i = 0; do { int mode = bitstream_read_bit(bc); int run = bitstream_read(bc, binkb_runbits[i]) + 1; i += run; if (i > 64) { av_log(c->avctx, AV_LOG_ERROR, "Run went out of bounds\n"); return AVERROR_INVALIDDATA; } if (mode) { v = binkb_get_value(c, BINKB_SRC_COLORS); for (j = 0; j < run; j++) dst[[[coordmap]][*scan++]] = v; } else { for (j = 0; j < run; j++) dst[[[coordmap]][*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS); } } while (i < 63); if (i == 63) dst[[[coordmap]][*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS); break; case 2: memset(dctblock, 0, sizeof(*dctblock) * 64); dctblock[0] = binkb_get_value(c, BINKB_SRC_INTRA_DC); qp = binkb_get_value(c, BINKB_SRC_INTRA_Q); read_dct_coeffs(bc, dctblock, bink_scan, binkb_intra_quant, qp); c->binkdsp.idct_put(dst, stride, dctblock); break; case 3: xoff = binkb_get_value(c, BINKB_SRC_X_OFF); yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < ref_start || ref + 8*stride > ref_end) { av_log(c->avctx, AV_LOG_WARNING, "Reference block is out of bounds\n"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8); } else { put_pixels8x8_overlapped(dst, ref, stride); } c->bdsp.clear_block(block); v = binkb_get_value(c, BINKB_SRC_INTER_COEFS); read_residue(bc, block, v); c->binkdsp.add_pixels8(dst, block, stride); break; case 4: xoff = binkb_get_value(c, BINKB_SRC_X_OFF); yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < ref_start || ref + 8 * stride > ref_end) { av_log(c->avctx, AV_LOG_WARNING, "Reference block is out of bounds\n"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8); } else { put_pixels8x8_overlapped(dst, ref, stride); } memset(dctblock, 0, sizeof(*dctblock) * 64); dctblock[0] = binkb_get_value(c, BINKB_SRC_INTER_DC); qp = binkb_get_value(c, BINKB_SRC_INTER_Q); read_dct_coeffs(bc, dctblock, bink_scan, binkb_inter_quant, qp); c->binkdsp.idct_add(dst, stride, dctblock); break; case 5: v = binkb_get_value(c, BINKB_SRC_COLORS); c->bdsp.fill_block_tab[1](dst, v, stride, 8); break; case 6: for (i = 0; i < 2; i++) col[i] = binkb_get_value(c, BINKB_SRC_COLORS); for (i = 0; i < 8; i++) { v = binkb_get_value(c, BINKB_SRC_PATTERN); for (j = 0; j < 8; j++, v >>= 1) dst[i*stride + j] = col[v & 1]; } break; case 7: xoff = binkb_get_value(c, BINKB_SRC_X_OFF); yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < ref_start || ref + 8 * stride > ref_end) { av_log(c->avctx, AV_LOG_WARNING, "Reference block is out of bounds\n"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8); } else { put_pixels8x8_overlapped(dst, ref, stride); } break; case 8: for (i = 0; i < 8; i++) memcpy(dst + i*stride, c->bundle[BINKB_SRC_COLORS].cur_ptr + i*8, 8); c->bundle[BINKB_SRC_COLORS].cur_ptr += 64; break; default: av_log(c->avctx, AV_LOG_ERROR, "Unknown block type %d\n", blk); return AVERROR_INVALIDDATA; } } } if (bitstream_tell(bc) & 0x1F) bitstream_skip(bc, 32 - (bitstream_tell(bc) & 0x1F)); return 0; }

[[[[Adv]]]]: static int binkb_decode_plane(BinkContext *c, AVFrame *frame, BitstreamContext *bc, int plane_idx, int is_key, int is_chroma) { int blk, ret; int i, j, bx, by; uint8_t *dst, *ref, *ref_start, *ref_end; int v, col[2]; const uint8_t *scan; int xoff, yoff; LOCAL_ALIGNED_16(int16_t, block, [64]); LOCAL_ALIGNED_16(int32_t, dctblock, [64]); int [[farmer]][64]; int ybias = is_key ? -15 : 0; int qp; const int stride = frame->linesize[plane_idx]; int bw = is_chroma ? (c->avctx->width + 15) >> 4 : (c->avctx->width + 7) >> 3; int bh = is_chroma ? (c->avctx->height + 15) >> 4 : (c->avctx->height + 7) >> 3; binkb_init_bundles(c); ref_start = frame->data[plane_idx]; ref_end = frame->data[plane_idx] + (bh * frame->linesize[plane_idx] + bw) * 8; for (i = 0; i < 64; i++) [[farmer]][i] = (i & 7) + (i >> 3) * stride; for (by = 0; by < bh; by++) { for (i = 0; i < BINKB_NB_SRC; i++) { if ((ret = binkb_read_bundle(c, bc, i)) < 0) return ret; } dst = frame->data[plane_idx] + 8*by*stride; for (bx = 0; bx < bw; bx++, dst += 8) { blk = binkb_get_value(c, BINKB_SRC_BLOCK_TYPES); switch (blk) { case 0: break; case 1: scan = bink_patterns[bitstream_read(bc, 4)]; i = 0; do { int mode = bitstream_read_bit(bc); int run = bitstream_read(bc, binkb_runbits[i]) + 1; i += run; if (i > 64) { av_log(c->avctx, AV_LOG_ERROR, "Run went out of bounds\n"); return AVERROR_INVALIDDATA; } if (mode) { v = binkb_get_value(c, BINKB_SRC_COLORS); for (j = 0; j < run; j++) dst[[[farmer]][*scan++]] = v; } else { for (j = 0; j < run; j++) dst[[[farmer]][*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS); } } while (i < 63); if (i == 63) dst[[[farmer]][*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS); break; case 2: memset(dctblock, 0, sizeof(*dctblock) * 64); dctblock[0] = binkb_get_value(c, BINKB_SRC_INTRA_DC); qp = binkb_get_value(c, BINKB_SRC_INTRA_Q); read_dct_coeffs(bc, dctblock, bink_scan, binkb_intra_quant, qp); c->binkdsp.idct_put(dst, stride, dctblock); break; case 3: xoff = binkb_get_value(c, BINKB_SRC_X_OFF); yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < ref_start || ref + 8*stride > ref_end) { av_log(c->avctx, AV_LOG_WARNING, "Reference block is out of bounds\n"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8); } else { put_pixels8x8_overlapped(dst, ref, stride); } c->bdsp.clear_block(block); v = binkb_get_value(c, BINKB_SRC_INTER_COEFS); read_residue(bc, block, v); c->binkdsp.add_pixels8(dst, block, stride); break; case 4: xoff = binkb_get_value(c, BINKB_SRC_X_OFF); yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < ref_start || ref + 8 * stride > ref_end) { av_log(c->avctx, AV_LOG_WARNING, "Reference block is out of bounds\n"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8); } else { put_pixels8x8_overlapped(dst, ref, stride); } memset(dctblock, 0, sizeof(*dctblock) * 64); dctblock[0] = binkb_get_value(c, BINKB_SRC_INTER_DC); qp = binkb_get_value(c, BINKB_SRC_INTER_Q); read_dct_coeffs(bc, dctblock, bink_scan, binkb_inter_quant, qp); c->binkdsp.idct_add(dst, stride, dctblock); break; case 5: v = binkb_get_value(c, BINKB_SRC_COLORS); c->bdsp.fill_block_tab[1](dst, v, stride, 8); break; case 6: for (i = 0; i < 2; i++) col[i] = binkb_get_value(c, BINKB_SRC_COLORS); for (i = 0; i < 8; i++) { v = binkb_get_value(c, BINKB_SRC_PATTERN); for (j = 0; j < 8; j++, v >>= 1) dst[i*stride + j] = col[v & 1]; } break; case 7: xoff = binkb_get_value(c, BINKB_SRC_X_OFF); yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < ref_start || ref + 8 * stride > ref_end) { av_log(c->avctx, AV_LOG_WARNING, "Reference block is out of bounds\n"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8); } else { put_pixels8x8_overlapped(dst, ref, stride); } break; case 8: for (i = 0; i < 8; i++) memcpy(dst + i*stride, c->bundle[BINKB_SRC_COLORS].cur_ptr + i*8, 8); c->bundle[BINKB_SRC_COLORS].cur_ptr += 64; break; default: av_log(c->avctx, AV_LOG_ERROR, "Unknown block type %d\n", blk); return AVERROR_INVALIDDATA; } } } if (bitstream_tell(bc) & 0x1F) bitstream_skip(bc, 32 - (bitstream_tell(bc) & 0x1F)); return 0; }[Succeeded / Failed / Skipped / Total] 433 / 45 / 278 / 756:  28%|       | 756/2690 [8:58:28<22:57:32, 42.74s/it][Succeeded / Failed / Skipped / Total] 433 / 45 / 278 / 756:  28%|       | 757/2690 [8:58:39<22:55:26, 42.69s/it][Succeeded / Failed / Skipped / Total] 434 / 45 / 278 / 757:  28%|       | 757/2690 [8:58:39<22:55:26, 42.69s/it][Succeeded / Failed / Skipped / Total] 434 / 45 / 278 / 757:  28%|       | 758/2690 [8:59:04<22:53:59, 42.67s/it][Succeeded / Failed / Skipped / Total] 435 / 45 / 278 / 758:  28%|       | 758/2690 [8:59:04<22:53:59, 42.67s/it][Succeeded / Failed / Skipped / Total] 435 / 45 / 278 / 758:  28%|       | 759/2690 [9:00:53<22:56:06, 42.76s/it][Succeeded / Failed / Skipped / Total] 436 / 45 / 278 / 759:  28%|       | 759/2690 [9:00:53<22:56:06, 42.76s/it][Succeeded / Failed / Skipped / Total] 436 / 45 / 278 / 759:  28%|       | 760/2690 [9:01:24<22:54:53, 42.74s/it][Succeeded / Failed / Skipped / Total] 437 / 45 / 278 / 760:  28%|       | 760/2690 [9:01:24<22:54:53, 42.74s/it][Succeeded / Failed / Skipped / Total] 437 / 45 / 278 / 760:  28%|       | 761/2690 [9:02:16<22:54:34, 42.76s/it]
--------------------------------------------- Result 757 ---------------------------------------------
[[0 (89%)]] --> [[0 (48%)]] --> Socre: 0.5249943137168884

[[[[Adv]]]]: static int get_cpsr(QEMUFile *[[f]], void *[[opaque]], size_t [[size]]) { ARMCPU *[[cpu]] = [[opaque]]; CPUARMState *env = &[[cpu]]->env; uint32_t [[val]] = qemu_get_be32([[f]]); env->aarch64 = (([[val]] & PSTATE_nRW) == 0); if (is_a64(env)) { pstate_write(env, [[val]]); return 0; } env->uncached_cpsr = [[val]] & CPSR_M; cpsr_write(env, [[val]], 0xffffffff, CPSRWriteRaw); return 0; }

[[[[Adv]]]]: static int get_cpsr(QEMUFile *[[walker]], void *[[vague]], size_t [[splendor]]) { ARMCPU *[[mcu]] = [[vague]]; CPUARMState *env = &[[mcu]]->env; uint32_t [[opt]] = qemu_get_be32([[walker]]); env->aarch64 = (([[opt]] & PSTATE_nRW) == 0); if (is_a64(env)) { pstate_write(env, [[opt]]); return 0; } env->uncached_cpsr = [[opt]] & CPSR_M; cpsr_write(env, [[opt]], 0xffffffff, CPSRWriteRaw); return 0; }
--------------------------------------------- Result 758 ---------------------------------------------
[[0 (23%)]] --> [[0 (93%)]] --> Socre: 0.93294358253479

[[[[Adv]]]]: static void term_handle_byte(int [[ch]]) { switch(term_esc_state) { case IS_NORM: switch([[ch]]) { case 1: term_bol(); break; case 4: term_delete_char(); break; case 5: term_eol(); break; case 9: term_completion(); break; case 10: case 13: term_cmd_buf[term_cmd_buf_size] = '\0'; term_hist_add(term_cmd_buf); term_printf("\n"); term_handle_command(term_cmd_buf); term_show_prompt(); break; case 27: term_esc_state = IS_ESC; break; case 127: case 8: term_backspace(); break; case 155: term_esc_state = IS_CSI; break; default: if ([[ch]] >= 32) { term_insert_char([[ch]]); } break; } break; case IS_ESC: if ([[ch]] == '[') { term_esc_state = IS_CSI; term_esc_param = 0; } else { term_esc_state = IS_NORM; } break; case IS_CSI: switch([[ch]]) { case 'A': case 'F': term_up_char(); break; case 'B': case 'E': term_down_char(); break; case 'D': term_backward_char(); break; case 'C': term_forward_char(); break; case '0' ... '9': term_esc_param = term_esc_param * 10 + ([[ch]] - '0'); goto the_end; case '~': switch(term_esc_param) { case 1: term_bol(); break; case 3: term_delete_char(); break; case 4: term_eol(); break; } break; default: break; } term_esc_state = IS_NORM; the_end: break; } term_update(); }

[[[[Adv]]]]: static void term_handle_byte(int [[promontory]]) { switch(term_esc_state) { case IS_NORM: switch([[promontory]]) { case 1: term_bol(); break; case 4: term_delete_char(); break; case 5: term_eol(); break; case 9: term_completion(); break; case 10: case 13: term_cmd_buf[term_cmd_buf_size] = '\0'; term_hist_add(term_cmd_buf); term_printf("\n"); term_handle_command(term_cmd_buf); term_show_prompt(); break; case 27: term_esc_state = IS_ESC; break; case 127: case 8: term_backspace(); break; case 155: term_esc_state = IS_CSI; break; default: if ([[promontory]] >= 32) { term_insert_char([[promontory]]); } break; } break; case IS_ESC: if ([[promontory]] == '[') { term_esc_state = IS_CSI; term_esc_param = 0; } else { term_esc_state = IS_NORM; } break; case IS_CSI: switch([[promontory]]) { case 'A': case 'F': term_up_char(); break; case 'B': case 'E': term_down_char(); break; case 'D': term_backward_char(); break; case 'C': term_forward_char(); break; case '0' ... '9': term_esc_param = term_esc_param * 10 + ([[promontory]] - '0'); goto the_end; case '~': switch(term_esc_param) { case 1: term_bol(); break; case 3: term_delete_char(); break; case 4: term_eol(); break; } break; default: break; } term_esc_state = IS_NORM; the_end: break; } term_update(); }
--------------------------------------------- Result 759 ---------------------------------------------
[[0 (2%)]] --> [[0 (99%)]] --> Socre: 0.9874486327171326

[[[[Adv]]]]: static inline int get_chroma_qp(H264Context *h, int t, int [[qscale]]){ return h->pps.chroma_qp_table[t][[[qscale]]]; }

[[[[Adv]]]]: static inline int get_chroma_qp(H264Context *h, int t, int [[dja]]){ return h->pps.chroma_qp_table[t][[[dja]]]; }
--------------------------------------------- Result 760 ---------------------------------------------
[[0 (4%)]] --> [[0 (73%)]] --> Socre: 0.7285213470458984

[[[[Adv]]]]: static void qbus_list_bus(DeviceState *dev, char *dest, int len) { BusState *[[child]]; const char *sep = " "; int pos = 0; pos += snprintf(dest+pos, len-pos,"child busses at \"%s\":", dev->id ? dev->id : dev->info->name); LIST_FOREACH([[child]], &dev->child_bus, sibling) { pos += snprintf(dest+pos, len-pos, "%s\"%s\"", sep, [[child]]->name); sep = ", "; } }

[[[[Adv]]]]: static void qbus_list_bus(DeviceState *dev, char *dest, int len) { BusState *[[miners]]; const char *sep = " "; int pos = 0; pos += snprintf(dest+pos, len-pos,"child busses at \"%s\":", dev->id ? dev->id : dev->info->name); LIST_FOREACH([[miners]], &dev->child_bus, sibling) { pos += snprintf(dest+pos, len-pos, "%s\"%s\"", sep, [[miners]]->name); sep = ", "; } }
--------------------------------------------- Result 761 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 438 / 45 / 278 / 761:  28%|       | 761/2690 [9:02:16<22:54:34, 42.76s/it][Succeeded / Failed / Skipped / Total] 438 / 45 / 278 / 761:  28%|       | 762/2690 [9:02:21<22:52:16, 42.71s/it][[0 (78%)]] --> [[0 (30%)]] --> Socre: 0.702242910861969

[[[[Adv]]]]: static int read_directory(BDRVVVFATState* s, int mapping_index) { mapping_t* mapping = array_get(&(s->mapping), mapping_index); direntry_t* direntry; const char* dirname = mapping->path; int first_cluster = mapping->begin; int parent_index = mapping->info.dir.parent_mapping_index; mapping_t* parent_mapping = (mapping_t*) (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL); int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -1; DIR* [[dir]]=opendir(dirname); struct dirent* entry; int i; assert(mapping->mode & MODE_DIRECTORY); if(![[dir]]) { mapping->end = mapping->begin; return -1; } i = mapping->info.dir.first_dir_index = first_cluster == 0 ? 0 : s->directory.next; if (first_cluster != 0) { (void)create_short_and_long_name(s, i, ".", 1); (void)create_short_and_long_name(s, i, "..", 1); } while((entry=readdir([[dir]]))) { unsigned int length=strlen(dirname)+2+strlen(entry->d_name); char* buffer; direntry_t* direntry; struct stat st; int is_dot=!strcmp(entry->d_name,"."); int is_dotdot=!strcmp(entry->d_name,".."); if(first_cluster == 0 && (is_dotdot || is_dot)) continue; buffer = g_malloc(length); snprintf(buffer,length,"%s/%s",dirname,entry->d_name); if(stat(buffer,&st)<0) { g_free(buffer); continue; } if (!is_dot && !is_dotdot) { direntry = create_short_and_long_name(s, i, entry->d_name, 0); } else { direntry = array_get(&(s->directory), is_dot ? i : i + 1); } direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20); direntry->reserved[0]=direntry->reserved[1]=0; direntry->ctime=fat_datetime(st.st_ctime,1); direntry->cdate=fat_datetime(st.st_ctime,0); direntry->adate=fat_datetime(st.st_atime,0); direntry->begin_hi=0; direntry->mtime=fat_datetime(st.st_mtime,1); direntry->mdate=fat_datetime(st.st_mtime,0); if(is_dotdot) set_begin_of_direntry(direntry, first_cluster_of_parent); else if(is_dot) set_begin_of_direntry(direntry, first_cluster); else direntry->begin=0; if (st.st_size > 0x7fffffff) { fprintf(stderr, "File %s is larger than 2GB\n", buffer); g_free(buffer); closedir([[dir]]); return -2; } direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size); if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) { s->current_mapping = array_get_next(&(s->mapping)); s->current_mapping->begin=0; s->current_mapping->end=st.st_size; s->current_mapping->dir_index=s->directory.next-1; s->current_mapping->first_mapping_index = -1; if (S_ISDIR(st.st_mode)) { s->current_mapping->mode = MODE_DIRECTORY; s->current_mapping->info.dir.parent_mapping_index = mapping_index; } else { s->current_mapping->mode = MODE_UNDEFINED; s->current_mapping->info.file.offset = 0; } s->current_mapping->path=buffer; s->current_mapping->read_only = (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0; } else { g_free(buffer); } } closedir([[dir]]); while(s->directory.next%(0x10*s->sectors_per_cluster)) { direntry_t* direntry=array_get_next(&(s->directory)); memset(direntry,0,sizeof(direntry_t)); } #define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster) if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) { int cur = s->directory.next; array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1); s->directory.next = ROOT_ENTRIES; memset(array_get(&(s->directory), cur), 0, (ROOT_ENTRIES - cur) * sizeof(direntry_t)); } mapping = array_get(&(s->mapping), mapping_index); first_cluster += (s->directory.next - mapping->info.dir.first_dir_index) * 0x20 / s->cluster_size; mapping->end = first_cluster; direntry = array_get(&(s->directory), mapping->dir_index); set_begin_of_direntry(direntry, mapping->begin); return 0; }

[[[[Adv]]]]: static int read_directory(BDRVVVFATState* s, int mapping_index) { mapping_t* mapping = array_get(&(s->mapping), mapping_index); direntry_t* direntry; const char* dirname = mapping->path; int first_cluster = mapping->begin; int parent_index = mapping->info.dir.parent_mapping_index; mapping_t* parent_mapping = (mapping_t*) (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL); int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -1; DIR* [[jetzt]]=opendir(dirname); struct dirent* entry; int i; assert(mapping->mode & MODE_DIRECTORY); if(![[jetzt]]) { mapping->end = mapping->begin; return -1; } i = mapping->info.dir.first_dir_index = first_cluster == 0 ? 0 : s->directory.next; if (first_cluster != 0) { (void)create_short_and_long_name(s, i, ".", 1); (void)create_short_and_long_name(s, i, "..", 1); } while((entry=readdir([[jetzt]]))) { unsigned int length=strlen(dirname)+2+strlen(entry->d_name); char* buffer; direntry_t* direntry; struct stat st; int is_dot=!strcmp(entry->d_name,"."); int is_dotdot=!strcmp(entry->d_name,".."); if(first_cluster == 0 && (is_dotdot || is_dot)) continue; buffer = g_malloc(length); snprintf(buffer,length,"%s/%s",dirname,entry->d_name); if(stat(buffer,&st)<0) { g_free(buffer); continue; } if (!is_dot && !is_dotdot) { direntry = create_short_and_long_name(s, i, entry->d_name, 0); } else { direntry = array_get(&(s->directory), is_dot ? i : i + 1); } direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20); direntry->reserved[0]=direntry->reserved[1]=0; direntry->ctime=fat_datetime(st.st_ctime,1); direntry->cdate=fat_datetime(st.st_ctime,0); direntry->adate=fat_datetime(st.st_atime,0); direntry->begin_hi=0; direntry->mtime=fat_datetime(st.st_mtime,1); direntry->mdate=fat_datetime(st.st_mtime,0); if(is_dotdot) set_begin_of_direntry(direntry, first_cluster_of_parent); else if(is_dot) set_begin_of_direntry(direntry, first_cluster); else direntry->begin=0; if (st.st_size > 0x7fffffff) { fprintf(stderr, "File %s is larger than 2GB\n", buffer); g_free(buffer); closedir([[jetzt]]); return -2; } direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size); if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) { s->current_mapping = array_get_next(&(s->mapping)); s->current_mapping->begin=0; s->current_mapping->end=st.st_size; s->current_mapping->dir_index=s->directory.next-1; s->current_mapping->first_mapping_index = -1; if (S_ISDIR(st.st_mode)) { s->current_mapping->mode = MODE_DIRECTORY; s->current_mapping->info.dir.parent_mapping_index = mapping_index; } else { s->current_mapping->mode = MODE_UNDEFINED; s->current_mapping->info.file.offset = 0; } s->current_mapping->path=buffer; s->current_mapping->read_only = (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0; } else { g_free(buffer); } } closedir([[jetzt]]); while(s->directory.next%(0x10*s->sectors_per_cluster)) { direntry_t* direntry=array_get_next(&(s->directory)); memset(direntry,0,sizeof(direntry_t)); } #define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster) if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) { int cur = s->directory.next; array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1); s->directory.next = ROOT_ENTRIES; memset(array_get(&(s->directory), cur), 0, (ROOT_ENTRIES - cur) * sizeof(direntry_t)); } mapping = array_get(&(s->mapping), mapping_index); first_cluster += (s->directory.next - mapping->info.dir.first_dir_index) * 0x20 / s->cluster_size; mapping->end = first_cluster; direntry = array_get(&(s->directory), mapping->dir_index); set_begin_of_direntry(direntry, mapping->begin); return 0; }
--------------------------------------------- Result 762 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 439 / 45 / 278 / 762:  28%|       | 762/2690 [9:02:21<22:52:16, 42.71s/it][Succeeded / Failed / Skipped / Total] 439 / 45 / 278 / 762:  28%|       | 763/2690 [9:02:22<22:49:46, 42.65s/it][Succeeded / Failed / Skipped / Total] 439 / 45 / 279 / 763:  28%|       | 763/2690 [9:02:22<22:49:46, 42.65s/it][Succeeded / Failed / Skipped / Total] 439 / 45 / 279 / 763:  28%|       | 764/2690 [9:03:15<22:49:32, 42.66s/it][Succeeded / Failed / Skipped / Total] 440 / 45 / 279 / 764:  28%|       | 764/2690 [9:03:15<22:49:32, 42.66s/it][Succeeded / Failed / Skipped / Total] 440 / 45 / 279 / 764:  28%|       | 765/2690 [9:03:31<22:47:42, 42.63s/it][Succeeded / Failed / Skipped / Total] 441 / 45 / 279 / 765:  28%|       | 765/2690 [9:03:31<22:47:42, 42.63s/it][Succeeded / Failed / Skipped / Total] 441 / 45 / 279 / 765:  28%|       | 766/2690 [9:04:38<22:47:59, 42.66s/it][[0 (43%)]] --> [[0 (56%)]] --> Socre: 0.5606188178062439

[[[[Adv]]]]: static int replace_int_data_in_filename(char *[[buf]], int buf_size, const char *filename, char placeholder, int64_t number) { const char *p; char *q, buf1[20], c; int nd, len, addchar_count; int found_count = 0; q = [[buf]]; p = filename; for (;;) { c = *p; if (c == '\0') break; if (c == '%' && *(p+1) == '%') addchar_count = 2; else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) { nd = 0; addchar_count = 1; while (av_isdigit(*(p + addchar_count))) { nd = nd * 10 + *(p + addchar_count) - '0'; addchar_count++; } if (*(p + addchar_count) == placeholder) { len = snprintf(buf1, sizeof(buf1), "%0*"PRId64, (number < 0) ? nd : nd++, number); if (len < 1) goto fail; if ((q - [[buf]] + len) > buf_size - 1) goto fail; memcpy(q, buf1, len); q += len; p += (addchar_count + 1); addchar_count = 0; found_count++; } } else addchar_count = 1; while (addchar_count--) if ((q - [[buf]]) < buf_size - 1) *q++ = *p++; else goto fail; } *q = '\0'; return found_count; fail: *q = '\0'; return -1; }

[[[[Adv]]]]: static int replace_int_data_in_filename(char *[[differed]], int buf_size, const char *filename, char placeholder, int64_t number) { const char *p; char *q, buf1[20], c; int nd, len, addchar_count; int found_count = 0; q = [[differed]]; p = filename; for (;;) { c = *p; if (c == '\0') break; if (c == '%' && *(p+1) == '%') addchar_count = 2; else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) { nd = 0; addchar_count = 1; while (av_isdigit(*(p + addchar_count))) { nd = nd * 10 + *(p + addchar_count) - '0'; addchar_count++; } if (*(p + addchar_count) == placeholder) { len = snprintf(buf1, sizeof(buf1), "%0*"PRId64, (number < 0) ? nd : nd++, number); if (len < 1) goto fail; if ((q - [[differed]] + len) > buf_size - 1) goto fail; memcpy(q, buf1, len); q += len; p += (addchar_count + 1); addchar_count = 0; found_count++; } } else addchar_count = 1; while (addchar_count--) if ((q - [[differed]]) < buf_size - 1) *q++ = *p++; else goto fail; } *q = '\0'; return found_count; fail: *q = '\0'; return -1; }
--------------------------------------------- Result 763 ---------------------------------------------
[[0 (77%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void cubieboard_init(QEMUMachineInitArgs *args) { CubieBoardState *s = g_new(CubieBoardState, 1); Error *err = NULL; s->a10 = AW_A10(object_new(TYPE_AW_A10)); object_property_set_bool(OBJECT(s->a10), "True" == "True", "realized", &err); if (err != NULL) { error_report("Couldn't realize Allwinner A10: %s\n", error_get_pretty(err)); exit(1); } memory_region_init_ram(&s->sdram, NULL, "cubieboard.ram", args->ram_size); vmstate_register_ram_global(&s->sdram); memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE, &s->sdram); cubieboard_binfo.ram_size = args->ram_size; cubieboard_binfo.kernel_filename = args->kernel_filename; cubieboard_binfo.kernel_cmdline = args->kernel_cmdline; arm_load_kernel(&s->a10->cpu, &cubieboard_binfo); }
--------------------------------------------- Result 764 ---------------------------------------------
[[0 (24%)]] --> [[0 (51%)]] --> Socre: 0.5103203654289246

[[[[Adv]]]]: void esp_init(target_phys_addr_t espaddr, int it_shift, ESPDMAMemoryReadWriteFunc dma_memory_read, ESPDMAMemoryReadWriteFunc dma_memory_write, void *dma_opaque, qemu_irq [[irq]], qemu_irq *reset, qemu_irq *dma_enable) { DeviceState *dev; SysBusDevice *[[s]]; SysBusESPState *[[sysbus]]; ESPState *esp; dev = qdev_create(NULL, "esp"); [[sysbus]] = DO_UPCAST(SysBusESPState, busdev.qdev, dev); esp = &[[sysbus]]->esp; esp->dma_memory_read = dma_memory_read; esp->dma_memory_write = dma_memory_write; esp->dma_opaque = dma_opaque; [[sysbus]]->it_shift = it_shift; esp->dma_enabled = 1; qdev_init_nofail(dev); [[s]] = sysbus_from_qdev(dev); sysbus_connect_irq([[s]], 0, [[irq]]); sysbus_mmio_map([[s]], 0, espaddr); *reset = qdev_get_gpio_in(dev, 0); *dma_enable = qdev_get_gpio_in(dev, 1); }

[[[[Adv]]]]: void esp_init(target_phys_addr_t espaddr, int it_shift, ESPDMAMemoryReadWriteFunc dma_memory_read, ESPDMAMemoryReadWriteFunc dma_memory_write, void *dma_opaque, qemu_irq [[consoling]], qemu_irq *reset, qemu_irq *dma_enable) { DeviceState *dev; SysBusDevice *[[o]]; SysBusESPState *[[coverage]]; ESPState *esp; dev = qdev_create(NULL, "esp"); [[coverage]] = DO_UPCAST(SysBusESPState, busdev.qdev, dev); esp = &[[coverage]]->esp; esp->dma_memory_read = dma_memory_read; esp->dma_memory_write = dma_memory_write; esp->dma_opaque = dma_opaque; [[coverage]]->it_shift = it_shift; esp->dma_enabled = 1; qdev_init_nofail(dev); [[o]] = sysbus_from_qdev(dev); sysbus_connect_irq([[o]], 0, [[consoling]]); sysbus_mmio_map([[o]], 0, espaddr); *reset = qdev_get_gpio_in(dev, 0); *dma_enable = qdev_get_gpio_in(dev, 1); }
--------------------------------------------- Result 765 ---------------------------------------------
[[0 (44%)]] --> [[0 (60%)]] --> Socre: 0.5973060131072998

[[[[Adv]]]]: static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame) { WMACodecContext *s = avctx->priv_data; float **[[audio]] = (float **) frame->extended_data; int len = frame->nb_samples; int window_index = s->frame_len_bits - s->block_len_bits; FFTContext *mdct = &s->mdct_ctx[window_index]; int ch; const float *win = s->windows[window_index]; int window_len = 1 << s->block_len_bits; float n = 2.0 * 32768.0 / window_len; for (ch = 0; ch < avctx->channels; ch++) { memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output)); s->fdsp->vector_fmul_scalar(s->frame_out[ch], [[audio]][ch], n, len); s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch], win, len); s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len); mdct->mdct_calc(mdct, s->coefs[ch], s->output); } }

[[[[Adv]]]]: static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame) { WMACodecContext *s = avctx->priv_data; float **[[vowel]] = (float **) frame->extended_data; int len = frame->nb_samples; int window_index = s->frame_len_bits - s->block_len_bits; FFTContext *mdct = &s->mdct_ctx[window_index]; int ch; const float *win = s->windows[window_index]; int window_len = 1 << s->block_len_bits; float n = 2.0 * 32768.0 / window_len; for (ch = 0; ch < avctx->channels; ch++) { memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output)); s->fdsp->vector_fmul_scalar(s->frame_out[ch], [[vowel]][ch], n, len); s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch], win, len); s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len); mdct->mdct_calc(mdct, s->coefs[ch], s->output); } }
--------------------------------------------- Result 766 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 442 / 45 / 279 / 766:  28%|       | 766/2690 [9:04:38<22:47:59, 42.66s/it][Succeeded / Failed / Skipped / Total] 442 / 45 / 279 / 766:  29%|       | 767/2690 [9:06:01<22:48:59, 42.71s/it][Succeeded / Failed / Skipped / Total] 443 / 45 / 279 / 767:  29%|       | 767/2690 [9:06:01<22:48:59, 42.71s/it][Succeeded / Failed / Skipped / Total] 443 / 45 / 279 / 767:  29%|       | 768/2690 [9:06:05<22:46:39, 42.66s/it][Succeeded / Failed / Skipped / Total] 444 / 45 / 279 / 768:  29%|       | 768/2690 [9:06:05<22:46:39, 42.66s/it][Succeeded / Failed / Skipped / Total] 444 / 45 / 279 / 768:  29%|       | 769/2690 [9:06:06<22:44:11, 42.61s/it][Succeeded / Failed / Skipped / Total] 444 / 45 / 280 / 769:  29%|       | 769/2690 [9:06:06<22:44:11, 42.61s/it][Succeeded / Failed / Skipped / Total] 444 / 45 / 280 / 769:  29%|       | 770/2690 [9:06:24<22:42:27, 42.58s/it][Succeeded / Failed / Skipped / Total] 445 / 45 / 280 / 770:  29%|       | 770/2690 [9:06:24<22:42:27, 42.58s/it][Succeeded / Failed / Skipped / Total] 445 / 45 / 280 / 770:  29%|       | 771/2690 [9:06:24<22:40:00, 42.52s/it][[0 (78%)]] --> [[0 (43%)]] --> Socre: 0.5675026476383209

[[[[Adv]]]]: static void diff_pixels_altivec(int16_t *restrict [[block]], const uint8_t *s1, const uint8_t *s2, int [[stride]]) { int [[i]]; vec_u8 perm1 = vec_lvsl(0, s1); vec_u8 perm2 = vec_lvsl(0, s2); const vec_u8 zero = (const vec_u8)vec_splat_u8(0); vec_s16 shorts1, shorts2; for ([[i]] = 0; [[i]] < 4; [[i]]++) { vec_u8 pixl = vec_ld(0, s1); vec_u8 [[pixr]] = vec_ld(15, s1); vec_u8 bytes = vec_perm(pixl, [[pixr]], perm1); shorts1 = (vec_s16)vec_mergeh(zero, bytes); pixl = vec_ld(0, s2); [[pixr]] = vec_ld(15, s2); bytes = vec_perm(pixl, [[pixr]], perm2); shorts2 = (vec_s16)vec_mergeh(zero, bytes); shorts1 = vec_sub(shorts1, shorts2); vec_st(shorts1, 0, (vec_s16 *)[[block]]); s1 += [[stride]]; s2 += [[stride]]; [[block]] += 8; pixl = vec_ld(0, s1); [[pixr]] = vec_ld(15, s1); bytes = vec_perm(pixl, [[pixr]], perm1); shorts1 = (vec_s16)vec_mergeh(zero, bytes); pixl = vec_ld(0, s2); [[pixr]] = vec_ld(15, s2); bytes = vec_perm(pixl, [[pixr]], perm2); shorts2 = (vec_s16)vec_mergeh(zero, bytes); shorts1 = vec_sub(shorts1, shorts2); vec_st(shorts1, 0, (vec_s16 *)[[block]]); s1 += [[stride]]; s2 += [[stride]]; [[block]] += 8; } }

[[[[Adv]]]]: static void diff_pixels_altivec(int16_t *restrict [[blocking]], const uint8_t *s1, const uint8_t *s2, int [[action]]) { int [[gonna]]; vec_u8 perm1 = vec_lvsl(0, s1); vec_u8 perm2 = vec_lvsl(0, s2); const vec_u8 zero = (const vec_u8)vec_splat_u8(0); vec_s16 shorts1, shorts2; for ([[gonna]] = 0; [[gonna]] < 4; [[gonna]]++) { vec_u8 pixl = vec_ld(0, s1); vec_u8 [[mavericks]] = vec_ld(15, s1); vec_u8 bytes = vec_perm(pixl, [[mavericks]], perm1); shorts1 = (vec_s16)vec_mergeh(zero, bytes); pixl = vec_ld(0, s2); [[mavericks]] = vec_ld(15, s2); bytes = vec_perm(pixl, [[mavericks]], perm2); shorts2 = (vec_s16)vec_mergeh(zero, bytes); shorts1 = vec_sub(shorts1, shorts2); vec_st(shorts1, 0, (vec_s16 *)[[blocking]]); s1 += [[action]]; s2 += [[action]]; [[blocking]] += 8; pixl = vec_ld(0, s1); [[mavericks]] = vec_ld(15, s1); bytes = vec_perm(pixl, [[mavericks]], perm1); shorts1 = (vec_s16)vec_mergeh(zero, bytes); pixl = vec_ld(0, s2); [[mavericks]] = vec_ld(15, s2); bytes = vec_perm(pixl, [[mavericks]], perm2); shorts2 = (vec_s16)vec_mergeh(zero, bytes); shorts1 = vec_sub(shorts1, shorts2); vec_st(shorts1, 0, (vec_s16 *)[[blocking]]); s1 += [[action]]; s2 += [[action]]; [[blocking]] += 8; } }
--------------------------------------------- Result 767 ---------------------------------------------
[[0 (9%)]] --> [[0 (51%)]] --> Socre: 0.5075770616531372

[[[[Adv]]]]: static GtkWidget *gd_create_menu_machine(GtkDisplayState *[[s]], GtkAccelGroup *[[accel_group]]) { GtkWidget *machine_menu; GtkWidget *separator; machine_menu = gtk_menu_new(); gtk_menu_set_accel_group(GTK_MENU(machine_menu), [[accel_group]]); [[s]]->pause_item = gtk_check_menu_item_new_with_mnemonic(_("_Pause")); gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), [[s]]->pause_item); separator = gtk_separator_menu_item_new(); gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator); [[s]]->reset_item = gtk_menu_item_new_with_mnemonic(_("_Reset")); gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), [[s]]->reset_item); [[s]]->powerdown_item = gtk_menu_item_new_with_mnemonic(_("Power _Down")); gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), [[s]]->powerdown_item); separator = gtk_separator_menu_item_new(); gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator); [[s]]->quit_item = gtk_menu_item_new_with_mnemonic(_("_Quit")); gtk_menu_item_set_accel_path(GTK_MENU_ITEM([[s]]->quit_item), "<QEMU>/Machine/Quit"); gtk_accel_map_add_entry("<QEMU>/Machine/Quit", GDK_KEY_q, GDK_CONTROL_MASK); gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), [[s]]->quit_item); return machine_menu; }

[[[[Adv]]]]: static GtkWidget *gd_create_menu_machine(GtkDisplayState *[[nor]], GtkAccelGroup *[[beardy]]) { GtkWidget *machine_menu; GtkWidget *separator; machine_menu = gtk_menu_new(); gtk_menu_set_accel_group(GTK_MENU(machine_menu), [[beardy]]); [[nor]]->pause_item = gtk_check_menu_item_new_with_mnemonic(_("_Pause")); gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), [[nor]]->pause_item); separator = gtk_separator_menu_item_new(); gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator); [[nor]]->reset_item = gtk_menu_item_new_with_mnemonic(_("_Reset")); gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), [[nor]]->reset_item); [[nor]]->powerdown_item = gtk_menu_item_new_with_mnemonic(_("Power _Down")); gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), [[nor]]->powerdown_item); separator = gtk_separator_menu_item_new(); gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator); [[nor]]->quit_item = gtk_menu_item_new_with_mnemonic(_("_Quit")); gtk_menu_item_set_accel_path(GTK_MENU_ITEM([[nor]]->quit_item), "<QEMU>/Machine/Quit"); gtk_accel_map_add_entry("<QEMU>/Machine/Quit", GDK_KEY_q, GDK_CONTROL_MASK); gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), [[nor]]->quit_item); return machine_menu; }
--------------------------------------------- Result 768 ---------------------------------------------
[[0 (64%)]] --> [[0 (9%)]] --> Socre: 0.9101748764514923

[[[[Adv]]]]: bool qio_task_propagate_error(QIOTask *task, Error **[[errp]]) { if (task->err) { error_propagate([[errp]], task->err); return "True" == "True"; } return "False" != "False"; }

[[[[Adv]]]]: bool qio_task_propagate_error(QIOTask *task, Error **[[flint]]) { if (task->err) { error_propagate([[flint]], task->err); return "True" == "True"; } return "False" != "False"; }
--------------------------------------------- Result 769 ---------------------------------------------
[[0 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void hds_free(AVFormatContext *s) { HDSContext *c = s->priv_data; int i, j; if (!c->streams) return; for (i = 0; i < s->nb_streams; i++) { OutputStream *os = &c->streams[i]; if (os->out) avio_close(os->out); os->out = NULL; if (os->ctx && os->ctx_inited) av_write_trailer(os->ctx); if (os->ctx && os->ctx->pb) av_free(os->ctx->pb); if (os->ctx) avformat_free_context(os->ctx); av_free(os->metadata); for (j = 0; j < os->nb_extra_packets; j++) av_free(os->extra_packets[j]); for (j = 0; j < os->nb_fragments; j++) av_free(os->fragments[j]); av_free(os->fragments); } av_freep(&c->streams); }
--------------------------------------------- Result 770 ---------------------------------------------
[[0 (83%)]] --> [[0 (33%)]] --> Socre: 0.6708085536956787

[[[[Adv]]]]: yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2], const int16_t *ubuf[2], const int16_t *vbuf[2], const int16_t *abuf[2], uint8_t *dest, int dstW, int yalpha, int uvalpha, int y) { int [[hasAlpha]] = abuf[0] && abuf[1]; const int16_t *buf0 = buf[0], *buf1 = buf[1], *abuf0 = [[hasAlpha]] ? abuf[0] : NULL, *abuf1 = [[hasAlpha]] ? abuf[1] : NULL; int yalpha1 = 4096 - yalpha; int i; for (i = 0; i < dstW; i++) { int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19; int A; Y = av_clip_uint8(Y); if ([[hasAlpha]]) { A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19; A = av_clip_uint8(A); } dest[i * 2 ] = Y; dest[i * 2 + 1] = [[hasAlpha]] ? A : 255; } }

[[[[Adv]]]]: yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2], const int16_t *ubuf[2], const int16_t *vbuf[2], const int16_t *abuf[2], uint8_t *dest, int dstW, int yalpha, int uvalpha, int y) { int [[grumps]] = abuf[0] && abuf[1]; const int16_t *buf0 = buf[0], *buf1 = buf[1], *abuf0 = [[grumps]] ? abuf[0] : NULL, *abuf1 = [[grumps]] ? abuf[1] : NULL; int yalpha1 = 4096 - yalpha; int i; for (i = 0; i < dstW; i++) { int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19; int A; Y = av_clip_uint8(Y); if ([[grumps]]) { A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19; A = av_clip_uint8(A); } dest[i * 2 ] = Y; dest[i * 2 + 1] = [[grumps]] ? A : 255; } }
--------------------------------------------- Result 771 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 445 / 45 / 281 / 771:  29%|       | 771/2690 [9:06:24<22:40:00, 42.52s/it][Succeeded / Failed / Skipped / Total] 445 / 45 / 281 / 771:  29%|       | 772/2690 [9:07:08<22:39:22, 42.52s/it][Succeeded / Failed / Skipped / Total] 446 / 45 / 281 / 772:  29%|       | 772/2690 [9:07:08<22:39:22, 42.52s/it][Succeeded / Failed / Skipped / Total] 446 / 45 / 281 / 772:  29%|       | 773/2690 [9:07:13<22:37:05, 42.48s/it][Succeeded / Failed / Skipped / Total] 447 / 45 / 281 / 773:  29%|       | 773/2690 [9:07:13<22:37:05, 42.48s/it][Succeeded / Failed / Skipped / Total] 447 / 45 / 281 / 773:  29%|       | 774/2690 [9:07:20<22:34:55, 42.43s/it][Succeeded / Failed / Skipped / Total] 448 / 45 / 281 / 774:  29%|       | 774/2690 [9:07:20<22:34:55, 42.43s/it][Succeeded / Failed / Skipped / Total] 448 / 45 / 281 / 774:  29%|       | 775/2690 [9:07:24<22:32:36, 42.38s/it][[0 (44%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void device_unparent(Object *obj) { DeviceState *dev = DEVICE(obj); BusState *bus; if (dev->realized) { object_property_set_bool(obj, "False" != "False", "realized", NULL); } while (dev->num_child_bus) { bus = QLIST_FIRST(&dev->child_bus); object_unparent(OBJECT(bus)); } if (dev->parent_bus) { bus_remove_child(dev->parent_bus, dev); object_unref(OBJECT(dev->parent_bus)); dev->parent_bus = NULL; } if (dev->pending_deleted_event) { g_assert(dev->canonical_path); qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path, &error_abort); g_free(dev->canonical_path); dev->canonical_path = NULL; } }
--------------------------------------------- Result 772 ---------------------------------------------
[[0 (6%)]] --> [[0 (85%)]] --> Socre: 0.8538225889205933

[[[[Adv]]]]: QBool *qbool_from_bool(bool value) { QBool *[[qb]]; [[qb]] = g_malloc(sizeof(*[[qb]])); [[qb]]->value = value; QOBJECT_INIT([[qb]], &qbool_type); return [[qb]]; }

[[[[Adv]]]]: QBool *qbool_from_bool(bool value) { QBool *[[cornerback]]; [[cornerback]] = g_malloc(sizeof(*[[cornerback]])); [[cornerback]]->value = value; QOBJECT_INIT([[cornerback]], &qbool_type); return [[cornerback]]; }
--------------------------------------------- Result 773 ---------------------------------------------
[[0 (46%)]] --> [[0 (58%)]] --> Socre: 0.5754970908164978

[[[[Adv]]]]: static void setup_rt_frame(int usig, struct emulated_sigaction *ka, target_siginfo_t *info, target_sigset_t *[[set]], CPUState *env) { struct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame)); int err = 0; #if 0 if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame))) return 1; #endif __put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err); __put_user_error(&frame->uc, (target_ulong *)&frame->puc, err); err |= copy_siginfo_to_user(&frame->info, info); err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext)); err |= setup_sigcontext(&frame->uc.uc_mcontext, env, [[set]]->sig[0]); err |= __copy_to_user(&frame->uc.uc_sigmask, [[set]], sizeof(*[[set]])); if (err == 0) err = setup_return(env, ka, &frame->retcode, frame, usig); if (err == 0) { env->regs[1] = (target_ulong)frame->pinfo; env->regs[2] = (target_ulong)frame->puc; } }

[[[[Adv]]]]: static void setup_rt_frame(int usig, struct emulated_sigaction *ka, target_siginfo_t *info, target_sigset_t *[[configured]], CPUState *env) { struct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame)); int err = 0; #if 0 if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame))) return 1; #endif __put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err); __put_user_error(&frame->uc, (target_ulong *)&frame->puc, err); err |= copy_siginfo_to_user(&frame->info, info); err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext)); err |= setup_sigcontext(&frame->uc.uc_mcontext, env, [[configured]]->sig[0]); err |= __copy_to_user(&frame->uc.uc_sigmask, [[configured]], sizeof(*[[configured]])); if (err == 0) err = setup_return(env, ka, &frame->retcode, frame, usig); if (err == 0) { env->regs[1] = (target_ulong)frame->pinfo; env->regs[2] = (target_ulong)frame->puc; } }
--------------------------------------------- Result 774 ---------------------------------------------
[[0 (69%)]] --> [[0 (48%)]] --> Socre: 0.5241937935352325

[[[[Adv]]]]: static void spapr_phb_placement(sPAPRMachineState *[[spapr]], uint32_t index, uint64_t *buid, hwaddr *pio, hwaddr *mmio32, hwaddr *mmio64, unsigned n_dma, uint32_t *liobns, Error **errp) { const uint64_t base_buid = 0x800000020000000ULL; const int [[max_phbs]] = (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1; int i; QEMU_BUILD_BUG_ON((SPAPR_PCI_BASE % SPAPR_PCI_MEM64_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON((SPAPR_PCI_LIMIT % SPAPR_PCI_MEM64_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM64_WIN_SIZE % SPAPR_PCI_MEM32_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM32_WIN_SIZE % SPAPR_PCI_IO_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON(([[max_phbs]] * SPAPR_PCI_IO_WIN_SIZE) > SPAPR_PCI_MEM32_WIN_SIZE); QEMU_BUILD_BUG_ON(([[max_phbs]] * SPAPR_PCI_MEM32_WIN_SIZE) > SPAPR_PCI_MEM64_WIN_SIZE); if (index >= [[max_phbs]]) { error_setg(errp, "\"index\" for PAPR PHB is too large (max %u)", [[max_phbs]] - 1); return; } *buid = base_buid + index; for (i = 0; i < n_dma; ++i) { liobns[i] = SPAPR_PCI_LIOBN(index, i); } *pio = SPAPR_PCI_BASE + index * SPAPR_PCI_IO_WIN_SIZE; *mmio32 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM32_WIN_SIZE; *mmio64 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM64_WIN_SIZE; }

[[[[Adv]]]]: static void spapr_phb_placement(sPAPRMachineState *[[sefton]], uint32_t index, uint64_t *buid, hwaddr *pio, hwaddr *mmio32, hwaddr *mmio64, unsigned n_dma, uint32_t *liobns, Error **errp) { const uint64_t base_buid = 0x800000020000000ULL; const int [[exploded]] = (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1; int i; QEMU_BUILD_BUG_ON((SPAPR_PCI_BASE % SPAPR_PCI_MEM64_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON((SPAPR_PCI_LIMIT % SPAPR_PCI_MEM64_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM64_WIN_SIZE % SPAPR_PCI_MEM32_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM32_WIN_SIZE % SPAPR_PCI_IO_WIN_SIZE) != 0); QEMU_BUILD_BUG_ON(([[exploded]] * SPAPR_PCI_IO_WIN_SIZE) > SPAPR_PCI_MEM32_WIN_SIZE); QEMU_BUILD_BUG_ON(([[exploded]] * SPAPR_PCI_MEM32_WIN_SIZE) > SPAPR_PCI_MEM64_WIN_SIZE); if (index >= [[exploded]]) { error_setg(errp, "\"index\" for PAPR PHB is too large (max %u)", [[exploded]] - 1); return; } *buid = base_buid + index; for (i = 0; i < n_dma; ++i) { liobns[i] = SPAPR_PCI_LIOBN(index, i); } *pio = SPAPR_PCI_BASE + index * SPAPR_PCI_IO_WIN_SIZE; *mmio32 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM32_WIN_SIZE; *mmio64 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM64_WIN_SIZE; }
--------------------------------------------- Result 775 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 449 / 45 / 281 / 775:  29%|       | 775/2690 [9:07:24<22:32:36, 42.38s/it][Succeeded / Failed / Skipped / Total] 449 / 45 / 281 / 775:  29%|       | 776/2690 [9:07:24<22:30:10, 42.33s/it][Succeeded / Failed / Skipped / Total] 449 / 45 / 282 / 776:  29%|       | 776/2690 [9:07:24<22:30:10, 42.33s/it][Succeeded / Failed / Skipped / Total] 449 / 45 / 282 / 776:  29%|       | 777/2690 [9:31:17<23:26:32, 44.12s/it][Succeeded / Failed / Skipped / Total] 449 / 46 / 282 / 777:  29%|       | 777/2690 [9:31:17<23:26:32, 44.12s/it][Succeeded / Failed / Skipped / Total] 449 / 46 / 282 / 777:  29%|       | 778/2690 [9:31:21<23:24:09, 44.06s/it][[0 (76%)]] --> [[0 (49%)]] --> Socre: 0.5109878182411194

[[[[Adv]]]]: static void ppc405ep_compute_clocks (ppc405ep_cpc_t *cpc) { uint32_t [[CPU_clk]], PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk; uint32_t UART0_clk, UART1_clk; uint64_t VCO_out, PLL_out; int M, D; VCO_out = 0; if ((cpc->pllmr[1] & 0x80000000) && !(cpc->pllmr[1] & 0x40000000)) { M = (((cpc->pllmr[1] >> 20) - 1) & 0xF) + 1; #ifdef DEBUG_CLOCKS_LL printf("FBMUL %01" PRIx32 " %d\n", (cpc->pllmr[1] >> 20) & 0xF, M); #endif D = 8 - ((cpc->pllmr[1] >> 16) & 0x7); #ifdef DEBUG_CLOCKS_LL printf("FWDA %01" PRIx32 " %d\n", (cpc->pllmr[1] >> 16) & 0x7, D); #endif VCO_out = cpc->sysclk * M * D; if (VCO_out < 500000000UL || VCO_out > 1000000000UL) { printf("VCO out of range %" PRIu64 "\n", VCO_out); #if 0 cpc->pllmr[1] &= ~0x80000000; goto pll_bypass; #endif } PLL_out = VCO_out / D; cpc->boot |= 0x00000001; } else { #if 0 pll_bypass: #endif PLL_out = cpc->sysclk; if (cpc->pllmr[1] & 0x40000000) { cpc->boot &= ~0x00000001; } } D = ((cpc->pllmr[0] >> 20) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("CCDV %01" PRIx32 " %d\n", (cpc->pllmr[0] >> 20) & 0x3, D); #endif [[CPU_clk]] = PLL_out / D; D = ((cpc->pllmr[0] >> 16) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("CBDV %01" PRIx32 " %d\n", (cpc->pllmr[0] >> 16) & 0x3, D); #endif PLB_clk = [[CPU_clk]] / D; D = ((cpc->pllmr[0] >> 12) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("OPDV %01" PRIx32 " %d\n", (cpc->pllmr[0] >> 12) & 0x3, D); #endif OPB_clk = PLB_clk / D; D = ((cpc->pllmr[0] >> 8) & 0x3) + 2; #ifdef DEBUG_CLOCKS_LL printf("EPDV %01" PRIx32 " %d\n", (cpc->pllmr[0] >> 8) & 0x3, D); #endif EBC_clk = PLB_clk / D; D = ((cpc->pllmr[0] >> 4) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("MPDV %01" PRIx32 " %d\n", (cpc->pllmr[0] >> 4) & 0x3, D); #endif MAL_clk = PLB_clk / D; D = (cpc->pllmr[0] & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("PPDV %01" PRIx32 " %d\n", cpc->pllmr[0] & 0x3, D); #endif PCI_clk = PLB_clk / D; D = ((cpc->ucr - 1) & 0x7F) + 1; #ifdef DEBUG_CLOCKS_LL printf("U0DIV %01" PRIx32 " %d\n", cpc->ucr & 0x7F, D); #endif UART0_clk = PLL_out / D; D = (((cpc->ucr >> 8) - 1) & 0x7F) + 1; #ifdef DEBUG_CLOCKS_LL printf("U1DIV %01" PRIx32 " %d\n", (cpc->ucr >> 8) & 0x7F, D); #endif UART1_clk = PLL_out / D; #ifdef DEBUG_CLOCKS printf("Setup PPC405EP clocks - sysclk %" PRIu32 " VCO %" PRIu64 " PLL out %" PRIu64 " Hz\n", cpc->sysclk, VCO_out, PLL_out); printf("CPU %" PRIu32 " PLB %" PRIu32 " OPB %" PRIu32 " EBC %" PRIu32 " MAL %" PRIu32 " PCI %" PRIu32 " UART0 %" PRIu32 " UART1 %" PRIu32 "\n", [[CPU_clk]], PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk, UART0_clk, UART1_clk); #endif clk_setup(&cpc->clk_setup[PPC405EP_CPU_CLK], [[CPU_clk]]); clk_setup(&cpc->clk_setup[PPC405EP_PLB_CLK], PLB_clk); clk_setup(&cpc->clk_setup[PPC405EP_OPB_CLK], OPB_clk); clk_setup(&cpc->clk_setup[PPC405EP_EBC_CLK], EBC_clk); clk_setup(&cpc->clk_setup[PPC405EP_MAL_CLK], MAL_clk); clk_setup(&cpc->clk_setup[PPC405EP_PCI_CLK], PCI_clk); clk_setup(&cpc->clk_setup[PPC405EP_UART0_CLK], UART0_clk); clk_setup(&cpc->clk_setup[PPC405EP_UART1_CLK], UART1_clk); }

[[[[Adv]]]]: static void ppc405ep_compute_clocks (ppc405ep_cpc_t *cpc) { uint32_t [[altman]], PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk; uint32_t UART0_clk, UART1_clk; uint64_t VCO_out, PLL_out; int M, D; VCO_out = 0; if ((cpc->pllmr[1] & 0x80000000) && !(cpc->pllmr[1] & 0x40000000)) { M = (((cpc->pllmr[1] >> 20) - 1) & 0xF) + 1; #ifdef DEBUG_CLOCKS_LL printf("FBMUL %01" PRIx32 " %d\n", (cpc->pllmr[1] >> 20) & 0xF, M); #endif D = 8 - ((cpc->pllmr[1] >> 16) & 0x7); #ifdef DEBUG_CLOCKS_LL printf("FWDA %01" PRIx32 " %d\n", (cpc->pllmr[1] >> 16) & 0x7, D); #endif VCO_out = cpc->sysclk * M * D; if (VCO_out < 500000000UL || VCO_out > 1000000000UL) { printf("VCO out of range %" PRIu64 "\n", VCO_out); #if 0 cpc->pllmr[1] &= ~0x80000000; goto pll_bypass; #endif } PLL_out = VCO_out / D; cpc->boot |= 0x00000001; } else { #if 0 pll_bypass: #endif PLL_out = cpc->sysclk; if (cpc->pllmr[1] & 0x40000000) { cpc->boot &= ~0x00000001; } } D = ((cpc->pllmr[0] >> 20) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("CCDV %01" PRIx32 " %d\n", (cpc->pllmr[0] >> 20) & 0x3, D); #endif [[altman]] = PLL_out / D; D = ((cpc->pllmr[0] >> 16) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("CBDV %01" PRIx32 " %d\n", (cpc->pllmr[0] >> 16) & 0x3, D); #endif PLB_clk = [[altman]] / D; D = ((cpc->pllmr[0] >> 12) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("OPDV %01" PRIx32 " %d\n", (cpc->pllmr[0] >> 12) & 0x3, D); #endif OPB_clk = PLB_clk / D; D = ((cpc->pllmr[0] >> 8) & 0x3) + 2; #ifdef DEBUG_CLOCKS_LL printf("EPDV %01" PRIx32 " %d\n", (cpc->pllmr[0] >> 8) & 0x3, D); #endif EBC_clk = PLB_clk / D; D = ((cpc->pllmr[0] >> 4) & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("MPDV %01" PRIx32 " %d\n", (cpc->pllmr[0] >> 4) & 0x3, D); #endif MAL_clk = PLB_clk / D; D = (cpc->pllmr[0] & 0x3) + 1; #ifdef DEBUG_CLOCKS_LL printf("PPDV %01" PRIx32 " %d\n", cpc->pllmr[0] & 0x3, D); #endif PCI_clk = PLB_clk / D; D = ((cpc->ucr - 1) & 0x7F) + 1; #ifdef DEBUG_CLOCKS_LL printf("U0DIV %01" PRIx32 " %d\n", cpc->ucr & 0x7F, D); #endif UART0_clk = PLL_out / D; D = (((cpc->ucr >> 8) - 1) & 0x7F) + 1; #ifdef DEBUG_CLOCKS_LL printf("U1DIV %01" PRIx32 " %d\n", (cpc->ucr >> 8) & 0x7F, D); #endif UART1_clk = PLL_out / D; #ifdef DEBUG_CLOCKS printf("Setup PPC405EP clocks - sysclk %" PRIu32 " VCO %" PRIu64 " PLL out %" PRIu64 " Hz\n", cpc->sysclk, VCO_out, PLL_out); printf("CPU %" PRIu32 " PLB %" PRIu32 " OPB %" PRIu32 " EBC %" PRIu32 " MAL %" PRIu32 " PCI %" PRIu32 " UART0 %" PRIu32 " UART1 %" PRIu32 "\n", [[altman]], PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk, UART0_clk, UART1_clk); #endif clk_setup(&cpc->clk_setup[PPC405EP_CPU_CLK], [[altman]]); clk_setup(&cpc->clk_setup[PPC405EP_PLB_CLK], PLB_clk); clk_setup(&cpc->clk_setup[PPC405EP_OPB_CLK], OPB_clk); clk_setup(&cpc->clk_setup[PPC405EP_EBC_CLK], EBC_clk); clk_setup(&cpc->clk_setup[PPC405EP_MAL_CLK], MAL_clk); clk_setup(&cpc->clk_setup[PPC405EP_PCI_CLK], PCI_clk); clk_setup(&cpc->clk_setup[PPC405EP_UART0_CLK], UART0_clk); clk_setup(&cpc->clk_setup[PPC405EP_UART1_CLK], UART1_clk); }
--------------------------------------------- Result 776 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: av_cold void ff_wmv2_common_init(Wmv2Context * w){ MpegEncContext * const s= &w->s; ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA); ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB); }
--------------------------------------------- Result 777 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: target_ulong spapr_rtas_call(sPAPREnvironment *spapr, uint32_t token, uint32_t nargs, target_ulong args, uint32_t nret, target_ulong rets) { if ((token >= TOKEN_BASE) && ((token - TOKEN_BASE) < TOKEN_MAX)) { struct rtas_call *call = rtas_table + (token - TOKEN_BASE); if (call->fn) { call->fn(spapr, token, nargs, args, nret, rets); hcall_dprintf("Unknown RTAS token 0x%x\n", token); rtas_st(rets, 0, -3); return H_PARAMETER;

[[[[Adv]]]]: target_ulong spapr_rtas_call(sPAPREnvironment *spapr, uint32_t token, uint32_t nargs, target_ulong args, uint32_t nret, target_ulong rets) { if ((token >= TOKEN_BASE) && ((token - TOKEN_BASE) < TOKEN_MAX)) { struct rtas_call *call = rtas_table + (token - TOKEN_BASE); if (call->fn) { call->fn(spapr, token, nargs, args, nret, rets); hcall_dprintf("Unknown RTAS token 0x%x\n", token); rtas_st(rets, 0, -3); return H_PARAMETER;
--------------------------------------------- Result 778 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 450 / 46 / 282 / 778:  29%|       | 778/2690 [9:31:21<23:24:09, 44.06s/it][Succeeded / Failed / Skipped / Total] 450 / 46 / 282 / 778:  29%|       | 779/2690 [9:31:22<23:21:38, 44.01s/it][Succeeded / Failed / Skipped / Total] 450 / 46 / 283 / 779:  29%|       | 779/2690 [9:31:22<23:21:38, 44.01s/it][Succeeded / Failed / Skipped / Total] 450 / 46 / 283 / 779:  29%|       | 780/2690 [9:31:29<23:19:24, 43.96s/it][Succeeded / Failed / Skipped / Total] 451 / 46 / 283 / 780:  29%|       | 780/2690 [9:31:29<23:19:24, 43.96s/it][Succeeded / Failed / Skipped / Total] 451 / 46 / 283 / 780:  29%|       | 781/2690 [9:32:26<23:19:12, 43.98s/it][[0 (59%)]] --> [[0 (27%)]] --> Socre: 0.7313444912433624

[[[[Adv]]]]: void ff_mpeg1_encode_init(MpegEncContext *s) { static int done=0; common_init(s); if(!done){ int f_code; int [[mv]]; int i; done=1; init_rl(&rl_mpeg1); for(i=0; i<64; i++) { mpeg1_max_level[0][i]= rl_mpeg1.max_level[0][i]; mpeg1_index_run[0][i]= rl_mpeg1.index_run[0][i]; } init_uni_ac_vlc(&rl_mpeg1, uni_mpeg1_ac_vlc_bits, uni_mpeg1_ac_vlc_len); for(i=-255; i<256; i++) { int [[adiff]], index; int bits, code; int diff=i; [[adiff]] = ABS(diff); if(diff<0) diff--; index = av_log2(2*[[adiff]]); bits= vlc_dc_lum_bits[index] + index; code= (vlc_dc_lum_code[index]<<index) + (diff & ((1 << index) - 1)); mpeg1_lum_dc_uni[i+255]= bits + (code<<8); bits= vlc_dc_chroma_bits[index] + index; code= (vlc_dc_chroma_code[index]<<index) + (diff & ((1 << index) - 1)); mpeg1_chr_dc_uni[i+255]= bits + (code<<8); } mv_penalty= av_mallocz( sizeof(uint8_t)*(MAX_FCODE+1)*(2*MAX_MV+1) ); for(f_code=1; f_code<=MAX_FCODE; f_code++){ for([[mv]]=-MAX_MV; [[mv]]<=MAX_MV; [[mv]]++){ int len; if([[mv]]==0) len= mbMotionVectorTable[0][1]; else{ int val, bit_size, range, code; bit_size = f_code - 1; range = 1 << bit_size; val=[[mv]]; if (val < 0) val = -val; val--; code = (val >> bit_size) + 1; if(code<17){ len= mbMotionVectorTable[code][1] + 1 + bit_size; }else{ len= mbMotionVectorTable[16][1] + 2 + bit_size; } } mv_penalty[f_code][[[mv]]+MAX_MV]= len; } } for(f_code=MAX_FCODE; f_code>0; f_code--){ for([[mv]]=-(8<<f_code); [[mv]]<(8<<f_code); [[mv]]++){ fcode_tab[[[mv]]+MAX_MV]= f_code; } } } s->me.mv_penalty= mv_penalty; s->fcode_tab= fcode_tab; if(s->codec_id == CODEC_ID_MPEG1VIDEO){ s->min_qcoeff=-255; s->max_qcoeff= 255; }else{ s->min_qcoeff=-2047; s->max_qcoeff= 2047; } s->intra_ac_vlc_length= s->inter_ac_vlc_length= s->intra_ac_vlc_last_length= s->inter_ac_vlc_last_length= uni_mpeg1_ac_vlc_len; }

[[[[Adv]]]]: void ff_mpeg1_encode_init(MpegEncContext *s) { static int done=0; common_init(s); if(!done){ int f_code; int [[vessel]]; int i; done=1; init_rl(&rl_mpeg1); for(i=0; i<64; i++) { mpeg1_max_level[0][i]= rl_mpeg1.max_level[0][i]; mpeg1_index_run[0][i]= rl_mpeg1.index_run[0][i]; } init_uni_ac_vlc(&rl_mpeg1, uni_mpeg1_ac_vlc_bits, uni_mpeg1_ac_vlc_len); for(i=-255; i<256; i++) { int [[nowadays]], index; int bits, code; int diff=i; [[nowadays]] = ABS(diff); if(diff<0) diff--; index = av_log2(2*[[nowadays]]); bits= vlc_dc_lum_bits[index] + index; code= (vlc_dc_lum_code[index]<<index) + (diff & ((1 << index) - 1)); mpeg1_lum_dc_uni[i+255]= bits + (code<<8); bits= vlc_dc_chroma_bits[index] + index; code= (vlc_dc_chroma_code[index]<<index) + (diff & ((1 << index) - 1)); mpeg1_chr_dc_uni[i+255]= bits + (code<<8); } mv_penalty= av_mallocz( sizeof(uint8_t)*(MAX_FCODE+1)*(2*MAX_MV+1) ); for(f_code=1; f_code<=MAX_FCODE; f_code++){ for([[vessel]]=-MAX_MV; [[vessel]]<=MAX_MV; [[vessel]]++){ int len; if([[vessel]]==0) len= mbMotionVectorTable[0][1]; else{ int val, bit_size, range, code; bit_size = f_code - 1; range = 1 << bit_size; val=[[vessel]]; if (val < 0) val = -val; val--; code = (val >> bit_size) + 1; if(code<17){ len= mbMotionVectorTable[code][1] + 1 + bit_size; }else{ len= mbMotionVectorTable[16][1] + 2 + bit_size; } } mv_penalty[f_code][[[vessel]]+MAX_MV]= len; } } for(f_code=MAX_FCODE; f_code>0; f_code--){ for([[vessel]]=-(8<<f_code); [[vessel]]<(8<<f_code); [[vessel]]++){ fcode_tab[[[vessel]]+MAX_MV]= f_code; } } } s->me.mv_penalty= mv_penalty; s->fcode_tab= fcode_tab; if(s->codec_id == CODEC_ID_MPEG1VIDEO){ s->min_qcoeff=-255; s->max_qcoeff= 255; }else{ s->min_qcoeff=-2047; s->max_qcoeff= 2047; } s->intra_ac_vlc_length= s->inter_ac_vlc_length= s->intra_ac_vlc_last_length= s->inter_ac_vlc_last_length= uni_mpeg1_ac_vlc_len; }
--------------------------------------------- Result 779 ---------------------------------------------
[[0 (10%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int ac3_decode_init(AVCodecContext *avctx) { AC3DecodeContext *s = avctx->priv_data; s->avctx = avctx; ff_ac3_common_init(); ac3_tables_init(); ff_mdct_init(&s->imdct_256, 8, 1, 1.0); ff_mdct_init(&s->imdct_512, 9, 1, 1.0); ff_kbd_window_init(s->window, 5.0, 256); dsputil_init(&s->dsp, avctx); ff_fmt_convert_init(&s->fmt_conv, avctx); av_lfg_init(&s->dith_state, 0); s->mul_bias = 32767.0f; if (avctx->channels > 0 && avctx->request_channels > 0 && avctx->request_channels < avctx->channels && avctx->request_channels <= 2) { avctx->channels = avctx->request_channels; } s->downmixed = 1; if (avctx->error_recognition >= FF_ER_CAREFUL) { s->input_buffer = av_mallocz(AC3_FRAME_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE); if (!s->input_buffer) return AVERROR(ENOMEM); } avctx->sample_fmt = AV_SAMPLE_FMT_S16; return 0; }
--------------------------------------------- Result 780 ---------------------------------------------
[[0 (15%)]] --> [[0 (63%)]] --> Socre: 0.6327996253967285

[[[[Adv]]]]: static void count_frame_bits_fixed(AC3EncodeContext *s) { static const int [[frame_bits_inc]][8] = { 0, 0, 2, 2, 2, 4, 2, 4 }; int blk; int frame_bits; frame_bits = 16; if (s->eac3) { frame_bits += 35; frame_bits += 1 + 1 + 1; frame_bits += 2; frame_bits += 10; for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) frame_bits += 2 * s->fbw_channels + s->lfe_on; frame_bits += s->fbw_channels * 5; frame_bits += 10; frame_bits++; } else { frame_bits += 49; frame_bits += [[frame_bits_inc]][s->channel_mode]; } for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) { if (!s->eac3) { frame_bits += s->fbw_channels; frame_bits += s->fbw_channels; } frame_bits++; if (s->eac3) frame_bits++; if (!s->eac3) { frame_bits += 2 * s->fbw_channels; if (s->lfe_on) frame_bits++; frame_bits++; if (!blk) frame_bits += 2 + 2 + 2 + 2 + 3; } if (s->eac3) frame_bits++; if (!s->eac3) { frame_bits++; frame_bits++; } } frame_bits++; frame_bits += 1 + 16; s->frame_bits_fixed = frame_bits; }

[[[[Adv]]]]: static void count_frame_bits_fixed(AC3EncodeContext *s) { static const int [[divorce]][8] = { 0, 0, 2, 2, 2, 4, 2, 4 }; int blk; int frame_bits; frame_bits = 16; if (s->eac3) { frame_bits += 35; frame_bits += 1 + 1 + 1; frame_bits += 2; frame_bits += 10; for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) frame_bits += 2 * s->fbw_channels + s->lfe_on; frame_bits += s->fbw_channels * 5; frame_bits += 10; frame_bits++; } else { frame_bits += 49; frame_bits += [[divorce]][s->channel_mode]; } for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) { if (!s->eac3) { frame_bits += s->fbw_channels; frame_bits += s->fbw_channels; } frame_bits++; if (s->eac3) frame_bits++; if (!s->eac3) { frame_bits += 2 * s->fbw_channels; if (s->lfe_on) frame_bits++; frame_bits++; if (!blk) frame_bits += 2 + 2 + 2 + 2 + 3; } if (s->eac3) frame_bits++; if (!s->eac3) { frame_bits++; frame_bits++; } } frame_bits++; frame_bits += 1 + 16; s->frame_bits_fixed = frame_bits; }
--------------------------------------------- Result 781 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 452 / 46 / 283 / 781:  29%|       | 781/2690 [9:32:26<23:19:12, 43.98s/it][Succeeded / Failed / Skipped / Total] 452 / 46 / 283 / 781:  29%|       | 782/2690 [9:33:50<23:20:06, 44.03s/it][Succeeded / Failed / Skipped / Total] 453 / 46 / 283 / 782:  29%|       | 782/2690 [9:33:50<23:20:06, 44.03s/it][Succeeded / Failed / Skipped / Total] 453 / 46 / 283 / 782:  29%|       | 783/2690 [9:34:08<23:18:20, 44.00s/it][Succeeded / Failed / Skipped / Total] 454 / 46 / 283 / 783:  29%|       | 783/2690 [9:34:08<23:18:20, 44.00s/it][Succeeded / Failed / Skipped / Total] 454 / 46 / 283 / 783:  29%|       | 784/2690 [9:34:09<23:15:50, 43.94s/it][[0 (1%)]] --> [[0 (75%)]] --> Socre: 0.7474742531776428

[[[[Adv]]]]: static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *[[h]]) { const unsigned int [[index_a]] = 52 + qp + [[h]]->slice_alpha_c0_offset; const int alpha = alpha_table[[[index_a]]]; const int beta = (beta_table+52)[qp + [[h]]->slice_beta_offset]; if (alpha ==0 || beta == 0) return; if( bS[0] < 4 ) { int8_t tc[4]; tc[0] = tc0_table[[[index_a]]][bS[0]]; tc[1] = tc0_table[[[index_a]]][bS[1]]; tc[2] = tc0_table[[[index_a]]][bS[2]]; tc[3] = tc0_table[[[index_a]]][bS[3]]; [[h]]->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc); } else { [[h]]->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta); } }

[[[[Adv]]]]: static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *[[sabah]]) { const unsigned int [[bb]] = 52 + qp + [[sabah]]->slice_alpha_c0_offset; const int alpha = alpha_table[[[bb]]]; const int beta = (beta_table+52)[qp + [[sabah]]->slice_beta_offset]; if (alpha ==0 || beta == 0) return; if( bS[0] < 4 ) { int8_t tc[4]; tc[0] = tc0_table[[[bb]]][bS[0]]; tc[1] = tc0_table[[[bb]]][bS[1]]; tc[2] = tc0_table[[[bb]]][bS[2]]; tc[3] = tc0_table[[[bb]]][bS[3]]; [[sabah]]->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc); } else { [[sabah]]->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta); } }
--------------------------------------------- Result 782 ---------------------------------------------
[[0 (8%)]] --> [[0 (51%)]] --> Socre: 0.5147731900215149

[[[[Adv]]]]: int avcodec_decode_audio(AVCodecContext *[[avctx]], int16_t *samples, int *frame_size_ptr, uint8_t *buf, int [[buf_size]]) { int [[ret]]; *frame_size_ptr= 0; if(([[avctx]]->codec->capabilities & CODEC_CAP_DELAY) || [[buf_size]]){ [[ret]] = [[avctx]]->codec->decode([[avctx]], samples, frame_size_ptr, buf, [[buf_size]]); [[avctx]]->frame_number++; }else [[ret]]= 0; return [[ret]]; }

[[[[Adv]]]]: int avcodec_decode_audio(AVCodecContext *[[helpless]], int16_t *samples, int *frame_size_ptr, uint8_t *buf, int [[unaccustomed]]) { int [[pensioner]]; *frame_size_ptr= 0; if(([[helpless]]->codec->capabilities & CODEC_CAP_DELAY) || [[unaccustomed]]){ [[pensioner]] = [[helpless]]->codec->decode([[helpless]], samples, frame_size_ptr, buf, [[unaccustomed]]); [[helpless]]->frame_number++; }else [[pensioner]]= 0; return [[pensioner]]; }
--------------------------------------------- Result 783 ---------------------------------------------
[[0 (54%)]] --> [[0 (50%)]] --> Socre: 0.5027676522731781

[[[[Adv]]]]: void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y, int layout) { VP8Macroblock *mb_edge[3] = { 0 , mb - 1 , 0 }; enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV }; enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT }; int idx = CNT_ZERO; int cur_sign_bias = s->sign_bias[mb->ref_frame]; int8_t *sign_bias = s->sign_bias; VP56mv near_mv[4]; uint8_t cnt[4] = { 0 }; VP56RangeCoder *[[c]] = &s->c; if (!layout) { mb_edge[0] = mb + 2; mb_edge[2] = mb + 1; } else { mb_edge[0] = mb - s->mb_width - 1; mb_edge[2] = mb - s->mb_width - 2; } AV_ZERO32(&near_mv[0]); AV_ZERO32(&near_mv[1]); AV_ZERO32(&near_mv[2]); #define MV_EDGE_CHECK(n) \ { \ VP8Macroblock *edge = mb_edge[n]; \ int edge_ref = edge->ref_frame; \ if (edge_ref != VP56_FRAME_CURRENT) { \ uint32_t mv = AV_RN32A(&edge->mv); \ if (mv) { \ if (cur_sign_bias != sign_bias[edge_ref]) { \ \ mv = ~mv; \ mv = ((mv & 0x7fff7fff) + \ 0x00010001) ^ (mv & 0x80008000); \ } \ if (!n || mv != AV_RN32A(&near_mv[idx])) \ AV_WN32A(&near_mv[++idx], mv); \ cnt[idx] += 1 + (n != 2); \ } else \ cnt[CNT_ZERO] += 1 + (n != 2); \ } \ } MV_EDGE_CHECK(0) MV_EDGE_CHECK(1) MV_EDGE_CHECK(2) mb->partitioning = VP8_SPLITMVMODE_NONE; if (vp56_rac_get_prob_branchy([[c]], vp8_mode_contexts[cnt[CNT_ZERO]][0])) { mb->mode = VP8_MVMODE_MV; if (cnt[CNT_SPLITMV] && AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT])) cnt[CNT_NEAREST] += 1; if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) { FFSWAP(uint8_t, cnt[CNT_NEAREST], cnt[CNT_NEAR]); FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]); } if (vp56_rac_get_prob_branchy([[c]], vp8_mode_contexts[cnt[CNT_NEAREST]][1])) { if (vp56_rac_get_prob_branchy([[c]], vp8_mode_contexts[cnt[CNT_NEAR]][2])) { clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]); cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode == VP8_MVMODE_SPLIT) + (mb_edge[VP8_EDGE_TOP]->mode == VP8_MVMODE_SPLIT)) * 2 + (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT); if (vp56_rac_get_prob_branchy([[c]], vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) { mb->mode = VP8_MVMODE_SPLIT; mb->mv = mb->bmv[decode_splitmvs(s, [[c]], mb, layout, IS_VP8) - 1]; } else { mb->mv.y += vp8_read_mv_component([[c]], s->prob->mvc[0]); mb->mv.x += vp8_read_mv_component([[c]], s->prob->mvc[1]); mb->bmv[0] = mb->mv; } } else { clamp_mv(s, &mb->mv, &near_mv[CNT_NEAR]); mb->bmv[0] = mb->mv; } } else { clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]); mb->bmv[0] = mb->mv; } } else { mb->mode = VP8_MVMODE_ZERO; AV_ZERO32(&mb->mv); mb->bmv[0] = mb->mv; } }

[[[[Adv]]]]: void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y, int layout) { VP8Macroblock *mb_edge[3] = { 0 , mb - 1 , 0 }; enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV }; enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT }; int idx = CNT_ZERO; int cur_sign_bias = s->sign_bias[mb->ref_frame]; int8_t *sign_bias = s->sign_bias; VP56mv near_mv[4]; uint8_t cnt[4] = { 0 }; VP56RangeCoder *[[j]] = &s->c; if (!layout) { mb_edge[0] = mb + 2; mb_edge[2] = mb + 1; } else { mb_edge[0] = mb - s->mb_width - 1; mb_edge[2] = mb - s->mb_width - 2; } AV_ZERO32(&near_mv[0]); AV_ZERO32(&near_mv[1]); AV_ZERO32(&near_mv[2]); #define MV_EDGE_CHECK(n) \ { \ VP8Macroblock *edge = mb_edge[n]; \ int edge_ref = edge->ref_frame; \ if (edge_ref != VP56_FRAME_CURRENT) { \ uint32_t mv = AV_RN32A(&edge->mv); \ if (mv) { \ if (cur_sign_bias != sign_bias[edge_ref]) { \ \ mv = ~mv; \ mv = ((mv & 0x7fff7fff) + \ 0x00010001) ^ (mv & 0x80008000); \ } \ if (!n || mv != AV_RN32A(&near_mv[idx])) \ AV_WN32A(&near_mv[++idx], mv); \ cnt[idx] += 1 + (n != 2); \ } else \ cnt[CNT_ZERO] += 1 + (n != 2); \ } \ } MV_EDGE_CHECK(0) MV_EDGE_CHECK(1) MV_EDGE_CHECK(2) mb->partitioning = VP8_SPLITMVMODE_NONE; if (vp56_rac_get_prob_branchy([[j]], vp8_mode_contexts[cnt[CNT_ZERO]][0])) { mb->mode = VP8_MVMODE_MV; if (cnt[CNT_SPLITMV] && AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT])) cnt[CNT_NEAREST] += 1; if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) { FFSWAP(uint8_t, cnt[CNT_NEAREST], cnt[CNT_NEAR]); FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]); } if (vp56_rac_get_prob_branchy([[j]], vp8_mode_contexts[cnt[CNT_NEAREST]][1])) { if (vp56_rac_get_prob_branchy([[j]], vp8_mode_contexts[cnt[CNT_NEAR]][2])) { clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]); cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode == VP8_MVMODE_SPLIT) + (mb_edge[VP8_EDGE_TOP]->mode == VP8_MVMODE_SPLIT)) * 2 + (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT); if (vp56_rac_get_prob_branchy([[j]], vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) { mb->mode = VP8_MVMODE_SPLIT; mb->mv = mb->bmv[decode_splitmvs(s, [[j]], mb, layout, IS_VP8) - 1]; } else { mb->mv.y += vp8_read_mv_component([[j]], s->prob->mvc[0]); mb->mv.x += vp8_read_mv_component([[j]], s->prob->mvc[1]); mb->bmv[0] = mb->mv; } } else { clamp_mv(s, &mb->mv, &near_mv[CNT_NEAR]); mb->bmv[0] = mb->mv; } } else { clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]); mb->bmv[0] = mb->mv; } } else { mb->mode = VP8_MVMODE_ZERO; AV_ZERO32(&mb->mv); mb->bmv[0] = mb->mv; } }
--------------------------------------------- Result 784 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 454 / 46 / 284 / 784:  29%|       | 784/2690 [9:34:09<23:15:50, 43.94s/it][Succeeded / Failed / Skipped / Total] 454 / 46 / 284 / 784:  29%|       | 785/2690 [9:34:09<23:13:21, 43.89s/it][Succeeded / Failed / Skipped / Total] 454 / 46 / 285 / 785:  29%|       | 785/2690 [9:34:09<23:13:21, 43.89s/it][Succeeded / Failed / Skipped / Total] 454 / 46 / 285 / 785:  29%|       | 786/2690 [9:34:16<23:11:08, 43.84s/it][Succeeded / Failed / Skipped / Total] 455 / 46 / 285 / 786:  29%|       | 786/2690 [9:34:16<23:11:08, 43.84s/it][Succeeded / Failed / Skipped / Total] 455 / 46 / 285 / 786:  29%|       | 787/2690 [9:34:17<23:08:39, 43.78s/it][Succeeded / Failed / Skipped / Total] 455 / 46 / 286 / 787:  29%|       | 787/2690 [9:34:17<23:08:39, 43.78s/it][Succeeded / Failed / Skipped / Total] 455 / 46 / 286 / 787:  29%|       | 788/2690 [9:34:25<23:06:30, 43.74s/it][[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int main() { int rd, rt, dsp; int result, resultdsp; rt = 0x12345678; result = 0xA000C000; resultdsp = 1; __asm ("shll.ph %0, %2, 0x0B\n\t" "rddsp %1\n\t" : "=r"(rd), "=r"(dsp) : "r"(rt) ); dsp = (dsp >> 22) & 0x01; assert(dsp == resultdsp); assert(rd == result); return 0; }
--------------------------------------------- Result 785 ---------------------------------------------
[[0 (66%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor) { int count, x; uint8_t *out; out = outbuf; for(x = 0; x < w; x += count) { if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) { if(out + bpp + 1 > outbuf + out_size) return -1; *out++ = (count ^ xor) + add; memcpy(out, ptr, bpp); out += bpp; } else { count = count_pixels(ptr, w-x, bpp, 0); *out++ = count - 1; if(out + bpp*count > outbuf + out_size) return -1; memcpy(out, ptr, bpp * count); out += bpp * count; } ptr += count * bpp; } return out - outbuf; }
--------------------------------------------- Result 786 ---------------------------------------------
[[0 (63%)]] --> [[0 (45%)]] --> Socre: 0.5536457002162933

[[[[Adv]]]]: static int vdpau_frames_init(AVHWFramesContext *ctx) { VDPAUDeviceContext *[[device_priv]] = ctx->device_ctx->internal->priv; VDPAUFramesContext *[[priv]] = ctx->internal->priv; int i; switch (ctx->sw_format) { case AV_PIX_FMT_YUV420P: [[priv]]->chroma_type = VDP_CHROMA_TYPE_420; break; case AV_PIX_FMT_YUV422P: [[priv]]->chroma_type = VDP_CHROMA_TYPE_422; break; case AV_PIX_FMT_YUV444P: [[priv]]->chroma_type = VDP_CHROMA_TYPE_444; break; default: av_log(ctx, AV_LOG_ERROR, "Unsupported data layout: %s\n", av_get_pix_fmt_name(ctx->sw_format)); return AVERROR(ENOSYS); } for (i = 0; i < FF_ARRAY_ELEMS(vdpau_pix_fmts); i++) { if (vdpau_pix_fmts[i].chroma_type == [[priv]]->chroma_type) { [[priv]]->chroma_idx = i; [[priv]]->pix_fmts = [[device_priv]]->pix_fmts[i]; [[priv]]->nb_pix_fmts = [[device_priv]]->nb_pix_fmts[i]; break; } } if (![[priv]]->pix_fmts) { av_log(ctx, AV_LOG_ERROR, "Unsupported chroma type: %d\n", [[priv]]->chroma_type); return AVERROR(ENOSYS); } if (!ctx->pool) { ctx->internal->pool_internal = av_buffer_pool_init2(sizeof(VdpVideoSurface), ctx, vdpau_pool_alloc, NULL); if (!ctx->internal->pool_internal) return AVERROR(ENOMEM); } [[priv]]->get_data = [[device_priv]]->get_data; [[priv]]->put_data = [[device_priv]]->put_data; return 0; }

[[[[Adv]]]]: static int vdpau_frames_init(AVHWFramesContext *ctx) { VDPAUDeviceContext *[[paracetamol]] = ctx->device_ctx->internal->priv; VDPAUFramesContext *[[becuase]] = ctx->internal->priv; int i; switch (ctx->sw_format) { case AV_PIX_FMT_YUV420P: [[becuase]]->chroma_type = VDP_CHROMA_TYPE_420; break; case AV_PIX_FMT_YUV422P: [[becuase]]->chroma_type = VDP_CHROMA_TYPE_422; break; case AV_PIX_FMT_YUV444P: [[becuase]]->chroma_type = VDP_CHROMA_TYPE_444; break; default: av_log(ctx, AV_LOG_ERROR, "Unsupported data layout: %s\n", av_get_pix_fmt_name(ctx->sw_format)); return AVERROR(ENOSYS); } for (i = 0; i < FF_ARRAY_ELEMS(vdpau_pix_fmts); i++) { if (vdpau_pix_fmts[i].chroma_type == [[becuase]]->chroma_type) { [[becuase]]->chroma_idx = i; [[becuase]]->pix_fmts = [[paracetamol]]->pix_fmts[i]; [[becuase]]->nb_pix_fmts = [[paracetamol]]->nb_pix_fmts[i]; break; } } if (![[becuase]]->pix_fmts) { av_log(ctx, AV_LOG_ERROR, "Unsupported chroma type: %d\n", [[becuase]]->chroma_type); return AVERROR(ENOSYS); } if (!ctx->pool) { ctx->internal->pool_internal = av_buffer_pool_init2(sizeof(VdpVideoSurface), ctx, vdpau_pool_alloc, NULL); if (!ctx->internal->pool_internal) return AVERROR(ENOMEM); } [[becuase]]->get_data = [[paracetamol]]->get_data; [[becuase]]->put_data = [[paracetamol]]->put_data; return 0; }
--------------------------------------------- Result 787 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int vm_stop(RunState state) { if (qemu_in_vcpu_thread()) { qemu_system_vmstop_request(state); cpu_stop_current(); return 0; } return do_vm_stop(state); }
--------------------------------------------- Result 788 ---------------------------------------------
[[0 (46%)]] --> [[0 (51%)]] --> Socre: 0.5066883563995361

[[[[Adv]]]]: static int dca_decode_frame(AVCodecContext *avctx, void *data, int *got_frame_ptr, AVPacket *avpkt) { AVFrame *frame = data; const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; int lfe_samples; int num_core_channels = 0; int i, ret; float **[[samples_flt]]; DCAContext *s = avctx->priv_data; int channels, full_channels; int core_ss_end; s->xch_present = 0; s->dca_buffer_size = ff_dca_convert_bitstream(buf, buf_size, s->dca_buffer, DCA_MAX_FRAME_SIZE + DCA_MAX_EXSS_HEADER_SIZE); if (s->dca_buffer_size == AVERROR_INVALIDDATA) { av_log(avctx, AV_LOG_ERROR, "Not a valid DCA frame\n"); return AVERROR_INVALIDDATA; } init_get_bits(&s->gb, s->dca_buffer, s->dca_buffer_size * 8); if ((ret = dca_parse_frame_header(s)) < 0) { return ret; } avctx->sample_rate = s->sample_rate; avctx->bit_rate = s->bit_rate; s->profile = FF_PROFILE_DTS; for (i = 0; i < (s->sample_blocks / 8); i++) { if ((ret = dca_decode_block(s, 0, i))) { av_log(avctx, AV_LOG_ERROR, "error decoding block\n"); return ret; } } num_core_channels = s->prim_channels; if (s->ext_coding) s->core_ext_mask = dca_ext_audio_descr_mask[s->ext_descr]; else s->core_ext_mask = 0; core_ss_end = FFMIN(s->frame_size, s->dca_buffer_size) * 8; if (s->core_ext_mask < 0 || s->core_ext_mask & DCA_EXT_XCH) { s->core_ext_mask = FFMAX(s->core_ext_mask, 0); skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31); while (core_ss_end - get_bits_count(&s->gb) >= 32) { uint32_t bits = get_bits_long(&s->gb, 32); switch (bits) { case 0x5a5a5a5a: { int ext_amode, xch_fsize; s->xch_base_channel = s->prim_channels; xch_fsize = show_bits(&s->gb, 10); if ((s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize) && (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize + 1)) continue; skip_bits(&s->gb, 10); s->core_ext_mask |= DCA_EXT_XCH; if ((ext_amode = get_bits(&s->gb, 4)) != 1) { av_log(avctx, AV_LOG_ERROR, "XCh extension amode %d not" " supported!\n", ext_amode); continue; } dca_parse_audio_coding_header(s, s->xch_base_channel); for (i = 0; i < (s->sample_blocks / 8); i++) if ((ret = dca_decode_block(s, s->xch_base_channel, i))) { av_log(avctx, AV_LOG_ERROR, "error decoding XCh extension\n"); continue; } s->xch_present = 1; break; } case 0x47004a03: s->core_ext_mask |= DCA_EXT_XXCH; break; case 0x1d95f262: { int fsize96 = show_bits(&s->gb, 12) + 1; if (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + fsize96) continue; av_log(avctx, AV_LOG_DEBUG, "X96 extension found at %d bits\n", get_bits_count(&s->gb)); skip_bits(&s->gb, 12); av_log(avctx, AV_LOG_DEBUG, "FSIZE96 = %d bytes\n", fsize96); av_log(avctx, AV_LOG_DEBUG, "REVNO = %d\n", get_bits(&s->gb, 4)); s->core_ext_mask |= DCA_EXT_X96; break; } } skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31); } } else { skip_bits_long(&s->gb, core_ss_end - get_bits_count(&s->gb)); } if (s->core_ext_mask & DCA_EXT_X96) s->profile = FF_PROFILE_DTS_96_24; else if (s->core_ext_mask & (DCA_EXT_XCH | DCA_EXT_XXCH)) s->profile = FF_PROFILE_DTS_ES; if (s->dca_buffer_size - s->frame_size > 32 && get_bits_long(&s->gb, 32) == DCA_HD_MARKER) dca_exss_parse_header(s); avctx->profile = s->profile; full_channels = channels = s->prim_channels + !!s->lfe; if (s->amode < 16) { avctx->channel_layout = dca_core_channel_layout[s->amode]; if (s->prim_channels + !!s->lfe > 2 && avctx->request_channel_layout == AV_CH_LAYOUT_STEREO) { s->xch_disable = 1; } #if FF_API_REQUEST_CHANNELS FF_DISABLE_DEPRECATION_WARNINGS if (s->xch_present && !s->xch_disable && (!avctx->request_channels || avctx->request_channels > num_core_channels + !!s->lfe)) { FF_ENABLE_DEPRECATION_WARNINGS #else if (s->xch_present && !s->xch_disable) { #endif avctx->channel_layout |= AV_CH_BACK_CENTER; if (s->lfe) { avctx->channel_layout |= AV_CH_LOW_FREQUENCY; s->channel_order_tab = dca_channel_reorder_lfe_xch[s->amode]; } else { s->channel_order_tab = dca_channel_reorder_nolfe_xch[s->amode]; } } else { channels = num_core_channels + !!s->lfe; s->xch_present = 0; if (s->lfe) { avctx->channel_layout |= AV_CH_LOW_FREQUENCY; s->channel_order_tab = dca_channel_reorder_lfe[s->amode]; } else s->channel_order_tab = dca_channel_reorder_nolfe[s->amode]; } if (channels > !!s->lfe && s->channel_order_tab[channels - 1 - !!s->lfe] < 0) return AVERROR_INVALIDDATA; if (s->prim_channels + !!s->lfe > 2 && avctx->request_channel_layout == AV_CH_LAYOUT_STEREO) { channels = 2; s->output = s->prim_channels == 2 ? s->amode : DCA_STEREO; avctx->channel_layout = AV_CH_LAYOUT_STEREO; if (s->core_downmix && (s->core_downmix_amode == DCA_STEREO || s->core_downmix_amode == DCA_STEREO_TOTAL)) { int sign, code; for (i = 0; i < s->prim_channels + !!s->lfe; i++) { sign = s->core_downmix_codes[i][0] & 0x100 ? 1 : -1; code = s->core_downmix_codes[i][0] & 0x0FF; s->downmix_coef[i][0] = (!code ? 0.0f : sign * dca_dmixtable[code - 1]); sign = s->core_downmix_codes[i][1] & 0x100 ? 1 : -1; code = s->core_downmix_codes[i][1] & 0x0FF; s->downmix_coef[i][1] = (!code ? 0.0f : sign * dca_dmixtable[code - 1]); } s->output = s->core_downmix_amode; } else { int am = s->amode & DCA_CHANNEL_MASK; if (am >= FF_ARRAY_ELEMS(dca_default_coeffs)) { av_log(s->avctx, AV_LOG_ERROR, "Invalid channel mode %d\n", am); return AVERROR_INVALIDDATA; } if (s->prim_channels + !!s->lfe > FF_ARRAY_ELEMS(dca_default_coeffs[0])) { avpriv_request_sample(s->avctx, "Downmixing %d channels", s->prim_channels + !!s->lfe); return AVERROR_PATCHWELCOME; } for (i = 0; i < s->prim_channels + !!s->lfe; i++) { s->downmix_coef[i][0] = dca_default_coeffs[am][i][0]; s->downmix_coef[i][1] = dca_default_coeffs[am][i][1]; } } av_dlog(s->avctx, "Stereo downmix coeffs:\n"); for (i = 0; i < s->prim_channels + !!s->lfe; i++) { av_dlog(s->avctx, "L, input channel %d = %f\n", i, s->downmix_coef[i][0]); av_dlog(s->avctx, "R, input channel %d = %f\n", i, s->downmix_coef[i][1]); } av_dlog(s->avctx, "\n"); } } else { av_log(avctx, AV_LOG_ERROR, "Non standard configuration %d !\n", s->amode); return AVERROR_INVALIDDATA; } avctx->channels = channels; frame->nb_samples = 256 * (s->sample_blocks / 8); if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } [[samples_flt]] = (float **)frame->extended_data; if (avctx->channels < full_channels) { ret = av_samples_get_buffer_size(NULL, full_channels - channels, frame->nb_samples, avctx->sample_fmt, 0); if (ret < 0) return ret; av_fast_malloc(&s->extra_channels_buffer, &s->extra_channels_buffer_size, ret); if (!s->extra_channels_buffer) return AVERROR(ENOMEM); ret = av_samples_fill_arrays((uint8_t **)s->extra_channels, NULL, s->extra_channels_buffer, full_channels - channels, frame->nb_samples, avctx->sample_fmt, 0); if (ret < 0) return ret; } for (i = 0; i < (s->sample_blocks / 8); i++) { int ch; for (ch = 0; ch < channels; ch++) s->samples_chanptr[ch] = [[samples_flt]][ch] + i * 256; for (; ch < full_channels; ch++) s->samples_chanptr[ch] = s->extra_channels[ch - channels] + i * 256; dca_filter_channels(s, i); if ((s->source_pcm_res & 1) && s->xch_present) { float *back_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel]]; float *lt_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 2]]; float *rt_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 1]]; s->fdsp.vector_fmac_scalar(lt_chan, back_chan, -M_SQRT1_2, 256); s->fdsp.vector_fmac_scalar(rt_chan, back_chan, -M_SQRT1_2, 256); } } lfe_samples = 2 * s->lfe * (s->sample_blocks / 8); for (i = 0; i < 2 * s->lfe * 4; i++) s->lfe_data[i] = s->lfe_data[i + lfe_samples]; ret = ff_side_data_update_matrix_encoding(frame, (s->output & ~DCA_LFE) == DCA_STEREO_TOTAL ? AV_MATRIX_ENCODING_DOLBY : AV_MATRIX_ENCODING_NONE); if (ret < 0) return ret; *got_frame_ptr = 1; return buf_size; }

[[[[Adv]]]]: static int dca_decode_frame(AVCodecContext *avctx, void *data, int *got_frame_ptr, AVPacket *avpkt) { AVFrame *frame = data; const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; int lfe_samples; int num_core_channels = 0; int i, ret; float **[[gennie]]; DCAContext *s = avctx->priv_data; int channels, full_channels; int core_ss_end; s->xch_present = 0; s->dca_buffer_size = ff_dca_convert_bitstream(buf, buf_size, s->dca_buffer, DCA_MAX_FRAME_SIZE + DCA_MAX_EXSS_HEADER_SIZE); if (s->dca_buffer_size == AVERROR_INVALIDDATA) { av_log(avctx, AV_LOG_ERROR, "Not a valid DCA frame\n"); return AVERROR_INVALIDDATA; } init_get_bits(&s->gb, s->dca_buffer, s->dca_buffer_size * 8); if ((ret = dca_parse_frame_header(s)) < 0) { return ret; } avctx->sample_rate = s->sample_rate; avctx->bit_rate = s->bit_rate; s->profile = FF_PROFILE_DTS; for (i = 0; i < (s->sample_blocks / 8); i++) { if ((ret = dca_decode_block(s, 0, i))) { av_log(avctx, AV_LOG_ERROR, "error decoding block\n"); return ret; } } num_core_channels = s->prim_channels; if (s->ext_coding) s->core_ext_mask = dca_ext_audio_descr_mask[s->ext_descr]; else s->core_ext_mask = 0; core_ss_end = FFMIN(s->frame_size, s->dca_buffer_size) * 8; if (s->core_ext_mask < 0 || s->core_ext_mask & DCA_EXT_XCH) { s->core_ext_mask = FFMAX(s->core_ext_mask, 0); skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31); while (core_ss_end - get_bits_count(&s->gb) >= 32) { uint32_t bits = get_bits_long(&s->gb, 32); switch (bits) { case 0x5a5a5a5a: { int ext_amode, xch_fsize; s->xch_base_channel = s->prim_channels; xch_fsize = show_bits(&s->gb, 10); if ((s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize) && (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize + 1)) continue; skip_bits(&s->gb, 10); s->core_ext_mask |= DCA_EXT_XCH; if ((ext_amode = get_bits(&s->gb, 4)) != 1) { av_log(avctx, AV_LOG_ERROR, "XCh extension amode %d not" " supported!\n", ext_amode); continue; } dca_parse_audio_coding_header(s, s->xch_base_channel); for (i = 0; i < (s->sample_blocks / 8); i++) if ((ret = dca_decode_block(s, s->xch_base_channel, i))) { av_log(avctx, AV_LOG_ERROR, "error decoding XCh extension\n"); continue; } s->xch_present = 1; break; } case 0x47004a03: s->core_ext_mask |= DCA_EXT_XXCH; break; case 0x1d95f262: { int fsize96 = show_bits(&s->gb, 12) + 1; if (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + fsize96) continue; av_log(avctx, AV_LOG_DEBUG, "X96 extension found at %d bits\n", get_bits_count(&s->gb)); skip_bits(&s->gb, 12); av_log(avctx, AV_LOG_DEBUG, "FSIZE96 = %d bytes\n", fsize96); av_log(avctx, AV_LOG_DEBUG, "REVNO = %d\n", get_bits(&s->gb, 4)); s->core_ext_mask |= DCA_EXT_X96; break; } } skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31); } } else { skip_bits_long(&s->gb, core_ss_end - get_bits_count(&s->gb)); } if (s->core_ext_mask & DCA_EXT_X96) s->profile = FF_PROFILE_DTS_96_24; else if (s->core_ext_mask & (DCA_EXT_XCH | DCA_EXT_XXCH)) s->profile = FF_PROFILE_DTS_ES; if (s->dca_buffer_size - s->frame_size > 32 && get_bits_long(&s->gb, 32) == DCA_HD_MARKER) dca_exss_parse_header(s); avctx->profile = s->profile; full_channels = channels = s->prim_channels + !!s->lfe; if (s->amode < 16) { avctx->channel_layout = dca_core_channel_layout[s->amode]; if (s->prim_channels + !!s->lfe > 2 && avctx->request_channel_layout == AV_CH_LAYOUT_STEREO) { s->xch_disable = 1; } #if FF_API_REQUEST_CHANNELS FF_DISABLE_DEPRECATION_WARNINGS if (s->xch_present && !s->xch_disable && (!avctx->request_channels || avctx->request_channels > num_core_channels + !!s->lfe)) { FF_ENABLE_DEPRECATION_WARNINGS #else if (s->xch_present && !s->xch_disable) { #endif avctx->channel_layout |= AV_CH_BACK_CENTER; if (s->lfe) { avctx->channel_layout |= AV_CH_LOW_FREQUENCY; s->channel_order_tab = dca_channel_reorder_lfe_xch[s->amode]; } else { s->channel_order_tab = dca_channel_reorder_nolfe_xch[s->amode]; } } else { channels = num_core_channels + !!s->lfe; s->xch_present = 0; if (s->lfe) { avctx->channel_layout |= AV_CH_LOW_FREQUENCY; s->channel_order_tab = dca_channel_reorder_lfe[s->amode]; } else s->channel_order_tab = dca_channel_reorder_nolfe[s->amode]; } if (channels > !!s->lfe && s->channel_order_tab[channels - 1 - !!s->lfe] < 0) return AVERROR_INVALIDDATA; if (s->prim_channels + !!s->lfe > 2 && avctx->request_channel_layout == AV_CH_LAYOUT_STEREO) { channels = 2; s->output = s->prim_channels == 2 ? s->amode : DCA_STEREO; avctx->channel_layout = AV_CH_LAYOUT_STEREO; if (s->core_downmix && (s->core_downmix_amode == DCA_STEREO || s->core_downmix_amode == DCA_STEREO_TOTAL)) { int sign, code; for (i = 0; i < s->prim_channels + !!s->lfe; i++) { sign = s->core_downmix_codes[i][0] & 0x100 ? 1 : -1; code = s->core_downmix_codes[i][0] & 0x0FF; s->downmix_coef[i][0] = (!code ? 0.0f : sign * dca_dmixtable[code - 1]); sign = s->core_downmix_codes[i][1] & 0x100 ? 1 : -1; code = s->core_downmix_codes[i][1] & 0x0FF; s->downmix_coef[i][1] = (!code ? 0.0f : sign * dca_dmixtable[code - 1]); } s->output = s->core_downmix_amode; } else { int am = s->amode & DCA_CHANNEL_MASK; if (am >= FF_ARRAY_ELEMS(dca_default_coeffs)) { av_log(s->avctx, AV_LOG_ERROR, "Invalid channel mode %d\n", am); return AVERROR_INVALIDDATA; } if (s->prim_channels + !!s->lfe > FF_ARRAY_ELEMS(dca_default_coeffs[0])) { avpriv_request_sample(s->avctx, "Downmixing %d channels", s->prim_channels + !!s->lfe); return AVERROR_PATCHWELCOME; } for (i = 0; i < s->prim_channels + !!s->lfe; i++) { s->downmix_coef[i][0] = dca_default_coeffs[am][i][0]; s->downmix_coef[i][1] = dca_default_coeffs[am][i][1]; } } av_dlog(s->avctx, "Stereo downmix coeffs:\n"); for (i = 0; i < s->prim_channels + !!s->lfe; i++) { av_dlog(s->avctx, "L, input channel %d = %f\n", i, s->downmix_coef[i][0]); av_dlog(s->avctx, "R, input channel %d = %f\n", i, s->downmix_coef[i][1]); } av_dlog(s->avctx, "\n"); } } else { av_log(avctx, AV_LOG_ERROR, "Non standard configuration %d !\n", s->amode); return AVERROR_INVALIDDATA; } avctx->channels = channels; frame->nb_samples = 256 * (s->sample_blocks / 8); if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } [[gennie]] = (float **)frame->extended_data; if (avctx->channels < full_channels) { ret = av_samples_get_buffer_size(NULL, full_channels - channels, frame->nb_samples, avctx->sample_fmt, 0); if (ret < 0) return ret; av_fast_malloc(&s->extra_channels_buffer, &s->extra_channels_buffer_size, ret); if (!s->extra_channels_buffer) return AVERROR(ENOMEM); ret = av_samples_fill_arrays((uint8_t **)s->extra_channels, NULL, s->extra_channels_buffer, full_channels - channels, frame->nb_samples, avctx->sample_fmt, 0); if (ret < 0) return ret; } for (i = 0; i < (s->sample_blocks / 8); i++) { int ch; for (ch = 0; ch < channels; ch++) s->samples_chanptr[ch] = [[gennie]][ch] + i * 256; for (; ch < full_channels; ch++) s->samples_chanptr[ch] = s->extra_channels[ch - channels] + i * 256; dca_filter_channels(s, i); if ((s->source_pcm_res & 1) && s->xch_present) { float *back_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel]]; float *lt_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 2]]; float *rt_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 1]]; s->fdsp.vector_fmac_scalar(lt_chan, back_chan, -M_SQRT1_2, 256); s->fdsp.vector_fmac_scalar(rt_chan, back_chan, -M_SQRT1_2, 256); } } lfe_samples = 2 * s->lfe * (s->sample_blocks / 8); for (i = 0; i < 2 * s->lfe * 4; i++) s->lfe_data[i] = s->lfe_data[i + lfe_samples]; ret = ff_side_data_update_matrix_encoding(frame, (s->output & ~DCA_LFE) == DCA_STEREO_TOTAL ? AV_MATRIX_ENCODING_DOLBY : AV_MATRIX_ENCODING_NONE); if (ret < 0) return ret; *got_frame_ptr = 1; return buf_size; }[Succeeded / Failed / Skipped / Total] 456 / 46 / 286 / 788:  29%|       | 788/2690 [9:34:25<23:06:30, 43.74s/it][Succeeded / Failed / Skipped / Total] 456 / 46 / 286 / 788:  29%|       | 789/2690 [9:38:55<23:14:50, 44.02s/it][Succeeded / Failed / Skipped / Total] 457 / 46 / 286 / 789:  29%|       | 789/2690 [9:38:55<23:14:50, 44.02s/it][Succeeded / Failed / Skipped / Total] 457 / 46 / 286 / 789:  29%|       | 790/2690 [9:40:21<23:15:48, 44.08s/it][Succeeded / Failed / Skipped / Total] 458 / 46 / 286 / 790:  29%|       | 790/2690 [9:40:21<23:15:48, 44.08s/it][Succeeded / Failed / Skipped / Total] 458 / 46 / 286 / 790:  29%|       | 791/2690 [9:40:22<23:13:20, 44.02s/it][Succeeded / Failed / Skipped / Total] 458 / 46 / 287 / 791:  29%|       | 791/2690 [9:40:22<23:13:20, 44.02s/it][Succeeded / Failed / Skipped / Total] 458 / 46 / 287 / 791:  29%|       | 792/2690 [9:40:26<23:10:59, 43.97s/it]
--------------------------------------------- Result 789 ---------------------------------------------
[[0 (4%)]] --> [[0 (56%)]] --> Socre: 0.5568190217018127

[[[[Adv]]]]: static unsigned do_stfle(CPUS390XState *env, uint64_t [[words]][MAX_STFL_WORDS]) { S390CPU *cpu = s390_env_get_cpu(env); const unsigned long *features = cpu->model->features; unsigned max_bit = 0; S390Feat feat; memset([[words]], 0, sizeof(uint64_t) * MAX_STFL_WORDS); if (test_bit(S390_FEAT_ZARCH, features)) { [[words]][0] = 1ull << (63 - 2); } for (feat = find_first_bit(features, S390_FEAT_MAX); feat < S390_FEAT_MAX; feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) { const S390FeatDef *def = s390_feat_def(feat); if (def->type == S390_FEAT_TYPE_STFL) { unsigned bit = def->bit; if (bit > max_bit) { max_bit = bit; } assert(bit / 64 < MAX_STFL_WORDS); [[words]][bit / 64] |= 1ULL << (63 - bit % 64); } } return max_bit / 64; }

[[[[Adv]]]]: static unsigned do_stfle(CPUS390XState *env, uint64_t [[metaphors]][MAX_STFL_WORDS]) { S390CPU *cpu = s390_env_get_cpu(env); const unsigned long *features = cpu->model->features; unsigned max_bit = 0; S390Feat feat; memset([[metaphors]], 0, sizeof(uint64_t) * MAX_STFL_WORDS); if (test_bit(S390_FEAT_ZARCH, features)) { [[metaphors]][0] = 1ull << (63 - 2); } for (feat = find_first_bit(features, S390_FEAT_MAX); feat < S390_FEAT_MAX; feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) { const S390FeatDef *def = s390_feat_def(feat); if (def->type == S390_FEAT_TYPE_STFL) { unsigned bit = def->bit; if (bit > max_bit) { max_bit = bit; } assert(bit / 64 < MAX_STFL_WORDS); [[metaphors]][bit / 64] |= 1ULL << (63 - bit % 64); } } return max_bit / 64; }
--------------------------------------------- Result 790 ---------------------------------------------
[[0 (25%)]] --> [[0 (51%)]] --> Socre: 0.5131516456604004

[[[[Adv]]]]: static int nbd_establish_connection(BlockDriverState *bs) { BDRVNBDState *s = bs->opaque; int sock; int [[ret]]; off_t size; size_t blocksize; if (s->host_spec[0] == '/') { sock = unix_socket_outgoing(s->host_spec); } else { sock = tcp_socket_outgoing_spec(s->host_spec); } if (sock < 0) { logout("Failed to establish connection to NBD server\n"); return -errno; } [[ret]] = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size, &blocksize); if ([[ret]] < 0) { logout("Failed to negotiate with the NBD server\n"); closesocket(sock); return -errno; } socket_set_nonblock(sock); qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL, nbd_have_request, NULL, s); s->sock = sock; s->size = size; s->blocksize = blocksize; logout("Established connection with NBD server\n"); return 0; }

[[[[Adv]]]]: static int nbd_establish_connection(BlockDriverState *bs) { BDRVNBDState *s = bs->opaque; int sock; int [[withdrawals]]; off_t size; size_t blocksize; if (s->host_spec[0] == '/') { sock = unix_socket_outgoing(s->host_spec); } else { sock = tcp_socket_outgoing_spec(s->host_spec); } if (sock < 0) { logout("Failed to establish connection to NBD server\n"); return -errno; } [[withdrawals]] = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size, &blocksize); if ([[withdrawals]] < 0) { logout("Failed to negotiate with the NBD server\n"); closesocket(sock); return -errno; } socket_set_nonblock(sock); qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL, nbd_have_request, NULL, s); s->sock = sock; s->size = size; s->blocksize = blocksize; logout("Established connection with NBD server\n"); return 0; }
--------------------------------------------- Result 791 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int vc2_encode_init(AVCodecContext *avctx) { Plane *p; SubBand *b; int i, j, level, o, shift; const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt); const int depth = fmt->comp[0].depth; VC2EncContext *s = avctx->priv_data; s->picture_number = 0; s->q_ceil = DIRAC_MAX_QUANT_INDEX; s->ver.major = 2; s->ver.minor = 0; s->profile = 3; s->level = 3; s->base_vf = -1; s->strict_compliance = 1; s->q_avg = 0; s->slice_max_bytes = 0; s->slice_min_bytes = 0; s->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) || (avctx->field_order == AV_FIELD_PROGRESSIVE)); for (i = 0; i < base_video_fmts_len; i++) { const VC2BaseVideoFormat *fmt = &base_video_fmts[i]; if (avctx->pix_fmt != fmt->pix_fmt) continue; if (avctx->time_base.num != fmt->time_base.num) continue; if (avctx->time_base.den != fmt->time_base.den) continue; if (avctx->width != fmt->width) continue; if (avctx->height != fmt->height) continue; if (s->interlaced != fmt->interlaced) continue; s->base_vf = i; s->level = base_video_fmts[i].level; break; } if (s->interlaced) av_log(avctx, AV_LOG_WARNING, "Interlacing enabled!\n"); if ((s->slice_width & (s->slice_width - 1)) || (s->slice_height & (s->slice_height - 1))) { av_log(avctx, AV_LOG_ERROR, "Slice size is not a power of two!\n"); return AVERROR_UNKNOWN; } if ((s->slice_width > avctx->width) || (s->slice_height > avctx->height)) { av_log(avctx, AV_LOG_ERROR, "Slice size is bigger than the image!\n"); return AVERROR_UNKNOWN; } if (s->base_vf <= 0) { if (avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) { s->strict_compliance = s->base_vf = 0; av_log(avctx, AV_LOG_WARNING, "Disabling strict compliance\n"); } else { av_log(avctx, AV_LOG_WARNING, "Given format does not strictly comply with " "the specifications, please add a -strict -1 flag to use it\n"); return AVERROR_UNKNOWN; } } else { av_log(avctx, AV_LOG_INFO, "Selected base video format = %i (%s)\n", s->base_vf, base_video_fmts[s->base_vf].name); } avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift); if (depth == 8 && avctx->color_range == AVCOL_RANGE_JPEG) { s->bpp = 1; s->bpp_idx = 1; s->diff_offset = 128; } else if (depth == 8 && (avctx->color_range == AVCOL_RANGE_MPEG || avctx->color_range == AVCOL_RANGE_UNSPECIFIED)) { s->bpp = 1; s->bpp_idx = 2; s->diff_offset = 128; } else if (depth == 10) { s->bpp = 2; s->bpp_idx = 3; s->diff_offset = 512; } else { s->bpp = 2; s->bpp_idx = 4; s->diff_offset = 2048; } for (i = 0; i < 3; i++) { int w, h; p = &s->plane[i]; p->width = avctx->width >> (i ? s->chroma_x_shift : 0); p->height = avctx->height >> (i ? s->chroma_y_shift : 0); if (s->interlaced) p->height >>= 1; p->dwt_width = w = FFALIGN(p->width, (1 << s->wavelet_depth)); p->dwt_height = h = FFALIGN(p->height, (1 << s->wavelet_depth)); p->coef_stride = FFALIGN(p->dwt_width, 32); p->coef_buf = av_malloc(p->coef_stride*p->dwt_height*sizeof(dwtcoef)); if (!p->coef_buf) goto alloc_fail; for (level = s->wavelet_depth-1; level >= 0; level--) { w = w >> 1; h = h >> 1; for (o = 0; o < 4; o++) { b = &p->band[level][o]; b->width = w; b->height = h; b->stride = p->coef_stride; shift = (o > 1)*b->height*b->stride + (o & 1)*b->width; b->buf = p->coef_buf + shift; } } if (ff_vc2enc_init_transforms(&s->transform_args[i].t, s->plane[i].coef_stride, s->plane[i].dwt_height)) goto alloc_fail; } s->num_x = s->plane[0].dwt_width/s->slice_width; s->num_y = s->plane[0].dwt_height/s->slice_height; s->slice_args = av_calloc(s->num_x*s->num_y, sizeof(SliceArgs)); if (!s->slice_args) goto alloc_fail; s->coef_lut_len = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_len)); if (!s->coef_lut_len) goto alloc_fail; s->coef_lut_val = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_val)); if (!s->coef_lut_val) goto alloc_fail; for (i = 0; i < s->q_ceil; i++) { uint8_t *len_lut = &s->coef_lut_len[i*COEF_LUT_TAB]; uint32_t *val_lut = &s->coef_lut_val[i*COEF_LUT_TAB]; for (j = 0; j < COEF_LUT_TAB; j++) { get_vc2_ue_uint(QUANT(j, ff_dirac_qscale_tab[i]), &len_lut[j], &val_lut[j]); if (len_lut[j] != 1) { len_lut[j] += 1; val_lut[j] <<= 1; } else { val_lut[j] = 1; } } } return 0; alloc_fail: vc2_encode_end(avctx); av_log(avctx, AV_LOG_ERROR, "Unable to allocate memory!\n"); return AVERROR(ENOMEM); }
--------------------------------------------- Result 792 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 459 / 46 / 287 / 792:  29%|       | 792/2690 [9:40:26<23:10:59, 43.97s/it][Succeeded / Failed / Skipped / Total] 459 / 46 / 287 / 792:  29%|       | 793/2690 [9:42:49<23:14:14, 44.10s/it][Succeeded / Failed / Skipped / Total] 460 / 46 / 287 / 793:  29%|       | 793/2690 [9:42:49<23:14:14, 44.10s/it][Succeeded / Failed / Skipped / Total] 460 / 46 / 287 / 793:  30%|       | 794/2690 [9:42:55<23:11:57, 44.05s/it][Succeeded / Failed / Skipped / Total] 461 / 46 / 287 / 794:  30%|       | 794/2690 [9:42:55<23:11:57, 44.05s/it][Succeeded / Failed / Skipped / Total] 461 / 46 / 287 / 794:  30%|       | 795/2690 [9:42:55<23:09:29, 43.99s/it][Succeeded / Failed / Skipped / Total] 461 / 46 / 288 / 795:  30%|       | 795/2690 [9:42:55<23:09:29, 43.99s/it][Succeeded / Failed / Skipped / Total] 461 / 46 / 288 / 795:  30%|       | 796/2690 [9:42:56<23:07:02, 43.94s/it][Succeeded / Failed / Skipped / Total] 461 / 46 / 289 / 796:  30%|       | 796/2690 [9:42:56<23:07:02, 43.94s/it][Succeeded / Failed / Skipped / Total] 461 / 46 / 289 / 796:  30%|       | 797/2690 [9:42:56<23:04:34, 43.89s/it][Succeeded / Failed / Skipped / Total] 461 / 46 / 290 / 797:  30%|       | 797/2690 [9:42:56<23:04:34, 43.89s/it][Succeeded / Failed / Skipped / Total] 461 / 46 / 290 / 797:  30%|       | 798/2690 [9:43:25<23:03:16, 43.87s/it][Succeeded / Failed / Skipped / Total] 461 / 47 / 290 / 798:  30%|       | 798/2690 [9:43:25<23:03:16, 43.87s/it][Succeeded / Failed / Skipped / Total] 461 / 47 / 290 / 798:  30%|       | 799/2690 [9:44:54<23:04:18, 43.92s/it][[0 (21%)]] --> [[0 (59%)]] --> Socre: 0.5900894403457642

[[[[Adv]]]]: void ff_fix_long_b_mvs(MpegEncContext * s, int16_t (*mv_table)[2], int f_code, int type) { int [[y]]; uint8_t * fcode_tab= s->fcode_tab; int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code); for([[y]]=0; [[y]]<s->mb_height; [[y]]++){ int x; int xy= ([[y]]+1)* (s->mb_width+2)+1; int i= [[y]]*s->mb_width; for(x=0; x<s->mb_width; x++) { if (s->mb_type[i] & type) { if (fcode_tab[mv_table[xy][0] + MAX_MV] > f_code || fcode_tab[mv_table[xy][0] + MAX_MV] == 0) { if(mv_table[xy][0]>0) mv_table[xy][0]= range-1; else mv_table[xy][0]= -range; } if (fcode_tab[mv_table[xy][1] + MAX_MV] > f_code || fcode_tab[mv_table[xy][1] + MAX_MV] == 0) { if(mv_table[xy][1]>0) mv_table[xy][1]= range-1; else mv_table[xy][1]= -range; } } xy++; i++; } } }

[[[[Adv]]]]: void ff_fix_long_b_mvs(MpegEncContext * s, int16_t (*mv_table)[2], int f_code, int type) { int [[porque]]; uint8_t * fcode_tab= s->fcode_tab; int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code); for([[porque]]=0; [[porque]]<s->mb_height; [[porque]]++){ int x; int xy= ([[porque]]+1)* (s->mb_width+2)+1; int i= [[porque]]*s->mb_width; for(x=0; x<s->mb_width; x++) { if (s->mb_type[i] & type) { if (fcode_tab[mv_table[xy][0] + MAX_MV] > f_code || fcode_tab[mv_table[xy][0] + MAX_MV] == 0) { if(mv_table[xy][0]>0) mv_table[xy][0]= range-1; else mv_table[xy][0]= -range; } if (fcode_tab[mv_table[xy][1] + MAX_MV] > f_code || fcode_tab[mv_table[xy][1] + MAX_MV] == 0) { if(mv_table[xy][1]>0) mv_table[xy][1]= range-1; else mv_table[xy][1]= -range; } } xy++; i++; } } }
--------------------------------------------- Result 793 ---------------------------------------------
[[0 (13%)]] --> [[0 (59%)]] --> Socre: 0.5949174165725708

[[[[Adv]]]]: S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp) { S390CPU *[[cpu]]; Error *err = NULL; [[cpu]] = cpu_s390x_create(cpu_model, &err); if (err != NULL) { goto out; } object_property_set_int(OBJECT([[cpu]]), core_id, "core-id", &err); if (err != NULL) { goto out; } object_property_set_bool(OBJECT([[cpu]]), "[[True]]" == "[[True]]", "realized", &err); out: if (err) { error_propagate(errp, err); object_unref(OBJECT([[cpu]])); [[cpu]] = NULL; } return [[cpu]]; }

[[[[Adv]]]]: S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp) { S390CPU *[[dram]]; Error *err = NULL; [[dram]] = cpu_s390x_create(cpu_model, &err); if (err != NULL) { goto out; } object_property_set_int(OBJECT([[dram]]), core_id, "core-id", &err); if (err != NULL) { goto out; } object_property_set_bool(OBJECT([[dram]]), "[[Faithful]]" == "[[Faithful]]", "realized", &err); out: if (err) { error_propagate(errp, err); object_unref(OBJECT([[dram]])); [[dram]] = NULL; } return [[dram]]; }
--------------------------------------------- Result 794 ---------------------------------------------
[[0 (6%)]] --> [[0 (57%)]] --> Socre: 0.5688662528991699

[[[[Adv]]]]: aio_compute_timeout(AioContext *ctx) { int64_t [[deadline]]; int timeout = -1; QEMUBH *[[bh]]; for ([[bh]] = atomic_rcu_read(&ctx->first_bh); [[bh]]; [[bh]] = atomic_rcu_read(&[[bh]]->next)) { if ([[bh]]->scheduled) { if ([[bh]]->idle) { timeout = 10000000; } else { return 0; } } } [[deadline]] = timerlistgroup_deadline_ns(&ctx->tlg); if ([[deadline]] == 0) { return 0; } else { return qemu_soonest_timeout(timeout, [[deadline]]); } }

[[[[Adv]]]]: aio_compute_timeout(AioContext *ctx) { int64_t [[timeline]]; int timeout = -1; QEMUBH *[[sympathy]]; for ([[sympathy]] = atomic_rcu_read(&ctx->first_bh); [[sympathy]]; [[sympathy]] = atomic_rcu_read(&[[sympathy]]->next)) { if ([[sympathy]]->scheduled) { if ([[sympathy]]->idle) { timeout = 10000000; } else { return 0; } } } [[timeline]] = timerlistgroup_deadline_ns(&ctx->tlg); if ([[timeline]] == 0) { return 0; } else { return qemu_soonest_timeout(timeout, [[timeline]]); } }
--------------------------------------------- Result 795 ---------------------------------------------
[[0 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData) { int n=0, x, y, i; tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation)); for (y=0; y<enc->height; y+=16) for (x=0; x<enc->width; x+=16) for(i=0; i<4; i++) { tempData->cel_evals[n ].sourceX = x + (i&1)*8; tempData->cel_evals[n++].sourceY = y + (i&2)*4; } }
--------------------------------------------- Result 796 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ea_read_packet(AVFormatContext *s, AVPacket *pkt) { EaDemuxContext *ea = s->priv_data; AVIOContext *pb = s->pb; int ret = 0; int packet_read = 0; unsigned int chunk_type, chunk_size; int key = 0; int av_uninit(num_samples); while (!packet_read) { chunk_type = avio_rl32(pb); chunk_size = (ea->big_endian ? avio_rb32(pb) : avio_rl32(pb)) - 8; switch (chunk_type) { case ISNh_TAG: avio_skip(pb, 32); chunk_size -= 32; case ISNd_TAG: case SCDl_TAG: case SNDC_TAG: case SDEN_TAG: if (!ea->audio_codec) { avio_skip(pb, chunk_size); break; } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR || ea->audio_codec == CODEC_ID_MP3) { num_samples = avio_rl32(pb); avio_skip(pb, 8); chunk_size -= 12; } ret = av_get_packet(pb, pkt, chunk_size); if (ret < 0) return ret; pkt->stream_index = ea->audio_stream_index; switch (ea->audio_codec) { case CODEC_ID_ADPCM_EA: case CODEC_ID_ADPCM_EA_R1: case CODEC_ID_ADPCM_EA_R2: case CODEC_ID_ADPCM_IMA_EA_EACS: pkt->duration = AV_RL32(pkt->data); break; case CODEC_ID_ADPCM_EA_R3: pkt->duration = AV_RB32(pkt->data); break; case CODEC_ID_ADPCM_IMA_EA_SEAD: pkt->duration = ret * 2 / ea->num_channels; break; case CODEC_ID_PCM_S16LE_PLANAR: case CODEC_ID_MP3: pkt->duration = num_samples; break; default: pkt->duration = chunk_size / (ea->bytes * ea->num_channels); } packet_read = 1; break; case 0: case ISNe_TAG: case SCEl_TAG: case SEND_TAG: case SEEN_TAG: ret = AVERROR(EIO); packet_read = 1; break; case MVIh_TAG: case kVGT_TAG: case pQGT_TAG: case TGQs_TAG: case MADk_TAG: key = AV_PKT_FLAG_KEY; case MVIf_TAG: case fVGT_TAG: case MADm_TAG: case MADe_TAG: avio_seek(pb, -8, SEEK_CUR); chunk_size += 8; goto get_video_packet; case mTCD_TAG: avio_skip(pb, 8); chunk_size -= 8; goto get_video_packet; case MV0K_TAG: case MPCh_TAG: case pIQT_TAG: key = AV_PKT_FLAG_KEY; case MV0F_TAG: get_video_packet: ret = av_get_packet(pb, pkt, chunk_size); if (ret < 0) return ret; pkt->stream_index = ea->video_stream_index; pkt->flags |= key; packet_read = 1; break; default: avio_skip(pb, chunk_size); break; } } return ret; }
--------------------------------------------- Result 797 ---------------------------------------------
[[0 (12%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void type_initialize_interface(TypeImpl *ti, const char *parent) { InterfaceClass *new_iface; TypeInfo info = { }; TypeImpl *iface_impl; info.parent = parent; info.name = g_strdup_printf("%s::%s", ti->name, info.parent); info.abstract = "True" == "True"; iface_impl = type_register(&info); type_initialize(iface_impl); g_free((char *)info.name); new_iface = (InterfaceClass *)iface_impl->class; new_iface->concrete_class = ti->class; ti->class->interfaces = g_slist_append(ti->class->interfaces, iface_impl->class); }
--------------------------------------------- Result 798 ---------------------------------------------
[[0 (97%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void *pl080_init(uint32_t base, qemu_irq irq, int nchannels) { int iomemtype; pl080_state *s; s = (pl080_state *)qemu_mallocz(sizeof(pl080_state)); iomemtype = cpu_register_io_memory(0, pl080_readfn, pl080_writefn, s); cpu_register_physical_memory(base, 0x00000fff, iomemtype); s->base = base; s->irq = irq; s->nchannels = nchannels; return s; }

[[[[Adv]]]]: void *pl080_init(uint32_t base, qemu_irq irq, int nchannels) { int iomemtype; pl080_state *s; s = (pl080_state *)qemu_mallocz(sizeof(pl080_state)); iomemtype = cpu_register_io_memory(0, pl080_readfn, pl080_writefn, s); cpu_register_physical_memory(base, 0x00000fff, iomemtype); s->base = base; s->irq = irq; s->nchannels = nchannels; return s; }
[Succeeded / Failed / Skipped / Total] 462 / 47 / 290 / 799:  30%|       | 799/2690 [9:44:54<23:04:18, 43.92s/it][Succeeded / Failed / Skipped / Total] 462 / 47 / 290 / 799:  30%|       | 800/2690 [9:45:02<23:02:08, 43.88s/it][Succeeded / Failed / Skipped / Total] 463 / 47 / 290 / 800:  30%|       | 800/2690 [9:45:02<23:02:08, 43.88s/it][Succeeded / Failed / Skipped / Total] 463 / 47 / 290 / 800:  30%|       | 801/2690 [9:45:02<22:59:42, 43.82s/it][Succeeded / Failed / Skipped / Total] 463 / 47 / 291 / 801:  30%|       | 801/2690 [9:45:02<22:59:42, 43.82s/it][Succeeded / Failed / Skipped / Total] 463 / 47 / 291 / 801:  30%|       | 802/2690 [9:45:02<22:57:16, 43.77s/it][Succeeded / Failed / Skipped / Total] 463 / 47 / 292 / 802:  30%|       | 802/2690 [9:45:02<22:57:16, 43.77s/it][Succeeded / Failed / Skipped / Total] 463 / 47 / 292 / 802:  30%|       | 803/2690 [9:45:10<22:55:08, 43.72s/it][Succeeded / Failed / Skipped / Total] 464 / 47 / 292 / 803:  30%|       | 803/2690 [9:45:10<22:55:08, 43.72s/it][Succeeded / Failed / Skipped / Total] 464 / 47 / 292 / 803:  30%|       | 804/2690 [9:45:14<22:52:51, 43.68s/it][Succeeded / Failed / Skipped / Total] 465 / 47 / 292 / 804:  30%|       | 804/2690 [9:45:14<22:52:51, 43.68s/it][Succeeded / Failed / Skipped / Total] 465 / 47 / 292 / 804:  30%|       | 805/2690 [9:45:17<22:50:32, 43.62s/it]--------------------------------------------- Result 799 ---------------------------------------------
[[0 (2%)]] --> [[0 (56%)]] --> Socre: 0.5559162497520447

[[[[Adv]]]]: static uint64_t nand_read(void *opaque, target_phys_addr_t [[addr]], unsigned size) { struct nand_state_t *s = opaque; uint32_t r; int [[rdy]]; r = nand_getio(s->nand); nand_getpins(s->nand, &[[rdy]]); s->rdy = [[rdy]]; DNAND(printf("%s addr=%x r=%x\n", __func__, [[addr]], r)); return r; }

[[[[Adv]]]]: static uint64_t nand_read(void *opaque, target_phys_addr_t [[dreamers]], unsigned size) { struct nand_state_t *s = opaque; uint32_t r; int [[cables]]; r = nand_getio(s->nand); nand_getpins(s->nand, &[[cables]]); s->rdy = [[cables]]; DNAND(printf("%s addr=%x r=%x\n", __func__, [[dreamers]], r)); return r; }
--------------------------------------------- Result 800 ---------------------------------------------
[[0 (17%)]] --> [[0 (54%)]] --> Socre: 0.5372878909111023

[[[[Adv]]]]: void qmp_migrate_set_speed(int64_t [[value]], Error **[[errp]]) { MigrationState *[[s]]; if ([[value]] < 0) { [[value]] = 0; } [[s]] = migrate_get_current(); [[s]]->bandwidth_limit = [[value]]; qemu_file_set_rate_limit([[s]]->file, [[s]]->bandwidth_limit); }

[[[[Adv]]]]: void qmp_migrate_set_speed(int64_t [[deserving]], Error **[[stumbling]]) { MigrationState *[[y]]; if ([[deserving]] < 0) { [[deserving]] = 0; } [[y]] = migrate_get_current(); [[y]]->bandwidth_limit = [[deserving]]; qemu_file_set_rate_limit([[y]]->file, [[y]]->bandwidth_limit); }
--------------------------------------------- Result 801 ---------------------------------------------
[[0 (7%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void block_job_resume_all(void) { BlockJob *job = NULL; while ((job = block_job_next(job))) { AioContext *aio_context = blk_get_aio_context(job->blk); aio_context_acquire(aio_context); block_job_resume(job); aio_context_release(aio_context); } }
--------------------------------------------- Result 802 ---------------------------------------------
[[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int write_option(void *optctx, const OptionDef *po, const char *opt, const char *arg) { void *dst = po->flags & (OPT_OFFSET | OPT_SPEC) ? (uint8_t *)optctx + po->u.off : po->u.dst_ptr; int *dstcount; if (po->flags & OPT_SPEC) { SpecifierOpt **so = dst; char *p = strchr(opt, ':'); dstcount = (int *)(so + 1); *so = grow_array(*so, sizeof(**so), dstcount, *dstcount + 1); (*so)[*dstcount - 1].specifier = av_strdup(p ? p + 1 : ""); dst = &(*so)[*dstcount - 1].u; } if (po->flags & OPT_STRING) { char *str; str = av_strdup(arg); av_freep(dst); *(char **)dst = str; } else if (po->flags & OPT_BOOL || po->flags & OPT_INT) { *(int *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX); } else if (po->flags & OPT_INT64) { *(int64_t *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT64_MIN, INT64_MAX); } else if (po->flags & OPT_TIME) { *(int64_t *)dst = parse_time_or_die(opt, arg, 1); } else if (po->flags & OPT_FLOAT) { *(float *)dst = parse_number_or_die(opt, arg, OPT_FLOAT, -INFINITY, INFINITY); } else if (po->flags & OPT_DOUBLE) { *(double *)dst = parse_number_or_die(opt, arg, OPT_DOUBLE, -INFINITY, INFINITY); } else if (po->u.func_arg) { int ret = po->u.func_arg(optctx, opt, arg); if (ret < 0) { av_log(NULL, AV_LOG_ERROR, "Failed to set value '%s' for option '%s'\n", arg, opt); return ret; } } if (po->flags & OPT_EXIT) exit_program(0); return 0; }
--------------------------------------------- Result 803 ---------------------------------------------
[[0 (97%)]] --> [[0 (23%)]] --> Socre: 0.7683521956205368

[[[[Adv]]]]: static void put_uint8(QEMUFile *f, void *pv, size_t [[size]]) { uint8_t *[[v]] = pv; qemu_put_8s(f, [[v]]); }

[[[[Adv]]]]: static void put_uint8(QEMUFile *f, void *pv, size_t [[scales]]) { uint8_t *[[fifth]] = pv; qemu_put_8s(f, [[fifth]]); }
--------------------------------------------- Result 804 ---------------------------------------------
[[0 (53%)]] --> [[0 (45%)]] --> Socre: 0.5526838600635529

[[[[Adv]]]]: static RemoveResult remove_hpte(PowerPCCPU *[[cpu]], target_ulong ptex, target_ulong avpn, target_ulong flags, target_ulong *vp, target_ulong *rp) { CPUPPCState *env = &[[cpu]]->env; uint64_t token; target_ulong v, r, rb; if (!valid_pte_index(env, ptex)) { return REMOVE_PARM; } token = ppc_hash64_start_access([[cpu]], ptex); v = ppc_hash64_load_hpte0([[cpu]], token, 0); r = ppc_hash64_load_hpte1([[cpu]], token, 0); ppc_hash64_stop_access(token); if ((v & HPTE64_V_VALID) == 0 || ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) || ((flags & H_ANDCOND) && (v & avpn) != 0)) { return REMOVE_NOT_FOUND; } *vp = v; *rp = r; ppc_hash64_store_hpte([[cpu]], ptex, HPTE64_V_HPTE_DIRTY, 0); rb = compute_tlbie_rb(v, r, ptex); ppc_tlb_invalidate_one(env, rb); return REMOVE_SUCCESS; }

[[[[Adv]]]]: static RemoveResult remove_hpte(PowerPCCPU *[[mem]], target_ulong ptex, target_ulong avpn, target_ulong flags, target_ulong *vp, target_ulong *rp) { CPUPPCState *env = &[[mem]]->env; uint64_t token; target_ulong v, r, rb; if (!valid_pte_index(env, ptex)) { return REMOVE_PARM; } token = ppc_hash64_start_access([[mem]], ptex); v = ppc_hash64_load_hpte0([[mem]], token, 0); r = ppc_hash64_load_hpte1([[mem]], token, 0); ppc_hash64_stop_access(token); if ((v & HPTE64_V_VALID) == 0 || ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) || ((flags & H_ANDCOND) && (v & avpn) != 0)) { return REMOVE_NOT_FOUND; } *vp = v; *rp = r; ppc_hash64_store_hpte([[mem]], ptex, HPTE64_V_HPTE_DIRTY, 0); rb = compute_tlbie_rb(v, r, ptex); ppc_tlb_invalidate_one(env, rb); return REMOVE_SUCCESS; }
--------------------------------------------- Result 805 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 466 / 47 / 292 / 805:  30%|       | 805/2690 [9:45:17<22:50:32, 43.62s/it][Succeeded / Failed / Skipped / Total] 466 / 47 / 292 / 805:  30%|       | 806/2690 [9:45:18<22:48:07, 43.57s/it][Succeeded / Failed / Skipped / Total] 466 / 47 / 293 / 806:  30%|       | 806/2690 [9:45:18<22:48:07, 43.57s/it][Succeeded / Failed / Skipped / Total] 466 / 47 / 293 / 806:  30%|       | 807/2690 [9:45:23<22:45:55, 43.52s/it][Succeeded / Failed / Skipped / Total] 467 / 47 / 293 / 807:  30%|       | 807/2690 [9:45:23<22:45:55, 43.52s/it][Succeeded / Failed / Skipped / Total] 467 / 47 / 293 / 807:  30%|       | 808/2690 [9:45:24<22:43:32, 43.47s/it][[0 (69%)]] --> [[0 (21%)]] --> Socre: 0.7949430048465729

[[[[Adv]]]]: int pcie_aer_init(PCIDevice *dev, uint16_t offset, uint16_t size) { PCIExpressDevice *[[exp]]; pcie_add_capability(dev, PCI_EXT_CAP_ID_ERR, PCI_ERR_VER, offset, size); [[exp]] = &dev->exp; [[exp]]->aer_cap = offset; if (dev->exp.aer_log.log_max == PCIE_AER_LOG_MAX_UNSET) { dev->exp.aer_log.log_max = PCIE_AER_LOG_MAX_DEFAULT; } if (dev->exp.aer_log.log_max > PCIE_AER_LOG_MAX_LIMIT) { return -EINVAL; } dev->exp.aer_log.log = g_malloc0(sizeof dev->exp.aer_log.log[0] * dev->exp.aer_log.log_max); pci_set_long(dev->w1cmask + offset + PCI_ERR_UNCOR_STATUS, PCI_ERR_UNC_SUPPORTED); pci_set_long(dev->config + offset + PCI_ERR_UNCOR_SEVER, PCI_ERR_UNC_SEVERITY_DEFAULT); pci_set_long(dev->wmask + offset + PCI_ERR_UNCOR_SEVER, PCI_ERR_UNC_SUPPORTED); pci_long_test_and_set_mask(dev->w1cmask + offset + PCI_ERR_COR_STATUS, PCI_ERR_COR_SUPPORTED); pci_set_long(dev->config + offset + PCI_ERR_COR_MASK, PCI_ERR_COR_MASK_DEFAULT); pci_set_long(dev->wmask + offset + PCI_ERR_COR_MASK, PCI_ERR_COR_SUPPORTED); if (dev->exp.aer_log.log_max > 0) { pci_set_long(dev->config + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC | PCI_ERR_CAP_MHRC); pci_set_long(dev->wmask + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE | PCI_ERR_CAP_MHRE); } else { pci_set_long(dev->config + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC); pci_set_long(dev->wmask + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE); } switch (pcie_cap_get_type(dev)) { case PCI_EXP_TYPE_ROOT_PORT: case PCI_EXP_TYPE_DOWNSTREAM: case PCI_EXP_TYPE_UPSTREAM: pci_word_test_and_set_mask(dev->wmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_SERR); pci_long_test_and_set_mask(dev->w1cmask + PCI_STATUS, PCI_SEC_STATUS_RCV_SYSTEM_ERROR); break; default: break; } return 0; }

[[[[Adv]]]]: int pcie_aer_init(PCIDevice *dev, uint16_t offset, uint16_t size) { PCIExpressDevice *[[instructive]]; pcie_add_capability(dev, PCI_EXT_CAP_ID_ERR, PCI_ERR_VER, offset, size); [[instructive]] = &dev->exp; [[instructive]]->aer_cap = offset; if (dev->exp.aer_log.log_max == PCIE_AER_LOG_MAX_UNSET) { dev->exp.aer_log.log_max = PCIE_AER_LOG_MAX_DEFAULT; } if (dev->exp.aer_log.log_max > PCIE_AER_LOG_MAX_LIMIT) { return -EINVAL; } dev->exp.aer_log.log = g_malloc0(sizeof dev->exp.aer_log.log[0] * dev->exp.aer_log.log_max); pci_set_long(dev->w1cmask + offset + PCI_ERR_UNCOR_STATUS, PCI_ERR_UNC_SUPPORTED); pci_set_long(dev->config + offset + PCI_ERR_UNCOR_SEVER, PCI_ERR_UNC_SEVERITY_DEFAULT); pci_set_long(dev->wmask + offset + PCI_ERR_UNCOR_SEVER, PCI_ERR_UNC_SUPPORTED); pci_long_test_and_set_mask(dev->w1cmask + offset + PCI_ERR_COR_STATUS, PCI_ERR_COR_SUPPORTED); pci_set_long(dev->config + offset + PCI_ERR_COR_MASK, PCI_ERR_COR_MASK_DEFAULT); pci_set_long(dev->wmask + offset + PCI_ERR_COR_MASK, PCI_ERR_COR_SUPPORTED); if (dev->exp.aer_log.log_max > 0) { pci_set_long(dev->config + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC | PCI_ERR_CAP_MHRC); pci_set_long(dev->wmask + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE | PCI_ERR_CAP_MHRE); } else { pci_set_long(dev->config + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC); pci_set_long(dev->wmask + offset + PCI_ERR_CAP, PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE); } switch (pcie_cap_get_type(dev)) { case PCI_EXP_TYPE_ROOT_PORT: case PCI_EXP_TYPE_DOWNSTREAM: case PCI_EXP_TYPE_UPSTREAM: pci_word_test_and_set_mask(dev->wmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_SERR); pci_long_test_and_set_mask(dev->w1cmask + PCI_STATUS, PCI_SEC_STATUS_RCV_SYSTEM_ERROR); break; default: break; } return 0; }
--------------------------------------------- Result 806 ---------------------------------------------
[[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qemu_tcg_init_vcpu(CPUState *cpu) { char thread_name[VCPU_THREAD_NAME_SIZE]; static QemuCond *tcg_halt_cond; static QemuThread *tcg_cpu_thread; if (!tcg_cpu_thread) { cpu->thread = g_malloc0(sizeof(QemuThread)); cpu->halt_cond = g_malloc0(sizeof(QemuCond)); qemu_cond_init(cpu->halt_cond); tcg_halt_cond = cpu->halt_cond; snprintf(thread_name, VCPU_THREAD_NAME_SIZE, "CPU %d/TCG", cpu->cpu_index); qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn, cpu, QEMU_THREAD_JOINABLE); #ifdef _WIN32 cpu->hThread = qemu_thread_get_handle(cpu->thread); #endif while (!cpu->created) { qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex); } tcg_cpu_thread = cpu->thread; } else { cpu->thread = tcg_cpu_thread; cpu->halt_cond = tcg_halt_cond; } }
--------------------------------------------- Result 807 ---------------------------------------------
[[0 (55%)]] --> [[0 (31%)]] --> Socre: 0.6863331496715546

[[[[Adv]]]]: ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *[[data]], size_t datalen) { ssize_t ret; #ifdef CONFIG_VNC_TLS if (vs->tls.session) { ret = vnc_client_write_tls(&vs->tls.session, [[data]], datalen); } else { #endif ret = send(vs->csock, (const void *)data, datalen, 0); #ifdef CONFIG_VNC_TLS } #endif VNC_DEBUG("Wrote wire %p %zd -> %ld\n", [[data]], datalen, ret); return vnc_client_io_error(vs, ret, socket_error()); }

[[[[Adv]]]]: ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *[[statistical]], size_t datalen) { ssize_t ret; #ifdef CONFIG_VNC_TLS if (vs->tls.session) { ret = vnc_client_write_tls(&vs->tls.session, [[statistical]], datalen); } else { #endif ret = send(vs->csock, (const void *)data, datalen, 0); #ifdef CONFIG_VNC_TLS } #endif VNC_DEBUG("Wrote wire %p %zd -> %ld\n", [[statistical]], datalen, ret); return vnc_client_io_error(vs, ret, socket_error()); }
--------------------------------------------- Result 808 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 467 / 47 / 294 / 808:  30%|       | 808/2690 [9:45:24<22:43:32, 43.47s/it][Succeeded / Failed / Skipped / Total] 467 / 47 / 294 / 808:  30%|       | 809/2690 [9:45:31<22:41:23, 43.43s/it][Succeeded / Failed / Skipped / Total] 468 / 47 / 294 / 809:  30%|       | 809/2690 [9:45:31<22:41:23, 43.43s/it][Succeeded / Failed / Skipped / Total] 468 / 47 / 294 / 809:  30%|       | 810/2690 [9:45:31<22:39:00, 43.37s/it][Succeeded / Failed / Skipped / Total] 468 / 47 / 295 / 810:  30%|       | 810/2690 [9:45:31<22:39:00, 43.37s/it][Succeeded / Failed / Skipped / Total] 468 / 47 / 295 / 810:  30%|       | 811/2690 [9:45:32<22:36:37, 43.32s/it][[0 (81%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int decode_init(AVCodecContext * avctx) { MPADecodeContext *s = avctx->priv_data; static int init=0; int i, j, k; s->avctx = avctx; ff_mpadsp_init(&s->mpadsp); avctx->sample_fmt= OUT_FMT; s->error_recognition= avctx->error_recognition; if (!init && !avctx->parse_only) { int offset; for(i=0;i<64;i++) { int shift, mod; shift = (i / 3); mod = i % 3; scale_factor_modshift[i] = mod | (shift << 2); } for(i=0;i<15;i++) { int n, norm; n = i + 2; norm = ((INT64_C(1) << n) * FRAC_ONE) / ((1 << n) - 1); scale_factor_mult[i][0] = MULLx(norm, FIXR(1.0 * 2.0), FRAC_BITS); scale_factor_mult[i][1] = MULLx(norm, FIXR(0.7937005259 * 2.0), FRAC_BITS); scale_factor_mult[i][2] = MULLx(norm, FIXR(0.6299605249 * 2.0), FRAC_BITS); av_dlog(avctx, "%d: norm=%x s=%x %x %x\n", i, norm, scale_factor_mult[i][0], scale_factor_mult[i][1], scale_factor_mult[i][2]); } RENAME(ff_mpa_synth_init)(RENAME(ff_mpa_synth_window)); offset = 0; for(i=1;i<16;i++) { const HuffTable *h = &mpa_huff_tables[i]; int xsize, x, y; uint8_t tmp_bits [512]; uint16_t tmp_codes[512]; memset(tmp_bits , 0, sizeof(tmp_bits )); memset(tmp_codes, 0, sizeof(tmp_codes)); xsize = h->xsize; j = 0; for(x=0;x<xsize;x++) { for(y=0;y<xsize;y++){ tmp_bits [(x << 5) | y | ((x&&y)<<4)]= h->bits [j ]; tmp_codes[(x << 5) | y | ((x&&y)<<4)]= h->codes[j++]; } } huff_vlc[i].table = huff_vlc_tables+offset; huff_vlc[i].table_allocated = huff_vlc_tables_sizes[i]; init_vlc(&huff_vlc[i], 7, 512, tmp_bits, 1, 1, tmp_codes, 2, 2, INIT_VLC_USE_NEW_STATIC); offset += huff_vlc_tables_sizes[i]; } assert(offset == FF_ARRAY_ELEMS(huff_vlc_tables)); offset = 0; for(i=0;i<2;i++) { huff_quad_vlc[i].table = huff_quad_vlc_tables+offset; huff_quad_vlc[i].table_allocated = huff_quad_vlc_tables_sizes[i]; init_vlc(&huff_quad_vlc[i], i == 0 ? 7 : 4, 16, mpa_quad_bits[i], 1, 1, mpa_quad_codes[i], 1, 1, INIT_VLC_USE_NEW_STATIC); offset += huff_quad_vlc_tables_sizes[i]; } assert(offset == FF_ARRAY_ELEMS(huff_quad_vlc_tables)); for(i=0;i<9;i++) { k = 0; for(j=0;j<22;j++) { band_index_long[i][j] = k; k += band_size_long[i][j]; } band_index_long[i][22] = k; } int_pow_init(); mpegaudio_tableinit(); for (i = 0; i < 4; i++) if (ff_mpa_quant_bits[i] < 0) for (j = 0; j < (1<<(-ff_mpa_quant_bits[i]+1)); j++) { int val1, val2, val3, steps; int val = j; steps = ff_mpa_quant_steps[i]; val1 = val % steps; val /= steps; val2 = val % steps; val3 = val / steps; division_tabs[i][j] = val1 + (val2 << 4) + (val3 << 8); } for(i=0;i<7;i++) { float f; INTFLOAT v; if (i != 6) { f = tan((double)i * M_PI / 12.0); v = FIXR(f / (1.0 + f)); } else { v = FIXR(1.0); } is_table[0][i] = v; is_table[1][6 - i] = v; } for(i=7;i<16;i++) is_table[0][i] = is_table[1][i] = 0.0; for(i=0;i<16;i++) { double f; int e, k; for(j=0;j<2;j++) { e = -(j + 1) * ((i + 1) >> 1); f = pow(2.0, e / 4.0); k = i & 1; is_table_lsf[j][k ^ 1][i] = FIXR(f); is_table_lsf[j][k][i] = FIXR(1.0); av_dlog(avctx, "is_table_lsf %d %d: %x %x\n", i, j, is_table_lsf[j][0][i], is_table_lsf[j][1][i]); } } for(i=0;i<8;i++) { float ci, cs, ca; ci = ci_table[i]; cs = 1.0 / sqrt(1.0 + ci * ci); ca = cs * ci; csa_table[i][0] = FIXHR(cs/4); csa_table[i][1] = FIXHR(ca/4); csa_table[i][2] = FIXHR(ca/4) + FIXHR(cs/4); csa_table[i][3] = FIXHR(ca/4) - FIXHR(cs/4); csa_table_float[i][0] = cs; csa_table_float[i][1] = ca; csa_table_float[i][2] = ca + cs; csa_table_float[i][3] = ca - cs; } for(i=0;i<36;i++) { for(j=0; j<4; j++){ double d; if(j==2 && i%3 != 1) continue; d= sin(M_PI * (i + 0.5) / 36.0); if(j==1){ if (i>=30) d= 0; else if(i>=24) d= sin(M_PI * (i - 18 + 0.5) / 12.0); else if(i>=18) d= 1; }else if(j==3){ if (i< 6) d= 0; else if(i< 12) d= sin(M_PI * (i - 6 + 0.5) / 12.0); else if(i< 18) d= 1; } d*= 0.5 / cos(M_PI*(2*i + 19)/72); if(j==2) mdct_win[j][i/3] = FIXHR((d / (1<<5))); else mdct_win[j][i ] = FIXHR((d / (1<<5))); } } for(j=0;j<4;j++) { for(i=0;i<36;i+=2) { mdct_win[j + 4][i] = mdct_win[j][i]; mdct_win[j + 4][i + 1] = -mdct_win[j][i + 1]; } } init = 1; } if (avctx->codec_id == CODEC_ID_MP3ADU) s->adu_mode = 1; return 0; }
--------------------------------------------- Result 809 ---------------------------------------------
[[0 (20%)]] --> [[0 (60%)]] --> Socre: 0.6003710031509399

[[[[Adv]]]]: static int libgsm_decode_frame(AVCodecContext *avctx, void *[[data]], int *data_size, AVPacket *avpkt) { uint8_t *[[buf]] = avpkt->data; int buf_size = avpkt->size; int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt); if (*data_size < out_size) { av_log(avctx, AV_LOG_ERROR, "Output buffer is too small\n"); return AVERROR(EINVAL); } if (buf_size < avctx->block_align) { av_log(avctx, AV_LOG_ERROR, "Packet is too small\n"); return AVERROR_INVALIDDATA; } switch(avctx->codec_id) { case CODEC_ID_GSM: if(gsm_decode(avctx->priv_data,[[buf]],[[data]])) return -1; break; case CODEC_ID_GSM_MS: if(gsm_decode(avctx->priv_data,[[buf]],[[data]]) || gsm_decode(avctx->priv_data,[[buf]]+33,((int16_t*)[[data]])+GSM_FRAME_SIZE)) return -1; } *data_size = out_size; return avctx->block_align; }

[[[[Adv]]]]: static int libgsm_decode_frame(AVCodecContext *avctx, void *[[explanations]], int *data_size, AVPacket *avpkt) { uint8_t *[[jams]] = avpkt->data; int buf_size = avpkt->size; int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt); if (*data_size < out_size) { av_log(avctx, AV_LOG_ERROR, "Output buffer is too small\n"); return AVERROR(EINVAL); } if (buf_size < avctx->block_align) { av_log(avctx, AV_LOG_ERROR, "Packet is too small\n"); return AVERROR_INVALIDDATA; } switch(avctx->codec_id) { case CODEC_ID_GSM: if(gsm_decode(avctx->priv_data,[[jams]],[[explanations]])) return -1; break; case CODEC_ID_GSM_MS: if(gsm_decode(avctx->priv_data,[[jams]],[[explanations]]) || gsm_decode(avctx->priv_data,[[jams]]+33,((int16_t*)[[explanations]])+GSM_FRAME_SIZE)) return -1; } *data_size = out_size; return avctx->block_align; }
--------------------------------------------- Result 810 ---------------------------------------------
[[0 (20%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr) { unsigned access_size_min = mr->ops->impl.min_access_size; unsigned access_size_max = mr->ops->impl.max_access_size; if (access_size_min == 0) { access_size_min = 1; } if (access_size_max == 0) { access_size_max = 4; } if (!mr->ops->impl.unaligned) { unsigned align_size_max = addr & -addr; if (align_size_max != 0 && align_size_max < access_size_max) { access_size_max = align_size_max; } } if (l > access_size_max) { l = access_size_max; } assert(l >= access_size_min); return l; }
--------------------------------------------- Result 811 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 468 / 47 / 296 / 811:  30%|       | 811/2690 [9:45:32<22:36:37, 43.32s/it][Succeeded / Failed / Skipped / Total] 468 / 47 / 296 / 811:  30%|       | 812/2690 [9:45:32<22:34:15, 43.27s/it][Succeeded / Failed / Skipped / Total] 468 / 47 / 297 / 812:  30%|       | 812/2690 [9:45:32<22:34:15, 43.27s/it][Succeeded / Failed / Skipped / Total] 468 / 47 / 297 / 812:  30%|       | 813/2690 [9:45:33<22:31:53, 43.21s/it][Succeeded / Failed / Skipped / Total] 468 / 47 / 298 / 813:  30%|       | 813/2690 [9:45:33<22:31:53, 43.21s/it][Succeeded / Failed / Skipped / Total] 468 / 47 / 298 / 813:  30%|       | 814/2690 [9:45:33<22:29:31, 43.16s/it][Succeeded / Failed / Skipped / Total] 468 / 47 / 299 / 814:  30%|       | 814/2690 [9:45:33<22:29:31, 43.16s/it][Succeeded / Failed / Skipped / Total] 468 / 47 / 299 / 814:  30%|       | 815/2690 [9:47:41<22:32:03, 43.27s/it][Succeeded / Failed / Skipped / Total] 469 / 47 / 299 / 815:  30%|       | 815/2690 [9:47:41<22:32:03, 43.27s/it][Succeeded / Failed / Skipped / Total] 469 / 47 / 299 / 815:  30%|       | 816/2690 [9:47:42<22:29:42, 43.21s/it][Succeeded / Failed / Skipped / Total] 469 / 47 / 300 / 816:  30%|       | 816/2690 [9:47:42<22:29:42, 43.21s/it][Succeeded / Failed / Skipped / Total] 469 / 47 / 300 / 816:  30%|       | 817/2690 [9:47:42<22:27:21, 43.16s/it][[0 (25%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void fw_cfg_add_file_callback(FWCfgState *s, const char *filename, FWCfgCallback select_cb, FWCfgWriteCallback write_cb, void *callback_opaque, void *data, size_t len, bool read_only) { int i, index, count; size_t dsize; MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine()); int order = 0; if (!s->files) { dsize = sizeof(uint32_t) + sizeof(FWCfgFile) * fw_cfg_file_slots(s); s->files = g_malloc0(dsize); fw_cfg_add_bytes(s, FW_CFG_FILE_DIR, s->files, dsize); } count = be32_to_cpu(s->files->count); assert(count < fw_cfg_file_slots(s)); if (mc->legacy_fw_cfg_order) { order = get_fw_cfg_order(s, filename); for (index = count; index > 0 && order < s->entry_order[index - 1]; index--); } else { for (index = count; index > 0 && strcmp(filename, s->files->f[index - 1].name) < 0; index--); } for (i = count + 1; i > index; i--) { s->files->f[i] = s->files->f[i - 1]; s->files->f[i].select = cpu_to_be16(FW_CFG_FILE_FIRST + i); s->entries[0][FW_CFG_FILE_FIRST + i] = s->entries[0][FW_CFG_FILE_FIRST + i - 1]; s->entry_order[i] = s->entry_order[i - 1]; } memset(&s->files->f[index], 0, sizeof(FWCfgFile)); memset(&s->entries[0][FW_CFG_FILE_FIRST + index], 0, sizeof(FWCfgEntry)); pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename); for (i = 0; i <= count; i++) { if (i != index && strcmp(s->files->f[index].name, s->files->f[i].name) == 0) { error_report("duplicate fw_cfg file name: %s", s->files->f[index].name); exit(1); } } fw_cfg_add_bytes_callback(s, FW_CFG_FILE_FIRST + index, select_cb, write_cb, callback_opaque, data, len, read_only); s->files->f[index].size = cpu_to_be32(len); s->files->f[index].select = cpu_to_be16(FW_CFG_FILE_FIRST + index); s->entry_order[index] = order; trace_fw_cfg_add_file(s, index, s->files->f[index].name, len); s->files->count = cpu_to_be32(count+1); }
--------------------------------------------- Result 812 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void stellaris_enet_save(QEMUFile *f, void *opaque) { stellaris_enet_state *s = (stellaris_enet_state *)opaque; int i; qemu_put_be32(f, s->ris); qemu_put_be32(f, s->im); qemu_put_be32(f, s->rctl); qemu_put_be32(f, s->tctl); qemu_put_be32(f, s->thr); qemu_put_be32(f, s->mctl); qemu_put_be32(f, s->mdv); qemu_put_be32(f, s->mtxd); qemu_put_be32(f, s->mrxd); qemu_put_be32(f, s->np); qemu_put_be32(f, s->tx_fifo_len); qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo)); for (i = 0; i < 31; i++) { qemu_put_be32(f, s->rx[i].len); qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data)); } qemu_put_be32(f, s->next_packet); qemu_put_be32(f, s->rx_fifo_offset); }
--------------------------------------------- Result 813 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void exit_program(void) { int i, j; for (i = 0; i < nb_filtergraphs; i++) { avfilter_graph_free(&filtergraphs[i]->graph); for (j = 0; j < filtergraphs[i]->nb_inputs; j++) { av_freep(&filtergraphs[i]->inputs[j]->name); av_freep(&filtergraphs[i]->inputs[j]); } av_freep(&filtergraphs[i]->inputs); for (j = 0; j < filtergraphs[i]->nb_outputs; j++) { av_freep(&filtergraphs[i]->outputs[j]->name); av_freep(&filtergraphs[i]->outputs[j]); } av_freep(&filtergraphs[i]->outputs); av_freep(&filtergraphs[i]->graph_desc); av_freep(&filtergraphs[i]); } av_freep(&filtergraphs); for (i = 0; i < nb_output_files; i++) { AVFormatContext *s = output_files[i]->ctx; if (!(s->oformat->flags & AVFMT_NOFILE) && s->pb) avio_close(s->pb); avformat_free_context(s); av_dict_free(&output_files[i]->opts); av_freep(&output_files[i]); } for (i = 0; i < nb_output_streams; i++) { AVBitStreamFilterContext *bsfc = output_streams[i]->bitstream_filters; while (bsfc) { AVBitStreamFilterContext *next = bsfc->next; av_bitstream_filter_close(bsfc); bsfc = next; } output_streams[i]->bitstream_filters = NULL; avcodec_free_frame(&output_streams[i]->filtered_frame); av_freep(&output_streams[i]->forced_keyframes); av_freep(&output_streams[i]->avfilter); av_freep(&output_streams[i]->logfile_prefix); av_freep(&output_streams[i]); } for (i = 0; i < nb_input_files; i++) { avformat_close_input(&input_files[i]->ctx); av_freep(&input_files[i]); } for (i = 0; i < nb_input_streams; i++) { av_frame_free(&input_streams[i]->decoded_frame); av_frame_free(&input_streams[i]->filter_frame); av_dict_free(&input_streams[i]->opts); av_freep(&input_streams[i]->filters); av_freep(&input_streams[i]); } if (vstats_file) fclose(vstats_file); av_free(vstats_filename); av_freep(&input_streams); av_freep(&input_files); av_freep(&output_streams); av_freep(&output_files); uninit_opts(); avfilter_uninit(); avformat_network_deinit(); if (received_sigterm) { av_log(NULL, AV_LOG_INFO, "Received signal %d: terminating.\n", (int) received_sigterm); exit (255); } }
--------------------------------------------- Result 814 ---------------------------------------------
[[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs, int64_t sector_num, int nb_sectors, int *num_same) { int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8; uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE; uint8_t bitmap[BDRV_SECTOR_SIZE]; int ret; int changed; ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)); if (ret < 0) { return ret; } bitnum &= BITS_PER_BITMAP_SECTOR - 1; changed = cow_test_bit(bitnum, bitmap); *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors); return changed; }
--------------------------------------------- Result 815 ---------------------------------------------
[[0 (4%)]] --> [[0 (99%)]] --> Socre: 0.9902985692024231

[[[[Adv]]]]: bool timerlist_expired(QEMUTimerList *timer_list) { int64_t [[expire_time]]; if (!atomic_read(&timer_list->active_timers)) { return "False" != "False"; } qemu_mutex_lock(&timer_list->active_timers_lock); if (!timer_list->active_timers) { qemu_mutex_unlock(&timer_list->active_timers_lock); return "False" != "False"; } [[expire_time]] = timer_list->active_timers->expire_time; qemu_mutex_unlock(&timer_list->active_timers_lock); return [[expire_time]] < qemu_clock_get_ns(timer_list->clock->type); }

[[[[Adv]]]]: bool timerlist_expired(QEMUTimerList *timer_list) { int64_t [[vocs]]; if (!atomic_read(&timer_list->active_timers)) { return "False" != "False"; } qemu_mutex_lock(&timer_list->active_timers_lock); if (!timer_list->active_timers) { qemu_mutex_unlock(&timer_list->active_timers_lock); return "False" != "False"; } [[vocs]] = timer_list->active_timers->expire_time; qemu_mutex_unlock(&timer_list->active_timers_lock); return [[vocs]] < qemu_clock_get_ns(timer_list->clock->type); }
--------------------------------------------- Result 816 ---------------------------------------------
[[0 (88%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void check_refcounts(BlockDriverState *bs) { BDRVQcowState *s = bs->opaque; int64_t size; int nb_clusters, refcount1, refcount2, i; QCowSnapshot *sn; uint16_t *refcount_table; size = bdrv_getlength(s->hd); nb_clusters = size_to_clusters(s, size); refcount_table = qemu_mallocz(nb_clusters * sizeof(uint16_t)); inc_refcounts(bs, refcount_table, nb_clusters, 0, s->cluster_size); check_refcounts_l1(bs, refcount_table, nb_clusters, s->l1_table_offset, s->l1_size, 1); for(i = 0; i < s->nb_snapshots; i++) { sn = s->snapshots + i; check_refcounts_l1(bs, refcount_table, nb_clusters, sn->l1_table_offset, sn->l1_size, 0); } inc_refcounts(bs, refcount_table, nb_clusters, s->snapshots_offset, s->snapshots_size); inc_refcounts(bs, refcount_table, nb_clusters, s->refcount_table_offset, s->refcount_table_size * sizeof(uint64_t)); for(i = 0; i < s->refcount_table_size; i++) { int64_t offset; offset = s->refcount_table[i]; if (offset != 0) { inc_refcounts(bs, refcount_table, nb_clusters, offset, s->cluster_size); } } for(i = 0; i < nb_clusters; i++) { refcount1 = get_refcount(bs, i); refcount2 = refcount_table[i]; if (refcount1 != refcount2) fprintf(stderr, "ERROR cluster %d refcount=%d reference=%d\n", i, refcount1, refcount2); } qemu_free(refcount_table); }
[Succeeded / Failed / Skipped / Total] 469 / 47 / 301 / 817:  30%|       | 817/2690 [9:47:42<22:27:21, 43.16s/it][Succeeded / Failed / Skipped / Total] 469 / 47 / 301 / 817:  30%|       | 818/2690 [9:47:46<22:25:08, 43.11s/it][Succeeded / Failed / Skipped / Total] 470 / 47 / 301 / 818:  30%|       | 818/2690 [9:47:46<22:25:08, 43.11s/it][Succeeded / Failed / Skipped / Total] 470 / 47 / 301 / 818:  30%|       | 819/2690 [9:47:51<22:22:56, 43.07s/it][Succeeded / Failed / Skipped / Total] 471 / 47 / 301 / 819:  30%|       | 819/2690 [9:47:51<22:22:56, 43.07s/it][Succeeded / Failed / Skipped / Total] 471 / 47 / 301 / 819:  30%|       | 820/2690 [9:47:51<22:20:36, 43.01s/it][Succeeded / Failed / Skipped / Total] 471 / 47 / 302 / 820:  30%|       | 820/2690 [9:47:51<22:20:36, 43.01s/it][Succeeded / Failed / Skipped / Total] 471 / 47 / 302 / 820:  31%|       | 821/2690 [9:49:16<22:21:29, 43.07s/it]--------------------------------------------- Result 817 ---------------------------------------------
[[0 (28%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ipoctal_init(IPackDevice *ip) { IPOctalState *s = IPOCTAL(ip); unsigned i; for (i = 0; i < N_CHANNELS; i++) { SCC2698Channel *ch = &s->ch[i]; ch->ipoctal = s; if (ch->devpath) { const char chr_name[] = "ipoctal"; char label[ARRAY_SIZE(chr_name) + 2]; static int index; snprintf(label, sizeof(label), "%s%d", chr_name, index); ch->dev = qemu_chr_new(label, ch->devpath, NULL); if (ch->dev) { index++; qemu_chr_add_handlers(ch->dev, hostdev_can_receive, hostdev_receive, hostdev_event, ch); DPRINTF("Redirecting channel %u to %s (%s)\n", i, ch->devpath, label); } else { DPRINTF("Could not redirect channel %u to %s\n", i, ch->devpath); } } } return 0; }
--------------------------------------------- Result 818 ---------------------------------------------
[[0 (74%)]] --> [[0 (32%)]] --> Socre: 0.6754315495491028

[[[[Adv]]]]: static AddrRange addrrange_intersection(AddrRange [[r1]], AddrRange r2) { uint64_t start = MAX([[r1]].start, r2.start); uint64_t end = MIN(addrrange_end([[r1]]) - 1, addrrange_end(r2) - 1); return addrrange_make(start, end - start + 1); }

[[[[Adv]]]]: static AddrRange addrrange_intersection(AddrRange [[discharge]], AddrRange r2) { uint64_t start = MAX([[discharge]].start, r2.start); uint64_t end = MIN(addrrange_end([[discharge]]) - 1, addrrange_end(r2) - 1); return addrrange_make(start, end - start + 1); }
--------------------------------------------- Result 819 ---------------------------------------------
[[0 (43%)]] --> [[0 (60%)]] --> Socre: 0.597244918346405

[[[[Adv]]]]: static int wc3_read_header(AVFormatContext *s, AVFormatParameters *ap) { Wc3DemuxContext *wc3 = s->priv_data; ByteIOContext *[[pb]] = s->pb; unsigned int fourcc_tag; unsigned int size; AVStream *st; unsigned char [[preamble]][WC3_PREAMBLE_SIZE]; int ret = 0; int current_palette = 0; int bytes_to_read; int i; unsigned char rotate; wc3->width = WC3_DEFAULT_WIDTH; wc3->height = WC3_DEFAULT_HEIGHT; wc3->palettes = NULL; wc3->palette_count = 0; wc3->pts = 0; wc3->video_stream_index = wc3->audio_stream_index = 0; url_fseek([[pb]], 12, SEEK_CUR); if ((ret = get_buffer([[pb]], [[preamble]], WC3_PREAMBLE_SIZE)) != WC3_PREAMBLE_SIZE) return AVERROR(EIO); fourcc_tag = AV_RL32(&[[preamble]][0]); size = (AV_RB32(&[[preamble]][4]) + 1) & (~1); do { switch (fourcc_tag) { case SOND_TAG: case INDX_TAG: url_fseek([[pb]], size, SEEK_CUR); break; case _PC__TAG: url_fseek([[pb]], 8, SEEK_CUR); if ((ret = get_buffer([[pb]], [[preamble]], 4)) != 4) return AVERROR(EIO); wc3->palette_count = AV_RL32(&[[preamble]][0]); if((unsigned)wc3->palette_count >= UINT_MAX / PALETTE_SIZE){ wc3->palette_count= 0; return -1; } wc3->palettes = av_malloc(wc3->palette_count * PALETTE_SIZE); break; case BNAM_TAG: if ((unsigned)size < 512) bytes_to_read = size; else bytes_to_read = 512; if ((ret = get_buffer([[pb]], s->title, bytes_to_read)) != bytes_to_read) return AVERROR(EIO); break; case SIZE_TAG: if ((ret = get_buffer([[pb]], [[preamble]], WC3_PREAMBLE_SIZE)) != WC3_PREAMBLE_SIZE) return AVERROR(EIO); wc3->width = AV_RL32(&[[preamble]][0]); wc3->height = AV_RL32(&[[preamble]][4]); break; case PALT_TAG: if ((unsigned)current_palette >= wc3->palette_count) return AVERROR_INVALIDDATA; if ((ret = get_buffer([[pb]], &wc3->palettes[current_palette * PALETTE_SIZE], PALETTE_SIZE)) != PALETTE_SIZE) return AVERROR(EIO); for (i = current_palette * PALETTE_SIZE; i < (current_palette + 1) * PALETTE_SIZE; i++) { rotate = ((wc3->palettes[i] << 2) & 0xFF) | ((wc3->palettes[i] >> 6) & 0xFF); wc3->palettes[i] = wc3_pal_lookup[rotate]; } current_palette++; break; default: av_log(s, AV_LOG_ERROR, " unrecognized WC3 chunk: %c%c%c%c (0x%02X%02X%02X%02X)\n", [[preamble]][0], [[preamble]][1], [[preamble]][2], [[preamble]][3], [[preamble]][0], [[preamble]][1], [[preamble]][2], [[preamble]][3]); return AVERROR_INVALIDDATA; break; } if ((ret = get_buffer([[pb]], [[preamble]], WC3_PREAMBLE_SIZE)) != WC3_PREAMBLE_SIZE) return AVERROR(EIO); fourcc_tag = AV_RL32(&[[preamble]][0]); size = (AV_RB32(&[[preamble]][4]) + 1) & (~1); } while (fourcc_tag != BRCH_TAG); st = av_new_stream(s, 0); if (!st) return AVERROR(ENOMEM); av_set_pts_info(st, 33, 1, 90000); wc3->video_stream_index = st->index; st->codec->codec_type = CODEC_TYPE_VIDEO; st->codec->codec_id = CODEC_ID_XAN_WC3; st->codec->codec_tag = 0; st->codec->width = wc3->width; st->codec->height = wc3->height; st->codec->palctrl = &wc3->palette_control; st = av_new_stream(s, 0); if (!st) return AVERROR(ENOMEM); av_set_pts_info(st, 33, 1, 90000); wc3->audio_stream_index = st->index; st->codec->codec_type = CODEC_TYPE_AUDIO; st->codec->codec_id = CODEC_ID_PCM_S16LE; st->codec->codec_tag = 1; st->codec->channels = WC3_AUDIO_CHANNELS; st->codec->bits_per_sample = WC3_AUDIO_BITS; st->codec->sample_rate = WC3_SAMPLE_RATE; st->codec->bit_rate = st->codec->channels * st->codec->sample_rate * st->codec->bits_per_sample; st->codec->block_align = WC3_AUDIO_BITS * WC3_AUDIO_CHANNELS; return 0; }

[[[[Adv]]]]: static int wc3_read_header(AVFormatContext *s, AVFormatParameters *ap) { Wc3DemuxContext *wc3 = s->priv_data; ByteIOContext *[[gp]] = s->pb; unsigned int fourcc_tag; unsigned int size; AVStream *st; unsigned char [[inclusion]][WC3_PREAMBLE_SIZE]; int ret = 0; int current_palette = 0; int bytes_to_read; int i; unsigned char rotate; wc3->width = WC3_DEFAULT_WIDTH; wc3->height = WC3_DEFAULT_HEIGHT; wc3->palettes = NULL; wc3->palette_count = 0; wc3->pts = 0; wc3->video_stream_index = wc3->audio_stream_index = 0; url_fseek([[gp]], 12, SEEK_CUR); if ((ret = get_buffer([[gp]], [[inclusion]], WC3_PREAMBLE_SIZE)) != WC3_PREAMBLE_SIZE) return AVERROR(EIO); fourcc_tag = AV_RL32(&[[inclusion]][0]); size = (AV_RB32(&[[inclusion]][4]) + 1) & (~1); do { switch (fourcc_tag) { case SOND_TAG: case INDX_TAG: url_fseek([[gp]], size, SEEK_CUR); break; case _PC__TAG: url_fseek([[gp]], 8, SEEK_CUR); if ((ret = get_buffer([[gp]], [[inclusion]], 4)) != 4) return AVERROR(EIO); wc3->palette_count = AV_RL32(&[[inclusion]][0]); if((unsigned)wc3->palette_count >= UINT_MAX / PALETTE_SIZE){ wc3->palette_count= 0; return -1; } wc3->palettes = av_malloc(wc3->palette_count * PALETTE_SIZE); break; case BNAM_TAG: if ((unsigned)size < 512) bytes_to_read = size; else bytes_to_read = 512; if ((ret = get_buffer([[gp]], s->title, bytes_to_read)) != bytes_to_read) return AVERROR(EIO); break; case SIZE_TAG: if ((ret = get_buffer([[gp]], [[inclusion]], WC3_PREAMBLE_SIZE)) != WC3_PREAMBLE_SIZE) return AVERROR(EIO); wc3->width = AV_RL32(&[[inclusion]][0]); wc3->height = AV_RL32(&[[inclusion]][4]); break; case PALT_TAG: if ((unsigned)current_palette >= wc3->palette_count) return AVERROR_INVALIDDATA; if ((ret = get_buffer([[gp]], &wc3->palettes[current_palette * PALETTE_SIZE], PALETTE_SIZE)) != PALETTE_SIZE) return AVERROR(EIO); for (i = current_palette * PALETTE_SIZE; i < (current_palette + 1) * PALETTE_SIZE; i++) { rotate = ((wc3->palettes[i] << 2) & 0xFF) | ((wc3->palettes[i] >> 6) & 0xFF); wc3->palettes[i] = wc3_pal_lookup[rotate]; } current_palette++; break; default: av_log(s, AV_LOG_ERROR, " unrecognized WC3 chunk: %c%c%c%c (0x%02X%02X%02X%02X)\n", [[inclusion]][0], [[inclusion]][1], [[inclusion]][2], [[inclusion]][3], [[inclusion]][0], [[inclusion]][1], [[inclusion]][2], [[inclusion]][3]); return AVERROR_INVALIDDATA; break; } if ((ret = get_buffer([[gp]], [[inclusion]], WC3_PREAMBLE_SIZE)) != WC3_PREAMBLE_SIZE) return AVERROR(EIO); fourcc_tag = AV_RL32(&[[inclusion]][0]); size = (AV_RB32(&[[inclusion]][4]) + 1) & (~1); } while (fourcc_tag != BRCH_TAG); st = av_new_stream(s, 0); if (!st) return AVERROR(ENOMEM); av_set_pts_info(st, 33, 1, 90000); wc3->video_stream_index = st->index; st->codec->codec_type = CODEC_TYPE_VIDEO; st->codec->codec_id = CODEC_ID_XAN_WC3; st->codec->codec_tag = 0; st->codec->width = wc3->width; st->codec->height = wc3->height; st->codec->palctrl = &wc3->palette_control; st = av_new_stream(s, 0); if (!st) return AVERROR(ENOMEM); av_set_pts_info(st, 33, 1, 90000); wc3->audio_stream_index = st->index; st->codec->codec_type = CODEC_TYPE_AUDIO; st->codec->codec_id = CODEC_ID_PCM_S16LE; st->codec->codec_tag = 1; st->codec->channels = WC3_AUDIO_CHANNELS; st->codec->bits_per_sample = WC3_AUDIO_BITS; st->codec->sample_rate = WC3_SAMPLE_RATE; st->codec->bit_rate = st->codec->channels * st->codec->sample_rate * st->codec->bits_per_sample; st->codec->block_align = WC3_AUDIO_BITS * WC3_AUDIO_CHANNELS; return 0; }
--------------------------------------------- Result 820 ---------------------------------------------
[[0 (77%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int64_t do_strtosz(const char *nptr, char **end, const char default_suffix, int64_t unit) { int64_t retval; char *endptr; unsigned char c; int mul_required = 0; double val, mul, integral, fraction; errno = 0; val = strtod(nptr, &endptr); if (isnan(val) || endptr == nptr || errno != 0) { retval = -EINVAL; goto out; } fraction = modf(val, &integral); if (fraction != 0) { mul_required = 1; } c = *endptr; mul = suffix_mul(c, unit); if (mul >= 0) { endptr++; } else { mul = suffix_mul(default_suffix, unit); assert(mul >= 0); } if (mul == 1 && mul_required) { retval = -EINVAL; goto out; } if ((val * mul >= INT64_MAX) || val < 0) { retval = -ERANGE; goto out; } retval = val * mul; out: if (end) { *end = endptr; } else if (*endptr) { retval = -EINVAL; } return retval; }
--------------------------------------------- Result 821 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 471 / 48 / 302 / 821:  31%|       | 821/2690 [9:49:16<22:21:29, 43.07s/it][Succeeded / Failed / Skipped / Total] 471 / 48 / 302 / 821:  31%|       | 822/2690 [9:49:17<22:19:10, 43.01s/it][Succeeded / Failed / Skipped / Total] 471 / 48 / 303 / 822:  31%|       | 822/2690 [9:49:17<22:19:10, 43.01s/it][Succeeded / Failed / Skipped / Total] 471 / 48 / 303 / 822:  31%|       | 823/2690 [9:49:21<22:16:57, 42.97s/it][Succeeded / Failed / Skipped / Total] 472 / 48 / 303 / 823:  31%|       | 823/2690 [9:49:21<22:16:57, 42.97s/it][Succeeded / Failed / Skipped / Total] 472 / 48 / 303 / 823:  31%|       | 824/2690 [9:50:50<22:17:59, 43.02s/it][[0 (5%)]] --> [[[FAILED]]]

[[[[Adv]]]]: struct omap_l4_s *omap_l4_init(target_phys_addr_t base, int ta_num) { struct omap_l4_s *bus = g_malloc0( sizeof(*bus) + ta_num * sizeof(*bus->ta)); bus->ta_num = ta_num; bus->base = base; #ifdef L4_MUX_HACK omap_l4_io_entries = 1; omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry)); omap_cpu_io_entry = cpu_register_io_memory(omap_l4_io_readfn, omap_l4_io_writefn, bus, DEVICE_NATIVE_ENDIAN); # define L4_PAGES (0xb4000 / TARGET_PAGE_SIZE) omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES); #endif return bus; }

[[[[Adv]]]]: struct omap_l4_s *omap_l4_init(target_phys_addr_t base, int ta_num) { struct omap_l4_s *bus = g_malloc0( sizeof(*bus) + ta_num * sizeof(*bus->ta)); bus->ta_num = ta_num; bus->base = base; #ifdef L4_MUX_HACK omap_l4_io_entries = 1; omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry)); omap_cpu_io_entry = cpu_register_io_memory(omap_l4_io_readfn, omap_l4_io_writefn, bus, DEVICE_NATIVE_ENDIAN); # define L4_PAGES (0xb4000 / TARGET_PAGE_SIZE) omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES); omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES); #endif return bus; }
--------------------------------------------- Result 822 ---------------------------------------------
[[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static uint32_t dcr_read_pob (void *opaque, int dcrn) { ppc4xx_pob_t *pob; uint32_t ret; pob = opaque; switch (dcrn) { case POB0_BEAR: ret = pob->bear; break; case POB0_BESR0: case POB0_BESR1: ret = pob->besr[dcrn - POB0_BESR0]; break; default: ret = 0; break; } return ret; }
--------------------------------------------- Result 823 ---------------------------------------------
[[0 (41%)]] --> [[0 (56%)]] --> Socre: 0.5638833045959473

[[[[Adv]]]]: static inline int onenand_erase(OneNANDState *s, int sec, int num) { uint8_t *[[blankbuf]], *tmpbuf; [[blankbuf]] = g_malloc(512); if (![[blankbuf]]) { return 1; } tmpbuf = g_malloc(512); if (!tmpbuf) { g_free([[blankbuf]]); return 1; } memset([[blankbuf]], 0xff, 512); for (; num > 0; num--, sec++) { if (s->bdrv_cur) { int erasesec = s->secs_cur + (sec >> 5); if (bdrv_write(s->bdrv_cur, sec, [[blankbuf]], 1) < 0) { goto fail; } if (bdrv_read(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) { goto fail; } memcpy(tmpbuf + ((sec & 31) << 4), [[blankbuf]], 1 << 4); if (bdrv_write(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) { goto fail; } } else { if (sec + 1 > s->secs_cur) { goto fail; } memcpy(s->current + (sec << 9), [[blankbuf]], 512); memcpy(s->current + (s->secs_cur << 9) + (sec << 4), [[blankbuf]], 1 << 4); } } g_free(tmpbuf); g_free([[blankbuf]]); return 0; fail: g_free(tmpbuf); g_free([[blankbuf]]); return 1; }

[[[[Adv]]]]: static inline int onenand_erase(OneNANDState *s, int sec, int num) { uint8_t *[[gunned]], *tmpbuf; [[gunned]] = g_malloc(512); if (![[gunned]]) { return 1; } tmpbuf = g_malloc(512); if (!tmpbuf) { g_free([[gunned]]); return 1; } memset([[gunned]], 0xff, 512); for (; num > 0; num--, sec++) { if (s->bdrv_cur) { int erasesec = s->secs_cur + (sec >> 5); if (bdrv_write(s->bdrv_cur, sec, [[gunned]], 1) < 0) { goto fail; } if (bdrv_read(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) { goto fail; } memcpy(tmpbuf + ((sec & 31) << 4), [[gunned]], 1 << 4); if (bdrv_write(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) { goto fail; } } else { if (sec + 1 > s->secs_cur) { goto fail; } memcpy(s->current + (sec << 9), [[gunned]], 512); memcpy(s->current + (s->secs_cur << 9) + (sec << 4), [[gunned]], 1 << 4); } } g_free(tmpbuf); g_free([[gunned]]); return 0; fail: g_free(tmpbuf); g_free([[gunned]]); return 1; }
--------------------------------------------- Result 824 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 473 / 48 / 303 / 824:  31%|       | 824/2690 [9:50:50<22:17:59, 43.02s/it][Succeeded / Failed / Skipped / Total] 473 / 48 / 303 / 824:  31%|       | 825/2690 [9:54:38<22:24:15, 43.25s/it][Succeeded / Failed / Skipped / Total] 473 / 49 / 303 / 825:  31%|       | 825/2690 [9:54:38<22:24:15, 43.25s/it][Succeeded / Failed / Skipped / Total] 473 / 49 / 303 / 825:  31%|       | 826/2690 [9:54:39<22:21:56, 43.20s/it][[0 (60%)]] --> [[0 (45%)]] --> Socre: 0.545218288898468

[[[[Adv]]]]: static int vmdk_parse_extents(const char *[[desc]], BlockDriverState *bs, const char *desc_file_path, Error **errp) { int ret; char access[11]; char type[11]; char fname[512]; const char *[[p]] = [[desc]]; int64_t sectors = 0; int64_t flat_offset; char extent_path[PATH_MAX]; BlockDriverState *extent_file; BDRVVmdkState *s = bs->opaque; VmdkExtent *extent; while (*[[p]]) { flat_offset = -1; ret = sscanf([[p]], "%10s %" SCNd64 " %10s \"%511[^\n\r\"]\" %" SCNd64, access, &sectors, type, fname, &flat_offset); if (ret < 4 || strcmp(access, "RW")) { goto next_line; } else if (!strcmp(type, "FLAT")) { if (ret != 5 || flat_offset < 0) { error_setg(errp, "Invalid extent lines: \n%s", [[p]]); return -EINVAL; } } else if (!strcmp(type, "VMFS")) { if (ret == 4) { flat_offset = 0; } else { error_setg(errp, "Invalid extent lines:\n%s", [[p]]); return -EINVAL; } } else if (ret != 4) { error_setg(errp, "Invalid extent lines:\n%s", [[p]]); return -EINVAL; } if (sectors <= 0 || (strcmp(type, "FLAT") && strcmp(type, "SPARSE") && strcmp(type, "VMFS") && strcmp(type, "VMFSSPARSE")) || (strcmp(access, "RW"))) { goto next_line; } path_combine(extent_path, sizeof(extent_path), desc_file_path, fname); extent_file = NULL; ret = bdrv_open(&extent_file, extent_path, NULL, NULL, bs->open_flags | BDRV_O_PROTOCOL, NULL, errp); if (ret) { return ret; } if (!strcmp(type, "FLAT") || !strcmp(type, "VMFS")) { ret = vmdk_add_extent(bs, extent_file, "True" == "True", sectors, 0, 0, 0, 0, 0, &extent, errp); if (ret < 0) { return ret; } extent->flat_start_offset = flat_offset << 9; } else if (!strcmp(type, "SPARSE") || !strcmp(type, "VMFSSPARSE")) { char *buf = vmdk_read_desc(extent_file, 0, errp); if (!buf) { ret = -EINVAL; } else { ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, buf, errp); } if (ret) { g_free(buf); return ret; } extent = &s->extents[s->num_extents - 1]; } else { error_setg(errp, "Unsupported extent type '%s'", type); return -ENOTSUP; } extent->type = g_strdup(type); next_line: while (*[[p]]) { if (*[[p]] == '\n') { [[p]]++; break; } [[p]]++; } } return 0; }

[[[[Adv]]]]: static int vmdk_parse_extents(const char *[[dreamers]], BlockDriverState *bs, const char *desc_file_path, Error **errp) { int ret; char access[11]; char type[11]; char fname[512]; const char *[[sodium]] = [[dreamers]]; int64_t sectors = 0; int64_t flat_offset; char extent_path[PATH_MAX]; BlockDriverState *extent_file; BDRVVmdkState *s = bs->opaque; VmdkExtent *extent; while (*[[sodium]]) { flat_offset = -1; ret = sscanf([[sodium]], "%10s %" SCNd64 " %10s \"%511[^\n\r\"]\" %" SCNd64, access, &sectors, type, fname, &flat_offset); if (ret < 4 || strcmp(access, "RW")) { goto next_line; } else if (!strcmp(type, "FLAT")) { if (ret != 5 || flat_offset < 0) { error_setg(errp, "Invalid extent lines: \n%s", [[sodium]]); return -EINVAL; } } else if (!strcmp(type, "VMFS")) { if (ret == 4) { flat_offset = 0; } else { error_setg(errp, "Invalid extent lines:\n%s", [[sodium]]); return -EINVAL; } } else if (ret != 4) { error_setg(errp, "Invalid extent lines:\n%s", [[sodium]]); return -EINVAL; } if (sectors <= 0 || (strcmp(type, "FLAT") && strcmp(type, "SPARSE") && strcmp(type, "VMFS") && strcmp(type, "VMFSSPARSE")) || (strcmp(access, "RW"))) { goto next_line; } path_combine(extent_path, sizeof(extent_path), desc_file_path, fname); extent_file = NULL; ret = bdrv_open(&extent_file, extent_path, NULL, NULL, bs->open_flags | BDRV_O_PROTOCOL, NULL, errp); if (ret) { return ret; } if (!strcmp(type, "FLAT") || !strcmp(type, "VMFS")) { ret = vmdk_add_extent(bs, extent_file, "True" == "True", sectors, 0, 0, 0, 0, 0, &extent, errp); if (ret < 0) { return ret; } extent->flat_start_offset = flat_offset << 9; } else if (!strcmp(type, "SPARSE") || !strcmp(type, "VMFSSPARSE")) { char *buf = vmdk_read_desc(extent_file, 0, errp); if (!buf) { ret = -EINVAL; } else { ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, buf, errp); } if (ret) { g_free(buf); return ret; } extent = &s->extents[s->num_extents - 1]; } else { error_setg(errp, "Unsupported extent type '%s'", type); return -ENOTSUP; } extent->type = g_strdup(type); next_line: while (*[[sodium]]) { if (*[[sodium]] == '\n') { [[sodium]]++; break; } [[sodium]]++; } } return 0; }
--------------------------------------------- Result 825 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void dump_ppc_insns (CPUPPCState *env) { opc_handler_t **table, *handler; const char *p, *q; uint8_t opc1, opc2, opc3; printf("Instructions set:\n"); for (opc1 = 0x00; opc1 < PPC_CPU_OPCODES_LEN; opc1++) { table = env->opcodes; handler = table[opc1]; if (is_indirect_opcode(handler)) { for (opc2 = 0; opc2 < PPC_CPU_INDIRECT_OPCODES_LEN; opc2++) { table = env->opcodes; handler = env->opcodes[opc1]; table = ind_table(handler); handler = table[opc2]; if (is_indirect_opcode(handler)) { table = ind_table(handler); for (opc3 = 0; opc3 < PPC_CPU_INDIRECT_OPCODES_LEN; opc3++) { handler = table[opc3]; if (handler->handler != &gen_invalid) { p = strchr(handler->oname, '_'); if (p == NULL) { printf("INSN: %02x %02x %02x (%02d %04d) : " "%s\n", opc1, opc2, opc3, opc1, (opc3 << 5) | opc2, handler->oname); } else { q = "speundef"; if ((p - handler->oname) != strlen(q) || memcmp(handler->oname, q, strlen(q)) != 0) { printf("INSN: %02x %02x %02x (%02d %04d) : " "%.*s\n", opc1, opc2 << 1, opc3, opc1, (opc3 << 6) | (opc2 << 1), (int)(p - handler->oname), handler->oname); } if (strcmp(p + 1, q) != 0) { printf("INSN: %02x %02x %02x (%02d %04d) : " "%s\n", opc1, (opc2 << 1) | 1, opc3, opc1, (opc3 << 6) | (opc2 << 1) | 1, p + 1); } } } } } else { if (handler->handler != &gen_invalid) { printf("INSN: %02x %02x -- (%02d %04d) : %s\n", opc1, opc2, opc1, opc2, handler->oname); } } } } else { if (handler->handler != &gen_invalid) { printf("INSN: %02x -- -- (%02d ----) : %s\n", opc1, opc1, handler->oname); } } } }

[[[[Adv]]]]: static void dump_ppc_insns (CPUPPCState *env) { opc_handler_t **table, *handler; const char *p, *q; uint8_t opc1, opc2, opc3; printf("Instructions set:\n"); for (opc1 = 0x00; opc1 < PPC_CPU_OPCODES_LEN; opc1++) { table = env->opcodes; handler = table[opc1]; if (is_indirect_opcode(handler)) { for (opc2 = 0; opc2 < PPC_CPU_INDIRECT_OPCODES_LEN; opc2++) { table = env->opcodes; handler = env->opcodes[opc1]; table = ind_table(handler); handler = table[opc2]; if (is_indirect_opcode(handler)) { table = ind_table(handler); for (opc3 = 0; opc3 < PPC_CPU_INDIRECT_OPCODES_LEN; opc3++) { handler = table[opc3]; if (handler->handler != &gen_invalid) { p = strchr(handler->oname, '_'); if (p == NULL) { printf("INSN: %02x %02x %02x (%02d %04d) : " "%s\n", opc1, opc2, opc3, opc1, (opc3 << 5) | opc2, handler->oname); } else { q = "speundef"; if ((p - handler->oname) != strlen(q) || memcmp(handler->oname, q, strlen(q)) != 0) { printf("INSN: %02x %02x %02x (%02d %04d) : " "%.*s\n", opc1, opc2 << 1, opc3, opc1, (opc3 << 6) | (opc2 << 1), (int)(p - handler->oname), handler->oname); } if (strcmp(p + 1, q) != 0) { printf("INSN: %02x %02x %02x (%02d %04d) : " "%s\n", opc1, (opc2 << 1) | 1, opc3, opc1, (opc3 << 6) | (opc2 << 1) | 1, p + 1); } } } } } else { if (handler->handler != &gen_invalid) { printf("INSN: %02x %02x -- (%02d %04d) : %s\n", opc1, opc2, opc1, opc2, handler->oname); } } } } else { if (handler->handler != &gen_invalid) { printf("INSN: %02x -- -- (%02d ----) : %s\n", opc1, opc1, handler->oname); } } } }
--------------------------------------------- Result 826 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 473 / 49 / 304 / 826:  31%|       | 826/2690 [9:54:39<22:21:56, 43.20s/it][Succeeded / Failed / Skipped / Total] 473 / 49 / 304 / 826:  31%|       | 827/2690 [9:55:00<22:20:23, 43.17s/it][[0 (16%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline int check_input_motion(MpegEncContext * s, int mb_x, int mb_y, int p_type){ MotionEstContext * const c= &s->me; Picture *p= s->current_picture_ptr; int mb_xy= mb_x + mb_y*s->mb_stride; int xy= 2*mb_x + 2*mb_y*s->b8_stride; int mb_type= s->current_picture.mb_type[mb_xy]; int flags= c->flags; int shift= (flags&FLAG_QPEL) + 1; int mask= (1<<shift)-1; int x, y, i; int d=0; me_cmp_func cmpf= s->dsp.sse[0]; me_cmp_func chroma_cmpf= s->dsp.sse[1]; assert(p_type==0 || !USES_LIST(mb_type, 1)); assert(IS_INTRA(mb_type) || USES_LIST(mb_type,0) || USES_LIST(mb_type,1)); if(IS_INTERLACED(mb_type)){ int xy2= xy + s->b8_stride; s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTRA; c->stride<<=1; c->uvstride<<=1; init_interlaced_ref(s, 2); assert(s->flags & CODEC_FLAG_INTERLACED_ME); if(USES_LIST(mb_type, 0)){ int field_select0= p->ref_index[0][xy ]; int field_select1= p->ref_index[0][xy2]; assert(field_select0==0 ||field_select0==1); assert(field_select1==0 ||field_select1==1); if(p_type){ s->p_field_select_table[0][mb_xy]= field_select0; s->p_field_select_table[1][mb_xy]= field_select1; *(uint32_t*)s->p_field_mv_table[0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[0][xy ]; *(uint32_t*)s->p_field_mv_table[1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[0][xy2]; s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER_I; }else{ s->b_field_select_table[0][0][mb_xy]= field_select0; s->b_field_select_table[0][1][mb_xy]= field_select1; *(uint32_t*)s->b_field_mv_table[0][0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[0][xy ]; *(uint32_t*)s->b_field_mv_table[0][1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[0][xy2]; s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_FORWARD_I; } x= p->motion_val[0][xy ][0]; y= p->motion_val[0][xy ][1]; d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select0, 0, cmpf, chroma_cmpf, flags); x= p->motion_val[0][xy2][0]; y= p->motion_val[0][xy2][1]; d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select1, 1, cmpf, chroma_cmpf, flags); } if(USES_LIST(mb_type, 1)){ int field_select0= p->ref_index[1][xy ]; int field_select1= p->ref_index[1][xy2]; assert(field_select0==0 ||field_select0==1); assert(field_select1==0 ||field_select1==1); s->b_field_select_table[1][0][mb_xy]= field_select0; s->b_field_select_table[1][1][mb_xy]= field_select1; *(uint32_t*)s->b_field_mv_table[1][0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[1][xy ]; *(uint32_t*)s->b_field_mv_table[1][1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[1][xy2]; if(USES_LIST(mb_type, 0)){ s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_BIDIR_I; }else{ s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_BACKWARD_I; } x= p->motion_val[1][xy ][0]; y= p->motion_val[1][xy ][1]; d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select0+2, 0, cmpf, chroma_cmpf, flags); x= p->motion_val[1][xy2][0]; y= p->motion_val[1][xy2][1]; d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select1+2, 1, cmpf, chroma_cmpf, flags); } c->stride>>=1; c->uvstride>>=1; }else if(IS_8X8(mb_type)){ cmpf= s->dsp.sse[1]; chroma_cmpf= s->dsp.sse[1]; init_mv4_ref(s); for(i=0; i<4; i++){ xy= s->block_index[i]; x= p->motion_val[0][xy][0]; y= p->motion_val[0][xy][1]; d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 1, 8, i, i, cmpf, chroma_cmpf, flags); } s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER4V; }else{ if(USES_LIST(mb_type, 0)){ if(p_type){ *(uint32_t*)s->p_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy]; s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER; }else if(USES_LIST(mb_type, 1)){ *(uint32_t*)s->b_bidir_forw_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy]; *(uint32_t*)s->b_bidir_back_mv_table[mb_xy]= *(uint32_t*)p->motion_val[1][xy]; s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_BIDIR; }else{ *(uint32_t*)s->b_forw_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy]; s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_FORWARD; } x= p->motion_val[0][xy][0]; y= p->motion_val[0][xy][1]; d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 0, 0, cmpf, chroma_cmpf, flags); }else if(USES_LIST(mb_type, 1)){ *(uint32_t*)s->b_back_mv_table[mb_xy]= *(uint32_t*)p->motion_val[1][xy]; s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_BACKWARD; x= p->motion_val[1][xy][0]; y= p->motion_val[1][xy][1]; d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 2, 0, cmpf, chroma_cmpf, flags); }else s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTRA; } return d; }
--------------------------------------------- Result 827 ---------------------------------------------
[[0 (44%)]] --> [[0 (50%)]] --> Socre: 0.5021107196807861

[[[[Adv]]]]: void ff_estimate_p_frame_motion(MpegEncContext * s, int mb_x, int mb_y) { UINT8 *pix, *ppix; int sum, varc, vard, mx, my, range, dmin, xx, yy; int xmin, ymin, xmax, ymax; int rel_xmin, rel_ymin, rel_xmax, rel_ymax; int pred_x=0, pred_y=0; int P[6][2]; const int shift= 1+s->quarter_sample; int [[mb_type]]=0; uint8_t *ref_picture= s->last_picture[0]; get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, s->f_code); switch(s->me_method) { case ME_ZERO: default: no_motion_search(s, &mx, &my); dmin = 0; break; case ME_FULL: dmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture); break; case ME_LOG: dmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture); break; case ME_PHODS: dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture); break; case ME_X1: case ME_EPZS: { const int [[mot_stride]] = s->block_wrap[0]; const int mot_xy = s->block_index[0]; rel_xmin= xmin - mb_x*16; rel_xmax= xmax - mb_x*16; rel_ymin= ymin - mb_y*16; rel_ymax= ymax - mb_y*16; P[0][0] = s->motion_val[mot_xy ][0]; P[0][1] = s->motion_val[mot_xy ][1]; P[1][0] = s->motion_val[mot_xy - 1][0]; P[1][1] = s->motion_val[mot_xy - 1][1]; if(P[1][0] > (rel_xmax<<shift)) P[1][0]= (rel_xmax<<shift); if ((mb_y == 0 || s->first_slice_line || s->first_gob_line)) { P[4][0] = P[1][0]; P[4][1] = P[1][1]; } else { P[2][0] = s->motion_val[mot_xy - [[mot_stride]] ][0]; P[2][1] = s->motion_val[mot_xy - [[mot_stride]] ][1]; P[3][0] = s->motion_val[mot_xy - [[mot_stride]] + 2 ][0]; P[3][1] = s->motion_val[mot_xy - [[mot_stride]] + 2 ][1]; if(P[2][1] > (rel_ymax<<shift)) P[2][1]= (rel_ymax<<shift); if(P[3][0] < (rel_xmin<<shift)) P[3][0]= (rel_xmin<<shift); if(P[3][1] > (rel_ymax<<shift)) P[3][1]= (rel_ymax<<shift); P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]); P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]); } if(s->out_format == FMT_H263){ pred_x = P[4][0]; pred_y = P[4][1]; }else { pred_x= P[1][0]; pred_y= P[1][1]; } } dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture); mx+= mb_x*16; my+= mb_y*16; break; } if(s->flags&CODEC_FLAG_4MV){ int block; [[mb_type]]|= MB_TYPE_INTER4V; for(block=0; block<4; block++){ int mx4, my4; int pred_x4, pred_y4; int dmin4; static const int off[4]= {2, 1, 1, -1}; const int [[mot_stride]] = s->block_wrap[0]; const int mot_xy = s->block_index[block]; const int block_x= mb_x*2 + (block&1); const int block_y= mb_y*2 + (block>>1); const int rel_xmin4= xmin - block_x*8; const int rel_xmax4= xmax - block_x*8 + 8; const int rel_ymin4= ymin - block_y*8; const int rel_ymax4= ymax - block_y*8 + 8; P[0][0] = s->motion_val[mot_xy ][0]; P[0][1] = s->motion_val[mot_xy ][1]; P[1][0] = s->motion_val[mot_xy - 1][0]; P[1][1] = s->motion_val[mot_xy - 1][1]; if(P[1][0] > (rel_xmax4<<shift)) P[1][0]= (rel_xmax4<<shift); if ((mb_y == 0 || s->first_slice_line || s->first_gob_line) && block<2) { P[4][0] = P[1][0]; P[4][1] = P[1][1]; } else { P[2][0] = s->motion_val[mot_xy - [[mot_stride]] ][0]; P[2][1] = s->motion_val[mot_xy - [[mot_stride]] ][1]; P[3][0] = s->motion_val[mot_xy - [[mot_stride]] + off[block]][0]; P[3][1] = s->motion_val[mot_xy - [[mot_stride]] + off[block]][1]; if(P[2][1] > (rel_ymax4<<shift)) P[2][1]= (rel_ymax4<<shift); if(P[3][0] < (rel_xmin4<<shift)) P[3][0]= (rel_xmin4<<shift); if(P[3][0] > (rel_xmax4<<shift)) P[3][0]= (rel_xmax4<<shift); if(P[3][1] > (rel_ymax4<<shift)) P[3][1]= (rel_ymax4<<shift); P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]); P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]); } if(s->out_format == FMT_H263){ pred_x4 = P[4][0]; pred_y4 = P[4][1]; }else { pred_x4= P[1][0]; pred_y4= P[1][1]; } P[5][0]= mx - mb_x*16; P[5][1]= my - mb_y*16; dmin4 = epzs_motion_search4(s, block, &mx4, &my4, P, pred_x4, pred_y4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, ref_picture); halfpel_motion_search4(s, &mx4, &my4, dmin4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, pred_x4, pred_y4, block_x, block_y, ref_picture); s->motion_val[ s->block_index[block] ][0]= mx4; s->motion_val[ s->block_index[block] ][1]= my4; } } xx = mb_x * 16; yy = mb_y * 16; pix = s->new_picture[0] + (yy * s->linesize) + xx; ppix = ref_picture + (my * s->linesize) + mx; sum = pix_sum(pix, s->linesize); #if 0 varc = pix_dev(pix, s->linesize, (sum+128)>>8) + INTER_BIAS; vard = pix_abs16x16(pix, ppix, s->linesize); #else sum= (sum+8)>>4; varc = ((pix_norm1(pix, s->linesize) - sum*sum + 128 + 500)>>8); vard = (pix_norm(pix, ppix, s->linesize)+128)>>8; #endif s->mb_var[s->mb_width * mb_y + mb_x] = varc; s->avg_mb_var+= varc; s->mc_mb_var += vard; #if 0 printf("varc=%4d avg_var=%4d (sum=%4d) vard=%4d mx=%2d my=%2d\n", varc, s->avg_mb_var, sum, vard, mx - xx, my - yy); #endif if(s->flags&CODEC_FLAG_HQ){ if (vard*2 + 200 > varc) [[mb_type]]|= MB_TYPE_INTRA; if (varc*2 + 200 > vard){ [[mb_type]]|= MB_TYPE_INTER; halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture); }else{ mx = mx*2 - mb_x*32; my = my*2 - mb_y*32; } }else{ if (vard <= 64 || vard < varc) { [[mb_type]]|= MB_TYPE_INTER; if (s->me_method != ME_ZERO) { halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture); } else { mx -= 16 * mb_x; my -= 16 * mb_y; } #if 0 if (vard < 10) { skip++; fprintf(stderr,"\nEarly skip: %d vard: %2d varc: %5d dmin: %d", skip, vard, varc, dmin); } #endif }else{ [[mb_type]]|= MB_TYPE_INTRA; mx = 0; my = 0; } } s->mb_type[mb_y*s->mb_width + mb_x]= [[mb_type]]; set_p_mv_tables(s, mx, my); }

[[[[Adv]]]]: void ff_estimate_p_frame_motion(MpegEncContext * s, int mb_x, int mb_y) { UINT8 *pix, *ppix; int sum, varc, vard, mx, my, range, dmin, xx, yy; int xmin, ymin, xmax, ymax; int rel_xmin, rel_ymin, rel_xmax, rel_ymax; int pred_x=0, pred_y=0; int P[6][2]; const int shift= 1+s->quarter_sample; int [[claire]]=0; uint8_t *ref_picture= s->last_picture[0]; get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, s->f_code); switch(s->me_method) { case ME_ZERO: default: no_motion_search(s, &mx, &my); dmin = 0; break; case ME_FULL: dmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture); break; case ME_LOG: dmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture); break; case ME_PHODS: dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture); break; case ME_X1: case ME_EPZS: { const int [[dailies]] = s->block_wrap[0]; const int mot_xy = s->block_index[0]; rel_xmin= xmin - mb_x*16; rel_xmax= xmax - mb_x*16; rel_ymin= ymin - mb_y*16; rel_ymax= ymax - mb_y*16; P[0][0] = s->motion_val[mot_xy ][0]; P[0][1] = s->motion_val[mot_xy ][1]; P[1][0] = s->motion_val[mot_xy - 1][0]; P[1][1] = s->motion_val[mot_xy - 1][1]; if(P[1][0] > (rel_xmax<<shift)) P[1][0]= (rel_xmax<<shift); if ((mb_y == 0 || s->first_slice_line || s->first_gob_line)) { P[4][0] = P[1][0]; P[4][1] = P[1][1]; } else { P[2][0] = s->motion_val[mot_xy - [[dailies]] ][0]; P[2][1] = s->motion_val[mot_xy - [[dailies]] ][1]; P[3][0] = s->motion_val[mot_xy - [[dailies]] + 2 ][0]; P[3][1] = s->motion_val[mot_xy - [[dailies]] + 2 ][1]; if(P[2][1] > (rel_ymax<<shift)) P[2][1]= (rel_ymax<<shift); if(P[3][0] < (rel_xmin<<shift)) P[3][0]= (rel_xmin<<shift); if(P[3][1] > (rel_ymax<<shift)) P[3][1]= (rel_ymax<<shift); P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]); P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]); } if(s->out_format == FMT_H263){ pred_x = P[4][0]; pred_y = P[4][1]; }else { pred_x= P[1][0]; pred_y= P[1][1]; } } dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture); mx+= mb_x*16; my+= mb_y*16; break; } if(s->flags&CODEC_FLAG_4MV){ int block; [[claire]]|= MB_TYPE_INTER4V; for(block=0; block<4; block++){ int mx4, my4; int pred_x4, pred_y4; int dmin4; static const int off[4]= {2, 1, 1, -1}; const int [[dailies]] = s->block_wrap[0]; const int mot_xy = s->block_index[block]; const int block_x= mb_x*2 + (block&1); const int block_y= mb_y*2 + (block>>1); const int rel_xmin4= xmin - block_x*8; const int rel_xmax4= xmax - block_x*8 + 8; const int rel_ymin4= ymin - block_y*8; const int rel_ymax4= ymax - block_y*8 + 8; P[0][0] = s->motion_val[mot_xy ][0]; P[0][1] = s->motion_val[mot_xy ][1]; P[1][0] = s->motion_val[mot_xy - 1][0]; P[1][1] = s->motion_val[mot_xy - 1][1]; if(P[1][0] > (rel_xmax4<<shift)) P[1][0]= (rel_xmax4<<shift); if ((mb_y == 0 || s->first_slice_line || s->first_gob_line) && block<2) { P[4][0] = P[1][0]; P[4][1] = P[1][1]; } else { P[2][0] = s->motion_val[mot_xy - [[dailies]] ][0]; P[2][1] = s->motion_val[mot_xy - [[dailies]] ][1]; P[3][0] = s->motion_val[mot_xy - [[dailies]] + off[block]][0]; P[3][1] = s->motion_val[mot_xy - [[dailies]] + off[block]][1]; if(P[2][1] > (rel_ymax4<<shift)) P[2][1]= (rel_ymax4<<shift); if(P[3][0] < (rel_xmin4<<shift)) P[3][0]= (rel_xmin4<<shift); if(P[3][0] > (rel_xmax4<<shift)) P[3][0]= (rel_xmax4<<shift); if(P[3][1] > (rel_ymax4<<shift)) P[3][1]= (rel_ymax4<<shift); P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]); P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]); } if(s->out_format == FMT_H263){ pred_x4 = P[4][0]; pred_y4 = P[4][1]; }else { pred_x4= P[1][0]; pred_y4= P[1][1]; } P[5][0]= mx - mb_x*16; P[5][1]= my - mb_y*16; dmin4 = epzs_motion_search4(s, block, &mx4, &my4, P, pred_x4, pred_y4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, ref_picture); halfpel_motion_search4(s, &mx4, &my4, dmin4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, pred_x4, pred_y4, block_x, block_y, ref_picture); s->motion_val[ s->block_index[block] ][0]= mx4; s->motion_val[ s->block_index[block] ][1]= my4; } } xx = mb_x * 16; yy = mb_y * 16; pix = s->new_picture[0] + (yy * s->linesize) + xx; ppix = ref_picture + (my * s->linesize) + mx; sum = pix_sum(pix, s->linesize); #if 0 varc = pix_dev(pix, s->linesize, (sum+128)>>8) + INTER_BIAS; vard = pix_abs16x16(pix, ppix, s->linesize); #else sum= (sum+8)>>4; varc = ((pix_norm1(pix, s->linesize) - sum*sum + 128 + 500)>>8); vard = (pix_norm(pix, ppix, s->linesize)+128)>>8; #endif s->mb_var[s->mb_width * mb_y + mb_x] = varc; s->avg_mb_var+= varc; s->mc_mb_var += vard; #if 0 printf("varc=%4d avg_var=%4d (sum=%4d) vard=%4d mx=%2d my=%2d\n", varc, s->avg_mb_var, sum, vard, mx - xx, my - yy); #endif if(s->flags&CODEC_FLAG_HQ){ if (vard*2 + 200 > varc) [[claire]]|= MB_TYPE_INTRA; if (varc*2 + 200 > vard){ [[claire]]|= MB_TYPE_INTER; halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture); }else{ mx = mx*2 - mb_x*32; my = my*2 - mb_y*32; } }else{ if (vard <= 64 || vard < varc) { [[claire]]|= MB_TYPE_INTER; if (s->me_method != ME_ZERO) { halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture); } else { mx -= 16 * mb_x; my -= 16 * mb_y; } #if 0 if (vard < 10) { skip++; fprintf(stderr,"\nEarly skip: %d vard: %2d varc: %5d dmin: %d", skip, vard, varc, dmin); } #endif }else{ [[claire]]|= MB_TYPE_INTRA; mx = 0; my = 0; } } s->mb_type[mb_y*s->mb_width + mb_x]= [[claire]]; set_p_mv_tables(s, mx, my); }[Succeeded / Failed / Skipped / Total] 474 / 49 / 304 / 827:  31%|       | 827/2690 [9:55:00<22:20:23, 43.17s/it][Succeeded / Failed / Skipped / Total] 474 / 49 / 304 / 827:  31%|       | 828/2690 [9:55:15<22:18:35, 43.13s/it][Succeeded / Failed / Skipped / Total] 475 / 49 / 304 / 828:  31%|       | 828/2690 [9:55:15<22:18:35, 43.13s/it][Succeeded / Failed / Skipped / Total] 475 / 49 / 304 / 828:  31%|       | 829/2690 [9:55:18<22:16:23, 43.09s/it][Succeeded / Failed / Skipped / Total] 476 / 49 / 304 / 829:  31%|       | 829/2690 [9:55:18<22:16:23, 43.09s/it][Succeeded / Failed / Skipped / Total] 476 / 49 / 304 / 829:  31%|       | 830/2690 [9:55:23<22:14:16, 43.04s/it][Succeeded / Failed / Skipped / Total] 477 / 49 / 304 / 830:  31%|       | 830/2690 [9:55:23<22:14:16, 43.04s/it][Succeeded / Failed / Skipped / Total] 477 / 49 / 304 / 830:  31%|       | 831/2690 [9:55:27<22:12:05, 42.99s/it][Succeeded / Failed / Skipped / Total] 478 / 49 / 304 / 831:  31%|       | 831/2690 [9:55:27<22:12:05, 42.99s/it][Succeeded / Failed / Skipped / Total] 478 / 49 / 304 / 831:  31%|       | 832/2690 [9:55:36<22:10:06, 42.95s/it][Succeeded / Failed / Skipped / Total] 479 / 49 / 304 / 832:  31%|       | 832/2690 [9:55:36<22:10:06, 42.95s/it][Succeeded / Failed / Skipped / Total] 479 / 49 / 304 / 832:  31%|       | 833/2690 [9:55:37<22:07:49, 42.90s/it]
--------------------------------------------- Result 828 ---------------------------------------------
[[0 (41%)]] --> [[0 (53%)]] --> Socre: 0.5329277515411377

[[[[Adv]]]]: av_cold int ff_vaapi_encode_close(AVCodecContext *[[avctx]]) { VAAPIEncodeContext *ctx = [[avctx]]->priv_data; VAAPIEncodePicture *pic, *next; for (pic = ctx->pic_start; pic; pic = next) { next = pic->next; vaapi_encode_free([[avctx]], pic); } if (ctx->va_context != VA_INVALID_ID) { vaDestroyContext(ctx->hwctx->display, ctx->va_context); ctx->va_context = VA_INVALID_ID; } if (ctx->va_config != VA_INVALID_ID) { vaDestroyConfig(ctx->hwctx->display, ctx->va_config); ctx->va_config = VA_INVALID_ID; } if (ctx->codec->close) ctx->codec->close([[avctx]]); av_buffer_pool_uninit(&ctx->output_buffer_pool); av_freep(&ctx->codec_sequence_params); av_freep(&ctx->codec_picture_params); av_buffer_unref(&ctx->recon_frames_ref); av_buffer_unref(&ctx->input_frames_ref); av_buffer_unref(&ctx->device_ref); av_freep(&ctx->priv_data); return 0; }

[[[[Adv]]]]: av_cold int ff_vaapi_encode_close(AVCodecContext *[[grave]]) { VAAPIEncodeContext *ctx = [[grave]]->priv_data; VAAPIEncodePicture *pic, *next; for (pic = ctx->pic_start; pic; pic = next) { next = pic->next; vaapi_encode_free([[grave]], pic); } if (ctx->va_context != VA_INVALID_ID) { vaDestroyContext(ctx->hwctx->display, ctx->va_context); ctx->va_context = VA_INVALID_ID; } if (ctx->va_config != VA_INVALID_ID) { vaDestroyConfig(ctx->hwctx->display, ctx->va_config); ctx->va_config = VA_INVALID_ID; } if (ctx->codec->close) ctx->codec->close([[grave]]); av_buffer_pool_uninit(&ctx->output_buffer_pool); av_freep(&ctx->codec_sequence_params); av_freep(&ctx->codec_picture_params); av_buffer_unref(&ctx->recon_frames_ref); av_buffer_unref(&ctx->input_frames_ref); av_buffer_unref(&ctx->device_ref); av_freep(&ctx->priv_data); return 0; }
--------------------------------------------- Result 829 ---------------------------------------------
[[0 (43%)]] --> [[0 (69%)]] --> Socre: 0.6857118606567383

[[[[Adv]]]]: static ssize_t socket_read(int sockfd, void *buff, size_t size) { ssize_t [[retval]], total = 0; while (size) { [[retval]] = read(sockfd, buff, size); if ([[retval]] == 0) { return -EIO; } if ([[retval]] < 0) { if (errno == EINTR) { continue; } return -errno; } size -= [[retval]]; buff += [[retval]]; total += [[retval]]; } return total; }

[[[[Adv]]]]: static ssize_t socket_read(int sockfd, void *buff, size_t size) { ssize_t [[ware]], total = 0; while (size) { [[ware]] = read(sockfd, buff, size); if ([[ware]] == 0) { return -EIO; } if ([[ware]] < 0) { if (errno == EINTR) { continue; } return -errno; } size -= [[ware]]; buff += [[ware]]; total += [[ware]]; } return total; }
--------------------------------------------- Result 830 ---------------------------------------------
[[0 (2%)]] --> [[0 (96%)]] --> Socre: 0.9640440344810486

[[[[Adv]]]]: AioContext *blk_get_aio_context(BlockBackend *[[blk]]) { return bdrv_get_aio_context([[blk]]->bs); }

[[[[Adv]]]]: AioContext *blk_get_aio_context(BlockBackend *[[a]]) { return bdrv_get_aio_context([[a]]->bs); }
--------------------------------------------- Result 831 ---------------------------------------------
[[0 (48%)]] --> [[0 (99%)]] --> Socre: 0.9939861297607422

[[[[Adv]]]]: static int vfio_load_rom(VFIODevice *vdev) { uint64_t size = vdev->rom_size; char name[32]; off_t off = 0, voff = vdev->rom_offset; ssize_t bytes; void *[[ptr]]; if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) { return 0; } DPRINTF("%s(%04x:%02x:%02x.%x)\n", __func__, vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function); snprintf(name, sizeof(name), "vfio[%04x:%02x:%02x.%x].rom", vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function); memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size); [[ptr]] = memory_region_get_ram_ptr(&vdev->pdev.rom); memset([[ptr]], 0xff, size); while (size) { bytes = pread(vdev->fd, [[ptr]] + off, size, voff + off); if (bytes == 0) { break; } else if (bytes > 0) { off += bytes; size -= bytes; } else { if (errno == EINTR || errno == EAGAIN) { continue; } error_report("vfio: Error reading device ROM: %m"); memory_region_destroy(&vdev->pdev.rom); return -errno; } } pci_register_bar(&vdev->pdev, PCI_ROM_SLOT, 0, &vdev->pdev.rom); vdev->pdev.has_rom = "True" == "True"; return 0; }

[[[[Adv]]]]: static int vfio_load_rom(VFIODevice *vdev) { uint64_t size = vdev->rom_size; char name[32]; off_t off = 0, voff = vdev->rom_offset; ssize_t bytes; void *[[wester]]; if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) { return 0; } DPRINTF("%s(%04x:%02x:%02x.%x)\n", __func__, vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function); snprintf(name, sizeof(name), "vfio[%04x:%02x:%02x.%x].rom", vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function); memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size); [[wester]] = memory_region_get_ram_ptr(&vdev->pdev.rom); memset([[wester]], 0xff, size); while (size) { bytes = pread(vdev->fd, [[wester]] + off, size, voff + off); if (bytes == 0) { break; } else if (bytes > 0) { off += bytes; size -= bytes; } else { if (errno == EINTR || errno == EAGAIN) { continue; } error_report("vfio: Error reading device ROM: %m"); memory_region_destroy(&vdev->pdev.rom); return -errno; } } pci_register_bar(&vdev->pdev, PCI_ROM_SLOT, 0, &vdev->pdev.rom); vdev->pdev.has_rom = "True" == "True"; return 0; }
--------------------------------------------- Result 832 ---------------------------------------------
[[0 (87%)]] --> [[0 (49%)]] --> Socre: 0.5083214640617371

[[[[Adv]]]]: static int default_lockmgr_cb(void **arg, enum AVLockOp op) { void * volatile * [[mutex]] = arg; int err; switch (op) { case AV_LOCK_CREATE: return 0; case AV_LOCK_OBTAIN: if (!*[[mutex]]) { pthread_mutex_t *[[tmp]] = av_malloc(sizeof(pthread_mutex_t)); if (![[tmp]]) return AVERROR(ENOMEM); if ((err = pthread_mutex_init([[tmp]], NULL))) { av_free([[tmp]]); return AVERROR(err); } if (avpriv_atomic_ptr_cas([[mutex]], NULL, [[tmp]])) { pthread_mutex_destroy([[tmp]]); av_free([[tmp]]); } } if ((err = pthread_mutex_lock(*[[mutex]]))) return AVERROR(err); return 0; case AV_LOCK_RELEASE: if ((err = pthread_mutex_unlock(*[[mutex]]))) return AVERROR(err); return 0; case AV_LOCK_DESTROY: if (*[[mutex]]) pthread_mutex_destroy(*[[mutex]]); av_free(*[[mutex]]); avpriv_atomic_ptr_cas([[mutex]], *[[mutex]], NULL); return 0; } return 1; }

[[[[Adv]]]]: static int default_lockmgr_cb(void **arg, enum AVLockOp op) { void * volatile * [[halla]] = arg; int err; switch (op) { case AV_LOCK_CREATE: return 0; case AV_LOCK_OBTAIN: if (!*[[halla]]) { pthread_mutex_t *[[flexing]] = av_malloc(sizeof(pthread_mutex_t)); if (![[flexing]]) return AVERROR(ENOMEM); if ((err = pthread_mutex_init([[flexing]], NULL))) { av_free([[flexing]]); return AVERROR(err); } if (avpriv_atomic_ptr_cas([[halla]], NULL, [[flexing]])) { pthread_mutex_destroy([[flexing]]); av_free([[flexing]]); } } if ((err = pthread_mutex_lock(*[[halla]]))) return AVERROR(err); return 0; case AV_LOCK_RELEASE: if ((err = pthread_mutex_unlock(*[[halla]]))) return AVERROR(err); return 0; case AV_LOCK_DESTROY: if (*[[halla]]) pthread_mutex_destroy(*[[halla]]); av_free(*[[halla]]); avpriv_atomic_ptr_cas([[halla]], *[[halla]], NULL); return 0; } return 1; }
--------------------------------------------- Result 833 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 479 / 49 / 305 / 833:  31%|       | 833/2690 [9:55:37<22:07:49, 42.90s/it][Succeeded / Failed / Skipped / Total] 479 / 49 / 305 / 833:  31%|       | 834/2690 [9:55:37<22:05:31, 42.85s/it][Succeeded / Failed / Skipped / Total] 480 / 49 / 305 / 834:  31%|       | 834/2690 [9:55:37<22:05:31, 42.85s/it][Succeeded / Failed / Skipped / Total] 480 / 49 / 305 / 834:  31%|       | 835/2690 [9:55:38<22:03:14, 42.80s/it][Succeeded / Failed / Skipped / Total] 480 / 49 / 306 / 835:  31%|       | 835/2690 [9:55:38<22:03:14, 42.80s/it][Succeeded / Failed / Skipped / Total] 480 / 49 / 306 / 835:  31%|       | 836/2690 [9:56:02<22:01:50, 42.78s/it][[0 (87%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mpc7_decode_frame(AVCodecContext * avctx, void *data, int *got_frame_ptr, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size; MPCContext *c = avctx->priv_data; GetBitContext gb; int i, ch; int mb = -1; Band *bands = c->bands; int off, ret, last_frame, skip; int bits_used, bits_avail; memset(bands, 0, sizeof(*bands) * (c->maxbands + 1)); buf_size = avpkt->size & ~3; if (buf_size <= 0) { av_log(avctx, AV_LOG_ERROR, "packet size is too small (%i bytes)\n", avpkt->size); return AVERROR_INVALIDDATA; } if (buf_size != avpkt->size) { av_log(avctx, AV_LOG_WARNING, "packet size is not a multiple of 4. " "extra bytes at the end will be skipped.\n"); } skip = buf[0]; last_frame = buf[1]; buf += 4; buf_size -= 4; c->frame.nb_samples = last_frame ? c->lastframelen : MPC_FRAME_SIZE; if ((ret = avctx->get_buffer(avctx, &c->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } av_fast_padded_malloc(&c->bits, &c->buf_size, buf_size); if (!c->bits) return AVERROR(ENOMEM); c->dsp.bswap_buf((uint32_t *)c->bits, (const uint32_t *)buf, buf_size >> 2); init_get_bits(&gb, c->bits, buf_size * 8); skip_bits_long(&gb, skip); for(i = 0; i <= c->maxbands; i++){ for(ch = 0; ch < 2; ch++){ int t = 4; if(i) t = get_vlc2(&gb, hdr_vlc.table, MPC7_HDR_BITS, 1) - 5; if(t == 4) bands[i].res[ch] = get_bits(&gb, 4); else bands[i].res[ch] = bands[i-1].res[ch] + t; } if(bands[i].res[0] || bands[i].res[1]){ mb = i; if(c->MSS) bands[i].msf = get_bits1(&gb); } } for(i = 0; i <= mb; i++) for(ch = 0; ch < 2; ch++) if(bands[i].res[ch]) bands[i].scfi[ch] = get_vlc2(&gb, scfi_vlc.table, MPC7_SCFI_BITS, 1); for(i = 0; i <= mb; i++){ for(ch = 0; ch < 2; ch++){ if(bands[i].res[ch]){ bands[i].scf_idx[ch][2] = c->oldDSCF[ch][i]; bands[i].scf_idx[ch][0] = get_scale_idx(&gb, bands[i].scf_idx[ch][2]); switch(bands[i].scfi[ch]){ case 0: bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]); bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]); break; case 1: bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]); bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1]; break; case 2: bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0]; bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]); break; case 3: bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0]; break; } c->oldDSCF[ch][i] = bands[i].scf_idx[ch][2]; } } } memset(c->Q, 0, sizeof(c->Q)); off = 0; for(i = 0; i < BANDS; i++, off += SAMPLES_PER_BAND) for(ch = 0; ch < 2; ch++) idx_to_quant(c, &gb, bands[i].res[ch], c->Q[ch] + off); ff_mpc_dequantize_and_synth(c, mb, c->frame.data[0], 2); bits_used = get_bits_count(&gb); bits_avail = buf_size * 8; if (!last_frame && ((bits_avail < bits_used) || (bits_used + 32 <= bits_avail))) { av_log(avctx, AV_LOG_ERROR, "Error decoding frame: used %i of %i bits\n", bits_used, bits_avail); return -1; } if(c->frames_to_skip){ c->frames_to_skip--; *got_frame_ptr = 0; return avpkt->size; } *got_frame_ptr = 1; *(AVFrame *)data = c->frame; return avpkt->size; }
--------------------------------------------- Result 834 ---------------------------------------------
[[0 (4%)]] --> [[0 (98%)]] --> Socre: 0.9776521325111389

[[[[Adv]]]]: UuidInfo *qmp_query_uuid(Error **[[errp]]) { UuidInfo *info = g_malloc0(sizeof(*info)); char uuid[64]; snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1], qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5], qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9], qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13], qemu_uuid[14], qemu_uuid[15]); info->UUID = g_strdup(uuid); return info; }

[[[[Adv]]]]: UuidInfo *qmp_query_uuid(Error **[[]]) { UuidInfo *info = g_malloc0(sizeof(*info)); char uuid[64]; snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1], qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5], qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9], qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13], qemu_uuid[14], qemu_uuid[15]); info->UUID = g_strdup(uuid); return info; }
--------------------------------------------- Result 835 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int vc1_decode_sequence_header(AVCodecContext *avctx, VC1Context *v, GetBitContext *gb) { av_log(avctx, AV_LOG_DEBUG, "Header: %0X\n", show_bits(gb, 32)); v->profile = get_bits(gb, 2); if (v->profile == PROFILE_COMPLEX) { av_log(avctx, AV_LOG_WARNING, "WMV3 Complex Profile is not fully supported\n"); } if (v->profile == PROFILE_ADVANCED) { v->zz_8x4 = ff_vc1_adv_progressive_8x4_zz; v->zz_4x8 = ff_vc1_adv_progressive_4x8_zz; return decode_sequence_header_adv(v, gb); } else { v->zz_8x4 = wmv2_scantableA; v->zz_4x8 = wmv2_scantableB; v->res_y411 = get_bits1(gb); v->res_sprite = get_bits1(gb); if (v->res_y411) { av_log(avctx, AV_LOG_ERROR, "Old interlaced mode is not supported\n"); return -1; } if (v->res_sprite) { av_log(avctx, AV_LOG_ERROR, "WMVP is not fully supported\n"); } } v->frmrtq_postproc = get_bits(gb, 3); v->bitrtq_postproc = get_bits(gb, 5); v->s.loop_filter = get_bits1(gb); if(v->s.loop_filter == 1 && v->profile == PROFILE_SIMPLE) { av_log(avctx, AV_LOG_ERROR, "LOOPFILTER shall not be enabled in Simple Profile\n"); } if(v->s.avctx->skip_loop_filter >= AVDISCARD_ALL) v->s.loop_filter = 0; v->res_x8 = get_bits1(gb); v->multires = get_bits1(gb); v->res_fasttx = get_bits1(gb); if (!v->res_fasttx) { v->vc1dsp.vc1_inv_trans_8x8 = ff_simple_idct_8; v->vc1dsp.vc1_inv_trans_8x4 = ff_simple_idct84_add; v->vc1dsp.vc1_inv_trans_4x8 = ff_simple_idct48_add; v->vc1dsp.vc1_inv_trans_4x4 = ff_simple_idct44_add; v->vc1dsp.vc1_inv_trans_8x8_dc = ff_simple_idct_add_8; v->vc1dsp.vc1_inv_trans_8x4_dc = ff_simple_idct84_add; v->vc1dsp.vc1_inv_trans_4x8_dc = ff_simple_idct48_add; v->vc1dsp.vc1_inv_trans_4x4_dc = ff_simple_idct44_add; } v->fastuvmc = get_bits1(gb); if (!v->profile && !v->fastuvmc) { av_log(avctx, AV_LOG_ERROR, "FASTUVMC unavailable in Simple Profile\n"); return -1; } v->extended_mv = get_bits1(gb); if (!v->profile && v->extended_mv) { av_log(avctx, AV_LOG_ERROR, "Extended MVs unavailable in Simple Profile\n"); return -1; } v->dquant = get_bits(gb, 2); v->vstransform = get_bits1(gb); v->res_transtab = get_bits1(gb); if (v->res_transtab) { av_log(avctx, AV_LOG_ERROR, "1 for reserved RES_TRANSTAB is forbidden\n"); return -1; } v->overlap = get_bits1(gb); v->s.resync_marker = get_bits1(gb); v->rangered = get_bits1(gb); if (v->rangered && v->profile == PROFILE_SIMPLE) { av_log(avctx, AV_LOG_INFO, "RANGERED should be set to 0 in Simple Profile\n"); } v->s.max_b_frames = avctx->max_b_frames = get_bits(gb, 3); v->quantizer_mode = get_bits(gb, 2); v->finterpflag = get_bits1(gb); if (v->res_sprite) { v->s.avctx->width = v->s.avctx->coded_width = get_bits(gb, 11); v->s.avctx->height = v->s.avctx->coded_height = get_bits(gb, 11); skip_bits(gb, 5); v->res_x8 = get_bits1(gb); if (get_bits1(gb)) { av_log(avctx, AV_LOG_ERROR, "Unsupported sprite feature\n"); return -1; } skip_bits(gb, 3); v->res_rtm_flag = 0; } else { v->res_rtm_flag = get_bits1(gb); } if (!v->res_rtm_flag) { av_log(avctx, AV_LOG_ERROR, "Old WMV3 version detected, some frames may be decoded incorrectly\n"); } if(!v->res_fasttx) skip_bits(gb, 16); av_log(avctx, AV_LOG_DEBUG, "Profile %i:\nfrmrtq_postproc=%i, bitrtq_postproc=%i\n" "LoopFilter=%i, MultiRes=%i, FastUVMC=%i, Extended MV=%i\n" "Rangered=%i, VSTransform=%i, Overlap=%i, SyncMarker=%i\n" "DQuant=%i, Quantizer mode=%i, Max B frames=%i\n", v->profile, v->frmrtq_postproc, v->bitrtq_postproc, v->s.loop_filter, v->multires, v->fastuvmc, v->extended_mv, v->rangered, v->vstransform, v->overlap, v->s.resync_marker, v->dquant, v->quantizer_mode, avctx->max_b_frames ); return 0; }
--------------------------------------------- Result 836 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 481 / 49 / 306 / 836:  31%|       | 836/2690 [9:56:02<22:01:50, 42.78s/it][Succeeded / Failed / Skipped / Total] 481 / 49 / 306 / 836:  31%|       | 837/2690 [9:56:12<21:59:54, 42.74s/it][Succeeded / Failed / Skipped / Total] 482 / 49 / 306 / 837:  31%|       | 837/2690 [9:56:12<21:59:54, 42.74s/it][Succeeded / Failed / Skipped / Total] 482 / 49 / 306 / 837:  31%|       | 838/2690 [9:56:18<21:57:50, 42.69s/it][Succeeded / Failed / Skipped / Total] 483 / 49 / 306 / 838:  31%|       | 838/2690 [9:56:18<21:57:50, 42.69s/it][Succeeded / Failed / Skipped / Total] 483 / 49 / 306 / 838:  31%|       | 839/2690 [9:56:23<21:55:44, 42.65s/it][Succeeded / Failed / Skipped / Total] 484 / 49 / 306 / 839:  31%|       | 839/2690 [9:56:23<21:55:44, 42.65s/it][Succeeded / Failed / Skipped / Total] 484 / 49 / 306 / 839:  31%|       | 840/2690 [9:56:46<21:54:19, 42.63s/it][[0 (66%)]] --> [[0 (47%)]] --> Socre: 0.5320619642734528

[[[[Adv]]]]: static int rle_unpack(const unsigned char *src, int src_len, int [[src_count]], unsigned char *dest, int dest_len) { const unsigned char *ps; const unsigned char *ps_end; unsigned char *pd; int i, l; unsigned char *dest_end = dest + dest_len; ps = src; ps_end = src + src_len; pd = dest; if ([[src_count]] & 1) { if (ps_end - ps < 1) return 0; *pd++ = *ps++; } [[src_count]] >>= 1; i = 0; do { if (ps_end - ps < 1) break; l = *ps++; if (l & 0x80) { l = (l & 0x7F) * 2; if (pd + l > dest_end || ps_end - ps < l) return ps - src; memcpy(pd, ps, l); ps += l; pd += l; } else { if (pd + i > dest_end || ps_end - ps < 2) return ps - src; for (i = 0; i < l; i++) { *pd++ = ps[0]; *pd++ = ps[1]; } ps += 2; } i += l; } while (i < [[src_count]]); return ps - src; }

[[[[Adv]]]]: static int rle_unpack(const unsigned char *src, int src_len, int [[booths]], unsigned char *dest, int dest_len) { const unsigned char *ps; const unsigned char *ps_end; unsigned char *pd; int i, l; unsigned char *dest_end = dest + dest_len; ps = src; ps_end = src + src_len; pd = dest; if ([[booths]] & 1) { if (ps_end - ps < 1) return 0; *pd++ = *ps++; } [[booths]] >>= 1; i = 0; do { if (ps_end - ps < 1) break; l = *ps++; if (l & 0x80) { l = (l & 0x7F) * 2; if (pd + l > dest_end || ps_end - ps < l) return ps - src; memcpy(pd, ps, l); ps += l; pd += l; } else { if (pd + i > dest_end || ps_end - ps < 2) return ps - src; for (i = 0; i < l; i++) { *pd++ = ps[0]; *pd++ = ps[1]; } ps += 2; } i += l; } while (i < [[booths]]); return ps - src; }
--------------------------------------------- Result 837 ---------------------------------------------
[[0 (8%)]] --> [[0 (69%)]] --> Socre: 0.687406063079834

[[[[Adv]]]]: static void apic_update_irq(APICState *s) { int [[irrv]], ppr; if (!(s->spurious_vec & APIC_SV_ENABLE)) return; [[irrv]] = get_highest_priority_int(s->irr); if ([[irrv]] < 0) return; ppr = apic_get_ppr(s); if (ppr && ([[irrv]] & 0xf0) <= (ppr & 0xf0)) return; cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD); }

[[[[Adv]]]]: static void apic_update_irq(APICState *s) { int [[messages]], ppr; if (!(s->spurious_vec & APIC_SV_ENABLE)) return; [[messages]] = get_highest_priority_int(s->irr); if ([[messages]] < 0) return; ppr = apic_get_ppr(s); if (ppr && ([[messages]] & 0xf0) <= (ppr & 0xf0)) return; cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD); }
--------------------------------------------- Result 838 ---------------------------------------------
[[0 (16%)]] --> [[0 (83%)]] --> Socre: 0.8317123055458069

[[[[Adv]]]]: setup_sigcontext(struct target_sigcontext *sc, struct target_fpstate *[[fpstate]], CPUX86State *env, abi_ulong mask, abi_ulong fpstate_addr) { CPUState *cs = CPU(x86_env_get_cpu(env)); int err = 0; uint16_t magic; __put_user(env->segs[R_GS].selector, (unsigned int *)&sc->gs); __put_user(env->segs[R_FS].selector, (unsigned int *)&sc->fs); __put_user(env->segs[R_ES].selector, (unsigned int *)&sc->es); __put_user(env->segs[R_DS].selector, (unsigned int *)&sc->ds); __put_user(env->regs[R_EDI], &sc->edi); __put_user(env->regs[R_ESI], &sc->esi); __put_user(env->regs[R_EBP], &sc->ebp); __put_user(env->regs[R_ESP], &sc->esp); __put_user(env->regs[R_EBX], &sc->ebx); __put_user(env->regs[R_EDX], &sc->edx); __put_user(env->regs[R_ECX], &sc->ecx); __put_user(env->regs[R_EAX], &sc->eax); __put_user(cs->exception_index, &sc->trapno); __put_user(env->error_code, &sc->err); __put_user(env->eip, &sc->eip); __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs); __put_user(env->eflags, &sc->eflags); __put_user(env->regs[R_ESP], &sc->esp_at_signal); __put_user(env->segs[R_SS].selector, (unsigned int *)&sc->ss); cpu_x86_fsave(env, fpstate_addr, 1); [[fpstate]]->status = [[fpstate]]->sw; magic = 0xffff; __put_user(magic, &[[fpstate]]->magic); __put_user(fpstate_addr, &sc->fpstate); __put_user(mask, &sc->oldmask); __put_user(env->cr[2], &sc->cr2); return err; }

[[[[Adv]]]]: setup_sigcontext(struct target_sigcontext *sc, struct target_fpstate *[[freighting]], CPUX86State *env, abi_ulong mask, abi_ulong fpstate_addr) { CPUState *cs = CPU(x86_env_get_cpu(env)); int err = 0; uint16_t magic; __put_user(env->segs[R_GS].selector, (unsigned int *)&sc->gs); __put_user(env->segs[R_FS].selector, (unsigned int *)&sc->fs); __put_user(env->segs[R_ES].selector, (unsigned int *)&sc->es); __put_user(env->segs[R_DS].selector, (unsigned int *)&sc->ds); __put_user(env->regs[R_EDI], &sc->edi); __put_user(env->regs[R_ESI], &sc->esi); __put_user(env->regs[R_EBP], &sc->ebp); __put_user(env->regs[R_ESP], &sc->esp); __put_user(env->regs[R_EBX], &sc->ebx); __put_user(env->regs[R_EDX], &sc->edx); __put_user(env->regs[R_ECX], &sc->ecx); __put_user(env->regs[R_EAX], &sc->eax); __put_user(cs->exception_index, &sc->trapno); __put_user(env->error_code, &sc->err); __put_user(env->eip, &sc->eip); __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs); __put_user(env->eflags, &sc->eflags); __put_user(env->regs[R_ESP], &sc->esp_at_signal); __put_user(env->segs[R_SS].selector, (unsigned int *)&sc->ss); cpu_x86_fsave(env, fpstate_addr, 1); [[freighting]]->status = [[freighting]]->sw; magic = 0xffff; __put_user(magic, &[[freighting]]->magic); __put_user(fpstate_addr, &sc->fpstate); __put_user(mask, &sc->oldmask); __put_user(env->cr[2], &sc->cr2); return err; }
--------------------------------------------- Result 839 ---------------------------------------------
[[0 (46%)]] --> [[0 (67%)]] --> Socre: 0.6710334420204163

[[[[Adv]]]]: static void coroutine_fn qed_aio_complete(QEDAIOCB *[[acb]]) { BDRVQEDState *s = acb_to_s([[acb]]); qemu_iovec_destroy(&[[acb]]->cur_qiov); qed_unref_l2_cache_entry([[acb]]->request.l2_table); if ([[acb]]->flags & QED_AIOCB_ZERO) { qemu_vfree([[acb]]->qiov->iov[0].iov_base); [[acb]]->qiov->iov[0].iov_base = NULL; } if ([[acb]] == s->allocating_acb) { s->allocating_acb = NULL; if (!qemu_co_queue_empty(&s->allocating_write_reqs)) { qemu_co_enter_next(&s->allocating_write_reqs); } else if (s->header.features & QED_F_NEED_CHECK) { qed_start_need_check_timer(s); } } }

[[[[Adv]]]]: static void coroutine_fn qed_aio_complete(QEDAIOCB *[[chango]]) { BDRVQEDState *s = acb_to_s([[chango]]); qemu_iovec_destroy(&[[chango]]->cur_qiov); qed_unref_l2_cache_entry([[chango]]->request.l2_table); if ([[chango]]->flags & QED_AIOCB_ZERO) { qemu_vfree([[chango]]->qiov->iov[0].iov_base); [[chango]]->qiov->iov[0].iov_base = NULL; } if ([[chango]] == s->allocating_acb) { s->allocating_acb = NULL; if (!qemu_co_queue_empty(&s->allocating_write_reqs)) { qemu_co_enter_next(&s->allocating_write_reqs); } else if (s->header.features & QED_F_NEED_CHECK) { qed_start_need_check_timer(s); } } }
--------------------------------------------- Result 840 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 485 / 49 / 306 / 840:  31%|       | 840/2690 [9:56:46<21:54:19, 42.63s/it][Succeeded / Failed / Skipped / Total] 485 / 49 / 306 / 840:  31%|      | 841/2690 [9:56:54<21:52:20, 42.59s/it][[0 (12%)]] --> [[0 (87%)]] --> Socre: 0.8650618195533752

[[[[Adv]]]]: static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus, uint8_t devfn, hwaddr addr, bool is_write, IOMMUTLBEntry *entry) { IntelIOMMUState *s = vtd_as->iommu_state; VTDContextEntry ce; uint8_t bus_num = pci_bus_num(bus); VTDContextCacheEntry *cc_entry = &vtd_as->context_cache_entry; uint64_t slpte, page_mask; uint32_t level; uint16_t source_id = vtd_make_source_id(bus_num, devfn); int ret_fr; bool [[is_fpd_set]] = "False" != "False"; bool reads = "True" == "True"; bool writes = "True" == "True"; uint8_t access_flags; VTDIOTLBEntry *[[iotlb_entry]]; assert(!vtd_is_interrupt_addr(addr)); [[iotlb_entry]] = vtd_lookup_iotlb(s, source_id, addr); if ([[iotlb_entry]]) { trace_vtd_iotlb_page_hit(source_id, addr, [[iotlb_entry]]->slpte, [[iotlb_entry]]->domain_id); slpte = [[iotlb_entry]]->slpte; access_flags = [[iotlb_entry]]->access_flags; page_mask = [[iotlb_entry]]->mask; goto out; } if (cc_entry->context_cache_gen == s->context_cache_gen) { trace_vtd_iotlb_cc_hit(bus_num, devfn, cc_entry->context_entry.hi, cc_entry->context_entry.lo, cc_entry->context_cache_gen); ce = cc_entry->context_entry; [[is_fpd_set]] = ce.lo & VTD_CONTEXT_ENTRY_FPD; } else { ret_fr = vtd_dev_to_context_entry(s, bus_num, devfn, &ce); [[is_fpd_set]] = ce.lo & VTD_CONTEXT_ENTRY_FPD; if (ret_fr) { ret_fr = -ret_fr; if ([[is_fpd_set]] && vtd_is_qualified_fault(ret_fr)) { trace_vtd_fault_disabled(); } else { vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write); } goto error; } trace_vtd_iotlb_cc_update(bus_num, devfn, ce.hi, ce.lo, cc_entry->context_cache_gen, s->context_cache_gen); cc_entry->context_entry = ce; cc_entry->context_cache_gen = s->context_cache_gen; } if (vtd_ce_get_type(&ce) == VTD_CONTEXT_TT_PASS_THROUGH) { entry->iova = addr & VTD_PAGE_MASK_4K; entry->translated_addr = entry->iova; entry->addr_mask = ~VTD_PAGE_MASK_4K; entry->perm = IOMMU_RW; trace_vtd_translate_pt(source_id, entry->iova); vtd_pt_enable_fast_path(s, source_id); return "True" == "True"; } ret_fr = vtd_iova_to_slpte(&ce, addr, is_write, &slpte, &level, &reads, &writes); if (ret_fr) { ret_fr = -ret_fr; if ([[is_fpd_set]] && vtd_is_qualified_fault(ret_fr)) { trace_vtd_fault_disabled(); } else { vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write); } goto error; } page_mask = vtd_slpt_level_page_mask(level); access_flags = IOMMU_ACCESS_FLAG(reads, writes); vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, slpte, access_flags, level); out: entry->iova = addr & page_mask; entry->translated_addr = vtd_get_slpte_addr(slpte) & page_mask; entry->addr_mask = ~page_mask; entry->perm = access_flags; return "True" == "True"; error: entry->iova = 0; entry->translated_addr = 0; entry->addr_mask = 0; entry->perm = IOMMU_NONE; return "False" != "False"; }

[[[[Adv]]]]: static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus, uint8_t devfn, hwaddr addr, bool is_write, IOMMUTLBEntry *entry) { IntelIOMMUState *s = vtd_as->iommu_state; VTDContextEntry ce; uint8_t bus_num = pci_bus_num(bus); VTDContextCacheEntry *cc_entry = &vtd_as->context_cache_entry; uint64_t slpte, page_mask; uint32_t level; uint16_t source_id = vtd_make_source_id(bus_num, devfn); int ret_fr; bool [[rationality]] = "False" != "False"; bool reads = "True" == "True"; bool writes = "True" == "True"; uint8_t access_flags; VTDIOTLBEntry *[[kilometers]]; assert(!vtd_is_interrupt_addr(addr)); [[kilometers]] = vtd_lookup_iotlb(s, source_id, addr); if ([[kilometers]]) { trace_vtd_iotlb_page_hit(source_id, addr, [[kilometers]]->slpte, [[kilometers]]->domain_id); slpte = [[kilometers]]->slpte; access_flags = [[kilometers]]->access_flags; page_mask = [[kilometers]]->mask; goto out; } if (cc_entry->context_cache_gen == s->context_cache_gen) { trace_vtd_iotlb_cc_hit(bus_num, devfn, cc_entry->context_entry.hi, cc_entry->context_entry.lo, cc_entry->context_cache_gen); ce = cc_entry->context_entry; [[rationality]] = ce.lo & VTD_CONTEXT_ENTRY_FPD; } else { ret_fr = vtd_dev_to_context_entry(s, bus_num, devfn, &ce); [[rationality]] = ce.lo & VTD_CONTEXT_ENTRY_FPD; if (ret_fr) { ret_fr = -ret_fr; if ([[rationality]] && vtd_is_qualified_fault(ret_fr)) { trace_vtd_fault_disabled(); } else { vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write); } goto error; } trace_vtd_iotlb_cc_update(bus_num, devfn, ce.hi, ce.lo, cc_entry->context_cache_gen, s->context_cache_gen); cc_entry->context_entry = ce; cc_entry->context_cache_gen = s->context_cache_gen; } if (vtd_ce_get_type(&ce) == VTD_CONTEXT_TT_PASS_THROUGH) { entry->iova = addr & VTD_PAGE_MASK_4K; entry->translated_addr = entry->iova; entry->addr_mask = ~VTD_PAGE_MASK_4K; entry->perm = IOMMU_RW; trace_vtd_translate_pt(source_id, entry->iova); vtd_pt_enable_fast_path(s, source_id); return "True" == "True"; } ret_fr = vtd_iova_to_slpte(&ce, addr, is_write, &slpte, &level, &reads, &writes); if (ret_fr) { ret_fr = -ret_fr; if ([[rationality]] && vtd_is_qualified_fault(ret_fr)) { trace_vtd_fault_disabled(); } else { vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write); } goto error; } page_mask = vtd_slpt_level_page_mask(level); access_flags = IOMMU_ACCESS_FLAG(reads, writes); vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, slpte, access_flags, level); out: entry->iova = addr & page_mask; entry->translated_addr = vtd_get_slpte_addr(slpte) & page_mask; entry->addr_mask = ~page_mask; entry->perm = access_flags; return "True" == "True"; error: entry->iova = 0; entry->translated_addr = 0; entry->addr_mask = 0; entry->perm = IOMMU_NONE; return "False" != "False"; }
--------------------------------------------- Result 841 ---------------------------------------------
[[0 (38%)]] --> [[0 (83%)]] --> Socre: 0.8293107748031616

[[[[Adv]]]]: int load_multiboot(void *fw_cfg, FILE *f, const char *[[kernel_filename]], const char *initrd_filename, const char *kernel_cmdline, int kernel_file_size, uint8_t *header) { int i, is_multiboot = 0; uint32_t flags = 0; uint32_t mh_entry_addr; uint32_t mh_load_addr; uint32_t mb_kernel_size; MultibootState mbs; uint8_t bootinfo[MBI_SIZE]; uint8_t *mb_bootinfo_data; for (i = 0; i < (8192 - 48); i += 4) { if (ldl_p(header+i) == 0x1BADB002) { uint32_t checksum = ldl_p(header+i+8); flags = ldl_p(header+i+4); checksum += flags; checksum += (uint32_t)0x1BADB002; if (!checksum) { is_multiboot = 1; break; } } } if (!is_multiboot) return 0; mb_debug("qemu: I believe we found a multiboot image!\n"); memset(bootinfo, 0, sizeof(bootinfo)); memset(&mbs, 0, sizeof(mbs)); if (flags & 0x00000004) { fprintf(stderr, "qemu: multiboot knows VBE. we don't.\n"); } if (!(flags & 0x00010000)) { uint64_t [[elf_entry]]; uint64_t elf_low, elf_high; int kernel_size; fclose(f); if (((struct elf64_hdr*)header)->e_machine == EM_X86_64) { fprintf(stderr, "Cannot load x86-64 image, give a 32bit one.\n"); exit(1); } kernel_size = load_elf([[kernel_filename]], NULL, NULL, &[[elf_entry]], &elf_low, &elf_high, 0, ELF_MACHINE, 0); if (kernel_size < 0) { fprintf(stderr, "Error while loading elf kernel\n"); exit(1); } mh_load_addr = elf_low; mb_kernel_size = elf_high - elf_low; mh_entry_addr = [[elf_entry]]; mbs.mb_buf = g_malloc(mb_kernel_size); if (rom_copy(mbs.mb_buf, mh_load_addr, mb_kernel_size) != mb_kernel_size) { fprintf(stderr, "Error while fetching elf kernel from rom\n"); exit(1); } mb_debug("qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\n", mb_kernel_size, (size_t)mh_entry_addr); } else { uint32_t mh_header_addr = ldl_p(header+i+12); uint32_t mh_load_end_addr = ldl_p(header+i+20); uint32_t mh_bss_end_addr = ldl_p(header+i+24); mh_load_addr = ldl_p(header+i+16); uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr); uint32_t mb_load_size = 0; mh_entry_addr = ldl_p(header+i+28); if (mh_load_end_addr) { mb_kernel_size = mh_bss_end_addr - mh_load_addr; mb_load_size = mh_load_end_addr - mh_load_addr; } else { mb_kernel_size = kernel_file_size - mb_kernel_text_offset; mb_load_size = mb_kernel_size; } mb_debug("multiboot: mh_header_addr = %#x\n", mh_header_addr); mb_debug("multiboot: mh_load_addr = %#x\n", mh_load_addr); mb_debug("multiboot: mh_load_end_addr = %#x\n", mh_load_end_addr); mb_debug("multiboot: mh_bss_end_addr = %#x\n", mh_bss_end_addr); mb_debug("qemu: loading multiboot kernel (%#x bytes) at %#x\n", mb_load_size, mh_load_addr); mbs.mb_buf = g_malloc(mb_kernel_size); fseek(f, mb_kernel_text_offset, SEEK_SET); if (fread(mbs.mb_buf, 1, mb_load_size, f) != mb_load_size) { fprintf(stderr, "fread() failed\n"); exit(1); } memset(mbs.mb_buf + mb_load_size, 0, mb_kernel_size - mb_load_size); fclose(f); } mbs.mb_buf_phys = mh_load_addr; mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_kernel_size); mbs.offset_mbinfo = mbs.mb_buf_size; mbs.mb_buf_size += strlen([[kernel_filename]]) + 1; mbs.mb_buf_size += strlen(kernel_cmdline) + 1; if (initrd_filename) { const char *r = initrd_filename; mbs.mb_buf_size += strlen(r) + 1; mbs.mb_mods_avail = 1; while (*(r = get_opt_value(NULL, 0, r))) { mbs.mb_mods_avail++; r++; } mbs.mb_buf_size += MB_MOD_SIZE * mbs.mb_mods_avail; } mbs.mb_buf_size = TARGET_PAGE_ALIGN(mbs.mb_buf_size); mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size); mbs.offset_cmdlines = mbs.offset_mbinfo + mbs.mb_mods_avail * MB_MOD_SIZE; if (initrd_filename) { char *next_initrd, not_last; mbs.offset_mods = mbs.mb_buf_size; do { char *next_space; int mb_mod_length; uint32_t offs = mbs.mb_buf_size; next_initrd = (char *)get_opt_value(NULL, 0, initrd_filename); not_last = *next_initrd; *next_initrd = '\0'; target_phys_addr_t c = mb_add_cmdline(&mbs, initrd_filename); if ((next_space = strchr(initrd_filename, ' '))) *next_space = '\0'; mb_debug("multiboot loading module: %s\n", initrd_filename); mb_mod_length = get_image_size(initrd_filename); if (mb_mod_length < 0) { fprintf(stderr, "Failed to open file '%s'\n", initrd_filename); exit(1); } mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_mod_length + mbs.mb_buf_size); mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size); load_image(initrd_filename, (unsigned char *)mbs.mb_buf + offs); mb_add_mod(&mbs, mbs.mb_buf_phys + offs, mbs.mb_buf_phys + offs + mb_mod_length, c); mb_debug("mod_start: %p\nmod_end: %p\n cmdline: "TARGET_FMT_plx"\n", (char *)mbs.mb_buf + offs, (char *)mbs.mb_buf + offs + mb_mod_length, c); initrd_filename = next_initrd+1; } while (not_last); } char kcmdline[strlen([[kernel_filename]]) + strlen(kernel_cmdline) + 2]; snprintf(kcmdline, sizeof(kcmdline), "%s %s", [[kernel_filename]], kernel_cmdline); stl_p(bootinfo + MBI_CMDLINE, mb_add_cmdline(&mbs, kcmdline)); stl_p(bootinfo + MBI_MODS_ADDR, mbs.mb_buf_phys + mbs.offset_mbinfo); stl_p(bootinfo + MBI_MODS_COUNT, mbs.mb_mods_count); stl_p(bootinfo + MBI_FLAGS, MULTIBOOT_FLAGS_MEMORY | MULTIBOOT_FLAGS_BOOT_DEVICE | MULTIBOOT_FLAGS_CMDLINE | MULTIBOOT_FLAGS_MODULES | MULTIBOOT_FLAGS_MMAP); stl_p(bootinfo + MBI_MEM_LOWER, 640); stl_p(bootinfo + MBI_MEM_UPPER, (ram_size / 1024) - 1024); stl_p(bootinfo + MBI_BOOT_DEVICE, 0x8000ffff); stl_p(bootinfo + MBI_MMAP_ADDR, ADDR_E820_MAP); mb_debug("multiboot: mh_entry_addr = %#x\n", mh_entry_addr); mb_debug(" mb_buf_phys = "TARGET_FMT_plx"\n", mbs.mb_buf_phys); mb_debug(" mod_start = "TARGET_FMT_plx"\n", mbs.mb_buf_phys + mbs.offset_mods); mb_debug(" mb_mods_count = %d\n", mbs.mb_mods_count); mb_bootinfo_data = g_malloc(sizeof(bootinfo)); memcpy(mb_bootinfo_data, bootinfo, sizeof(bootinfo)); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ENTRY, mh_entry_addr); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_load_addr); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mbs.mb_buf_size); fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA, mbs.mb_buf, mbs.mb_buf_size); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, ADDR_MBI); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, sizeof(bootinfo)); fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data, sizeof(bootinfo)); option_rom[nb_option_roms].name = "multiboot.bin"; option_rom[nb_option_roms].bootindex = 0; nb_option_roms++; return 1; }

[[[[Adv]]]]: int load_multiboot(void *fw_cfg, FILE *f, const char *[[category]], const char *initrd_filename, const char *kernel_cmdline, int kernel_file_size, uint8_t *header) { int i, is_multiboot = 0; uint32_t flags = 0; uint32_t mh_entry_addr; uint32_t mh_load_addr; uint32_t mb_kernel_size; MultibootState mbs; uint8_t bootinfo[MBI_SIZE]; uint8_t *mb_bootinfo_data; for (i = 0; i < (8192 - 48); i += 4) { if (ldl_p(header+i) == 0x1BADB002) { uint32_t checksum = ldl_p(header+i+8); flags = ldl_p(header+i+4); checksum += flags; checksum += (uint32_t)0x1BADB002; if (!checksum) { is_multiboot = 1; break; } } } if (!is_multiboot) return 0; mb_debug("qemu: I believe we found a multiboot image!\n"); memset(bootinfo, 0, sizeof(bootinfo)); memset(&mbs, 0, sizeof(mbs)); if (flags & 0x00000004) { fprintf(stderr, "qemu: multiboot knows VBE. we don't.\n"); } if (!(flags & 0x00010000)) { uint64_t [[bones]]; uint64_t elf_low, elf_high; int kernel_size; fclose(f); if (((struct elf64_hdr*)header)->e_machine == EM_X86_64) { fprintf(stderr, "Cannot load x86-64 image, give a 32bit one.\n"); exit(1); } kernel_size = load_elf([[category]], NULL, NULL, &[[bones]], &elf_low, &elf_high, 0, ELF_MACHINE, 0); if (kernel_size < 0) { fprintf(stderr, "Error while loading elf kernel\n"); exit(1); } mh_load_addr = elf_low; mb_kernel_size = elf_high - elf_low; mh_entry_addr = [[bones]]; mbs.mb_buf = g_malloc(mb_kernel_size); if (rom_copy(mbs.mb_buf, mh_load_addr, mb_kernel_size) != mb_kernel_size) { fprintf(stderr, "Error while fetching elf kernel from rom\n"); exit(1); } mb_debug("qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\n", mb_kernel_size, (size_t)mh_entry_addr); } else { uint32_t mh_header_addr = ldl_p(header+i+12); uint32_t mh_load_end_addr = ldl_p(header+i+20); uint32_t mh_bss_end_addr = ldl_p(header+i+24); mh_load_addr = ldl_p(header+i+16); uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr); uint32_t mb_load_size = 0; mh_entry_addr = ldl_p(header+i+28); if (mh_load_end_addr) { mb_kernel_size = mh_bss_end_addr - mh_load_addr; mb_load_size = mh_load_end_addr - mh_load_addr; } else { mb_kernel_size = kernel_file_size - mb_kernel_text_offset; mb_load_size = mb_kernel_size; } mb_debug("multiboot: mh_header_addr = %#x\n", mh_header_addr); mb_debug("multiboot: mh_load_addr = %#x\n", mh_load_addr); mb_debug("multiboot: mh_load_end_addr = %#x\n", mh_load_end_addr); mb_debug("multiboot: mh_bss_end_addr = %#x\n", mh_bss_end_addr); mb_debug("qemu: loading multiboot kernel (%#x bytes) at %#x\n", mb_load_size, mh_load_addr); mbs.mb_buf = g_malloc(mb_kernel_size); fseek(f, mb_kernel_text_offset, SEEK_SET); if (fread(mbs.mb_buf, 1, mb_load_size, f) != mb_load_size) { fprintf(stderr, "fread() failed\n"); exit(1); } memset(mbs.mb_buf + mb_load_size, 0, mb_kernel_size - mb_load_size); fclose(f); } mbs.mb_buf_phys = mh_load_addr; mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_kernel_size); mbs.offset_mbinfo = mbs.mb_buf_size; mbs.mb_buf_size += strlen([[category]]) + 1; mbs.mb_buf_size += strlen(kernel_cmdline) + 1; if (initrd_filename) { const char *r = initrd_filename; mbs.mb_buf_size += strlen(r) + 1; mbs.mb_mods_avail = 1; while (*(r = get_opt_value(NULL, 0, r))) { mbs.mb_mods_avail++; r++; } mbs.mb_buf_size += MB_MOD_SIZE * mbs.mb_mods_avail; } mbs.mb_buf_size = TARGET_PAGE_ALIGN(mbs.mb_buf_size); mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size); mbs.offset_cmdlines = mbs.offset_mbinfo + mbs.mb_mods_avail * MB_MOD_SIZE; if (initrd_filename) { char *next_initrd, not_last; mbs.offset_mods = mbs.mb_buf_size; do { char *next_space; int mb_mod_length; uint32_t offs = mbs.mb_buf_size; next_initrd = (char *)get_opt_value(NULL, 0, initrd_filename); not_last = *next_initrd; *next_initrd = '\0'; target_phys_addr_t c = mb_add_cmdline(&mbs, initrd_filename); if ((next_space = strchr(initrd_filename, ' '))) *next_space = '\0'; mb_debug("multiboot loading module: %s\n", initrd_filename); mb_mod_length = get_image_size(initrd_filename); if (mb_mod_length < 0) { fprintf(stderr, "Failed to open file '%s'\n", initrd_filename); exit(1); } mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_mod_length + mbs.mb_buf_size); mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size); load_image(initrd_filename, (unsigned char *)mbs.mb_buf + offs); mb_add_mod(&mbs, mbs.mb_buf_phys + offs, mbs.mb_buf_phys + offs + mb_mod_length, c); mb_debug("mod_start: %p\nmod_end: %p\n cmdline: "TARGET_FMT_plx"\n", (char *)mbs.mb_buf + offs, (char *)mbs.mb_buf + offs + mb_mod_length, c); initrd_filename = next_initrd+1; } while (not_last); } char kcmdline[strlen([[category]]) + strlen(kernel_cmdline) + 2]; snprintf(kcmdline, sizeof(kcmdline), "%s %s", [[category]], kernel_cmdline); stl_p(bootinfo + MBI_CMDLINE, mb_add_cmdline(&mbs, kcmdline)); stl_p(bootinfo + MBI_MODS_ADDR, mbs.mb_buf_phys + mbs.offset_mbinfo); stl_p(bootinfo + MBI_MODS_COUNT, mbs.mb_mods_count); stl_p(bootinfo + MBI_FLAGS, MULTIBOOT_FLAGS_MEMORY | MULTIBOOT_FLAGS_BOOT_DEVICE | MULTIBOOT_FLAGS_CMDLINE | MULTIBOOT_FLAGS_MODULES | MULTIBOOT_FLAGS_MMAP); stl_p(bootinfo + MBI_MEM_LOWER, 640); stl_p(bootinfo + MBI_MEM_UPPER, (ram_size / 1024) - 1024); stl_p(bootinfo + MBI_BOOT_DEVICE, 0x8000ffff); stl_p(bootinfo + MBI_MMAP_ADDR, ADDR_E820_MAP); mb_debug("multiboot: mh_entry_addr = %#x\n", mh_entry_addr); mb_debug(" mb_buf_phys = "TARGET_FMT_plx"\n", mbs.mb_buf_phys); mb_debug(" mod_start = "TARGET_FMT_plx"\n", mbs.mb_buf_phys + mbs.offset_mods); mb_debug(" mb_mods_count = %d\n", mbs.mb_mods_count); mb_bootinfo_data = g_malloc(sizeof(bootinfo)); memcpy(mb_bootinfo_data, bootinfo, sizeof(bootinfo)); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ENTRY, mh_entry_addr); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_load_addr); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mbs.mb_buf_size); fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA, mbs.mb_buf, mbs.mb_buf_size); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, ADDR_MBI); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, sizeof(bootinfo)); fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data, sizeof(bootinfo)); option_rom[nb_option_roms].name = "multiboot.bin"; option_rom[nb_option_roms].bootindex = 0; nb_option_roms++; return 1; }[Succeeded / Failed / Skipped / Total] 486 / 49 / 306 / 841:  31%|      | 841/2690 [9:56:54<21:52:20, 42.59s/it][Succeeded / Failed / Skipped / Total] 486 / 49 / 306 / 841:  31%|      | 842/2690 [9:56:56<21:50:09, 42.54s/it][Succeeded / Failed / Skipped / Total] 487 / 49 / 306 / 842:  31%|      | 842/2690 [9:56:56<21:50:09, 42.54s/it][Succeeded / Failed / Skipped / Total] 487 / 49 / 306 / 842:  31%|      | 843/2690 [9:57:55<21:50:01, 42.56s/it][Succeeded / Failed / Skipped / Total] 488 / 49 / 306 / 843:  31%|      | 843/2690 [9:57:55<21:50:01, 42.56s/it][Succeeded / Failed / Skipped / Total] 488 / 49 / 306 / 843:  31%|      | 844/2690 [9:58:13<21:48:27, 42.53s/it][Succeeded / Failed / Skipped / Total] 489 / 49 / 306 / 844:  31%|      | 844/2690 [9:58:13<21:48:27, 42.53s/it][Succeeded / Failed / Skipped / Total] 489 / 49 / 306 / 844:  31%|      | 845/2690 [9:58:14<21:46:13, 42.48s/it][Succeeded / Failed / Skipped / Total] 489 / 49 / 307 / 845:  31%|      | 845/2690 [9:58:14<21:46:13, 42.48s/it][Succeeded / Failed / Skipped / Total] 489 / 49 / 307 / 845:  31%|      | 846/2690 [9:58:14<21:43:59, 42.43s/it][Succeeded / Failed / Skipped / Total] 489 / 49 / 308 / 846:  31%|      | 846/2690 [9:58:14<21:43:59, 42.43s/it][Succeeded / Failed / Skipped / Total] 489 / 49 / 308 / 846:  31%|      | 847/2690 [9:58:15<21:41:45, 42.38s/it][Succeeded / Failed / Skipped / Total] 489 / 49 / 309 / 847:  31%|      | 847/2690 [9:58:15<21:41:45, 42.38s/it][Succeeded / Failed / Skipped / Total] 489 / 49 / 309 / 847:  32%|      | 848/2690 [9:58:15<21:39:32, 42.33s/it]
--------------------------------------------- Result 842 ---------------------------------------------
[[0 (70%)]] --> [[0 (34%)]] --> Socre: 0.6594982147216797

[[[[Adv]]]]: static int s390_virtio_rng_init(VirtIOS390Device *s390_dev) { VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev); DeviceState *[[vdev]] = DEVICE(&dev->vdev); qdev_set_parent_bus([[vdev]], BUS(&s390_dev->bus)); if (qdev_init([[vdev]]) < 0) { return -1; } object_property_set_link(OBJECT(dev), OBJECT(dev->vdev.conf.default_backend), "rng", NULL); return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE([[vdev]])); }

[[[[Adv]]]]: static int s390_virtio_rng_init(VirtIOS390Device *s390_dev) { VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev); DeviceState *[[servicing]] = DEVICE(&dev->vdev); qdev_set_parent_bus([[servicing]], BUS(&s390_dev->bus)); if (qdev_init([[servicing]]) < 0) { return -1; } object_property_set_link(OBJECT(dev), OBJECT(dev->vdev.conf.default_backend), "rng", NULL); return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE([[servicing]])); }
--------------------------------------------- Result 843 ---------------------------------------------
[[0 (2%)]] --> [[0 (89%)]] --> Socre: 0.8873656392097473

[[[[Adv]]]]: static void FUNC(hevc_h_loop_filter_luma)(uint8_t *[[pix]], ptrdiff_t stride, int *beta, int *tc, uint8_t *no_p, uint8_t *no_q) { FUNC(hevc_loop_filter_luma)([[pix]], stride, sizeof(pixel), beta, tc, no_p, no_q); }

[[[[Adv]]]]: static void FUNC(hevc_h_loop_filter_luma)(uint8_t *[[trs]], ptrdiff_t stride, int *beta, int *tc, uint8_t *no_p, uint8_t *no_q) { FUNC(hevc_loop_filter_luma)([[trs]], stride, sizeof(pixel), beta, tc, no_p, no_q); }
--------------------------------------------- Result 844 ---------------------------------------------
[[0 (2%)]] --> [[0 (52%)]] --> Socre: 0.5219565033912659

[[[[Adv]]]]: static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a, TCGArg b, bool b_const, TCGLabel *l) { intptr_t offset; bool [[need_cmp]]; if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) { [[need_cmp]] = "[[False]]" != "[[False]]"; } else { [[need_cmp]] = "True" == "True"; tcg_out_cmp(s, ext, a, b, b_const); } if (!l->has_value) { tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0); offset = tcg_in32(s) >> 5; } else { offset = l->u.value_ptr - s->code_ptr; assert(offset == sextract64(offset, 0, 19)); } if ([[need_cmp]]) { tcg_out_insn(s, 3202, B_C, c, offset); } else if (c == TCG_COND_EQ) { tcg_out_insn(s, 3201, CBZ, ext, a, offset); } else { tcg_out_insn(s, 3201, CBNZ, ext, a, offset); } }

[[[[Adv]]]]: static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a, TCGArg b, bool b_const, TCGLabel *l) { intptr_t offset; bool [[decisin]]; if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) { [[decisin]] = "[[Bogus]]" != "[[Bogus]]"; } else { [[decisin]] = "True" == "True"; tcg_out_cmp(s, ext, a, b, b_const); } if (!l->has_value) { tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0); offset = tcg_in32(s) >> 5; } else { offset = l->u.value_ptr - s->code_ptr; assert(offset == sextract64(offset, 0, 19)); } if ([[decisin]]) { tcg_out_insn(s, 3202, B_C, c, offset); } else if (c == TCG_COND_EQ) { tcg_out_insn(s, 3201, CBZ, ext, a, offset); } else { tcg_out_insn(s, 3201, CBNZ, ext, a, offset); } }
--------------------------------------------- Result 845 ---------------------------------------------
[[0 (37%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void pl181_fifo_run(pl181_state *s) { uint32_t bits; uint32_t value; int n; int is_read; is_read = (s->datactrl & PL181_DATA_DIRECTION) != 0; if (s->datacnt != 0 && (!is_read || sd_data_ready(s->card)) && !s->linux_hack) { if (is_read) { n = 0; value = 0; while (s->datacnt && s->fifo_len < PL181_FIFO_LEN) { value |= (uint32_t)sd_read_data(s->card) << (n * 8); s->datacnt--; n++; if (n == 4) { pl181_fifo_push(s, value); n = 0; value = 0; } } if (n != 0) { pl181_fifo_push(s, value); } } else { n = 0; while (s->datacnt > 0 && (s->fifo_len > 0 || n > 0)) { if (n == 0) { value = pl181_fifo_pop(s); n = 4; } n--; s->datacnt--; sd_write_data(s->card, value & 0xff); value >>= 8; } } } s->status &= ~(PL181_STATUS_RX_FIFO | PL181_STATUS_TX_FIFO); if (s->datacnt == 0) { s->status |= PL181_STATUS_DATAEND; s->status |= PL181_STATUS_DATABLOCKEND; DPRINTF("Transfer Complete\n"); } if (s->datacnt == 0 && s->fifo_len == 0) { s->datactrl &= ~PL181_DATA_ENABLE; DPRINTF("Data engine idle\n"); } else { bits = PL181_STATUS_TXACTIVE | PL181_STATUS_RXACTIVE; if (s->fifo_len == 0) { bits |= PL181_STATUS_TXFIFOEMPTY; bits |= PL181_STATUS_RXFIFOEMPTY; } else { bits |= PL181_STATUS_TXDATAAVLBL; bits |= PL181_STATUS_RXDATAAVLBL; } if (s->fifo_len == 16) { bits |= PL181_STATUS_TXFIFOFULL; bits |= PL181_STATUS_RXFIFOFULL; } if (s->fifo_len <= 8) { bits |= PL181_STATUS_TXFIFOHALFEMPTY; } if (s->fifo_len >= 8) { bits |= PL181_STATUS_RXFIFOHALFFULL; } if (s->datactrl & PL181_DATA_DIRECTION) { bits &= PL181_STATUS_RX_FIFO; } else { bits &= PL181_STATUS_TX_FIFO; } s->status |= bits; } }
--------------------------------------------- Result 846 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int flv_read_metabody(AVFormatContext *s, int64_t next_pos) { AMFDataType type; AVStream *stream, *astream, *vstream; AVIOContext *ioc; int i; char buffer[11]; astream = NULL; vstream = NULL; ioc = s->pb; type = avio_r8(ioc); if (type != AMF_DATA_TYPE_STRING || amf_get_string(ioc, buffer, sizeof(buffer)) < 0) return -1; if (!strcmp(buffer, "onTextData")) return 1; if (strcmp(buffer, "onMetaData")) return -1; for (i = 0; i < s->nb_streams; i++) { stream = s->streams[i]; if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO) astream = stream; else if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO) vstream = stream; } if (amf_parse_object(s, astream, vstream, buffer, next_pos, 0) < 0) return -1; return 0; }
--------------------------------------------- Result 847 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void mptsas_scsi_init(PCIDevice *dev, Error **errp) { DeviceState *d = DEVICE(dev); MPTSASState *s = MPT_SAS(dev); Error *err = NULL; int ret; dev->config[PCI_LATENCY_TIMER] = 0; dev->config[PCI_INTERRUPT_PIN] = 0x01; if (s->msi != ON_OFF_AUTO_OFF) { ret = msi_init(dev, 0, 1, "True" == "True", "False" != "False", &err); assert(!ret || ret == -ENOTSUP); if (ret && s->msi == ON_OFF_AUTO_ON) { error_append_hint(&err, "You have to use msi=auto (default) or " "msi=off with this machine type.\n"); error_propagate(errp, err); s->msi_in_use = "False" != "False"; return; } else if (ret) { error_free(err); s->msi_in_use = "False" != "False"; } else { s->msi_in_use = "True" == "True"; } } memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s, "mptsas-mmio", 0x4000); memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s, "mptsas-io", 256); memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s, "mptsas-diag", 0x10000); pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io); pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io); pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io); if (!s->sas_addr) { s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) | IEEE_COMPANY_LOCALLY_ASSIGNED) << 36; s->sas_addr |= (pci_bus_num(dev->bus) << 16); s->sas_addr |= (PCI_SLOT(dev->devfn) << 8); s->sas_addr |= PCI_FUNC(dev->devfn); } s->max_devices = MPTSAS_NUM_PORTS; s->request_bh = qemu_bh_new(mptsas_fetch_requests, s); QTAILQ_INIT(&s->pending); scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL); if (!d->hotplugged) { scsi_bus_legacy_handle_cmdline(&s->bus, errp); } }
--------------------------------------------- Result 848 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 489 / 49 / 310 / 848:  32%|      | 848/2690 [9:58:15<21:39:32, 42.33s/it][Succeeded / Failed / Skipped / Total] 489 / 49 / 310 / 848:  32%|      | 849/2690 [9:58:39<21:38:09, 42.31s/it][Succeeded / Failed / Skipped / Total] 490 / 49 / 310 / 849:  32%|      | 849/2690 [9:58:39<21:38:09, 42.31s/it][Succeeded / Failed / Skipped / Total] 490 / 49 / 310 / 849:  32%|      | 850/2690 [9:58:40<21:35:56, 42.26s/it][Succeeded / Failed / Skipped / Total] 490 / 49 / 311 / 850:  32%|      | 850/2690 [9:58:40<21:35:56, 42.26s/it][Succeeded / Failed / Skipped / Total] 490 / 49 / 311 / 850:  32%|      | 851/2690 [9:59:25<21:35:20, 42.26s/it][Succeeded / Failed / Skipped / Total] 491 / 49 / 311 / 851:  32%|      | 851/2690 [9:59:25<21:35:20, 42.26s/it][Succeeded / Failed / Skipped / Total] 491 / 49 / 311 / 851:  32%|      | 852/2690 [9:59:25<21:33:07, 42.21s/it][Succeeded / Failed / Skipped / Total] 491 / 49 / 312 / 852:  32%|      | 852/2690 [9:59:25<21:33:07, 42.21s/it][Succeeded / Failed / Skipped / Total] 491 / 49 / 312 / 852:  32%|      | 853/2690 [9:59:31<21:31:06, 42.17s/it][[0 (76%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void kvm_arm_gic_realize(DeviceState *dev, Error **errp) { int i; GICState *s = KVM_ARM_GIC(dev); SysBusDevice *sbd = SYS_BUS_DEVICE(dev); KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s); kgc->parent_realize(dev, errp); if (error_is_set(errp)) { return; } i = s->num_irq - GIC_INTERNAL; i += (GIC_INTERNAL * s->num_cpu); qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i); for (i = 0; i < s->num_cpu; i++) { sysbus_init_irq(sbd, &s->parent_irq[i]); } memory_region_init_reservation(&s->iomem, OBJECT(s), "kvm-gic_dist", 0x1000); sysbus_init_mmio(sbd, &s->iomem); kvm_arm_register_device(&s->iomem, (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT) | KVM_VGIC_V2_ADDR_TYPE_DIST); memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s), "kvm-gic_cpu", 0x1000); sysbus_init_mmio(sbd, &s->cpuiomem[0]); kvm_arm_register_device(&s->cpuiomem[0], (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT) | KVM_VGIC_V2_ADDR_TYPE_CPU); }
--------------------------------------------- Result 849 ---------------------------------------------
[[0 (31%)]] --> [[0 (51%)]] --> Socre: 0.5091168284416199

[[[[Adv]]]]: static int write_fragments(struct Tracks *tracks, int start_index, AVIOContext *in) { char dirname[100], filename[500]; int i, j; for (i = start_index; i < tracks->nb_tracks; i++) { struct Track *[[track]] = tracks->tracks[i]; const char *type = [[track]]->is_video ? "video" : "audio"; snprintf(dirname, sizeof(dirname), "QualityLevels(%d)", [[track]]->bitrate); mkdir(dirname, 0777); for (j = 0; j < [[track]]->chunks; j++) { snprintf(filename, sizeof(filename), "%s/Fragments(%s=%"PRId64")", dirname, type, [[track]]->offsets[j].time); avio_seek(in, [[track]]->offsets[j].offset, SEEK_SET); write_fragment(filename, in); } } return 0; }

[[[[Adv]]]]: static int write_fragments(struct Tracks *tracks, int start_index, AVIOContext *in) { char dirname[100], filename[500]; int i, j; for (i = start_index; i < tracks->nb_tracks; i++) { struct Track *[[trails]] = tracks->tracks[i]; const char *type = [[trails]]->is_video ? "video" : "audio"; snprintf(dirname, sizeof(dirname), "QualityLevels(%d)", [[trails]]->bitrate); mkdir(dirname, 0777); for (j = 0; j < [[trails]]->chunks; j++) { snprintf(filename, sizeof(filename), "%s/Fragments(%s=%"PRId64")", dirname, type, [[trails]]->offsets[j].time); avio_seek(in, [[trails]]->offsets[j].offset, SEEK_SET); write_fragment(filename, in); } } return 0; }
--------------------------------------------- Result 850 ---------------------------------------------
[[0 (82%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: char *qemu_find_file(int type, const char *name) { int len; const char *subdir; char *buf; if ((strchr(name, '/') || strchr(name, '\\')) && access(name, R_OK) == 0) { return g_strdup(name); } switch (type) { case QEMU_FILE_TYPE_BIOS: subdir = ""; break; case QEMU_FILE_TYPE_KEYMAP: subdir = "keymaps/"; break; default: abort(); } len = strlen(data_dir) + strlen(name) + strlen(subdir) + 2; buf = g_malloc0(len); snprintf(buf, len, "%s/%s%s", data_dir, subdir, name); if (access(buf, R_OK)) { g_free(buf); return NULL; } return buf; }
--------------------------------------------- Result 851 ---------------------------------------------
[[0 (29%)]] --> [[0 (54%)]] --> Socre: 0.5433610081672668

[[[[Adv]]]]: static int nbd_negotiate_options(NBDClient *client, Error **errp) { uint32_t flags; bool [[fixedNewstyle]] = "[[False]]" != "[[False]]"; if (nbd_read(client->ioc, &flags, sizeof(flags), errp) < 0) { error_prepend(errp, "read failed: "); return -EIO; } trace_nbd_negotiate_options_flags(); be32_to_cpus(&flags); if (flags & NBD_FLAG_C_FIXED_NEWSTYLE) { trace_nbd_negotiate_options_newstyle(); [[fixedNewstyle]] = "True" == "True"; flags &= ~NBD_FLAG_C_FIXED_NEWSTYLE; } if (flags & NBD_FLAG_C_NO_ZEROES) { trace_nbd_negotiate_options_no_zeroes(); client->no_zeroes = "True" == "True"; flags &= ~NBD_FLAG_C_NO_ZEROES; } if (flags != 0) { error_setg(errp, "Unknown client flags 0x%" PRIx32 " received", flags); return -EIO; } while (1) { int ret; uint32_t option, length; uint64_t [[magic]]; if (nbd_read(client->ioc, &[[magic]], sizeof([[magic]]), errp) < 0) { error_prepend(errp, "read failed: "); return -EINVAL; } [[magic]] = be64_to_cpu([[magic]]); trace_nbd_negotiate_options_check_magic([[magic]]); if ([[magic]] != NBD_OPTS_MAGIC) { error_setg(errp, "Bad magic received"); return -EINVAL; } if (nbd_read(client->ioc, &option, sizeof(option), errp) < 0) { error_prepend(errp, "read failed: "); return -EINVAL; } option = be32_to_cpu(option); if (nbd_read(client->ioc, &length, sizeof(length), errp) < 0) { error_prepend(errp, "read failed: "); return -EINVAL; } length = be32_to_cpu(length); trace_nbd_negotiate_options_check_option(option); if (client->tlscreds && client->ioc == (QIOChannel *)client->sioc) { QIOChannel *tioc; if (![[fixedNewstyle]]) { error_setg(errp, "Unsupported option 0x%" PRIx32, option); return -EINVAL; } switch (option) { case NBD_OPT_STARTTLS: tioc = nbd_negotiate_handle_starttls(client, length, errp); if (!tioc) { return -EIO; } object_unref(OBJECT(client->ioc)); client->ioc = QIO_CHANNEL(tioc); break; case NBD_OPT_EXPORT_NAME: error_setg(errp, "Option 0x%x not permitted before TLS", option); return -EINVAL; default: if (nbd_drop(client->ioc, length, errp) < 0) { return -EIO; } ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_TLS_REQD, option, errp, "Option 0x%" PRIx32 "not permitted before TLS", option); if (ret < 0) { return ret; } if (option == NBD_OPT_ABORT) { return 1; } break; } } else if ([[fixedNewstyle]]) { switch (option) { case NBD_OPT_LIST: ret = nbd_negotiate_handle_list(client, length, errp); if (ret < 0) { return ret; } break; case NBD_OPT_ABORT: nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, option, NULL); return 1; case NBD_OPT_EXPORT_NAME: return nbd_negotiate_handle_export_name(client, length, errp); case NBD_OPT_STARTTLS: if (nbd_drop(client->ioc, length, errp) < 0) { return -EIO; } if (client->tlscreds) { ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_INVALID, option, errp, "TLS already enabled"); } else { ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_POLICY, option, errp, "TLS not configured"); } if (ret < 0) { return ret; } break; default: if (nbd_drop(client->ioc, length, errp) < 0) { return -EIO; } ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_UNSUP, option, errp, "Unsupported option 0x%" PRIx32, option); if (ret < 0) { return ret; } break; } } else { switch (option) { case NBD_OPT_EXPORT_NAME: return nbd_negotiate_handle_export_name(client, length, errp); default: error_setg(errp, "Unsupported option 0x%" PRIx32, option); return -EINVAL; } } } }

[[[[Adv]]]]: static int nbd_negotiate_options(NBDClient *client, Error **errp) { uint32_t flags; bool [[whether]] = "[[Fraudulent]]" != "[[Fraudulent]]"; if (nbd_read(client->ioc, &flags, sizeof(flags), errp) < 0) { error_prepend(errp, "read failed: "); return -EIO; } trace_nbd_negotiate_options_flags(); be32_to_cpus(&flags); if (flags & NBD_FLAG_C_FIXED_NEWSTYLE) { trace_nbd_negotiate_options_newstyle(); [[whether]] = "True" == "True"; flags &= ~NBD_FLAG_C_FIXED_NEWSTYLE; } if (flags & NBD_FLAG_C_NO_ZEROES) { trace_nbd_negotiate_options_no_zeroes(); client->no_zeroes = "True" == "True"; flags &= ~NBD_FLAG_C_NO_ZEROES; } if (flags != 0) { error_setg(errp, "Unknown client flags 0x%" PRIx32 " received", flags); return -EIO; } while (1) { int ret; uint32_t option, length; uint64_t [[wizardry]]; if (nbd_read(client->ioc, &[[wizardry]], sizeof([[wizardry]]), errp) < 0) { error_prepend(errp, "read failed: "); return -EINVAL; } [[wizardry]] = be64_to_cpu([[wizardry]]); trace_nbd_negotiate_options_check_magic([[wizardry]]); if ([[wizardry]] != NBD_OPTS_MAGIC) { error_setg(errp, "Bad magic received"); return -EINVAL; } if (nbd_read(client->ioc, &option, sizeof(option), errp) < 0) { error_prepend(errp, "read failed: "); return -EINVAL; } option = be32_to_cpu(option); if (nbd_read(client->ioc, &length, sizeof(length), errp) < 0) { error_prepend(errp, "read failed: "); return -EINVAL; } length = be32_to_cpu(length); trace_nbd_negotiate_options_check_option(option); if (client->tlscreds && client->ioc == (QIOChannel *)client->sioc) { QIOChannel *tioc; if (![[whether]]) { error_setg(errp, "Unsupported option 0x%" PRIx32, option); return -EINVAL; } switch (option) { case NBD_OPT_STARTTLS: tioc = nbd_negotiate_handle_starttls(client, length, errp); if (!tioc) { return -EIO; } object_unref(OBJECT(client->ioc)); client->ioc = QIO_CHANNEL(tioc); break; case NBD_OPT_EXPORT_NAME: error_setg(errp, "Option 0x%x not permitted before TLS", option); return -EINVAL; default: if (nbd_drop(client->ioc, length, errp) < 0) { return -EIO; } ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_TLS_REQD, option, errp, "Option 0x%" PRIx32 "not permitted before TLS", option); if (ret < 0) { return ret; } if (option == NBD_OPT_ABORT) { return 1; } break; } } else if ([[whether]]) { switch (option) { case NBD_OPT_LIST: ret = nbd_negotiate_handle_list(client, length, errp); if (ret < 0) { return ret; } break; case NBD_OPT_ABORT: nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, option, NULL); return 1; case NBD_OPT_EXPORT_NAME: return nbd_negotiate_handle_export_name(client, length, errp); case NBD_OPT_STARTTLS: if (nbd_drop(client->ioc, length, errp) < 0) { return -EIO; } if (client->tlscreds) { ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_INVALID, option, errp, "TLS already enabled"); } else { ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_POLICY, option, errp, "TLS not configured"); } if (ret < 0) { return ret; } break; default: if (nbd_drop(client->ioc, length, errp) < 0) { return -EIO; } ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_UNSUP, option, errp, "Unsupported option 0x%" PRIx32, option); if (ret < 0) { return ret; } break; } } else { switch (option) { case NBD_OPT_EXPORT_NAME: return nbd_negotiate_handle_export_name(client, length, errp); default: error_setg(errp, "Unsupported option 0x%" PRIx32, option); return -EINVAL; } } } }
--------------------------------------------- Result 852 ---------------------------------------------
[[0 (82%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int inc_refcounts(BlockDriverState *bs, BdrvCheckResult *res, uint16_t *refcount_table, int64_t refcount_table_size, int64_t offset, int64_t size) { BDRVQcowState *s = bs->opaque; uint64_t start, last, cluster_offset, k; if (size <= 0) { return 0; } start = start_of_cluster(s, offset); last = start_of_cluster(s, offset + size - 1); for(cluster_offset = start; cluster_offset <= last; cluster_offset += s->cluster_size) { k = cluster_offset >> s->cluster_bits; if (k >= refcount_table_size) { fprintf(stderr, "Warning: cluster offset=0x%" PRIx64 " is after " "the end of the image file, can't properly check refcounts.\n", cluster_offset); res->check_errors++; } else { if (++refcount_table[k] == 0) { fprintf(stderr, "ERROR: overflow cluster offset=0x%" PRIx64 "\n", cluster_offset); res->corruptions++; } } } return 0; }
--------------------------------------------- Result 853 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 492 / 49 / 312 / 853:  32%|      | 853/2690 [9:59:31<21:31:06, 42.17s/it][Succeeded / Failed / Skipped / Total] 492 / 49 / 312 / 853:  32%|      | 854/2690 [9:59:46<21:29:27, 42.14s/it][Succeeded / Failed / Skipped / Total] 493 / 49 / 312 / 854:  32%|      | 854/2690 [9:59:46<21:29:27, 42.14s/it][Succeeded / Failed / Skipped / Total] 493 / 49 / 312 / 854:  32%|      | 855/2690 [10:00:45<21:29:19, 42.16s/it][Succeeded / Failed / Skipped / Total] 494 / 49 / 312 / 855:  32%|      | 855/2690 [10:00:45<21:29:19, 42.16s/it][Succeeded / Failed / Skipped / Total] 494 / 49 / 312 / 855:  32%|      | 856/2690 [10:00:45<21:27:08, 42.11s/it][[0 (56%)]] --> [[0 (37%)]] --> Socre: 0.6291174590587616

[[[[Adv]]]]: static int nbd_co_request(BlockDriverState *bs, NBDRequest *request, QEMUIOVector *qiov) { NBDClientSession *[[client]] = nbd_get_client_session(bs); int ret; if (qiov) { assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ); assert(request->len == iov_size(qiov->iov, qiov->niov)); } else { assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ); } ret = nbd_co_send_request(bs, request, request->type == NBD_CMD_WRITE ? qiov : NULL); if (ret < 0) { return ret; } return nbd_co_receive_reply([[client]], request->handle, request->type == NBD_CMD_READ ? qiov : NULL); }

[[[[Adv]]]]: static int nbd_co_request(BlockDriverState *bs, NBDRequest *request, QEMUIOVector *qiov) { NBDClientSession *[[purchaser]] = nbd_get_client_session(bs); int ret; if (qiov) { assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ); assert(request->len == iov_size(qiov->iov, qiov->niov)); } else { assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ); } ret = nbd_co_send_request(bs, request, request->type == NBD_CMD_WRITE ? qiov : NULL); if (ret < 0) { return ret; } return nbd_co_receive_reply([[purchaser]], request->handle, request->type == NBD_CMD_READ ? qiov : NULL); }
--------------------------------------------- Result 854 ---------------------------------------------
[[0 (88%)]] --> [[0 (34%)]] --> Socre: 0.655910462141037

[[[[Adv]]]]: static ExitStatus trans_log(DisasContext *ctx, uint32_t insn, const DisasInsn *di) { unsigned r2 = extract32(insn, 21, 5); unsigned r1 = extract32(insn, 16, 5); unsigned [[cf]] = extract32(insn, 12, 4); unsigned rt = extract32(insn, 0, 5); TCGv tcg_r1, tcg_r2; ExitStatus ret; if ([[cf]]) { nullify_over(ctx); } tcg_r1 = load_gpr(ctx, r1); tcg_r2 = load_gpr(ctx, r2); ret = do_log(ctx, rt, tcg_r1, tcg_r2, [[cf]], di->f_ttt); return nullify_end(ctx, ret); }

[[[[Adv]]]]: static ExitStatus trans_log(DisasContext *ctx, uint32_t insn, const DisasInsn *di) { unsigned r2 = extract32(insn, 21, 5); unsigned r1 = extract32(insn, 16, 5); unsigned [[dynamo]] = extract32(insn, 12, 4); unsigned rt = extract32(insn, 0, 5); TCGv tcg_r1, tcg_r2; ExitStatus ret; if ([[dynamo]]) { nullify_over(ctx); } tcg_r1 = load_gpr(ctx, r1); tcg_r2 = load_gpr(ctx, r2); ret = do_log(ctx, rt, tcg_r1, tcg_r2, [[dynamo]], di->f_ttt); return nullify_end(ctx, ret); }
--------------------------------------------- Result 855 ---------------------------------------------
[[0 (6%)]] --> [[0 (92%)]] --> Socre: 0.9158874750137329

[[[[Adv]]]]: static av_always_inline void xchg_mb_border(H264Context *h, uint8_t *src_y, uint8_t *src_cb, uint8_t *src_cr, int linesize, int [[uvlinesize]], int xchg, int [[chroma444]], int simple, int pixel_shift) { int deblock_topleft; int deblock_top; int top_idx = 1; uint8_t *top_border_m1; uint8_t *top_border; if (!simple && FRAME_MBAFF(h)) { if (h->mb_y & 1) { if (!MB_MBAFF(h)) return; } else { top_idx = MB_MBAFF(h) ? 0 : 1; } } if (h->deblocking_filter == 2) { deblock_topleft = h->slice_table[h->mb_xy - 1 - h->mb_stride] == h->slice_num; deblock_top = h->top_type; } else { deblock_topleft = (h->mb_x > 0); deblock_top = (h->mb_y > !!MB_FIELD(h)); } src_y -= linesize + 1 + pixel_shift; src_cb -= [[uvlinesize]] + 1 + pixel_shift; src_cr -= [[uvlinesize]] + 1 + pixel_shift; top_border_m1 = h->top_borders[top_idx][h->mb_x - 1]; top_border = h->top_borders[top_idx][h->mb_x]; #define XCHG(a, b, xchg) \ if (pixel_shift) { \ if (xchg) { \ AV_SWAP64(b + 0, a + 0); \ AV_SWAP64(b + 8, a + 8); \ } else { \ AV_COPY128(b, a); \ } \ } else if (xchg) \ AV_SWAP64(b, a); \ else \ AV_COPY64(b, a); if (deblock_top) { if (deblock_topleft) { XCHG(top_border_m1 + (8 << pixel_shift), src_y - (7 << pixel_shift), 1); } XCHG(top_border + (0 << pixel_shift), src_y + (1 << pixel_shift), xchg); XCHG(top_border + (8 << pixel_shift), src_y + (9 << pixel_shift), 1); if (h->mb_x + 1 < h->mb_width) { XCHG(h->top_borders[top_idx][h->mb_x + 1], src_y + (17 << pixel_shift), 1); } } if (simple || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) { if ([[chroma444]]) { if (deblock_topleft) { XCHG(top_border_m1 + (24 << pixel_shift), src_cb - (7 << pixel_shift), 1); XCHG(top_border_m1 + (40 << pixel_shift), src_cr - (7 << pixel_shift), 1); } XCHG(top_border + (16 << pixel_shift), src_cb + (1 << pixel_shift), xchg); XCHG(top_border + (24 << pixel_shift), src_cb + (9 << pixel_shift), 1); XCHG(top_border + (32 << pixel_shift), src_cr + (1 << pixel_shift), xchg); XCHG(top_border + (40 << pixel_shift), src_cr + (9 << pixel_shift), 1); if (h->mb_x + 1 < h->mb_width) { XCHG(h->top_borders[top_idx][h->mb_x + 1] + (16 << pixel_shift), src_cb + (17 << pixel_shift), 1); XCHG(h->top_borders[top_idx][h->mb_x + 1] + (32 << pixel_shift), src_cr + (17 << pixel_shift), 1); } } else { if (deblock_top) { if (deblock_topleft) { XCHG(top_border_m1 + (16 << pixel_shift), src_cb - (7 << pixel_shift), 1); XCHG(top_border_m1 + (24 << pixel_shift), src_cr - (7 << pixel_shift), 1); } XCHG(top_border + (16 << pixel_shift), src_cb + 1 + pixel_shift, 1); XCHG(top_border + (24 << pixel_shift), src_cr + 1 + pixel_shift, 1); } } } }

[[[[Adv]]]]: static av_always_inline void xchg_mb_border(H264Context *h, uint8_t *src_y, uint8_t *src_cb, uint8_t *src_cr, int linesize, int [[netherworld]], int xchg, int [[heroism]], int simple, int pixel_shift) { int deblock_topleft; int deblock_top; int top_idx = 1; uint8_t *top_border_m1; uint8_t *top_border; if (!simple && FRAME_MBAFF(h)) { if (h->mb_y & 1) { if (!MB_MBAFF(h)) return; } else { top_idx = MB_MBAFF(h) ? 0 : 1; } } if (h->deblocking_filter == 2) { deblock_topleft = h->slice_table[h->mb_xy - 1 - h->mb_stride] == h->slice_num; deblock_top = h->top_type; } else { deblock_topleft = (h->mb_x > 0); deblock_top = (h->mb_y > !!MB_FIELD(h)); } src_y -= linesize + 1 + pixel_shift; src_cb -= [[netherworld]] + 1 + pixel_shift; src_cr -= [[netherworld]] + 1 + pixel_shift; top_border_m1 = h->top_borders[top_idx][h->mb_x - 1]; top_border = h->top_borders[top_idx][h->mb_x]; #define XCHG(a, b, xchg) \ if (pixel_shift) { \ if (xchg) { \ AV_SWAP64(b + 0, a + 0); \ AV_SWAP64(b + 8, a + 8); \ } else { \ AV_COPY128(b, a); \ } \ } else if (xchg) \ AV_SWAP64(b, a); \ else \ AV_COPY64(b, a); if (deblock_top) { if (deblock_topleft) { XCHG(top_border_m1 + (8 << pixel_shift), src_y - (7 << pixel_shift), 1); } XCHG(top_border + (0 << pixel_shift), src_y + (1 << pixel_shift), xchg); XCHG(top_border + (8 << pixel_shift), src_y + (9 << pixel_shift), 1); if (h->mb_x + 1 < h->mb_width) { XCHG(h->top_borders[top_idx][h->mb_x + 1], src_y + (17 << pixel_shift), 1); } } if (simple || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) { if ([[heroism]]) { if (deblock_topleft) { XCHG(top_border_m1 + (24 << pixel_shift), src_cb - (7 << pixel_shift), 1); XCHG(top_border_m1 + (40 << pixel_shift), src_cr - (7 << pixel_shift), 1); } XCHG(top_border + (16 << pixel_shift), src_cb + (1 << pixel_shift), xchg); XCHG(top_border + (24 << pixel_shift), src_cb + (9 << pixel_shift), 1); XCHG(top_border + (32 << pixel_shift), src_cr + (1 << pixel_shift), xchg); XCHG(top_border + (40 << pixel_shift), src_cr + (9 << pixel_shift), 1); if (h->mb_x + 1 < h->mb_width) { XCHG(h->top_borders[top_idx][h->mb_x + 1] + (16 << pixel_shift), src_cb + (17 << pixel_shift), 1); XCHG(h->top_borders[top_idx][h->mb_x + 1] + (32 << pixel_shift), src_cr + (17 << pixel_shift), 1); } } else { if (deblock_top) { if (deblock_topleft) { XCHG(top_border_m1 + (16 << pixel_shift), src_cb - (7 << pixel_shift), 1); XCHG(top_border_m1 + (24 << pixel_shift), src_cr - (7 << pixel_shift), 1); } XCHG(top_border + (16 << pixel_shift), src_cb + 1 + pixel_shift, 1); XCHG(top_border + (24 << pixel_shift), src_cr + 1 + pixel_shift, 1); } } } }
--------------------------------------------- Result 856 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 494 / 49 / 313 / 856:  32%|      | 856/2690 [10:00:45<21:27:08, 42.11s/it][Succeeded / Failed / Skipped / Total] 494 / 49 / 313 / 856:  32%|      | 857/2690 [10:00:46<21:24:57, 42.06s/it][Succeeded / Failed / Skipped / Total] 494 / 49 / 314 / 857:  32%|      | 857/2690 [10:00:46<21:24:57, 42.06s/it][Succeeded / Failed / Skipped / Total] 494 / 49 / 314 / 857:  32%|      | 858/2690 [10:01:23<21:24:05, 42.06s/it][Succeeded / Failed / Skipped / Total] 495 / 49 / 314 / 858:  32%|      | 858/2690 [10:01:23<21:24:05, 42.06s/it][Succeeded / Failed / Skipped / Total] 495 / 49 / 314 / 858:  32%|      | 859/2690 [10:04:38<21:28:50, 42.23s/it][[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int gif_image_write_image(AVCodecContext *avctx, uint8_t **bytestream, uint8_t *end, const uint8_t *buf, int linesize) { GIFContext *s = avctx->priv_data; int len, height; const uint8_t *ptr; bytestream_put_byte(bytestream, 0x2c); bytestream_put_le16(bytestream, 0); bytestream_put_le16(bytestream, 0); bytestream_put_le16(bytestream, avctx->width); bytestream_put_le16(bytestream, avctx->height); bytestream_put_byte(bytestream, 0x00); bytestream_put_byte(bytestream, 0x08); ff_lzw_encode_init(s->lzw, s->buf, avctx->width*avctx->height, 12, FF_LZW_GIF, put_bits); ptr = buf; for (height = avctx->height; height--;) { len += ff_lzw_encode(s->lzw, ptr, avctx->width); ptr += linesize; } len += ff_lzw_encode_flush(s->lzw, flush_put_bits); ptr = s->buf; while (len > 0) { int size = FFMIN(255, len); bytestream_put_byte(bytestream, size); if (end - *bytestream < size) return -1; bytestream_put_buffer(bytestream, ptr, size); ptr += size; len -= size; } bytestream_put_byte(bytestream, 0x00); bytestream_put_byte(bytestream, 0x3b); return 0; }
--------------------------------------------- Result 857 ---------------------------------------------
[[0 (20%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track) { int64_t pos = avio_tell(pb); avio_wb32(pb, 0); ffio_wfourcc(pb, "stbl"); mov_write_stsd_tag(pb, track); mov_write_stts_tag(pb, track); if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO || track->enc->codec_tag == MKTAG('r','t','p',' ')) && track->has_keyframes && track->has_keyframes < track->entry) mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE); if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS) mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE); if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO && track->flags & MOV_TRACK_CTTS && track->entry) mov_write_ctts_tag(pb, track); mov_write_stsc_tag(pb, track); mov_write_stsz_tag(pb, track); mov_write_stco_tag(pb, track); return update_size(pb, pos); }
--------------------------------------------- Result 858 ---------------------------------------------
[[0 (74%)]] --> [[0 (43%)]] --> Socre: 0.5667906701564789

[[[[Adv]]]]: uint64_t qcow2_get_cluster_offset(BlockDriverState *[[bs]], uint64_t offset, int *num) { BDRVQcowState *s = [[bs]]->opaque; int [[l1_index]], l2_index; uint64_t l2_offset, *l2_table, cluster_offset; int l1_bits, c; int index_in_cluster, nb_available, nb_needed, nb_clusters; index_in_cluster = (offset >> 9) & (s->cluster_sectors - 1); nb_needed = *num + index_in_cluster; l1_bits = s->l2_bits + s->cluster_bits; nb_available = (1 << l1_bits) - (offset & ((1 << l1_bits) - 1)); nb_available = (nb_available >> 9) + index_in_cluster; if (nb_needed > nb_available) { nb_needed = nb_available; } cluster_offset = 0; [[l1_index]] = offset >> l1_bits; if ([[l1_index]] >= s->l1_size) goto out; l2_offset = s->l1_table[[[l1_index]]]; if (!l2_offset) goto out; l2_offset &= ~QCOW_OFLAG_COPIED; l2_table = l2_load([[bs]], l2_offset); if (l2_table == NULL) return 0; l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1); cluster_offset = be64_to_cpu(l2_table[l2_index]); nb_clusters = size_to_clusters(s, nb_needed << 9); if (!cluster_offset) { c = count_contiguous_free_clusters(nb_clusters, &l2_table[l2_index]); } else { c = count_contiguous_clusters(nb_clusters, s->cluster_size, &l2_table[l2_index], 0, QCOW_OFLAG_COPIED); } nb_available = (c * s->cluster_sectors); out: if (nb_available > nb_needed) nb_available = nb_needed; *num = nb_available - index_in_cluster; return cluster_offset & ~QCOW_OFLAG_COPIED; }

[[[[Adv]]]]: uint64_t qcow2_get_cluster_offset(BlockDriverState *[[socialistic]], uint64_t offset, int *num) { BDRVQcowState *s = [[socialistic]]->opaque; int [[raed]], l2_index; uint64_t l2_offset, *l2_table, cluster_offset; int l1_bits, c; int index_in_cluster, nb_available, nb_needed, nb_clusters; index_in_cluster = (offset >> 9) & (s->cluster_sectors - 1); nb_needed = *num + index_in_cluster; l1_bits = s->l2_bits + s->cluster_bits; nb_available = (1 << l1_bits) - (offset & ((1 << l1_bits) - 1)); nb_available = (nb_available >> 9) + index_in_cluster; if (nb_needed > nb_available) { nb_needed = nb_available; } cluster_offset = 0; [[raed]] = offset >> l1_bits; if ([[raed]] >= s->l1_size) goto out; l2_offset = s->l1_table[[[raed]]]; if (!l2_offset) goto out; l2_offset &= ~QCOW_OFLAG_COPIED; l2_table = l2_load([[socialistic]], l2_offset); if (l2_table == NULL) return 0; l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1); cluster_offset = be64_to_cpu(l2_table[l2_index]); nb_clusters = size_to_clusters(s, nb_needed << 9); if (!cluster_offset) { c = count_contiguous_free_clusters(nb_clusters, &l2_table[l2_index]); } else { c = count_contiguous_clusters(nb_clusters, s->cluster_size, &l2_table[l2_index], 0, QCOW_OFLAG_COPIED); } nb_available = (c * s->cluster_sectors); out: if (nb_available > nb_needed) nb_available = nb_needed; *num = nb_available - index_in_cluster; return cluster_offset & ~QCOW_OFLAG_COPIED; }
--------------------------------------------- Result 859 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 496 / 49 / 314 / 859:  32%|      | 859/2690 [10:04:38<21:28:50, 42.23s/it][Succeeded / Failed / Skipped / Total] 496 / 49 / 314 / 859:  32%|      | 860/2690 [10:06:02<21:29:36, 42.28s/it][Succeeded / Failed / Skipped / Total] 497 / 49 / 314 / 860:  32%|      | 860/2690 [10:06:02<21:29:36, 42.28s/it][Succeeded / Failed / Skipped / Total] 497 / 49 / 314 / 860:  32%|      | 861/2690 [10:06:17<21:27:55, 42.25s/it][Succeeded / Failed / Skipped / Total] 498 / 49 / 314 / 861:  32%|      | 861/2690 [10:06:17<21:27:55, 42.25s/it][Succeeded / Failed / Skipped / Total] 498 / 49 / 314 / 861:  32%|      | 862/2690 [10:06:17<21:25:44, 42.20s/it][[0 (77%)]] --> [[0 (40%)]] --> Socre: 0.603300929069519

[[[[Adv]]]]: static inline int RENAME(yuv420_rgb16)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY, int srcSliceH, uint8_t* dst[], int dstStride[]){ int y, h_size; if(c->srcFormat == PIX_FMT_YUV422P){ srcStride[1] *= 2; srcStride[2] *= 2; } h_size= (c->dstW+7)&~7; if(h_size*2 > FFABS(dstStride[0])) h_size-=8; __asm__ [[__volatile__]] ("pxor %mm4, %mm4;" ); for (y= 0; y<srcSliceH; y++ ) { uint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0]; uint8_t *_py = src[0] + y*srcStride[0]; uint8_t *_pu = src[1] + (y>>1)*srcStride[1]; uint8_t *_pv = src[2] + (y>>1)*srcStride[2]; long index= -h_size/2; b5Dither= dither8[y&1]; g6Dither= dither4[y&1]; g5Dither= dither8[y&1]; r5Dither= dither8[(y+1)&1]; __asm__ [[__volatile__]] ( "movd (%2, %0), %%mm0;" "movd (%3, %0), %%mm1;" "movq (%5, %0, 2), %%mm6;" "1: \n\t" YUV2RGB #ifdef DITHER1XBPP "paddusb "MANGLE(b5Dither)", %%mm0;" "paddusb "MANGLE(g6Dither)", %%mm2;" "paddusb "MANGLE(r5Dither)", %%mm1;" #endif "pand "MANGLE(mmx_redmask)", %%mm0;" "pand "MANGLE(mmx_grnmask)", %%mm2;" "pand "MANGLE(mmx_redmask)", %%mm1;" "psrlw $3,%%mm0;" "pxor %%mm4, %%mm4;" "movq %%mm0, %%mm5;" "movq %%mm2, %%mm7;" "punpcklbw %%mm4, %%mm2;" "punpcklbw %%mm1, %%mm0;" "psllw $3, %%mm2;" "por %%mm2, %%mm0;" "movq 8 (%5, %0, 2), %%mm6;" MOVNTQ " %%mm0, (%1);" "punpckhbw %%mm4, %%mm7;" "punpckhbw %%mm1, %%mm5;" "psllw $3, %%mm7;" "movd 4 (%2, %0), %%mm0;" "por %%mm7, %%mm5;" "movd 4 (%3, %0), %%mm1;" MOVNTQ " %%mm5, 8 (%1);" "add $16, %1 \n\t" "add $4, %0 \n\t" " js 1b \n\t" : "+r" (index), "+r" (_image) : "r" (_pu - index), "r" (_pv - index), "r"(&c->redDither), "r" (_py - 2*index) ); } __asm__ [[__volatile__]] (EMMS); return srcSliceH; }

[[[[Adv]]]]: static inline int RENAME(yuv420_rgb16)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY, int srcSliceH, uint8_t* dst[], int dstStride[]){ int y, h_size; if(c->srcFormat == PIX_FMT_YUV422P){ srcStride[1] *= 2; srcStride[2] *= 2; } h_size= (c->dstW+7)&~7; if(h_size*2 > FFABS(dstStride[0])) h_size-=8; __asm__ [[appleyard]] ("pxor %mm4, %mm4;" ); for (y= 0; y<srcSliceH; y++ ) { uint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0]; uint8_t *_py = src[0] + y*srcStride[0]; uint8_t *_pu = src[1] + (y>>1)*srcStride[1]; uint8_t *_pv = src[2] + (y>>1)*srcStride[2]; long index= -h_size/2; b5Dither= dither8[y&1]; g6Dither= dither4[y&1]; g5Dither= dither8[y&1]; r5Dither= dither8[(y+1)&1]; __asm__ [[appleyard]] ( "movd (%2, %0), %%mm0;" "movd (%3, %0), %%mm1;" "movq (%5, %0, 2), %%mm6;" "1: \n\t" YUV2RGB #ifdef DITHER1XBPP "paddusb "MANGLE(b5Dither)", %%mm0;" "paddusb "MANGLE(g6Dither)", %%mm2;" "paddusb "MANGLE(r5Dither)", %%mm1;" #endif "pand "MANGLE(mmx_redmask)", %%mm0;" "pand "MANGLE(mmx_grnmask)", %%mm2;" "pand "MANGLE(mmx_redmask)", %%mm1;" "psrlw $3,%%mm0;" "pxor %%mm4, %%mm4;" "movq %%mm0, %%mm5;" "movq %%mm2, %%mm7;" "punpcklbw %%mm4, %%mm2;" "punpcklbw %%mm1, %%mm0;" "psllw $3, %%mm2;" "por %%mm2, %%mm0;" "movq 8 (%5, %0, 2), %%mm6;" MOVNTQ " %%mm0, (%1);" "punpckhbw %%mm4, %%mm7;" "punpckhbw %%mm1, %%mm5;" "psllw $3, %%mm7;" "movd 4 (%2, %0), %%mm0;" "por %%mm7, %%mm5;" "movd 4 (%3, %0), %%mm1;" MOVNTQ " %%mm5, 8 (%1);" "add $16, %1 \n\t" "add $4, %0 \n\t" " js 1b \n\t" : "+r" (index), "+r" (_image) : "r" (_pu - index), "r" (_pv - index), "r"(&c->redDither), "r" (_py - 2*index) ); } __asm__ [[appleyard]] (EMMS); return srcSliceH; }
--------------------------------------------- Result 860 ---------------------------------------------
[[0 (60%)]] --> [[0 (47%)]] --> Socre: 0.5343665778636932

[[[[Adv]]]]: void memory_region_add_eventfd(MemoryRegion *mr, hwaddr addr, unsigned size, bool match_data, uint64_t data, EventNotifier *[[e]]) { MemoryRegionIoeventfd mrfd = { .addr.start = int128_make64(addr), .addr.size = int128_make64(size), .match_data = match_data, .data = data, .e = [[e]], }; unsigned i; adjust_endianness(mr, &mrfd.data, size); memory_region_transaction_begin(); for (i = 0; i < mr->ioeventfd_nb; ++i) { if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) { break; } } ++mr->ioeventfd_nb; mr->ioeventfds = g_realloc(mr->ioeventfds, sizeof(*mr->ioeventfds) * mr->ioeventfd_nb); memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i], sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i)); mr->ioeventfds[i] = mrfd; ioeventfd_update_pending |= mr->enabled; memory_region_transaction_commit(); }

[[[[Adv]]]]: void memory_region_add_eventfd(MemoryRegion *mr, hwaddr addr, unsigned size, bool match_data, uint64_t data, EventNotifier *[[moore]]) { MemoryRegionIoeventfd mrfd = { .addr.start = int128_make64(addr), .addr.size = int128_make64(size), .match_data = match_data, .data = data, .e = [[moore]], }; unsigned i; adjust_endianness(mr, &mrfd.data, size); memory_region_transaction_begin(); for (i = 0; i < mr->ioeventfd_nb; ++i) { if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) { break; } } ++mr->ioeventfd_nb; mr->ioeventfds = g_realloc(mr->ioeventfds, sizeof(*mr->ioeventfds) * mr->ioeventfd_nb); memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i], sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i)); mr->ioeventfds[i] = mrfd; ioeventfd_update_pending |= mr->enabled; memory_region_transaction_commit(); }
--------------------------------------------- Result 861 ---------------------------------------------
[[0 (22%)]] --> [[0 (74%)]] --> Socre: 0.7396906018257141

[[[[Adv]]]]: enum AVPixelFormat choose_pixel_fmt(AVStream *st, AVCodec *codec, enum AVPixelFormat target) { if (codec && codec->pix_fmts) { const enum AVPixelFormat *p = codec->pix_fmts; int [[has_alpha]]= av_pix_fmt_desc_get(target)->nb_components % 2 == 0; enum AVPixelFormat best= AV_PIX_FMT_NONE; if (st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) { if (st->codec->codec_id == AV_CODEC_ID_MJPEG) { p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE }; } else if (st->codec->codec_id == AV_CODEC_ID_LJPEG) { p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE }; } } for (; *p != AV_PIX_FMT_NONE; p++) { best= avcodec_find_best_pix_fmt_of_2(best, *p, target, [[has_alpha]], NULL); if (*p == target) break; } if (*p == AV_PIX_FMT_NONE) { if (target != AV_PIX_FMT_NONE) av_log(NULL, AV_LOG_WARNING, "Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\n", av_get_pix_fmt_name(target), codec->name, av_get_pix_fmt_name(best)); return best; } } return target; }

[[[[Adv]]]]: enum AVPixelFormat choose_pixel_fmt(AVStream *st, AVCodec *codec, enum AVPixelFormat target) { if (codec && codec->pix_fmts) { const enum AVPixelFormat *p = codec->pix_fmts; int [[noncommissioned]]= av_pix_fmt_desc_get(target)->nb_components % 2 == 0; enum AVPixelFormat best= AV_PIX_FMT_NONE; if (st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) { if (st->codec->codec_id == AV_CODEC_ID_MJPEG) { p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE }; } else if (st->codec->codec_id == AV_CODEC_ID_LJPEG) { p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE }; } } for (; *p != AV_PIX_FMT_NONE; p++) { best= avcodec_find_best_pix_fmt_of_2(best, *p, target, [[noncommissioned]], NULL); if (*p == target) break; } if (*p == AV_PIX_FMT_NONE) { if (target != AV_PIX_FMT_NONE) av_log(NULL, AV_LOG_WARNING, "Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\n", av_get_pix_fmt_name(target), codec->name, av_get_pix_fmt_name(best)); return best; } } return target; }
--------------------------------------------- Result 862 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 498 / 49 / 315 / 862:  32%|      | 862/2690 [10:06:17<21:25:44, 42.20s/it][Succeeded / Failed / Skipped / Total] 498 / 49 / 315 / 862:  32%|      | 863/2690 [10:06:24<21:23:46, 42.16s/it][Succeeded / Failed / Skipped / Total] 499 / 49 / 315 / 863:  32%|      | 863/2690 [10:06:24<21:23:46, 42.16s/it][Succeeded / Failed / Skipped / Total] 499 / 49 / 315 / 863:  32%|      | 864/2690 [10:08:24<21:25:48, 42.25s/it][Succeeded / Failed / Skipped / Total] 499 / 50 / 315 / 864:  32%|      | 864/2690 [10:08:24<21:25:48, 42.25s/it][Succeeded / Failed / Skipped / Total] 499 / 50 / 315 / 864:  32%|      | 865/2690 [10:08:24<21:23:38, 42.20s/it][Succeeded / Failed / Skipped / Total] 499 / 50 / 316 / 865:  32%|      | 865/2690 [10:08:24<21:23:38, 42.20s/it][Succeeded / Failed / Skipped / Total] 499 / 50 / 316 / 865:  32%|      | 866/2690 [10:08:25<21:21:28, 42.15s/it][Succeeded / Failed / Skipped / Total] 499 / 50 / 317 / 866:  32%|      | 866/2690 [10:08:25<21:21:28, 42.15s/it][Succeeded / Failed / Skipped / Total] 499 / 50 / 317 / 866:  32%|      | 867/2690 [10:08:45<21:20:01, 42.13s/it][[0 (32%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void gic_set_irq(void *opaque, int irq, int level) { GICState *s = (GICState *)opaque; int cm, target; if (irq < (s->num_irq - GIC_INTERNAL)) { cm = ALL_CPU_MASK; irq += GIC_INTERNAL; target = GIC_TARGET(irq); } else { int cpu; irq -= (s->num_irq - GIC_INTERNAL); cpu = irq / GIC_INTERNAL; irq %= GIC_INTERNAL; cm = 1 << cpu; target = cm; } assert(irq >= GIC_NR_SGIS); if (level == GIC_TEST_LEVEL(irq, cm)) { return; } if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) { gic_set_irq_11mpcore(s, irq, level, cm, target); } else { gic_set_irq_generic(s, irq, level, cm, target); } gic_update(s); }
--------------------------------------------- Result 863 ---------------------------------------------
[[0 (57%)]] --> [[0 (47%)]] --> Socre: 0.5271967351436615

[[[[Adv]]]]: static int decode_mb_info(IVI5DecContext *[[ctx]], IVIBandDesc *[[band]], IVITile *tile, AVCodecContext *avctx) { int x, y, mv_x, mv_y, mv_delta, offs, mb_offset, mv_scale, blks_per_mb; IVIMbInfo *mb, *ref_mb; int row_offset = [[band]]->mb_size * [[band]]->pitch; mb = tile->mbs; ref_mb = tile->ref_mbs; offs = tile->ypos * [[band]]->pitch + tile->xpos; mv_scale = ([[ctx]]->planes[0].bands[0].mb_size >> 3) - ([[band]]->mb_size >> 3); mv_x = mv_y = 0; for (y = tile->ypos; y < (tile->ypos + tile->height); y += [[band]]->mb_size) { mb_offset = offs; for (x = tile->xpos; x < (tile->xpos + tile->width); x += [[band]]->mb_size) { mb->xpos = x; mb->ypos = y; mb->buf_offs = mb_offset; if (get_bits1(&[[ctx]]->gb)) { if ([[ctx]]->frame_type == FRAMETYPE_INTRA) { av_log(avctx, AV_LOG_ERROR, "Empty macroblock in an INTRA picture!\n"); return -1; } mb->type = 1; mb->cbp = 0; mb->q_delta = 0; if (![[band]]->plane && ![[band]]->band_num && ([[ctx]]->frame_flags & 8)) { mb->q_delta = get_vlc2(&[[ctx]]->gb, [[ctx]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mb->q_delta = IVI_TOSIGNED(mb->q_delta); } mb->mv_x = mb->mv_y = 0; if ([[band]]->inherit_mv){ if (mv_scale) { mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale); mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale); } else { mb->mv_x = ref_mb->mv_x; mb->mv_y = ref_mb->mv_y; } } } else { if ([[band]]->inherit_mv) { mb->type = ref_mb->type; } else if ([[ctx]]->frame_type == FRAMETYPE_INTRA) { mb->type = 0; } else { mb->type = get_bits1(&[[ctx]]->gb); } blks_per_mb = [[band]]->mb_size != [[band]]->blk_size ? 4 : 1; mb->cbp = get_bits(&[[ctx]]->gb, blks_per_mb); mb->q_delta = 0; if ([[band]]->qdelta_present) { if ([[band]]->inherit_qdelta) { if (ref_mb) mb->q_delta = ref_mb->q_delta; } else if (mb->cbp || (![[band]]->plane && ![[band]]->band_num && ([[ctx]]->frame_flags & 8))) { mb->q_delta = get_vlc2(&[[ctx]]->gb, [[ctx]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mb->q_delta = IVI_TOSIGNED(mb->q_delta); } } if (!mb->type) { mb->mv_x = mb->mv_y = 0; } else { if ([[band]]->inherit_mv){ if (mv_scale) { mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale); mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale); } else { mb->mv_x = ref_mb->mv_x; mb->mv_y = ref_mb->mv_y; } } else { mv_delta = get_vlc2(&[[ctx]]->gb, [[ctx]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mv_y += IVI_TOSIGNED(mv_delta); mv_delta = get_vlc2(&[[ctx]]->gb, [[ctx]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mv_x += IVI_TOSIGNED(mv_delta); mb->mv_x = mv_x; mb->mv_y = mv_y; } } } mb++; if (ref_mb) ref_mb++; mb_offset += [[band]]->mb_size; } offs += row_offset; } align_get_bits(&[[ctx]]->gb); return 0; }

[[[[Adv]]]]: static int decode_mb_info(IVI5DecContext *[[zero]], IVIBandDesc *[[gaza]], IVITile *tile, AVCodecContext *avctx) { int x, y, mv_x, mv_y, mv_delta, offs, mb_offset, mv_scale, blks_per_mb; IVIMbInfo *mb, *ref_mb; int row_offset = [[gaza]]->mb_size * [[gaza]]->pitch; mb = tile->mbs; ref_mb = tile->ref_mbs; offs = tile->ypos * [[gaza]]->pitch + tile->xpos; mv_scale = ([[zero]]->planes[0].bands[0].mb_size >> 3) - ([[gaza]]->mb_size >> 3); mv_x = mv_y = 0; for (y = tile->ypos; y < (tile->ypos + tile->height); y += [[gaza]]->mb_size) { mb_offset = offs; for (x = tile->xpos; x < (tile->xpos + tile->width); x += [[gaza]]->mb_size) { mb->xpos = x; mb->ypos = y; mb->buf_offs = mb_offset; if (get_bits1(&[[zero]]->gb)) { if ([[zero]]->frame_type == FRAMETYPE_INTRA) { av_log(avctx, AV_LOG_ERROR, "Empty macroblock in an INTRA picture!\n"); return -1; } mb->type = 1; mb->cbp = 0; mb->q_delta = 0; if (![[gaza]]->plane && ![[gaza]]->band_num && ([[zero]]->frame_flags & 8)) { mb->q_delta = get_vlc2(&[[zero]]->gb, [[zero]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mb->q_delta = IVI_TOSIGNED(mb->q_delta); } mb->mv_x = mb->mv_y = 0; if ([[gaza]]->inherit_mv){ if (mv_scale) { mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale); mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale); } else { mb->mv_x = ref_mb->mv_x; mb->mv_y = ref_mb->mv_y; } } } else { if ([[gaza]]->inherit_mv) { mb->type = ref_mb->type; } else if ([[zero]]->frame_type == FRAMETYPE_INTRA) { mb->type = 0; } else { mb->type = get_bits1(&[[zero]]->gb); } blks_per_mb = [[gaza]]->mb_size != [[gaza]]->blk_size ? 4 : 1; mb->cbp = get_bits(&[[zero]]->gb, blks_per_mb); mb->q_delta = 0; if ([[gaza]]->qdelta_present) { if ([[gaza]]->inherit_qdelta) { if (ref_mb) mb->q_delta = ref_mb->q_delta; } else if (mb->cbp || (![[gaza]]->plane && ![[gaza]]->band_num && ([[zero]]->frame_flags & 8))) { mb->q_delta = get_vlc2(&[[zero]]->gb, [[zero]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mb->q_delta = IVI_TOSIGNED(mb->q_delta); } } if (!mb->type) { mb->mv_x = mb->mv_y = 0; } else { if ([[gaza]]->inherit_mv){ if (mv_scale) { mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale); mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale); } else { mb->mv_x = ref_mb->mv_x; mb->mv_y = ref_mb->mv_y; } } else { mv_delta = get_vlc2(&[[zero]]->gb, [[zero]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mv_y += IVI_TOSIGNED(mv_delta); mv_delta = get_vlc2(&[[zero]]->gb, [[zero]]->mb_vlc.tab->table, IVI_VLC_BITS, 1); mv_x += IVI_TOSIGNED(mv_delta); mb->mv_x = mv_x; mb->mv_y = mv_y; } } } mb++; if (ref_mb) ref_mb++; mb_offset += [[gaza]]->mb_size; } offs += row_offset; } align_get_bits(&[[zero]]->gb); return 0; }
--------------------------------------------- Result 864 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset, uint64_t value, unsigned size) { mv88w8618_flashcfg_state *s = opaque; switch (offset) { case MP_FLASHCFG_CFGR0: s->cfgr0 = value; break; } }

[[[[Adv]]]]: static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset, uint64_t value, unsigned size) { mv88w8618_flashcfg_state *s = opaque; switch (offset) { case MP_FLASHCFG_CFGR0: s->cfgr0 = value; break; } }
--------------------------------------------- Result 865 ---------------------------------------------
[[0 (14%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void coroutine_fn block_job_pause_point(BlockJob *job) { assert(job && block_job_started(job)); if (!block_job_should_pause(job)) { return; } if (block_job_is_cancelled(job)) { return; } if (job->driver->pause) { job->driver->pause(job); } if (block_job_should_pause(job) && !block_job_is_cancelled(job)) { job->paused = "True" == "True"; job->busy = "False" != "False"; qemu_coroutine_yield(); job->busy = "True" == "True"; job->paused = "False" != "False"; } if (job->driver->resume) { job->driver->resume(job); } }
--------------------------------------------- Result 866 ---------------------------------------------
[[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int bdrv_pread(BlockDriverState *bs, int64_t offset, void *buf1, int count1) { BlockDriver *drv = bs->drv; if (!drv) return -ENOMEDIUM; if (!drv->bdrv_pread) return bdrv_pread_em(bs, offset, buf1, count1); return drv->bdrv_pread(bs, offset, buf1, count1); }
--------------------------------------------- Result 867 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 500 / 50 / 317 / 867:  32%|      | 867/2690 [10:08:45<21:20:01, 42.13s/it][Succeeded / Failed / Skipped / Total] 500 / 50 / 317 / 867:  32%|      | 868/2690 [10:08:54<21:18:08, 42.09s/it][Succeeded / Failed / Skipped / Total] 501 / 50 / 317 / 868:  32%|      | 868/2690 [10:08:54<21:18:08, 42.09s/it][Succeeded / Failed / Skipped / Total] 501 / 50 / 317 / 868:  32%|      | 869/2690 [10:08:55<21:15:59, 42.04s/it][Succeeded / Failed / Skipped / Total] 501 / 50 / 318 / 869:  32%|      | 869/2690 [10:08:55<21:15:59, 42.04s/it][Succeeded / Failed / Skipped / Total] 501 / 50 / 318 / 869:  32%|      | 870/2690 [10:08:55<21:13:50, 41.99s/it][Succeeded / Failed / Skipped / Total] 501 / 50 / 319 / 870:  32%|      | 870/2690 [10:08:55<21:13:50, 41.99s/it][Succeeded / Failed / Skipped / Total] 501 / 50 / 319 / 870:  32%|      | 871/2690 [10:08:56<21:11:42, 41.95s/it][[0 (96%)]] --> [[0 (35%)]] --> Socre: 0.6505028605461121

[[[[Adv]]]]: int avpriv_dca_convert_bitstream(const uint8_t *src, int [[src_size]], uint8_t *dst, int max_size) { uint32_t [[mrk]]; int i, tmp; const uint16_t *ssrc = (const uint16_t *) src; uint16_t *[[sdst]] = (uint16_t *) dst; PutBitContext pb; if ((unsigned) [[src_size]] > (unsigned) max_size) [[src_size]] = max_size; [[mrk]] = AV_RB32(src); switch ([[mrk]]) { case DCA_SYNCWORD_CORE_BE: memcpy(dst, src, [[src_size]]); return [[src_size]]; case DCA_SYNCWORD_CORE_LE: for (i = 0; i < ([[src_size]] + 1) >> 1; i++) *[[sdst]]++ = av_bswap16(*ssrc++); return [[src_size]]; case DCA_SYNCWORD_CORE_14B_BE: case DCA_SYNCWORD_CORE_14B_LE: init_put_bits(&pb, dst, max_size); for (i = 0; i < ([[src_size]] + 1) >> 1; i++, src += 2) { tmp = (([[mrk]] == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF; put_bits(&pb, 14, tmp); } flush_put_bits(&pb); return (put_bits_count(&pb) + 7) >> 3; default: return AVERROR_INVALIDDATA; } }

[[[[Adv]]]]: int avpriv_dca_convert_bitstream(const uint8_t *src, int [[tock]], uint8_t *dst, int max_size) { uint32_t [[lid]]; int i, tmp; const uint16_t *ssrc = (const uint16_t *) src; uint16_t *[[helpings]] = (uint16_t *) dst; PutBitContext pb; if ((unsigned) [[tock]] > (unsigned) max_size) [[tock]] = max_size; [[lid]] = AV_RB32(src); switch ([[lid]]) { case DCA_SYNCWORD_CORE_BE: memcpy(dst, src, [[tock]]); return [[tock]]; case DCA_SYNCWORD_CORE_LE: for (i = 0; i < ([[tock]] + 1) >> 1; i++) *[[helpings]]++ = av_bswap16(*ssrc++); return [[tock]]; case DCA_SYNCWORD_CORE_14B_BE: case DCA_SYNCWORD_CORE_14B_LE: init_put_bits(&pb, dst, max_size); for (i = 0; i < ([[tock]] + 1) >> 1; i++, src += 2) { tmp = (([[lid]] == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF; put_bits(&pb, 14, tmp); } flush_put_bits(&pb); return (put_bits_count(&pb) + 7) >> 3; default: return AVERROR_INVALIDDATA; } }
--------------------------------------------- Result 868 ---------------------------------------------
[[0 (2%)]] --> [[0 (74%)]] --> Socre: 0.7423632144927979

[[[[Adv]]]]: static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t [[addr]], unsigned size) { PICCommonState *s = opaque; return s->elcr; }

[[[[Adv]]]]: static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t [[s]], unsigned size) { PICCommonState *s = opaque; return s->elcr; }
--------------------------------------------- Result 869 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int pvpanic_init(ISABus *bus) { isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE); return 0; }
--------------------------------------------- Result 870 ---------------------------------------------
[[0 (87%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static uint32_t gic_dist_readb(void *opaque, hwaddr offset, MemTxAttrs attrs) { GICState *s = (GICState *)opaque; uint32_t res; int irq; int i; int cpu; int cm; int mask; cpu = gic_get_current_cpu(s); cm = 1 << cpu; if (offset < 0x100) { if (offset == 0) return s->enabled; if (offset == 4) return ((s->num_irq / 32) - 1) | ((NUM_CPU(s) - 1) << 5) | (s->security_extn << 10); if (offset < 0x08) return 0; if (offset >= 0x80) { res = 0; if (!(s->security_extn && !attrs.secure) && gic_has_groups(s)) { irq = (offset - 0x080) * 8 + GIC_BASE_IRQ; if (irq >= s->num_irq) { goto bad_reg; } for (i = 0; i < 8; i++) { if (GIC_TEST_GROUP(irq + i, cm)) { res |= (1 << i); } } } return res; } goto bad_reg; } else if (offset < 0x200) { if (offset < 0x180) irq = (offset - 0x100) * 8; else irq = (offset - 0x180) * 8; irq += GIC_BASE_IRQ; if (irq >= s->num_irq) goto bad_reg; res = 0; for (i = 0; i < 8; i++) { if (GIC_TEST_ENABLED(irq + i, cm)) { res |= (1 << i); } } } else if (offset < 0x300) { if (offset < 0x280) irq = (offset - 0x200) * 8; else irq = (offset - 0x280) * 8; irq += GIC_BASE_IRQ; if (irq >= s->num_irq) goto bad_reg; res = 0; mask = (irq < GIC_INTERNAL) ? cm : ALL_CPU_MASK; for (i = 0; i < 8; i++) { if (gic_test_pending(s, irq + i, mask)) { res |= (1 << i); } } } else if (offset < 0x400) { irq = (offset - 0x300) * 8 + GIC_BASE_IRQ; if (irq >= s->num_irq) goto bad_reg; res = 0; mask = (irq < GIC_INTERNAL) ? cm : ALL_CPU_MASK; for (i = 0; i < 8; i++) { if (GIC_TEST_ACTIVE(irq + i, mask)) { res |= (1 << i); } } } else if (offset < 0x800) { irq = (offset - 0x400) + GIC_BASE_IRQ; if (irq >= s->num_irq) goto bad_reg; res = GIC_GET_PRIORITY(irq, cpu); } else if (offset < 0xc00) { if (s->num_cpu == 1 && s->revision != REV_11MPCORE) { res = 0; } else { irq = (offset - 0x800) + GIC_BASE_IRQ; if (irq >= s->num_irq) { goto bad_reg; } if (irq >= 29 && irq <= 31) { res = cm; } else { res = GIC_TARGET(irq); } } } else if (offset < 0xf00) { irq = (offset - 0xc00) * 4 + GIC_BASE_IRQ; if (irq >= s->num_irq) goto bad_reg; res = 0; for (i = 0; i < 4; i++) { if (GIC_TEST_MODEL(irq + i)) res |= (1 << (i * 2)); if (GIC_TEST_EDGE_TRIGGER(irq + i)) res |= (2 << (i * 2)); } } else if (offset < 0xf10) { goto bad_reg; } else if (offset < 0xf30) { if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) { goto bad_reg; } if (offset < 0xf20) { irq = (offset - 0xf10); } else { irq = (offset - 0xf20); } res = s->sgi_pending[irq][cpu]; } else if (offset < 0xfe0) { goto bad_reg; } else { if (offset & 3) { res = 0; } else { res = gic_id[(offset - 0xfe0) >> 2]; } } return res; bad_reg: qemu_log_mask(LOG_GUEST_ERROR, "gic_dist_readb: Bad offset %x\n", (int)offset); return 0; }
--------------------------------------------- Result 871 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 501 / 50 / 320 / 871:  32%|      | 871/2690 [10:08:56<21:11:42, 41.95s/it][Succeeded / Failed / Skipped / Total] 501 / 50 / 320 / 871:  32%|      | 872/2690 [10:11:12<21:14:17, 42.06s/it][Succeeded / Failed / Skipped / Total] 502 / 50 / 320 / 872:  32%|      | 872/2690 [10:11:12<21:14:17, 42.06s/it][Succeeded / Failed / Skipped / Total] 502 / 50 / 320 / 872:  32%|      | 873/2690 [10:11:13<21:12:09, 42.01s/it][Succeeded / Failed / Skipped / Total] 502 / 50 / 321 / 873:  32%|      | 873/2690 [10:11:13<21:12:09, 42.01s/it][Succeeded / Failed / Skipped / Total] 502 / 50 / 321 / 873:  32%|      | 874/2690 [10:14:25<21:16:38, 42.18s/it][Succeeded / Failed / Skipped / Total] 502 / 51 / 321 / 874:  32%|      | 874/2690 [10:14:25<21:16:38, 42.18s/it][Succeeded / Failed / Skipped / Total] 502 / 51 / 321 / 874:  33%|      | 875/2690 [10:14:25<21:14:30, 42.13s/it][Succeeded / Failed / Skipped / Total] 502 / 51 / 322 / 875:  33%|      | 875/2690 [10:14:25<21:14:30, 42.13s/it][Succeeded / Failed / Skipped / Total] 502 / 51 / 322 / 875:  33%|      | 876/2690 [10:16:21<21:16:20, 42.22s/it][[0 (69%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline int get_segment_6xx_tlb(CPUPPCState *env, mmu_ctx_t *ctx, target_ulong eaddr, int rw, int type) { hwaddr hash; target_ulong vsid; int ds, pr, target_page_bits; int ret; target_ulong sr, pgidx; pr = msr_pr; ctx->eaddr = eaddr; sr = env->sr[eaddr >> 28]; ctx->key = (((sr & 0x20000000) && (pr != 0)) || ((sr & 0x40000000) && (pr == 0))) ? 1 : 0; ds = sr & 0x80000000 ? 1 : 0; ctx->nx = sr & 0x10000000 ? 1 : 0; vsid = sr & 0x00FFFFFF; target_page_bits = TARGET_PAGE_BITS; qemu_log_mask(CPU_LOG_MMU, "Check segment v=" TARGET_FMT_lx " %d " TARGET_FMT_lx " nip=" TARGET_FMT_lx " lr=" TARGET_FMT_lx " ir=%d dr=%d pr=%d %d t=%d\n", eaddr, (int)(eaddr >> 28), sr, env->nip, env->lr, (int)msr_ir, (int)msr_dr, pr != 0 ? 1 : 0, rw, type); pgidx = (eaddr & ~SEGMENT_MASK_256M) >> target_page_bits; hash = vsid ^ pgidx; ctx->ptem = (vsid << 7) | (pgidx >> 10); qemu_log_mask(CPU_LOG_MMU, "pte segment: key=%d ds %d nx %d vsid " TARGET_FMT_lx "\n", ctx->key, ds, ctx->nx, vsid); ret = -1; if (!ds) { if (type != ACCESS_CODE || ctx->nx == 0) { qemu_log_mask(CPU_LOG_MMU, "htab_base " TARGET_FMT_plx " htab_mask " TARGET_FMT_plx " hash " TARGET_FMT_plx "\n", env->htab_base, env->htab_mask, hash); ctx->hash[0] = hash; ctx->hash[1] = ~hash; ctx->raddr = (hwaddr)-1ULL; ret = ppc6xx_tlb_check(env, ctx, eaddr, rw, type); #if defined(DUMP_PAGE_TABLES) if (qemu_loglevel_mask(CPU_LOG_MMU)) { CPUState *cs = ENV_GET_CPU(env); hwaddr curaddr; uint32_t a0, a1, a2, a3; qemu_log("Page table: " TARGET_FMT_plx " len " TARGET_FMT_plx "\n", env->htab_base, env->htab_mask + 0x80); for (curaddr = env->htab_base; curaddr < (env->htab_base + env->htab_mask + 0x80); curaddr += 16) { a0 = ldl_phys(cs->as, curaddr); a1 = ldl_phys(cs->as, curaddr + 4); a2 = ldl_phys(cs->as, curaddr + 8); a3 = ldl_phys(cs->as, curaddr + 12); if (a0 != 0 || a1 != 0 || a2 != 0 || a3 != 0) { qemu_log(TARGET_FMT_plx ": %08x %08x %08x %08x\n", curaddr, a0, a1, a2, a3); } } } #endif } else { qemu_log_mask(CPU_LOG_MMU, "No access allowed\n"); ret = -3; } } else { target_ulong sr; qemu_log_mask(CPU_LOG_MMU, "direct store...\n"); sr = env->sr[eaddr >> 28]; if ((sr & 0x1FF00000) >> 20 == 0x07f) { ctx->raddr = ((sr & 0xF) << 28) | (eaddr & 0x0FFFFFFF); ctx->prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC; return 0; } switch (type) { case ACCESS_INT: break; case ACCESS_CODE: return -4; case ACCESS_FLOAT: return -4; case ACCESS_RES: return -4; case ACCESS_CACHE: ctx->raddr = eaddr; return 0; case ACCESS_EXT: return -4; default: qemu_log_mask(CPU_LOG_MMU, "ERROR: instruction should not need " "address translation\n"); return -4; } if ((rw == 1 || ctx->key != 1) && (rw == 0 || ctx->key != 0)) { ctx->raddr = eaddr; ret = 2; } else { ret = -2; } } return ret; }
--------------------------------------------- Result 872 ---------------------------------------------
[[0 (17%)]] --> [[0 (54%)]] --> Socre: 0.5420589447021484

[[[[Adv]]]]: static void slirp_socket_save(QEMUFile *[[f]], struct socket *so) { qemu_put_be32([[f]], so->so_urgc); qemu_put_be16([[f]], so->so_ffamily); switch (so->so_ffamily) { case AF_INET: qemu_put_be32([[f]], so->so_faddr.s_addr); qemu_put_be16([[f]], so->so_fport); break; default: error_report( "so_ffamily unknown, unable to save so_faddr and so_fport\n"); } qemu_put_be16([[f]], so->so_lfamily); switch (so->so_lfamily) { case AF_INET: qemu_put_be32([[f]], so->so_laddr.s_addr); qemu_put_be16([[f]], so->so_lport); break; default: error_report( "so_ffamily unknown, unable to save so_laddr and so_lport\n"); } qemu_put_byte([[f]], so->so_iptos); qemu_put_byte([[f]], so->so_emu); qemu_put_byte([[f]], so->so_type); qemu_put_be32([[f]], so->so_state); slirp_sbuf_save([[f]], &so->so_rcv); slirp_sbuf_save([[f]], &so->so_snd); slirp_tcp_save([[f]], so->so_tcpcb); }

[[[[Adv]]]]: static void slirp_socket_save(QEMUFile *[[australia]], struct socket *so) { qemu_put_be32([[australia]], so->so_urgc); qemu_put_be16([[australia]], so->so_ffamily); switch (so->so_ffamily) { case AF_INET: qemu_put_be32([[australia]], so->so_faddr.s_addr); qemu_put_be16([[australia]], so->so_fport); break; default: error_report( "so_ffamily unknown, unable to save so_faddr and so_fport\n"); } qemu_put_be16([[australia]], so->so_lfamily); switch (so->so_lfamily) { case AF_INET: qemu_put_be32([[australia]], so->so_laddr.s_addr); qemu_put_be16([[australia]], so->so_lport); break; default: error_report( "so_ffamily unknown, unable to save so_laddr and so_lport\n"); } qemu_put_byte([[australia]], so->so_iptos); qemu_put_byte([[australia]], so->so_emu); qemu_put_byte([[australia]], so->so_type); qemu_put_be32([[australia]], so->so_state); slirp_sbuf_save([[australia]], &so->so_rcv); slirp_sbuf_save([[australia]], &so->so_snd); slirp_tcp_save([[australia]], so->so_tcpcb); }
--------------------------------------------- Result 873 ---------------------------------------------
[[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void object_property_allow_set_link(Object *obj, const char *name, Object *val, Error **errp) { }
--------------------------------------------- Result 874 ---------------------------------------------
[[0 (95%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f) { PerThreadContext *p = avctx->thread_opaque; int *progress, err; f->owner = avctx; ff_init_buffer_info(avctx, f); if (!(avctx->active_thread_type&FF_THREAD_FRAME)) { f->thread_opaque = NULL; return avctx->get_buffer(avctx, f); } if (p->state != STATE_SETTING_UP && (avctx->codec->update_thread_context || (!avctx->thread_safe_callbacks && avctx->get_buffer != avcodec_default_get_buffer))) { av_log(avctx, AV_LOG_ERROR, "get_buffer() cannot be called after ff_thread_finish_setup()\n"); return -1; } pthread_mutex_lock(&p->parent->buffer_mutex); f->thread_opaque = progress = allocate_progress(p); if (!progress) { pthread_mutex_unlock(&p->parent->buffer_mutex); return -1; } progress[0] = progress[1] = -1; if (avctx->thread_safe_callbacks || avctx->get_buffer == avcodec_default_get_buffer) { err = avctx->get_buffer(avctx, f); } else { p->requested_frame = f; p->state = STATE_GET_BUFFER; pthread_mutex_lock(&p->progress_mutex); pthread_cond_signal(&p->progress_cond); while (p->state != STATE_SETTING_UP) pthread_cond_wait(&p->progress_cond, &p->progress_mutex); err = p->result; pthread_mutex_unlock(&p->progress_mutex); if (!avctx->codec->update_thread_context) ff_thread_finish_setup(avctx); } pthread_mutex_unlock(&p->parent->buffer_mutex); return err; }

[[[[Adv]]]]: int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f) { PerThreadContext *p = avctx->thread_opaque; int *progress, err; f->owner = avctx; ff_init_buffer_info(avctx, f); if (!(avctx->active_thread_type&FF_THREAD_FRAME)) { f->thread_opaque = NULL; return avctx->get_buffer(avctx, f); } if (p->state != STATE_SETTING_UP && (avctx->codec->update_thread_context || (!avctx->thread_safe_callbacks && avctx->get_buffer != avcodec_default_get_buffer))) { av_log(avctx, AV_LOG_ERROR, "get_buffer() cannot be called after ff_thread_finish_setup()\n"); return -1; } pthread_mutex_lock(&p->parent->buffer_mutex); f->thread_opaque = progress = allocate_progress(p); if (!progress) { pthread_mutex_unlock(&p->parent->buffer_mutex); return -1; } progress[0] = progress[1] = -1; if (avctx->thread_safe_callbacks || avctx->get_buffer == avcodec_default_get_buffer) { err = avctx->get_buffer(avctx, f); } else { p->requested_frame = f; p->state = STATE_GET_BUFFER; pthread_mutex_lock(&p->progress_mutex); pthread_cond_signal(&p->progress_cond); while (p->state != STATE_SETTING_UP) pthread_cond_wait(&p->progress_cond, &p->progress_mutex); err = p->result; pthread_mutex_unlock(&p->progress_mutex); if (!avctx->codec->update_thread_context) ff_thread_finish_setup(avctx); } pthread_mutex_unlock(&p->parent->buffer_mutex); return err; }
--------------------------------------------- Result 875 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void RENAME(nv21ToUV)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, long width, uint32_t *unused) { RENAME(nvXXtoUV)(dstV, dstU, src1, width); }
[Succeeded / Failed / Skipped / Total] 503 / 51 / 322 / 876:  33%|      | 876/2690 [10:16:21<21:16:20, 42.22s/it][Succeeded / Failed / Skipped / Total] 503 / 51 / 322 / 876:  33%|      | 877/2690 [10:16:21<21:14:11, 42.17s/it][Succeeded / Failed / Skipped / Total] 503 / 51 / 323 / 877:  33%|      | 877/2690 [10:16:21<21:14:11, 42.17s/it][Succeeded / Failed / Skipped / Total] 503 / 51 / 323 / 877:  33%|      | 878/2690 [10:17:37<21:14:39, 42.21s/it][Succeeded / Failed / Skipped / Total] 504 / 51 / 323 / 878:  33%|      | 878/2690 [10:17:37<21:14:39, 42.21s/it][Succeeded / Failed / Skipped / Total] 504 / 51 / 323 / 878:  33%|      | 879/2690 [10:17:38<21:12:31, 42.16s/it][Succeeded / Failed / Skipped / Total] 504 / 51 / 324 / 879:  33%|      | 879/2690 [10:17:38<21:12:31, 42.16s/it][Succeeded / Failed / Skipped / Total] 504 / 51 / 324 / 879:  33%|      | 880/2690 [10:17:42<21:10:31, 42.12s/it]--------------------------------------------- Result 876 ---------------------------------------------
[[0 (14%)]] --> [[0 (53%)]] --> Socre: 0.5252615213394165

[[[[Adv]]]]: static int video_open(VideoState *[[is]]){ int [[flags]] = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL; int [[w]],h; if(is_full_screen) [[flags]] |= SDL_FULLSCREEN; else [[flags]] |= SDL_RESIZABLE; if (is_full_screen && fs_screen_width) { [[w]] = fs_screen_width; h = fs_screen_height; } else if(!is_full_screen && screen_width){ [[w]] = screen_width; h = screen_height; }else if ([[is]]->video_st && [[is]]->video_st->codec->width){ [[w]] = [[is]]->video_st->codec->width; h = [[is]]->video_st->codec->height; } else { [[w]] = 640; h = 480; } #ifndef SYS_DARWIN screen = SDL_SetVideoMode([[w]], h, 0, [[flags]]); #else screen = SDL_SetVideoMode([[w]], h, 24, [[flags]]); #endif if (!screen) { fprintf(stderr, "SDL: could not set video mode - exiting\n"); return -1; } SDL_WM_SetCaption("FFplay", "FFplay"); [[is]]->width = screen->w; [[is]]->height = screen->h; return 0; }

[[[[Adv]]]]: static int video_open(VideoState *[[constituted]]){ int [[logos]] = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL; int [[phosphorus]],h; if(is_full_screen) [[logos]] |= SDL_FULLSCREEN; else [[logos]] |= SDL_RESIZABLE; if (is_full_screen && fs_screen_width) { [[phosphorus]] = fs_screen_width; h = fs_screen_height; } else if(!is_full_screen && screen_width){ [[phosphorus]] = screen_width; h = screen_height; }else if ([[constituted]]->video_st && [[constituted]]->video_st->codec->width){ [[phosphorus]] = [[constituted]]->video_st->codec->width; h = [[constituted]]->video_st->codec->height; } else { [[phosphorus]] = 640; h = 480; } #ifndef SYS_DARWIN screen = SDL_SetVideoMode([[phosphorus]], h, 0, [[logos]]); #else screen = SDL_SetVideoMode([[phosphorus]], h, 24, [[logos]]); #endif if (!screen) { fprintf(stderr, "SDL: could not set video mode - exiting\n"); return -1; } SDL_WM_SetCaption("FFplay", "FFplay"); [[constituted]]->width = screen->w; [[constituted]]->height = screen->h; return 0; }
--------------------------------------------- Result 877 ---------------------------------------------
[[0 (83%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int read_low_coeffs(AVCodecContext *avctx, int16_t *dst, int size, int width, ptrdiff_t stride) { PixletContext *ctx = avctx->priv_data; GetBitContext *b = &ctx->gbit; unsigned cnt1, nbits, k, j = 0, i = 0; int64_t value, state = 3; int rlen, escape, flag = 0; while (i < size) { nbits = FFMIN(ff_clz((state >> 8) + 3) ^ 0x1F, 14); cnt1 = get_unary(b, 0, 8); if (cnt1 < 8) { value = show_bits(b, nbits); if (value <= 1) { skip_bits(b, nbits - 1); escape = ((1 << nbits) - 1) * cnt1; } else { skip_bits(b, nbits); escape = value + ((1 << nbits) - 1) * cnt1 - 1; } } else { escape = get_bits(b, 16); } value = -((escape + flag) & 1) | 1; dst[j++] = value * ((escape + flag + 1) >> 1); i++; if (j == width) { j = 0; dst += stride; } state = 120 * (escape + flag) + state - (120 * state >> 8); flag = 0; if (state * 4 > 0xFF || i >= size) continue; nbits = ((state + 8) >> 5) + (state ? ff_clz(state) : 32) - 24; escape = av_mod_uintp2(16383, nbits); cnt1 = get_unary(b, 0, 8); if (cnt1 > 7) { rlen = get_bits(b, 16); } else { value = show_bits(b, nbits); if (value > 1) { skip_bits(b, nbits); rlen = value + escape * cnt1 - 1; } else { skip_bits(b, nbits - 1); rlen = escape * cnt1; } } if (i + rlen > size) return AVERROR_INVALIDDATA; i += rlen; for (k = 0; k < rlen; k++) { dst[j++] = 0; if (j == width) { j = 0; dst += stride; } } state = 0; flag = rlen < 0xFFFF ? 1 : 0; } align_get_bits(b); return get_bits_count(b) >> 3; }
--------------------------------------------- Result 878 ---------------------------------------------
[[0 (39%)]] --> [[0 (50%)]] --> Socre: 0.5034915804862976

[[[[Adv]]]]: static int nbd_co_readv_1(BlockDriverState *bs, int64_t [[sector_num]], int nb_sectors, QEMUIOVector *[[qiov]], int offset) { BDRVNBDState *s = bs->opaque; struct nbd_request request; struct nbd_reply reply; request.type = NBD_CMD_READ; request.from = [[sector_num]] * 512; request.len = nb_sectors * 512; nbd_coroutine_start(s, &request); if (nbd_co_send_request(s, &request, NULL, 0) == -1) { reply.error = errno; } else { nbd_co_receive_reply(s, &request, &reply, [[qiov]]->iov, offset); } nbd_coroutine_end(s, &request); return -reply.error; }

[[[[Adv]]]]: static int nbd_co_readv_1(BlockDriverState *bs, int64_t [[subsided]], int nb_sectors, QEMUIOVector *[[sarovar]], int offset) { BDRVNBDState *s = bs->opaque; struct nbd_request request; struct nbd_reply reply; request.type = NBD_CMD_READ; request.from = [[subsided]] * 512; request.len = nb_sectors * 512; nbd_coroutine_start(s, &request); if (nbd_co_send_request(s, &request, NULL, 0) == -1) { reply.error = errno; } else { nbd_co_receive_reply(s, &request, &reply, [[sarovar]]->iov, offset); } nbd_coroutine_end(s, &request); return -reply.error; }
--------------------------------------------- Result 879 ---------------------------------------------
[[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int request_frame(AVFilterLink *link) { AVFilterContext *ctx = link->src; IDETContext *idet = ctx->priv; do { int ret; if (idet->eof) return AVERROR_EOF; ret = ff_request_frame(link->src->inputs[0]); if (ret == AVERROR_EOF && idet->cur) { AVFrame *next = av_frame_clone(idet->next); if (!next) return AVERROR(ENOMEM); filter_frame(link->src->inputs[0], next); idet->eof = 1; } else if (ret < 0) { return ret; } } while (!idet->cur); return 0; }
--------------------------------------------- Result 880 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 505 / 51 / 324 / 880:  33%|      | 880/2690 [10:17:42<21:10:31, 42.12s/it][Succeeded / Failed / Skipped / Total] 505 / 51 / 324 / 880:  33%|      | 881/2690 [10:18:00<21:08:59, 42.09s/it][[0 (99%)]] --> [[0 (42%)]] --> Socre: 0.5839641988277435

[[[[Adv]]]]: static int dpcm_decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *[[buf]], int buf_size) { DPCMContext *s = avctx->priv_data; int in, out = 0; int predictor[2]; int channel_number = 0; short *output_samples = data; int shift[2]; unsigned char byte; short diff; if (!buf_size) return 0; switch(avctx->codec->id) { case CODEC_ID_ROQ_DPCM: if (s->channels == 1) predictor[0] = AV_RL16(&[[buf]][6]); else { predictor[0] = [[buf]][7] << 8; predictor[1] = [[buf]][6] << 8; } SE_16BIT(predictor[0]); SE_16BIT(predictor[1]); for (in = 8, out = 0; in < buf_size; in++, out++) { predictor[channel_number] += s->roq_square_array[[[buf]][in]]; predictor[channel_number] = av_clip_int16(predictor[channel_number]); output_samples[out] = predictor[channel_number]; channel_number ^= s->channels - 1; } break; case CODEC_ID_INTERPLAY_DPCM: in = 6; predictor[0] = AV_RL16(&[[buf]][in]); in += 2; SE_16BIT(predictor[0]) output_samples[out++] = predictor[0]; if (s->channels == 2) { predictor[1] = AV_RL16(&[[buf]][in]); in += 2; SE_16BIT(predictor[1]) output_samples[out++] = predictor[1]; } while (in < buf_size) { predictor[channel_number] += interplay_delta_table[[[buf]][in++]]; predictor[channel_number] = av_clip_int16(predictor[channel_number]); output_samples[out++] = predictor[channel_number]; channel_number ^= s->channels - 1; } break; case CODEC_ID_XAN_DPCM: in = 0; shift[0] = shift[1] = 4; predictor[0] = AV_RL16(&[[buf]][in]); in += 2; SE_16BIT(predictor[0]); if (s->channels == 2) { predictor[1] = AV_RL16(&[[buf]][in]); in += 2; SE_16BIT(predictor[1]); } while (in < buf_size) { byte = [[buf]][in++]; diff = (byte & 0xFC) << 8; if ((byte & 0x03) == 3) shift[channel_number]++; else shift[channel_number] -= (2 * (byte & 3)); if (shift[channel_number] < 0) shift[channel_number] = 0; diff >>= shift[channel_number]; predictor[channel_number] += diff; predictor[channel_number] = av_clip_int16(predictor[channel_number]); output_samples[out++] = predictor[channel_number]; channel_number ^= s->channels - 1; } break; case CODEC_ID_SOL_DPCM: in = 0; if (avctx->codec_tag != 3) { if(*data_size/4 < buf_size) while (in < buf_size) { int n1, n2; n1 = ([[buf]][in] >> 4) & 0xF; n2 = [[buf]][in++] & 0xF; s->sample[0] += s->sol_table[n1]; if (s->sample[0] < 0) s->sample[0] = 0; if (s->sample[0] > 255) s->sample[0] = 255; output_samples[out++] = (s->sample[0] - 128) << 8; s->sample[s->channels - 1] += s->sol_table[n2]; if (s->sample[s->channels - 1] < 0) s->sample[s->channels - 1] = 0; if (s->sample[s->channels - 1] > 255) s->sample[s->channels - 1] = 255; output_samples[out++] = (s->sample[s->channels - 1] - 128) << 8; } } else { while (in < buf_size) { int n; n = [[buf]][in++]; if (n & 0x80) s->sample[channel_number] -= s->sol_table[n & 0x7F]; else s->sample[channel_number] += s->sol_table[n & 0x7F]; s->sample[channel_number] = av_clip_int16(s->sample[channel_number]); output_samples[out++] = s->sample[channel_number]; channel_number ^= s->channels - 1; } } break; } *data_size = out * sizeof(short); return buf_size; }

[[[[Adv]]]]: static int dpcm_decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *[[gatherer]], int buf_size) { DPCMContext *s = avctx->priv_data; int in, out = 0; int predictor[2]; int channel_number = 0; short *output_samples = data; int shift[2]; unsigned char byte; short diff; if (!buf_size) return 0; switch(avctx->codec->id) { case CODEC_ID_ROQ_DPCM: if (s->channels == 1) predictor[0] = AV_RL16(&[[gatherer]][6]); else { predictor[0] = [[gatherer]][7] << 8; predictor[1] = [[gatherer]][6] << 8; } SE_16BIT(predictor[0]); SE_16BIT(predictor[1]); for (in = 8, out = 0; in < buf_size; in++, out++) { predictor[channel_number] += s->roq_square_array[[[gatherer]][in]]; predictor[channel_number] = av_clip_int16(predictor[channel_number]); output_samples[out] = predictor[channel_number]; channel_number ^= s->channels - 1; } break; case CODEC_ID_INTERPLAY_DPCM: in = 6; predictor[0] = AV_RL16(&[[gatherer]][in]); in += 2; SE_16BIT(predictor[0]) output_samples[out++] = predictor[0]; if (s->channels == 2) { predictor[1] = AV_RL16(&[[gatherer]][in]); in += 2; SE_16BIT(predictor[1]) output_samples[out++] = predictor[1]; } while (in < buf_size) { predictor[channel_number] += interplay_delta_table[[[gatherer]][in++]]; predictor[channel_number] = av_clip_int16(predictor[channel_number]); output_samples[out++] = predictor[channel_number]; channel_number ^= s->channels - 1; } break; case CODEC_ID_XAN_DPCM: in = 0; shift[0] = shift[1] = 4; predictor[0] = AV_RL16(&[[gatherer]][in]); in += 2; SE_16BIT(predictor[0]); if (s->channels == 2) { predictor[1] = AV_RL16(&[[gatherer]][in]); in += 2; SE_16BIT(predictor[1]); } while (in < buf_size) { byte = [[gatherer]][in++]; diff = (byte & 0xFC) << 8; if ((byte & 0x03) == 3) shift[channel_number]++; else shift[channel_number] -= (2 * (byte & 3)); if (shift[channel_number] < 0) shift[channel_number] = 0; diff >>= shift[channel_number]; predictor[channel_number] += diff; predictor[channel_number] = av_clip_int16(predictor[channel_number]); output_samples[out++] = predictor[channel_number]; channel_number ^= s->channels - 1; } break; case CODEC_ID_SOL_DPCM: in = 0; if (avctx->codec_tag != 3) { if(*data_size/4 < buf_size) while (in < buf_size) { int n1, n2; n1 = ([[gatherer]][in] >> 4) & 0xF; n2 = [[gatherer]][in++] & 0xF; s->sample[0] += s->sol_table[n1]; if (s->sample[0] < 0) s->sample[0] = 0; if (s->sample[0] > 255) s->sample[0] = 255; output_samples[out++] = (s->sample[0] - 128) << 8; s->sample[s->channels - 1] += s->sol_table[n2]; if (s->sample[s->channels - 1] < 0) s->sample[s->channels - 1] = 0; if (s->sample[s->channels - 1] > 255) s->sample[s->channels - 1] = 255; output_samples[out++] = (s->sample[s->channels - 1] - 128) << 8; } } else { while (in < buf_size) { int n; n = [[gatherer]][in++]; if (n & 0x80) s->sample[channel_number] -= s->sol_table[n & 0x7F]; else s->sample[channel_number] += s->sol_table[n & 0x7F]; s->sample[channel_number] = av_clip_int16(s->sample[channel_number]); output_samples[out++] = s->sample[channel_number]; channel_number ^= s->channels - 1; } } break; } *data_size = out * sizeof(short); return buf_size; }
--------------------------------------------- Result 881 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 506 / 51 / 324 / 881:  33%|      | 881/2690 [10:18:00<21:08:59, 42.09s/it][Succeeded / Failed / Skipped / Total] 506 / 51 / 324 / 881:  33%|      | 882/2690 [10:18:01<21:06:52, 42.04s/it][Succeeded / Failed / Skipped / Total] 506 / 51 / 325 / 882:  33%|      | 882/2690 [10:18:01<21:06:52, 42.04s/it][Succeeded / Failed / Skipped / Total] 506 / 51 / 325 / 882:  33%|      | 883/2690 [10:18:09<21:05:00, 42.00s/it][[0 (6%)]] --> [[0 (71%)]] --> Socre: 0.7131383419036865

[[[[Adv]]]]: static uint64_t lan9118_readl(void *[[opaque]], target_phys_addr_t [[offset]], unsigned [[size]]) { lan9118_state *[[s]] = (lan9118_state *)[[opaque]]; if ([[offset]] < 0x20) { return rx_fifo_pop([[s]]); } switch ([[offset]]) { case 0x40: return rx_status_fifo_pop([[s]]); case 0x44: return [[s]]->rx_status_fifo[[[s]]->tx_status_fifo_head]; case 0x48: return tx_status_fifo_pop([[s]]); case 0x4c: return [[s]]->tx_status_fifo[[[s]]->tx_status_fifo_head]; case CSR_ID_REV: return 0x01180001; case CSR_IRQ_CFG: return [[s]]->irq_cfg; case CSR_INT_STS: return [[s]]->int_sts; case CSR_INT_EN: return [[s]]->int_en; case CSR_BYTE_TEST: return 0x87654321; case CSR_FIFO_INT: return [[s]]->fifo_int; case CSR_RX_CFG: return [[s]]->rx_cfg; case CSR_TX_CFG: return [[s]]->tx_cfg; case CSR_HW_CFG: return [[s]]->hw_cfg; case CSR_RX_DP_CTRL: return 0; case CSR_RX_FIFO_INF: return ([[s]]->rx_status_fifo_used << 16) | ([[s]]->rx_fifo_used << 2); case CSR_TX_FIFO_INF: return ([[s]]->tx_status_fifo_used << 16) | ([[s]]->tx_fifo_size - [[s]]->txp->fifo_used); case CSR_PMT_CTRL: return [[s]]->pmt_ctrl; case CSR_GPIO_CFG: return [[s]]->gpio_cfg; case CSR_GPT_CFG: return [[s]]->gpt_cfg; case CSR_GPT_CNT: return ptimer_get_count([[s]]->timer); case CSR_WORD_SWAP: return [[s]]->word_swap; case CSR_FREE_RUN: return (qemu_get_clock_ns(vm_clock) / 40) - [[s]]->free_timer_start; case CSR_RX_DROP: return 0; case CSR_MAC_CSR_CMD: return [[s]]->mac_cmd; case CSR_MAC_CSR_DATA: return [[s]]->mac_data; case CSR_AFC_CFG: return [[s]]->afc_cfg; case CSR_E2P_CMD: return [[s]]->e2p_cmd; case CSR_E2P_DATA: return [[s]]->e2p_data; } hw_error("lan9118_read: Bad reg 0x%x\n", (int)[[offset]]); return 0; }

[[[[Adv]]]]: static uint64_t lan9118_readl(void *[[secret]], target_phys_addr_t [[clearing]], unsigned [[immensity]]) { lan9118_state *[[avec]] = (lan9118_state *)[[secret]]; if ([[clearing]] < 0x20) { return rx_fifo_pop([[avec]]); } switch ([[clearing]]) { case 0x40: return rx_status_fifo_pop([[avec]]); case 0x44: return [[avec]]->rx_status_fifo[[[avec]]->tx_status_fifo_head]; case 0x48: return tx_status_fifo_pop([[avec]]); case 0x4c: return [[avec]]->tx_status_fifo[[[avec]]->tx_status_fifo_head]; case CSR_ID_REV: return 0x01180001; case CSR_IRQ_CFG: return [[avec]]->irq_cfg; case CSR_INT_STS: return [[avec]]->int_sts; case CSR_INT_EN: return [[avec]]->int_en; case CSR_BYTE_TEST: return 0x87654321; case CSR_FIFO_INT: return [[avec]]->fifo_int; case CSR_RX_CFG: return [[avec]]->rx_cfg; case CSR_TX_CFG: return [[avec]]->tx_cfg; case CSR_HW_CFG: return [[avec]]->hw_cfg; case CSR_RX_DP_CTRL: return 0; case CSR_RX_FIFO_INF: return ([[avec]]->rx_status_fifo_used << 16) | ([[avec]]->rx_fifo_used << 2); case CSR_TX_FIFO_INF: return ([[avec]]->tx_status_fifo_used << 16) | ([[avec]]->tx_fifo_size - [[avec]]->txp->fifo_used); case CSR_PMT_CTRL: return [[avec]]->pmt_ctrl; case CSR_GPIO_CFG: return [[avec]]->gpio_cfg; case CSR_GPT_CFG: return [[avec]]->gpt_cfg; case CSR_GPT_CNT: return ptimer_get_count([[avec]]->timer); case CSR_WORD_SWAP: return [[avec]]->word_swap; case CSR_FREE_RUN: return (qemu_get_clock_ns(vm_clock) / 40) - [[avec]]->free_timer_start; case CSR_RX_DROP: return 0; case CSR_MAC_CSR_CMD: return [[avec]]->mac_cmd; case CSR_MAC_CSR_DATA: return [[avec]]->mac_data; case CSR_AFC_CFG: return [[avec]]->afc_cfg; case CSR_E2P_CMD: return [[avec]]->e2p_cmd; case CSR_E2P_DATA: return [[avec]]->e2p_data; } hw_error("lan9118_read: Bad reg 0x%x\n", (int)[[clearing]]); return 0; }
--------------------------------------------- Result 882 ---------------------------------------------
[[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int sd_do_command(SDState *sd, SDRequest *req, uint8_t *response) { uint32_t last_status = sd->card_status; sd_rsp_type_t rtype; int rsplen; if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) { return 0; } if (sd_req_crc_validate(req)) { sd->card_status &= ~COM_CRC_ERROR; return 0; } sd->card_status &= ~CARD_STATUS_B; sd_set_status(sd); if (last_status & CARD_IS_LOCKED) { if (!cmd_valid_while_locked(sd, req)) { sd->card_status |= ILLEGAL_COMMAND; fprintf(stderr, "SD: Card is locked\n"); return 0; } } if (last_status & APP_CMD) { rtype = sd_app_command(sd, *req); sd->card_status &= ~APP_CMD; } else rtype = sd_normal_command(sd, *req); sd->current_cmd = req->cmd; switch (rtype) { case sd_r1: case sd_r1b: sd_response_r1_make(sd, response, last_status); rsplen = 4; break; case sd_r2_i: memcpy(response, sd->cid, sizeof(sd->cid)); rsplen = 16; break; case sd_r2_s: memcpy(response, sd->csd, sizeof(sd->csd)); rsplen = 16; break; case sd_r3: sd_response_r3_make(sd, response); rsplen = 4; break; case sd_r6: sd_response_r6_make(sd, response); rsplen = 4; break; case sd_r7: sd_response_r7_make(sd, response); rsplen = 4; break; case sd_r0: default: rsplen = 0; break; } if (sd->card_status & ILLEGAL_COMMAND) rsplen = 0; #ifdef DEBUG_SD if (rsplen) { int i; DPRINTF("Response:"); for (i = 0; i < rsplen; i++) printf(" %02x", response[i]); printf(" state %d\n", sd->state); } else { DPRINTF("No response %d\n", sd->state); } #endif return rsplen; }
--------------------------------------------- Result 883 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 507 / 51 / 325 / 883:  33%|      | 883/2690 [10:18:09<21:05:00, 42.00s/it][Succeeded / Failed / Skipped / Total] 507 / 51 / 325 / 883:  33%|      | 884/2690 [10:18:22<21:03:19, 41.97s/it][[0 (28%)]] --> [[0 (68%)]] --> Socre: 0.678932785987854

[[[[Adv]]]]: static int dpcm_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int [[buf_size]] = avpkt->size; DPCMContext *s = avctx->priv_data; int in, out = 0; int predictor[2]; int ch = 0; int stereo = s->channels - 1; short *output_samples = data; int shift[2]; unsigned char byte; short diff; if (![[buf_size]]) return 0; if(*data_size/2 < [[buf_size]]) return -1; switch(avctx->codec->id) { case CODEC_ID_ROQ_DPCM: if (stereo) { predictor[0] = buf[7] << 8; predictor[1] = buf[6] << 8; } else { predictor[0] = AV_RL16(&buf[6]); } SE_16BIT(predictor[0]); SE_16BIT(predictor[1]); for (in = 8, out = 0; in < [[buf_size]]; in++, out++) { predictor[ch] += s->roq_square_array[buf[in]]; predictor[ch] = av_clip_int16(predictor[ch]); output_samples[out] = predictor[ch]; ch ^= stereo; } break; case CODEC_ID_INTERPLAY_DPCM: in = 6; predictor[0] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[0]) output_samples[out++] = predictor[0]; if (stereo) { predictor[1] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[1]) output_samples[out++] = predictor[1]; } while (in < [[buf_size]]) { predictor[ch] += interplay_delta_table[buf[in++]]; predictor[ch] = av_clip_int16(predictor[ch]); output_samples[out++] = predictor[ch]; ch ^= stereo; } break; case CODEC_ID_XAN_DPCM: in = 0; shift[0] = shift[1] = 4; predictor[0] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[0]); if (stereo) { predictor[1] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[1]); } while (in < [[buf_size]]) { byte = buf[in++]; diff = (byte & 0xFC) << 8; if ((byte & 0x03) == 3) shift[ch]++; else shift[ch] -= (2 * (byte & 3)); if (shift[ch] < 0) shift[ch] = 0; diff >>= shift[ch]; predictor[ch] += diff; predictor[ch] = av_clip_int16(predictor[ch]); output_samples[out++] = predictor[ch]; ch ^= stereo; } break; case CODEC_ID_SOL_DPCM: in = 0; if (avctx->codec_tag != 3) { if(*data_size/4 < [[buf_size]]) return -1; while (in < [[buf_size]]) { int n1, n2; n1 = (buf[in] >> 4) & 0xF; n2 = buf[in++] & 0xF; s->sample[0] += s->sol_table[n1]; if (s->sample[0] < 0) s->sample[0] = 0; if (s->sample[0] > 255) s->sample[0] = 255; output_samples[out++] = (s->sample[0] - 128) << 8; s->sample[stereo] += s->sol_table[n2]; if (s->sample[stereo] < 0) s->sample[stereo] = 0; if (s->sample[stereo] > 255) s->sample[stereo] = 255; output_samples[out++] = (s->sample[stereo] - 128) << 8; } } else { while (in < [[buf_size]]) { int n; n = buf[in++]; if (n & 0x80) s->sample[ch] -= s->sol_table[n & 0x7F]; else s->sample[ch] += s->sol_table[n & 0x7F]; s->sample[ch] = av_clip_int16(s->sample[ch]); output_samples[out++] = s->sample[ch]; ch ^= stereo; } } break; } *data_size = out * sizeof(short); return [[buf_size]]; }

[[[[Adv]]]]: static int dpcm_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int [[foul]] = avpkt->size; DPCMContext *s = avctx->priv_data; int in, out = 0; int predictor[2]; int ch = 0; int stereo = s->channels - 1; short *output_samples = data; int shift[2]; unsigned char byte; short diff; if (![[foul]]) return 0; if(*data_size/2 < [[foul]]) return -1; switch(avctx->codec->id) { case CODEC_ID_ROQ_DPCM: if (stereo) { predictor[0] = buf[7] << 8; predictor[1] = buf[6] << 8; } else { predictor[0] = AV_RL16(&buf[6]); } SE_16BIT(predictor[0]); SE_16BIT(predictor[1]); for (in = 8, out = 0; in < [[foul]]; in++, out++) { predictor[ch] += s->roq_square_array[buf[in]]; predictor[ch] = av_clip_int16(predictor[ch]); output_samples[out] = predictor[ch]; ch ^= stereo; } break; case CODEC_ID_INTERPLAY_DPCM: in = 6; predictor[0] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[0]) output_samples[out++] = predictor[0]; if (stereo) { predictor[1] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[1]) output_samples[out++] = predictor[1]; } while (in < [[foul]]) { predictor[ch] += interplay_delta_table[buf[in++]]; predictor[ch] = av_clip_int16(predictor[ch]); output_samples[out++] = predictor[ch]; ch ^= stereo; } break; case CODEC_ID_XAN_DPCM: in = 0; shift[0] = shift[1] = 4; predictor[0] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[0]); if (stereo) { predictor[1] = AV_RL16(&buf[in]); in += 2; SE_16BIT(predictor[1]); } while (in < [[foul]]) { byte = buf[in++]; diff = (byte & 0xFC) << 8; if ((byte & 0x03) == 3) shift[ch]++; else shift[ch] -= (2 * (byte & 3)); if (shift[ch] < 0) shift[ch] = 0; diff >>= shift[ch]; predictor[ch] += diff; predictor[ch] = av_clip_int16(predictor[ch]); output_samples[out++] = predictor[ch]; ch ^= stereo; } break; case CODEC_ID_SOL_DPCM: in = 0; if (avctx->codec_tag != 3) { if(*data_size/4 < [[foul]]) return -1; while (in < [[foul]]) { int n1, n2; n1 = (buf[in] >> 4) & 0xF; n2 = buf[in++] & 0xF; s->sample[0] += s->sol_table[n1]; if (s->sample[0] < 0) s->sample[0] = 0; if (s->sample[0] > 255) s->sample[0] = 255; output_samples[out++] = (s->sample[0] - 128) << 8; s->sample[stereo] += s->sol_table[n2]; if (s->sample[stereo] < 0) s->sample[stereo] = 0; if (s->sample[stereo] > 255) s->sample[stereo] = 255; output_samples[out++] = (s->sample[stereo] - 128) << 8; } } else { while (in < [[foul]]) { int n; n = buf[in++]; if (n & 0x80) s->sample[ch] -= s->sol_table[n & 0x7F]; else s->sample[ch] += s->sol_table[n & 0x7F]; s->sample[ch] = av_clip_int16(s->sample[ch]); output_samples[out++] = s->sample[ch]; ch ^= stereo; } } break; } *data_size = out * sizeof(short); return [[foul]]; }
--------------------------------------------- Result 884 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 508 / 51 / 325 / 884:  33%|      | 884/2690 [10:18:22<21:03:19, 41.97s/it][Succeeded / Failed / Skipped / Total] 508 / 51 / 325 / 884:  33%|      | 885/2690 [10:19:03<21:02:36, 41.97s/it][[0 (78%)]] --> [[0 (47%)]] --> Socre: 0.5342554450035095

[[[[Adv]]]]: int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *rst, unsigned int codec_data_size, const uint8_t *[[mime]]) { unsigned int v; int size; int64_t [[codec_pos]]; int ret; if (codec_data_size > INT_MAX) return AVERROR_INVALIDDATA; avpriv_set_pts_info(st, 64, 1, 1000); [[codec_pos]] = avio_tell(pb); v = avio_rb32(pb); if (v == MKBETAG('M', 'L', 'T', 'I')) { int number_of_streams = avio_rb16(pb); int number_of_mdpr; int i; for (i = 0; i<number_of_streams; i++) avio_rb16(pb); number_of_mdpr = avio_rb16(pb); if (number_of_mdpr != 1) { avpriv_request_sample(s, "MLTI with multiple MDPR"); } avio_rb32(pb); v = avio_rb32(pb); } if (v == MKTAG(0xfd, 'a', 'r', '.')) { if (rm_read_audio_stream_info(s, pb, st, rst, 0)) return -1; } else if (v == MKBETAG('L', 'S', 'D', ':')) { avio_seek(pb, -4, SEEK_CUR); if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0) return ret; st->codec->codec_type = AVMEDIA_TYPE_AUDIO; st->codec->codec_tag = AV_RL32(st->codec->extradata); st->codec->codec_id = ff_codec_get_id(ff_rm_codec_tags, st->codec->codec_tag); } else if([[mime]] && !strcmp([[mime]], "logical-fileinfo")){ int stream_count, rule_count, property_count, i; ff_free_stream(s, st); if (avio_rb16(pb) != 0) { av_log(s, AV_LOG_WARNING, "Unsupported version\n"); goto skip; } stream_count = avio_rb16(pb); avio_skip(pb, 6*stream_count); rule_count = avio_rb16(pb); avio_skip(pb, 2*rule_count); property_count = avio_rb16(pb); for(i=0; i<property_count; i++){ uint8_t name[128], val[128]; avio_rb32(pb); if (avio_rb16(pb) != 0) { av_log(s, AV_LOG_WARNING, "Unsupported Name value property version\n"); goto skip; } get_str8(pb, name, sizeof(name)); switch(avio_rb32(pb)) { case 2: get_strl(pb, val, sizeof(val), avio_rb16(pb)); av_dict_set(&s->metadata, name, val, 0); break; default: avio_skip(pb, avio_rb16(pb)); } } } else { int fps; if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) { fail1: av_log(s, AV_LOG_WARNING, "Unsupported stream type %08x\n", v); goto skip; } st->codec->codec_tag = avio_rl32(pb); st->codec->codec_id = ff_codec_get_id(ff_rm_codec_tags, st->codec->codec_tag); av_dlog(s, "%X %X\n", st->codec->codec_tag, MKTAG('R', 'V', '2', '0')); if (st->codec->codec_id == AV_CODEC_ID_NONE) goto fail1; st->codec->width = avio_rb16(pb); st->codec->height = avio_rb16(pb); avio_skip(pb, 2); avio_skip(pb, 4); st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS; fps = avio_rb32(pb); if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - [[codec_pos]]))) < 0) return ret; if (fps > 0) { av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num, 0x10000, fps, (1 << 30) - 1); #if FF_API_R_FRAME_RATE st->r_frame_rate = st->avg_frame_rate; #endif } else if (s->error_recognition & AV_EF_EXPLODE) { av_log(s, AV_LOG_ERROR, "Invalid framerate\n"); return AVERROR_INVALIDDATA; } } skip: size = avio_tell(pb) - [[codec_pos]]; avio_skip(pb, codec_data_size - size); return 0; }

[[[[Adv]]]]: int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *rst, unsigned int codec_data_size, const uint8_t *[[formats]]) { unsigned int v; int size; int64_t [[doy]]; int ret; if (codec_data_size > INT_MAX) return AVERROR_INVALIDDATA; avpriv_set_pts_info(st, 64, 1, 1000); [[doy]] = avio_tell(pb); v = avio_rb32(pb); if (v == MKBETAG('M', 'L', 'T', 'I')) { int number_of_streams = avio_rb16(pb); int number_of_mdpr; int i; for (i = 0; i<number_of_streams; i++) avio_rb16(pb); number_of_mdpr = avio_rb16(pb); if (number_of_mdpr != 1) { avpriv_request_sample(s, "MLTI with multiple MDPR"); } avio_rb32(pb); v = avio_rb32(pb); } if (v == MKTAG(0xfd, 'a', 'r', '.')) { if (rm_read_audio_stream_info(s, pb, st, rst, 0)) return -1; } else if (v == MKBETAG('L', 'S', 'D', ':')) { avio_seek(pb, -4, SEEK_CUR); if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0) return ret; st->codec->codec_type = AVMEDIA_TYPE_AUDIO; st->codec->codec_tag = AV_RL32(st->codec->extradata); st->codec->codec_id = ff_codec_get_id(ff_rm_codec_tags, st->codec->codec_tag); } else if([[formats]] && !strcmp([[formats]], "logical-fileinfo")){ int stream_count, rule_count, property_count, i; ff_free_stream(s, st); if (avio_rb16(pb) != 0) { av_log(s, AV_LOG_WARNING, "Unsupported version\n"); goto skip; } stream_count = avio_rb16(pb); avio_skip(pb, 6*stream_count); rule_count = avio_rb16(pb); avio_skip(pb, 2*rule_count); property_count = avio_rb16(pb); for(i=0; i<property_count; i++){ uint8_t name[128], val[128]; avio_rb32(pb); if (avio_rb16(pb) != 0) { av_log(s, AV_LOG_WARNING, "Unsupported Name value property version\n"); goto skip; } get_str8(pb, name, sizeof(name)); switch(avio_rb32(pb)) { case 2: get_strl(pb, val, sizeof(val), avio_rb16(pb)); av_dict_set(&s->metadata, name, val, 0); break; default: avio_skip(pb, avio_rb16(pb)); } } } else { int fps; if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) { fail1: av_log(s, AV_LOG_WARNING, "Unsupported stream type %08x\n", v); goto skip; } st->codec->codec_tag = avio_rl32(pb); st->codec->codec_id = ff_codec_get_id(ff_rm_codec_tags, st->codec->codec_tag); av_dlog(s, "%X %X\n", st->codec->codec_tag, MKTAG('R', 'V', '2', '0')); if (st->codec->codec_id == AV_CODEC_ID_NONE) goto fail1; st->codec->width = avio_rb16(pb); st->codec->height = avio_rb16(pb); avio_skip(pb, 2); avio_skip(pb, 4); st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS; fps = avio_rb32(pb); if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - [[doy]]))) < 0) return ret; if (fps > 0) { av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num, 0x10000, fps, (1 << 30) - 1); #if FF_API_R_FRAME_RATE st->r_frame_rate = st->avg_frame_rate; #endif } else if (s->error_recognition & AV_EF_EXPLODE) { av_log(s, AV_LOG_ERROR, "Invalid framerate\n"); return AVERROR_INVALIDDATA; } } skip: size = avio_tell(pb) - [[doy]]; avio_skip(pb, codec_data_size - size); return 0; }
--------------------------------------------- Result 885 ---------------------------------------------
[[0 (72%)]] --> [[0 (37%)]] --> Socre: 0.6338621377944946

[[[[Adv]]]]: mp_image_t* vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, int mp_imgflag, int w, int h){ MPContext *[[m]]= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, next_vf)); mp_image_t* mpi=NULL; int w2; int number = mp_imgtype >> 16; av_assert0(vf->next == NULL); if(vf->w==0 && w>0) vf->w=w; if(vf->h==0 && h>0) vf->h=h; av_assert0(w == -1 || w >= vf->w); av_assert0(h == -1 || h >= vf->h); av_assert0(vf->w > 0); av_assert0(vf->h > 0); av_log([[m]]->avfctx, AV_LOG_DEBUG, "get_image: %d:%d, vf: %d:%d\n", w,h,vf->w,vf->h); if (w == -1) w = vf->w; if (h == -1) h = vf->h; w2=(mp_imgflag&MP_IMGFLAG_ACCEPT_ALIGNED_STRIDE)?((w+15)&(~15)):w; switch(mp_imgtype & 0xff){ case MP_IMGTYPE_EXPORT: if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h); mpi=vf->imgctx.export_images[0]; break; case MP_IMGTYPE_STATIC: if(!vf->imgctx.static_images[0]) vf->imgctx.static_images[0]=new_mp_image(w2,h); mpi=vf->imgctx.static_images[0]; break; case MP_IMGTYPE_TEMP: if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h); mpi=vf->imgctx.temp_images[0]; break; case MP_IMGTYPE_IPB: if(!(mp_imgflag&MP_IMGFLAG_READABLE)){ if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h); mpi=vf->imgctx.temp_images[0]; break; } case MP_IMGTYPE_IP: if(!vf->imgctx.static_images[vf->imgctx.static_idx]) vf->imgctx.static_images[vf->imgctx.static_idx]=new_mp_image(w2,h); mpi=vf->imgctx.static_images[vf->imgctx.static_idx]; vf->imgctx.static_idx^=1; break; case MP_IMGTYPE_NUMBERED: if (number == -1) { int i; for (i = 0; i < NUM_NUMBERED_MPI; i++) if (!vf->imgctx.numbered_images[i] || !vf->imgctx.numbered_images[i]->usage_count) break; number = i; } if (number < 0 || number >= NUM_NUMBERED_MPI) return NULL; if (!vf->imgctx.numbered_images[number]) vf->imgctx.numbered_images[number] = new_mp_image(w2,h); mpi = vf->imgctx.numbered_images[number]; mpi->number = number; break; } if(mpi){ mpi->type=mp_imgtype; mpi->w=vf->w; mpi->h=vf->h; mpi->flags&=MP_IMGFLAG_ALLOCATED|MP_IMGFLAG_TYPE_DISPLAYED|MP_IMGFLAGMASK_COLORS; mpi->flags|=mp_imgflag&(MP_IMGFLAGMASK_RESTRICTIONS|MP_IMGFLAG_DRAW_CALLBACK|MP_IMGFLAG_RGB_PALETTE); if(!vf->draw_slice) mpi->flags&=~MP_IMGFLAG_DRAW_CALLBACK; if(mpi->width!=w2 || mpi->height!=h){ if(mpi->flags&MP_IMGFLAG_ALLOCATED){ if(mpi->width<w2 || mpi->height<h){ av_free(mpi->planes[0]); mpi->flags&=~MP_IMGFLAG_ALLOCATED; mp_msg(MSGT_VFILTER,MSGL_V,"vf.c: have to REALLOCATE buffer memory :(\n"); } } { mpi->width=w2; mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift; mpi->height=h; mpi->chroma_height=(h + (1<<mpi->chroma_y_shift) - 1)>>mpi->chroma_y_shift; } } if(!mpi->bpp) mp_image_setfmt(mpi,outfmt); if(!(mpi->flags&MP_IMGFLAG_ALLOCATED) && mpi->type>MP_IMGTYPE_EXPORT){ av_assert0(!vf->get_image); if(vf->get_image) vf->get_image(vf,mpi); if(!(mpi->flags&MP_IMGFLAG_DIRECT)){ if (!mpi->bpp) { mp_msg(MSGT_DECVIDEO, MSGL_FATAL, "vf_get_image: Tried to allocate a format that can not be allocated!\n"); return NULL; } if(mp_imgflag&MP_IMGFLAG_PREFER_ALIGNED_STRIDE){ int align=(mpi->flags&MP_IMGFLAG_PLANAR && mpi->flags&MP_IMGFLAG_YUV) ? (8<<mpi->chroma_x_shift)-1 : 15; w2=((w+align)&(~align)); if(mpi->width!=w2){ #if 0 int flags=vf->query_format(vf,outfmt); if(!(flags&3)) mp_msg(MSGT_DECVIDEO,MSGL_WARN,"??? vf_get_image{vf->query_format(outfmt)} failed!\n"); if(flags&VFCAP_ACCEPT_STRIDE){ #endif mpi->width=w2; mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift; } } mp_image_alloc_planes(mpi); vf_mpi_clear(mpi,0,0,mpi->width,mpi->height); } } av_assert0(!vf->start_slice); if(mpi->flags&MP_IMGFLAG_DRAW_CALLBACK) if(vf->start_slice) vf->start_slice(vf,mpi); if(!(mpi->flags&MP_IMGFLAG_TYPE_DISPLAYED)){ mp_msg(MSGT_DECVIDEO,MSGL_V,"*** [%s] %s%s mp_image_t, %dx%dx%dbpp %s %s, %d bytes\n", "NULL" , (mpi->type==MP_IMGTYPE_EXPORT)?"Exporting": ((mpi->flags&MP_IMGFLAG_DIRECT)?"Direct Rendering":"Allocating"), (mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)?" (slices)":"", mpi->width,mpi->height,mpi->bpp, (mpi->flags&MP_IMGFLAG_YUV)?"YUV":((mpi->flags&MP_IMGFLAG_SWAPPED)?"BGR":"RGB"), (mpi->flags&MP_IMGFLAG_PLANAR)?"planar":"packed", mpi->bpp*mpi->width*mpi->height/8); mp_msg(MSGT_DECVIDEO,MSGL_DBG2,"(imgfmt: %x, planes: %p,%p,%p strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\n", mpi->imgfmt, mpi->planes[0], mpi->planes[1], mpi->planes[2], mpi->stride[0], mpi->stride[1], mpi->stride[2], mpi->chroma_width, mpi->chroma_height, mpi->chroma_x_shift, mpi->chroma_y_shift); mpi->flags|=MP_IMGFLAG_TYPE_DISPLAYED; } mpi->qscale = NULL; } mpi->usage_count++; return mpi; }

[[[[Adv]]]]: mp_image_t* vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, int mp_imgflag, int w, int h){ MPContext *[[kilometer]]= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, next_vf)); mp_image_t* mpi=NULL; int w2; int number = mp_imgtype >> 16; av_assert0(vf->next == NULL); if(vf->w==0 && w>0) vf->w=w; if(vf->h==0 && h>0) vf->h=h; av_assert0(w == -1 || w >= vf->w); av_assert0(h == -1 || h >= vf->h); av_assert0(vf->w > 0); av_assert0(vf->h > 0); av_log([[kilometer]]->avfctx, AV_LOG_DEBUG, "get_image: %d:%d, vf: %d:%d\n", w,h,vf->w,vf->h); if (w == -1) w = vf->w; if (h == -1) h = vf->h; w2=(mp_imgflag&MP_IMGFLAG_ACCEPT_ALIGNED_STRIDE)?((w+15)&(~15)):w; switch(mp_imgtype & 0xff){ case MP_IMGTYPE_EXPORT: if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h); mpi=vf->imgctx.export_images[0]; break; case MP_IMGTYPE_STATIC: if(!vf->imgctx.static_images[0]) vf->imgctx.static_images[0]=new_mp_image(w2,h); mpi=vf->imgctx.static_images[0]; break; case MP_IMGTYPE_TEMP: if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h); mpi=vf->imgctx.temp_images[0]; break; case MP_IMGTYPE_IPB: if(!(mp_imgflag&MP_IMGFLAG_READABLE)){ if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h); mpi=vf->imgctx.temp_images[0]; break; } case MP_IMGTYPE_IP: if(!vf->imgctx.static_images[vf->imgctx.static_idx]) vf->imgctx.static_images[vf->imgctx.static_idx]=new_mp_image(w2,h); mpi=vf->imgctx.static_images[vf->imgctx.static_idx]; vf->imgctx.static_idx^=1; break; case MP_IMGTYPE_NUMBERED: if (number == -1) { int i; for (i = 0; i < NUM_NUMBERED_MPI; i++) if (!vf->imgctx.numbered_images[i] || !vf->imgctx.numbered_images[i]->usage_count) break; number = i; } if (number < 0 || number >= NUM_NUMBERED_MPI) return NULL; if (!vf->imgctx.numbered_images[number]) vf->imgctx.numbered_images[number] = new_mp_image(w2,h); mpi = vf->imgctx.numbered_images[number]; mpi->number = number; break; } if(mpi){ mpi->type=mp_imgtype; mpi->w=vf->w; mpi->h=vf->h; mpi->flags&=MP_IMGFLAG_ALLOCATED|MP_IMGFLAG_TYPE_DISPLAYED|MP_IMGFLAGMASK_COLORS; mpi->flags|=mp_imgflag&(MP_IMGFLAGMASK_RESTRICTIONS|MP_IMGFLAG_DRAW_CALLBACK|MP_IMGFLAG_RGB_PALETTE); if(!vf->draw_slice) mpi->flags&=~MP_IMGFLAG_DRAW_CALLBACK; if(mpi->width!=w2 || mpi->height!=h){ if(mpi->flags&MP_IMGFLAG_ALLOCATED){ if(mpi->width<w2 || mpi->height<h){ av_free(mpi->planes[0]); mpi->flags&=~MP_IMGFLAG_ALLOCATED; mp_msg(MSGT_VFILTER,MSGL_V,"vf.c: have to REALLOCATE buffer memory :(\n"); } } { mpi->width=w2; mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift; mpi->height=h; mpi->chroma_height=(h + (1<<mpi->chroma_y_shift) - 1)>>mpi->chroma_y_shift; } } if(!mpi->bpp) mp_image_setfmt(mpi,outfmt); if(!(mpi->flags&MP_IMGFLAG_ALLOCATED) && mpi->type>MP_IMGTYPE_EXPORT){ av_assert0(!vf->get_image); if(vf->get_image) vf->get_image(vf,mpi); if(!(mpi->flags&MP_IMGFLAG_DIRECT)){ if (!mpi->bpp) { mp_msg(MSGT_DECVIDEO, MSGL_FATAL, "vf_get_image: Tried to allocate a format that can not be allocated!\n"); return NULL; } if(mp_imgflag&MP_IMGFLAG_PREFER_ALIGNED_STRIDE){ int align=(mpi->flags&MP_IMGFLAG_PLANAR && mpi->flags&MP_IMGFLAG_YUV) ? (8<<mpi->chroma_x_shift)-1 : 15; w2=((w+align)&(~align)); if(mpi->width!=w2){ #if 0 int flags=vf->query_format(vf,outfmt); if(!(flags&3)) mp_msg(MSGT_DECVIDEO,MSGL_WARN,"??? vf_get_image{vf->query_format(outfmt)} failed!\n"); if(flags&VFCAP_ACCEPT_STRIDE){ #endif mpi->width=w2; mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift; } } mp_image_alloc_planes(mpi); vf_mpi_clear(mpi,0,0,mpi->width,mpi->height); } } av_assert0(!vf->start_slice); if(mpi->flags&MP_IMGFLAG_DRAW_CALLBACK) if(vf->start_slice) vf->start_slice(vf,mpi); if(!(mpi->flags&MP_IMGFLAG_TYPE_DISPLAYED)){ mp_msg(MSGT_DECVIDEO,MSGL_V,"*** [%s] %s%s mp_image_t, %dx%dx%dbpp %s %s, %d bytes\n", "NULL" , (mpi->type==MP_IMGTYPE_EXPORT)?"Exporting": ((mpi->flags&MP_IMGFLAG_DIRECT)?"Direct Rendering":"Allocating"), (mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)?" (slices)":"", mpi->width,mpi->height,mpi->bpp, (mpi->flags&MP_IMGFLAG_YUV)?"YUV":((mpi->flags&MP_IMGFLAG_SWAPPED)?"BGR":"RGB"), (mpi->flags&MP_IMGFLAG_PLANAR)?"planar":"packed", mpi->bpp*mpi->width*mpi->height/8); mp_msg(MSGT_DECVIDEO,MSGL_DBG2,"(imgfmt: %x, planes: %p,%p,%p strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\n", mpi->imgfmt, mpi->planes[0], mpi->planes[1], mpi->planes[2], mpi->stride[0], mpi->stride[1], mpi->stride[2], mpi->chroma_width, mpi->chroma_height, mpi->chroma_x_shift, mpi->chroma_y_shift); mpi->flags|=MP_IMGFLAG_TYPE_DISPLAYED; } mpi->qscale = NULL; } mpi->usage_count++; return mpi; }[Succeeded / Failed / Skipped / Total] 509 / 51 / 325 / 885:  33%|      | 885/2690 [10:19:03<21:02:36, 41.97s/it][Succeeded / Failed / Skipped / Total] 509 / 51 / 325 / 885:  33%|      | 886/2690 [10:20:45<21:03:55, 42.04s/it][Succeeded / Failed / Skipped / Total] 510 / 51 / 325 / 886:  33%|      | 886/2690 [10:20:45<21:03:55, 42.04s/it][Succeeded / Failed / Skipped / Total] 510 / 51 / 325 / 886:  33%|      | 887/2690 [10:21:49<21:03:58, 42.06s/it][Succeeded / Failed / Skipped / Total] 511 / 51 / 325 / 887:  33%|      | 887/2690 [10:21:49<21:03:58, 42.06s/it][Succeeded / Failed / Skipped / Total] 511 / 51 / 325 / 887:  33%|      | 888/2690 [10:22:38<21:03:30, 42.07s/it]
--------------------------------------------- Result 886 ---------------------------------------------
[[0 (82%)]] --> [[0 (43%)]] --> Socre: 0.5712180435657501

[[[[Adv]]]]: static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run, int *x, int *y, int *plane, int bits_per_plane) { uint8_t *[[d]]; int shift = *plane * bits_per_plane; unsigned mask = ((1 << bits_per_plane) - 1) << shift; value <<= shift; while (run > 0) { int j; for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) { [[d]] = frame->data[0] + *y * frame->linesize[0]; [[d]][*x] |= (value >> j) & mask; *x += 1; if (*x == s->width) { *y -= 1; *x = 0; if (*y < 0) { *y = s->height - 1; *plane += 1; if (*plane >= s->nb_planes) return; value <<= bits_per_plane; mask <<= bits_per_plane; } } } run--; } }

[[[[Adv]]]]: static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run, int *x, int *y, int *plane, int bits_per_plane) { uint8_t *[[five]]; int shift = *plane * bits_per_plane; unsigned mask = ((1 << bits_per_plane) - 1) << shift; value <<= shift; while (run > 0) { int j; for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) { [[five]] = frame->data[0] + *y * frame->linesize[0]; [[five]][*x] |= (value >> j) & mask; *x += 1; if (*x == s->width) { *y -= 1; *x = 0; if (*y < 0) { *y = s->height - 1; *plane += 1; if (*plane >= s->nb_planes) return; value <<= bits_per_plane; mask <<= bits_per_plane; } } } run--; } }
--------------------------------------------- Result 887 ---------------------------------------------
[[0 (97%)]] --> [[0 (12%)]] --> Socre: 0.8842965438961983

[[[[Adv]]]]: target_ulong helper_mul_suov(CPUTriCoreState *[[env]], target_ulong r1, target_ulong r2) { int64_t t1 = extract64(r1, 0, 32); int64_t t2 = extract64(r2, 0, 32); int64_t result = t1 * t2; return suov32([[env]], result); }

[[[[Adv]]]]: target_ulong helper_mul_suov(CPUTriCoreState *[[onlookers]], target_ulong r1, target_ulong r2) { int64_t t1 = extract64(r1, 0, 32); int64_t t2 = extract64(r2, 0, 32); int64_t result = t1 * t2; return suov32([[onlookers]], result); }
--------------------------------------------- Result 888 ---------------------------------------------
[[0 (72%)]] --> [[0 (49%)]] --> Socre: 0.5094501674175262

[[[[Adv]]]]: static int parse_chunks(AVFormatContext *s, int [[mode]], int64_t seekts, int *len_ptr) { WtvContext *[[wtv]] = s->priv_data; AVIOContext *pb = [[wtv]]->pb; while (!url_feof(pb)) { ff_asf_guid g; int len, sid, consumed; ff_get_guid(pb, &g); len = avio_rl32(pb); if (len < 32) break; sid = avio_rl32(pb) & 0x7FFF; avio_skip(pb, 8); consumed = 32; if (!ff_guidcmp(g, ff_SBE2_STREAM_DESC_EVENT)) { if (ff_find_stream_index(s, sid) < 0) { ff_asf_guid mediatype, subtype, formattype; int size; avio_skip(pb, 28); ff_get_guid(pb, &mediatype); ff_get_guid(pb, &subtype); avio_skip(pb, 12); ff_get_guid(pb, &formattype); size = avio_rl32(pb); parse_media_type(s, 0, sid, mediatype, subtype, formattype, size); consumed += 92 + size; } } else if (!ff_guidcmp(g, ff_stream2_guid)) { int stream_index = ff_find_stream_index(s, sid); if (stream_index >= 0 && !((WtvStream*)s->streams[stream_index]->priv_data)->seen_data) { ff_asf_guid mediatype, subtype, formattype; int size; avio_skip(pb, 12); ff_get_guid(pb, &mediatype); ff_get_guid(pb, &subtype); avio_skip(pb, 12); ff_get_guid(pb, &formattype); size = avio_rl32(pb); parse_media_type(s, s->streams[stream_index], sid, mediatype, subtype, formattype, size); consumed += 76 + size; } } else if (!ff_guidcmp(g, EVENTID_AudioDescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_StreamIDSpanningEvent) || !ff_guidcmp(g, EVENTID_SubtitleSpanningEvent) || !ff_guidcmp(g, EVENTID_TeletextSpanningEvent)) { int stream_index = ff_find_stream_index(s, sid); if (stream_index >= 0) { AVStream *st = s->streams[stream_index]; uint8_t buf[258]; const uint8_t *pbuf = buf; int buf_size; avio_skip(pb, 8); consumed += 8; if (!ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent)) { avio_skip(pb, 6); consumed += 6; } buf_size = FFMIN(len - consumed, sizeof(buf)); avio_read(pb, buf, buf_size); consumed += buf_size; ff_parse_mpeg2_descriptor(s, st, 0, &pbuf, buf + buf_size, NULL, 0, 0, NULL); } } else if (!ff_guidcmp(g, EVENTID_AudioTypeSpanningEvent)) { int stream_index = ff_find_stream_index(s, sid); if (stream_index >= 0) { AVStream *st = s->streams[stream_index]; int audio_type; avio_skip(pb, 8); audio_type = avio_r8(pb); if (audio_type == 2) st->disposition |= AV_DISPOSITION_HEARING_IMPAIRED; else if (audio_type == 3) st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED; consumed += 9; } } else if (!ff_guidcmp(g, EVENTID_DVBScramblingControlSpanningEvent)) { int stream_index = ff_find_stream_index(s, sid); if (stream_index >= 0) { avio_skip(pb, 12); if (avio_rl32(pb)) av_log(s, AV_LOG_WARNING, "DVB scrambled stream detected (st:%d), decoding will likely fail\n", stream_index); consumed += 16; } } else if (!ff_guidcmp(g, EVENTID_LanguageSpanningEvent)) { int stream_index = ff_find_stream_index(s, sid); if (stream_index >= 0) { AVStream *st = s->streams[stream_index]; uint8_t language[4]; avio_skip(pb, 12); avio_read(pb, language, 3); if (language[0]) { language[3] = 0; av_dict_set(&st->metadata, "language", language, 0); if (!strcmp(language, "nar") || !strcmp(language, "NAR")) st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED; } consumed += 15; } } else if (!ff_guidcmp(g, ff_timestamp_guid)) { int stream_index = ff_find_stream_index(s, sid); if (stream_index >= 0) { avio_skip(pb, 8); [[wtv]]->pts = avio_rl64(pb); consumed += 16; if ([[wtv]]->pts == -1) [[wtv]]->pts = AV_NOPTS_VALUE; else { [[wtv]]->last_valid_pts = [[wtv]]->pts; if ([[wtv]]->epoch == AV_NOPTS_VALUE || [[wtv]]->pts < [[wtv]]->epoch) [[wtv]]->epoch = [[wtv]]->pts; if ([[mode]] == SEEK_TO_PTS && [[wtv]]->pts >= seekts) { avio_skip(pb, WTV_PAD8(len) - consumed); return 0; } } } } else if (!ff_guidcmp(g, ff_data_guid)) { int stream_index = ff_find_stream_index(s, sid); if ([[mode]] == SEEK_TO_DATA && stream_index >= 0 && len > 32 && s->streams[stream_index]->priv_data) { WtvStream *wst = s->streams[stream_index]->priv_data; wst->seen_data = 1; if (len_ptr) { *len_ptr = len; } return stream_index; } } else if (!ff_guidcmp(g, (const ff_asf_guid){0x83,0x95,0x74,0x40,0x9D,0x6B,0xEC,0x4E,0xB4,0x3C,0x67,0xA1,0x80,0x1E,0x1A,0x9B})) { int stream_index = ff_find_stream_index(s, sid); if (stream_index >= 0) av_log(s, AV_LOG_WARNING, "encrypted stream detected (st:%d), decoding will likely fail\n", stream_index); } else if ( !ff_guidcmp(g, (const ff_asf_guid){0x14,0x56,0x1A,0x0C,0xCD,0x30,0x40,0x4F,0xBC,0xBF,0xD0,0x3E,0x52,0x30,0x62,0x07}) || !ff_guidcmp(g, (const ff_asf_guid){0x79,0x66,0xB5,0xE0,0xB9,0x12,0xCC,0x43,0xB7,0xDF,0x57,0x8C,0xAA,0x5A,0x7B,0x63}) || !ff_guidcmp(g, (const ff_asf_guid){0x02,0xAE,0x5B,0x2F,0x8F,0x7B,0x60,0x4F,0x82,0xD6,0xE4,0xEA,0x2F,0x1F,0x4C,0x99}) || !ff_guidcmp(g, ff_DSATTRIB_TRANSPORT_PROPERTIES) || !ff_guidcmp(g, (const ff_asf_guid){0xCC,0x32,0x64,0xDD,0x29,0xE2,0xDB,0x40,0x80,0xF6,0xD2,0x63,0x28,0xD2,0x76,0x1F}) || !ff_guidcmp(g, (const ff_asf_guid){0xE5,0xC5,0x67,0x90,0x5C,0x4C,0x05,0x42,0x86,0xC8,0x7A,0xFE,0x20,0xFE,0x1E,0xFA}) || !ff_guidcmp(g, (const ff_asf_guid){0x80,0x6D,0xF3,0x41,0x32,0x41,0xC2,0x4C,0xB1,0x21,0x01,0xA4,0x32,0x19,0xD8,0x1B}) || !ff_guidcmp(g, (const ff_asf_guid){0x51,0x1D,0xAB,0x72,0xD2,0x87,0x9B,0x48,0xBA,0x11,0x0E,0x08,0xDC,0x21,0x02,0x43}) || !ff_guidcmp(g, (const ff_asf_guid){0x65,0x8F,0xFC,0x47,0xBB,0xE2,0x34,0x46,0x9C,0xEF,0xFD,0xBF,0xE6,0x26,0x1D,0x5C}) || !ff_guidcmp(g, (const ff_asf_guid){0xCB,0xC5,0x68,0x80,0x04,0x3C,0x2B,0x49,0xB4,0x7D,0x03,0x08,0x82,0x0D,0xCE,0x51}) || !ff_guidcmp(g, (const ff_asf_guid){0xBC,0x2E,0xAF,0x82,0xA6,0x30,0x64,0x42,0xA8,0x0B,0xAD,0x2E,0x13,0x72,0xAC,0x60}) || !ff_guidcmp(g, (const ff_asf_guid){0x1E,0xBE,0xC3,0xC5,0x43,0x92,0xDC,0x11,0x85,0xE5,0x00,0x12,0x3F,0x6F,0x73,0xB9}) || !ff_guidcmp(g, (const ff_asf_guid){0x3B,0x86,0xA2,0xB1,0xEB,0x1E,0xC3,0x44,0x8C,0x88,0x1C,0xA3,0xFF,0xE3,0xE7,0x6A}) || !ff_guidcmp(g, (const ff_asf_guid){0x4E,0x7F,0x4C,0x5B,0xC4,0xD0,0x38,0x4B,0xA8,0x3E,0x21,0x7F,0x7B,0xBF,0x52,0xE7}) || !ff_guidcmp(g, (const ff_asf_guid){0x63,0x36,0xEB,0xFE,0xA1,0x7E,0xD9,0x11,0x83,0x08,0x00,0x07,0xE9,0x5E,0xAD,0x8D}) || !ff_guidcmp(g, (const ff_asf_guid){0x70,0xE9,0xF1,0xF8,0x89,0xA4,0x4C,0x4D,0x83,0x73,0xB8,0x12,0xE0,0xD5,0xF8,0x1E}) || !ff_guidcmp(g, ff_index_guid) || !ff_guidcmp(g, ff_sync_guid) || !ff_guidcmp(g, ff_stream1_guid) || !ff_guidcmp(g, (const ff_asf_guid){0xF7,0x10,0x02,0xB9,0xEE,0x7C,0xED,0x4E,0xBD,0x7F,0x05,0x40,0x35,0x86,0x18,0xA1})) { } else av_log(s, AV_LOG_WARNING, "unsupported chunk:"FF_PRI_GUID"\n", FF_ARG_GUID(g)); avio_skip(pb, WTV_PAD8(len) - consumed); } return AVERROR_EOF; }

[[[[Adv]]]]: static int parse_chunks(AVFormatContext *s, int [[style]], int64_t seekts, int *len_ptr) { WtvContext *[[fruitless]] = s->priv_data; AVIOContext *pb = [[fruitless]]->pb; while (!url_feof(pb)) { ff_asf_guid g; int len, sid, consumed; ff_get_guid(pb, &g); len = avio_rl32(pb); if (len < 32) break; sid = avio_rl32(pb) & 0x7FFF; avio_skip(pb, 8); consumed = 32; if (!ff_guidcmp(g, ff_SBE2_STREAM_DESC_EVENT)) { if (ff_find_stream_index(s, sid) < 0) { ff_asf_guid mediatype, subtype, formattype; int size; avio_skip(pb, 28); ff_get_guid(pb, &mediatype); ff_get_guid(pb, &subtype); avio_skip(pb, 12); ff_get_guid(pb, &formattype); size = avio_rl32(pb); parse_media_type(s, 0, sid, mediatype, subtype, formattype, size); consumed += 92 + size; } } else if (!ff_guidcmp(g, ff_stream2_guid)) { int stream_index = ff_find_stream_index(s, sid); if (stream_index >= 0 && !((WtvStream*)s->streams[stream_index]->priv_data)->seen_data) { ff_asf_guid mediatype, subtype, formattype; int size; avio_skip(pb, 12); ff_get_guid(pb, &mediatype); ff_get_guid(pb, &subtype); avio_skip(pb, 12); ff_get_guid(pb, &formattype); size = avio_rl32(pb); parse_media_type(s, s->streams[stream_index], sid, mediatype, subtype, formattype, size); consumed += 76 + size; } } else if (!ff_guidcmp(g, EVENTID_AudioDescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_StreamIDSpanningEvent) || !ff_guidcmp(g, EVENTID_SubtitleSpanningEvent) || !ff_guidcmp(g, EVENTID_TeletextSpanningEvent)) { int stream_index = ff_find_stream_index(s, sid); if (stream_index >= 0) { AVStream *st = s->streams[stream_index]; uint8_t buf[258]; const uint8_t *pbuf = buf; int buf_size; avio_skip(pb, 8); consumed += 8; if (!ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) || !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent)) { avio_skip(pb, 6); consumed += 6; } buf_size = FFMIN(len - consumed, sizeof(buf)); avio_read(pb, buf, buf_size); consumed += buf_size; ff_parse_mpeg2_descriptor(s, st, 0, &pbuf, buf + buf_size, NULL, 0, 0, NULL); } } else if (!ff_guidcmp(g, EVENTID_AudioTypeSpanningEvent)) { int stream_index = ff_find_stream_index(s, sid); if (stream_index >= 0) { AVStream *st = s->streams[stream_index]; int audio_type; avio_skip(pb, 8); audio_type = avio_r8(pb); if (audio_type == 2) st->disposition |= AV_DISPOSITION_HEARING_IMPAIRED; else if (audio_type == 3) st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED; consumed += 9; } } else if (!ff_guidcmp(g, EVENTID_DVBScramblingControlSpanningEvent)) { int stream_index = ff_find_stream_index(s, sid); if (stream_index >= 0) { avio_skip(pb, 12); if (avio_rl32(pb)) av_log(s, AV_LOG_WARNING, "DVB scrambled stream detected (st:%d), decoding will likely fail\n", stream_index); consumed += 16; } } else if (!ff_guidcmp(g, EVENTID_LanguageSpanningEvent)) { int stream_index = ff_find_stream_index(s, sid); if (stream_index >= 0) { AVStream *st = s->streams[stream_index]; uint8_t language[4]; avio_skip(pb, 12); avio_read(pb, language, 3); if (language[0]) { language[3] = 0; av_dict_set(&st->metadata, "language", language, 0); if (!strcmp(language, "nar") || !strcmp(language, "NAR")) st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED; } consumed += 15; } } else if (!ff_guidcmp(g, ff_timestamp_guid)) { int stream_index = ff_find_stream_index(s, sid); if (stream_index >= 0) { avio_skip(pb, 8); [[fruitless]]->pts = avio_rl64(pb); consumed += 16; if ([[fruitless]]->pts == -1) [[fruitless]]->pts = AV_NOPTS_VALUE; else { [[fruitless]]->last_valid_pts = [[fruitless]]->pts; if ([[fruitless]]->epoch == AV_NOPTS_VALUE || [[fruitless]]->pts < [[fruitless]]->epoch) [[fruitless]]->epoch = [[fruitless]]->pts; if ([[style]] == SEEK_TO_PTS && [[fruitless]]->pts >= seekts) { avio_skip(pb, WTV_PAD8(len) - consumed); return 0; } } } } else if (!ff_guidcmp(g, ff_data_guid)) { int stream_index = ff_find_stream_index(s, sid); if ([[style]] == SEEK_TO_DATA && stream_index >= 0 && len > 32 && s->streams[stream_index]->priv_data) { WtvStream *wst = s->streams[stream_index]->priv_data; wst->seen_data = 1; if (len_ptr) { *len_ptr = len; } return stream_index; } } else if (!ff_guidcmp(g, (const ff_asf_guid){0x83,0x95,0x74,0x40,0x9D,0x6B,0xEC,0x4E,0xB4,0x3C,0x67,0xA1,0x80,0x1E,0x1A,0x9B})) { int stream_index = ff_find_stream_index(s, sid); if (stream_index >= 0) av_log(s, AV_LOG_WARNING, "encrypted stream detected (st:%d), decoding will likely fail\n", stream_index); } else if ( !ff_guidcmp(g, (const ff_asf_guid){0x14,0x56,0x1A,0x0C,0xCD,0x30,0x40,0x4F,0xBC,0xBF,0xD0,0x3E,0x52,0x30,0x62,0x07}) || !ff_guidcmp(g, (const ff_asf_guid){0x79,0x66,0xB5,0xE0,0xB9,0x12,0xCC,0x43,0xB7,0xDF,0x57,0x8C,0xAA,0x5A,0x7B,0x63}) || !ff_guidcmp(g, (const ff_asf_guid){0x02,0xAE,0x5B,0x2F,0x8F,0x7B,0x60,0x4F,0x82,0xD6,0xE4,0xEA,0x2F,0x1F,0x4C,0x99}) || !ff_guidcmp(g, ff_DSATTRIB_TRANSPORT_PROPERTIES) || !ff_guidcmp(g, (const ff_asf_guid){0xCC,0x32,0x64,0xDD,0x29,0xE2,0xDB,0x40,0x80,0xF6,0xD2,0x63,0x28,0xD2,0x76,0x1F}) || !ff_guidcmp(g, (const ff_asf_guid){0xE5,0xC5,0x67,0x90,0x5C,0x4C,0x05,0x42,0x86,0xC8,0x7A,0xFE,0x20,0xFE,0x1E,0xFA}) || !ff_guidcmp(g, (const ff_asf_guid){0x80,0x6D,0xF3,0x41,0x32,0x41,0xC2,0x4C,0xB1,0x21,0x01,0xA4,0x32,0x19,0xD8,0x1B}) || !ff_guidcmp(g, (const ff_asf_guid){0x51,0x1D,0xAB,0x72,0xD2,0x87,0x9B,0x48,0xBA,0x11,0x0E,0x08,0xDC,0x21,0x02,0x43}) || !ff_guidcmp(g, (const ff_asf_guid){0x65,0x8F,0xFC,0x47,0xBB,0xE2,0x34,0x46,0x9C,0xEF,0xFD,0xBF,0xE6,0x26,0x1D,0x5C}) || !ff_guidcmp(g, (const ff_asf_guid){0xCB,0xC5,0x68,0x80,0x04,0x3C,0x2B,0x49,0xB4,0x7D,0x03,0x08,0x82,0x0D,0xCE,0x51}) || !ff_guidcmp(g, (const ff_asf_guid){0xBC,0x2E,0xAF,0x82,0xA6,0x30,0x64,0x42,0xA8,0x0B,0xAD,0x2E,0x13,0x72,0xAC,0x60}) || !ff_guidcmp(g, (const ff_asf_guid){0x1E,0xBE,0xC3,0xC5,0x43,0x92,0xDC,0x11,0x85,0xE5,0x00,0x12,0x3F,0x6F,0x73,0xB9}) || !ff_guidcmp(g, (const ff_asf_guid){0x3B,0x86,0xA2,0xB1,0xEB,0x1E,0xC3,0x44,0x8C,0x88,0x1C,0xA3,0xFF,0xE3,0xE7,0x6A}) || !ff_guidcmp(g, (const ff_asf_guid){0x4E,0x7F,0x4C,0x5B,0xC4,0xD0,0x38,0x4B,0xA8,0x3E,0x21,0x7F,0x7B,0xBF,0x52,0xE7}) || !ff_guidcmp(g, (const ff_asf_guid){0x63,0x36,0xEB,0xFE,0xA1,0x7E,0xD9,0x11,0x83,0x08,0x00,0x07,0xE9,0x5E,0xAD,0x8D}) || !ff_guidcmp(g, (const ff_asf_guid){0x70,0xE9,0xF1,0xF8,0x89,0xA4,0x4C,0x4D,0x83,0x73,0xB8,0x12,0xE0,0xD5,0xF8,0x1E}) || !ff_guidcmp(g, ff_index_guid) || !ff_guidcmp(g, ff_sync_guid) || !ff_guidcmp(g, ff_stream1_guid) || !ff_guidcmp(g, (const ff_asf_guid){0xF7,0x10,0x02,0xB9,0xEE,0x7C,0xED,0x4E,0xBD,0x7F,0x05,0x40,0x35,0x86,0x18,0xA1})) { } else av_log(s, AV_LOG_WARNING, "unsupported chunk:"FF_PRI_GUID"\n", FF_ARG_GUID(g)); avio_skip(pb, WTV_PAD8(len) - consumed); } return AVERROR_EOF; }[Succeeded / Failed / Skipped / Total] 512 / 51 / 325 / 888:  33%|      | 888/2690 [10:22:38<21:03:30, 42.07s/it][Succeeded / Failed / Skipped / Total] 512 / 51 / 325 / 888:  33%|      | 889/2690 [10:22:46<21:01:38, 42.03s/it][Succeeded / Failed / Skipped / Total] 513 / 51 / 325 / 889:  33%|      | 889/2690 [10:22:46<21:01:38, 42.03s/it][Succeeded / Failed / Skipped / Total] 513 / 51 / 325 / 889:  33%|      | 890/2690 [10:24:03<21:02:08, 42.07s/it][Succeeded / Failed / Skipped / Total] 514 / 51 / 325 / 890:  33%|      | 890/2690 [10:24:03<21:02:08, 42.07s/it][Succeeded / Failed / Skipped / Total] 514 / 51 / 325 / 890:  33%|      | 891/2690 [10:24:08<21:00:10, 42.03s/it][Succeeded / Failed / Skipped / Total] 515 / 51 / 325 / 891:  33%|      | 891/2690 [10:24:08<21:00:10, 42.03s/it][Succeeded / Failed / Skipped / Total] 515 / 51 / 325 / 891:  33%|      | 892/2690 [10:25:52<21:01:35, 42.10s/it][Succeeded / Failed / Skipped / Total] 516 / 51 / 325 / 892:  33%|      | 892/2690 [10:25:52<21:01:35, 42.10s/it][Succeeded / Failed / Skipped / Total] 516 / 51 / 325 / 892:  33%|      | 893/2690 [10:29:21<21:06:28, 42.29s/it][Succeeded / Failed / Skipped / Total] 516 / 52 / 325 / 893:  33%|      | 893/2690 [10:29:21<21:06:28, 42.29s/it][Succeeded / Failed / Skipped / Total] 516 / 52 / 325 / 893:  33%|      | 894/2690 [10:29:25<21:04:28, 42.24s/it][Succeeded / Failed / Skipped / Total] 517 / 52 / 325 / 894:  33%|      | 894/2690 [10:29:25<21:04:28, 42.24s/it][Succeeded / Failed / Skipped / Total] 517 / 52 / 325 / 894:  33%|      | 895/2690 [10:29:43<21:02:58, 42.22s/it]
--------------------------------------------- Result 889 ---------------------------------------------
[[0 (95%)]] --> [[0 (41%)]] --> Socre: 0.592279851436615

[[[[Adv]]]]: static void virtio_rng_class_init(ObjectClass *[[klass]], void *[[data]]) { DeviceClass *[[dc]] = DEVICE_CLASS([[klass]]); VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS([[klass]]); [[dc]]->props = virtio_rng_properties; set_bit(DEVICE_CATEGORY_MISC, [[dc]]->categories); vdc->realize = virtio_rng_device_realize; vdc->unrealize = virtio_rng_device_unrealize; vdc->get_features = get_features; vdc->load = virtio_rng_load_device; }

[[[[Adv]]]]: static void virtio_rng_class_init(ObjectClass *[[tesh]], void *[[accuracy]]) { DeviceClass *[[kt]] = DEVICE_CLASS([[tesh]]); VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS([[tesh]]); [[kt]]->props = virtio_rng_properties; set_bit(DEVICE_CATEGORY_MISC, [[kt]]->categories); vdc->realize = virtio_rng_device_realize; vdc->unrealize = virtio_rng_device_unrealize; vdc->get_features = get_features; vdc->load = virtio_rng_load_device; }
--------------------------------------------- Result 890 ---------------------------------------------
[[0 (98%)]] --> [[0 (45%)]] --> Socre: 0.549484133720398

[[[[Adv]]]]: int kvm_init(int [[smp_cpus]]) { KVMState *s; int ret; int i; if ([[smp_cpus]] > 1) return -EINVAL; s = qemu_mallocz(sizeof(KVMState)); if (s == NULL) return -ENOMEM; for (i = 0; i < ARRAY_SIZE(s->slots); i++) s->slots[i].slot = i; s->vmfd = -1; s->fd = open("/dev/kvm", O_RDWR); if (s->fd == -1) { fprintf(stderr, "Could not access KVM kernel module: %m\n"); ret = -errno; goto err; } ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0); if (ret < KVM_API_VERSION) { ret = -EINVAL; fprintf(stderr, "kvm version too old\n"); goto err; } if (ret > KVM_API_VERSION) { ret = -EINVAL; fprintf(stderr, "kvm version not supported\n"); goto err; } s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0); if (s->vmfd < 0) goto err; ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, KVM_CAP_USER_MEMORY); if (ret <= 0) { if (ret == 0) ret = -EINVAL; fprintf(stderr, "kvm does not support KVM_CAP_USER_MEMORY\n"); goto err; } ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, KVM_CAP_DESTROY_MEMORY_REGION_WORKS); if (ret <= 0) { if (ret == 0) ret = -EINVAL; fprintf(stderr, "KVM kernel module broken (DESTROY_MEMORY_REGION)\n" "Please upgrade to at least kvm-81.\n"); goto err; } ret = kvm_arch_init(s, [[smp_cpus]]); if (ret < 0) goto err; kvm_state = s; return 0; err: if (s) { if (s->vmfd != -1) close(s->vmfd); if (s->fd != -1) close(s->fd); } qemu_free(s); return ret; }

[[[[Adv]]]]: int kvm_init(int [[notional]]) { KVMState *s; int ret; int i; if ([[notional]] > 1) return -EINVAL; s = qemu_mallocz(sizeof(KVMState)); if (s == NULL) return -ENOMEM; for (i = 0; i < ARRAY_SIZE(s->slots); i++) s->slots[i].slot = i; s->vmfd = -1; s->fd = open("/dev/kvm", O_RDWR); if (s->fd == -1) { fprintf(stderr, "Could not access KVM kernel module: %m\n"); ret = -errno; goto err; } ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0); if (ret < KVM_API_VERSION) { ret = -EINVAL; fprintf(stderr, "kvm version too old\n"); goto err; } if (ret > KVM_API_VERSION) { ret = -EINVAL; fprintf(stderr, "kvm version not supported\n"); goto err; } s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0); if (s->vmfd < 0) goto err; ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, KVM_CAP_USER_MEMORY); if (ret <= 0) { if (ret == 0) ret = -EINVAL; fprintf(stderr, "kvm does not support KVM_CAP_USER_MEMORY\n"); goto err; } ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, KVM_CAP_DESTROY_MEMORY_REGION_WORKS); if (ret <= 0) { if (ret == 0) ret = -EINVAL; fprintf(stderr, "KVM kernel module broken (DESTROY_MEMORY_REGION)\n" "Please upgrade to at least kvm-81.\n"); goto err; } ret = kvm_arch_init(s, [[notional]]); if (ret < 0) goto err; kvm_state = s; return 0; err: if (s) { if (s->vmfd != -1) close(s->vmfd); if (s->fd != -1) close(s->fd); } qemu_free(s); return ret; }
--------------------------------------------- Result 891 ---------------------------------------------
[[0 (55%)]] --> [[0 (46%)]] --> Socre: 0.5351085662841797

[[[[Adv]]]]: static int64_t nfs_client_open(NFSClient *client, const char *filename, int flags, Error **errp) { int ret = -EINVAL, i; struct stat [[st]]; URI *uri; QueryParams *qp = NULL; char *file = NULL, *strp = NULL; uri = uri_parse(filename); if (!uri) { error_setg(errp, "Invalid URL specified"); goto fail; } if (!uri->server) { error_setg(errp, "Invalid URL specified"); goto fail; } strp = strrchr(uri->path, '/'); if (strp == NULL) { error_setg(errp, "Invalid URL specified"); goto fail; } file = g_strdup(strp); *strp = 0; client->context = nfs_init_context(); if (client->context == NULL) { error_setg(errp, "Failed to init NFS context"); goto fail; } qp = query_params_parse(uri->query); for (i = 0; i < qp->n; i++) { if (!qp->p[i].value) { error_setg(errp, "Value for NFS parameter expected: %s", qp->p[i].name); goto fail; } if (!strncmp(qp->p[i].name, "uid", 3)) { nfs_set_uid(client->context, atoi(qp->p[i].value)); } else if (!strncmp(qp->p[i].name, "gid", 3)) { nfs_set_gid(client->context, atoi(qp->p[i].value)); } else if (!strncmp(qp->p[i].name, "tcp-syncnt", 10)) { nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value)); } else { error_setg(errp, "Unknown NFS parameter name: %s", qp->p[i].name); goto fail; } } ret = nfs_mount(client->context, uri->server, uri->path); if (ret < 0) { error_setg(errp, "Failed to mount nfs share: %s", nfs_get_error(client->context)); goto fail; } if (flags & O_CREAT) { ret = nfs_creat(client->context, file, 0600, &client->fh); if (ret < 0) { error_setg(errp, "Failed to create file: %s", nfs_get_error(client->context)); goto fail; } } else { ret = nfs_open(client->context, file, flags, &client->fh); if (ret < 0) { error_setg(errp, "Failed to open file : %s", nfs_get_error(client->context)); goto fail; } } ret = nfs_fstat(client->context, client->fh, &[[st]]); if (ret < 0) { error_setg(errp, "Failed to fstat file: %s", nfs_get_error(client->context)); goto fail; } ret = DIV_ROUND_UP([[st]].st_size, BDRV_SECTOR_SIZE); client->has_zero_init = S_ISREG([[st]].st_mode); goto out; fail: nfs_client_close(client); out: if (qp) { query_params_free(qp); } uri_free(uri); g_free(file); return ret; }

[[[[Adv]]]]: static int64_t nfs_client_open(NFSClient *client, const char *filename, int flags, Error **errp) { int ret = -EINVAL, i; struct stat [[santi]]; URI *uri; QueryParams *qp = NULL; char *file = NULL, *strp = NULL; uri = uri_parse(filename); if (!uri) { error_setg(errp, "Invalid URL specified"); goto fail; } if (!uri->server) { error_setg(errp, "Invalid URL specified"); goto fail; } strp = strrchr(uri->path, '/'); if (strp == NULL) { error_setg(errp, "Invalid URL specified"); goto fail; } file = g_strdup(strp); *strp = 0; client->context = nfs_init_context(); if (client->context == NULL) { error_setg(errp, "Failed to init NFS context"); goto fail; } qp = query_params_parse(uri->query); for (i = 0; i < qp->n; i++) { if (!qp->p[i].value) { error_setg(errp, "Value for NFS parameter expected: %s", qp->p[i].name); goto fail; } if (!strncmp(qp->p[i].name, "uid", 3)) { nfs_set_uid(client->context, atoi(qp->p[i].value)); } else if (!strncmp(qp->p[i].name, "gid", 3)) { nfs_set_gid(client->context, atoi(qp->p[i].value)); } else if (!strncmp(qp->p[i].name, "tcp-syncnt", 10)) { nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value)); } else { error_setg(errp, "Unknown NFS parameter name: %s", qp->p[i].name); goto fail; } } ret = nfs_mount(client->context, uri->server, uri->path); if (ret < 0) { error_setg(errp, "Failed to mount nfs share: %s", nfs_get_error(client->context)); goto fail; } if (flags & O_CREAT) { ret = nfs_creat(client->context, file, 0600, &client->fh); if (ret < 0) { error_setg(errp, "Failed to create file: %s", nfs_get_error(client->context)); goto fail; } } else { ret = nfs_open(client->context, file, flags, &client->fh); if (ret < 0) { error_setg(errp, "Failed to open file : %s", nfs_get_error(client->context)); goto fail; } } ret = nfs_fstat(client->context, client->fh, &[[santi]]); if (ret < 0) { error_setg(errp, "Failed to fstat file: %s", nfs_get_error(client->context)); goto fail; } ret = DIV_ROUND_UP([[santi]].st_size, BDRV_SECTOR_SIZE); client->has_zero_init = S_ISREG([[santi]].st_mode); goto out; fail: nfs_client_close(client); out: if (qp) { query_params_free(qp); } uri_free(uri); g_free(file); return ret; }
--------------------------------------------- Result 892 ---------------------------------------------
[[0 (100%)]] --> [[0 (46%)]] --> Socre: 0.5383699536323547

[[[[Adv]]]]: static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid, unsigned int [[epid]]) { XHCISlot *slot; XHCIEPContext *[[epctx]]; int i; trace_usb_xhci_ep_disable(slotid, [[epid]]); assert(slotid >= 1 && slotid <= xhci->numslots); assert([[epid]] >= 1 && [[epid]] <= 31); slot = &xhci->slots[slotid-1]; if (!slot->eps[[[epid]]-1]) { DPRINTF("xhci: slot %d ep %d already disabled\n", slotid, [[epid]]); return CC_SUCCESS; xhci_ep_nuke_xfers(xhci, slotid, [[epid]]); [[epctx]] = slot->eps[[[epid]]-1]; if ([[epctx]]->nr_pstreams) { xhci_free_streams([[epctx]]); xhci_set_ep_state(xhci, [[epctx]], NULL, EP_DISABLED); timer_free([[epctx]]->kick_timer); g_free([[epctx]]); slot->eps[[[epid]]-1] = NULL; return CC_SUCCESS;

[[[[Adv]]]]: static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid, unsigned int [[raising]]) { XHCISlot *slot; XHCIEPContext *[[crdoba]]; int i; trace_usb_xhci_ep_disable(slotid, [[raising]]); assert(slotid >= 1 && slotid <= xhci->numslots); assert([[raising]] >= 1 && [[raising]] <= 31); slot = &xhci->slots[slotid-1]; if (!slot->eps[[[raising]]-1]) { DPRINTF("xhci: slot %d ep %d already disabled\n", slotid, [[raising]]); return CC_SUCCESS; xhci_ep_nuke_xfers(xhci, slotid, [[raising]]); [[crdoba]] = slot->eps[[[raising]]-1]; if ([[crdoba]]->nr_pstreams) { xhci_free_streams([[crdoba]]); xhci_set_ep_state(xhci, [[crdoba]], NULL, EP_DISABLED); timer_free([[crdoba]]->kick_timer); g_free([[crdoba]]); slot->eps[[[raising]]-1] = NULL; return CC_SUCCESS;
--------------------------------------------- Result 893 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx) { int i; float (*output)[256] = ctx->audio_block.block_output; for (i = 0; i < 256; i++) output[1][i] = (output[2][i] + output[3][i] + output[4][i]); memset(output[2], 0, sizeof(output[2])); memset(output[3], 0, sizeof(output[3])); memset(output[4], 0, sizeof(output[4])); }

[[[[Adv]]]]: static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx) { int i; float (*output)[256] = ctx->audio_block.block_output; for (i = 0; i < 256; i++) output[1][i] = (output[2][i] + output[3][i] + output[4][i]); memset(output[2], 0, sizeof(output[2])); memset(output[3], 0, sizeof(output[3])); memset(output[4], 0, sizeof(output[4])); }
--------------------------------------------- Result 894 ---------------------------------------------
[[0 (51%)]] --> [[0 (46%)]] --> Socre: 0.5411228835582733

[[[[Adv]]]]: static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size) { DeviceState *[[dev]]; SysBusDevice *s; RamDevice *d; [[dev]] = qdev_create(NULL, "memory"); s = sysbus_from_qdev([[dev]]); d = FROM_SYSBUS(RamDevice, s); d->size = RAM_size; qdev_init([[dev]]); sysbus_mmio_map(s, 0, addr); }

[[[[Adv]]]]: static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size) { DeviceState *[[gautam]]; SysBusDevice *s; RamDevice *d; [[gautam]] = qdev_create(NULL, "memory"); s = sysbus_from_qdev([[gautam]]); d = FROM_SYSBUS(RamDevice, s); d->size = RAM_size; qdev_init([[gautam]]); sysbus_mmio_map(s, 0, addr); }
--------------------------------------------- Result 895 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 518 / 52 / 325 / 895:  33%|      | 895/2690 [10:29:43<21:02:58, 42.22s/it][Succeeded / Failed / Skipped / Total] 518 / 52 / 325 / 895:  33%|      | 896/2690 [10:29:43<21:00:52, 42.17s/it][[0 (84%)]] --> [[0 (47%)]] --> Socre: 0.5285255610942841

[[[[Adv]]]]: QemuOpts *qemu_chr_parse_compat(const char *label, const char *[[filename]]) { char host[65], port[33], width[8], height[8]; int pos; const char *p; QemuOpts *[[opts]]; Error *[[local_err]] = NULL; [[opts]] = qemu_opts_create(qemu_find_opts("chardev"), label, 1, &[[local_err]]); if (error_is_set(&[[local_err]])) { qerror_report_err([[local_err]]); error_free([[local_err]]); return NULL; } if (strstart([[filename]], "mon:", &p)) { [[filename]] = p; qemu_opt_set([[opts]], "mux", "on"); if (strcmp([[filename]], "stdio") == 0) { qemu_opt_set([[opts]], "signal", "off"); } } if (strcmp([[filename]], "null") == 0 || strcmp([[filename]], "pty") == 0 || strcmp([[filename]], "msmouse") == 0 || strcmp([[filename]], "braille") == 0 || strcmp([[filename]], "stdio") == 0) { qemu_opt_set([[opts]], "backend", [[filename]]); return [[opts]]; } if (strstart([[filename]], "vc", &p)) { qemu_opt_set([[opts]], "backend", "vc"); if (*p == ':') { if (sscanf(p+1, "%8[0-9]x%8[0-9]", width, height) == 2) { qemu_opt_set([[opts]], "width", width); qemu_opt_set([[opts]], "height", height); } else if (sscanf(p+1, "%8[0-9]Cx%8[0-9]C", width, height) == 2) { qemu_opt_set([[opts]], "cols", width); qemu_opt_set([[opts]], "rows", height); } else { goto fail; } } return [[opts]]; } if (strcmp([[filename]], "con:") == 0) { qemu_opt_set([[opts]], "backend", "console"); return [[opts]]; } if (strstart([[filename]], "COM", NULL)) { qemu_opt_set([[opts]], "backend", "serial"); qemu_opt_set([[opts]], "path", [[filename]]); return [[opts]]; } if (strstart([[filename]], "file:", &p)) { qemu_opt_set([[opts]], "backend", "file"); qemu_opt_set([[opts]], "path", p); return [[opts]]; } if (strstart([[filename]], "pipe:", &p)) { qemu_opt_set([[opts]], "backend", "pipe"); qemu_opt_set([[opts]], "path", p); return [[opts]]; } if (strstart([[filename]], "tcp:", &p) || strstart([[filename]], "telnet:", &p)) { if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) { host[0] = 0; if (sscanf(p, ":%32[^,]%n", port, &pos) < 1) goto fail; } qemu_opt_set([[opts]], "backend", "socket"); qemu_opt_set([[opts]], "host", host); qemu_opt_set([[opts]], "port", port); if (p[pos] == ',') { if (qemu_opts_do_parse([[opts]], p+pos+1, NULL) != 0) goto fail; } if (strstart([[filename]], "telnet:", &p)) qemu_opt_set([[opts]], "telnet", "on"); return [[opts]]; } if (strstart([[filename]], "udp:", &p)) { qemu_opt_set([[opts]], "backend", "udp"); if (sscanf(p, "%64[^:]:%32[^@,]%n", host, port, &pos) < 2) { host[0] = 0; if (sscanf(p, ":%32[^@,]%n", port, &pos) < 1) { goto fail; } } qemu_opt_set([[opts]], "host", host); qemu_opt_set([[opts]], "port", port); if (p[pos] == '@') { p += pos + 1; if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) { host[0] = 0; if (sscanf(p, ":%32[^,]%n", port, &pos) < 1) { goto fail; } } qemu_opt_set([[opts]], "localaddr", host); qemu_opt_set([[opts]], "localport", port); } return [[opts]]; } if (strstart([[filename]], "unix:", &p)) { qemu_opt_set([[opts]], "backend", "socket"); if (qemu_opts_do_parse([[opts]], p, "path") != 0) goto fail; return [[opts]]; } if (strstart([[filename]], "/dev/parport", NULL) || strstart([[filename]], "/dev/ppi", NULL)) { qemu_opt_set([[opts]], "backend", "parport"); qemu_opt_set([[opts]], "path", [[filename]]); return [[opts]]; } if (strstart([[filename]], "/dev/", NULL)) { qemu_opt_set([[opts]], "backend", "tty"); qemu_opt_set([[opts]], "path", [[filename]]); return [[opts]]; } fail: qemu_opts_del([[opts]]); return NULL; }

[[[[Adv]]]]: QemuOpts *qemu_chr_parse_compat(const char *label, const char *[[dimitri]]) { char host[65], port[33], width[8], height[8]; int pos; const char *p; QemuOpts *[[trivedi]]; Error *[[smarten]] = NULL; [[trivedi]] = qemu_opts_create(qemu_find_opts("chardev"), label, 1, &[[smarten]]); if (error_is_set(&[[smarten]])) { qerror_report_err([[smarten]]); error_free([[smarten]]); return NULL; } if (strstart([[dimitri]], "mon:", &p)) { [[dimitri]] = p; qemu_opt_set([[trivedi]], "mux", "on"); if (strcmp([[dimitri]], "stdio") == 0) { qemu_opt_set([[trivedi]], "signal", "off"); } } if (strcmp([[dimitri]], "null") == 0 || strcmp([[dimitri]], "pty") == 0 || strcmp([[dimitri]], "msmouse") == 0 || strcmp([[dimitri]], "braille") == 0 || strcmp([[dimitri]], "stdio") == 0) { qemu_opt_set([[trivedi]], "backend", [[dimitri]]); return [[trivedi]]; } if (strstart([[dimitri]], "vc", &p)) { qemu_opt_set([[trivedi]], "backend", "vc"); if (*p == ':') { if (sscanf(p+1, "%8[0-9]x%8[0-9]", width, height) == 2) { qemu_opt_set([[trivedi]], "width", width); qemu_opt_set([[trivedi]], "height", height); } else if (sscanf(p+1, "%8[0-9]Cx%8[0-9]C", width, height) == 2) { qemu_opt_set([[trivedi]], "cols", width); qemu_opt_set([[trivedi]], "rows", height); } else { goto fail; } } return [[trivedi]]; } if (strcmp([[dimitri]], "con:") == 0) { qemu_opt_set([[trivedi]], "backend", "console"); return [[trivedi]]; } if (strstart([[dimitri]], "COM", NULL)) { qemu_opt_set([[trivedi]], "backend", "serial"); qemu_opt_set([[trivedi]], "path", [[dimitri]]); return [[trivedi]]; } if (strstart([[dimitri]], "file:", &p)) { qemu_opt_set([[trivedi]], "backend", "file"); qemu_opt_set([[trivedi]], "path", p); return [[trivedi]]; } if (strstart([[dimitri]], "pipe:", &p)) { qemu_opt_set([[trivedi]], "backend", "pipe"); qemu_opt_set([[trivedi]], "path", p); return [[trivedi]]; } if (strstart([[dimitri]], "tcp:", &p) || strstart([[dimitri]], "telnet:", &p)) { if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) { host[0] = 0; if (sscanf(p, ":%32[^,]%n", port, &pos) < 1) goto fail; } qemu_opt_set([[trivedi]], "backend", "socket"); qemu_opt_set([[trivedi]], "host", host); qemu_opt_set([[trivedi]], "port", port); if (p[pos] == ',') { if (qemu_opts_do_parse([[trivedi]], p+pos+1, NULL) != 0) goto fail; } if (strstart([[dimitri]], "telnet:", &p)) qemu_opt_set([[trivedi]], "telnet", "on"); return [[trivedi]]; } if (strstart([[dimitri]], "udp:", &p)) { qemu_opt_set([[trivedi]], "backend", "udp"); if (sscanf(p, "%64[^:]:%32[^@,]%n", host, port, &pos) < 2) { host[0] = 0; if (sscanf(p, ":%32[^@,]%n", port, &pos) < 1) { goto fail; } } qemu_opt_set([[trivedi]], "host", host); qemu_opt_set([[trivedi]], "port", port); if (p[pos] == '@') { p += pos + 1; if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) { host[0] = 0; if (sscanf(p, ":%32[^,]%n", port, &pos) < 1) { goto fail; } } qemu_opt_set([[trivedi]], "localaddr", host); qemu_opt_set([[trivedi]], "localport", port); } return [[trivedi]]; } if (strstart([[dimitri]], "unix:", &p)) { qemu_opt_set([[trivedi]], "backend", "socket"); if (qemu_opts_do_parse([[trivedi]], p, "path") != 0) goto fail; return [[trivedi]]; } if (strstart([[dimitri]], "/dev/parport", NULL) || strstart([[dimitri]], "/dev/ppi", NULL)) { qemu_opt_set([[trivedi]], "backend", "parport"); qemu_opt_set([[trivedi]], "path", [[dimitri]]); return [[trivedi]]; } if (strstart([[dimitri]], "/dev/", NULL)) { qemu_opt_set([[trivedi]], "backend", "tty"); qemu_opt_set([[trivedi]], "path", [[dimitri]]); return [[trivedi]]; } fail: qemu_opts_del([[trivedi]]); return NULL; }
--------------------------------------------- Result 896 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 518 / 52 / 326 / 896:  33%|      | 896/2690 [10:29:43<21:00:52, 42.17s/it][Succeeded / Failed / Skipped / Total] 518 / 52 / 326 / 896:  33%|      | 897/2690 [10:29:44<20:58:46, 42.12s/it][Succeeded / Failed / Skipped / Total] 518 / 52 / 327 / 897:  33%|      | 897/2690 [10:29:44<20:58:46, 42.12s/it][Succeeded / Failed / Skipped / Total] 518 / 52 / 327 / 897:  33%|      | 898/2690 [10:47:30<21:32:07, 43.26s/it][Succeeded / Failed / Skipped / Total] 518 / 53 / 327 / 898:  33%|      | 898/2690 [10:47:30<21:32:07, 43.26s/it][Succeeded / Failed / Skipped / Total] 518 / 53 / 327 / 898:  33%|      | 899/2690 [10:47:30<21:29:59, 43.22s/it][[0 (17%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: POWERPC_FAMILY(POWER8)(ObjectClass *oc, void *data) { DeviceClass *dc = DEVICE_CLASS(oc); PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc); dc->fw_name = "PowerPC,POWER8"; dc->desc = "POWER8"; pcc->pvr = CPU_POWERPC_POWER8_BASE; pcc->pvr_mask = CPU_POWERPC_POWER8_MASK; pcc->init_proc = init_proc_POWER7; pcc->check_pow = check_pow_nocheck; pcc->insns_flags = PPC_INSNS_BASE | PPC_STRING | PPC_MFTB | PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES | PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE | PPC_FLOAT_STFIWX | PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ | PPC_MEM_SYNC | PPC_MEM_EIEIO | PPC_MEM_TLBIE | PPC_MEM_TLBSYNC | PPC_64B | PPC_ALTIVEC | PPC_SEGMENT_64B | PPC_SLBI | PPC_POPCNTB | PPC_POPCNTWD; pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX | PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 | PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206; pcc->msr_mask = 0x800000000284FF36ULL; pcc->mmu_model = POWERPC_MMU_2_06; #if defined(CONFIG_SOFTMMU) pcc->handle_mmu_fault = ppc_hash64_handle_mmu_fault; #endif pcc->excp_model = POWERPC_EXCP_POWER7; pcc->bus_model = PPC_FLAGS_INPUT_POWER7; pcc->bfd_mach = bfd_mach_ppc64; pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE | POWERPC_FLAG_BE | POWERPC_FLAG_PMM | POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR | POWERPC_FLAG_VSX; pcc->l1_dcache_size = 0x8000; pcc->l1_icache_size = 0x8000; }
--------------------------------------------- Result 897 ---------------------------------------------
[[0 (56%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int parse_object_segment(AVCodecContext *avctx, const uint8_t *buf, int buf_size) { PGSSubContext *ctx = avctx->priv_data; PGSSubObject *object; uint8_t sequence_desc; unsigned int rle_bitmap_len, width, height; int id; if (buf_size <= 4) return AVERROR_INVALIDDATA; buf_size -= 4; id = bytestream_get_be16(&buf); object = find_object(id, &ctx->objects); if (!object) { if (ctx->objects.count >= MAX_EPOCH_OBJECTS) { av_log(avctx, AV_LOG_ERROR, "Too many objects in epoch\n"); return AVERROR_INVALIDDATA; } object = &ctx->objects.object[ctx->objects.count++]; object->id = id; } buf += 1; sequence_desc = bytestream_get_byte(&buf); if (!(sequence_desc & 0x80)) { if (buf_size > object->rle_remaining_len) return AVERROR_INVALIDDATA; memcpy(object->rle + object->rle_data_len, buf, buf_size); object->rle_data_len += buf_size; object->rle_remaining_len -= buf_size; return 0; } if (buf_size <= 7) return AVERROR_INVALIDDATA; buf_size -= 7; rle_bitmap_len = bytestream_get_be24(&buf) - 2*2; if (buf_size > rle_bitmap_len) { av_log(avctx, AV_LOG_ERROR, "Buffer dimension %d larger than the expected RLE data %d\n", buf_size, rle_bitmap_len); return AVERROR_INVALIDDATA; } width = bytestream_get_be16(&buf); height = bytestream_get_be16(&buf); if (avctx->width < width || avctx->height < height || !width || !height) { av_log(avctx, AV_LOG_ERROR, "Bitmap dimensions (%dx%d) invalid.\n", width, height); return AVERROR_INVALIDDATA; } object->w = width; object->h = height; av_fast_padded_malloc(&object->rle, &object->rle_buffer_size, rle_bitmap_len); if (!object->rle) return AVERROR(ENOMEM); memcpy(object->rle, buf, buf_size); object->rle_data_len = buf_size; object->rle_remaining_len = rle_bitmap_len - buf_size; return 0; }
--------------------------------------------- Result 898 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void tap_fd_set_offload(int fd, int csum, int tso4, int tso6, int ecn, int ufo) { unsigned int offload = 0; if (csum) { offload |= TUN_F_CSUM; if (tso4) offload |= TUN_F_TSO4; if (tso6) offload |= TUN_F_TSO6; if ((tso4 || tso6) && ecn) offload |= TUN_F_TSO_ECN; if (ufo) offload |= TUN_F_UFO; if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) { offload &= ~TUN_F_UFO; if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) { fprintf(stderr, "TUNSETOFFLOAD ioctl() failed: %s\n", strerror(errno));

[[[[Adv]]]]: void tap_fd_set_offload(int fd, int csum, int tso4, int tso6, int ecn, int ufo) { unsigned int offload = 0; if (csum) { offload |= TUN_F_CSUM; if (tso4) offload |= TUN_F_TSO4; if (tso6) offload |= TUN_F_TSO6; if ((tso4 || tso6) && ecn) offload |= TUN_F_TSO_ECN; if (ufo) offload |= TUN_F_UFO; if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) { offload &= ~TUN_F_UFO; if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) { fprintf(stderr, "TUNSETOFFLOAD ioctl() failed: %s\n", strerror(errno));
--------------------------------------------- Result 899 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 518 / 53 / 328 / 899:  33%|      | 899/2690 [10:47:30<21:29:59, 43.22s/it][Succeeded / Failed / Skipped / Total] 518 / 53 / 328 / 899:  33%|      | 900/2690 [10:47:31<21:27:51, 43.17s/it][Succeeded / Failed / Skipped / Total] 518 / 53 / 329 / 900:  33%|      | 900/2690 [10:47:31<21:27:51, 43.17s/it][Succeeded / Failed / Skipped / Total] 518 / 53 / 329 / 900:  33%|      | 901/2690 [10:47:31<21:25:43, 43.12s/it][Succeeded / Failed / Skipped / Total] 518 / 53 / 330 / 901:  33%|      | 901/2690 [10:47:31<21:25:43, 43.12s/it][Succeeded / Failed / Skipped / Total] 518 / 53 / 330 / 901:  34%|      | 902/2690 [10:50:20<21:29:09, 43.26s/it][Succeeded / Failed / Skipped / Total] 519 / 53 / 330 / 902:  34%|      | 902/2690 [10:50:20<21:29:09, 43.26s/it][Succeeded / Failed / Skipped / Total] 519 / 53 / 330 / 902:  34%|      | 903/2690 [10:50:36<21:27:31, 43.23s/it][[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void vga_draw_graphic(VGAState *s, int full_update) { int y1, y, update, page_min, page_max, linesize, y_start, double_scan, mask, depth; int width, height, shift_control, line_offset, page0, page1, bwidth, bits; int disp_width, multi_scan, multi_run; uint8_t *d; uint32_t v, addr1, addr; vga_draw_line_func *vga_draw_line; full_update |= update_basic_params(s); if (!full_update) vga_sync_dirty_bitmap(s); s->get_resolution(s, &width, &height); disp_width = width; shift_control = (s->gr[0x05] >> 5) & 3; double_scan = (s->cr[0x09] >> 7); if (shift_control != 1) { multi_scan = (((s->cr[0x09] & 0x1f) + 1) << double_scan) - 1; } else { multi_scan = double_scan; } multi_run = multi_scan; if (shift_control != s->shift_control || double_scan != s->double_scan) { full_update = 1; s->shift_control = shift_control; s->double_scan = double_scan; } if (shift_control == 0) { full_update |= update_palette16(s); if (s->sr[0x01] & 8) { v = VGA_DRAW_LINE4D2; disp_width <<= 1; } else { v = VGA_DRAW_LINE4; } bits = 4; } else if (shift_control == 1) { full_update |= update_palette16(s); if (s->sr[0x01] & 8) { v = VGA_DRAW_LINE2D2; disp_width <<= 1; } else { v = VGA_DRAW_LINE2; } bits = 4; } else { switch(s->get_bpp(s)) { default: case 0: full_update |= update_palette256(s); v = VGA_DRAW_LINE8D2; bits = 4; break; case 8: full_update |= update_palette256(s); v = VGA_DRAW_LINE8; bits = 8; break; case 15: v = VGA_DRAW_LINE15; bits = 16; break; case 16: v = VGA_DRAW_LINE16; bits = 16; break; case 24: v = VGA_DRAW_LINE24; bits = 24; break; case 32: v = VGA_DRAW_LINE32; bits = 32; break; } } vga_draw_line = vga_draw_line_table[v * NB_DEPTHS + get_depth_index(s->ds)]; depth = s->get_bpp(s); if (s->line_offset != s->last_line_offset || disp_width != s->last_width || height != s->last_height || s->last_depth != depth) { if (depth == 16 || depth == 32) { if (is_graphic_console()) { qemu_free_displaysurface(s->ds->surface); s->ds->surface = qemu_create_displaysurface_from(disp_width, height, depth, s->line_offset, s->vram_ptr + (s->start_addr * 4)); dpy_resize(s->ds); } else { qemu_console_resize(s->ds, disp_width, height); } } else { qemu_console_resize(s->ds, disp_width, height); } s->last_scr_width = disp_width; s->last_scr_height = height; s->last_width = disp_width; s->last_height = height; s->last_line_offset = s->line_offset; s->last_depth = depth; full_update = 1; } else if (is_graphic_console() && is_buffer_shared(s->ds->surface) && (full_update || s->ds->surface->data != s->vram_ptr + (s->start_addr * 4))) { s->ds->surface->data = s->vram_ptr + (s->start_addr * 4); dpy_setdata(s->ds); } s->rgb_to_pixel = rgb_to_pixel_dup_table[get_depth_index(s->ds)]; if (!is_buffer_shared(s->ds->surface) && s->cursor_invalidate) s->cursor_invalidate(s); line_offset = s->line_offset; #if 0 printf("w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\n", width, height, v, line_offset, s->cr[9], s->cr[0x17], s->line_compare, s->sr[0x01]); #endif addr1 = (s->start_addr * 4); bwidth = (width * bits + 7) / 8; y_start = -1; page_min = 0x7fffffff; page_max = -1; d = ds_get_data(s->ds); linesize = ds_get_linesize(s->ds); y1 = 0; for(y = 0; y < height; y++) { addr = addr1; if (!(s->cr[0x17] & 1)) { int shift; shift = 14 + ((s->cr[0x17] >> 6) & 1); addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift); } if (!(s->cr[0x17] & 2)) { addr = (addr & ~0x8000) | ((y1 & 2) << 14); } page0 = s->vram_offset + (addr & TARGET_PAGE_MASK); page1 = s->vram_offset + ((addr + bwidth - 1) & TARGET_PAGE_MASK); update = full_update | cpu_physical_memory_get_dirty(page0, VGA_DIRTY_FLAG) | cpu_physical_memory_get_dirty(page1, VGA_DIRTY_FLAG); if ((page1 - page0) > TARGET_PAGE_SIZE) { update |= cpu_physical_memory_get_dirty(page0 + TARGET_PAGE_SIZE, VGA_DIRTY_FLAG); } update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1; if (update) { if (y_start < 0) y_start = y; if (page0 < page_min) page_min = page0; if (page1 > page_max) page_max = page1; if (!(is_buffer_shared(s->ds->surface))) { vga_draw_line(s, d, s->vram_ptr + addr, width); if (s->cursor_draw_line) s->cursor_draw_line(s, d, y); } } else { if (y_start >= 0) { dpy_update(s->ds, 0, y_start, disp_width, y - y_start); y_start = -1; } } if (!multi_run) { mask = (s->cr[0x17] & 3) ^ 3; if ((y1 & mask) == mask) addr1 += line_offset; y1++; multi_run = multi_scan; } else { multi_run--; } if (y == s->line_compare) addr1 = 0; d += linesize; } if (y_start >= 0) { dpy_update(s->ds, 0, y_start, disp_width, y - y_start); } if (page_max != -1) { cpu_physical_memory_reset_dirty(page_min, page_max + TARGET_PAGE_SIZE, VGA_DIRTY_FLAG); } memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4); }
--------------------------------------------- Result 900 ---------------------------------------------
[[0 (25%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qemu_signalfd_compat(const sigset_t *mask) { pthread_attr_t attr; pthread_t tid; struct sigfd_compat_info *info; int fds[2]; info = malloc(sizeof(*info)); if (info == NULL) { errno = ENOMEM; return -1; } if (pipe(fds) == -1) { free(info); return -1; } memcpy(&info->mask, mask, sizeof(*mask)); info->fd = fds[1]; pthread_attr_init(&attr); pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED); pthread_create(&tid, &attr, sigwait_compat, info); pthread_attr_destroy(&attr); return fds[0]; }
--------------------------------------------- Result 901 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len) { uint32_t startlen = read_u32(data, 0); VNC_DEBUG("Got client start len %d\n", startlen); if (startlen > SASL_DATA_MAX_LEN) { VNC_DEBUG("Too much SASL data %d\n", startlen); vnc_client_error(vs); return -1; } if (startlen == 0) return protocol_client_auth_sasl_start(vs, NULL, 0); vnc_read_when(vs, protocol_client_auth_sasl_start, startlen); return 0; }
--------------------------------------------- Result 902 ---------------------------------------------
[[0 (72%)]] --> [[0 (48%)]] --> Socre: 0.5182698369026184

[[[[Adv]]]]: static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw, cavs_vector *col_mv) { cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS; int [[den]] = h->direct_den[col_mv->ref]; int [[m]] = FF_SIGNBIT(col_mv->x); pmv_fw->dist = h->dist[1]; pmv_bw->dist = h->dist[0]; pmv_fw->ref = 1; pmv_bw->ref = 0; pmv_fw->x = ((([[den]] + ([[den]] * col_mv->x * pmv_fw->dist ^ [[m]]) - [[m]] - 1) >> 14) ^ [[m]]) - [[m]]; pmv_bw->x = [[m]] - ((([[den]] + ([[den]] * col_mv->x * pmv_bw->dist ^ [[m]]) - [[m]] - 1) >> 14) ^ [[m]]); [[m]] = FF_SIGNBIT(col_mv->y); pmv_fw->y = ((([[den]] + ([[den]] * col_mv->y * pmv_fw->dist ^ [[m]]) - [[m]] - 1) >> 14) ^ [[m]]) - [[m]]; pmv_bw->y = [[m]] - ((([[den]] + ([[den]] * col_mv->y * pmv_bw->dist ^ [[m]]) - [[m]] - 1) >> 14) ^ [[m]]); }

[[[[Adv]]]]: static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw, cavs_vector *col_mv) { cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS; int [[parlors]] = h->direct_den[col_mv->ref]; int [[magpies]] = FF_SIGNBIT(col_mv->x); pmv_fw->dist = h->dist[1]; pmv_bw->dist = h->dist[0]; pmv_fw->ref = 1; pmv_bw->ref = 0; pmv_fw->x = ((([[parlors]] + ([[parlors]] * col_mv->x * pmv_fw->dist ^ [[magpies]]) - [[magpies]] - 1) >> 14) ^ [[magpies]]) - [[magpies]]; pmv_bw->x = [[magpies]] - ((([[parlors]] + ([[parlors]] * col_mv->x * pmv_bw->dist ^ [[magpies]]) - [[magpies]] - 1) >> 14) ^ [[magpies]]); [[magpies]] = FF_SIGNBIT(col_mv->y); pmv_fw->y = ((([[parlors]] + ([[parlors]] * col_mv->y * pmv_fw->dist ^ [[magpies]]) - [[magpies]] - 1) >> 14) ^ [[magpies]]) - [[magpies]]; pmv_bw->y = [[magpies]] - ((([[parlors]] + ([[parlors]] * col_mv->y * pmv_bw->dist ^ [[magpies]]) - [[magpies]] - 1) >> 14) ^ [[magpies]]); }
--------------------------------------------- Result 903 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 520 / 53 / 330 / 903:  34%|      | 903/2690 [10:50:36<21:27:31, 43.23s/it][Succeeded / Failed / Skipped / Total] 520 / 53 / 330 / 903:  34%|      | 904/2690 [10:50:55<21:26:00, 43.20s/it][Succeeded / Failed / Skipped / Total] 521 / 53 / 330 / 904:  34%|      | 904/2690 [10:50:55<21:26:00, 43.20s/it][Succeeded / Failed / Skipped / Total] 521 / 53 / 330 / 904:  34%|      | 905/2690 [10:50:55<21:23:53, 43.16s/it][Succeeded / Failed / Skipped / Total] 521 / 53 / 331 / 905:  34%|      | 905/2690 [10:50:55<21:23:53, 43.16s/it][Succeeded / Failed / Skipped / Total] 521 / 53 / 331 / 905:  34%|      | 906/2690 [10:51:00<21:21:54, 43.11s/it][[0 (17%)]] --> [[0 (58%)]] --> Socre: 0.5831208825111389

[[[[Adv]]]]: static inline void h264_deblock_q1(register vector [[unsigned]] char [[p0]], register vector [[unsigned]] char p1, register vector [[unsigned]] char p2, register vector [[unsigned]] char q0, register vector [[unsigned]] char tc0) { register vector unsigned char average = vec_avg([[p0]], q0); register vector unsigned char temp; register vector unsigned char uncliped; register vector unsigned char [[ones]]; register vector unsigned char max; register vector unsigned char min; temp = vec_xor(average, p2); average = vec_avg(average, p2); [[ones]] = vec_splat_u8(1); temp = vec_and(temp, [[ones]]); uncliped = vec_subs(average, temp); max = vec_adds(p1, tc0); min = vec_subs(p1, tc0); p1 = vec_max(min, uncliped); p1 = vec_min(max, p1); }

[[[[Adv]]]]: static inline void h264_deblock_q1(register vector [[unconfirmed]] char [[peppino]], register vector [[unconfirmed]] char p1, register vector [[unconfirmed]] char p2, register vector [[unconfirmed]] char q0, register vector [[unconfirmed]] char tc0) { register vector unsigned char average = vec_avg([[peppino]], q0); register vector unsigned char temp; register vector unsigned char uncliped; register vector unsigned char [[yours]]; register vector unsigned char max; register vector unsigned char min; temp = vec_xor(average, p2); average = vec_avg(average, p2); [[yours]] = vec_splat_u8(1); temp = vec_and(temp, [[yours]]); uncliped = vec_subs(average, temp); max = vec_adds(p1, tc0); min = vec_subs(p1, tc0); p1 = vec_max(min, uncliped); p1 = vec_min(max, p1); }
--------------------------------------------- Result 904 ---------------------------------------------
[[0 (2%)]] --> [[0 (50%)]] --> Socre: 0.501009464263916

[[[[Adv]]]]: static inline void gen_branch_a(DisasContext *[[dc]], target_ulong pc1, target_ulong [[pc2]], TCGv [[r_cond]]) { int [[l1]]; [[l1]] = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_EQ, [[r_cond]], 0, [[l1]]); gen_goto_tb([[dc]], 0, [[pc2]], pc1); gen_set_label([[l1]]); gen_goto_tb([[dc]], 1, [[pc2]] + 4, [[pc2]] + 8); }

[[[[Adv]]]]: static inline void gen_branch_a(DisasContext *[[city]], target_ulong pc1, target_ulong [[mils]], TCGv [[corinne]]) { int [[convincing]]; [[convincing]] = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_EQ, [[corinne]], 0, [[convincing]]); gen_goto_tb([[city]], 0, [[mils]], pc1); gen_set_label([[convincing]]); gen_goto_tb([[city]], 1, [[mils]] + 4, [[mils]] + 8); }
--------------------------------------------- Result 905 ---------------------------------------------
[[0 (97%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs, uint64_t offset, int n_start, int n_end, int *num, QCowL2Meta *m) { BDRVQcowState *s = bs->opaque; int l2_index, ret; uint64_t l2_offset, *l2_table, cluster_offset; int nb_clusters, i = 0; QCowL2Meta *old_alloc; ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index); if (ret == 0) return 0; nb_clusters = size_to_clusters(s, n_end << 9); nb_clusters = MIN(nb_clusters, s->l2_size - l2_index); cluster_offset = be64_to_cpu(l2_table[l2_index]); if (cluster_offset & QCOW_OFLAG_COPIED) { nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size, &l2_table[l2_index], 0, 0); cluster_offset &= ~QCOW_OFLAG_COPIED; m->nb_clusters = 0; goto out; } if (cluster_offset & QCOW_OFLAG_COMPRESSED) nb_clusters = 1; while (i < nb_clusters) { i += count_contiguous_clusters(nb_clusters - i, s->cluster_size, &l2_table[l2_index], i, 0); if(be64_to_cpu(l2_table[l2_index + i])) break; i += count_contiguous_free_clusters(nb_clusters - i, &l2_table[l2_index + i]); cluster_offset = be64_to_cpu(l2_table[l2_index + i]); if ((cluster_offset & QCOW_OFLAG_COPIED) || (cluster_offset & QCOW_OFLAG_COMPRESSED)) break; } nb_clusters = i; LIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) { uint64_t end_offset = offset + nb_clusters * s->cluster_size; uint64_t old_offset = old_alloc->offset; uint64_t old_end_offset = old_alloc->offset + old_alloc->nb_clusters * s->cluster_size; if (end_offset < old_offset || offset > old_end_offset) { } else { if (offset < old_offset) { nb_clusters = (old_offset - offset) >> s->cluster_bits; } else { nb_clusters = 0; } if (nb_clusters == 0) { m->depends_on = old_alloc; m->nb_clusters = 0; *num = 0; return 0; } } } if (!nb_clusters) { abort(); } LIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight); cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size); m->offset = offset; m->n_start = n_start; m->nb_clusters = nb_clusters; out: m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end); *num = m->nb_available - n_start; return cluster_offset; }
--------------------------------------------- Result 906 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 522 / 53 / 331 / 906:  34%|      | 906/2690 [10:51:00<21:21:54, 43.11s/it][Succeeded / Failed / Skipped / Total] 522 / 53 / 331 / 906:  34%|      | 907/2690 [10:52:13<21:22:10, 43.15s/it][Succeeded / Failed / Skipped / Total] 523 / 53 / 331 / 907:  34%|      | 907/2690 [10:52:13<21:22:10, 43.15s/it][Succeeded / Failed / Skipped / Total] 523 / 53 / 331 / 907:  34%|      | 908/2690 [10:52:14<21:20:03, 43.10s/it][Succeeded / Failed / Skipped / Total] 523 / 53 / 332 / 908:  34%|      | 908/2690 [10:52:14<21:20:03, 43.10s/it][Succeeded / Failed / Skipped / Total] 523 / 53 / 332 / 908:  34%|      | 909/2690 [10:52:15<21:17:57, 43.05s/it][Succeeded / Failed / Skipped / Total] 523 / 53 / 333 / 909:  34%|      | 909/2690 [10:52:15<21:17:57, 43.05s/it][Succeeded / Failed / Skipped / Total] 523 / 53 / 333 / 909:  34%|      | 910/2690 [10:52:15<21:15:50, 43.01s/it][[0 (50%)]] --> [[0 (52%)]] --> Socre: 0.5177592635154724

[[[[Adv]]]]: static int tx_consume(Rocker *r, DescInfo *info) { PCIDevice *dev = PCI_DEVICE(r); char *buf = desc_get_buf(info, "True" == "True"); RockerTlv *tlv_frag; RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1]; struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, }; uint32_t pport; uint32_t port; uint16_t tx_offload = ROCKER_TX_OFFLOAD_NONE; uint16_t tx_l3_csum_off = 0; uint16_t tx_tso_mss = 0; uint16_t tx_tso_hdr_len = 0; int iovcnt = 0; int err = ROCKER_OK; int rem; int i; if (!buf) { return -ROCKER_ENXIO; } rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info)); if (!tlvs[[[ROCKER_TLV_TX_FRAGS]]]) { return -ROCKER_EINVAL; } pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info)); if (!fp_port_from_pport(pport, &port)) { return -ROCKER_EINVAL; } if (tlvs[ROCKER_TLV_TX_OFFLOAD]) { tx_offload = rocker_tlv_get_u8(tlvs[ROCKER_TLV_TX_OFFLOAD]); } switch (tx_offload) { case ROCKER_TX_OFFLOAD_L3_CSUM: if (!tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) { return -ROCKER_EINVAL; } break; case ROCKER_TX_OFFLOAD_TSO: if (!tlvs[ROCKER_TLV_TX_TSO_MSS] || !tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) { return -ROCKER_EINVAL; } break; } if (tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) { tx_l3_csum_off = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]); } if (tlvs[ROCKER_TLV_TX_TSO_MSS]) { tx_tso_mss = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_MSS]); } if (tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) { tx_tso_hdr_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]); } rocker_tlv_for_each_nested(tlv_frag, tlvs[[[ROCKER_TLV_TX_FRAGS]]], rem) { hwaddr frag_addr; uint16_t frag_len; if (rocker_tlv_type(tlv_frag) != ROCKER_TLV_TX_FRAG) { err = -ROCKER_EINVAL; goto err_bad_attr; } rocker_tlv_parse_nested(tlvs, ROCKER_TLV_TX_FRAG_ATTR_MAX, tlv_frag); if (!tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR] || !tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]) { err = -ROCKER_EINVAL; goto err_bad_attr; } frag_addr = rocker_tlv_get_le64(tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR]); frag_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]); iov[iovcnt].iov_len = frag_len; iov[iovcnt].iov_base = g_malloc(frag_len); if (!iov[iovcnt].iov_base) { err = -ROCKER_ENOMEM; goto err_no_mem; } if (pci_dma_read(dev, frag_addr, iov[iovcnt].iov_base, iov[iovcnt].iov_len)) { err = -ROCKER_ENXIO; goto err_bad_io; } if (++iovcnt > ROCKER_TX_FRAGS_MAX) { goto err_too_many_frags; } } if (iovcnt) { tx_l3_csum_off += tx_tso_mss = tx_tso_hdr_len = 0; } err = fp_port_eg(r->fp_port[port], iov, iovcnt); err_too_many_frags: err_bad_io: err_no_mem: err_bad_attr: for (i = 0; i < ROCKER_TX_FRAGS_MAX; i++) { if (iov[i].iov_base) { g_free(iov[i].iov_base); } } return err; }

[[[[Adv]]]]: static int tx_consume(Rocker *r, DescInfo *info) { PCIDevice *dev = PCI_DEVICE(r); char *buf = desc_get_buf(info, "True" == "True"); RockerTlv *tlv_frag; RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1]; struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, }; uint32_t pport; uint32_t port; uint16_t tx_offload = ROCKER_TX_OFFLOAD_NONE; uint16_t tx_l3_csum_off = 0; uint16_t tx_tso_mss = 0; uint16_t tx_tso_hdr_len = 0; int iovcnt = 0; int err = ROCKER_OK; int rem; int i; if (!buf) { return -ROCKER_ENXIO; } rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info)); if (!tlvs[[[CHARACTERS]]]) { return -ROCKER_EINVAL; } pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info)); if (!fp_port_from_pport(pport, &port)) { return -ROCKER_EINVAL; } if (tlvs[ROCKER_TLV_TX_OFFLOAD]) { tx_offload = rocker_tlv_get_u8(tlvs[ROCKER_TLV_TX_OFFLOAD]); } switch (tx_offload) { case ROCKER_TX_OFFLOAD_L3_CSUM: if (!tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) { return -ROCKER_EINVAL; } break; case ROCKER_TX_OFFLOAD_TSO: if (!tlvs[ROCKER_TLV_TX_TSO_MSS] || !tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) { return -ROCKER_EINVAL; } break; } if (tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) { tx_l3_csum_off = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]); } if (tlvs[ROCKER_TLV_TX_TSO_MSS]) { tx_tso_mss = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_MSS]); } if (tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) { tx_tso_hdr_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]); } rocker_tlv_for_each_nested(tlv_frag, tlvs[[[CHARACTERS]]], rem) { hwaddr frag_addr; uint16_t frag_len; if (rocker_tlv_type(tlv_frag) != ROCKER_TLV_TX_FRAG) { err = -ROCKER_EINVAL; goto err_bad_attr; } rocker_tlv_parse_nested(tlvs, ROCKER_TLV_TX_FRAG_ATTR_MAX, tlv_frag); if (!tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR] || !tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]) { err = -ROCKER_EINVAL; goto err_bad_attr; } frag_addr = rocker_tlv_get_le64(tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR]); frag_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]); iov[iovcnt].iov_len = frag_len; iov[iovcnt].iov_base = g_malloc(frag_len); if (!iov[iovcnt].iov_base) { err = -ROCKER_ENOMEM; goto err_no_mem; } if (pci_dma_read(dev, frag_addr, iov[iovcnt].iov_base, iov[iovcnt].iov_len)) { err = -ROCKER_ENXIO; goto err_bad_io; } if (++iovcnt > ROCKER_TX_FRAGS_MAX) { goto err_too_many_frags; } } if (iovcnt) { tx_l3_csum_off += tx_tso_mss = tx_tso_hdr_len = 0; } err = fp_port_eg(r->fp_port[port], iov, iovcnt); err_too_many_frags: err_bad_io: err_no_mem: err_bad_attr: for (i = 0; i < ROCKER_TX_FRAGS_MAX; i++) { if (iov[i].iov_base) { g_free(iov[i].iov_base); } } return err; }
--------------------------------------------- Result 907 ---------------------------------------------
[[0 (46%)]] --> [[0 (51%)]] --> Socre: 0.5132290720939636

[[[[Adv]]]]: MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB, CharDriverState *chrA, CharDriverState *chrB, int clock, int [[it_shift]]) { DeviceState *dev; SysBusDevice *s; SerialState *d; dev = qdev_create(NULL, "escc"); qdev_prop_set_uint32(dev, "disabled", 0); qdev_prop_set_uint32(dev, "frequency", clock); qdev_prop_set_uint32(dev, "it_shift", [[it_shift]]); qdev_prop_set_chr(dev, "chrB", chrB); qdev_prop_set_chr(dev, "chrA", chrA); qdev_prop_set_uint32(dev, "chnBtype", ser); qdev_prop_set_uint32(dev, "chnAtype", ser); qdev_init_nofail(dev); s = sysbus_from_qdev(dev); sysbus_connect_irq(s, 0, irqB); sysbus_connect_irq(s, 1, irqA); if (base) { sysbus_mmio_map(s, 0, base); } d = FROM_SYSBUS(SerialState, s); return &d->mmio; }

[[[[Adv]]]]: MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB, CharDriverState *chrA, CharDriverState *chrB, int clock, int [[domesticated]]) { DeviceState *dev; SysBusDevice *s; SerialState *d; dev = qdev_create(NULL, "escc"); qdev_prop_set_uint32(dev, "disabled", 0); qdev_prop_set_uint32(dev, "frequency", clock); qdev_prop_set_uint32(dev, "it_shift", [[domesticated]]); qdev_prop_set_chr(dev, "chrB", chrB); qdev_prop_set_chr(dev, "chrA", chrA); qdev_prop_set_uint32(dev, "chnBtype", ser); qdev_prop_set_uint32(dev, "chnAtype", ser); qdev_init_nofail(dev); s = sysbus_from_qdev(dev); sysbus_connect_irq(s, 0, irqB); sysbus_connect_irq(s, 1, irqA); if (base) { sysbus_mmio_map(s, 0, base); } d = FROM_SYSBUS(SerialState, s); return &d->mmio; }
--------------------------------------------- Result 908 ---------------------------------------------
[[0 (47%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void free_geotags(TiffContext *const s) { int i; for (i = 0; i < s->geotag_count; i++) { if (s->geotags[i].val) av_freep(&s->geotags[i].val); } av_freep(&s->geotags); }
--------------------------------------------- Result 909 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_bink_idct_c(DCTELEM *block) { int i; DCTELEM temp[64]; for (i = 0; i < 8; i++) bink_idct_col(&temp[i], &block[i]); for (i = 0; i < 8; i++) { IDCT_ROW( (&block[8*i]), (&temp[8*i]) ); } }
--------------------------------------------- Result 910 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 523 / 53 / 334 / 910:  34%|      | 910/2690 [10:52:15<21:15:50, 43.01s/it][Succeeded / Failed / Skipped / Total] 523 / 53 / 334 / 910:  34%|      | 911/2690 [10:52:31<21:14:15, 42.98s/it][Succeeded / Failed / Skipped / Total] 524 / 53 / 334 / 911:  34%|      | 911/2690 [10:52:31<21:14:15, 42.98s/it][Succeeded / Failed / Skipped / Total] 524 / 53 / 334 / 911:  34%|      | 912/2690 [10:52:37<21:12:20, 42.94s/it][Succeeded / Failed / Skipped / Total] 525 / 53 / 334 / 912:  34%|      | 912/2690 [10:52:37<21:12:20, 42.94s/it][Succeeded / Failed / Skipped / Total] 525 / 53 / 334 / 912:  34%|      | 913/2690 [10:52:45<21:10:28, 42.90s/it][Succeeded / Failed / Skipped / Total] 526 / 53 / 334 / 913:  34%|      | 913/2690 [10:52:45<21:10:28, 42.90s/it][Succeeded / Failed / Skipped / Total] 526 / 53 / 334 / 913:  34%|      | 914/2690 [10:52:50<21:08:32, 42.86s/it][Succeeded / Failed / Skipped / Total] 527 / 53 / 334 / 914:  34%|      | 914/2690 [10:52:50<21:08:32, 42.86s/it][Succeeded / Failed / Skipped / Total] 527 / 53 / 334 / 914:  34%|      | 915/2690 [10:52:50<21:06:27, 42.81s/it][[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: PCIBus *pci_pmac_init(qemu_irq *pic) { DeviceState *dev; SysBusDevice *s; UNINState *d; dev = qdev_create(NULL, "Uni-north main"); qdev_init_nofail(dev); s = sysbus_from_qdev(dev); d = FROM_SYSBUS(UNINState, s); d->host_state.bus = pci_register_bus(&d->busdev.qdev, "pci", pci_unin_set_irq, pci_unin_map_irq, pic, 11 << 3, 4); pci_create_simple(d->host_state.bus, 11 << 3, "Uni-north main"); sysbus_mmio_map(s, 0, 0xf2800000); sysbus_mmio_map(s, 1, 0xf2c00000); #if 0 pci_create_simple(d->host_state.bus, 12 << 3, "DEC 21154"); #endif pci_create_simple(d->host_state.bus, 13 << 3, "Uni-north AGP"); #if 0 pci_create_simple(d->host_state.bus, 14 << 3, "Uni-north internal"); #endif return d->host_state.bus; }
--------------------------------------------- Result 911 ---------------------------------------------
[[0 (26%)]] --> [[0 (79%)]] --> Socre: 0.7905033230781555

[[[[Adv]]]]: static void json_message_process_token(JSONLexer *[[lexer]], GString *input, JSONTokenType type, int x, int y) { JSONMessageParser *parser = container_of([[lexer]], JSONMessageParser, [[lexer]]); QDict *dict; switch (type) { case JSON_LCURLY: parser->brace_count++; break; case JSON_RCURLY: parser->brace_count--; break; case JSON_LSQUARE: parser->bracket_count++; break; case JSON_RSQUARE: parser->bracket_count--; break; default: break; } dict = qdict_new(); qdict_put(dict, "type", qint_from_int(type)); qdict_put(dict, "token", qstring_from_str(input->str)); qdict_put(dict, "x", qint_from_int(x)); qdict_put(dict, "y", qint_from_int(y)); parser->token_size += input->len; g_queue_push_tail(parser->tokens, dict); if (type == JSON_ERROR) { goto out_emit_bad; } else if (parser->brace_count < 0 || parser->bracket_count < 0 || (parser->brace_count == 0 && parser->bracket_count == 0)) { goto out_emit; } else if (parser->token_size > MAX_TOKEN_SIZE || parser->bracket_count + parser->brace_count > MAX_NESTING) { goto out_emit_bad; } return; out_emit_bad: json_message_free_tokens(parser); out_emit: parser->brace_count = 0; parser->bracket_count = 0; parser->emit(parser, parser->tokens); parser->tokens = g_queue_new(); parser->token_size = 0; }

[[[[Adv]]]]: static void json_message_process_token(JSONLexer *[[distorted]], GString *input, JSONTokenType type, int x, int y) { JSONMessageParser *parser = container_of([[distorted]], JSONMessageParser, [[distorted]]); QDict *dict; switch (type) { case JSON_LCURLY: parser->brace_count++; break; case JSON_RCURLY: parser->brace_count--; break; case JSON_LSQUARE: parser->bracket_count++; break; case JSON_RSQUARE: parser->bracket_count--; break; default: break; } dict = qdict_new(); qdict_put(dict, "type", qint_from_int(type)); qdict_put(dict, "token", qstring_from_str(input->str)); qdict_put(dict, "x", qint_from_int(x)); qdict_put(dict, "y", qint_from_int(y)); parser->token_size += input->len; g_queue_push_tail(parser->tokens, dict); if (type == JSON_ERROR) { goto out_emit_bad; } else if (parser->brace_count < 0 || parser->bracket_count < 0 || (parser->brace_count == 0 && parser->bracket_count == 0)) { goto out_emit; } else if (parser->token_size > MAX_TOKEN_SIZE || parser->bracket_count + parser->brace_count > MAX_NESTING) { goto out_emit_bad; } return; out_emit_bad: json_message_free_tokens(parser); out_emit: parser->brace_count = 0; parser->bracket_count = 0; parser->emit(parser, parser->tokens); parser->tokens = g_queue_new(); parser->token_size = 0; }
--------------------------------------------- Result 912 ---------------------------------------------
[[0 (20%)]] --> [[0 (85%)]] --> Socre: 0.8468778729438782

[[[[Adv]]]]: static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env, target_ulong eaddr, uint32_t pid) { #if !defined(FLUSH_ALL_TLBS) CPUState *cs = CPU(ppc_env_get_cpu(env)); ppcemb_tlb_t *tlb; hwaddr [[raddr]]; target_ulong page, end; int i; for (i = 0; i < env->nb_tlb; i++) { tlb = &env->tlb.tlbe[i]; if (ppcemb_tlb_check(env, tlb, &[[raddr]], eaddr, pid, 0, i) == 0) { end = tlb->EPN + tlb->size; for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) { tlb_flush_page(cs, page); } tlb->prot &= ~PAGE_VALID; break; } } #else ppc4xx_tlb_invalidate_all(env); #endif }

[[[[Adv]]]]: static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env, target_ulong eaddr, uint32_t pid) { #if !defined(FLUSH_ALL_TLBS) CPUState *cs = CPU(ppc_env_get_cpu(env)); ppcemb_tlb_t *tlb; hwaddr [[tak]]; target_ulong page, end; int i; for (i = 0; i < env->nb_tlb; i++) { tlb = &env->tlb.tlbe[i]; if (ppcemb_tlb_check(env, tlb, &[[tak]], eaddr, pid, 0, i) == 0) { end = tlb->EPN + tlb->size; for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) { tlb_flush_page(cs, page); } tlb->prot &= ~PAGE_VALID; break; } } #else ppc4xx_tlb_invalidate_all(env); #endif }
--------------------------------------------- Result 913 ---------------------------------------------
[[0 (38%)]] --> [[0 (55%)]] --> Socre: 0.5458129048347473

[[[[Adv]]]]: void pci_bridge_initfn(PCIDevice *dev, const char *[[typename]]) { PCIBus *parent = dev->bus; PCIBridge *br = PCI_BRIDGE(dev); PCIBus *[[sec_bus]] = &br->sec_bus; pci_word_test_and_set_mask(dev->config + PCI_STATUS, PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK); pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI); dev->config[PCI_HEADER_TYPE] = (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) | PCI_HEADER_TYPE_BRIDGE; pci_set_word(dev->config + PCI_SEC_STATUS, PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK); if (!br->bus_name && dev->qdev.id && *dev->qdev.id) { br->bus_name = dev->qdev.id; } qbus_create_inplace([[sec_bus]], sizeof(br->sec_bus), [[typename]], DEVICE(dev), br->bus_name); [[sec_bus]]->parent_dev = dev; [[sec_bus]]->map_irq = br->map_irq ? br->map_irq : pci_swizzle_map_irq_fn; [[sec_bus]]->address_space_mem = &br->address_space_mem; memory_region_init(&br->address_space_mem, OBJECT(br), "pci_bridge_pci", UINT64_MAX); [[sec_bus]]->address_space_io = &br->address_space_io; memory_region_init(&br->address_space_io, OBJECT(br), "pci_bridge_io", 65536); br->windows = pci_bridge_region_init(br); QLIST_INIT(&[[sec_bus]]->child); QLIST_INSERT_HEAD(&parent->child, [[sec_bus]], sibling); }

[[[[Adv]]]]: void pci_bridge_initfn(PCIDevice *dev, const char *[[girlfriends]]) { PCIBus *parent = dev->bus; PCIBridge *br = PCI_BRIDGE(dev); PCIBus *[[surveilling]] = &br->sec_bus; pci_word_test_and_set_mask(dev->config + PCI_STATUS, PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK); pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI); dev->config[PCI_HEADER_TYPE] = (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) | PCI_HEADER_TYPE_BRIDGE; pci_set_word(dev->config + PCI_SEC_STATUS, PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK); if (!br->bus_name && dev->qdev.id && *dev->qdev.id) { br->bus_name = dev->qdev.id; } qbus_create_inplace([[surveilling]], sizeof(br->sec_bus), [[girlfriends]], DEVICE(dev), br->bus_name); [[surveilling]]->parent_dev = dev; [[surveilling]]->map_irq = br->map_irq ? br->map_irq : pci_swizzle_map_irq_fn; [[surveilling]]->address_space_mem = &br->address_space_mem; memory_region_init(&br->address_space_mem, OBJECT(br), "pci_bridge_pci", UINT64_MAX); [[surveilling]]->address_space_io = &br->address_space_io; memory_region_init(&br->address_space_io, OBJECT(br), "pci_bridge_io", 65536); br->windows = pci_bridge_region_init(br); QLIST_INIT(&[[surveilling]]->child); QLIST_INSERT_HEAD(&parent->child, [[surveilling]], sibling); }
--------------------------------------------- Result 914 ---------------------------------------------
[[0 (10%)]] --> [[0 (67%)]] --> Socre: 0.6690992712974548

[[[[Adv]]]]: void qemu_pixman_linebuf_fill(pixman_image_t *[[linebuf]], pixman_image_t *fb, int width, int y) { pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, [[linebuf]], 0, y, 0, 0, 0, 0, width, 1); }

[[[[Adv]]]]: void qemu_pixman_linebuf_fill(pixman_image_t *[[trespassers]], pixman_image_t *fb, int width, int y) { pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, [[trespassers]], 0, y, 0, 0, 0, 0, width, 1); }
--------------------------------------------- Result 915 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 527 / 53 / 335 / 915:  34%|      | 915/2690 [10:52:50<21:06:27, 42.81s/it][Succeeded / Failed / Skipped / Total] 527 / 53 / 335 / 915:  34%|      | 916/2690 [10:52:55<21:04:30, 42.77s/it][Succeeded / Failed / Skipped / Total] 528 / 53 / 335 / 916:  34%|      | 916/2690 [10:52:55<21:04:30, 42.77s/it][Succeeded / Failed / Skipped / Total] 528 / 53 / 335 / 916:  34%|      | 917/2690 [10:53:48<21:04:07, 42.78s/it][Succeeded / Failed / Skipped / Total] 529 / 53 / 335 / 917:  34%|      | 917/2690 [10:53:48<21:04:07, 42.78s/it][Succeeded / Failed / Skipped / Total] 529 / 53 / 335 / 917:  34%|      | 918/2690 [10:53:48<21:02:02, 42.73s/it][Succeeded / Failed / Skipped / Total] 529 / 53 / 336 / 918:  34%|      | 918/2690 [10:53:48<21:02:02, 42.73s/it][Succeeded / Failed / Skipped / Total] 529 / 53 / 336 / 918:  34%|      | 919/2690 [10:53:49<20:59:58, 42.69s/it][[0 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline abi_long target_to_host_cmsg(struct msghdr *msgh, struct target_msghdr *target_msgh) { struct cmsghdr *cmsg = CMSG_FIRSTHDR(msgh); abi_long msg_controllen; abi_ulong target_cmsg_addr; struct target_cmsghdr *target_cmsg; socklen_t space = 0; msg_controllen = tswapal(target_msgh->msg_controllen); if (msg_controllen < sizeof (struct target_cmsghdr)) goto the_end; target_cmsg_addr = tswapal(target_msgh->msg_control); target_cmsg = lock_user(VERIFY_READ, target_cmsg_addr, msg_controllen, 1); if (!target_cmsg) return -TARGET_EFAULT; while (cmsg && target_cmsg) { void *data = CMSG_DATA(cmsg); void *target_data = TARGET_CMSG_DATA(target_cmsg); int len = tswapal(target_cmsg->cmsg_len) - TARGET_CMSG_ALIGN(sizeof (struct target_cmsghdr)); space += CMSG_SPACE(len); if (space > msgh->msg_controllen) { space -= CMSG_SPACE(len); gemu_log("Host cmsg overflow\n"); break; } if (tswap32(target_cmsg->cmsg_level) == TARGET_SOL_SOCKET) { cmsg->cmsg_level = SOL_SOCKET; } else { cmsg->cmsg_level = tswap32(target_cmsg->cmsg_level); } cmsg->cmsg_type = tswap32(target_cmsg->cmsg_type); cmsg->cmsg_len = CMSG_LEN(len); if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) { gemu_log("Unsupported ancillary data: %d/%d\n", cmsg->cmsg_level, cmsg->cmsg_type); memcpy(data, target_data, len); } else { int *fd = (int *)data; int *target_fd = (int *)target_data; int i, numfds = len / sizeof(int); for (i = 0; i < numfds; i++) fd[i] = tswap32(target_fd[i]); } cmsg = CMSG_NXTHDR(msgh, cmsg); target_cmsg = TARGET_CMSG_NXTHDR(target_msgh, target_cmsg); } unlock_user(target_cmsg, target_cmsg_addr, 0); the_end: msgh->msg_controllen = space; return 0; }
--------------------------------------------- Result 916 ---------------------------------------------
[[0 (47%)]] --> [[0 (65%)]] --> Socre: 0.6454578638076782

[[[[Adv]]]]: static bool ga_open_pidfile(const char *[[pidfile]]) { int pidfd; char pidstr[32]; pidfd = open([[pidfile]], O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR); if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) { g_critical("Cannot lock pid file, %s", strerror(errno)); if (pidfd != -1) { close(pidfd); } return "False" != "False"; } if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) { g_critical("Failed to truncate pid file"); goto fail; } sprintf(pidstr, "%d", getpid()); if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) { g_critical("Failed to write pid file"); goto fail; } return "True" == "True"; fail: unlink([[pidfile]]); return "False" != "False"; }

[[[[Adv]]]]: static bool ga_open_pidfile(const char *[[muta]]) { int pidfd; char pidstr[32]; pidfd = open([[muta]], O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR); if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) { g_critical("Cannot lock pid file, %s", strerror(errno)); if (pidfd != -1) { close(pidfd); } return "False" != "False"; } if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) { g_critical("Failed to truncate pid file"); goto fail; } sprintf(pidstr, "%d", getpid()); if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) { g_critical("Failed to write pid file"); goto fail; } return "True" == "True"; fail: unlink([[muta]]); return "False" != "False"; }
--------------------------------------------- Result 917 ---------------------------------------------
[[0 (71%)]] --> [[0 (48%)]] --> Socre: 0.520773857831955

[[[[Adv]]]]: static void handle_pending_signal(CPUArchState *cpu_env, int [[sig]]) { CPUState *[[cpu]] = ENV_GET_CPU(cpu_env); abi_ulong handler; sigset_t [[set]], old_set; target_sigset_t [[target_old_set]]; struct target_sigaction *sa; struct sigqueue *q; TaskState *[[ts]] = [[cpu]]->opaque; struct emulated_sigtable *k = &[[ts]]->sigtab[[[sig]] - 1]; trace_user_handle_signal(cpu_env, [[sig]]); q = k->first; k->first = q->next; if (!k->first) k->pending = 0; [[sig]] = gdb_handlesig([[cpu]], [[sig]]); if (![[sig]]) { sa = NULL; handler = TARGET_SIG_IGN; } else { sa = &sigact_table[[[sig]] - 1]; handler = sa->_sa_handler; } if ([[ts]]->sigsegv_blocked && [[sig]] == TARGET_SIGSEGV) { handler = TARGET_SIG_DFL; } if (handler == TARGET_SIG_DFL) { if ([[sig]] == TARGET_SIGTSTP || [[sig]] == TARGET_SIGTTIN || [[sig]] == TARGET_SIGTTOU) { kill(getpid(),SIGSTOP); } else if ([[sig]] != TARGET_SIGCHLD && [[sig]] != TARGET_SIGURG && [[sig]] != TARGET_SIGWINCH && [[sig]] != TARGET_SIGCONT) { force_sig([[sig]]); } } else if (handler == TARGET_SIG_IGN) { } else if (handler == TARGET_SIG_ERR) { force_sig([[sig]]); } else { target_to_host_sigset(&[[set]], &sa->sa_mask); if (!(sa->sa_flags & TARGET_SA_NODEFER)) sigaddset(&[[set]], target_to_host_signal([[sig]])); do_sigprocmask(SIG_BLOCK, &[[set]], &old_set); host_to_target_sigset_internal(&[[target_old_set]], &old_set); #if defined(TARGET_I386) && !defined(TARGET_X86_64) { CPUX86State *env = cpu_env; if (env->eflags & VM_MASK) save_v86_state(env); } #endif #if defined(TARGET_ABI_MIPSN32) || defined(TARGET_ABI_MIPSN64) \ || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX) setup_rt_frame([[sig]], sa, &q->info, &[[target_old_set]], cpu_env); #else if (sa->sa_flags & TARGET_SA_SIGINFO) setup_rt_frame([[sig]], sa, &q->info, &[[target_old_set]], cpu_env); else setup_frame([[sig]], sa, &[[target_old_set]], cpu_env); #endif if (sa->sa_flags & TARGET_SA_RESETHAND) { sa->_sa_handler = TARGET_SIG_DFL; } } if (q != &k->info) free_sigqueue(cpu_env, q); }

[[[[Adv]]]]: static void handle_pending_signal(CPUArchState *cpu_env, int [[handgun]]) { CPUState *[[multitasking]] = ENV_GET_CPU(cpu_env); abi_ulong handler; sigset_t [[ensemble]], old_set; target_sigset_t [[repossession]]; struct target_sigaction *sa; struct sigqueue *q; TaskState *[[tb]] = [[multitasking]]->opaque; struct emulated_sigtable *k = &[[tb]]->sigtab[[[handgun]] - 1]; trace_user_handle_signal(cpu_env, [[handgun]]); q = k->first; k->first = q->next; if (!k->first) k->pending = 0; [[handgun]] = gdb_handlesig([[multitasking]], [[handgun]]); if (![[handgun]]) { sa = NULL; handler = TARGET_SIG_IGN; } else { sa = &sigact_table[[[handgun]] - 1]; handler = sa->_sa_handler; } if ([[tb]]->sigsegv_blocked && [[handgun]] == TARGET_SIGSEGV) { handler = TARGET_SIG_DFL; } if (handler == TARGET_SIG_DFL) { if ([[handgun]] == TARGET_SIGTSTP || [[handgun]] == TARGET_SIGTTIN || [[handgun]] == TARGET_SIGTTOU) { kill(getpid(),SIGSTOP); } else if ([[handgun]] != TARGET_SIGCHLD && [[handgun]] != TARGET_SIGURG && [[handgun]] != TARGET_SIGWINCH && [[handgun]] != TARGET_SIGCONT) { force_sig([[handgun]]); } } else if (handler == TARGET_SIG_IGN) { } else if (handler == TARGET_SIG_ERR) { force_sig([[handgun]]); } else { target_to_host_sigset(&[[ensemble]], &sa->sa_mask); if (!(sa->sa_flags & TARGET_SA_NODEFER)) sigaddset(&[[ensemble]], target_to_host_signal([[handgun]])); do_sigprocmask(SIG_BLOCK, &[[ensemble]], &old_set); host_to_target_sigset_internal(&[[repossession]], &old_set); #if defined(TARGET_I386) && !defined(TARGET_X86_64) { CPUX86State *env = cpu_env; if (env->eflags & VM_MASK) save_v86_state(env); } #endif #if defined(TARGET_ABI_MIPSN32) || defined(TARGET_ABI_MIPSN64) \ || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX) setup_rt_frame([[handgun]], sa, &q->info, &[[repossession]], cpu_env); #else if (sa->sa_flags & TARGET_SA_SIGINFO) setup_rt_frame([[handgun]], sa, &q->info, &[[repossession]], cpu_env); else setup_frame([[handgun]], sa, &[[repossession]], cpu_env); #endif if (sa->sa_flags & TARGET_SA_RESETHAND) { sa->_sa_handler = TARGET_SIG_DFL; } } if (q != &k->info) free_sigqueue(cpu_env, q); }
--------------------------------------------- Result 918 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void pcie_pci_bridge_write_config(PCIDevice *d, uint32_t address, uint32_t val, int len) { pci_bridge_write_config(d, address, val, len); msi_write_config(d, address, val, len); shpc_cap_write_config(d, address, val, len); }
--------------------------------------------- Result 919 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 529 / 53 / 337 / 919:  34%|      | 919/2690 [10:53:49<20:59:58, 42.69s/it][Succeeded / Failed / Skipped / Total] 529 / 53 / 337 / 919:  34%|      | 920/2690 [10:53:49<20:57:54, 42.64s/it][Succeeded / Failed / Skipped / Total] 529 / 53 / 338 / 920:  34%|      | 920/2690 [10:53:49<20:57:54, 42.64s/it][Succeeded / Failed / Skipped / Total] 529 / 53 / 338 / 920:  34%|      | 921/2690 [10:54:25<20:56:57, 42.63s/it][Succeeded / Failed / Skipped / Total] 530 / 53 / 338 / 921:  34%|      | 921/2690 [10:54:25<20:56:57, 42.63s/it][Succeeded / Failed / Skipped / Total] 530 / 53 / 338 / 921:  34%|      | 922/2690 [10:54:25<20:54:54, 42.59s/it][Succeeded / Failed / Skipped / Total] 530 / 53 / 339 / 922:  34%|      | 922/2690 [10:54:25<20:54:54, 42.59s/it][Succeeded / Failed / Skipped / Total] 530 / 53 / 339 / 922:  34%|      | 923/2690 [10:54:26<20:52:51, 42.54s/it][[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static ram_addr_t find_ram_offset(ram_addr_t size) { RAMBlock *block, *next_block; ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX; assert(size != 0); if (QTAILQ_EMPTY(&ram_list.blocks)) return 0; QTAILQ_FOREACH(block, &ram_list.blocks, next) { ram_addr_t end, next = RAM_ADDR_MAX; end = block->offset + block->length; QTAILQ_FOREACH(next_block, &ram_list.blocks, next) { if (next_block->offset >= end) { next = MIN(next, next_block->offset); } } if (next - end >= size && next - end < mingap) { offset = end; mingap = next - end; } } if (offset == RAM_ADDR_MAX) { fprintf(stderr, "Failed to find gap of requested size: %" PRIu64 "\n", (uint64_t)size); abort(); } return offset; }
--------------------------------------------- Result 920 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: CharDriverState *qemu_chr_alloc(void) { CharDriverState *chr = g_malloc0(sizeof(CharDriverState)); qemu_mutex_init(&chr->chr_write_lock); return chr; }
--------------------------------------------- Result 921 ---------------------------------------------
[[0 (34%)]] --> [[0 (56%)]] --> Socre: 0.563742458820343

[[[[Adv]]]]: static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *[[outbuf]]) { SCSIRequest *req = &r->req; SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev); uint64_t nb_sectors; int buflen = 0; int ret; switch (req->cmd.buf[0]) { case TEST_UNIT_READY: if (!bdrv_is_inserted(s->bs)) goto not_ready; break; case REQUEST_SENSE: if (req->cmd.xfer < 4) goto illegal_request; buflen = scsi_device_get_sense(&s->qdev, [[outbuf]], req->cmd.xfer, (req->cmd.buf[1] & 1) == 0); break; case INQUIRY: buflen = scsi_disk_emulate_inquiry(req, [[outbuf]]); if (buflen < 0) goto illegal_request; break; case MODE_SENSE: case MODE_SENSE_10: buflen = scsi_disk_emulate_mode_sense(req, [[outbuf]]); if (buflen < 0) goto illegal_request; break; case READ_TOC: buflen = scsi_disk_emulate_read_toc(req, [[outbuf]]); if (buflen < 0) goto illegal_request; break; case RESERVE: if (req->cmd.buf[1] & 1) goto illegal_request; break; case RESERVE_10: if (req->cmd.buf[1] & 3) goto illegal_request; break; case RELEASE: if (req->cmd.buf[1] & 1) goto illegal_request; break; case RELEASE_10: if (req->cmd.buf[1] & 3) goto illegal_request; break; case START_STOP: if (s->qdev.type == TYPE_ROM && (req->cmd.buf[4] & 2)) { bdrv_eject(s->bs, !(req->cmd.buf[4] & 1)); } break; case ALLOW_MEDIUM_REMOVAL: bdrv_set_locked(s->bs, req->cmd.buf[4] & 1); break; case READ_CAPACITY_10: memset([[outbuf]], 0, 8); bdrv_get_geometry(s->bs, &nb_sectors); if (!nb_sectors) goto not_ready; nb_sectors /= s->cluster_size; nb_sectors--; s->max_lba = nb_sectors; if (nb_sectors > UINT32_MAX) nb_sectors = UINT32_MAX; [[outbuf]][0] = (nb_sectors >> 24) & 0xff; [[outbuf]][1] = (nb_sectors >> 16) & 0xff; [[outbuf]][2] = (nb_sectors >> 8) & 0xff; [[outbuf]][3] = nb_sectors & 0xff; [[outbuf]][4] = 0; [[outbuf]][5] = 0; [[outbuf]][6] = s->cluster_size * 2; [[outbuf]][7] = 0; buflen = 8; break; case SYNCHRONIZE_CACHE: ret = bdrv_flush(s->bs); if (ret < 0) { if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_FLUSH)) { return -1; } } break; case GET_CONFIGURATION: memset([[outbuf]], 0, 8); [[outbuf]][7] = 8; buflen = 8; break; case SERVICE_ACTION_IN: if ((req->cmd.buf[1] & 31) == 0x10) { DPRINTF("SAI READ CAPACITY(16)\n"); memset([[outbuf]], 0, req->cmd.xfer); bdrv_get_geometry(s->bs, &nb_sectors); if (!nb_sectors) goto not_ready; nb_sectors /= s->cluster_size; nb_sectors--; s->max_lba = nb_sectors; [[outbuf]][0] = (nb_sectors >> 56) & 0xff; [[outbuf]][1] = (nb_sectors >> 48) & 0xff; [[outbuf]][2] = (nb_sectors >> 40) & 0xff; [[outbuf]][3] = (nb_sectors >> 32) & 0xff; [[outbuf]][4] = (nb_sectors >> 24) & 0xff; [[outbuf]][5] = (nb_sectors >> 16) & 0xff; [[outbuf]][6] = (nb_sectors >> 8) & 0xff; [[outbuf]][7] = nb_sectors & 0xff; [[outbuf]][8] = 0; [[outbuf]][9] = 0; [[outbuf]][10] = s->cluster_size * 2; [[outbuf]][11] = 0; [[outbuf]][12] = 0; [[outbuf]][13] = get_physical_block_exp(&s->qdev.conf); if (s->qdev.conf.discard_granularity) { [[outbuf]][14] = 0x80; } buflen = req->cmd.xfer; break; } DPRINTF("Unsupported Service Action In\n"); goto illegal_request; case REPORT_LUNS: if (req->cmd.xfer < 16) goto illegal_request; memset([[outbuf]], 0, 16); [[outbuf]][3] = 8; buflen = 16; break; case VERIFY_10: break; default: scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE)); return -1; } return buflen; not_ready: if (!bdrv_is_inserted(s->bs)) { scsi_check_condition(r, SENSE_CODE(NO_MEDIUM)); } else { scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY)); } return -1; illegal_request: scsi_check_condition(r, SENSE_CODE(INVALID_FIELD)); return -1; }

[[[[Adv]]]]: static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *[[apptit]]) { SCSIRequest *req = &r->req; SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev); uint64_t nb_sectors; int buflen = 0; int ret; switch (req->cmd.buf[0]) { case TEST_UNIT_READY: if (!bdrv_is_inserted(s->bs)) goto not_ready; break; case REQUEST_SENSE: if (req->cmd.xfer < 4) goto illegal_request; buflen = scsi_device_get_sense(&s->qdev, [[apptit]], req->cmd.xfer, (req->cmd.buf[1] & 1) == 0); break; case INQUIRY: buflen = scsi_disk_emulate_inquiry(req, [[apptit]]); if (buflen < 0) goto illegal_request; break; case MODE_SENSE: case MODE_SENSE_10: buflen = scsi_disk_emulate_mode_sense(req, [[apptit]]); if (buflen < 0) goto illegal_request; break; case READ_TOC: buflen = scsi_disk_emulate_read_toc(req, [[apptit]]); if (buflen < 0) goto illegal_request; break; case RESERVE: if (req->cmd.buf[1] & 1) goto illegal_request; break; case RESERVE_10: if (req->cmd.buf[1] & 3) goto illegal_request; break; case RELEASE: if (req->cmd.buf[1] & 1) goto illegal_request; break; case RELEASE_10: if (req->cmd.buf[1] & 3) goto illegal_request; break; case START_STOP: if (s->qdev.type == TYPE_ROM && (req->cmd.buf[4] & 2)) { bdrv_eject(s->bs, !(req->cmd.buf[4] & 1)); } break; case ALLOW_MEDIUM_REMOVAL: bdrv_set_locked(s->bs, req->cmd.buf[4] & 1); break; case READ_CAPACITY_10: memset([[apptit]], 0, 8); bdrv_get_geometry(s->bs, &nb_sectors); if (!nb_sectors) goto not_ready; nb_sectors /= s->cluster_size; nb_sectors--; s->max_lba = nb_sectors; if (nb_sectors > UINT32_MAX) nb_sectors = UINT32_MAX; [[apptit]][0] = (nb_sectors >> 24) & 0xff; [[apptit]][1] = (nb_sectors >> 16) & 0xff; [[apptit]][2] = (nb_sectors >> 8) & 0xff; [[apptit]][3] = nb_sectors & 0xff; [[apptit]][4] = 0; [[apptit]][5] = 0; [[apptit]][6] = s->cluster_size * 2; [[apptit]][7] = 0; buflen = 8; break; case SYNCHRONIZE_CACHE: ret = bdrv_flush(s->bs); if (ret < 0) { if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_FLUSH)) { return -1; } } break; case GET_CONFIGURATION: memset([[apptit]], 0, 8); [[apptit]][7] = 8; buflen = 8; break; case SERVICE_ACTION_IN: if ((req->cmd.buf[1] & 31) == 0x10) { DPRINTF("SAI READ CAPACITY(16)\n"); memset([[apptit]], 0, req->cmd.xfer); bdrv_get_geometry(s->bs, &nb_sectors); if (!nb_sectors) goto not_ready; nb_sectors /= s->cluster_size; nb_sectors--; s->max_lba = nb_sectors; [[apptit]][0] = (nb_sectors >> 56) & 0xff; [[apptit]][1] = (nb_sectors >> 48) & 0xff; [[apptit]][2] = (nb_sectors >> 40) & 0xff; [[apptit]][3] = (nb_sectors >> 32) & 0xff; [[apptit]][4] = (nb_sectors >> 24) & 0xff; [[apptit]][5] = (nb_sectors >> 16) & 0xff; [[apptit]][6] = (nb_sectors >> 8) & 0xff; [[apptit]][7] = nb_sectors & 0xff; [[apptit]][8] = 0; [[apptit]][9] = 0; [[apptit]][10] = s->cluster_size * 2; [[apptit]][11] = 0; [[apptit]][12] = 0; [[apptit]][13] = get_physical_block_exp(&s->qdev.conf); if (s->qdev.conf.discard_granularity) { [[apptit]][14] = 0x80; } buflen = req->cmd.xfer; break; } DPRINTF("Unsupported Service Action In\n"); goto illegal_request; case REPORT_LUNS: if (req->cmd.xfer < 16) goto illegal_request; memset([[apptit]], 0, 16); [[apptit]][3] = 8; buflen = 16; break; case VERIFY_10: break; default: scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE)); return -1; } return buflen; not_ready: if (!bdrv_is_inserted(s->bs)) { scsi_check_condition(r, SENSE_CODE(NO_MEDIUM)); } else { scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY)); } return -1; illegal_request: scsi_check_condition(r, SENSE_CODE(INVALID_FIELD)); return -1; }
--------------------------------------------- Result 922 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void flush_queued_work(CPUState *cpu) { struct qemu_work_item *wi; if (cpu->queued_work_first == NULL) { return; } while ((wi = cpu->queued_work_first)) { cpu->queued_work_first = wi->next; wi->func(wi->data); wi->done = "True" == "True"; if (wi->free) { g_free(wi); } } cpu->queued_work_last = NULL; qemu_cond_broadcast(&qemu_work_cond); }
--------------------------------------------- Result 923 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 530 / 53 / 340 / 923:  34%|      | 923/2690 [10:54:26<20:52:51, 42.54s/it][Succeeded / Failed / Skipped / Total] 530 / 53 / 340 / 923:  34%|      | 924/2690 [10:54:26<20:50:48, 42.50s/it][Succeeded / Failed / Skipped / Total] 530 / 53 / 341 / 924:  34%|      | 924/2690 [10:54:26<20:50:48, 42.50s/it][Succeeded / Failed / Skipped / Total] 530 / 53 / 341 / 924:  34%|      | 925/2690 [11:02:46<21:04:38, 42.99s/it][Succeeded / Failed / Skipped / Total] 531 / 53 / 341 / 925:  34%|      | 925/2690 [11:02:46<21:04:38, 42.99s/it][Succeeded / Failed / Skipped / Total] 531 / 53 / 341 / 925:  34%|      | 926/2690 [11:03:41<21:04:19, 43.00s/it][Succeeded / Failed / Skipped / Total] 531 / 54 / 341 / 926:  34%|      | 926/2690 [11:03:41<21:04:19, 43.00s/it][Succeeded / Failed / Skipped / Total] 531 / 54 / 341 / 926:  34%|      | 927/2690 [11:03:42<21:02:15, 42.96s/it][Succeeded / Failed / Skipped / Total] 531 / 54 / 342 / 927:  34%|      | 927/2690 [11:03:42<21:02:15, 42.96s/it][Succeeded / Failed / Skipped / Total] 531 / 54 / 342 / 927:  34%|      | 928/2690 [11:05:02<21:02:43, 43.00s/it][[0 (68%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int validate_guest_space(unsigned long guest_base, unsigned long guest_size) { unsigned long real_start, test_page_addr; test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask); if (test_page_addr >= guest_base && test_page_addr <= (guest_base + guest_size)) { return -1; } real_start = (unsigned long) mmap((void *)test_page_addr, qemu_host_page_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); if (real_start == -1ul) { return 0; } if (real_start != test_page_addr) { munmap((void *)real_start, qemu_host_page_size); return 0; } __put_user(5, (uint32_t *)g2h(0xffff0ffcul)); if (mprotect((void *)test_page_addr, qemu_host_page_size, PROT_READ)) { perror("Protecting guest commpage"); exit(-1); } return 1; }
--------------------------------------------- Result 924 ---------------------------------------------
[[0 (41%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: long do_sigreturn(CPUCRISState *env) { struct target_signal_frame *frame; abi_ulong frame_addr; target_sigset_t target_set; sigset_t set; int i; frame_addr = env->regs[R_SP]; if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1)) goto badframe; if (__get_user(target_set.sig[0], &frame->sc.oldmask)) goto badframe; for(i = 1; i < TARGET_NSIG_WORDS; i++) { if (__get_user(target_set.sig[i], &frame->extramask[i - 1])) goto badframe; } target_to_host_sigset_internal(&set, &target_set); do_sigprocmask(SIG_SETMASK, &set, NULL); restore_sigcontext(&frame->sc, env); unlock_user_struct(frame, frame_addr, 0); return env->regs[10]; badframe: unlock_user_struct(frame, frame_addr, 0); force_sig(TARGET_SIGSEGV); }
--------------------------------------------- Result 925 ---------------------------------------------
[[0 (77%)]] --> [[0 (49%)]] --> Socre: 0.5084617137908936

[[[[Adv]]]]: static void usbredir_interrupt_packet(void *priv, uint32_t id, struct usb_redir_interrupt_packet_header *interrupt_packet, uint8_t *data, int data_len) { USBRedirDevice *dev = priv; uint8_t ep = interrupt_packet->endpoint; DPRINTF("interrupt-in status %d ep %02X len %d id %u\n", interrupt_packet->status, ep, data_len, id); if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) { ERROR("received int packet for non interrupt endpoint %02X\n", ep); free(data); return; } if (ep & USB_DIR_IN) { if (dev->endpoint[EP2I(ep)].interrupt_started == 0) { DPRINTF("received int packet while not started ep %02X\n", ep); free(data); return; } bufp_alloc(dev, data, data_len, interrupt_packet->status, ep); } else { int len = interrupt_packet->length; AsyncURB *[[aurb]] = async_find(dev, id); if (![[aurb]]) { return; } if ([[aurb]]->interrupt_packet.endpoint != interrupt_packet->endpoint) { ERROR("return int packet mismatch, please report this!\n"); len = USB_RET_NAK; } if ([[aurb]]->packet) { [[aurb]]->packet->len = usbredir_handle_status(dev, interrupt_packet->status, len); usb_packet_complete(&dev->dev, [[aurb]]->packet); } async_free(dev, [[aurb]]); } }

[[[[Adv]]]]: static void usbredir_interrupt_packet(void *priv, uint32_t id, struct usb_redir_interrupt_packet_header *interrupt_packet, uint8_t *data, int data_len) { USBRedirDevice *dev = priv; uint8_t ep = interrupt_packet->endpoint; DPRINTF("interrupt-in status %d ep %02X len %d id %u\n", interrupt_packet->status, ep, data_len, id); if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) { ERROR("received int packet for non interrupt endpoint %02X\n", ep); free(data); return; } if (ep & USB_DIR_IN) { if (dev->endpoint[EP2I(ep)].interrupt_started == 0) { DPRINTF("received int packet while not started ep %02X\n", ep); free(data); return; } bufp_alloc(dev, data, data_len, interrupt_packet->status, ep); } else { int len = interrupt_packet->length; AsyncURB *[[tight]] = async_find(dev, id); if (![[tight]]) { return; } if ([[tight]]->interrupt_packet.endpoint != interrupt_packet->endpoint) { ERROR("return int packet mismatch, please report this!\n"); len = USB_RET_NAK; } if ([[tight]]->packet) { [[tight]]->packet->len = usbredir_handle_status(dev, interrupt_packet->status, len); usb_packet_complete(&dev->dev, [[tight]]->packet); } async_free(dev, [[tight]]); } }
--------------------------------------------- Result 926 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg) { VIOsPAPRDevice *sdev; sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg); if (!sdev && reg == 0) { return spapr_vty_get_default(spapr->vio_bus); return sdev;

[[[[Adv]]]]: VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg) { VIOsPAPRDevice *sdev; sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg); if (!sdev && reg == 0) { return spapr_vty_get_default(spapr->vio_bus); return sdev;
--------------------------------------------- Result 927 ---------------------------------------------
[[0 (72%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void virtio_ccw_device_realize(VirtioCcwDevice *dev, Error **errp) { unsigned int cssid = 0; unsigned int ssid = 0; unsigned int schid; unsigned int devno; bool have_devno = "False" != "False"; bool found = "False" != "False"; SubchDev *sch; int num; DeviceState *parent = DEVICE(dev); Error *err = NULL; VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev); VirtIODevice *vdev; sch = g_malloc0(sizeof(SubchDev)); sch->driver_data = dev; dev->sch = sch; dev->indicators = NULL; sch->channel_prog = 0x0; sch->last_cmd_valid = "False" != "False"; sch->thinint_active = "False" != "False"; if (dev->bus_id) { num = sscanf(dev->bus_id, "%x.%x.%04x", &cssid, &ssid, &devno); if (num == 3) { if ((cssid > MAX_CSSID) || (ssid > MAX_SSID)) { error_setg(errp, "Invalid cssid or ssid: cssid %x, ssid %x", cssid, ssid); goto out_err; } if (cssid != VIRTUAL_CSSID) { error_setg(errp, "cssid %x not valid for virtio devices", cssid); goto out_err; } if (css_devno_used(cssid, ssid, devno)) { error_setg(errp, "Device %x.%x.%04x already exists", cssid, ssid, devno); goto out_err; } sch->cssid = cssid; sch->ssid = ssid; sch->devno = devno; have_devno = "True" == "True"; } else { error_setg(errp, "Malformed devno parameter '%s'", dev->bus_id); goto out_err; } } if (have_devno) { for (schid = 0; schid <= MAX_SCHID; schid++) { if (!css_find_subch(1, cssid, ssid, schid)) { sch->schid = schid; css_subch_assign(cssid, ssid, schid, devno, sch); found = "True" == "True"; break; } } if (!found) { error_setg(errp, "No free subchannel found for %x.%x.%04x", cssid, ssid, devno); goto out_err; } trace_virtio_ccw_new_device(cssid, ssid, schid, devno, "user-configured"); } else { cssid = VIRTUAL_CSSID; for (ssid = 0; ssid <= MAX_SSID; ssid++) { for (schid = 0; schid <= MAX_SCHID; schid++) { if (!css_find_subch(1, cssid, ssid, schid)) { sch->cssid = cssid; sch->ssid = ssid; sch->schid = schid; devno = schid; while (css_devno_used(cssid, ssid, devno)) { if (devno == MAX_SCHID) { devno = 0; } else if (devno == schid - 1) { error_setg(errp, "No free devno found"); goto out_err; } else { devno++; } } sch->devno = devno; css_subch_assign(cssid, ssid, schid, devno, sch); found = "True" == "True"; break; } } if (found) { break; } } if (!found) { error_setg(errp, "Virtual channel subsystem is full!"); goto out_err; } trace_virtio_ccw_new_device(cssid, ssid, schid, devno, "auto-configured"); } css_sch_build_virtual_schib(sch, 0, VIRTIO_CCW_CHPID_TYPE); sch->ccw_cb = virtio_ccw_cb; memset(&sch->id, 0, sizeof(SenseId)); sch->id.reserved = 0xff; sch->id.cu_type = VIRTIO_CCW_CU_TYPE; if (k->realize) { k->realize(dev, &err); } if (err) { error_propagate(errp, err); css_subch_assign(cssid, ssid, schid, devno, NULL); goto out_err; } vdev = virtio_ccw_get_vdev(sch); sch->id.cu_model = vdev->device_id; dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus, dev->host_features[0]); virtio_add_feature(&dev->host_features[0], VIRTIO_F_NOTIFY_ON_EMPTY); virtio_add_feature(&dev->host_features[0], VIRTIO_F_BAD_FEATURE); css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid, parent->hotplugged, 1); return; out_err: dev->sch = NULL; g_free(sch); }
[Succeeded / Failed / Skipped / Total] 532 / 54 / 342 / 928:  34%|      | 928/2690 [11:05:02<21:02:43, 43.00s/it][Succeeded / Failed / Skipped / Total] 532 / 54 / 342 / 928:  35%|      | 929/2690 [11:10:15<21:10:31, 43.29s/it][Succeeded / Failed / Skipped / Total] 533 / 54 / 342 / 929:  35%|      | 929/2690 [11:10:15<21:10:31, 43.29s/it][Succeeded / Failed / Skipped / Total] 533 / 54 / 342 / 929:  35%|      | 930/2690 [11:10:19<21:08:35, 43.25s/it]--------------------------------------------- Result 928 ---------------------------------------------
[[0 (90%)]] --> [[0 (49%)]] --> Socre: 0.5139606297016144

[[[[Adv]]]]: static inline void RENAME(rgb24tobgr24)(const uint8_t *src, uint8_t *dst, long [[src_size]]) { unsigned i; #ifdef HAVE_MMX long [[mmx_size]]= 23 - [[src_size]]; asm volatile ( "test %%"REG_a", %%"REG_a" \n\t" "jns 2f \n\t" "movq "MANGLE(mask24r)", %%mm5 \n\t" "movq "MANGLE(mask24g)", %%mm6 \n\t" "movq "MANGLE(mask24b)", %%mm7 \n\t" ASMALIGN(4) "1: \n\t" PREFETCH" 32(%1, %%"REG_a") \n\t" "movq (%1, %%"REG_a"), %%mm0 \n\t" "movq (%1, %%"REG_a"), %%mm1 \n\t" "movq 2(%1, %%"REG_a"), %%mm2 \n\t" "psllq $16, %%mm0 \n\t" "pand %%mm5, %%mm0 \n\t" "pand %%mm6, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "por %%mm0, %%mm1 \n\t" "por %%mm2, %%mm1 \n\t" "movq 6(%1, %%"REG_a"), %%mm0 \n\t" MOVNTQ" %%mm1, (%2, %%"REG_a")\n\t" "movq 8(%1, %%"REG_a"), %%mm1 \n\t" "movq 10(%1, %%"REG_a"), %%mm2 \n\t" "pand %%mm7, %%mm0 \n\t" "pand %%mm5, %%mm1 \n\t" "pand %%mm6, %%mm2 \n\t" "por %%mm0, %%mm1 \n\t" "por %%mm2, %%mm1 \n\t" "movq 14(%1, %%"REG_a"), %%mm0 \n\t" MOVNTQ" %%mm1, 8(%2, %%"REG_a")\n\t" "movq 16(%1, %%"REG_a"), %%mm1 \n\t" "movq 18(%1, %%"REG_a"), %%mm2 \n\t" "pand %%mm6, %%mm0 \n\t" "pand %%mm7, %%mm1 \n\t" "pand %%mm5, %%mm2 \n\t" "por %%mm0, %%mm1 \n\t" "por %%mm2, %%mm1 \n\t" MOVNTQ" %%mm1, 16(%2, %%"REG_a")\n\t" "add $24, %%"REG_a" \n\t" " js 1b \n\t" "2: \n\t" : "+a" ([[mmx_size]]) : "r" (src-[[mmx_size]]), "r"(dst-[[mmx_size]]) ); __asm __volatile(SFENCE:::"memory"); __asm __volatile(EMMS:::"memory"); if([[mmx_size]]==23) return; src+= [[src_size]]; dst+= [[src_size]]; [[src_size]]= 23-[[mmx_size]]; src-= [[src_size]]; dst-= [[src_size]]; #endif for(i=0; i<[[src_size]]; i+=3) { register uint8_t x; x = src[i + 2]; dst[i + 1] = src[i + 1]; dst[i + 2] = src[i + 0]; dst[i + 0] = x; } }

[[[[Adv]]]]: static inline void RENAME(rgb24tobgr24)(const uint8_t *src, uint8_t *dst, long [[fretting]]) { unsigned i; #ifdef HAVE_MMX long [[mogul]]= 23 - [[fretting]]; asm volatile ( "test %%"REG_a", %%"REG_a" \n\t" "jns 2f \n\t" "movq "MANGLE(mask24r)", %%mm5 \n\t" "movq "MANGLE(mask24g)", %%mm6 \n\t" "movq "MANGLE(mask24b)", %%mm7 \n\t" ASMALIGN(4) "1: \n\t" PREFETCH" 32(%1, %%"REG_a") \n\t" "movq (%1, %%"REG_a"), %%mm0 \n\t" "movq (%1, %%"REG_a"), %%mm1 \n\t" "movq 2(%1, %%"REG_a"), %%mm2 \n\t" "psllq $16, %%mm0 \n\t" "pand %%mm5, %%mm0 \n\t" "pand %%mm6, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "por %%mm0, %%mm1 \n\t" "por %%mm2, %%mm1 \n\t" "movq 6(%1, %%"REG_a"), %%mm0 \n\t" MOVNTQ" %%mm1, (%2, %%"REG_a")\n\t" "movq 8(%1, %%"REG_a"), %%mm1 \n\t" "movq 10(%1, %%"REG_a"), %%mm2 \n\t" "pand %%mm7, %%mm0 \n\t" "pand %%mm5, %%mm1 \n\t" "pand %%mm6, %%mm2 \n\t" "por %%mm0, %%mm1 \n\t" "por %%mm2, %%mm1 \n\t" "movq 14(%1, %%"REG_a"), %%mm0 \n\t" MOVNTQ" %%mm1, 8(%2, %%"REG_a")\n\t" "movq 16(%1, %%"REG_a"), %%mm1 \n\t" "movq 18(%1, %%"REG_a"), %%mm2 \n\t" "pand %%mm6, %%mm0 \n\t" "pand %%mm7, %%mm1 \n\t" "pand %%mm5, %%mm2 \n\t" "por %%mm0, %%mm1 \n\t" "por %%mm2, %%mm1 \n\t" MOVNTQ" %%mm1, 16(%2, %%"REG_a")\n\t" "add $24, %%"REG_a" \n\t" " js 1b \n\t" "2: \n\t" : "+a" ([[mogul]]) : "r" (src-[[mogul]]), "r"(dst-[[mogul]]) ); __asm __volatile(SFENCE:::"memory"); __asm __volatile(EMMS:::"memory"); if([[mogul]]==23) return; src+= [[fretting]]; dst+= [[fretting]]; [[fretting]]= 23-[[mogul]]; src-= [[fretting]]; dst-= [[fretting]]; #endif for(i=0; i<[[fretting]]; i+=3) { register uint8_t x; x = src[i + 2]; dst[i + 1] = src[i + 1]; dst[i + 2] = src[i + 0]; dst[i + 0] = x; } }
--------------------------------------------- Result 929 ---------------------------------------------
[[0 (78%)]] --> [[0 (44%)]] --> Socre: 0.559994637966156

[[[[Adv]]]]: static int check_refcounts_l1(BlockDriverState *bs, BdrvCheckResult *res, uint16_t **refcount_table, int64_t *[[refcount_table_size]], int64_t [[l1_table_offset]], int l1_size, int flags) { BDRVQcowState *s = bs->opaque; uint64_t *[[l1_table]] = NULL, l2_offset, l1_size2; int i, ret; l1_size2 = l1_size * sizeof(uint64_t); ret = inc_refcounts(bs, res, refcount_table, [[refcount_table_size]], [[l1_table_offset]], l1_size2); if (ret < 0) { goto fail; } if (l1_size2 > 0) { [[l1_table]] = g_try_malloc(l1_size2); if ([[l1_table]] == NULL) { ret = -ENOMEM; res->check_errors++; goto fail; } ret = bdrv_pread(bs->file, [[l1_table_offset]], [[l1_table]], l1_size2); if (ret < 0) { fprintf(stderr, "ERROR: I/O error in check_refcounts_l1\n"); res->check_errors++; goto fail; } for(i = 0;i < l1_size; i++) be64_to_cpus(&[[l1_table]][i]); } for(i = 0; i < l1_size; i++) { l2_offset = [[l1_table]][i]; if (l2_offset) { l2_offset &= L1E_OFFSET_MASK; ret = inc_refcounts(bs, res, refcount_table, [[refcount_table_size]], l2_offset, s->cluster_size); if (ret < 0) { goto fail; } if (offset_into_cluster(s, l2_offset)) { fprintf(stderr, "ERROR l2_offset=%" PRIx64 ": Table is not " "cluster aligned; L1 entry corrupted\n", l2_offset); res->corruptions++; } ret = check_refcounts_l2(bs, res, refcount_table, [[refcount_table_size]], l2_offset, flags); if (ret < 0) { goto fail; } } } g_free([[l1_table]]); return 0; fail: g_free([[l1_table]]); return ret; }

[[[[Adv]]]]: static int check_refcounts_l1(BlockDriverState *bs, BdrvCheckResult *res, uint16_t **refcount_table, int64_t *[[kane]], int64_t [[glaser]], int l1_size, int flags) { BDRVQcowState *s = bs->opaque; uint64_t *[[enlistment]] = NULL, l2_offset, l1_size2; int i, ret; l1_size2 = l1_size * sizeof(uint64_t); ret = inc_refcounts(bs, res, refcount_table, [[kane]], [[glaser]], l1_size2); if (ret < 0) { goto fail; } if (l1_size2 > 0) { [[enlistment]] = g_try_malloc(l1_size2); if ([[enlistment]] == NULL) { ret = -ENOMEM; res->check_errors++; goto fail; } ret = bdrv_pread(bs->file, [[glaser]], [[enlistment]], l1_size2); if (ret < 0) { fprintf(stderr, "ERROR: I/O error in check_refcounts_l1\n"); res->check_errors++; goto fail; } for(i = 0;i < l1_size; i++) be64_to_cpus(&[[enlistment]][i]); } for(i = 0; i < l1_size; i++) { l2_offset = [[enlistment]][i]; if (l2_offset) { l2_offset &= L1E_OFFSET_MASK; ret = inc_refcounts(bs, res, refcount_table, [[kane]], l2_offset, s->cluster_size); if (ret < 0) { goto fail; } if (offset_into_cluster(s, l2_offset)) { fprintf(stderr, "ERROR l2_offset=%" PRIx64 ": Table is not " "cluster aligned; L1 entry corrupted\n", l2_offset); res->corruptions++; } ret = check_refcounts_l2(bs, res, refcount_table, [[kane]], l2_offset, flags); if (ret < 0) { goto fail; } } } g_free([[enlistment]]); return 0; fail: g_free([[enlistment]]); return ret; }
--------------------------------------------- Result 930 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 534 / 54 / 342 / 930:  35%|      | 930/2690 [11:10:19<21:08:35, 43.25s/it][Succeeded / Failed / Skipped / Total] 534 / 54 / 342 / 930:  35%|      | 931/2690 [11:10:24<21:06:38, 43.21s/it][Succeeded / Failed / Skipped / Total] 535 / 54 / 342 / 931:  35%|      | 931/2690 [11:10:24<21:06:38, 43.21s/it][Succeeded / Failed / Skipped / Total] 535 / 54 / 342 / 931:  35%|      | 932/2690 [11:10:24<21:04:34, 43.16s/it][Succeeded / Failed / Skipped / Total] 535 / 54 / 343 / 932:  35%|      | 932/2690 [11:10:24<21:04:34, 43.16s/it][Succeeded / Failed / Skipped / Total] 535 / 54 / 343 / 932:  35%|      | 933/2690 [11:10:25<21:02:31, 43.11s/it][Succeeded / Failed / Skipped / Total] 535 / 54 / 344 / 933:  35%|      | 933/2690 [11:10:25<21:02:31, 43.11s/it][Succeeded / Failed / Skipped / Total] 535 / 54 / 344 / 933:  35%|      | 934/2690 [11:10:25<21:00:27, 43.07s/it][[0 (62%)]] --> [[0 (47%)]] --> Socre: 0.5347875952720642

[[[[Adv]]]]: static int decode_frame(AVCodecContext *avctx, void *[[data]], int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; H264Context *h = avctx->priv_data; AVFrame *pict = [[data]]; int [[buf_index]] = 0; Picture *out; int i, out_idx; int ret; h->flags = avctx->flags; if (buf_size == 0) { out: h->cur_pic_ptr = NULL; h->first_field = 0; out = h->delayed_pic[0]; out_idx = 0; for (i = 1; h->delayed_pic[i] && !h->delayed_pic[i]->f.key_frame && !h->delayed_pic[i]->mmco_reset; i++) if (h->delayed_pic[i]->poc < out->poc) { out = h->delayed_pic[i]; out_idx = i; } for (i = out_idx; h->delayed_pic[i]; i++) h->delayed_pic[i] = h->delayed_pic[i + 1]; if (out) { out->reference &= ~DELAYED_PIC_REF; ret = output_frame(h, pict, &out->f); if (ret < 0) return ret; *got_frame = 1; } return [[buf_index]]; } if(h->is_avc && buf_size >= 9 && buf[0]==1 && buf[2]==0 && (buf[4]&0xFC)==0xFC && (buf[5]&0x1F) && buf[8]==0x67){ int cnt= buf[5]&0x1f; const uint8_t *p= buf+6; while(cnt--){ int nalsize= AV_RB16(p) + 2; if(nalsize > buf_size - (p-buf) || p[2]!=0x67) goto not_extra; p += nalsize; } cnt = *(p++); if(!cnt) goto not_extra; while(cnt--){ int nalsize= AV_RB16(p) + 2; if(nalsize > buf_size - (p-buf) || p[2]!=0x68) goto not_extra; p += nalsize; } return ff_h264_decode_extradata(h, buf, buf_size); } not_extra: [[buf_index]] = decode_nal_units(h, buf, buf_size, 0); if ([[buf_index]] < 0) return -1; if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) { av_assert0([[buf_index]] <= buf_size); goto out; } if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) { if (avctx->skip_frame >= AVDISCARD_NONREF || buf_size >= 4 && !memcmp("Q264", buf, 4)) return buf_size; av_log(avctx, AV_LOG_ERROR, "no frame!\n"); return -1; } if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) || (h->mb_y >= h->mb_height && h->mb_height)) { if (avctx->flags2 & CODEC_FLAG2_CHUNKS) decode_postinit(h, 1); field_end(h, 0); *got_frame = 0; if (h->next_output_pic && (h->next_output_pic->sync || h->sync>1)) { ret = output_frame(h, pict, &h->next_output_pic->f); if (ret < 0) return ret; *got_frame = 1; if (CONFIG_MPEGVIDEO) { ff_print_debug_info2(h->avctx, h->next_output_pic, pict, h->er.mbskip_table, &h->low_delay, h->mb_width, h->mb_height, h->mb_stride, 1); } } } assert(pict->data[0] || !*got_frame); return get_consumed_bytes([[buf_index]], buf_size); }

[[[[Adv]]]]: static int decode_frame(AVCodecContext *avctx, void *[[clarification]], int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; H264Context *h = avctx->priv_data; AVFrame *pict = [[clarification]]; int [[sangria]] = 0; Picture *out; int i, out_idx; int ret; h->flags = avctx->flags; if (buf_size == 0) { out: h->cur_pic_ptr = NULL; h->first_field = 0; out = h->delayed_pic[0]; out_idx = 0; for (i = 1; h->delayed_pic[i] && !h->delayed_pic[i]->f.key_frame && !h->delayed_pic[i]->mmco_reset; i++) if (h->delayed_pic[i]->poc < out->poc) { out = h->delayed_pic[i]; out_idx = i; } for (i = out_idx; h->delayed_pic[i]; i++) h->delayed_pic[i] = h->delayed_pic[i + 1]; if (out) { out->reference &= ~DELAYED_PIC_REF; ret = output_frame(h, pict, &out->f); if (ret < 0) return ret; *got_frame = 1; } return [[sangria]]; } if(h->is_avc && buf_size >= 9 && buf[0]==1 && buf[2]==0 && (buf[4]&0xFC)==0xFC && (buf[5]&0x1F) && buf[8]==0x67){ int cnt= buf[5]&0x1f; const uint8_t *p= buf+6; while(cnt--){ int nalsize= AV_RB16(p) + 2; if(nalsize > buf_size - (p-buf) || p[2]!=0x67) goto not_extra; p += nalsize; } cnt = *(p++); if(!cnt) goto not_extra; while(cnt--){ int nalsize= AV_RB16(p) + 2; if(nalsize > buf_size - (p-buf) || p[2]!=0x68) goto not_extra; p += nalsize; } return ff_h264_decode_extradata(h, buf, buf_size); } not_extra: [[sangria]] = decode_nal_units(h, buf, buf_size, 0); if ([[sangria]] < 0) return -1; if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) { av_assert0([[sangria]] <= buf_size); goto out; } if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) { if (avctx->skip_frame >= AVDISCARD_NONREF || buf_size >= 4 && !memcmp("Q264", buf, 4)) return buf_size; av_log(avctx, AV_LOG_ERROR, "no frame!\n"); return -1; } if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) || (h->mb_y >= h->mb_height && h->mb_height)) { if (avctx->flags2 & CODEC_FLAG2_CHUNKS) decode_postinit(h, 1); field_end(h, 0); *got_frame = 0; if (h->next_output_pic && (h->next_output_pic->sync || h->sync>1)) { ret = output_frame(h, pict, &h->next_output_pic->f); if (ret < 0) return ret; *got_frame = 1; if (CONFIG_MPEGVIDEO) { ff_print_debug_info2(h->avctx, h->next_output_pic, pict, h->er.mbskip_table, &h->low_delay, h->mb_width, h->mb_height, h->mb_stride, 1); } } } assert(pict->data[0] || !*got_frame); return get_consumed_bytes([[sangria]], buf_size); }
--------------------------------------------- Result 931 ---------------------------------------------
[[0 (63%)]] --> [[0 (44%)]] --> Socre: 0.5628750324249268

[[[[Adv]]]]: GIOStatus ga_channel_write_all(GAChannel *c, const char *buf, size_t size) { GIOStatus [[status]] = G_IO_STATUS_NORMAL; size_t count; while (size) { [[status]] = ga_channel_write(c, buf, size, &count); if ([[status]] == G_IO_STATUS_NORMAL) { size -= count; buf += count; } else if ([[status]] != G_IO_STATUS_AGAIN) { break; } } return [[status]]; }

[[[[Adv]]]]: GIOStatus ga_channel_write_all(GAChannel *c, const char *buf, size_t size) { GIOStatus [[regulation]] = G_IO_STATUS_NORMAL; size_t count; while (size) { [[regulation]] = ga_channel_write(c, buf, size, &count); if ([[regulation]] == G_IO_STATUS_NORMAL) { size -= count; buf += count; } else if ([[regulation]] != G_IO_STATUS_AGAIN) { break; } } return [[regulation]]; }
--------------------------------------------- Result 932 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int channelmap_query_formats(AVFilterContext *ctx) { ChannelMapContext *s = ctx->priv; ff_set_common_formats(ctx, ff_planar_sample_fmts()); ff_set_common_samplerates(ctx, ff_all_samplerates()); ff_channel_layouts_ref(ff_all_channel_layouts(), &ctx->inputs[0]->out_channel_layouts); ff_channel_layouts_ref(s->channel_layouts, &ctx->outputs[0]->in_channel_layouts); return 0; }
--------------------------------------------- Result 933 ---------------------------------------------
[[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void flush_queued_work(CPUState *env) { struct qemu_work_item *wi; if (!env->queued_work_first) return; while ((wi = env->queued_work_first)) { env->queued_work_first = wi->next; wi->func(wi->data); wi->done = "True" == "True"; } env->queued_work_last = NULL; qemu_cond_broadcast(&qemu_work_cond); }
--------------------------------------------- Result 934 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 535 / 54 / 345 / 934:  35%|      | 934/2690 [11:10:25<21:00:27, 43.07s/it][Succeeded / Failed / Skipped / Total] 535 / 54 / 345 / 934:  35%|      | 935/2690 [11:11:43<21:00:49, 43.10s/it][Succeeded / Failed / Skipped / Total] 536 / 54 / 345 / 935:  35%|      | 935/2690 [11:11:43<21:00:49, 43.10s/it][Succeeded / Failed / Skipped / Total] 536 / 54 / 345 / 935:  35%|      | 936/2690 [11:11:43<20:58:46, 43.06s/it][Succeeded / Failed / Skipped / Total] 536 / 54 / 346 / 936:  35%|      | 936/2690 [11:11:43<20:58:46, 43.06s/it][Succeeded / Failed / Skipped / Total] 536 / 54 / 346 / 936:  35%|      | 937/2690 [11:12:01<20:57:15, 43.03s/it][[0 (72%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req, struct iovec *iov, int niov, bool create, enum AIOCBState aiocb_type) { int nr_copies = s->inode.nr_copies; SheepdogObjReq hdr; unsigned int wlen; int ret; uint64_t oid = aio_req->oid; unsigned int datalen = aio_req->data_len; uint64_t offset = aio_req->offset; uint8_t flags = aio_req->flags; uint64_t old_oid = aio_req->base_oid; if (!nr_copies) { error_report("bug"); } memset(&hdr, 0, sizeof(hdr)); if (aiocb_type == AIOCB_READ_UDATA) { wlen = 0; hdr.opcode = SD_OP_READ_OBJ; hdr.flags = flags; } else if (create) { wlen = datalen; hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ; hdr.flags = SD_FLAG_CMD_WRITE | flags; } else { wlen = datalen; hdr.opcode = SD_OP_WRITE_OBJ; hdr.flags = SD_FLAG_CMD_WRITE | flags; } if (s->cache_flags) { hdr.flags |= s->cache_flags; } hdr.oid = oid; hdr.cow_oid = old_oid; hdr.copies = s->inode.nr_copies; hdr.data_length = datalen; hdr.offset = offset; hdr.id = aio_req->id; qemu_co_mutex_lock(&s->lock); s->co_send = qemu_coroutine_self(); qemu_aio_set_fd_handler(s->fd, co_read_response, co_write_request, aio_flush_request, s); socket_set_cork(s->fd, 1); ret = qemu_co_send(s->fd, &hdr, sizeof(hdr)); if (ret < 0) { qemu_co_mutex_unlock(&s->lock); error_report("failed to send a req, %s", strerror(errno)); return -errno; } if (wlen) { ret = qemu_co_sendv(s->fd, iov, niov, aio_req->iov_offset, wlen); if (ret < 0) { qemu_co_mutex_unlock(&s->lock); error_report("failed to send a data, %s", strerror(errno)); return -errno; } } socket_set_cork(s->fd, 0); qemu_aio_set_fd_handler(s->fd, co_read_response, NULL, aio_flush_request, s); qemu_co_mutex_unlock(&s->lock); return 0; }
--------------------------------------------- Result 935 ---------------------------------------------
[[0 (56%)]] --> [[0 (48%)]] --> Socre: 0.5223675966262817

[[[[Adv]]]]: static int img_write_packet(AVFormatContext *s, int stream_index, UINT8 *buf, int size) { VideoData *img = s->priv_data; AVStream *[[st]] = s->streams[stream_index]; ByteIOContext pb1, *pb; AVPicture picture; int width, height, ret, size1; char filename[1024]; width = [[st]]->codec.width; height = [[st]]->codec.height; switch([[st]]->codec.pix_fmt) { case PIX_FMT_YUV420P: size1 = (width * height * 3) / 2; if (size != size1) return -EIO; picture.data[0] = buf; picture.data[1] = picture.data[0] + width * height; picture.data[2] = picture.data[1] + (width * height) / 4; picture.linesize[0] = width; picture.linesize[1] = width >> 1; picture.linesize[2] = width >> 1; break; case PIX_FMT_RGB24: size1 = (width * height * 3); if (size != size1) return -EIO; picture.data[0] = buf; picture.linesize[0] = width * 3; break; default: return -EIO; } if (get_frame_filename(filename, sizeof(filename), img->path, img->img_number) < 0) return -EIO; if (!img->is_pipe) { pb = &pb1; if (url_fopen(pb, filename, URL_WRONLY) < 0) return -EIO; } else { pb = &s->pb; } switch(img->img_fmt) { case IMGFMT_PGMYUV: ret = pgm_save(&picture, width, height, pb, 1); break; case IMGFMT_PGM: ret = pgm_save(&picture, width, height, pb, 0); break; case IMGFMT_YUV: ret = yuv_save(&picture, width, height, filename); break; case IMGFMT_PPM: ret = ppm_save(&picture, width, height, pb); break; } if (!img->is_pipe) { url_fclose(pb); } img->img_number++; return 0; }

[[[[Adv]]]]: static int img_write_packet(AVFormatContext *s, int stream_index, UINT8 *buf, int size) { VideoData *img = s->priv_data; AVStream *[[mecca]] = s->streams[stream_index]; ByteIOContext pb1, *pb; AVPicture picture; int width, height, ret, size1; char filename[1024]; width = [[mecca]]->codec.width; height = [[mecca]]->codec.height; switch([[mecca]]->codec.pix_fmt) { case PIX_FMT_YUV420P: size1 = (width * height * 3) / 2; if (size != size1) return -EIO; picture.data[0] = buf; picture.data[1] = picture.data[0] + width * height; picture.data[2] = picture.data[1] + (width * height) / 4; picture.linesize[0] = width; picture.linesize[1] = width >> 1; picture.linesize[2] = width >> 1; break; case PIX_FMT_RGB24: size1 = (width * height * 3); if (size != size1) return -EIO; picture.data[0] = buf; picture.linesize[0] = width * 3; break; default: return -EIO; } if (get_frame_filename(filename, sizeof(filename), img->path, img->img_number) < 0) return -EIO; if (!img->is_pipe) { pb = &pb1; if (url_fopen(pb, filename, URL_WRONLY) < 0) return -EIO; } else { pb = &s->pb; } switch(img->img_fmt) { case IMGFMT_PGMYUV: ret = pgm_save(&picture, width, height, pb, 1); break; case IMGFMT_PGM: ret = pgm_save(&picture, width, height, pb, 0); break; case IMGFMT_YUV: ret = yuv_save(&picture, width, height, filename); break; case IMGFMT_PPM: ret = ppm_save(&picture, width, height, pb); break; } if (!img->is_pipe) { url_fclose(pb); } img->img_number++; return 0; }
--------------------------------------------- Result 936 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo) { monitor_printf(mon, "Can't hot-add drive to type %d\n", dinfo->type); return -1; }
--------------------------------------------- Result 937 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 537 / 54 / 346 / 937:  35%|      | 937/2690 [11:12:01<20:57:15, 43.03s/it][Succeeded / Failed / Skipped / Total] 537 / 54 / 346 / 937:  35%|      | 938/2690 [11:12:01<20:55:13, 42.99s/it][[0 (59%)]] --> [[0 (49%)]] --> Socre: 0.5143540501594543

[[[[Adv]]]]: static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY, int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) { uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY; uint8_t *ysrc = src[0]; uint8_t *usrc = src[1]; uint8_t *[[vsrc]] = src[2]; const int [[width]] = c->srcW; const int height = srcSliceH; const int lumStride = srcStride[0]; const int chromStride = srcStride[1]; const int dstStride = dstStride_a[0]; const vector unsigned char yperm = vec_lvsl(0, ysrc); const int vertLumPerChroma = 2; register unsigned int y; if([[width]]&15){ yv12toyuy2( ysrc, usrc, [[vsrc]], dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride); return srcSliceH; } for(y=0; y<height; y++) { int i; for (i = 0; i < [[width]] - 31; i+= 32) { const unsigned int j = i >> 1; vector unsigned char v_yA = vec_ld(i, ysrc); vector unsigned char v_yB = vec_ld(i + 16, ysrc); vector unsigned char v_yC = vec_ld(i + 32, ysrc); vector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm); vector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm); vector unsigned char v_uA = vec_ld(j, usrc); vector unsigned char v_uB = vec_ld(j + 16, usrc); vector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc)); vector unsigned char v_vA = vec_ld(j, [[vsrc]]); vector unsigned char v_vB = vec_ld(j + 16, [[vsrc]]); vector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, [[vsrc]])); vector unsigned char v_uv_a = vec_mergeh(v_u, v_v); vector unsigned char v_uv_b = vec_mergel(v_u, v_v); vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a); vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a); vector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b); vector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b); vec_st(v_yuy2_0, (i << 1), dst); vec_st(v_yuy2_1, (i << 1) + 16, dst); vec_st(v_yuy2_2, (i << 1) + 32, dst); vec_st(v_yuy2_3, (i << 1) + 48, dst); } if (i < [[width]]) { const unsigned int j = i >> 1; vector unsigned char v_y1 = vec_ld(i, ysrc); vector unsigned char v_u = vec_ld(j, usrc); vector unsigned char v_v = vec_ld(j, [[vsrc]]); vector unsigned char v_uv_a = vec_mergeh(v_u, v_v); vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a); vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a); vec_st(v_yuy2_0, (i << 1), dst); vec_st(v_yuy2_1, (i << 1) + 16, dst); } if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) ) { usrc += chromStride; [[vsrc]] += chromStride; } ysrc += lumStride; dst += dstStride; } return srcSliceH; }

[[[[Adv]]]]: static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY, int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) { uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY; uint8_t *ysrc = src[0]; uint8_t *usrc = src[1]; uint8_t *[[fleet]] = src[2]; const int [[sizes]] = c->srcW; const int height = srcSliceH; const int lumStride = srcStride[0]; const int chromStride = srcStride[1]; const int dstStride = dstStride_a[0]; const vector unsigned char yperm = vec_lvsl(0, ysrc); const int vertLumPerChroma = 2; register unsigned int y; if([[sizes]]&15){ yv12toyuy2( ysrc, usrc, [[fleet]], dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride); return srcSliceH; } for(y=0; y<height; y++) { int i; for (i = 0; i < [[sizes]] - 31; i+= 32) { const unsigned int j = i >> 1; vector unsigned char v_yA = vec_ld(i, ysrc); vector unsigned char v_yB = vec_ld(i + 16, ysrc); vector unsigned char v_yC = vec_ld(i + 32, ysrc); vector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm); vector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm); vector unsigned char v_uA = vec_ld(j, usrc); vector unsigned char v_uB = vec_ld(j + 16, usrc); vector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc)); vector unsigned char v_vA = vec_ld(j, [[fleet]]); vector unsigned char v_vB = vec_ld(j + 16, [[fleet]]); vector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, [[fleet]])); vector unsigned char v_uv_a = vec_mergeh(v_u, v_v); vector unsigned char v_uv_b = vec_mergel(v_u, v_v); vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a); vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a); vector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b); vector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b); vec_st(v_yuy2_0, (i << 1), dst); vec_st(v_yuy2_1, (i << 1) + 16, dst); vec_st(v_yuy2_2, (i << 1) + 32, dst); vec_st(v_yuy2_3, (i << 1) + 48, dst); } if (i < [[sizes]]) { const unsigned int j = i >> 1; vector unsigned char v_y1 = vec_ld(i, ysrc); vector unsigned char v_u = vec_ld(j, usrc); vector unsigned char v_v = vec_ld(j, [[fleet]]); vector unsigned char v_uv_a = vec_mergeh(v_u, v_v); vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a); vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a); vec_st(v_yuy2_0, (i << 1), dst); vec_st(v_yuy2_1, (i << 1) + 16, dst); } if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) ) { usrc += chromStride; [[fleet]] += chromStride; } ysrc += lumStride; dst += dstStride; } return srcSliceH; }
--------------------------------------------- Result 938 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 537 / 54 / 347 / 938:  35%|      | 938/2690 [11:12:01<20:55:13, 42.99s/it][Succeeded / Failed / Skipped / Total] 537 / 54 / 347 / 938:  35%|      | 939/2690 [11:12:34<20:54:10, 42.98s/it][Succeeded / Failed / Skipped / Total] 538 / 54 / 347 / 939:  35%|      | 939/2690 [11:12:34<20:54:10, 42.98s/it][Succeeded / Failed / Skipped / Total] 538 / 54 / 347 / 939:  35%|      | 940/2690 [11:12:34<20:52:08, 42.93s/it][Succeeded / Failed / Skipped / Total] 538 / 54 / 348 / 940:  35%|      | 940/2690 [11:12:34<20:52:08, 42.93s/it][Succeeded / Failed / Skipped / Total] 538 / 54 / 348 / 940:  35%|      | 941/2690 [11:12:38<20:50:13, 42.89s/it][Succeeded / Failed / Skipped / Total] 539 / 54 / 348 / 941:  35%|      | 941/2690 [11:12:38<20:50:13, 42.89s/it][Succeeded / Failed / Skipped / Total] 539 / 54 / 348 / 941:  35%|      | 942/2690 [11:12:54<20:48:39, 42.86s/it][[0 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void cpu_loop(CPUAlphaState *env) { CPUState *cs = CPU(alpha_env_get_cpu(env)); int trapnr; target_siginfo_t info; abi_long sysret; while (1) { cpu_exec_start(cs); trapnr = cpu_alpha_exec(cs); cpu_exec_end(cs); env->intr_flag = 0; switch (trapnr) { case EXCP_RESET: fprintf(stderr, "Reset requested. Exit\n"); exit(EXIT_FAILURE); break; case EXCP_MCHK: fprintf(stderr, "Machine check exception. Exit\n"); exit(EXIT_FAILURE); break; case EXCP_SMP_INTERRUPT: case EXCP_CLK_INTERRUPT: case EXCP_DEV_INTERRUPT: fprintf(stderr, "External interrupt. Exit\n"); exit(EXIT_FAILURE); break; case EXCP_MMFAULT: env->lock_addr = -1; info.si_signo = TARGET_SIGSEGV; info.si_errno = 0; info.si_code = (page_get_flags(env->trap_arg0) & PAGE_VALID ? TARGET_SEGV_ACCERR : TARGET_SEGV_MAPERR); info._sifields._sigfault._addr = env->trap_arg0; queue_signal(env, info.si_signo, &info); break; case EXCP_UNALIGN: env->lock_addr = -1; info.si_signo = TARGET_SIGBUS; info.si_errno = 0; info.si_code = TARGET_BUS_ADRALN; info._sifields._sigfault._addr = env->trap_arg0; queue_signal(env, info.si_signo, &info); break; case EXCP_OPCDEC: do_sigill: env->lock_addr = -1; info.si_signo = TARGET_SIGILL; info.si_errno = 0; info.si_code = TARGET_ILL_ILLOPC; info._sifields._sigfault._addr = env->pc; queue_signal(env, info.si_signo, &info); break; case EXCP_ARITH: env->lock_addr = -1; info.si_signo = TARGET_SIGFPE; info.si_errno = 0; info.si_code = TARGET_FPE_FLTINV; info._sifields._sigfault._addr = env->pc; queue_signal(env, info.si_signo, &info); break; case EXCP_FEN: break; case EXCP_CALL_PAL: env->lock_addr = -1; switch (env->error_code) { case 0x80: info.si_signo = TARGET_SIGTRAP; info.si_errno = 0; info.si_code = TARGET_TRAP_BRKPT; info._sifields._sigfault._addr = env->pc; queue_signal(env, info.si_signo, &info); break; case 0x81: info.si_signo = TARGET_SIGTRAP; info.si_errno = 0; info.si_code = 0; info._sifields._sigfault._addr = env->pc; queue_signal(env, info.si_signo, &info); break; case 0x83: trapnr = env->ir[IR_V0]; sysret = do_syscall(env, trapnr, env->ir[IR_A0], env->ir[IR_A1], env->ir[IR_A2], env->ir[IR_A3], env->ir[IR_A4], env->ir[IR_A5], 0, 0); if (trapnr == TARGET_NR_sigreturn || trapnr == TARGET_NR_rt_sigreturn) { break; } trapnr = (env->ir[IR_V0] != 0 && sysret < 0); env->ir[IR_V0] = (trapnr ? -sysret : sysret); env->ir[IR_A3] = trapnr; break; case 0x86: break; case 0x9E: abort(); case 0x9F: abort(); case 0xAA: info.si_signo = TARGET_SIGFPE; switch (env->ir[IR_A0]) { case TARGET_GEN_INTOVF: info.si_code = TARGET_FPE_INTOVF; break; case TARGET_GEN_INTDIV: info.si_code = TARGET_FPE_INTDIV; break; case TARGET_GEN_FLTOVF: info.si_code = TARGET_FPE_FLTOVF; break; case TARGET_GEN_FLTUND: info.si_code = TARGET_FPE_FLTUND; break; case TARGET_GEN_FLTINV: info.si_code = TARGET_FPE_FLTINV; break; case TARGET_GEN_FLTINE: info.si_code = TARGET_FPE_FLTRES; break; case TARGET_GEN_ROPRAND: info.si_code = 0; break; default: info.si_signo = TARGET_SIGTRAP; info.si_code = 0; break; } info.si_errno = 0; info._sifields._sigfault._addr = env->pc; queue_signal(env, info.si_signo, &info); break; default: goto do_sigill; } break; case EXCP_DEBUG: info.si_signo = gdb_handlesig(cs, TARGET_SIGTRAP); if (info.si_signo) { env->lock_addr = -1; info.si_errno = 0; info.si_code = TARGET_TRAP_BRKPT; queue_signal(env, info.si_signo, &info); } break; case EXCP_STL_C: case EXCP_STQ_C: do_store_exclusive(env, env->error_code, trapnr - EXCP_STL_C); break; case EXCP_INTERRUPT: break; default: printf ("Unhandled trap: 0x%x\n", trapnr); cpu_dump_state(cs, stderr, fprintf, 0); exit(EXIT_FAILURE); } process_pending_signals (env); } }
--------------------------------------------- Result 939 ---------------------------------------------
[[0 (7%)]] --> [[0 (94%)]] --> Socre: 0.9359649419784546

[[[[Adv]]]]: static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target) { int i; S390PCIBusDevice *[[pbdev]]; S390pciState *s = s390_get_phb(); if (!target) { return NULL; } for (i = 0; i < PCI_SLOT_MAX; i++) { [[pbdev]] = s->pbdev[i]; if (![[pbdev]]) { continue; } if (!strcmp([[pbdev]]->target, target)) { return [[pbdev]]; } } return NULL; }

[[[[Adv]]]]: static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target) { int i; S390PCIBusDevice *[[pass]]; S390pciState *s = s390_get_phb(); if (!target) { return NULL; } for (i = 0; i < PCI_SLOT_MAX; i++) { [[pass]] = s->pbdev[i]; if (![[pass]]) { continue; } if (!strcmp([[pass]]->target, target)) { return [[pass]]; } } return NULL; }
--------------------------------------------- Result 940 ---------------------------------------------
[[0 (74%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void cin_decode_lzss(const unsigned char *src, int src_size, unsigned char *dst, int dst_size) { uint16_t cmd; int i, sz, offset, code; unsigned char *dst_end = dst + dst_size; const unsigned char *src_end = src + src_size; while (src < src_end && dst < dst_end) { code = *src++; for (i = 0; i < 8 && src < src_end && dst < dst_end; ++i) { if (code & (1 << i)) { *dst++ = *src++; } else { cmd = AV_RL16(src); src += 2; offset = cmd >> 4; sz = (cmd & 0xF) + 2; sz = FFMIN(sz, dst_end - dst); while (sz--) { *dst = *(dst - offset - 1); ++dst; } } } } }
--------------------------------------------- Result 941 ---------------------------------------------
[[0 (70%)]] --> [[0 (46%)]] --> Socre: 0.5352623164653778

[[[[Adv]]]]: ff_rdt_parse_open(AVFormatContext *ic, int [[first_stream_of_set_idx]], void *[[priv_data]], RTPDynamicProtocolHandler *handler) { RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext)); if (!s) return NULL; s->ic = ic; s->streams = &ic->streams[[[first_stream_of_set_idx]]]; do { s->n_streams++; } while ([[first_stream_of_set_idx]] + s->n_streams < ic->nb_streams && s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data); s->prev_set_id = -1; s->prev_stream_id = -1; s->prev_timestamp = -1; s->parse_packet = handler->parse_packet; s->dynamic_protocol_context = [[priv_data]]; return s; }

[[[[Adv]]]]: ff_rdt_parse_open(AVFormatContext *ic, int [[vicarious]], void *[[directive]], RTPDynamicProtocolHandler *handler) { RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext)); if (!s) return NULL; s->ic = ic; s->streams = &ic->streams[[[vicarious]]]; do { s->n_streams++; } while ([[vicarious]] + s->n_streams < ic->nb_streams && s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data); s->prev_set_id = -1; s->prev_stream_id = -1; s->prev_timestamp = -1; s->parse_packet = handler->parse_packet; s->dynamic_protocol_context = [[directive]]; return s; }
--------------------------------------------- Result 942 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 540 / 54 / 348 / 942:  35%|      | 942/2690 [11:12:54<20:48:39, 42.86s/it][Succeeded / Failed / Skipped / Total] 540 / 54 / 348 / 942:  35%|      | 943/2690 [11:14:45<20:50:03, 42.93s/it][[0 (77%)]] --> [[0 (44%)]] --> Socre: 0.5581088066101074

[[[[Adv]]]]: static int qcow2_co_writev(BlockDriverState *bs, int64_t sector_num, int remaining_sectors, QEMUIOVector *qiov) { BDRVQcowState *s = bs->opaque; int index_in_cluster; int n_end; int ret; int cur_nr_sectors; QCowL2Meta [[l2meta]]; uint64_t cluster_offset; QEMUIOVector hd_qiov; uint64_t bytes_done = 0; uint8_t *cluster_data = NULL; [[l2meta]].nb_clusters = 0; qemu_co_queue_init(&[[l2meta]].dependent_requests); qemu_iovec_init(&hd_qiov, qiov->niov); s->cluster_cache_offset = -1; qemu_co_mutex_lock(&s->lock); while (remaining_sectors != 0) { index_in_cluster = sector_num & (s->cluster_sectors - 1); n_end = index_in_cluster + remaining_sectors; if (s->crypt_method && n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) { n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors; } ret = qcow2_alloc_cluster_offset(bs, sector_num << 9, index_in_cluster, n_end, &cur_nr_sectors, &[[l2meta]]); if (ret < 0) { goto fail; } cluster_offset = [[l2meta]].cluster_offset; assert((cluster_offset & 511) == 0); qemu_iovec_reset(&hd_qiov); qemu_iovec_copy(&hd_qiov, qiov, bytes_done, cur_nr_sectors * 512); if (s->crypt_method) { if (!cluster_data) { cluster_data = g_malloc0(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size); } assert(hd_qiov.size <= QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size); qemu_iovec_to_buffer(&hd_qiov, cluster_data); qcow2_encrypt_sectors(s, sector_num, cluster_data, cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key); qemu_iovec_reset(&hd_qiov); qemu_iovec_add(&hd_qiov, cluster_data, cur_nr_sectors * 512); } BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO); qemu_co_mutex_unlock(&s->lock); ret = bdrv_co_writev(bs->file, (cluster_offset >> 9) + index_in_cluster, cur_nr_sectors, &hd_qiov); qemu_co_mutex_lock(&s->lock); if (ret < 0) { goto fail; } ret = qcow2_alloc_cluster_link_l2(bs, &[[l2meta]]); run_dependent_requests(s, &[[l2meta]]); if (ret < 0) { goto fail; } remaining_sectors -= cur_nr_sectors; sector_num += cur_nr_sectors; bytes_done += cur_nr_sectors * 512; } ret = 0; fail: qemu_co_mutex_unlock(&s->lock); qemu_iovec_destroy(&hd_qiov); return ret; }

[[[[Adv]]]]: static int qcow2_co_writev(BlockDriverState *bs, int64_t sector_num, int remaining_sectors, QEMUIOVector *qiov) { BDRVQcowState *s = bs->opaque; int index_in_cluster; int n_end; int ret; int cur_nr_sectors; QCowL2Meta [[ojo]]; uint64_t cluster_offset; QEMUIOVector hd_qiov; uint64_t bytes_done = 0; uint8_t *cluster_data = NULL; [[ojo]].nb_clusters = 0; qemu_co_queue_init(&[[ojo]].dependent_requests); qemu_iovec_init(&hd_qiov, qiov->niov); s->cluster_cache_offset = -1; qemu_co_mutex_lock(&s->lock); while (remaining_sectors != 0) { index_in_cluster = sector_num & (s->cluster_sectors - 1); n_end = index_in_cluster + remaining_sectors; if (s->crypt_method && n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) { n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors; } ret = qcow2_alloc_cluster_offset(bs, sector_num << 9, index_in_cluster, n_end, &cur_nr_sectors, &[[ojo]]); if (ret < 0) { goto fail; } cluster_offset = [[ojo]].cluster_offset; assert((cluster_offset & 511) == 0); qemu_iovec_reset(&hd_qiov); qemu_iovec_copy(&hd_qiov, qiov, bytes_done, cur_nr_sectors * 512); if (s->crypt_method) { if (!cluster_data) { cluster_data = g_malloc0(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size); } assert(hd_qiov.size <= QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size); qemu_iovec_to_buffer(&hd_qiov, cluster_data); qcow2_encrypt_sectors(s, sector_num, cluster_data, cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key); qemu_iovec_reset(&hd_qiov); qemu_iovec_add(&hd_qiov, cluster_data, cur_nr_sectors * 512); } BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO); qemu_co_mutex_unlock(&s->lock); ret = bdrv_co_writev(bs->file, (cluster_offset >> 9) + index_in_cluster, cur_nr_sectors, &hd_qiov); qemu_co_mutex_lock(&s->lock); if (ret < 0) { goto fail; } ret = qcow2_alloc_cluster_link_l2(bs, &[[ojo]]); run_dependent_requests(s, &[[ojo]]); if (ret < 0) { goto fail; } remaining_sectors -= cur_nr_sectors; sector_num += cur_nr_sectors; bytes_done += cur_nr_sectors * 512; } ret = 0; fail: qemu_co_mutex_unlock(&s->lock); qemu_iovec_destroy(&hd_qiov); return ret; }
--------------------------------------------- Result 943 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 541 / 54 / 348 / 943:  35%|      | 943/2690 [11:14:45<20:50:03, 42.93s/it][Succeeded / Failed / Skipped / Total] 541 / 54 / 348 / 943:  35%|      | 944/2690 [11:14:46<20:48:02, 42.89s/it][Succeeded / Failed / Skipped / Total] 541 / 54 / 349 / 944:  35%|      | 944/2690 [11:14:46<20:48:02, 42.89s/it][Succeeded / Failed / Skipped / Total] 541 / 54 / 349 / 944:  35%|      | 945/2690 [11:16:03<20:48:23, 42.92s/it][Succeeded / Failed / Skipped / Total] 542 / 54 / 349 / 945:  35%|      | 945/2690 [11:16:03<20:48:23, 42.92s/it][Succeeded / Failed / Skipped / Total] 542 / 54 / 349 / 945:  35%|      | 946/2690 [11:20:19<20:54:13, 43.15s/it][[0 (64%)]] --> [[0 (50%)]] --> Socre: 0.5001580119132996

[[[[Adv]]]]: int vhost_dev_init(struct vhost_dev *[[hdev]], void *[[opaque]], VhostBackendType backend_type, bool force) { uint64_t [[features]]; int [[i]], r; if (vhost_set_backend_type([[hdev]], backend_type) < 0) { close((uintptr_t)[[opaque]]); return -1; } if ([[hdev]]->vhost_ops->vhost_backend_init([[hdev]], [[opaque]]) < 0) { close((uintptr_t)[[opaque]]); return -errno; } r = [[hdev]]->vhost_ops->vhost_call([[hdev]], VHOST_SET_OWNER, NULL); if (r < 0) { goto fail; } r = [[hdev]]->vhost_ops->vhost_call([[hdev]], VHOST_GET_FEATURES, &[[features]]); if (r < 0) { goto fail; } for ([[i]] = 0; [[i]] < [[hdev]]->nvqs; ++[[i]]) { r = vhost_virtqueue_init([[hdev]], [[hdev]]->vqs + [[i]], [[i]]); if (r < 0) { goto fail_vq; } } [[hdev]]->features = [[features]]; [[hdev]]->memory_listener = (MemoryListener) { .begin = vhost_begin, .commit = vhost_commit, .region_add = vhost_region_add, .region_del = vhost_region_del, .region_nop = vhost_region_nop, .log_start = vhost_log_start, .log_stop = vhost_log_stop, .log_sync = vhost_log_sync, .log_global_start = vhost_log_global_start, .log_global_stop = vhost_log_global_stop, .eventfd_add = vhost_eventfd_add, .eventfd_del = vhost_eventfd_del, .priority = 10 }; [[hdev]]->migration_blocker = NULL; if (!([[hdev]]->features & (0x1ULL << VHOST_F_LOG_ALL))) { error_setg(&[[hdev]]->migration_blocker, "Migration disabled: vhost lacks VHOST_F_LOG_ALL feature."); migrate_add_blocker([[hdev]]->migration_blocker); } [[hdev]]->mem = g_malloc0(offsetof(struct vhost_memory, regions)); [[hdev]]->n_mem_sections = 0; [[hdev]]->mem_sections = NULL; [[hdev]]->log = NULL; [[hdev]]->log_size = 0; [[hdev]]->log_enabled = "False" != "False"; [[hdev]]->started = "False" != "False"; [[hdev]]->memory_changed = "False" != "False"; memory_listener_register(&[[hdev]]->memory_listener, &address_space_memory); [[hdev]]->force = force; return 0; fail_vq: while (--[[i]] >= 0) { vhost_virtqueue_cleanup([[hdev]]->vqs + [[i]]); } fail: r = -errno; [[hdev]]->vhost_ops->vhost_backend_cleanup([[hdev]]); return r; }

[[[[Adv]]]]: int vhost_dev_init(struct vhost_dev *[[spore]], void *[[ambiguous]], VhostBackendType backend_type, bool force) { uint64_t [[featured]]; int [[je]], r; if (vhost_set_backend_type([[spore]], backend_type) < 0) { close((uintptr_t)[[ambiguous]]); return -1; } if ([[spore]]->vhost_ops->vhost_backend_init([[spore]], [[ambiguous]]) < 0) { close((uintptr_t)[[ambiguous]]); return -errno; } r = [[spore]]->vhost_ops->vhost_call([[spore]], VHOST_SET_OWNER, NULL); if (r < 0) { goto fail; } r = [[spore]]->vhost_ops->vhost_call([[spore]], VHOST_GET_FEATURES, &[[featured]]); if (r < 0) { goto fail; } for ([[je]] = 0; [[je]] < [[spore]]->nvqs; ++[[je]]) { r = vhost_virtqueue_init([[spore]], [[spore]]->vqs + [[je]], [[je]]); if (r < 0) { goto fail_vq; } } [[spore]]->features = [[featured]]; [[spore]]->memory_listener = (MemoryListener) { .begin = vhost_begin, .commit = vhost_commit, .region_add = vhost_region_add, .region_del = vhost_region_del, .region_nop = vhost_region_nop, .log_start = vhost_log_start, .log_stop = vhost_log_stop, .log_sync = vhost_log_sync, .log_global_start = vhost_log_global_start, .log_global_stop = vhost_log_global_stop, .eventfd_add = vhost_eventfd_add, .eventfd_del = vhost_eventfd_del, .priority = 10 }; [[spore]]->migration_blocker = NULL; if (!([[spore]]->features & (0x1ULL << VHOST_F_LOG_ALL))) { error_setg(&[[spore]]->migration_blocker, "Migration disabled: vhost lacks VHOST_F_LOG_ALL feature."); migrate_add_blocker([[spore]]->migration_blocker); } [[spore]]->mem = g_malloc0(offsetof(struct vhost_memory, regions)); [[spore]]->n_mem_sections = 0; [[spore]]->mem_sections = NULL; [[spore]]->log = NULL; [[spore]]->log_size = 0; [[spore]]->log_enabled = "False" != "False"; [[spore]]->started = "False" != "False"; [[spore]]->memory_changed = "False" != "False"; memory_listener_register(&[[spore]]->memory_listener, &address_space_memory); [[spore]]->force = force; return 0; fail_vq: while (--[[je]] >= 0) { vhost_virtqueue_cleanup([[spore]]->vqs + [[je]]); } fail: r = -errno; [[spore]]->vhost_ops->vhost_backend_cleanup([[spore]]); return r; }
--------------------------------------------- Result 944 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt) { int i; for (i = 0; i < 256; i++) { int r, g, b; switch (pix_fmt) { case AV_PIX_FMT_RGB8: r = (i>>5 )*36; g = ((i>>2)&7)*36; b = (i&3 )*85; break; case AV_PIX_FMT_BGR8: b = (i>>6 )*85; g = ((i>>3)&7)*36; r = (i&7 )*36; break; case AV_PIX_FMT_RGB4_BYTE: r = (i>>3 )*255; g = ((i>>1)&3)*85; b = (i&1 )*255; break; case AV_PIX_FMT_BGR4_BYTE: b = (i>>3 )*255; g = ((i>>1)&3)*85; r = (i&1 )*255; break; case AV_PIX_FMT_GRAY8: r = b = g = i; break; default: return AVERROR(EINVAL); } pal[i] = b + (g<<8) + (r<<16) + (0xFF<<24); } return 0; }
--------------------------------------------- Result 945 ---------------------------------------------
[[0 (33%)]] --> [[0 (58%)]] --> Socre: 0.5752273797988892

[[[[Adv]]]]: void qmp_transaction(TransactionActionList *dev_list, Error **errp) { TransactionActionList *dev_entry = dev_list; BlkTransactionState *[[state]], *next; Error *local_err = NULL; QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states; QSIMPLEQ_INIT(&snap_bdrv_states); bdrv_drain_all(); while (NULL != dev_entry) { TransactionAction *[[dev_info]] = NULL; const BdrvActionOps *ops; [[dev_info]] = dev_entry->value; dev_entry = dev_entry->next; assert([[dev_info]]->kind < ARRAY_SIZE(actions)); ops = &actions[[[dev_info]]->kind]; assert(ops->instance_size > 0); [[state]] = g_malloc0(ops->instance_size); [[state]]->ops = ops; [[state]]->action = [[dev_info]]; QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, [[state]], entry); [[state]]->ops->prepare([[state]], &local_err); if (local_err) { error_propagate(errp, local_err); goto delete_and_fail; } } QSIMPLEQ_FOREACH([[state]], &snap_bdrv_states, entry) { if ([[state]]->ops->commit) { [[state]]->ops->commit([[state]]); } } goto exit; delete_and_fail: QSIMPLEQ_FOREACH([[state]], &snap_bdrv_states, entry) { if ([[state]]->ops->abort) { [[state]]->ops->abort([[state]]); } } exit: QSIMPLEQ_FOREACH_SAFE([[state]], &snap_bdrv_states, entry, next) { if ([[state]]->ops->clean) { [[state]]->ops->clean([[state]]); } g_free([[state]]); } }

[[[[Adv]]]]: void qmp_transaction(TransactionActionList *dev_list, Error **errp) { TransactionActionList *dev_entry = dev_list; BlkTransactionState *[[government]], *next; Error *local_err = NULL; QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states; QSIMPLEQ_INIT(&snap_bdrv_states); bdrv_drain_all(); while (NULL != dev_entry) { TransactionAction *[[uprooting]] = NULL; const BdrvActionOps *ops; [[uprooting]] = dev_entry->value; dev_entry = dev_entry->next; assert([[uprooting]]->kind < ARRAY_SIZE(actions)); ops = &actions[[[uprooting]]->kind]; assert(ops->instance_size > 0); [[government]] = g_malloc0(ops->instance_size); [[government]]->ops = ops; [[government]]->action = [[uprooting]]; QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, [[government]], entry); [[government]]->ops->prepare([[government]], &local_err); if (local_err) { error_propagate(errp, local_err); goto delete_and_fail; } } QSIMPLEQ_FOREACH([[government]], &snap_bdrv_states, entry) { if ([[government]]->ops->commit) { [[government]]->ops->commit([[government]]); } } goto exit; delete_and_fail: QSIMPLEQ_FOREACH([[government]], &snap_bdrv_states, entry) { if ([[government]]->ops->abort) { [[government]]->ops->abort([[government]]); } } exit: QSIMPLEQ_FOREACH_SAFE([[government]], &snap_bdrv_states, entry, next) { if ([[government]]->ops->clean) { [[government]]->ops->clean([[government]]); } g_free([[government]]); } }
--------------------------------------------- Result 946 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 543 / 54 / 349 / 946:  35%|      | 946/2690 [11:20:19<20:54:13, 43.15s/it][Succeeded / Failed / Skipped / Total] 543 / 54 / 349 / 946:  35%|      | 947/2690 [11:20:51<20:53:08, 43.14s/it][Succeeded / Failed / Skipped / Total] 544 / 54 / 349 / 947:  35%|      | 947/2690 [11:20:51<20:53:08, 43.14s/it][Succeeded / Failed / Skipped / Total] 544 / 54 / 349 / 947:  35%|      | 948/2690 [11:23:15<20:55:30, 43.24s/it][[0 (19%)]] --> [[0 (51%)]] --> Socre: 0.5056465268135071

[[[[Adv]]]]: static int intel_hda_init(PCIDevice *pci) { IntelHDAState *[[d]] = DO_UPCAST(IntelHDAState, pci, pci); uint8_t *[[conf]] = [[d]]->pci.config; [[d]]->name = [[d]]->pci.qdev.info->name; pci_config_set_vendor_id([[conf]], PCI_VENDOR_ID_INTEL); pci_config_set_device_id([[conf]], 0x2668); pci_config_set_revision([[conf]], 1); pci_config_set_class([[conf]], PCI_CLASS_MULTIMEDIA_HD_AUDIO); pci_config_set_interrupt_pin([[conf]], 1); [[conf]][0x40] = 0x01; [[d]]->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read, intel_hda_mmio_write, [[d]], DEVICE_NATIVE_ENDIAN); pci_register_bar_simple(&[[d]]->pci, 0, 0x4000, 0, [[d]]->mmio_addr); if ([[d]]->msi) { msi_init(&[[d]]->pci, 0x50, 1, "True" == "True", "[[False]]" != "[[False]]"); } hda_codec_bus_init(&[[d]]->pci.qdev, &[[d]]->codecs, intel_hda_response, intel_hda_xfer); return 0; }

[[[[Adv]]]]: static int intel_hda_init(PCIDevice *pci) { IntelHDAState *[[per]] = DO_UPCAST(IntelHDAState, pci, pci); uint8_t *[[vim]] = [[per]]->pci.config; [[per]]->name = [[per]]->pci.qdev.info->name; pci_config_set_vendor_id([[vim]], PCI_VENDOR_ID_INTEL); pci_config_set_device_id([[vim]], 0x2668); pci_config_set_revision([[vim]], 1); pci_config_set_class([[vim]], PCI_CLASS_MULTIMEDIA_HD_AUDIO); pci_config_set_interrupt_pin([[vim]], 1); [[vim]][0x40] = 0x01; [[per]]->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read, intel_hda_mmio_write, [[per]], DEVICE_NATIVE_ENDIAN); pci_register_bar_simple(&[[per]]->pci, 0, 0x4000, 0, [[per]]->mmio_addr); if ([[per]]->msi) { msi_init(&[[per]]->pci, 0x50, 1, "True" == "True", "[[Fake]]" != "[[Fake]]"); } hda_codec_bus_init(&[[per]]->pci.qdev, &[[per]]->codecs, intel_hda_response, intel_hda_xfer); return 0; }
--------------------------------------------- Result 947 ---------------------------------------------
[[0 (3%)]] --> [[0 (65%)]] --> Socre: 0.6488719582557678

[[[[Adv]]]]: static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs, int64_t sector_num, QEMUIOVector *qiov, int nb_sectors, BlockDriverCompletionFunc *cb, void *opaque) { RawAIOCB *[[acb]]; [[acb]] = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque); if (![[acb]]) return NULL; if (qemu_paio_write(&[[acb]]->aiocb) < 0) { raw_aio_remove([[acb]]); return NULL; } return &[[acb]]->common; }

[[[[Adv]]]]: static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs, int64_t sector_num, QEMUIOVector *qiov, int nb_sectors, BlockDriverCompletionFunc *cb, void *opaque) { RawAIOCB *[[mortals]]; [[mortals]] = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque); if (![[mortals]]) return NULL; if (qemu_paio_write(&[[mortals]]->aiocb) < 0) { raw_aio_remove([[mortals]]); return NULL; } return &[[mortals]]->common; }
--------------------------------------------- Result 948 ---------------------------------------------
[[0 (5%)]] --> [[0 (60%)]] --> Socre: 0.6043665409088135

[[[[Adv]]]]: static inline void pred_direct_motion(H264Context * const h, int *[[mb_type]]){ MpegEncContext * const s = &h->s; const int mb_xy = s->mb_x + s->mb_y*s->mb_stride; const int b8_xy = 2*s->mb_x + 2*s->mb_y*h->b8_stride; const int b4_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride; const int mb_type_col = h->ref_list[1][0].mb_type[mb_xy]; const int16_t (*l1mv0)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[0][b4_xy]; const int8_t *l1ref0 = &h->ref_list[1][0].ref_index[0][b8_xy]; const int is_b8x8 = IS_8X8(*[[mb_type]]); int sub_mb_type; int i8, i4; if(IS_8X8(mb_type_col) && !h->sps.direct_8x8_inference_flag){ sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; *[[mb_type]] = MB_TYPE_8x8; }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){ sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; *[[mb_type]] = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; }else{ sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; *[[mb_type]] = MB_TYPE_8x8; } if(!is_b8x8) *[[mb_type]] |= MB_TYPE_DIRECT2; tprintf("mb_type = %08x, sub_mb_type = %08x, is_b8x8 = %d, mb_type_col = %08x\n", *[[mb_type]], sub_mb_type, is_b8x8, mb_type_col); if(h->direct_spatial_mv_pred){ int ref[2]; int mv[2][2]; int list; for(list=0; list<2; list++){ int refa = h->ref_cache[list][scan8[0] - 1]; int refb = h->ref_cache[list][scan8[0] - 8]; int refc = h->ref_cache[list][scan8[0] - 8 + 4]; if(refc == -2) refc = h->ref_cache[list][scan8[0] - 8 - 1]; ref[list] = refa; if(ref[list] < 0 || (refb < ref[list] && refb >= 0)) ref[list] = refb; if(ref[list] < 0 || (refc < ref[list] && refc >= 0)) ref[list] = refc; if(ref[list] < 0) ref[list] = -1; } if(ref[0] < 0 && ref[1] < 0){ ref[0] = ref[1] = 0; mv[0][0] = mv[0][1] = mv[1][0] = mv[1][1] = 0; }else{ for(list=0; list<2; list++){ if(ref[list] >= 0) pred_motion(h, 0, 4, list, ref[list], &mv[list][0], &mv[list][1]); else mv[list][0] = mv[list][1] = 0; } } if(ref[1] < 0){ *[[mb_type]] &= ~MB_TYPE_P0L1; sub_mb_type &= ~MB_TYPE_P0L1; }else if(ref[0] < 0){ *[[mb_type]] &= ~MB_TYPE_P0L0; sub_mb_type &= ~MB_TYPE_P0L0; } if(IS_16X16(*[[mb_type]])){ fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref[0], 1); fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, ref[1], 1); if(!IS_INTRA(mb_type_col) && l1ref0[0] == 0 && ABS(l1mv0[0][0]) <= 1 && ABS(l1mv0[0][1]) <= 1){ if(ref[0] > 0) fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4); else fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4); if(ref[1] > 0) fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4); else fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4); }else{ fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4); fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4); } }else{ for(i8=0; i8<4; i8++){ const int x8 = i8&1; const int y8 = i8>>1; if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8])) continue; h->sub_mb_type[i8] = sub_mb_type; fill_rectangle(&h->mv_cache[0][scan8[i8*4]], 2, 2, 8, pack16to32(mv[0][0],mv[0][1]), 4); fill_rectangle(&h->mv_cache[1][scan8[i8*4]], 2, 2, 8, pack16to32(mv[1][0],mv[1][1]), 4); fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref[0], 1); fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, ref[1], 1); if(!IS_INTRA(mb_type_col) && l1ref0[x8 + y8*h->b8_stride] == 0){ for(i4=0; i4<4; i4++){ const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride]; if(ABS(mv_col[0]) <= 1 && ABS(mv_col[1]) <= 1){ if(ref[0] == 0) *(uint32_t*)h->mv_cache[0][scan8[i8*4+i4]] = 0; if(ref[1] == 0) *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] = 0; } } } } } }else{ if(IS_16X16(*[[mb_type]])){ fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1); if(IS_INTRA(mb_type_col)){ fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, 0, 1); fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, 0, 4); fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, 0, 4); }else{ const int ref0 = l1ref0[0]; const int dist_scale_factor = h->dist_scale_factor[ref0]; const int16_t *mv_col = l1mv0[0]; int mv_l0[2]; mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8; mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8; fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref0, 1); fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0],mv_l0[1]), 4); fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]), 4); } }else{ for(i8=0; i8<4; i8++){ const int x8 = i8&1; const int y8 = i8>>1; int ref0, dist_scale_factor; if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8])) continue; h->sub_mb_type[i8] = sub_mb_type; if(IS_INTRA(mb_type_col)){ fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, 0, 1); fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1); fill_rectangle(&h-> mv_cache[0][scan8[i8*4]], 2, 2, 8, 0, 4); fill_rectangle(&h-> mv_cache[1][scan8[i8*4]], 2, 2, 8, 0, 4); continue; } ref0 = l1ref0[x8 + y8*h->b8_stride]; dist_scale_factor = h->dist_scale_factor[ref0]; fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref0, 1); fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1); for(i4=0; i4<4; i4++){ const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride]; int16_t *mv_l0 = h->mv_cache[0][scan8[i8*4+i4]]; mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8; mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8; *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] = pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]); } } } } }

[[[[Adv]]]]: static inline void pred_direct_motion(H264Context * const h, int *[[didnt]]){ MpegEncContext * const s = &h->s; const int mb_xy = s->mb_x + s->mb_y*s->mb_stride; const int b8_xy = 2*s->mb_x + 2*s->mb_y*h->b8_stride; const int b4_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride; const int mb_type_col = h->ref_list[1][0].mb_type[mb_xy]; const int16_t (*l1mv0)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[0][b4_xy]; const int8_t *l1ref0 = &h->ref_list[1][0].ref_index[0][b8_xy]; const int is_b8x8 = IS_8X8(*[[didnt]]); int sub_mb_type; int i8, i4; if(IS_8X8(mb_type_col) && !h->sps.direct_8x8_inference_flag){ sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; *[[didnt]] = MB_TYPE_8x8; }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){ sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; *[[didnt]] = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; }else{ sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; *[[didnt]] = MB_TYPE_8x8; } if(!is_b8x8) *[[didnt]] |= MB_TYPE_DIRECT2; tprintf("mb_type = %08x, sub_mb_type = %08x, is_b8x8 = %d, mb_type_col = %08x\n", *[[didnt]], sub_mb_type, is_b8x8, mb_type_col); if(h->direct_spatial_mv_pred){ int ref[2]; int mv[2][2]; int list; for(list=0; list<2; list++){ int refa = h->ref_cache[list][scan8[0] - 1]; int refb = h->ref_cache[list][scan8[0] - 8]; int refc = h->ref_cache[list][scan8[0] - 8 + 4]; if(refc == -2) refc = h->ref_cache[list][scan8[0] - 8 - 1]; ref[list] = refa; if(ref[list] < 0 || (refb < ref[list] && refb >= 0)) ref[list] = refb; if(ref[list] < 0 || (refc < ref[list] && refc >= 0)) ref[list] = refc; if(ref[list] < 0) ref[list] = -1; } if(ref[0] < 0 && ref[1] < 0){ ref[0] = ref[1] = 0; mv[0][0] = mv[0][1] = mv[1][0] = mv[1][1] = 0; }else{ for(list=0; list<2; list++){ if(ref[list] >= 0) pred_motion(h, 0, 4, list, ref[list], &mv[list][0], &mv[list][1]); else mv[list][0] = mv[list][1] = 0; } } if(ref[1] < 0){ *[[didnt]] &= ~MB_TYPE_P0L1; sub_mb_type &= ~MB_TYPE_P0L1; }else if(ref[0] < 0){ *[[didnt]] &= ~MB_TYPE_P0L0; sub_mb_type &= ~MB_TYPE_P0L0; } if(IS_16X16(*[[didnt]])){ fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref[0], 1); fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, ref[1], 1); if(!IS_INTRA(mb_type_col) && l1ref0[0] == 0 && ABS(l1mv0[0][0]) <= 1 && ABS(l1mv0[0][1]) <= 1){ if(ref[0] > 0) fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4); else fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4); if(ref[1] > 0) fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4); else fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4); }else{ fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4); fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4); } }else{ for(i8=0; i8<4; i8++){ const int x8 = i8&1; const int y8 = i8>>1; if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8])) continue; h->sub_mb_type[i8] = sub_mb_type; fill_rectangle(&h->mv_cache[0][scan8[i8*4]], 2, 2, 8, pack16to32(mv[0][0],mv[0][1]), 4); fill_rectangle(&h->mv_cache[1][scan8[i8*4]], 2, 2, 8, pack16to32(mv[1][0],mv[1][1]), 4); fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref[0], 1); fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, ref[1], 1); if(!IS_INTRA(mb_type_col) && l1ref0[x8 + y8*h->b8_stride] == 0){ for(i4=0; i4<4; i4++){ const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride]; if(ABS(mv_col[0]) <= 1 && ABS(mv_col[1]) <= 1){ if(ref[0] == 0) *(uint32_t*)h->mv_cache[0][scan8[i8*4+i4]] = 0; if(ref[1] == 0) *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] = 0; } } } } } }else{ if(IS_16X16(*[[didnt]])){ fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1); if(IS_INTRA(mb_type_col)){ fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, 0, 1); fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, 0, 4); fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, 0, 4); }else{ const int ref0 = l1ref0[0]; const int dist_scale_factor = h->dist_scale_factor[ref0]; const int16_t *mv_col = l1mv0[0]; int mv_l0[2]; mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8; mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8; fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref0, 1); fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0],mv_l0[1]), 4); fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]), 4); } }else{ for(i8=0; i8<4; i8++){ const int x8 = i8&1; const int y8 = i8>>1; int ref0, dist_scale_factor; if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8])) continue; h->sub_mb_type[i8] = sub_mb_type; if(IS_INTRA(mb_type_col)){ fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, 0, 1); fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1); fill_rectangle(&h-> mv_cache[0][scan8[i8*4]], 2, 2, 8, 0, 4); fill_rectangle(&h-> mv_cache[1][scan8[i8*4]], 2, 2, 8, 0, 4); continue; } ref0 = l1ref0[x8 + y8*h->b8_stride]; dist_scale_factor = h->dist_scale_factor[ref0]; fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref0, 1); fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1); for(i4=0; i4<4; i4++){ const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride]; int16_t *mv_l0 = h->mv_cache[0][scan8[i8*4+i4]]; mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8; mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8; *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] = pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]); } } } } }[Succeeded / Failed / Skipped / Total] 545 / 54 / 349 / 948:  35%|      | 948/2690 [11:23:15<20:55:30, 43.24s/it][Succeeded / Failed / Skipped / Total] 545 / 54 / 349 / 948:  35%|      | 949/2690 [11:23:21<20:53:40, 43.21s/it][Succeeded / Failed / Skipped / Total] 546 / 54 / 349 / 949:  35%|      | 949/2690 [11:23:21<20:53:40, 43.21s/it][Succeeded / Failed / Skipped / Total] 546 / 54 / 349 / 949:  35%|      | 950/2690 [11:23:29<20:51:51, 43.17s/it][Succeeded / Failed / Skipped / Total] 547 / 54 / 349 / 950:  35%|      | 950/2690 [11:23:29<20:51:51, 43.17s/it][Succeeded / Failed / Skipped / Total] 547 / 54 / 349 / 950:  35%|      | 951/2690 [11:23:38<20:50:05, 43.13s/it][Succeeded / Failed / Skipped / Total] 548 / 54 / 349 / 951:  35%|      | 951/2690 [11:23:38<20:50:05, 43.13s/it][Succeeded / Failed / Skipped / Total] 548 / 54 / 349 / 951:  35%|      | 952/2690 [11:23:40<20:48:07, 43.09s/it][Succeeded / Failed / Skipped / Total] 549 / 54 / 349 / 952:  35%|      | 952/2690 [11:23:40<20:48:07, 43.09s/it][Succeeded / Failed / Skipped / Total] 549 / 54 / 349 / 952:  35%|      | 953/2690 [11:24:42<20:48:00, 43.11s/it][Succeeded / Failed / Skipped / Total] 550 / 54 / 349 / 953:  35%|      | 953/2690 [11:24:42<20:48:00, 43.11s/it][Succeeded / Failed / Skipped / Total] 550 / 54 / 349 / 953:  35%|      | 954/2690 [11:25:09<20:46:47, 43.09s/it]
--------------------------------------------- Result 949 ---------------------------------------------
[[0 (11%)]] --> [[0 (62%)]] --> Socre: 0.6152538061141968

[[[[Adv]]]]: static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot) { uint32_t [[ret]]; switch (ot) { case MO_8: [[ret]] = cpu_ldub_code(env, s->pc); s->pc++; break; case MO_16: [[ret]] = cpu_lduw_code(env, s->pc); s->pc += 2; break; case MO_32: #ifdef TARGET_X86_64 case MO_64: #endif [[ret]] = cpu_ldl_code(env, s->pc); s->pc += 4; break; default: tcg_abort(); } return [[ret]]; }

[[[[Adv]]]]: static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot) { uint32_t [[pension]]; switch (ot) { case MO_8: [[pension]] = cpu_ldub_code(env, s->pc); s->pc++; break; case MO_16: [[pension]] = cpu_lduw_code(env, s->pc); s->pc += 2; break; case MO_32: #ifdef TARGET_X86_64 case MO_64: #endif [[pension]] = cpu_ldl_code(env, s->pc); s->pc += 4; break; default: tcg_abort(); } return [[pension]]; }
--------------------------------------------- Result 950 ---------------------------------------------
[[0 (5%)]] --> [[0 (54%)]] --> Socre: 0.5380200743675232

[[[[Adv]]]]: static void bdrv_throttle_write_timer_cb(void *[[opaque]]) { BlockDriverState *bs = [[opaque]]; qemu_co_enter_next(&bs->throttled_reqs[1]); }

[[[[Adv]]]]: static void bdrv_throttle_write_timer_cb(void *[[grainy]]) { BlockDriverState *bs = [[grainy]]; qemu_co_enter_next(&bs->throttled_reqs[1]); }
--------------------------------------------- Result 951 ---------------------------------------------
[[0 (9%)]] --> [[0 (52%)]] --> Socre: 0.5227857232093811

[[[[Adv]]]]: static int find_pte32(CPUPPCState *[[env]], mmu_ctx_t *ctx, int h, int rw, int type, int target_page_bits) { hwaddr pteg_off; target_ulong pte0, pte1; int i, good = -1; int ret, r; ret = -1; pteg_off = get_pteg_offset([[env]], ctx->hash[h], HASH_PTE_SIZE_32); for (i = 0; i < 8; i++) { if ([[env]]->external_htab) { pte0 = ldl_p([[env]]->external_htab + pteg_off + (i * 8)); pte1 = ldl_p([[env]]->external_htab + pteg_off + (i * 8) + 4); } else { pte0 = ldl_phys([[env]]->htab_base + pteg_off + (i * 8)); pte1 = ldl_phys([[env]]->htab_base + pteg_off + (i * 8) + 4); } r = pte_check_hash32(ctx, pte0, pte1, h, rw, type); LOG_MMU("Load pte from %08" HWADDR_PRIx " => " TARGET_FMT_lx " " TARGET_FMT_lx " %d %d %d " TARGET_FMT_lx "\n", pteg_off + (i * 8), pte0, pte1, (int)(pte0 >> 31), h, (int)((pte0 >> 6) & 1), ctx->ptem); switch (r) { case -3: return -1; case -2: ret = -2; good = i; break; case -1: default: break; case 0: ret = 0; good = i; goto done; } } if (good != -1) { done: LOG_MMU("found PTE at addr %08" HWADDR_PRIx " prot=%01x ret=%d\n", ctx->raddr, ctx->prot, ret); pte1 = ctx->raddr; if (pte_update_flags(ctx, &pte1, ret, rw) == 1) { if ([[env]]->external_htab) { stl_p([[env]]->external_htab + pteg_off + (good * 8) + 4, pte1); } else { stl_phys_notdirty([[env]]->htab_base + pteg_off + (good * 8) + 4, pte1); } } } if (target_page_bits != TARGET_PAGE_BITS) { ctx->raddr |= (ctx->eaddr & ((1 << target_page_bits) - 1)) & TARGET_PAGE_MASK; } return ret; }

[[[[Adv]]]]: static int find_pte32(CPUPPCState *[[hallucination]], mmu_ctx_t *ctx, int h, int rw, int type, int target_page_bits) { hwaddr pteg_off; target_ulong pte0, pte1; int i, good = -1; int ret, r; ret = -1; pteg_off = get_pteg_offset([[hallucination]], ctx->hash[h], HASH_PTE_SIZE_32); for (i = 0; i < 8; i++) { if ([[hallucination]]->external_htab) { pte0 = ldl_p([[hallucination]]->external_htab + pteg_off + (i * 8)); pte1 = ldl_p([[hallucination]]->external_htab + pteg_off + (i * 8) + 4); } else { pte0 = ldl_phys([[hallucination]]->htab_base + pteg_off + (i * 8)); pte1 = ldl_phys([[hallucination]]->htab_base + pteg_off + (i * 8) + 4); } r = pte_check_hash32(ctx, pte0, pte1, h, rw, type); LOG_MMU("Load pte from %08" HWADDR_PRIx " => " TARGET_FMT_lx " " TARGET_FMT_lx " %d %d %d " TARGET_FMT_lx "\n", pteg_off + (i * 8), pte0, pte1, (int)(pte0 >> 31), h, (int)((pte0 >> 6) & 1), ctx->ptem); switch (r) { case -3: return -1; case -2: ret = -2; good = i; break; case -1: default: break; case 0: ret = 0; good = i; goto done; } } if (good != -1) { done: LOG_MMU("found PTE at addr %08" HWADDR_PRIx " prot=%01x ret=%d\n", ctx->raddr, ctx->prot, ret); pte1 = ctx->raddr; if (pte_update_flags(ctx, &pte1, ret, rw) == 1) { if ([[hallucination]]->external_htab) { stl_p([[hallucination]]->external_htab + pteg_off + (good * 8) + 4, pte1); } else { stl_phys_notdirty([[hallucination]]->htab_base + pteg_off + (good * 8) + 4, pte1); } } } if (target_page_bits != TARGET_PAGE_BITS) { ctx->raddr |= (ctx->eaddr & ((1 << target_page_bits) - 1)) & TARGET_PAGE_MASK; } return ret; }
--------------------------------------------- Result 952 ---------------------------------------------
[[0 (14%)]] --> [[0 (96%)]] --> Socre: 0.9572175145149231

[[[[Adv]]]]: static int kvm_put_xcrs(CPUState *[[env]]) { #ifdef KVM_CAP_XCRS struct kvm_xcrs xcrs; if (!kvm_has_xcrs()) return 0; xcrs.nr_xcrs = 1; xcrs.flags = 0; xcrs.xcrs[0].xcr = 0; xcrs.xcrs[0].value = [[env]]->xcr0; return kvm_vcpu_ioctl([[env]], KVM_SET_XCRS, &xcrs); #else return 0; #endif }

[[[[Adv]]]]: static int kvm_put_xcrs(CPUState *[[lige]]) { #ifdef KVM_CAP_XCRS struct kvm_xcrs xcrs; if (!kvm_has_xcrs()) return 0; xcrs.nr_xcrs = 1; xcrs.flags = 0; xcrs.xcrs[0].xcr = 0; xcrs.xcrs[0].value = [[lige]]->xcr0; return kvm_vcpu_ioctl([[lige]], KVM_SET_XCRS, &xcrs); #else return 0; #endif }
--------------------------------------------- Result 953 ---------------------------------------------
[[0 (3%)]] --> [[0 (85%)]] --> Socre: 0.8539010882377625

[[[[Adv]]]]: static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond [[cond]], TCGv cmp, int32_t [[disp]]) { uint64_t [[dest]] = ctx->pc + ([[disp]] << 2); int lab_true = gen_new_label(); if (use_goto_tb(ctx, [[dest]])) { tcg_gen_brcondi_i64([[cond]], cmp, 0, lab_true); tcg_gen_goto_tb(0); tcg_gen_movi_i64(cpu_pc, ctx->pc); tcg_gen_exit_tb((uintptr_t)ctx->tb); gen_set_label(lab_true); tcg_gen_goto_tb(1); tcg_gen_movi_i64(cpu_pc, [[dest]]); tcg_gen_exit_tb((uintptr_t)ctx->tb + 1); return EXIT_GOTO_TB; } else { TCGv_i64 z = tcg_const_i64(0); TCGv_i64 d = tcg_const_i64([[dest]]); TCGv_i64 p = tcg_const_i64(ctx->pc); tcg_gen_movcond_i64([[cond]], cpu_pc, cmp, z, d, p); tcg_temp_free_i64(z); tcg_temp_free_i64(d); tcg_temp_free_i64(p); return EXIT_PC_UPDATED; } }

[[[[Adv]]]]: static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond [[gerardo]], TCGv cmp, int32_t [[veuve]]) { uint64_t [[sicilians]] = ctx->pc + ([[veuve]] << 2); int lab_true = gen_new_label(); if (use_goto_tb(ctx, [[sicilians]])) { tcg_gen_brcondi_i64([[gerardo]], cmp, 0, lab_true); tcg_gen_goto_tb(0); tcg_gen_movi_i64(cpu_pc, ctx->pc); tcg_gen_exit_tb((uintptr_t)ctx->tb); gen_set_label(lab_true); tcg_gen_goto_tb(1); tcg_gen_movi_i64(cpu_pc, [[sicilians]]); tcg_gen_exit_tb((uintptr_t)ctx->tb + 1); return EXIT_GOTO_TB; } else { TCGv_i64 z = tcg_const_i64(0); TCGv_i64 d = tcg_const_i64([[sicilians]]); TCGv_i64 p = tcg_const_i64(ctx->pc); tcg_gen_movcond_i64([[gerardo]], cpu_pc, cmp, z, d, p); tcg_temp_free_i64(z); tcg_temp_free_i64(d); tcg_temp_free_i64(p); return EXIT_PC_UPDATED; } }
--------------------------------------------- Result 954 ---------------------------------------------
[[0 (18%)]] --> [[0 (54%)]] --> Socre: 0.5443609952926636

[[[[Adv]]]]: void mpeg1_encode_mb(MpegEncContext *s, DCTELEM block[6][64], int [[motion_x]], int motion_y) { int i, cbp; const int mb_x = s->mb_x; const int [[mb_y]] = s->mb_y; const int first_mb= mb_x == s->resync_mb_x && [[mb_y]] == s->resync_mb_y; cbp = 0; for(i=0;i<6;i++) { if (s->block_last_index[i] >= 0) cbp |= 1 << (5 - i); } if (cbp == 0 && !first_mb && (mb_x != s->mb_width - 1 || ([[mb_y]] != s->mb_height - 1 && s->codec_id == CODEC_ID_MPEG1VIDEO)) && ((s->pict_type == P_TYPE && s->mv_type == MV_TYPE_16X16 && ([[motion_x]] | motion_y) == 0) || (s->pict_type == B_TYPE && s->mv_dir == s->last_mv_dir && (((s->mv_dir & MV_DIR_FORWARD) ? ((s->mv[0][0][0] - s->last_mv[0][0][0])|(s->mv[0][0][1] - s->last_mv[0][0][1])) : 0) | ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) { s->mb_skip_run++; s->qscale -= s->dquant; s->skip_count++; s->misc_bits++; s->last_bits++; if(s->pict_type == P_TYPE){ s->last_mv[0][1][0]= s->last_mv[0][0][0]= s->last_mv[0][1][1]= s->last_mv[0][0][1]= 0; } } else { if(first_mb){ assert(s->mb_skip_run == 0); encode_mb_skip_run(s, s->mb_x); }else{ encode_mb_skip_run(s, s->mb_skip_run); } if (s->pict_type == I_TYPE) { if(s->dquant && cbp){ put_mb_modes(s, 2, 1, 0, 0); put_bits(&s->pb, 5, s->qscale); }else{ put_mb_modes(s, 1, 1, 0, 0); s->qscale -= s->dquant; } s->misc_bits+= get_bits_diff(s); s->i_count++; } else if (s->mb_intra) { if(s->dquant && cbp){ put_mb_modes(s, 6, 0x01, 0, 0); put_bits(&s->pb, 5, s->qscale); }else{ put_mb_modes(s, 5, 0x03, 0, 0); s->qscale -= s->dquant; } s->misc_bits+= get_bits_diff(s); s->i_count++; memset(s->last_mv, 0, sizeof(s->last_mv)); } else if (s->pict_type == P_TYPE) { if(s->mv_type == MV_TYPE_16X16){ if (cbp != 0) { if (([[motion_x]]|motion_y) == 0) { if(s->dquant){ put_mb_modes(s, 5, 1, 0, 0); put_bits(&s->pb, 5, s->qscale); }else{ put_mb_modes(s, 2, 1, 0, 0); } s->misc_bits+= get_bits_diff(s); } else { if(s->dquant){ put_mb_modes(s, 5, 2, 1, 0); put_bits(&s->pb, 5, s->qscale); }else{ put_mb_modes(s, 1, 1, 1, 0); } s->misc_bits+= get_bits_diff(s); mpeg1_encode_motion(s, [[motion_x]] - s->last_mv[0][0][0], s->f_code); mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code); s->mv_bits+= get_bits_diff(s); } } else { put_bits(&s->pb, 3, 1); if (!s->frame_pred_frame_dct) put_bits(&s->pb, 2, 2); s->misc_bits+= get_bits_diff(s); mpeg1_encode_motion(s, [[motion_x]] - s->last_mv[0][0][0], s->f_code); mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code); s->qscale -= s->dquant; s->mv_bits+= get_bits_diff(s); } s->last_mv[0][1][0]= s->last_mv[0][0][0]= [[motion_x]]; s->last_mv[0][1][1]= s->last_mv[0][0][1]= motion_y; }else{ assert(!s->frame_pred_frame_dct && s->mv_type == MV_TYPE_FIELD); if (cbp) { if(s->dquant){ put_mb_modes(s, 5, 2, 1, 1); put_bits(&s->pb, 5, s->qscale); }else{ put_mb_modes(s, 1, 1, 1, 1); } } else { put_bits(&s->pb, 3, 1); put_bits(&s->pb, 2, 1); s->qscale -= s->dquant; } s->misc_bits+= get_bits_diff(s); for(i=0; i<2; i++){ put_bits(&s->pb, 1, s->field_select[0][i]); mpeg1_encode_motion(s, s->mv[0][i][0] - s->last_mv[0][i][0] , s->f_code); mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code); s->last_mv[0][i][0]= s->mv[0][i][0]; s->last_mv[0][i][1]= 2*s->mv[0][i][1]; } s->mv_bits+= get_bits_diff(s); } if(cbp) put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]); s->f_count++; } else{ static const int mb_type_len[4]={0,3,4,2}; if(s->mv_type == MV_TYPE_16X16){ if (cbp){ if (s->dquant) { if(s->mv_dir == MV_DIR_FORWARD) put_mb_modes(s, 6, 3, 1, 0); else put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 0); put_bits(&s->pb, 5, s->qscale); } else { put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 0); } }else{ put_bits(&s->pb, mb_type_len[s->mv_dir], 2); if (!s->frame_pred_frame_dct) put_bits(&s->pb, 2, 2); s->qscale -= s->dquant; } s->misc_bits += get_bits_diff(s); if (s->mv_dir&MV_DIR_FORWARD){ mpeg1_encode_motion(s, s->mv[0][0][0] - s->last_mv[0][0][0], s->f_code); mpeg1_encode_motion(s, s->mv[0][0][1] - s->last_mv[0][0][1], s->f_code); s->last_mv[0][0][0]=s->last_mv[0][1][0]= s->mv[0][0][0]; s->last_mv[0][0][1]=s->last_mv[0][1][1]= s->mv[0][0][1]; s->f_count++; } if (s->mv_dir&MV_DIR_BACKWARD){ mpeg1_encode_motion(s, s->mv[1][0][0] - s->last_mv[1][0][0], s->b_code); mpeg1_encode_motion(s, s->mv[1][0][1] - s->last_mv[1][0][1], s->b_code); s->last_mv[1][0][0]=s->last_mv[1][1][0]= s->mv[1][0][0]; s->last_mv[1][0][1]=s->last_mv[1][1][1]= s->mv[1][0][1]; s->b_count++; } }else{ assert(s->mv_type == MV_TYPE_FIELD); assert(!s->frame_pred_frame_dct); if (cbp){ if (s->dquant) { if(s->mv_dir == MV_DIR_FORWARD) put_mb_modes(s, 6, 3, 1, 1); else put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 1); put_bits(&s->pb, 5, s->qscale); } else { put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 1); } }else{ put_bits(&s->pb, mb_type_len[s->mv_dir], 2); put_bits(&s->pb, 2, 1); s->qscale -= s->dquant; } s->misc_bits += get_bits_diff(s); if (s->mv_dir&MV_DIR_FORWARD){ for(i=0; i<2; i++){ put_bits(&s->pb, 1, s->field_select[0][i]); mpeg1_encode_motion(s, s->mv[0][i][0] - s->last_mv[0][i][0] , s->f_code); mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code); s->last_mv[0][i][0]= s->mv[0][i][0]; s->last_mv[0][i][1]= 2*s->mv[0][i][1]; } s->f_count++; } if (s->mv_dir&MV_DIR_BACKWARD){ for(i=0; i<2; i++){ put_bits(&s->pb, 1, s->field_select[1][i]); mpeg1_encode_motion(s, s->mv[1][i][0] - s->last_mv[1][i][0] , s->b_code); mpeg1_encode_motion(s, s->mv[1][i][1] - (s->last_mv[1][i][1]>>1), s->b_code); s->last_mv[1][i][0]= s->mv[1][i][0]; s->last_mv[1][i][1]= 2*s->mv[1][i][1]; } s->b_count++; } } s->mv_bits += get_bits_diff(s); if(cbp) put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]); } for(i=0;i<6;i++) { if (cbp & (1 << (5 - i))) { mpeg1_encode_block(s, block[i], i); } } s->mb_skip_run = 0; if(s->mb_intra) s->i_tex_bits+= get_bits_diff(s); else s->p_tex_bits+= get_bits_diff(s); } }

[[[[Adv]]]]: void mpeg1_encode_mb(MpegEncContext *s, DCTELEM block[6][64], int [[rentals]], int motion_y) { int i, cbp; const int mb_x = s->mb_x; const int [[marqus]] = s->mb_y; const int first_mb= mb_x == s->resync_mb_x && [[marqus]] == s->resync_mb_y; cbp = 0; for(i=0;i<6;i++) { if (s->block_last_index[i] >= 0) cbp |= 1 << (5 - i); } if (cbp == 0 && !first_mb && (mb_x != s->mb_width - 1 || ([[marqus]] != s->mb_height - 1 && s->codec_id == CODEC_ID_MPEG1VIDEO)) && ((s->pict_type == P_TYPE && s->mv_type == MV_TYPE_16X16 && ([[rentals]] | motion_y) == 0) || (s->pict_type == B_TYPE && s->mv_dir == s->last_mv_dir && (((s->mv_dir & MV_DIR_FORWARD) ? ((s->mv[0][0][0] - s->last_mv[0][0][0])|(s->mv[0][0][1] - s->last_mv[0][0][1])) : 0) | ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) { s->mb_skip_run++; s->qscale -= s->dquant; s->skip_count++; s->misc_bits++; s->last_bits++; if(s->pict_type == P_TYPE){ s->last_mv[0][1][0]= s->last_mv[0][0][0]= s->last_mv[0][1][1]= s->last_mv[0][0][1]= 0; } } else { if(first_mb){ assert(s->mb_skip_run == 0); encode_mb_skip_run(s, s->mb_x); }else{ encode_mb_skip_run(s, s->mb_skip_run); } if (s->pict_type == I_TYPE) { if(s->dquant && cbp){ put_mb_modes(s, 2, 1, 0, 0); put_bits(&s->pb, 5, s->qscale); }else{ put_mb_modes(s, 1, 1, 0, 0); s->qscale -= s->dquant; } s->misc_bits+= get_bits_diff(s); s->i_count++; } else if (s->mb_intra) { if(s->dquant && cbp){ put_mb_modes(s, 6, 0x01, 0, 0); put_bits(&s->pb, 5, s->qscale); }else{ put_mb_modes(s, 5, 0x03, 0, 0); s->qscale -= s->dquant; } s->misc_bits+= get_bits_diff(s); s->i_count++; memset(s->last_mv, 0, sizeof(s->last_mv)); } else if (s->pict_type == P_TYPE) { if(s->mv_type == MV_TYPE_16X16){ if (cbp != 0) { if (([[rentals]]|motion_y) == 0) { if(s->dquant){ put_mb_modes(s, 5, 1, 0, 0); put_bits(&s->pb, 5, s->qscale); }else{ put_mb_modes(s, 2, 1, 0, 0); } s->misc_bits+= get_bits_diff(s); } else { if(s->dquant){ put_mb_modes(s, 5, 2, 1, 0); put_bits(&s->pb, 5, s->qscale); }else{ put_mb_modes(s, 1, 1, 1, 0); } s->misc_bits+= get_bits_diff(s); mpeg1_encode_motion(s, [[rentals]] - s->last_mv[0][0][0], s->f_code); mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code); s->mv_bits+= get_bits_diff(s); } } else { put_bits(&s->pb, 3, 1); if (!s->frame_pred_frame_dct) put_bits(&s->pb, 2, 2); s->misc_bits+= get_bits_diff(s); mpeg1_encode_motion(s, [[rentals]] - s->last_mv[0][0][0], s->f_code); mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code); s->qscale -= s->dquant; s->mv_bits+= get_bits_diff(s); } s->last_mv[0][1][0]= s->last_mv[0][0][0]= [[rentals]]; s->last_mv[0][1][1]= s->last_mv[0][0][1]= motion_y; }else{ assert(!s->frame_pred_frame_dct && s->mv_type == MV_TYPE_FIELD); if (cbp) { if(s->dquant){ put_mb_modes(s, 5, 2, 1, 1); put_bits(&s->pb, 5, s->qscale); }else{ put_mb_modes(s, 1, 1, 1, 1); } } else { put_bits(&s->pb, 3, 1); put_bits(&s->pb, 2, 1); s->qscale -= s->dquant; } s->misc_bits+= get_bits_diff(s); for(i=0; i<2; i++){ put_bits(&s->pb, 1, s->field_select[0][i]); mpeg1_encode_motion(s, s->mv[0][i][0] - s->last_mv[0][i][0] , s->f_code); mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code); s->last_mv[0][i][0]= s->mv[0][i][0]; s->last_mv[0][i][1]= 2*s->mv[0][i][1]; } s->mv_bits+= get_bits_diff(s); } if(cbp) put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]); s->f_count++; } else{ static const int mb_type_len[4]={0,3,4,2}; if(s->mv_type == MV_TYPE_16X16){ if (cbp){ if (s->dquant) { if(s->mv_dir == MV_DIR_FORWARD) put_mb_modes(s, 6, 3, 1, 0); else put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 0); put_bits(&s->pb, 5, s->qscale); } else { put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 0); } }else{ put_bits(&s->pb, mb_type_len[s->mv_dir], 2); if (!s->frame_pred_frame_dct) put_bits(&s->pb, 2, 2); s->qscale -= s->dquant; } s->misc_bits += get_bits_diff(s); if (s->mv_dir&MV_DIR_FORWARD){ mpeg1_encode_motion(s, s->mv[0][0][0] - s->last_mv[0][0][0], s->f_code); mpeg1_encode_motion(s, s->mv[0][0][1] - s->last_mv[0][0][1], s->f_code); s->last_mv[0][0][0]=s->last_mv[0][1][0]= s->mv[0][0][0]; s->last_mv[0][0][1]=s->last_mv[0][1][1]= s->mv[0][0][1]; s->f_count++; } if (s->mv_dir&MV_DIR_BACKWARD){ mpeg1_encode_motion(s, s->mv[1][0][0] - s->last_mv[1][0][0], s->b_code); mpeg1_encode_motion(s, s->mv[1][0][1] - s->last_mv[1][0][1], s->b_code); s->last_mv[1][0][0]=s->last_mv[1][1][0]= s->mv[1][0][0]; s->last_mv[1][0][1]=s->last_mv[1][1][1]= s->mv[1][0][1]; s->b_count++; } }else{ assert(s->mv_type == MV_TYPE_FIELD); assert(!s->frame_pred_frame_dct); if (cbp){ if (s->dquant) { if(s->mv_dir == MV_DIR_FORWARD) put_mb_modes(s, 6, 3, 1, 1); else put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 1); put_bits(&s->pb, 5, s->qscale); } else { put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 1); } }else{ put_bits(&s->pb, mb_type_len[s->mv_dir], 2); put_bits(&s->pb, 2, 1); s->qscale -= s->dquant; } s->misc_bits += get_bits_diff(s); if (s->mv_dir&MV_DIR_FORWARD){ for(i=0; i<2; i++){ put_bits(&s->pb, 1, s->field_select[0][i]); mpeg1_encode_motion(s, s->mv[0][i][0] - s->last_mv[0][i][0] , s->f_code); mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code); s->last_mv[0][i][0]= s->mv[0][i][0]; s->last_mv[0][i][1]= 2*s->mv[0][i][1]; } s->f_count++; } if (s->mv_dir&MV_DIR_BACKWARD){ for(i=0; i<2; i++){ put_bits(&s->pb, 1, s->field_select[1][i]); mpeg1_encode_motion(s, s->mv[1][i][0] - s->last_mv[1][i][0] , s->b_code); mpeg1_encode_motion(s, s->mv[1][i][1] - (s->last_mv[1][i][1]>>1), s->b_code); s->last_mv[1][i][0]= s->mv[1][i][0]; s->last_mv[1][i][1]= 2*s->mv[1][i][1]; } s->b_count++; } } s->mv_bits += get_bits_diff(s); if(cbp) put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]); } for(i=0;i<6;i++) { if (cbp & (1 << (5 - i))) { mpeg1_encode_block(s, block[i], i); } } s->mb_skip_run = 0; if(s->mb_intra) s->i_tex_bits+= get_bits_diff(s); else s->p_tex_bits+= get_bits_diff(s); } }[Succeeded / Failed / Skipped / Total] 551 / 54 / 349 / 954:  35%|      | 954/2690 [11:25:09<20:46:47, 43.09s/it][Succeeded / Failed / Skipped / Total] 551 / 54 / 349 / 954:  36%|      | 955/2690 [11:25:10<20:44:47, 43.05s/it][Succeeded / Failed / Skipped / Total] 551 / 54 / 350 / 955:  36%|      | 955/2690 [11:25:10<20:44:47, 43.05s/it][Succeeded / Failed / Skipped / Total] 551 / 54 / 350 / 955:  36%|      | 956/2690 [11:25:48<20:43:55, 43.04s/it][Succeeded / Failed / Skipped / Total] 552 / 54 / 350 / 956:  36%|      | 956/2690 [11:25:48<20:43:55, 43.04s/it][Succeeded / Failed / Skipped / Total] 552 / 54 / 350 / 956:  36%|      | 957/2690 [11:25:49<20:41:55, 43.00s/it][Succeeded / Failed / Skipped / Total] 552 / 54 / 351 / 957:  36%|      | 957/2690 [11:25:49<20:41:55, 43.00s/it][Succeeded / Failed / Skipped / Total] 552 / 54 / 351 / 957:  36%|      | 958/2690 [11:25:49<20:39:56, 42.95s/it][Succeeded / Failed / Skipped / Total] 552 / 54 / 352 / 958:  36%|      | 958/2690 [11:25:49<20:39:56, 42.95s/it][Succeeded / Failed / Skipped / Total] 552 / 54 / 352 / 958:  36%|      | 959/2690 [11:25:56<20:38:08, 42.92s/it]
--------------------------------------------- Result 955 ---------------------------------------------
[[0 (2%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void rtas_get_time_of_day(PowerPCCPU *cpu, sPAPREnvironment *spapr, uint32_t token, uint32_t nargs, target_ulong args, uint32_t nret, target_ulong rets) { struct tm tm; if (nret != 8) { rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR); return; } qemu_get_timedate(&tm, spapr->rtc_offset); rtas_st(rets, 0, RTAS_OUT_SUCCESS); rtas_st(rets, 1, tm.tm_year + 1900); rtas_st(rets, 2, tm.tm_mon + 1); rtas_st(rets, 3, tm.tm_mday); rtas_st(rets, 4, tm.tm_hour); rtas_st(rets, 5, tm.tm_min); rtas_st(rets, 6, tm.tm_sec); rtas_st(rets, 7, 0); }
--------------------------------------------- Result 956 ---------------------------------------------
[[0 (38%)]] --> [[0 (59%)]] --> Socre: 0.5889086723327637

[[[[Adv]]]]: static uint32_t gt64120_read_config(PCIDevice *d, uint32_t [[address]], int len) { uint32_t val = pci_default_read_config(d, [[address]], len); #ifdef TARGET_WORDS_BIGENDIAN val = bswap32(val); #endif return val; }

[[[[Adv]]]]: static uint32_t gt64120_read_config(PCIDevice *d, uint32_t [[treatment]], int len) { uint32_t val = pci_default_read_config(d, [[treatment]], len); #ifdef TARGET_WORDS_BIGENDIAN val = bswap32(val); #endif return val; }
--------------------------------------------- Result 957 ---------------------------------------------
[[0 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int create_stream(AVFormatContext *s) { XCBGrabContext *c = s->priv_data; AVStream *st = avformat_new_stream(s, NULL); xcb_get_geometry_cookie_t gc; xcb_get_geometry_reply_t *geo; int ret; if (!st) return AVERROR(ENOMEM); ret = av_parse_video_size(&c->width, &c->height, c->video_size); if (ret < 0) return ret; ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate); if (ret < 0) return ret; avpriv_set_pts_info(st, 64, 1, 1000000); gc = xcb_get_geometry(c->conn, c->screen->root); geo = xcb_get_geometry_reply(c->conn, gc, NULL); c->width = FFMIN(geo->width, c->width); c->height = FFMIN(geo->height, c->height); c->time_base = (AVRational){ st->avg_frame_rate.den, st->avg_frame_rate.num }; c->time_frame = av_gettime(); st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->codec->codec_id = AV_CODEC_ID_RAWVIDEO; st->codec->width = c->width; st->codec->height = c->height; st->codec->time_base = c->time_base; ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt); free(geo); return ret; }
--------------------------------------------- Result 958 ---------------------------------------------
[[0 (98%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vorbis_parse_setup_hdr_codebooks(vorbis_context *vc) { unsigned cb; uint8_t *tmp_vlc_bits; uint32_t *tmp_vlc_codes; GetBitContext *gb = &vc->gb; uint16_t *codebook_multiplicands; int ret = 0; vc->codebook_count = get_bits(gb, 8) + 1; av_dlog(NULL, " Codebooks: %d \n", vc->codebook_count); vc->codebooks = av_mallocz(vc->codebook_count * sizeof(*vc->codebooks)); tmp_vlc_bits = av_mallocz(V_MAX_VLCS * sizeof(*tmp_vlc_bits)); tmp_vlc_codes = av_mallocz(V_MAX_VLCS * sizeof(*tmp_vlc_codes)); codebook_multiplicands = av_malloc(V_MAX_VLCS * sizeof(*codebook_multiplicands)); for (cb = 0; cb < vc->codebook_count; ++cb) { vorbis_codebook *codebook_setup = &vc->codebooks[cb]; unsigned ordered, t, entries, used_entries = 0; av_dlog(NULL, " %u. Codebook\n", cb); if (get_bits(gb, 24) != 0x564342) { av_log(vc->avctx, AV_LOG_ERROR, " %u. Codebook setup data corrupt.\n", cb); ret = AVERROR_INVALIDDATA; goto error; } codebook_setup->dimensions=get_bits(gb, 16); if (codebook_setup->dimensions > 16 || codebook_setup->dimensions == 0) { av_log(vc->avctx, AV_LOG_ERROR, " %u. Codebook's dimension is invalid (%d).\n", cb, codebook_setup->dimensions); ret = AVERROR_INVALIDDATA; goto error; } entries = get_bits(gb, 24); if (entries > V_MAX_VLCS) { av_log(vc->avctx, AV_LOG_ERROR, " %u. Codebook has too many entries (%u).\n", cb, entries); ret = AVERROR_INVALIDDATA; goto error; } ordered = get_bits1(gb); av_dlog(NULL, " codebook_dimensions %d, codebook_entries %u\n", codebook_setup->dimensions, entries); if (!ordered) { unsigned ce, flag; unsigned sparse = get_bits1(gb); av_dlog(NULL, " not ordered \n"); if (sparse) { av_dlog(NULL, " sparse \n"); used_entries = 0; for (ce = 0; ce < entries; ++ce) { flag = get_bits1(gb); if (flag) { tmp_vlc_bits[ce] = get_bits(gb, 5) + 1; ++used_entries; } else tmp_vlc_bits[ce] = 0; } } else { av_dlog(NULL, " not sparse \n"); used_entries = entries; for (ce = 0; ce < entries; ++ce) tmp_vlc_bits[ce] = get_bits(gb, 5) + 1; } } else { unsigned current_entry = 0; unsigned current_length = get_bits(gb, 5) + 1; av_dlog(NULL, " ordered, current length: %u\n", current_length); used_entries = entries; for (; current_entry < used_entries && current_length <= 32; ++current_length) { unsigned i, number; av_dlog(NULL, " number bits: %u ", ilog(entries - current_entry)); number = get_bits(gb, ilog(entries - current_entry)); av_dlog(NULL, " number: %u\n", number); for (i = current_entry; i < number+current_entry; ++i) if (i < used_entries) tmp_vlc_bits[i] = current_length; current_entry+=number; } if (current_entry>used_entries) { av_log(vc->avctx, AV_LOG_ERROR, " More codelengths than codes in codebook. \n"); ret = AVERROR_INVALIDDATA; goto error; } } codebook_setup->lookup_type = get_bits(gb, 4); av_dlog(NULL, " lookup type: %d : %s \n", codebook_setup->lookup_type, codebook_setup->lookup_type ? "vq" : "no lookup"); if (codebook_setup->lookup_type == 1) { unsigned i, j, k; unsigned codebook_lookup_values = ff_vorbis_nth_root(entries, codebook_setup->dimensions); float codebook_minimum_value = vorbisfloat2float(get_bits_long(gb, 32)); float codebook_delta_value = vorbisfloat2float(get_bits_long(gb, 32)); unsigned codebook_value_bits = get_bits(gb, 4) + 1; unsigned codebook_sequence_p = get_bits1(gb); av_dlog(NULL, " We expect %d numbers for building the codevectors. \n", codebook_lookup_values); av_dlog(NULL, " delta %f minmum %f \n", codebook_delta_value, codebook_minimum_value); for (i = 0; i < codebook_lookup_values; ++i) { codebook_multiplicands[i] = get_bits(gb, codebook_value_bits); av_dlog(NULL, " multiplicands*delta+minmum : %e \n", (float)codebook_multiplicands[i] * codebook_delta_value + codebook_minimum_value); av_dlog(NULL, " multiplicand %u\n", codebook_multiplicands[i]); } codebook_setup->codevectors = used_entries ? av_mallocz(used_entries * codebook_setup->dimensions * sizeof(*codebook_setup->codevectors)) : NULL; for (j = 0, i = 0; i < entries; ++i) { unsigned dim = codebook_setup->dimensions; if (tmp_vlc_bits[i]) { float last = 0.0; unsigned lookup_offset = i; av_dlog(vc->avctx, "Lookup offset %u ,", i); for (k = 0; k < dim; ++k) { unsigned multiplicand_offset = lookup_offset % codebook_lookup_values; codebook_setup->codevectors[j * dim + k] = codebook_multiplicands[multiplicand_offset] * codebook_delta_value + codebook_minimum_value + last; if (codebook_sequence_p) last = codebook_setup->codevectors[j * dim + k]; lookup_offset/=codebook_lookup_values; } tmp_vlc_bits[j] = tmp_vlc_bits[i]; av_dlog(vc->avctx, "real lookup offset %u, vector: ", j); for (k = 0; k < dim; ++k) av_dlog(vc->avctx, " %f ", codebook_setup->codevectors[j * dim + k]); av_dlog(vc->avctx, "\n"); ++j; } } if (j != used_entries) { av_log(vc->avctx, AV_LOG_ERROR, "Bug in codevector vector building code. \n"); ret = AVERROR_INVALIDDATA; goto error; } entries = used_entries; } else if (codebook_setup->lookup_type >= 2) { av_log(vc->avctx, AV_LOG_ERROR, "Codebook lookup type not supported. \n"); ret = AVERROR_INVALIDDATA; goto error; } if (ff_vorbis_len2vlc(tmp_vlc_bits, tmp_vlc_codes, entries)) { av_log(vc->avctx, AV_LOG_ERROR, " Invalid code lengths while generating vlcs. \n"); ret = AVERROR_INVALIDDATA; goto error; } codebook_setup->maxdepth = 0; for (t = 0; t < entries; ++t) if (tmp_vlc_bits[t] >= codebook_setup->maxdepth) codebook_setup->maxdepth = tmp_vlc_bits[t]; if (codebook_setup->maxdepth > 3 * V_NB_BITS) codebook_setup->nb_bits = V_NB_BITS2; else codebook_setup->nb_bits = V_NB_BITS; codebook_setup->maxdepth = (codebook_setup->maxdepth+codebook_setup->nb_bits - 1) / codebook_setup->nb_bits; if ((ret = init_vlc(&codebook_setup->vlc, codebook_setup->nb_bits, entries, tmp_vlc_bits, sizeof(*tmp_vlc_bits), sizeof(*tmp_vlc_bits), tmp_vlc_codes, sizeof(*tmp_vlc_codes), sizeof(*tmp_vlc_codes), INIT_VLC_LE))) { av_log(vc->avctx, AV_LOG_ERROR, " Error generating vlc tables. \n"); goto error; } } av_free(tmp_vlc_bits); av_free(tmp_vlc_codes); av_free(codebook_multiplicands); return 0; error: av_free(tmp_vlc_bits); av_free(tmp_vlc_codes); av_free(codebook_multiplicands); return ret; }
--------------------------------------------- Result 959 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 553 / 54 / 352 / 959:  36%|      | 959/2690 [11:25:56<20:38:08, 42.92s/it][Succeeded / Failed / Skipped / Total] 553 / 54 / 352 / 959:  36%|      | 960/2690 [11:26:06<20:36:25, 42.88s/it][Succeeded / Failed / Skipped / Total] 554 / 54 / 352 / 960:  36%|      | 960/2690 [11:26:06<20:36:25, 42.88s/it][Succeeded / Failed / Skipped / Total] 554 / 54 / 352 / 960:  36%|      | 961/2690 [11:26:17<20:34:45, 42.85s/it][Succeeded / Failed / Skipped / Total] 555 / 54 / 352 / 961:  36%|      | 961/2690 [11:26:17<20:34:45, 42.85s/it][Succeeded / Failed / Skipped / Total] 555 / 54 / 352 / 961:  36%|      | 962/2690 [11:26:18<20:32:46, 42.80s/it][Succeeded / Failed / Skipped / Total] 555 / 54 / 353 / 962:  36%|      | 962/2690 [11:26:18<20:32:46, 42.80s/it][Succeeded / Failed / Skipped / Total] 555 / 54 / 353 / 962:  36%|      | 963/2690 [11:26:22<20:30:54, 42.76s/it][[0 (62%)]] --> [[0 (50%)]] --> Socre: 0.5015718936920166

[[[[Adv]]]]: static int htab_save_later_pass(QEMUFile *[[f]], sPAPREnvironment *spapr, int64_t max_ns) { bool final = max_ns < 0; int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64; int examined = 0, sent = 0; int [[index]] = spapr->htab_save_index; int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME); assert(!spapr->htab_first_pass); do { int chunkstart, invalidstart; while (([[index]] < htabslots) && !HPTE_DIRTY(HPTE(spapr->htab, [[index]]))) { [[index]]++; examined++; } chunkstart = [[index]]; while (([[index]] < htabslots) && HPTE_DIRTY(HPTE(spapr->htab, [[index]])) && HPTE_VALID(HPTE(spapr->htab, [[index]]))) { CLEAN_HPTE(HPTE(spapr->htab, [[index]])); [[index]]++; examined++; } invalidstart = [[index]]; while (([[index]] < htabslots) && HPTE_DIRTY(HPTE(spapr->htab, [[index]])) && !HPTE_VALID(HPTE(spapr->htab, [[index]]))) { CLEAN_HPTE(HPTE(spapr->htab, [[index]])); [[index]]++; examined++; } if ([[index]] > chunkstart) { int n_valid = invalidstart - chunkstart; int [[n_invalid]] = [[index]] - invalidstart; qemu_put_be32([[f]], chunkstart); qemu_put_be16([[f]], n_valid); qemu_put_be16([[f]], [[n_invalid]]); qemu_put_buffer([[f]], HPTE(spapr->htab, chunkstart), HASH_PTE_SIZE_64 * n_valid); sent += [[index]] - chunkstart; if (!final && (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) { break; } } if (examined >= htabslots) { break; } if ([[index]] >= htabslots) { assert([[index]] == htabslots); [[index]] = 0; } } while ((examined < htabslots) && (!qemu_file_rate_limit([[f]]) || final)); if ([[index]] >= htabslots) { assert([[index]] == htabslots); [[index]] = 0; } spapr->htab_save_index = [[index]]; return (examined >= htabslots) && (sent == 0) ? 1 : 0; }

[[[[Adv]]]]: static int htab_save_later_pass(QEMUFile *[[ft]], sPAPREnvironment *spapr, int64_t max_ns) { bool final = max_ns < 0; int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64; int examined = 0, sent = 0; int [[forefinger]] = spapr->htab_save_index; int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME); assert(!spapr->htab_first_pass); do { int chunkstart, invalidstart; while (([[forefinger]] < htabslots) && !HPTE_DIRTY(HPTE(spapr->htab, [[forefinger]]))) { [[forefinger]]++; examined++; } chunkstart = [[forefinger]]; while (([[forefinger]] < htabslots) && HPTE_DIRTY(HPTE(spapr->htab, [[forefinger]])) && HPTE_VALID(HPTE(spapr->htab, [[forefinger]]))) { CLEAN_HPTE(HPTE(spapr->htab, [[forefinger]])); [[forefinger]]++; examined++; } invalidstart = [[forefinger]]; while (([[forefinger]] < htabslots) && HPTE_DIRTY(HPTE(spapr->htab, [[forefinger]])) && !HPTE_VALID(HPTE(spapr->htab, [[forefinger]]))) { CLEAN_HPTE(HPTE(spapr->htab, [[forefinger]])); [[forefinger]]++; examined++; } if ([[forefinger]] > chunkstart) { int n_valid = invalidstart - chunkstart; int [[rossellini]] = [[forefinger]] - invalidstart; qemu_put_be32([[ft]], chunkstart); qemu_put_be16([[ft]], n_valid); qemu_put_be16([[ft]], [[rossellini]]); qemu_put_buffer([[ft]], HPTE(spapr->htab, chunkstart), HASH_PTE_SIZE_64 * n_valid); sent += [[forefinger]] - chunkstart; if (!final && (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) { break; } } if (examined >= htabslots) { break; } if ([[forefinger]] >= htabslots) { assert([[forefinger]] == htabslots); [[forefinger]] = 0; } } while ((examined < htabslots) && (!qemu_file_rate_limit([[ft]]) || final)); if ([[forefinger]] >= htabslots) { assert([[forefinger]] == htabslots); [[forefinger]] = 0; } spapr->htab_save_index = [[forefinger]]; return (examined >= htabslots) && (sent == 0) ? 1 : 0; }
--------------------------------------------- Result 960 ---------------------------------------------
[[0 (7%)]] --> [[0 (99%)]] --> Socre: 0.9890120029449463

[[[[Adv]]]]: static abi_long do_socket(int domain, int type, int [[protocol]]) { int target_type = type; int ret; ret = target_to_host_sock_type(&type); if (ret) { return ret; } if (domain == PF_NETLINK) return -TARGET_EAFNOSUPPORT; if (domain == AF_PACKET || (domain == AF_INET && type == SOCK_PACKET)) { [[protocol]] = tswap16([[protocol]]); } ret = get_errno(socket(domain, type, [[protocol]])); if (ret >= 0) { ret = sock_flags_fixup(ret, target_type); if (type == SOCK_PACKET) { fd_trans_register(ret, &target_packet_trans); } } return ret; }

[[[[Adv]]]]: static abi_long do_socket(int domain, int type, int [[communiqu]]) { int target_type = type; int ret; ret = target_to_host_sock_type(&type); if (ret) { return ret; } if (domain == PF_NETLINK) return -TARGET_EAFNOSUPPORT; if (domain == AF_PACKET || (domain == AF_INET && type == SOCK_PACKET)) { [[communiqu]] = tswap16([[communiqu]]); } ret = get_errno(socket(domain, type, [[communiqu]])); if (ret >= 0) { ret = sock_flags_fixup(ret, target_type); if (type == SOCK_PACKET) { fd_trans_register(ret, &target_packet_trans); } } return ret; }
--------------------------------------------- Result 961 ---------------------------------------------
[[0 (33%)]] --> [[0 (51%)]] --> Socre: 0.514312207698822

[[[[Adv]]]]: int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len) { PowerPCCPU *cpu = ppc_env_get_cpu(env); CPUState *cs = CPU(cpu); uint32_t *[[hc]] = (uint32_t*)buf; struct kvm_ppc_pvinfo [[pvinfo]]; if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) && !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &[[pvinfo]])) { memcpy(buf, [[pvinfo]].hcall, buf_len); return 0; } [[hc]][0] = 0x3860ffff; [[hc]][1] = 0x60000000; [[hc]][2] = 0x60000000; [[hc]][3] = 0x60000000; return 0; }

[[[[Adv]]]]: int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len) { PowerPCCPU *cpu = ppc_env_get_cpu(env); CPUState *cs = CPU(cpu); uint32_t *[[cl]] = (uint32_t*)buf; struct kvm_ppc_pvinfo [[crested]]; if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) && !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &[[crested]])) { memcpy(buf, [[crested]].hcall, buf_len); return 0; } [[cl]][0] = 0x3860ffff; [[cl]][1] = 0x60000000; [[cl]][2] = 0x60000000; [[cl]][3] = 0x60000000; return 0; }
--------------------------------------------- Result 962 ---------------------------------------------
[[0 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void process_incoming_migration(QEMUFile *f) { if (qemu_loadvm_state(f) < 0) { fprintf(stderr, "load of migration failed\n"); exit(0); } qemu_announce_self(); DPRINTF("successfully loaded vm state\n"); incoming_expected = "False" != "False"; if (autostart) { vm_start(); } else { runstate_set(RSTATE_PRE_LAUNCH); } }
--------------------------------------------- Result 963 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 556 / 54 / 353 / 963:  36%|      | 963/2690 [11:26:22<20:30:54, 42.76s/it][Succeeded / Failed / Skipped / Total] 556 / 54 / 353 / 963:  36%|      | 964/2690 [11:26:46<20:29:37, 42.75s/it][Succeeded / Failed / Skipped / Total] 557 / 54 / 353 / 964:  36%|      | 964/2690 [11:26:46<20:29:37, 42.75s/it][Succeeded / Failed / Skipped / Total] 557 / 54 / 353 / 964:  36%|      | 965/2690 [11:26:59<20:28:02, 42.71s/it][[0 (48%)]] --> [[0 (52%)]] --> Socre: 0.5152167081832886

[[[[Adv]]]]: static int rv40_decode_mb_info(RV34DecContext *r) { MpegEncContext *[[s]] = &r->s; GetBitContext *gb = &[[s]]->gb; int q, i; int prev_type = 0; int mb_pos = [[s]]->mb_x + [[s]]->mb_y * [[s]]->mb_stride; int blocks[RV34_MB_TYPES] = {0}; int count = 0; if(!r->s.mb_skip_run) r->s.mb_skip_run = svq3_get_ue_golomb(gb) + 1; if(--r->s.mb_skip_run) return RV34_MB_SKIP; if(r->avail_cache[6-1]) blocks[r->mb_type[mb_pos - 1]]++; if(r->avail_cache[6-4]){ blocks[r->mb_type[mb_pos - [[s]]->mb_stride]]++; if(r->avail_cache[6-2]) blocks[r->mb_type[mb_pos - [[s]]->mb_stride + 1]]++; if(r->avail_cache[6-5]) blocks[r->mb_type[mb_pos - [[s]]->mb_stride - 1]]++; } for(i = 0; i < RV34_MB_TYPES; i++){ if(blocks[i] > count){ count = blocks[i]; prev_type = i; } } if([[s]]->pict_type == AV_PICTURE_TYPE_P){ prev_type = block_num_to_ptype_vlc_num[prev_type]; q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1); if(q < PBTYPE_ESCAPE) return q; q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1); av_log([[s]]->avctx, AV_LOG_ERROR, "Dquant for P-frame\n"); }else{ prev_type = block_num_to_btype_vlc_num[prev_type]; q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1); if(q < PBTYPE_ESCAPE) return q; q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1); av_log([[s]]->avctx, AV_LOG_ERROR, "Dquant for B-frame\n"); } return 0; }

[[[[Adv]]]]: static int rv40_decode_mb_info(RV34DecContext *r) { MpegEncContext *[[du]] = &r->s; GetBitContext *gb = &[[du]]->gb; int q, i; int prev_type = 0; int mb_pos = [[du]]->mb_x + [[du]]->mb_y * [[du]]->mb_stride; int blocks[RV34_MB_TYPES] = {0}; int count = 0; if(!r->s.mb_skip_run) r->s.mb_skip_run = svq3_get_ue_golomb(gb) + 1; if(--r->s.mb_skip_run) return RV34_MB_SKIP; if(r->avail_cache[6-1]) blocks[r->mb_type[mb_pos - 1]]++; if(r->avail_cache[6-4]){ blocks[r->mb_type[mb_pos - [[du]]->mb_stride]]++; if(r->avail_cache[6-2]) blocks[r->mb_type[mb_pos - [[du]]->mb_stride + 1]]++; if(r->avail_cache[6-5]) blocks[r->mb_type[mb_pos - [[du]]->mb_stride - 1]]++; } for(i = 0; i < RV34_MB_TYPES; i++){ if(blocks[i] > count){ count = blocks[i]; prev_type = i; } } if([[du]]->pict_type == AV_PICTURE_TYPE_P){ prev_type = block_num_to_ptype_vlc_num[prev_type]; q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1); if(q < PBTYPE_ESCAPE) return q; q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1); av_log([[du]]->avctx, AV_LOG_ERROR, "Dquant for P-frame\n"); }else{ prev_type = block_num_to_btype_vlc_num[prev_type]; q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1); if(q < PBTYPE_ESCAPE) return q; q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1); av_log([[du]]->avctx, AV_LOG_ERROR, "Dquant for B-frame\n"); } return 0; }
--------------------------------------------- Result 964 ---------------------------------------------
[[0 (7%)]] --> [[0 (58%)]] --> Socre: 0.5761269927024841

[[[[Adv]]]]: void qmp_block_job_set_speed(const char *[[device]], int64_t speed, Error **[[errp]]) { BlockJob *job = find_block_job([[device]]); if (!job) { error_set([[errp]], QERR_BLOCK_JOB_NOT_ACTIVE, [[device]]); return; } block_job_set_speed(job, speed, [[errp]]); }

[[[[Adv]]]]: void qmp_block_job_set_speed(const char *[[accoutrements]], int64_t speed, Error **[[shampooing]]) { BlockJob *job = find_block_job([[accoutrements]]); if (!job) { error_set([[shampooing]], QERR_BLOCK_JOB_NOT_ACTIVE, [[accoutrements]]); return; } block_job_set_speed(job, speed, [[shampooing]]); }
--------------------------------------------- Result 965 ---------------------------------------------
[[0 (38%)]] --> [[0 (66%)]] --> Socre: 0.6557270288467407

[[[[Adv]]]]: static int pcm_decode_frame(AVCodecContext *[[avctx]], void *data, int *data_size, AVPacket *[[avpkt]]) { const uint8_t *buf = [[avpkt]]->data; int [[buf_size]] = [[avpkt]]->size; PCMDecode *s = [[avctx]]->priv_data; int sample_size, c, n, i; uint8_t *samples; const uint8_t *src, *src8, *src2[MAX_CHANNELS]; int32_t *dst_int32_t; samples = data; src = buf; if ([[avctx]]->sample_fmt!=[[avctx]]->codec->sample_fmts[0]) { av_log([[avctx]], AV_LOG_ERROR, "invalid sample_fmt\n"); return -1; } if([[avctx]]->channels <= 0 || [[avctx]]->channels > MAX_CHANNELS){ av_log([[avctx]], AV_LOG_ERROR, "PCM channels out of bounds\n"); return -1; } sample_size = av_get_bits_per_sample([[avctx]]->codec_id)/8; if (CODEC_ID_PCM_DVD == [[avctx]]->codec_id) sample_size = [[avctx]]->bits_per_coded_sample * 2 / 8; else if ([[avctx]]->codec_id == CODEC_ID_PCM_LXF) sample_size = 5; if (sample_size == 0) { av_log([[avctx]], AV_LOG_ERROR, "Invalid sample_size\n"); return AVERROR(EINVAL); } n = [[avctx]]->channels * sample_size; if(n && [[buf_size]] % n){ if ([[buf_size]] < n) { av_log([[avctx]], AV_LOG_ERROR, "invalid PCM packet\n"); return -1; }else [[buf_size]] -= [[buf_size]] % n; } [[buf_size]]= FFMIN([[buf_size]], *data_size/2); n = [[buf_size]]/sample_size; switch([[avctx]]->codec->id) { case CODEC_ID_PCM_U32LE: DECODE(32, le32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_U32BE: DECODE(32, be32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_S24LE: DECODE(32, le24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_S24BE: DECODE(32, be24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_U24LE: DECODE(32, le24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_U24BE: DECODE(32, be24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_S24DAUD: for(;n>0;n--) { uint32_t v = bytestream_get_be24(&src); v >>= 4; AV_WN16A(samples, av_reverse[(v >> 8) & 0xff] + (av_reverse[v & 0xff] << 8)); samples += 2; } break; case CODEC_ID_PCM_S16LE_PLANAR: n /= [[avctx]]->channels; for(c=0;c<[[avctx]]->channels;c++) src2[c] = &src[c*n*2]; for(;n>0;n--) for(c=0;c<[[avctx]]->channels;c++) { AV_WN16A(samples, bytestream_get_le16(&src2[c])); samples += 2; } src = src2[[[avctx]]->channels-1]; break; case CODEC_ID_PCM_U16LE: DECODE(16, le16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_U16BE: DECODE(16, be16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_S8: for(;n>0;n--) { *samples++ = *src++ + 128; } break; #if HAVE_BIGENDIAN case CODEC_ID_PCM_F64LE: DECODE(64, le64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_F32LE: DECODE(32, le32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16LE: DECODE(16, le16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64BE: case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: case CODEC_ID_PCM_S16BE: #else case CODEC_ID_PCM_F64BE: DECODE(64, be64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: DECODE(32, be32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16BE: DECODE(16, be16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64LE: case CODEC_ID_PCM_F32LE: case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_S16LE: #endif case CODEC_ID_PCM_U8: memcpy(samples, src, n*sample_size); src += n*sample_size; samples += n * sample_size; break; case CODEC_ID_PCM_ZORK: for(;n>0;n--) { int x= *src++; if(x&128) x-= 128; else x = -x; AV_WN16A(samples, x << 8); samples += 2; } break; case CODEC_ID_PCM_ALAW: case CODEC_ID_PCM_MULAW: for(;n>0;n--) { AV_WN16A(samples, s->table[*src++]); samples += 2; } break; case CODEC_ID_PCM_DVD: dst_int32_t = data; n /= [[avctx]]->channels; switch ([[avctx]]->bits_per_coded_sample) { case 20: while (n--) { c = [[avctx]]->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8 &0xf0) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12); } src = src8; } break; case 24: while (n--) { c = [[avctx]]->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); } src = src8; } break; default: av_log([[avctx]], AV_LOG_ERROR, "PCM DVD unsupported sample depth\n"); return -1; } samples = (uint8_t *) dst_int32_t; break; case CODEC_ID_PCM_LXF: dst_int32_t = data; n /= [[avctx]]->channels; for (i = 0; i < n; i++) { for (c = 0, src8 = src + i*5; c < [[avctx]]->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) | ((src8[2] & 0xF) << 8) | src8[1]; } for (c = 0, src8 = src + i*5; c < [[avctx]]->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) | ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4); } } src += n * [[avctx]]->channels * 5; samples = (uint8_t *) dst_int32_t; break; default: return -1; } *data_size = samples - (uint8_t *)data; return src - buf; }

[[[[Adv]]]]: static int pcm_decode_frame(AVCodecContext *[[kilowatt]], void *data, int *data_size, AVPacket *[[janni]]) { const uint8_t *buf = [[janni]]->data; int [[disgusts]] = [[janni]]->size; PCMDecode *s = [[kilowatt]]->priv_data; int sample_size, c, n, i; uint8_t *samples; const uint8_t *src, *src8, *src2[MAX_CHANNELS]; int32_t *dst_int32_t; samples = data; src = buf; if ([[kilowatt]]->sample_fmt!=[[kilowatt]]->codec->sample_fmts[0]) { av_log([[kilowatt]], AV_LOG_ERROR, "invalid sample_fmt\n"); return -1; } if([[kilowatt]]->channels <= 0 || [[kilowatt]]->channels > MAX_CHANNELS){ av_log([[kilowatt]], AV_LOG_ERROR, "PCM channels out of bounds\n"); return -1; } sample_size = av_get_bits_per_sample([[kilowatt]]->codec_id)/8; if (CODEC_ID_PCM_DVD == [[kilowatt]]->codec_id) sample_size = [[kilowatt]]->bits_per_coded_sample * 2 / 8; else if ([[kilowatt]]->codec_id == CODEC_ID_PCM_LXF) sample_size = 5; if (sample_size == 0) { av_log([[kilowatt]], AV_LOG_ERROR, "Invalid sample_size\n"); return AVERROR(EINVAL); } n = [[kilowatt]]->channels * sample_size; if(n && [[disgusts]] % n){ if ([[disgusts]] < n) { av_log([[kilowatt]], AV_LOG_ERROR, "invalid PCM packet\n"); return -1; }else [[disgusts]] -= [[disgusts]] % n; } [[disgusts]]= FFMIN([[disgusts]], *data_size/2); n = [[disgusts]]/sample_size; switch([[kilowatt]]->codec->id) { case CODEC_ID_PCM_U32LE: DECODE(32, le32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_U32BE: DECODE(32, be32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_S24LE: DECODE(32, le24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_S24BE: DECODE(32, be24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_U24LE: DECODE(32, le24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_U24BE: DECODE(32, be24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_S24DAUD: for(;n>0;n--) { uint32_t v = bytestream_get_be24(&src); v >>= 4; AV_WN16A(samples, av_reverse[(v >> 8) & 0xff] + (av_reverse[v & 0xff] << 8)); samples += 2; } break; case CODEC_ID_PCM_S16LE_PLANAR: n /= [[kilowatt]]->channels; for(c=0;c<[[kilowatt]]->channels;c++) src2[c] = &src[c*n*2]; for(;n>0;n--) for(c=0;c<[[kilowatt]]->channels;c++) { AV_WN16A(samples, bytestream_get_le16(&src2[c])); samples += 2; } src = src2[[[kilowatt]]->channels-1]; break; case CODEC_ID_PCM_U16LE: DECODE(16, le16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_U16BE: DECODE(16, be16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_S8: for(;n>0;n--) { *samples++ = *src++ + 128; } break; #if HAVE_BIGENDIAN case CODEC_ID_PCM_F64LE: DECODE(64, le64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_F32LE: DECODE(32, le32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16LE: DECODE(16, le16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64BE: case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: case CODEC_ID_PCM_S16BE: #else case CODEC_ID_PCM_F64BE: DECODE(64, be64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: DECODE(32, be32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16BE: DECODE(16, be16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64LE: case CODEC_ID_PCM_F32LE: case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_S16LE: #endif case CODEC_ID_PCM_U8: memcpy(samples, src, n*sample_size); src += n*sample_size; samples += n * sample_size; break; case CODEC_ID_PCM_ZORK: for(;n>0;n--) { int x= *src++; if(x&128) x-= 128; else x = -x; AV_WN16A(samples, x << 8); samples += 2; } break; case CODEC_ID_PCM_ALAW: case CODEC_ID_PCM_MULAW: for(;n>0;n--) { AV_WN16A(samples, s->table[*src++]); samples += 2; } break; case CODEC_ID_PCM_DVD: dst_int32_t = data; n /= [[kilowatt]]->channels; switch ([[kilowatt]]->bits_per_coded_sample) { case 20: while (n--) { c = [[kilowatt]]->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8 &0xf0) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12); } src = src8; } break; case 24: while (n--) { c = [[kilowatt]]->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); } src = src8; } break; default: av_log([[kilowatt]], AV_LOG_ERROR, "PCM DVD unsupported sample depth\n"); return -1; } samples = (uint8_t *) dst_int32_t; break; case CODEC_ID_PCM_LXF: dst_int32_t = data; n /= [[kilowatt]]->channels; for (i = 0; i < n; i++) { for (c = 0, src8 = src + i*5; c < [[kilowatt]]->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) | ((src8[2] & 0xF) << 8) | src8[1]; } for (c = 0, src8 = src + i*5; c < [[kilowatt]]->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) | ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4); } } src += n * [[kilowatt]]->channels * 5; samples = (uint8_t *) dst_int32_t; break; default: return -1; } *data_size = samples - (uint8_t *)data; return src - buf; }[Succeeded / Failed / Skipped / Total] 558 / 54 / 353 / 965:  36%|      | 965/2690 [11:26:59<20:28:02, 42.71s/it][Succeeded / Failed / Skipped / Total] 558 / 54 / 353 / 965:  36%|      | 966/2690 [11:27:00<20:26:04, 42.67s/it][Succeeded / Failed / Skipped / Total] 558 / 54 / 354 / 966:  36%|      | 966/2690 [11:27:00<20:26:04, 42.67s/it][Succeeded / Failed / Skipped / Total] 558 / 54 / 354 / 966:  36%|      | 967/2690 [11:27:00<20:24:06, 42.63s/it][Succeeded / Failed / Skipped / Total] 558 / 54 / 355 / 967:  36%|      | 967/2690 [11:27:00<20:24:06, 42.63s/it][Succeeded / Failed / Skipped / Total] 558 / 54 / 355 / 967:  36%|      | 968/2690 [11:28:34<20:24:55, 42.68s/it][Succeeded / Failed / Skipped / Total] 559 / 54 / 355 / 968:  36%|      | 968/2690 [11:28:34<20:24:55, 42.68s/it][Succeeded / Failed / Skipped / Total] 559 / 54 / 355 / 968:  36%|      | 969/2690 [11:28:38<20:23:03, 42.64s/it][Succeeded / Failed / Skipped / Total] 560 / 54 / 355 / 969:  36%|      | 969/2690 [11:28:38<20:23:03, 42.64s/it][Succeeded / Failed / Skipped / Total] 560 / 54 / 355 / 969:  36%|      | 970/2690 [11:29:07<20:21:57, 42.63s/it][Succeeded / Failed / Skipped / Total] 561 / 54 / 355 / 970:  36%|      | 970/2690 [11:29:07<20:21:57, 42.63s/it][Succeeded / Failed / Skipped / Total] 561 / 54 / 355 / 970:  36%|      | 971/2690 [11:29:25<20:20:30, 42.60s/it]
--------------------------------------------- Result 966 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int parse_presentation_segment(AVCodecContext *avctx, const uint8_t *buf, int buf_size, int64_t pts) { PGSSubContext *ctx = avctx->priv_data; int x, y, ret; int w = bytestream_get_be16(&buf); int h = bytestream_get_be16(&buf); ctx->presentation.pts = pts; av_dlog(avctx, "Video Dimensions %dx%d\n", w, h); ret = ff_set_dimensions(avctx, w, h); if (ret < 0) return ret; buf++; ctx->presentation.id_number = bytestream_get_be16(&buf); buf += 3; ctx->presentation.object_number = bytestream_get_byte(&buf); ctx->presentation.composition_flag = 0; if (!ctx->presentation.object_number) return 0; buf += 3; ctx->presentation.composition_flag = bytestream_get_byte(&buf); x = bytestream_get_be16(&buf); y = bytestream_get_be16(&buf); av_dlog(avctx, "Subtitle Placement x=%d, y=%d\n", x, y); if (x > avctx->width || y > avctx->height) { av_log(avctx, AV_LOG_ERROR, "Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\n", x, y, avctx->width, avctx->height); x = 0; y = 0; } ctx->presentation.x = x; ctx->presentation.y = y; return 0; }
--------------------------------------------- Result 967 ---------------------------------------------
[[0 (73%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qemu_coroutine_delete(Coroutine *co_) { CoroutineThreadState *s = coroutine_get_thread_state(); CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_); if (s->pool_size < POOL_MAX_SIZE) { QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next); co->base.caller = NULL; s->pool_size++; return; } g_free(co->stack); g_free(co); }
--------------------------------------------- Result 968 ---------------------------------------------
[[0 (1%)]] --> [[0 (69%)]] --> Socre: 0.6939388513565063

[[[[Adv]]]]: int float64_eq_signaling( float64 [[a]], float64 b STATUS_PARAM ) { if ( ( ( extractFloat64Exp( [[a]] ) == 0x7FF ) && extractFloat64Frac( [[a]] ) ) || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) ) ) { float_raise( float_flag_invalid STATUS_VAR); return 0; } return ( [[a]] == b ) || ( (bits64) ( ( [[a]] | b )<<1 ) == 0 ); }

[[[[Adv]]]]: int float64_eq_signaling( float64 [[]], float64 b STATUS_PARAM ) { if ( ( ( extractFloat64Exp( [[]] ) == 0x7FF ) && extractFloat64Frac( [[]] ) ) || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) ) ) { float_raise( float_flag_invalid STATUS_VAR); return 0; } return ( [[]] == b ) || ( (bits64) ( ( [[]] | b )<<1 ) == 0 ); }
--------------------------------------------- Result 969 ---------------------------------------------
[[0 (42%)]] --> [[0 (61%)]] --> Socre: 0.6072813272476196

[[[[Adv]]]]: static int tpm_passthrough_unix_tx_bufs(int tpm_fd, const uint8_t *in, uint32_t in_len, uint8_t *out, uint32_t [[out_len]]) { int ret; ret = tpm_passthrough_unix_write(tpm_fd, in, in_len); if (ret != in_len) { error_report("tpm_passthrough: error while transmitting data " "to TPM: %s (%i)\n", strerror(errno), errno); goto err_exit; } ret = tpm_passthrough_unix_read(tpm_fd, out, [[out_len]]); if (ret < 0) { error_report("tpm_passthrough: error while reading data from " "TPM: %s (%i)\n", strerror(errno), errno); } else if (ret < sizeof(struct tpm_resp_hdr) || tpm_passthrough_get_size_from_buffer(out) != ret) { ret = -1; error_report("tpm_passthrough: received invalid response " "packet from TPM\n"); } err_exit: if (ret < 0) { tpm_write_fatal_error_response(out, [[out_len]]); } return ret; }

[[[[Adv]]]]: static int tpm_passthrough_unix_tx_bufs(int tpm_fd, const uint8_t *in, uint32_t in_len, uint8_t *out, uint32_t [[straws]]) { int ret; ret = tpm_passthrough_unix_write(tpm_fd, in, in_len); if (ret != in_len) { error_report("tpm_passthrough: error while transmitting data " "to TPM: %s (%i)\n", strerror(errno), errno); goto err_exit; } ret = tpm_passthrough_unix_read(tpm_fd, out, [[straws]]); if (ret < 0) { error_report("tpm_passthrough: error while reading data from " "TPM: %s (%i)\n", strerror(errno), errno); } else if (ret < sizeof(struct tpm_resp_hdr) || tpm_passthrough_get_size_from_buffer(out) != ret) { ret = -1; error_report("tpm_passthrough: received invalid response " "packet from TPM\n"); } err_exit: if (ret < 0) { tpm_write_fatal_error_response(out, [[straws]]); } return ret; }
--------------------------------------------- Result 970 ---------------------------------------------
[[0 (13%)]] --> [[0 (97%)]] --> Socre: 0.9688372015953064

[[[[Adv]]]]: int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr, uint8_t *[[buf]], int len, int is_write) { int l; target_phys_addr_t phys_addr; target_ulong page; while (len > 0) { page = addr & TARGET_PAGE_MASK; phys_addr = cpu_get_phys_page_debug(env, page); if (phys_addr == -1) return -1; l = (page + TARGET_PAGE_SIZE) - addr; if (l > len) l = len; phys_addr += (addr & ~TARGET_PAGE_MASK); if (is_write) cpu_physical_memory_write_rom(phys_addr, [[buf]], l); else cpu_physical_memory_rw(phys_addr, [[buf]], l, is_write); len -= l; [[buf]] += l; addr += l; } return 0; }

[[[[Adv]]]]: int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr, uint8_t *[[ingls]], int len, int is_write) { int l; target_phys_addr_t phys_addr; target_ulong page; while (len > 0) { page = addr & TARGET_PAGE_MASK; phys_addr = cpu_get_phys_page_debug(env, page); if (phys_addr == -1) return -1; l = (page + TARGET_PAGE_SIZE) - addr; if (l > len) l = len; phys_addr += (addr & ~TARGET_PAGE_MASK); if (is_write) cpu_physical_memory_write_rom(phys_addr, [[ingls]], l); else cpu_physical_memory_rw(phys_addr, [[ingls]], l, is_write); len -= l; [[ingls]] += l; addr += l; } return 0; }
--------------------------------------------- Result 971 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 562 / 54 / 355 / 971:  36%|      | 971/2690 [11:29:25<20:20:30, 42.60s/it][Succeeded / Failed / Skipped / Total] 562 / 54 / 355 / 971:  36%|      | 972/2690 [11:31:19<20:21:54, 42.67s/it][Succeeded / Failed / Skipped / Total] 563 / 54 / 355 / 972:  36%|      | 972/2690 [11:31:19<20:21:54, 42.67s/it][Succeeded / Failed / Skipped / Total] 563 / 54 / 355 / 972:  36%|      | 973/2690 [11:31:20<20:19:58, 42.63s/it][[0 (6%)]] --> [[0 (51%)]] --> Socre: 0.5057376027107239

[[[[Adv]]]]: static inline void RENAME(yvu9_to_yuy2)(const uint8_t *[[src1]], const uint8_t *src2, const uint8_t *src3, uint8_t *dst, long width, long height, long srcStride1, long srcStride2, long srcStride3, long [[dstStride]]) { x86_reg x; long [[y]],w,h; w=width/2; h=height; for ([[y]]=0;[[y]]<h;[[y]]++) { const uint8_t* yp=[[src1]]+srcStride1*[[y]]; const uint8_t* [[up]]=src2+srcStride2*([[y]]>>2); const uint8_t* vp=src3+srcStride3*([[y]]>>2); uint8_t* d=dst+[[dstStride]]*[[y]]; x=0; #if COMPILE_TEMPLATE_MMX for (;x<w-7;x+=8) { __asm__ volatile( PREFETCH" 32(%1, %0) \n\t" PREFETCH" 32(%2, %0) \n\t" PREFETCH" 32(%3, %0) \n\t" "movq (%1, %0, 4), %%mm0 \n\t" "movq (%2, %0), %%mm1 \n\t" "movq (%3, %0), %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklbw %%mm1, %%mm1 \n\t" "punpcklbw %%mm2, %%mm2 \n\t" "punpckhbw %%mm4, %%mm4 \n\t" "punpckhbw %%mm5, %%mm5 \n\t" "movq %%mm1, %%mm6 \n\t" "punpcklbw %%mm2, %%mm1 \n\t" "punpcklbw %%mm1, %%mm0 \n\t" "punpckhbw %%mm1, %%mm3 \n\t" MOVNTQ" %%mm0, (%4, %0, 8) \n\t" MOVNTQ" %%mm3, 8(%4, %0, 8) \n\t" "punpckhbw %%mm2, %%mm6 \n\t" "movq 8(%1, %0, 4), %%mm0 \n\t" "movq %%mm0, %%mm3 \n\t" "punpcklbw %%mm6, %%mm0 \n\t" "punpckhbw %%mm6, %%mm3 \n\t" MOVNTQ" %%mm0, 16(%4, %0, 8) \n\t" MOVNTQ" %%mm3, 24(%4, %0, 8) \n\t" "movq %%mm4, %%mm6 \n\t" "movq 16(%1, %0, 4), %%mm0 \n\t" "movq %%mm0, %%mm3 \n\t" "punpcklbw %%mm5, %%mm4 \n\t" "punpcklbw %%mm4, %%mm0 \n\t" "punpckhbw %%mm4, %%mm3 \n\t" MOVNTQ" %%mm0, 32(%4, %0, 8) \n\t" MOVNTQ" %%mm3, 40(%4, %0, 8) \n\t" "punpckhbw %%mm5, %%mm6 \n\t" "movq 24(%1, %0, 4), %%mm0 \n\t" "movq %%mm0, %%mm3 \n\t" "punpcklbw %%mm6, %%mm0 \n\t" "punpckhbw %%mm6, %%mm3 \n\t" MOVNTQ" %%mm0, 48(%4, %0, 8) \n\t" MOVNTQ" %%mm3, 56(%4, %0, 8) \n\t" : "+r" (x) : "r"(yp), "r" (up), "r"(vp), "r"(d) :"memory"); } #endif for (; x<w; x++) { const long x2 = x<<2; d[8*x+0] = yp[x2]; d[8*x+1] = [[up]][x]; d[8*x+2] = yp[x2+1]; d[8*x+3] = vp[x]; d[8*x+4] = yp[x2+2]; d[8*x+5] = [[up]][x]; d[8*x+6] = yp[x2+3]; d[8*x+7] = vp[x]; } } #if COMPILE_TEMPLATE_MMX __asm__( EMMS" \n\t" SFENCE" \n\t" ::: "memory" ); #endif }

[[[[Adv]]]]: static inline void RENAME(yvu9_to_yuy2)(const uint8_t *[[mercan]], const uint8_t *src2, const uint8_t *src3, uint8_t *dst, long width, long height, long srcStride1, long srcStride2, long srcStride3, long [[overtake]]) { x86_reg x; long [[como]],w,h; w=width/2; h=height; for ([[como]]=0;[[como]]<h;[[como]]++) { const uint8_t* yp=[[mercan]]+srcStride1*[[como]]; const uint8_t* [[hiked]]=src2+srcStride2*([[como]]>>2); const uint8_t* vp=src3+srcStride3*([[como]]>>2); uint8_t* d=dst+[[overtake]]*[[como]]; x=0; #if COMPILE_TEMPLATE_MMX for (;x<w-7;x+=8) { __asm__ volatile( PREFETCH" 32(%1, %0) \n\t" PREFETCH" 32(%2, %0) \n\t" PREFETCH" 32(%3, %0) \n\t" "movq (%1, %0, 4), %%mm0 \n\t" "movq (%2, %0), %%mm1 \n\t" "movq (%3, %0), %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklbw %%mm1, %%mm1 \n\t" "punpcklbw %%mm2, %%mm2 \n\t" "punpckhbw %%mm4, %%mm4 \n\t" "punpckhbw %%mm5, %%mm5 \n\t" "movq %%mm1, %%mm6 \n\t" "punpcklbw %%mm2, %%mm1 \n\t" "punpcklbw %%mm1, %%mm0 \n\t" "punpckhbw %%mm1, %%mm3 \n\t" MOVNTQ" %%mm0, (%4, %0, 8) \n\t" MOVNTQ" %%mm3, 8(%4, %0, 8) \n\t" "punpckhbw %%mm2, %%mm6 \n\t" "movq 8(%1, %0, 4), %%mm0 \n\t" "movq %%mm0, %%mm3 \n\t" "punpcklbw %%mm6, %%mm0 \n\t" "punpckhbw %%mm6, %%mm3 \n\t" MOVNTQ" %%mm0, 16(%4, %0, 8) \n\t" MOVNTQ" %%mm3, 24(%4, %0, 8) \n\t" "movq %%mm4, %%mm6 \n\t" "movq 16(%1, %0, 4), %%mm0 \n\t" "movq %%mm0, %%mm3 \n\t" "punpcklbw %%mm5, %%mm4 \n\t" "punpcklbw %%mm4, %%mm0 \n\t" "punpckhbw %%mm4, %%mm3 \n\t" MOVNTQ" %%mm0, 32(%4, %0, 8) \n\t" MOVNTQ" %%mm3, 40(%4, %0, 8) \n\t" "punpckhbw %%mm5, %%mm6 \n\t" "movq 24(%1, %0, 4), %%mm0 \n\t" "movq %%mm0, %%mm3 \n\t" "punpcklbw %%mm6, %%mm0 \n\t" "punpckhbw %%mm6, %%mm3 \n\t" MOVNTQ" %%mm0, 48(%4, %0, 8) \n\t" MOVNTQ" %%mm3, 56(%4, %0, 8) \n\t" : "+r" (x) : "r"(yp), "r" (up), "r"(vp), "r"(d) :"memory"); } #endif for (; x<w; x++) { const long x2 = x<<2; d[8*x+0] = yp[x2]; d[8*x+1] = [[hiked]][x]; d[8*x+2] = yp[x2+1]; d[8*x+3] = vp[x]; d[8*x+4] = yp[x2+2]; d[8*x+5] = [[hiked]][x]; d[8*x+6] = yp[x2+3]; d[8*x+7] = vp[x]; } } #if COMPILE_TEMPLATE_MMX __asm__( EMMS" \n\t" SFENCE" \n\t" ::: "memory" ); #endif }
--------------------------------------------- Result 972 ---------------------------------------------
[[0 (11%)]] --> [[0 (55%)]] --> Socre: 0.5492153167724609

[[[[Adv]]]]: static int send_sub_rect(VncState *vs, int x, int y, int w, int h) { VncPalette *palette = &color_count_palette; uint32_t bg = 0, fg = 0; int colors; int ret = 0; #ifdef CONFIG_VNC_JPEG bool force_jpeg = "False" != "False"; bool [[allow_jpeg]] = "True" == "True"; #endif vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type); vnc_tight_start(vs); vnc_raw_send_framebuffer_update(vs, x, y, w, h); vnc_tight_stop(vs); #ifdef CONFIG_VNC_JPEG if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) { double freq = vnc_update_freq(vs, x, y, w, h); if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) { [[allow_jpeg]] = "False" != "False"; } if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) { force_jpeg = "True" == "True"; vnc_sent_lossy_rect(vs, x, y, w, h); } } #endif colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette); #ifdef CONFIG_VNC_JPEG if ([[allow_jpeg]] && vs->tight.quality != (uint8_t)-1) { ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette, force_jpeg); } else { ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette); } #else ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette); #endif return ret; }

[[[[Adv]]]]: static int send_sub_rect(VncState *vs, int x, int y, int w, int h) { VncPalette *palette = &color_count_palette; uint32_t bg = 0, fg = 0; int colors; int ret = 0; #ifdef CONFIG_VNC_JPEG bool force_jpeg = "False" != "False"; bool [[nio]] = "True" == "True"; #endif vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type); vnc_tight_start(vs); vnc_raw_send_framebuffer_update(vs, x, y, w, h); vnc_tight_stop(vs); #ifdef CONFIG_VNC_JPEG if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) { double freq = vnc_update_freq(vs, x, y, w, h); if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) { [[nio]] = "False" != "False"; } if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) { force_jpeg = "True" == "True"; vnc_sent_lossy_rect(vs, x, y, w, h); } } #endif colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette); #ifdef CONFIG_VNC_JPEG if ([[nio]] && vs->tight.quality != (uint8_t)-1) { ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette, force_jpeg); } else { ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette); } #else ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette); #endif return ret; }
--------------------------------------------- Result 973 ---------------------------------------------
[[0 (68%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static ExitStatus translate_one(DisasContext *ctx, uint32_t insn) { uint32_t palcode; int32_t disp21, disp16; #ifndef CONFIG_USER_ONLY int32_t disp12; #endif uint16_t fn11; uint8_t opc, ra, rb, rc, fpfn, fn7, islit, real_islit; uint8_t lit; ExitStatus ret; opc = insn >> 26; ra = (insn >> 21) & 0x1F; rb = (insn >> 16) & 0x1F; rc = insn & 0x1F; real_islit = islit = (insn >> 12) & 1; if (rb == 31 && !islit) { islit = 1; lit = 0; } else lit = (insn >> 13) & 0xFF; palcode = insn & 0x03FFFFFF; disp21 = ((int32_t)((insn & 0x001FFFFF) << 11)) >> 11; disp16 = (int16_t)(insn & 0x0000FFFF); #ifndef CONFIG_USER_ONLY disp12 = (int32_t)((insn & 0x00000FFF) << 20) >> 20; #endif fn11 = (insn >> 5) & 0x000007FF; fpfn = fn11 & 0x3F; fn7 = (insn >> 5) & 0x0000007F; LOG_DISAS("opc %02x ra %2d rb %2d rc %2d disp16 %6d\n", opc, ra, rb, rc, disp16); ret = NO_EXIT; switch (opc) { case 0x00: ret = gen_call_pal(ctx, palcode); break; case 0x01: goto invalid_opc; case 0x02: goto invalid_opc; case 0x03: goto invalid_opc; case 0x04: goto invalid_opc; case 0x05: goto invalid_opc; case 0x06: goto invalid_opc; case 0x07: goto invalid_opc; case 0x08: if (likely(ra != 31)) { if (rb != 31) { tcg_gen_addi_i64(cpu_ir[ra], cpu_ir[rb], disp16); } else { tcg_gen_movi_i64(cpu_ir[ra], disp16); } } break; case 0x09: if (likely(ra != 31)) { if (rb != 31) { tcg_gen_addi_i64(cpu_ir[ra], cpu_ir[rb], disp16 << 16); } else { tcg_gen_movi_i64(cpu_ir[ra], disp16 << 16); } } break; case 0x0A: if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) { gen_load_mem(ctx, &tcg_gen_qemu_ld8u, ra, rb, disp16, 0, 0); break; } goto invalid_opc; case 0x0B: gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 1); break; case 0x0C: if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) { gen_load_mem(ctx, &tcg_gen_qemu_ld16u, ra, rb, disp16, 0, 0); break; } goto invalid_opc; case 0x0D: gen_store_mem(ctx, &tcg_gen_qemu_st16, ra, rb, disp16, 0, 0); break; case 0x0E: gen_store_mem(ctx, &tcg_gen_qemu_st8, ra, rb, disp16, 0, 0); break; case 0x0F: gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 1); break; case 0x10: switch (fn7) { case 0x00: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_addi_i64(cpu_ir[rc], cpu_ir[ra], lit); tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]); } else { tcg_gen_add_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]); } } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x02: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 2); if (islit) { tcg_gen_addi_i64(tmp, tmp, lit); } else { tcg_gen_add_i64(tmp, tmp, cpu_ir[rb]); } tcg_gen_ext32s_i64(cpu_ir[rc], tmp); tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x09: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_subi_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_sub_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], -lit); } else { tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]); tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]); } } } break; case 0x0B: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 2); if (islit) { tcg_gen_subi_i64(tmp, tmp, lit); } else { tcg_gen_sub_i64(tmp, tmp, cpu_ir[rb]); } tcg_gen_ext32s_i64(cpu_ir[rc], tmp); tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], -lit); } else { tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]); tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]); } } } break; case 0x0F: gen_cmpbge(ra, rb, rc, islit, lit); break; case 0x12: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 3); if (islit) { tcg_gen_addi_i64(tmp, tmp, lit); } else { tcg_gen_add_i64(tmp, tmp, cpu_ir[rb]); } tcg_gen_ext32s_i64(cpu_ir[rc], tmp); tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x1B: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 3); if (islit) { tcg_gen_subi_i64(tmp, tmp, lit); } else { tcg_gen_sub_i64(tmp, tmp, cpu_ir[rb]); } tcg_gen_ext32s_i64(cpu_ir[rc], tmp); tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], -lit); } else { tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]); tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]); } } } break; case 0x1D: gen_cmp(TCG_COND_LTU, ra, rb, rc, islit, lit); break; case 0x20: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_addi_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_add_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x22: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 2); if (islit) { tcg_gen_addi_i64(cpu_ir[rc], tmp, lit); } else { tcg_gen_add_i64(cpu_ir[rc], tmp, cpu_ir[rb]); } tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x29: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_subi_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_sub_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], -lit); } else { tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x2B: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 2); if (islit) { tcg_gen_subi_i64(cpu_ir[rc], tmp, lit); } else { tcg_gen_sub_i64(cpu_ir[rc], tmp, cpu_ir[rb]); } tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], -lit); } else { tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x2D: gen_cmp(TCG_COND_EQ, ra, rb, rc, islit, lit); break; case 0x32: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 3); if (islit) { tcg_gen_addi_i64(cpu_ir[rc], tmp, lit); } else { tcg_gen_add_i64(cpu_ir[rc], tmp, cpu_ir[rb]); } tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x3B: if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcg_temp_new(); tcg_gen_shli_i64(tmp, cpu_ir[ra], 3); if (islit) { tcg_gen_subi_i64(cpu_ir[rc], tmp, lit); } else { tcg_gen_sub_i64(cpu_ir[rc], tmp, cpu_ir[rb]); } tcg_temp_free(tmp); } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], -lit); } else { tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x3D: gen_cmp(TCG_COND_LEU, ra, rb, rc, islit, lit); break; case 0x40: gen_addlv(ra, rb, rc, islit, lit); break; case 0x49: gen_sublv(ra, rb, rc, islit, lit); break; case 0x4D: gen_cmp(TCG_COND_LT, ra, rb, rc, islit, lit); break; case 0x60: gen_addqv(ra, rb, rc, islit, lit); break; case 0x69: gen_subqv(ra, rb, rc, islit, lit); break; case 0x6D: gen_cmp(TCG_COND_LE, ra, rb, rc, islit, lit); break; default: goto invalid_opc; } break; case 0x11: switch (fn7) { case 0x00: if (likely(rc != 31)) { if (ra == 31) { tcg_gen_movi_i64(cpu_ir[rc], 0); } else if (islit) { tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_and_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } break; case 0x08: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[ra], ~lit); } else { tcg_gen_andc_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } else tcg_gen_movi_i64(cpu_ir[rc], 0); } break; case 0x14: gen_cmov(TCG_COND_NE, ra, rb, rc, islit, lit, 1); break; case 0x16: gen_cmov(TCG_COND_EQ, ra, rb, rc, islit, lit, 1); break; case 0x20: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_ori_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_or_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x24: gen_cmov(TCG_COND_EQ, ra, rb, rc, islit, lit, 0); break; case 0x26: gen_cmov(TCG_COND_NE, ra, rb, rc, islit, lit, 0); break; case 0x28: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_ori_i64(cpu_ir[rc], cpu_ir[ra], ~lit); } else { tcg_gen_orc_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], ~lit); } else { tcg_gen_not_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x40: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_xori_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_xor_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit); } else { tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x44: gen_cmov(TCG_COND_LT, ra, rb, rc, islit, lit, 0); break; case 0x46: gen_cmov(TCG_COND_GE, ra, rb, rc, islit, lit, 0); break; case 0x48: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_xori_i64(cpu_ir[rc], cpu_ir[ra], ~lit); } else { tcg_gen_eqv_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } else { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], ~lit); } else { tcg_gen_not_i64(cpu_ir[rc], cpu_ir[rb]); } } } break; case 0x61: if (likely(rc != 31)) { uint64_t amask = ctx->tb->flags >> TB_FLAGS_AMASK_SHIFT; if (islit) { tcg_gen_movi_i64(cpu_ir[rc], lit & ~amask); } else { tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[rb], ~amask); } } break; case 0x64: gen_cmov(TCG_COND_LE, ra, rb, rc, islit, lit, 0); break; case 0x66: gen_cmov(TCG_COND_GT, ra, rb, rc, islit, lit, 0); break; case 0x6C: if (rc != 31) { tcg_gen_movi_i64(cpu_ir[rc], ctx->implver); } break; default: goto invalid_opc; } break; case 0x12: switch (fn7) { case 0x02: gen_msk_l(ra, rb, rc, islit, lit, 0x01); break; case 0x06: gen_ext_l(ra, rb, rc, islit, lit, 0x01); break; case 0x0B: gen_ins_l(ra, rb, rc, islit, lit, 0x01); break; case 0x12: gen_msk_l(ra, rb, rc, islit, lit, 0x03); break; case 0x16: gen_ext_l(ra, rb, rc, islit, lit, 0x03); break; case 0x1B: gen_ins_l(ra, rb, rc, islit, lit, 0x03); break; case 0x22: gen_msk_l(ra, rb, rc, islit, lit, 0x0f); break; case 0x26: gen_ext_l(ra, rb, rc, islit, lit, 0x0f); break; case 0x2B: gen_ins_l(ra, rb, rc, islit, lit, 0x0f); break; case 0x30: gen_zap(ra, rb, rc, islit, lit); break; case 0x31: gen_zapnot(ra, rb, rc, islit, lit); break; case 0x32: gen_msk_l(ra, rb, rc, islit, lit, 0xff); break; case 0x34: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_shri_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f); } else { TCGv shift = tcg_temp_new(); tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f); tcg_gen_shr_i64(cpu_ir[rc], cpu_ir[ra], shift); tcg_temp_free(shift); } } else tcg_gen_movi_i64(cpu_ir[rc], 0); } break; case 0x36: gen_ext_l(ra, rb, rc, islit, lit, 0xff); break; case 0x39: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f); } else { TCGv shift = tcg_temp_new(); tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f); tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], shift); tcg_temp_free(shift); } } else tcg_gen_movi_i64(cpu_ir[rc], 0); } break; case 0x3B: gen_ins_l(ra, rb, rc, islit, lit, 0xff); break; case 0x3C: if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcg_gen_sari_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f); } else { TCGv shift = tcg_temp_new(); tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f); tcg_gen_sar_i64(cpu_ir[rc], cpu_ir[ra], shift); tcg_temp_free(shift); } } else tcg_gen_movi_i64(cpu_ir[rc], 0); } break; case 0x52: gen_msk_h(ra, rb, rc, islit, lit, 0x03); break; case 0x57: gen_ins_h(ra, rb, rc, islit, lit, 0x03); break; case 0x5A: gen_ext_h(ra, rb, rc, islit, lit, 0x03); break; case 0x62: gen_msk_h(ra, rb, rc, islit, lit, 0x0f); break; case 0x67: gen_ins_h(ra, rb, rc, islit, lit, 0x0f); break; case 0x6A: gen_ext_h(ra, rb, rc, islit, lit, 0x0f); break; case 0x72: gen_msk_h(ra, rb, rc, islit, lit, 0xff); break; case 0x77: gen_ins_h(ra, rb, rc, islit, lit, 0xff); break; case 0x7A: gen_ext_h(ra, rb, rc, islit, lit, 0xff); break; default: goto invalid_opc; } break; case 0x13: switch (fn7) { case 0x00: if (likely(rc != 31)) { if (ra == 31) { tcg_gen_movi_i64(cpu_ir[rc], 0); } else { if (islit) { tcg_gen_muli_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_mul_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]); } } break; case 0x20: if (likely(rc != 31)) { if (ra == 31) { tcg_gen_movi_i64(cpu_ir[rc], 0); } else if (islit) { tcg_gen_muli_i64(cpu_ir[rc], cpu_ir[ra], lit); } else { tcg_gen_mul_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } } break; case 0x30: { TCGv low; if (unlikely(rc == 31)){ break; } if (ra == 31) { tcg_gen_movi_i64(cpu_ir[rc], 0); break; } low = tcg_temp_new(); if (islit) { tcg_gen_movi_tl(low, lit); tcg_gen_mulu2_i64(low, cpu_ir[rc], cpu_ir[ra], low); } else { tcg_gen_mulu2_i64(low, cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]); } tcg_temp_free(low); } break; case 0x40: gen_mullv(ra, rb, rc, islit, lit); break; case 0x60: gen_mulqv(ra, rb, rc, islit, lit); break; default: goto invalid_opc; } break; case 0x14: switch (fpfn) { case 0x04: if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) { goto invalid_opc; } if (likely(rc != 31)) { if (ra != 31) { TCGv_i32 tmp = tcg_temp_new_i32(); tcg_gen_trunc_i64_i32(tmp, cpu_ir[ra]); gen_helper_memory_to_s(cpu_fir[rc], tmp); tcg_temp_free_i32(tmp); } else tcg_gen_movi_i64(cpu_fir[rc], 0); } break; case 0x0A: if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) { gen_fsqrtf(rb, rc); break; } goto invalid_opc; case 0x0B: if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) { gen_fsqrts(ctx, rb, rc, fn11); break; } goto invalid_opc; case 0x14: if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) { goto invalid_opc; } if (likely(rc != 31)) { if (ra != 31) { TCGv_i32 tmp = tcg_temp_new_i32(); tcg_gen_trunc_i64_i32(tmp, cpu_ir[ra]); gen_helper_memory_to_f(cpu_fir[rc], tmp); tcg_temp_free_i32(tmp); } else tcg_gen_movi_i64(cpu_fir[rc], 0); } break; case 0x24: if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) { goto invalid_opc; } if (likely(rc != 31)) { if (ra != 31) { tcg_gen_mov_i64(cpu_fir[rc], cpu_ir[ra]); } else { tcg_gen_movi_i64(cpu_fir[rc], 0); } } break; case 0x2A: if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) { gen_fsqrtg(rb, rc); break; } goto invalid_opc; case 0x02B: if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) { gen_fsqrtt(ctx, rb, rc, fn11); break; } goto invalid_opc; default: goto invalid_opc; } break; case 0x15: switch (fpfn) { case 0x00: gen_faddf(ra, rb, rc); break; case 0x01: gen_fsubf(ra, rb, rc); break; case 0x02: gen_fmulf(ra, rb, rc); break; case 0x03: gen_fdivf(ra, rb, rc); break; case 0x1E: #if 0 gen_fcvtdg(rb, rc); #else goto invalid_opc; #endif break; case 0x20: gen_faddg(ra, rb, rc); break; case 0x21: gen_fsubg(ra, rb, rc); break; case 0x22: gen_fmulg(ra, rb, rc); break; case 0x23: gen_fdivg(ra, rb, rc); break; case 0x25: gen_fcmpgeq(ra, rb, rc); break; case 0x26: gen_fcmpglt(ra, rb, rc); break; case 0x27: gen_fcmpgle(ra, rb, rc); break; case 0x2C: gen_fcvtgf(rb, rc); break; case 0x2D: #if 0 gen_fcvtgd(rb, rc); #else goto invalid_opc; #endif break; case 0x2F: gen_fcvtgq(rb, rc); break; case 0x3C: gen_fcvtqf(rb, rc); break; case 0x3E: gen_fcvtqg(rb, rc); break; default: goto invalid_opc; } break; case 0x16: switch (fpfn) { case 0x00: gen_fadds(ctx, ra, rb, rc, fn11); break; case 0x01: gen_fsubs(ctx, ra, rb, rc, fn11); break; case 0x02: gen_fmuls(ctx, ra, rb, rc, fn11); break; case 0x03: gen_fdivs(ctx, ra, rb, rc, fn11); break; case 0x20: gen_faddt(ctx, ra, rb, rc, fn11); break; case 0x21: gen_fsubt(ctx, ra, rb, rc, fn11); break; case 0x22: gen_fmult(ctx, ra, rb, rc, fn11); break; case 0x23: gen_fdivt(ctx, ra, rb, rc, fn11); break; case 0x24: gen_fcmptun(ctx, ra, rb, rc, fn11); break; case 0x25: gen_fcmpteq(ctx, ra, rb, rc, fn11); break; case 0x26: gen_fcmptlt(ctx, ra, rb, rc, fn11); break; case 0x27: gen_fcmptle(ctx, ra, rb, rc, fn11); break; case 0x2C: if (fn11 == 0x2AC || fn11 == 0x6AC) { gen_fcvtst(ctx, rb, rc, fn11); } else { gen_fcvtts(ctx, rb, rc, fn11); } break; case 0x2F: gen_fcvttq(ctx, rb, rc, fn11); break; case 0x3C: gen_fcvtqs(ctx, rb, rc, fn11); break; case 0x3E: gen_fcvtqt(ctx, rb, rc, fn11); break; default: goto invalid_opc; } break; case 0x17: switch (fn11) { case 0x010: gen_fcvtlq(rb, rc); break; case 0x020: if (likely(rc != 31)) { if (ra == rb) { if (ra == 31) { tcg_gen_movi_i64(cpu_fir[rc], 0); } else { tcg_gen_mov_i64(cpu_fir[rc], cpu_fir[ra]); } } else { gen_fcpys(ra, rb, rc); } } break; case 0x021: gen_fcpysn(ra, rb, rc); break; case 0x022: gen_fcpyse(ra, rb, rc); break; case 0x024: if (likely(ra != 31)) { gen_helper_store_fpcr(cpu_env, cpu_fir[ra]); } else { TCGv tmp = tcg_const_i64(0); gen_helper_store_fpcr(cpu_env, tmp); tcg_temp_free(tmp); } break; case 0x025: if (likely(ra != 31)) { gen_helper_load_fpcr(cpu_fir[ra], cpu_env); } break; case 0x02A: gen_fcmov(TCG_COND_EQ, ra, rb, rc); break; case 0x02B: gen_fcmov(TCG_COND_NE, ra, rb, rc); break; case 0x02C: gen_fcmov(TCG_COND_LT, ra, rb, rc); break; case 0x02D: gen_fcmov(TCG_COND_GE, ra, rb, rc); break; case 0x02E: gen_fcmov(TCG_COND_LE, ra, rb, rc); break; case 0x02F: gen_fcmov(TCG_COND_GT, ra, rb, rc); break; case 0x030: gen_fcvtql(rb, rc); break; case 0x130: case 0x530: gen_fcvtql_v(ctx, rb, rc); break; default: goto invalid_opc; } break; case 0x18: switch ((uint16_t)disp16) { case 0x0000: break; case 0x0400: break; case 0x4000: break; case 0x4400: break; case 0x8000: break; case 0xA000: break; case 0xC000: if (ra != 31) { if (use_icount) { gen_io_start(); gen_helper_load_pcc(cpu_ir[ra], cpu_env); gen_io_end(); ret = EXIT_PC_STALE; } else { gen_helper_load_pcc(cpu_ir[ra], cpu_env); } } break; case 0xE000: gen_rx(ra, 0); break; case 0xE800: break; case 0xF000: gen_rx(ra, 1); break; case 0xF800: break; default: goto invalid_opc; } break; case 0x19: #ifndef CONFIG_USER_ONLY if (ctx->tb->flags & TB_FLAGS_PAL_MODE) { return gen_mfpr(ra, insn & 0xffff); } #endif goto invalid_opc; case 0x1A: if (rb != 31) { tcg_gen_andi_i64(cpu_pc, cpu_ir[rb], ~3); } else { tcg_gen_movi_i64(cpu_pc, 0); } if (ra != 31) { tcg_gen_movi_i64(cpu_ir[ra], ctx->pc); } ret = EXIT_PC_UPDATED; break; case 0x1B: #ifndef CONFIG_USER_ONLY if (ctx->tb->flags & TB_FLAGS_PAL_MODE) { TCGv addr; if (ra == 31) { break; } addr = tcg_temp_new(); if (rb != 31) { tcg_gen_addi_i64(addr, cpu_ir[rb], disp12); } else { tcg_gen_movi_i64(addr, disp12); } switch ((insn >> 12) & 0xF) { case 0x0: gen_helper_ldl_phys(cpu_ir[ra], cpu_env, addr); break; case 0x1: gen_helper_ldq_phys(cpu_ir[ra], cpu_env, addr); break; case 0x2: gen_helper_ldl_l_phys(cpu_ir[ra], cpu_env, addr); break; case 0x3: gen_helper_ldq_l_phys(cpu_ir[ra], cpu_env, addr); break; case 0x4: goto invalid_opc; case 0x5: goto invalid_opc; break; case 0x6: goto invalid_opc; case 0x7: goto invalid_opc; case 0x8: goto invalid_opc; case 0x9: goto invalid_opc; case 0xA: tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_KERNEL_IDX, MO_LESL); break; case 0xB: tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_KERNEL_IDX, MO_LEQ); break; case 0xC: goto invalid_opc; case 0xD: goto invalid_opc; case 0xE: tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_USER_IDX, MO_LESL); break; case 0xF: tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_USER_IDX, MO_LEQ); break; } tcg_temp_free(addr); break; } #endif goto invalid_opc; case 0x1C: switch (fn7) { case 0x00: if ((ctx->tb->flags & TB_FLAGS_AMASK_BWX) == 0) { goto invalid_opc; } if (likely(rc != 31)) { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], (int64_t)((int8_t)lit)); } else { tcg_gen_ext8s_i64(cpu_ir[rc], cpu_ir[rb]); } } break; case 0x01: if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) { if (likely(rc != 31)) { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], (int64_t)((int16_t)lit)); } else { tcg_gen_ext16s_i64(cpu_ir[rc], cpu_ir[rb]); } } break; } goto invalid_opc; case 0x30: if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) { if (likely(rc != 31)) { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], ctpop64(lit)); } else { gen_helper_ctpop(cpu_ir[rc], cpu_ir[rb]); } } break; } goto invalid_opc; case 0x31: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_perr(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x32: if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) { if (likely(rc != 31)) { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], clz64(lit)); } else { gen_helper_ctlz(cpu_ir[rc], cpu_ir[rb]); } } break; } goto invalid_opc; case 0x33: if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) { if (likely(rc != 31)) { if (islit) { tcg_gen_movi_i64(cpu_ir[rc], ctz64(lit)); } else { gen_helper_cttz(cpu_ir[rc], cpu_ir[rb]); } } break; } goto invalid_opc; case 0x34: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { if (real_islit || ra != 31) { goto invalid_opc; } gen_unpkbw(rb, rc); break; } goto invalid_opc; case 0x35: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { if (real_islit || ra != 31) { goto invalid_opc; } gen_unpkbl(rb, rc); break; } goto invalid_opc; case 0x36: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { if (real_islit || ra != 31) { goto invalid_opc; } gen_pkwb(rb, rc); break; } goto invalid_opc; case 0x37: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { if (real_islit || ra != 31) { goto invalid_opc; } gen_pklb(rb, rc); break; } goto invalid_opc; case 0x38: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_minsb8(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x39: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_minsw4(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x3A: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_minub8(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x3B: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_minuw4(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x3C: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_maxub8(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x3D: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_maxuw4(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x3E: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_maxsb8(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x3F: if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) { gen_maxsw4(ra, rb, rc, islit, lit); break; } goto invalid_opc; case 0x70: if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) { goto invalid_opc; } if (likely(rc != 31)) { if (ra != 31) { tcg_gen_mov_i64(cpu_ir[rc], cpu_fir[ra]); } else { tcg_gen_movi_i64(cpu_ir[rc], 0); } } break; case 0x78: if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) { goto invalid_opc; } if (rc != 31) { TCGv_i32 tmp1 = tcg_temp_new_i32(); if (ra != 31) { gen_helper_s_to_memory(tmp1, cpu_fir[ra]); } else { TCGv tmp2 = tcg_const_i64(0); gen_helper_s_to_memory(tmp1, tmp2); tcg_temp_free(tmp2); } tcg_gen_ext_i32_i64(cpu_ir[rc], tmp1); tcg_temp_free_i32(tmp1); } break; default: goto invalid_opc; } break; case 0x1D: #ifndef CONFIG_USER_ONLY if (ctx->tb->flags & TB_FLAGS_PAL_MODE) { return gen_mtpr(ctx, rb, insn & 0xffff); } #endif goto invalid_opc; case 0x1E: #ifndef CONFIG_USER_ONLY if (ctx->tb->flags & TB_FLAGS_PAL_MODE) { if (rb == 31) { TCGv tmp = tcg_temp_new(); tcg_gen_ld_i64(tmp, cpu_env, offsetof(CPUAlphaState, exc_addr)); gen_helper_hw_ret(cpu_env, tmp); tcg_temp_free(tmp); } else { gen_helper_hw_ret(cpu_env, cpu_ir[rb]); } ret = EXIT_PC_UPDATED; break; } #endif goto invalid_opc; case 0x1F: #ifndef CONFIG_USER_ONLY if (ctx->tb->flags & TB_FLAGS_PAL_MODE) { TCGv addr, val; addr = tcg_temp_new(); if (rb != 31) { tcg_gen_addi_i64(addr, cpu_ir[rb], disp12); } else { tcg_gen_movi_i64(addr, disp12); } if (ra != 31) { val = cpu_ir[ra]; } else { val = tcg_temp_new(); tcg_gen_movi_i64(val, 0); } switch ((insn >> 12) & 0xF) { case 0x0: gen_helper_stl_phys(cpu_env, addr, val); break; case 0x1: gen_helper_stq_phys(cpu_env, addr, val); break; case 0x2: gen_helper_stl_c_phys(val, cpu_env, addr, val); break; case 0x3: gen_helper_stq_c_phys(val, cpu_env, addr, val); break; case 0x4: goto invalid_opc; case 0x5: goto invalid_opc; case 0x6: goto invalid_opc; case 0x7: goto invalid_opc; case 0x8: goto invalid_opc; case 0x9: goto invalid_opc; case 0xA: goto invalid_opc; case 0xB: goto invalid_opc; case 0xC: goto invalid_opc; case 0xD: goto invalid_opc; case 0xE: goto invalid_opc; case 0xF: goto invalid_opc; } if (ra == 31) { tcg_temp_free(val); } tcg_temp_free(addr); break; } #endif goto invalid_opc; case 0x20: gen_load_mem(ctx, &gen_qemu_ldf, ra, rb, disp16, 1, 0); break; case 0x21: gen_load_mem(ctx, &gen_qemu_ldg, ra, rb, disp16, 1, 0); break; case 0x22: gen_load_mem(ctx, &gen_qemu_lds, ra, rb, disp16, 1, 0); break; case 0x23: gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 1, 0); break; case 0x24: gen_store_mem(ctx, &gen_qemu_stf, ra, rb, disp16, 1, 0); break; case 0x25: gen_store_mem(ctx, &gen_qemu_stg, ra, rb, disp16, 1, 0); break; case 0x26: gen_store_mem(ctx, &gen_qemu_sts, ra, rb, disp16, 1, 0); break; case 0x27: gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 1, 0); break; case 0x28: gen_load_mem(ctx, &tcg_gen_qemu_ld32s, ra, rb, disp16, 0, 0); break; case 0x29: gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 0); break; case 0x2A: gen_load_mem(ctx, &gen_qemu_ldl_l, ra, rb, disp16, 0, 0); break; case 0x2B: gen_load_mem(ctx, &gen_qemu_ldq_l, ra, rb, disp16, 0, 0); break; case 0x2C: gen_store_mem(ctx, &tcg_gen_qemu_st32, ra, rb, disp16, 0, 0); break; case 0x2D: gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 0); break; case 0x2E: ret = gen_store_conditional(ctx, ra, rb, disp16, 0); break; case 0x2F: ret = gen_store_conditional(ctx, ra, rb, disp16, 1); break; case 0x30: ret = gen_bdirect(ctx, ra, disp21); break; case 0x31: ret = gen_fbcond(ctx, TCG_COND_EQ, ra, disp21); break; case 0x32: ret = gen_fbcond(ctx, TCG_COND_LT, ra, disp21); break; case 0x33: ret = gen_fbcond(ctx, TCG_COND_LE, ra, disp21); break; case 0x34: ret = gen_bdirect(ctx, ra, disp21); break; case 0x35: ret = gen_fbcond(ctx, TCG_COND_NE, ra, disp21); break; case 0x36: ret = gen_fbcond(ctx, TCG_COND_GE, ra, disp21); break; case 0x37: ret = gen_fbcond(ctx, TCG_COND_GT, ra, disp21); break; case 0x38: ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 1); break; case 0x39: ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 0); break; case 0x3A: ret = gen_bcond(ctx, TCG_COND_LT, ra, disp21, 0); break; case 0x3B: ret = gen_bcond(ctx, TCG_COND_LE, ra, disp21, 0); break; case 0x3C: ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 1); break; case 0x3D: ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 0); break; case 0x3E: ret = gen_bcond(ctx, TCG_COND_GE, ra, disp21, 0); break; case 0x3F: ret = gen_bcond(ctx, TCG_COND_GT, ra, disp21, 0); break; invalid_opc: ret = gen_invalid(ctx); break; } return ret; }[Succeeded / Failed / Skipped / Total] 563 / 54 / 356 / 973:  36%|      | 973/2690 [11:31:20<20:19:58, 42.63s/it][Succeeded / Failed / Skipped / Total] 563 / 54 / 356 / 973:  36%|      | 974/2690 [11:31:37<20:18:31, 42.61s/it][Succeeded / Failed / Skipped / Total] 564 / 54 / 356 / 974:  36%|      | 974/2690 [11:31:37<20:18:31, 42.61s/it][Succeeded / Failed / Skipped / Total] 564 / 54 / 356 / 974:  36%|      | 975/2690 [11:31:45<20:16:47, 42.57s/it]
--------------------------------------------- Result 974 ---------------------------------------------
[[0 (8%)]] --> [[0 (98%)]] --> Socre: 0.9767979383468628

[[[[Adv]]]]: inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, long dstWidth, const uint8_t *src1, const uint8_t *src2, int srcW, int xInc, int flags, const int16_t *hChrFilter, const int16_t *[[hChrFilterPos]], int hChrFilterSize, int srcFormat, uint8_t *formatConvBuffer, uint32_t *pal) { int32_t av_unused *mmx2FilterPos = c->chrMmx2FilterPos; int16_t av_unused *mmx2Filter = c->chrMmx2Filter; int av_unused canMMX2BeUsed = c->canMMX2BeUsed; void av_unused *mmx2FilterCode= c->chrMmx2FilterCode; if (isGray(srcFormat) || srcFormat==PIX_FMT_MONOBLACK || srcFormat==PIX_FMT_MONOWHITE) return; if (srcFormat==PIX_FMT_RGB32_1 || srcFormat==PIX_FMT_BGR32_1) { src1 += ALT32_CORR; src2 += ALT32_CORR; } if (srcFormat==PIX_FMT_RGB48LE) { src1++; src2++; } if (c->hcscale_internal) { c->hcscale_internal(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal); src1= formatConvBuffer; src2= formatConvBuffer+VOFW; } #if COMPILE_TEMPLATE_MMX if (!(flags&SWS_FAST_BILINEAR) || (!canMMX2BeUsed)) #else if (!(flags&SWS_FAST_BILINEAR)) #endif { c->hScale(dst , dstWidth, src1, srcW, xInc, hChrFilter, [[hChrFilterPos]], hChrFilterSize); c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, [[hChrFilterPos]], hChrFilterSize); } else { #if ARCH_X86 && CONFIG_GPL #if COMPILE_TEMPLATE_MMX2 int i; #if defined(PIC) DECLARE_ALIGNED(8, uint64_t, ebxsave); #endif if (canMMX2BeUsed) { __asm__ volatile( #if defined(PIC) "mov %%"REG_b", %6 \n\t" #endif "pxor %%mm7, %%mm7 \n\t" "mov %0, %%"REG_c" \n\t" "mov %1, %%"REG_D" \n\t" "mov %2, %%"REG_d" \n\t" "mov %3, %%"REG_b" \n\t" "xor %%"REG_a", %%"REG_a" \n\t" PREFETCH" (%%"REG_c") \n\t" PREFETCH" 32(%%"REG_c") \n\t" PREFETCH" 64(%%"REG_c") \n\t" CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE "xor %%"REG_a", %%"REG_a" \n\t" "mov %5, %%"REG_c" \n\t" "mov %1, %%"REG_D" \n\t" "add $"AV_STRINGIFY(VOF)", %%"REG_D" \n\t" PREFETCH" (%%"REG_c") \n\t" PREFETCH" 32(%%"REG_c") \n\t" PREFETCH" 64(%%"REG_c") \n\t" CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE #if defined(PIC) "mov %6, %%"REG_b" \n\t" #endif :: "m" (src1), "m" (dst), "m" (mmx2Filter), "m" (mmx2FilterPos), "m" (mmx2FilterCode), "m" (src2) #if defined(PIC) ,"m" (ebxsave) #endif : "%"REG_a, "%"REG_c, "%"REG_d, "%"REG_S, "%"REG_D #if !defined(PIC) ,"%"REG_b #endif ); for (i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) { dst[i] = src1[srcW-1]*128; dst[i+VOFW] = src2[srcW-1]*128; } } else { #endif x86_reg xInc_shr16 = (x86_reg) (xInc >> 16); uint16_t xInc_mask = xInc & 0xffff; __asm__ volatile( "xor %%"REG_a", %%"REG_a" \n\t" "xor %%"REG_d", %%"REG_d" \n\t" "xorl %%ecx, %%ecx \n\t" ASMALIGN(4) "1: \n\t" "mov %0, %%"REG_S" \n\t" "movzbl (%%"REG_S", %%"REG_d"), %%edi \n\t" "movzbl 1(%%"REG_S", %%"REG_d"), %%esi \n\t" FAST_BILINEAR_X86 "movw %%si, (%%"REG_D", %%"REG_a", 2) \n\t" "movzbl (%5, %%"REG_d"), %%edi \n\t" "movzbl 1(%5, %%"REG_d"), %%esi \n\t" FAST_BILINEAR_X86 "movw %%si, "AV_STRINGIFY(VOF)"(%%"REG_D", %%"REG_a", 2) \n\t" "addw %4, %%cx \n\t" "adc %3, %%"REG_d" \n\t" "add $1, %%"REG_a" \n\t" "cmp %2, %%"REG_a" \n\t" " jb 1b \n\t" #if ARCH_X86_64 && ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)) :: "m" (src1), "m" (dst), "g" (dstWidth), "m" (xInc_shr16), "m" (xInc_mask), #else :: "m" (src1), "m" (dst), "m" (dstWidth), "m" (xInc_shr16), "m" (xInc_mask), #endif "r" (src2) : "%"REG_a, "%"REG_d, "%ecx", "%"REG_D, "%esi" ); #if COMPILE_TEMPLATE_MMX2 } #endif #else c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc); #endif } if(c->srcRange != c->dstRange && !(isRGB(c->dstFormat) || isBGR(c->dstFormat))) { int i; if(c->srcRange) { for (i=0; i<dstWidth; i++) { dst[i ]= (dst[i ]*1799 + 4081085)>>11; dst[i+VOFW]= (dst[i+VOFW]*1799 + 4081085)>>11; } } else { for (i=0; i<dstWidth; i++) { dst[i ]= (FFMIN(dst[i ],30775)*4663 - 9289992)>>12; dst[i+VOFW]= (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; } } } }

[[[[Adv]]]]: inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, long dstWidth, const uint8_t *src1, const uint8_t *src2, int srcW, int xInc, int flags, const int16_t *hChrFilter, const int16_t *[[f]], int hChrFilterSize, int srcFormat, uint8_t *formatConvBuffer, uint32_t *pal) { int32_t av_unused *mmx2FilterPos = c->chrMmx2FilterPos; int16_t av_unused *mmx2Filter = c->chrMmx2Filter; int av_unused canMMX2BeUsed = c->canMMX2BeUsed; void av_unused *mmx2FilterCode= c->chrMmx2FilterCode; if (isGray(srcFormat) || srcFormat==PIX_FMT_MONOBLACK || srcFormat==PIX_FMT_MONOWHITE) return; if (srcFormat==PIX_FMT_RGB32_1 || srcFormat==PIX_FMT_BGR32_1) { src1 += ALT32_CORR; src2 += ALT32_CORR; } if (srcFormat==PIX_FMT_RGB48LE) { src1++; src2++; } if (c->hcscale_internal) { c->hcscale_internal(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal); src1= formatConvBuffer; src2= formatConvBuffer+VOFW; } #if COMPILE_TEMPLATE_MMX if (!(flags&SWS_FAST_BILINEAR) || (!canMMX2BeUsed)) #else if (!(flags&SWS_FAST_BILINEAR)) #endif { c->hScale(dst , dstWidth, src1, srcW, xInc, hChrFilter, [[f]], hChrFilterSize); c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, [[f]], hChrFilterSize); } else { #if ARCH_X86 && CONFIG_GPL #if COMPILE_TEMPLATE_MMX2 int i; #if defined(PIC) DECLARE_ALIGNED(8, uint64_t, ebxsave); #endif if (canMMX2BeUsed) { __asm__ volatile( #if defined(PIC) "mov %%"REG_b", %6 \n\t" #endif "pxor %%mm7, %%mm7 \n\t" "mov %0, %%"REG_c" \n\t" "mov %1, %%"REG_D" \n\t" "mov %2, %%"REG_d" \n\t" "mov %3, %%"REG_b" \n\t" "xor %%"REG_a", %%"REG_a" \n\t" PREFETCH" (%%"REG_c") \n\t" PREFETCH" 32(%%"REG_c") \n\t" PREFETCH" 64(%%"REG_c") \n\t" CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE "xor %%"REG_a", %%"REG_a" \n\t" "mov %5, %%"REG_c" \n\t" "mov %1, %%"REG_D" \n\t" "add $"AV_STRINGIFY(VOF)", %%"REG_D" \n\t" PREFETCH" (%%"REG_c") \n\t" PREFETCH" 32(%%"REG_c") \n\t" PREFETCH" 64(%%"REG_c") \n\t" CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE #if defined(PIC) "mov %6, %%"REG_b" \n\t" #endif :: "m" (src1), "m" (dst), "m" (mmx2Filter), "m" (mmx2FilterPos), "m" (mmx2FilterCode), "m" (src2) #if defined(PIC) ,"m" (ebxsave) #endif : "%"REG_a, "%"REG_c, "%"REG_d, "%"REG_S, "%"REG_D #if !defined(PIC) ,"%"REG_b #endif ); for (i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) { dst[i] = src1[srcW-1]*128; dst[i+VOFW] = src2[srcW-1]*128; } } else { #endif x86_reg xInc_shr16 = (x86_reg) (xInc >> 16); uint16_t xInc_mask = xInc & 0xffff; __asm__ volatile( "xor %%"REG_a", %%"REG_a" \n\t" "xor %%"REG_d", %%"REG_d" \n\t" "xorl %%ecx, %%ecx \n\t" ASMALIGN(4) "1: \n\t" "mov %0, %%"REG_S" \n\t" "movzbl (%%"REG_S", %%"REG_d"), %%edi \n\t" "movzbl 1(%%"REG_S", %%"REG_d"), %%esi \n\t" FAST_BILINEAR_X86 "movw %%si, (%%"REG_D", %%"REG_a", 2) \n\t" "movzbl (%5, %%"REG_d"), %%edi \n\t" "movzbl 1(%5, %%"REG_d"), %%esi \n\t" FAST_BILINEAR_X86 "movw %%si, "AV_STRINGIFY(VOF)"(%%"REG_D", %%"REG_a", 2) \n\t" "addw %4, %%cx \n\t" "adc %3, %%"REG_d" \n\t" "add $1, %%"REG_a" \n\t" "cmp %2, %%"REG_a" \n\t" " jb 1b \n\t" #if ARCH_X86_64 && ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)) :: "m" (src1), "m" (dst), "g" (dstWidth), "m" (xInc_shr16), "m" (xInc_mask), #else :: "m" (src1), "m" (dst), "m" (dstWidth), "m" (xInc_shr16), "m" (xInc_mask), #endif "r" (src2) : "%"REG_a, "%"REG_d, "%ecx", "%"REG_D, "%esi" ); #if COMPILE_TEMPLATE_MMX2 } #endif #else c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc); #endif } if(c->srcRange != c->dstRange && !(isRGB(c->dstFormat) || isBGR(c->dstFormat))) { int i; if(c->srcRange) { for (i=0; i<dstWidth; i++) { dst[i ]= (dst[i ]*1799 + 4081085)>>11; dst[i+VOFW]= (dst[i+VOFW]*1799 + 4081085)>>11; } } else { for (i=0; i<dstWidth; i++) { dst[i ]= (FFMIN(dst[i ],30775)*4663 - 9289992)>>12; dst[i+VOFW]= (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; } } } }
--------------------------------------------- Result 975 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 565 / 54 / 356 / 975:  36%|      | 975/2690 [11:31:45<20:16:47, 42.57s/it][Succeeded / Failed / Skipped / Total] 565 / 54 / 356 / 975:  36%|      | 976/2690 [11:31:47<20:14:53, 42.53s/it][Succeeded / Failed / Skipped / Total] 566 / 54 / 356 / 976:  36%|      | 976/2690 [11:31:47<20:14:53, 42.53s/it][Succeeded / Failed / Skipped / Total] 566 / 54 / 356 / 976:  36%|      | 977/2690 [11:35:41<20:19:46, 42.72s/it][Succeeded / Failed / Skipped / Total] 567 / 54 / 356 / 977:  36%|      | 977/2690 [11:35:41<20:19:46, 42.72s/it][Succeeded / Failed / Skipped / Total] 567 / 54 / 356 / 977:  36%|      | 978/2690 [11:35:53<20:18:10, 42.69s/it][Succeeded / Failed / Skipped / Total] 568 / 54 / 356 / 978:  36%|      | 978/2690 [11:35:53<20:18:10, 42.69s/it][Succeeded / Failed / Skipped / Total] 568 / 54 / 356 / 978:  36%|      | 979/2690 [11:35:54<20:16:14, 42.65s/it][Succeeded / Failed / Skipped / Total] 568 / 54 / 357 / 979:  36%|      | 979/2690 [11:35:54<20:16:14, 42.65s/it][Succeeded / Failed / Skipped / Total] 568 / 54 / 357 / 979:  36%|      | 980/2690 [11:36:13<20:14:50, 42.63s/it][Succeeded / Failed / Skipped / Total] 569 / 54 / 357 / 980:  36%|      | 980/2690 [11:36:13<20:14:50, 42.63s/it][Succeeded / Failed / Skipped / Total] 569 / 54 / 357 / 980:  36%|      | 981/2690 [11:36:13<20:12:54, 42.58s/it][Succeeded / Failed / Skipped / Total] 569 / 54 / 358 / 981:  36%|      | 981/2690 [11:36:13<20:12:54, 42.58s/it][Succeeded / Failed / Skipped / Total] 569 / 54 / 358 / 981:  37%|      | 982/2690 [11:36:14<20:10:58, 42.54s/it][[0 (1%)]] --> [[0 (72%)]] --> Socre: 0.7199739217758179

[[[[Adv]]]]: float32 HELPER(ucf64_abss)(float32 [[a]]) { return float32_abs([[a]]); }

[[[[Adv]]]]: float32 HELPER(ucf64_abss)(float32 [[]]) { return float32_abs([[]]); }
--------------------------------------------- Result 976 ---------------------------------------------
[[0 (25%)]] --> [[0 (84%)]] --> Socre: 0.8384827971458435

[[[[Adv]]]]: int qemu_thread_equal(QemuThread *thread1, QemuThread *[[thread2]]) { return pthread_equal(thread1->thread, [[thread2]]->thread); }

[[[[Adv]]]]: int qemu_thread_equal(QemuThread *thread1, QemuThread *[[cervantes]]) { return pthread_equal(thread1->thread, [[cervantes]]->thread); }
--------------------------------------------- Result 977 ---------------------------------------------
[[0 (98%)]] --> [[0 (21%)]] --> Socre: 0.7892947196960449

[[[[Adv]]]]: static int parse_MP4SLDescrTag(MP4DescrParseContext *d, int64_t off, int len) { Mp4Descr *[[descr]] = d->active_descr; int [[predefined]]; if (![[descr]]) return -1; [[predefined]] = avio_r8(&d->pb); if (![[predefined]]) { int lengths; int flags = avio_r8(&d->pb); [[descr]]->sl.use_au_start = !!(flags & 0x80); [[descr]]->sl.use_au_end = !!(flags & 0x40); [[descr]]->sl.use_rand_acc_pt = !!(flags & 0x20); [[descr]]->sl.use_padding = !!(flags & 0x08); [[descr]]->sl.use_timestamps = !!(flags & 0x04); [[descr]]->sl.use_idle = !!(flags & 0x02); [[descr]]->sl.timestamp_res = avio_rb32(&d->pb); avio_rb32(&d->pb); [[descr]]->sl.timestamp_len = avio_r8(&d->pb); [[descr]]->sl.ocr_len = avio_r8(&d->pb); [[descr]]->sl.au_len = avio_r8(&d->pb); [[descr]]->sl.inst_bitrate_len = avio_r8(&d->pb); lengths = avio_rb16(&d->pb); [[descr]]->sl.degr_prior_len = lengths >> 12; [[descr]]->sl.au_seq_num_len = (lengths >> 7) & 0x1f; [[descr]]->sl.packet_seq_num_len = (lengths >> 2) & 0x1f; } else { avpriv_report_missing_feature(d->s, "Predefined SLConfigDescriptor"); return 0;

[[[[Adv]]]]: static int parse_MP4SLDescrTag(MP4DescrParseContext *d, int64_t off, int len) { Mp4Descr *[[activated]] = d->active_descr; int [[crpuscule]]; if (![[activated]]) return -1; [[crpuscule]] = avio_r8(&d->pb); if (![[crpuscule]]) { int lengths; int flags = avio_r8(&d->pb); [[activated]]->sl.use_au_start = !!(flags & 0x80); [[activated]]->sl.use_au_end = !!(flags & 0x40); [[activated]]->sl.use_rand_acc_pt = !!(flags & 0x20); [[activated]]->sl.use_padding = !!(flags & 0x08); [[activated]]->sl.use_timestamps = !!(flags & 0x04); [[activated]]->sl.use_idle = !!(flags & 0x02); [[activated]]->sl.timestamp_res = avio_rb32(&d->pb); avio_rb32(&d->pb); [[activated]]->sl.timestamp_len = avio_r8(&d->pb); [[activated]]->sl.ocr_len = avio_r8(&d->pb); [[activated]]->sl.au_len = avio_r8(&d->pb); [[activated]]->sl.inst_bitrate_len = avio_r8(&d->pb); lengths = avio_rb16(&d->pb); [[activated]]->sl.degr_prior_len = lengths >> 12; [[activated]]->sl.au_seq_num_len = (lengths >> 7) & 0x1f; [[activated]]->sl.packet_seq_num_len = (lengths >> 2) & 0x1f; } else { avpriv_report_missing_feature(d->s, "Predefined SLConfigDescriptor"); return 0;
--------------------------------------------- Result 978 ---------------------------------------------
[[0 (7%)]] --> [[0 (56%)]] --> Socre: 0.5593727231025696

[[[[Adv]]]]: static inline void gen_outs(DisasContext *s, TCGMemOp [[ot]]) { if (use_icount) gen_io_start(); gen_string_movl_A0_ESI(s); gen_op_ld_v(s, [[ot]], cpu_T[0], cpu_A0); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]); tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]); gen_helper_out_func([[ot]], cpu_tmp2_i32, cpu_tmp3_i32); gen_op_movl_T0_Dshift([[ot]]); gen_op_add_reg_T0(s->aflag, R_ESI); if (use_icount) gen_io_end(); }

[[[[Adv]]]]: static inline void gen_outs(DisasContext *s, TCGMemOp [[oilers]]) { if (use_icount) gen_io_start(); gen_string_movl_A0_ESI(s); gen_op_ld_v(s, [[oilers]], cpu_T[0], cpu_A0); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]); tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]); gen_helper_out_func([[oilers]], cpu_tmp2_i32, cpu_tmp3_i32); gen_op_movl_T0_Dshift([[oilers]]); gen_op_add_reg_T0(s->aflag, R_ESI); if (use_icount) gen_io_end(); }
--------------------------------------------- Result 979 ---------------------------------------------
[[0 (83%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void test_fcmp(double a, double b) { long eflags, fpus; fpu_clear_exceptions(); asm("fcom %2\n" "fstsw %%ax\n" : "=a" (fpus) : "t" (a), "u" (b)); printf("fcom(%f %f)=%04lx \n", a, b, fpus & (0x4500 | FPUS_EMASK)); fpu_clear_exceptions(); asm("fucom %2\n" "fstsw %%ax\n" : "=a" (fpus) : "t" (a), "u" (b)); printf("fucom(%f %f)=%04lx\n", a, b, fpus & (0x4500 | FPUS_EMASK)); if (TEST_FCOMI) { fpu_clear_exceptions(); asm("fcomi %3, %2\n" "fstsw %%ax\n" "pushf\n" "pop %0\n" : "=r" (eflags), "=a" (fpus) : "t" (a), "u" (b)); printf("fcomi(%f %f)=%04lx %02lx\n", a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C)); fpu_clear_exceptions(); asm("fucomi %3, %2\n" "fstsw %%ax\n" "pushf\n" "pop %0\n" : "=r" (eflags), "=a" (fpus) : "t" (a), "u" (b)); printf("fucomi(%f %f)=%04lx %02lx\n", a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C)); } fpu_clear_exceptions(); asm volatile("fxam\n" "fstsw %%ax\n" : "=a" (fpus) : "t" (a)); printf("fxam(%f)=%04lx\n", a, fpus & 0x4700); fpu_clear_exceptions(); }
--------------------------------------------- Result 980 ---------------------------------------------
[[0 (4%)]] --> [[0 (77%)]] --> Socre: 0.7745198607444763

[[[[Adv]]]]: struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory, target_phys_addr_t base, qemu_irq *[[irq]], qemu_irq dma, omap_clk clk) { struct omap_uwire_s *[[s]] = (struct omap_uwire_s *) g_malloc0(sizeof(struct omap_uwire_s)); [[s]]->txirq = [[irq]][0]; [[s]]->rxirq = [[irq]][1]; [[s]]->txdrq = dma; omap_uwire_reset([[s]]); memory_region_init_io(&[[s]]->iomem, &omap_uwire_ops, [[s]], "omap-uwire", 0x800); memory_region_add_subregion(system_memory, base, &[[s]]->iomem); return [[s]]; }

[[[[Adv]]]]: struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory, target_phys_addr_t base, qemu_irq *[[its]], qemu_irq dma, omap_clk clk) { struct omap_uwire_s *[[pp]] = (struct omap_uwire_s *) g_malloc0(sizeof(struct omap_uwire_s)); [[pp]]->txirq = [[its]][0]; [[pp]]->rxirq = [[its]][1]; [[pp]]->txdrq = dma; omap_uwire_reset([[pp]]); memory_region_init_io(&[[pp]]->iomem, &omap_uwire_ops, [[pp]], "omap-uwire", 0x800); memory_region_add_subregion(system_memory, base, &[[pp]]->iomem); return [[pp]]; }
--------------------------------------------- Result 981 ---------------------------------------------
[[0 (10%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher, const uint8_t *key, size_t nkey, Error **errp) { QCryptoCipherBuiltin *ctxt; if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) { error_setg(errp, "Unsupported cipher mode %d", cipher->mode); return -1; } ctxt = g_new0(QCryptoCipherBuiltin, 1); ctxt->state.desrfb.key = g_new0(uint8_t, nkey); memcpy(ctxt->state.desrfb.key, key, nkey); ctxt->state.desrfb.nkey = nkey; ctxt->free = qcrypto_cipher_free_des_rfb; ctxt->setiv = qcrypto_cipher_setiv_des_rfb; ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb; ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb; cipher->opaque = ctxt; return 0; }
--------------------------------------------- Result 982 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 569 / 54 / 359 / 982:  37%|      | 982/2690 [11:36:14<20:10:58, 42.54s/it][Succeeded / Failed / Skipped / Total] 569 / 54 / 359 / 982:  37%|      | 983/2690 [11:36:14<20:09:02, 42.50s/it][Succeeded / Failed / Skipped / Total] 569 / 54 / 360 / 983:  37%|      | 983/2690 [11:36:14<20:09:02, 42.50s/it][Succeeded / Failed / Skipped / Total] 569 / 54 / 360 / 983:  37%|      | 984/2690 [11:36:55<20:08:17, 42.50s/it][Succeeded / Failed / Skipped / Total] 570 / 54 / 360 / 984:  37%|      | 984/2690 [11:36:55<20:08:17, 42.50s/it][Succeeded / Failed / Skipped / Total] 570 / 54 / 360 / 984:  37%|      | 985/2690 [11:36:56<20:06:22, 42.45s/it][Succeeded / Failed / Skipped / Total] 570 / 54 / 361 / 985:  37%|      | 985/2690 [11:36:56<20:06:22, 42.45s/it][Succeeded / Failed / Skipped / Total] 570 / 54 / 361 / 985:  37%|      | 986/2690 [11:37:01<20:04:34, 42.41s/it][Succeeded / Failed / Skipped / Total] 571 / 54 / 361 / 986:  37%|      | 986/2690 [11:37:01<20:04:34, 42.41s/it][Succeeded / Failed / Skipped / Total] 571 / 54 / 361 / 986:  37%|      | 987/2690 [11:37:03<20:02:43, 42.37s/it][[0 (95%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int virtio_ccw_handle_set_vq(SubchDev *sch, CCW1 ccw, bool check_len, bool is_legacy) { int ret; VqInfoBlock info; VqInfoBlockLegacy linfo; size_t info_len = is_legacy ? sizeof(linfo) : sizeof(info); if (check_len) { if (ccw.count != info_len) { return -EINVAL; } } else if (ccw.count < info_len) { return -EINVAL; } if (!ccw.cda) { return -EFAULT; } if (is_legacy) { linfo.queue = address_space_ldq_be(&address_space_memory, ccw.cda, MEMTXATTRS_UNSPECIFIED, NULL); linfo.align = address_space_ldl_be(&address_space_memory, ccw.cda + sizeof(linfo.queue), MEMTXATTRS_UNSPECIFIED, NULL); linfo.index = address_space_lduw_be(&address_space_memory, ccw.cda + sizeof(linfo.queue) + sizeof(linfo.align), MEMTXATTRS_UNSPECIFIED, NULL); linfo.num = address_space_lduw_be(&address_space_memory, ccw.cda + sizeof(linfo.queue) + sizeof(linfo.align) + sizeof(linfo.index), MEMTXATTRS_UNSPECIFIED, NULL); ret = virtio_ccw_set_vqs(sch, NULL, &linfo); } else { info.desc = address_space_ldq_be(&address_space_memory, ccw.cda, MEMTXATTRS_UNSPECIFIED, NULL); info.index = address_space_lduw_be(&address_space_memory, ccw.cda + sizeof(info.desc) + sizeof(info.res0), MEMTXATTRS_UNSPECIFIED, NULL); info.num = address_space_lduw_be(&address_space_memory, ccw.cda + sizeof(info.desc) + sizeof(info.res0) + sizeof(info.index), MEMTXATTRS_UNSPECIFIED, NULL); info.avail = address_space_ldq_be(&address_space_memory, ccw.cda + sizeof(info.desc) + sizeof(info.res0) + sizeof(info.index) + sizeof(info.num), MEMTXATTRS_UNSPECIFIED, NULL); info.used = address_space_ldq_be(&address_space_memory, ccw.cda + sizeof(info.desc) + sizeof(info.res0) + sizeof(info.index) + sizeof(info.num) + sizeof(info.avail), MEMTXATTRS_UNSPECIFIED, NULL); ret = virtio_ccw_set_vqs(sch, &info, NULL); } sch->curr_status.scsw.count = 0; return ret; }
--------------------------------------------- Result 983 ---------------------------------------------
[[0 (80%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void vnc_client_cache_addr(VncState *client) { Error *err = NULL; client->info = g_malloc0(sizeof(*client->info)); client->info->base = g_malloc0(sizeof(*client->info->base)); vnc_init_basic_info_from_remote_addr(client->csock, client->info->base, &err); if (err) { qapi_free_VncClientInfo(client->info); client->info = NULL; error_free(err); } }
--------------------------------------------- Result 984 ---------------------------------------------
[[0 (17%)]] --> [[0 (69%)]] --> Socre: 0.692033052444458

[[[[Adv]]]]: int kvm_irqchip_add_irqfd(KVMState *s, int [[fd]], int virq) { return kvm_irqchip_assign_irqfd(s, [[fd]], virq, "True" == "True"); }

[[[[Adv]]]]: int kvm_irqchip_add_irqfd(KVMState *s, int [[realm]], int virq) { return kvm_irqchip_assign_irqfd(s, [[realm]], virq, "True" == "True"); }
--------------------------------------------- Result 985 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque) { CharDriverState *chr = opaque; NetCharDriver *s = chr->opaque; gsize bytes_read = 0; GIOStatus status; if (s->max_size == 0) return "False" != "False"; status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf), &bytes_read, NULL); s->bufcnt = bytes_read; s->bufptr = s->bufcnt; if (status != G_IO_STATUS_NORMAL) { return "False" != "False"; } s->bufptr = 0; while (s->max_size > 0 && s->bufptr < s->bufcnt) { qemu_chr_be_write(chr, &s->buf[s->bufptr], 1); s->bufptr++; s->max_size = qemu_chr_be_can_write(chr); } return "True" == "True"; }
--------------------------------------------- Result 986 ---------------------------------------------
[[0 (73%)]] --> [[0 (40%)]] --> Socre: 0.5955850481987

[[[[Adv]]]]: PCIBus *pci_prep_init(qemu_irq *[[pic]]) { PREPPCIState *s; PCIDevice *[[d]]; int PPC_io_memory; s = qemu_mallocz(sizeof(PREPPCIState)); s->bus = pci_register_bus(prep_set_irq, prep_map_irq, [[pic]], 0, 2); register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s); register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s); register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s); register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s); register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s); register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s); register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s); register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s); PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read, PPC_PCIIO_write, s); cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory); [[d]] = pci_register_device(s->bus, "PREP Host Bridge - Motorola Raven", sizeof(PCIDevice), 0, NULL, NULL); [[d]]->config[0x00] = 0x57; [[d]]->config[0x01] = 0x10; [[d]]->config[0x02] = 0x01; [[d]]->config[0x03] = 0x48; [[d]]->config[0x08] = 0x00; [[d]]->config[0x0A] = 0x00; [[d]]->config[0x0B] = 0x06; [[d]]->config[0x0C] = 0x08; [[d]]->config[0x0D] = 0x10; [[d]]->config[0x0E] = 0x00; [[d]]->config[0x34] = 0x00; return s->bus; }

[[[[Adv]]]]: PCIBus *pci_prep_init(qemu_irq *[[busy]]) { PREPPCIState *s; PCIDevice *[[quattro]]; int PPC_io_memory; s = qemu_mallocz(sizeof(PREPPCIState)); s->bus = pci_register_bus(prep_set_irq, prep_map_irq, [[busy]], 0, 2); register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s); register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s); register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s); register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s); register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s); register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s); register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s); register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s); PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read, PPC_PCIIO_write, s); cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory); [[quattro]] = pci_register_device(s->bus, "PREP Host Bridge - Motorola Raven", sizeof(PCIDevice), 0, NULL, NULL); [[quattro]]->config[0x00] = 0x57; [[quattro]]->config[0x01] = 0x10; [[quattro]]->config[0x02] = 0x01; [[quattro]]->config[0x03] = 0x48; [[quattro]]->config[0x08] = 0x00; [[quattro]]->config[0x0A] = 0x00; [[quattro]]->config[0x0B] = 0x06; [[quattro]]->config[0x0C] = 0x08; [[quattro]]->config[0x0D] = 0x10; [[quattro]]->config[0x0E] = 0x00; [[quattro]]->config[0x34] = 0x00; return s->bus; }
--------------------------------------------- Result 987 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 572 / 54 / 361 / 987:  37%|      | 987/2690 [11:37:03<20:02:43, 42.37s/it][Succeeded / Failed / Skipped / Total] 572 / 54 / 361 / 987:  37%|      | 988/2690 [11:37:03<20:00:48, 42.33s/it][Succeeded / Failed / Skipped / Total] 572 / 54 / 362 / 988:  37%|      | 988/2690 [11:37:03<20:00:48, 42.33s/it][Succeeded / Failed / Skipped / Total] 572 / 54 / 362 / 988:  37%|      | 989/2690 [11:37:04<19:58:54, 42.29s/it][Succeeded / Failed / Skipped / Total] 572 / 54 / 363 / 989:  37%|      | 989/2690 [11:37:04<19:58:54, 42.29s/it][Succeeded / Failed / Skipped / Total] 572 / 54 / 363 / 989:  37%|      | 990/2690 [11:37:55<19:58:26, 42.30s/it][Succeeded / Failed / Skipped / Total] 573 / 54 / 363 / 990:  37%|      | 990/2690 [11:37:55<19:58:26, 42.30s/it][Succeeded / Failed / Skipped / Total] 573 / 54 / 363 / 990:  37%|      | 991/2690 [11:38:28<19:57:29, 42.29s/it][[0 (93%)]] --> [[0 (31%)]] --> Socre: 0.6891505718231201

[[[[Adv]]]]: void tlb_set_page_with_attrs(CPUState *[[cpu]], target_ulong vaddr, hwaddr paddr, MemTxAttrs attrs, int prot, int mmu_idx, target_ulong size) { CPUArchState *env = [[cpu]]->env_ptr; MemoryRegionSection *section; unsigned int index; target_ulong address; target_ulong code_address; uintptr_t addend; CPUTLBEntry *[[te]]; hwaddr iotlb, xlat, sz; unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE; int asidx = cpu_asidx_from_attrs([[cpu]], attrs); assert_cpu_is_self([[cpu]]); assert(size >= TARGET_PAGE_SIZE); if (size != TARGET_PAGE_SIZE) { tlb_add_large_page(env, vaddr, size); } sz = size; section = address_space_translate_for_iotlb([[cpu]], asidx, paddr, &xlat, &sz); assert(sz >= TARGET_PAGE_SIZE); tlb_debug("vaddr=" TARGET_FMT_lx " paddr=0x" TARGET_FMT_plx " prot=%x idx=%d\n", vaddr, paddr, prot, mmu_idx); address = vaddr; if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) { address |= TLB_MMIO; addend = 0; } else { addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat; } code_address = address; iotlb = memory_region_section_get_iotlb([[cpu]], section, vaddr, paddr, xlat, prot, &address); index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1); [[te]] = &env->tlb_table[mmu_idx][index]; env->tlb_v_table[mmu_idx][vidx] = *[[te]]; env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index]; env->iotlb[mmu_idx][index].addr = iotlb - vaddr; env->iotlb[mmu_idx][index].attrs = attrs; [[te]]->addend = addend - vaddr; if (prot & PAGE_READ) { [[te]]->addr_read = address; } else { [[te]]->addr_read = -1; } if (prot & PAGE_EXEC) { [[te]]->addr_code = code_address; } else { [[te]]->addr_code = -1; } if (prot & PAGE_WRITE) { if ((memory_region_is_ram(section->mr) && section->readonly) || memory_region_is_romd(section->mr)) { [[te]]->addr_write = address | TLB_MMIO; } else if (memory_region_is_ram(section->mr) && cpu_physical_memory_is_clean( memory_region_get_ram_addr(section->mr) + xlat)) { [[te]]->addr_write = address | TLB_NOTDIRTY; } else { [[te]]->addr_write = address; } } else { [[te]]->addr_write = -1; } }

[[[[Adv]]]]: void tlb_set_page_with_attrs(CPUState *[[megahertz]], target_ulong vaddr, hwaddr paddr, MemTxAttrs attrs, int prot, int mmu_idx, target_ulong size) { CPUArchState *env = [[megahertz]]->env_ptr; MemoryRegionSection *section; unsigned int index; target_ulong address; target_ulong code_address; uintptr_t addend; CPUTLBEntry *[[tus]]; hwaddr iotlb, xlat, sz; unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE; int asidx = cpu_asidx_from_attrs([[megahertz]], attrs); assert_cpu_is_self([[megahertz]]); assert(size >= TARGET_PAGE_SIZE); if (size != TARGET_PAGE_SIZE) { tlb_add_large_page(env, vaddr, size); } sz = size; section = address_space_translate_for_iotlb([[megahertz]], asidx, paddr, &xlat, &sz); assert(sz >= TARGET_PAGE_SIZE); tlb_debug("vaddr=" TARGET_FMT_lx " paddr=0x" TARGET_FMT_plx " prot=%x idx=%d\n", vaddr, paddr, prot, mmu_idx); address = vaddr; if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) { address |= TLB_MMIO; addend = 0; } else { addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat; } code_address = address; iotlb = memory_region_section_get_iotlb([[megahertz]], section, vaddr, paddr, xlat, prot, &address); index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1); [[tus]] = &env->tlb_table[mmu_idx][index]; env->tlb_v_table[mmu_idx][vidx] = *[[tus]]; env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index]; env->iotlb[mmu_idx][index].addr = iotlb - vaddr; env->iotlb[mmu_idx][index].attrs = attrs; [[tus]]->addend = addend - vaddr; if (prot & PAGE_READ) { [[tus]]->addr_read = address; } else { [[tus]]->addr_read = -1; } if (prot & PAGE_EXEC) { [[tus]]->addr_code = code_address; } else { [[tus]]->addr_code = -1; } if (prot & PAGE_WRITE) { if ((memory_region_is_ram(section->mr) && section->readonly) || memory_region_is_romd(section->mr)) { [[tus]]->addr_write = address | TLB_MMIO; } else if (memory_region_is_ram(section->mr) && cpu_physical_memory_is_clean( memory_region_get_ram_addr(section->mr) + xlat)) { [[tus]]->addr_write = address | TLB_NOTDIRTY; } else { [[tus]]->addr_write = address; } } else { [[tus]]->addr_write = -1; } }
--------------------------------------------- Result 988 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decode_sequence_header_adv(VC1Context *v, GetBitContext *gb) { v->res_rtm_flag = 1; v->level = get_bits(gb, 3); if(v->level >= 5) { av_log(v->s.avctx, AV_LOG_ERROR, "Reserved LEVEL %i\n",v->level); } v->chromaformat = get_bits(gb, 2); if (v->chromaformat != 1) { av_log(v->s.avctx, AV_LOG_ERROR, "Only 4:2:0 chroma format supported\n"); return -1; } v->frmrtq_postproc = get_bits(gb, 3); v->bitrtq_postproc = get_bits(gb, 5); v->postprocflag = get_bits(gb, 1); v->s.avctx->coded_width = (get_bits(gb, 12) + 1) << 1; v->s.avctx->coded_height = (get_bits(gb, 12) + 1) << 1; v->broadcast = get_bits1(gb); v->interlace = get_bits1(gb); if(v->interlace){ av_log(v->s.avctx, AV_LOG_ERROR, "Interlaced mode not supported (yet)\n"); return -1; } v->tfcntrflag = get_bits1(gb); v->finterpflag = get_bits1(gb); get_bits1(gb); v->psf = get_bits1(gb); if(v->psf) { av_log(v->s.avctx, AV_LOG_ERROR, "Progressive Segmented Frame mode: not supported (yet)\n"); return -1; } if(get_bits1(gb)) { int w, h, ar = 0; av_log(v->s.avctx, AV_LOG_INFO, "Display extended info:\n"); w = get_bits(gb, 14); h = get_bits(gb, 14); av_log(v->s.avctx, AV_LOG_INFO, "Display dimensions: %ix%i\n", w, h); if(get_bits1(gb)) ar = get_bits(gb, 4); if(ar == 15) { w = get_bits(gb, 8); h = get_bits(gb, 8); } if(get_bits1(gb)){ if(get_bits1(gb)) { get_bits(gb, 16); } else { get_bits(gb, 8); get_bits(gb, 4); } } if(get_bits1(gb)){ v->color_prim = get_bits(gb, 8); v->transfer_char = get_bits(gb, 8); v->matrix_coef = get_bits(gb, 8); } } v->hrd_param_flag = get_bits1(gb); if(v->hrd_param_flag) { int i; v->hrd_num_leaky_buckets = get_bits(gb, 5); get_bits(gb, 4); get_bits(gb, 4); for(i = 0; i < v->hrd_num_leaky_buckets; i++) { get_bits(gb, 16); get_bits(gb, 16); } } return 0; }
--------------------------------------------- Result 989 ---------------------------------------------
[[0 (10%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int page_unprotect(target_ulong address, uintptr_t pc, void *puc) { unsigned int prot; PageDesc *p; target_ulong host_start, host_end, addr; mmap_lock(); p = page_find(address >> TARGET_PAGE_BITS); if (!p) { mmap_unlock(); return 0; } if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) { host_start = address & qemu_host_page_mask; host_end = host_start + qemu_host_page_size; prot = 0; for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) { p = page_find(addr >> TARGET_PAGE_BITS); p->flags |= PAGE_WRITE; prot |= p->flags; tb_invalidate_phys_page(addr, pc, puc); #ifdef DEBUG_TB_CHECK tb_invalidate_check(addr); #endif } mprotect((void *)g2h(host_start), qemu_host_page_size, prot & PAGE_BITS); mmap_unlock(); return 1; } mmap_unlock(); return 0; }
--------------------------------------------- Result 990 ---------------------------------------------
[[0 (2%)]] --> [[0 (98%)]] --> Socre: 0.9835940003395081

[[[[Adv]]]]: static int raw_init_encoder(AVCodecContext *[[avctx]]) { [[avctx]]->coded_frame = (AVFrame *)[[avctx]]->priv_data; [[avctx]]->coded_frame->pict_type = FF_I_TYPE; [[avctx]]->coded_frame->key_frame = 1; [[avctx]]->codec_tag = findFourCC([[avctx]]->pix_fmt); return 0; }

[[[[Adv]]]]: static int raw_init_encoder(AVCodecContext *[[leo]]) { [[leo]]->coded_frame = (AVFrame *)[[leo]]->priv_data; [[leo]]->coded_frame->pict_type = FF_I_TYPE; [[leo]]->coded_frame->key_frame = 1; [[leo]]->codec_tag = findFourCC([[leo]]->pix_fmt); return 0; }
--------------------------------------------- Result 991 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 573 / 55 / 363 / 991:  37%|      | 991/2690 [11:38:28<19:57:29, 42.29s/it][Succeeded / Failed / Skipped / Total] 573 / 55 / 363 / 991:  37%|      | 992/2690 [11:38:54<19:56:19, 42.27s/it][Succeeded / Failed / Skipped / Total] 574 / 55 / 363 / 992:  37%|      | 992/2690 [11:38:54<19:56:19, 42.27s/it][Succeeded / Failed / Skipped / Total] 574 / 55 / 363 / 992:  37%|      | 993/2690 [11:39:00<19:54:34, 42.24s/it][Succeeded / Failed / Skipped / Total] 575 / 55 / 363 / 993:  37%|      | 993/2690 [11:39:00<19:54:34, 42.24s/it][Succeeded / Failed / Skipped / Total] 575 / 55 / 363 / 993:  37%|      | 994/2690 [11:39:25<19:53:23, 42.22s/it][[0 (7%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int film_probe(AVProbeData *p) { if (p->buf_size < 4) return 0; if (AV_RB32(&p->buf[0]) != FILM_TAG) return 0; return AVPROBE_SCORE_MAX; }

[[[[Adv]]]]: static int film_probe(AVProbeData *p) { if (p->buf_size < 4) return 0; if (AV_RB32(&p->buf[0]) != FILM_TAG) return 0; return AVPROBE_SCORE_MAX; }
--------------------------------------------- Result 992 ---------------------------------------------
[[0 (18%)]] --> [[0 (51%)]] --> Socre: 0.5079344511032104

[[[[Adv]]]]: static void ivshmem_io_writel(void *[[opaque]], target_phys_addr_t [[addr]], uint32_t [[val]]) { IVShmemState *s = [[opaque]]; uint64_t write_one = 1; uint16_t [[dest]] = [[val]] >> 16; uint16_t vector = [[val]] & 0xff; [[addr]] &= 0xfc; IVSHMEM_DPRINTF("writing to addr " TARGET_FMT_plx "\n", [[addr]]); switch ([[addr]]) { case INTRMASK: ivshmem_IntrMask_write(s, [[val]]); break; case INTRSTATUS: ivshmem_IntrStatus_write(s, [[val]]); break; case DOORBELL: if (([[dest]] < 0) || ([[dest]] > s->max_peer)) { IVSHMEM_DPRINTF("Invalid destination VM ID (%d)\n", [[dest]]); break; } if ((vector >= 0) && (vector < s->peers[[[dest]]].nb_eventfds)) { IVSHMEM_DPRINTF("Writing %" PRId64 " to VM %d on vector %d\n", write_one, [[dest]], vector); if (write(s->peers[[[dest]]].eventfds[vector], &(write_one), 8) != 8) { IVSHMEM_DPRINTF("error writing to eventfd\n"); } } break; default: IVSHMEM_DPRINTF("Invalid VM Doorbell VM %d\n", [[dest]]); } }

[[[[Adv]]]]: static void ivshmem_io_writel(void *[[blurred]], target_phys_addr_t [[winchell]], uint32_t [[selector]]) { IVShmemState *s = [[blurred]]; uint64_t write_one = 1; uint16_t [[masks]] = [[selector]] >> 16; uint16_t vector = [[selector]] & 0xff; [[winchell]] &= 0xfc; IVSHMEM_DPRINTF("writing to addr " TARGET_FMT_plx "\n", [[winchell]]); switch ([[winchell]]) { case INTRMASK: ivshmem_IntrMask_write(s, [[selector]]); break; case INTRSTATUS: ivshmem_IntrStatus_write(s, [[selector]]); break; case DOORBELL: if (([[masks]] < 0) || ([[masks]] > s->max_peer)) { IVSHMEM_DPRINTF("Invalid destination VM ID (%d)\n", [[masks]]); break; } if ((vector >= 0) && (vector < s->peers[[[masks]]].nb_eventfds)) { IVSHMEM_DPRINTF("Writing %" PRId64 " to VM %d on vector %d\n", write_one, [[masks]], vector); if (write(s->peers[[[masks]]].eventfds[vector], &(write_one), 8) != 8) { IVSHMEM_DPRINTF("error writing to eventfd\n"); } } break; default: IVSHMEM_DPRINTF("Invalid VM Doorbell VM %d\n", [[masks]]); } }
--------------------------------------------- Result 993 ---------------------------------------------
[[0 (5%)]] --> [[0 (53%)]] --> Socre: 0.5325815081596375

[[[[Adv]]]]: static void ide_trim_bh_cb(void *[[opaque]]) { TrimAIOCB *[[iocb]] = [[opaque]]; [[iocb]]->common.cb([[iocb]]->common.opaque, [[iocb]]->ret); qemu_bh_delete([[iocb]]->bh); [[iocb]]->bh = NULL; qemu_aio_unref([[iocb]]); }

[[[[Adv]]]]: static void ide_trim_bh_cb(void *[[secrets]]) { TrimAIOCB *[[dobbin]] = [[secrets]]; [[dobbin]]->common.cb([[dobbin]]->common.opaque, [[dobbin]]->ret); qemu_bh_delete([[dobbin]]->bh); [[dobbin]]->bh = NULL; qemu_aio_unref([[dobbin]]); }
--------------------------------------------- Result 994 ---------------------------------------------
[[0 (20%)]] --> [[0 (62%)]] --> Socre: 0.6203885078430176

[[[[Adv]]]]: static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd, abi_long cmd, abi_long arg) { void *argptr; struct dm_ioctl *host_dm; abi_long guest_data; uint32_t [[guest_data_size]]; int target_size; const argtype *arg_type = ie->arg_type; abi_long ret; void *big_buf = NULL; char *host_data; arg_type++; target_size = thunk_type_size(arg_type, 0); argptr = lock_user(VERIFY_READ, arg, target_size, 1); if (!argptr) { ret = -TARGET_EFAULT; goto out; } thunk_convert(buf_temp, argptr, arg_type, THUNK_HOST); unlock_user(argptr, arg, 0); big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2); memcpy(big_buf, buf_temp, target_size); buf_temp = big_buf; host_dm = big_buf; guest_data = arg + host_dm->data_start; if ((guest_data - arg) < 0) { ret = -EINVAL; goto out; } [[guest_data_size]] = host_dm->data_size - host_dm->data_start; host_data = (char*)host_dm + host_dm->data_start; argptr = lock_user(VERIFY_READ, guest_data, [[guest_data_size]], 1); switch (ie->host_cmd) { case DM_REMOVE_ALL: case DM_LIST_DEVICES: case DM_DEV_CREATE: case DM_DEV_REMOVE: case DM_DEV_SUSPEND: case DM_DEV_STATUS: case DM_DEV_WAIT: case DM_TABLE_STATUS: case DM_TABLE_CLEAR: case DM_TABLE_DEPS: case DM_LIST_VERSIONS: break; case DM_DEV_RENAME: case DM_DEV_SET_GEOMETRY: memcpy(host_data, argptr, [[guest_data_size]]); break; case DM_TARGET_MSG: memcpy(host_data, argptr, [[guest_data_size]]); *(uint64_t*)host_data = tswap64(*(uint64_t*)argptr); break; case DM_TABLE_LOAD: { void *gspec = argptr; void *cur_data = host_data; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) }; int spec_size = thunk_type_size(arg_type, 0); int i; for (i = 0; i < host_dm->target_count; i++) { struct dm_target_spec *spec = cur_data; uint32_t next; int slen; thunk_convert(spec, gspec, arg_type, THUNK_HOST); slen = strlen((char*)gspec + spec_size) + 1; next = spec->next; spec->next = sizeof(*spec) + slen; strcpy((char*)&spec[1], gspec + spec_size); gspec += next; cur_data += spec->next; } break; } default: ret = -TARGET_EINVAL; goto out; } unlock_user(argptr, guest_data, 0); ret = get_errno(ioctl(fd, ie->host_cmd, buf_temp)); if (!is_error(ret)) { guest_data = arg + host_dm->data_start; [[guest_data_size]] = host_dm->data_size - host_dm->data_start; argptr = lock_user(VERIFY_WRITE, guest_data, [[guest_data_size]], 0); switch (ie->host_cmd) { case DM_REMOVE_ALL: case DM_DEV_CREATE: case DM_DEV_REMOVE: case DM_DEV_RENAME: case DM_DEV_SUSPEND: case DM_DEV_STATUS: case DM_TABLE_LOAD: case DM_TABLE_CLEAR: case DM_TARGET_MSG: case DM_DEV_SET_GEOMETRY: break; case DM_LIST_DEVICES: { struct dm_name_list *nl = (void*)host_dm + host_dm->data_start; uint32_t remaining_data = [[guest_data_size]]; void *cur_data = argptr; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_name_list) }; int nl_size = 12; while (1) { uint32_t next = nl->next; if (next) { nl->next = nl_size + (strlen(nl->name) + 1); } if (remaining_data < nl->next) { host_dm->flags |= DM_BUFFER_FULL_FLAG; break; } thunk_convert(cur_data, nl, arg_type, THUNK_TARGET); strcpy(cur_data + nl_size, nl->name); cur_data += nl->next; remaining_data -= nl->next; if (!next) { break; } nl = (void*)nl + next; } break; } case DM_DEV_WAIT: case DM_TABLE_STATUS: { struct dm_target_spec *spec = (void*)host_dm + host_dm->data_start; void *cur_data = argptr; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) }; int spec_size = thunk_type_size(arg_type, 0); int i; for (i = 0; i < host_dm->target_count; i++) { uint32_t next = spec->next; int slen = strlen((char*)&spec[1]) + 1; spec->next = (cur_data - argptr) + spec_size + slen; if ([[guest_data_size]] < spec->next) { host_dm->flags |= DM_BUFFER_FULL_FLAG; break; } thunk_convert(cur_data, spec, arg_type, THUNK_TARGET); strcpy(cur_data + spec_size, (char*)&spec[1]); cur_data = argptr + spec->next; spec = (void*)host_dm + host_dm->data_start + next; } break; } case DM_TABLE_DEPS: { void *hdata = (void*)host_dm + host_dm->data_start; int count = *(uint32_t*)hdata; uint64_t *hdev = hdata + 8; uint64_t *gdev = argptr + 8; int i; *(uint32_t*)argptr = tswap32(count); for (i = 0; i < count; i++) { *gdev = tswap64(*hdev); gdev++; hdev++; } break; } case DM_LIST_VERSIONS: { struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start; uint32_t remaining_data = [[guest_data_size]]; void *cur_data = argptr; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_versions) }; int vers_size = thunk_type_size(arg_type, 0); while (1) { uint32_t next = vers->next; if (next) { vers->next = vers_size + (strlen(vers->name) + 1); } if (remaining_data < vers->next) { host_dm->flags |= DM_BUFFER_FULL_FLAG; break; } thunk_convert(cur_data, vers, arg_type, THUNK_TARGET); strcpy(cur_data + vers_size, vers->name); cur_data += vers->next; remaining_data -= vers->next; if (!next) { break; } vers = (void*)vers + next; } break; } default: ret = -TARGET_EINVAL; goto out; } unlock_user(argptr, guest_data, [[guest_data_size]]); argptr = lock_user(VERIFY_WRITE, arg, target_size, 0); if (!argptr) { ret = -TARGET_EFAULT; goto out; } thunk_convert(argptr, buf_temp, arg_type, THUNK_TARGET); unlock_user(argptr, arg, target_size); } out: if (big_buf) { free(big_buf); } return ret; }

[[[[Adv]]]]: static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd, abi_long cmd, abi_long arg) { void *argptr; struct dm_ioctl *host_dm; abi_long guest_data; uint32_t [[culvert]]; int target_size; const argtype *arg_type = ie->arg_type; abi_long ret; void *big_buf = NULL; char *host_data; arg_type++; target_size = thunk_type_size(arg_type, 0); argptr = lock_user(VERIFY_READ, arg, target_size, 1); if (!argptr) { ret = -TARGET_EFAULT; goto out; } thunk_convert(buf_temp, argptr, arg_type, THUNK_HOST); unlock_user(argptr, arg, 0); big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2); memcpy(big_buf, buf_temp, target_size); buf_temp = big_buf; host_dm = big_buf; guest_data = arg + host_dm->data_start; if ((guest_data - arg) < 0) { ret = -EINVAL; goto out; } [[culvert]] = host_dm->data_size - host_dm->data_start; host_data = (char*)host_dm + host_dm->data_start; argptr = lock_user(VERIFY_READ, guest_data, [[culvert]], 1); switch (ie->host_cmd) { case DM_REMOVE_ALL: case DM_LIST_DEVICES: case DM_DEV_CREATE: case DM_DEV_REMOVE: case DM_DEV_SUSPEND: case DM_DEV_STATUS: case DM_DEV_WAIT: case DM_TABLE_STATUS: case DM_TABLE_CLEAR: case DM_TABLE_DEPS: case DM_LIST_VERSIONS: break; case DM_DEV_RENAME: case DM_DEV_SET_GEOMETRY: memcpy(host_data, argptr, [[culvert]]); break; case DM_TARGET_MSG: memcpy(host_data, argptr, [[culvert]]); *(uint64_t*)host_data = tswap64(*(uint64_t*)argptr); break; case DM_TABLE_LOAD: { void *gspec = argptr; void *cur_data = host_data; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) }; int spec_size = thunk_type_size(arg_type, 0); int i; for (i = 0; i < host_dm->target_count; i++) { struct dm_target_spec *spec = cur_data; uint32_t next; int slen; thunk_convert(spec, gspec, arg_type, THUNK_HOST); slen = strlen((char*)gspec + spec_size) + 1; next = spec->next; spec->next = sizeof(*spec) + slen; strcpy((char*)&spec[1], gspec + spec_size); gspec += next; cur_data += spec->next; } break; } default: ret = -TARGET_EINVAL; goto out; } unlock_user(argptr, guest_data, 0); ret = get_errno(ioctl(fd, ie->host_cmd, buf_temp)); if (!is_error(ret)) { guest_data = arg + host_dm->data_start; [[culvert]] = host_dm->data_size - host_dm->data_start; argptr = lock_user(VERIFY_WRITE, guest_data, [[culvert]], 0); switch (ie->host_cmd) { case DM_REMOVE_ALL: case DM_DEV_CREATE: case DM_DEV_REMOVE: case DM_DEV_RENAME: case DM_DEV_SUSPEND: case DM_DEV_STATUS: case DM_TABLE_LOAD: case DM_TABLE_CLEAR: case DM_TARGET_MSG: case DM_DEV_SET_GEOMETRY: break; case DM_LIST_DEVICES: { struct dm_name_list *nl = (void*)host_dm + host_dm->data_start; uint32_t remaining_data = [[culvert]]; void *cur_data = argptr; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_name_list) }; int nl_size = 12; while (1) { uint32_t next = nl->next; if (next) { nl->next = nl_size + (strlen(nl->name) + 1); } if (remaining_data < nl->next) { host_dm->flags |= DM_BUFFER_FULL_FLAG; break; } thunk_convert(cur_data, nl, arg_type, THUNK_TARGET); strcpy(cur_data + nl_size, nl->name); cur_data += nl->next; remaining_data -= nl->next; if (!next) { break; } nl = (void*)nl + next; } break; } case DM_DEV_WAIT: case DM_TABLE_STATUS: { struct dm_target_spec *spec = (void*)host_dm + host_dm->data_start; void *cur_data = argptr; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) }; int spec_size = thunk_type_size(arg_type, 0); int i; for (i = 0; i < host_dm->target_count; i++) { uint32_t next = spec->next; int slen = strlen((char*)&spec[1]) + 1; spec->next = (cur_data - argptr) + spec_size + slen; if ([[culvert]] < spec->next) { host_dm->flags |= DM_BUFFER_FULL_FLAG; break; } thunk_convert(cur_data, spec, arg_type, THUNK_TARGET); strcpy(cur_data + spec_size, (char*)&spec[1]); cur_data = argptr + spec->next; spec = (void*)host_dm + host_dm->data_start + next; } break; } case DM_TABLE_DEPS: { void *hdata = (void*)host_dm + host_dm->data_start; int count = *(uint32_t*)hdata; uint64_t *hdev = hdata + 8; uint64_t *gdev = argptr + 8; int i; *(uint32_t*)argptr = tswap32(count); for (i = 0; i < count; i++) { *gdev = tswap64(*hdev); gdev++; hdev++; } break; } case DM_LIST_VERSIONS: { struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start; uint32_t remaining_data = [[culvert]]; void *cur_data = argptr; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_versions) }; int vers_size = thunk_type_size(arg_type, 0); while (1) { uint32_t next = vers->next; if (next) { vers->next = vers_size + (strlen(vers->name) + 1); } if (remaining_data < vers->next) { host_dm->flags |= DM_BUFFER_FULL_FLAG; break; } thunk_convert(cur_data, vers, arg_type, THUNK_TARGET); strcpy(cur_data + vers_size, vers->name); cur_data += vers->next; remaining_data -= vers->next; if (!next) { break; } vers = (void*)vers + next; } break; } default: ret = -TARGET_EINVAL; goto out; } unlock_user(argptr, guest_data, [[culvert]]); argptr = lock_user(VERIFY_WRITE, arg, target_size, 0); if (!argptr) { ret = -TARGET_EFAULT; goto out; } thunk_convert(argptr, buf_temp, arg_type, THUNK_TARGET); unlock_user(argptr, arg, target_size); } out: if (big_buf) { free(big_buf); } return ret; }[Succeeded / Failed / Skipped / Total] 576 / 55 / 363 / 994:  37%|      | 994/2690 [11:39:25<19:53:23, 42.22s/it][Succeeded / Failed / Skipped / Total] 576 / 55 / 363 / 994:  37%|      | 995/2690 [11:39:45<19:52:02, 42.20s/it][Succeeded / Failed / Skipped / Total] 577 / 55 / 363 / 995:  37%|      | 995/2690 [11:39:45<19:52:02, 42.20s/it][Succeeded / Failed / Skipped / Total] 577 / 55 / 363 / 995:  37%|      | 996/2690 [11:39:55<19:50:25, 42.16s/it][Succeeded / Failed / Skipped / Total] 578 / 55 / 363 / 996:  37%|      | 996/2690 [11:39:55<19:50:25, 42.16s/it][Succeeded / Failed / Skipped / Total] 578 / 55 / 363 / 996:  37%|      | 997/2690 [11:40:14<19:49:04, 42.14s/it]
--------------------------------------------- Result 995 ---------------------------------------------
[[0 (19%)]] --> [[0 (50%)]] --> Socre: 0.5043454170227051

[[[[Adv]]]]: static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame) { InputStream *[[ist]] = s->opaque; DXVA2Context *[[ctx]] = [[ist]]->hwaccel_ctx; int [[ret]]; [[ret]] = av_hwframe_transfer_data([[ctx]]->tmp_frame, frame, 0); if ([[ret]] < 0) return [[ret]]; [[ret]] = av_frame_copy_props([[ctx]]->tmp_frame, frame); if ([[ret]] < 0) { av_frame_unref([[ctx]]->tmp_frame); return [[ret]]; } av_frame_unref(frame); av_frame_move_ref(frame, [[ctx]]->tmp_frame); return 0; }

[[[[Adv]]]]: static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame) { InputStream *[[tsa]] = s->opaque; DXVA2Context *[[req]] = [[tsa]]->hwaccel_ctx; int [[retirees]]; [[retirees]] = av_hwframe_transfer_data([[req]]->tmp_frame, frame, 0); if ([[retirees]] < 0) return [[retirees]]; [[retirees]] = av_frame_copy_props([[req]]->tmp_frame, frame); if ([[retirees]] < 0) { av_frame_unref([[req]]->tmp_frame); return [[retirees]]; } av_frame_unref(frame); av_frame_move_ref(frame, [[req]]->tmp_frame); return 0; }
--------------------------------------------- Result 996 ---------------------------------------------
[[0 (99%)]] --> [[0 (49%)]] --> Socre: 0.514566957950592

[[[[Adv]]]]: void decode_mb_mode(VP8Context *s, VP8Macroblock *[[mb]], int [[mb_x]], int [[mb_y]], uint8_t *segment, uint8_t *ref, int layout) { VP56RangeCoder *c = &s->c; if (s->segmentation.update_map) *segment = vp8_rac_get_tree(c, vp8_segmentid_tree, s->prob->segmentid); else if (s->segmentation.enabled) *segment = ref ? *ref : *segment; [[mb]]->segment = *segment; [[mb]]->skip = s->mbskip_enabled ? vp56_rac_get_prob(c, s->prob->mbskip) : 0; if (s->keyframe) { [[mb]]->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra, vp8_pred16x16_prob_intra); if ([[mb]]->mode == MODE_I4x4) { decode_intra4x4_modes(s, c, [[mb]], [[mb_x]], 1, layout); } else { const uint32_t [[modes]] = vp8_pred4x4_mode[[[mb]]->mode] * 0x01010101u; if (s->mb_layout == 1) AV_WN32A([[mb]]->intra4x4_pred_mode_top, [[modes]]); else AV_WN32A(s->intra4x4_pred_mode_top + 4 * [[mb_x]], [[modes]]); AV_WN32A(s->intra4x4_pred_mode_left, [[modes]]); } [[mb]]->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree, vp8_pred8x8c_prob_intra); [[mb]]->ref_frame = VP56_FRAME_CURRENT; } else if (vp56_rac_get_prob_branchy(c, s->prob->intra)) { if (vp56_rac_get_prob_branchy(c, s->prob->last)) [[mb]]->ref_frame = vp56_rac_get_prob(c, s->prob->golden) ? VP56_FRAME_GOLDEN2 : VP56_FRAME_GOLDEN; else [[mb]]->ref_frame = VP56_FRAME_PREVIOUS; s->ref_count[[[mb]]->ref_frame - 1]++; decode_mvs(s, [[mb]], [[mb_x]], [[mb_y]], layout); } else { [[mb]]->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s->prob->pred16x16); if ([[mb]]->mode == MODE_I4x4) decode_intra4x4_modes(s, c, [[mb]], [[mb_x]], 0, layout); [[mb]]->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree, s->prob->pred8x8c); [[mb]]->ref_frame = VP56_FRAME_CURRENT; [[mb]]->partitioning = VP8_SPLITMVMODE_NONE; AV_ZERO32(&[[mb]]->bmv[0]); } }

[[[[Adv]]]]: void decode_mb_mode(VP8Context *s, VP8Macroblock *[[zip]], int [[surveys]], int [[spiced]], uint8_t *segment, uint8_t *ref, int layout) { VP56RangeCoder *c = &s->c; if (s->segmentation.update_map) *segment = vp8_rac_get_tree(c, vp8_segmentid_tree, s->prob->segmentid); else if (s->segmentation.enabled) *segment = ref ? *ref : *segment; [[zip]]->segment = *segment; [[zip]]->skip = s->mbskip_enabled ? vp56_rac_get_prob(c, s->prob->mbskip) : 0; if (s->keyframe) { [[zip]]->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra, vp8_pred16x16_prob_intra); if ([[zip]]->mode == MODE_I4x4) { decode_intra4x4_modes(s, c, [[zip]], [[surveys]], 1, layout); } else { const uint32_t [[pathways]] = vp8_pred4x4_mode[[[zip]]->mode] * 0x01010101u; if (s->mb_layout == 1) AV_WN32A([[zip]]->intra4x4_pred_mode_top, [[pathways]]); else AV_WN32A(s->intra4x4_pred_mode_top + 4 * [[surveys]], [[pathways]]); AV_WN32A(s->intra4x4_pred_mode_left, [[pathways]]); } [[zip]]->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree, vp8_pred8x8c_prob_intra); [[zip]]->ref_frame = VP56_FRAME_CURRENT; } else if (vp56_rac_get_prob_branchy(c, s->prob->intra)) { if (vp56_rac_get_prob_branchy(c, s->prob->last)) [[zip]]->ref_frame = vp56_rac_get_prob(c, s->prob->golden) ? VP56_FRAME_GOLDEN2 : VP56_FRAME_GOLDEN; else [[zip]]->ref_frame = VP56_FRAME_PREVIOUS; s->ref_count[[[zip]]->ref_frame - 1]++; decode_mvs(s, [[zip]], [[surveys]], [[spiced]], layout); } else { [[zip]]->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s->prob->pred16x16); if ([[zip]]->mode == MODE_I4x4) decode_intra4x4_modes(s, c, [[zip]], [[surveys]], 0, layout); [[zip]]->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree, s->prob->pred8x8c); [[zip]]->ref_frame = VP56_FRAME_CURRENT; [[zip]]->partitioning = VP8_SPLITMVMODE_NONE; AV_ZERO32(&[[zip]]->bmv[0]); } }
--------------------------------------------- Result 997 ---------------------------------------------
[[0 (72%)]] --> [[0 (42%)]] --> Socre: 0.5786179602146149

[[[[Adv]]]]: static int decode_micromips_opc (CPUMIPSState *[[env]], DisasContext *ctx, int *is_branch) { uint32_t op; if (ctx->pc & 0x1) { [[env]]->CP0_BadVAddr = ctx->pc; generate_exception(ctx, EXCP_AdEL); ctx->bstate = BS_STOP; return 2; } op = (ctx->opcode >> 10) & 0x3f; if (ctx->hflags & MIPS_HFLAG_BMASK) { int bits = ctx->hflags & MIPS_HFLAG_BMASK_EXT; switch (op) { case POOL32A: case POOL32B: case POOL32I: case POOL32C: case ADDI32: case ADDIU32: case ORI32: case XORI32: case SLTI32: case SLTIU32: case ANDI32: case JALX32: case LBU32: case LHU32: case POOL32F: case JALS32: case BEQ32: case BNE32: case J32: case JAL32: case SB32: case SH32: case POOL32S: case ADDIUPC: case SWC132: case SDC132: case SD32: case SW32: case LB32: case LH32: case DADDIU32: case LWC132: case LDC132: case LD32: case LW32: if (bits & MIPS_HFLAG_BDS16) { generate_exception(ctx, EXCP_RI); ctx->bstate = BS_STOP; return 2; } break; case POOL16A: case POOL16B: case POOL16C: case LWGP16: case POOL16F: case LBU16: case LHU16: case LWSP16: case LW16: case SB16: case SH16: case SWSP16: case SW16: case MOVE16: case ANDI16: case POOL16D: case POOL16E: case BEQZ16: case BNEZ16: case B16: case LI16: if (bits & MIPS_HFLAG_BDS32) { generate_exception(ctx, EXCP_RI); ctx->bstate = BS_STOP; return 2; } break; default: break; } } switch (op) { case POOL16A: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rs1 = mmreg(uMIPS_RS1(ctx->opcode)); int rs2 = mmreg(uMIPS_RS2(ctx->opcode)); uint32_t opc = 0; switch (ctx->opcode & 0x1) { case ADDU16: opc = OPC_ADDU; break; case SUBU16: opc = OPC_SUBU; break; } gen_arith(ctx, opc, rd, rs1, rs2); } break; case POOL16B: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rs = mmreg(uMIPS_RS(ctx->opcode)); int amount = (ctx->opcode >> 1) & 0x7; uint32_t opc = 0; amount = amount == 0 ? 8 : amount; switch (ctx->opcode & 0x1) { case SLL16: opc = OPC_SLL; break; case SRL16: opc = OPC_SRL; break; } gen_shift_imm(ctx, opc, rd, rs, amount); } break; case POOL16C: gen_pool16c_insn(ctx, is_branch); break; case LWGP16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = 28; int16_t offset = SIMM(ctx->opcode, 0, 7) << 2; gen_ld(ctx, OPC_LW, rd, rb, offset); } break; case POOL16F: if (ctx->opcode & 1) { generate_exception(ctx, EXCP_RI); } else { int enc_dest = uMIPS_RD(ctx->opcode); int enc_rt = uMIPS_RS2(ctx->opcode); int enc_rs = uMIPS_RS1(ctx->opcode); int rd, rs, re, rt; static const int rd_enc[] = { 5, 5, 6, 4, 4, 4, 4, 4 }; static const int re_enc[] = { 6, 7, 7, 21, 22, 5, 6, 7 }; static const int rs_rt_enc[] = { 0, 17, 2, 3, 16, 18, 19, 20 }; rd = rd_enc[enc_dest]; re = re_enc[enc_dest]; rs = rs_rt_enc[enc_rs]; rt = rs_rt_enc[enc_rt]; gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0); gen_arith_imm(ctx, OPC_ADDIU, re, rt, 0); } break; case LBU16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4); offset = (offset == 0xf ? -1 : offset); gen_ld(ctx, OPC_LBU, rd, rb, offset); } break; case LHU16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1; gen_ld(ctx, OPC_LHU, rd, rb, offset); } break; case LWSP16: { int rd = (ctx->opcode >> 5) & 0x1f; int rb = 29; int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2; gen_ld(ctx, OPC_LW, rd, rb, offset); } break; case LW16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2; gen_ld(ctx, OPC_LW, rd, rb, offset); } break; case SB16: { int rd = mmreg2(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4); gen_st(ctx, OPC_SB, rd, rb, offset); } break; case SH16: { int rd = mmreg2(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1; gen_st(ctx, OPC_SH, rd, rb, offset); } break; case SWSP16: { int rd = (ctx->opcode >> 5) & 0x1f; int rb = 29; int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2; gen_st(ctx, OPC_SW, rd, rb, offset); } break; case SW16: { int rd = mmreg2(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2; gen_st(ctx, OPC_SW, rd, rb, offset); } break; case MOVE16: { int rd = uMIPS_RD5(ctx->opcode); int rs = uMIPS_RS5(ctx->opcode); gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0); } break; case ANDI16: gen_andi16(ctx); break; case POOL16D: switch (ctx->opcode & 0x1) { case ADDIUS5: gen_addius5(ctx); break; case ADDIUSP: gen_addiusp(ctx); break; } break; case POOL16E: switch (ctx->opcode & 0x1) { case ADDIUR2: gen_addiur2(ctx); break; case ADDIUR1SP: gen_addiur1sp(ctx); break; } break; case B16: gen_compute_branch(ctx, OPC_BEQ, 2, 0, 0, SIMM(ctx->opcode, 0, 10) << 1); *is_branch = 1; break; case BNEZ16: case BEQZ16: gen_compute_branch(ctx, op == BNEZ16 ? OPC_BNE : OPC_BEQ, 2, mmreg(uMIPS_RD(ctx->opcode)), 0, SIMM(ctx->opcode, 0, 7) << 1); *is_branch = 1; break; case LI16: { int reg = mmreg(uMIPS_RD(ctx->opcode)); int imm = ZIMM(ctx->opcode, 0, 7); imm = (imm == 0x7f ? -1 : imm); tcg_gen_movi_tl(cpu_gpr[reg], imm); } break; case RES_20: case RES_28: case RES_29: case RES_30: case RES_31: case RES_38: case RES_39: generate_exception(ctx, EXCP_RI); break; default: decode_micromips32_opc ([[env]], ctx, op, is_branch); return 4; } return 2; }

[[[[Adv]]]]: static int decode_micromips_opc (CPUMIPSState *[[olay]], DisasContext *ctx, int *is_branch) { uint32_t op; if (ctx->pc & 0x1) { [[olay]]->CP0_BadVAddr = ctx->pc; generate_exception(ctx, EXCP_AdEL); ctx->bstate = BS_STOP; return 2; } op = (ctx->opcode >> 10) & 0x3f; if (ctx->hflags & MIPS_HFLAG_BMASK) { int bits = ctx->hflags & MIPS_HFLAG_BMASK_EXT; switch (op) { case POOL32A: case POOL32B: case POOL32I: case POOL32C: case ADDI32: case ADDIU32: case ORI32: case XORI32: case SLTI32: case SLTIU32: case ANDI32: case JALX32: case LBU32: case LHU32: case POOL32F: case JALS32: case BEQ32: case BNE32: case J32: case JAL32: case SB32: case SH32: case POOL32S: case ADDIUPC: case SWC132: case SDC132: case SD32: case SW32: case LB32: case LH32: case DADDIU32: case LWC132: case LDC132: case LD32: case LW32: if (bits & MIPS_HFLAG_BDS16) { generate_exception(ctx, EXCP_RI); ctx->bstate = BS_STOP; return 2; } break; case POOL16A: case POOL16B: case POOL16C: case LWGP16: case POOL16F: case LBU16: case LHU16: case LWSP16: case LW16: case SB16: case SH16: case SWSP16: case SW16: case MOVE16: case ANDI16: case POOL16D: case POOL16E: case BEQZ16: case BNEZ16: case B16: case LI16: if (bits & MIPS_HFLAG_BDS32) { generate_exception(ctx, EXCP_RI); ctx->bstate = BS_STOP; return 2; } break; default: break; } } switch (op) { case POOL16A: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rs1 = mmreg(uMIPS_RS1(ctx->opcode)); int rs2 = mmreg(uMIPS_RS2(ctx->opcode)); uint32_t opc = 0; switch (ctx->opcode & 0x1) { case ADDU16: opc = OPC_ADDU; break; case SUBU16: opc = OPC_SUBU; break; } gen_arith(ctx, opc, rd, rs1, rs2); } break; case POOL16B: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rs = mmreg(uMIPS_RS(ctx->opcode)); int amount = (ctx->opcode >> 1) & 0x7; uint32_t opc = 0; amount = amount == 0 ? 8 : amount; switch (ctx->opcode & 0x1) { case SLL16: opc = OPC_SLL; break; case SRL16: opc = OPC_SRL; break; } gen_shift_imm(ctx, opc, rd, rs, amount); } break; case POOL16C: gen_pool16c_insn(ctx, is_branch); break; case LWGP16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = 28; int16_t offset = SIMM(ctx->opcode, 0, 7) << 2; gen_ld(ctx, OPC_LW, rd, rb, offset); } break; case POOL16F: if (ctx->opcode & 1) { generate_exception(ctx, EXCP_RI); } else { int enc_dest = uMIPS_RD(ctx->opcode); int enc_rt = uMIPS_RS2(ctx->opcode); int enc_rs = uMIPS_RS1(ctx->opcode); int rd, rs, re, rt; static const int rd_enc[] = { 5, 5, 6, 4, 4, 4, 4, 4 }; static const int re_enc[] = { 6, 7, 7, 21, 22, 5, 6, 7 }; static const int rs_rt_enc[] = { 0, 17, 2, 3, 16, 18, 19, 20 }; rd = rd_enc[enc_dest]; re = re_enc[enc_dest]; rs = rs_rt_enc[enc_rs]; rt = rs_rt_enc[enc_rt]; gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0); gen_arith_imm(ctx, OPC_ADDIU, re, rt, 0); } break; case LBU16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4); offset = (offset == 0xf ? -1 : offset); gen_ld(ctx, OPC_LBU, rd, rb, offset); } break; case LHU16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1; gen_ld(ctx, OPC_LHU, rd, rb, offset); } break; case LWSP16: { int rd = (ctx->opcode >> 5) & 0x1f; int rb = 29; int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2; gen_ld(ctx, OPC_LW, rd, rb, offset); } break; case LW16: { int rd = mmreg(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2; gen_ld(ctx, OPC_LW, rd, rb, offset); } break; case SB16: { int rd = mmreg2(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4); gen_st(ctx, OPC_SB, rd, rb, offset); } break; case SH16: { int rd = mmreg2(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1; gen_st(ctx, OPC_SH, rd, rb, offset); } break; case SWSP16: { int rd = (ctx->opcode >> 5) & 0x1f; int rb = 29; int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2; gen_st(ctx, OPC_SW, rd, rb, offset); } break; case SW16: { int rd = mmreg2(uMIPS_RD(ctx->opcode)); int rb = mmreg(uMIPS_RS(ctx->opcode)); int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2; gen_st(ctx, OPC_SW, rd, rb, offset); } break; case MOVE16: { int rd = uMIPS_RD5(ctx->opcode); int rs = uMIPS_RS5(ctx->opcode); gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0); } break; case ANDI16: gen_andi16(ctx); break; case POOL16D: switch (ctx->opcode & 0x1) { case ADDIUS5: gen_addius5(ctx); break; case ADDIUSP: gen_addiusp(ctx); break; } break; case POOL16E: switch (ctx->opcode & 0x1) { case ADDIUR2: gen_addiur2(ctx); break; case ADDIUR1SP: gen_addiur1sp(ctx); break; } break; case B16: gen_compute_branch(ctx, OPC_BEQ, 2, 0, 0, SIMM(ctx->opcode, 0, 10) << 1); *is_branch = 1; break; case BNEZ16: case BEQZ16: gen_compute_branch(ctx, op == BNEZ16 ? OPC_BNE : OPC_BEQ, 2, mmreg(uMIPS_RD(ctx->opcode)), 0, SIMM(ctx->opcode, 0, 7) << 1); *is_branch = 1; break; case LI16: { int reg = mmreg(uMIPS_RD(ctx->opcode)); int imm = ZIMM(ctx->opcode, 0, 7); imm = (imm == 0x7f ? -1 : imm); tcg_gen_movi_tl(cpu_gpr[reg], imm); } break; case RES_20: case RES_28: case RES_29: case RES_30: case RES_31: case RES_38: case RES_39: generate_exception(ctx, EXCP_RI); break; default: decode_micromips32_opc ([[olay]], ctx, op, is_branch); return 4; } return 2; }[Succeeded / Failed / Skipped / Total] 579 / 55 / 363 / 997:  37%|      | 997/2690 [11:40:14<19:49:04, 42.14s/it][Succeeded / Failed / Skipped / Total] 579 / 55 / 363 / 997:  37%|      | 998/2690 [11:40:20<19:47:20, 42.10s/it][Succeeded / Failed / Skipped / Total] 580 / 55 / 363 / 998:  37%|      | 998/2690 [11:40:20<19:47:20, 42.10s/it][Succeeded / Failed / Skipped / Total] 580 / 55 / 363 / 998:  37%|      | 999/2690 [11:40:28<19:45:40, 42.07s/it][Succeeded / Failed / Skipped / Total] 581 / 55 / 363 / 999:  37%|      | 999/2690 [11:40:28<19:45:40, 42.07s/it][Succeeded / Failed / Skipped / Total] 581 / 55 / 363 / 999:  37%|      | 1000/2690 [11:40:32<19:43:54, 42.03s/it][Succeeded / Failed / Skipped / Total] 582 / 55 / 363 / 1000:  37%|      | 1000/2690 [11:40:32<19:43:54, 42.03s/it][Succeeded / Failed / Skipped / Total] 582 / 55 / 363 / 1000:  37%|      | 1001/2690 [11:40:35<19:42:06, 41.99s/it][Succeeded / Failed / Skipped / Total] 583 / 55 / 363 / 1001:  37%|      | 1001/2690 [11:40:35<19:42:06, 41.99s/it][Succeeded / Failed / Skipped / Total] 583 / 55 / 363 / 1001:  37%|      | 1002/2690 [11:41:15<19:41:21, 41.99s/it]
--------------------------------------------- Result 998 ---------------------------------------------
[[0 (31%)]] --> [[0 (54%)]] --> Socre: 0.544651985168457

[[[[Adv]]]]: static void decouple_info(COOKContext *q, COOKSubpacket *p, int *[[decouple_tab]]) { int i; int vlc = get_bits1(&q->gb); int start = cplband[p->js_subband_start]; int end = cplband[p->subbands - 1]; int length = end - start + 1; if (start > end) return; if (vlc) for (i = 0; i < length; i++) [[decouple_tab]][start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2); else for (i = 0; i < length; i++) [[decouple_tab]][start + i] = get_bits(&q->gb, p->js_vlc_bits); }

[[[[Adv]]]]: static void decouple_info(COOKContext *q, COOKSubpacket *p, int *[[neuro]]) { int i; int vlc = get_bits1(&q->gb); int start = cplband[p->js_subband_start]; int end = cplband[p->subbands - 1]; int length = end - start + 1; if (start > end) return; if (vlc) for (i = 0; i < length; i++) [[neuro]][start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2); else for (i = 0; i < length; i++) [[neuro]][start + i] = get_bits(&q->gb, p->js_vlc_bits); }
--------------------------------------------- Result 999 ---------------------------------------------
[[0 (1%)]] --> [[0 (61%)]] --> Socre: 0.6076670289039612

[[[[Adv]]]]: void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *[[src]], ptrdiff_t stride) { avc_luma_midv_qrt_8w_msa([[src]] - (2 * stride) - 2, stride, dst, stride, 8, 1); }

[[[[Adv]]]]: void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *[[glria]], ptrdiff_t stride) { avc_luma_midv_qrt_8w_msa([[glria]] - (2 * stride) - 2, stride, dst, stride, 8, 1); }
--------------------------------------------- Result 1000 ---------------------------------------------
[[0 (47%)]] --> [[0 (90%)]] --> Socre: 0.8954102396965027

[[[[Adv]]]]: static void find_best_state(uint8_t best_state[256][256], const uint8_t one_state[256]){ int i,j,k,m; double l2tab[256]; for(i=1; i<256; i++) l2tab[i]= log2(i/256.0); for(i=0; i<256; i++){ double best_len[256]; double p= i/256.0; for(j=0; j<256; j++) best_len[j]= 1<<30; for(j=FFMAX(i-10,1); j<FFMIN(i+11,256); j++){ double [[occ]][256]={0}; double len=0; [[occ]][j]=1.0; for(k=0; k<256; k++){ double newocc[256]={0}; for(m=0; m<256; m++){ if([[occ]][m]){ len -=[[occ]][m]*( p *l2tab[ m] + (1-p)*l2tab[256-m]); } } if(len < best_len[k]){ best_len[k]= len; best_state[i][k]= j; } for(m=0; m<256; m++){ if([[occ]][m]){ newocc[ one_state[ m]] += [[occ]][m]* p ; newocc[256-one_state[256-m]] += [[occ]][m]*(1-p); } } memcpy([[occ]], newocc, sizeof([[occ]])); } } } }

[[[[Adv]]]]: static void find_best_state(uint8_t best_state[256][256], const uint8_t one_state[256]){ int i,j,k,m; double l2tab[256]; for(i=1; i<256; i++) l2tab[i]= log2(i/256.0); for(i=0; i<256; i++){ double best_len[256]; double p= i/256.0; for(j=0; j<256; j++) best_len[j]= 1<<30; for(j=FFMAX(i-10,1); j<FFMIN(i+11,256); j++){ double [[seepage]][256]={0}; double len=0; [[seepage]][j]=1.0; for(k=0; k<256; k++){ double newocc[256]={0}; for(m=0; m<256; m++){ if([[seepage]][m]){ len -=[[seepage]][m]*( p *l2tab[ m] + (1-p)*l2tab[256-m]); } } if(len < best_len[k]){ best_len[k]= len; best_state[i][k]= j; } for(m=0; m<256; m++){ if([[seepage]][m]){ newocc[ one_state[ m]] += [[seepage]][m]* p ; newocc[256-one_state[256-m]] += [[seepage]][m]*(1-p); } } memcpy([[seepage]], newocc, sizeof([[seepage]])); } } } }
--------------------------------------------- Result 1001 ---------------------------------------------
[[0 (37%)]] --> [[0 (70%)]] --> Socre: 0.695648729801178

[[[[Adv]]]]: static int get_pcm(HEVCContext *s, int [[x]], int y) { int log2_min_pu_size = s->sps->log2_min_pu_size; int x_pu = [[x]] >> log2_min_pu_size; int y_pu = y >> log2_min_pu_size; if ([[x]] < 0 || x_pu >= s->sps->min_pu_width || y < 0 || y_pu >= s->sps->min_pu_height) return 2; return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu]; }

[[[[Adv]]]]: static int get_pcm(HEVCContext *s, int [[umpteenth]], int y) { int log2_min_pu_size = s->sps->log2_min_pu_size; int x_pu = [[umpteenth]] >> log2_min_pu_size; int y_pu = y >> log2_min_pu_size; if ([[umpteenth]] < 0 || x_pu >= s->sps->min_pu_width || y < 0 || y_pu >= s->sps->min_pu_height) return 2; return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu]; }
--------------------------------------------- Result 1002 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 584 / 55 / 363 / 1002:  37%|      | 1002/2690 [11:41:15<19:41:21, 41.99s/it][Succeeded / Failed / Skipped / Total] 584 / 55 / 363 / 1002:  37%|      | 1003/2690 [11:41:20<19:39:37, 41.95s/it][Succeeded / Failed / Skipped / Total] 585 / 55 / 363 / 1003:  37%|      | 1003/2690 [11:41:20<19:39:37, 41.95s/it][Succeeded / Failed / Skipped / Total] 585 / 55 / 363 / 1003:  37%|      | 1004/2690 [11:44:16<19:42:39, 42.09s/it][Succeeded / Failed / Skipped / Total] 586 / 55 / 363 / 1004:  37%|      | 1004/2690 [11:44:16<19:42:39, 42.09s/it][Succeeded / Failed / Skipped / Total] 586 / 55 / 363 / 1004:  37%|      | 1005/2690 [11:46:05<19:43:51, 42.16s/it][[0 (15%)]] --> [[0 (99%)]] --> Socre: 0.9894495606422424

[[[[Adv]]]]: static int h264_decode_frame(AVCodecContext *[[avctx]], void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; H264Context *h = [[avctx]]->priv_data; AVFrame *pict = data; int buf_index = 0; int ret; const uint8_t *new_extradata; int new_extradata_size; h->flags = [[avctx]]->flags; h->setup_finished = 0; out: if (buf_size == 0) { H264Picture *out; int i, out_idx; h->cur_pic_ptr = NULL; out = h->delayed_pic[0]; out_idx = 0; for (i = 1; h->delayed_pic[i] && !h->delayed_pic[i]->f->key_frame && !h->delayed_pic[i]->mmco_reset; i++) if (h->delayed_pic[i]->poc < out->poc) { out = h->delayed_pic[i]; out_idx = i; } for (i = out_idx; h->delayed_pic[i]; i++) h->delayed_pic[i] = h->delayed_pic[i + 1]; if (out) { ret = output_frame(h, pict, out->f); if (ret < 0) return ret; *got_frame = 1; } return buf_index; } new_extradata_size = 0; new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA, &new_extradata_size); if (new_extradata_size > 0 && new_extradata) { ret = ff_h264_decode_extradata(new_extradata, new_extradata_size, &h->ps, &h->is_avc, &h->nal_length_size, [[avctx]]->err_recognition, [[avctx]]); if (ret < 0) return ret; } buf_index = decode_nal_units(h, buf, buf_size); if (buf_index < 0) return AVERROR_INVALIDDATA; if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) { buf_size = 0; goto out; } if (!([[avctx]]->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) { if ([[avctx]]->skip_frame >= AVDISCARD_NONREF) return 0; av_log([[avctx]], AV_LOG_ERROR, "no frame!\n"); return AVERROR_INVALIDDATA; } if (!([[avctx]]->flags2 & AV_CODEC_FLAG2_CHUNKS) || (h->mb_y >= h->mb_height && h->mb_height)) { if ([[avctx]]->flags2 & AV_CODEC_FLAG2_CHUNKS) decode_postinit(h, 1); ff_h264_field_end(h, &h->slice_ctx[0], 0); *got_frame = 0; if (h->next_output_pic && (([[avctx]]->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) || h->next_output_pic->recovered)) { if (!h->next_output_pic->recovered) h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT; ret = output_frame(h, pict, h->next_output_pic->f); if (ret < 0) return ret; *got_frame = 1; } } assert(pict->buf[0] || !*got_frame); return get_consumed_bytes(buf_index, buf_size); }

[[[[Adv]]]]: static int h264_decode_frame(AVCodecContext *[[pel]], void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; H264Context *h = [[pel]]->priv_data; AVFrame *pict = data; int buf_index = 0; int ret; const uint8_t *new_extradata; int new_extradata_size; h->flags = [[pel]]->flags; h->setup_finished = 0; out: if (buf_size == 0) { H264Picture *out; int i, out_idx; h->cur_pic_ptr = NULL; out = h->delayed_pic[0]; out_idx = 0; for (i = 1; h->delayed_pic[i] && !h->delayed_pic[i]->f->key_frame && !h->delayed_pic[i]->mmco_reset; i++) if (h->delayed_pic[i]->poc < out->poc) { out = h->delayed_pic[i]; out_idx = i; } for (i = out_idx; h->delayed_pic[i]; i++) h->delayed_pic[i] = h->delayed_pic[i + 1]; if (out) { ret = output_frame(h, pict, out->f); if (ret < 0) return ret; *got_frame = 1; } return buf_index; } new_extradata_size = 0; new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA, &new_extradata_size); if (new_extradata_size > 0 && new_extradata) { ret = ff_h264_decode_extradata(new_extradata, new_extradata_size, &h->ps, &h->is_avc, &h->nal_length_size, [[pel]]->err_recognition, [[pel]]); if (ret < 0) return ret; } buf_index = decode_nal_units(h, buf, buf_size); if (buf_index < 0) return AVERROR_INVALIDDATA; if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) { buf_size = 0; goto out; } if (!([[pel]]->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) { if ([[pel]]->skip_frame >= AVDISCARD_NONREF) return 0; av_log([[pel]], AV_LOG_ERROR, "no frame!\n"); return AVERROR_INVALIDDATA; } if (!([[pel]]->flags2 & AV_CODEC_FLAG2_CHUNKS) || (h->mb_y >= h->mb_height && h->mb_height)) { if ([[pel]]->flags2 & AV_CODEC_FLAG2_CHUNKS) decode_postinit(h, 1); ff_h264_field_end(h, &h->slice_ctx[0], 0); *got_frame = 0; if (h->next_output_pic && (([[pel]]->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) || h->next_output_pic->recovered)) { if (!h->next_output_pic->recovered) h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT; ret = output_frame(h, pict, h->next_output_pic->f); if (ret < 0) return ret; *got_frame = 1; } } assert(pict->buf[0] || !*got_frame); return get_consumed_bytes(buf_index, buf_size); }
--------------------------------------------- Result 1003 ---------------------------------------------
[[0 (34%)]] --> [[0 (52%)]] --> Socre: 0.5163432359695435

[[[[Adv]]]]: static inline int16_t calc_lowcomp(int16_t [[a]], int16_t b0, int16_t [[b1]], uint8_t bin) { if (bin < 7) { if ((b0 + 256) == [[b1]]) [[a]] = 384; else if (b0 > [[b1]]) [[a]] = FFMAX(0, [[a]] - 64); } else if (bin < 20) { if ((b0 + 256) == [[b1]]) [[a]] = 320; else if (b0 > [[b1]]) [[a]] = FFMAX(0, [[a]] - 64); } else { [[a]] = FFMAX(0, [[a]] - 128); } return [[a]]; }

[[[[Adv]]]]: static inline int16_t calc_lowcomp(int16_t [[de]], int16_t b0, int16_t [[bundy]], uint8_t bin) { if (bin < 7) { if ((b0 + 256) == [[bundy]]) [[de]] = 384; else if (b0 > [[bundy]]) [[de]] = FFMAX(0, [[de]] - 64); } else if (bin < 20) { if ((b0 + 256) == [[bundy]]) [[de]] = 320; else if (b0 > [[bundy]]) [[de]] = FFMAX(0, [[de]] - 64); } else { [[de]] = FFMAX(0, [[de]] - 128); } return [[de]]; }
--------------------------------------------- Result 1004 ---------------------------------------------
[[0 (2%)]] --> [[0 (98%)]] --> Socre: 0.97939532995224

[[[[Adv]]]]: static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val, unsigned int [[size]], int mem_index) { int l1 = gen_new_label(); TCGv [[taddr]] = tcg_temp_local_new(); TCGv [[tval]] = tcg_temp_local_new(); TCGv [[t1]] = tcg_temp_local_new(); dc->postinc = 0; cris_evaluate_flags(dc); tcg_gen_mov_tl([[taddr]], addr); tcg_gen_mov_tl([[tval]], val); tcg_gen_andi_tl([[t1]], cpu_PR[PR_CCS], F_FLAG_V10); tcg_gen_brcondi_tl(TCG_COND_NE, [[t1]], 0, l1); if ([[size]] == 1) { tcg_gen_qemu_st8([[tval]], [[taddr]], mem_index); } else if ([[size]] == 2) { tcg_gen_qemu_st16([[tval]], [[taddr]], mem_index); } else { tcg_gen_qemu_st32([[tval]], [[taddr]], mem_index); } gen_set_label(l1); tcg_gen_shri_tl([[t1]], [[t1]], 1); tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], [[t1]]); tcg_temp_free([[t1]]); tcg_temp_free([[tval]]); tcg_temp_free([[taddr]]); }

[[[[Adv]]]]: static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val, unsigned int [[dimensions]], int mem_index) { int l1 = gen_new_label(); TCGv [[csar]] = tcg_temp_local_new(); TCGv [[firelight]] = tcg_temp_local_new(); TCGv [[qt]] = tcg_temp_local_new(); dc->postinc = 0; cris_evaluate_flags(dc); tcg_gen_mov_tl([[csar]], addr); tcg_gen_mov_tl([[firelight]], val); tcg_gen_andi_tl([[qt]], cpu_PR[PR_CCS], F_FLAG_V10); tcg_gen_brcondi_tl(TCG_COND_NE, [[qt]], 0, l1); if ([[dimensions]] == 1) { tcg_gen_qemu_st8([[firelight]], [[csar]], mem_index); } else if ([[dimensions]] == 2) { tcg_gen_qemu_st16([[firelight]], [[csar]], mem_index); } else { tcg_gen_qemu_st32([[firelight]], [[csar]], mem_index); } gen_set_label(l1); tcg_gen_shri_tl([[qt]], [[qt]], 1); tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], [[qt]]); tcg_temp_free([[qt]]); tcg_temp_free([[firelight]]); tcg_temp_free([[csar]]); }
--------------------------------------------- Result 1005 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 587 / 55 / 363 / 1005:  37%|      | 1005/2690 [11:46:05<19:43:51, 42.16s/it][Succeeded / Failed / Skipped / Total] 587 / 55 / 363 / 1005:  37%|      | 1006/2690 [11:46:06<19:41:59, 42.11s/it][Succeeded / Failed / Skipped / Total] 587 / 55 / 364 / 1006:  37%|      | 1006/2690 [11:46:06<19:41:59, 42.11s/it][Succeeded / Failed / Skipped / Total] 587 / 55 / 364 / 1006:  37%|      | 1007/2690 [11:46:11<19:40:16, 42.08s/it][[0 (8%)]] --> [[0 (93%)]] --> Socre: 0.933079719543457

[[[[Adv]]]]: static BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *node, const char *name, BlockDriverState **pbs, AioContext **paio, Error **errp) { BlockDriverState *bs; BdrvDirtyBitmap *[[bitmap]]; AioContext *aio_context; if (!node) { error_setg(errp, "Node cannot be NULL"); return NULL; } if (!name) { error_setg(errp, "Bitmap name cannot be NULL"); return NULL; } bs = bdrv_lookup_bs(node, node, NULL); if (!bs) { error_setg(errp, "Node '%s' not found", node); return NULL; } aio_context = bdrv_get_aio_context(bs); aio_context_acquire(aio_context); [[bitmap]] = bdrv_find_dirty_bitmap(bs, name); if (![[bitmap]]) { error_setg(errp, "Dirty bitmap '%s' not found", name); goto fail; } if (pbs) { *pbs = bs; } if (paio) { *paio = aio_context; } else { aio_context_release(aio_context); } return [[bitmap]]; fail: aio_context_release(aio_context); return NULL; }

[[[[Adv]]]]: static BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *node, const char *name, BlockDriverState **pbs, AioContext **paio, Error **errp) { BlockDriverState *bs; BdrvDirtyBitmap *[[citt]]; AioContext *aio_context; if (!node) { error_setg(errp, "Node cannot be NULL"); return NULL; } if (!name) { error_setg(errp, "Bitmap name cannot be NULL"); return NULL; } bs = bdrv_lookup_bs(node, node, NULL); if (!bs) { error_setg(errp, "Node '%s' not found", node); return NULL; } aio_context = bdrv_get_aio_context(bs); aio_context_acquire(aio_context); [[citt]] = bdrv_find_dirty_bitmap(bs, name); if (![[citt]]) { error_setg(errp, "Dirty bitmap '%s' not found", name); goto fail; } if (pbs) { *pbs = bs; } if (paio) { *paio = aio_context; } else { aio_context_release(aio_context); } return [[citt]]; fail: aio_context_release(aio_context); return NULL; }
--------------------------------------------- Result 1006 ---------------------------------------------
[[0 (25%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ppce500_init(MachineState *machine, PPCE500Params *params) { MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); PCIBus *pci_bus; CPUPPCState *env = NULL; uint64_t loadaddr; hwaddr kernel_base = -1LL; int kernel_size = 0; hwaddr dt_base = 0; hwaddr initrd_base = 0; int initrd_size = 0; hwaddr cur_base = 0; char *filename; hwaddr bios_entry = 0; target_long bios_size; struct boot_info *boot_info; int dt_size; int i; unsigned int pci_irq_nrs[PCI_NUM_PINS] = {1, 2, 3, 4}; qemu_irq **irqs, *mpic; DeviceState *dev; CPUPPCState *firstenv = NULL; MemoryRegion *ccsr_addr_space; SysBusDevice *s; PPCE500CCSRState *ccsr; if (machine->cpu_model == NULL) { machine->cpu_model = "e500v2_v30"; } irqs = g_malloc0(smp_cpus * sizeof(qemu_irq *)); irqs[0] = g_malloc0(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB); for (i = 0; i < smp_cpus; i++) { PowerPCCPU *cpu; CPUState *cs; qemu_irq *input; cpu = cpu_ppc_init(machine->cpu_model); if (cpu == NULL) { fprintf(stderr, "Unable to initialize CPU!\n"); exit(1); } env = &cpu->env; cs = CPU(cpu); if (!firstenv) { firstenv = env; } irqs[i] = irqs[0] + (i * OPENPIC_OUTPUT_NB); input = (qemu_irq *)env->irq_inputs; irqs[i][OPENPIC_OUTPUT_INT] = input[PPCE500_INPUT_INT]; irqs[i][OPENPIC_OUTPUT_CINT] = input[PPCE500_INPUT_CINT]; env->spr_cb[SPR_BOOKE_PIR].default_value = cs->cpu_index = i; env->mpic_iack = params->ccsrbar_base + MPC8544_MPIC_REGS_OFFSET + 0xa0; ppc_booke_timers_init(cpu, 400000000, PPC_TIMER_E500); if (!i) { struct boot_info *boot_info; boot_info = g_malloc0(sizeof(struct boot_info)); qemu_register_reset(ppce500_cpu_reset, cpu); env->load_info = boot_info; } else { qemu_register_reset(ppce500_cpu_reset_sec, cpu); } } env = firstenv; ram_size &= ~(RAM_SIZES_ALIGN - 1); machine->ram_size = ram_size; memory_region_allocate_system_memory(ram, NULL, "mpc8544ds.ram", ram_size); memory_region_add_subregion(address_space_mem, 0, ram); dev = qdev_create(NULL, "e500-ccsr"); object_property_add_child(qdev_get_machine(), "e500-ccsr", OBJECT(dev), NULL); qdev_init_nofail(dev); ccsr = CCSR(dev); ccsr_addr_space = &ccsr->ccsr_space; memory_region_add_subregion(address_space_mem, params->ccsrbar_base, ccsr_addr_space); mpic = ppce500_init_mpic(params, ccsr_addr_space, irqs); if (serial_hds[0]) { serial_mm_init(ccsr_addr_space, MPC8544_SERIAL0_REGS_OFFSET, 0, mpic[42], 399193, serial_hds[0], DEVICE_BIG_ENDIAN); } if (serial_hds[1]) { serial_mm_init(ccsr_addr_space, MPC8544_SERIAL1_REGS_OFFSET, 0, mpic[42], 399193, serial_hds[1], DEVICE_BIG_ENDIAN); } dev = qdev_create(NULL, "mpc8544-guts"); qdev_init_nofail(dev); s = SYS_BUS_DEVICE(dev); memory_region_add_subregion(ccsr_addr_space, MPC8544_UTIL_OFFSET, sysbus_mmio_get_region(s, 0)); dev = qdev_create(NULL, "e500-pcihost"); qdev_prop_set_uint32(dev, "first_slot", params->pci_first_slot); qdev_prop_set_uint32(dev, "first_pin_irq", pci_irq_nrs[0]); qdev_init_nofail(dev); s = SYS_BUS_DEVICE(dev); for (i = 0; i < PCI_NUM_PINS; i++) { sysbus_connect_irq(s, i, mpic[pci_irq_nrs[i]]); } memory_region_add_subregion(ccsr_addr_space, MPC8544_PCI_REGS_OFFSET, sysbus_mmio_get_region(s, 0)); pci_bus = (PCIBus *)qdev_get_child_bus(dev, "pci.0"); if (!pci_bus) printf("couldn't create PCI controller!\n"); if (pci_bus) { for (i = 0; i < nb_nics; i++) { pci_nic_init_nofail(&nd_table[i], pci_bus, "virtio", NULL); } } sysbus_create_simple("e500-spin", params->spin_base, NULL); if (cur_base < (32 * 1024 * 1024)) { cur_base = (32 * 1024 * 1024); } if (params->has_mpc8xxx_gpio) { qemu_irq poweroff_irq; dev = qdev_create(NULL, "mpc8xxx_gpio"); s = SYS_BUS_DEVICE(dev); qdev_init_nofail(dev); sysbus_connect_irq(s, 0, mpic[MPC8XXX_GPIO_IRQ]); memory_region_add_subregion(ccsr_addr_space, MPC8XXX_GPIO_OFFSET, sysbus_mmio_get_region(s, 0)); poweroff_irq = qemu_allocate_irq(ppce500_power_off, NULL, 0); qdev_connect_gpio_out(dev, 0, poweroff_irq); } if (params->has_platform_bus) { dev = qdev_create(NULL, TYPE_PLATFORM_BUS_DEVICE); dev->id = TYPE_PLATFORM_BUS_DEVICE; qdev_prop_set_uint32(dev, "num_irqs", params->platform_bus_num_irqs); qdev_prop_set_uint32(dev, "mmio_size", params->platform_bus_size); qdev_init_nofail(dev); s = SYS_BUS_DEVICE(dev); for (i = 0; i < params->platform_bus_num_irqs; i++) { int irqn = params->platform_bus_first_irq + i; sysbus_connect_irq(s, i, mpic[irqn]); } memory_region_add_subregion(address_space_mem, params->platform_bus_base, sysbus_mmio_get_region(s, 0)); } if (machine->kernel_filename) { kernel_base = cur_base; kernel_size = load_image_targphys(machine->kernel_filename, cur_base, ram_size - cur_base); if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", machine->kernel_filename); exit(1); } cur_base += kernel_size; } if (machine->initrd_filename) { initrd_base = (cur_base + INITRD_LOAD_PAD) & ~INITRD_PAD_MASK; initrd_size = load_image_targphys(machine->initrd_filename, initrd_base, ram_size - initrd_base); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", machine->initrd_filename); exit(1); } cur_base = initrd_base + initrd_size; } if (bios_name == NULL) { if (machine->kernel_filename) { bios_name = machine->kernel_filename; } else { bios_name = "u-boot.e500"; } } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); bios_size = load_elf(filename, NULL, NULL, &bios_entry, &loadaddr, NULL, 1, ELF_MACHINE, 0); if (bios_size < 0) { kernel_size = load_uimage(filename, &bios_entry, &loadaddr, NULL, NULL, NULL); if (kernel_size < 0) { fprintf(stderr, "qemu: could not load firmware '%s'\n", filename); exit(1); } } dt_base = (loadaddr + bios_size + DTC_LOAD_PAD) & ~DTC_PAD_MASK; dt_size = ppce500_prep_device_tree(machine, params, dt_base, initrd_base, initrd_size, kernel_base, kernel_size); if (dt_size < 0) { fprintf(stderr, "couldn't load device tree\n"); exit(1); } assert(dt_size < DTB_MAX_SIZE); boot_info = env->load_info; boot_info->entry = bios_entry; boot_info->dt_base = dt_base; boot_info->dt_size = dt_size; if (kvm_enabled()) { kvmppc_init(); } }
--------------------------------------------- Result 1007 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 588 / 55 / 364 / 1007:  37%|      | 1007/2690 [11:46:11<19:40:16, 42.08s/it][Succeeded / Failed / Skipped / Total] 588 / 55 / 364 / 1007:  37%|      | 1008/2690 [11:46:12<19:38:24, 42.04s/it][Succeeded / Failed / Skipped / Total] 588 / 55 / 365 / 1008:  37%|      | 1008/2690 [11:46:12<19:38:24, 42.04s/it][Succeeded / Failed / Skipped / Total] 588 / 55 / 365 / 1008:  38%|      | 1009/2690 [11:46:15<19:36:37, 42.00s/it][Succeeded / Failed / Skipped / Total] 589 / 55 / 365 / 1009:  38%|      | 1009/2690 [11:46:15<19:36:37, 42.00s/it][Succeeded / Failed / Skipped / Total] 589 / 55 / 365 / 1009:  38%|      | 1010/2690 [11:47:54<19:37:30, 42.05s/it][Succeeded / Failed / Skipped / Total] 590 / 55 / 365 / 1010:  38%|      | 1010/2690 [11:47:54<19:37:30, 42.05s/it][Succeeded / Failed / Skipped / Total] 590 / 55 / 365 / 1010:  38%|      | 1011/2690 [11:48:00<19:35:49, 42.02s/it][[0 (58%)]] --> [[0 (50%)]] --> Socre: 0.5026029050350189

[[[[Adv]]]]: static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param) { int prefix = 0; int suffix = 0; int last_coeff_abs_level_remaining; int i; while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc)) prefix++; if (prefix < 3) { for (i = 0; i < rc_rice_param; i++) suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc); last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix; } else { int [[prefix_minus3]] = prefix - 3; if (prefix == CABAC_MAX_BIN) { av_log(s->avctx, AV_LOG_ERROR, "CABAC_MAX_BIN : %d\n", prefix); return 0; } for (i = 0; i < [[prefix_minus3]] + rc_rice_param; i++) suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc); last_coeff_abs_level_remaining = (((1 << [[prefix_minus3]]) + 3 - 1) << rc_rice_param) + suffix; } return last_coeff_abs_level_remaining; }

[[[[Adv]]]]: static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param) { int prefix = 0; int suffix = 0; int last_coeff_abs_level_remaining; int i; while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc)) prefix++; if (prefix < 3) { for (i = 0; i < rc_rice_param; i++) suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc); last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix; } else { int [[pumper]] = prefix - 3; if (prefix == CABAC_MAX_BIN) { av_log(s->avctx, AV_LOG_ERROR, "CABAC_MAX_BIN : %d\n", prefix); return 0; } for (i = 0; i < [[pumper]] + rc_rice_param; i++) suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc); last_coeff_abs_level_remaining = (((1 << [[pumper]]) + 3 - 1) << rc_rice_param) + suffix; } return last_coeff_abs_level_remaining; }
--------------------------------------------- Result 1008 ---------------------------------------------
[[0 (98%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int segment_hls_window(AVFormatContext *s, int last) { SegmentContext *seg = s->priv_data; int i, ret = 0; char buf[1024]; if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL)) < 0) goto fail; avio_printf(seg->pb, "#EXTM3U\n"); avio_printf(seg->pb, "#EXT-X-VERSION:3\n"); avio_printf(seg->pb, "#EXT-X-TARGETDURATION:%d\n", (int)seg->time); avio_printf(seg->pb, "#EXT-X-MEDIA-SEQUENCE:%d\n", FFMAX(0, seg->number - seg->size)); av_log(s, AV_LOG_VERBOSE, "EXT-X-MEDIA-SEQUENCE:%d\n", FFMAX(0, seg->number - seg->size)); for (i = FFMAX(0, seg->number - seg->size); i < seg->number; i++) { avio_printf(seg->pb, "#EXTINF:%d,\n", (int)seg->time); if (seg->entry_prefix) { avio_printf(seg->pb, "%s", seg->entry_prefix); } ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i); if (ret < 0) { ret = AVERROR(EINVAL); goto fail; } avio_printf(seg->pb, "%s\n", buf); } if (last) avio_printf(seg->pb, "#EXT-X-ENDLIST\n"); fail: avio_closep(&seg->pb); return ret; }
--------------------------------------------- Result 1009 ---------------------------------------------
[[0 (89%)]] --> [[0 (23%)]] --> Socre: 0.771958664059639

[[[[Adv]]]]: static inline int cris_addc_pi_m(int a, int **[[b]]) { asm volatile ("addc [%1+], %0\n" : "+r" (a), "+b" (*[[b]])); return a; }

[[[[Adv]]]]: static inline int cris_addc_pi_m(int a, int **[[segundo]]) { asm volatile ("addc [%1+], %0\n" : "+r" (a), "+b" (*[[segundo]])); return a; }
--------------------------------------------- Result 1010 ---------------------------------------------
[[0 (87%)]] --> [[0 (44%)]] --> Socre: 0.5581510663032532

[[[[Adv]]]]: static void vmgenid_query_monitor_test(void) { QemuUUID [[expected]], measured; gchar *[[cmd]]; g_assert(qemu_uuid_parse(VGID_GUID, &[[expected]]) == 0); [[cmd]] = g_strdup_printf("-machine accel=tcg -device vmgenid,id=testvgid," "guid=%s", VGID_GUID); qtest_start([[cmd]]); read_guid_from_monitor(&measured); g_assert(memcmp(measured.data, [[expected]].data, sizeof(measured.data)) == 0); qtest_quit(global_qtest); g_free([[cmd]]); }

[[[[Adv]]]]: static void vmgenid_query_monitor_test(void) { QemuUUID [[predictability]], measured; gchar *[[dlg]]; g_assert(qemu_uuid_parse(VGID_GUID, &[[predictability]]) == 0); [[dlg]] = g_strdup_printf("-machine accel=tcg -device vmgenid,id=testvgid," "guid=%s", VGID_GUID); qtest_start([[dlg]]); read_guid_from_monitor(&measured); g_assert(memcmp(measured.data, [[predictability]].data, sizeof(measured.data)) == 0); qtest_quit(global_qtest); g_free([[dlg]]); }
--------------------------------------------- Result 1011 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 591 / 55 / 365 / 1011:  38%|      | 1011/2690 [11:48:00<19:35:49, 42.02s/it][Succeeded / Failed / Skipped / Total] 591 / 55 / 365 / 1011:  38%|      | 1012/2690 [11:59:34<19:53:07, 42.66s/it][[0 (52%)]] --> [[0 (48%)]] --> Socre: 0.5166469216346741

[[[[Adv]]]]: static int decode_frame_byterun1(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { IffContext *s = avctx->priv_data; const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL; const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0; const uint8_t *buf_end = buf+buf_size; int [[y]], plane, res; if ((res = extract_header(avctx, avpkt)) < 0) return res; if (s->init) { if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "reget_buffer() failed\n"); return res; } } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return res; } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) { if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0) return res; } s->init = 1; if (avctx->codec_tag == MKTAG('I','L','B','M')) { if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { for([[y]] = 0; [[y]] < avctx->height ; [[y]]++ ) { uint8_t *row = &s->frame.data[0][ [[y]]*s->frame.linesize[0] ]; memset(row, 0, avctx->width); for (plane = 0; plane < s->bpp; plane++) { buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end); decodeplane8(row, s->planebuf, s->planesize, plane); } } } else if (s->ham) { for ([[y]] = 0; [[y]] < avctx->height ; [[y]]++) { uint8_t *row = &s->frame.data[0][[[y]]*s->frame.linesize[0]]; memset(s->ham_buf, 0, avctx->width); for (plane = 0; plane < s->bpp; plane++) { buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end); decodeplane8(s->ham_buf, s->planebuf, s->planesize, plane); } decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize); } } else { for([[y]] = 0; [[y]] < avctx->height ; [[y]]++ ) { uint8_t *row = &s->frame.data[0][[[y]]*s->frame.linesize[0]]; memset(row, 0, avctx->width << 2); for (plane = 0; plane < s->bpp; plane++) { buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end); decodeplane32((uint32_t *) row, s->planebuf, s->planesize, plane); } } } } else if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { for([[y]] = 0; [[y]] < avctx->height ; [[y]]++ ) { uint8_t *row = &s->frame.data[0][[[y]]*s->frame.linesize[0]]; buf += decode_byterun(row, avctx->width, buf, buf_end); } } else { for ([[y]] = 0; [[y]] < avctx->height ; [[y]]++) { uint8_t *row = &s->frame.data[0][[[y]]*s->frame.linesize[0]]; buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end); decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, avctx->width); } } *data_size = sizeof(AVFrame); *(AVFrame*)data = s->frame; return buf_size; }

[[[[Adv]]]]: static int decode_frame_byterun1(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { IffContext *s = avctx->priv_data; const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL; const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0; const uint8_t *buf_end = buf+buf_size; int [[ni]], plane, res; if ((res = extract_header(avctx, avpkt)) < 0) return res; if (s->init) { if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "reget_buffer() failed\n"); return res; } } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return res; } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) { if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0) return res; } s->init = 1; if (avctx->codec_tag == MKTAG('I','L','B','M')) { if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { for([[ni]] = 0; [[ni]] < avctx->height ; [[ni]]++ ) { uint8_t *row = &s->frame.data[0][ [[ni]]*s->frame.linesize[0] ]; memset(row, 0, avctx->width); for (plane = 0; plane < s->bpp; plane++) { buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end); decodeplane8(row, s->planebuf, s->planesize, plane); } } } else if (s->ham) { for ([[ni]] = 0; [[ni]] < avctx->height ; [[ni]]++) { uint8_t *row = &s->frame.data[0][[[ni]]*s->frame.linesize[0]]; memset(s->ham_buf, 0, avctx->width); for (plane = 0; plane < s->bpp; plane++) { buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end); decodeplane8(s->ham_buf, s->planebuf, s->planesize, plane); } decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize); } } else { for([[ni]] = 0; [[ni]] < avctx->height ; [[ni]]++ ) { uint8_t *row = &s->frame.data[0][[[ni]]*s->frame.linesize[0]]; memset(row, 0, avctx->width << 2); for (plane = 0; plane < s->bpp; plane++) { buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end); decodeplane32((uint32_t *) row, s->planebuf, s->planesize, plane); } } } } else if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { for([[ni]] = 0; [[ni]] < avctx->height ; [[ni]]++ ) { uint8_t *row = &s->frame.data[0][[[ni]]*s->frame.linesize[0]]; buf += decode_byterun(row, avctx->width, buf, buf_end); } } else { for ([[ni]] = 0; [[ni]] < avctx->height ; [[ni]]++) { uint8_t *row = &s->frame.data[0][[[ni]]*s->frame.linesize[0]]; buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end); decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, avctx->width); } } *data_size = sizeof(AVFrame); *(AVFrame*)data = s->frame; return buf_size; }
--------------------------------------------- Result 1012 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 592 / 55 / 365 / 1012:  38%|      | 1012/2690 [11:59:34<19:53:07, 42.66s/it][Succeeded / Failed / Skipped / Total] 592 / 55 / 365 / 1012:  38%|      | 1013/2690 [12:04:01<19:58:35, 42.88s/it][[0 (82%)]] --> [[0 (40%)]] --> Socre: 0.596832811832428

[[[[Adv]]]]: int alloc_picture(MpegEncContext *[[s]], Picture *pic, int [[shared]]){ const int big_mb_num= [[s]]->mb_stride*([[s]]->mb_height+1) + 1; const int mb_array_size= [[s]]->mb_stride*[[s]]->mb_height; const int b8_array_size= [[s]]->b8_stride*[[s]]->mb_height*2; const int b4_array_size= [[s]]->b4_stride*[[s]]->mb_height*4; int i; if([[shared]]){ assert(pic->data[0]); assert(pic->type == 0 || pic->type == FF_BUFFER_TYPE_SHARED); pic->type= FF_BUFFER_TYPE_SHARED; }else{ int r; assert(!pic->data[0]); r= [[s]]->avctx->get_buffer([[s]]->avctx, (AVFrame*)pic); if(r<0 || !pic->age || !pic->type || !pic->data[0]){ av_log([[s]]->avctx, AV_LOG_ERROR, "get_buffer() failed (%d %d %d %p)\n", r, pic->age, pic->type, pic->data[0]); return -1; } if([[s]]->linesize && ([[s]]->linesize != pic->linesize[0] || [[s]]->uvlinesize != pic->linesize[1])){ av_log([[s]]->avctx, AV_LOG_ERROR, "get_buffer() failed (stride changed)\n"); return -1; } if(pic->linesize[1] != pic->linesize[2]){ av_log([[s]]->avctx, AV_LOG_ERROR, "get_buffer() failed (uv stride mismatch)\n"); return -1; } [[s]]->linesize = pic->linesize[0]; [[s]]->uvlinesize= pic->linesize[1]; } if(pic->qscale_table==NULL){ if ([[s]]->encoding) { CHECKED_ALLOCZ(pic->mb_var , mb_array_size * sizeof(int16_t)) CHECKED_ALLOCZ(pic->mc_mb_var, mb_array_size * sizeof(int16_t)) CHECKED_ALLOCZ(pic->mb_mean , mb_array_size * sizeof(int8_t)) } CHECKED_ALLOCZ(pic->mbskip_table , mb_array_size * sizeof(uint8_t)+2) CHECKED_ALLOCZ(pic->qscale_table , mb_array_size * sizeof(uint8_t)) CHECKED_ALLOCZ(pic->mb_type_base , big_mb_num * sizeof(uint32_t)) pic->mb_type= pic->mb_type_base + [[s]]->mb_stride+1; if([[s]]->out_format == FMT_H264){ for(i=0; i<2; i++){ CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b4_array_size+4) * sizeof(int16_t)) pic->motion_val[i]= pic->motion_val_base[i]+4; CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t)) } pic->motion_subsample_log2= 2; }else if([[s]]->out_format == FMT_H263 || [[s]]->encoding || ([[s]]->avctx->debug&FF_DEBUG_MV) || ([[s]]->avctx->debug_mv)){ for(i=0; i<2; i++){ CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b8_array_size+4) * sizeof(int16_t)) pic->motion_val[i]= pic->motion_val_base[i]+4; CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t)) } pic->motion_subsample_log2= 3; } if([[s]]->avctx->debug&FF_DEBUG_DCT_COEFF) { CHECKED_ALLOCZ(pic->dct_coeff, 64 * mb_array_size * sizeof(DCTELEM)*6) } pic->qstride= [[s]]->mb_stride; CHECKED_ALLOCZ(pic->pan_scan , 1 * sizeof(AVPanScan)) } memmove([[s]]->prev_pict_types+1, [[s]]->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE-1); [[s]]->prev_pict_types[0]= [[s]]->pict_type; if(pic->age < PREV_PICT_TYPES_BUFFER_SIZE && [[s]]->prev_pict_types[pic->age] == B_TYPE) pic->age= INT_MAX; return 0; fail: return -1; }

[[[[Adv]]]]: int alloc_picture(MpegEncContext *[[nth]], Picture *pic, int [[pooling]]){ const int big_mb_num= [[nth]]->mb_stride*([[nth]]->mb_height+1) + 1; const int mb_array_size= [[nth]]->mb_stride*[[nth]]->mb_height; const int b8_array_size= [[nth]]->b8_stride*[[nth]]->mb_height*2; const int b4_array_size= [[nth]]->b4_stride*[[nth]]->mb_height*4; int i; if([[pooling]]){ assert(pic->data[0]); assert(pic->type == 0 || pic->type == FF_BUFFER_TYPE_SHARED); pic->type= FF_BUFFER_TYPE_SHARED; }else{ int r; assert(!pic->data[0]); r= [[nth]]->avctx->get_buffer([[nth]]->avctx, (AVFrame*)pic); if(r<0 || !pic->age || !pic->type || !pic->data[0]){ av_log([[nth]]->avctx, AV_LOG_ERROR, "get_buffer() failed (%d %d %d %p)\n", r, pic->age, pic->type, pic->data[0]); return -1; } if([[nth]]->linesize && ([[nth]]->linesize != pic->linesize[0] || [[nth]]->uvlinesize != pic->linesize[1])){ av_log([[nth]]->avctx, AV_LOG_ERROR, "get_buffer() failed (stride changed)\n"); return -1; } if(pic->linesize[1] != pic->linesize[2]){ av_log([[nth]]->avctx, AV_LOG_ERROR, "get_buffer() failed (uv stride mismatch)\n"); return -1; } [[nth]]->linesize = pic->linesize[0]; [[nth]]->uvlinesize= pic->linesize[1]; } if(pic->qscale_table==NULL){ if ([[nth]]->encoding) { CHECKED_ALLOCZ(pic->mb_var , mb_array_size * sizeof(int16_t)) CHECKED_ALLOCZ(pic->mc_mb_var, mb_array_size * sizeof(int16_t)) CHECKED_ALLOCZ(pic->mb_mean , mb_array_size * sizeof(int8_t)) } CHECKED_ALLOCZ(pic->mbskip_table , mb_array_size * sizeof(uint8_t)+2) CHECKED_ALLOCZ(pic->qscale_table , mb_array_size * sizeof(uint8_t)) CHECKED_ALLOCZ(pic->mb_type_base , big_mb_num * sizeof(uint32_t)) pic->mb_type= pic->mb_type_base + [[nth]]->mb_stride+1; if([[nth]]->out_format == FMT_H264){ for(i=0; i<2; i++){ CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b4_array_size+4) * sizeof(int16_t)) pic->motion_val[i]= pic->motion_val_base[i]+4; CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t)) } pic->motion_subsample_log2= 2; }else if([[nth]]->out_format == FMT_H263 || [[nth]]->encoding || ([[nth]]->avctx->debug&FF_DEBUG_MV) || ([[nth]]->avctx->debug_mv)){ for(i=0; i<2; i++){ CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b8_array_size+4) * sizeof(int16_t)) pic->motion_val[i]= pic->motion_val_base[i]+4; CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t)) } pic->motion_subsample_log2= 3; } if([[nth]]->avctx->debug&FF_DEBUG_DCT_COEFF) { CHECKED_ALLOCZ(pic->dct_coeff, 64 * mb_array_size * sizeof(DCTELEM)*6) } pic->qstride= [[nth]]->mb_stride; CHECKED_ALLOCZ(pic->pan_scan , 1 * sizeof(AVPanScan)) } memmove([[nth]]->prev_pict_types+1, [[nth]]->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE-1); [[nth]]->prev_pict_types[0]= [[nth]]->pict_type; if(pic->age < PREV_PICT_TYPES_BUFFER_SIZE && [[nth]]->prev_pict_types[pic->age] == B_TYPE) pic->age= INT_MAX; return 0; fail: return -1; }
--------------------------------------------- Result 1013 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 592 / 56 / 365 / 1013:  38%|      | 1013/2690 [12:04:01<19:58:35, 42.88s/it][Succeeded / Failed / Skipped / Total] 592 / 56 / 365 / 1013:  38%|      | 1014/2690 [12:04:05<19:56:49, 42.85s/it][[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int nut_read_header(AVFormatContext * avf, AVFormatParameters * ap) { NUTContext * priv = avf->priv_data; AVIOContext * bc = avf->pb; nut_demuxer_opts_tt dopts = { .input = { .priv = bc, .seek = av_seek, .read = av_read, .eof = NULL, .file_pos = 0, }, .alloc = { av_malloc, av_realloc, av_free }, .read_index = 1, .cache_syncpoints = 1, }; nut_context_tt * nut = priv->nut = nut_demuxer_init(&dopts); nut_stream_header_tt * s; int ret, i; if ((ret = nut_read_headers(nut, &s, NULL))) { av_log(avf, AV_LOG_ERROR, " NUT error: %s\n", nut_error(ret)); return -1; priv->s = s; for (i = 0; s[i].type != -1 && i < 2; i++) { AVStream * st = avformat_new_stream(avf, NULL); int j; for (j = 0; j < s[i].fourcc_len && j < 8; j++) st->codec->codec_tag |= s[i].fourcc[j]<<(j*8); st->codec->has_b_frames = s[i].decode_delay; st->codec->extradata_size = s[i].codec_specific_len; if (st->codec->extradata_size) { st->codec->extradata = av_mallocz(st->codec->extradata_size); memcpy(st->codec->extradata, s[i].codec_specific, st->codec->extradata_size); avpriv_set_pts_info(avf->streams[i], 60, s[i].time_base.num, s[i].time_base.den); st->start_time = 0; st->duration = s[i].max_pts; st->codec->codec_id = ff_codec_get_id(nut_tags, st->codec->codec_tag); switch(s[i].type) { case NUT_AUDIO_CLASS: st->codec->codec_type = AVMEDIA_TYPE_AUDIO; if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_wav_tags, st->codec->codec_tag); st->codec->channels = s[i].channel_count; st->codec->sample_rate = s[i].samplerate_num / s[i].samplerate_denom; break; case NUT_VIDEO_CLASS: st->codec->codec_type = AVMEDIA_TYPE_VIDEO; if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_bmp_tags, st->codec->codec_tag); st->codec->width = s[i].width; st->codec->height = s[i].height; st->sample_aspect_ratio.num = s[i].sample_width; st->sample_aspect_ratio.den = s[i].sample_height; break; if (st->codec->codec_id == CODEC_ID_NONE) av_log(avf, AV_LOG_ERROR, "Unknown codec?!\n"); return 0;

[[[[Adv]]]]: static int nut_read_header(AVFormatContext * avf, AVFormatParameters * ap) { NUTContext * priv = avf->priv_data; AVIOContext * bc = avf->pb; nut_demuxer_opts_tt dopts = { .input = { .priv = bc, .seek = av_seek, .read = av_read, .eof = NULL, .file_pos = 0, }, .alloc = { av_malloc, av_realloc, av_free }, .read_index = 1, .cache_syncpoints = 1, }; nut_context_tt * nut = priv->nut = nut_demuxer_init(&dopts); nut_stream_header_tt * s; int ret, i; if ((ret = nut_read_headers(nut, &s, NULL))) { av_log(avf, AV_LOG_ERROR, " NUT error: %s\n", nut_error(ret)); return -1; priv->s = s; for (i = 0; s[i].type != -1 && i < 2; i++) { AVStream * st = avformat_new_stream(avf, NULL); int j; for (j = 0; j < s[i].fourcc_len && j < 8; j++) st->codec->codec_tag |= s[i].fourcc[j]<<(j*8); st->codec->has_b_frames = s[i].decode_delay; st->codec->extradata_size = s[i].codec_specific_len; if (st->codec->extradata_size) { st->codec->extradata = av_mallocz(st->codec->extradata_size); memcpy(st->codec->extradata, s[i].codec_specific, st->codec->extradata_size); avpriv_set_pts_info(avf->streams[i], 60, s[i].time_base.num, s[i].time_base.den); st->start_time = 0; st->duration = s[i].max_pts; st->codec->codec_id = ff_codec_get_id(nut_tags, st->codec->codec_tag); switch(s[i].type) { case NUT_AUDIO_CLASS: st->codec->codec_type = AVMEDIA_TYPE_AUDIO; if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_wav_tags, st->codec->codec_tag); st->codec->channels = s[i].channel_count; st->codec->sample_rate = s[i].samplerate_num / s[i].samplerate_denom; break; case NUT_VIDEO_CLASS: st->codec->codec_type = AVMEDIA_TYPE_VIDEO; if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_bmp_tags, st->codec->codec_tag); st->codec->width = s[i].width; st->codec->height = s[i].height; st->sample_aspect_ratio.num = s[i].sample_width; st->sample_aspect_ratio.den = s[i].sample_height; break; if (st->codec->codec_id == CODEC_ID_NONE) av_log(avf, AV_LOG_ERROR, "Unknown codec?!\n"); return 0;
--------------------------------------------- Result 1014 ---------------------------------------------
[[0 (51%)]] --> [[0 (48%)]] --> Socre: 0.5228142738342285

[[[[Adv]]]]: static int mpegts_write_header(AVFormatContext *s) { MpegTSWrite *ts = s->priv_data; MpegTSWriteStream *ts_st; MpegTSService *service; AVStream *st, *pcr_st = NULL; AVDictionaryEntry *[[title]], *provider; int i, j; const char *service_name; const char *provider_name; int *pids; int ret; if (s->max_delay < 0) s->max_delay = 0; ts->pes_payload_size = (ts->pes_payload_size + 14 + 183) / 184 * 184 - 14; ts->tsid = ts->transport_stream_id; ts->onid = ts->original_network_id; [[title]] = av_dict_get(s->metadata, "service_name", NULL, 0); if (![[title]]) [[title]] = av_dict_get(s->metadata, "title", NULL, 0); service_name = [[title]] ? [[title]]->value : DEFAULT_SERVICE_NAME; provider = av_dict_get(s->metadata, "service_provider", NULL, 0); provider_name = provider ? provider->value : DEFAULT_PROVIDER_NAME; service = mpegts_add_service(ts, ts->service_id, provider_name, service_name); if (!service) return AVERROR(ENOMEM); service->pmt.write_packet = section_write_packet; service->pmt.opaque = s; service->pmt.cc = 15; ts->pat.pid = PAT_PID; ts->pat.cc = 15; ts->pat.write_packet = section_write_packet; ts->pat.opaque = s; ts->sdt.pid = SDT_PID; ts->sdt.cc = 15; ts->sdt.write_packet = section_write_packet; ts->sdt.opaque = s; pids = av_malloc_array(s->nb_streams, sizeof(*pids)); if (!pids) { ret = AVERROR(ENOMEM); goto fail; } for (i = 0; i < s->nb_streams; i++) { st = s->streams[i]; ts_st = av_mallocz(sizeof(MpegTSWriteStream)); if (!ts_st) { ret = AVERROR(ENOMEM); goto fail; } st->priv_data = ts_st; ts_st->user_tb = st->time_base; avpriv_set_pts_info(st, 33, 1, 90000); ts_st->payload = av_mallocz(ts->pes_payload_size); if (!ts_st->payload) { ret = AVERROR(ENOMEM); goto fail; } ts_st->service = service; if (st->id < 16) { ts_st->pid = ts->start_pid + i; } else if (st->id < 0x1FFF) { ts_st->pid = st->id; } else { av_log(s, AV_LOG_ERROR, "Invalid stream id %d, must be less than 8191\n", st->id); ret = AVERROR(EINVAL); goto fail; } if (ts_st->pid == service->pmt.pid) { av_log(s, AV_LOG_ERROR, "Duplicate stream id %d\n", ts_st->pid); ret = AVERROR(EINVAL); goto fail; } for (j = 0; j < i; j++) { if (pids[j] == ts_st->pid) { av_log(s, AV_LOG_ERROR, "Duplicate stream id %d\n", ts_st->pid); ret = AVERROR(EINVAL); goto fail; } } pids[i] = ts_st->pid; ts_st->payload_pts = AV_NOPTS_VALUE; ts_st->payload_dts = AV_NOPTS_VALUE; ts_st->first_pts_check = 1; ts_st->cc = 15; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO && service->pcr_pid == 0x1fff) { service->pcr_pid = ts_st->pid; pcr_st = st; } if (st->codec->codec_id == AV_CODEC_ID_AAC && st->codec->extradata_size > 0) { AVStream *ast; ts_st->amux = avformat_alloc_context(); if (!ts_st->amux) { ret = AVERROR(ENOMEM); goto fail; } ts_st->amux->oformat = av_guess_format((ts->flags & MPEGTS_FLAG_AAC_LATM) ? "latm" : "adts", NULL, NULL); if (!ts_st->amux->oformat) { ret = AVERROR(EINVAL); goto fail; } if (!(ast = avformat_new_stream(ts_st->amux, NULL))) { ret = AVERROR(ENOMEM); goto fail; } ret = avcodec_copy_context(ast->codec, st->codec); if (ret != 0) goto fail; ast->time_base = st->time_base; ret = avformat_write_header(ts_st->amux, NULL); if (ret < 0) goto fail; } if (st->codec->codec_id == AV_CODEC_ID_OPUS) { ts_st->opus_pending_trim_start = st->codec->initial_padding * 48000 / st->codec->sample_rate; } } av_freep(&pids); if (service->pcr_pid == 0x1fff && s->nb_streams > 0) { pcr_st = s->streams[0]; ts_st = pcr_st->priv_data; service->pcr_pid = ts_st->pid; } else ts_st = pcr_st->priv_data; if (ts->mux_rate > 1) { service->pcr_packet_period = (ts->mux_rate * ts->pcr_period) / (TS_PACKET_SIZE * 8 * 1000); ts->sdt_packet_period = (ts->mux_rate * SDT_RETRANS_TIME) / (TS_PACKET_SIZE * 8 * 1000); ts->pat_packet_period = (ts->mux_rate * PAT_RETRANS_TIME) / (TS_PACKET_SIZE * 8 * 1000); if (ts->copyts < 1) ts->first_pcr = av_rescale(s->max_delay, PCR_TIME_BASE, AV_TIME_BASE); } else { ts->sdt_packet_period = 200; ts->pat_packet_period = 40; if (pcr_st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if (!pcr_st->codec->frame_size) { av_log(s, AV_LOG_WARNING, "frame size not set\n"); service->pcr_packet_period = pcr_st->codec->sample_rate / (10 * 512); } else { service->pcr_packet_period = pcr_st->codec->sample_rate / (10 * pcr_st->codec->frame_size); } } else { service->pcr_packet_period = ts_st->user_tb.den / (10 * ts_st->user_tb.num); } if (!service->pcr_packet_period) service->pcr_packet_period = 1; } ts->last_pat_ts = AV_NOPTS_VALUE; ts->last_sdt_ts = AV_NOPTS_VALUE; if (ts->pat_period < INT_MAX/2) { ts->pat_packet_period = INT_MAX; } if (ts->sdt_period < INT_MAX/2) { ts->sdt_packet_period = INT_MAX; } service->pcr_packet_count = service->pcr_packet_period; ts->pat_packet_count = ts->pat_packet_period - 1; ts->sdt_packet_count = ts->sdt_packet_period - 1; if (ts->mux_rate == 1) av_log(s, AV_LOG_VERBOSE, "muxrate VBR, "); else av_log(s, AV_LOG_VERBOSE, "muxrate %d, ", ts->mux_rate); av_log(s, AV_LOG_VERBOSE, "pcr every %d pkts, sdt every %d, pat/pmt every %d pkts\n", service->pcr_packet_period, ts->sdt_packet_period, ts->pat_packet_period); if (ts->m2ts_mode == -1) { if (av_match_ext(s->filename, "m2ts")) { ts->m2ts_mode = 1; } else { ts->m2ts_mode = 0; } } return 0; fail: av_freep(&pids); for (i = 0; i < s->nb_streams; i++) { st = s->streams[i]; ts_st = st->priv_data; if (ts_st) { av_freep(&ts_st->payload); if (ts_st->amux) { avformat_free_context(ts_st->amux); ts_st->amux = NULL; } } av_freep(&st->priv_data); } for (i = 0; i < ts->nb_services; i++) { service = ts->services[i]; av_freep(&service->provider_name); av_freep(&service->name); av_freep(&service); } av_freep(&ts->services); return ret; }

[[[[Adv]]]]: static int mpegts_write_header(AVFormatContext *s) { MpegTSWrite *ts = s->priv_data; MpegTSWriteStream *ts_st; MpegTSService *service; AVStream *st, *pcr_st = NULL; AVDictionaryEntry *[[noun]], *provider; int i, j; const char *service_name; const char *provider_name; int *pids; int ret; if (s->max_delay < 0) s->max_delay = 0; ts->pes_payload_size = (ts->pes_payload_size + 14 + 183) / 184 * 184 - 14; ts->tsid = ts->transport_stream_id; ts->onid = ts->original_network_id; [[noun]] = av_dict_get(s->metadata, "service_name", NULL, 0); if (![[noun]]) [[noun]] = av_dict_get(s->metadata, "title", NULL, 0); service_name = [[noun]] ? [[noun]]->value : DEFAULT_SERVICE_NAME; provider = av_dict_get(s->metadata, "service_provider", NULL, 0); provider_name = provider ? provider->value : DEFAULT_PROVIDER_NAME; service = mpegts_add_service(ts, ts->service_id, provider_name, service_name); if (!service) return AVERROR(ENOMEM); service->pmt.write_packet = section_write_packet; service->pmt.opaque = s; service->pmt.cc = 15; ts->pat.pid = PAT_PID; ts->pat.cc = 15; ts->pat.write_packet = section_write_packet; ts->pat.opaque = s; ts->sdt.pid = SDT_PID; ts->sdt.cc = 15; ts->sdt.write_packet = section_write_packet; ts->sdt.opaque = s; pids = av_malloc_array(s->nb_streams, sizeof(*pids)); if (!pids) { ret = AVERROR(ENOMEM); goto fail; } for (i = 0; i < s->nb_streams; i++) { st = s->streams[i]; ts_st = av_mallocz(sizeof(MpegTSWriteStream)); if (!ts_st) { ret = AVERROR(ENOMEM); goto fail; } st->priv_data = ts_st; ts_st->user_tb = st->time_base; avpriv_set_pts_info(st, 33, 1, 90000); ts_st->payload = av_mallocz(ts->pes_payload_size); if (!ts_st->payload) { ret = AVERROR(ENOMEM); goto fail; } ts_st->service = service; if (st->id < 16) { ts_st->pid = ts->start_pid + i; } else if (st->id < 0x1FFF) { ts_st->pid = st->id; } else { av_log(s, AV_LOG_ERROR, "Invalid stream id %d, must be less than 8191\n", st->id); ret = AVERROR(EINVAL); goto fail; } if (ts_st->pid == service->pmt.pid) { av_log(s, AV_LOG_ERROR, "Duplicate stream id %d\n", ts_st->pid); ret = AVERROR(EINVAL); goto fail; } for (j = 0; j < i; j++) { if (pids[j] == ts_st->pid) { av_log(s, AV_LOG_ERROR, "Duplicate stream id %d\n", ts_st->pid); ret = AVERROR(EINVAL); goto fail; } } pids[i] = ts_st->pid; ts_st->payload_pts = AV_NOPTS_VALUE; ts_st->payload_dts = AV_NOPTS_VALUE; ts_st->first_pts_check = 1; ts_st->cc = 15; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO && service->pcr_pid == 0x1fff) { service->pcr_pid = ts_st->pid; pcr_st = st; } if (st->codec->codec_id == AV_CODEC_ID_AAC && st->codec->extradata_size > 0) { AVStream *ast; ts_st->amux = avformat_alloc_context(); if (!ts_st->amux) { ret = AVERROR(ENOMEM); goto fail; } ts_st->amux->oformat = av_guess_format((ts->flags & MPEGTS_FLAG_AAC_LATM) ? "latm" : "adts", NULL, NULL); if (!ts_st->amux->oformat) { ret = AVERROR(EINVAL); goto fail; } if (!(ast = avformat_new_stream(ts_st->amux, NULL))) { ret = AVERROR(ENOMEM); goto fail; } ret = avcodec_copy_context(ast->codec, st->codec); if (ret != 0) goto fail; ast->time_base = st->time_base; ret = avformat_write_header(ts_st->amux, NULL); if (ret < 0) goto fail; } if (st->codec->codec_id == AV_CODEC_ID_OPUS) { ts_st->opus_pending_trim_start = st->codec->initial_padding * 48000 / st->codec->sample_rate; } } av_freep(&pids); if (service->pcr_pid == 0x1fff && s->nb_streams > 0) { pcr_st = s->streams[0]; ts_st = pcr_st->priv_data; service->pcr_pid = ts_st->pid; } else ts_st = pcr_st->priv_data; if (ts->mux_rate > 1) { service->pcr_packet_period = (ts->mux_rate * ts->pcr_period) / (TS_PACKET_SIZE * 8 * 1000); ts->sdt_packet_period = (ts->mux_rate * SDT_RETRANS_TIME) / (TS_PACKET_SIZE * 8 * 1000); ts->pat_packet_period = (ts->mux_rate * PAT_RETRANS_TIME) / (TS_PACKET_SIZE * 8 * 1000); if (ts->copyts < 1) ts->first_pcr = av_rescale(s->max_delay, PCR_TIME_BASE, AV_TIME_BASE); } else { ts->sdt_packet_period = 200; ts->pat_packet_period = 40; if (pcr_st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if (!pcr_st->codec->frame_size) { av_log(s, AV_LOG_WARNING, "frame size not set\n"); service->pcr_packet_period = pcr_st->codec->sample_rate / (10 * 512); } else { service->pcr_packet_period = pcr_st->codec->sample_rate / (10 * pcr_st->codec->frame_size); } } else { service->pcr_packet_period = ts_st->user_tb.den / (10 * ts_st->user_tb.num); } if (!service->pcr_packet_period) service->pcr_packet_period = 1; } ts->last_pat_ts = AV_NOPTS_VALUE; ts->last_sdt_ts = AV_NOPTS_VALUE; if (ts->pat_period < INT_MAX/2) { ts->pat_packet_period = INT_MAX; } if (ts->sdt_period < INT_MAX/2) { ts->sdt_packet_period = INT_MAX; } service->pcr_packet_count = service->pcr_packet_period; ts->pat_packet_count = ts->pat_packet_period - 1; ts->sdt_packet_count = ts->sdt_packet_period - 1; if (ts->mux_rate == 1) av_log(s, AV_LOG_VERBOSE, "muxrate VBR, "); else av_log(s, AV_LOG_VERBOSE, "muxrate %d, ", ts->mux_rate); av_log(s, AV_LOG_VERBOSE, "pcr every %d pkts, sdt every %d, pat/pmt every %d pkts\n", service->pcr_packet_period, ts->sdt_packet_period, ts->pat_packet_period); if (ts->m2ts_mode == -1) { if (av_match_ext(s->filename, "m2ts")) { ts->m2ts_mode = 1; } else { ts->m2ts_mode = 0; } } return 0; fail: av_freep(&pids); for (i = 0; i < s->nb_streams; i++) { st = s->streams[i]; ts_st = st->priv_data; if (ts_st) { av_freep(&ts_st->payload); if (ts_st->amux) { avformat_free_context(ts_st->amux); ts_st->amux = NULL; } } av_freep(&st->priv_data); } for (i = 0; i < ts->nb_services; i++) { service = ts->services[i]; av_freep(&service->provider_name); av_freep(&service->name); av_freep(&service); } av_freep(&ts->services); return ret; }[Succeeded / Failed / Skipped / Total] 593 / 56 / 365 / 1014:  38%|      | 1014/2690 [12:04:05<19:56:49, 42.85s/it][Succeeded / Failed / Skipped / Total] 593 / 56 / 365 / 1014:  38%|      | 1015/2690 [12:04:09<19:55:02, 42.81s/it][Succeeded / Failed / Skipped / Total] 594 / 56 / 365 / 1015:  38%|      | 1015/2690 [12:04:09<19:55:02, 42.81s/it][Succeeded / Failed / Skipped / Total] 594 / 56 / 365 / 1015:  38%|      | 1016/2690 [12:05:12<19:54:53, 42.83s/it][Succeeded / Failed / Skipped / Total] 595 / 56 / 365 / 1016:  38%|      | 1016/2690 [12:05:12<19:54:53, 42.83s/it][Succeeded / Failed / Skipped / Total] 595 / 56 / 365 / 1016:  38%|      | 1017/2690 [12:05:16<19:53:05, 42.79s/it][Succeeded / Failed / Skipped / Total] 596 / 56 / 365 / 1017:  38%|      | 1017/2690 [12:05:16<19:53:05, 42.79s/it][Succeeded / Failed / Skipped / Total] 596 / 56 / 365 / 1017:  38%|      | 1018/2690 [12:10:41<20:00:06, 43.07s/it]
--------------------------------------------- Result 1015 ---------------------------------------------
[[0 (94%)]] --> [[0 (13%)]] --> Socre: 0.8720417022705078

[[[[Adv]]]]: void dct32(INTFLOAT *out, const INTFLOAT *tab) { INTFLOAT tmp0, tmp1; INTFLOAT [[val0]] , val1 , val2 , val3 , val4 , val5 , val6 , val7 , val8 , val9 , val10, val11, val12, val13, val14, val15, val16, val17, val18, val19, val20, val21, val22, val23, val24, val25, val26, val27, val28, val29, val30, val31; BF0( 0, 31, COS0_0 , 1); BF0(15, 16, COS0_15, 5); BF( 0, 15, COS1_0 , 1); BF(16, 31,-COS1_0 , 1); BF0( 7, 24, COS0_7 , 1); BF0( 8, 23, COS0_8 , 1); BF( 7, 8, COS1_7 , 4); BF(23, 24,-COS1_7 , 4); BF( 0, 7, COS2_0 , 1); BF( 8, 15,-COS2_0 , 1); BF(16, 23, COS2_0 , 1); BF(24, 31,-COS2_0 , 1); BF0( 3, 28, COS0_3 , 1); BF0(12, 19, COS0_12, 2); BF( 3, 12, COS1_3 , 1); BF(19, 28,-COS1_3 , 1); BF0( 4, 27, COS0_4 , 1); BF0(11, 20, COS0_11, 2); BF( 4, 11, COS1_4 , 1); BF(20, 27,-COS1_4 , 1); BF( 3, 4, COS2_3 , 3); BF(11, 12,-COS2_3 , 3); BF(19, 20, COS2_3 , 3); BF(27, 28,-COS2_3 , 3); BF( 0, 3, COS3_0 , 1); BF( 4, 7,-COS3_0 , 1); BF( 8, 11, COS3_0 , 1); BF(12, 15,-COS3_0 , 1); BF(16, 19, COS3_0 , 1); BF(20, 23,-COS3_0 , 1); BF(24, 27, COS3_0 , 1); BF(28, 31,-COS3_0 , 1); BF0( 1, 30, COS0_1 , 1); BF0(14, 17, COS0_14, 3); BF( 1, 14, COS1_1 , 1); BF(17, 30,-COS1_1 , 1); BF0( 6, 25, COS0_6 , 1); BF0( 9, 22, COS0_9 , 1); BF( 6, 9, COS1_6 , 2); BF(22, 25,-COS1_6 , 2); BF( 1, 6, COS2_1 , 1); BF( 9, 14,-COS2_1 , 1); BF(17, 22, COS2_1 , 1); BF(25, 30,-COS2_1 , 1); BF0( 2, 29, COS0_2 , 1); BF0(13, 18, COS0_13, 3); BF( 2, 13, COS1_2 , 1); BF(18, 29,-COS1_2 , 1); BF0( 5, 26, COS0_5 , 1); BF0(10, 21, COS0_10, 1); BF( 5, 10, COS1_5 , 2); BF(21, 26,-COS1_5 , 2); BF( 2, 5, COS2_2 , 1); BF(10, 13,-COS2_2 , 1); BF(18, 21, COS2_2 , 1); BF(26, 29,-COS2_2 , 1); BF( 1, 2, COS3_1 , 2); BF( 5, 6,-COS3_1 , 2); BF( 9, 10, COS3_1 , 2); BF(13, 14,-COS3_1 , 2); BF(17, 18, COS3_1 , 2); BF(21, 22,-COS3_1 , 2); BF(25, 26, COS3_1 , 2); BF(29, 30,-COS3_1 , 2); BF1( 0, 1, 2, 3); BF2( 4, 5, 6, 7); BF1( 8, 9, 10, 11); BF2(12, 13, 14, 15); BF1(16, 17, 18, 19); BF2(20, 21, 22, 23); BF1(24, 25, 26, 27); BF2(28, 29, 30, 31); ADD( 8, 12); ADD(12, 10); ADD(10, 14); ADD(14, 9); ADD( 9, 13); ADD(13, 11); ADD(11, 15); out[ 0] = [[val0]]; out[16] = val1; out[ 8] = val2; out[24] = val3; out[ 4] = val4; out[20] = val5; out[12] = val6; out[28] = val7; out[ 2] = val8; out[18] = val9; out[10] = val10; out[26] = val11; out[ 6] = val12; out[22] = val13; out[14] = val14; out[30] = val15; ADD(24, 28); ADD(28, 26); ADD(26, 30); ADD(30, 25); ADD(25, 29); ADD(29, 27); ADD(27, 31); out[ 1] = val16 + val24; out[17] = val17 + val25; out[ 9] = val18 + val26; out[25] = val19 + val27; out[ 5] = val20 + val28; out[21] = val21 + val29; out[13] = val22 + val30; out[29] = val23 + val31; out[ 3] = val24 + val20; out[19] = val25 + val21; out[11] = val26 + val22; out[27] = val27 + val23; out[ 7] = val28 + val18; out[23] = val29 + val19; out[15] = val30 + val17; out[31] = val31; }

[[[[Adv]]]]: void dct32(INTFLOAT *out, const INTFLOAT *tab) { INTFLOAT tmp0, tmp1; INTFLOAT [[fredy]] , val1 , val2 , val3 , val4 , val5 , val6 , val7 , val8 , val9 , val10, val11, val12, val13, val14, val15, val16, val17, val18, val19, val20, val21, val22, val23, val24, val25, val26, val27, val28, val29, val30, val31; BF0( 0, 31, COS0_0 , 1); BF0(15, 16, COS0_15, 5); BF( 0, 15, COS1_0 , 1); BF(16, 31,-COS1_0 , 1); BF0( 7, 24, COS0_7 , 1); BF0( 8, 23, COS0_8 , 1); BF( 7, 8, COS1_7 , 4); BF(23, 24,-COS1_7 , 4); BF( 0, 7, COS2_0 , 1); BF( 8, 15,-COS2_0 , 1); BF(16, 23, COS2_0 , 1); BF(24, 31,-COS2_0 , 1); BF0( 3, 28, COS0_3 , 1); BF0(12, 19, COS0_12, 2); BF( 3, 12, COS1_3 , 1); BF(19, 28,-COS1_3 , 1); BF0( 4, 27, COS0_4 , 1); BF0(11, 20, COS0_11, 2); BF( 4, 11, COS1_4 , 1); BF(20, 27,-COS1_4 , 1); BF( 3, 4, COS2_3 , 3); BF(11, 12,-COS2_3 , 3); BF(19, 20, COS2_3 , 3); BF(27, 28,-COS2_3 , 3); BF( 0, 3, COS3_0 , 1); BF( 4, 7,-COS3_0 , 1); BF( 8, 11, COS3_0 , 1); BF(12, 15,-COS3_0 , 1); BF(16, 19, COS3_0 , 1); BF(20, 23,-COS3_0 , 1); BF(24, 27, COS3_0 , 1); BF(28, 31,-COS3_0 , 1); BF0( 1, 30, COS0_1 , 1); BF0(14, 17, COS0_14, 3); BF( 1, 14, COS1_1 , 1); BF(17, 30,-COS1_1 , 1); BF0( 6, 25, COS0_6 , 1); BF0( 9, 22, COS0_9 , 1); BF( 6, 9, COS1_6 , 2); BF(22, 25,-COS1_6 , 2); BF( 1, 6, COS2_1 , 1); BF( 9, 14,-COS2_1 , 1); BF(17, 22, COS2_1 , 1); BF(25, 30,-COS2_1 , 1); BF0( 2, 29, COS0_2 , 1); BF0(13, 18, COS0_13, 3); BF( 2, 13, COS1_2 , 1); BF(18, 29,-COS1_2 , 1); BF0( 5, 26, COS0_5 , 1); BF0(10, 21, COS0_10, 1); BF( 5, 10, COS1_5 , 2); BF(21, 26,-COS1_5 , 2); BF( 2, 5, COS2_2 , 1); BF(10, 13,-COS2_2 , 1); BF(18, 21, COS2_2 , 1); BF(26, 29,-COS2_2 , 1); BF( 1, 2, COS3_1 , 2); BF( 5, 6,-COS3_1 , 2); BF( 9, 10, COS3_1 , 2); BF(13, 14,-COS3_1 , 2); BF(17, 18, COS3_1 , 2); BF(21, 22,-COS3_1 , 2); BF(25, 26, COS3_1 , 2); BF(29, 30,-COS3_1 , 2); BF1( 0, 1, 2, 3); BF2( 4, 5, 6, 7); BF1( 8, 9, 10, 11); BF2(12, 13, 14, 15); BF1(16, 17, 18, 19); BF2(20, 21, 22, 23); BF1(24, 25, 26, 27); BF2(28, 29, 30, 31); ADD( 8, 12); ADD(12, 10); ADD(10, 14); ADD(14, 9); ADD( 9, 13); ADD(13, 11); ADD(11, 15); out[ 0] = [[fredy]]; out[16] = val1; out[ 8] = val2; out[24] = val3; out[ 4] = val4; out[20] = val5; out[12] = val6; out[28] = val7; out[ 2] = val8; out[18] = val9; out[10] = val10; out[26] = val11; out[ 6] = val12; out[22] = val13; out[14] = val14; out[30] = val15; ADD(24, 28); ADD(28, 26); ADD(26, 30); ADD(30, 25); ADD(25, 29); ADD(29, 27); ADD(27, 31); out[ 1] = val16 + val24; out[17] = val17 + val25; out[ 9] = val18 + val26; out[25] = val19 + val27; out[ 5] = val20 + val28; out[21] = val21 + val29; out[13] = val22 + val30; out[29] = val23 + val31; out[ 3] = val24 + val20; out[19] = val25 + val21; out[11] = val26 + val22; out[27] = val27 + val23; out[ 7] = val28 + val18; out[23] = val29 + val19; out[15] = val30 + val17; out[31] = val31; }
--------------------------------------------- Result 1016 ---------------------------------------------
[[0 (1%)]] --> [[0 (99%)]] --> Socre: 0.9887850284576416

[[[[Adv]]]]: static inline void gen_op_movl_seg_T0_vm(int [[seg_reg]]) { tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff); tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,segs[[[seg_reg]]].selector)); tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4); tcg_gen_st_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,segs[[[seg_reg]]].base)); }

[[[[Adv]]]]: static inline void gen_op_movl_seg_T0_vm(int [[bjrk]]) { tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff); tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,segs[[[bjrk]]].selector)); tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4); tcg_gen_st_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,segs[[[bjrk]]].base)); }
--------------------------------------------- Result 1017 ---------------------------------------------
[[0 (85%)]] --> [[0 (48%)]] --> Socre: 0.521586149930954

[[[[Adv]]]]: static void vc1_v_overlap_c(uint8_t* [[src]], int stride) { int i; int a, b, c, d; int d1, d2; int rnd = 1; for(i = 0; i < 8; i++) { a = [[src]][-2*stride]; b = [[src]][-stride]; c = [[src]][0]; d = [[src]][stride]; d1 = (a - d + 3 + rnd) >> 3; d2 = (a - d + b - c + 4 - rnd) >> 3; [[src]][-2*stride] = a - d1; [[src]][-stride] = b - d2; [[src]][0] = c + d2; [[src]][stride] = d + d1; [[src]]++; rnd = !rnd; } }

[[[[Adv]]]]: static void vc1_v_overlap_c(uint8_t* [[mimics]], int stride) { int i; int a, b, c, d; int d1, d2; int rnd = 1; for(i = 0; i < 8; i++) { a = [[mimics]][-2*stride]; b = [[mimics]][-stride]; c = [[mimics]][0]; d = [[mimics]][stride]; d1 = (a - d + 3 + rnd) >> 3; d2 = (a - d + b - c + 4 - rnd) >> 3; [[mimics]][-2*stride] = a - d1; [[mimics]][-stride] = b - d2; [[mimics]][0] = c + d2; [[mimics]][stride] = d + d1; [[mimics]]++; rnd = !rnd; } }
--------------------------------------------- Result 1018 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 596 / 57 / 365 / 1018:  38%|      | 1018/2690 [12:10:41<20:00:06, 43.07s/it][Succeeded / Failed / Skipped / Total] 596 / 57 / 365 / 1018:  38%|      | 1019/2690 [12:10:41<19:58:13, 43.02s/it][Succeeded / Failed / Skipped / Total] 596 / 57 / 366 / 1019:  38%|      | 1019/2690 [12:10:41<19:58:13, 43.02s/it][Succeeded / Failed / Skipped / Total] 596 / 57 / 366 / 1019:  38%|      | 1020/2690 [12:10:41<19:56:20, 42.98s/it][Succeeded / Failed / Skipped / Total] 596 / 57 / 367 / 1020:  38%|      | 1020/2690 [12:10:41<19:56:20, 42.98s/it][Succeeded / Failed / Skipped / Total] 596 / 57 / 367 / 1020:  38%|      | 1021/2690 [12:10:42<19:54:28, 42.94s/it][Succeeded / Failed / Skipped / Total] 596 / 57 / 368 / 1021:  38%|      | 1021/2690 [12:10:42<19:54:28, 42.94s/it][Succeeded / Failed / Skipped / Total] 596 / 57 / 368 / 1021:  38%|      | 1022/2690 [12:10:42<19:52:35, 42.90s/it][Succeeded / Failed / Skipped / Total] 596 / 57 / 369 / 1022:  38%|      | 1022/2690 [12:10:42<19:52:35, 42.90s/it][Succeeded / Failed / Skipped / Total] 596 / 57 / 369 / 1022:  38%|      | 1023/2690 [12:10:52<19:50:59, 42.87s/it][[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int qemu_rdma_register_and_get_keys(RDMAContext *rdma, RDMALocalBlock *block, uintptr_t host_addr, uint32_t *lkey, uint32_t *rkey, int chunk, uint8_t *chunk_start, uint8_t *chunk_end) { if (block->mr) { if (lkey) { *lkey = block->mr->lkey; } if (rkey) { *rkey = block->mr->rkey; } return 0; } if (!block->pmr) { block->pmr = g_malloc0(block->nb_chunks * sizeof(struct ibv_mr *)); } if (!block->pmr[chunk]) { uint64_t len = chunk_end - chunk_start; trace_qemu_rdma_register_and_get_keys(len, chunk_start); block->pmr[chunk] = ibv_reg_mr(rdma->pd, chunk_start, len, (rkey ? (IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE) : 0)); if (!block->pmr[chunk]) { perror("Failed to register chunk!"); fprintf(stderr, "Chunk details: block: %d chunk index %d" " start %" PRIuPTR " end %" PRIuPTR " host %" PRIuPTR " local %" PRIuPTR " registrations: %d\n", block->index, chunk, (uintptr_t)chunk_start, (uintptr_t)chunk_end, host_addr, (uintptr_t)block->local_host_addr, rdma->total_registrations); return -1; } rdma->total_registrations++; } if (lkey) { *lkey = block->pmr[chunk]->lkey; } if (rkey) { *rkey = block->pmr[chunk]->rkey; } return 0; }

[[[[Adv]]]]: static int qemu_rdma_register_and_get_keys(RDMAContext *rdma, RDMALocalBlock *block, uintptr_t host_addr, uint32_t *lkey, uint32_t *rkey, int chunk, uint8_t *chunk_start, uint8_t *chunk_end) { if (block->mr) { if (lkey) { *lkey = block->mr->lkey; } if (rkey) { *rkey = block->mr->rkey; } return 0; } if (!block->pmr) { block->pmr = g_malloc0(block->nb_chunks * sizeof(struct ibv_mr *)); } if (!block->pmr[chunk]) { uint64_t len = chunk_end - chunk_start; trace_qemu_rdma_register_and_get_keys(len, chunk_start); block->pmr[chunk] = ibv_reg_mr(rdma->pd, chunk_start, len, (rkey ? (IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE) : 0)); if (!block->pmr[chunk]) { perror("Failed to register chunk!"); fprintf(stderr, "Chunk details: block: %d chunk index %d" " start %" PRIuPTR " end %" PRIuPTR " host %" PRIuPTR " local %" PRIuPTR " registrations: %d\n", block->index, chunk, (uintptr_t)chunk_start, (uintptr_t)chunk_end, host_addr, (uintptr_t)block->local_host_addr, rdma->total_registrations); return -1; } rdma->total_registrations++; } if (lkey) { *lkey = block->pmr[chunk]->lkey; } if (rkey) { *rkey = block->pmr[chunk]->rkey; } return 0; }
--------------------------------------------- Result 1019 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void gen_rdhwr(DisasContext *ctx, int rt, int rd) { TCGv t0; #if !defined(CONFIG_USER_ONLY) check_insn(ctx, ISA_MIPS32R2); #endif t0 = tcg_temp_new(); switch (rd) { case 0: save_cpu_state(ctx, 1); gen_helper_rdhwr_cpunum(t0, cpu_env); gen_store_gpr(t0, rt); break; case 1: save_cpu_state(ctx, 1); gen_helper_rdhwr_synci_step(t0, cpu_env); gen_store_gpr(t0, rt); break; case 2: save_cpu_state(ctx, 1); gen_helper_rdhwr_cc(t0, cpu_env); gen_store_gpr(t0, rt); break; case 3: save_cpu_state(ctx, 1); gen_helper_rdhwr_ccres(t0, cpu_env); gen_store_gpr(t0, rt); break; case 29: #if defined(CONFIG_USER_ONLY) tcg_gen_ld_tl(t0, cpu_env, offsetof(CPUMIPSState, tls_value)); gen_store_gpr(t0, rt); break; #else #endif default: MIPS_INVAL("rdhwr"); generate_exception(ctx, EXCP_RI); break; } tcg_temp_free(t0); }
--------------------------------------------- Result 1020 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void usb_msd_realize_bot(USBDevice *dev, Error **errp) { MSDState *s = DO_UPCAST(MSDState, dev, dev); usb_desc_create_serial(dev); usb_desc_init(dev); scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev), &usb_msd_scsi_info_bot, NULL); s->bus.qbus.allow_hotplug = 0; usb_msd_handle_reset(dev); }
--------------------------------------------- Result 1021 ---------------------------------------------
[[0 (57%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decode_slice_header(FFV1Context *f, FFV1Context *fs) { RangeCoder *c = &fs->c; uint8_t state[CONTEXT_SIZE]; unsigned ps, i, context_count; memset(state, 128, sizeof(state)); if (fs->ac > 1) { for (i = 1; i < 256; i++) { fs->c.one_state[i] = f->state_transition[i]; fs->c.zero_state[256 - i] = 256 - fs->c.one_state[i]; } } fs->slice_x = get_symbol(c, state, 0) * f->width; fs->slice_y = get_symbol(c, state, 0) * f->height; fs->slice_width = (get_symbol(c, state, 0) + 1) * f->width + fs->slice_x; fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y; fs->slice_x /= f->num_h_slices; fs->slice_y /= f->num_v_slices; fs->slice_width = fs->slice_width / f->num_h_slices - fs->slice_x; fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y; if ((unsigned)fs->slice_width > f->width || (unsigned)fs->slice_height > f->height) return AVERROR_INVALIDDATA; if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width > f->width || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height) return AVERROR_INVALIDDATA; for (i = 0; i < f->plane_count; i++) { PlaneContext *const p = &fs->plane[i]; int idx = get_symbol(c, state, 0); if (idx > (unsigned)f->quant_table_count) { av_log(f->avctx, AV_LOG_ERROR, "quant_table_index out of range\n"); return AVERROR_INVALIDDATA; } p->quant_table_index = idx; memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table)); context_count = f->context_count[idx]; if (p->context_count < context_count) { av_freep(&p->state); av_freep(&p->vlc_state); } p->context_count = context_count; } ps = get_symbol(c, state, 0); if (ps == 1) { f->cur->interlaced_frame = 1; f->cur->top_field_first = 1; } else if (ps == 2) { f->cur->interlaced_frame = 1; f->cur->top_field_first = 0; } else if (ps == 3) { f->cur->interlaced_frame = 0; } f->cur->sample_aspect_ratio.num = get_symbol(c, state, 0); f->cur->sample_aspect_ratio.den = get_symbol(c, state, 0); if (av_image_check_sar(f->width, f->height, f->cur->sample_aspect_ratio) < 0) { av_log(f->avctx, AV_LOG_WARNING, "ignoring invalid SAR: %u/%u\n", f->cur->sample_aspect_ratio.num, f->cur->sample_aspect_ratio.den); f->cur->sample_aspect_ratio = (AVRational){ 0, 1 }; } return 0; }
--------------------------------------------- Result 1022 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp) { if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn, sizeof(diag_501), 0) || cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501, sizeof(diag_501), 1)) { return -EINVAL; } return 0; }
--------------------------------------------- Result 1023 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void ppc_cpu_realizefn(DeviceState *dev, Error **errp) { CPUState *cs = CPU(dev); PowerPCCPU *cpu = POWERPC_CPU(dev); PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu); Error *local_err = NULL; #if !defined(CONFIG_USER_ONLY) int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1; #endif #if !defined(CONFIG_USER_ONLY) if (smp_threads > max_smt) { error_setg(errp, "Cannot support more than %d threads on PPC with %s", max_smt, kvm_enabled() ? "KVM" : "TCG"); if (!is_power_of_2(smp_threads)) { error_setg(errp, "Cannot support %d threads on PPC with %s, " "threads count must be a power of 2.", smp_threads, kvm_enabled() ? "KVM" : "TCG"); #endif cpu_exec_init(cs, &local_err); if (local_err != NULL) { error_propagate(errp, local_err); #if !defined(CONFIG_USER_ONLY) cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt + (cs->cpu_index % smp_threads); #endif if (tcg_enabled()) { if (ppc_fixup_cpu(cpu) != 0) { error_setg(errp, "Unable to emulate selected CPU with TCG"); #if defined(TARGET_PPCEMB) if (!ppc_cpu_is_valid(pcc)) { error_setg(errp, "CPU does not possess a BookE or 4xx MMU. " "Please use qemu-system-ppc or qemu-system-ppc64 instead " "or choose another CPU model."); #endif create_ppc_opcodes(cpu, &local_err); if (local_err != NULL) { error_propagate(errp, local_err); init_ppc_proc(cpu); if (pcc->insns_flags & PPC_FLOAT) { gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg, 33, "power-fpu.xml", 0); if (pcc->insns_flags & PPC_ALTIVEC) { gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg, 34, "power-altivec.xml", 0); if (pcc->insns_flags & PPC_SPE) { gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg, 34, "power-spe.xml", 0); if (pcc->insns_flags2 & PPC2_VSX) { gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg, 32, "power-vsx.xml", 0); qemu_init_vcpu(cs); pcc->parent_realize(dev, errp); #if defined(PPC_DUMP_CPU) { CPUPPCState *env = &cpu->env; const char *mmu_model, *excp_model, *bus_model; switch (env->mmu_model) { case POWERPC_MMU_32B: mmu_model = "PowerPC 32"; break; case POWERPC_MMU_SOFT_6xx: mmu_model = "PowerPC 6xx/7xx with software driven TLBs"; break; case POWERPC_MMU_SOFT_74xx: mmu_model = "PowerPC 74xx with software driven TLBs"; break; case POWERPC_MMU_SOFT_4xx: mmu_model = "PowerPC 4xx with software driven TLBs"; break; case POWERPC_MMU_SOFT_4xx_Z: mmu_model = "PowerPC 4xx with software driven TLBs " "and zones protections"; break; case POWERPC_MMU_REAL: mmu_model = "PowerPC real mode only"; break; case POWERPC_MMU_MPC8xx: mmu_model = "PowerPC MPC8xx"; break; case POWERPC_MMU_BOOKE: mmu_model = "PowerPC BookE"; break; case POWERPC_MMU_BOOKE206: mmu_model = "PowerPC BookE 2.06"; break; case POWERPC_MMU_601: mmu_model = "PowerPC 601"; break; #if defined (TARGET_PPC64) case POWERPC_MMU_64B: mmu_model = "PowerPC 64"; break; #endif default: mmu_model = "Unknown or invalid"; break; switch (env->excp_model) { case POWERPC_EXCP_STD: excp_model = "PowerPC"; break; case POWERPC_EXCP_40x: excp_model = "PowerPC 40x"; break; case POWERPC_EXCP_601: excp_model = "PowerPC 601"; break; case POWERPC_EXCP_602: excp_model = "PowerPC 602"; break; case POWERPC_EXCP_603: excp_model = "PowerPC 603"; break; case POWERPC_EXCP_603E: excp_model = "PowerPC 603e"; break; case POWERPC_EXCP_604: excp_model = "PowerPC 604"; break; case POWERPC_EXCP_7x0: excp_model = "PowerPC 740/750"; break; case POWERPC_EXCP_7x5: excp_model = "PowerPC 745/755"; break; case POWERPC_EXCP_74xx: excp_model = "PowerPC 74xx"; break; case POWERPC_EXCP_BOOKE: excp_model = "PowerPC BookE"; break; #if defined (TARGET_PPC64) case POWERPC_EXCP_970: excp_model = "PowerPC 970"; break; #endif default: excp_model = "Unknown or invalid"; break; switch (env->bus_model) { case PPC_FLAGS_INPUT_6xx: bus_model = "PowerPC 6xx"; break; case PPC_FLAGS_INPUT_BookE: bus_model = "PowerPC BookE"; break; case PPC_FLAGS_INPUT_405: bus_model = "PowerPC 405"; break; case PPC_FLAGS_INPUT_401: bus_model = "PowerPC 401/403"; break; case PPC_FLAGS_INPUT_RCPU: bus_model = "RCPU / MPC8xx"; break; #if defined (TARGET_PPC64) case PPC_FLAGS_INPUT_970: bus_model = "PowerPC 970"; break; #endif default: bus_model = "Unknown or invalid"; break; printf("PowerPC %-12s : PVR %08x MSR %016" PRIx64 "\n" " MMU model : %s\n", object_class_get_name(OBJECT_CLASS(pcc)), pcc->pvr, pcc->msr_mask, mmu_model); #if !defined(CONFIG_USER_ONLY) if (env->tlb.tlb6) { printf(" %d %s TLB in %d ways\n", env->nb_tlb, env->id_tlbs ? "splitted" : "merged", env->nb_ways); #endif printf(" Exceptions model : %s\n" " Bus model : %s\n", excp_model, bus_model); printf(" MSR features :\n"); if (env->flags & POWERPC_FLAG_SPE) printf(" signal processing engine enable" "\n"); else if (env->flags & POWERPC_FLAG_VRE) printf(" vector processor enable\n"); if (env->flags & POWERPC_FLAG_TGPR) printf(" temporary GPRs\n"); else if (env->flags & POWERPC_FLAG_CE) printf(" critical input enable\n"); if (env->flags & POWERPC_FLAG_SE) printf(" single-step trace mode\n"); else if (env->flags & POWERPC_FLAG_DWE) printf(" debug wait enable\n"); else if (env->flags & POWERPC_FLAG_UBLE) printf(" user BTB lock enable\n"); if (env->flags & POWERPC_FLAG_BE) printf(" branch-step trace mode\n"); else if (env->flags & POWERPC_FLAG_DE) printf(" debug interrupt enable\n"); if (env->flags & POWERPC_FLAG_PX) printf(" inclusive protection\n"); else if (env->flags & POWERPC_FLAG_PMM) printf(" performance monitor mark\n"); if (env->flags == POWERPC_FLAG_NONE) printf(" none\n"); printf(" Time-base/decrementer clock source: %s\n", env->flags & POWERPC_FLAG_RTC_CLK ? "RTC clock" : "bus clock"); dump_ppc_insns(env); dump_ppc_sprs(env); fflush(stdout); #endif

[[[[Adv]]]]: static void ppc_cpu_realizefn(DeviceState *dev, Error **errp) { CPUState *cs = CPU(dev); PowerPCCPU *cpu = POWERPC_CPU(dev); PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu); Error *local_err = NULL; #if !defined(CONFIG_USER_ONLY) int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1; #endif #if !defined(CONFIG_USER_ONLY) if (smp_threads > max_smt) { error_setg(errp, "Cannot support more than %d threads on PPC with %s", max_smt, kvm_enabled() ? "KVM" : "TCG"); if (!is_power_of_2(smp_threads)) { error_setg(errp, "Cannot support %d threads on PPC with %s, " "threads count must be a power of 2.", smp_threads, kvm_enabled() ? "KVM" : "TCG"); #endif cpu_exec_init(cs, &local_err); if (local_err != NULL) { error_propagate(errp, local_err); #if !defined(CONFIG_USER_ONLY) cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt + (cs->cpu_index % smp_threads); #endif if (tcg_enabled()) { if (ppc_fixup_cpu(cpu) != 0) { error_setg(errp, "Unable to emulate selected CPU with TCG"); #if defined(TARGET_PPCEMB) if (!ppc_cpu_is_valid(pcc)) { error_setg(errp, "CPU does not possess a BookE or 4xx MMU. " "Please use qemu-system-ppc or qemu-system-ppc64 instead " "or choose another CPU model."); #endif create_ppc_opcodes(cpu, &local_err); if (local_err != NULL) { error_propagate(errp, local_err); init_ppc_proc(cpu); if (pcc->insns_flags & PPC_FLOAT) { gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg, 33, "power-fpu.xml", 0); if (pcc->insns_flags & PPC_ALTIVEC) { gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg, 34, "power-altivec.xml", 0); if (pcc->insns_flags & PPC_SPE) { gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg, 34, "power-spe.xml", 0); if (pcc->insns_flags2 & PPC2_VSX) { gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg, 32, "power-vsx.xml", 0); qemu_init_vcpu(cs); pcc->parent_realize(dev, errp); #if defined(PPC_DUMP_CPU) { CPUPPCState *env = &cpu->env; const char *mmu_model, *excp_model, *bus_model; switch (env->mmu_model) { case POWERPC_MMU_32B: mmu_model = "PowerPC 32"; break; case POWERPC_MMU_SOFT_6xx: mmu_model = "PowerPC 6xx/7xx with software driven TLBs"; break; case POWERPC_MMU_SOFT_74xx: mmu_model = "PowerPC 74xx with software driven TLBs"; break; case POWERPC_MMU_SOFT_4xx: mmu_model = "PowerPC 4xx with software driven TLBs"; break; case POWERPC_MMU_SOFT_4xx_Z: mmu_model = "PowerPC 4xx with software driven TLBs " "and zones protections"; break; case POWERPC_MMU_REAL: mmu_model = "PowerPC real mode only"; break; case POWERPC_MMU_MPC8xx: mmu_model = "PowerPC MPC8xx"; break; case POWERPC_MMU_BOOKE: mmu_model = "PowerPC BookE"; break; case POWERPC_MMU_BOOKE206: mmu_model = "PowerPC BookE 2.06"; break; case POWERPC_MMU_601: mmu_model = "PowerPC 601"; break; #if defined (TARGET_PPC64) case POWERPC_MMU_64B: mmu_model = "PowerPC 64"; break; #endif default: mmu_model = "Unknown or invalid"; break; switch (env->excp_model) { case POWERPC_EXCP_STD: excp_model = "PowerPC"; break; case POWERPC_EXCP_40x: excp_model = "PowerPC 40x"; break; case POWERPC_EXCP_601: excp_model = "PowerPC 601"; break; case POWERPC_EXCP_602: excp_model = "PowerPC 602"; break; case POWERPC_EXCP_603: excp_model = "PowerPC 603"; break; case POWERPC_EXCP_603E: excp_model = "PowerPC 603e"; break; case POWERPC_EXCP_604: excp_model = "PowerPC 604"; break; case POWERPC_EXCP_7x0: excp_model = "PowerPC 740/750"; break; case POWERPC_EXCP_7x5: excp_model = "PowerPC 745/755"; break; case POWERPC_EXCP_74xx: excp_model = "PowerPC 74xx"; break; case POWERPC_EXCP_BOOKE: excp_model = "PowerPC BookE"; break; #if defined (TARGET_PPC64) case POWERPC_EXCP_970: excp_model = "PowerPC 970"; break; #endif default: excp_model = "Unknown or invalid"; break; switch (env->bus_model) { case PPC_FLAGS_INPUT_6xx: bus_model = "PowerPC 6xx"; break; case PPC_FLAGS_INPUT_BookE: bus_model = "PowerPC BookE"; break; case PPC_FLAGS_INPUT_405: bus_model = "PowerPC 405"; break; case PPC_FLAGS_INPUT_401: bus_model = "PowerPC 401/403"; break; case PPC_FLAGS_INPUT_RCPU: bus_model = "RCPU / MPC8xx"; break; #if defined (TARGET_PPC64) case PPC_FLAGS_INPUT_970: bus_model = "PowerPC 970"; break; #endif default: bus_model = "Unknown or invalid"; break; printf("PowerPC %-12s : PVR %08x MSR %016" PRIx64 "\n" " MMU model : %s\n", object_class_get_name(OBJECT_CLASS(pcc)), pcc->pvr, pcc->msr_mask, mmu_model); #if !defined(CONFIG_USER_ONLY) if (env->tlb.tlb6) { printf(" %d %s TLB in %d ways\n", env->nb_tlb, env->id_tlbs ? "splitted" : "merged", env->nb_ways); #endif printf(" Exceptions model : %s\n" " Bus model : %s\n", excp_model, bus_model); printf(" MSR features :\n"); if (env->flags & POWERPC_FLAG_SPE) printf(" signal processing engine enable" "\n"); else if (env->flags & POWERPC_FLAG_VRE) printf(" vector processor enable\n"); if (env->flags & POWERPC_FLAG_TGPR) printf(" temporary GPRs\n"); else if (env->flags & POWERPC_FLAG_CE) printf(" critical input enable\n"); if (env->flags & POWERPC_FLAG_SE) printf(" single-step trace mode\n"); else if (env->flags & POWERPC_FLAG_DWE) printf(" debug wait enable\n"); else if (env->flags & POWERPC_FLAG_UBLE) printf(" user BTB lock enable\n"); if (env->flags & POWERPC_FLAG_BE) printf(" branch-step trace mode\n"); else if (env->flags & POWERPC_FLAG_DE) printf(" debug interrupt enable\n"); if (env->flags & POWERPC_FLAG_PX) printf(" inclusive protection\n"); else if (env->flags & POWERPC_FLAG_PMM) printf(" performance monitor mark\n"); if (env->flags == POWERPC_FLAG_NONE) printf(" none\n"); printf(" Time-base/decrementer clock source: %s\n", env->flags & POWERPC_FLAG_RTC_CLK ? "RTC clock" : "bus clock"); dump_ppc_insns(env); dump_ppc_sprs(env); fflush(stdout); #endif[Succeeded / Failed / Skipped / Total] 596 / 58 / 369 / 1023:  38%|      | 1023/2690 [12:10:52<19:50:59, 42.87s/it][Succeeded / Failed / Skipped / Total] 596 / 58 / 369 / 1023:  38%|      | 1024/2690 [12:10:53<19:49:07, 42.83s/it][Succeeded / Failed / Skipped / Total] 596 / 58 / 370 / 1024:  38%|      | 1024/2690 [12:10:53<19:49:07, 42.83s/it][Succeeded / Failed / Skipped / Total] 596 / 58 / 370 / 1024:  38%|      | 1025/2690 [12:10:53<19:47:15, 42.78s/it][Succeeded / Failed / Skipped / Total] 596 / 58 / 371 / 1025:  38%|      | 1025/2690 [12:10:53<19:47:15, 42.78s/it][Succeeded / Failed / Skipped / Total] 596 / 58 / 371 / 1025:  38%|      | 1026/2690 [12:11:18<19:46:02, 42.77s/it]
--------------------------------------------- Result 1024 ---------------------------------------------
[[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decode_element(AVCodecContext *avctx, void *data, int ch_index, int channels) { ALACContext *alac = avctx->priv_data; int has_size, bps, is_compressed, decorr_shift, decorr_left_weight, ret; uint32_t output_samples; int i, ch; skip_bits(&alac->gb, 4); skip_bits(&alac->gb, 12); has_size = get_bits1(&alac->gb); alac->extra_bits = get_bits(&alac->gb, 2) << 3; bps = alac->sample_size - alac->extra_bits + channels - 1; if (bps > 32) { av_log(avctx, AV_LOG_ERROR, "bps is unsupported: %d\n", bps); return AVERROR_PATCHWELCOME; } is_compressed = !get_bits1(&alac->gb); if (has_size) output_samples = get_bits_long(&alac->gb, 32); else output_samples = alac->max_samples_per_frame; if (!output_samples || output_samples > alac->max_samples_per_frame) { av_log(avctx, AV_LOG_ERROR, "invalid samples per frame: %d\n", output_samples); return AVERROR_INVALIDDATA; } if (!alac->nb_samples) { alac->frame.nb_samples = output_samples; if ((ret = avctx->get_buffer(avctx, &alac->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } } else if (output_samples != alac->nb_samples) { av_log(avctx, AV_LOG_ERROR, "sample count mismatch: %u != %d\n", output_samples, alac->nb_samples); return AVERROR_INVALIDDATA; } alac->nb_samples = output_samples; if (alac->direct_output) { for (ch = 0; ch < channels; ch++) alac->output_samples_buffer[ch] = (int32_t *)alac->frame.extended_data[ch_index + ch]; } if (is_compressed) { int16_t lpc_coefs[2][32]; int lpc_order[2]; int prediction_type[2]; int lpc_quant[2]; int rice_history_mult[2]; decorr_shift = get_bits(&alac->gb, 8); decorr_left_weight = get_bits(&alac->gb, 8); for (ch = 0; ch < channels; ch++) { prediction_type[ch] = get_bits(&alac->gb, 4); lpc_quant[ch] = get_bits(&alac->gb, 4); rice_history_mult[ch] = get_bits(&alac->gb, 3); lpc_order[ch] = get_bits(&alac->gb, 5); for (i = lpc_order[ch] - 1; i >= 0; i--) lpc_coefs[ch][i] = get_sbits(&alac->gb, 16); } if (alac->extra_bits) { for (i = 0; i < alac->nb_samples; i++) { if(get_bits_left(&alac->gb) <= 0) return -1; for (ch = 0; ch < channels; ch++) alac->extra_bits_buffer[ch][i] = get_bits(&alac->gb, alac->extra_bits); } } for (ch = 0; ch < channels; ch++) { int ret=rice_decompress(alac, alac->predict_error_buffer[ch], alac->nb_samples, bps, rice_history_mult[ch] * alac->rice_history_mult / 4); if(ret<0) return ret; if (prediction_type[ch] == 15) { lpc_prediction(alac->predict_error_buffer[ch], alac->predict_error_buffer[ch], alac->nb_samples, bps, NULL, 31, 0); } else if (prediction_type[ch] > 0) { av_log(avctx, AV_LOG_WARNING, "unknown prediction type: %i\n", prediction_type[ch]); } lpc_prediction(alac->predict_error_buffer[ch], alac->output_samples_buffer[ch], alac->nb_samples, bps, lpc_coefs[ch], lpc_order[ch], lpc_quant[ch]); } } else { for (i = 0; i < alac->nb_samples; i++) { if(get_bits_left(&alac->gb) <= 0) return -1; for (ch = 0; ch < channels; ch++) { alac->output_samples_buffer[ch][i] = get_sbits_long(&alac->gb, alac->sample_size); } } alac->extra_bits = 0; decorr_shift = 0; decorr_left_weight = 0; } if (channels == 2 && decorr_left_weight) { decorrelate_stereo(alac->output_samples_buffer, alac->nb_samples, decorr_shift, decorr_left_weight); } if (alac->extra_bits) { append_extra_bits(alac->output_samples_buffer, alac->extra_bits_buffer, alac->extra_bits, channels, alac->nb_samples); } if(av_sample_fmt_is_planar(avctx->sample_fmt)) { switch(alac->sample_size) { case 16: { for (ch = 0; ch < channels; ch++) { int16_t *outbuffer = (int16_t *)alac->frame.extended_data[ch_index + ch]; for (i = 0; i < alac->nb_samples; i++) *outbuffer++ = alac->output_samples_buffer[ch][i]; }} break; case 24: { for (ch = 0; ch < channels; ch++) { for (i = 0; i < alac->nb_samples; i++) alac->output_samples_buffer[ch][i] <<= 8; }} break; } }else{ switch(alac->sample_size) { case 16: { int16_t *outbuffer = ((int16_t *)alac->frame.extended_data[0]) + ch_index; for (i = 0; i < alac->nb_samples; i++) { for (ch = 0; ch < channels; ch++) *outbuffer++ = alac->output_samples_buffer[ch][i]; outbuffer += alac->channels - channels; } } break; case 24: { int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index; for (i = 0; i < alac->nb_samples; i++) { for (ch = 0; ch < channels; ch++) *outbuffer++ = alac->output_samples_buffer[ch][i] << 8; outbuffer += alac->channels - channels; } } break; case 32: { int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index; for (i = 0; i < alac->nb_samples; i++) { for (ch = 0; ch < channels; ch++) *outbuffer++ = alac->output_samples_buffer[ch][i]; outbuffer += alac->channels - channels; } } break; } } return 0; }
--------------------------------------------- Result 1025 ---------------------------------------------
[[0 (77%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_always_inline float quantize_and_encode_band_cost_template( struct AACEncContext *s, PutBitContext *pb, const float *in, const float *scaled, int size, int scale_idx, int cb, const float lambda, const float uplim, int *bits, int BT_ZERO, int BT_UNSIGNED, int BT_PAIR, int BT_ESC) { const float IQ = ff_aac_pow2sf_tab[200 + scale_idx - SCALE_ONE_POS + SCALE_DIV_512]; const float Q = ff_aac_pow2sf_tab[200 - scale_idx + SCALE_ONE_POS - SCALE_DIV_512]; const float CLIPPED_ESCAPE = 165140.0f*IQ; int i, j, k; float cost = 0; const int dim = BT_PAIR ? 2 : 4; int resbits = 0; const float Q34 = sqrtf(Q * sqrtf(Q)); const int range = aac_cb_range[cb]; const int maxval = aac_cb_maxval[cb]; int off; if (BT_ZERO) { for (i = 0; i < size; i++) cost += in[i]*in[i]; if (bits) *bits = 0; return cost * lambda; } if (!scaled) { abs_pow34_v(s->scoefs, in, size); scaled = s->scoefs; } quantize_bands(s->qcoefs, in, scaled, size, Q34, !BT_UNSIGNED, maxval); if (BT_UNSIGNED) { off = 0; } else { off = maxval; } for (i = 0; i < size; i += dim) { const float *vec; int *quants = s->qcoefs + i; int curidx = 0; int curbits; float rd = 0.0f; for (j = 0; j < dim; j++) { curidx *= range; curidx += quants[j] + off; } curbits = ff_aac_spectral_bits[cb-1][curidx]; vec = &ff_aac_codebook_vectors[cb-1][curidx*dim]; if (BT_UNSIGNED) { for (k = 0; k < dim; k++) { float t = fabsf(in[i+k]); float di; if (BT_ESC && vec[k] == 64.0f) { if (t >= CLIPPED_ESCAPE) { di = t - CLIPPED_ESCAPE; curbits += 21; } else { int c = av_clip(quant(t, Q), 0, 8191); di = t - c*cbrtf(c)*IQ; curbits += av_log2(c)*2 - 4 + 1; } } else { di = t - vec[k]*IQ; } if (vec[k] != 0.0f) curbits++; rd += di*di; } } else { for (k = 0; k < dim; k++) { float di = in[i+k] - vec[k]*IQ; rd += di*di; } } cost += rd * lambda + curbits; resbits += curbits; if (cost >= uplim) return uplim; if (pb) { put_bits(pb, ff_aac_spectral_bits[cb-1][curidx], ff_aac_spectral_codes[cb-1][curidx]); if (BT_UNSIGNED) for (j = 0; j < dim; j++) if (ff_aac_codebook_vectors[cb-1][curidx*dim+j] != 0.0f) put_bits(pb, 1, in[i+j] < 0.0f); if (BT_ESC) { for (j = 0; j < 2; j++) { if (ff_aac_codebook_vectors[cb-1][curidx*2+j] == 64.0f) { int coef = av_clip(quant(fabsf(in[i+j]), Q), 0, 8191); int len = av_log2(coef); put_bits(pb, len - 4 + 1, (1 << (len - 4 + 1)) - 2); put_bits(pb, len, coef & ((1 << len) - 1)); } } } } } if (bits) *bits = resbits; return cost; }
--------------------------------------------- Result 1026 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 597 / 58 / 371 / 1026:  38%|      | 1026/2690 [12:11:18<19:46:02, 42.77s/it][Succeeded / Failed / Skipped / Total] 597 / 58 / 371 / 1026:  38%|      | 1027/2690 [12:11:18<19:44:11, 42.72s/it][Succeeded / Failed / Skipped / Total] 597 / 58 / 372 / 1027:  38%|      | 1027/2690 [12:11:18<19:44:11, 42.72s/it][Succeeded / Failed / Skipped / Total] 597 / 58 / 372 / 1027:  38%|      | 1028/2690 [12:11:18<19:42:20, 42.68s/it][Succeeded / Failed / Skipped / Total] 597 / 58 / 373 / 1028:  38%|      | 1028/2690 [12:11:18<19:42:20, 42.68s/it][Succeeded / Failed / Skipped / Total] 597 / 58 / 373 / 1028:  38%|      | 1029/2690 [12:11:26<19:40:40, 42.65s/it][[0 (42%)]] --> [[0 (93%)]] --> Socre: 0.9302682280540466

[[[[Adv]]]]: static void event_loop(VideoState *cur_stream) { SDL_Event event; double [[incr]], pos, frac; for(;;) { double x; SDL_WaitEvent(&event); switch(event.type) { case SDL_KEYDOWN: if (exit_on_keydown) { do_exit(cur_stream); break; } switch(event.key.keysym.sym) { case SDLK_ESCAPE: case SDLK_q: do_exit(cur_stream); break; case SDLK_f: toggle_full_screen(cur_stream); break; case SDLK_p: case SDLK_SPACE: if (cur_stream) toggle_pause(cur_stream); break; case SDLK_s: if (cur_stream) step_to_next_frame(cur_stream); break; case SDLK_a: if (cur_stream) stream_cycle_channel(cur_stream, AVMEDIA_TYPE_AUDIO); break; case SDLK_v: if (cur_stream) stream_cycle_channel(cur_stream, AVMEDIA_TYPE_VIDEO); break; case SDLK_t: if (cur_stream) stream_cycle_channel(cur_stream, AVMEDIA_TYPE_SUBTITLE); break; case SDLK_w: if (cur_stream) toggle_audio_display(cur_stream); break; case SDLK_LEFT: [[incr]] = -10.0; goto do_seek; case SDLK_RIGHT: [[incr]] = 10.0; goto do_seek; case SDLK_UP: [[incr]] = 60.0; goto do_seek; case SDLK_DOWN: [[incr]] = -60.0; do_seek: if (cur_stream) { if (seek_by_bytes) { if (cur_stream->video_stream >= 0 && cur_stream->video_current_pos>=0){ pos= cur_stream->video_current_pos; }else if(cur_stream->audio_stream >= 0 && cur_stream->audio_pkt.pos>=0){ pos= cur_stream->audio_pkt.pos; }else pos = avio_tell(cur_stream->ic->pb); if (cur_stream->ic->bit_rate) [[incr]] *= cur_stream->ic->bit_rate / 8.0; else [[incr]] *= 180000.0; pos += [[incr]]; stream_seek(cur_stream, pos, [[incr]], 1); } else { pos = get_master_clock(cur_stream); pos += [[incr]]; stream_seek(cur_stream, (int64_t)(pos * AV_TIME_BASE), (int64_t)([[incr]] * AV_TIME_BASE), 0); } } break; default: break; } break; case SDL_MOUSEBUTTONDOWN: if (exit_on_mousedown) { do_exit(cur_stream); break; } case SDL_MOUSEMOTION: if(event.type ==SDL_MOUSEBUTTONDOWN){ x= event.button.x; }else{ if(event.motion.state != SDL_PRESSED) break; x= event.motion.x; } if (cur_stream) { if(seek_by_bytes || cur_stream->ic->duration<=0){ uint64_t size= avio_size(cur_stream->ic->pb); stream_seek(cur_stream, size*x/cur_stream->width, 0, 1); }else{ int64_t ts; int ns, hh, mm, ss; int tns, thh, tmm, tss; tns = cur_stream->ic->duration/1000000LL; thh = tns/3600; tmm = (tns%3600)/60; tss = (tns%60); frac = x/cur_stream->width; ns = frac*tns; hh = ns/3600; mm = (ns%3600)/60; ss = (ns%60); fprintf(stderr, "Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d) \n", frac*100, hh, mm, ss, thh, tmm, tss); ts = frac*cur_stream->ic->duration; if (cur_stream->ic->start_time != AV_NOPTS_VALUE) ts += cur_stream->ic->start_time; stream_seek(cur_stream, ts, 0, 0); } } break; case SDL_VIDEORESIZE: if (cur_stream) { screen = SDL_SetVideoMode(event.resize.w, event.resize.h, 0, SDL_HWSURFACE|SDL_RESIZABLE|SDL_ASYNCBLIT|SDL_HWACCEL); screen_width = cur_stream->width = event.resize.w; screen_height= cur_stream->height= event.resize.h; } break; case SDL_QUIT: case FF_QUIT_EVENT: do_exit(cur_stream); break; case FF_ALLOC_EVENT: video_open(event.user.data1); alloc_picture(event.user.data1); break; case FF_REFRESH_EVENT: video_refresh(event.user.data1); cur_stream->refresh=0; break; default: break; } } }

[[[[Adv]]]]: static void event_loop(VideoState *cur_stream) { SDL_Event event; double [[whackin]], pos, frac; for(;;) { double x; SDL_WaitEvent(&event); switch(event.type) { case SDL_KEYDOWN: if (exit_on_keydown) { do_exit(cur_stream); break; } switch(event.key.keysym.sym) { case SDLK_ESCAPE: case SDLK_q: do_exit(cur_stream); break; case SDLK_f: toggle_full_screen(cur_stream); break; case SDLK_p: case SDLK_SPACE: if (cur_stream) toggle_pause(cur_stream); break; case SDLK_s: if (cur_stream) step_to_next_frame(cur_stream); break; case SDLK_a: if (cur_stream) stream_cycle_channel(cur_stream, AVMEDIA_TYPE_AUDIO); break; case SDLK_v: if (cur_stream) stream_cycle_channel(cur_stream, AVMEDIA_TYPE_VIDEO); break; case SDLK_t: if (cur_stream) stream_cycle_channel(cur_stream, AVMEDIA_TYPE_SUBTITLE); break; case SDLK_w: if (cur_stream) toggle_audio_display(cur_stream); break; case SDLK_LEFT: [[whackin]] = -10.0; goto do_seek; case SDLK_RIGHT: [[whackin]] = 10.0; goto do_seek; case SDLK_UP: [[whackin]] = 60.0; goto do_seek; case SDLK_DOWN: [[whackin]] = -60.0; do_seek: if (cur_stream) { if (seek_by_bytes) { if (cur_stream->video_stream >= 0 && cur_stream->video_current_pos>=0){ pos= cur_stream->video_current_pos; }else if(cur_stream->audio_stream >= 0 && cur_stream->audio_pkt.pos>=0){ pos= cur_stream->audio_pkt.pos; }else pos = avio_tell(cur_stream->ic->pb); if (cur_stream->ic->bit_rate) [[whackin]] *= cur_stream->ic->bit_rate / 8.0; else [[whackin]] *= 180000.0; pos += [[whackin]]; stream_seek(cur_stream, pos, [[whackin]], 1); } else { pos = get_master_clock(cur_stream); pos += [[whackin]]; stream_seek(cur_stream, (int64_t)(pos * AV_TIME_BASE), (int64_t)([[whackin]] * AV_TIME_BASE), 0); } } break; default: break; } break; case SDL_MOUSEBUTTONDOWN: if (exit_on_mousedown) { do_exit(cur_stream); break; } case SDL_MOUSEMOTION: if(event.type ==SDL_MOUSEBUTTONDOWN){ x= event.button.x; }else{ if(event.motion.state != SDL_PRESSED) break; x= event.motion.x; } if (cur_stream) { if(seek_by_bytes || cur_stream->ic->duration<=0){ uint64_t size= avio_size(cur_stream->ic->pb); stream_seek(cur_stream, size*x/cur_stream->width, 0, 1); }else{ int64_t ts; int ns, hh, mm, ss; int tns, thh, tmm, tss; tns = cur_stream->ic->duration/1000000LL; thh = tns/3600; tmm = (tns%3600)/60; tss = (tns%60); frac = x/cur_stream->width; ns = frac*tns; hh = ns/3600; mm = (ns%3600)/60; ss = (ns%60); fprintf(stderr, "Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d) \n", frac*100, hh, mm, ss, thh, tmm, tss); ts = frac*cur_stream->ic->duration; if (cur_stream->ic->start_time != AV_NOPTS_VALUE) ts += cur_stream->ic->start_time; stream_seek(cur_stream, ts, 0, 0); } } break; case SDL_VIDEORESIZE: if (cur_stream) { screen = SDL_SetVideoMode(event.resize.w, event.resize.h, 0, SDL_HWSURFACE|SDL_RESIZABLE|SDL_ASYNCBLIT|SDL_HWACCEL); screen_width = cur_stream->width = event.resize.w; screen_height= cur_stream->height= event.resize.h; } break; case SDL_QUIT: case FF_QUIT_EVENT: do_exit(cur_stream); break; case FF_ALLOC_EVENT: video_open(event.user.data1); alloc_picture(event.user.data1); break; case FF_REFRESH_EVENT: video_refresh(event.user.data1); cur_stream->refresh=0; break; default: break; } } }
--------------------------------------------- Result 1027 ---------------------------------------------
[[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int sox_read_packet(AVFormatContext *s, AVPacket *pkt) { int ret, size; if (url_feof(s->pb)) return AVERROR_EOF; size = SOX_SAMPLES*s->streams[0]->codec->block_align; ret = av_get_packet(s->pb, pkt, size); if (ret < 0) return AVERROR(EIO); pkt->stream_index = 0; pkt->size = ret; return 0; }
--------------------------------------------- Result 1028 ---------------------------------------------
[[0 (6%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int svq1_encode_init(AVCodecContext *avctx) { SVQ1Context * const s = avctx->priv_data; dsputil_init(&s->dsp, avctx); avctx->coded_frame= (AVFrame*)&s->picture; s->frame_width = avctx->width; s->frame_height = avctx->height; s->y_block_width = (s->frame_width + 15) / 16; s->y_block_height = (s->frame_height + 15) / 16; s->c_block_width = (s->frame_width / 4 + 15) / 16; s->c_block_height = (s->frame_height / 4 + 15) / 16; s->avctx= avctx; s->m.avctx= avctx; s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t)); s->m.me.map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t)); s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t)); s->mb_type = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t)); s->dummy = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t)); h263_encode_init(&s->m); return 0; }
--------------------------------------------- Result 1029 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 598 / 58 / 373 / 1029:  38%|      | 1029/2690 [12:11:26<19:40:40, 42.65s/it][Succeeded / Failed / Skipped / Total] 598 / 58 / 373 / 1029:  38%|      | 1030/2690 [12:11:30<19:38:56, 42.61s/it][Succeeded / Failed / Skipped / Total] 599 / 58 / 373 / 1030:  38%|      | 1030/2690 [12:11:30<19:38:56, 42.61s/it][Succeeded / Failed / Skipped / Total] 599 / 58 / 373 / 1030:  38%|      | 1031/2690 [12:12:30<19:38:41, 42.63s/it][Succeeded / Failed / Skipped / Total] 600 / 58 / 373 / 1031:  38%|      | 1031/2690 [12:12:30<19:38:41, 42.63s/it][Succeeded / Failed / Skipped / Total] 600 / 58 / 373 / 1031:  38%|      | 1032/2690 [12:12:30<19:36:51, 42.59s/it][Succeeded / Failed / Skipped / Total] 600 / 58 / 374 / 1032:  38%|      | 1032/2690 [12:12:30<19:36:51, 42.59s/it][Succeeded / Failed / Skipped / Total] 600 / 58 / 374 / 1032:  38%|      | 1033/2690 [12:12:48<19:35:28, 42.56s/it][[0 (96%)]] --> [[0 (43%)]] --> Socre: 0.5733391344547272

[[[[Adv]]]]: static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset) { AHCICmdHdr *cmd = ad->cur_cmd; uint32_t opts = le32_to_cpu(cmd->opts); uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80; int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN; dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG)); dma_addr_t real_prdt_len = prdt_len; uint8_t *prdt; int i; int r = 0; int sum = 0; int off_idx = -1; int off_pos = -1; int tbl_entry_size; IDEBus *bus = &ad->port; BusState *[[qbus]] = BUS(bus); if (!sglist_alloc_hint) { DPRINTF(ad->port_no, "no sg list given by guest: 0x%08x\n", opts); return -1; } if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len, DMA_DIRECTION_TO_DEVICE))){ DPRINTF(ad->port_no, "map failed\n"); return -1; } if (prdt_len < real_prdt_len) { DPRINTF(ad->port_no, "mapped less than expected\n"); r = -1; goto out; } if (sglist_alloc_hint > 0) { AHCI_SG *tbl = (AHCI_SG *)prdt; sum = 0; for (i = 0; i < sglist_alloc_hint; i++) { tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1); if (offset <= (sum + tbl_entry_size)) { off_idx = i; off_pos = offset - sum; break; } sum += tbl_entry_size; } if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) { DPRINTF(ad->port_no, "%s: Incorrect offset! " "off_idx: %d, off_pos: %d\n", __func__, off_idx, off_pos); r = -1; goto out; } qemu_sglist_init(sglist, [[qbus]]->parent, (sglist_alloc_hint - off_idx), ad->hba->as); qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos), le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos); for (i = off_idx + 1; i < sglist_alloc_hint; i++) { qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr), le32_to_cpu(tbl[i].flags_size) + 1); } } out: dma_memory_unmap(ad->hba->as, prdt, prdt_len, DMA_DIRECTION_TO_DEVICE, prdt_len); return r; }

[[[[Adv]]]]: static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset) { AHCICmdHdr *cmd = ad->cur_cmd; uint32_t opts = le32_to_cpu(cmd->opts); uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80; int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN; dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG)); dma_addr_t real_prdt_len = prdt_len; uint8_t *prdt; int i; int r = 0; int sum = 0; int off_idx = -1; int off_pos = -1; int tbl_entry_size; IDEBus *bus = &ad->port; BusState *[[colonialism]] = BUS(bus); if (!sglist_alloc_hint) { DPRINTF(ad->port_no, "no sg list given by guest: 0x%08x\n", opts); return -1; } if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len, DMA_DIRECTION_TO_DEVICE))){ DPRINTF(ad->port_no, "map failed\n"); return -1; } if (prdt_len < real_prdt_len) { DPRINTF(ad->port_no, "mapped less than expected\n"); r = -1; goto out; } if (sglist_alloc_hint > 0) { AHCI_SG *tbl = (AHCI_SG *)prdt; sum = 0; for (i = 0; i < sglist_alloc_hint; i++) { tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1); if (offset <= (sum + tbl_entry_size)) { off_idx = i; off_pos = offset - sum; break; } sum += tbl_entry_size; } if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) { DPRINTF(ad->port_no, "%s: Incorrect offset! " "off_idx: %d, off_pos: %d\n", __func__, off_idx, off_pos); r = -1; goto out; } qemu_sglist_init(sglist, [[colonialism]]->parent, (sglist_alloc_hint - off_idx), ad->hba->as); qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos), le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos); for (i = off_idx + 1; i < sglist_alloc_hint; i++) { qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr), le32_to_cpu(tbl[i].flags_size) + 1); } } out: dma_memory_unmap(ad->hba->as, prdt, prdt_len, DMA_DIRECTION_TO_DEVICE, prdt_len); return r; }
--------------------------------------------- Result 1030 ---------------------------------------------
[[0 (55%)]] --> [[0 (49%)]] --> Socre: 0.507937878370285

[[[[Adv]]]]: static av_always_inline void mpeg_motion_lowres(MpegEncContext *s, uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr, int field_based, int bottom_field, int field_select, uint8_t **ref_picture, h264_chroma_mc_func *pix_op, int [[motion_x]], int motion_y, int h, int mb_y) { uint8_t *ptr_y, *ptr_cb, *ptr_cr; int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, uvlinesize, linesize, sx, sy, uvsx, uvsy; const int lowres = s->avctx->lowres; const int op_index = FFMIN(lowres, 2); const int block_s = 8>>lowres; const int s_mask = (2 << lowres) - 1; const int h_edge_pos = s->h_edge_pos >> lowres; const int v_edge_pos = s->v_edge_pos >> lowres; linesize = s->current_picture.f.linesize[0] << field_based; uvlinesize = s->current_picture.f.linesize[1] << field_based; if (s->quarter_sample) { [[motion_x]] /= 2; motion_y /= 2; } if (field_based) { motion_y += (bottom_field - field_select) * (1 << lowres - 1); } sx = [[motion_x]] & s_mask; sy = motion_y & s_mask; src_x = s->mb_x * 2 * block_s + ([[motion_x]] >> lowres + 1); src_y = (mb_y * 2 * block_s >> field_based) + (motion_y >> lowres + 1); if (s->out_format == FMT_H263) { uvsx = (([[motion_x]] >> 1) & s_mask) | (sx & 1); uvsy = ((motion_y >> 1) & s_mask) | (sy & 1); uvsrc_x = src_x >> 1; uvsrc_y = src_y >> 1; } else if (s->out_format == FMT_H261) { mx = [[motion_x]] / 4; my = motion_y / 4; uvsx = (2 * mx) & s_mask; uvsy = (2 * my) & s_mask; uvsrc_x = s->mb_x * block_s + (mx >> lowres); uvsrc_y = mb_y * block_s + (my >> lowres); } else { mx = [[motion_x]] / 2; my = motion_y / 2; uvsx = mx & s_mask; uvsy = my & s_mask; uvsrc_x = s->mb_x * block_s + (mx >> lowres + 1); uvsrc_y = (mb_y * block_s >> field_based) + (my >> lowres + 1); } ptr_y = ref_picture[0] + src_y * linesize + src_x; ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x; ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x; if ((unsigned) src_x > h_edge_pos - (!!sx) - 2 * block_s || (unsigned) src_y > (v_edge_pos >> field_based) - (!!sy) - h) { s->dsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y, s->linesize, 17, 17 + field_based, src_x, src_y << field_based, h_edge_pos, v_edge_pos); ptr_y = s->edge_emu_buffer; if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) { uint8_t *uvbuf = s->edge_emu_buffer + 18 * s->linesize; s->dsp.emulated_edge_mc(uvbuf , ptr_cb, s->uvlinesize, 9, 9 + field_based, uvsrc_x, uvsrc_y << field_based, h_edge_pos >> 1, v_edge_pos >> 1); s->dsp.emulated_edge_mc(uvbuf + 16, ptr_cr, s->uvlinesize, 9, 9 + field_based, uvsrc_x, uvsrc_y << field_based, h_edge_pos >> 1, v_edge_pos >> 1); ptr_cb = uvbuf; ptr_cr = uvbuf + 16; } } if (bottom_field) { dest_y += s->linesize; dest_cb += s->uvlinesize; dest_cr += s->uvlinesize; } if (field_select) { ptr_y += s->linesize; ptr_cb += s->uvlinesize; ptr_cr += s->uvlinesize; } sx = (sx << 2) >> lowres; sy = (sy << 2) >> lowres; pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy); if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) { uvsx = (uvsx << 2) >> lowres; uvsy = (uvsy << 2) >> lowres; pix_op[op_index](dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift, uvsx, uvsy); pix_op[op_index](dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift, uvsx, uvsy); } }

[[[[Adv]]]]: static av_always_inline void mpeg_motion_lowres(MpegEncContext *s, uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr, int field_based, int bottom_field, int field_select, uint8_t **ref_picture, h264_chroma_mc_func *pix_op, int [[kuwait]], int motion_y, int h, int mb_y) { uint8_t *ptr_y, *ptr_cb, *ptr_cr; int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, uvlinesize, linesize, sx, sy, uvsx, uvsy; const int lowres = s->avctx->lowres; const int op_index = FFMIN(lowres, 2); const int block_s = 8>>lowres; const int s_mask = (2 << lowres) - 1; const int h_edge_pos = s->h_edge_pos >> lowres; const int v_edge_pos = s->v_edge_pos >> lowres; linesize = s->current_picture.f.linesize[0] << field_based; uvlinesize = s->current_picture.f.linesize[1] << field_based; if (s->quarter_sample) { [[kuwait]] /= 2; motion_y /= 2; } if (field_based) { motion_y += (bottom_field - field_select) * (1 << lowres - 1); } sx = [[kuwait]] & s_mask; sy = motion_y & s_mask; src_x = s->mb_x * 2 * block_s + ([[kuwait]] >> lowres + 1); src_y = (mb_y * 2 * block_s >> field_based) + (motion_y >> lowres + 1); if (s->out_format == FMT_H263) { uvsx = (([[kuwait]] >> 1) & s_mask) | (sx & 1); uvsy = ((motion_y >> 1) & s_mask) | (sy & 1); uvsrc_x = src_x >> 1; uvsrc_y = src_y >> 1; } else if (s->out_format == FMT_H261) { mx = [[kuwait]] / 4; my = motion_y / 4; uvsx = (2 * mx) & s_mask; uvsy = (2 * my) & s_mask; uvsrc_x = s->mb_x * block_s + (mx >> lowres); uvsrc_y = mb_y * block_s + (my >> lowres); } else { mx = [[kuwait]] / 2; my = motion_y / 2; uvsx = mx & s_mask; uvsy = my & s_mask; uvsrc_x = s->mb_x * block_s + (mx >> lowres + 1); uvsrc_y = (mb_y * block_s >> field_based) + (my >> lowres + 1); } ptr_y = ref_picture[0] + src_y * linesize + src_x; ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x; ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x; if ((unsigned) src_x > h_edge_pos - (!!sx) - 2 * block_s || (unsigned) src_y > (v_edge_pos >> field_based) - (!!sy) - h) { s->dsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y, s->linesize, 17, 17 + field_based, src_x, src_y << field_based, h_edge_pos, v_edge_pos); ptr_y = s->edge_emu_buffer; if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) { uint8_t *uvbuf = s->edge_emu_buffer + 18 * s->linesize; s->dsp.emulated_edge_mc(uvbuf , ptr_cb, s->uvlinesize, 9, 9 + field_based, uvsrc_x, uvsrc_y << field_based, h_edge_pos >> 1, v_edge_pos >> 1); s->dsp.emulated_edge_mc(uvbuf + 16, ptr_cr, s->uvlinesize, 9, 9 + field_based, uvsrc_x, uvsrc_y << field_based, h_edge_pos >> 1, v_edge_pos >> 1); ptr_cb = uvbuf; ptr_cr = uvbuf + 16; } } if (bottom_field) { dest_y += s->linesize; dest_cb += s->uvlinesize; dest_cr += s->uvlinesize; } if (field_select) { ptr_y += s->linesize; ptr_cb += s->uvlinesize; ptr_cr += s->uvlinesize; } sx = (sx << 2) >> lowres; sy = (sy << 2) >> lowres; pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy); if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) { uvsx = (uvsx << 2) >> lowres; uvsy = (uvsy << 2) >> lowres; pix_op[op_index](dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift, uvsx, uvsy); pix_op[op_index](dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift, uvsx, uvsy); } }
--------------------------------------------- Result 1031 ---------------------------------------------
[[0 (87%)]] --> [[0 (47%)]] --> Socre: 0.5324462652206421

[[[[Adv]]]]: static inline uint8_t *ram_chunk_start(const RDMALocalBlock *[[rdma_ram_block]], uint64_t i) { return (uint8_t *) (((uintptr_t) [[rdma_ram_block]]->local_host_addr) + (i << RDMA_REG_CHUNK_SHIFT)); }

[[[[Adv]]]]: static inline uint8_t *ram_chunk_start(const RDMALocalBlock *[[libretto]], uint64_t i) { return (uint8_t *) (((uintptr_t) [[libretto]]->local_host_addr) + (i << RDMA_REG_CHUNK_SHIFT)); }
--------------------------------------------- Result 1032 ---------------------------------------------
[[0 (10%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void csrhci_reset(struct csrhci_s *s) { s->out_len = 0; s->out_size = FIFO_LEN; s->in_len = 0; s->baud_delay = NANOSECONDS_PER_SECOND; s->enable = 0; s->in_hdr = INT_MAX; s->in_data = INT_MAX; s->modem_state = 0; s->modem_state |= CHR_TIOCM_CTS; memset(&s->bd_addr, 0, sizeof(bdaddr_t)); }
--------------------------------------------- Result 1033 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 601 / 58 / 374 / 1033:  38%|      | 1033/2690 [12:12:48<19:35:28, 42.56s/it][Succeeded / Failed / Skipped / Total] 601 / 58 / 374 / 1033:  38%|      | 1034/2690 [12:12:48<19:33:38, 42.52s/it][Succeeded / Failed / Skipped / Total] 601 / 58 / 375 / 1034:  38%|      | 1034/2690 [12:12:48<19:33:38, 42.52s/it][Succeeded / Failed / Skipped / Total] 601 / 58 / 375 / 1034:  38%|      | 1035/2690 [12:12:49<19:31:48, 42.48s/it][Succeeded / Failed / Skipped / Total] 601 / 58 / 376 / 1035:  38%|      | 1035/2690 [12:12:49<19:31:48, 42.48s/it][Succeeded / Failed / Skipped / Total] 601 / 58 / 376 / 1035:  39%|      | 1036/2690 [12:12:49<19:29:58, 42.44s/it][Succeeded / Failed / Skipped / Total] 601 / 58 / 377 / 1036:  39%|      | 1036/2690 [12:12:49<19:29:58, 42.44s/it][Succeeded / Failed / Skipped / Total] 601 / 58 / 377 / 1036:  39%|      | 1037/2690 [12:14:18<19:30:29, 42.49s/it][[0 (96%)]] --> [[0 (35%)]] --> Socre: 0.6484828591346741

[[[[Adv]]]]: void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int [[src_size]]) { unsigned i; unsigned [[num_pixels]] = [[src_size]] >> 1; for(i=0; i<[[num_pixels]]; i++) { unsigned b,g,r; register uint16_t rgb; rgb = src[2*i]; r = rgb&0x1F; g = (rgb&0x3E0)>>5; b = (rgb&0x7C00)>>10; dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10); } }

[[[[Adv]]]]: void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int [[jaspers]]) { unsigned i; unsigned [[typesetter]] = [[jaspers]] >> 1; for(i=0; i<[[typesetter]]; i++) { unsigned b,g,r; register uint16_t rgb; rgb = src[2*i]; r = rgb&0x1F; g = (rgb&0x3E0)>>5; b = (rgb&0x7C00)>>10; dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10); } }
--------------------------------------------- Result 1034 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int net_init_vhost_user(const Netdev *netdev, const char *name, NetClientState *peer, Error **errp) { int queues; const NetdevVhostUserOptions *vhost_user_opts; CharDriverState *chr; assert(netdev->type == NET_CLIENT_DRIVER_VHOST_USER); vhost_user_opts = &netdev->u.vhost_user; chr = net_vhost_parse_chardev(vhost_user_opts, errp); if (!chr) { return -1; } if (qemu_opts_foreach(qemu_find_opts("device"), net_vhost_check_net, (char *)name, errp)) { return -1; } queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1; if (queues < 1 || queues > MAX_QUEUE_NUM) { error_setg(errp, "vhost-user number of queues must be in range [1, %d]", MAX_QUEUE_NUM); return -1; } return net_vhost_user_init(peer, "vhost_user", name, chr, queues); }
--------------------------------------------- Result 1035 ---------------------------------------------
[[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int lag_decode_prob(GetBitContext *gb, uint32_t *value) { static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 }; int i; int bit = 0; int bits = 0; int prevbit = 0; unsigned val; for (i = 0; i < 7; i++) { if (prevbit && bit) break; prevbit = bit; bit = get_bits1(gb); if (bit && !prevbit) bits += series[i]; } bits--; if (bits < 0 || bits > 31) { *value = 0; return -1; } else if (bits == 0) { *value = 0; return 0; } val = get_bits_long(gb, bits); val |= 1 << bits; *value = val - 1; return 0; }
--------------------------------------------- Result 1036 ---------------------------------------------
[[0 (7%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void check_add_res(HEVCDSPContext h, int bit_depth) { int i; LOCAL_ALIGNED_32(int16_t, res0, [32 * 32]); LOCAL_ALIGNED_32(int16_t, res1, [32 * 32]); LOCAL_ALIGNED_32(uint8_t, dst0, [32 * 32 * 2]); LOCAL_ALIGNED_32(uint8_t, dst1, [32 * 32 * 2]); for (i = 2; i <= 5; i++) { int block_size = 1 << i; int size = block_size * block_size; ptrdiff_t stride = block_size << (bit_depth > 8); declare_func_emms(AV_CPU_FLAG_MMX, void, uint8_t *dst, int16_t *res, ptrdiff_t stride); randomize_buffers(res0, size); randomize_buffers2(dst0, size); memcpy(res1, res0, sizeof(*res0) * size); memcpy(dst1, dst0, size); if (check_func(h.add_residual[i - 2], "add_res_%dx%d_%d", block_size, block_size, bit_depth)) { call_ref(dst0, res0, stride); call_new(dst1, res1, stride); if (memcmp(dst0, dst1, size)) fail(); bench_new(dst1, res1, stride); } } }
--------------------------------------------- Result 1037 ---------------------------------------------
[[0 (71%)]] --> [[0 (48%)]] --> Socre: 0.5163495242595673

[[[[Adv]]]]: static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *[[avpkt]]) { const uint8_t *buf = [[avpkt]]->data; unsigned int buf_size = [[avpkt]]->size; const uint8_t *buf_end = buf + buf_size; const AVPixFmtDescriptor *desc; EXRContext *const s = avctx->priv_data; AVFrame *picture = data; AVFrame *const p = &s->picture; uint8_t *ptr; int i, x, y, stride, magic_number, version, flags, ret; int w = 0; int h = 0; unsigned int xmin = ~0; unsigned int [[xmax]] = ~0; unsigned int ymin = ~0; unsigned int ymax = ~0; unsigned int xdelta = ~0; int out_line_size; int bxmin, axmax; int scan_lines_per_block; unsigned long scan_line_size; unsigned long uncompressed_size; unsigned int current_channel_offset = 0; s->channel_offsets[0] = -1; s->channel_offsets[1] = -1; s->channel_offsets[2] = -1; s->channel_offsets[3] = -1; s->bits_per_color_id = -1; s->compr = -1; if (buf_size < 10) { av_log(avctx, AV_LOG_ERROR, "Too short header to parse\n"); return AVERROR_INVALIDDATA; } magic_number = bytestream_get_le32(&buf); if (magic_number != 20000630) { av_log(avctx, AV_LOG_ERROR, "Wrong magic number %d\n", magic_number); return AVERROR_INVALIDDATA; } version = bytestream_get_byte(&buf); if (version != 2) { av_log(avctx, AV_LOG_ERROR, "Unsupported version %d\n", version); return AVERROR_PATCHWELCOME; } flags = bytestream_get_le24(&buf); if (flags & 0x2) { av_log(avctx, AV_LOG_ERROR, "Tile based images are not supported\n"); return AVERROR_PATCHWELCOME; } while (buf < buf_end && buf[0]) { unsigned int variable_buffer_data_size; if (check_header_variable(avctx, &buf, buf_end, "channels", "chlist", 38, &variable_buffer_data_size) >= 0) { const uint8_t *channel_list_end; if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; channel_list_end = buf + variable_buffer_data_size; while (channel_list_end - buf >= 19) { int current_bits_per_color_id = -1; int channel_index = -1; if (!strcmp(buf, "R")) channel_index = 0; else if (!strcmp(buf, "G")) channel_index = 1; else if (!strcmp(buf, "B")) channel_index = 2; else if (!strcmp(buf, "A")) channel_index = 3; else av_log(avctx, AV_LOG_WARNING, "Unsupported channel %.256s\n", buf); while (bytestream_get_byte(&buf) && buf < channel_list_end) continue; if (channel_list_end - * &buf < 4) { av_log(avctx, AV_LOG_ERROR, "Incomplete header\n"); return AVERROR_INVALIDDATA; } current_bits_per_color_id = bytestream_get_le32(&buf); if (current_bits_per_color_id > 2) { av_log(avctx, AV_LOG_ERROR, "Unknown color format\n"); return AVERROR_INVALIDDATA; } if (channel_index >= 0) { if (s->bits_per_color_id != -1 && s->bits_per_color_id != current_bits_per_color_id) { av_log(avctx, AV_LOG_ERROR, "RGB channels not of the same depth\n"); return AVERROR_INVALIDDATA; } s->bits_per_color_id = current_bits_per_color_id; s->channel_offsets[channel_index] = current_channel_offset; } current_channel_offset += 1 << current_bits_per_color_id; buf += 12; } if (FFMIN3(s->channel_offsets[0], s->channel_offsets[1], s->channel_offsets[2]) < 0) { if (s->channel_offsets[0] < 0) av_log(avctx, AV_LOG_ERROR, "Missing red channel\n"); if (s->channel_offsets[1] < 0) av_log(avctx, AV_LOG_ERROR, "Missing green channel\n"); if (s->channel_offsets[2] < 0) av_log(avctx, AV_LOG_ERROR, "Missing blue channel\n"); return AVERROR_INVALIDDATA; } buf = channel_list_end; continue; } else if (check_header_variable(avctx, &buf, buf_end, "dataWindow", "box2i", 31, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; xmin = AV_RL32(buf); ymin = AV_RL32(buf + 4); [[xmax]] = AV_RL32(buf + 8); ymax = AV_RL32(buf + 12); xdelta = ([[xmax]]-xmin) + 1; buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "displayWindow", "box2i", 34, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; w = AV_RL32(buf + 8) + 1; h = AV_RL32(buf + 12) + 1; buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "lineOrder", "lineOrder", 25, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; if (*buf) { av_log(avctx, AV_LOG_ERROR, "Doesn't support this line order : %d\n", *buf); return AVERROR_PATCHWELCOME; } buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "pixelAspectRatio", "float", 31, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; avctx->sample_aspect_ratio = av_d2q(av_int2float(AV_RL32(buf)), 255); buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "compression", "compression", 29, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; if (s->compr == -1) s->compr = *buf; else av_log(avctx, AV_LOG_WARNING, "Found more than one compression attribute\n"); buf += variable_buffer_data_size; continue; } if (buf_end - buf <= 9) { av_log(avctx, AV_LOG_ERROR, "Incomplete header\n"); return AVERROR_INVALIDDATA; } for (i = 0; i < 2; i++) { while (++buf < buf_end) if (buf[0] == 0x0) break; } buf++; if (buf_end - buf >= 5) { variable_buffer_data_size = get_header_variable_length(&buf, buf_end); if (!variable_buffer_data_size) { av_log(avctx, AV_LOG_ERROR, "Incomplete header\n"); return AVERROR_INVALIDDATA; } buf += variable_buffer_data_size; } } if (s->compr == -1) { av_log(avctx, AV_LOG_ERROR, "Missing compression attribute\n"); return AVERROR_INVALIDDATA; } if (buf >= buf_end) { av_log(avctx, AV_LOG_ERROR, "Incomplete frame\n"); return AVERROR_INVALIDDATA; } buf++; switch (s->bits_per_color_id) { case 2: case 1: if (s->channel_offsets[3] >= 0) avctx->pix_fmt = AV_PIX_FMT_RGBA64; else avctx->pix_fmt = AV_PIX_FMT_RGB48; break; case 0: av_log_missing_feature(avctx, "8-bit OpenEXR", 1); return AVERROR_PATCHWELCOME; default: av_log(avctx, AV_LOG_ERROR, "Unknown color format : %d\n", s->bits_per_color_id); return AVERROR_INVALIDDATA; } switch (s->compr) { case EXR_RAW: case EXR_RLE: case EXR_ZIP1: scan_lines_per_block = 1; break; case EXR_ZIP16: scan_lines_per_block = 16; break; default: av_log(avctx, AV_LOG_ERROR, "Compression type %d is not supported\n", s->compr); return AVERROR_PATCHWELCOME; } if (s->picture.data[0]) ff_thread_release_buffer(avctx, &s->picture); if (av_image_check_size(w, h, 0, avctx)) return AVERROR_INVALIDDATA; if (xmin > [[xmax]] || ymin > ymax || xdelta != [[xmax]] - xmin + 1 || [[xmax]] >= w || ymax >= h) { av_log(avctx, AV_LOG_ERROR, "Wrong sizing or missing size information\n"); return AVERROR_INVALIDDATA; } if (w != avctx->width || h != avctx->height) { avcodec_set_dimensions(avctx, w, h); } desc = av_pix_fmt_desc_get(avctx->pix_fmt); bxmin = xmin * 2 * desc->nb_components; axmax = (avctx->width - ([[xmax]] + 1)) * 2 * desc->nb_components; out_line_size = avctx->width * 2 * desc->nb_components; scan_line_size = xdelta * current_channel_offset; uncompressed_size = scan_line_size * scan_lines_per_block; if (s->compr != EXR_RAW) { av_fast_padded_malloc(&s->uncompressed_data, &s->uncompressed_size, uncompressed_size); av_fast_padded_malloc(&s->tmp, &s->tmp_size, uncompressed_size); if (!s->uncompressed_data || !s->tmp) return AVERROR(ENOMEM); } if ((ret = ff_thread_get_buffer(avctx, p)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } ptr = p->data[0]; stride = p->linesize[0]; for (y = 0; y < ymin; y++) { memset(ptr, 0, out_line_size); ptr += stride; } for (y = ymin; y <= ymax; y += scan_lines_per_block) { uint16_t *ptr_x = (uint16_t *)ptr; if (buf_end - buf > 8) { const uint64_t line_offset = bytestream_get_le64(&buf) + 8; int32_t data_size; if ((line_offset > buf_size) || (s->compr == EXR_RAW && line_offset > [[avpkt]]->size - xdelta * current_channel_offset) || (s->compr != EXR_RAW && line_offset > buf_size - (data_size = AV_RL32([[avpkt]]->data + line_offset - 4)))) { av_log(avctx, AV_LOG_WARNING, "Line offset for line %d is out of reach setting it to black\n", y); for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) { ptr_x = (uint16_t *)ptr; memset(ptr_x, 0, out_line_size); } } else { const uint8_t *red_channel_buffer, *green_channel_buffer, *blue_channel_buffer, *alpha_channel_buffer = 0; if (scan_lines_per_block > 1) uncompressed_size = scan_line_size * FFMIN(scan_lines_per_block, ymax - y + 1); if ((s->compr == EXR_ZIP1 || s->compr == EXR_ZIP16) && data_size < uncompressed_size) { unsigned long dest_len = uncompressed_size; if (uncompress(s->tmp, &dest_len, [[avpkt]]->data + line_offset, data_size) != Z_OK || dest_len != uncompressed_size) { av_log(avctx, AV_LOG_ERROR, "error during zlib decompression\n"); return AVERROR(EINVAL); } } else if (s->compr == EXR_RLE && data_size < uncompressed_size) { if (rle_uncompress([[avpkt]]->data + line_offset, data_size, s->tmp, uncompressed_size)) { av_log(avctx, AV_LOG_ERROR, "error during rle decompression\n"); return AVERROR(EINVAL); } } if (s->compr != EXR_RAW && data_size < uncompressed_size) { predictor(s->tmp, uncompressed_size); reorder_pixels(s->tmp, s->uncompressed_data, uncompressed_size); red_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[0]; green_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[1]; blue_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[2]; if (s->channel_offsets[3] >= 0) alpha_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[3]; } else { red_channel_buffer = [[avpkt]]->data + line_offset + xdelta * s->channel_offsets[0]; green_channel_buffer = [[avpkt]]->data + line_offset + xdelta * s->channel_offsets[1]; blue_channel_buffer = [[avpkt]]->data + line_offset + xdelta * s->channel_offsets[2]; if (s->channel_offsets[3] >= 0) alpha_channel_buffer = [[avpkt]]->data + line_offset + xdelta * s->channel_offsets[3]; } for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) { const uint8_t *r, *g, *b, *a; r = red_channel_buffer; g = green_channel_buffer; b = blue_channel_buffer; if (alpha_channel_buffer) a = alpha_channel_buffer; ptr_x = (uint16_t *)ptr; memset(ptr_x, 0, bxmin); ptr_x += xmin * desc->nb_components; if (s->bits_per_color_id == 2) { for (x = 0; x < xdelta; x++) { *ptr_x++ = exr_flt2uint(bytestream_get_le32(&r)); *ptr_x++ = exr_flt2uint(bytestream_get_le32(&g)); *ptr_x++ = exr_flt2uint(bytestream_get_le32(&b)); if (alpha_channel_buffer) *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a)); } } else { for (x = 0; x < xdelta; x++) { *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&r)); *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&g)); *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&b)); if (alpha_channel_buffer) *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&a)); } } memset(ptr_x, 0, axmax); red_channel_buffer += scan_line_size; green_channel_buffer += scan_line_size; blue_channel_buffer += scan_line_size; if (alpha_channel_buffer) alpha_channel_buffer += scan_line_size; } } } } for (y = ymax + 1; y < avctx->height; y++) { memset(ptr, 0, out_line_size); ptr += stride; } *picture = s->picture; *got_frame = 1; return buf_size; }

[[[[Adv]]]]: static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *[[recognisable]]) { const uint8_t *buf = [[recognisable]]->data; unsigned int buf_size = [[recognisable]]->size; const uint8_t *buf_end = buf + buf_size; const AVPixFmtDescriptor *desc; EXRContext *const s = avctx->priv_data; AVFrame *picture = data; AVFrame *const p = &s->picture; uint8_t *ptr; int i, x, y, stride, magic_number, version, flags, ret; int w = 0; int h = 0; unsigned int xmin = ~0; unsigned int [[theological]] = ~0; unsigned int ymin = ~0; unsigned int ymax = ~0; unsigned int xdelta = ~0; int out_line_size; int bxmin, axmax; int scan_lines_per_block; unsigned long scan_line_size; unsigned long uncompressed_size; unsigned int current_channel_offset = 0; s->channel_offsets[0] = -1; s->channel_offsets[1] = -1; s->channel_offsets[2] = -1; s->channel_offsets[3] = -1; s->bits_per_color_id = -1; s->compr = -1; if (buf_size < 10) { av_log(avctx, AV_LOG_ERROR, "Too short header to parse\n"); return AVERROR_INVALIDDATA; } magic_number = bytestream_get_le32(&buf); if (magic_number != 20000630) { av_log(avctx, AV_LOG_ERROR, "Wrong magic number %d\n", magic_number); return AVERROR_INVALIDDATA; } version = bytestream_get_byte(&buf); if (version != 2) { av_log(avctx, AV_LOG_ERROR, "Unsupported version %d\n", version); return AVERROR_PATCHWELCOME; } flags = bytestream_get_le24(&buf); if (flags & 0x2) { av_log(avctx, AV_LOG_ERROR, "Tile based images are not supported\n"); return AVERROR_PATCHWELCOME; } while (buf < buf_end && buf[0]) { unsigned int variable_buffer_data_size; if (check_header_variable(avctx, &buf, buf_end, "channels", "chlist", 38, &variable_buffer_data_size) >= 0) { const uint8_t *channel_list_end; if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; channel_list_end = buf + variable_buffer_data_size; while (channel_list_end - buf >= 19) { int current_bits_per_color_id = -1; int channel_index = -1; if (!strcmp(buf, "R")) channel_index = 0; else if (!strcmp(buf, "G")) channel_index = 1; else if (!strcmp(buf, "B")) channel_index = 2; else if (!strcmp(buf, "A")) channel_index = 3; else av_log(avctx, AV_LOG_WARNING, "Unsupported channel %.256s\n", buf); while (bytestream_get_byte(&buf) && buf < channel_list_end) continue; if (channel_list_end - * &buf < 4) { av_log(avctx, AV_LOG_ERROR, "Incomplete header\n"); return AVERROR_INVALIDDATA; } current_bits_per_color_id = bytestream_get_le32(&buf); if (current_bits_per_color_id > 2) { av_log(avctx, AV_LOG_ERROR, "Unknown color format\n"); return AVERROR_INVALIDDATA; } if (channel_index >= 0) { if (s->bits_per_color_id != -1 && s->bits_per_color_id != current_bits_per_color_id) { av_log(avctx, AV_LOG_ERROR, "RGB channels not of the same depth\n"); return AVERROR_INVALIDDATA; } s->bits_per_color_id = current_bits_per_color_id; s->channel_offsets[channel_index] = current_channel_offset; } current_channel_offset += 1 << current_bits_per_color_id; buf += 12; } if (FFMIN3(s->channel_offsets[0], s->channel_offsets[1], s->channel_offsets[2]) < 0) { if (s->channel_offsets[0] < 0) av_log(avctx, AV_LOG_ERROR, "Missing red channel\n"); if (s->channel_offsets[1] < 0) av_log(avctx, AV_LOG_ERROR, "Missing green channel\n"); if (s->channel_offsets[2] < 0) av_log(avctx, AV_LOG_ERROR, "Missing blue channel\n"); return AVERROR_INVALIDDATA; } buf = channel_list_end; continue; } else if (check_header_variable(avctx, &buf, buf_end, "dataWindow", "box2i", 31, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; xmin = AV_RL32(buf); ymin = AV_RL32(buf + 4); [[theological]] = AV_RL32(buf + 8); ymax = AV_RL32(buf + 12); xdelta = ([[theological]]-xmin) + 1; buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "displayWindow", "box2i", 34, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; w = AV_RL32(buf + 8) + 1; h = AV_RL32(buf + 12) + 1; buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "lineOrder", "lineOrder", 25, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; if (*buf) { av_log(avctx, AV_LOG_ERROR, "Doesn't support this line order : %d\n", *buf); return AVERROR_PATCHWELCOME; } buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "pixelAspectRatio", "float", 31, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; avctx->sample_aspect_ratio = av_d2q(av_int2float(AV_RL32(buf)), 255); buf += variable_buffer_data_size; continue; } else if (check_header_variable(avctx, &buf, buf_end, "compression", "compression", 29, &variable_buffer_data_size) >= 0) { if (!variable_buffer_data_size) return AVERROR_INVALIDDATA; if (s->compr == -1) s->compr = *buf; else av_log(avctx, AV_LOG_WARNING, "Found more than one compression attribute\n"); buf += variable_buffer_data_size; continue; } if (buf_end - buf <= 9) { av_log(avctx, AV_LOG_ERROR, "Incomplete header\n"); return AVERROR_INVALIDDATA; } for (i = 0; i < 2; i++) { while (++buf < buf_end) if (buf[0] == 0x0) break; } buf++; if (buf_end - buf >= 5) { variable_buffer_data_size = get_header_variable_length(&buf, buf_end); if (!variable_buffer_data_size) { av_log(avctx, AV_LOG_ERROR, "Incomplete header\n"); return AVERROR_INVALIDDATA; } buf += variable_buffer_data_size; } } if (s->compr == -1) { av_log(avctx, AV_LOG_ERROR, "Missing compression attribute\n"); return AVERROR_INVALIDDATA; } if (buf >= buf_end) { av_log(avctx, AV_LOG_ERROR, "Incomplete frame\n"); return AVERROR_INVALIDDATA; } buf++; switch (s->bits_per_color_id) { case 2: case 1: if (s->channel_offsets[3] >= 0) avctx->pix_fmt = AV_PIX_FMT_RGBA64; else avctx->pix_fmt = AV_PIX_FMT_RGB48; break; case 0: av_log_missing_feature(avctx, "8-bit OpenEXR", 1); return AVERROR_PATCHWELCOME; default: av_log(avctx, AV_LOG_ERROR, "Unknown color format : %d\n", s->bits_per_color_id); return AVERROR_INVALIDDATA; } switch (s->compr) { case EXR_RAW: case EXR_RLE: case EXR_ZIP1: scan_lines_per_block = 1; break; case EXR_ZIP16: scan_lines_per_block = 16; break; default: av_log(avctx, AV_LOG_ERROR, "Compression type %d is not supported\n", s->compr); return AVERROR_PATCHWELCOME; } if (s->picture.data[0]) ff_thread_release_buffer(avctx, &s->picture); if (av_image_check_size(w, h, 0, avctx)) return AVERROR_INVALIDDATA; if (xmin > [[theological]] || ymin > ymax || xdelta != [[theological]] - xmin + 1 || [[theological]] >= w || ymax >= h) { av_log(avctx, AV_LOG_ERROR, "Wrong sizing or missing size information\n"); return AVERROR_INVALIDDATA; } if (w != avctx->width || h != avctx->height) { avcodec_set_dimensions(avctx, w, h); } desc = av_pix_fmt_desc_get(avctx->pix_fmt); bxmin = xmin * 2 * desc->nb_components; axmax = (avctx->width - ([[theological]] + 1)) * 2 * desc->nb_components; out_line_size = avctx->width * 2 * desc->nb_components; scan_line_size = xdelta * current_channel_offset; uncompressed_size = scan_line_size * scan_lines_per_block; if (s->compr != EXR_RAW) { av_fast_padded_malloc(&s->uncompressed_data, &s->uncompressed_size, uncompressed_size); av_fast_padded_malloc(&s->tmp, &s->tmp_size, uncompressed_size); if (!s->uncompressed_data || !s->tmp) return AVERROR(ENOMEM); } if ((ret = ff_thread_get_buffer(avctx, p)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } ptr = p->data[0]; stride = p->linesize[0]; for (y = 0; y < ymin; y++) { memset(ptr, 0, out_line_size); ptr += stride; } for (y = ymin; y <= ymax; y += scan_lines_per_block) { uint16_t *ptr_x = (uint16_t *)ptr; if (buf_end - buf > 8) { const uint64_t line_offset = bytestream_get_le64(&buf) + 8; int32_t data_size; if ((line_offset > buf_size) || (s->compr == EXR_RAW && line_offset > [[recognisable]]->size - xdelta * current_channel_offset) || (s->compr != EXR_RAW && line_offset > buf_size - (data_size = AV_RL32([[recognisable]]->data + line_offset - 4)))) { av_log(avctx, AV_LOG_WARNING, "Line offset for line %d is out of reach setting it to black\n", y); for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) { ptr_x = (uint16_t *)ptr; memset(ptr_x, 0, out_line_size); } } else { const uint8_t *red_channel_buffer, *green_channel_buffer, *blue_channel_buffer, *alpha_channel_buffer = 0; if (scan_lines_per_block > 1) uncompressed_size = scan_line_size * FFMIN(scan_lines_per_block, ymax - y + 1); if ((s->compr == EXR_ZIP1 || s->compr == EXR_ZIP16) && data_size < uncompressed_size) { unsigned long dest_len = uncompressed_size; if (uncompress(s->tmp, &dest_len, [[recognisable]]->data + line_offset, data_size) != Z_OK || dest_len != uncompressed_size) { av_log(avctx, AV_LOG_ERROR, "error during zlib decompression\n"); return AVERROR(EINVAL); } } else if (s->compr == EXR_RLE && data_size < uncompressed_size) { if (rle_uncompress([[recognisable]]->data + line_offset, data_size, s->tmp, uncompressed_size)) { av_log(avctx, AV_LOG_ERROR, "error during rle decompression\n"); return AVERROR(EINVAL); } } if (s->compr != EXR_RAW && data_size < uncompressed_size) { predictor(s->tmp, uncompressed_size); reorder_pixels(s->tmp, s->uncompressed_data, uncompressed_size); red_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[0]; green_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[1]; blue_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[2]; if (s->channel_offsets[3] >= 0) alpha_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[3]; } else { red_channel_buffer = [[recognisable]]->data + line_offset + xdelta * s->channel_offsets[0]; green_channel_buffer = [[recognisable]]->data + line_offset + xdelta * s->channel_offsets[1]; blue_channel_buffer = [[recognisable]]->data + line_offset + xdelta * s->channel_offsets[2]; if (s->channel_offsets[3] >= 0) alpha_channel_buffer = [[recognisable]]->data + line_offset + xdelta * s->channel_offsets[3]; } for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) { const uint8_t *r, *g, *b, *a; r = red_channel_buffer; g = green_channel_buffer; b = blue_channel_buffer; if (alpha_channel_buffer) a = alpha_channel_buffer; ptr_x = (uint16_t *)ptr; memset(ptr_x, 0, bxmin); ptr_x += xmin * desc->nb_components; if (s->bits_per_color_id == 2) { for (x = 0; x < xdelta; x++) { *ptr_x++ = exr_flt2uint(bytestream_get_le32(&r)); *ptr_x++ = exr_flt2uint(bytestream_get_le32(&g)); *ptr_x++ = exr_flt2uint(bytestream_get_le32(&b)); if (alpha_channel_buffer) *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a)); } } else { for (x = 0; x < xdelta; x++) { *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&r)); *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&g)); *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&b)); if (alpha_channel_buffer) *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&a)); } } memset(ptr_x, 0, axmax); red_channel_buffer += scan_line_size; green_channel_buffer += scan_line_size; blue_channel_buffer += scan_line_size; if (alpha_channel_buffer) alpha_channel_buffer += scan_line_size; } } } } for (y = ymax + 1; y < avctx->height; y++) { memset(ptr, 0, out_line_size); ptr += stride; } *picture = s->picture; *got_frame = 1; return buf_size; }[Succeeded / Failed / Skipped / Total] 602 / 58 / 377 / 1037:  39%|      | 1037/2690 [12:14:18<19:30:29, 42.49s/it][Succeeded / Failed / Skipped / Total] 602 / 58 / 377 / 1037:  39%|      | 1038/2690 [12:14:19<19:28:41, 42.45s/it][Succeeded / Failed / Skipped / Total] 603 / 58 / 377 / 1038:  39%|      | 1038/2690 [12:14:19<19:28:41, 42.45s/it][Succeeded / Failed / Skipped / Total] 603 / 58 / 377 / 1038:  39%|      | 1039/2690 [12:14:20<19:26:52, 42.41s/it][Succeeded / Failed / Skipped / Total] 603 / 58 / 378 / 1039:  39%|      | 1039/2690 [12:14:20<19:26:52, 42.41s/it][Succeeded / Failed / Skipped / Total] 603 / 58 / 378 / 1039:  39%|      | 1040/2690 [12:14:25<19:25:12, 42.37s/it]
--------------------------------------------- Result 1038 ---------------------------------------------
[[0 (18%)]] --> [[0 (59%)]] --> Socre: 0.5883544087409973

[[[[Adv]]]]: static void test_validate_fail_union_flat(TestInputVisitorData *data, const void *[[unused]]) { UserDefFlatUnion *[[tmp]] = NULL; Error *errp = NULL; Visitor *v; v = validate_test_init(data, "{ 'string': 'c', 'integer': 41, 'boolean': true }"); visit_type_UserDefFlatUnion(v, &[[tmp]], NULL, &errp); g_assert(error_is_set(&errp)); qapi_free_UserDefFlatUnion([[tmp]]); }

[[[[Adv]]]]: static void test_validate_fail_union_flat(TestInputVisitorData *data, const void *[[ral]]) { UserDefFlatUnion *[[innovations]] = NULL; Error *errp = NULL; Visitor *v; v = validate_test_init(data, "{ 'string': 'c', 'integer': 41, 'boolean': true }"); visit_type_UserDefFlatUnion(v, &[[innovations]], NULL, &errp); g_assert(error_is_set(&errp)); qapi_free_UserDefFlatUnion([[innovations]]); }
--------------------------------------------- Result 1039 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int drive_init(struct drive_opt *arg, int snapshot, void *opaque) { char buf[128]; char file[1024]; char devname[128]; char serial[21]; const char *mediastr = ""; BlockInterfaceType type; enum { MEDIA_DISK, MEDIA_CDROM } media; int bus_id, unit_id; int cyls, heads, secs, translation; BlockDriverState *bdrv; BlockDriver *drv = NULL; QEMUMachine *machine = opaque; int max_devs; int index; int cache; int bdrv_flags, onerror; int drives_table_idx; char *str = arg->opt; static const char * const params[] = { "bus", "unit", "if", "index", "cyls", "heads", "secs", "trans", "media", "snapshot", "file", "cache", "format", "serial", "werror", NULL }; if (check_params(buf, sizeof(buf), params, str) < 0) { fprintf(stderr, "qemu: unknown parameter '%s' in '%s'\n", buf, str); return -1; } file[0] = 0; cyls = heads = secs = 0; bus_id = 0; unit_id = -1; translation = BIOS_ATA_TRANSLATION_AUTO; index = -1; cache = 3; if (machine->use_scsi) { type = IF_SCSI; max_devs = MAX_SCSI_DEVS; pstrcpy(devname, sizeof(devname), "scsi"); } else { type = IF_IDE; max_devs = MAX_IDE_DEVS; pstrcpy(devname, sizeof(devname), "ide"); } media = MEDIA_DISK; if (get_param_value(buf, sizeof(buf), "bus", str)) { bus_id = strtol(buf, NULL, 0); if (bus_id < 0) { fprintf(stderr, "qemu: '%s' invalid bus id\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "unit", str)) { unit_id = strtol(buf, NULL, 0); if (unit_id < 0) { fprintf(stderr, "qemu: '%s' invalid unit id\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "if", str)) { pstrcpy(devname, sizeof(devname), buf); if (!strcmp(buf, "ide")) { type = IF_IDE; max_devs = MAX_IDE_DEVS; } else if (!strcmp(buf, "scsi")) { type = IF_SCSI; max_devs = MAX_SCSI_DEVS; } else if (!strcmp(buf, "floppy")) { type = IF_FLOPPY; max_devs = 0; } else if (!strcmp(buf, "pflash")) { type = IF_PFLASH; max_devs = 0; } else if (!strcmp(buf, "mtd")) { type = IF_MTD; max_devs = 0; } else if (!strcmp(buf, "sd")) { type = IF_SD; max_devs = 0; } else if (!strcmp(buf, "virtio")) { type = IF_VIRTIO; max_devs = 0; } else if (!strcmp(buf, "xen")) { type = IF_XEN; max_devs = 0; } else { fprintf(stderr, "qemu: '%s' unsupported bus type '%s'\n", str, buf); return -1; } } if (get_param_value(buf, sizeof(buf), "index", str)) { index = strtol(buf, NULL, 0); if (index < 0) { fprintf(stderr, "qemu: '%s' invalid index\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "cyls", str)) { cyls = strtol(buf, NULL, 0); } if (get_param_value(buf, sizeof(buf), "heads", str)) { heads = strtol(buf, NULL, 0); } if (get_param_value(buf, sizeof(buf), "secs", str)) { secs = strtol(buf, NULL, 0); } if (cyls || heads || secs) { if (cyls < 1 || cyls > 16383) { fprintf(stderr, "qemu: '%s' invalid physical cyls number\n", str); return -1; } if (heads < 1 || heads > 16) { fprintf(stderr, "qemu: '%s' invalid physical heads number\n", str); return -1; } if (secs < 1 || secs > 63) { fprintf(stderr, "qemu: '%s' invalid physical secs number\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "trans", str)) { if (!cyls) { fprintf(stderr, "qemu: '%s' trans must be used with cyls,heads and secs\n", str); return -1; } if (!strcmp(buf, "none")) translation = BIOS_ATA_TRANSLATION_NONE; else if (!strcmp(buf, "lba")) translation = BIOS_ATA_TRANSLATION_LBA; else if (!strcmp(buf, "auto")) translation = BIOS_ATA_TRANSLATION_AUTO; else { fprintf(stderr, "qemu: '%s' invalid translation type\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "media", str)) { if (!strcmp(buf, "disk")) { media = MEDIA_DISK; } else if (!strcmp(buf, "cdrom")) { if (cyls || secs || heads) { fprintf(stderr, "qemu: '%s' invalid physical CHS format\n", str); return -1; } media = MEDIA_CDROM; } else { fprintf(stderr, "qemu: '%s' invalid media\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "snapshot", str)) { if (!strcmp(buf, "on")) snapshot = 1; else if (!strcmp(buf, "off")) snapshot = 0; else { fprintf(stderr, "qemu: '%s' invalid snapshot option\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "cache", str)) { if (!strcmp(buf, "off") || !strcmp(buf, "none")) cache = 0; else if (!strcmp(buf, "writethrough")) cache = 1; else if (!strcmp(buf, "writeback")) cache = 2; else { fprintf(stderr, "qemu: invalid cache option\n"); return -1; } } if (get_param_value(buf, sizeof(buf), "format", str)) { if (strcmp(buf, "?") == 0) { fprintf(stderr, "qemu: Supported formats:"); bdrv_iterate_format(bdrv_format_print, NULL); fprintf(stderr, "\n"); return -1; } drv = bdrv_find_format(buf); if (!drv) { fprintf(stderr, "qemu: '%s' invalid format\n", buf); return -1; } } if (arg->file == NULL) get_param_value(file, sizeof(file), "file", str); else pstrcpy(file, sizeof(file), arg->file); if (!get_param_value(serial, sizeof(serial), "serial", str)) memset(serial, 0, sizeof(serial)); onerror = BLOCK_ERR_STOP_ENOSPC; if (get_param_value(buf, sizeof(serial), "werror", str)) { if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) { fprintf(stderr, "werror is no supported by this format\n"); return -1; } if (!strcmp(buf, "ignore")) onerror = BLOCK_ERR_IGNORE; else if (!strcmp(buf, "enospc")) onerror = BLOCK_ERR_STOP_ENOSPC; else if (!strcmp(buf, "stop")) onerror = BLOCK_ERR_STOP_ANY; else if (!strcmp(buf, "report")) onerror = BLOCK_ERR_REPORT; else { fprintf(stderr, "qemu: '%s' invalid write error action\n", buf); return -1; } } if (index != -1) { if (bus_id != 0 || unit_id != -1) { fprintf(stderr, "qemu: '%s' index cannot be used with bus and unit\n", str); return -1; } if (max_devs == 0) { unit_id = index; bus_id = 0; } else { unit_id = index % max_devs; bus_id = index / max_devs; } } if (unit_id == -1) { unit_id = 0; while (drive_get_index(type, bus_id, unit_id) != -1) { unit_id++; if (max_devs && unit_id >= max_devs) { unit_id -= max_devs; bus_id++; } } } if (max_devs && unit_id >= max_devs) { fprintf(stderr, "qemu: '%s' unit %d too big (max is %d)\n", str, unit_id, max_devs - 1); return -1; } if (drive_get_index(type, bus_id, unit_id) != -1) return -2; if (type == IF_IDE || type == IF_SCSI) mediastr = (media == MEDIA_CDROM) ? "-cd" : "-hd"; if (max_devs) snprintf(buf, sizeof(buf), "%s%i%s%i", devname, bus_id, mediastr, unit_id); else snprintf(buf, sizeof(buf), "%s%s%i", devname, mediastr, unit_id); bdrv = bdrv_new(buf); drives_table_idx = drive_get_free_idx(); drives_table[drives_table_idx].bdrv = bdrv; drives_table[drives_table_idx].type = type; drives_table[drives_table_idx].bus = bus_id; drives_table[drives_table_idx].unit = unit_id; drives_table[drives_table_idx].onerror = onerror; drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt; strncpy(drives_table[nb_drives].serial, serial, sizeof(serial)); nb_drives++; switch(type) { case IF_IDE: case IF_SCSI: case IF_XEN: switch(media) { case MEDIA_DISK: if (cyls != 0) { bdrv_set_geometry_hint(bdrv, cyls, heads, secs); bdrv_set_translation_hint(bdrv, translation); } break; case MEDIA_CDROM: bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM); break; } break; case IF_SD: case IF_FLOPPY: bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY); break; case IF_PFLASH: case IF_MTD: case IF_VIRTIO: break; } if (!file[0]) return -2; bdrv_flags = 0; if (snapshot) { bdrv_flags |= BDRV_O_SNAPSHOT; cache = 2; } if (cache == 0) bdrv_flags |= BDRV_O_NOCACHE; else if (cache == 2) bdrv_flags |= BDRV_O_CACHE_WB; else if (cache == 3) bdrv_flags |= BDRV_O_CACHE_DEF; if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) { fprintf(stderr, "qemu: could not open disk image %s\n", file); return -1; } if (bdrv_key_required(bdrv)) autostart = 0; return drives_table_idx; }
--------------------------------------------- Result 1040 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 604 / 58 / 378 / 1040:  39%|      | 1040/2690 [12:14:25<19:25:12, 42.37s/it][Succeeded / Failed / Skipped / Total] 604 / 58 / 378 / 1040:  39%|      | 1041/2690 [12:14:27<19:23:26, 42.33s/it][Succeeded / Failed / Skipped / Total] 605 / 58 / 378 / 1041:  39%|      | 1041/2690 [12:14:27<19:23:26, 42.33s/it][Succeeded / Failed / Skipped / Total] 605 / 58 / 378 / 1041:  39%|      | 1042/2690 [12:14:32<19:21:44, 42.30s/it][Succeeded / Failed / Skipped / Total] 606 / 58 / 378 / 1042:  39%|      | 1042/2690 [12:14:32<19:21:44, 42.30s/it][Succeeded / Failed / Skipped / Total] 606 / 58 / 378 / 1042:  39%|      | 1043/2690 [12:16:42<19:23:20, 42.38s/it][[0 (64%)]] --> [[0 (47%)]] --> Socre: 0.5255081355571747

[[[[Adv]]]]: static void unix_wait_for_connect(int fd, Error *err, void *[[opaque]]) { MigrationState *s = [[opaque]]; if (fd < 0) { DPRINTF("migrate connect error: %s\n", error_get_pretty(err)); s->file = NULL; migrate_fd_error(s); } else { DPRINTF("migrate connect success\n"); s->file = qemu_fopen_socket(fd, "wb"); migrate_fd_connect(s); } }

[[[[Adv]]]]: static void unix_wait_for_connect(int fd, Error *err, void *[[perplexing]]) { MigrationState *s = [[perplexing]]; if (fd < 0) { DPRINTF("migrate connect error: %s\n", error_get_pretty(err)); s->file = NULL; migrate_fd_error(s); } else { DPRINTF("migrate connect success\n"); s->file = qemu_fopen_socket(fd, "wb"); migrate_fd_connect(s); } }
--------------------------------------------- Result 1041 ---------------------------------------------
[[0 (5%)]] --> [[0 (63%)]] --> Socre: 0.6327049136161804

[[[[Adv]]]]: void cpu_x86_update_cr4(CPUX86State *[[env]], uint32_t [[new_cr4]]) { #if defined(DEBUG_MMU) printf("CR4 update: CR4=%08x\n", (uint32_t)[[env]]->cr[4]); #endif if (([[new_cr4]] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) != ([[env]]->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) { tlb_flush([[env]], 1); } if (!([[env]]->cpuid_features & CPUID_SSE)) [[new_cr4]] &= ~CR4_OSFXSR_MASK; if ([[new_cr4]] & CR4_OSFXSR_MASK) [[env]]->hflags |= HF_OSFXSR_MASK; else [[env]]->hflags &= ~HF_OSFXSR_MASK; [[env]]->cr[4] = [[new_cr4]]; }

[[[[Adv]]]]: void cpu_x86_update_cr4(CPUX86State *[[mosaic]], uint32_t [[protracted]]) { #if defined(DEBUG_MMU) printf("CR4 update: CR4=%08x\n", (uint32_t)[[mosaic]]->cr[4]); #endif if (([[protracted]] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) != ([[mosaic]]->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) { tlb_flush([[mosaic]], 1); } if (!([[mosaic]]->cpuid_features & CPUID_SSE)) [[protracted]] &= ~CR4_OSFXSR_MASK; if ([[protracted]] & CR4_OSFXSR_MASK) [[mosaic]]->hflags |= HF_OSFXSR_MASK; else [[mosaic]]->hflags &= ~HF_OSFXSR_MASK; [[mosaic]]->cr[4] = [[protracted]]; }
--------------------------------------------- Result 1042 ---------------------------------------------
[[0 (13%)]] --> [[0 (68%)]] --> Socre: 0.6823628544807434

[[[[Adv]]]]: static int ljpeg_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pict, int *got_packet) { LJpegEncContext *s = avctx->priv_data; PutBitContext pb; const int width = avctx->width; const int height = avctx->height; const int mb_width = (width + s->hsample[0] - 1) / s->hsample[0]; const int mb_height = (height + s->vsample[0] - 1) / s->vsample[0]; int max_pkt_size = AV_INPUT_BUFFER_MIN_SIZE; int [[ret]], header_bits; if (avctx->pix_fmt == AV_PIX_FMT_BGR24) max_pkt_size += width * height * 3 * 3; else { max_pkt_size += mb_width * mb_height * 3 * 4 * s->hsample[0] * s->vsample[0]; } if (([[ret]] = ff_alloc_packet(pkt, max_pkt_size)) < 0) { av_log(avctx, AV_LOG_ERROR, "Error getting output packet of size %d.\n", max_pkt_size); return [[ret]]; } init_put_bits(&pb, pkt->data, pkt->size); ff_mjpeg_encode_picture_header(avctx, &pb, &s->scantable, s->matrix); header_bits = put_bits_count(&pb); if (avctx->pix_fmt == AV_PIX_FMT_BGR24) [[ret]] = ljpeg_encode_bgr(avctx, &pb, pict); else [[ret]] = ljpeg_encode_yuv(avctx, &pb, pict); if ([[ret]] < 0) return [[ret]]; emms_c(); ff_mjpeg_encode_picture_trailer(&pb, header_bits); flush_put_bits(&pb); pkt->size = put_bits_ptr(&pb) - pb.buf; pkt->flags |= AV_PKT_FLAG_KEY; *got_packet = 1; return 0; }

[[[[Adv]]]]: static int ljpeg_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pict, int *got_packet) { LJpegEncContext *s = avctx->priv_data; PutBitContext pb; const int width = avctx->width; const int height = avctx->height; const int mb_width = (width + s->hsample[0] - 1) / s->hsample[0]; const int mb_height = (height + s->vsample[0] - 1) / s->vsample[0]; int max_pkt_size = AV_INPUT_BUFFER_MIN_SIZE; int [[overhauled]], header_bits; if (avctx->pix_fmt == AV_PIX_FMT_BGR24) max_pkt_size += width * height * 3 * 3; else { max_pkt_size += mb_width * mb_height * 3 * 4 * s->hsample[0] * s->vsample[0]; } if (([[overhauled]] = ff_alloc_packet(pkt, max_pkt_size)) < 0) { av_log(avctx, AV_LOG_ERROR, "Error getting output packet of size %d.\n", max_pkt_size); return [[overhauled]]; } init_put_bits(&pb, pkt->data, pkt->size); ff_mjpeg_encode_picture_header(avctx, &pb, &s->scantable, s->matrix); header_bits = put_bits_count(&pb); if (avctx->pix_fmt == AV_PIX_FMT_BGR24) [[overhauled]] = ljpeg_encode_bgr(avctx, &pb, pict); else [[overhauled]] = ljpeg_encode_yuv(avctx, &pb, pict); if ([[overhauled]] < 0) return [[overhauled]]; emms_c(); ff_mjpeg_encode_picture_trailer(&pb, header_bits); flush_put_bits(&pb); pkt->size = put_bits_ptr(&pb) - pb.buf; pkt->flags |= AV_PKT_FLAG_KEY; *got_packet = 1; return 0; }
--------------------------------------------- Result 1043 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 607 / 58 / 378 / 1043:  39%|      | 1043/2690 [12:16:42<19:23:20, 42.38s/it][Succeeded / Failed / Skipped / Total] 607 / 58 / 378 / 1043:  39%|      | 1044/2690 [12:16:43<19:21:32, 42.34s/it][Succeeded / Failed / Skipped / Total] 607 / 58 / 379 / 1044:  39%|      | 1044/2690 [12:16:43<19:21:32, 42.34s/it][Succeeded / Failed / Skipped / Total] 607 / 58 / 379 / 1044:  39%|      | 1045/2690 [12:16:44<19:19:44, 42.30s/it][Succeeded / Failed / Skipped / Total] 607 / 58 / 380 / 1045:  39%|      | 1045/2690 [12:16:44<19:19:44, 42.30s/it][Succeeded / Failed / Skipped / Total] 607 / 58 / 380 / 1045:  39%|      | 1046/2690 [12:17:21<19:18:54, 42.30s/it][Succeeded / Failed / Skipped / Total] 608 / 58 / 380 / 1046:  39%|      | 1046/2690 [12:17:21<19:18:54, 42.30s/it][Succeeded / Failed / Skipped / Total] 608 / 58 / 380 / 1046:  39%|      | 1047/2690 [12:17:27<19:17:15, 42.26s/it][[0 (99%)]] --> [[0 (34%)]] --> Socre: 0.6564085781574249

[[[[Adv]]]]: int av_vsrc_buffer_add_video_buffer_ref(AVFilterContext *buffer_filter, AVFilterBufferRef *picref) { BufferSourceContext *c = buffer_filter->priv; AVFilterLink *[[outlink]] = buffer_filter->outputs[0]; int ret; if (c->picref) { av_log(buffer_filter, AV_LOG_ERROR, "Buffering several frames is not supported. " "Please consume all available frames before adding a new one.\n" ); } if (picref->video->w != c->w || picref->video->h != c->h || picref->format != c->pix_fmt) { AVFilterContext *scale = buffer_filter->outputs[0]->dst; AVFilterLink *link; char scale_param[1024]; av_log(buffer_filter, AV_LOG_INFO, "Buffer video input changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\n", c->w, c->h, av_pix_fmt_descriptors[c->pix_fmt].name, picref->video->w, picref->video->h, av_pix_fmt_descriptors[picref->format].name); if (!scale || strcmp(scale->filter->name, "scale")) { AVFilter *f = avfilter_get_by_name("scale"); av_log(buffer_filter, AV_LOG_INFO, "Inserting scaler filter\n"); if ((ret = avfilter_open(&scale, f, "Input equalizer")) < 0) return ret; snprintf(scale_param, sizeof(scale_param)-1, "%d:%d:%s", c->w, c->h, c->sws_param); if ((ret = avfilter_init_filter(scale, scale_param, NULL)) < 0) { avfilter_free(scale); return ret; } if ((ret = avfilter_insert_filter(buffer_filter->outputs[0], scale, 0, 0)) < 0) { avfilter_free(scale); return ret; } scale->outputs[0]->time_base = scale->inputs[0]->time_base; scale->outputs[0]->format= c->pix_fmt; } else if (!strcmp(scale->filter->name, "scale")) { snprintf(scale_param, sizeof(scale_param)-1, "%d:%d:%s", scale->outputs[0]->w, scale->outputs[0]->h, c->sws_param); scale->filter->init(scale, scale_param, NULL); } c->pix_fmt = scale->inputs[0]->format = picref->format; c->w = scale->inputs[0]->w = picref->video->w; c->h = scale->inputs[0]->h = picref->video->h; link = scale->outputs[0]; if ((ret = link->srcpad->config_props(link)) < 0) return ret; } c->picref = avfilter_get_video_buffer([[outlink]], AV_PERM_WRITE, picref->video->w, picref->video->h); av_image_copy(c->picref->data, c->picref->linesize, picref->data, picref->linesize, picref->format, picref->video->w, picref->video->h); avfilter_copy_buffer_ref_props(c->picref, picref); return 0; }

[[[[Adv]]]]: int av_vsrc_buffer_add_video_buffer_ref(AVFilterContext *buffer_filter, AVFilterBufferRef *picref) { BufferSourceContext *c = buffer_filter->priv; AVFilterLink *[[n]] = buffer_filter->outputs[0]; int ret; if (c->picref) { av_log(buffer_filter, AV_LOG_ERROR, "Buffering several frames is not supported. " "Please consume all available frames before adding a new one.\n" ); } if (picref->video->w != c->w || picref->video->h != c->h || picref->format != c->pix_fmt) { AVFilterContext *scale = buffer_filter->outputs[0]->dst; AVFilterLink *link; char scale_param[1024]; av_log(buffer_filter, AV_LOG_INFO, "Buffer video input changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\n", c->w, c->h, av_pix_fmt_descriptors[c->pix_fmt].name, picref->video->w, picref->video->h, av_pix_fmt_descriptors[picref->format].name); if (!scale || strcmp(scale->filter->name, "scale")) { AVFilter *f = avfilter_get_by_name("scale"); av_log(buffer_filter, AV_LOG_INFO, "Inserting scaler filter\n"); if ((ret = avfilter_open(&scale, f, "Input equalizer")) < 0) return ret; snprintf(scale_param, sizeof(scale_param)-1, "%d:%d:%s", c->w, c->h, c->sws_param); if ((ret = avfilter_init_filter(scale, scale_param, NULL)) < 0) { avfilter_free(scale); return ret; } if ((ret = avfilter_insert_filter(buffer_filter->outputs[0], scale, 0, 0)) < 0) { avfilter_free(scale); return ret; } scale->outputs[0]->time_base = scale->inputs[0]->time_base; scale->outputs[0]->format= c->pix_fmt; } else if (!strcmp(scale->filter->name, "scale")) { snprintf(scale_param, sizeof(scale_param)-1, "%d:%d:%s", scale->outputs[0]->w, scale->outputs[0]->h, c->sws_param); scale->filter->init(scale, scale_param, NULL); } c->pix_fmt = scale->inputs[0]->format = picref->format; c->w = scale->inputs[0]->w = picref->video->w; c->h = scale->inputs[0]->h = picref->video->h; link = scale->outputs[0]; if ((ret = link->srcpad->config_props(link)) < 0) return ret; } c->picref = avfilter_get_video_buffer([[n]], AV_PERM_WRITE, picref->video->w, picref->video->h); av_image_copy(c->picref->data, c->picref->linesize, picref->data, picref->linesize, picref->format, picref->video->w, picref->video->h); avfilter_copy_buffer_ref_props(c->picref, picref); return 0; }
--------------------------------------------- Result 1044 ---------------------------------------------
[[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qxl_spice_monitors_config_async(PCIQXLDevice *qxl, int replay) { trace_qxl_spice_monitors_config(qxl->id); if (replay) { spice_qxl_monitors_config_async(&qxl->ssd.qxl, qxl->guest_monitors_config, MEMSLOT_GROUP_GUEST, (uintptr_t)qxl_cookie_new( QXL_COOKIE_TYPE_POST_LOAD_MONITORS_CONFIG, 0)); } else { #if SPICE_SERVER_VERSION >= 0x000c06 if (qxl->max_outputs) { spice_qxl_set_monitors_config_limit(&qxl->ssd.qxl, qxl->max_outputs); } #endif qxl->guest_monitors_config = qxl->ram->monitors_config; spice_qxl_monitors_config_async(&qxl->ssd.qxl, qxl->ram->monitors_config, MEMSLOT_GROUP_GUEST, (uintptr_t)qxl_cookie_new(QXL_COOKIE_TYPE_IO, QXL_IO_MONITORS_CONFIG_ASYNC)); } }
--------------------------------------------- Result 1045 ---------------------------------------------
[[0 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void virtio_net_vhost_status(VirtIONet *n, uint8_t status) { VirtIODevice *vdev = VIRTIO_DEVICE(n); NetClientState *nc = qemu_get_queue(n->nic); int queues = n->multiqueue ? n->max_queues : 1; if (!get_vhost_net(nc->peer)) { return; } if (!!n->vhost_started == (virtio_net_started(n, status) && !nc->peer->link_down)) { return; } if (!n->vhost_started) { int r; if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) { return; } n->vhost_started = 1; r = vhost_net_start(vdev, n->nic->ncs, queues); if (r < 0) { error_report("unable to start vhost net: %d: " "falling back on userspace virtio", -r); n->vhost_started = 0; } } else { vhost_net_stop(vdev, n->nic->ncs, queues); n->vhost_started = 0; } }
--------------------------------------------- Result 1046 ---------------------------------------------
[[0 (12%)]] --> [[0 (59%)]] --> Socre: 0.5912957191467285

[[[[Adv]]]]: static void spapr_cpu_core_host_initfn(Object *[[obj]]) { sPAPRCPUCore *core = SPAPR_CPU_CORE([[obj]]); char *[[name]] = g_strdup_printf("%s-" TYPE_POWERPC_CPU, "host"); ObjectClass *[[oc]] = object_class_by_name([[name]]); g_assert([[oc]]); g_free((void *)[[name]]); core->cpu_class = [[oc]]; }

[[[[Adv]]]]: static void spapr_cpu_core_host_initfn(Object *[[ultron]]) { sPAPRCPUCore *core = SPAPR_CPU_CORE([[ultron]]); char *[[sake]] = g_strdup_printf("%s-" TYPE_POWERPC_CPU, "host"); ObjectClass *[[coven]] = object_class_by_name([[sake]]); g_assert([[coven]]); g_free((void *)[[sake]]); core->cpu_class = [[coven]]; }
--------------------------------------------- Result 1047 ---------------------------------------------
[[0 (32%)]] --> [[0 (74%)]] --> Socre: 0.7409257292747498

[[[[Adv]]]]: static void init_block_mapping(Vp3DecodeContext *s) { int i, j; signed int [[hilbert_walk_y]][16]; signed int hilbert_walk_c[16]; signed int hilbert_walk_mb[4]; int current_fragment = 0; int current_width = 0; int current_height = 0; int right_edge = 0; int bottom_edge = 0; int superblock_row_inc = 0; int *hilbert = NULL; int mapping_index = 0; int current_macroblock; int c_fragment; signed char travel_width[16] = { 1, 1, 0, -1, 0, 0, 1, 0, 1, 0, 1, 0, 0, -1, 0, 1 }; signed char travel_height[16] = { 0, 0, 1, 0, 1, 1, 0, -1, 0, 1, 0, -1, -1, 0, -1, 0 }; signed char travel_width_mb[4] = { 1, 0, 1, 0 }; signed char travel_height_mb[4] = { 0, 1, 0, -1 }; debug_vp3(" vp3: initialize block mapping tables\n"); [[hilbert_walk_y]][0] = 1; [[hilbert_walk_y]][1] = 1; [[hilbert_walk_y]][2] = s->fragment_width; [[hilbert_walk_y]][3] = -1; [[hilbert_walk_y]][4] = s->fragment_width; [[hilbert_walk_y]][5] = s->fragment_width; [[hilbert_walk_y]][6] = 1; [[hilbert_walk_y]][7] = -s->fragment_width; [[hilbert_walk_y]][8] = 1; [[hilbert_walk_y]][9] = s->fragment_width; [[hilbert_walk_y]][10] = 1; [[hilbert_walk_y]][11] = -s->fragment_width; [[hilbert_walk_y]][12] = -s->fragment_width; [[hilbert_walk_y]][13] = -1; [[hilbert_walk_y]][14] = -s->fragment_width; [[hilbert_walk_y]][15] = 1; hilbert_walk_c[0] = 1; hilbert_walk_c[1] = 1; hilbert_walk_c[2] = s->fragment_width / 2; hilbert_walk_c[3] = -1; hilbert_walk_c[4] = s->fragment_width / 2; hilbert_walk_c[5] = s->fragment_width / 2; hilbert_walk_c[6] = 1; hilbert_walk_c[7] = -s->fragment_width / 2; hilbert_walk_c[8] = 1; hilbert_walk_c[9] = s->fragment_width / 2; hilbert_walk_c[10] = 1; hilbert_walk_c[11] = -s->fragment_width / 2; hilbert_walk_c[12] = -s->fragment_width / 2; hilbert_walk_c[13] = -1; hilbert_walk_c[14] = -s->fragment_width / 2; hilbert_walk_c[15] = 1; hilbert_walk_mb[0] = 1; hilbert_walk_mb[1] = s->macroblock_width; hilbert_walk_mb[2] = 1; hilbert_walk_mb[3] = -s->macroblock_width; for (i = 0; i < s->superblock_count; i++) { debug_init(" superblock %d (u starts @ %d, v starts @ %d)\n", i, s->u_superblock_start, s->v_superblock_start); if (i == 0) { right_edge = s->fragment_width; bottom_edge = s->fragment_height; current_width = 0; current_height = 0; superblock_row_inc = 3 * s->fragment_width; hilbert = [[hilbert_walk_y]]; current_fragment = -1; } else if (i == s->u_superblock_start) { right_edge = s->fragment_width / 2; bottom_edge = s->fragment_height / 2; current_width = 0; current_height = 0; superblock_row_inc = 3 * (s->fragment_width / 2); hilbert = hilbert_walk_c; current_fragment = s->u_fragment_start - 1; } else if (i == s->v_superblock_start) { right_edge = s->fragment_width / 2; bottom_edge = s->fragment_height / 2; current_width = 0; current_height = 0; superblock_row_inc = 3 * (s->fragment_width / 2); hilbert = hilbert_walk_c; current_fragment = s->v_fragment_start - 1; } if (current_width >= right_edge) { current_width = 0; current_height += 4; current_fragment += superblock_row_inc; } for (j = 0; j < 16; j++) { current_fragment += hilbert[j]; current_height += travel_height[j]; if ((current_width <= right_edge) && (current_height < bottom_edge)) { s->superblock_fragments[mapping_index] = current_fragment; debug_init(" mapping fragment %d to superblock %d, position %d\n", s->superblock_fragments[mapping_index], i, j); } else { s->superblock_fragments[mapping_index] = -1; debug_init(" superblock %d, position %d has no fragment\n", i, j); } current_width += travel_width[j]; mapping_index++; } } right_edge = s->macroblock_width; bottom_edge = s->macroblock_height; current_width = 0; current_height = 0; superblock_row_inc = s->macroblock_width; hilbert = hilbert_walk_mb; mapping_index = 0; current_macroblock = -1; for (i = 0; i < s->u_superblock_start; i++) { if (current_width >= right_edge) { current_width = 0; current_height += 2; current_macroblock += superblock_row_inc; } for (j = 0; j < 4; j++) { current_macroblock += hilbert_walk_mb[j]; current_height += travel_height_mb[j]; if ((current_width <= right_edge) && (current_height < bottom_edge)) { s->superblock_macroblocks[mapping_index] = current_macroblock; debug_init(" mapping macroblock %d to superblock %d, position %d\n", s->superblock_macroblocks[mapping_index], i, j); } else { s->superblock_macroblocks[mapping_index] = -1; debug_init(" superblock %d, position %d has no macroblock\n", i, j); } current_width += travel_width_mb[j]; mapping_index++; } } current_fragment = 0; current_macroblock = 0; mapping_index = 0; for (i = 0; i < s->fragment_height; i += 2) { for (j = 0; j < s->fragment_width; j += 2) { debug_init(" macroblock %d contains fragments: ", current_macroblock); s->all_fragments[current_fragment].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment; debug_init("%d ", current_fragment); if (j + 1 < s->fragment_width) { s->all_fragments[current_fragment + 1].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment + 1; debug_init("%d ", current_fragment + 1); } else s->macroblock_fragments[mapping_index++] = -1; if (i + 1 < s->fragment_height) { s->all_fragments[current_fragment + s->fragment_width].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment + s->fragment_width; debug_init("%d ", current_fragment + s->fragment_width); } else s->macroblock_fragments[mapping_index++] = -1; if ((j + 1 < s->fragment_width) && (i + 1 < s->fragment_height)) { s->all_fragments[current_fragment + s->fragment_width + 1].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment + s->fragment_width + 1; debug_init("%d ", current_fragment + s->fragment_width + 1); } else s->macroblock_fragments[mapping_index++] = -1; c_fragment = s->u_fragment_start + (i * s->fragment_width / 4) + (j / 2); s->all_fragments[c_fragment].macroblock = s->macroblock_count; s->macroblock_fragments[mapping_index++] = c_fragment; debug_init("%d ", c_fragment); c_fragment = s->v_fragment_start + (i * s->fragment_width / 4) + (j / 2); s->all_fragments[c_fragment].macroblock = s->macroblock_count; s->macroblock_fragments[mapping_index++] = c_fragment; debug_init("%d ", c_fragment); debug_init("\n"); if (j + 2 <= s->fragment_width) current_fragment += 2; else current_fragment++; current_macroblock++; } current_fragment += s->fragment_width; } }

[[[[Adv]]]]: static void init_block_mapping(Vp3DecodeContext *s) { int i, j; signed int [[ealing]][16]; signed int hilbert_walk_c[16]; signed int hilbert_walk_mb[4]; int current_fragment = 0; int current_width = 0; int current_height = 0; int right_edge = 0; int bottom_edge = 0; int superblock_row_inc = 0; int *hilbert = NULL; int mapping_index = 0; int current_macroblock; int c_fragment; signed char travel_width[16] = { 1, 1, 0, -1, 0, 0, 1, 0, 1, 0, 1, 0, 0, -1, 0, 1 }; signed char travel_height[16] = { 0, 0, 1, 0, 1, 1, 0, -1, 0, 1, 0, -1, -1, 0, -1, 0 }; signed char travel_width_mb[4] = { 1, 0, 1, 0 }; signed char travel_height_mb[4] = { 0, 1, 0, -1 }; debug_vp3(" vp3: initialize block mapping tables\n"); [[ealing]][0] = 1; [[ealing]][1] = 1; [[ealing]][2] = s->fragment_width; [[ealing]][3] = -1; [[ealing]][4] = s->fragment_width; [[ealing]][5] = s->fragment_width; [[ealing]][6] = 1; [[ealing]][7] = -s->fragment_width; [[ealing]][8] = 1; [[ealing]][9] = s->fragment_width; [[ealing]][10] = 1; [[ealing]][11] = -s->fragment_width; [[ealing]][12] = -s->fragment_width; [[ealing]][13] = -1; [[ealing]][14] = -s->fragment_width; [[ealing]][15] = 1; hilbert_walk_c[0] = 1; hilbert_walk_c[1] = 1; hilbert_walk_c[2] = s->fragment_width / 2; hilbert_walk_c[3] = -1; hilbert_walk_c[4] = s->fragment_width / 2; hilbert_walk_c[5] = s->fragment_width / 2; hilbert_walk_c[6] = 1; hilbert_walk_c[7] = -s->fragment_width / 2; hilbert_walk_c[8] = 1; hilbert_walk_c[9] = s->fragment_width / 2; hilbert_walk_c[10] = 1; hilbert_walk_c[11] = -s->fragment_width / 2; hilbert_walk_c[12] = -s->fragment_width / 2; hilbert_walk_c[13] = -1; hilbert_walk_c[14] = -s->fragment_width / 2; hilbert_walk_c[15] = 1; hilbert_walk_mb[0] = 1; hilbert_walk_mb[1] = s->macroblock_width; hilbert_walk_mb[2] = 1; hilbert_walk_mb[3] = -s->macroblock_width; for (i = 0; i < s->superblock_count; i++) { debug_init(" superblock %d (u starts @ %d, v starts @ %d)\n", i, s->u_superblock_start, s->v_superblock_start); if (i == 0) { right_edge = s->fragment_width; bottom_edge = s->fragment_height; current_width = 0; current_height = 0; superblock_row_inc = 3 * s->fragment_width; hilbert = [[ealing]]; current_fragment = -1; } else if (i == s->u_superblock_start) { right_edge = s->fragment_width / 2; bottom_edge = s->fragment_height / 2; current_width = 0; current_height = 0; superblock_row_inc = 3 * (s->fragment_width / 2); hilbert = hilbert_walk_c; current_fragment = s->u_fragment_start - 1; } else if (i == s->v_superblock_start) { right_edge = s->fragment_width / 2; bottom_edge = s->fragment_height / 2; current_width = 0; current_height = 0; superblock_row_inc = 3 * (s->fragment_width / 2); hilbert = hilbert_walk_c; current_fragment = s->v_fragment_start - 1; } if (current_width >= right_edge) { current_width = 0; current_height += 4; current_fragment += superblock_row_inc; } for (j = 0; j < 16; j++) { current_fragment += hilbert[j]; current_height += travel_height[j]; if ((current_width <= right_edge) && (current_height < bottom_edge)) { s->superblock_fragments[mapping_index] = current_fragment; debug_init(" mapping fragment %d to superblock %d, position %d\n", s->superblock_fragments[mapping_index], i, j); } else { s->superblock_fragments[mapping_index] = -1; debug_init(" superblock %d, position %d has no fragment\n", i, j); } current_width += travel_width[j]; mapping_index++; } } right_edge = s->macroblock_width; bottom_edge = s->macroblock_height; current_width = 0; current_height = 0; superblock_row_inc = s->macroblock_width; hilbert = hilbert_walk_mb; mapping_index = 0; current_macroblock = -1; for (i = 0; i < s->u_superblock_start; i++) { if (current_width >= right_edge) { current_width = 0; current_height += 2; current_macroblock += superblock_row_inc; } for (j = 0; j < 4; j++) { current_macroblock += hilbert_walk_mb[j]; current_height += travel_height_mb[j]; if ((current_width <= right_edge) && (current_height < bottom_edge)) { s->superblock_macroblocks[mapping_index] = current_macroblock; debug_init(" mapping macroblock %d to superblock %d, position %d\n", s->superblock_macroblocks[mapping_index], i, j); } else { s->superblock_macroblocks[mapping_index] = -1; debug_init(" superblock %d, position %d has no macroblock\n", i, j); } current_width += travel_width_mb[j]; mapping_index++; } } current_fragment = 0; current_macroblock = 0; mapping_index = 0; for (i = 0; i < s->fragment_height; i += 2) { for (j = 0; j < s->fragment_width; j += 2) { debug_init(" macroblock %d contains fragments: ", current_macroblock); s->all_fragments[current_fragment].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment; debug_init("%d ", current_fragment); if (j + 1 < s->fragment_width) { s->all_fragments[current_fragment + 1].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment + 1; debug_init("%d ", current_fragment + 1); } else s->macroblock_fragments[mapping_index++] = -1; if (i + 1 < s->fragment_height) { s->all_fragments[current_fragment + s->fragment_width].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment + s->fragment_width; debug_init("%d ", current_fragment + s->fragment_width); } else s->macroblock_fragments[mapping_index++] = -1; if ((j + 1 < s->fragment_width) && (i + 1 < s->fragment_height)) { s->all_fragments[current_fragment + s->fragment_width + 1].macroblock = current_macroblock; s->macroblock_fragments[mapping_index++] = current_fragment + s->fragment_width + 1; debug_init("%d ", current_fragment + s->fragment_width + 1); } else s->macroblock_fragments[mapping_index++] = -1; c_fragment = s->u_fragment_start + (i * s->fragment_width / 4) + (j / 2); s->all_fragments[c_fragment].macroblock = s->macroblock_count; s->macroblock_fragments[mapping_index++] = c_fragment; debug_init("%d ", c_fragment); c_fragment = s->v_fragment_start + (i * s->fragment_width / 4) + (j / 2); s->all_fragments[c_fragment].macroblock = s->macroblock_count; s->macroblock_fragments[mapping_index++] = c_fragment; debug_init("%d ", c_fragment); debug_init("\n"); if (j + 2 <= s->fragment_width) current_fragment += 2; else current_fragment++; current_macroblock++; } current_fragment += s->fragment_width; } }[Succeeded / Failed / Skipped / Total] 609 / 58 / 380 / 1047:  39%|      | 1047/2690 [12:17:27<19:17:15, 42.26s/it]
--------------------------------------------- Result 1048 ---------------------------------------------
[[0 (100%)]] --> [[0 (29%)]] --> Socre: 0.7131416201591492

[[[[Adv]]]]: int ff_h264_decode_picture_parameter_set(GetBitContext *gb, AVCodecContext *avctx, H264ParamSets *ps, int bit_length) { AVBufferRef *pps_buf; const SPS *[[sps]]; unsigned int pps_id = get_ue_golomb(gb); PPS *pps; int qp_bd_offset; int bits_left; int ret; if (pps_id >= MAX_PPS_COUNT) { av_log(avctx, AV_LOG_ERROR, "pps_id %u out of range\n", pps_id); return AVERROR_INVALIDDATA; pps_buf = av_buffer_allocz(sizeof(*pps)); if (!pps_buf) return AVERROR(ENOMEM); pps = (PPS*)pps_buf->data; pps->data_size = gb->buffer_end - gb->buffer; if (pps->data_size > sizeof(pps->data)) { av_log(avctx, AV_LOG_WARNING, "Truncating likely oversized PPS " "(%"SIZE_SPECIFIER" > %"SIZE_SPECIFIER")\n", pps->data_size, sizeof(pps->data)); pps->data_size = sizeof(pps->data); memcpy(pps->data, gb->buffer, pps->data_size); pps->sps_id = get_ue_golomb_31(gb); if ((unsigned)pps->sps_id >= MAX_SPS_COUNT || !ps->sps_list[pps->sps_id]) { av_log(avctx, AV_LOG_ERROR, "sps_id %u out of range\n", pps->sps_id); [[sps]] = (const SPS*)ps->sps_list[pps->sps_id]->data; if ([[sps]]->bit_depth_luma > 14) { av_log(avctx, AV_LOG_ERROR, "Invalid luma bit depth=%d\n", [[sps]]->bit_depth_luma); } else if ([[sps]]->bit_depth_luma == 11 || [[sps]]->bit_depth_luma == 13) { av_log(avctx, AV_LOG_ERROR, "Unimplemented luma bit depth=%d\n", [[sps]]->bit_depth_luma); ret = AVERROR_PATCHWELCOME; pps->cabac = get_bits1(gb); pps->pic_order_present = get_bits1(gb); pps->slice_group_count = get_ue_golomb(gb) + 1; if (pps->slice_group_count > 1) { pps->mb_slice_group_map_type = get_ue_golomb(gb); av_log(avctx, AV_LOG_ERROR, "FMO not supported\n"); switch (pps->mb_slice_group_map_type) { case 0: #if 0 | for (i = 0; i <= num_slice_groups_minus1; i++) | | | | run_length[i] |1 |ue(v) | #endif break; case 2: #if 0 | for (i = 0; i < num_slice_groups_minus1; i++) { | | | | top_left_mb[i] |1 |ue(v) | | bottom_right_mb[i] |1 |ue(v) | | } | | | #endif break; case 3: case 4: case 5: #if 0 | slice_group_change_direction_flag |1 |u(1) | | slice_group_change_rate_minus1 |1 |ue(v) | #endif break; case 6: #if 0 | slice_group_id_cnt_minus1 |1 |ue(v) | | for (i = 0; i <= slice_group_id_cnt_minus1; i++)| | | | slice_group_id[i] |1 |u(v) | #endif break; pps->ref_count[0] = get_ue_golomb(gb) + 1; pps->ref_count[1] = get_ue_golomb(gb) + 1; if (pps->ref_count[0] - 1 > 32 - 1 || pps->ref_count[1] - 1 > 32 - 1) { av_log(avctx, AV_LOG_ERROR, "reference overflow (pps)\n"); qp_bd_offset = 6 * ([[sps]]->bit_depth_luma - 8); pps->weighted_pred = get_bits1(gb); pps->weighted_bipred_idc = get_bits(gb, 2); pps->init_qp = get_se_golomb(gb) + 26 + qp_bd_offset; pps->init_qs = get_se_golomb(gb) + 26 + qp_bd_offset; pps->chroma_qp_index_offset[0] = get_se_golomb(gb); pps->deblocking_filter_parameters_present = get_bits1(gb); pps->constrained_intra_pred = get_bits1(gb); pps->redundant_pic_cnt_present = get_bits1(gb); pps->transform_8x8_mode = 0; memcpy(pps->scaling_matrix4, [[sps]]->scaling_matrix4, sizeof(pps->scaling_matrix4)); memcpy(pps->scaling_matrix8, [[sps]]->scaling_matrix8, sizeof(pps->scaling_matrix8)); bits_left = bit_length - get_bits_count(gb); if (bits_left > 0 && more_rbsp_data_in_pps([[sps]], avctx)) { pps->transform_8x8_mode = get_bits1(gb); decode_scaling_matrices(gb, [[sps]], pps, 0, pps->scaling_matrix4, pps->scaling_matrix8); pps->chroma_qp_index_offset[1] = get_se_golomb(gb); if (pps->chroma_qp_index_offset[1] < -12 || pps->chroma_qp_index_offset[1] > 12) { } else { pps->chroma_qp_index_offset[1] = pps->chroma_qp_index_offset[0]; build_qp_table(pps, 0, pps->chroma_qp_index_offset[0], [[sps]]->bit_depth_luma); build_qp_table(pps, 1, pps->chroma_qp_index_offset[1], [[sps]]->bit_depth_luma); init_dequant_tables(pps, [[sps]]); if (pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1]) pps->chroma_qp_diff = 1; if (avctx->debug & FF_DEBUG_PICT_INFO) { av_log(avctx, AV_LOG_DEBUG, "pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\n", pps_id, pps->sps_id, pps->cabac ? "CABAC" : "CAVLC", pps->slice_group_count, pps->ref_count[0], pps->ref_count[1], pps->weighted_pred ? "weighted" : "", pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1], pps->deblocking_filter_parameters_present ? "LPAR" : "", pps->constrained_intra_pred ? "CONSTR" : "", pps->redundant_pic_cnt_present ? "REDU" : "", pps->transform_8x8_mode ? "8x8DCT" : ""); remove_pps(ps, pps_id); ps->pps_list[pps_id] = pps_buf; return 0; fail: av_buffer_unref(&pps_buf); return ret;

[[[[Adv]]]]: int ff_h264_decode_picture_parameter_set(GetBitContext *gb, AVCodecContext *avctx, H264ParamSets *ps, int bit_length) { AVBufferRef *pps_buf; const SPS *[[dnde]]; unsigned int pps_id = get_ue_golomb(gb); PPS *pps; int qp_bd_offset; int bits_left; int ret; if (pps_id >= MAX_PPS_COUNT) { av_log(avctx, AV_LOG_ERROR, "pps_id %u out of range\n", pps_id); return AVERROR_INVALIDDATA; pps_buf = av_buffer_allocz(sizeof(*pps)); if (!pps_buf) return AVERROR(ENOMEM); pps = (PPS*)pps_buf->data; pps->data_size = gb->buffer_end - gb->buffer; if (pps->data_size > sizeof(pps->data)) { av_log(avctx, AV_LOG_WARNING, "Truncating likely oversized PPS " "(%"SIZE_SPECIFIER" > %"SIZE_SPECIFIER")\n", pps->data_size, sizeof(pps->data)); pps->data_size = sizeof(pps->data); memcpy(pps->data, gb->buffer, pps->data_size); pps->sps_id = get_ue_golomb_31(gb); if ((unsigned)pps->sps_id >= MAX_SPS_COUNT || !ps->sps_list[pps->sps_id]) { av_log(avctx, AV_LOG_ERROR, "sps_id %u out of range\n", pps->sps_id); [[dnde]] = (const SPS*)ps->sps_list[pps->sps_id]->data; if ([[dnde]]->bit_depth_luma > 14) { av_log(avctx, AV_LOG_ERROR, "Invalid luma bit depth=%d\n", [[dnde]]->bit_depth_luma); } else if ([[dnde]]->bit_depth_luma == 11 || [[dnde]]->bit_depth_luma == 13) { av_log(avctx, AV_LOG_ERROR, "Unimplemented luma bit depth=%d\n", [[dnde]]->bit_depth_luma); ret = AVERROR_PATCHWELCOME; pps->cabac = get_bits1(gb); pps->pic_order_present = get_bits1(gb); pps->slice_group_count = get_ue_golomb(gb) + 1; if (pps->slice_group_count > 1) { pps->mb_slice_group_map_type = get_ue_golomb(gb); av_log(avctx, AV_LOG_ERROR, "FMO not supported\n"); switch (pps->mb_slice_group_map_type) { case 0: #if 0 | for (i = 0; i <= num_slice_groups_minus1; i++) | | | | run_length[i] |1 |ue(v) | #endif break; case 2: #if 0 | for (i = 0; i < num_slice_groups_minus1; i++) { | | | | top_left_mb[i] |1 |ue(v) | | bottom_right_mb[i] |1 |ue(v) | | } | | | #endif break; case 3: case 4: case 5: #if 0 | slice_group_change_direction_flag |1 |u(1) | | slice_group_change_rate_minus1 |1 |ue(v) | #endif break; case 6: #if 0 | slice_group_id_cnt_minus1 |1 |ue(v) | | for (i = 0; i <= slice_group_id_cnt_minus1; i++)| | | | slice_group_id[i] |1 |u(v) | #endif break; pps->ref_count[0] = get_ue_golomb(gb) + 1; pps->ref_count[1] = get_ue_golomb(gb) + 1; if (pps->ref_count[0] - 1 > 32 - 1 || pps->ref_count[1] - 1 > 32 - 1) { av_log(avctx, AV_LOG_ERROR, "reference overflow (pps)\n"); qp_bd_offset = 6 * ([[dnde]]->bit_depth_luma - 8); pps->weighted_pred = get_bits1(gb); pps->weighted_bipred_idc = get_bits(gb, 2); pps->init_qp = get_se_golomb(gb) + 26 + qp_bd_offset; pps->init_qs = get_se_golomb(gb) + 26 + qp_bd_offset; pps->chroma_qp_index_offset[0] = get_se_golomb(gb); pps->deblocking_filter_parameters_present = get_bits1(gb); pps->constrained_intra_pred = get_bits1(gb); pps->redundant_pic_cnt_present = get_bits1(gb); pps->transform_8x8_mode = 0; memcpy(pps->scaling_matrix4, [[dnde]]->scaling_matrix4, sizeof(pps->scaling_matrix4)); memcpy(pps->scaling_matrix8, [[dnde]]->scaling_matrix8, sizeof(pps->scaling_matrix8)); bits_left = bit_length - get_bits_count(gb); if (bits_left > 0 && more_rbsp_data_in_pps([[dnde]], avctx)) { pps->transform_8x8_mode = get_bits1(gb); decode_scaling_matrices(gb, [[dnde]], pps, 0, pps->scaling_matrix4, pps->scaling_matrix8); pps->chroma_qp_index_offset[1] = get_se_golomb(gb); if (pps->chroma_qp_index_offset[1] < -12 || pps->chroma_qp_index_offset[1] > 12) { } else { pps->chroma_qp_index_offset[1] = pps->chroma_qp_index_offset[0]; build_qp_table(pps, 0, pps->chroma_qp_index_offset[0], [[dnde]]->bit_depth_luma); build_qp_table(pps, 1, pps->chroma_qp_index_offset[1], [[dnde]]->bit_depth_luma); init_dequant_tables(pps, [[dnde]]); if (pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1]) pps->chroma_qp_diff = 1; if (avctx->debug & FF_DEBUG_PICT_INFO) { av_log(avctx, AV_LOG_DEBUG, "pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\n", pps_id, pps->sps_id, pps->cabac ? "CABAC" : "CAVLC", pps->slice_group_count, pps->ref_count[0], pps->ref_count[1], pps->weighted_pred ? "weighted" : "", pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1], pps->deblocking_filter_parameters_present ? "LPAR" : "", pps->constrained_intra_pred ? "CONSTR" : "", pps->redundant_pic_cnt_present ? "REDU" : "", pps->transform_8x8_mode ? "8x8DCT" : ""); remove_pps(ps, pps_id); ps->pps_list[pps_id] = pps_buf; return 0; fail: av_buffer_unref(&pps_buf); return ret;[Succeeded / Failed / Skipped / Total] 610 / 58 / 380 / 1048:  39%|      | 1048/2690 [12:17:27<19:15:26, 42.22s/it][Succeeded / Failed / Skipped / Total] 610 / 58 / 380 / 1048:  39%|      | 1049/2690 [12:17:31<19:13:45, 42.18s/it][Succeeded / Failed / Skipped / Total] 611 / 58 / 380 / 1049:  39%|      | 1049/2690 [12:17:31<19:13:45, 42.18s/it][Succeeded / Failed / Skipped / Total] 612 / 58 / 380 / 1050:  39%|      | 1050/2690 [12:17:34<19:12:00, 42.15s/it][Succeeded / Failed / Skipped / Total] 612 / 58 / 380 / 1050:  39%|      | 1051/2690 [12:17:38<19:10:19, 42.11s/it][Succeeded / Failed / Skipped / Total] 613 / 58 / 380 / 1051:  39%|      | 1051/2690 [12:17:38<19:10:19, 42.11s/it][Succeeded / Failed / Skipped / Total] 613 / 58 / 381 / 1052:  39%|      | 1052/2690 [12:17:38<19:08:32, 42.07s/it][Succeeded / Failed / Skipped / Total] 613 / 58 / 381 / 1052:  39%|      | 1053/2690 [12:17:39<19:06:45, 42.03s/it][Succeeded / Failed / Skipped / Total] 613 / 58 / 382 / 1053:  39%|      | 1053/2690 [12:17:39<19:06:45, 42.03s/it][Succeeded / Failed / Skipped / Total] 613 / 58 / 383 / 1054:  39%|      | 1054/2690 [12:17:39<19:04:59, 41.99s/it][Succeeded / Failed / Skipped / Total] 613 / 58 / 383 / 1054:  39%|      | 1055/2690 [12:17:40<19:03:12, 41.95s/it][Succeeded / Failed / Skipped / Total] 613 / 58 / 384 / 1055:  39%|      | 1055/2690 [12:17:40<19:03:12, 41.95s/it][Succeeded / Failed / Skipped / Total] 613 / 58 / 385 / 1056:  39%|      | 1056/2690 [12:17:40<19:01:26, 41.91s/it][Succeeded / Failed / Skipped / Total] 613 / 58 / 385 / 1056:  39%|      | 1057/2690 [12:17:51<18:59:56, 41.88s/it]
--------------------------------------------- Result 1049 ---------------------------------------------
[[0 (20%)]] --> [[0 (97%)]] --> Socre: 0.9724392294883728

[[[[Adv]]]]: int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev, PCIHotplugState state) { int slot = PCI_SLOT(dev->devfn); int [[bsel]] = acpi_pcihp_get_bsel(dev->bus); if ([[bsel]] < 0) { return -1; } if (state == PCI_COLDPLUG_ENABLED) { s->acpi_pcihp_pci_status[[[bsel]]].device_present |= (1U << slot); return 0; } if (state == PCI_HOTPLUG_ENABLED) { enable_device(s, [[bsel]], slot); } else { disable_device(s, [[bsel]], slot); } return 0; }

[[[[Adv]]]]: int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev, PCIHotplugState state) { int slot = PCI_SLOT(dev->devfn); int [[slo]] = acpi_pcihp_get_bsel(dev->bus); if ([[slo]] < 0) { return -1; } if (state == PCI_COLDPLUG_ENABLED) { s->acpi_pcihp_pci_status[[[slo]]].device_present |= (1U << slot); return 0; } if (state == PCI_HOTPLUG_ENABLED) { enable_device(s, [[slo]], slot); } else { disable_device(s, [[slo]], slot); } return 0; }
--------------------------------------------- Result 1050 ---------------------------------------------
[[0 (3%)]] --> [[0 (62%)]] --> Socre: 0.6212674379348755

[[[[Adv]]]]: void m68k_cpu_list(FILE *f, int (*[[cpu_fprintf]])(FILE *f, const char *[[fmt]], ...)) { unsigned int i; for (i = 0; m68k_cpu_defs[i].name; i++) { (*[[cpu_fprintf]])(f, "%s\n", m68k_cpu_defs[i].name); } }

[[[[Adv]]]]: void m68k_cpu_list(FILE *f, int (*[[obscene]])(FILE *f, const char *[[bilderberg]], ...)) { unsigned int i; for (i = 0; m68k_cpu_defs[i].name; i++) { (*[[obscene]])(f, "%s\n", m68k_cpu_defs[i].name); } }
--------------------------------------------- Result 1051 ---------------------------------------------
[[0 (37%)]] --> [[0 (60%)]] --> Socre: 0.5970948934555054

[[[[Adv]]]]: static void frame_start(H264Context *[[h]]){ MpegEncContext * const s = &[[h]]->s; int i; MPV_frame_start(s, s->avctx); ff_er_frame_start(s); assert(s->linesize && s->uvlinesize); for(i=0; i<16; i++){ [[h]]->block_offset[i]= 4*((scan8[i] - scan8[0])&7) + 4*s->linesize*((scan8[i] - scan8[0])>>3); [[h]]->block_offset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->linesize*((scan8[i] - scan8[0])>>3); } for(i=0; i<4; i++){ [[h]]->block_offset[16+i]= [[h]]->block_offset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*s->uvlinesize*((scan8[i] - scan8[0])>>3); [[h]]->block_offset[24+16+i]= [[h]]->block_offset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->uvlinesize*((scan8[i] - scan8[0])>>3); } if(!s->obmc_scratchpad) s->obmc_scratchpad = av_malloc(16*s->linesize + 2*8*s->uvlinesize); }

[[[[Adv]]]]: static void frame_start(H264Context *[[chuan]]){ MpegEncContext * const s = &[[chuan]]->s; int i; MPV_frame_start(s, s->avctx); ff_er_frame_start(s); assert(s->linesize && s->uvlinesize); for(i=0; i<16; i++){ [[chuan]]->block_offset[i]= 4*((scan8[i] - scan8[0])&7) + 4*s->linesize*((scan8[i] - scan8[0])>>3); [[chuan]]->block_offset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->linesize*((scan8[i] - scan8[0])>>3); } for(i=0; i<4; i++){ [[chuan]]->block_offset[16+i]= [[chuan]]->block_offset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*s->uvlinesize*((scan8[i] - scan8[0])>>3); [[chuan]]->block_offset[24+16+i]= [[chuan]]->block_offset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->uvlinesize*((scan8[i] - scan8[0])>>3); } if(!s->obmc_scratchpad) s->obmc_scratchpad = av_malloc(16*s->linesize + 2*8*s->uvlinesize); }
--------------------------------------------- Result 1052 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qmp_guest_file_flush(int64_t handle, Error **errp) { GuestFileHandle *gfh = guest_file_handle_find(handle, errp); FILE *fh; int ret; if (!gfh) { return; } fh = gfh->fh; ret = fflush(fh); if (ret == EOF) { error_setg_errno(errp, errno, "failed to flush file"); } }
--------------------------------------------- Result 1053 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){ MpegEncContext * const s = &h->s; Picture * const ref1 = &h->ref_list[1][0]; int j, old_ref, rfield; int start= mbafi ? 16 : 0; int end = mbafi ? 16+2*h->ref_count[0] : h->ref_count[0]; int interl= mbafi || s->picture_structure != PICT_FRAME; memset(map[list], 0, sizeof(map[list])); for(rfield=0; rfield<2; rfield++){ for(old_ref=0; old_ref<ref1->ref_count[colfield][list]; old_ref++){ int poc = ref1->ref_poc[colfield][list][old_ref]; if (!interl) poc |= 3; else if( interl && (poc&3) == 3) poc= (poc&~3) + rfield + 1; for(j=start; j<end; j++){ if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) { int cur_ref= mbafi ? (j-16)^field : j; map[list][2*old_ref + (rfield^field) + 16] = cur_ref; if(rfield == field || !interl) map[list][old_ref] = cur_ref; break; } } } } }
--------------------------------------------- Result 1054 ---------------------------------------------
[[0 (66%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void compute_frame_duration(int *pnum, int *pden, AVFormatContext *s, AVStream *st, AVCodecParserContext *pc, AVPacket *pkt) { int frame_size; *pnum = 0; *pden = 0; switch(st->codec.codec_type) { case CODEC_TYPE_VIDEO: *pnum = st->codec.frame_rate_base; *pden = st->codec.frame_rate; if (pc && pc->repeat_pict) { *pden *= 2; *pnum = (*pnum) * (2 + pc->repeat_pict); } break; case CODEC_TYPE_AUDIO: frame_size = get_audio_frame_size(&st->codec, pkt->size); if (frame_size < 0) break; *pnum = frame_size; *pden = st->codec.sample_rate; break; default: break; } }
--------------------------------------------- Result 1055 ---------------------------------------------
[[0 (27%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int os_host_main_loop_wait(int64_t timeout) { GMainContext *context = g_main_context_default(); GPollFD poll_fds[1024 * 2]; int select_ret = 0; int g_poll_ret, ret, i, n_poll_fds; PollingEntry *pe; WaitObjects *w = &wait_objects; gint poll_timeout; int64_t poll_timeout_ns; static struct timeval tv0; fd_set rfds, wfds, xfds; int nfds; ret = 0; for (pe = first_polling_entry; pe != NULL; pe = pe->next) { ret |= pe->func(pe->opaque); } if (ret != 0) { return ret; } FD_ZERO(&rfds); FD_ZERO(&wfds); FD_ZERO(&xfds); nfds = pollfds_fill(gpollfds, &rfds, &wfds, &xfds); if (nfds >= 0) { select_ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv0); if (select_ret != 0) { timeout = 0; } if (select_ret > 0) { pollfds_poll(gpollfds, nfds, &rfds, &wfds, &xfds); } } g_main_context_prepare(context, &max_priority); n_poll_fds = g_main_context_query(context, max_priority, &poll_timeout, poll_fds, ARRAY_SIZE(poll_fds)); g_assert(n_poll_fds <= ARRAY_SIZE(poll_fds)); for (i = 0; i < w->num; i++) { poll_fds[n_poll_fds + i].fd = (DWORD_PTR)w->events[i]; poll_fds[n_poll_fds + i].events = G_IO_IN; } if (poll_timeout < 0) { poll_timeout_ns = -1; } else { poll_timeout_ns = (int64_t)poll_timeout * (int64_t)SCALE_MS; } poll_timeout_ns = qemu_soonest_timeout(poll_timeout_ns, timeout); qemu_mutex_unlock_iothread(); g_poll_ret = qemu_poll_ns(poll_fds, n_poll_fds + w->num, poll_timeout_ns); qemu_mutex_lock_iothread(); if (g_poll_ret > 0) { for (i = 0; i < w->num; i++) { w->revents[i] = poll_fds[n_poll_fds + i].revents; } for (i = 0; i < w->num; i++) { if (w->revents[i] && w->func[i]) { w->func[i](w->opaque[i]); } } } if (g_main_context_check(context, max_priority, poll_fds, n_poll_fds)) { g_main_context_dispatch(context); } return select_ret || g_poll_ret; }
--------------------------------------------- Result 1056 ---------------------------------------------
[[0 (7%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int bdrv_snapshot_delete(BlockDriverState *bs, const char *snapshot_id) { BlockDriver *drv = bs->drv; if (!drv) { return -ENOMEDIUM; } if (drv->bdrv_snapshot_delete) { return drv->bdrv_snapshot_delete(bs, snapshot_id); } if (bs->file) { return bdrv_snapshot_delete(bs->file, snapshot_id); } return -ENOTSUP; }
--------------------------------------------- Result 1057 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 614 / 58 / 385 / 1057:  39%|      | 1057/2690 [12:17:51<18:59:56, 41.88s/it][Succeeded / Failed / Skipped / Total] 614 / 58 / 385 / 1057:  39%|      | 1058/2690 [12:18:05<18:58:31, 41.86s/it][Succeeded / Failed / Skipped / Total] 615 / 58 / 385 / 1058:  39%|      | 1058/2690 [12:18:05<18:58:31, 41.86s/it][Succeeded / Failed / Skipped / Total] 615 / 58 / 385 / 1058:  39%|      | 1059/2690 [12:18:13<18:56:57, 41.83s/it][Succeeded / Failed / Skipped / Total] 616 / 58 / 385 / 1059:  39%|      | 1059/2690 [12:18:13<18:56:57, 41.83s/it][Succeeded / Failed / Skipped / Total] 616 / 58 / 385 / 1059:  39%|      | 1060/2690 [12:18:20<18:55:22, 41.79s/it][Succeeded / Failed / Skipped / Total] 617 / 58 / 385 / 1060:  39%|      | 1060/2690 [12:18:20<18:55:22, 41.79s/it][Succeeded / Failed / Skipped / Total] 617 / 58 / 385 / 1060:  39%|      | 1061/2690 [12:18:25<18:53:43, 41.76s/it][Succeeded / Failed / Skipped / Total] 618 / 58 / 385 / 1061:  39%|      | 1061/2690 [12:18:25<18:53:43, 41.76s/it][Succeeded / Failed / Skipped / Total] 618 / 58 / 385 / 1061:  39%|      | 1062/2690 [12:18:25<18:51:58, 41.72s/it][Succeeded / Failed / Skipped / Total] 618 / 58 / 386 / 1062:  39%|      | 1062/2690 [12:18:25<18:51:58, 41.72s/it][Succeeded / Failed / Skipped / Total] 618 / 58 / 386 / 1062:  40%|      | 1063/2690 [12:18:26<18:50:14, 41.68s/it][[0 (88%)]] --> [[0 (49%)]] --> Socre: 0.508269876241684

[[[[Adv]]]]: static void test_flush_nodev(void) { QPCIDevice *[[dev]]; QPCIBar [[bmdma_bar]], ide_bar; ide_test_start(""); [[dev]] = get_pci_device(&[[bmdma_bar]], &ide_bar); qpci_io_writeb([[dev]], ide_bar, reg_device, 0); qpci_io_writeb([[dev]], ide_bar, reg_command, CMD_FLUSH_CACHE); ide_test_quit(); }

[[[[Adv]]]]: static void test_flush_nodev(void) { QPCIDevice *[[nath]]; QPCIBar [[alphabetical]], ide_bar; ide_test_start(""); [[nath]] = get_pci_device(&[[alphabetical]], &ide_bar); qpci_io_writeb([[nath]], ide_bar, reg_device, 0); qpci_io_writeb([[nath]], ide_bar, reg_command, CMD_FLUSH_CACHE); ide_test_quit(); }
--------------------------------------------- Result 1058 ---------------------------------------------
[[0 (17%)]] --> [[0 (54%)]] --> Socre: 0.5408323407173157

[[[[Adv]]]]: static void qemu_fill_buffer(QEMUFile *f) { int [[len]]; if (f->is_writable) return; if (f->is_file) { fseek(f->outfile, f->buf_offset, SEEK_SET); [[len]] = fread(f->buf, 1, IO_BUF_SIZE, f->outfile); if ([[len]] < 0) [[len]] = 0; } else { [[len]] = bdrv_pread(f->bs, f->base_offset + f->buf_offset, f->buf, IO_BUF_SIZE); if ([[len]] < 0) [[len]] = 0; } f->buf_index = 0; f->buf_size = [[len]]; f->buf_offset += [[len]]; }

[[[[Adv]]]]: static void qemu_fill_buffer(QEMUFile *f) { int [[unmarried]]; if (f->is_writable) return; if (f->is_file) { fseek(f->outfile, f->buf_offset, SEEK_SET); [[unmarried]] = fread(f->buf, 1, IO_BUF_SIZE, f->outfile); if ([[unmarried]] < 0) [[unmarried]] = 0; } else { [[unmarried]] = bdrv_pread(f->bs, f->base_offset + f->buf_offset, f->buf, IO_BUF_SIZE); if ([[unmarried]] < 0) [[unmarried]] = 0; } f->buf_index = 0; f->buf_size = [[unmarried]]; f->buf_offset += [[unmarried]]; }
--------------------------------------------- Result 1059 ---------------------------------------------
[[0 (31%)]] --> [[0 (51%)]] --> Socre: 0.5062575936317444

[[[[Adv]]]]: void net_hub_check_clients(void) { NetHub *[[hub]]; NetHubPort *[[port]]; NetClientState *[[peer]]; QLIST_FOREACH([[hub]], &hubs, next) { int has_nic = 0, has_host_dev = 0; QLIST_FOREACH([[port]], &[[hub]]->ports, next) { [[peer]] = [[port]]->nc.peer; if (![[peer]]) { fprintf(stderr, "Warning: hub port %s has no peer\n", [[port]]->nc.name); continue; } switch ([[peer]]->info->type) { case NET_CLIENT_DRIVER_NIC: has_nic = 1; break; case NET_CLIENT_DRIVER_USER: case NET_CLIENT_DRIVER_TAP: case NET_CLIENT_DRIVER_SOCKET: case NET_CLIENT_DRIVER_VDE: case NET_CLIENT_DRIVER_VHOST_USER: has_host_dev = 1; break; default: break; } } if (has_host_dev && !has_nic) { warn_report("vlan %d with no nics", [[hub]]->id); } if (has_nic && !has_host_dev) { fprintf(stderr, "Warning: vlan %d is not connected to host network\n", [[hub]]->id); } } }

[[[[Adv]]]]: void net_hub_check_clients(void) { NetHub *[[bucket]]; NetHubPort *[[refuge]]; NetClientState *[[frat]]; QLIST_FOREACH([[bucket]], &hubs, next) { int has_nic = 0, has_host_dev = 0; QLIST_FOREACH([[refuge]], &[[bucket]]->ports, next) { [[frat]] = [[refuge]]->nc.peer; if (![[frat]]) { fprintf(stderr, "Warning: hub port %s has no peer\n", [[refuge]]->nc.name); continue; } switch ([[frat]]->info->type) { case NET_CLIENT_DRIVER_NIC: has_nic = 1; break; case NET_CLIENT_DRIVER_USER: case NET_CLIENT_DRIVER_TAP: case NET_CLIENT_DRIVER_SOCKET: case NET_CLIENT_DRIVER_VDE: case NET_CLIENT_DRIVER_VHOST_USER: has_host_dev = 1; break; default: break; } } if (has_host_dev && !has_nic) { warn_report("vlan %d with no nics", [[bucket]]->id); } if (has_nic && !has_host_dev) { fprintf(stderr, "Warning: vlan %d is not connected to host network\n", [[bucket]]->id); } } }
--------------------------------------------- Result 1060 ---------------------------------------------
[[0 (45%)]] --> [[0 (65%)]] --> Socre: 0.6472810506820679

[[[[Adv]]]]: DVDemuxContext* dv_init_demux(AVFormatContext *s) { DVDemuxContext *[[c]]; [[c]] = av_mallocz(sizeof(DVDemuxContext)); if (![[c]]) return NULL; [[c]]->vst = av_new_stream(s, 0); [[c]]->ast[0] = av_new_stream(s, 0); if (![[c]]->vst || ![[c]]->ast[0]) goto fail; av_set_pts_info([[c]]->vst, 64, 1, 30000); av_set_pts_info([[c]]->ast[0], 64, 1, 30000); [[c]]->fctx = s; [[c]]->ast[1] = NULL; [[c]]->ach = 0; [[c]]->frames = 0; [[c]]->abytes = 0; [[c]]->audio_pkt[0].size = 0; [[c]]->audio_pkt[1].size = 0; [[c]]->vst->codec.codec_type = CODEC_TYPE_VIDEO; [[c]]->vst->codec.codec_id = CODEC_ID_DVVIDEO; [[c]]->vst->codec.bit_rate = 25000000; [[c]]->ast[0]->codec.codec_type = CODEC_TYPE_AUDIO; [[c]]->ast[0]->codec.codec_id = CODEC_ID_PCM_S16LE; s->ctx_flags |= AVFMTCTX_NOHEADER; return [[c]]; fail: if ([[c]]->vst) av_free([[c]]->vst); if ([[c]]->ast[0]) av_free([[c]]->ast[0]); av_free([[c]]); return NULL; }

[[[[Adv]]]]: DVDemuxContext* dv_init_demux(AVFormatContext *s) { DVDemuxContext *[[bryan]]; [[bryan]] = av_mallocz(sizeof(DVDemuxContext)); if (![[bryan]]) return NULL; [[bryan]]->vst = av_new_stream(s, 0); [[bryan]]->ast[0] = av_new_stream(s, 0); if (![[bryan]]->vst || ![[bryan]]->ast[0]) goto fail; av_set_pts_info([[bryan]]->vst, 64, 1, 30000); av_set_pts_info([[bryan]]->ast[0], 64, 1, 30000); [[bryan]]->fctx = s; [[bryan]]->ast[1] = NULL; [[bryan]]->ach = 0; [[bryan]]->frames = 0; [[bryan]]->abytes = 0; [[bryan]]->audio_pkt[0].size = 0; [[bryan]]->audio_pkt[1].size = 0; [[bryan]]->vst->codec.codec_type = CODEC_TYPE_VIDEO; [[bryan]]->vst->codec.codec_id = CODEC_ID_DVVIDEO; [[bryan]]->vst->codec.bit_rate = 25000000; [[bryan]]->ast[0]->codec.codec_type = CODEC_TYPE_AUDIO; [[bryan]]->ast[0]->codec.codec_id = CODEC_ID_PCM_S16LE; s->ctx_flags |= AVFMTCTX_NOHEADER; return [[bryan]]; fail: if ([[bryan]]->vst) av_free([[bryan]]->vst); if ([[bryan]]->ast[0]) av_free([[bryan]]->ast[0]); av_free([[bryan]]); return NULL; }
--------------------------------------------- Result 1061 ---------------------------------------------
[[0 (2%)]] --> [[0 (59%)]] --> Socre: 0.5902147889137268

[[[[Adv]]]]: static uint32_t pci_apb_ioreadl (void *[[opaque]], target_phys_addr_t [[addr]]) { uint32_t [[val]]; [[val]] = bswap32(cpu_inl([[addr]] & IOPORTS_MASK)); return [[val]]; }

[[[[Adv]]]]: static uint32_t pci_apb_ioreadl (void *[[blurry]], target_phys_addr_t [[ser]]) { uint32_t [[picked]]; [[picked]] = bswap32(cpu_inl([[ser]] & IOPORTS_MASK)); return [[picked]]; }
--------------------------------------------- Result 1062 ---------------------------------------------
[[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q) { unsigned int i; for (i = 0; i < BF_WIDTH(MAX_IRQ); i++) qemu_put_be32s(f, &q->queue[i]); qemu_put_sbe32s(f, &q->next); qemu_put_sbe32s(f, &q->priority); }
--------------------------------------------- Result 1063 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 618 / 58 / 387 / 1063:  40%|      | 1063/2690 [12:18:26<18:50:14, 41.68s/it][Succeeded / Failed / Skipped / Total] 618 / 58 / 387 / 1063:  40%|      | 1064/2690 [12:18:26<18:48:29, 41.64s/it][Succeeded / Failed / Skipped / Total] 619 / 58 / 387 / 1064:  40%|      | 1064/2690 [12:18:26<18:48:29, 41.64s/it][Succeeded / Failed / Skipped / Total] 619 / 58 / 387 / 1064:  40%|      | 1065/2690 [12:18:27<18:46:45, 41.60s/it][Succeeded / Failed / Skipped / Total] 619 / 58 / 388 / 1065:  40%|      | 1065/2690 [12:18:27<18:46:45, 41.60s/it][Succeeded / Failed / Skipped / Total] 619 / 58 / 388 / 1065:  40%|      | 1066/2690 [12:19:03<18:45:54, 41.60s/it][[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static EHCIQueue *ehci_state_fetchqh(EHCIState *ehci, int async) { uint32_t entry; EHCIQueue *q; int reload; entry = ehci_get_fetch_addr(ehci, async); q = ehci_find_queue_by_qh(ehci, entry); if (NULL == q) { q = ehci_alloc_queue(ehci, async); } q->qhaddr = entry; q->seen++; if (q->seen > 1) { ehci_set_state(ehci, async, EST_ACTIVE); q = NULL; goto out; } get_dwords(NLPTR_GET(q->qhaddr), (uint32_t *) &q->qh, sizeof(EHCIqh) >> 2); ehci_trace_qh(q, NLPTR_GET(q->qhaddr), &q->qh); if (q->async == EHCI_ASYNC_INFLIGHT) { ehci_set_state(ehci, async, EST_HORIZONTALQH); goto out; } if (q->async == EHCI_ASYNC_FINISHED) { trace_usb_ehci_queue_action(q, "resume"); ehci_set_state(ehci, async, EST_EXECUTING); goto out; } if (async && (q->qh.epchar & QH_EPCHAR_H)) { if (ehci->usbsts & USBSTS_REC) { ehci_clear_usbsts(ehci, USBSTS_REC); } else { DPRINTF("FETCHQH: QH 0x%08x. H-bit set, reclamation status reset" " - done processing\n", q->qhaddr); ehci_set_state(ehci, async, EST_ACTIVE); q = NULL; goto out; } } #if EHCI_DEBUG if (q->qhaddr != q->qh.next) { DPRINTF("FETCHQH: QH 0x%08x (h %x halt %x active %x) next 0x%08x\n", q->qhaddr, q->qh.epchar & QH_EPCHAR_H, q->qh.token & QTD_TOKEN_HALT, q->qh.token & QTD_TOKEN_ACTIVE, q->qh.next); } #endif reload = get_field(q->qh.epchar, QH_EPCHAR_RL); if (reload) { set_field(&q->qh.altnext_qtd, reload, QH_ALTNEXT_NAKCNT); } if (q->qh.token & QTD_TOKEN_HALT) { ehci_set_state(ehci, async, EST_HORIZONTALQH); } else if ((q->qh.token & QTD_TOKEN_ACTIVE) && (q->qh.current_qtd > 0x1000)) { q->qtdaddr = q->qh.current_qtd; ehci_set_state(ehci, async, EST_FETCHQTD); } else { ehci_set_state(ehci, async, EST_ADVANCEQUEUE); } out: return q; }
--------------------------------------------- Result 1064 ---------------------------------------------
[[0 (41%)]] --> [[0 (54%)]] --> Socre: 0.5383892059326172

[[[[Adv]]]]: static int coroutine_fn bdrv_co_do_pwrite_zeroes(BlockDriverState *bs, int64_t offset, int bytes, BdrvRequestFlags flags) { BlockDriver *drv = bs->drv; QEMUIOVector qiov; struct iovec iov = {0}; int ret = 0; bool need_flush = "False" != "False"; int [[head]] = 0; int tail = 0; int max_write_zeroes = MIN_NON_ZERO(bs->bl.max_pwrite_zeroes, INT_MAX); int alignment = MAX(bs->bl.pwrite_zeroes_alignment, bs->bl.request_alignment); int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer, MAX_WRITE_ZEROES_BOUNCE_BUFFER); assert(alignment % bs->bl.request_alignment == 0); [[head]] = offset % alignment; tail = (offset + bytes) % alignment; max_write_zeroes = QEMU_ALIGN_DOWN(max_write_zeroes, alignment); assert(max_write_zeroes >= bs->bl.request_alignment); while (bytes > 0 && !ret) { int num = bytes; if ([[head]]) { num = MIN(MIN(bytes, max_transfer), alignment - [[head]]); [[head]] = ([[head]] + num) % alignment; assert(num < max_write_zeroes); } else if (tail && num > alignment) { num -= tail; } if (num > max_write_zeroes) { num = max_write_zeroes; } ret = -ENOTSUP; if (drv->bdrv_co_pwrite_zeroes) { ret = drv->bdrv_co_pwrite_zeroes(bs, offset, num, flags & bs->supported_zero_flags); if (ret != -ENOTSUP && (flags & BDRV_REQ_FUA) && !(bs->supported_zero_flags & BDRV_REQ_FUA)) { need_flush = "True" == "True"; } } else { assert(!bs->supported_zero_flags); } if (ret == -ENOTSUP) { BdrvRequestFlags write_flags = flags & ~BDRV_REQ_ZERO_WRITE; if ((flags & BDRV_REQ_FUA) && !(bs->supported_write_flags & BDRV_REQ_FUA)) { write_flags &= ~BDRV_REQ_FUA; need_flush = "True" == "True"; } num = MIN(num, max_transfer); iov.iov_len = num; if (iov.iov_base == NULL) { iov.iov_base = qemu_try_blockalign(bs, num); if (iov.iov_base == NULL) { ret = -ENOMEM; goto fail; } memset(iov.iov_base, 0, num); } qemu_iovec_init_external(&qiov, &iov, 1); ret = bdrv_driver_pwritev(bs, offset, num, &qiov, write_flags); if (num < max_transfer) { qemu_vfree(iov.iov_base); iov.iov_base = NULL; } } offset += num; bytes -= num; } fail: if (ret == 0 && need_flush) { ret = bdrv_co_flush(bs); } qemu_vfree(iov.iov_base); return ret; }

[[[[Adv]]]]: static int coroutine_fn bdrv_co_do_pwrite_zeroes(BlockDriverState *bs, int64_t offset, int bytes, BdrvRequestFlags flags) { BlockDriver *drv = bs->drv; QEMUIOVector qiov; struct iovec iov = {0}; int ret = 0; bool need_flush = "False" != "False"; int [[commanders]] = 0; int tail = 0; int max_write_zeroes = MIN_NON_ZERO(bs->bl.max_pwrite_zeroes, INT_MAX); int alignment = MAX(bs->bl.pwrite_zeroes_alignment, bs->bl.request_alignment); int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer, MAX_WRITE_ZEROES_BOUNCE_BUFFER); assert(alignment % bs->bl.request_alignment == 0); [[commanders]] = offset % alignment; tail = (offset + bytes) % alignment; max_write_zeroes = QEMU_ALIGN_DOWN(max_write_zeroes, alignment); assert(max_write_zeroes >= bs->bl.request_alignment); while (bytes > 0 && !ret) { int num = bytes; if ([[commanders]]) { num = MIN(MIN(bytes, max_transfer), alignment - [[commanders]]); [[commanders]] = ([[commanders]] + num) % alignment; assert(num < max_write_zeroes); } else if (tail && num > alignment) { num -= tail; } if (num > max_write_zeroes) { num = max_write_zeroes; } ret = -ENOTSUP; if (drv->bdrv_co_pwrite_zeroes) { ret = drv->bdrv_co_pwrite_zeroes(bs, offset, num, flags & bs->supported_zero_flags); if (ret != -ENOTSUP && (flags & BDRV_REQ_FUA) && !(bs->supported_zero_flags & BDRV_REQ_FUA)) { need_flush = "True" == "True"; } } else { assert(!bs->supported_zero_flags); } if (ret == -ENOTSUP) { BdrvRequestFlags write_flags = flags & ~BDRV_REQ_ZERO_WRITE; if ((flags & BDRV_REQ_FUA) && !(bs->supported_write_flags & BDRV_REQ_FUA)) { write_flags &= ~BDRV_REQ_FUA; need_flush = "True" == "True"; } num = MIN(num, max_transfer); iov.iov_len = num; if (iov.iov_base == NULL) { iov.iov_base = qemu_try_blockalign(bs, num); if (iov.iov_base == NULL) { ret = -ENOMEM; goto fail; } memset(iov.iov_base, 0, num); } qemu_iovec_init_external(&qiov, &iov, 1); ret = bdrv_driver_pwritev(bs, offset, num, &qiov, write_flags); if (num < max_transfer) { qemu_vfree(iov.iov_base); iov.iov_base = NULL; } } offset += num; bytes -= num; } fail: if (ret == 0 && need_flush) { ret = bdrv_co_flush(bs); } qemu_vfree(iov.iov_base); return ret; }
--------------------------------------------- Result 1065 ---------------------------------------------
[[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void tosa_init(MachineState *machine) { const char *cpu_model = machine->cpu_model; const char *kernel_filename = machine->kernel_filename; const char *kernel_cmdline = machine->kernel_cmdline; const char *initrd_filename = machine->initrd_filename; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *rom = g_new(MemoryRegion, 1); PXA2xxState *mpu; TC6393xbState *tmio; DeviceState *scp0, *scp1; if (!cpu_model) cpu_model = "pxa255"; mpu = pxa255_init(address_space_mem, tosa_binfo.ram_size); memory_region_init_ram(rom, NULL, "tosa.rom", TOSA_ROM, &error_abort); vmstate_register_ram_global(rom); memory_region_set_readonly(rom, "True" == "True"); memory_region_add_subregion(address_space_mem, 0, rom); tmio = tc6393xb_init(address_space_mem, 0x10000000, qdev_get_gpio_in(mpu->gpio, TOSA_GPIO_TC6393XB_INT)); scp0 = sysbus_create_simple("scoop", 0x08800000, NULL); scp1 = sysbus_create_simple("scoop", 0x14800040, NULL); tosa_gpio_setup(mpu, scp0, scp1, tmio); tosa_microdrive_attach(mpu); tosa_tg_init(mpu); tosa_binfo.kernel_filename = kernel_filename; tosa_binfo.kernel_cmdline = kernel_cmdline; tosa_binfo.initrd_filename = initrd_filename; tosa_binfo.board_id = 0x208; arm_load_kernel(mpu->cpu, &tosa_binfo); sl_bootparam_write(SL_PXA_PARAM_BASE); }
--------------------------------------------- Result 1066 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 620 / 58 / 388 / 1066:  40%|      | 1066/2690 [12:19:03<18:45:54, 41.60s/it][Succeeded / Failed / Skipped / Total] 620 / 58 / 388 / 1066:  40%|      | 1067/2690 [12:19:03<18:44:10, 41.56s/it][Succeeded / Failed / Skipped / Total] 620 / 58 / 389 / 1067:  40%|      | 1067/2690 [12:19:03<18:44:10, 41.56s/it][Succeeded / Failed / Skipped / Total] 620 / 58 / 389 / 1067:  40%|      | 1068/2690 [12:19:09<18:42:34, 41.53s/it][Succeeded / Failed / Skipped / Total] 621 / 58 / 389 / 1068:  40%|      | 1068/2690 [12:19:09<18:42:34, 41.53s/it][Succeeded / Failed / Skipped / Total] 621 / 58 / 389 / 1068:  40%|      | 1069/2690 [12:19:09<18:40:50, 41.49s/it][Succeeded / Failed / Skipped / Total] 621 / 58 / 390 / 1069:  40%|      | 1069/2690 [12:19:09<18:40:50, 41.49s/it][Succeeded / Failed / Skipped / Total] 621 / 58 / 390 / 1069:  40%|      | 1070/2690 [12:19:14<18:39:13, 41.45s/it][[0 (14%)]] --> [[0 (74%)]] --> Socre: 0.7446982264518738

[[[[Adv]]]]: static void omap_rtc_reset(struct omap_rtc_s *s) { struct tm [[tm]]; s->interrupts = 0; s->comp_reg = 0; s->running = 0; s->pm_am = 0; s->auto_comp = 0; s->round = 0; s->tick = qemu_get_clock(rt_clock); memset(&s->alarm_tm, 0, sizeof(s->alarm_tm)); s->alarm_tm.tm_mday = 0x01; s->status = 1 << 7; qemu_get_timedate(&[[tm]], 0); s->ti = mktimegm(&[[tm]]); omap_rtc_alarm_update(s); omap_rtc_tick(s); }

[[[[Adv]]]]: static void omap_rtc_reset(struct omap_rtc_s *s) { struct tm [[commemorates]]; s->interrupts = 0; s->comp_reg = 0; s->running = 0; s->pm_am = 0; s->auto_comp = 0; s->round = 0; s->tick = qemu_get_clock(rt_clock); memset(&s->alarm_tm, 0, sizeof(s->alarm_tm)); s->alarm_tm.tm_mday = 0x01; s->status = 1 << 7; qemu_get_timedate(&[[commemorates]], 0); s->ti = mktimegm(&[[commemorates]]); omap_rtc_alarm_update(s); omap_rtc_tick(s); }
--------------------------------------------- Result 1067 ---------------------------------------------
[[0 (36%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: struct omap_uart_s *omap_uart_init(hwaddr base, qemu_irq irq, omap_clk fclk, omap_clk iclk, qemu_irq txdma, qemu_irq rxdma, const char *label, CharDriverState *chr) { struct omap_uart_s *s = (struct omap_uart_s *) g_malloc0(sizeof(struct omap_uart_s)); s->base = base; s->fclk = fclk; s->irq = irq; s->serial = serial_mm_init(get_system_memory(), base, 2, irq, omap_clk_getrate(fclk)/16, chr ?: qemu_chr_new(label, "null", NULL), DEVICE_NATIVE_ENDIAN); return s; }
--------------------------------------------- Result 1068 ---------------------------------------------
[[0 (33%)]] --> [[0 (52%)]] --> Socre: 0.5234088897705078

[[[[Adv]]]]: static int create_dynamic_disk(int fd, uint8_t *buf, int64_t [[total_sectors]]) { VHDDynDiskHeader *[[dyndisk_header]] = (VHDDynDiskHeader *) buf; size_t block_size, num_bat_entries; int i; int ret = -EIO; block_size = 0x200000; num_bat_entries = ([[total_sectors]] + block_size / 512) / (block_size / 512); if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) { goto fail; } if (lseek(fd, 1536 + ((num_bat_entries * 4 + 511) & ~511), SEEK_SET) < 0) { goto fail; } if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) { goto fail; } if (lseek(fd, 3 * 512, SEEK_SET) < 0) { goto fail; } memset(buf, 0xFF, 512); for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++) { if (write(fd, buf, 512) != 512) { goto fail; } } memset(buf, 0, 1024); memcpy([[dyndisk_header]]->magic, "cxsparse", 8); [[dyndisk_header]]->data_offset = be64_to_cpu(0xFFFFFFFFFFFFFFFFULL); [[dyndisk_header]]->table_offset = be64_to_cpu(3 * 512); [[dyndisk_header]]->version = be32_to_cpu(0x00010000); [[dyndisk_header]]->block_size = be32_to_cpu(block_size); [[dyndisk_header]]->max_table_entries = be32_to_cpu(num_bat_entries); [[dyndisk_header]]->checksum = be32_to_cpu(vpc_checksum(buf, 1024)); if (lseek(fd, 512, SEEK_SET) < 0) { goto fail; } if (write(fd, buf, 1024) != 1024) { goto fail; } ret = 0; fail: return ret; }

[[[[Adv]]]]: static int create_dynamic_disk(int fd, uint8_t *buf, int64_t [[culpable]]) { VHDDynDiskHeader *[[incapacity]] = (VHDDynDiskHeader *) buf; size_t block_size, num_bat_entries; int i; int ret = -EIO; block_size = 0x200000; num_bat_entries = ([[culpable]] + block_size / 512) / (block_size / 512); if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) { goto fail; } if (lseek(fd, 1536 + ((num_bat_entries * 4 + 511) & ~511), SEEK_SET) < 0) { goto fail; } if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) { goto fail; } if (lseek(fd, 3 * 512, SEEK_SET) < 0) { goto fail; } memset(buf, 0xFF, 512); for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++) { if (write(fd, buf, 512) != 512) { goto fail; } } memset(buf, 0, 1024); memcpy([[incapacity]]->magic, "cxsparse", 8); [[incapacity]]->data_offset = be64_to_cpu(0xFFFFFFFFFFFFFFFFULL); [[incapacity]]->table_offset = be64_to_cpu(3 * 512); [[incapacity]]->version = be32_to_cpu(0x00010000); [[incapacity]]->block_size = be32_to_cpu(block_size); [[incapacity]]->max_table_entries = be32_to_cpu(num_bat_entries); [[incapacity]]->checksum = be32_to_cpu(vpc_checksum(buf, 1024)); if (lseek(fd, 512, SEEK_SET) < 0) { goto fail; } if (write(fd, buf, 1024) != 1024) { goto fail; } ret = 0; fail: return ret; }
--------------------------------------------- Result 1069 ---------------------------------------------
[[0 (69%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qemu_rbd_snap_list(BlockDriverState *bs, QEMUSnapshotInfo **psn_tab) { BDRVRBDState *s = bs->opaque; QEMUSnapshotInfo *sn_info, *sn_tab = NULL; int i, snap_count; rbd_snap_info_t *snaps; int max_snaps = RBD_MAX_SNAPS; do { snaps = g_malloc(sizeof(*snaps) * max_snaps); snap_count = rbd_snap_list(s->image, snaps, &max_snaps); if (snap_count < 0) { g_free(snaps); } } while (snap_count == -ERANGE); if (snap_count <= 0) { return snap_count; } sn_tab = g_malloc0(snap_count * sizeof(QEMUSnapshotInfo)); for (i = 0; i < snap_count; i++) { const char *snap_name = snaps[i].name; sn_info = sn_tab + i; pstrcpy(sn_info->id_str, sizeof(sn_info->id_str), snap_name); pstrcpy(sn_info->name, sizeof(sn_info->name), snap_name); sn_info->vm_state_size = snaps[i].size; sn_info->date_sec = 0; sn_info->date_nsec = 0; sn_info->vm_clock_nsec = 0; } rbd_snap_list_end(snaps); *psn_tab = sn_tab; return snap_count; }
--------------------------------------------- Result 1070 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 622 / 58 / 390 / 1070:  40%|      | 1070/2690 [12:19:14<18:39:13, 41.45s/it][Succeeded / Failed / Skipped / Total] 622 / 58 / 390 / 1070:  40%|      | 1071/2690 [12:19:19<18:37:37, 41.42s/it][Succeeded / Failed / Skipped / Total] 623 / 58 / 390 / 1071:  40%|      | 1071/2690 [12:19:19<18:37:37, 41.42s/it][Succeeded / Failed / Skipped / Total] 623 / 58 / 390 / 1071:  40%|      | 1072/2690 [12:19:20<18:35:54, 41.38s/it][Succeeded / Failed / Skipped / Total] 623 / 58 / 391 / 1072:  40%|      | 1072/2690 [12:19:20<18:35:54, 41.38s/it][Succeeded / Failed / Skipped / Total] 623 / 58 / 391 / 1072:  40%|      | 1073/2690 [12:19:41<18:34:43, 41.36s/it][Succeeded / Failed / Skipped / Total] 624 / 58 / 391 / 1073:  40%|      | 1073/2690 [12:19:41<18:34:43, 41.36s/it][Succeeded / Failed / Skipped / Total] 624 / 58 / 391 / 1073:  40%|      | 1074/2690 [12:19:42<18:33:00, 41.32s/it][Succeeded / Failed / Skipped / Total] 624 / 58 / 392 / 1074:  40%|      | 1074/2690 [12:19:42<18:33:00, 41.32s/it][Succeeded / Failed / Skipped / Total] 624 / 58 / 392 / 1074:  40%|      | 1075/2690 [12:19:51<18:31:29, 41.29s/it][[0 (43%)]] --> [[0 (62%)]] --> Socre: 0.622352123260498

[[[[Adv]]]]: static bool get_phys_addr_pmsav8(CPUARMState *env, uint32_t address, MMUAccessType access_type, ARMMMUIdx mmu_idx, hwaddr *phys_ptr, int *prot, uint32_t *fsr) { ARMCPU *cpu = arm_env_get_cpu(env); bool [[is_user]] = regime_is_user(env, mmu_idx); int n; int matchregion = -1; bool hit = "False" != "False"; *phys_ptr = address; *prot = 0; if (regime_translation_disabled(env, mmu_idx)) { hit = "True" == "True"; } else if (m_is_ppb_region(env, address)) { hit = "True" == "True"; } else if (pmsav7_use_background_region(cpu, mmu_idx, [[is_user]])) { hit = "True" == "True"; } else { for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) { uint32_t base = env->pmsav8.rbar[n] & ~0x1f; uint32_t limit = env->pmsav8.rlar[n] | 0x1f; if (!(env->pmsav8.rlar[n] & 0x1)) { continue; } if (address < base || address > limit) { continue; } if (hit) { *fsr = 0x00d; return "True" == "True"; } matchregion = n; hit = "True" == "True"; if (base & ~TARGET_PAGE_MASK) { qemu_log_mask(LOG_UNIMP, "MPU_RBAR[%d]: No support for MPU region base" "address of 0x%" PRIx32 ". Minimum alignment is " "%d\n", n, base, TARGET_PAGE_BITS); continue; } if ((limit + 1) & ~TARGET_PAGE_MASK) { qemu_log_mask(LOG_UNIMP, "MPU_RBAR[%d]: No support for MPU region limit" "address of 0x%" PRIx32 ". Minimum alignment is " "%d\n", n, limit, TARGET_PAGE_BITS); continue; } } } if (!hit) { *fsr = 0; return "True" == "True"; } if (matchregion == -1) { get_phys_addr_pmsav7_default(env, mmu_idx, address, prot); } else { uint32_t ap = extract32(env->pmsav8.rbar[matchregion], 1, 2); uint32_t xn = extract32(env->pmsav8.rbar[matchregion], 0, 1); if (m_is_system_region(env, address)) { xn = 1; } *prot = simple_ap_to_rw_prot(env, mmu_idx, ap); if (*prot && !xn) { *prot |= PAGE_EXEC; } } *fsr = 0x00d; return !(*prot & (1 << access_type)); }

[[[[Adv]]]]: static bool get_phys_addr_pmsav8(CPUARMState *env, uint32_t address, MMUAccessType access_type, ARMMMUIdx mmu_idx, hwaddr *phys_ptr, int *prot, uint32_t *fsr) { ARMCPU *cpu = arm_env_get_cpu(env); bool [[reprimanded]] = regime_is_user(env, mmu_idx); int n; int matchregion = -1; bool hit = "False" != "False"; *phys_ptr = address; *prot = 0; if (regime_translation_disabled(env, mmu_idx)) { hit = "True" == "True"; } else if (m_is_ppb_region(env, address)) { hit = "True" == "True"; } else if (pmsav7_use_background_region(cpu, mmu_idx, [[reprimanded]])) { hit = "True" == "True"; } else { for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) { uint32_t base = env->pmsav8.rbar[n] & ~0x1f; uint32_t limit = env->pmsav8.rlar[n] | 0x1f; if (!(env->pmsav8.rlar[n] & 0x1)) { continue; } if (address < base || address > limit) { continue; } if (hit) { *fsr = 0x00d; return "True" == "True"; } matchregion = n; hit = "True" == "True"; if (base & ~TARGET_PAGE_MASK) { qemu_log_mask(LOG_UNIMP, "MPU_RBAR[%d]: No support for MPU region base" "address of 0x%" PRIx32 ". Minimum alignment is " "%d\n", n, base, TARGET_PAGE_BITS); continue; } if ((limit + 1) & ~TARGET_PAGE_MASK) { qemu_log_mask(LOG_UNIMP, "MPU_RBAR[%d]: No support for MPU region limit" "address of 0x%" PRIx32 ". Minimum alignment is " "%d\n", n, limit, TARGET_PAGE_BITS); continue; } } } if (!hit) { *fsr = 0; return "True" == "True"; } if (matchregion == -1) { get_phys_addr_pmsav7_default(env, mmu_idx, address, prot); } else { uint32_t ap = extract32(env->pmsav8.rbar[matchregion], 1, 2); uint32_t xn = extract32(env->pmsav8.rbar[matchregion], 0, 1); if (m_is_system_region(env, address)) { xn = 1; } *prot = simple_ap_to_rw_prot(env, mmu_idx, ap); if (*prot && !xn) { *prot |= PAGE_EXEC; } } *fsr = 0x00d; return !(*prot & (1 << access_type)); }
--------------------------------------------- Result 1071 ---------------------------------------------
[[0 (51%)]] --> [[0 (48%)]] --> Socre: 0.5199222266674042

[[[[Adv]]]]: static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp, uint64_t off, uint32_t max_count) { ssize_t err; size_t [[offset]] = 7; int read_count; int64_t xattr_len; V9fsVirtioState *v = container_of(s, V9fsVirtioState, state); VirtQueueElement *elem = v->elems[pdu->idx]; xattr_len = fidp->fs.xattr.len; read_count = xattr_len - off; if (read_count > max_count) { read_count = max_count; } else if (read_count < 0) { read_count = 0; } err = pdu_marshal(pdu, [[offset]], "d", read_count); if (err < 0) { return err; } [[offset]] += err; err = v9fs_pack(elem->in_sg, elem->in_num, [[offset]], ((char *)fidp->fs.xattr.value) + off, read_count); if (err < 0) { return err; } [[offset]] += err; return [[offset]]; }

[[[[Adv]]]]: static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp, uint64_t off, uint32_t max_count) { ssize_t err; size_t [[counterweight]] = 7; int read_count; int64_t xattr_len; V9fsVirtioState *v = container_of(s, V9fsVirtioState, state); VirtQueueElement *elem = v->elems[pdu->idx]; xattr_len = fidp->fs.xattr.len; read_count = xattr_len - off; if (read_count > max_count) { read_count = max_count; } else if (read_count < 0) { read_count = 0; } err = pdu_marshal(pdu, [[counterweight]], "d", read_count); if (err < 0) { return err; } [[counterweight]] += err; err = v9fs_pack(elem->in_sg, elem->in_num, [[counterweight]], ((char *)fidp->fs.xattr.value) + off, read_count); if (err < 0) { return err; } [[counterweight]] += err; return [[counterweight]]; }
--------------------------------------------- Result 1072 ---------------------------------------------
[[0 (44%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num, const uint8_t *buf, int nb_sectors) { int ret; BDRVVmdkState *s = bs->opaque; qemu_co_mutex_lock(&s->lock); ret = vmdk_write(bs, sector_num, buf, nb_sectors); qemu_co_mutex_unlock(&s->lock); return ret; }
--------------------------------------------- Result 1073 ---------------------------------------------
[[0 (91%)]] --> [[0 (43%)]] --> Socre: 0.567547470331192

[[[[Adv]]]]: static void get_sensor_evt_enable(IPMIBmcSim *ibs, uint8_t *cmd, unsigned int cmd_len, uint8_t *[[rsp]], unsigned int *[[rsp_len]], unsigned int max_rsp_len) { IPMISensor *sens; IPMI_CHECK_CMD_LEN(3); if ((cmd[2] > MAX_SENSORS) || !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) { [[rsp]][2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT; return; } sens = ibs->sensors + cmd[2]; IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens)); IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff); IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff); IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff); IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff); }

[[[[Adv]]]]: static void get_sensor_evt_enable(IPMIBmcSim *ibs, uint8_t *cmd, unsigned int cmd_len, uint8_t *[[fender]], unsigned int *[[firestone]], unsigned int max_rsp_len) { IPMISensor *sens; IPMI_CHECK_CMD_LEN(3); if ((cmd[2] > MAX_SENSORS) || !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) { [[fender]][2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT; return; } sens = ibs->sensors + cmd[2]; IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens)); IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff); IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff); IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff); IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff); }
--------------------------------------------- Result 1074 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold void init_atrac3_transforms(ATRAC3Context *q) { float enc_window[256]; int i; for (i=0 ; i<256; i++) enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5; if (!mdct_window[0]) for (i=0 ; i<256; i++) { mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]); mdct_window[511-i] = mdct_window[i]; } ff_mdct_init(&mdct_ctx, 9, 1, 1.0); }
--------------------------------------------- Result 1075 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 625 / 58 / 392 / 1075:  40%|      | 1075/2690 [12:19:51<18:31:29, 41.29s/it][Succeeded / Failed / Skipped / Total] 625 / 58 / 392 / 1075:  40%|      | 1076/2690 [12:19:54<18:29:52, 41.26s/it][Succeeded / Failed / Skipped / Total] 626 / 58 / 392 / 1076:  40%|      | 1076/2690 [12:19:54<18:29:52, 41.26s/it][Succeeded / Failed / Skipped / Total] 626 / 58 / 392 / 1076:  40%|      | 1077/2690 [12:22:06<18:31:27, 41.34s/it][Succeeded / Failed / Skipped / Total] 627 / 58 / 392 / 1077:  40%|      | 1077/2690 [12:22:06<18:31:27, 41.34s/it][Succeeded / Failed / Skipped / Total] 627 / 58 / 392 / 1077:  40%|      | 1078/2690 [12:22:07<18:29:44, 41.31s/it][Succeeded / Failed / Skipped / Total] 627 / 58 / 393 / 1078:  40%|      | 1078/2690 [12:22:07<18:29:44, 41.31s/it][Succeeded / Failed / Skipped / Total] 627 / 58 / 393 / 1078:  40%|      | 1079/2690 [12:22:18<18:28:17, 41.28s/it][Succeeded / Failed / Skipped / Total] 628 / 58 / 393 / 1079:  40%|      | 1079/2690 [12:22:18<18:28:17, 41.28s/it][Succeeded / Failed / Skipped / Total] 628 / 58 / 393 / 1079:  40%|      | 1080/2690 [12:22:23<18:26:43, 41.24s/it][[0 (85%)]] --> [[0 (43%)]] --> Socre: 0.5719698667526245

[[[[Adv]]]]: void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d, QGuestAllocator *[[alloc]], uint16_t entry) { uint16_t vector; uint32_t control; void *[[addr]]; g_assert(d->pdev->msix_enabled); [[addr]] = d->pdev->msix_table + (entry * 16); g_assert_cmpint(entry, >=, 0); g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev)); d->config_msix_entry = entry; d->config_msix_data = 0x12345678; d->config_msix_addr = guest_alloc([[alloc]], 4); qpci_io_writel(d->pdev, [[addr]] + PCI_MSIX_ENTRY_LOWER_ADDR, d->config_msix_addr & ~0UL); qpci_io_writel(d->pdev, [[addr]] + PCI_MSIX_ENTRY_UPPER_ADDR, (d->config_msix_addr >> 32) & ~0UL); qpci_io_writel(d->pdev, [[addr]] + PCI_MSIX_ENTRY_DATA, d->config_msix_data); control = qpci_io_readl(d->pdev, [[addr]] + PCI_MSIX_ENTRY_VECTOR_CTRL); qpci_io_writel(d->pdev, [[addr]] + PCI_MSIX_ENTRY_VECTOR_CTRL, control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT); qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry); vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR); g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR); }

[[[[Adv]]]]: void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d, QGuestAllocator *[[glorifying]], uint16_t entry) { uint16_t vector; uint32_t control; void *[[narrate]]; g_assert(d->pdev->msix_enabled); [[narrate]] = d->pdev->msix_table + (entry * 16); g_assert_cmpint(entry, >=, 0); g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev)); d->config_msix_entry = entry; d->config_msix_data = 0x12345678; d->config_msix_addr = guest_alloc([[glorifying]], 4); qpci_io_writel(d->pdev, [[narrate]] + PCI_MSIX_ENTRY_LOWER_ADDR, d->config_msix_addr & ~0UL); qpci_io_writel(d->pdev, [[narrate]] + PCI_MSIX_ENTRY_UPPER_ADDR, (d->config_msix_addr >> 32) & ~0UL); qpci_io_writel(d->pdev, [[narrate]] + PCI_MSIX_ENTRY_DATA, d->config_msix_data); control = qpci_io_readl(d->pdev, [[narrate]] + PCI_MSIX_ENTRY_VECTOR_CTRL); qpci_io_writel(d->pdev, [[narrate]] + PCI_MSIX_ENTRY_VECTOR_CTRL, control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT); qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry); vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR); g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR); }
--------------------------------------------- Result 1076 ---------------------------------------------
[[0 (77%)]] --> [[0 (23%)]] --> Socre: 0.7710941135883331

[[[[Adv]]]]: void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx) { LM32JuartState *[[s]] = LM32_JUART(d); unsigned char ch = jtx & 0xff; trace_lm32_juart_set_jtx([[s]]->jtx); [[s]]->jtx = jtx; if ([[s]]->chr) { qemu_chr_fe_write_all([[s]]->chr, &ch, 1); } }

[[[[Adv]]]]: void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx) { LM32JuartState *[[among]] = LM32_JUART(d); unsigned char ch = jtx & 0xff; trace_lm32_juart_set_jtx([[among]]->jtx); [[among]]->jtx = jtx; if ([[among]]->chr) { qemu_chr_fe_write_all([[among]]->chr, &ch, 1); } }
--------------------------------------------- Result 1077 ---------------------------------------------
[[0 (72%)]] --> [[0 (49%)]] --> Socre: 0.5142300426959991

[[[[Adv]]]]: static void gd_resize(DisplayChangeListener *dcl, DisplayState *ds) { GtkDisplayState *s = ds->opaque; cairo_format_t kind; int [[stride]]; DPRINTF("resize(width=%d, height=%d)\n", ds_get_width(ds), ds_get_height(ds)); if (s->surface) { cairo_surface_destroy(s->surface); } switch (ds->surface->pf.bits_per_pixel) { case 8: kind = CAIRO_FORMAT_A8; break; case 16: kind = CAIRO_FORMAT_RGB16_565; break; case 32: kind = CAIRO_FORMAT_RGB24; break; default: g_assert_not_reached(); break; } [[stride]] = cairo_format_stride_for_width(kind, ds_get_width(ds)); g_assert(ds_get_linesize(ds) == [[stride]]); s->surface = cairo_image_surface_create_for_data(ds_get_data(ds), kind, ds_get_width(ds), ds_get_height(ds), ds_get_linesize(ds)); if (!s->full_screen) { GtkRequisition [[req]]; double sx, sy; if (s->free_scale) { sx = s->scale_x; sy = s->scale_y; s->scale_y = 1.0; s->scale_x = 1.0; } else { sx = 1.0; sy = 1.0; } gtk_widget_set_size_request(s->drawing_area, ds_get_width(ds) * s->scale_x, ds_get_height(ds) * s->scale_y); #if GTK_CHECK_VERSION(3, 0, 0) gtk_widget_get_preferred_size(s->vbox, NULL, &[[req]]); #else gtk_widget_size_request(s->vbox, &[[req]]); #endif gtk_window_resize(GTK_WINDOW(s->window), [[req]].width * sx, [[req]].height * sy); } }

[[[[Adv]]]]: static void gd_resize(DisplayChangeListener *dcl, DisplayState *ds) { GtkDisplayState *s = ds->opaque; cairo_format_t kind; int [[juncture]]; DPRINTF("resize(width=%d, height=%d)\n", ds_get_width(ds), ds_get_height(ds)); if (s->surface) { cairo_surface_destroy(s->surface); } switch (ds->surface->pf.bits_per_pixel) { case 8: kind = CAIRO_FORMAT_A8; break; case 16: kind = CAIRO_FORMAT_RGB16_565; break; case 32: kind = CAIRO_FORMAT_RGB24; break; default: g_assert_not_reached(); break; } [[juncture]] = cairo_format_stride_for_width(kind, ds_get_width(ds)); g_assert(ds_get_linesize(ds) == [[juncture]]); s->surface = cairo_image_surface_create_for_data(ds_get_data(ds), kind, ds_get_width(ds), ds_get_height(ds), ds_get_linesize(ds)); if (!s->full_screen) { GtkRequisition [[eval]]; double sx, sy; if (s->free_scale) { sx = s->scale_x; sy = s->scale_y; s->scale_y = 1.0; s->scale_x = 1.0; } else { sx = 1.0; sy = 1.0; } gtk_widget_set_size_request(s->drawing_area, ds_get_width(ds) * s->scale_x, ds_get_height(ds) * s->scale_y); #if GTK_CHECK_VERSION(3, 0, 0) gtk_widget_get_preferred_size(s->vbox, NULL, &[[eval]]); #else gtk_widget_size_request(s->vbox, &[[eval]]); #endif gtk_window_resize(GTK_WINDOW(s->window), [[eval]].width * sx, [[eval]].height * sy); } }
--------------------------------------------- Result 1078 ---------------------------------------------
[[0 (64%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: send_msg( VSCMsgType type, uint32_t reader_id, const void *msg, unsigned int length ) { VSCMsgHeader mhHeader; qemu_mutex_lock(&socket_to_send_lock); if (verbose > 10) { printf("sending type=%d id=%u, len =%u (0x%x)\n", type, reader_id, length, length); } mhHeader.type = htonl(type); mhHeader.reader_id = 0; mhHeader.length = htonl(length); g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader)); g_byte_array_append(socket_to_send, (guint8 *)msg, length); g_idle_add(socket_prepare_sending, NULL); qemu_mutex_unlock(&socket_to_send_lock); return 0; }
--------------------------------------------- Result 1079 ---------------------------------------------
[[0 (40%)]] --> [[0 (52%)]] --> Socre: 0.52103191614151

[[[[Adv]]]]: void FUNCC(ff_h264_idct_dc_add)(uint8_t *[[_dst]], int16_t *block, int stride){ int i, j; int dc = (((dctcoef*)block)[0] + 32) >> 6; pixel *dst = (pixel*)[[_dst]]; stride >>= sizeof(pixel)-1; for( j = 0; j < 4; j++ ) { for( i = 0; i < 4; i++ ) dst[i] = av_clip_pixel( dst[i] + dc ); dst += stride; } }

[[[[Adv]]]]: void FUNCC(ff_h264_idct_dc_add)(uint8_t *[[thailand]], int16_t *block, int stride){ int i, j; int dc = (((dctcoef*)block)[0] + 32) >> 6; pixel *dst = (pixel*)[[thailand]]; stride >>= sizeof(pixel)-1; for( j = 0; j < 4; j++ ) { for( i = 0; i < 4; i++ ) dst[i] = av_clip_pixel( dst[i] + dc ); dst += stride; } }
--------------------------------------------- Result 1080 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 629 / 58 / 393 / 1080:  40%|      | 1080/2690 [12:22:23<18:26:43, 41.24s/it][Succeeded / Failed / Skipped / Total] 629 / 58 / 393 / 1080:  40%|      | 1081/2690 [12:22:24<18:25:01, 41.21s/it][Succeeded / Failed / Skipped / Total] 629 / 58 / 394 / 1081:  40%|      | 1081/2690 [12:22:24<18:25:01, 41.21s/it][Succeeded / Failed / Skipped / Total] 629 / 58 / 394 / 1081:  40%|      | 1082/2690 [12:23:24<18:24:48, 41.22s/it][[0 (41%)]] --> [[0 (63%)]] --> Socre: 0.6265907287597656

[[[[Adv]]]]: static int encode_picture_ls(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *[[pict]], int *got_packet) { const AVFrame *const p = [[pict]]; const int near = avctx->prediction_method; PutBitContext pb, pb2; GetBitContext gb; uint8_t *buf2 = NULL; uint8_t *zero = NULL; uint8_t *cur = NULL; uint8_t *last = NULL; JLSState *state; int i, size, ret; int comps; if (avctx->pix_fmt == AV_PIX_FMT_GRAY8 || avctx->pix_fmt == AV_PIX_FMT_GRAY16) comps = 1; else comps = 3; if ((ret = ff_alloc_packet(pkt, avctx->width * avctx->height * comps * 4 + AV_INPUT_BUFFER_MIN_SIZE)) < 0) { av_log(avctx, AV_LOG_ERROR, "Error getting output packet.\n"); return ret; } buf2 = av_malloc(pkt->size); if (!buf2) goto memfail; init_put_bits(&pb, pkt->data, pkt->size); init_put_bits(&pb2, buf2, pkt->size); put_marker(&pb, SOI); put_marker(&pb, SOF48); put_bits(&pb, 16, 8 + comps * 3); put_bits(&pb, 8, (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8); put_bits(&pb, 16, avctx->height); put_bits(&pb, 16, avctx->width); put_bits(&pb, 8, comps); for (i = 1; i <= comps; i++) { put_bits(&pb, 8, i); put_bits(&pb, 8, 0x11); put_bits(&pb, 8, 0); } put_marker(&pb, SOS); put_bits(&pb, 16, 6 + comps * 2); put_bits(&pb, 8, comps); for (i = 1; i <= comps; i++) { put_bits(&pb, 8, i); put_bits(&pb, 8, 0); } put_bits(&pb, 8, near); put_bits(&pb, 8, (comps > 1) ? 1 : 0); put_bits(&pb, 8, 0); state = av_mallocz(sizeof(JLSState)); if (!state) goto memfail; state->near = near; state->bpp = (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8; ff_jpegls_reset_coding_parameters(state, 0); ff_jpegls_init_state(state); ls_store_lse(state, &pb); zero = last = av_mallocz(p->linesize[0]); if (!zero) goto memfail; cur = p->data[0]; if (avctx->pix_fmt == AV_PIX_FMT_GRAY8) { int t = 0; for (i = 0; i < avctx->height; i++) { ls_encode_line(state, &pb2, last, cur, t, avctx->width, 1, 0, 8); t = last[0]; last = cur; cur += p->linesize[0]; } } else if (avctx->pix_fmt == AV_PIX_FMT_GRAY16) { int t = 0; for (i = 0; i < avctx->height; i++) { ls_encode_line(state, &pb2, last, cur, t, avctx->width, 1, 0, 16); t = *((uint16_t *)last); last = cur; cur += p->linesize[0]; } } else if (avctx->pix_fmt == AV_PIX_FMT_RGB24) { int j, width; int Rc[3] = { 0, 0, 0 }; width = avctx->width * 3; for (i = 0; i < avctx->height; i++) { for (j = 0; j < 3; j++) { ls_encode_line(state, &pb2, last + j, cur + j, Rc[j], width, 3, j, 8); Rc[j] = last[j]; } last = cur; cur += p->linesize[0]; } } else if (avctx->pix_fmt == AV_PIX_FMT_BGR24) { int j, width; int Rc[3] = { 0, 0, 0 }; width = avctx->width * 3; for (i = 0; i < avctx->height; i++) { for (j = 2; j >= 0; j--) { ls_encode_line(state, &pb2, last + j, cur + j, Rc[j], width, 3, j, 8); Rc[j] = last[j]; } last = cur; cur += p->linesize[0]; } } av_freep(&zero); av_freep(&state); put_bits(&pb2, 7, 0); size = put_bits_count(&pb2); flush_put_bits(&pb2); init_get_bits(&gb, buf2, size); size -= 7; while (get_bits_count(&gb) < size) { int v; v = get_bits(&gb, 8); put_bits(&pb, 8, v); if (v == 0xFF) { v = get_bits(&gb, 7); put_bits(&pb, 8, v); } } avpriv_align_put_bits(&pb); av_freep(&buf2); put_marker(&pb, EOI); flush_put_bits(&pb); emms_c(); pkt->size = put_bits_count(&pb) >> 3; pkt->flags |= AV_PKT_FLAG_KEY; *got_packet = 1; return 0; memfail: av_packet_unref(pkt); av_freep(&buf2); av_freep(&state); av_freep(&zero); return AVERROR(ENOMEM); }

[[[[Adv]]]]: static int encode_picture_ls(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *[[razo]], int *got_packet) { const AVFrame *const p = [[razo]]; const int near = avctx->prediction_method; PutBitContext pb, pb2; GetBitContext gb; uint8_t *buf2 = NULL; uint8_t *zero = NULL; uint8_t *cur = NULL; uint8_t *last = NULL; JLSState *state; int i, size, ret; int comps; if (avctx->pix_fmt == AV_PIX_FMT_GRAY8 || avctx->pix_fmt == AV_PIX_FMT_GRAY16) comps = 1; else comps = 3; if ((ret = ff_alloc_packet(pkt, avctx->width * avctx->height * comps * 4 + AV_INPUT_BUFFER_MIN_SIZE)) < 0) { av_log(avctx, AV_LOG_ERROR, "Error getting output packet.\n"); return ret; } buf2 = av_malloc(pkt->size); if (!buf2) goto memfail; init_put_bits(&pb, pkt->data, pkt->size); init_put_bits(&pb2, buf2, pkt->size); put_marker(&pb, SOI); put_marker(&pb, SOF48); put_bits(&pb, 16, 8 + comps * 3); put_bits(&pb, 8, (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8); put_bits(&pb, 16, avctx->height); put_bits(&pb, 16, avctx->width); put_bits(&pb, 8, comps); for (i = 1; i <= comps; i++) { put_bits(&pb, 8, i); put_bits(&pb, 8, 0x11); put_bits(&pb, 8, 0); } put_marker(&pb, SOS); put_bits(&pb, 16, 6 + comps * 2); put_bits(&pb, 8, comps); for (i = 1; i <= comps; i++) { put_bits(&pb, 8, i); put_bits(&pb, 8, 0); } put_bits(&pb, 8, near); put_bits(&pb, 8, (comps > 1) ? 1 : 0); put_bits(&pb, 8, 0); state = av_mallocz(sizeof(JLSState)); if (!state) goto memfail; state->near = near; state->bpp = (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8; ff_jpegls_reset_coding_parameters(state, 0); ff_jpegls_init_state(state); ls_store_lse(state, &pb); zero = last = av_mallocz(p->linesize[0]); if (!zero) goto memfail; cur = p->data[0]; if (avctx->pix_fmt == AV_PIX_FMT_GRAY8) { int t = 0; for (i = 0; i < avctx->height; i++) { ls_encode_line(state, &pb2, last, cur, t, avctx->width, 1, 0, 8); t = last[0]; last = cur; cur += p->linesize[0]; } } else if (avctx->pix_fmt == AV_PIX_FMT_GRAY16) { int t = 0; for (i = 0; i < avctx->height; i++) { ls_encode_line(state, &pb2, last, cur, t, avctx->width, 1, 0, 16); t = *((uint16_t *)last); last = cur; cur += p->linesize[0]; } } else if (avctx->pix_fmt == AV_PIX_FMT_RGB24) { int j, width; int Rc[3] = { 0, 0, 0 }; width = avctx->width * 3; for (i = 0; i < avctx->height; i++) { for (j = 0; j < 3; j++) { ls_encode_line(state, &pb2, last + j, cur + j, Rc[j], width, 3, j, 8); Rc[j] = last[j]; } last = cur; cur += p->linesize[0]; } } else if (avctx->pix_fmt == AV_PIX_FMT_BGR24) { int j, width; int Rc[3] = { 0, 0, 0 }; width = avctx->width * 3; for (i = 0; i < avctx->height; i++) { for (j = 2; j >= 0; j--) { ls_encode_line(state, &pb2, last + j, cur + j, Rc[j], width, 3, j, 8); Rc[j] = last[j]; } last = cur; cur += p->linesize[0]; } } av_freep(&zero); av_freep(&state); put_bits(&pb2, 7, 0); size = put_bits_count(&pb2); flush_put_bits(&pb2); init_get_bits(&gb, buf2, size); size -= 7; while (get_bits_count(&gb) < size) { int v; v = get_bits(&gb, 8); put_bits(&pb, 8, v); if (v == 0xFF) { v = get_bits(&gb, 7); put_bits(&pb, 8, v); } } avpriv_align_put_bits(&pb); av_freep(&buf2); put_marker(&pb, EOI); flush_put_bits(&pb); emms_c(); pkt->size = put_bits_count(&pb) >> 3; pkt->flags |= AV_PKT_FLAG_KEY; *got_packet = 1; return 0; memfail: av_packet_unref(pkt); av_freep(&buf2); av_freep(&state); av_freep(&zero); return AVERROR(ENOMEM); }
--------------------------------------------- Result 1081 ---------------------------------------------
[[0 (100%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_vc1_decode_blocks(VC1Context *v) { v->s.esc3_level_length = 0; if (v->x8_type) { ff_intrax8_decode_picture(&v->x8, 2*v->pq + v->halfpq, v->pq * !v->pquantizer); ff_er_add_slice(&v->s.er, 0, 0, (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1, ER_MB_END); } else { v->cur_blk_idx = 0; v->left_blk_idx = -1; v->topleft_blk_idx = 1; v->top_blk_idx = 2; switch (v->s.pict_type) { case AV_PICTURE_TYPE_I: if (v->profile == PROFILE_ADVANCED) vc1_decode_i_blocks_adv(v); else vc1_decode_i_blocks(v); break; case AV_PICTURE_TYPE_P: if (v->p_frame_skipped) vc1_decode_skip_blocks(v); else vc1_decode_p_blocks(v); break; case AV_PICTURE_TYPE_B: if (v->bi_type) { if (v->profile == PROFILE_ADVANCED) vc1_decode_i_blocks_adv(v); else vc1_decode_i_blocks(v); } else vc1_decode_b_blocks(v); break; } } }
--------------------------------------------- Result 1082 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 630 / 58 / 394 / 1082:  40%|      | 1082/2690 [12:23:24<18:24:48, 41.22s/it][Succeeded / Failed / Skipped / Total] 630 / 58 / 394 / 1082:  40%|      | 1083/2690 [12:31:21<18:34:53, 41.63s/it][Succeeded / Failed / Skipped / Total] 631 / 58 / 394 / 1083:  40%|      | 1083/2690 [12:31:21<18:34:53, 41.63s/it][Succeeded / Failed / Skipped / Total] 631 / 58 / 394 / 1083:  40%|      | 1084/2690 [12:31:22<18:33:12, 41.59s/it][Succeeded / Failed / Skipped / Total] 632 / 58 / 394 / 1084:  40%|      | 1084/2690 [12:31:22<18:33:12, 41.59s/it][Succeeded / Failed / Skipped / Total] 632 / 58 / 394 / 1084:  40%|      | 1085/2690 [12:31:23<18:31:29, 41.55s/it][Succeeded / Failed / Skipped / Total] 632 / 58 / 395 / 1085:  40%|      | 1085/2690 [12:31:23<18:31:29, 41.55s/it][Succeeded / Failed / Skipped / Total] 632 / 58 / 395 / 1085:  40%|      | 1086/2690 [12:31:26<18:29:51, 41.52s/it][[0 (89%)]] --> [[0 (48%)]] --> Socre: 0.5215142667293549

[[[[Adv]]]]: int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int [[slen]], uint8_t *dst, int dlen) { uint32_t zrun_len = 0, nzrun_len = 0; int d = 0, i = 0; long res, xor; uint8_t *nzrun_start = NULL; g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | [[slen]]) % sizeof(long))); while (i < [[slen]]) { if (d + 2 > dlen) { return -1; } res = ([[slen]] - i) % sizeof(long); while (res && old_buf[i] == new_buf[i]) { zrun_len++; i++; res--; } if (!res) { while (i < [[slen]] && (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) { i += sizeof(long); zrun_len += sizeof(long); } while (i < [[slen]] && old_buf[i] == new_buf[i]) { zrun_len++; i++; } } if (zrun_len == [[slen]]) { return 0; } if (i == [[slen]]) { return d; } d += uleb128_encode_small(dst + d, zrun_len); zrun_len = 0; nzrun_start = new_buf + i; if (d + 2 > dlen) { return -1; } res = ([[slen]] - i) % sizeof(long); while (res && old_buf[i] != new_buf[i]) { i++; nzrun_len++; res--; } if (!res) { long mask = (long)0x0101010101010101ULL; while (i < [[slen]]) { xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i); if ((xor - mask) & ~xor & (mask << 7)) { while (old_buf[i] != new_buf[i]) { nzrun_len++; i++; } break; } else { i += sizeof(long); nzrun_len += sizeof(long); } } } d += uleb128_encode_small(dst + d, nzrun_len); if (d + nzrun_len > dlen) { return -1; } memcpy(dst + d, nzrun_start, nzrun_len); d += nzrun_len; nzrun_len = 0; } return d; }

[[[[Adv]]]]: int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int [[loosens]], uint8_t *dst, int dlen) { uint32_t zrun_len = 0, nzrun_len = 0; int d = 0, i = 0; long res, xor; uint8_t *nzrun_start = NULL; g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | [[loosens]]) % sizeof(long))); while (i < [[loosens]]) { if (d + 2 > dlen) { return -1; } res = ([[loosens]] - i) % sizeof(long); while (res && old_buf[i] == new_buf[i]) { zrun_len++; i++; res--; } if (!res) { while (i < [[loosens]] && (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) { i += sizeof(long); zrun_len += sizeof(long); } while (i < [[loosens]] && old_buf[i] == new_buf[i]) { zrun_len++; i++; } } if (zrun_len == [[loosens]]) { return 0; } if (i == [[loosens]]) { return d; } d += uleb128_encode_small(dst + d, zrun_len); zrun_len = 0; nzrun_start = new_buf + i; if (d + 2 > dlen) { return -1; } res = ([[loosens]] - i) % sizeof(long); while (res && old_buf[i] != new_buf[i]) { i++; nzrun_len++; res--; } if (!res) { long mask = (long)0x0101010101010101ULL; while (i < [[loosens]]) { xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i); if ((xor - mask) & ~xor & (mask << 7)) { while (old_buf[i] != new_buf[i]) { nzrun_len++; i++; } break; } else { i += sizeof(long); nzrun_len += sizeof(long); } } } d += uleb128_encode_small(dst + d, nzrun_len); if (d + nzrun_len > dlen) { return -1; } memcpy(dst + d, nzrun_start, nzrun_len); d += nzrun_len; nzrun_len = 0; } return d; }
--------------------------------------------- Result 1083 ---------------------------------------------
[[0 (98%)]] --> [[0 (50%)]] --> Socre: 0.500744491815567

[[[[Adv]]]]: paint_mouse_pointer(XImage *image, struct x11_grab *[[s]]) { int x_off = [[s]]->x_off; int y_off = [[s]]->y_off; int width = [[s]]->width; int height = [[s]]->height; Display *dpy = [[s]]->dpy; XFixesCursorImage *[[xcim]]; int x, y; int line, column; int to_line, to_column; int image_addr, xcim_addr; [[xcim]] = XFixesGetCursorImage(dpy); x = [[xcim]]->x - [[xcim]]->xhot; y = [[xcim]]->y - [[xcim]]->yhot; to_line = FFMIN((y + [[xcim]]->height), (height + y_off)); to_column = FFMIN((x + [[xcim]]->width), (width + x_off)); for (line = FFMAX(y, y_off); line < to_line; line++) { for (column = FFMAX(x, x_off); column < to_column; column++) { xcim_addr = (line - y) * [[xcim]]->width + column - x; if ((unsigned char)([[xcim]]->pixels[xcim_addr] >> 24) != 0) { image_addr = ((line - y_off) * width + column - x_off) * 4; image->data[image_addr] = (unsigned char)([[xcim]]->pixels[xcim_addr] >> 0); image->data[image_addr+1] = (unsigned char)([[xcim]]->pixels[xcim_addr] >> 8); image->data[image_addr+2] = (unsigned char)([[xcim]]->pixels[xcim_addr] >> 16); } } } XFree([[xcim]]); [[xcim]] = NULL; }

[[[[Adv]]]]: paint_mouse_pointer(XImage *image, struct x11_grab *[[among]]) { int x_off = [[among]]->x_off; int y_off = [[among]]->y_off; int width = [[among]]->width; int height = [[among]]->height; Display *dpy = [[among]]->dpy; XFixesCursorImage *[[shades]]; int x, y; int line, column; int to_line, to_column; int image_addr, xcim_addr; [[shades]] = XFixesGetCursorImage(dpy); x = [[shades]]->x - [[shades]]->xhot; y = [[shades]]->y - [[shades]]->yhot; to_line = FFMIN((y + [[shades]]->height), (height + y_off)); to_column = FFMIN((x + [[shades]]->width), (width + x_off)); for (line = FFMAX(y, y_off); line < to_line; line++) { for (column = FFMAX(x, x_off); column < to_column; column++) { xcim_addr = (line - y) * [[shades]]->width + column - x; if ((unsigned char)([[shades]]->pixels[xcim_addr] >> 24) != 0) { image_addr = ((line - y_off) * width + column - x_off) * 4; image->data[image_addr] = (unsigned char)([[shades]]->pixels[xcim_addr] >> 0); image->data[image_addr+1] = (unsigned char)([[shades]]->pixels[xcim_addr] >> 8); image->data[image_addr+2] = (unsigned char)([[shades]]->pixels[xcim_addr] >> 16); } } } XFree([[shades]]); [[shades]] = NULL; }
--------------------------------------------- Result 1084 ---------------------------------------------
[[0 (27%)]] --> [[0 (68%)]] --> Socre: 0.6843432188034058

[[[[Adv]]]]: int avfilter_register(AVFilter *[[filter]]) { if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB) return -1; registered_avfilters[next_registered_avfilter_idx++] = [[filter]]; return 0; }

[[[[Adv]]]]: int avfilter_register(AVFilter *[[cleansing]]) { if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB) return -1; registered_avfilters[next_registered_avfilter_idx++] = [[cleansing]]; return 0; }
--------------------------------------------- Result 1085 ---------------------------------------------
[[0 (29%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qmp_migrate_cancel(Error **errp) { migrate_fd_cancel(migrate_get_current()); }
--------------------------------------------- Result 1086 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 632 / 59 / 395 / 1086:  40%|      | 1086/2690 [12:31:26<18:29:51, 41.52s/it][Succeeded / Failed / Skipped / Total] 632 / 59 / 395 / 1086:  40%|      | 1087/2690 [12:32:53<18:30:16, 41.56s/it][Succeeded / Failed / Skipped / Total] 633 / 59 / 395 / 1087:  40%|      | 1087/2690 [12:32:53<18:30:16, 41.56s/it][Succeeded / Failed / Skipped / Total] 633 / 59 / 395 / 1087:  40%|      | 1088/2690 [12:32:53<18:28:35, 41.52s/it][[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int decode_pic_hdr(IVI5DecContext *ctx, AVCodecContext *avctx) { if (get_bits(&ctx->gb, 5) != 0x1F) { av_log(avctx, AV_LOG_ERROR, "Invalid picture start code!\n"); return -1; ctx->prev_frame_type = ctx->frame_type; ctx->frame_type = get_bits(&ctx->gb, 3); if (ctx->frame_type >= 5) { av_log(avctx, AV_LOG_ERROR, "Invalid frame type: %d \n", ctx->frame_type); return -1; ctx->frame_num = get_bits(&ctx->gb, 8); if (ctx->frame_type == FRAMETYPE_INTRA) { ctx->gop_invalid = 1; if (decode_gop_header(ctx, avctx)) return -1; ctx->gop_invalid = 0; if (ctx->frame_type != FRAMETYPE_NULL) { ctx->frame_flags = get_bits(&ctx->gb, 8); ctx->pic_hdr_size = (ctx->frame_flags & 1) ? get_bits_long(&ctx->gb, 24) : 0; ctx->checksum = (ctx->frame_flags & 0x10) ? get_bits(&ctx->gb, 16) : 0; if (ctx->frame_flags & 0x20) skip_hdr_extension(&ctx->gb); if (ff_ivi_dec_huff_desc(&ctx->gb, ctx->frame_flags & 0x40, IVI_MB_HUFF, &ctx->mb_vlc, avctx)) return -1; skip_bits(&ctx->gb, 3); align_get_bits(&ctx->gb); return 0;

[[[[Adv]]]]: static int decode_pic_hdr(IVI5DecContext *ctx, AVCodecContext *avctx) { if (get_bits(&ctx->gb, 5) != 0x1F) { av_log(avctx, AV_LOG_ERROR, "Invalid picture start code!\n"); return -1; ctx->prev_frame_type = ctx->frame_type; ctx->frame_type = get_bits(&ctx->gb, 3); if (ctx->frame_type >= 5) { av_log(avctx, AV_LOG_ERROR, "Invalid frame type: %d \n", ctx->frame_type); return -1; ctx->frame_num = get_bits(&ctx->gb, 8); if (ctx->frame_type == FRAMETYPE_INTRA) { ctx->gop_invalid = 1; if (decode_gop_header(ctx, avctx)) return -1; ctx->gop_invalid = 0; if (ctx->frame_type != FRAMETYPE_NULL) { ctx->frame_flags = get_bits(&ctx->gb, 8); ctx->pic_hdr_size = (ctx->frame_flags & 1) ? get_bits_long(&ctx->gb, 24) : 0; ctx->checksum = (ctx->frame_flags & 0x10) ? get_bits(&ctx->gb, 16) : 0; if (ctx->frame_flags & 0x20) skip_hdr_extension(&ctx->gb); if (ff_ivi_dec_huff_desc(&ctx->gb, ctx->frame_flags & 0x40, IVI_MB_HUFF, &ctx->mb_vlc, avctx)) return -1; skip_bits(&ctx->gb, 3); align_get_bits(&ctx->gb); return 0;
--------------------------------------------- Result 1087 ---------------------------------------------
[[0 (63%)]] --> [[0 (42%)]] --> Socre: 0.5837510824203491

[[[[Adv]]]]: int load_snapshot(const char *name, Error **errp) { BlockDriverState *[[bs]], *bs_vm_state; QEMUSnapshotInfo sn; QEMUFile *f; int [[ret]]; AioContext *aio_context; MigrationIncomingState *mis = migration_incoming_get_current(); if (!bdrv_all_can_snapshot(&[[bs]])) { error_setg(errp, "Device '%s' is writable but does not support snapshots", bdrv_get_device_name([[bs]])); return -ENOTSUP; } [[ret]] = bdrv_all_find_snapshot(name, &[[bs]]); if ([[ret]] < 0) { error_setg(errp, "Device '%s' does not have the requested snapshot '%s'", bdrv_get_device_name([[bs]]), name); return [[ret]]; } bs_vm_state = bdrv_all_find_vmstate_bs(); if (!bs_vm_state) { error_setg(errp, "No block device supports snapshots"); return -ENOTSUP; } aio_context = bdrv_get_aio_context(bs_vm_state); aio_context_acquire(aio_context); [[ret]] = bdrv_snapshot_find(bs_vm_state, &sn, name); aio_context_release(aio_context); if ([[ret]] < 0) { return [[ret]]; } else if (sn.vm_state_size == 0) { error_setg(errp, "This is a disk-only snapshot. Revert to it " " offline using qemu-img"); return -EINVAL; } bdrv_drain_all(); [[ret]] = bdrv_all_goto_snapshot(name, &[[bs]]); if ([[ret]] < 0) { error_setg(errp, "Error %d while activating snapshot '%s' on '%s'", [[ret]], name, bdrv_get_device_name([[bs]])); return [[ret]]; } f = qemu_fopen_bdrv(bs_vm_state, 0); if (!f) { error_setg(errp, "Could not open VM state file"); return -EINVAL; } qemu_system_reset(SHUTDOWN_CAUSE_NONE); mis->from_src_file = f; aio_context_acquire(aio_context); [[ret]] = qemu_loadvm_state(f); qemu_fclose(f); aio_context_release(aio_context); migration_incoming_state_destroy(); if ([[ret]] < 0) { error_setg(errp, "Error %d while loading VM state", [[ret]]); return [[ret]]; } return 0; }

[[[[Adv]]]]: int load_snapshot(const char *name, Error **errp) { BlockDriverState *[[majoring]], *bs_vm_state; QEMUSnapshotInfo sn; QEMUFile *f; int [[annuity]]; AioContext *aio_context; MigrationIncomingState *mis = migration_incoming_get_current(); if (!bdrv_all_can_snapshot(&[[majoring]])) { error_setg(errp, "Device '%s' is writable but does not support snapshots", bdrv_get_device_name([[majoring]])); return -ENOTSUP; } [[annuity]] = bdrv_all_find_snapshot(name, &[[majoring]]); if ([[annuity]] < 0) { error_setg(errp, "Device '%s' does not have the requested snapshot '%s'", bdrv_get_device_name([[majoring]]), name); return [[annuity]]; } bs_vm_state = bdrv_all_find_vmstate_bs(); if (!bs_vm_state) { error_setg(errp, "No block device supports snapshots"); return -ENOTSUP; } aio_context = bdrv_get_aio_context(bs_vm_state); aio_context_acquire(aio_context); [[annuity]] = bdrv_snapshot_find(bs_vm_state, &sn, name); aio_context_release(aio_context); if ([[annuity]] < 0) { return [[annuity]]; } else if (sn.vm_state_size == 0) { error_setg(errp, "This is a disk-only snapshot. Revert to it " " offline using qemu-img"); return -EINVAL; } bdrv_drain_all(); [[annuity]] = bdrv_all_goto_snapshot(name, &[[majoring]]); if ([[annuity]] < 0) { error_setg(errp, "Error %d while activating snapshot '%s' on '%s'", [[annuity]], name, bdrv_get_device_name([[majoring]])); return [[annuity]]; } f = qemu_fopen_bdrv(bs_vm_state, 0); if (!f) { error_setg(errp, "Could not open VM state file"); return -EINVAL; } qemu_system_reset(SHUTDOWN_CAUSE_NONE); mis->from_src_file = f; aio_context_acquire(aio_context); [[annuity]] = qemu_loadvm_state(f); qemu_fclose(f); aio_context_release(aio_context); migration_incoming_state_destroy(); if ([[annuity]] < 0) { error_setg(errp, "Error %d while loading VM state", [[annuity]]); return [[annuity]]; } return 0; }
--------------------------------------------- Result 1088 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 633 / 59 / 396 / 1088:  40%|      | 1088/2690 [12:32:53<18:28:35, 41.52s/it][Succeeded / Failed / Skipped / Total] 633 / 59 / 396 / 1088:  40%|      | 1089/2690 [12:32:54<18:26:53, 41.48s/it][Succeeded / Failed / Skipped / Total] 633 / 59 / 397 / 1089:  40%|      | 1089/2690 [12:32:54<18:26:53, 41.48s/it][Succeeded / Failed / Skipped / Total] 633 / 59 / 397 / 1089:  41%|      | 1090/2690 [12:32:54<18:25:11, 41.44s/it][Succeeded / Failed / Skipped / Total] 633 / 59 / 398 / 1090:  41%|      | 1090/2690 [12:32:54<18:25:11, 41.44s/it][Succeeded / Failed / Skipped / Total] 633 / 59 / 398 / 1090:  41%|      | 1091/2690 [12:33:03<18:23:41, 41.41s/it][Succeeded / Failed / Skipped / Total] 634 / 59 / 398 / 1091:  41%|      | 1091/2690 [12:33:03<18:23:41, 41.41s/it][Succeeded / Failed / Skipped / Total] 634 / 59 / 398 / 1091:  41%|      | 1092/2690 [12:33:11<18:22:11, 41.38s/it][Succeeded / Failed / Skipped / Total] 635 / 59 / 398 / 1092:  41%|      | 1092/2690 [12:33:11<18:22:11, 41.38s/it][Succeeded / Failed / Skipped / Total] 635 / 59 / 398 / 1092:  41%|      | 1093/2690 [12:33:19<18:20:42, 41.35s/it][[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mov_text_tx3g(AVCodecContext *avctx, MovTextContext *m) { char *tx3g_ptr = avctx->extradata; int i, box_size, font_length; int8_t v_align, h_align; int style_fontID; StyleBox s_default; m->count_f = 0; m->ftab_entries = 0; box_size = BOX_SIZE_INITIAL; if (avctx->extradata_size < box_size) return -1; tx3g_ptr += 4; h_align = *tx3g_ptr++; v_align = *tx3g_ptr++; if (h_align == 0) { if (v_align == 0) m->d.alignment = TOP_LEFT; if (v_align == 1) m->d.alignment = MIDDLE_LEFT; if (v_align == -1) m->d.alignment = BOTTOM_LEFT; } if (h_align == 1) { if (v_align == 0) m->d.alignment = TOP_CENTER; if (v_align == 1) m->d.alignment = MIDDLE_CENTER; if (v_align == -1) m->d.alignment = BOTTOM_CENTER; } if (h_align == -1) { if (v_align == 0) m->d.alignment = TOP_RIGHT; if (v_align == 1) m->d.alignment = MIDDLE_RIGHT; if (v_align == -1) m->d.alignment = BOTTOM_RIGHT; } m->d.back_color = AV_RB24(tx3g_ptr); tx3g_ptr += 4; tx3g_ptr += 8; tx3g_ptr += 4; style_fontID = AV_RB16(tx3g_ptr); tx3g_ptr += 2; s_default.style_flag = *tx3g_ptr++; m->d.bold = s_default.style_flag & STYLE_FLAG_BOLD; m->d.italic = s_default.style_flag & STYLE_FLAG_ITALIC; m->d.underline = s_default.style_flag & STYLE_FLAG_UNDERLINE; m->d.fontsize = *tx3g_ptr++; m->d.color = AV_RB24(tx3g_ptr); tx3g_ptr += 4; tx3g_ptr += 4; tx3g_ptr += 4; m->ftab_entries = AV_RB16(tx3g_ptr); tx3g_ptr += 2; for (i = 0; i < m->ftab_entries; i++) { box_size += 3; if (avctx->extradata_size < box_size) { mov_text_cleanup_ftab(m); m->ftab_entries = 0; return -1; } m->ftab_temp = av_malloc(sizeof(*m->ftab_temp)); if (!m->ftab_temp) { mov_text_cleanup_ftab(m); return AVERROR(ENOMEM); } m->ftab_temp->fontID = AV_RB16(tx3g_ptr); tx3g_ptr += 2; font_length = *tx3g_ptr++; box_size = box_size + font_length; if (avctx->extradata_size < box_size) { mov_text_cleanup_ftab(m); m->ftab_entries = 0; return -1; } m->ftab_temp->font = av_malloc(font_length + 1); if (!m->ftab_temp->font) { mov_text_cleanup_ftab(m); return AVERROR(ENOMEM); } memcpy(m->ftab_temp->font, tx3g_ptr, font_length); m->ftab_temp->font[font_length] = '\0'; av_dynarray_add(&m->ftab, &m->count_f, m->ftab_temp); if (!m->ftab) { mov_text_cleanup_ftab(m); return AVERROR(ENOMEM); } tx3g_ptr = tx3g_ptr + font_length; } for (i = 0; i < m->ftab_entries; i++) { if (style_fontID == m->ftab[i]->fontID) m->d.font = m->ftab[i]->font; } return 0; }
--------------------------------------------- Result 1089 ---------------------------------------------
[[0 (44%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void msmouse_chr_close (struct CharDriverState *chr) { MouseState *mouse = chr->opaque; qemu_input_handler_unregister(mouse->hs); g_free(mouse); g_free(chr); }
--------------------------------------------- Result 1090 ---------------------------------------------
[[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int qemu_init_main_loop(void) { int ret; ret = qemu_signal_init(); if (ret) { return ret; } qemu_init_sigbus(); return qemu_event_init(); }
--------------------------------------------- Result 1091 ---------------------------------------------
[[0 (77%)]] --> [[0 (39%)]] --> Socre: 0.6066407859325409

[[[[Adv]]]]: envlist_parse(envlist_t *envlist, const char *env, int (*callback)(envlist_t *, const char *)) { char *[[tmpenv]], *envvar; char *envsave = NULL; assert(callback != NULL); if ((envlist == NULL) || (env == NULL)) return (EINVAL); if (([[tmpenv]] = strdup(env)) == NULL) return (errno); envvar = strtok_r([[tmpenv]], ",", &envsave); while (envvar != NULL) { if ((*callback)(envlist, envvar) != 0) { free([[tmpenv]]); return (errno); } envvar = strtok_r(NULL, ",", &envsave); } free([[tmpenv]]); return (0); }

[[[[Adv]]]]: envlist_parse(envlist_t *envlist, const char *env, int (*callback)(envlist_t *, const char *)) { char *[[ornithology]], *envvar; char *envsave = NULL; assert(callback != NULL); if ((envlist == NULL) || (env == NULL)) return (EINVAL); if (([[ornithology]] = strdup(env)) == NULL) return (errno); envvar = strtok_r([[ornithology]], ",", &envsave); while (envvar != NULL) { if ((*callback)(envlist, envvar) != 0) { free([[ornithology]]); return (errno); } envvar = strtok_r(NULL, ",", &envsave); } free([[ornithology]]); return (0); }
--------------------------------------------- Result 1092 ---------------------------------------------
[[0 (45%)]] --> [[0 (87%)]] --> Socre: 0.8692712783813477

[[[[Adv]]]]: static int avi_write_packet(AVFormatContext *s, AVPacket *pkt) { unsigned char tag[5]; unsigned int flags = 0; const int stream_index = pkt->stream_index; int size = pkt->size; AVIContext *avi = s->priv_data; AVIOContext *pb = s->pb; AVIStream *[[avist]] = s->streams[stream_index]->priv_data; AVCodecParameters *par = s->streams[stream_index]->codecpar; while (par->block_align == 0 && pkt->dts != AV_NOPTS_VALUE && pkt->dts > [[avist]]->packet_count) { AVPacket empty_packet; av_init_packet(&empty_packet); empty_packet.size = 0; empty_packet.data = NULL; empty_packet.stream_index = stream_index; avi_write_packet(s, &empty_packet); } [[avist]]->packet_count++; if (pb->seekable && (avio_tell(pb) - avi->riff_start > AVI_MAX_RIFF_SIZE)) { avi_write_ix(s); ff_end_tag(pb, avi->movi_list); if (avi->riff_id == 1) avi_write_idx1(s); ff_end_tag(pb, avi->riff_start); avi->movi_list = avi_start_new_riff(s, pb, "AVIX", "movi"); } avi_stream2fourcc(tag, stream_index, par->codec_type); if (pkt->flags & AV_PKT_FLAG_KEY) flags = 0x10; if (par->codec_type == AVMEDIA_TYPE_AUDIO) [[avist]]->audio_strm_length += size; if (s->pb->seekable) { int err; AVIIndex *idx = &[[avist]]->indexes; int cl = idx->entry / AVI_INDEX_CLUSTER_SIZE; int id = idx->entry % AVI_INDEX_CLUSTER_SIZE; if (idx->ents_allocated <= idx->entry) { if ((err = av_reallocp(&idx->cluster, (cl + 1) * sizeof(*idx->cluster))) < 0) { idx->ents_allocated = 0; idx->entry = 0; return err; } idx->cluster[cl] = av_malloc(AVI_INDEX_CLUSTER_SIZE * sizeof(AVIIentry)); if (!idx->cluster[cl]) return -1; idx->ents_allocated += AVI_INDEX_CLUSTER_SIZE; } idx->cluster[cl][id].flags = flags; idx->cluster[cl][id].pos = avio_tell(pb) - avi->movi_list; idx->cluster[cl][id].len = size; idx->entry++; } avio_write(pb, tag, 4); avio_wl32(pb, size); avio_write(pb, pkt->data, size); if (size & 1) avio_w8(pb, 0); return 0; }

[[[[Adv]]]]: static int avi_write_packet(AVFormatContext *s, AVPacket *pkt) { unsigned char tag[5]; unsigned int flags = 0; const int stream_index = pkt->stream_index; int size = pkt->size; AVIContext *avi = s->priv_data; AVIOContext *pb = s->pb; AVIStream *[[logic]] = s->streams[stream_index]->priv_data; AVCodecParameters *par = s->streams[stream_index]->codecpar; while (par->block_align == 0 && pkt->dts != AV_NOPTS_VALUE && pkt->dts > [[logic]]->packet_count) { AVPacket empty_packet; av_init_packet(&empty_packet); empty_packet.size = 0; empty_packet.data = NULL; empty_packet.stream_index = stream_index; avi_write_packet(s, &empty_packet); } [[logic]]->packet_count++; if (pb->seekable && (avio_tell(pb) - avi->riff_start > AVI_MAX_RIFF_SIZE)) { avi_write_ix(s); ff_end_tag(pb, avi->movi_list); if (avi->riff_id == 1) avi_write_idx1(s); ff_end_tag(pb, avi->riff_start); avi->movi_list = avi_start_new_riff(s, pb, "AVIX", "movi"); } avi_stream2fourcc(tag, stream_index, par->codec_type); if (pkt->flags & AV_PKT_FLAG_KEY) flags = 0x10; if (par->codec_type == AVMEDIA_TYPE_AUDIO) [[logic]]->audio_strm_length += size; if (s->pb->seekable) { int err; AVIIndex *idx = &[[logic]]->indexes; int cl = idx->entry / AVI_INDEX_CLUSTER_SIZE; int id = idx->entry % AVI_INDEX_CLUSTER_SIZE; if (idx->ents_allocated <= idx->entry) { if ((err = av_reallocp(&idx->cluster, (cl + 1) * sizeof(*idx->cluster))) < 0) { idx->ents_allocated = 0; idx->entry = 0; return err; } idx->cluster[cl] = av_malloc(AVI_INDEX_CLUSTER_SIZE * sizeof(AVIIentry)); if (!idx->cluster[cl]) return -1; idx->ents_allocated += AVI_INDEX_CLUSTER_SIZE; } idx->cluster[cl][id].flags = flags; idx->cluster[cl][id].pos = avio_tell(pb) - avi->movi_list; idx->cluster[cl][id].len = size; idx->entry++; } avio_write(pb, tag, 4); avio_wl32(pb, size); avio_write(pb, pkt->data, size); if (size & 1) avio_w8(pb, 0); return 0; }
[Succeeded / Failed / Skipped / Total] 636 / 59 / 398 / 1093:  41%|      | 1093/2690 [12:33:19<18:20:42, 41.35s/it][Succeeded / Failed / Skipped / Total] 636 / 59 / 398 / 1093:  41%|      | 1094/2690 [12:33:27<18:19:11, 41.32s/it]--------------------------------------------- Result 1093 ---------------------------------------------
[[0 (12%)]] --> [[0 (53%)]] --> Socre: 0.5252678394317627

[[[[Adv]]]]: static av_noinline void emulated_edge_mc_sse(uint8_t *[[buf]], const uint8_t *src, ptrdiff_t [[buf_stride]], ptrdiff_t src_stride, int block_w, int block_h, int src_x, int [[src_y]], int w, int h) { emulated_edge_mc([[buf]], src, [[buf_stride]], src_stride, block_w, block_h, src_x, [[src_y]], w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse, hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext); }

[[[[Adv]]]]: static av_noinline void emulated_edge_mc_sse(uint8_t *[[grandiose]], const uint8_t *src, ptrdiff_t [[betroth]], ptrdiff_t src_stride, int block_w, int block_h, int src_x, int [[svenson]], int w, int h) { emulated_edge_mc([[grandiose]], src, [[betroth]], src_stride, block_w, block_h, src_x, [[svenson]], w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse, hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext); }
--------------------------------------------- Result 1094 ---------------------------------------------
[[0 (26%)]] --> [[0 (65%)]] --> Socre: 0.6462444067001343

[[[[Adv]]]]: static void show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, int in_program) { AVStream *stream = fmt_ctx->streams[stream_idx]; AVCodecContext *dec_ctx; const AVCodec *dec; char [[val_str]][128]; const char *s; AVRational sar, dar; AVBPrint pbuf; av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED); writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM); print_int("index", stream->index); if ((dec_ctx = stream->codec)) { const char *profile = NULL; dec = dec_ctx->codec; if (dec) { print_str("codec_name", dec->name); if (!do_bitexact) { if (dec->long_name) print_str ("codec_long_name", dec->long_name); else print_str_opt("codec_long_name", "unknown"); } } else { print_str_opt("codec_name", "unknown"); if (!do_bitexact) { print_str_opt("codec_long_name", "unknown"); } } if (dec && (profile = av_get_profile_name(dec, dec_ctx->profile))) print_str("profile", profile); else print_str_opt("profile", "unknown"); s = av_get_media_type_string(dec_ctx->codec_type); if (s) print_str ("codec_type", s); else print_str_opt("codec_type", "unknown"); print_q("codec_time_base", dec_ctx->time_base, '/'); av_get_codec_tag_string([[val_str]], sizeof([[val_str]]), dec_ctx->codec_tag); print_str("codec_tag_string", [[val_str]]); print_fmt("codec_tag", "0x%04x", dec_ctx->codec_tag); switch (dec_ctx->codec_type) { case AVMEDIA_TYPE_VIDEO: print_int("width", dec_ctx->width); print_int("height", dec_ctx->height); print_int("has_b_frames", dec_ctx->has_b_frames); sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL); if (sar.den) { print_q("sample_aspect_ratio", sar, ':'); av_reduce(&dar.num, &dar.den, dec_ctx->width * sar.num, dec_ctx->height * sar.den, 1024*1024); print_q("display_aspect_ratio", dar, ':'); } else { print_str_opt("sample_aspect_ratio", "N/A"); print_str_opt("display_aspect_ratio", "N/A"); } s = av_get_pix_fmt_name(dec_ctx->pix_fmt); if (s) print_str ("pix_fmt", s); else print_str_opt("pix_fmt", "unknown"); print_int("level", dec_ctx->level); if (dec_ctx->timecode_frame_start >= 0) { char tcbuf[AV_TIMECODE_STR_SIZE]; av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start); print_str("timecode", tcbuf); } else { print_str_opt("timecode", "N/A"); } break; case AVMEDIA_TYPE_AUDIO: s = av_get_sample_fmt_name(dec_ctx->sample_fmt); if (s) print_str ("sample_fmt", s); else print_str_opt("sample_fmt", "unknown"); print_val("sample_rate", dec_ctx->sample_rate, unit_hertz_str); print_int("channels", dec_ctx->channels); if (dec_ctx->channel_layout) { av_bprint_clear(&pbuf); av_bprint_channel_layout(&pbuf, dec_ctx->channels, dec_ctx->channel_layout); print_str ("channel_layout", pbuf.str); } else { print_str_opt("channel_layout", "unknown"); } print_int("bits_per_sample", av_get_bits_per_sample(dec_ctx->codec_id)); break; case AVMEDIA_TYPE_SUBTITLE: if (dec_ctx->width) print_int("width", dec_ctx->width); else print_str_opt("width", "N/A"); if (dec_ctx->height) print_int("height", dec_ctx->height); else print_str_opt("height", "N/A"); break; } } else { print_str_opt("codec_type", "unknown"); } if (dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) { const AVOption *opt = NULL; while (opt = av_opt_next(dec_ctx->priv_data,opt)) { uint8_t *str; if (opt->flags) continue; if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) { print_str(opt->name, str); av_free(str); } } } if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt ("id", "0x%x", stream->id); else print_str_opt("id", "N/A"); print_q("r_frame_rate", stream->r_frame_rate, '/'); print_q("avg_frame_rate", stream->avg_frame_rate, '/'); print_q("time_base", stream->time_base, '/'); print_ts ("start_pts", stream->start_time); print_time("start_time", stream->start_time, &stream->time_base); print_ts ("duration_ts", stream->duration); print_time("duration", stream->duration, &stream->time_base); if (dec_ctx->bit_rate > 0) print_val ("bit_rate", dec_ctx->bit_rate, unit_bit_per_second_str); else print_str_opt("bit_rate", "N/A"); if (stream->nb_frames) print_fmt ("nb_frames", "%"PRId64, stream->nb_frames); else print_str_opt("nb_frames", "N/A"); if (nb_streams_frames[stream_idx]) print_fmt ("nb_read_frames", "%"PRIu64, nb_streams_frames[stream_idx]); else print_str_opt("nb_read_frames", "N/A"); if (nb_streams_packets[stream_idx]) print_fmt ("nb_read_packets", "%"PRIu64, nb_streams_packets[stream_idx]); else print_str_opt("nb_read_packets", "N/A"); if (do_show_data) writer_print_data(w, "extradata", dec_ctx->extradata, dec_ctx->extradata_size); #define PRINT_DISPOSITION(flagname, name) do { \ print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \ } while (0) if (do_show_stream_disposition) { writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION); PRINT_DISPOSITION(DEFAULT, "default"); PRINT_DISPOSITION(DUB, "dub"); PRINT_DISPOSITION(ORIGINAL, "original"); PRINT_DISPOSITION(COMMENT, "comment"); PRINT_DISPOSITION(LYRICS, "lyrics"); PRINT_DISPOSITION(KARAOKE, "karaoke"); PRINT_DISPOSITION(FORCED, "forced"); PRINT_DISPOSITION(HEARING_IMPAIRED, "hearing_impaired"); PRINT_DISPOSITION(VISUAL_IMPAIRED, "visual_impaired"); PRINT_DISPOSITION(CLEAN_EFFECTS, "clean_effects"); PRINT_DISPOSITION(ATTACHED_PIC, "attached_pic"); writer_print_section_footer(w); } show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS); writer_print_section_footer(w); av_bprint_finalize(&pbuf, NULL); fflush(stdout); }

[[[[Adv]]]]: static void show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, int in_program) { AVStream *stream = fmt_ctx->streams[stream_idx]; AVCodecContext *dec_ctx; const AVCodec *dec; char [[apa]][128]; const char *s; AVRational sar, dar; AVBPrint pbuf; av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED); writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM); print_int("index", stream->index); if ((dec_ctx = stream->codec)) { const char *profile = NULL; dec = dec_ctx->codec; if (dec) { print_str("codec_name", dec->name); if (!do_bitexact) { if (dec->long_name) print_str ("codec_long_name", dec->long_name); else print_str_opt("codec_long_name", "unknown"); } } else { print_str_opt("codec_name", "unknown"); if (!do_bitexact) { print_str_opt("codec_long_name", "unknown"); } } if (dec && (profile = av_get_profile_name(dec, dec_ctx->profile))) print_str("profile", profile); else print_str_opt("profile", "unknown"); s = av_get_media_type_string(dec_ctx->codec_type); if (s) print_str ("codec_type", s); else print_str_opt("codec_type", "unknown"); print_q("codec_time_base", dec_ctx->time_base, '/'); av_get_codec_tag_string([[apa]], sizeof([[apa]]), dec_ctx->codec_tag); print_str("codec_tag_string", [[apa]]); print_fmt("codec_tag", "0x%04x", dec_ctx->codec_tag); switch (dec_ctx->codec_type) { case AVMEDIA_TYPE_VIDEO: print_int("width", dec_ctx->width); print_int("height", dec_ctx->height); print_int("has_b_frames", dec_ctx->has_b_frames); sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL); if (sar.den) { print_q("sample_aspect_ratio", sar, ':'); av_reduce(&dar.num, &dar.den, dec_ctx->width * sar.num, dec_ctx->height * sar.den, 1024*1024); print_q("display_aspect_ratio", dar, ':'); } else { print_str_opt("sample_aspect_ratio", "N/A"); print_str_opt("display_aspect_ratio", "N/A"); } s = av_get_pix_fmt_name(dec_ctx->pix_fmt); if (s) print_str ("pix_fmt", s); else print_str_opt("pix_fmt", "unknown"); print_int("level", dec_ctx->level); if (dec_ctx->timecode_frame_start >= 0) { char tcbuf[AV_TIMECODE_STR_SIZE]; av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start); print_str("timecode", tcbuf); } else { print_str_opt("timecode", "N/A"); } break; case AVMEDIA_TYPE_AUDIO: s = av_get_sample_fmt_name(dec_ctx->sample_fmt); if (s) print_str ("sample_fmt", s); else print_str_opt("sample_fmt", "unknown"); print_val("sample_rate", dec_ctx->sample_rate, unit_hertz_str); print_int("channels", dec_ctx->channels); if (dec_ctx->channel_layout) { av_bprint_clear(&pbuf); av_bprint_channel_layout(&pbuf, dec_ctx->channels, dec_ctx->channel_layout); print_str ("channel_layout", pbuf.str); } else { print_str_opt("channel_layout", "unknown"); } print_int("bits_per_sample", av_get_bits_per_sample(dec_ctx->codec_id)); break; case AVMEDIA_TYPE_SUBTITLE: if (dec_ctx->width) print_int("width", dec_ctx->width); else print_str_opt("width", "N/A"); if (dec_ctx->height) print_int("height", dec_ctx->height); else print_str_opt("height", "N/A"); break; } } else { print_str_opt("codec_type", "unknown"); } if (dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) { const AVOption *opt = NULL; while (opt = av_opt_next(dec_ctx->priv_data,opt)) { uint8_t *str; if (opt->flags) continue; if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) { print_str(opt->name, str); av_free(str); } } } if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt ("id", "0x%x", stream->id); else print_str_opt("id", "N/A"); print_q("r_frame_rate", stream->r_frame_rate, '/'); print_q("avg_frame_rate", stream->avg_frame_rate, '/'); print_q("time_base", stream->time_base, '/'); print_ts ("start_pts", stream->start_time); print_time("start_time", stream->start_time, &stream->time_base); print_ts ("duration_ts", stream->duration); print_time("duration", stream->duration, &stream->time_base); if (dec_ctx->bit_rate > 0) print_val ("bit_rate", dec_ctx->bit_rate, unit_bit_per_second_str); else print_str_opt("bit_rate", "N/A"); if (stream->nb_frames) print_fmt ("nb_frames", "%"PRId64, stream->nb_frames); else print_str_opt("nb_frames", "N/A"); if (nb_streams_frames[stream_idx]) print_fmt ("nb_read_frames", "%"PRIu64, nb_streams_frames[stream_idx]); else print_str_opt("nb_read_frames", "N/A"); if (nb_streams_packets[stream_idx]) print_fmt ("nb_read_packets", "%"PRIu64, nb_streams_packets[stream_idx]); else print_str_opt("nb_read_packets", "N/A"); if (do_show_data) writer_print_data(w, "extradata", dec_ctx->extradata, dec_ctx->extradata_size); #define PRINT_DISPOSITION(flagname, name) do { \ print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \ } while (0) if (do_show_stream_disposition) { writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION); PRINT_DISPOSITION(DEFAULT, "default"); PRINT_DISPOSITION(DUB, "dub"); PRINT_DISPOSITION(ORIGINAL, "original"); PRINT_DISPOSITION(COMMENT, "comment"); PRINT_DISPOSITION(LYRICS, "lyrics"); PRINT_DISPOSITION(KARAOKE, "karaoke"); PRINT_DISPOSITION(FORCED, "forced"); PRINT_DISPOSITION(HEARING_IMPAIRED, "hearing_impaired"); PRINT_DISPOSITION(VISUAL_IMPAIRED, "visual_impaired"); PRINT_DISPOSITION(CLEAN_EFFECTS, "clean_effects"); PRINT_DISPOSITION(ATTACHED_PIC, "attached_pic"); writer_print_section_footer(w); } show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS); writer_print_section_footer(w); av_bprint_finalize(&pbuf, NULL); fflush(stdout); }[Succeeded / Failed / Skipped / Total] 637 / 59 / 398 / 1094:  41%|      | 1094/2690 [12:33:27<18:19:11, 41.32s/it][Succeeded / Failed / Skipped / Total] 637 / 59 / 398 / 1094:  41%|      | 1095/2690 [12:33:34<18:17:40, 41.29s/it][Succeeded / Failed / Skipped / Total] 638 / 59 / 398 / 1095:  41%|      | 1095/2690 [12:33:34<18:17:40, 41.29s/it][Succeeded / Failed / Skipped / Total] 638 / 59 / 398 / 1095:  41%|      | 1096/2690 [12:33:35<18:16:00, 41.26s/it][Succeeded / Failed / Skipped / Total] 639 / 59 / 398 / 1096:  41%|      | 1096/2690 [12:33:35<18:16:00, 41.26s/it][Succeeded / Failed / Skipped / Total] 639 / 59 / 398 / 1096:  41%|      | 1097/2690 [12:33:35<18:14:20, 41.22s/it][Succeeded / Failed / Skipped / Total] 639 / 59 / 399 / 1097:  41%|      | 1097/2690 [12:33:35<18:14:20, 41.22s/it][Succeeded / Failed / Skipped / Total] 639 / 59 / 399 / 1097:  41%|      | 1098/2690 [12:33:36<18:12:39, 41.18s/it][Succeeded / Failed / Skipped / Total] 639 / 59 / 400 / 1098:  41%|      | 1098/2690 [12:33:36<18:12:39, 41.18s/it][Succeeded / Failed / Skipped / Total] 639 / 59 / 400 / 1098:  41%|      | 1099/2690 [12:33:37<18:10:59, 41.14s/it][Succeeded / Failed / Skipped / Total] 640 / 59 / 400 / 1099:  41%|      | 1099/2690 [12:33:37<18:10:59, 41.14s/it][Succeeded / Failed / Skipped / Total] 640 / 59 / 400 / 1099:  41%|      | 1100/2690 [12:33:37<18:09:19, 41.11s/it][Succeeded / Failed / Skipped / Total] 640 / 59 / 401 / 1100:  41%|      | 1100/2690 [12:33:37<18:09:19, 41.11s/it][Succeeded / Failed / Skipped / Total] 640 / 59 / 401 / 1100:  41%|      | 1101/2690 [12:33:38<18:07:40, 41.07s/it][Succeeded / Failed / Skipped / Total] 640 / 59 / 402 / 1101:  41%|      | 1101/2690 [12:33:38<18:07:40, 41.07s/it][Succeeded / Failed / Skipped / Total] 640 / 59 / 402 / 1101:  41%|      | 1102/2690 [12:36:11<18:09:40, 41.17s/it][Succeeded / Failed / Skipped / Total] 641 / 59 / 402 / 1102:  41%|      | 1102/2690 [12:36:11<18:09:40, 41.17s/it][Succeeded / Failed / Skipped / Total] 641 / 59 / 402 / 1102:  41%|      | 1103/2690 [12:36:15<18:08:06, 41.14s/it]
--------------------------------------------- Result 1095 ---------------------------------------------
[[0 (64%)]] --> [[0 (40%)]] --> Socre: 0.5977876782417297

[[[[Adv]]]]: static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan, const uint32_t *quant) { int coeff, i, n; int8_t ac; uint8_t [[dc]] = get_bits(gb, 8); if ([[dc]] == 255) coeff = get_bits(gb, 6); if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits) memset(block, 0, 64 * sizeof(DCTELEM)); while (coeff) { ac = get_sbits(gb, 2); if (ac == -2) break; PUT_COEFF(ac); } ALIGN(4); while (coeff) { ac = get_sbits(gb, 4); if (ac == -8) break; PUT_COEFF(ac); } ALIGN(8); if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits) while (coeff) { ac = get_sbits(gb, 8); PUT_COEFF(ac); } PUT_COEFF([[dc]]); return 1; }

[[[[Adv]]]]: static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan, const uint32_t *quant) { int coeff, i, n; int8_t ac; uint8_t [[cdc]] = get_bits(gb, 8); if ([[cdc]] == 255) coeff = get_bits(gb, 6); if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits) memset(block, 0, 64 * sizeof(DCTELEM)); while (coeff) { ac = get_sbits(gb, 2); if (ac == -2) break; PUT_COEFF(ac); } ALIGN(4); while (coeff) { ac = get_sbits(gb, 4); if (ac == -8) break; PUT_COEFF(ac); } ALIGN(8); if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits) while (coeff) { ac = get_sbits(gb, 8); PUT_COEFF(ac); } PUT_COEFF([[cdc]]); return 1; }
--------------------------------------------- Result 1096 ---------------------------------------------
[[0 (11%)]] --> [[0 (57%)]] --> Socre: 0.5688278675079346

[[[[Adv]]]]: static av_cold int check_cuda_errors(AVCodecContext *[[avctx]], CUresult err, const char *[[func]]) { if (err != CUDA_SUCCESS) { av_log([[avctx]], AV_LOG_FATAL, ">> %s - failed with error code 0x%x\n", [[func]], err); return 0; } return 1; }

[[[[Adv]]]]: static av_cold int check_cuda_errors(AVCodecContext *[[gallup]], CUresult err, const char *[[mcbain]]) { if (err != CUDA_SUCCESS) { av_log([[gallup]], AV_LOG_FATAL, ">> %s - failed with error code 0x%x\n", [[mcbain]], err); return 0; } return 1; }
--------------------------------------------- Result 1097 ---------------------------------------------
[[0 (97%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int parse_header(OutputStream *os, const uint8_t *buf, int buf_size) { if (buf_size < 13) return AVERROR_INVALIDDATA; if (memcmp(buf, "FLV", 3)) return AVERROR_INVALIDDATA; buf += 13; buf_size -= 13; while (buf_size >= 11 + 4) { int type = buf[0]; int size = AV_RB24(&buf[1]) + 11 + 4; if (size > buf_size) return AVERROR_INVALIDDATA; if (type == 8 || type == 9) { if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extra_packets)) return AVERROR_INVALIDDATA; os->extra_packet_sizes[os->nb_extra_packets] = size; os->extra_packets[os->nb_extra_packets] = av_malloc(size); if (!os->extra_packets[os->nb_extra_packets]) return AVERROR(ENOMEM); memcpy(os->extra_packets[os->nb_extra_packets], buf, size); os->nb_extra_packets++; } else if (type == 0x12) { if (os->metadata) return AVERROR_INVALIDDATA; os->metadata_size = size - 11 - 4; os->metadata = av_malloc(os->metadata_size); if (!os->metadata) return AVERROR(ENOMEM); memcpy(os->metadata, buf + 11, os->metadata_size); } buf += size; buf_size -= size; } if (!os->metadata) return AVERROR_INVALIDDATA; return 0; }
--------------------------------------------- Result 1098 ---------------------------------------------
[[0 (24%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: restore_sigcontext(CPUMIPSState *regs, struct target_sigcontext *sc) { int err = 0; int i; __get_user(regs->CP0_EPC, &sc->sc_pc); __get_user(regs->active_tc.HI[0], &sc->sc_mdhi); __get_user(regs->active_tc.LO[0], &sc->sc_mdlo); for (i = 1; i < 32; ++i) { __get_user(regs->active_tc.gpr[i], &sc->sc_regs[i]); } __get_user(regs->active_tc.HI[1], &sc->sc_hi1); __get_user(regs->active_tc.HI[2], &sc->sc_hi2); __get_user(regs->active_tc.HI[3], &sc->sc_hi3); __get_user(regs->active_tc.LO[1], &sc->sc_lo1); __get_user(regs->active_tc.LO[2], &sc->sc_lo2); __get_user(regs->active_tc.LO[3], &sc->sc_lo3); { uint32_t dsp; __get_user(dsp, &sc->sc_dsp); cpu_wrdsp(dsp, 0x3ff, regs); } for (i = 0; i < 32; ++i) { __get_user(regs->active_fpu.fpr[i].d, &sc->sc_fpregs[i]); } return err; }
--------------------------------------------- Result 1099 ---------------------------------------------
[[0 (87%)]] --> [[0 (48%)]] --> Socre: 0.5200213491916656

[[[[Adv]]]]: static void gen_neon_trn_u16(TCGv t0, TCGv t1) { TCGv [[rd]], tmp; [[rd]] = new_tmp(); tmp = new_tmp(); tcg_gen_shli_i32([[rd]], t0, 16); tcg_gen_andi_i32(tmp, t1, 0xffff); tcg_gen_or_i32([[rd]], [[rd]], tmp); tcg_gen_shri_i32(t1, t1, 16); tcg_gen_andi_i32(tmp, t0, 0xffff0000); tcg_gen_or_i32(t1, t1, tmp); tcg_gen_mov_i32(t0, [[rd]]); dead_tmp(tmp); dead_tmp([[rd]]); }

[[[[Adv]]]]: static void gen_neon_trn_u16(TCGv t0, TCGv t1) { TCGv [[doctorate]], tmp; [[doctorate]] = new_tmp(); tmp = new_tmp(); tcg_gen_shli_i32([[doctorate]], t0, 16); tcg_gen_andi_i32(tmp, t1, 0xffff); tcg_gen_or_i32([[doctorate]], [[doctorate]], tmp); tcg_gen_shri_i32(t1, t1, 16); tcg_gen_andi_i32(tmp, t0, 0xffff0000); tcg_gen_or_i32(t1, t1, tmp); tcg_gen_mov_i32(t0, [[doctorate]]); dead_tmp(tmp); dead_tmp([[doctorate]]); }
--------------------------------------------- Result 1100 ---------------------------------------------
[[0 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static AHCIQState *ahci_boot(void) { AHCIQState *s; const char *cli; s = g_malloc0(sizeof(AHCIQState)); cli = "-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s" ",format=qcow2" " -M q35 " "-device ide-hd,drive=drive0 " "-global ide-hd.ver=%s"; s->parent = qtest_pc_boot(cli, tmp_path, "testdisk", "version"); alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT); s->dev = get_ahci_device(&s->fingerprint); return s; }
--------------------------------------------- Result 1101 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void address_space_destroy_dispatch(AddressSpace *as) { AddressSpaceDispatch *d = as->dispatch; memory_listener_unregister(&d->listener); g_free(d); as->dispatch = NULL; }
--------------------------------------------- Result 1102 ---------------------------------------------
[[0 (1%)]] --> [[0 (55%)]] --> Socre: 0.5505577325820923

[[[[Adv]]]]: mst_fpga_readb(void *[[opaque]], target_phys_addr_t [[addr]]) { mst_irq_state *s = (mst_irq_state *) [[opaque]]; switch ([[addr]]) { case MST_LEDDAT1: return s->leddat1; case MST_LEDDAT2: return s->leddat2; case MST_LEDCTRL: return s->ledctrl; case MST_GPSWR: return s->gpswr; case MST_MSCWR1: return s->mscwr1; case MST_MSCWR2: return s->mscwr2; case MST_MSCWR3: return s->mscwr3; case MST_MSCRD: return s->mscrd; case MST_INTMSKENA: return s->intmskena; case MST_INTSETCLR: return s->intsetclr; case MST_PCMCIA0: return s->pcmcia0; case MST_PCMCIA1: return s->pcmcia1; default: printf("Mainstone - mst_fpga_readb: Bad register offset " "0x" TARGET_FMT_plx " \n", [[addr]]); } return 0; }

[[[[Adv]]]]: mst_fpga_readb(void *[[perplexing]], target_phys_addr_t [[]]) { mst_irq_state *s = (mst_irq_state *) [[perplexing]]; switch ([[]]) { case MST_LEDDAT1: return s->leddat1; case MST_LEDDAT2: return s->leddat2; case MST_LEDCTRL: return s->ledctrl; case MST_GPSWR: return s->gpswr; case MST_MSCWR1: return s->mscwr1; case MST_MSCWR2: return s->mscwr2; case MST_MSCWR3: return s->mscwr3; case MST_MSCRD: return s->mscrd; case MST_INTMSKENA: return s->intmskena; case MST_INTSETCLR: return s->intsetclr; case MST_PCMCIA0: return s->pcmcia0; case MST_PCMCIA1: return s->pcmcia1; default: printf("Mainstone - mst_fpga_readb: Bad register offset " "0x" TARGET_FMT_plx " \n", [[]]); } return 0; }
--------------------------------------------- Result 1103 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 642 / 59 / 402 / 1103:  41%|      | 1103/2690 [12:36:15<18:08:06, 41.14s/it][Succeeded / Failed / Skipped / Total] 642 / 59 / 402 / 1103:  41%|      | 1104/2690 [12:36:16<18:06:27, 41.10s/it][Succeeded / Failed / Skipped / Total] 642 / 59 / 403 / 1104:  41%|      | 1104/2690 [12:36:16<18:06:27, 41.10s/it][Succeeded / Failed / Skipped / Total] 642 / 59 / 403 / 1104:  41%|      | 1105/2690 [12:36:16<18:04:47, 41.06s/it][Succeeded / Failed / Skipped / Total] 642 / 59 / 404 / 1105:  41%|      | 1105/2690 [12:36:16<18:04:47, 41.06s/it][Succeeded / Failed / Skipped / Total] 642 / 59 / 404 / 1105:  41%|      | 1106/2690 [12:36:50<18:03:56, 41.06s/it][Succeeded / Failed / Skipped / Total] 642 / 60 / 404 / 1106:  41%|      | 1106/2690 [12:36:50<18:03:56, 41.06s/it][Succeeded / Failed / Skipped / Total] 642 / 60 / 404 / 1106:  41%|      | 1107/2690 [12:36:51<18:02:17, 41.02s/it][Succeeded / Failed / Skipped / Total] 642 / 60 / 405 / 1107:  41%|      | 1107/2690 [12:36:51<18:02:17, 41.02s/it][Succeeded / Failed / Skipped / Total] 642 / 60 / 405 / 1107:  41%|      | 1108/2690 [12:37:47<18:01:58, 41.04s/it][Succeeded / Failed / Skipped / Total] 642 / 61 / 405 / 1108:  41%|      | 1108/2690 [12:37:47<18:01:58, 41.04s/it][Succeeded / Failed / Skipped / Total] 642 / 61 / 405 / 1108:  41%|      | 1109/2690 [12:37:52<18:00:25, 41.00s/it][Succeeded / Failed / Skipped / Total] 643 / 61 / 405 / 1109:  41%|      | 1109/2690 [12:37:52<18:00:25, 41.00s/it][Succeeded / Failed / Skipped / Total] 643 / 61 / 405 / 1109:  41%|     | 1110/2690 [12:38:37<17:59:50, 41.01s/it][Succeeded / Failed / Skipped / Total] 644 / 61 / 405 / 1110:  41%|     | 1110/2690 [12:38:37<17:59:50, 41.01s/it][Succeeded / Failed / Skipped / Total] 644 / 61 / 405 / 1110:  41%|     | 1111/2690 [12:39:25<17:59:19, 41.01s/it][[0 (14%)]] --> [[0 (50%)]] --> Socre: 0.5038190484046936

[[[[Adv]]]]: static int pci_piix_ide_initfn(PCIIDEState *[[d]]) { uint8_t *[[pci_conf]] = [[d]]->dev.config; [[pci_conf]][PCI_CLASS_PROG] = 0x80; pci_config_set_class([[pci_conf]], PCI_CLASS_STORAGE_IDE); qemu_register_reset(piix3_reset, [[d]]); pci_register_bar(&[[d]]->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map); vmstate_register(&[[d]]->dev.qdev, 0, &vmstate_ide_pci, [[d]]); pci_piix_init_ports([[d]]); return 0; }

[[[[Adv]]]]: static int pci_piix_ide_initfn(PCIIDEState *[[w]]) { uint8_t *[[moderne]] = [[w]]->dev.config; [[moderne]][PCI_CLASS_PROG] = 0x80; pci_config_set_class([[moderne]], PCI_CLASS_STORAGE_IDE); qemu_register_reset(piix3_reset, [[w]]); pci_register_bar(&[[w]]->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map); vmstate_register(&[[w]]->dev.qdev, 0, &vmstate_ide_pci, [[w]]); pci_piix_init_ports([[w]]); return 0; }
--------------------------------------------- Result 1104 ---------------------------------------------
[[0 (76%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp) { DeviceState *qdev = DEVICE(vpci_dev); VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev); DeviceState *vdev = DEVICE(&dev->vdev); virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features); virtio_net_set_netclient_name(&dev->vdev, qdev->id, object_get_typename(OBJECT(qdev))); qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus)); object_property_set_bool(OBJECT(vdev), "True" == "True", "realized", errp); }
--------------------------------------------- Result 1105 ---------------------------------------------
[[0 (73%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void spapr_nvram_realize(VIOsPAPRDevice *dev, Error **errp) { sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev); int ret; if (nvram->blk) { nvram->size = blk_getlength(nvram->blk); ret = blk_set_perm(nvram->blk, BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE, BLK_PERM_ALL, errp); if (ret < 0) { return; } } else { nvram->size = DEFAULT_NVRAM_SIZE; } nvram->buf = g_malloc0(nvram->size); if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) { error_setg(errp, "spapr-nvram must be between %d and %d bytes in size", MIN_NVRAM_SIZE, MAX_NVRAM_SIZE); return; } if (nvram->blk) { int alen = blk_pread(nvram->blk, 0, nvram->buf, nvram->size); if (alen != nvram->size) { error_setg(errp, "can't read spapr-nvram contents"); return; } } else if (nb_prom_envs > 0) { chrp_nvram_create_system_partition(nvram->buf, MIN_NVRAM_SIZE / 4); chrp_nvram_create_free_partition(&nvram->buf[MIN_NVRAM_SIZE / 4], nvram->size - MIN_NVRAM_SIZE / 4); } spapr_rtas_register(RTAS_NVRAM_FETCH, "nvram-fetch", rtas_nvram_fetch); spapr_rtas_register(RTAS_NVRAM_STORE, "nvram-store", rtas_nvram_store); }
--------------------------------------------- Result 1106 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void ehci_free_packet(EHCIPacket *p) { trace_usb_ehci_packet_action(p->queue, p, "free"); if (p->async == EHCI_ASYNC_INFLIGHT) { usb_cancel_packet(&p->packet); usb_packet_unmap(&p->packet, &p->sgl); qemu_sglist_destroy(&p->sgl); QTAILQ_REMOVE(&p->queue->packets, p, next); usb_packet_cleanup(&p->packet); g_free(p);

[[[[Adv]]]]: static void ehci_free_packet(EHCIPacket *p) { trace_usb_ehci_packet_action(p->queue, p, "free"); if (p->async == EHCI_ASYNC_INFLIGHT) { usb_cancel_packet(&p->packet); usb_packet_unmap(&p->packet, &p->sgl); qemu_sglist_destroy(&p->sgl); QTAILQ_REMOVE(&p->queue->packets, p, next); usb_packet_cleanup(&p->packet); g_free(p);
--------------------------------------------- Result 1107 ---------------------------------------------
[[0 (82%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void RENAME(nv12ToUV)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, long width, uint32_t *unused) { RENAME(nvXXtoUV)(dstU, dstV, src1, width); }
--------------------------------------------- Result 1108 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int vda_h264_end_frame(AVCodecContext *avctx) { H264Context *h = avctx->priv_data; struct vda_context *vda_ctx = avctx->hwaccel_context; AVFrame *frame = &h->cur_pic_ptr->f; struct vda_buffer *context; AVBufferRef *buffer; int status; if (!vda_ctx->decoder || !vda_ctx->priv_bitstream) status = vda_sync_decode(vda_ctx); frame->data[3] = (void*)vda_ctx->cv_buffer; if (status) av_log(avctx, AV_LOG_ERROR, "Failed to decode frame (%d)\n", status);

[[[[Adv]]]]: static int vda_h264_end_frame(AVCodecContext *avctx) { H264Context *h = avctx->priv_data; struct vda_context *vda_ctx = avctx->hwaccel_context; AVFrame *frame = &h->cur_pic_ptr->f; struct vda_buffer *context; AVBufferRef *buffer; int status; if (!vda_ctx->decoder || !vda_ctx->priv_bitstream) status = vda_sync_decode(vda_ctx); frame->data[3] = (void*)vda_ctx->cv_buffer; if (status) av_log(avctx, AV_LOG_ERROR, "Failed to decode frame (%d)\n", status);
--------------------------------------------- Result 1109 ---------------------------------------------
[[0 (2%)]] --> [[0 (50%)]] --> Socre: 0.503028929233551

[[[[Adv]]]]: static inline bool memory_access_is_direct(MemoryRegion *[[mr]], bool [[is_write]]) { if (memory_region_is_ram([[mr]])) { return !([[is_write]] && [[mr]]->readonly); } if (memory_region_is_romd([[mr]])) { return ![[is_write]]; } return "[[False]]" != "[[False]]"; }

[[[[Adv]]]]: static inline bool memory_access_is_direct(MemoryRegion *[[messrs]], bool [[reschedule]]) { if (memory_region_is_ram([[messrs]])) { return !([[reschedule]] && [[messrs]]->readonly); } if (memory_region_is_romd([[messrs]])) { return ![[reschedule]]; } return "[[Untruthful]]" != "[[Untruthful]]"; }
--------------------------------------------- Result 1110 ---------------------------------------------
[[0 (3%)]] --> [[0 (51%)]] --> Socre: 0.510162889957428

[[[[Adv]]]]: int ff_thread_init(AVCodecContext *[[avctx]]) { if ([[avctx]]->thread_opaque) { av_log([[avctx]], AV_LOG_ERROR, "avcodec_thread_init is ignored after avcodec_open\n"); return -1; } #if HAVE_W32THREADS w32thread_init(); #endif if ([[avctx]]->codec) { validate_thread_parameters([[avctx]]); if ([[avctx]]->active_thread_type&FF_THREAD_SLICE) return thread_init([[avctx]]); else if ([[avctx]]->active_thread_type&FF_THREAD_FRAME) return frame_thread_init([[avctx]]); } return 0; }

[[[[Adv]]]]: int ff_thread_init(AVCodecContext *[[goggles]]) { if ([[goggles]]->thread_opaque) { av_log([[goggles]], AV_LOG_ERROR, "avcodec_thread_init is ignored after avcodec_open\n"); return -1; } #if HAVE_W32THREADS w32thread_init(); #endif if ([[goggles]]->codec) { validate_thread_parameters([[goggles]]); if ([[goggles]]->active_thread_type&FF_THREAD_SLICE) return thread_init([[goggles]]); else if ([[goggles]]->active_thread_type&FF_THREAD_FRAME) return frame_thread_init([[goggles]]); } return 0; }
--------------------------------------------- Result 1111 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 645 / 61 / 405 / 1111:  41%|     | 1111/2690 [12:39:25<17:59:19, 41.01s/it][Succeeded / Failed / Skipped / Total] 645 / 61 / 405 / 1111:  41%|     | 1112/2690 [12:39:25<17:57:40, 40.98s/it][Succeeded / Failed / Skipped / Total] 645 / 61 / 406 / 1112:  41%|     | 1112/2690 [12:39:25<17:57:40, 40.98s/it][Succeeded / Failed / Skipped / Total] 645 / 61 / 406 / 1112:  41%|     | 1113/2690 [12:39:32<17:56:11, 40.95s/it][Succeeded / Failed / Skipped / Total] 646 / 61 / 406 / 1113:  41%|     | 1113/2690 [12:39:32<17:56:11, 40.95s/it][Succeeded / Failed / Skipped / Total] 646 / 61 / 406 / 1113:  41%|     | 1114/2690 [12:39:35<17:54:37, 40.91s/it][[0 (36%)]] --> [[0 (50%)]] --> Socre: 0.500737726688385

[[[[Adv]]]]: VirtIODevice *virtio_blk_init(DeviceState *dev, VirtIOBlkConf *blk) { VirtIOBlock *s; int cylinders, heads, secs; static int [[virtio_blk_id]]; DriveInfo *[[dinfo]]; if (!blk->conf.bs) { error_report("drive property not set"); return NULL; } if (!bdrv_is_inserted(blk->conf.bs)) { error_report("Device needs media, but drive is empty"); return NULL; } if (!blk->serial) { [[dinfo]] = drive_get_by_blockdev(blk->conf.bs); if (*[[dinfo]]->serial) { blk->serial = strdup([[dinfo]]->serial); } } s = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK, sizeof(struct virtio_blk_config), sizeof(VirtIOBlock)); s->vdev.get_config = virtio_blk_update_config; s->vdev.get_features = virtio_blk_get_features; s->vdev.reset = virtio_blk_reset; s->bs = blk->conf.bs; s->conf = &blk->conf; s->blk = blk; s->rq = NULL; s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1; bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs); s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output); qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s); s->qdev = dev; register_savevm(dev, "virtio-blk", [[virtio_blk_id]]++, 2, virtio_blk_save, virtio_blk_load, s); bdrv_set_dev_ops(s->bs, &virtio_block_ops, s); bdrv_set_buffer_alignment(s->bs, s->conf->logical_block_size); bdrv_iostatus_enable(s->bs); add_boot_device_path(s->conf->bootindex, dev, "/disk@0,0"); return &s->vdev; }

[[[[Adv]]]]: VirtIODevice *virtio_blk_init(DeviceState *dev, VirtIOBlkConf *blk) { VirtIOBlock *s; int cylinders, heads, secs; static int [[tatooine]]; DriveInfo *[[aggravating]]; if (!blk->conf.bs) { error_report("drive property not set"); return NULL; } if (!bdrv_is_inserted(blk->conf.bs)) { error_report("Device needs media, but drive is empty"); return NULL; } if (!blk->serial) { [[aggravating]] = drive_get_by_blockdev(blk->conf.bs); if (*[[aggravating]]->serial) { blk->serial = strdup([[aggravating]]->serial); } } s = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK, sizeof(struct virtio_blk_config), sizeof(VirtIOBlock)); s->vdev.get_config = virtio_blk_update_config; s->vdev.get_features = virtio_blk_get_features; s->vdev.reset = virtio_blk_reset; s->bs = blk->conf.bs; s->conf = &blk->conf; s->blk = blk; s->rq = NULL; s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1; bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs); s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output); qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s); s->qdev = dev; register_savevm(dev, "virtio-blk", [[tatooine]]++, 2, virtio_blk_save, virtio_blk_load, s); bdrv_set_dev_ops(s->bs, &virtio_block_ops, s); bdrv_set_buffer_alignment(s->bs, s->conf->logical_block_size); bdrv_iostatus_enable(s->bs); add_boot_device_path(s->conf->bootindex, dev, "/disk@0,0"); return &s->vdev; }
--------------------------------------------- Result 1112 ---------------------------------------------
[[0 (6%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value) { if (ri->crm > 8) { return EXCP_UDEF; } env->cp15.c6_region[ri->crm] = value; return 0; }
--------------------------------------------- Result 1113 ---------------------------------------------
[[0 (63%)]] --> [[0 (46%)]] --> Socre: 0.5445666909217834

[[[[Adv]]]]: static int usb_host_open(USBHostDevice *[[dev]], int bus_num, int addr, const char *port, const char *prod_name, int speed) { int fd = -1, ret; trace_usb_host_open_started(bus_num, addr); if ([[dev]]->fd != -1) { goto fail; } fd = usb_host_open_device(bus_num, addr); if (fd < 0) { goto fail; } DPRINTF("husb: opened %s\n", buf); [[dev]]->bus_num = bus_num; [[dev]]->addr = addr; strcpy([[dev]]->port, port); [[dev]]->fd = fd; [[dev]]->descr_len = read(fd, [[dev]]->descr, sizeof([[dev]]->descr)); if ([[dev]]->descr_len <= 0) { perror("husb: reading device data failed"); goto fail; } #ifdef DEBUG { int [[x]]; printf("=== begin dumping device descriptor data ===\n"); for ([[x]] = 0; [[x]] < [[dev]]->descr_len; [[x]]++) { printf("%02x ", [[dev]]->descr[[[x]]]); } printf("\n=== end dumping device descriptor data ===\n"); } #endif if (!usb_host_claim_interfaces([[dev]], 0)) { goto fail; } usb_ep_init(&[[dev]]->dev); usb_linux_update_endp_table([[dev]]); if (speed == -1) { struct usbdevfs_connectinfo ci; ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci); if (ret < 0) { perror("usb_host_device_open: USBDEVFS_CONNECTINFO"); goto fail; } if (ci.slow) { speed = USB_SPEED_LOW; } else { speed = USB_SPEED_HIGH; } } [[dev]]->dev.speed = speed; [[dev]]->dev.speedmask = (1 << speed); if ([[dev]]->dev.speed == USB_SPEED_HIGH && usb_linux_full_speed_compat([[dev]])) { [[dev]]->dev.speedmask |= USB_SPEED_MASK_FULL; } trace_usb_host_open_success(bus_num, addr); if (!prod_name || prod_name[0] == '\0') { snprintf([[dev]]->dev.product_desc, sizeof([[dev]]->dev.product_desc), "host:%d.%d", bus_num, addr); } else { pstrcpy([[dev]]->dev.product_desc, sizeof([[dev]]->dev.product_desc), prod_name); } ret = usb_device_attach(&[[dev]]->dev); if (ret) { goto fail; } qemu_set_fd_handler([[dev]]->fd, NULL, async_complete, [[dev]]); return 0; fail: trace_usb_host_open_failure(bus_num, addr); if ([[dev]]->fd != -1) { close([[dev]]->fd); [[dev]]->fd = -1; } return -1; }

[[[[Adv]]]]: static int usb_host_open(USBHostDevice *[[kumar]], int bus_num, int addr, const char *port, const char *prod_name, int speed) { int fd = -1, ret; trace_usb_host_open_started(bus_num, addr); if ([[kumar]]->fd != -1) { goto fail; } fd = usb_host_open_device(bus_num, addr); if (fd < 0) { goto fail; } DPRINTF("husb: opened %s\n", buf); [[kumar]]->bus_num = bus_num; [[kumar]]->addr = addr; strcpy([[kumar]]->port, port); [[kumar]]->fd = fd; [[kumar]]->descr_len = read(fd, [[kumar]]->descr, sizeof([[kumar]]->descr)); if ([[kumar]]->descr_len <= 0) { perror("husb: reading device data failed"); goto fail; } #ifdef DEBUG { int [[centimeter]]; printf("=== begin dumping device descriptor data ===\n"); for ([[centimeter]] = 0; [[centimeter]] < [[kumar]]->descr_len; [[centimeter]]++) { printf("%02x ", [[kumar]]->descr[[[centimeter]]]); } printf("\n=== end dumping device descriptor data ===\n"); } #endif if (!usb_host_claim_interfaces([[kumar]], 0)) { goto fail; } usb_ep_init(&[[kumar]]->dev); usb_linux_update_endp_table([[kumar]]); if (speed == -1) { struct usbdevfs_connectinfo ci; ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci); if (ret < 0) { perror("usb_host_device_open: USBDEVFS_CONNECTINFO"); goto fail; } if (ci.slow) { speed = USB_SPEED_LOW; } else { speed = USB_SPEED_HIGH; } } [[kumar]]->dev.speed = speed; [[kumar]]->dev.speedmask = (1 << speed); if ([[kumar]]->dev.speed == USB_SPEED_HIGH && usb_linux_full_speed_compat([[kumar]])) { [[kumar]]->dev.speedmask |= USB_SPEED_MASK_FULL; } trace_usb_host_open_success(bus_num, addr); if (!prod_name || prod_name[0] == '\0') { snprintf([[kumar]]->dev.product_desc, sizeof([[kumar]]->dev.product_desc), "host:%d.%d", bus_num, addr); } else { pstrcpy([[kumar]]->dev.product_desc, sizeof([[kumar]]->dev.product_desc), prod_name); } ret = usb_device_attach(&[[kumar]]->dev); if (ret) { goto fail; } qemu_set_fd_handler([[kumar]]->fd, NULL, async_complete, [[kumar]]); return 0; fail: trace_usb_host_open_failure(bus_num, addr); if ([[kumar]]->fd != -1) { close([[kumar]]->fd); [[kumar]]->fd = -1; } return -1; }
--------------------------------------------- Result 1114 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 647 / 61 / 406 / 1114:  41%|     | 1114/2690 [12:39:35<17:54:37, 40.91s/it][Succeeded / Failed / Skipped / Total] 647 / 61 / 406 / 1114:  41%|     | 1115/2690 [12:41:57<17:56:18, 41.00s/it][[0 (65%)]] --> [[0 (45%)]] --> Socre: 0.54591304063797

[[[[Adv]]]]: static int esp_pci_scsi_init(PCIDevice *dev) { PCIESPState *pci = PCI_ESP(dev); DeviceState *d = DEVICE(dev); ESPState *s = &pci->esp; uint8_t *pci_conf; Error *[[err]] = NULL; pci_conf = dev->config; pci_conf[PCI_INTERRUPT_PIN] = 0x01; s->dma_memory_read = esp_pci_dma_memory_read; s->dma_memory_write = esp_pci_dma_memory_write; s->dma_opaque = pci; s->chip_id = TCHI_AM53C974; memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci, "esp-io", 0x80); pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io); s->irq = pci_allocate_irq(dev); scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL); if (!d->hotplugged) { scsi_bus_legacy_handle_cmdline(&s->bus, &[[err]]); if ([[err]] != NULL) { error_free([[err]]); return -1; } } return 0; }

[[[[Adv]]]]: static int esp_pci_scsi_init(PCIDevice *dev) { PCIESPState *pci = PCI_ESP(dev); DeviceState *d = DEVICE(dev); ESPState *s = &pci->esp; uint8_t *pci_conf; Error *[[ah]] = NULL; pci_conf = dev->config; pci_conf[PCI_INTERRUPT_PIN] = 0x01; s->dma_memory_read = esp_pci_dma_memory_read; s->dma_memory_write = esp_pci_dma_memory_write; s->dma_opaque = pci; s->chip_id = TCHI_AM53C974; memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci, "esp-io", 0x80); pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io); s->irq = pci_allocate_irq(dev); scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL); if (!d->hotplugged) { scsi_bus_legacy_handle_cmdline(&s->bus, &[[ah]]); if ([[ah]] != NULL) { error_free([[ah]]); return -1; } } return 0; }
--------------------------------------------- Result 1115 ---------------------------------------------
[[0 (100%)]] --> [[0 (47%)]] --> Socre: 0.5348250269889832

[[[[Adv]]]]: static int pcm_decode_frame(AVCodecContext *avctx, void *data, int *[[data_size]], AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; PCMDecode *s = avctx->priv_data; int sample_size, c, n, i; short *samples; const uint8_t *src, *src8, *src2[MAX_CHANNELS]; uint8_t *dstu8; int16_t *dst_int16_t; int32_t *dst_int32_t; int64_t *dst_int64_t; uint16_t *dst_uint16_t; uint32_t *dst_uint32_t; samples = data; src = buf; if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) { av_log(avctx, AV_LOG_ERROR, "invalid sample_fmt\n"); return -1; if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){ av_log(avctx, AV_LOG_ERROR, "PCM channels out of bounds\n"); return -1; sample_size = av_get_bits_per_sample(avctx->codec_id)/8; if (CODEC_ID_PCM_DVD == avctx->codec_id) sample_size = avctx->bits_per_coded_sample * 2 / 8; else if (avctx->codec_id == CODEC_ID_PCM_LXF) sample_size = 5; n = avctx->channels * sample_size; if(n && buf_size % n){ if (buf_size < n) { av_log(avctx, AV_LOG_ERROR, "invalid PCM packet\n"); return -1; }else buf_size -= buf_size % n; buf_size= FFMIN(buf_size, *[[data_size]]/2); *[[data_size]]=0; n = buf_size/sample_size; switch(avctx->codec->id) { case CODEC_ID_PCM_U32LE: DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_U32BE: DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_S24LE: DECODE(int32_t, le24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_S24BE: DECODE(int32_t, be24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_U24LE: DECODE(uint32_t, le24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_U24BE: DECODE(uint32_t, be24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_S24DAUD: for(;n>0;n--) { uint32_t v = bytestream_get_be24(&src); v >>= 4; *samples++ = av_reverse[(v >> 8) & 0xff] + (av_reverse[v & 0xff] << 8); break; case CODEC_ID_PCM_S16LE_PLANAR: n /= avctx->channels; for(c=0;c<avctx->channels;c++) src2[c] = &src[c*n*2]; for(;n>0;n--) for(c=0;c<avctx->channels;c++) *samples++ = bytestream_get_le16(&src2[c]); src = src2[avctx->channels-1]; break; case CODEC_ID_PCM_U16LE: DECODE(uint16_t, le16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_U16BE: DECODE(uint16_t, be16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_S8: dstu8= (uint8_t*)samples; for(;n>0;n--) { *dstu8++ = *src++ + 128; samples= (short*)dstu8; break; #if HAVE_BIGENDIAN case CODEC_ID_PCM_F64LE: DECODE(int64_t, le64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_F32LE: DECODE(int32_t, le32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16LE: DECODE(int16_t, le16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64BE: case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: case CODEC_ID_PCM_S16BE: #else case CODEC_ID_PCM_F64BE: DECODE(int64_t, be64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: DECODE(int32_t, be32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16BE: DECODE(int16_t, be16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64LE: case CODEC_ID_PCM_F32LE: case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_S16LE: #endif case CODEC_ID_PCM_U8: memcpy(samples, src, n*sample_size); src += n*sample_size; samples = (short*)((uint8_t*)data + n*sample_size); break; case CODEC_ID_PCM_ZORK: for(;n>0;n--) { int x= *src++; if(x&128) x-= 128; else x = -x; *samples++ = x << 8; break; case CODEC_ID_PCM_ALAW: case CODEC_ID_PCM_MULAW: for(;n>0;n--) { *samples++ = s->table[*src++]; break; case CODEC_ID_PCM_DVD: dst_int32_t = data; n /= avctx->channels; switch (avctx->bits_per_coded_sample) { case 20: while (n--) { c = avctx->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8 &0xf0) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12); src = src8; break; case 24: while (n--) { c = avctx->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); src = src8; break; default: av_log(avctx, AV_LOG_ERROR, "PCM DVD unsupported sample depth\n"); return -1; break; samples = (short *) dst_int32_t; break; case CODEC_ID_PCM_LXF: dst_int32_t = data; n /= avctx->channels; for (i = 0; i < n; i++) { for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) | ((src8[2] & 0xF) << 8) | src8[1]; for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) | ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4); src += n * avctx->channels * 5; samples = (short *) dst_int32_t; break; default: return -1; *[[data_size]] = (uint8_t *)samples - (uint8_t *)data; return src - buf;

[[[[Adv]]]]: static int pcm_decode_frame(AVCodecContext *avctx, void *data, int *[[enchante]], AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; PCMDecode *s = avctx->priv_data; int sample_size, c, n, i; short *samples; const uint8_t *src, *src8, *src2[MAX_CHANNELS]; uint8_t *dstu8; int16_t *dst_int16_t; int32_t *dst_int32_t; int64_t *dst_int64_t; uint16_t *dst_uint16_t; uint32_t *dst_uint32_t; samples = data; src = buf; if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) { av_log(avctx, AV_LOG_ERROR, "invalid sample_fmt\n"); return -1; if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){ av_log(avctx, AV_LOG_ERROR, "PCM channels out of bounds\n"); return -1; sample_size = av_get_bits_per_sample(avctx->codec_id)/8; if (CODEC_ID_PCM_DVD == avctx->codec_id) sample_size = avctx->bits_per_coded_sample * 2 / 8; else if (avctx->codec_id == CODEC_ID_PCM_LXF) sample_size = 5; n = avctx->channels * sample_size; if(n && buf_size % n){ if (buf_size < n) { av_log(avctx, AV_LOG_ERROR, "invalid PCM packet\n"); return -1; }else buf_size -= buf_size % n; buf_size= FFMIN(buf_size, *[[enchante]]/2); *[[enchante]]=0; n = buf_size/sample_size; switch(avctx->codec->id) { case CODEC_ID_PCM_U32LE: DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_U32BE: DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000) break; case CODEC_ID_PCM_S24LE: DECODE(int32_t, le24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_S24BE: DECODE(int32_t, be24, src, samples, n, 8, 0) break; case CODEC_ID_PCM_U24LE: DECODE(uint32_t, le24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_U24BE: DECODE(uint32_t, be24, src, samples, n, 8, 0x800000) break; case CODEC_ID_PCM_S24DAUD: for(;n>0;n--) { uint32_t v = bytestream_get_be24(&src); v >>= 4; *samples++ = av_reverse[(v >> 8) & 0xff] + (av_reverse[v & 0xff] << 8); break; case CODEC_ID_PCM_S16LE_PLANAR: n /= avctx->channels; for(c=0;c<avctx->channels;c++) src2[c] = &src[c*n*2]; for(;n>0;n--) for(c=0;c<avctx->channels;c++) *samples++ = bytestream_get_le16(&src2[c]); src = src2[avctx->channels-1]; break; case CODEC_ID_PCM_U16LE: DECODE(uint16_t, le16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_U16BE: DECODE(uint16_t, be16, src, samples, n, 0, 0x8000) break; case CODEC_ID_PCM_S8: dstu8= (uint8_t*)samples; for(;n>0;n--) { *dstu8++ = *src++ + 128; samples= (short*)dstu8; break; #if HAVE_BIGENDIAN case CODEC_ID_PCM_F64LE: DECODE(int64_t, le64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_F32LE: DECODE(int32_t, le32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16LE: DECODE(int16_t, le16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64BE: case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: case CODEC_ID_PCM_S16BE: #else case CODEC_ID_PCM_F64BE: DECODE(int64_t, be64, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F32BE: case CODEC_ID_PCM_S32BE: DECODE(int32_t, be32, src, samples, n, 0, 0) break; case CODEC_ID_PCM_S16BE: DECODE(int16_t, be16, src, samples, n, 0, 0) break; case CODEC_ID_PCM_F64LE: case CODEC_ID_PCM_F32LE: case CODEC_ID_PCM_S32LE: case CODEC_ID_PCM_S16LE: #endif case CODEC_ID_PCM_U8: memcpy(samples, src, n*sample_size); src += n*sample_size; samples = (short*)((uint8_t*)data + n*sample_size); break; case CODEC_ID_PCM_ZORK: for(;n>0;n--) { int x= *src++; if(x&128) x-= 128; else x = -x; *samples++ = x << 8; break; case CODEC_ID_PCM_ALAW: case CODEC_ID_PCM_MULAW: for(;n>0;n--) { *samples++ = s->table[*src++]; break; case CODEC_ID_PCM_DVD: dst_int32_t = data; n /= avctx->channels; switch (avctx->bits_per_coded_sample) { case 20: while (n--) { c = avctx->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8 &0xf0) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12); src = src8; break; case 24: while (n--) { c = avctx->channels; src8 = src + 4*c; while (c--) { *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8); src = src8; break; default: av_log(avctx, AV_LOG_ERROR, "PCM DVD unsupported sample depth\n"); return -1; break; samples = (short *) dst_int32_t; break; case CODEC_ID_PCM_LXF: dst_int32_t = data; n /= avctx->channels; for (i = 0; i < n; i++) { for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) | ((src8[2] & 0xF) << 8) | src8[1]; for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) { *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) | ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4); src += n * avctx->channels * 5; samples = (short *) dst_int32_t; break; default: return -1; *[[enchante]] = (uint8_t *)samples - (uint8_t *)data; return src - buf;[Succeeded / Failed / Skipped / Total] 648 / 61 / 406 / 1115:  41%|     | 1115/2690 [12:41:57<17:56:18, 41.00s/it][Succeeded / Failed / Skipped / Total] 648 / 61 / 406 / 1115:  41%|     | 1116/2690 [12:42:02<17:54:46, 40.97s/it][Succeeded / Failed / Skipped / Total] 649 / 61 / 406 / 1116:  41%|     | 1116/2690 [12:42:02<17:54:46, 40.97s/it][Succeeded / Failed / Skipped / Total] 649 / 61 / 406 / 1116:  42%|     | 1117/2690 [12:42:02<17:53:08, 40.93s/it][Succeeded / Failed / Skipped / Total] 649 / 61 / 407 / 1117:  42%|     | 1117/2690 [12:42:02<17:53:08, 40.93s/it][Succeeded / Failed / Skipped / Total] 649 / 61 / 407 / 1117:  42%|     | 1118/2690 [12:43:12<17:53:08, 40.96s/it][Succeeded / Failed / Skipped / Total] 650 / 61 / 407 / 1118:  42%|     | 1118/2690 [12:43:12<17:53:08, 40.96s/it][Succeeded / Failed / Skipped / Total] 650 / 61 / 407 / 1118:  42%|     | 1119/2690 [12:43:15<17:51:34, 40.93s/it][Succeeded / Failed / Skipped / Total] 651 / 61 / 407 / 1119:  42%|     | 1119/2690 [12:43:15<17:51:34, 40.93s/it][Succeeded / Failed / Skipped / Total] 651 / 61 / 407 / 1119:  42%|     | 1120/2690 [12:43:16<17:49:56, 40.89s/it][Succeeded / Failed / Skipped / Total] 651 / 61 / 408 / 1120:  42%|     | 1120/2690 [12:43:16<17:49:56, 40.89s/it][Succeeded / Failed / Skipped / Total] 651 / 61 / 408 / 1120:  42%|     | 1121/2690 [12:44:29<17:50:00, 40.92s/it]
--------------------------------------------- Result 1116 ---------------------------------------------
[[0 (89%)]] --> [[0 (47%)]] --> Socre: 0.5279592275619507

[[[[Adv]]]]: static uint64_t boston_platreg_read(void *[[opaque]], hwaddr addr, unsigned size) { BostonState *[[s]] = [[opaque]]; uint32_t gic_freq, val; if (size != 4) { qemu_log_mask(LOG_UNIMP, "%uB platform register read", size); return 0; } switch (addr & 0xffff) { case PLAT_FPGA_BUILD: case PLAT_CORE_CL: case PLAT_WRAPPER_CL: return 0; case PLAT_DDR3_STATUS: return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED; case PLAT_MMCM_DIV: gic_freq = mips_gictimer_get_freq([[s]]->cps->gic.gic_timer) / 1000000; val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT; val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT; val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT; val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT; return val; case PLAT_BUILD_CFG: val = PLAT_BUILD_CFG_PCIE0_EN; val |= PLAT_BUILD_CFG_PCIE1_EN; val |= PLAT_BUILD_CFG_PCIE2_EN; return val; case PLAT_DDR_CFG: val = [[s]]->mach->ram_size / G_BYTE; assert(!(val & ~PLAT_DDR_CFG_SIZE)); val |= PLAT_DDR_CFG_MHZ; return val; default: qemu_log_mask(LOG_UNIMP, "Read platform register 0x%" HWADDR_PRIx, addr & 0xffff); return 0; } }

[[[[Adv]]]]: static uint64_t boston_platreg_read(void *[[perplexing]], hwaddr addr, unsigned size) { BostonState *[[at]] = [[perplexing]]; uint32_t gic_freq, val; if (size != 4) { qemu_log_mask(LOG_UNIMP, "%uB platform register read", size); return 0; } switch (addr & 0xffff) { case PLAT_FPGA_BUILD: case PLAT_CORE_CL: case PLAT_WRAPPER_CL: return 0; case PLAT_DDR3_STATUS: return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED; case PLAT_MMCM_DIV: gic_freq = mips_gictimer_get_freq([[at]]->cps->gic.gic_timer) / 1000000; val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT; val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT; val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT; val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT; return val; case PLAT_BUILD_CFG: val = PLAT_BUILD_CFG_PCIE0_EN; val |= PLAT_BUILD_CFG_PCIE1_EN; val |= PLAT_BUILD_CFG_PCIE2_EN; return val; case PLAT_DDR_CFG: val = [[at]]->mach->ram_size / G_BYTE; assert(!(val & ~PLAT_DDR_CFG_SIZE)); val |= PLAT_DDR_CFG_MHZ; return val; default: qemu_log_mask(LOG_UNIMP, "Read platform register 0x%" HWADDR_PRIx, addr & 0xffff); return 0; } }
--------------------------------------------- Result 1117 ---------------------------------------------
[[0 (69%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref) { AResampleContext *aresample = inlink->dst->priv; const int n_in = insamplesref->audio->nb_samples; int n_out = FFMAX(n_in * aresample->ratio * 2, 1); AVFilterLink *const outlink = inlink->dst->outputs[0]; AVFilterBufferRef *outsamplesref = ff_get_audio_buffer(outlink, AV_PERM_WRITE, n_out); int ret; if(!outsamplesref) return AVERROR(ENOMEM); avfilter_copy_buffer_ref_props(outsamplesref, insamplesref); outsamplesref->format = outlink->format; outsamplesref->audio->channel_layout = outlink->channel_layout; outsamplesref->audio->sample_rate = outlink->sample_rate; if(insamplesref->pts != AV_NOPTS_VALUE) { int64_t inpts = av_rescale(insamplesref->pts, inlink->time_base.num * (int64_t)outlink->sample_rate * inlink->sample_rate, inlink->time_base.den); int64_t outpts= swr_next_pts(aresample->swr, inpts); aresample->next_pts = outsamplesref->pts = (outpts + inlink->sample_rate/2) / inlink->sample_rate; } else { outsamplesref->pts = AV_NOPTS_VALUE; } n_out = swr_convert(aresample->swr, outsamplesref->extended_data, n_out, (void *)insamplesref->extended_data, n_in); if (n_out <= 0) { avfilter_unref_buffer(outsamplesref); avfilter_unref_buffer(insamplesref); return 0; } outsamplesref->audio->nb_samples = n_out; ret = ff_filter_samples(outlink, outsamplesref); aresample->req_fullfilled= 1; avfilter_unref_buffer(insamplesref); return ret; }
--------------------------------------------- Result 1118 ---------------------------------------------
[[0 (25%)]] --> [[0 (53%)]] --> Socre: 0.5327499508857727

[[[[Adv]]]]: static int mov_read_ctts(MOVContext *c, ByteIOContext *pb, MOV_atom_t [[atom]]) { AVStream *[[st]] = c->fc->streams[c->fc->nb_streams-1]; MOVStreamContext *sc = [[st]]->priv_data; unsigned int i, entries; get_byte(pb); get_be24(pb); entries = get_be32(pb); if(entries >= UINT_MAX / sizeof(MOV_stts_t)) return -1; sc->ctts_count = entries; sc->ctts_data = av_malloc(entries * sizeof(MOV_stts_t)); if (!sc->ctts_data) return -1; dprintf(c->fc, "track[%i].ctts.entries = %i\n", c->fc->nb_streams-1, entries); for(i=0; i<entries; i++) { int count =get_be32(pb); int duration =get_be32(pb); if (duration < 0) { av_log(c->fc, AV_LOG_ERROR, "negative ctts, ignoring\n"); sc->ctts_count = 0; url_fskip(pb, 8 * (entries - i - 1)); break; } sc->ctts_data[i].count = count; sc->ctts_data[i].duration= duration; sc->time_rate= ff_gcd(sc->time_rate, duration); } return 0; }

[[[[Adv]]]]: static int mov_read_ctts(MOVContext *c, ByteIOContext *pb, MOV_atom_t [[molecular]]) { AVStream *[[avenida]] = c->fc->streams[c->fc->nb_streams-1]; MOVStreamContext *sc = [[avenida]]->priv_data; unsigned int i, entries; get_byte(pb); get_be24(pb); entries = get_be32(pb); if(entries >= UINT_MAX / sizeof(MOV_stts_t)) return -1; sc->ctts_count = entries; sc->ctts_data = av_malloc(entries * sizeof(MOV_stts_t)); if (!sc->ctts_data) return -1; dprintf(c->fc, "track[%i].ctts.entries = %i\n", c->fc->nb_streams-1, entries); for(i=0; i<entries; i++) { int count =get_be32(pb); int duration =get_be32(pb); if (duration < 0) { av_log(c->fc, AV_LOG_ERROR, "negative ctts, ignoring\n"); sc->ctts_count = 0; url_fskip(pb, 8 * (entries - i - 1)); break; } sc->ctts_data[i].count = count; sc->ctts_data[i].duration= duration; sc->time_rate= ff_gcd(sc->time_rate, duration); } return 0; }
--------------------------------------------- Result 1119 ---------------------------------------------
[[0 (75%)]] --> [[0 (35%)]] --> Socre: 0.6492744982242584

[[[[Adv]]]]: int64_t av_get_int(void *obj, const char *name, const AVOption **[[o_out]]) { int64_t intnum=1; double num=1; int den=1; av_get_number(obj, name, [[o_out]], &num, &den, &intnum); return num*intnum/den; }

[[[[Adv]]]]: int64_t av_get_int(void *obj, const char *name, const AVOption **[[hatchet]]) { int64_t intnum=1; double num=1; int den=1; av_get_number(obj, name, [[hatchet]], &num, &den, &intnum); return num*intnum/den; }
--------------------------------------------- Result 1120 ---------------------------------------------
[[0 (32%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void commit_active_start(BlockDriverState *bs, BlockDriverState *base, int64_t speed, BlockdevOnError on_error, BlockDriverCompletionFunc *cb, void *opaque, Error **errp) { int64_t length, base_length; int orig_base_flags; orig_base_flags = bdrv_get_flags(base); if (bdrv_reopen(base, bs->open_flags, errp)) { return; } length = bdrv_getlength(bs); if (length < 0) { error_setg(errp, "Unable to determine length of %s", bs->filename); goto error_restore_flags; } base_length = bdrv_getlength(base); if (base_length < 0) { error_setg(errp, "Unable to determine length of %s", base->filename); goto error_restore_flags; } if (length > base_length) { if (bdrv_truncate(base, length) < 0) { error_setg(errp, "Top image %s is larger than base image %s, and " "resize of base image failed", bs->filename, base->filename); goto error_restore_flags; } } bdrv_ref(base); mirror_start_job(bs, base, speed, 0, 0, on_error, on_error, cb, opaque, errp, &commit_active_job_driver, "False" != "False", base); if (error_is_set(errp)) { goto error_restore_flags; } return; error_restore_flags: bdrv_reopen(base, orig_base_flags, NULL); return; }
--------------------------------------------- Result 1121 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 652 / 61 / 408 / 1121:  42%|     | 1121/2690 [12:44:29<17:50:00, 40.92s/it][Succeeded / Failed / Skipped / Total] 652 / 61 / 408 / 1121:  42%|     | 1122/2690 [12:44:45<17:48:44, 40.90s/it][Succeeded / Failed / Skipped / Total] 653 / 61 / 408 / 1122:  42%|     | 1122/2690 [12:44:45<17:48:44, 40.90s/it][Succeeded / Failed / Skipped / Total] 653 / 61 / 408 / 1122:  42%|     | 1123/2690 [12:44:50<17:47:14, 40.86s/it][Succeeded / Failed / Skipped / Total] 654 / 61 / 408 / 1123:  42%|     | 1123/2690 [12:44:50<17:47:14, 40.86s/it][Succeeded / Failed / Skipped / Total] 654 / 61 / 408 / 1123:  42%|     | 1124/2690 [12:48:32<17:50:45, 41.03s/it][Succeeded / Failed / Skipped / Total] 655 / 61 / 408 / 1124:  42%|     | 1124/2690 [12:48:32<17:50:45, 41.03s/it][Succeeded / Failed / Skipped / Total] 655 / 61 / 408 / 1124:  42%|     | 1125/2690 [12:48:41<17:49:19, 41.00s/it][[0 (88%)]] --> [[0 (36%)]] --> Socre: 0.6439247131347656

[[[[Adv]]]]: static int matroska_decode_buffer(uint8_t** buf, int* buf_size, MatroskaTrack *track) { MatroskaTrackEncoding *[[encodings]] = track->encodings.elem; uint8_t* data = *buf; int isize = *buf_size; uint8_t* pkt_data = NULL; int [[pkt_size]] = isize; int result = 0; int olen; switch ([[encodings]][0].compression.algo) { case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP: return [[encodings]][0].compression.settings.size; case MATROSKA_TRACK_ENCODING_COMP_LZO: do { olen = [[pkt_size]] *= 3; pkt_data = av_realloc(pkt_data, [[pkt_size]]+AV_LZO_OUTPUT_PADDING); result = av_lzo1x_decode(pkt_data, &olen, data, &isize); } while (result==AV_LZO_OUTPUT_FULL && [[pkt_size]]<10000000); if (result) goto failed; [[pkt_size]] -= olen; break; #if CONFIG_ZLIB case MATROSKA_TRACK_ENCODING_COMP_ZLIB: { z_stream zstream = {0}; if (inflateInit(&zstream) != Z_OK) zstream.next_in = data; zstream.avail_in = isize; do { [[pkt_size]] *= 3; pkt_data = av_realloc(pkt_data, [[pkt_size]]); zstream.avail_out = [[pkt_size]] - zstream.total_out; zstream.next_out = pkt_data + zstream.total_out; result = inflate(&zstream, Z_NO_FLUSH); } while (result==Z_OK && [[pkt_size]]<10000000); [[pkt_size]] = zstream.total_out; inflateEnd(&zstream); if (result != Z_STREAM_END) goto failed; break; } #endif #if CONFIG_BZLIB case MATROSKA_TRACK_ENCODING_COMP_BZLIB: { bz_stream bzstream = {0}; if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK) bzstream.next_in = data; bzstream.avail_in = isize; do { [[pkt_size]] *= 3; pkt_data = av_realloc(pkt_data, [[pkt_size]]); bzstream.avail_out = [[pkt_size]] - bzstream.total_out_lo32; bzstream.next_out = pkt_data + bzstream.total_out_lo32; result = BZ2_bzDecompress(&bzstream); } while (result==BZ_OK && [[pkt_size]]<10000000); [[pkt_size]] = bzstream.total_out_lo32; BZ2_bzDecompressEnd(&bzstream); if (result != BZ_STREAM_END) goto failed; break; } #endif default: } *buf = pkt_data; *buf_size = [[pkt_size]]; return 0; failed: av_free(pkt_data); }

[[[[Adv]]]]: static int matroska_decode_buffer(uint8_t** buf, int* buf_size, MatroskaTrack *track) { MatroskaTrackEncoding *[[assaulting]] = track->encodings.elem; uint8_t* data = *buf; int isize = *buf_size; uint8_t* pkt_data = NULL; int [[livingstone]] = isize; int result = 0; int olen; switch ([[assaulting]][0].compression.algo) { case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP: return [[assaulting]][0].compression.settings.size; case MATROSKA_TRACK_ENCODING_COMP_LZO: do { olen = [[livingstone]] *= 3; pkt_data = av_realloc(pkt_data, [[livingstone]]+AV_LZO_OUTPUT_PADDING); result = av_lzo1x_decode(pkt_data, &olen, data, &isize); } while (result==AV_LZO_OUTPUT_FULL && [[livingstone]]<10000000); if (result) goto failed; [[livingstone]] -= olen; break; #if CONFIG_ZLIB case MATROSKA_TRACK_ENCODING_COMP_ZLIB: { z_stream zstream = {0}; if (inflateInit(&zstream) != Z_OK) zstream.next_in = data; zstream.avail_in = isize; do { [[livingstone]] *= 3; pkt_data = av_realloc(pkt_data, [[livingstone]]); zstream.avail_out = [[livingstone]] - zstream.total_out; zstream.next_out = pkt_data + zstream.total_out; result = inflate(&zstream, Z_NO_FLUSH); } while (result==Z_OK && [[livingstone]]<10000000); [[livingstone]] = zstream.total_out; inflateEnd(&zstream); if (result != Z_STREAM_END) goto failed; break; } #endif #if CONFIG_BZLIB case MATROSKA_TRACK_ENCODING_COMP_BZLIB: { bz_stream bzstream = {0}; if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK) bzstream.next_in = data; bzstream.avail_in = isize; do { [[livingstone]] *= 3; pkt_data = av_realloc(pkt_data, [[livingstone]]); bzstream.avail_out = [[livingstone]] - bzstream.total_out_lo32; bzstream.next_out = pkt_data + bzstream.total_out_lo32; result = BZ2_bzDecompress(&bzstream); } while (result==BZ_OK && [[livingstone]]<10000000); [[livingstone]] = bzstream.total_out_lo32; BZ2_bzDecompressEnd(&bzstream); if (result != BZ_STREAM_END) goto failed; break; } #endif default: } *buf = pkt_data; *buf_size = [[livingstone]]; return 0; failed: av_free(pkt_data); }
--------------------------------------------- Result 1122 ---------------------------------------------
[[0 (9%)]] --> [[0 (53%)]] --> Socre: 0.5279416441917419

[[[[Adv]]]]: void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr, bool is_write, bool is_exec, int unused, unsigned size) { AlphaCPU *cpu = ALPHA_CPU(cs); CPUAlphaState *[[env]] = &cpu->env; [[env]]->trap_arg0 = addr; [[env]]->trap_arg1 = is_write ? 1 : 0; dynamic_excp([[env]], 0, EXCP_MCHK, 0); }

[[[[Adv]]]]: void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr, bool is_write, bool is_exec, int unused, unsigned size) { AlphaCPU *cpu = ALPHA_CPU(cs); CPUAlphaState *[[angry]] = &cpu->env; [[angry]]->trap_arg0 = addr; [[angry]]->trap_arg1 = is_write ? 1 : 0; dynamic_excp([[angry]], 0, EXCP_MCHK, 0); }
--------------------------------------------- Result 1123 ---------------------------------------------
[[0 (30%)]] --> [[0 (54%)]] --> Socre: 0.5354838371276855

[[[[Adv]]]]: static int virtio_serial_init_pci(PCIDevice *pci_dev) { VirtIOPCIProxy *[[proxy]] = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev); VirtIODevice *vdev; if ([[proxy]]->class_code != PCI_CLASS_COMMUNICATION_OTHER && [[proxy]]->class_code != PCI_CLASS_DISPLAY_OTHER && [[proxy]]->class_code != PCI_CLASS_OTHERS) [[proxy]]->class_code = PCI_CLASS_COMMUNICATION_OTHER; vdev = virtio_serial_init(&pci_dev->qdev, &[[proxy]]->serial); if (!vdev) { return -1; } vdev->nvectors = [[proxy]]->nvectors == DEV_NVECTORS_UNSPECIFIED ? [[proxy]]->serial.max_virtserial_ports + 1 : [[proxy]]->nvectors; virtio_init_pci([[proxy]], vdev, PCI_VENDOR_ID_REDHAT_QUMRANET, PCI_DEVICE_ID_VIRTIO_CONSOLE, [[proxy]]->class_code, 0x00); [[proxy]]->nvectors = vdev->nvectors; return 0; }

[[[[Adv]]]]: static int virtio_serial_init_pci(PCIDevice *pci_dev) { VirtIOPCIProxy *[[alternating]] = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev); VirtIODevice *vdev; if ([[alternating]]->class_code != PCI_CLASS_COMMUNICATION_OTHER && [[alternating]]->class_code != PCI_CLASS_DISPLAY_OTHER && [[alternating]]->class_code != PCI_CLASS_OTHERS) [[alternating]]->class_code = PCI_CLASS_COMMUNICATION_OTHER; vdev = virtio_serial_init(&pci_dev->qdev, &[[alternating]]->serial); if (!vdev) { return -1; } vdev->nvectors = [[alternating]]->nvectors == DEV_NVECTORS_UNSPECIFIED ? [[alternating]]->serial.max_virtserial_ports + 1 : [[alternating]]->nvectors; virtio_init_pci([[alternating]], vdev, PCI_VENDOR_ID_REDHAT_QUMRANET, PCI_DEVICE_ID_VIRTIO_CONSOLE, [[alternating]]->class_code, 0x00); [[alternating]]->nvectors = vdev->nvectors; return 0; }
--------------------------------------------- Result 1124 ---------------------------------------------
[[0 (4%)]] --> [[0 (61%)]] --> Socre: 0.6143012046813965

[[[[Adv]]]]: static CharDriverState *qmp_chardev_open_serial(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **[[errp]]) { ChardevHostdev *serial = backend->serial; int fd; fd = qmp_chardev_open_file_source(serial->device, O_RDWR, [[errp]]); if (fd < 0) { return NULL; } qemu_set_nonblock(fd); return qemu_chr_open_tty_fd(fd); }

[[[[Adv]]]]: static CharDriverState *qmp_chardev_open_serial(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **[[schn]]) { ChardevHostdev *serial = backend->serial; int fd; fd = qmp_chardev_open_file_source(serial->device, O_RDWR, [[schn]]); if (fd < 0) { return NULL; } qemu_set_nonblock(fd); return qemu_chr_open_tty_fd(fd); }
--------------------------------------------- Result 1125 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 656 / 61 / 408 / 1125:  42%|     | 1125/2690 [12:48:41<17:49:19, 41.00s/it][Succeeded / Failed / Skipped / Total] 656 / 61 / 408 / 1125:  42%|     | 1126/2690 [12:50:51<17:50:42, 41.08s/it][Succeeded / Failed / Skipped / Total] 657 / 61 / 408 / 1126:  42%|     | 1126/2690 [12:50:51<17:50:42, 41.08s/it][Succeeded / Failed / Skipped / Total] 657 / 61 / 408 / 1126:  42%|     | 1127/2690 [12:50:54<17:49:08, 41.04s/it][Succeeded / Failed / Skipped / Total] 657 / 62 / 408 / 1127:  42%|     | 1127/2690 [12:50:54<17:49:08, 41.04s/it][Succeeded / Failed / Skipped / Total] 657 / 62 / 408 / 1127:  42%|     | 1128/2690 [12:51:01<17:47:40, 41.01s/it][[0 (33%)]] --> [[0 (50%)]] --> Socre: 0.5038608312606812

[[[[Adv]]]]: void alpha_pci_vga_setup(PCIBus *[[pci_bus]]) { switch (vga_interface_type) { #ifdef CONFIG_SPICE case VGA_QXL: pci_create_simple([[pci_bus]], -1, "qxl-vga"); return; #endif case VGA_CIRRUS: pci_cirrus_vga_init([[pci_bus]]); return; case VGA_VMWARE: if (pci_vmsvga_init([[pci_bus]])) { return; } break; } if (vga_interface_type != VGA_NONE) { pci_vga_init([[pci_bus]]); } }

[[[[Adv]]]]: void alpha_pci_vga_setup(PCIBus *[[rigors]]) { switch (vga_interface_type) { #ifdef CONFIG_SPICE case VGA_QXL: pci_create_simple([[rigors]], -1, "qxl-vga"); return; #endif case VGA_CIRRUS: pci_cirrus_vga_init([[rigors]]); return; case VGA_VMWARE: if (pci_vmsvga_init([[rigors]])) { return; } break; } if (vga_interface_type != VGA_NONE) { pci_vga_init([[rigors]]); } }
--------------------------------------------- Result 1126 ---------------------------------------------
[[0 (6%)]] --> [[0 (50%)]] --> Socre: 0.5045592188835144

[[[[Adv]]]]: struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *[[ta]], qemu_irq irq, omap_clk fclk, omap_clk [[iclk]], qemu_irq txdma, qemu_irq [[rxdma]], CharDriverState *chr) { target_phys_addr_t [[base]] = omap_l4_attach([[ta]], 0, 0); struct omap_uart_s *[[s]] = omap_uart_init([[base]], irq, fclk, [[iclk]], txdma, [[rxdma]], chr); int iomemtype = cpu_register_io_memory(0, omap_uart_readfn, omap_uart_writefn, [[s]]); [[s]]->ta = [[ta]]; [[s]]->base = [[base]]; cpu_register_physical_memory([[s]]->base + 0x20, 0x100, iomemtype); return [[s]]; }

[[[[Adv]]]]: struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *[[vou]], qemu_irq irq, omap_clk fclk, omap_clk [[diving]], qemu_irq txdma, qemu_irq [[keiji]], CharDriverState *chr) { target_phys_addr_t [[reasoned]] = omap_l4_attach([[vou]], 0, 0); struct omap_uart_s *[[en]] = omap_uart_init([[reasoned]], irq, fclk, [[diving]], txdma, [[keiji]], chr); int iomemtype = cpu_register_io_memory(0, omap_uart_readfn, omap_uart_writefn, [[en]]); [[en]]->ta = [[vou]]; [[en]]->base = [[reasoned]]; cpu_register_physical_memory([[en]]->base + 0x20, 0x100, iomemtype); return [[en]]; }
--------------------------------------------- Result 1127 ---------------------------------------------
[[0 (26%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void sdhci_write_block_to_card(SDHCIState *s) { int index = 0; if (s->prnsts & SDHC_SPACE_AVAILABLE) { if (s->norintstsen & SDHC_NISEN_WBUFRDY) { s->norintsts |= SDHC_NIS_WBUFRDY; } sdhci_update_irq(s); return; } if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) { if (s->blkcnt == 0) { return; } else { s->blkcnt--; } } for (index = 0; index < (s->blksize & 0x0fff); index++) { sd_write_data(s->card, s->fifo_buffer[index]); } s->prnsts |= SDHC_SPACE_AVAILABLE; if ((s->trnmod & SDHC_TRNS_MULTI) == 0 || ((s->trnmod & SDHC_TRNS_MULTI) && (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) { SDHCI_GET_CLASS(s)->end_data_transfer(s); } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) { s->norintsts |= SDHC_NIS_WBUFRDY; } if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) && s->blkcnt > 0) { s->prnsts &= ~SDHC_DOING_WRITE; if (s->norintstsen & SDHC_EISEN_BLKGAP) { s->norintsts |= SDHC_EIS_BLKGAP; } SDHCI_GET_CLASS(s)->end_data_transfer(s); } sdhci_update_irq(s); }

[[[[Adv]]]]: static void sdhci_write_block_to_card(SDHCIState *s) { int index = 0; if (s->prnsts & SDHC_SPACE_AVAILABLE) { if (s->norintstsen & SDHC_NISEN_WBUFRDY) { s->norintsts |= SDHC_NIS_WBUFRDY; } sdhci_update_irq(s); return; } if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) { if (s->blkcnt == 0) { return; } else { s->blkcnt--; } } for (index = 0; index < (s->blksize & 0x0fff); index++) { sd_write_data(s->card, s->fifo_buffer[index]); } s->prnsts |= SDHC_SPACE_AVAILABLE; if ((s->trnmod & SDHC_TRNS_MULTI) == 0 || ((s->trnmod & SDHC_TRNS_MULTI) && (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) { SDHCI_GET_CLASS(s)->end_data_transfer(s); } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) { s->norintsts |= SDHC_NIS_WBUFRDY; } if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) && s->blkcnt > 0) { s->prnsts &= ~SDHC_DOING_WRITE; if (s->norintstsen & SDHC_EISEN_BLKGAP) { s->norintsts |= SDHC_EIS_BLKGAP; } SDHCI_GET_CLASS(s)->end_data_transfer(s); } sdhci_update_irq(s); }
--------------------------------------------- Result 1128 ---------------------------------------------
[[0 (38%)]] --> [[0 (50%)]] --> Socre: 0.5033931732177734

[[[[Adv]]]]: static void QEMU_NORETURN help(void) { const char *[[help_msg]] = QEMU_IMG_VERSION "usage: qemu-img [standard options] command [command options]\n" "QEMU disk image utility\n" "\n" " '-h', '--help' display this help and exit\n" " '-V', '--version' output version information and exit\n" " '-T', '--trace' [[enable=]<pattern>][,events=<file>][,file=<file>]\n" " specify tracing options\n" "\n" "Command syntax:\n" #define DEF(option, callback, arg_string) \ " " arg_string "\n" #include "qemu-img-cmds.h" #undef DEF #undef GEN_DOCS "\n" "Command parameters:\n" " 'filename' is a disk image filename\n" " 'objectdef' is a QEMU user creatable object definition. See the qemu(1)\n" " manual page for a description of the object properties. The most common\n" " object type is a 'secret', which is used to supply passwords and/or\n" " encryption keys.\n" " 'fmt' is the disk image format. It is guessed automatically in most cases\n" " 'cache' is the cache mode used to write the output disk image, the valid\n" " options are: 'none', 'writeback' (default, except for convert), 'writethrough',\n" " 'directsync' and 'unsafe' (default for convert)\n" " 'src_cache' is the cache mode used to read input disk images, the valid\n" " options are the same as for the 'cache' option\n" " 'size' is the disk image size in bytes. Optional suffixes\n" " 'k' or 'K' (kilobyte, 1024), 'M' (megabyte, 1024k), 'G' (gigabyte, 1024M),\n" " 'T' (terabyte, 1024G), 'P' (petabyte, 1024T) and 'E' (exabyte, 1024P) are\n" " supported. 'b' is ignored.\n" " 'output_filename' is the destination disk image filename\n" " 'output_fmt' is the destination format\n" " 'options' is a comma separated list of format specific options in a\n" " name=value format. Use -o ? for an overview of the options supported by the\n" " used format\n" " 'snapshot_param' is param used for internal snapshot, format\n" " is 'snapshot.id=[ID],snapshot.name=[NAME]', or\n" " '[ID_OR_NAME]'\n" " 'snapshot_id_or_name' is deprecated, use 'snapshot_param'\n" " instead\n" " '-c' indicates that target image must be compressed (qcow format only)\n" " '-u' enables unsafe rebasing. It is assumed that old and new backing file\n" " match exactly. The image doesn't need a working backing file before\n" " rebasing in this case (useful for renaming the backing file)\n" " '-h' with or without a command shows this help and lists the supported formats\n" " '-p' show progress of command (only certain commands)\n" " '-q' use Quiet mode - do not print any output (except errors)\n" " '-S' indicates the consecutive number of bytes (defaults to 4k) that must\n" " contain only zeros for qemu-img to create a sparse image during\n" " conversion. If the number of bytes is 0, the source will not be scanned for\n" " unallocated or zero sectors, and the destination image will always be\n" " fully allocated\n" " '--output' takes the format in which the output must be done (human or json)\n" " '-n' skips the target volume creation (useful if the volume is created\n" " prior to running qemu-img)\n" "\n" "Parameters to check subcommand:\n" " '-r' tries to repair any inconsistencies that are found during the check.\n" " '-r leaks' repairs only cluster leaks, whereas '-r all' fixes all\n" " kinds of errors, with a higher risk of choosing the wrong fix or\n" " hiding corruption that has already occurred.\n" "\n" "Parameters to convert subcommand:\n" " '-m' specifies how many coroutines work in parallel during the convert\n" " process (defaults to 8)\n" " '-W' allow to write to the target out of order rather than sequential\n" "\n" "Parameters to snapshot subcommand:\n" " 'snapshot' is the name of the snapshot to create, apply or delete\n" " '-a' applies a snapshot (revert disk to saved state)\n" " '-c' creates a snapshot\n" " '-d' deletes a snapshot\n" " '-l' lists all snapshots in the given image\n" "\n" "Parameters to compare subcommand:\n" " '-f' first image format\n" " '-F' second image format\n" " '-s' run in Strict mode - fail on different image size or sector allocation\n" "\n" "Parameters to dd subcommand:\n" " 'bs=BYTES' read and write up to BYTES bytes at a time " "(default: 512)\n" " 'count=N' copy only N input blocks\n" " 'if=FILE' read from FILE\n" " 'of=FILE' write to FILE\n" " 'skip=N' skip N bs-sized blocks at the start of input\n"; printf("%s\nSupported formats:", [[help_msg]]); bdrv_iterate_format(format_print, NULL); printf("\n"); exit(EXIT_SUCCESS); }

[[[[Adv]]]]: static void QEMU_NORETURN help(void) { const char *[[riordan]] = QEMU_IMG_VERSION "usage: qemu-img [standard options] command [command options]\n" "QEMU disk image utility\n" "\n" " '-h', '--help' display this help and exit\n" " '-V', '--version' output version information and exit\n" " '-T', '--trace' [[enable=]<pattern>][,events=<file>][,file=<file>]\n" " specify tracing options\n" "\n" "Command syntax:\n" #define DEF(option, callback, arg_string) \ " " arg_string "\n" #include "qemu-img-cmds.h" #undef DEF #undef GEN_DOCS "\n" "Command parameters:\n" " 'filename' is a disk image filename\n" " 'objectdef' is a QEMU user creatable object definition. See the qemu(1)\n" " manual page for a description of the object properties. The most common\n" " object type is a 'secret', which is used to supply passwords and/or\n" " encryption keys.\n" " 'fmt' is the disk image format. It is guessed automatically in most cases\n" " 'cache' is the cache mode used to write the output disk image, the valid\n" " options are: 'none', 'writeback' (default, except for convert), 'writethrough',\n" " 'directsync' and 'unsafe' (default for convert)\n" " 'src_cache' is the cache mode used to read input disk images, the valid\n" " options are the same as for the 'cache' option\n" " 'size' is the disk image size in bytes. Optional suffixes\n" " 'k' or 'K' (kilobyte, 1024), 'M' (megabyte, 1024k), 'G' (gigabyte, 1024M),\n" " 'T' (terabyte, 1024G), 'P' (petabyte, 1024T) and 'E' (exabyte, 1024P) are\n" " supported. 'b' is ignored.\n" " 'output_filename' is the destination disk image filename\n" " 'output_fmt' is the destination format\n" " 'options' is a comma separated list of format specific options in a\n" " name=value format. Use -o ? for an overview of the options supported by the\n" " used format\n" " 'snapshot_param' is param used for internal snapshot, format\n" " is 'snapshot.id=[ID],snapshot.name=[NAME]', or\n" " '[ID_OR_NAME]'\n" " 'snapshot_id_or_name' is deprecated, use 'snapshot_param'\n" " instead\n" " '-c' indicates that target image must be compressed (qcow format only)\n" " '-u' enables unsafe rebasing. It is assumed that old and new backing file\n" " match exactly. The image doesn't need a working backing file before\n" " rebasing in this case (useful for renaming the backing file)\n" " '-h' with or without a command shows this help and lists the supported formats\n" " '-p' show progress of command (only certain commands)\n" " '-q' use Quiet mode - do not print any output (except errors)\n" " '-S' indicates the consecutive number of bytes (defaults to 4k) that must\n" " contain only zeros for qemu-img to create a sparse image during\n" " conversion. If the number of bytes is 0, the source will not be scanned for\n" " unallocated or zero sectors, and the destination image will always be\n" " fully allocated\n" " '--output' takes the format in which the output must be done (human or json)\n" " '-n' skips the target volume creation (useful if the volume is created\n" " prior to running qemu-img)\n" "\n" "Parameters to check subcommand:\n" " '-r' tries to repair any inconsistencies that are found during the check.\n" " '-r leaks' repairs only cluster leaks, whereas '-r all' fixes all\n" " kinds of errors, with a higher risk of choosing the wrong fix or\n" " hiding corruption that has already occurred.\n" "\n" "Parameters to convert subcommand:\n" " '-m' specifies how many coroutines work in parallel during the convert\n" " process (defaults to 8)\n" " '-W' allow to write to the target out of order rather than sequential\n" "\n" "Parameters to snapshot subcommand:\n" " 'snapshot' is the name of the snapshot to create, apply or delete\n" " '-a' applies a snapshot (revert disk to saved state)\n" " '-c' creates a snapshot\n" " '-d' deletes a snapshot\n" " '-l' lists all snapshots in the given image\n" "\n" "Parameters to compare subcommand:\n" " '-f' first image format\n" " '-F' second image format\n" " '-s' run in Strict mode - fail on different image size or sector allocation\n" "\n" "Parameters to dd subcommand:\n" " 'bs=BYTES' read and write up to BYTES bytes at a time " "(default: 512)\n" " 'count=N' copy only N input blocks\n" " 'if=FILE' read from FILE\n" " 'of=FILE' write to FILE\n" " 'skip=N' skip N bs-sized blocks at the start of input\n"; printf("%s\nSupported formats:", [[riordan]]); bdrv_iterate_format(format_print, NULL); printf("\n"); exit(EXIT_SUCCESS); }[Succeeded / Failed / Skipped / Total] 658 / 62 / 408 / 1128:  42%|     | 1128/2690 [12:51:01<17:47:40, 41.01s/it][Succeeded / Failed / Skipped / Total] 658 / 62 / 408 / 1128:  42%|     | 1129/2690 [12:51:01<17:46:02, 40.98s/it][Succeeded / Failed / Skipped / Total] 659 / 62 / 408 / 1129:  42%|     | 1129/2690 [12:51:01<17:46:02, 40.98s/it][Succeeded / Failed / Skipped / Total] 659 / 62 / 408 / 1129:  42%|     | 1130/2690 [12:51:23<17:44:55, 40.96s/it][Succeeded / Failed / Skipped / Total] 659 / 63 / 408 / 1130:  42%|     | 1130/2690 [12:51:23<17:44:55, 40.96s/it][Succeeded / Failed / Skipped / Total] 659 / 63 / 408 / 1130:  42%|     | 1131/2690 [12:51:24<17:43:19, 40.92s/it][Succeeded / Failed / Skipped / Total] 659 / 63 / 409 / 1131:  42%|     | 1131/2690 [12:51:24<17:43:19, 40.92s/it][Succeeded / Failed / Skipped / Total] 659 / 63 / 409 / 1131:  42%|     | 1132/2690 [12:51:44<17:42:10, 40.91s/it][Succeeded / Failed / Skipped / Total] 660 / 63 / 409 / 1132:  42%|     | 1132/2690 [12:51:44<17:42:10, 40.91s/it][Succeeded / Failed / Skipped / Total] 660 / 63 / 409 / 1132:  42%|     | 1133/2690 [12:51:50<17:40:40, 40.87s/it]
--------------------------------------------- Result 1129 ---------------------------------------------
[[0 (6%)]] --> [[0 (54%)]] --> Socre: 0.5440208315849304

[[[[Adv]]]]: static void coroutine_fn bdrv_create_co_entry(void *opaque) { Error *local_err = NULL; int [[ret]]; CreateCo *[[cco]] = opaque; assert([[cco]]->drv); [[ret]] = [[cco]]->drv->bdrv_create([[cco]]->filename, [[cco]]->opts, &local_err); if (local_err) { error_propagate(&[[cco]]->err, local_err); } [[cco]]->ret = [[ret]]; }

[[[[Adv]]]]: static void coroutine_fn bdrv_create_co_entry(void *opaque) { Error *local_err = NULL; int [[retirees]]; CreateCo *[[annoyances]] = opaque; assert([[annoyances]]->drv); [[retirees]] = [[annoyances]]->drv->bdrv_create([[annoyances]]->filename, [[annoyances]]->opts, &local_err); if (local_err) { error_propagate(&[[annoyances]]->err, local_err); } [[annoyances]]->ret = [[retirees]]; }
--------------------------------------------- Result 1130 ---------------------------------------------
[[0 (7%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void helper_mtc0_entryhi(CPUMIPSState *env, target_ulong arg1) { target_ulong old, val, mask; mask = (TARGET_PAGE_MASK << 1) | env->CP0_EntryHi_ASID_mask; if (((env->CP0_Config4 >> CP0C4_IE) & 0x3) >= 2) { mask |= 1 << CP0EnHi_EHINV; } #if defined(TARGET_MIPS64) if (env->insn_flags & ISA_MIPS32R6) { int entryhi_r = extract64(arg1, 62, 2); int config0_at = extract32(env->CP0_Config0, 13, 2); bool no_supervisor = (env->CP0_Status_rw_bitmask & 0x8) == 0; if ((entryhi_r == 2) || (entryhi_r == 1 && (no_supervisor || config0_at == 1))) { mask &= ~(0x3ull << 62); } } mask &= env->SEGMask; #endif old = env->CP0_EntryHi; val = (arg1 & mask) | (old & ~mask); env->CP0_EntryHi = val; if (env->CP0_Config3 & (1 << CP0C3_MT)) { sync_c0_entryhi(env, env->current_tc); } if ((old & env->CP0_EntryHi_ASID_mask) != (val & env->CP0_EntryHi_ASID_mask)) { cpu_mips_tlb_flush(env); } }

[[[[Adv]]]]: void helper_mtc0_entryhi(CPUMIPSState *env, target_ulong arg1) { target_ulong old, val, mask; mask = (TARGET_PAGE_MASK << 1) | env->CP0_EntryHi_ASID_mask; if (((env->CP0_Config4 >> CP0C4_IE) & 0x3) >= 2) { mask |= 1 << CP0EnHi_EHINV; } #if defined(TARGET_MIPS64) if (env->insn_flags & ISA_MIPS32R6) { int entryhi_r = extract64(arg1, 62, 2); int config0_at = extract32(env->CP0_Config0, 13, 2); bool no_supervisor = (env->CP0_Status_rw_bitmask & 0x8) == 0; if ((entryhi_r == 2) || (entryhi_r == 1 && (no_supervisor || config0_at == 1))) { mask &= ~(0x3ull << 62); } } mask &= env->SEGMask; #endif old = env->CP0_EntryHi; val = (arg1 & mask) | (old & ~mask); env->CP0_EntryHi = val; if (env->CP0_Config3 & (1 << CP0C3_MT)) { sync_c0_entryhi(env, env->current_tc); } if ((old & env->CP0_EntryHi_ASID_mask) != (val & env->CP0_EntryHi_ASID_mask)) { cpu_mips_tlb_flush(env); } }
--------------------------------------------- Result 1131 ---------------------------------------------
[[0 (5%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: ram_addr_t qemu_ram_addr_from_host_nofail(void *ptr) { ram_addr_t ram_addr; if (qemu_ram_addr_from_host(ptr, &ram_addr)) { fprintf(stderr, "Bad ram pointer %p\n", ptr); abort(); } return ram_addr; }
--------------------------------------------- Result 1132 ---------------------------------------------
[[0 (77%)]] --> [[0 (44%)]] --> Socre: 0.5563338100910187

[[[[Adv]]]]: static int decode_format80(VqaContext *[[s]], int [[src_size]], unsigned char *dest, int dest_size, int check_size) { int dest_index = 0; int count, opcode, start; int [[src_pos]]; unsigned char color; int i; start = bytestream2_tell(&[[s]]->gb); while (bytestream2_tell(&[[s]]->gb) - start < [[src_size]]) { opcode = bytestream2_get_byte(&[[s]]->gb); av_dlog([[s]]->avctx, "opcode %02X: ", opcode); if (opcode == 0x80) break; if (dest_index >= dest_size) { av_log([[s]]->avctx, AV_LOG_ERROR, "decode_format80 problem: dest_index (%d) exceeded dest_size (%d)\n", dest_index, dest_size); return AVERROR_INVALIDDATA; } if (opcode == 0xFF) { count = bytestream2_get_le16(&[[s]]->gb); [[src_pos]] = bytestream2_get_le16(&[[s]]->gb); av_dlog([[s]]->avctx, "(1) copy %X bytes from absolute pos %X\n", count, [[src_pos]]); CHECK_COUNT(); CHECK_COPY([[src_pos]]); for (i = 0; i < count; i++) dest[dest_index + i] = dest[[[src_pos]] + i]; dest_index += count; } else if (opcode == 0xFE) { count = bytestream2_get_le16(&[[s]]->gb); color = bytestream2_get_byte(&[[s]]->gb); av_dlog([[s]]->avctx, "(2) set %X bytes to %02X\n", count, color); CHECK_COUNT(); memset(&dest[dest_index], color, count); dest_index += count; } else if ((opcode & 0xC0) == 0xC0) { count = (opcode & 0x3F) + 3; [[src_pos]] = bytestream2_get_le16(&[[s]]->gb); av_dlog([[s]]->avctx, "(3) copy %X bytes from absolute pos %X\n", count, [[src_pos]]); CHECK_COUNT(); CHECK_COPY([[src_pos]]); for (i = 0; i < count; i++) dest[dest_index + i] = dest[[[src_pos]] + i]; dest_index += count; } else if (opcode > 0x80) { count = opcode & 0x3F; av_dlog([[s]]->avctx, "(4) copy %X bytes from source to dest\n", count); CHECK_COUNT(); bytestream2_get_buffer(&[[s]]->gb, &dest[dest_index], count); dest_index += count; } else { count = ((opcode & 0x70) >> 4) + 3; [[src_pos]] = bytestream2_get_byte(&[[s]]->gb) | ((opcode & 0x0F) << 8); av_dlog([[s]]->avctx, "(5) copy %X bytes from relpos %X\n", count, [[src_pos]]); CHECK_COUNT(); CHECK_COPY(dest_index - [[src_pos]]); for (i = 0; i < count; i++) dest[dest_index + i] = dest[dest_index - [[src_pos]] + i]; dest_index += count; } } if (check_size) if (dest_index < dest_size) av_log([[s]]->avctx, AV_LOG_ERROR, "decode_format80 problem: decode finished with dest_index (%d) < dest_size (%d)\n", dest_index, dest_size); return 0; }

[[[[Adv]]]]: static int decode_format80(VqaContext *[[of]], int [[polje]], unsigned char *dest, int dest_size, int check_size) { int dest_index = 0; int count, opcode, start; int [[sacrament]]; unsigned char color; int i; start = bytestream2_tell(&[[of]]->gb); while (bytestream2_tell(&[[of]]->gb) - start < [[polje]]) { opcode = bytestream2_get_byte(&[[of]]->gb); av_dlog([[of]]->avctx, "opcode %02X: ", opcode); if (opcode == 0x80) break; if (dest_index >= dest_size) { av_log([[of]]->avctx, AV_LOG_ERROR, "decode_format80 problem: dest_index (%d) exceeded dest_size (%d)\n", dest_index, dest_size); return AVERROR_INVALIDDATA; } if (opcode == 0xFF) { count = bytestream2_get_le16(&[[of]]->gb); [[sacrament]] = bytestream2_get_le16(&[[of]]->gb); av_dlog([[of]]->avctx, "(1) copy %X bytes from absolute pos %X\n", count, [[sacrament]]); CHECK_COUNT(); CHECK_COPY([[sacrament]]); for (i = 0; i < count; i++) dest[dest_index + i] = dest[[[sacrament]] + i]; dest_index += count; } else if (opcode == 0xFE) { count = bytestream2_get_le16(&[[of]]->gb); color = bytestream2_get_byte(&[[of]]->gb); av_dlog([[of]]->avctx, "(2) set %X bytes to %02X\n", count, color); CHECK_COUNT(); memset(&dest[dest_index], color, count); dest_index += count; } else if ((opcode & 0xC0) == 0xC0) { count = (opcode & 0x3F) + 3; [[sacrament]] = bytestream2_get_le16(&[[of]]->gb); av_dlog([[of]]->avctx, "(3) copy %X bytes from absolute pos %X\n", count, [[sacrament]]); CHECK_COUNT(); CHECK_COPY([[sacrament]]); for (i = 0; i < count; i++) dest[dest_index + i] = dest[[[sacrament]] + i]; dest_index += count; } else if (opcode > 0x80) { count = opcode & 0x3F; av_dlog([[of]]->avctx, "(4) copy %X bytes from source to dest\n", count); CHECK_COUNT(); bytestream2_get_buffer(&[[of]]->gb, &dest[dest_index], count); dest_index += count; } else { count = ((opcode & 0x70) >> 4) + 3; [[sacrament]] = bytestream2_get_byte(&[[of]]->gb) | ((opcode & 0x0F) << 8); av_dlog([[of]]->avctx, "(5) copy %X bytes from relpos %X\n", count, [[sacrament]]); CHECK_COUNT(); CHECK_COPY(dest_index - [[sacrament]]); for (i = 0; i < count; i++) dest[dest_index + i] = dest[dest_index - [[sacrament]] + i]; dest_index += count; } } if (check_size) if (dest_index < dest_size) av_log([[of]]->avctx, AV_LOG_ERROR, "decode_format80 problem: decode finished with dest_index (%d) < dest_size (%d)\n", dest_index, dest_size); return 0; }
--------------------------------------------- Result 1133 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 661 / 63 / 409 / 1133:  42%|     | 1133/2690 [12:51:50<17:40:40, 40.87s/it][Succeeded / Failed / Skipped / Total] 661 / 63 / 409 / 1133:  42%|     | 1134/2690 [12:51:51<17:39:05, 40.84s/it][Succeeded / Failed / Skipped / Total] 662 / 63 / 409 / 1134:  42%|     | 1134/2690 [12:51:51<17:39:05, 40.84s/it][Succeeded / Failed / Skipped / Total] 662 / 63 / 409 / 1134:  42%|     | 1135/2690 [12:51:59<17:37:39, 40.81s/it][Succeeded / Failed / Skipped / Total] 663 / 63 / 409 / 1135:  42%|     | 1135/2690 [12:51:59<17:37:39, 40.81s/it][Succeeded / Failed / Skipped / Total] 663 / 63 / 409 / 1135:  42%|     | 1136/2690 [12:52:01<17:36:06, 40.78s/it][Succeeded / Failed / Skipped / Total] 664 / 63 / 409 / 1136:  42%|     | 1136/2690 [12:52:01<17:36:06, 40.78s/it][Succeeded / Failed / Skipped / Total] 664 / 63 / 409 / 1136:  42%|     | 1137/2690 [12:52:30<17:35:09, 40.77s/it][[0 (82%)]] --> [[0 (28%)]] --> Socre: 0.7189503610134125

[[[[Adv]]]]: static bool vmxnet3_verify_driver_magic(hwaddr [[dshmem]]) { return (VMXNET3_READ_DRV_SHARED32([[dshmem]], magic) == VMXNET3_REV1_MAGIC); }

[[[[Adv]]]]: static bool vmxnet3_verify_driver_magic(hwaddr [[splinter]]) { return (VMXNET3_READ_DRV_SHARED32([[splinter]], magic) == VMXNET3_REV1_MAGIC); }
--------------------------------------------- Result 1134 ---------------------------------------------
[[0 (51%)]] --> [[0 (44%)]] --> Socre: 0.5626876950263977

[[[[Adv]]]]: static int zero12v_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { int line = 0, ret; const int width = avctx->width; AVFrame *[[pic]] = data; uint16_t *y, *u, *v; const uint8_t *line_end, *src = avpkt->data; int stride = avctx->width * 8 / 3; if (width == 1) { av_log(avctx, AV_LOG_ERROR, "Width 1 not supported.\n"); return AVERROR_INVALIDDATA; } if ( avctx->codec_tag == MKTAG('0', '1', '2', 'v') && avpkt->size % avctx->height == 0 && avpkt->size / avctx->height * 3 >= width * 8) stride = avpkt->size / avctx->height; if (avpkt->size < avctx->height * stride) { av_log(avctx, AV_LOG_ERROR, "Packet too small: %d instead of %d\n", avpkt->size, avctx->height * stride); return AVERROR_INVALIDDATA; } if ((ret = ff_get_buffer(avctx, [[pic]], 0)) < 0) return ret; [[pic]]->pict_type = AV_PICTURE_TYPE_I; [[pic]]->key_frame = 1; y = (uint16_t *)[[pic]]->data[0]; u = (uint16_t *)[[pic]]->data[1]; v = (uint16_t *)[[pic]]->data[2]; line_end = avpkt->data + stride; while (line++ < avctx->height) { while (1) { uint32_t t = AV_RL32(src); src += 4; *u++ = t << 6 & 0xFFC0; *y++ = t >> 4 & 0xFFC0; *v++ = t >> 14 & 0xFFC0; if (src >= line_end - 1) { *y = 0x80; src++; line_end += stride; y = (uint16_t *)([[pic]]->data[0] + line * [[pic]]->linesize[0]); u = (uint16_t *)([[pic]]->data[1] + line * [[pic]]->linesize[1]); v = (uint16_t *)([[pic]]->data[2] + line * [[pic]]->linesize[2]); break; } t = AV_RL32(src); src += 4; *y++ = t << 6 & 0xFFC0; *u++ = t >> 4 & 0xFFC0; *y++ = t >> 14 & 0xFFC0; if (src >= line_end - 2) { if (!(width & 1)) { *y = 0x80; src += 2; } line_end += stride; y = (uint16_t *)([[pic]]->data[0] + line * [[pic]]->linesize[0]); u = (uint16_t *)([[pic]]->data[1] + line * [[pic]]->linesize[1]); v = (uint16_t *)([[pic]]->data[2] + line * [[pic]]->linesize[2]); break; } t = AV_RL32(src); src += 4; *v++ = t << 6 & 0xFFC0; *y++ = t >> 4 & 0xFFC0; *u++ = t >> 14 & 0xFFC0; if (src >= line_end - 1) { *y = 0x80; src++; line_end += stride; y = (uint16_t *)([[pic]]->data[0] + line * [[pic]]->linesize[0]); u = (uint16_t *)([[pic]]->data[1] + line * [[pic]]->linesize[1]); v = (uint16_t *)([[pic]]->data[2] + line * [[pic]]->linesize[2]); break; } t = AV_RL32(src); src += 4; *y++ = t << 6 & 0xFFC0; *v++ = t >> 4 & 0xFFC0; *y++ = t >> 14 & 0xFFC0; if (src >= line_end - 2) { if (width & 1) { *y = 0x80; src += 2; } line_end += stride; y = (uint16_t *)([[pic]]->data[0] + line * [[pic]]->linesize[0]); u = (uint16_t *)([[pic]]->data[1] + line * [[pic]]->linesize[1]); v = (uint16_t *)([[pic]]->data[2] + line * [[pic]]->linesize[2]); break; } } } *got_frame = 1; return avpkt->size; }

[[[[Adv]]]]: static int zero12v_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { int line = 0, ret; const int width = avctx->width; AVFrame *[[crests]] = data; uint16_t *y, *u, *v; const uint8_t *line_end, *src = avpkt->data; int stride = avctx->width * 8 / 3; if (width == 1) { av_log(avctx, AV_LOG_ERROR, "Width 1 not supported.\n"); return AVERROR_INVALIDDATA; } if ( avctx->codec_tag == MKTAG('0', '1', '2', 'v') && avpkt->size % avctx->height == 0 && avpkt->size / avctx->height * 3 >= width * 8) stride = avpkt->size / avctx->height; if (avpkt->size < avctx->height * stride) { av_log(avctx, AV_LOG_ERROR, "Packet too small: %d instead of %d\n", avpkt->size, avctx->height * stride); return AVERROR_INVALIDDATA; } if ((ret = ff_get_buffer(avctx, [[crests]], 0)) < 0) return ret; [[crests]]->pict_type = AV_PICTURE_TYPE_I; [[crests]]->key_frame = 1; y = (uint16_t *)[[crests]]->data[0]; u = (uint16_t *)[[crests]]->data[1]; v = (uint16_t *)[[crests]]->data[2]; line_end = avpkt->data + stride; while (line++ < avctx->height) { while (1) { uint32_t t = AV_RL32(src); src += 4; *u++ = t << 6 & 0xFFC0; *y++ = t >> 4 & 0xFFC0; *v++ = t >> 14 & 0xFFC0; if (src >= line_end - 1) { *y = 0x80; src++; line_end += stride; y = (uint16_t *)([[crests]]->data[0] + line * [[crests]]->linesize[0]); u = (uint16_t *)([[crests]]->data[1] + line * [[crests]]->linesize[1]); v = (uint16_t *)([[crests]]->data[2] + line * [[crests]]->linesize[2]); break; } t = AV_RL32(src); src += 4; *y++ = t << 6 & 0xFFC0; *u++ = t >> 4 & 0xFFC0; *y++ = t >> 14 & 0xFFC0; if (src >= line_end - 2) { if (!(width & 1)) { *y = 0x80; src += 2; } line_end += stride; y = (uint16_t *)([[crests]]->data[0] + line * [[crests]]->linesize[0]); u = (uint16_t *)([[crests]]->data[1] + line * [[crests]]->linesize[1]); v = (uint16_t *)([[crests]]->data[2] + line * [[crests]]->linesize[2]); break; } t = AV_RL32(src); src += 4; *v++ = t << 6 & 0xFFC0; *y++ = t >> 4 & 0xFFC0; *u++ = t >> 14 & 0xFFC0; if (src >= line_end - 1) { *y = 0x80; src++; line_end += stride; y = (uint16_t *)([[crests]]->data[0] + line * [[crests]]->linesize[0]); u = (uint16_t *)([[crests]]->data[1] + line * [[crests]]->linesize[1]); v = (uint16_t *)([[crests]]->data[2] + line * [[crests]]->linesize[2]); break; } t = AV_RL32(src); src += 4; *y++ = t << 6 & 0xFFC0; *v++ = t >> 4 & 0xFFC0; *y++ = t >> 14 & 0xFFC0; if (src >= line_end - 2) { if (width & 1) { *y = 0x80; src += 2; } line_end += stride; y = (uint16_t *)([[crests]]->data[0] + line * [[crests]]->linesize[0]); u = (uint16_t *)([[crests]]->data[1] + line * [[crests]]->linesize[1]); v = (uint16_t *)([[crests]]->data[2] + line * [[crests]]->linesize[2]); break; } } } *got_frame = 1; return avpkt->size; }
--------------------------------------------- Result 1135 ---------------------------------------------
[[0 (3%)]] --> [[0 (52%)]] --> Socre: 0.5155726075172424

[[[[Adv]]]]: static inline int test_bit(uint32_t *[[field]], int bit) { return ([[field]][bit >> 5] & 1 << (bit & 0x1F)) != 0; }

[[[[Adv]]]]: static inline int test_bit(uint32_t *[[orbs]], int bit) { return ([[orbs]][bit >> 5] & 1 << (bit & 0x1F)) != 0; }
--------------------------------------------- Result 1136 ---------------------------------------------
[[0 (80%)]] --> [[0 (26%)]] --> Socre: 0.7352303564548492

[[[[Adv]]]]: static void piix3_class_init(ObjectClass *klass, void *data) { DeviceClass *[[dc]] = DEVICE_CLASS(klass); PCIDeviceClass *k = PCI_DEVICE_CLASS(klass); [[dc]]->desc = "ISA bridge"; [[dc]]->vmsd = &vmstate_piix3; [[dc]]->no_user = 1, k->no_hotplug = 1; k->init = piix3_initfn; k->config_write = piix3_write_config; k->vendor_id = PCI_VENDOR_ID_INTEL; k->device_id = PCI_DEVICE_ID_INTEL_82371SB_0; k->class_id = PCI_CLASS_BRIDGE_ISA; }

[[[[Adv]]]]: static void piix3_class_init(ObjectClass *klass, void *data) { DeviceClass *[[montgomery]] = DEVICE_CLASS(klass); PCIDeviceClass *k = PCI_DEVICE_CLASS(klass); [[montgomery]]->desc = "ISA bridge"; [[montgomery]]->vmsd = &vmstate_piix3; [[montgomery]]->no_user = 1, k->no_hotplug = 1; k->init = piix3_initfn; k->config_write = piix3_write_config; k->vendor_id = PCI_VENDOR_ID_INTEL; k->device_id = PCI_DEVICE_ID_INTEL_82371SB_0; k->class_id = PCI_CLASS_BRIDGE_ISA; }
--------------------------------------------- Result 1137 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 665 / 63 / 409 / 1137:  42%|     | 1137/2690 [12:52:30<17:35:09, 40.77s/it][Succeeded / Failed / Skipped / Total] 665 / 63 / 409 / 1137:  42%|     | 1138/2690 [12:52:45<17:33:53, 40.74s/it][[0 (87%)]] --> [[0 (16%)]] --> Socre: 0.8422774374485016

[[[[Adv]]]]: qio_channel_websock_source_dispatch(GSource *source, GSourceFunc callback, gpointer user_data) { QIOChannelFunc [[func]] = (QIOChannelFunc)callback; QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source; GIOCondition cond = 0; if (wsource->wioc->rawinput.offset) { cond |= G_IO_IN; } if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) { cond |= G_IO_OUT; } return (*[[func]])(QIO_CHANNEL(wsource->wioc), (cond & wsource->condition), user_data); }

[[[[Adv]]]]: qio_channel_websock_source_dispatch(GSource *source, GSourceFunc callback, gpointer user_data) { QIOChannelFunc [[activator]] = (QIOChannelFunc)callback; QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source; GIOCondition cond = 0; if (wsource->wioc->rawinput.offset) { cond |= G_IO_IN; } if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) { cond |= G_IO_OUT; } return (*[[activator]])(QIO_CHANNEL(wsource->wioc), (cond & wsource->condition), user_data); }
--------------------------------------------- Result 1138 ---------------------------------------------
[[0 (16%)]] --> [[0 (74%)]] --> Socre: 0.7430775165557861

[[[[Adv]]]]: static void acpi_dsdt_add_pci(Aml *scope, const MemMapEntry *memmap, uint32_t irq, bool use_highmem) { Aml *method, *crs, *ifctx, *UUID, *ifctx1, *elsectx, *buf; int i, bus_no; hwaddr base_mmio = memmap[VIRT_PCIE_MMIO].base; hwaddr size_mmio = memmap[VIRT_PCIE_MMIO].size; hwaddr base_pio = memmap[VIRT_PCIE_PIO].base; hwaddr size_pio = memmap[VIRT_PCIE_PIO].size; hwaddr base_ecam = memmap[VIRT_PCIE_ECAM].base; hwaddr size_ecam = memmap[VIRT_PCIE_ECAM].size; int [[nr_pcie_buses]] = size_ecam / PCIE_MMCFG_SIZE_MIN; Aml *dev = aml_device("%s", "PCI0"); aml_append(dev, aml_name_decl("_HID", aml_string("PNP0A08"))); aml_append(dev, aml_name_decl("_CID", aml_string("PNP0A03"))); aml_append(dev, aml_name_decl("_SEG", aml_int(0))); aml_append(dev, aml_name_decl("_BBN", aml_int(0))); aml_append(dev, aml_name_decl("_ADR", aml_int(0))); aml_append(dev, aml_name_decl("_UID", aml_string("PCI0"))); aml_append(dev, aml_name_decl("_STR", aml_unicode("PCIe 0 Device"))); aml_append(dev, aml_name_decl("_CCA", aml_int(1))); Aml *rt_pkg = aml_package([[nr_pcie_buses]] * PCI_NUM_PINS); for (bus_no = 0; bus_no < [[nr_pcie_buses]]; bus_no++) { for (i = 0; i < PCI_NUM_PINS; i++) { int gsi = (i + bus_no) % PCI_NUM_PINS; Aml *pkg = aml_package(4); aml_append(pkg, aml_int((bus_no << 16) | 0xFFFF)); aml_append(pkg, aml_int(i)); aml_append(pkg, aml_name("GSI%d", gsi)); aml_append(pkg, aml_int(0)); aml_append(rt_pkg, pkg); } } aml_append(dev, aml_name_decl("_PRT", rt_pkg)); for (i = 0; i < PCI_NUM_PINS; i++) { uint32_t irqs = irq + i; Aml *dev_gsi = aml_device("GSI%d", i); aml_append(dev_gsi, aml_name_decl("_HID", aml_string("PNP0C0F"))); aml_append(dev_gsi, aml_name_decl("_UID", aml_int(0))); crs = aml_resource_template(); aml_append(crs, aml_interrupt(AML_CONSUMER, AML_LEVEL, AML_ACTIVE_HIGH, AML_EXCLUSIVE, &irqs, 1)); aml_append(dev_gsi, aml_name_decl("_PRS", crs)); crs = aml_resource_template(); aml_append(crs, aml_interrupt(AML_CONSUMER, AML_LEVEL, AML_ACTIVE_HIGH, AML_EXCLUSIVE, &irqs, 1)); aml_append(dev_gsi, aml_name_decl("_CRS", crs)); method = aml_method("_SRS", 1, AML_NOTSERIALIZED); aml_append(dev_gsi, method); aml_append(dev, dev_gsi); } method = aml_method("_CBA", 0, AML_NOTSERIALIZED); aml_append(method, aml_return(aml_int(base_ecam))); aml_append(dev, method); method = aml_method("_CRS", 0, AML_NOTSERIALIZED); Aml *rbuf = aml_resource_template(); aml_append(rbuf, aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE, 0x0000, 0x0000, [[nr_pcie_buses]] - 1, 0x0000, [[nr_pcie_buses]])); aml_append(rbuf, aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED, AML_NON_CACHEABLE, AML_READ_WRITE, 0x0000, base_mmio, base_mmio + size_mmio - 1, 0x0000, size_mmio)); aml_append(rbuf, aml_dword_io(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE, AML_ENTIRE_RANGE, 0x0000, 0x0000, size_pio - 1, base_pio, size_pio)); if (use_highmem) { hwaddr base_mmio_high = memmap[VIRT_PCIE_MMIO_HIGH].base; hwaddr size_mmio_high = memmap[VIRT_PCIE_MMIO_HIGH].size; aml_append(rbuf, aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED, AML_NON_CACHEABLE, AML_READ_WRITE, 0x0000, base_mmio_high, base_mmio_high, 0x0000, size_mmio_high)); } aml_append(method, aml_name_decl("RBUF", rbuf)); aml_append(method, aml_return(rbuf)); aml_append(dev, method); aml_append(dev, aml_name_decl("SUPP", aml_int(0))); aml_append(dev, aml_name_decl("CTRL", aml_int(0))); method = aml_method("_OSC", 4, AML_NOTSERIALIZED); aml_append(method, aml_create_dword_field(aml_arg(3), aml_int(0), "CDW1")); UUID = aml_touuid("33DB4D5B-1FF7-401C-9657-7441C03DD766"); ifctx = aml_if(aml_equal(aml_arg(0), UUID)); aml_append(ifctx, aml_create_dword_field(aml_arg(3), aml_int(4), "CDW2")); aml_append(ifctx, aml_create_dword_field(aml_arg(3), aml_int(8), "CDW3")); aml_append(ifctx, aml_store(aml_name("CDW2"), aml_name("SUPP"))); aml_append(ifctx, aml_store(aml_name("CDW3"), aml_name("CTRL"))); aml_append(ifctx, aml_store(aml_and(aml_name("CTRL"), aml_int(0x1D), NULL), aml_name("CTRL"))); ifctx1 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1)))); aml_append(ifctx1, aml_store(aml_or(aml_name("CDW1"), aml_int(0x08), NULL), aml_name("CDW1"))); aml_append(ifctx, ifctx1); ifctx1 = aml_if(aml_lnot(aml_equal(aml_name("CDW3"), aml_name("CTRL")))); aml_append(ifctx1, aml_store(aml_or(aml_name("CDW1"), aml_int(0x10), NULL), aml_name("CDW1"))); aml_append(ifctx, ifctx1); aml_append(ifctx, aml_store(aml_name("CTRL"), aml_name("CDW3"))); aml_append(ifctx, aml_return(aml_arg(3))); aml_append(method, ifctx); elsectx = aml_else(); aml_append(elsectx, aml_store(aml_or(aml_name("CDW1"), aml_int(4), NULL), aml_name("CDW1"))); aml_append(elsectx, aml_return(aml_arg(3))); aml_append(method, elsectx); aml_append(dev, method); method = aml_method("_DSM", 4, AML_NOTSERIALIZED); UUID = aml_touuid("E5C937D0-3553-4D7A-9117-EA4D19C3434D"); ifctx = aml_if(aml_equal(aml_arg(0), UUID)); ifctx1 = aml_if(aml_equal(aml_arg(2), aml_int(0))); uint8_t byte_list[1] = {1}; buf = aml_buffer(1, byte_list); aml_append(ifctx1, aml_return(buf)); aml_append(ifctx, ifctx1); aml_append(method, ifctx); byte_list[0] = 0; buf = aml_buffer(1, byte_list); aml_append(method, aml_return(buf)); aml_append(dev, method); Aml *dev_rp0 = aml_device("%s", "RP0"); aml_append(dev_rp0, aml_name_decl("_ADR", aml_int(0))); aml_append(dev, dev_rp0); aml_append(scope, dev); }

[[[[Adv]]]]: static void acpi_dsdt_add_pci(Aml *scope, const MemMapEntry *memmap, uint32_t irq, bool use_highmem) { Aml *method, *crs, *ifctx, *UUID, *ifctx1, *elsectx, *buf; int i, bus_no; hwaddr base_mmio = memmap[VIRT_PCIE_MMIO].base; hwaddr size_mmio = memmap[VIRT_PCIE_MMIO].size; hwaddr base_pio = memmap[VIRT_PCIE_PIO].base; hwaddr size_pio = memmap[VIRT_PCIE_PIO].size; hwaddr base_ecam = memmap[VIRT_PCIE_ECAM].base; hwaddr size_ecam = memmap[VIRT_PCIE_ECAM].size; int [[beguine]] = size_ecam / PCIE_MMCFG_SIZE_MIN; Aml *dev = aml_device("%s", "PCI0"); aml_append(dev, aml_name_decl("_HID", aml_string("PNP0A08"))); aml_append(dev, aml_name_decl("_CID", aml_string("PNP0A03"))); aml_append(dev, aml_name_decl("_SEG", aml_int(0))); aml_append(dev, aml_name_decl("_BBN", aml_int(0))); aml_append(dev, aml_name_decl("_ADR", aml_int(0))); aml_append(dev, aml_name_decl("_UID", aml_string("PCI0"))); aml_append(dev, aml_name_decl("_STR", aml_unicode("PCIe 0 Device"))); aml_append(dev, aml_name_decl("_CCA", aml_int(1))); Aml *rt_pkg = aml_package([[beguine]] * PCI_NUM_PINS); for (bus_no = 0; bus_no < [[beguine]]; bus_no++) { for (i = 0; i < PCI_NUM_PINS; i++) { int gsi = (i + bus_no) % PCI_NUM_PINS; Aml *pkg = aml_package(4); aml_append(pkg, aml_int((bus_no << 16) | 0xFFFF)); aml_append(pkg, aml_int(i)); aml_append(pkg, aml_name("GSI%d", gsi)); aml_append(pkg, aml_int(0)); aml_append(rt_pkg, pkg); } } aml_append(dev, aml_name_decl("_PRT", rt_pkg)); for (i = 0; i < PCI_NUM_PINS; i++) { uint32_t irqs = irq + i; Aml *dev_gsi = aml_device("GSI%d", i); aml_append(dev_gsi, aml_name_decl("_HID", aml_string("PNP0C0F"))); aml_append(dev_gsi, aml_name_decl("_UID", aml_int(0))); crs = aml_resource_template(); aml_append(crs, aml_interrupt(AML_CONSUMER, AML_LEVEL, AML_ACTIVE_HIGH, AML_EXCLUSIVE, &irqs, 1)); aml_append(dev_gsi, aml_name_decl("_PRS", crs)); crs = aml_resource_template(); aml_append(crs, aml_interrupt(AML_CONSUMER, AML_LEVEL, AML_ACTIVE_HIGH, AML_EXCLUSIVE, &irqs, 1)); aml_append(dev_gsi, aml_name_decl("_CRS", crs)); method = aml_method("_SRS", 1, AML_NOTSERIALIZED); aml_append(dev_gsi, method); aml_append(dev, dev_gsi); } method = aml_method("_CBA", 0, AML_NOTSERIALIZED); aml_append(method, aml_return(aml_int(base_ecam))); aml_append(dev, method); method = aml_method("_CRS", 0, AML_NOTSERIALIZED); Aml *rbuf = aml_resource_template(); aml_append(rbuf, aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE, 0x0000, 0x0000, [[beguine]] - 1, 0x0000, [[beguine]])); aml_append(rbuf, aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED, AML_NON_CACHEABLE, AML_READ_WRITE, 0x0000, base_mmio, base_mmio + size_mmio - 1, 0x0000, size_mmio)); aml_append(rbuf, aml_dword_io(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE, AML_ENTIRE_RANGE, 0x0000, 0x0000, size_pio - 1, base_pio, size_pio)); if (use_highmem) { hwaddr base_mmio_high = memmap[VIRT_PCIE_MMIO_HIGH].base; hwaddr size_mmio_high = memmap[VIRT_PCIE_MMIO_HIGH].size; aml_append(rbuf, aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED, AML_NON_CACHEABLE, AML_READ_WRITE, 0x0000, base_mmio_high, base_mmio_high, 0x0000, size_mmio_high)); } aml_append(method, aml_name_decl("RBUF", rbuf)); aml_append(method, aml_return(rbuf)); aml_append(dev, method); aml_append(dev, aml_name_decl("SUPP", aml_int(0))); aml_append(dev, aml_name_decl("CTRL", aml_int(0))); method = aml_method("_OSC", 4, AML_NOTSERIALIZED); aml_append(method, aml_create_dword_field(aml_arg(3), aml_int(0), "CDW1")); UUID = aml_touuid("33DB4D5B-1FF7-401C-9657-7441C03DD766"); ifctx = aml_if(aml_equal(aml_arg(0), UUID)); aml_append(ifctx, aml_create_dword_field(aml_arg(3), aml_int(4), "CDW2")); aml_append(ifctx, aml_create_dword_field(aml_arg(3), aml_int(8), "CDW3")); aml_append(ifctx, aml_store(aml_name("CDW2"), aml_name("SUPP"))); aml_append(ifctx, aml_store(aml_name("CDW3"), aml_name("CTRL"))); aml_append(ifctx, aml_store(aml_and(aml_name("CTRL"), aml_int(0x1D), NULL), aml_name("CTRL"))); ifctx1 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1)))); aml_append(ifctx1, aml_store(aml_or(aml_name("CDW1"), aml_int(0x08), NULL), aml_name("CDW1"))); aml_append(ifctx, ifctx1); ifctx1 = aml_if(aml_lnot(aml_equal(aml_name("CDW3"), aml_name("CTRL")))); aml_append(ifctx1, aml_store(aml_or(aml_name("CDW1"), aml_int(0x10), NULL), aml_name("CDW1"))); aml_append(ifctx, ifctx1); aml_append(ifctx, aml_store(aml_name("CTRL"), aml_name("CDW3"))); aml_append(ifctx, aml_return(aml_arg(3))); aml_append(method, ifctx); elsectx = aml_else(); aml_append(elsectx, aml_store(aml_or(aml_name("CDW1"), aml_int(4), NULL), aml_name("CDW1"))); aml_append(elsectx, aml_return(aml_arg(3))); aml_append(method, elsectx); aml_append(dev, method); method = aml_method("_DSM", 4, AML_NOTSERIALIZED); UUID = aml_touuid("E5C937D0-3553-4D7A-9117-EA4D19C3434D"); ifctx = aml_if(aml_equal(aml_arg(0), UUID)); ifctx1 = aml_if(aml_equal(aml_arg(2), aml_int(0))); uint8_t byte_list[1] = {1}; buf = aml_buffer(1, byte_list); aml_append(ifctx1, aml_return(buf)); aml_append(ifctx, ifctx1); aml_append(method, ifctx); byte_list[0] = 0; buf = aml_buffer(1, byte_list); aml_append(method, aml_return(buf)); aml_append(dev, method); Aml *dev_rp0 = aml_device("%s", "RP0"); aml_append(dev_rp0, aml_name_decl("_ADR", aml_int(0))); aml_append(dev, dev_rp0); aml_append(scope, dev); }[Succeeded / Failed / Skipped / Total] 666 / 63 / 409 / 1138:  42%|     | 1138/2690 [12:52:45<17:33:53, 40.74s/it][Succeeded / Failed / Skipped / Total] 666 / 63 / 409 / 1138:  42%|     | 1139/2690 [12:53:12<17:32:53, 40.73s/it][Succeeded / Failed / Skipped / Total] 667 / 63 / 409 / 1139:  42%|     | 1139/2690 [12:53:12<17:32:53, 40.73s/it][Succeeded / Failed / Skipped / Total] 667 / 63 / 409 / 1139:  42%|     | 1140/2690 [12:54:10<17:32:36, 40.75s/it][Succeeded / Failed / Skipped / Total] 668 / 63 / 409 / 1140:  42%|     | 1140/2690 [12:54:10<17:32:36, 40.75s/it][Succeeded / Failed / Skipped / Total] 668 / 63 / 409 / 1140:  42%|     | 1141/2690 [12:54:11<17:31:01, 40.71s/it][Succeeded / Failed / Skipped / Total] 668 / 63 / 410 / 1141:  42%|     | 1141/2690 [12:54:11<17:31:01, 40.71s/it][Succeeded / Failed / Skipped / Total] 668 / 63 / 410 / 1141:  42%|     | 1142/2690 [12:54:14<17:29:30, 40.68s/it][Succeeded / Failed / Skipped / Total] 669 / 63 / 410 / 1142:  42%|     | 1142/2690 [12:54:14<17:29:30, 40.68s/it][Succeeded / Failed / Skipped / Total] 669 / 63 / 410 / 1142:  42%|     | 1143/2690 [12:54:15<17:27:55, 40.64s/it]
--------------------------------------------- Result 1139 ---------------------------------------------
[[0 (23%)]] --> [[0 (53%)]] --> Socre: 0.5340000987052917

[[[[Adv]]]]: static void test_qemu_strtoul_decimal(void) { const char *[[str]] = "0123"; char f = 'X'; const char *[[endptr]] = &f; unsigned long res = 999; int err; err = qemu_strtoul([[str]], &[[endptr]], 10, &res); g_assert_cmpint(err, ==, 0); g_assert_cmpint(res, ==, 123); g_assert([[endptr]] == [[str]] + strlen([[str]])); [[str]] = "123"; res = 999; [[endptr]] = &f; err = qemu_strtoul([[str]], &[[endptr]], 0, &res); g_assert_cmpint(err, ==, 0); g_assert_cmpint(res, ==, 123); g_assert([[endptr]] == [[str]] + strlen([[str]])); }

[[[[Adv]]]]: static void test_qemu_strtoul_decimal(void) { const char *[[std]] = "0123"; char f = 'X'; const char *[[rainey]] = &f; unsigned long res = 999; int err; err = qemu_strtoul([[std]], &[[rainey]], 10, &res); g_assert_cmpint(err, ==, 0); g_assert_cmpint(res, ==, 123); g_assert([[rainey]] == [[std]] + strlen([[std]])); [[std]] = "123"; res = 999; [[rainey]] = &f; err = qemu_strtoul([[std]], &[[rainey]], 0, &res); g_assert_cmpint(err, ==, 0); g_assert_cmpint(res, ==, 123); g_assert([[rainey]] == [[std]] + strlen([[std]])); }
--------------------------------------------- Result 1140 ---------------------------------------------
[[0 (29%)]] --> [[0 (52%)]] --> Socre: 0.5174431800842285

[[[[Adv]]]]: static int vmdk_parent_open(BlockDriverState *bs) { char *p_name; char desc[DESC_SIZE + 1]; BDRVVmdkState *s = bs->opaque; desc[DESC_SIZE] = '\0'; if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) { return -1; } if ((p_name = strstr(desc,"parentFileNameHint")) != NULL) { char *[[end_name]]; p_name += sizeof("parentFileNameHint") + 1; if (([[end_name]] = strchr(p_name,'\"')) == NULL) return -1; if (([[end_name]] - p_name) > sizeof (bs->backing_file) - 1) return -1; pstrcpy(bs->backing_file, [[end_name]] - p_name + 1, p_name); } return 0; }

[[[[Adv]]]]: static int vmdk_parent_open(BlockDriverState *bs) { char *p_name; char desc[DESC_SIZE + 1]; BDRVVmdkState *s = bs->opaque; desc[DESC_SIZE] = '\0'; if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) { return -1; } if ((p_name = strstr(desc,"parentFileNameHint")) != NULL) { char *[[succumb]]; p_name += sizeof("parentFileNameHint") + 1; if (([[succumb]] = strchr(p_name,'\"')) == NULL) return -1; if (([[succumb]] - p_name) > sizeof (bs->backing_file) - 1) return -1; pstrcpy(bs->backing_file, [[succumb]] - p_name + 1, p_name); } return 0; }
--------------------------------------------- Result 1141 ---------------------------------------------
[[0 (80%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void read_guest_mem(void) { uint32_t *guest_mem; gint64 end_time; int i, j; size_t size; g_mutex_lock(data_mutex); end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND; while (!fds_num) { if (!_cond_wait_until(data_cond, data_mutex, end_time)) { g_assert(fds_num); break; } } g_assert_cmpint(fds_num, >, 0); g_assert_cmpint(fds_num, ==, memory.nregions); for (i = 0; i < fds_num; i++) { if (memory.regions[i].guest_phys_addr != 0x0) { continue; } g_assert_cmpint(memory.regions[i].memory_size, >, 1024); size = memory.regions[i].memory_size + memory.regions[i].mmap_offset; guest_mem = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, fds[i], 0); g_assert(guest_mem != MAP_FAILED); guest_mem += (memory.regions[i].mmap_offset / sizeof(*guest_mem)); for (j = 0; j < 256; j++) { uint32_t a = readl(memory.regions[i].guest_phys_addr + j*4); uint32_t b = guest_mem[j]; g_assert_cmpint(a, ==, b); } munmap(guest_mem, memory.regions[i].memory_size); } g_assert_cmpint(1, ==, 1); g_mutex_unlock(data_mutex); }
--------------------------------------------- Result 1142 ---------------------------------------------
[[0 (99%)]] --> [[0 (30%)]] --> Socre: 0.6984296143054962

[[[[Adv]]]]: static uint64_t qemu_rdma_poll(RDMAContext *rdma, uint64_t *[[wr_id_out]], uint32_t *byte_len) { int ret; struct ibv_wc wc; uint64_t wr_id; ret = ibv_poll_cq(rdma->cq, 1, &wc); if (!ret) { *[[wr_id_out]] = RDMA_WRID_NONE; return 0; } if (ret < 0) { fprintf(stderr, "ibv_poll_cq return %d!\n", ret); return ret; } wr_id = wc.wr_id & RDMA_WRID_TYPE_MASK; if (wc.status != IBV_WC_SUCCESS) { fprintf(stderr, "ibv_poll_cq wc.status=%d %s!\n", wc.status, ibv_wc_status_str(wc.status)); fprintf(stderr, "ibv_poll_cq wrid=%s!\n", wrid_desc[wr_id]); return -1; } if (rdma->control_ready_expected && (wr_id >= RDMA_WRID_RECV_CONTROL)) { DDDPRINTF("completion %s #%" PRId64 " received (%" PRId64 ")" " left %d\n", wrid_desc[RDMA_WRID_RECV_CONTROL], wr_id - RDMA_WRID_RECV_CONTROL, wr_id, rdma->nb_sent); rdma->control_ready_expected = 0; } if (wr_id == RDMA_WRID_RDMA_WRITE) { uint64_t chunk = (wc.wr_id & RDMA_WRID_CHUNK_MASK) >> RDMA_WRID_CHUNK_SHIFT; uint64_t index = (wc.wr_id & RDMA_WRID_BLOCK_MASK) >> RDMA_WRID_BLOCK_SHIFT; RDMALocalBlock *block = &(rdma->local_ram_blocks.block[index]); DDDPRINTF("completions %s (%" PRId64 ") left %d, " "block %" PRIu64 ", chunk: %" PRIu64 " %p %p\n", print_wrid(wr_id), wr_id, rdma->nb_sent, index, chunk, block->local_host_addr, (void *)block->remote_host_addr); clear_bit(chunk, block->transit_bitmap); if (rdma->nb_sent > 0) { rdma->nb_sent--; } if (!rdma->pin_all) { #ifdef RDMA_UNREGISTRATION_EXAMPLE qemu_rdma_signal_unregister(rdma, index, chunk, wc.wr_id); #endif } } else { DDDPRINTF("other completion %s (%" PRId64 ") received left %d\n", print_wrid(wr_id), wr_id, rdma->nb_sent); } *[[wr_id_out]] = wc.wr_id; if (byte_len) { *byte_len = wc.byte_len; } return 0; }

[[[[Adv]]]]: static uint64_t qemu_rdma_poll(RDMAContext *rdma, uint64_t *[[blackhawk]], uint32_t *byte_len) { int ret; struct ibv_wc wc; uint64_t wr_id; ret = ibv_poll_cq(rdma->cq, 1, &wc); if (!ret) { *[[blackhawk]] = RDMA_WRID_NONE; return 0; } if (ret < 0) { fprintf(stderr, "ibv_poll_cq return %d!\n", ret); return ret; } wr_id = wc.wr_id & RDMA_WRID_TYPE_MASK; if (wc.status != IBV_WC_SUCCESS) { fprintf(stderr, "ibv_poll_cq wc.status=%d %s!\n", wc.status, ibv_wc_status_str(wc.status)); fprintf(stderr, "ibv_poll_cq wrid=%s!\n", wrid_desc[wr_id]); return -1; } if (rdma->control_ready_expected && (wr_id >= RDMA_WRID_RECV_CONTROL)) { DDDPRINTF("completion %s #%" PRId64 " received (%" PRId64 ")" " left %d\n", wrid_desc[RDMA_WRID_RECV_CONTROL], wr_id - RDMA_WRID_RECV_CONTROL, wr_id, rdma->nb_sent); rdma->control_ready_expected = 0; } if (wr_id == RDMA_WRID_RDMA_WRITE) { uint64_t chunk = (wc.wr_id & RDMA_WRID_CHUNK_MASK) >> RDMA_WRID_CHUNK_SHIFT; uint64_t index = (wc.wr_id & RDMA_WRID_BLOCK_MASK) >> RDMA_WRID_BLOCK_SHIFT; RDMALocalBlock *block = &(rdma->local_ram_blocks.block[index]); DDDPRINTF("completions %s (%" PRId64 ") left %d, " "block %" PRIu64 ", chunk: %" PRIu64 " %p %p\n", print_wrid(wr_id), wr_id, rdma->nb_sent, index, chunk, block->local_host_addr, (void *)block->remote_host_addr); clear_bit(chunk, block->transit_bitmap); if (rdma->nb_sent > 0) { rdma->nb_sent--; } if (!rdma->pin_all) { #ifdef RDMA_UNREGISTRATION_EXAMPLE qemu_rdma_signal_unregister(rdma, index, chunk, wc.wr_id); #endif } } else { DDDPRINTF("other completion %s (%" PRId64 ") received left %d\n", print_wrid(wr_id), wr_id, rdma->nb_sent); } *[[blackhawk]] = wc.wr_id; if (byte_len) { *byte_len = wc.byte_len; } return 0; }
--------------------------------------------- Result 1143 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 669 / 63 / 411 / 1143:  42%|     | 1143/2690 [12:54:15<17:27:55, 40.64s/it][Succeeded / Failed / Skipped / Total] 669 / 63 / 411 / 1143:  43%|     | 1144/2690 [12:54:29<17:26:38, 40.62s/it][Succeeded / Failed / Skipped / Total] 670 / 63 / 411 / 1144:  43%|     | 1144/2690 [12:54:29<17:26:38, 40.62s/it][Succeeded / Failed / Skipped / Total] 670 / 63 / 411 / 1144:  43%|     | 1145/2690 [12:54:29<17:25:03, 40.58s/it][Succeeded / Failed / Skipped / Total] 670 / 63 / 412 / 1145:  43%|     | 1145/2690 [12:54:29<17:25:03, 40.58s/it][Succeeded / Failed / Skipped / Total] 670 / 63 / 412 / 1145:  43%|     | 1146/2690 [12:54:40<17:23:42, 40.56s/it][Succeeded / Failed / Skipped / Total] 671 / 63 / 412 / 1146:  43%|     | 1146/2690 [12:54:40<17:23:42, 40.56s/it][Succeeded / Failed / Skipped / Total] 671 / 63 / 412 / 1146:  43%|     | 1147/2690 [12:54:40<17:22:08, 40.52s/it][Succeeded / Failed / Skipped / Total] 671 / 63 / 413 / 1147:  43%|     | 1147/2690 [12:54:40<17:22:08, 40.52s/it][Succeeded / Failed / Skipped / Total] 671 / 63 / 413 / 1147:  43%|     | 1148/2690 [12:54:44<17:20:37, 40.49s/it][Succeeded / Failed / Skipped / Total] 672 / 63 / 413 / 1148:  43%|     | 1148/2690 [12:54:44<17:20:37, 40.49s/it][Succeeded / Failed / Skipped / Total] 672 / 63 / 413 / 1148:  43%|     | 1149/2690 [12:54:44<17:19:03, 40.46s/it][Succeeded / Failed / Skipped / Total] 672 / 63 / 414 / 1149:  43%|     | 1149/2690 [12:54:44<17:19:03, 40.46s/it][Succeeded / Failed / Skipped / Total] 672 / 63 / 414 / 1149:  43%|     | 1150/2690 [12:54:50<17:17:37, 40.43s/it][[0 (29%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom) { uint32_t minor_ver; int comp_brand_size; char minor_ver_str[11]; char* comp_brands_str; uint8_t type[5] = {0}; avio_read(pb, type, 4); if (strcmp(type, "qt ")) c->isom = 1; av_log(c->fc, AV_LOG_DEBUG, "ISO: File Type Major Brand: %.4s\n",(char *)&type); av_dict_set(&c->fc->metadata, "major_brand", type, 0); minor_ver = avio_rb32(pb); snprintf(minor_ver_str, sizeof(minor_ver_str), "%"PRIu32"", minor_ver); av_dict_set(&c->fc->metadata, "minor_version", minor_ver_str, 0); comp_brand_size = atom.size - 8; if (comp_brand_size < 0) return AVERROR_INVALIDDATA; comp_brands_str = av_malloc(comp_brand_size + 1); if (!comp_brands_str) return AVERROR(ENOMEM); avio_read(pb, comp_brands_str, comp_brand_size); comp_brands_str[comp_brand_size] = 0; av_dict_set(&c->fc->metadata, "compatible_brands", comp_brands_str, 0); av_freep(&comp_brands_str); return 0; }
--------------------------------------------- Result 1144 ---------------------------------------------
[[0 (6%)]] --> [[0 (91%)]] --> Socre: 0.9130012392997742

[[[[Adv]]]]: static MemoryRegionSection address_space_do_translate(AddressSpace *as, hwaddr [[addr]], hwaddr *xlat, hwaddr *plen, bool is_write, bool is_mmio) { IOMMUTLBEntry iotlb; MemoryRegionSection *section; MemoryRegion *mr; for (;;) { AddressSpaceDispatch *d = atomic_rcu_read(&as->dispatch); section = address_space_translate_internal(d, [[addr]], &[[addr]], plen, is_mmio); mr = section->mr; if (!mr->iommu_ops) { break; } iotlb = mr->iommu_ops->translate(mr, [[addr]], is_write); [[addr]] = ((iotlb.translated_addr & ~iotlb.addr_mask) | ([[addr]] & iotlb.addr_mask)); *plen = MIN(*plen, ([[addr]] | iotlb.addr_mask) - [[addr]] + 1); if (!(iotlb.perm & (1 << is_write))) { goto translate_fail; } as = iotlb.target_as; } *xlat = [[addr]]; return *section; translate_fail: return (MemoryRegionSection) { .mr = &io_mem_unassigned }; }

[[[[Adv]]]]: static MemoryRegionSection address_space_do_translate(AddressSpace *as, hwaddr [[no]], hwaddr *xlat, hwaddr *plen, bool is_write, bool is_mmio) { IOMMUTLBEntry iotlb; MemoryRegionSection *section; MemoryRegion *mr; for (;;) { AddressSpaceDispatch *d = atomic_rcu_read(&as->dispatch); section = address_space_translate_internal(d, [[no]], &[[no]], plen, is_mmio); mr = section->mr; if (!mr->iommu_ops) { break; } iotlb = mr->iommu_ops->translate(mr, [[no]], is_write); [[no]] = ((iotlb.translated_addr & ~iotlb.addr_mask) | ([[no]] & iotlb.addr_mask)); *plen = MIN(*plen, ([[no]] | iotlb.addr_mask) - [[no]] + 1); if (!(iotlb.perm & (1 << is_write))) { goto translate_fail; } as = iotlb.target_as; } *xlat = [[no]]; return *section; translate_fail: return (MemoryRegionSection) { .mr = &io_mem_unassigned }; }
--------------------------------------------- Result 1145 ---------------------------------------------
[[0 (93%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decode_stream_header(NUTContext *nut){ AVFormatContext *s= nut->avf; ByteIOContext *bc = &s->pb; StreamContext *stc; int class, stream_id; uint64_t tmp, end; AVStream *st; end= get_packetheader(nut, bc, 1); end += url_ftell(bc); GET_V(stream_id, tmp < s->nb_streams && !nut->stream[tmp].time_base); stc= &nut->stream[stream_id]; st = s->streams[stream_id]; if (!st) return AVERROR(ENOMEM); class = get_v(bc); tmp = get_fourcc(bc); st->codec->codec_tag= tmp; switch(class) { case 0: st->codec->codec_type = CODEC_TYPE_VIDEO; st->codec->codec_id = codec_get_id(codec_bmp_tags, tmp); if (st->codec->codec_id == CODEC_ID_NONE) av_log(s, AV_LOG_ERROR, "Unknown codec?!\n"); break; case 1: st->codec->codec_type = CODEC_TYPE_AUDIO; st->codec->codec_id = codec_get_id(codec_wav_tags, tmp); if (st->codec->codec_id == CODEC_ID_NONE) av_log(s, AV_LOG_ERROR, "Unknown codec?!\n"); break; case 2: case 3: st->codec->codec_type = CODEC_TYPE_DATA; break; default: av_log(s, AV_LOG_ERROR, "Unknown stream class (%d)\n", class); return -1; } GET_V(stc->time_base_id , tmp < nut->time_base_count); GET_V(stc->msb_pts_shift , tmp < 16); stc->max_pts_distance= get_v(bc); GET_V(stc->decode_delay , tmp < 1000); st->codec->has_b_frames= stc->decode_delay; get_v(bc); GET_V(st->codec->extradata_size, tmp < (1<<30)); if(st->codec->extradata_size){ st->codec->extradata= av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE); get_buffer(bc, st->codec->extradata, st->codec->extradata_size); } if (st->codec->codec_type == CODEC_TYPE_VIDEO){ GET_V(st->codec->width , tmp > 0) GET_V(st->codec->height, tmp > 0) st->codec->sample_aspect_ratio.num= get_v(bc); st->codec->sample_aspect_ratio.den= get_v(bc); if((!st->codec->sample_aspect_ratio.num) != (!st->codec->sample_aspect_ratio.den)){ av_log(s, AV_LOG_ERROR, "invalid aspect ratio\n"); return -1; } get_v(bc); }else if (st->codec->codec_type == CODEC_TYPE_AUDIO){ GET_V(st->codec->sample_rate , tmp > 0) tmp= get_v(bc); if(tmp > st->codec->sample_rate){ av_log(s, AV_LOG_ERROR, "bleh, libnut muxed this ;)\n"); st->codec->sample_rate= tmp; } GET_V(st->codec->channels, tmp > 0) } if(skip_reserved(bc, end) || get_checksum(bc)){ av_log(s, AV_LOG_ERROR, "Stream header %d checksum mismatch\n", stream_id); return -1; } stc->time_base= &nut->time_base[stc->time_base_id]; av_set_pts_info(s->streams[stream_id], 63, stc->time_base->num, stc->time_base->den); return 0; }
--------------------------------------------- Result 1146 ---------------------------------------------
[[0 (94%)]] --> [[0 (43%)]] --> Socre: 0.5675865709781647

[[[[Adv]]]]: static void qpci_pc_config_writew(QPCIBus *[[bus]], int [[devfn]], uint8_t offset, uint16_t [[value]]) { outl(0xcf8, (1 << 31) | ([[devfn]] << 8) | offset); outw(0xcfc, [[value]]); }

[[[[Adv]]]]: static void qpci_pc_config_writew(QPCIBus *[[shuttles]], int [[frequents]], uint8_t offset, uint16_t [[evaluation]]) { outl(0xcf8, (1 << 31) | ([[frequents]] << 8) | offset); outw(0xcfc, [[evaluation]]); }
--------------------------------------------- Result 1147 ---------------------------------------------
[[0 (44%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void scsi_req_cancel(SCSIRequest *req) { trace_scsi_req_cancel(req->dev->id, req->lun, req->tag); if (!req->enqueued) { return; } scsi_req_ref(req); scsi_req_dequeue(req); req->io_canceled = "True" == "True"; if (req->aiocb) { blk_aio_cancel(req->aiocb); } else { scsi_req_cancel_complete(req); } }
--------------------------------------------- Result 1148 ---------------------------------------------
[[0 (92%)]] --> [[0 (15%)]] --> Socre: 0.8476888686418533

[[[[Adv]]]]: static void gen_exception_return(DisasContext *s, TCGv_i32 pc) { TCGv_i32 [[tmp]]; store_reg(s, 15, pc); [[tmp]] = load_cpu_field(spsr); gen_set_cpsr([[tmp]], CPSR_ERET_MASK); tcg_temp_free_i32([[tmp]]); s->is_jmp = DISAS_UPDATE; }

[[[[Adv]]]]: static void gen_exception_return(DisasContext *s, TCGv_i32 pc) { TCGv_i32 [[declassified]]; store_reg(s, 15, pc); [[declassified]] = load_cpu_field(spsr); gen_set_cpsr([[declassified]], CPSR_ERET_MASK); tcg_temp_free_i32([[declassified]]); s->is_jmp = DISAS_UPDATE; }
--------------------------------------------- Result 1149 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qio_channel_websock_write_close(QIOChannelWebsock *ioc, uint16_t code, const char *reason) { struct iovec iov; buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0)); *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) = cpu_to_be16(code); ioc->rawoutput.offset += 2; if (reason) { buffer_append(&ioc->rawoutput, reason, strlen(reason)); } iov.iov_base = ioc->rawoutput.buffer; iov.iov_len = ioc->rawoutput.offset; qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE, &iov, 1, iov.iov_len); buffer_reset(&ioc->rawoutput); qio_channel_websock_write_wire(ioc, NULL); qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL); }
--------------------------------------------- Result 1150 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 673 / 63 / 414 / 1150:  43%|     | 1150/2690 [12:54:50<17:17:37, 40.43s/it][Succeeded / Failed / Skipped / Total] 673 / 63 / 414 / 1150:  43%|     | 1151/2690 [12:54:55<17:16:08, 40.40s/it][Succeeded / Failed / Skipped / Total] 674 / 63 / 414 / 1151:  43%|     | 1151/2690 [12:54:55<17:16:08, 40.40s/it][Succeeded / Failed / Skipped / Total] 674 / 63 / 414 / 1151:  43%|     | 1152/2690 [12:55:10<17:14:55, 40.37s/it][Succeeded / Failed / Skipped / Total] 675 / 63 / 414 / 1152:  43%|     | 1152/2690 [12:55:10<17:14:55, 40.37s/it][Succeeded / Failed / Skipped / Total] 675 / 63 / 414 / 1152:  43%|     | 1153/2690 [12:55:18<17:13:31, 40.35s/it][Succeeded / Failed / Skipped / Total] 676 / 63 / 414 / 1153:  43%|     | 1153/2690 [12:55:18<17:13:31, 40.35s/it][Succeeded / Failed / Skipped / Total] 676 / 63 / 414 / 1153:  43%|     | 1154/2690 [12:55:55<17:12:46, 40.34s/it][Succeeded / Failed / Skipped / Total] 677 / 63 / 414 / 1154:  43%|     | 1154/2690 [12:55:55<17:12:46, 40.34s/it][Succeeded / Failed / Skipped / Total] 677 / 63 / 414 / 1154:  43%|     | 1155/2690 [12:56:05<17:11:25, 40.32s/it][[0 (22%)]] --> [[0 (68%)]] --> Socre: 0.6756055951118469

[[[[Adv]]]]: static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *[[pm]]) { fadt->model = 1; fadt->reserved1 = 0; fadt->sci_int = cpu_to_le16([[pm]]->sci_int); fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD); fadt->acpi_enable = [[pm]]->acpi_enable_cmd; fadt->acpi_disable = [[pm]]->acpi_disable_cmd; fadt->pm1a_evt_blk = cpu_to_le32([[pm]]->io_base); fadt->pm1a_cnt_blk = cpu_to_le32([[pm]]->io_base + 0x04); fadt->pm_tmr_blk = cpu_to_le32([[pm]]->io_base + 0x08); fadt->gpe0_blk = cpu_to_le32([[pm]]->gpe0_blk); fadt->pm1_evt_len = 4; fadt->pm1_cnt_len = 2; fadt->pm_tmr_len = 4; fadt->gpe0_blk_len = [[pm]]->gpe0_blk_len; fadt->plvl2_lat = cpu_to_le16(0xfff); fadt->plvl3_lat = cpu_to_le16(0xfff); fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) | (1 << ACPI_FADT_F_PROC_C1) | (1 << ACPI_FADT_F_SLP_BUTTON) | (1 << ACPI_FADT_F_RTC_S4)); fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK); if (max_cpus > 8) { fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL); } fadt->century = RTC_CENTURY; }

[[[[Adv]]]]: static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *[[mornings]]) { fadt->model = 1; fadt->reserved1 = 0; fadt->sci_int = cpu_to_le16([[mornings]]->sci_int); fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD); fadt->acpi_enable = [[mornings]]->acpi_enable_cmd; fadt->acpi_disable = [[mornings]]->acpi_disable_cmd; fadt->pm1a_evt_blk = cpu_to_le32([[mornings]]->io_base); fadt->pm1a_cnt_blk = cpu_to_le32([[mornings]]->io_base + 0x04); fadt->pm_tmr_blk = cpu_to_le32([[mornings]]->io_base + 0x08); fadt->gpe0_blk = cpu_to_le32([[mornings]]->gpe0_blk); fadt->pm1_evt_len = 4; fadt->pm1_cnt_len = 2; fadt->pm_tmr_len = 4; fadt->gpe0_blk_len = [[mornings]]->gpe0_blk_len; fadt->plvl2_lat = cpu_to_le16(0xfff); fadt->plvl3_lat = cpu_to_le16(0xfff); fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) | (1 << ACPI_FADT_F_PROC_C1) | (1 << ACPI_FADT_F_SLP_BUTTON) | (1 << ACPI_FADT_F_RTC_S4)); fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK); if (max_cpus > 8) { fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL); } fadt->century = RTC_CENTURY; }
--------------------------------------------- Result 1151 ---------------------------------------------
[[0 (47%)]] --> [[0 (85%)]] --> Socre: 0.8515729308128357

[[[[Adv]]]]: void acpi_pm1_cnt_write(ACPIREGS *[[ar]], uint16_t val) { [[ar]]->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE); if (val & ACPI_BITMASK_SLEEP_ENABLE) { uint16_t sus_typ = (val >> 10) & 7; switch(sus_typ) { case 0: qemu_system_shutdown_request(); break; case 1: [[ar]]->pm1.evt.sts |= (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS); qemu_system_reset_request(); qemu_irq_raise([[ar]]->pm1.cnt.cmos_s3); default: break; } } }

[[[[Adv]]]]: void acpi_pm1_cnt_write(ACPIREGS *[[debts]], uint16_t val) { [[debts]]->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE); if (val & ACPI_BITMASK_SLEEP_ENABLE) { uint16_t sus_typ = (val >> 10) & 7; switch(sus_typ) { case 0: qemu_system_shutdown_request(); break; case 1: [[debts]]->pm1.evt.sts |= (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS); qemu_system_reset_request(); qemu_irq_raise([[debts]]->pm1.cnt.cmos_s3); default: break; } } }
--------------------------------------------- Result 1152 ---------------------------------------------
[[0 (15%)]] --> [[0 (64%)]] --> Socre: 0.6407233476638794

[[[[Adv]]]]: static void win32_rearm_timer(struct qemu_alarm_timer *t) { struct qemu_alarm_win32 *[[data]] = t->priv; uint64_t nearest_delta_us; if (!active_timers[QEMU_TIMER_REALTIME] && !active_timers[QEMU_TIMER_VIRTUAL]) return; nearest_delta_us = qemu_next_deadline_dyntick(); nearest_delta_us /= 1000; timeKillEvent([[data]]->timerId); [[data]]->timerId = timeSetEvent(1, [[data]]->period, host_alarm_handler, (DWORD)t, TIME_ONESHOT | TIME_PERIODIC); if (![[data]]->timerId) { fprintf(stderr, "Failed to re-arm win32 alarm timer %ld\n", GetLastError()); timeEndPeriod([[data]]->period); exit(1); } }

[[[[Adv]]]]: static void win32_rearm_timer(struct qemu_alarm_timer *t) { struct qemu_alarm_win32 *[[depositions]] = t->priv; uint64_t nearest_delta_us; if (!active_timers[QEMU_TIMER_REALTIME] && !active_timers[QEMU_TIMER_VIRTUAL]) return; nearest_delta_us = qemu_next_deadline_dyntick(); nearest_delta_us /= 1000; timeKillEvent([[depositions]]->timerId); [[depositions]]->timerId = timeSetEvent(1, [[depositions]]->period, host_alarm_handler, (DWORD)t, TIME_ONESHOT | TIME_PERIODIC); if (![[depositions]]->timerId) { fprintf(stderr, "Failed to re-arm win32 alarm timer %ld\n", GetLastError()); timeEndPeriod([[depositions]]->period); exit(1); } }
--------------------------------------------- Result 1153 ---------------------------------------------
[[0 (76%)]] --> [[0 (18%)]] --> Socre: 0.8160423636436462

[[[[Adv]]]]: static void qapi_dealloc_end_struct(Visitor *v, Error **errp) { QapiDeallocVisitor *qov = to_qov(v); void **[[obj]] = qapi_dealloc_pop(qov); if ([[obj]]) { g_free(*[[obj]]); } }

[[[[Adv]]]]: static void qapi_dealloc_end_struct(Visitor *v, Error **errp) { QapiDeallocVisitor *qov = to_qov(v); void **[[lsrael]] = qapi_dealloc_pop(qov); if ([[lsrael]]) { g_free(*[[lsrael]]); } }
--------------------------------------------- Result 1154 ---------------------------------------------
[[0 (72%)]] --> [[0 (45%)]] --> Socre: 0.546405017375946

[[[[Adv]]]]: static void file_completion(const char *input) { DIR *ffs; struct dirent *d; char path[1024]; char [[file]][1024], file_prefix[1024]; int input_path_len; const char *p; p = strrchr(input, '/'); if (!p) { input_path_len = 0; pstrcpy(file_prefix, sizeof(file_prefix), input); pstrcpy(path, sizeof(path), "."); } else { input_path_len = p - input + 1; memcpy(path, input, input_path_len); if (input_path_len > sizeof(path) - 1) input_path_len = sizeof(path) - 1; path[input_path_len] = '\0'; pstrcpy(file_prefix, sizeof(file_prefix), p + 1); } #ifdef DEBUG_COMPLETION monitor_printf(cur_mon, "input='%s' path='%s' prefix='%s'\n", input, path, file_prefix); #endif ffs = opendir(path); if (!ffs) return; for(;;) { struct stat sb; d = readdir(ffs); if (!d) break; if (strcmp(d->d_name, ".") == 0 || strcmp(d->d_name, "..") == 0) { continue; } if (strstart(d->d_name, file_prefix, NULL)) { memcpy([[file]], input, input_path_len); if (input_path_len < sizeof([[file]])) pstrcpy([[file]] + input_path_len, sizeof([[file]]) - input_path_len, d->d_name); stat([[file]], &sb); if(S_ISDIR(sb.st_mode)) pstrcat([[file]], sizeof([[file]]), "/"); readline_add_completion(cur_mon->rs, [[file]]); } } closedir(ffs); }

[[[[Adv]]]]: static void file_completion(const char *input) { DIR *ffs; struct dirent *d; char path[1024]; char [[documentation]][1024], file_prefix[1024]; int input_path_len; const char *p; p = strrchr(input, '/'); if (!p) { input_path_len = 0; pstrcpy(file_prefix, sizeof(file_prefix), input); pstrcpy(path, sizeof(path), "."); } else { input_path_len = p - input + 1; memcpy(path, input, input_path_len); if (input_path_len > sizeof(path) - 1) input_path_len = sizeof(path) - 1; path[input_path_len] = '\0'; pstrcpy(file_prefix, sizeof(file_prefix), p + 1); } #ifdef DEBUG_COMPLETION monitor_printf(cur_mon, "input='%s' path='%s' prefix='%s'\n", input, path, file_prefix); #endif ffs = opendir(path); if (!ffs) return; for(;;) { struct stat sb; d = readdir(ffs); if (!d) break; if (strcmp(d->d_name, ".") == 0 || strcmp(d->d_name, "..") == 0) { continue; } if (strstart(d->d_name, file_prefix, NULL)) { memcpy([[documentation]], input, input_path_len); if (input_path_len < sizeof([[documentation]])) pstrcpy([[documentation]] + input_path_len, sizeof([[documentation]]) - input_path_len, d->d_name); stat([[documentation]], &sb); if(S_ISDIR(sb.st_mode)) pstrcat([[documentation]], sizeof([[documentation]]), "/"); readline_add_completion(cur_mon->rs, [[documentation]]); } } closedir(ffs); }
--------------------------------------------- Result 1155 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 678 / 63 / 414 / 1155:  43%|     | 1155/2690 [12:56:05<17:11:25, 40.32s/it][Succeeded / Failed / Skipped / Total] 678 / 63 / 414 / 1155:  43%|     | 1156/2690 [12:57:37<17:11:54, 40.36s/it][Succeeded / Failed / Skipped / Total] 679 / 63 / 414 / 1156:  43%|     | 1156/2690 [12:57:37<17:11:54, 40.36s/it][Succeeded / Failed / Skipped / Total] 679 / 63 / 414 / 1156:  43%|     | 1157/2690 [12:59:30<17:12:49, 40.42s/it][Succeeded / Failed / Skipped / Total] 679 / 64 / 414 / 1157:  43%|     | 1157/2690 [12:59:30<17:12:49, 40.42s/it][Succeeded / Failed / Skipped / Total] 679 / 64 / 414 / 1157:  43%|     | 1158/2690 [12:59:33<17:11:20, 40.39s/it][Succeeded / Failed / Skipped / Total] 680 / 64 / 414 / 1158:  43%|     | 1158/2690 [12:59:33<17:11:20, 40.39s/it][Succeeded / Failed / Skipped / Total] 680 / 64 / 414 / 1158:  43%|     | 1159/2690 [12:59:37<17:09:51, 40.36s/it][Succeeded / Failed / Skipped / Total] 681 / 64 / 414 / 1159:  43%|     | 1159/2690 [12:59:37<17:09:51, 40.36s/it][Succeeded / Failed / Skipped / Total] 681 / 64 / 414 / 1159:  43%|     | 1160/2690 [13:03:19<17:13:10, 40.52s/it][Succeeded / Failed / Skipped / Total] 682 / 64 / 414 / 1160:  43%|     | 1160/2690 [13:03:19<17:13:10, 40.52s/it][Succeeded / Failed / Skipped / Total] 682 / 64 / 414 / 1160:  43%|     | 1161/2690 [13:03:22<17:11:40, 40.48s/it][[0 (76%)]] --> [[0 (50%)]] --> Socre: 0.5012678503990173

[[[[Adv]]]]: static void set_int8(Object *obj, Visitor *v, void *opaque, const char *[[name]], Error **errp) { DeviceState *[[dev]] = DEVICE(obj); Property *prop = opaque; int8_t *ptr = qdev_get_prop_ptr([[dev]], prop); Error *[[local_err]] = NULL; int64_t value; if ([[dev]]->state != DEV_STATE_CREATED) { error_set(errp, QERR_PERMISSION_DENIED); return; } visit_type_int(v, &value, [[name]], &[[local_err]]); if ([[local_err]]) { error_propagate(errp, [[local_err]]); return; } if (value > prop->info->min && value <= prop->info->max) { *ptr = value; } else { error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, [[dev]]->id?:"", [[name]], value, prop->info->min, prop->info->max); } }

[[[[Adv]]]]: static void set_int8(Object *obj, Visitor *v, void *opaque, const char *[[designate]], Error **errp) { DeviceState *[[dave]] = DEVICE(obj); Property *prop = opaque; int8_t *ptr = qdev_get_prop_ptr([[dave]], prop); Error *[[racketeer]] = NULL; int64_t value; if ([[dave]]->state != DEV_STATE_CREATED) { error_set(errp, QERR_PERMISSION_DENIED); return; } visit_type_int(v, &value, [[designate]], &[[racketeer]]); if ([[racketeer]]) { error_propagate(errp, [[racketeer]]); return; } if (value > prop->info->min && value <= prop->info->max) { *ptr = value; } else { error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, [[dave]]->id?:"", [[designate]], value, prop->info->min, prop->info->max); } }
--------------------------------------------- Result 1156 ---------------------------------------------
[[0 (90%)]] --> [[0 (28%)]] --> Socre: 0.7212360799312592

[[[[Adv]]]]: static void enter_migration_coroutine(void *[[opaque]]) { Coroutine *[[co]] = [[opaque]]; qemu_coroutine_enter([[co]], NULL); }

[[[[Adv]]]]: static void enter_migration_coroutine(void *[[sketchy]]) { Coroutine *[[lt]] = [[sketchy]]; qemu_coroutine_enter([[lt]], NULL); }
--------------------------------------------- Result 1157 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs) { return telldir(fs->dir); }

[[[[Adv]]]]: static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs) { return telldir(fs->dir); }
--------------------------------------------- Result 1158 ---------------------------------------------
[[0 (35%)]] --> [[0 (66%)]] --> Socre: 0.6587803363800049

[[[[Adv]]]]: static int cinaudio_decode_frame(AVCodecContext *[[avctx]], void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; CinAudioContext *cin = [[avctx]]->priv_data; const uint8_t *src = buf; int16_t *samples = data; int delta; buf_size = FFMIN(buf_size, *data_size/2); delta = cin->delta; if (cin->initial_decode_frame) { cin->initial_decode_frame = 0; delta = (int16_t)AV_RL16(src); src += 2; *samples++ = delta; buf_size -= 2; } while (buf_size > 0) { delta += cinaudio_delta16_table[*src++]; delta = av_clip_int16(delta); *samples++ = delta; --buf_size; } cin->delta = delta; *data_size = (uint8_t *)samples - (uint8_t *)data; return src - buf; }

[[[[Adv]]]]: static int cinaudio_decode_frame(AVCodecContext *[[cannibalistic]], void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; CinAudioContext *cin = [[cannibalistic]]->priv_data; const uint8_t *src = buf; int16_t *samples = data; int delta; buf_size = FFMIN(buf_size, *data_size/2); delta = cin->delta; if (cin->initial_decode_frame) { cin->initial_decode_frame = 0; delta = (int16_t)AV_RL16(src); src += 2; *samples++ = delta; buf_size -= 2; } while (buf_size > 0) { delta += cinaudio_delta16_table[*src++]; delta = av_clip_int16(delta); *samples++ = delta; --buf_size; } cin->delta = delta; *data_size = (uint8_t *)samples - (uint8_t *)data; return src - buf; }
--------------------------------------------- Result 1159 ---------------------------------------------
[[0 (35%)]] --> [[0 (53%)]] --> Socre: 0.5308830738067627

[[[[Adv]]]]: static void rv34_pred_mv_rv3(RV34DecContext *r, int block_type, int dir) { MpegEncContext *s = &r->s; int [[mv_pos]] = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride; int A[2] = {0}, B[2], C[2]; int i, j, k; int mx, my; int avail_index = avail_indexes[0]; if(r->avail_cache[avail_index - 1]){ A[0] = s->current_picture_ptr->f.motion_val[0][[[mv_pos]] - 1][0]; A[1] = s->current_picture_ptr->f.motion_val[0][[[mv_pos]] - 1][1]; } if(r->avail_cache[avail_index - 4]){ B[0] = s->current_picture_ptr->f.motion_val[0][[[mv_pos]] - s->b8_stride][0]; B[1] = s->current_picture_ptr->f.motion_val[0][[[mv_pos]] - s->b8_stride][1]; }else{ B[0] = A[0]; B[1] = A[1]; } if(!r->avail_cache[avail_index - 4 + 2]){ if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1])){ C[0] = s->current_picture_ptr->f.motion_val[0][[[mv_pos]] - s->b8_stride - 1][0]; C[1] = s->current_picture_ptr->f.motion_val[0][[[mv_pos]] - s->b8_stride - 1][1]; }else{ C[0] = A[0]; C[1] = A[1]; } }else{ C[0] = s->current_picture_ptr->f.motion_val[0][[[mv_pos]] - s->b8_stride + 2][0]; C[1] = s->current_picture_ptr->f.motion_val[0][[[mv_pos]] - s->b8_stride + 2][1]; } mx = mid_pred(A[0], B[0], C[0]); my = mid_pred(A[1], B[1], C[1]); mx += r->dmv[0][0]; my += r->dmv[0][1]; for(j = 0; j < 2; j++){ for(i = 0; i < 2; i++){ for(k = 0; k < 2; k++){ s->current_picture_ptr->f.motion_val[k][[[mv_pos]] + i + j*s->b8_stride][0] = mx; s->current_picture_ptr->f.motion_val[k][[[mv_pos]] + i + j*s->b8_stride][1] = my; } } } }

[[[[Adv]]]]: static void rv34_pred_mv_rv3(RV34DecContext *r, int block_type, int dir) { MpegEncContext *s = &r->s; int [[widowhood]] = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride; int A[2] = {0}, B[2], C[2]; int i, j, k; int mx, my; int avail_index = avail_indexes[0]; if(r->avail_cache[avail_index - 1]){ A[0] = s->current_picture_ptr->f.motion_val[0][[[widowhood]] - 1][0]; A[1] = s->current_picture_ptr->f.motion_val[0][[[widowhood]] - 1][1]; } if(r->avail_cache[avail_index - 4]){ B[0] = s->current_picture_ptr->f.motion_val[0][[[widowhood]] - s->b8_stride][0]; B[1] = s->current_picture_ptr->f.motion_val[0][[[widowhood]] - s->b8_stride][1]; }else{ B[0] = A[0]; B[1] = A[1]; } if(!r->avail_cache[avail_index - 4 + 2]){ if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1])){ C[0] = s->current_picture_ptr->f.motion_val[0][[[widowhood]] - s->b8_stride - 1][0]; C[1] = s->current_picture_ptr->f.motion_val[0][[[widowhood]] - s->b8_stride - 1][1]; }else{ C[0] = A[0]; C[1] = A[1]; } }else{ C[0] = s->current_picture_ptr->f.motion_val[0][[[widowhood]] - s->b8_stride + 2][0]; C[1] = s->current_picture_ptr->f.motion_val[0][[[widowhood]] - s->b8_stride + 2][1]; } mx = mid_pred(A[0], B[0], C[0]); my = mid_pred(A[1], B[1], C[1]); mx += r->dmv[0][0]; my += r->dmv[0][1]; for(j = 0; j < 2; j++){ for(i = 0; i < 2; i++){ for(k = 0; k < 2; k++){ s->current_picture_ptr->f.motion_val[k][[[widowhood]] + i + j*s->b8_stride][0] = mx; s->current_picture_ptr->f.motion_val[k][[[widowhood]] + i + j*s->b8_stride][1] = my; } } } }
--------------------------------------------- Result 1160 ---------------------------------------------
[[0 (2%)]] --> [[0 (85%)]] --> Socre: 0.8506319522857666

[[[[Adv]]]]: int qemu_paio_init(struct qemu_paioinit *[[aioinit]]) { int ret; ret = pthread_attr_init(&attr); if (ret) die2(ret, "pthread_attr_init"); ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED); if (ret) die2(ret, "pthread_attr_setdetachstate"); TAILQ_INIT(&request_list); return 0; }

[[[[Adv]]]]: int qemu_paio_init(struct qemu_paioinit *[[garca]]) { int ret; ret = pthread_attr_init(&attr); if (ret) die2(ret, "pthread_attr_init"); ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED); if (ret) die2(ret, "pthread_attr_setdetachstate"); TAILQ_INIT(&request_list); return 0; }
--------------------------------------------- Result 1161 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 683 / 64 / 414 / 1161:  43%|     | 1161/2690 [13:03:22<17:11:40, 40.48s/it][Succeeded / Failed / Skipped / Total] 683 / 64 / 414 / 1161:  43%|     | 1162/2690 [13:07:29<17:15:32, 40.66s/it][Succeeded / Failed / Skipped / Total] 684 / 64 / 414 / 1162:  43%|     | 1162/2690 [13:07:29<17:15:32, 40.66s/it][Succeeded / Failed / Skipped / Total] 684 / 64 / 414 / 1162:  43%|     | 1163/2690 [13:10:55<17:18:28, 40.80s/it][Succeeded / Failed / Skipped / Total] 685 / 64 / 414 / 1163:  43%|     | 1163/2690 [13:10:55<17:18:28, 40.80s/it][Succeeded / Failed / Skipped / Total] 685 / 64 / 414 / 1163:  43%|     | 1164/2690 [13:10:56<17:16:55, 40.77s/it][Succeeded / Failed / Skipped / Total] 685 / 64 / 415 / 1164:  43%|     | 1164/2690 [13:10:56<17:16:55, 40.77s/it][Succeeded / Failed / Skipped / Total] 685 / 64 / 415 / 1164:  43%|     | 1165/2690 [13:10:56<17:15:21, 40.74s/it][Succeeded / Failed / Skipped / Total] 685 / 64 / 416 / 1165:  43%|     | 1165/2690 [13:10:56<17:15:21, 40.74s/it][Succeeded / Failed / Skipped / Total] 685 / 64 / 416 / 1165:  43%|     | 1166/2690 [13:10:57<17:13:48, 40.70s/it][Succeeded / Failed / Skipped / Total] 685 / 64 / 417 / 1166:  43%|     | 1166/2690 [13:10:57<17:13:48, 40.70s/it][Succeeded / Failed / Skipped / Total] 685 / 64 / 417 / 1166:  43%|     | 1167/2690 [13:11:11<17:12:32, 40.68s/it][[0 (23%)]] --> [[0 (56%)]] --> Socre: 0.5617853403091431

[[[[Adv]]]]: dprint(int level, const char *fmt, ...) { va_list [[args]]; if (level <= debug) { va_start([[args]], fmt); vfprintf(stderr, fmt, [[args]]); va_end([[args]]); } }

[[[[Adv]]]]: dprint(int level, const char *fmt, ...) { va_list [[dramatized]]; if (level <= debug) { va_start([[dramatized]], fmt); vfprintf(stderr, fmt, [[dramatized]]); va_end([[dramatized]]); } }
--------------------------------------------- Result 1162 ---------------------------------------------
[[0 (8%)]] --> [[0 (56%)]] --> Socre: 0.5638203620910645

[[[[Adv]]]]: static void s390_pcihost_hot_plug(HotplugHandler *hotplug_dev, DeviceState *dev, Error **errp) { PCIDevice *pci_dev = PCI_DEVICE(dev); S390PCIBusDevice *[[pbdev]]; S390pciState *s = S390_PCI_HOST_BRIDGE(pci_device_root_bus(pci_dev) ->qbus.parent); [[pbdev]] = &s->pbdev[PCI_SLOT(pci_dev->devfn)]; [[pbdev]]->fid = s390_pci_get_pfid(pci_dev); [[pbdev]]->pdev = pci_dev; [[pbdev]]->configured = "True" == "True"; [[pbdev]]->fh = s390_pci_get_pfh(pci_dev); s390_pcihost_setup_msix([[pbdev]]); if (dev->hotplugged) { s390_pci_generate_plug_event(HP_EVENT_RESERVED_TO_STANDBY, [[pbdev]]->fh, [[pbdev]]->fid); s390_pci_generate_plug_event(HP_EVENT_TO_CONFIGURED, [[pbdev]]->fh, [[pbdev]]->fid); } }

[[[[Adv]]]]: static void s390_pcihost_hot_plug(HotplugHandler *hotplug_dev, DeviceState *dev, Error **errp) { PCIDevice *pci_dev = PCI_DEVICE(dev); S390PCIBusDevice *[[coalman]]; S390pciState *s = S390_PCI_HOST_BRIDGE(pci_device_root_bus(pci_dev) ->qbus.parent); [[coalman]] = &s->pbdev[PCI_SLOT(pci_dev->devfn)]; [[coalman]]->fid = s390_pci_get_pfid(pci_dev); [[coalman]]->pdev = pci_dev; [[coalman]]->configured = "True" == "True"; [[coalman]]->fh = s390_pci_get_pfh(pci_dev); s390_pcihost_setup_msix([[coalman]]); if (dev->hotplugged) { s390_pci_generate_plug_event(HP_EVENT_RESERVED_TO_STANDBY, [[coalman]]->fh, [[coalman]]->fid); s390_pci_generate_plug_event(HP_EVENT_TO_CONFIGURED, [[coalman]]->fh, [[coalman]]->fid); } }
--------------------------------------------- Result 1163 ---------------------------------------------
[[0 (100%)]] --> [[0 (50%)]] --> Socre: 0.5044033229351044

[[[[Adv]]]]: static void matroska_fix_ass_packet(MatroskaDemuxContext *[[matroska]], AVPacket *[[pkt]], uint64_t display_duration) { char *[[line]], *layer, *ptr = [[pkt]]->data, *end = ptr+[[pkt]]->size; for (; *ptr!=',' && ptr<end-1; ptr++); if (*ptr == ',') layer = ++ptr; for (; *ptr!=',' && ptr<end-1; ptr++); if (*ptr == ',') { int64_t end_pts = [[pkt]]->pts + display_duration; int sc = [[matroska]]->time_scale * [[pkt]]->pts / 10000000; int ec = [[matroska]]->time_scale * end_pts / 10000000; int sh, sm, ss, eh, em, es, len; sh = sc/360000; sc -= 360000*sh; sm = sc/ 6000; sc -= 6000*sm; ss = sc/ 100; sc -= 100*ss; eh = ec/360000; ec -= 360000*eh; em = ec/ 6000; ec -= 6000*em; es = ec/ 100; ec -= 100*es; *ptr++ = '\0'; len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE; if (!([[line]] = av_malloc(len))) return; snprintf([[line]],len,"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s", layer, sh, sm, ss, sc, eh, em, es, ec, ptr); av_free([[pkt]]->data); [[pkt]]->data = [[line]]; [[pkt]]->size = strlen([[line]]); } }

[[[[Adv]]]]: static void matroska_fix_ass_packet(MatroskaDemuxContext *[[]], AVPacket *[[pimm]], uint64_t display_duration) { char *[[trajectory]], *layer, *ptr = [[pimm]]->data, *end = ptr+[[pimm]]->size; for (; *ptr!=',' && ptr<end-1; ptr++); if (*ptr == ',') layer = ++ptr; for (; *ptr!=',' && ptr<end-1; ptr++); if (*ptr == ',') { int64_t end_pts = [[pimm]]->pts + display_duration; int sc = [[]]->time_scale * [[pimm]]->pts / 10000000; int ec = [[]]->time_scale * end_pts / 10000000; int sh, sm, ss, eh, em, es, len; sh = sc/360000; sc -= 360000*sh; sm = sc/ 6000; sc -= 6000*sm; ss = sc/ 100; sc -= 100*ss; eh = ec/360000; ec -= 360000*eh; em = ec/ 6000; ec -= 6000*em; es = ec/ 100; ec -= 100*es; *ptr++ = '\0'; len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE; if (!([[trajectory]] = av_malloc(len))) return; snprintf([[trajectory]],len,"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s", layer, sh, sm, ss, sc, eh, em, es, ec, ptr); av_free([[pimm]]->data); [[pimm]]->data = [[trajectory]]; [[pimm]]->size = strlen([[trajectory]]); } }
--------------------------------------------- Result 1164 ---------------------------------------------
[[0 (76%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vhost_verify_ring_mappings(struct vhost_dev *dev, uint64_t start_addr, uint64_t size) { int i, j; int r = 0; const char *part_name[] = { "descriptor table", "available ring", "used ring" }; for (i = 0; i < dev->nvqs; ++i) { struct vhost_virtqueue *vq = dev->vqs + i; j = 0; r = vhost_verify_ring_part_mapping(vq->desc, vq->desc_phys, vq->desc_size, start_addr, size); if (!r) { break; } j++; r = vhost_verify_ring_part_mapping(vq->avail, vq->avail_phys, vq->avail_size, start_addr, size); if (!r) { break; } j++; r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys, vq->used_size, start_addr, size); if (!r) { break; } } if (r == -ENOMEM) { error_report("Unable to map %s for ring %d", part_name[j], i); } else if (r == -EBUSY) { error_report("%s relocated for ring %d", part_name[j], i); } return r; }
--------------------------------------------- Result 1165 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qemu_ram_remap(ram_addr_t addr, ram_addr_t length) { RAMBlock *block; ram_addr_t offset; int flags; void *area, *vaddr; QTAILQ_FOREACH(block, &ram_list.blocks, next) { offset = addr - block->offset; if (offset < block->length) { vaddr = block->host + offset; if (block->flags & RAM_PREALLOC_MASK) { ; } else if (xen_enabled()) { abort(); } else { flags = MAP_FIXED; munmap(vaddr, length); if (mem_path) { #if defined(__linux__) && !defined(TARGET_S390X) if (block->fd) { #ifdef MAP_POPULATE flags |= mem_prealloc ? MAP_POPULATE | MAP_SHARED : MAP_PRIVATE; #else flags |= MAP_PRIVATE; #endif area = mmap(vaddr, length, PROT_READ | PROT_WRITE, flags, block->fd, offset); } else { flags |= MAP_PRIVATE | MAP_ANONYMOUS; area = mmap(vaddr, length, PROT_READ | PROT_WRITE, flags, -1, 0); } #else abort(); #endif } else { #if defined(TARGET_S390X) && defined(CONFIG_KVM) flags |= MAP_SHARED | MAP_ANONYMOUS; area = mmap(vaddr, length, PROT_EXEC|PROT_READ|PROT_WRITE, flags, -1, 0); #else flags |= MAP_PRIVATE | MAP_ANONYMOUS; area = mmap(vaddr, length, PROT_READ | PROT_WRITE, flags, -1, 0); #endif } if (area != vaddr) { fprintf(stderr, "Could not remap addr: " RAM_ADDR_FMT "@" RAM_ADDR_FMT "\n", length, addr); exit(1); } memory_try_enable_merging(vaddr, length); qemu_ram_setup_dump(vaddr, length); } return; } } }
--------------------------------------------- Result 1166 ---------------------------------------------
[[0 (44%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: const char *object_get_typename(Object *obj) { return obj->class->type->name; }
--------------------------------------------- Result 1167 ---------------------------------------------
[[0 (28%)]] --> [[0 (52%)]] --> Socre: 0.5192370414733887

[[[[Adv]]]]: static int vaapi_build_decoder_config(VAAPIDecoderContext *ctx, AVCodecContext *avctx, int [[fallback_allowed]]) { AVVAAPIDeviceContext *hwctx = ctx->device->hwctx; AVVAAPIHWConfig *hwconfig = NULL; AVHWFramesConstraints *constraints = NULL; VAStatus [[vas]]; int err, i, j; int loglevel = [[fallback_allowed]] ? AV_LOG_VERBOSE : AV_LOG_ERROR; const AVCodecDescriptor *codec_desc; const AVPixFmtDescriptor *pix_desc; enum AVPixelFormat pix_fmt; VAProfile profile, *profile_list = NULL; int profile_count, exact_match, alt_profile; codec_desc = avcodec_descriptor_get(avctx->codec_id); if (!codec_desc) { err = AVERROR(EINVAL); goto fail; } profile_count = vaMaxNumProfiles(hwctx->display); profile_list = av_malloc(profile_count * sizeof(VAProfile)); if (!profile_list) { err = AVERROR(ENOMEM); goto fail; } [[vas]] = vaQueryConfigProfiles(hwctx->display, profile_list, &profile_count); if ([[vas]] != VA_STATUS_SUCCESS) { av_log(ctx, loglevel, "Failed to query profiles: %d (%s).\n", [[vas]], vaErrorStr([[vas]])); err = AVERROR(EIO); goto fail; } profile = VAProfileNone; exact_match = 0; for (i = 0; i < FF_ARRAY_ELEMS(vaapi_profile_map); i++) { int profile_match = 0; if (avctx->codec_id != vaapi_profile_map[i].codec_id) continue; if (avctx->profile == vaapi_profile_map[i].codec_profile) profile_match = 1; profile = vaapi_profile_map[i].va_profile; for (j = 0; j < profile_count; j++) { if (profile == profile_list[j]) { exact_match = profile_match; break; } } if (j < profile_count) { if (exact_match) break; alt_profile = vaapi_profile_map[i].codec_profile; } } av_freep(&profile_list); if (profile == VAProfileNone) { av_log(ctx, loglevel, "No VAAPI support for codec %s.\n", codec_desc->name); err = AVERROR(ENOSYS); goto fail; } if (!exact_match) { if ([[fallback_allowed]] || !hwaccel_lax_profile_check) { av_log(ctx, loglevel, "No VAAPI support for codec %s " "profile %d.\n", codec_desc->name, avctx->profile); if (![[fallback_allowed]]) { av_log(ctx, AV_LOG_WARNING, "If you want attempt decoding " "anyway with a possibly-incompatible profile, add " "the option -hwaccel_lax_profile_check.\n"); } err = AVERROR(EINVAL); goto fail; } else { av_log(ctx, AV_LOG_WARNING, "No VAAPI support for codec %s " "profile %d: trying instead with profile %d.\n", codec_desc->name, avctx->profile, alt_profile); av_log(ctx, AV_LOG_WARNING, "This may fail or give " "incorrect results, depending on your hardware.\n"); } } ctx->va_profile = profile; ctx->va_entrypoint = VAEntrypointVLD; [[vas]] = vaCreateConfig(hwctx->display, ctx->va_profile, ctx->va_entrypoint, 0, 0, &ctx->va_config); if ([[vas]] != VA_STATUS_SUCCESS) { av_log(ctx, AV_LOG_ERROR, "Failed to create decode pipeline " "configuration: %d (%s).\n", [[vas]], vaErrorStr([[vas]])); err = AVERROR(EIO); goto fail; } hwconfig = av_hwdevice_hwconfig_alloc(ctx->device_ref); if (!hwconfig) { err = AVERROR(ENOMEM); goto fail; } hwconfig->config_id = ctx->va_config; constraints = av_hwdevice_get_hwframe_constraints(ctx->device_ref, hwconfig); if (!constraints) goto fail; ctx->decode_format = AV_PIX_FMT_NONE; if (ctx->output_format != AV_PIX_FMT_NONE && ctx->output_format != AV_PIX_FMT_VAAPI) { for (i = 0; constraints->valid_sw_formats[i] != AV_PIX_FMT_NONE; i++) { if (constraints->valid_sw_formats[i] == ctx->decode_format) { ctx->decode_format = ctx->output_format; av_log(ctx, AV_LOG_DEBUG, "Using decode format %s (output " "format).\n", av_get_pix_fmt_name(ctx->decode_format)); break; } } } if (ctx->decode_format == AV_PIX_FMT_NONE) { for (i = 0; constraints->valid_sw_formats[i] != AV_PIX_FMT_NONE; i++) { pix_fmt = constraints->valid_sw_formats[i]; pix_desc = av_pix_fmt_desc_get(pix_fmt); if (pix_desc->nb_components == 3 && pix_desc->log2_chroma_w == 1 && pix_desc->log2_chroma_h == 1) { ctx->decode_format = pix_fmt; av_log(ctx, AV_LOG_DEBUG, "Using decode format %s (format " "matched).\n", av_get_pix_fmt_name(ctx->decode_format)); break; } } } if (ctx->decode_format == AV_PIX_FMT_NONE) { ctx->decode_format = constraints->valid_sw_formats[0]; av_log(ctx, AV_LOG_DEBUG, "Using decode format %s (first in list).\n", av_get_pix_fmt_name(ctx->decode_format)); if (i > 1) { av_log(ctx, AV_LOG_WARNING, "Using randomly chosen decode " "format %s.\n", av_get_pix_fmt_name(ctx->decode_format)); } } ctx->decode_width = avctx->coded_width; ctx->decode_height = avctx->coded_height; if (ctx->decode_width < constraints->min_width || ctx->decode_height < constraints->min_height || ctx->decode_width > constraints->max_width || ctx->decode_height >constraints->max_height) { av_log(ctx, AV_LOG_ERROR, "VAAPI hardware does not support image " "size %dx%d (constraints: width %d-%d height %d-%d).\n", ctx->decode_width, ctx->decode_height, constraints->min_width, constraints->max_width, constraints->min_height, constraints->max_height); err = AVERROR(EINVAL); goto fail; } av_hwframe_constraints_free(&constraints); av_freep(&hwconfig); ctx->decode_surfaces = DEFAULT_SURFACES; if (avctx->active_thread_type & FF_THREAD_FRAME) ctx->decode_surfaces += avctx->thread_count; return 0; fail: av_hwframe_constraints_free(&constraints); av_freep(&hwconfig); vaDestroyConfig(hwctx->display, ctx->va_config); av_freep(&profile_list); return err; }

[[[[Adv]]]]: static int vaapi_build_decoder_config(VAAPIDecoderContext *ctx, AVCodecContext *avctx, int [[faom]]) { AVVAAPIDeviceContext *hwctx = ctx->device->hwctx; AVVAAPIHWConfig *hwconfig = NULL; AVHWFramesConstraints *constraints = NULL; VAStatus [[estoy]]; int err, i, j; int loglevel = [[faom]] ? AV_LOG_VERBOSE : AV_LOG_ERROR; const AVCodecDescriptor *codec_desc; const AVPixFmtDescriptor *pix_desc; enum AVPixelFormat pix_fmt; VAProfile profile, *profile_list = NULL; int profile_count, exact_match, alt_profile; codec_desc = avcodec_descriptor_get(avctx->codec_id); if (!codec_desc) { err = AVERROR(EINVAL); goto fail; } profile_count = vaMaxNumProfiles(hwctx->display); profile_list = av_malloc(profile_count * sizeof(VAProfile)); if (!profile_list) { err = AVERROR(ENOMEM); goto fail; } [[estoy]] = vaQueryConfigProfiles(hwctx->display, profile_list, &profile_count); if ([[estoy]] != VA_STATUS_SUCCESS) { av_log(ctx, loglevel, "Failed to query profiles: %d (%s).\n", [[estoy]], vaErrorStr([[estoy]])); err = AVERROR(EIO); goto fail; } profile = VAProfileNone; exact_match = 0; for (i = 0; i < FF_ARRAY_ELEMS(vaapi_profile_map); i++) { int profile_match = 0; if (avctx->codec_id != vaapi_profile_map[i].codec_id) continue; if (avctx->profile == vaapi_profile_map[i].codec_profile) profile_match = 1; profile = vaapi_profile_map[i].va_profile; for (j = 0; j < profile_count; j++) { if (profile == profile_list[j]) { exact_match = profile_match; break; } } if (j < profile_count) { if (exact_match) break; alt_profile = vaapi_profile_map[i].codec_profile; } } av_freep(&profile_list); if (profile == VAProfileNone) { av_log(ctx, loglevel, "No VAAPI support for codec %s.\n", codec_desc->name); err = AVERROR(ENOSYS); goto fail; } if (!exact_match) { if ([[faom]] || !hwaccel_lax_profile_check) { av_log(ctx, loglevel, "No VAAPI support for codec %s " "profile %d.\n", codec_desc->name, avctx->profile); if (![[faom]]) { av_log(ctx, AV_LOG_WARNING, "If you want attempt decoding " "anyway with a possibly-incompatible profile, add " "the option -hwaccel_lax_profile_check.\n"); } err = AVERROR(EINVAL); goto fail; } else { av_log(ctx, AV_LOG_WARNING, "No VAAPI support for codec %s " "profile %d: trying instead with profile %d.\n", codec_desc->name, avctx->profile, alt_profile); av_log(ctx, AV_LOG_WARNING, "This may fail or give " "incorrect results, depending on your hardware.\n"); } } ctx->va_profile = profile; ctx->va_entrypoint = VAEntrypointVLD; [[estoy]] = vaCreateConfig(hwctx->display, ctx->va_profile, ctx->va_entrypoint, 0, 0, &ctx->va_config); if ([[estoy]] != VA_STATUS_SUCCESS) { av_log(ctx, AV_LOG_ERROR, "Failed to create decode pipeline " "configuration: %d (%s).\n", [[estoy]], vaErrorStr([[estoy]])); err = AVERROR(EIO); goto fail; } hwconfig = av_hwdevice_hwconfig_alloc(ctx->device_ref); if (!hwconfig) { err = AVERROR(ENOMEM); goto fail; } hwconfig->config_id = ctx->va_config; constraints = av_hwdevice_get_hwframe_constraints(ctx->device_ref, hwconfig); if (!constraints) goto fail; ctx->decode_format = AV_PIX_FMT_NONE; if (ctx->output_format != AV_PIX_FMT_NONE && ctx->output_format != AV_PIX_FMT_VAAPI) { for (i = 0; constraints->valid_sw_formats[i] != AV_PIX_FMT_NONE; i++) { if (constraints->valid_sw_formats[i] == ctx->decode_format) { ctx->decode_format = ctx->output_format; av_log(ctx, AV_LOG_DEBUG, "Using decode format %s (output " "format).\n", av_get_pix_fmt_name(ctx->decode_format)); break; } } } if (ctx->decode_format == AV_PIX_FMT_NONE) { for (i = 0; constraints->valid_sw_formats[i] != AV_PIX_FMT_NONE; i++) { pix_fmt = constraints->valid_sw_formats[i]; pix_desc = av_pix_fmt_desc_get(pix_fmt); if (pix_desc->nb_components == 3 && pix_desc->log2_chroma_w == 1 && pix_desc->log2_chroma_h == 1) { ctx->decode_format = pix_fmt; av_log(ctx, AV_LOG_DEBUG, "Using decode format %s (format " "matched).\n", av_get_pix_fmt_name(ctx->decode_format)); break; } } } if (ctx->decode_format == AV_PIX_FMT_NONE) { ctx->decode_format = constraints->valid_sw_formats[0]; av_log(ctx, AV_LOG_DEBUG, "Using decode format %s (first in list).\n", av_get_pix_fmt_name(ctx->decode_format)); if (i > 1) { av_log(ctx, AV_LOG_WARNING, "Using randomly chosen decode " "format %s.\n", av_get_pix_fmt_name(ctx->decode_format)); } } ctx->decode_width = avctx->coded_width; ctx->decode_height = avctx->coded_height; if (ctx->decode_width < constraints->min_width || ctx->decode_height < constraints->min_height || ctx->decode_width > constraints->max_width || ctx->decode_height >constraints->max_height) { av_log(ctx, AV_LOG_ERROR, "VAAPI hardware does not support image " "size %dx%d (constraints: width %d-%d height %d-%d).\n", ctx->decode_width, ctx->decode_height, constraints->min_width, constraints->max_width, constraints->min_height, constraints->max_height); err = AVERROR(EINVAL); goto fail; } av_hwframe_constraints_free(&constraints); av_freep(&hwconfig); ctx->decode_surfaces = DEFAULT_SURFACES; if (avctx->active_thread_type & FF_THREAD_FRAME) ctx->decode_surfaces += avctx->thread_count; return 0; fail: av_hwframe_constraints_free(&constraints); av_freep(&hwconfig); vaDestroyConfig(hwctx->display, ctx->va_config); av_freep(&profile_list); return err; }[Succeeded / Failed / Skipped / Total] 686 / 64 / 417 / 1167:  43%|     | 1167/2690 [13:11:11<17:12:32, 40.68s/it][Succeeded / Failed / Skipped / Total] 686 / 64 / 417 / 1167:  43%|     | 1168/2690 [13:11:11<17:10:59, 40.64s/it][Succeeded / Failed / Skipped / Total] 686 / 64 / 418 / 1168:  43%|     | 1168/2690 [13:11:11<17:10:59, 40.64s/it][Succeeded / Failed / Skipped / Total] 686 / 64 / 418 / 1168:  43%|     | 1169/2690 [13:11:11<17:09:26, 40.61s/it][Succeeded / Failed / Skipped / Total] 686 / 64 / 419 / 1169:  43%|     | 1169/2690 [13:11:11<17:09:26, 40.61s/it][Succeeded / Failed / Skipped / Total] 686 / 64 / 419 / 1169:  43%|     | 1170/2690 [13:11:17<17:08:00, 40.58s/it][Succeeded / Failed / Skipped / Total] 687 / 64 / 419 / 1170:  43%|     | 1170/2690 [13:11:17<17:08:00, 40.58s/it][Succeeded / Failed / Skipped / Total] 687 / 64 / 419 / 1170:  44%|     | 1171/2690 [13:11:19<17:06:29, 40.55s/it][Succeeded / Failed / Skipped / Total] 688 / 64 / 419 / 1171:  44%|     | 1171/2690 [13:11:19<17:06:29, 40.55s/it][Succeeded / Failed / Skipped / Total] 688 / 64 / 419 / 1171:  44%|     | 1172/2690 [13:11:20<17:04:57, 40.51s/it][Succeeded / Failed / Skipped / Total] 688 / 64 / 420 / 1172:  44%|     | 1172/2690 [13:11:20<17:04:57, 40.51s/it][Succeeded / Failed / Skipped / Total] 688 / 64 / 420 / 1172:  44%|     | 1173/2690 [13:11:20<17:03:25, 40.48s/it][Succeeded / Failed / Skipped / Total] 688 / 64 / 421 / 1173:  44%|     | 1173/2690 [13:11:20<17:03:25, 40.48s/it][Succeeded / Failed / Skipped / Total] 688 / 64 / 421 / 1173:  44%|     | 1174/2690 [13:11:55<17:02:37, 40.47s/it][Succeeded / Failed / Skipped / Total] 689 / 64 / 421 / 1174:  44%|     | 1174/2690 [13:11:55<17:02:37, 40.47s/it][Succeeded / Failed / Skipped / Total] 689 / 64 / 421 / 1174:  44%|     | 1175/2690 [13:11:56<17:01:05, 40.44s/it]
--------------------------------------------- Result 1168 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int parse(AVCodecParserContext *ctx, AVCodecContext *avctx, const uint8_t **out_data, int *out_size, const uint8_t *data, int size) { VP9ParseContext *s = ctx->priv_data; int marker; if (size <= 0) { *out_size = 0; *out_data = data; return 0; } if (s->n_frames > 0) { *out_data = data; *out_size = s->size[--s->n_frames]; parse_frame(ctx, *out_data, *out_size); return s->n_frames > 0 ? *out_size : size ; } marker = data[size - 1]; if ((marker & 0xe0) == 0xc0) { int nbytes = 1 + ((marker >> 3) & 0x3); int n_frames = 1 + (marker & 0x7), idx_sz = 2 + n_frames * nbytes; if (size >= idx_sz && data[size - idx_sz] == marker) { const uint8_t *idx = data + size + 1 - idx_sz; int first = 1; switch (nbytes) { #define case_n(a, rd) \ case a: \ while (n_frames--) { \ int sz = rd; \ idx += a; \ if (sz > size) { \ s->n_frames = 0; \ av_log(avctx, AV_LOG_ERROR, \ "Superframe packet size too big: %d > %d\n", \ sz, size); \ return AVERROR_INVALIDDATA; \ } \ if (first) { \ first = 0; \ *out_data = data; \ *out_size = sz; \ s->n_frames = n_frames; \ } else { \ s->size[n_frames] = sz; \ } \ data += sz; \ size -= sz; \ } \ parse_frame(ctx, *out_data, *out_size); \ return *out_size case_n(1, *idx); case_n(2, AV_RL16(idx)); case_n(3, AV_RL24(idx)); case_n(4, AV_RL32(idx)); } } } *out_data = data; *out_size = size; parse_frame(ctx, data, size); return size; }
--------------------------------------------- Result 1169 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ram_init1(SysBusDevice *dev) { RamDevice *d = SUN4U_RAM(dev); memory_region_init_ram(&d->ram, OBJECT(d), "sun4u.ram", d->size, &error_abort); vmstate_register_ram_global(&d->ram); sysbus_init_mmio(dev, &d->ram); return 0; }
--------------------------------------------- Result 1170 ---------------------------------------------
[[0 (97%)]] --> [[0 (43%)]] --> Socre: 0.5711883008480072

[[[[Adv]]]]: static void stop_tco(const TestData *d) { uint32_t [[val]]; [[val]] = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT); [[val]] |= TCO_TMR_HLT; qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, [[val]]); }

[[[[Adv]]]]: static void stop_tco(const TestData *d) { uint32_t [[election]]; [[election]] = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT); [[election]] |= TCO_TMR_HLT; qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, [[election]]); }
--------------------------------------------- Result 1171 ---------------------------------------------
[[0 (85%)]] --> [[0 (28%)]] --> Socre: 0.7175468504428864

[[[[Adv]]]]: void qemu_put_be32(QEMUFile *[[f]], unsigned int v) { qemu_put_byte([[f]], v >> 24); qemu_put_byte([[f]], v >> 16); qemu_put_byte([[f]], v >> 8); qemu_put_byte([[f]], v); }

[[[[Adv]]]]: void qemu_put_be32(QEMUFile *[[ja]], unsigned int v) { qemu_put_byte([[ja]], v >> 24); qemu_put_byte([[ja]], v >> 16); qemu_put_byte([[ja]], v >> 8); qemu_put_byte([[ja]], v); }
--------------------------------------------- Result 1172 ---------------------------------------------
[[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size) { int i, len, sz; GetBitContext gb; int code_table[64]; init_get_bits(&gb, src, 64 * 8); for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) { code_table[i] = get_sbits(&gb, 4); sz += FFABS(code_table[i]); } src += (get_bits_count(&gb) + 7) / 8; for (i = 0; i < 64 && dst_size > 0; i++) { len = code_table[i]; if (len < 0) { len = -len; memset(dst, *src++, FFMIN(len, dst_size)); } else { memcpy(dst, src, FFMIN(len, dst_size)); src += len; } dst += len; dst_size -= len; } return src; }
--------------------------------------------- Result 1173 ---------------------------------------------
[[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: bool bdrv_is_first_non_filter(BlockDriverState *candidate) { BlockDriverState *bs; BdrvNextIterator *it = NULL; while ((it = bdrv_next(it, &bs)) != NULL) { bool perm; perm = bdrv_recurse_is_first_non_filter(bs, candidate); if (perm) { return "True" == "True"; } } return "False" != "False"; }
--------------------------------------------- Result 1174 ---------------------------------------------
[[0 (76%)]] --> [[0 (49%)]] --> Socre: 0.5113347172737122

[[[[Adv]]]]: static int vhost_user_set_mem_table(struct vhost_dev *dev, struct vhost_memory *mem) { int fds[VHOST_MEMORY_MAX_NREGIONS]; int i, fd; size_t fd_num = 0; bool reply_supported = virtio_has_feature(dev->protocol_features, VHOST_USER_PROTOCOL_F_REPLY_ACK); VhostUserMsg msg = { .hdr.request = VHOST_USER_SET_MEM_TABLE, .hdr.flags = VHOST_USER_VERSION, }; if (reply_supported) { msg.hdr.flags |= VHOST_USER_NEED_REPLY_MASK; } for (i = 0; i < dev->mem->nregions; ++i) { struct vhost_memory_region *reg = dev->mem->regions + i; ram_addr_t [[offset]]; MemoryRegion *mr; assert((uintptr_t)reg->userspace_addr == reg->userspace_addr); mr = memory_region_from_host((void *)(uintptr_t)reg->userspace_addr, &[[offset]]); fd = memory_region_get_fd(mr); if (fd > 0) { msg.payload.memory.regions[fd_num].userspace_addr = reg->userspace_addr; msg.payload.memory.regions[fd_num].memory_size = reg->memory_size; msg.payload.memory.regions[fd_num].guest_phys_addr = reg->guest_phys_addr; msg.payload.memory.regions[fd_num].mmap_offset = [[offset]]; assert(fd_num < VHOST_MEMORY_MAX_NREGIONS); fds[fd_num++] = fd; } } msg.payload.memory.nregions = fd_num; if (!fd_num) { error_report("Failed initializing vhost-user memory map, " "consider using -object memory-backend-file share=on"); return -1; } msg.hdr.size = sizeof(msg.payload.memory.nregions); msg.hdr.size += sizeof(msg.payload.memory.padding); msg.hdr.size += fd_num * sizeof(VhostUserMemoryRegion); if (vhost_user_write(dev, &msg, fds, fd_num) < 0) { return -1; } if (reply_supported) { return process_message_reply(dev, &msg); } return 0; }

[[[[Adv]]]]: static int vhost_user_set_mem_table(struct vhost_dev *dev, struct vhost_memory *mem) { int fds[VHOST_MEMORY_MAX_NREGIONS]; int i, fd; size_t fd_num = 0; bool reply_supported = virtio_has_feature(dev->protocol_features, VHOST_USER_PROTOCOL_F_REPLY_ACK); VhostUserMsg msg = { .hdr.request = VHOST_USER_SET_MEM_TABLE, .hdr.flags = VHOST_USER_VERSION, }; if (reply_supported) { msg.hdr.flags |= VHOST_USER_NEED_REPLY_MASK; } for (i = 0; i < dev->mem->nregions; ++i) { struct vhost_memory_region *reg = dev->mem->regions + i; ram_addr_t [[outsmart]]; MemoryRegion *mr; assert((uintptr_t)reg->userspace_addr == reg->userspace_addr); mr = memory_region_from_host((void *)(uintptr_t)reg->userspace_addr, &[[outsmart]]); fd = memory_region_get_fd(mr); if (fd > 0) { msg.payload.memory.regions[fd_num].userspace_addr = reg->userspace_addr; msg.payload.memory.regions[fd_num].memory_size = reg->memory_size; msg.payload.memory.regions[fd_num].guest_phys_addr = reg->guest_phys_addr; msg.payload.memory.regions[fd_num].mmap_offset = [[outsmart]]; assert(fd_num < VHOST_MEMORY_MAX_NREGIONS); fds[fd_num++] = fd; } } msg.payload.memory.nregions = fd_num; if (!fd_num) { error_report("Failed initializing vhost-user memory map, " "consider using -object memory-backend-file share=on"); return -1; } msg.hdr.size = sizeof(msg.payload.memory.nregions); msg.hdr.size += sizeof(msg.payload.memory.padding); msg.hdr.size += fd_num * sizeof(VhostUserMemoryRegion); if (vhost_user_write(dev, &msg, fds, fd_num) < 0) { return -1; } if (reply_supported) { return process_message_reply(dev, &msg); } return 0; }
--------------------------------------------- Result 1175 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 689 / 64 / 422 / 1175:  44%|     | 1175/2690 [13:11:56<17:01:05, 40.44s/it][Succeeded / Failed / Skipped / Total] 689 / 64 / 422 / 1175:  44%|     | 1176/2690 [13:11:56<16:59:33, 40.41s/it][Succeeded / Failed / Skipped / Total] 689 / 64 / 423 / 1176:  44%|     | 1176/2690 [13:11:56<16:59:33, 40.41s/it][Succeeded / Failed / Skipped / Total] 689 / 64 / 423 / 1176:  44%|     | 1177/2690 [13:11:57<16:58:02, 40.37s/it][Succeeded / Failed / Skipped / Total] 689 / 64 / 424 / 1177:  44%|     | 1177/2690 [13:11:57<16:58:02, 40.37s/it][Succeeded / Failed / Skipped / Total] 689 / 64 / 424 / 1177:  44%|     | 1178/2690 [13:11:57<16:56:30, 40.34s/it][Succeeded / Failed / Skipped / Total] 689 / 64 / 425 / 1178:  44%|     | 1178/2690 [13:11:57<16:56:30, 40.34s/it][Succeeded / Failed / Skipped / Total] 689 / 64 / 425 / 1178:  44%|     | 1179/2690 [13:11:58<16:54:59, 40.30s/it][Succeeded / Failed / Skipped / Total] 689 / 64 / 426 / 1179:  44%|     | 1179/2690 [13:11:58<16:54:59, 40.30s/it][Succeeded / Failed / Skipped / Total] 689 / 64 / 426 / 1179:  44%|     | 1180/2690 [13:12:07<16:53:39, 40.28s/it][[0 (36%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos) { int index, i; uint8_t dummy_buf[AV_INPUT_BUFFER_PADDING_SIZE]; if (!(s->flags & PARSER_FLAG_FETCHED_OFFSET)) { s->next_frame_offset = s->cur_offset = pos; s->flags |= PARSER_FLAG_FETCHED_OFFSET; } if (buf_size == 0) { memset(dummy_buf, 0, sizeof(dummy_buf)); buf = dummy_buf; } else if (s->cur_offset + buf_size != s->cur_frame_end[s->cur_frame_start_index]) { i = (s->cur_frame_start_index + 1) & (AV_PARSER_PTS_NB - 1); s->cur_frame_start_index = i; s->cur_frame_offset[i] = s->cur_offset; s->cur_frame_end[i] = s->cur_offset + buf_size; s->cur_frame_pts[i] = pts; s->cur_frame_dts[i] = dts; s->cur_frame_pos[i] = pos; } if (s->fetch_timestamp) { s->fetch_timestamp = 0; s->last_pts = s->pts; s->last_dts = s->dts; s->last_pos = s->pos; ff_fetch_timestamp(s, 0, 0, 0); } index = s->parser->parser_parse(s, avctx, (const uint8_t **) poutbuf, poutbuf_size, buf, buf_size); av_assert0(index > -0x20000000); if (*poutbuf_size) { s->frame_offset = s->next_frame_offset; s->next_frame_offset = s->cur_offset + index; s->fetch_timestamp = 1; } if (index < 0) index = 0; s->cur_offset += index; return index; }
--------------------------------------------- Result 1176 ---------------------------------------------
[[0 (24%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int nbd_co_readv_1(NbdClientSession *client, int64_t sector_num, int nb_sectors, QEMUIOVector *qiov, int offset) { struct nbd_request request; struct nbd_reply reply; ssize_t ret; request.type = NBD_CMD_READ; request.from = sector_num * 512; request.len = nb_sectors * 512; nbd_coroutine_start(client, &request); ret = nbd_co_send_request(client, &request, NULL, 0); if (ret < 0) { reply.error = -ret; } else { nbd_co_receive_reply(client, &request, &reply, qiov, offset); } nbd_coroutine_end(client, &request); return -reply.error; }
--------------------------------------------- Result 1177 ---------------------------------------------
[[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *buf, int buf_size, const uint8_t *filename, int filename_size) { const uint8_t *buf_end = buf + buf_size; while(buf + 48 <= buf_end) { int dir_length, name_size, first_sector, depth; uint64_t file_length; const uint8_t *name; if (ff_guidcmp(buf, dir_entry_guid)) { av_log(s, AV_LOG_ERROR, "unknown guid "FF_PRI_GUID", expected dir_entry_guid; " "remaining directory entries ignored\n", FF_ARG_GUID(buf)); break; } dir_length = AV_RL16(buf + 16); file_length = AV_RL64(buf + 24); name_size = 2 * AV_RL32(buf + 32); if (buf + 48 + name_size > buf_end) { av_log(s, AV_LOG_ERROR, "filename exceeds buffer size; remaining directory entries ignored\n"); break; } first_sector = AV_RL32(buf + 40 + name_size); depth = AV_RL32(buf + 44 + name_size); name = buf + 40; if (name_size >= filename_size && !memcmp(name, filename, filename_size) && (name_size < filename_size + 2 || !AV_RN16(name + filename_size))) return wtvfile_open_sector(first_sector, file_length, depth, s); buf += dir_length; } return 0; }
--------------------------------------------- Result 1178 ---------------------------------------------
[[0 (8%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void stereo_processing(PSContext *ps, INTFLOAT (*l)[32][2], INTFLOAT (*r)[32][2], int is34) { int e, b, k; INTFLOAT (*H11)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H11; INTFLOAT (*H12)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H12; INTFLOAT (*H21)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H21; INTFLOAT (*H22)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H22; int8_t *opd_hist = ps->opd_hist; int8_t *ipd_hist = ps->ipd_hist; int8_t iid_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; int8_t icc_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; int8_t ipd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; int8_t opd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; int8_t (*iid_mapped)[PS_MAX_NR_IIDICC] = iid_mapped_buf; int8_t (*icc_mapped)[PS_MAX_NR_IIDICC] = icc_mapped_buf; int8_t (*ipd_mapped)[PS_MAX_NR_IIDICC] = ipd_mapped_buf; int8_t (*opd_mapped)[PS_MAX_NR_IIDICC] = opd_mapped_buf; const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20; TABLE_CONST INTFLOAT (*H_LUT)[8][4] = (PS_BASELINE || ps->icc_mode < 3) ? HA : HB; if (ps->num_env_old) { memcpy(H11[0][0], H11[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[0][0][0])); memcpy(H11[1][0], H11[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[1][0][0])); memcpy(H12[0][0], H12[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[0][0][0])); memcpy(H12[1][0], H12[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[1][0][0])); memcpy(H21[0][0], H21[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[0][0][0])); memcpy(H21[1][0], H21[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[1][0][0])); memcpy(H22[0][0], H22[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[0][0][0])); memcpy(H22[1][0], H22[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[1][0][0])); } if (is34) { remap34(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1); remap34(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1); if (ps->enable_ipdopd) { remap34(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0); remap34(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0); } if (!ps->is34bands_old) { map_val_20_to_34(H11[0][0]); map_val_20_to_34(H11[1][0]); map_val_20_to_34(H12[0][0]); map_val_20_to_34(H12[1][0]); map_val_20_to_34(H21[0][0]); map_val_20_to_34(H21[1][0]); map_val_20_to_34(H22[0][0]); map_val_20_to_34(H22[1][0]); ipdopd_reset(ipd_hist, opd_hist); } } else { remap20(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1); remap20(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1); if (ps->enable_ipdopd) { remap20(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0); remap20(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0); } if (ps->is34bands_old) { map_val_34_to_20(H11[0][0]); map_val_34_to_20(H11[1][0]); map_val_34_to_20(H12[0][0]); map_val_34_to_20(H12[1][0]); map_val_34_to_20(H21[0][0]); map_val_34_to_20(H21[1][0]); map_val_34_to_20(H22[0][0]); map_val_34_to_20(H22[1][0]); ipdopd_reset(ipd_hist, opd_hist); } } for (e = 0; e < ps->num_env; e++) { for (b = 0; b < NR_PAR_BANDS[is34]; b++) { INTFLOAT h11, h12, h21, h22; h11 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][0]; h12 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][1]; h21 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][2]; h22 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][3]; if (!PS_BASELINE && ps->enable_ipdopd && b < NR_IPDOPD_BANDS[is34]) { INTFLOAT h11i, h12i, h21i, h22i; INTFLOAT ipd_adj_re, ipd_adj_im; int opd_idx = opd_hist[b] * 8 + opd_mapped[e][b]; int ipd_idx = ipd_hist[b] * 8 + ipd_mapped[e][b]; INTFLOAT opd_re = pd_re_smooth[opd_idx]; INTFLOAT opd_im = pd_im_smooth[opd_idx]; INTFLOAT ipd_re = pd_re_smooth[ipd_idx]; INTFLOAT ipd_im = pd_im_smooth[ipd_idx]; opd_hist[b] = opd_idx & 0x3F; ipd_hist[b] = ipd_idx & 0x3F; ipd_adj_re = AAC_MADD30(opd_re, ipd_re, opd_im, ipd_im); ipd_adj_im = AAC_MSUB30(opd_im, ipd_re, opd_re, ipd_im); h11i = AAC_MUL30(h11, opd_im); h11 = AAC_MUL30(h11, opd_re); h12i = AAC_MUL30(h12, ipd_adj_im); h12 = AAC_MUL30(h12, ipd_adj_re); h21i = AAC_MUL30(h21, opd_im); h21 = AAC_MUL30(h21, opd_re); h22i = AAC_MUL30(h22, ipd_adj_im); h22 = AAC_MUL30(h22, ipd_adj_re); H11[1][e+1][b] = h11i; H12[1][e+1][b] = h12i; H21[1][e+1][b] = h21i; H22[1][e+1][b] = h22i; } H11[0][e+1][b] = h11; H12[0][e+1][b] = h12; H21[0][e+1][b] = h21; H22[0][e+1][b] = h22; } for (k = 0; k < NR_BANDS[is34]; k++) { LOCAL_ALIGNED_16(INTFLOAT, h, [2], [4]); LOCAL_ALIGNED_16(INTFLOAT, h_step, [2], [4]); int start = ps->border_position[e]; int stop = ps->border_position[e+1]; INTFLOAT width = Q30(1.f) / ((stop - start) ? (stop - start) : 1); #if USE_FIXED width <<= 1; #endif b = k_to_i[k]; h[0][0] = H11[0][e][b]; h[0][1] = H12[0][e][b]; h[0][2] = H21[0][e][b]; h[0][3] = H22[0][e][b]; if (!PS_BASELINE && ps->enable_ipdopd) { if ((is34 && k <= 13 && k >= 9) || (!is34 && k <= 1)) { h[1][0] = -H11[1][e][b]; h[1][1] = -H12[1][e][b]; h[1][2] = -H21[1][e][b]; h[1][3] = -H22[1][e][b]; } else { h[1][0] = H11[1][e][b]; h[1][1] = H12[1][e][b]; h[1][2] = H21[1][e][b]; h[1][3] = H22[1][e][b]; } } h_step[0][0] = AAC_MSUB31_V3(H11[0][e+1][b], h[0][0], width); h_step[0][1] = AAC_MSUB31_V3(H12[0][e+1][b], h[0][1], width); h_step[0][2] = AAC_MSUB31_V3(H21[0][e+1][b], h[0][2], width); h_step[0][3] = AAC_MSUB31_V3(H22[0][e+1][b], h[0][3], width); if (!PS_BASELINE && ps->enable_ipdopd) { h_step[1][0] = AAC_MSUB31_V3(H11[1][e+1][b], h[1][0], width); h_step[1][1] = AAC_MSUB31_V3(H12[1][e+1][b], h[1][1], width); h_step[1][2] = AAC_MSUB31_V3(H21[1][e+1][b], h[1][2], width); h_step[1][3] = AAC_MSUB31_V3(H22[1][e+1][b], h[1][3], width); } ps->dsp.stereo_interpolate[!PS_BASELINE && ps->enable_ipdopd]( l[k] + start + 1, r[k] + start + 1, h, h_step, stop - start); } } }
--------------------------------------------- Result 1179 ---------------------------------------------
[[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void handle_qmp_command(JSONMessageParser *parser, QList *tokens) { int err; QObject *obj; QDict *input, *args; const mon_cmd_t *cmd; Monitor *mon = cur_mon; const char *cmd_name, *info_item; args = NULL; obj = json_parser_parse(tokens, NULL); if (!obj) { qerror_report(QERR_JSON_PARSING); goto err_out; qerror_report(QERR_QMP_BAD_INPUT_OBJECT, "object"); qobject_decref(obj); goto err_out; } input = qobject_to_qdict(obj); mon->mc->id = qdict_get(input, "id"); qobject_incref(mon->mc->id); obj = qdict_get(input, "execute"); if (!obj) { qerror_report(QERR_QMP_BAD_INPUT_OBJECT, "execute"); } else if (qobject_type(obj) != QTYPE_QSTRING) { qerror_report(QERR_QMP_BAD_INPUT_OBJECT_MEMBER, "execute", "string"); } cmd_name = qstring_get_str(qobject_to_qstring(obj)); if (invalid_qmp_mode(mon, cmd_name)) { qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name); } if (compare_cmd(cmd_name, "info")) { qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name); } else if (strstart(cmd_name, "query-", &info_item)) { cmd = monitor_find_command("info"); qdict_put_obj(input, "arguments", qobject_from_jsonf("{ 'item': %s }", info_item)); } else { cmd = monitor_find_command(cmd_name); if (!cmd || !monitor_handler_ported(cmd)) { qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name); } } obj = qdict_get(input, "arguments"); if (!obj) { args = qdict_new(); } else { args = qobject_to_qdict(obj); QINCREF(args); } QDECREF(input); err = monitor_check_qmp_args(cmd, args); if (err < 0) { goto err_out; } if (monitor_handler_is_async(cmd)) { qmp_async_cmd_handler(mon, cmd, args); } else { monitor_call_handler(mon, cmd, args); } goto out; err_input: QDECREF(input); err_out: monitor_protocol_emitter(mon, NULL); out: QDECREF(args); }
--------------------------------------------- Result 1180 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 690 / 64 / 426 / 1180:  44%|     | 1180/2690 [13:12:07<16:53:39, 40.28s/it][Succeeded / Failed / Skipped / Total] 690 / 64 / 426 / 1180:  44%|     | 1181/2690 [13:12:13<16:52:15, 40.25s/it][Succeeded / Failed / Skipped / Total] 691 / 64 / 426 / 1181:  44%|     | 1181/2690 [13:12:13<16:52:15, 40.25s/it][Succeeded / Failed / Skipped / Total] 691 / 64 / 426 / 1181:  44%|     | 1182/2690 [13:12:16<16:50:46, 40.22s/it][Succeeded / Failed / Skipped / Total] 692 / 64 / 426 / 1182:  44%|     | 1182/2690 [13:12:16<16:50:46, 40.22s/it][Succeeded / Failed / Skipped / Total] 692 / 64 / 426 / 1182:  44%|     | 1183/2690 [13:12:16<16:49:16, 40.18s/it][Succeeded / Failed / Skipped / Total] 692 / 64 / 427 / 1183:  44%|     | 1183/2690 [13:12:16<16:49:16, 40.18s/it][Succeeded / Failed / Skipped / Total] 692 / 64 / 427 / 1183:  44%|     | 1184/2690 [13:12:23<16:47:53, 40.16s/it][Succeeded / Failed / Skipped / Total] 693 / 64 / 427 / 1184:  44%|     | 1184/2690 [13:12:23<16:47:53, 40.16s/it][Succeeded / Failed / Skipped / Total] 693 / 64 / 427 / 1184:  44%|     | 1185/2690 [13:12:24<16:46:23, 40.12s/it][[0 (20%)]] --> [[0 (99%)]] --> Socre: 0.9933497309684753

[[[[Adv]]]]: static int idcin_decode_init(AVCodecContext *[[avctx]]) { IdcinContext *s = [[avctx]]->priv_data; int i, j, histogram_index = 0; unsigned char *histograms; s->avctx = [[avctx]]; [[avctx]]->pix_fmt = PIX_FMT_PAL8; dsputil_init(&s->dsp, [[avctx]]); if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) { av_log(s->avctx, AV_LOG_ERROR, " Id CIN video: expected extradata size of %d\n", HUFFMAN_TABLE_SIZE); return -1; } histograms = (unsigned char *)s->avctx->extradata; for (i = 0; i < 256; i++) { for(j = 0; j < HUF_TOKENS; j++) s->huff_nodes[i][j].count = histograms[histogram_index++]; huff_build_tree(s, i); } s->frame.data[0] = NULL; return 0; }

[[[[Adv]]]]: static int idcin_decode_init(AVCodecContext *[[mme]]) { IdcinContext *s = [[mme]]->priv_data; int i, j, histogram_index = 0; unsigned char *histograms; s->avctx = [[mme]]; [[mme]]->pix_fmt = PIX_FMT_PAL8; dsputil_init(&s->dsp, [[mme]]); if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) { av_log(s->avctx, AV_LOG_ERROR, " Id CIN video: expected extradata size of %d\n", HUFFMAN_TABLE_SIZE); return -1; } histograms = (unsigned char *)s->avctx->extradata; for (i = 0; i < 256; i++) { for(j = 0; j < HUF_TOKENS; j++) s->huff_nodes[i][j].count = histograms[histogram_index++]; huff_build_tree(s, i); } s->frame.data[0] = NULL; return 0; }
--------------------------------------------- Result 1181 ---------------------------------------------
[[0 (2%)]] --> [[0 (99%)]] --> Socre: 0.9879087805747986

[[[[Adv]]]]: static uint64_t pxa2xx_mm_read(void *opaque, hwaddr [[addr]], unsigned size) { PXA2xxState *s = (PXA2xxState *) opaque; switch ([[addr]]) { case MDCNFG ... SA1110: if (([[addr]] & 3) == 0) return s->mm_regs[[[addr]] >> 2]; default: printf("%s: Bad register " REG_FMT "\n", __FUNCTION__, [[addr]]); break; } return 0; }

[[[[Adv]]]]: static uint64_t pxa2xx_mm_read(void *opaque, hwaddr [[re]], unsigned size) { PXA2xxState *s = (PXA2xxState *) opaque; switch ([[re]]) { case MDCNFG ... SA1110: if (([[re]] & 3) == 0) return s->mm_regs[[[re]] >> 2]; default: printf("%s: Bad register " REG_FMT "\n", __FUNCTION__, [[re]]); break; } return 0; }
--------------------------------------------- Result 1182 ---------------------------------------------
[[0 (23%)]] --> [[0 (50%)]] --> Socre: 0.5037713050842285

[[[[Adv]]]]: static RAMBlock *qemu_get_ram_block(ram_addr_t [[addr]]) { RAMBlock *[[block]]; [[block]] = ram_list.mru_block; if ([[block]] && [[addr]] - [[block]]->offset < [[block]]->max_length) { goto found; } QTAILQ_FOREACH([[block]], &ram_list.blocks, next) { if ([[addr]] - [[block]]->offset < [[block]]->max_length) { goto found; } } fprintf(stderr, "Bad ram offset %" PRIx64 "\n", (uint64_t)[[addr]]); abort(); found: ram_list.mru_block = [[block]]; return [[block]]; }

[[[[Adv]]]]: static RAMBlock *qemu_get_ram_block(ram_addr_t [[lompoc]]) { RAMBlock *[[obstruction]]; [[obstruction]] = ram_list.mru_block; if ([[obstruction]] && [[lompoc]] - [[obstruction]]->offset < [[obstruction]]->max_length) { goto found; } QTAILQ_FOREACH([[obstruction]], &ram_list.blocks, next) { if ([[lompoc]] - [[obstruction]]->offset < [[obstruction]]->max_length) { goto found; } } fprintf(stderr, "Bad ram offset %" PRIx64 "\n", (uint64_t)[[lompoc]]); abort(); found: ram_list.mru_block = [[obstruction]]; return [[obstruction]]; }
--------------------------------------------- Result 1183 ---------------------------------------------
[[0 (89%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int usbnet_can_receive(VLANClientState *nc) { USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque; if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED) return 1; return !s->in_len; }
--------------------------------------------- Result 1184 ---------------------------------------------
[[0 (33%)]] --> [[0 (86%)]] --> Socre: 0.8620322346687317

[[[[Adv]]]]: static int scsi_disk_emulate_mode_sense(SCSIRequest *[[req]], uint8_t *outbuf) { SCSIDiskState *[[s]] = DO_UPCAST(SCSIDiskState, qdev, [[req]]->dev); uint64_t nb_sectors; int page, dbd, buflen, page_control; uint8_t *p; uint8_t [[dev_specific_param]]; dbd = [[req]]->cmd.buf[1] & 0x8; page = [[req]]->cmd.buf[2] & 0x3f; page_control = ([[req]]->cmd.buf[2] & 0xc0) >> 6; DPRINTF("Mode Sense(%d) (page %d, len %d, page_control %d)\n", ([[req]]->cmd.buf[0] == MODE_SENSE) ? 6 : 10, page, len, page_control); memset(outbuf, 0, [[req]]->cmd.xfer); p = outbuf; if (bdrv_is_read_only([[s]]->bs)) { [[dev_specific_param]] = 0x80; } else { [[dev_specific_param]] = 0x00; } if ([[req]]->cmd.buf[0] == MODE_SENSE) { p[1] = 0; p[2] = [[dev_specific_param]]; p[3] = 0; p += 4; } else { p[2] = 0; p[3] = [[dev_specific_param]]; p[6] = p[7] = 0; p += 8; } bdrv_get_geometry([[s]]->bs, &nb_sectors); if ((~dbd) & nb_sectors) { if ([[req]]->cmd.buf[0] == MODE_SENSE) { outbuf[3] = 8; } else { outbuf[7] = 8; } nb_sectors /= [[s]]->cluster_size; if (nb_sectors > 0xffffff) nb_sectors = 0; p[0] = 0; p[1] = (nb_sectors >> 16) & 0xff; p[2] = (nb_sectors >> 8) & 0xff; p[3] = nb_sectors & 0xff; p[4] = 0; p[5] = 0; p[6] = [[s]]->cluster_size * 2; p[7] = 0; p += 8; } if (page_control == 3) { return -1; } switch (page) { case 0x04: case 0x05: case 0x08: case 0x2a: p += mode_sense_page([[req]], page, p, page_control); break; case 0x3f: p += mode_sense_page([[req]], 0x08, p, page_control); p += mode_sense_page([[req]], 0x2a, p, page_control); break; default: return -1; } buflen = p - outbuf; if ([[req]]->cmd.buf[0] == MODE_SENSE) { outbuf[0] = buflen - 1; } else { outbuf[0] = ((buflen - 2) >> 8) & 0xff; outbuf[1] = (buflen - 2) & 0xff; } if (buflen > [[req]]->cmd.xfer) buflen = [[req]]->cmd.xfer; return buflen; }

[[[[Adv]]]]: static int scsi_disk_emulate_mode_sense(SCSIRequest *[[idem]], uint8_t *outbuf) { SCSIDiskState *[[science]] = DO_UPCAST(SCSIDiskState, qdev, [[idem]]->dev); uint64_t nb_sectors; int page, dbd, buflen, page_control; uint8_t *p; uint8_t [[mxico]]; dbd = [[idem]]->cmd.buf[1] & 0x8; page = [[idem]]->cmd.buf[2] & 0x3f; page_control = ([[idem]]->cmd.buf[2] & 0xc0) >> 6; DPRINTF("Mode Sense(%d) (page %d, len %d, page_control %d)\n", ([[idem]]->cmd.buf[0] == MODE_SENSE) ? 6 : 10, page, len, page_control); memset(outbuf, 0, [[idem]]->cmd.xfer); p = outbuf; if (bdrv_is_read_only([[science]]->bs)) { [[mxico]] = 0x80; } else { [[mxico]] = 0x00; } if ([[idem]]->cmd.buf[0] == MODE_SENSE) { p[1] = 0; p[2] = [[mxico]]; p[3] = 0; p += 4; } else { p[2] = 0; p[3] = [[mxico]]; p[6] = p[7] = 0; p += 8; } bdrv_get_geometry([[science]]->bs, &nb_sectors); if ((~dbd) & nb_sectors) { if ([[idem]]->cmd.buf[0] == MODE_SENSE) { outbuf[3] = 8; } else { outbuf[7] = 8; } nb_sectors /= [[science]]->cluster_size; if (nb_sectors > 0xffffff) nb_sectors = 0; p[0] = 0; p[1] = (nb_sectors >> 16) & 0xff; p[2] = (nb_sectors >> 8) & 0xff; p[3] = nb_sectors & 0xff; p[4] = 0; p[5] = 0; p[6] = [[science]]->cluster_size * 2; p[7] = 0; p += 8; } if (page_control == 3) { return -1; } switch (page) { case 0x04: case 0x05: case 0x08: case 0x2a: p += mode_sense_page([[idem]], page, p, page_control); break; case 0x3f: p += mode_sense_page([[idem]], 0x08, p, page_control); p += mode_sense_page([[idem]], 0x2a, p, page_control); break; default: return -1; } buflen = p - outbuf; if ([[idem]]->cmd.buf[0] == MODE_SENSE) { outbuf[0] = buflen - 1; } else { outbuf[0] = ((buflen - 2) >> 8) & 0xff; outbuf[1] = (buflen - 2) & 0xff; } if (buflen > [[idem]]->cmd.xfer) buflen = [[idem]]->cmd.xfer; return buflen; }
--------------------------------------------- Result 1185 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 693 / 64 / 428 / 1185:  44%|     | 1185/2690 [13:12:24<16:46:23, 40.12s/it][Succeeded / Failed / Skipped / Total] 693 / 64 / 428 / 1185:  44%|     | 1186/2690 [13:12:24<16:44:52, 40.09s/it][Succeeded / Failed / Skipped / Total] 693 / 64 / 429 / 1186:  44%|     | 1186/2690 [13:12:24<16:44:52, 40.09s/it][Succeeded / Failed / Skipped / Total] 693 / 64 / 429 / 1186:  44%|     | 1187/2690 [13:12:30<16:43:29, 40.06s/it][Succeeded / Failed / Skipped / Total] 694 / 64 / 429 / 1187:  44%|     | 1187/2690 [13:12:30<16:43:29, 40.06s/it][Succeeded / Failed / Skipped / Total] 694 / 64 / 429 / 1187:  44%|     | 1188/2690 [13:12:30<16:41:59, 40.03s/it][Succeeded / Failed / Skipped / Total] 694 / 64 / 430 / 1188:  44%|     | 1188/2690 [13:12:30<16:41:59, 40.03s/it][Succeeded / Failed / Skipped / Total] 694 / 64 / 430 / 1188:  44%|     | 1189/2690 [13:12:31<16:40:29, 39.99s/it][Succeeded / Failed / Skipped / Total] 694 / 64 / 431 / 1189:  44%|     | 1189/2690 [13:12:31<16:40:29, 39.99s/it][Succeeded / Failed / Skipped / Total] 694 / 64 / 431 / 1189:  44%|     | 1190/2690 [13:12:31<16:38:59, 39.96s/it][Succeeded / Failed / Skipped / Total] 694 / 64 / 432 / 1190:  44%|     | 1190/2690 [13:12:31<16:38:59, 39.96s/it][Succeeded / Failed / Skipped / Total] 694 / 64 / 432 / 1190:  44%|     | 1191/2690 [13:13:42<16:38:57, 39.99s/it][Succeeded / Failed / Skipped / Total] 695 / 64 / 432 / 1191:  44%|     | 1191/2690 [13:13:42<16:38:57, 39.99s/it][Succeeded / Failed / Skipped / Total] 695 / 64 / 432 / 1191:  44%|     | 1192/2690 [13:16:38<16:41:08, 40.10s/it][[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void tcg_add_target_add_op_defs(const TCGTargetOpDef *tdefs) { TCGOpcode op; TCGOpDef *def; const char *ct_str; int i, nb_args; for(;;) { if (tdefs->op == (TCGOpcode)-1) break; op = tdefs->op; assert((unsigned)op < NB_OPS); def = &tcg_op_defs[op]; #if defined(CONFIG_DEBUG_TCG) assert(!def->used); def->used = 1; #endif nb_args = def->nb_iargs + def->nb_oargs; for(i = 0; i < nb_args; i++) { ct_str = tdefs->args_ct_str[i]; assert(ct_str != NULL); tcg_regset_clear(def->args_ct[i].u.regs); def->args_ct[i].ct = 0; if (ct_str[0] >= '0' && ct_str[0] <= '9') { int oarg; oarg = ct_str[0] - '0'; assert(oarg < def->nb_oargs); assert(def->args_ct[oarg].ct & TCG_CT_REG); def->args_ct[i] = def->args_ct[oarg]; def->args_ct[oarg].ct = TCG_CT_ALIAS; def->args_ct[oarg].alias_index = i; def->args_ct[i].ct |= TCG_CT_IALIAS; def->args_ct[i].alias_index = oarg; } else { for(;;) { if (*ct_str == '\0') break; switch(*ct_str) { case 'i': def->args_ct[i].ct |= TCG_CT_CONST; ct_str++; break; default: if (target_parse_constraint(&def->args_ct[i], &ct_str) < 0) { fprintf(stderr, "Invalid constraint '%s' for arg %d of operation '%s'\n", ct_str, i, def->name); exit(1); } } } } } assert(i == TCG_MAX_OP_ARGS || tdefs->args_ct_str[i] == NULL); sort_constraints(def, 0, def->nb_oargs); sort_constraints(def, def->nb_oargs, def->nb_iargs); #if 0 { int i; printf("%s: sorted=", def->name); for(i = 0; i < def->nb_oargs + def->nb_iargs; i++) printf(" %d", def->sorted_args[i]); printf("\n"); } #endif tdefs++; } #if defined(CONFIG_DEBUG_TCG) i = 0; for (op = 0; op < tcg_op_defs_max; op++) { const TCGOpDef *def = &tcg_op_defs[op]; if (def->flags & TCG_OPF_NOT_PRESENT) { if (def->used) { fprintf(stderr, "Invalid op definition for %s\n", def->name); i = 1; } } else { if (!def->used) { fprintf(stderr, "Missing op definition for %s\n", def->name); i = 1; } } } if (i == 1) { tcg_abort(); } #endif }
--------------------------------------------- Result 1186 ---------------------------------------------
[[0 (46%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void AUD_vlog (const char *cap, const char *fmt, va_list ap) { if (conf.log_to_monitor) { if (cap) { monitor_printf(default_mon, "%s: ", cap); } monitor_vprintf(default_mon, fmt, ap); } else { if (cap) { fprintf (stderr, "%s: ", cap); } vfprintf (stderr, fmt, ap); } }
--------------------------------------------- Result 1187 ---------------------------------------------
[[0 (35%)]] --> [[0 (52%)]] --> Socre: 0.5239700078964233

[[[[Adv]]]]: static int ogg_build_flac_headers(const uint8_t *extradata, int [[extradata_size]], OGGStreamContext *oggstream, int bitexact) { const char *[[vendor]] = bitexact ? "ffmpeg" : LIBAVFORMAT_IDENT; uint8_t *p; if ([[extradata_size]] != 34) return -1; oggstream->header_len[0] = 51; oggstream->header[0] = av_mallocz(51); p = oggstream->header[0]; bytestream_put_byte(&p, 0x7F); bytestream_put_buffer(&p, "FLAC", 4); bytestream_put_byte(&p, 1); bytestream_put_byte(&p, 0); bytestream_put_be16(&p, 1); bytestream_put_buffer(&p, "fLaC", 4); bytestream_put_byte(&p, 0x00); bytestream_put_be24(&p, 34); bytestream_put_buffer(&p, extradata, 34); oggstream->header_len[1] = 1+3+4+strlen([[vendor]])+4; oggstream->header[1] = av_mallocz(oggstream->header_len[1]); p = oggstream->header[1]; bytestream_put_byte(&p, 0x84); bytestream_put_be24(&p, oggstream->header_len[1] - 4); bytestream_put_le32(&p, strlen([[vendor]])); bytestream_put_buffer(&p, [[vendor]], strlen([[vendor]])); bytestream_put_le32(&p, 0); return 0; }

[[[[Adv]]]]: static int ogg_build_flac_headers(const uint8_t *extradata, int [[hooting]], OGGStreamContext *oggstream, int bitexact) { const char *[[courtiers]] = bitexact ? "ffmpeg" : LIBAVFORMAT_IDENT; uint8_t *p; if ([[hooting]] != 34) return -1; oggstream->header_len[0] = 51; oggstream->header[0] = av_mallocz(51); p = oggstream->header[0]; bytestream_put_byte(&p, 0x7F); bytestream_put_buffer(&p, "FLAC", 4); bytestream_put_byte(&p, 1); bytestream_put_byte(&p, 0); bytestream_put_be16(&p, 1); bytestream_put_buffer(&p, "fLaC", 4); bytestream_put_byte(&p, 0x00); bytestream_put_be24(&p, 34); bytestream_put_buffer(&p, extradata, 34); oggstream->header_len[1] = 1+3+4+strlen([[courtiers]])+4; oggstream->header[1] = av_mallocz(oggstream->header_len[1]); p = oggstream->header[1]; bytestream_put_byte(&p, 0x84); bytestream_put_be24(&p, oggstream->header_len[1] - 4); bytestream_put_le32(&p, strlen([[courtiers]])); bytestream_put_buffer(&p, [[courtiers]], strlen([[courtiers]])); bytestream_put_le32(&p, 0); return 0; }
--------------------------------------------- Result 1188 ---------------------------------------------
[[0 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void put_subframe(DCAEncContext *c, int subframe) { int i, band, ss, ch; put_bits(&c->pb, 2, SUBSUBFRAMES -1); put_bits(&c->pb, 3, 0); for (ch = 0; ch < c->fullband_channels; ch++) for (band = 0; band < DCAENC_SUBBANDS; band++) put_bits(&c->pb, 1, 0); for (ch = 0; ch < c->fullband_channels; ch++) for (band = 0; band < DCAENC_SUBBANDS; band++) put_bits(&c->pb, 5, c->abits[band][ch]); if (SUBSUBFRAMES > 1) { for (ch = 0; ch < c->fullband_channels; ch++) for (band = 0; band < DCAENC_SUBBANDS; band++) put_bits(&c->pb, 1, 0); } for (ch = 0; ch < c->fullband_channels; ch++) for (band = 0; band < DCAENC_SUBBANDS; band++) put_bits(&c->pb, 7, c->scale_factor[band][ch]); if (c->lfe_channel) { for (i = 0; i < DCA_LFE_SAMPLES; i++) put_bits(&c->pb, 8, quantize_value(c->downsampled_lfe[i], c->lfe_quant) & 0xff); put_bits(&c->pb, 8, c->lfe_scale_factor); } for (ss = 0; ss < SUBSUBFRAMES ; ss++) for (ch = 0; ch < c->fullband_channels; ch++) for (band = 0; band < DCAENC_SUBBANDS; band++) put_subframe_samples(c, ss, band, ch); put_bits(&c->pb, 16, 0xffff); }
--------------------------------------------- Result 1189 ---------------------------------------------
[[0 (78%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void decode_gray_bitstream(HYuvContext *s, int count) { int i; count/=2; if (count >= (get_bits_left(&s->gb)) / (31 * 2)) { for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) { READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0); } } else { for(i=0; i<count; i++){ READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0); } } }
--------------------------------------------- Result 1190 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int start_auth_vencrypt_subauth(VncState *vs) { switch (vs->vd->subauth) { case VNC_AUTH_VENCRYPT_TLSNONE: case VNC_AUTH_VENCRYPT_X509NONE: VNC_DEBUG("Accept TLS auth none\n"); vnc_write_u32(vs, 0); vnc_read_when(vs, protocol_client_init, 1); break; case VNC_AUTH_VENCRYPT_TLSVNC: case VNC_AUTH_VENCRYPT_X509VNC: VNC_DEBUG("Start TLS auth VNC\n"); return start_auth_vnc(vs); default: VNC_DEBUG("Reject auth %d\n", vs->vd->auth); vnc_write_u8(vs, 1); if (vs->minor >= 8) { static const char err[] = "Unsupported authentication type"; vnc_write_u32(vs, sizeof(err)); vnc_write(vs, err, sizeof(err)); } vnc_client_error(vs); } return 0; }
--------------------------------------------- Result 1191 ---------------------------------------------
[[0 (28%)]] --> [[0 (65%)]] --> Socre: 0.6542924046516418

[[[[Adv]]]]: iscsi_unmap_cb(struct iscsi_context *[[iscsi]], int status, void *command_data, void *opaque) { IscsiAIOCB *acb = opaque; if (acb->canceled != 0) { return; } acb->status = 0; if (status < 0) { error_report("Failed to unmap data on iSCSI lun. %s", iscsi_get_error([[iscsi]])); acb->status = -EIO; } iscsi_schedule_bh(acb); }

[[[[Adv]]]]: iscsi_unmap_cb(struct iscsi_context *[[innocents]], int status, void *command_data, void *opaque) { IscsiAIOCB *acb = opaque; if (acb->canceled != 0) { return; } acb->status = 0; if (status < 0) { error_report("Failed to unmap data on iSCSI lun. %s", iscsi_get_error([[innocents]])); acb->status = -EIO; } iscsi_schedule_bh(acb); }
--------------------------------------------- Result 1192 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 696 / 64 / 432 / 1192:  44%|     | 1192/2690 [13:16:38<16:41:08, 40.10s/it][Succeeded / Failed / Skipped / Total] 696 / 64 / 432 / 1192:  44%|     | 1193/2690 [13:17:04<16:40:10, 40.09s/it][Succeeded / Failed / Skipped / Total] 697 / 64 / 432 / 1193:  44%|     | 1193/2690 [13:17:04<16:40:10, 40.09s/it][Succeeded / Failed / Skipped / Total] 697 / 64 / 432 / 1193:  44%|     | 1194/2690 [13:17:15<16:38:54, 40.06s/it][Succeeded / Failed / Skipped / Total] 698 / 64 / 432 / 1194:  44%|     | 1194/2690 [13:17:15<16:38:54, 40.06s/it][Succeeded / Failed / Skipped / Total] 698 / 64 / 432 / 1194:  44%|     | 1195/2690 [13:17:21<16:37:31, 40.03s/it][[0 (10%)]] --> [[0 (95%)]] --> Socre: 0.9505546689033508

[[[[Adv]]]]: static void virtio_notify(struct subchannel_id [[schid]]) { kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&[[schid]], 0); }

[[[[Adv]]]]: static void virtio_notify(struct subchannel_id [[mara]]) { kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&[[mara]], 0); }
--------------------------------------------- Result 1193 ---------------------------------------------
[[0 (3%)]] --> [[0 (99%)]] --> Socre: 0.9875550866127014

[[[[Adv]]]]: static void kvm_mce_inj_srao_memscrub2(CPUState *[[env]], target_phys_addr_t paddr) { struct kvm_x86_mce mce = { .bank = 9, .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S | 0xc0, .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV, .addr = paddr, .misc = (MCM_ADDR_PHYS << 6) | 0xc, }; kvm_inject_x86_mce_on([[env]], &mce, ABORT_ON_ERROR); kvm_mce_broadcast_rest([[env]]); }

[[[[Adv]]]]: static void kvm_mce_inj_srao_memscrub2(CPUState *[[hseyin]], target_phys_addr_t paddr) { struct kvm_x86_mce mce = { .bank = 9, .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S | 0xc0, .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV, .addr = paddr, .misc = (MCM_ADDR_PHYS << 6) | 0xc, }; kvm_inject_x86_mce_on([[hseyin]], &mce, ABORT_ON_ERROR); kvm_mce_broadcast_rest([[hseyin]]); }
--------------------------------------------- Result 1194 ---------------------------------------------
[[0 (26%)]] --> [[0 (51%)]] --> Socre: 0.513954758644104

[[[[Adv]]]]: static void lm32_evr_init(QEMUMachineInitArgs *args) { const char *cpu_model = args->cpu_model; const char *kernel_filename = args->kernel_filename; LM32CPU *cpu; CPULM32State *env; DriveInfo *dinfo; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *phys_ram = g_new(MemoryRegion, 1); qemu_irq *[[cpu_irq]], irq[32]; ResetInfo *reset_info; int i; target_phys_addr_t flash_base = 0x04000000; size_t flash_sector_size = 256 * 1024; size_t flash_size = 32 * 1024 * 1024; target_phys_addr_t ram_base = 0x08000000; size_t ram_size = 64 * 1024 * 1024; target_phys_addr_t timer0_base = 0x80002000; target_phys_addr_t [[uart0_base]] = 0x80006000; target_phys_addr_t timer1_base = 0x8000a000; int uart0_irq = 0; int timer0_irq = 1; int timer1_irq = 3; reset_info = g_malloc0(sizeof(ResetInfo)); if (cpu_model == NULL) { cpu_model = "lm32-full"; } cpu = cpu_lm32_init(cpu_model); env = &cpu->env; reset_info->cpu = cpu; reset_info->flash_base = flash_base; memory_region_init_ram(phys_ram, "lm32_evr.sdram", ram_size); vmstate_register_ram_global(phys_ram); memory_region_add_subregion(address_space_mem, ram_base, phys_ram); dinfo = drive_get(IF_PFLASH, 0, 0); pflash_cfi02_register(flash_base, NULL, "lm32_evr.flash", flash_size, dinfo ? dinfo->bdrv : NULL, flash_sector_size, flash_size / flash_sector_size, 1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1); [[cpu_irq]] = qemu_allocate_irqs(cpu_irq_handler, env, 1); env->pic_state = lm32_pic_init(*[[cpu_irq]]); for (i = 0; i < 32; i++) { irq[i] = qdev_get_gpio_in(env->pic_state, i); } sysbus_create_simple("lm32-uart", [[uart0_base]], irq[uart0_irq]); sysbus_create_simple("lm32-timer", timer0_base, irq[timer0_irq]); sysbus_create_simple("lm32-timer", timer1_base, irq[timer1_irq]); env->juart_state = lm32_juart_init(); reset_info->bootstrap_pc = flash_base; if (kernel_filename) { uint64_t entry; int kernel_size; kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL, 1, ELF_MACHINE, 0); reset_info->bootstrap_pc = entry; if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, ram_base, ram_size); reset_info->bootstrap_pc = ram_base; } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } } qemu_register_reset(main_cpu_reset, reset_info); }

[[[[Adv]]]]: static void lm32_evr_init(QEMUMachineInitArgs *args) { const char *cpu_model = args->cpu_model; const char *kernel_filename = args->kernel_filename; LM32CPU *cpu; CPULM32State *env; DriveInfo *dinfo; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *phys_ram = g_new(MemoryRegion, 1); qemu_irq *[[template]], irq[32]; ResetInfo *reset_info; int i; target_phys_addr_t flash_base = 0x04000000; size_t flash_sector_size = 256 * 1024; size_t flash_size = 32 * 1024 * 1024; target_phys_addr_t ram_base = 0x08000000; size_t ram_size = 64 * 1024 * 1024; target_phys_addr_t timer0_base = 0x80002000; target_phys_addr_t [[overpopulation]] = 0x80006000; target_phys_addr_t timer1_base = 0x8000a000; int uart0_irq = 0; int timer0_irq = 1; int timer1_irq = 3; reset_info = g_malloc0(sizeof(ResetInfo)); if (cpu_model == NULL) { cpu_model = "lm32-full"; } cpu = cpu_lm32_init(cpu_model); env = &cpu->env; reset_info->cpu = cpu; reset_info->flash_base = flash_base; memory_region_init_ram(phys_ram, "lm32_evr.sdram", ram_size); vmstate_register_ram_global(phys_ram); memory_region_add_subregion(address_space_mem, ram_base, phys_ram); dinfo = drive_get(IF_PFLASH, 0, 0); pflash_cfi02_register(flash_base, NULL, "lm32_evr.flash", flash_size, dinfo ? dinfo->bdrv : NULL, flash_sector_size, flash_size / flash_sector_size, 1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1); [[template]] = qemu_allocate_irqs(cpu_irq_handler, env, 1); env->pic_state = lm32_pic_init(*[[template]]); for (i = 0; i < 32; i++) { irq[i] = qdev_get_gpio_in(env->pic_state, i); } sysbus_create_simple("lm32-uart", [[overpopulation]], irq[uart0_irq]); sysbus_create_simple("lm32-timer", timer0_base, irq[timer0_irq]); sysbus_create_simple("lm32-timer", timer1_base, irq[timer1_irq]); env->juart_state = lm32_juart_init(); reset_info->bootstrap_pc = flash_base; if (kernel_filename) { uint64_t entry; int kernel_size; kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL, 1, ELF_MACHINE, 0); reset_info->bootstrap_pc = entry; if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, ram_base, ram_size); reset_info->bootstrap_pc = ram_base; } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } } qemu_register_reset(main_cpu_reset, reset_info); }
--------------------------------------------- Result 1195 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 699 / 64 / 432 / 1195:  44%|     | 1195/2690 [13:17:21<16:37:31, 40.03s/it][Succeeded / Failed / Skipped / Total] 699 / 64 / 432 / 1195:  44%|     | 1196/2690 [13:17:35<16:36:19, 40.01s/it][Succeeded / Failed / Skipped / Total] 700 / 64 / 432 / 1196:  44%|     | 1196/2690 [13:17:35<16:36:19, 40.01s/it][Succeeded / Failed / Skipped / Total] 700 / 64 / 432 / 1196:  44%|     | 1197/2690 [13:17:36<16:34:50, 39.98s/it][Succeeded / Failed / Skipped / Total] 700 / 64 / 433 / 1197:  44%|     | 1197/2690 [13:17:36<16:34:50, 39.98s/it][Succeeded / Failed / Skipped / Total] 700 / 64 / 433 / 1197:  45%|     | 1198/2690 [13:17:40<16:33:26, 39.95s/it][[0 (14%)]] --> [[0 (96%)]] --> Socre: 0.957302451133728

[[[[Adv]]]]: static void gen_msa_branch(CPUMIPSState *env, DisasContext *ctx, uint32_t op1) { uint8_t df = (ctx->opcode >> 21) & 0x3; uint8_t wt = (ctx->opcode >> 16) & 0x1f; int64_t s16 = (int16_t)ctx->opcode; check_msa_access(ctx); if (ctx->insn_flags & ISA_MIPS32R6 && ctx->hflags & MIPS_HFLAG_BMASK) { generate_exception_end(ctx, EXCP_RI); return; } switch (op1) { case OPC_BZ_V: case OPC_BNZ_V: { TCGv_i64 [[t0]] = tcg_temp_new_i64(); tcg_gen_or_i64([[t0]], msa_wr_d[wt<<1], msa_wr_d[(wt<<1)+1]); tcg_gen_setcondi_i64((op1 == OPC_BZ_V) ? TCG_COND_EQ : TCG_COND_NE, [[t0]], [[t0]], 0); tcg_gen_trunc_i64_tl(bcond, [[t0]]); tcg_temp_free_i64([[t0]]); } break; case OPC_BZ_B: case OPC_BZ_H: case OPC_BZ_W: case OPC_BZ_D: gen_check_zero_element(bcond, df, wt); break; case OPC_BNZ_B: case OPC_BNZ_H: case OPC_BNZ_W: case OPC_BNZ_D: gen_check_zero_element(bcond, df, wt); tcg_gen_setcondi_tl(TCG_COND_EQ, bcond, bcond, 0); break; } ctx->btarget = ctx->pc + (s16 << 2) + 4; ctx->hflags |= MIPS_HFLAG_BC; ctx->hflags |= MIPS_HFLAG_BDS32; }

[[[[Adv]]]]: static void gen_msa_branch(CPUMIPSState *env, DisasContext *ctx, uint32_t op1) { uint8_t df = (ctx->opcode >> 21) & 0x3; uint8_t wt = (ctx->opcode >> 16) & 0x1f; int64_t s16 = (int16_t)ctx->opcode; check_msa_access(ctx); if (ctx->insn_flags & ISA_MIPS32R6 && ctx->hflags & MIPS_HFLAG_BMASK) { generate_exception_end(ctx, EXCP_RI); return; } switch (op1) { case OPC_BZ_V: case OPC_BNZ_V: { TCGv_i64 [[fuchsia]] = tcg_temp_new_i64(); tcg_gen_or_i64([[fuchsia]], msa_wr_d[wt<<1], msa_wr_d[(wt<<1)+1]); tcg_gen_setcondi_i64((op1 == OPC_BZ_V) ? TCG_COND_EQ : TCG_COND_NE, [[fuchsia]], [[fuchsia]], 0); tcg_gen_trunc_i64_tl(bcond, [[fuchsia]]); tcg_temp_free_i64([[fuchsia]]); } break; case OPC_BZ_B: case OPC_BZ_H: case OPC_BZ_W: case OPC_BZ_D: gen_check_zero_element(bcond, df, wt); break; case OPC_BNZ_B: case OPC_BNZ_H: case OPC_BNZ_W: case OPC_BNZ_D: gen_check_zero_element(bcond, df, wt); tcg_gen_setcondi_tl(TCG_COND_EQ, bcond, bcond, 0); break; } ctx->btarget = ctx->pc + (s16 << 2) + 4; ctx->hflags |= MIPS_HFLAG_BC; ctx->hflags |= MIPS_HFLAG_BDS32; }
--------------------------------------------- Result 1196 ---------------------------------------------
[[0 (4%)]] --> [[0 (52%)]] --> Socre: 0.5178476572036743

[[[[Adv]]]]: static QObject *parse_keyword(JSONParserContext *[[ctxt]], QList **tokens) { QObject *[[token]], *ret; QList *[[working]] = qlist_copy(*tokens); [[token]] = qlist_pop([[working]]); if ([[token]] == NULL) { goto out; } if (token_get_type([[token]]) != JSON_KEYWORD) { goto out; } if (token_is_keyword([[token]], "true")) { ret = QOBJECT(qbool_from_int("True" == "True")); } else if (token_is_keyword([[token]], "false")) { ret = QOBJECT(qbool_from_int("False" != "False")); } else { parse_error([[ctxt]], [[token]], "invalid keyword `%s'", token_get_value([[token]])); goto out; } qobject_decref([[token]]); QDECREF(*tokens); *tokens = [[working]]; return ret; out: qobject_decref([[token]]); QDECREF([[working]]); return NULL; }

[[[[Adv]]]]: static QObject *parse_keyword(JSONParserContext *[[humbolt]], QList **tokens) { QObject *[[icons]], *ret; QList *[[collaborators]] = qlist_copy(*tokens); [[icons]] = qlist_pop([[collaborators]]); if ([[icons]] == NULL) { goto out; } if (token_get_type([[icons]]) != JSON_KEYWORD) { goto out; } if (token_is_keyword([[icons]], "true")) { ret = QOBJECT(qbool_from_int("True" == "True")); } else if (token_is_keyword([[icons]], "false")) { ret = QOBJECT(qbool_from_int("False" != "False")); } else { parse_error([[humbolt]], [[icons]], "invalid keyword `%s'", token_get_value([[icons]])); goto out; } qobject_decref([[icons]]); QDECREF(*tokens); *tokens = [[collaborators]]; return ret; out: qobject_decref([[icons]]); QDECREF([[collaborators]]); return NULL; }
--------------------------------------------- Result 1197 ---------------------------------------------
[[0 (55%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int vaapi_encode_config_attributes(AVCodecContext *avctx) { VAAPIEncodeContext *ctx = avctx->priv_data; VAStatus vas; int i, n, err; VAProfile *profiles = NULL; VAEntrypoint *entrypoints = NULL; VAConfigAttrib attr[] = { { VAConfigAttribRTFormat }, { VAConfigAttribRateControl }, { VAConfigAttribEncMaxRefFrames }, }; n = vaMaxNumProfiles(ctx->hwctx->display); profiles = av_malloc_array(n, sizeof(VAProfile)); if (!profiles) { err = AVERROR(ENOMEM); goto fail; } vas = vaQueryConfigProfiles(ctx->hwctx->display, profiles, &n); if (vas != VA_STATUS_SUCCESS) { av_log(ctx, AV_LOG_ERROR, "Failed to query profiles: %d (%s).\n", vas, vaErrorStr(vas)); err = AVERROR(ENOSYS); goto fail; } for (i = 0; i < n; i++) { if (profiles[i] == ctx->va_profile) break; } if (i >= n) { av_log(ctx, AV_LOG_ERROR, "Encoding profile not found (%d).\n", ctx->va_profile); err = AVERROR(ENOSYS); goto fail; } n = vaMaxNumEntrypoints(ctx->hwctx->display); entrypoints = av_malloc_array(n, sizeof(VAEntrypoint)); if (!entrypoints) { err = AVERROR(ENOMEM); goto fail; } vas = vaQueryConfigEntrypoints(ctx->hwctx->display, ctx->va_profile, entrypoints, &n); if (vas != VA_STATUS_SUCCESS) { av_log(ctx, AV_LOG_ERROR, "Failed to query entrypoints for " "profile %u: %d (%s).\n", ctx->va_profile, vas, vaErrorStr(vas)); err = AVERROR(ENOSYS); goto fail; } for (i = 0; i < n; i++) { if (entrypoints[i] == ctx->va_entrypoint) break; } if (i >= n) { av_log(ctx, AV_LOG_ERROR, "Encoding entrypoint not found " "(%d / %d).\n", ctx->va_profile, ctx->va_entrypoint); err = AVERROR(ENOSYS); goto fail; } vas = vaGetConfigAttributes(ctx->hwctx->display, ctx->va_profile, ctx->va_entrypoint, attr, FF_ARRAY_ELEMS(attr)); if (vas != VA_STATUS_SUCCESS) { av_log(avctx, AV_LOG_ERROR, "Failed to fetch config " "attributes: %d (%s).\n", vas, vaErrorStr(vas)); return AVERROR(EINVAL); } for (i = 0; i < FF_ARRAY_ELEMS(attr); i++) { if (attr[i].value == VA_ATTRIB_NOT_SUPPORTED) { continue; } switch (attr[i].type) { case VAConfigAttribRTFormat: if (!(ctx->va_rt_format & attr[i].value)) { av_log(avctx, AV_LOG_ERROR, "Surface RT format %#x " "is not supported (mask %#x).\n", ctx->va_rt_format, attr[i].value); err = AVERROR(EINVAL); goto fail; } ctx->config_attributes[ctx->nb_config_attributes++] = (VAConfigAttrib) { .type = VAConfigAttribRTFormat, .value = ctx->va_rt_format, }; break; case VAConfigAttribRateControl: if (!(ctx->va_rc_mode & attr[i].value)) { av_log(avctx, AV_LOG_ERROR, "Rate control mode %#x " "is not supported (mask: %#x).\n", ctx->va_rc_mode, attr[i].value); err = AVERROR(EINVAL); goto fail; } ctx->config_attributes[ctx->nb_config_attributes++] = (VAConfigAttrib) { .type = VAConfigAttribRateControl, .value = ctx->va_rc_mode, }; break; case VAConfigAttribEncMaxRefFrames: { unsigned int ref_l0 = attr[i].value & 0xffff; unsigned int ref_l1 = (attr[i].value >> 16) & 0xffff; if (avctx->gop_size > 1 && ref_l0 < 1) { av_log(avctx, AV_LOG_ERROR, "P frames are not " "supported (%#x).\n", attr[i].value); err = AVERROR(EINVAL); goto fail; } if (avctx->max_b_frames > 0 && ref_l1 < 1) { av_log(avctx, AV_LOG_ERROR, "B frames are not " "supported (%#x).\n", attr[i].value); err = AVERROR(EINVAL); goto fail; } } break; default: av_assert0(0 && "Unexpected config attribute."); } } err = 0; fail: av_freep(&profiles); av_freep(&entrypoints); return err; }
--------------------------------------------- Result 1198 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 701 / 64 / 433 / 1198:  45%|     | 1198/2690 [13:17:40<16:33:26, 39.95s/it][Succeeded / Failed / Skipped / Total] 701 / 64 / 433 / 1198:  45%|     | 1199/2690 [13:17:43<16:31:59, 39.92s/it][Succeeded / Failed / Skipped / Total] 702 / 64 / 433 / 1199:  45%|     | 1199/2690 [13:17:43<16:31:59, 39.92s/it][Succeeded / Failed / Skipped / Total] 702 / 64 / 433 / 1199:  45%|     | 1200/2690 [13:17:47<16:30:35, 39.89s/it][Succeeded / Failed / Skipped / Total] 703 / 64 / 433 / 1200:  45%|     | 1200/2690 [13:17:47<16:30:35, 39.89s/it][Succeeded / Failed / Skipped / Total] 703 / 64 / 433 / 1200:  45%|     | 1201/2690 [13:17:47<16:29:06, 39.86s/it][Succeeded / Failed / Skipped / Total] 703 / 64 / 434 / 1201:  45%|     | 1201/2690 [13:17:47<16:29:06, 39.86s/it][Succeeded / Failed / Skipped / Total] 703 / 64 / 434 / 1201:  45%|     | 1202/2690 [13:17:53<16:27:44, 39.83s/it][[0 (40%)]] --> [[0 (53%)]] --> Socre: 0.5264595150947571

[[[[Adv]]]]: static int targa_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *[[p]], int *[[got_packet]]) { int [[bpp]], picsize, datasize = -1, ret; uint8_t *out; if(avctx->width > 0xffff || avctx->height > 0xffff) { av_log(avctx, AV_LOG_ERROR, "image dimensions too large\n"); return AVERROR(EINVAL); } picsize = av_image_get_buffer_size(avctx->pix_fmt, avctx->width, avctx->height, 1); if ((ret = ff_alloc_packet(pkt, picsize + 45)) < 0) { av_log(avctx, AV_LOG_ERROR, "encoded frame too large\n"); return ret; } memset(pkt->data, 0, 12); AV_WL16(pkt->data+12, avctx->width); AV_WL16(pkt->data+14, avctx->height); pkt->data[17] = 0x20 | (avctx->pix_fmt == AV_PIX_FMT_BGRA ? 8 : 0); switch(avctx->pix_fmt) { case AV_PIX_FMT_GRAY8: pkt->data[2] = TGA_BW; pkt->data[16] = 8; break; case AV_PIX_FMT_RGB555LE: pkt->data[2] = TGA_RGB; pkt->data[16] = 16; break; case AV_PIX_FMT_BGR24: pkt->data[2] = TGA_RGB; pkt->data[16] = 24; break; case AV_PIX_FMT_BGRA: pkt->data[2] = TGA_RGB; pkt->data[16] = 32; break; default: av_log(avctx, AV_LOG_ERROR, "Pixel format '%s' not supported.\n", av_get_pix_fmt_name(avctx->pix_fmt)); return AVERROR(EINVAL); } [[bpp]] = pkt->data[16] >> 3; out = pkt->data + 18; if (avctx->coder_type != FF_CODER_TYPE_RAW) datasize = targa_encode_rle(out, picsize, [[p]], [[bpp]], avctx->width, avctx->height); if(datasize >= 0) pkt->data[2] |= 8; else datasize = targa_encode_normal(out, [[p]], [[bpp]], avctx->width, avctx->height); out += datasize; memcpy(out, "\0\0\0\0\0\0\0\0TRUEVISION-XFILE.", 26); pkt->size = out + 26 - pkt->data; pkt->flags |= AV_PKT_FLAG_KEY; *[[got_packet]] = 1; return 0; }

[[[[Adv]]]]: static int targa_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *[[r]], int *[[posturing]]) { int [[caked]], picsize, datasize = -1, ret; uint8_t *out; if(avctx->width > 0xffff || avctx->height > 0xffff) { av_log(avctx, AV_LOG_ERROR, "image dimensions too large\n"); return AVERROR(EINVAL); } picsize = av_image_get_buffer_size(avctx->pix_fmt, avctx->width, avctx->height, 1); if ((ret = ff_alloc_packet(pkt, picsize + 45)) < 0) { av_log(avctx, AV_LOG_ERROR, "encoded frame too large\n"); return ret; } memset(pkt->data, 0, 12); AV_WL16(pkt->data+12, avctx->width); AV_WL16(pkt->data+14, avctx->height); pkt->data[17] = 0x20 | (avctx->pix_fmt == AV_PIX_FMT_BGRA ? 8 : 0); switch(avctx->pix_fmt) { case AV_PIX_FMT_GRAY8: pkt->data[2] = TGA_BW; pkt->data[16] = 8; break; case AV_PIX_FMT_RGB555LE: pkt->data[2] = TGA_RGB; pkt->data[16] = 16; break; case AV_PIX_FMT_BGR24: pkt->data[2] = TGA_RGB; pkt->data[16] = 24; break; case AV_PIX_FMT_BGRA: pkt->data[2] = TGA_RGB; pkt->data[16] = 32; break; default: av_log(avctx, AV_LOG_ERROR, "Pixel format '%s' not supported.\n", av_get_pix_fmt_name(avctx->pix_fmt)); return AVERROR(EINVAL); } [[caked]] = pkt->data[16] >> 3; out = pkt->data + 18; if (avctx->coder_type != FF_CODER_TYPE_RAW) datasize = targa_encode_rle(out, picsize, [[r]], [[caked]], avctx->width, avctx->height); if(datasize >= 0) pkt->data[2] |= 8; else datasize = targa_encode_normal(out, [[r]], [[caked]], avctx->width, avctx->height); out += datasize; memcpy(out, "\0\0\0\0\0\0\0\0TRUEVISION-XFILE.", 26); pkt->size = out + 26 - pkt->data; pkt->flags |= AV_PKT_FLAG_KEY; *[[posturing]] = 1; return 0; }
--------------------------------------------- Result 1199 ---------------------------------------------
[[0 (55%)]] --> [[0 (44%)]] --> Socre: 0.5588924288749695

[[[[Adv]]]]: static int scsi_req_length(SCSICommand *cmd, SCSIDevice *[[dev]], uint8_t *buf) { cmd->xfer = scsi_cdb_length(buf); switch (buf[0]) { case TEST_UNIT_READY: case REWIND: case START_STOP: case SET_CAPACITY: case WRITE_FILEMARKS: case WRITE_FILEMARKS_16: case SPACE: case RESERVE: case RELEASE: case ERASE: case ALLOW_MEDIUM_REMOVAL: case SEEK_10: case SYNCHRONIZE_CACHE: case SYNCHRONIZE_CACHE_16: case LOCATE_16: case LOCK_UNLOCK_CACHE: case SET_CD_SPEED: case SET_LIMITS: case WRITE_LONG_10: case UPDATE_BLOCK: case RESERVE_TRACK: case SET_READ_AHEAD: case PRE_FETCH: case PRE_FETCH_16: case ALLOW_OVERWRITE: cmd->xfer = 0; break; case VERIFY_10: case VERIFY_12: case VERIFY_16: if ((buf[1] & 2) == 0) { cmd->xfer = 0; } else if ((buf[1] & 4) == 1) { cmd->xfer = 1; } cmd->xfer *= [[dev]]->blocksize; break; case MODE_SENSE: break; case WRITE_SAME_10: case WRITE_SAME_16: cmd->xfer = [[dev]]->blocksize; break; case READ_CAPACITY_10: cmd->xfer = 8; break; case READ_BLOCK_LIMITS: cmd->xfer = 6; break; case SEND_VOLUME_TAG: if ([[dev]]->type == TYPE_ROM) { cmd->xfer = buf[10] | (buf[9] << 8); } else { cmd->xfer = buf[9] | (buf[8] << 8); } break; case WRITE_6: if (cmd->xfer == 0) { cmd->xfer = 256; } case WRITE_10: case WRITE_VERIFY_10: case WRITE_12: case WRITE_VERIFY_12: case WRITE_16: case WRITE_VERIFY_16: cmd->xfer *= [[dev]]->blocksize; break; case READ_6: case READ_REVERSE: if (cmd->xfer == 0) { cmd->xfer = 256; } case READ_10: case RECOVER_BUFFERED_DATA: case READ_12: case READ_16: cmd->xfer *= [[dev]]->blocksize; break; case FORMAT_UNIT: if ([[dev]]->type == TYPE_ROM && (buf[1] & 16)) { cmd->xfer = 12; } else { cmd->xfer = (buf[1] & 16) == 0 ? 0 : (buf[1] & 32 ? 8 : 4); } break; case INQUIRY: case RECEIVE_DIAGNOSTIC: case SEND_DIAGNOSTIC: cmd->xfer = buf[4] | (buf[3] << 8); break; case READ_CD: case READ_BUFFER: case WRITE_BUFFER: case SEND_CUE_SHEET: cmd->xfer = buf[8] | (buf[7] << 8) | (buf[6] << 16); break; case PERSISTENT_RESERVE_OUT: cmd->xfer = ldl_be_p(&buf[5]) & 0xffffffffULL; break; case ERASE_12: if ([[dev]]->type == TYPE_ROM) { cmd->xfer = scsi_get_performance_length(buf[9] | (buf[8] << 8), buf[10], buf[1] & 0x1f); } break; case MECHANISM_STATUS: case READ_DVD_STRUCTURE: case SEND_DVD_STRUCTURE: case MAINTENANCE_OUT: case MAINTENANCE_IN: if ([[dev]]->type == TYPE_ROM) { cmd->xfer = buf[9] | (buf[8] << 8); } break; case ATA_PASSTHROUGH_12: if ([[dev]]->type == TYPE_ROM) { cmd->xfer = 0; } else { cmd->xfer = ata_passthrough_12_xfer_size([[dev]], buf); } break; case ATA_PASSTHROUGH_16: cmd->xfer = ata_passthrough_16_xfer_size([[dev]], buf); break; } return 0; }

[[[[Adv]]]]: static int scsi_req_length(SCSICommand *cmd, SCSIDevice *[[iand]], uint8_t *buf) { cmd->xfer = scsi_cdb_length(buf); switch (buf[0]) { case TEST_UNIT_READY: case REWIND: case START_STOP: case SET_CAPACITY: case WRITE_FILEMARKS: case WRITE_FILEMARKS_16: case SPACE: case RESERVE: case RELEASE: case ERASE: case ALLOW_MEDIUM_REMOVAL: case SEEK_10: case SYNCHRONIZE_CACHE: case SYNCHRONIZE_CACHE_16: case LOCATE_16: case LOCK_UNLOCK_CACHE: case SET_CD_SPEED: case SET_LIMITS: case WRITE_LONG_10: case UPDATE_BLOCK: case RESERVE_TRACK: case SET_READ_AHEAD: case PRE_FETCH: case PRE_FETCH_16: case ALLOW_OVERWRITE: cmd->xfer = 0; break; case VERIFY_10: case VERIFY_12: case VERIFY_16: if ((buf[1] & 2) == 0) { cmd->xfer = 0; } else if ((buf[1] & 4) == 1) { cmd->xfer = 1; } cmd->xfer *= [[iand]]->blocksize; break; case MODE_SENSE: break; case WRITE_SAME_10: case WRITE_SAME_16: cmd->xfer = [[iand]]->blocksize; break; case READ_CAPACITY_10: cmd->xfer = 8; break; case READ_BLOCK_LIMITS: cmd->xfer = 6; break; case SEND_VOLUME_TAG: if ([[iand]]->type == TYPE_ROM) { cmd->xfer = buf[10] | (buf[9] << 8); } else { cmd->xfer = buf[9] | (buf[8] << 8); } break; case WRITE_6: if (cmd->xfer == 0) { cmd->xfer = 256; } case WRITE_10: case WRITE_VERIFY_10: case WRITE_12: case WRITE_VERIFY_12: case WRITE_16: case WRITE_VERIFY_16: cmd->xfer *= [[iand]]->blocksize; break; case READ_6: case READ_REVERSE: if (cmd->xfer == 0) { cmd->xfer = 256; } case READ_10: case RECOVER_BUFFERED_DATA: case READ_12: case READ_16: cmd->xfer *= [[iand]]->blocksize; break; case FORMAT_UNIT: if ([[iand]]->type == TYPE_ROM && (buf[1] & 16)) { cmd->xfer = 12; } else { cmd->xfer = (buf[1] & 16) == 0 ? 0 : (buf[1] & 32 ? 8 : 4); } break; case INQUIRY: case RECEIVE_DIAGNOSTIC: case SEND_DIAGNOSTIC: cmd->xfer = buf[4] | (buf[3] << 8); break; case READ_CD: case READ_BUFFER: case WRITE_BUFFER: case SEND_CUE_SHEET: cmd->xfer = buf[8] | (buf[7] << 8) | (buf[6] << 16); break; case PERSISTENT_RESERVE_OUT: cmd->xfer = ldl_be_p(&buf[5]) & 0xffffffffULL; break; case ERASE_12: if ([[iand]]->type == TYPE_ROM) { cmd->xfer = scsi_get_performance_length(buf[9] | (buf[8] << 8), buf[10], buf[1] & 0x1f); } break; case MECHANISM_STATUS: case READ_DVD_STRUCTURE: case SEND_DVD_STRUCTURE: case MAINTENANCE_OUT: case MAINTENANCE_IN: if ([[iand]]->type == TYPE_ROM) { cmd->xfer = buf[9] | (buf[8] << 8); } break; case ATA_PASSTHROUGH_12: if ([[iand]]->type == TYPE_ROM) { cmd->xfer = 0; } else { cmd->xfer = ata_passthrough_12_xfer_size([[iand]], buf); } break; case ATA_PASSTHROUGH_16: cmd->xfer = ata_passthrough_16_xfer_size([[iand]], buf); break; } return 0; }
--------------------------------------------- Result 1200 ---------------------------------------------
[[0 (42%)]] --> [[0 (66%)]] --> Socre: 0.6583982110023499

[[[[Adv]]]]: static void qdm2_init(QDM2Context *q) { static int [[inited]] = 0; if ([[inited]] != 0) return; [[inited]] = 1; qdm2_init_vlc(); ff_mpa_synth_init(mpa_window); softclip_table_init(); rnd_table_init(); init_noise_samples(); av_log(NULL, AV_LOG_DEBUG, "init done\n"); }

[[[[Adv]]]]: static void qdm2_init(QDM2Context *q) { static int [[depicts]] = 0; if ([[depicts]] != 0) return; [[depicts]] = 1; qdm2_init_vlc(); ff_mpa_synth_init(mpa_window); softclip_table_init(); rnd_table_init(); init_noise_samples(); av_log(NULL, AV_LOG_DEBUG, "init done\n"); }
--------------------------------------------- Result 1201 ---------------------------------------------
[[0 (27%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int encode_frame(FlacEncodeContext *s) { int ch, count; count = count_frame_header(s); for (ch = 0; ch < s->channels; ch++) count += encode_residual_ch(s, ch); count += (8 - (count & 7)) & 7; count += 16; return count >> 3; }
--------------------------------------------- Result 1202 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 704 / 64 / 434 / 1202:  45%|     | 1202/2690 [13:17:53<16:27:44, 39.83s/it][Succeeded / Failed / Skipped / Total] 704 / 64 / 434 / 1202:  45%|     | 1203/2690 [13:18:18<16:26:46, 39.82s/it][[0 (39%)]] --> [[0 (73%)]] --> Socre: 0.7342404723167419

[[[[Adv]]]]: static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos) { PCIDevice *[[pdev]] = &vdev->pdev; uint8_t cap_id, next, size; int ret; cap_id = [[pdev]]->config[pos]; next = [[pdev]]->config[pos + PCI_CAP_LIST_NEXT]; size = vfio_std_cap_max_size([[pdev]], pos); if (next) { ret = vfio_add_std_cap(vdev, next); if (ret) { return ret; } } else { [[pdev]]->config[PCI_CAPABILITY_LIST] = 0; vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff; vdev->emulated_config_bits[PCI_STATUS] |= PCI_STATUS_CAP_LIST; } pci_set_byte(vdev->emulated_config_bits + pos + PCI_CAP_LIST_NEXT, 0xff); switch (cap_id) { case PCI_CAP_ID_MSI: ret = vfio_msi_setup(vdev, pos); break; case PCI_CAP_ID_EXP: vfio_check_pcie_flr(vdev, pos); ret = vfio_setup_pcie_cap(vdev, pos, size); break; case PCI_CAP_ID_MSIX: ret = vfio_msix_setup(vdev, pos); break; case PCI_CAP_ID_PM: vfio_check_pm_reset(vdev, pos); vdev->pm_cap = pos; ret = pci_add_capability([[pdev]], cap_id, pos, size); break; case PCI_CAP_ID_AF: vfio_check_af_flr(vdev, pos); ret = pci_add_capability([[pdev]], cap_id, pos, size); break; default: ret = pci_add_capability([[pdev]], cap_id, pos, size); break; } if (ret < 0) { error_report("vfio: %04x:%02x:%02x.%x Error adding PCI capability " "0x%x[0x%x]@0x%x: %d", vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function, cap_id, size, pos, ret); return ret; } return 0; }

[[[[Adv]]]]: static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos) { PCIDevice *[[nightmares]] = &vdev->pdev; uint8_t cap_id, next, size; int ret; cap_id = [[nightmares]]->config[pos]; next = [[nightmares]]->config[pos + PCI_CAP_LIST_NEXT]; size = vfio_std_cap_max_size([[nightmares]], pos); if (next) { ret = vfio_add_std_cap(vdev, next); if (ret) { return ret; } } else { [[nightmares]]->config[PCI_CAPABILITY_LIST] = 0; vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff; vdev->emulated_config_bits[PCI_STATUS] |= PCI_STATUS_CAP_LIST; } pci_set_byte(vdev->emulated_config_bits + pos + PCI_CAP_LIST_NEXT, 0xff); switch (cap_id) { case PCI_CAP_ID_MSI: ret = vfio_msi_setup(vdev, pos); break; case PCI_CAP_ID_EXP: vfio_check_pcie_flr(vdev, pos); ret = vfio_setup_pcie_cap(vdev, pos, size); break; case PCI_CAP_ID_MSIX: ret = vfio_msix_setup(vdev, pos); break; case PCI_CAP_ID_PM: vfio_check_pm_reset(vdev, pos); vdev->pm_cap = pos; ret = pci_add_capability([[nightmares]], cap_id, pos, size); break; case PCI_CAP_ID_AF: vfio_check_af_flr(vdev, pos); ret = pci_add_capability([[nightmares]], cap_id, pos, size); break; default: ret = pci_add_capability([[nightmares]], cap_id, pos, size); break; } if (ret < 0) { error_report("vfio: %04x:%02x:%02x.%x Error adding PCI capability " "0x%x[0x%x]@0x%x: %d", vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function, cap_id, size, pos, ret); return ret; } return 0; }
--------------------------------------------- Result 1203 ---------------------------------------------
[[0 (44%)]] --> [[0 (64%)]] --> Socre: 0.6411421298980713

[[[[Adv]]]]: int cpu_exec(CPUState *[[env1]]) { #define DECLARE_HOST_REGS 1 #include "hostregs_helper.h" int ret, interrupt_request; TranslationBlock *tb; uint8_t *tc_ptr; unsigned long next_tb; if (cpu_halted([[env1]]) == EXCP_HALTED) return EXCP_HALTED; cpu_single_env = [[env1]]; #define SAVE_HOST_REGS 1 #include "hostregs_helper.h" env = [[env1]]; #if defined(TARGET_I386) CC_SRC = env->eflags & (CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C); DF = 1 - (2 * ((env->eflags >> 10) & 1)); CC_OP = CC_OP_EFLAGS; env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C); #elif defined(TARGET_SPARC) #elif defined(TARGET_M68K) env->cc_op = CC_OP_FLAGS; env->cc_dest = env->sr & 0xf; env->cc_x = (env->sr >> 4) & 1; #elif defined(TARGET_ALPHA) #elif defined(TARGET_ARM) #elif defined(TARGET_PPC) #elif defined(TARGET_MICROBLAZE) #elif defined(TARGET_MIPS) #elif defined(TARGET_SH4) #elif defined(TARGET_CRIS) #elif defined(TARGET_S390X) #else #error unsupported target CPU #endif env->exception_index = -1; for(;;) { if (setjmp(env->jmp_env) == 0) { #if defined(__sparc__) && !defined(CONFIG_SOLARIS) #undef env env = cpu_single_env; #define env cpu_single_env #endif if (env->exception_index >= 0) { if (env->exception_index >= EXCP_INTERRUPT) { ret = env->exception_index; if (ret == EXCP_DEBUG) cpu_handle_debug_exception(env); break; } else { #if defined(CONFIG_USER_ONLY) #if defined(TARGET_I386) do_interrupt_user(env->exception_index, env->exception_is_int, env->error_code, env->exception_next_eip); env->old_exception = -1; #endif ret = env->exception_index; break; #else #if defined(TARGET_I386) do_interrupt(env->exception_index, env->exception_is_int, env->error_code, env->exception_next_eip, 0); env->old_exception = -1; #elif defined(TARGET_PPC) do_interrupt(env); #elif defined(TARGET_MICROBLAZE) do_interrupt(env); #elif defined(TARGET_MIPS) do_interrupt(env); #elif defined(TARGET_SPARC) do_interrupt(env); #elif defined(TARGET_ARM) do_interrupt(env); #elif defined(TARGET_SH4) do_interrupt(env); #elif defined(TARGET_ALPHA) do_interrupt(env); #elif defined(TARGET_CRIS) do_interrupt(env); #elif defined(TARGET_M68K) do_interrupt(0); #endif env->exception_index = -1; #endif } } if (kvm_enabled()) { kvm_cpu_exec(env); longjmp(env->jmp_env, 1); } next_tb = 0; for(;;) { interrupt_request = env->interrupt_request; if (unlikely(interrupt_request)) { if (unlikely(env->singlestep_enabled & SSTEP_NOIRQ)) { interrupt_request &= ~(CPU_INTERRUPT_HARD | CPU_INTERRUPT_FIQ | CPU_INTERRUPT_SMI | CPU_INTERRUPT_NMI); } if (interrupt_request & CPU_INTERRUPT_DEBUG) { env->interrupt_request &= ~CPU_INTERRUPT_DEBUG; env->exception_index = EXCP_DEBUG; cpu_loop_exit(); } #if defined(TARGET_ARM) || defined(TARGET_SPARC) || defined(TARGET_MIPS) || \ defined(TARGET_PPC) || defined(TARGET_ALPHA) || defined(TARGET_CRIS) || \ defined(TARGET_MICROBLAZE) if (interrupt_request & CPU_INTERRUPT_HALT) { env->interrupt_request &= ~CPU_INTERRUPT_HALT; env->halted = 1; env->exception_index = EXCP_HLT; cpu_loop_exit(); } #endif #if defined(TARGET_I386) if (interrupt_request & CPU_INTERRUPT_INIT) { svm_check_intercept(SVM_EXIT_INIT); do_cpu_init(env); env->exception_index = EXCP_HALTED; cpu_loop_exit(); } else if (interrupt_request & CPU_INTERRUPT_SIPI) { do_cpu_sipi(env); } else if (env->hflags2 & HF2_GIF_MASK) { if ((interrupt_request & CPU_INTERRUPT_SMI) && !(env->hflags & HF_SMM_MASK)) { svm_check_intercept(SVM_EXIT_SMI); env->interrupt_request &= ~CPU_INTERRUPT_SMI; do_smm_enter(); next_tb = 0; } else if ((interrupt_request & CPU_INTERRUPT_NMI) && !(env->hflags2 & HF2_NMI_MASK)) { env->interrupt_request &= ~CPU_INTERRUPT_NMI; env->hflags2 |= HF2_NMI_MASK; do_interrupt(EXCP02_NMI, 0, 0, 0, 1); next_tb = 0; } else if (interrupt_request & CPU_INTERRUPT_MCE) { env->interrupt_request &= ~CPU_INTERRUPT_MCE; do_interrupt(EXCP12_MCHK, 0, 0, 0, 0); next_tb = 0; } else if ((interrupt_request & CPU_INTERRUPT_HARD) && (((env->hflags2 & HF2_VINTR_MASK) && (env->hflags2 & HF2_HIF_MASK)) || (!(env->hflags2 & HF2_VINTR_MASK) && (env->eflags & IF_MASK && !(env->hflags & HF_INHIBIT_IRQ_MASK))))) { int intno; svm_check_intercept(SVM_EXIT_INTR); env->interrupt_request &= ~(CPU_INTERRUPT_HARD | CPU_INTERRUPT_VIRQ); intno = cpu_get_pic_interrupt(env); qemu_log_mask(CPU_LOG_TB_IN_ASM, "Servicing hardware INT=0x%02x\n", intno); #if defined(__sparc__) && !defined(CONFIG_SOLARIS) #undef env env = cpu_single_env; #define env cpu_single_env #endif do_interrupt(intno, 0, 0, 0, 1); next_tb = 0; #if !defined(CONFIG_USER_ONLY) } else if ((interrupt_request & CPU_INTERRUPT_VIRQ) && (env->eflags & IF_MASK) && !(env->hflags & HF_INHIBIT_IRQ_MASK)) { int intno; svm_check_intercept(SVM_EXIT_VINTR); intno = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.int_vector)); qemu_log_mask(CPU_LOG_TB_IN_ASM, "Servicing virtual hardware INT=0x%02x\n", intno); do_interrupt(intno, 0, 0, 0, 1); env->interrupt_request &= ~CPU_INTERRUPT_VIRQ; next_tb = 0; #endif } } #elif defined(TARGET_PPC) #if 0 if ((interrupt_request & CPU_INTERRUPT_RESET)) { cpu_reset(env); } #endif if (interrupt_request & CPU_INTERRUPT_HARD) { ppc_hw_interrupt(env); if (env->pending_interrupts == 0) env->interrupt_request &= ~CPU_INTERRUPT_HARD; next_tb = 0; } #elif defined(TARGET_MICROBLAZE) if ((interrupt_request & CPU_INTERRUPT_HARD) && (env->sregs[SR_MSR] & MSR_IE) && !(env->sregs[SR_MSR] & (MSR_EIP | MSR_BIP)) && !(env->iflags & (D_FLAG | IMM_FLAG))) { env->exception_index = EXCP_IRQ; do_interrupt(env); next_tb = 0; } #elif defined(TARGET_MIPS) if ((interrupt_request & CPU_INTERRUPT_HARD) && (env->CP0_Status & env->CP0_Cause & CP0Ca_IP_mask) && (env->CP0_Status & (1 << CP0St_IE)) && !(env->CP0_Status & (1 << CP0St_EXL)) && !(env->CP0_Status & (1 << CP0St_ERL)) && !(env->hflags & MIPS_HFLAG_DM)) { env->exception_index = EXCP_EXT_INTERRUPT; env->error_code = 0; do_interrupt(env); next_tb = 0; } #elif defined(TARGET_SPARC) if (interrupt_request & CPU_INTERRUPT_HARD) { if (cpu_interrupts_enabled(env) && env->interrupt_index > 0) { int pil = env->interrupt_index & 0xf; int type = env->interrupt_index & 0xf0; if (((type == TT_EXTINT) && cpu_pil_allowed(env, pil)) || type != TT_EXTINT) { env->exception_index = env->interrupt_index; do_interrupt(env); next_tb = 0; } } } else if (interrupt_request & CPU_INTERRUPT_TIMER) { env->interrupt_request &= ~CPU_INTERRUPT_TIMER; } #elif defined(TARGET_ARM) if (interrupt_request & CPU_INTERRUPT_FIQ && !(env->uncached_cpsr & CPSR_F)) { env->exception_index = EXCP_FIQ; do_interrupt(env); next_tb = 0; } if (interrupt_request & CPU_INTERRUPT_HARD && ((IS_M(env) && env->regs[15] < 0xfffffff0) || !(env->uncached_cpsr & CPSR_I))) { env->exception_index = EXCP_IRQ; do_interrupt(env); next_tb = 0; } #elif defined(TARGET_SH4) if (interrupt_request & CPU_INTERRUPT_HARD) { do_interrupt(env); next_tb = 0; } #elif defined(TARGET_ALPHA) if (interrupt_request & CPU_INTERRUPT_HARD) { do_interrupt(env); next_tb = 0; } #elif defined(TARGET_CRIS) if (interrupt_request & CPU_INTERRUPT_HARD && (env->pregs[PR_CCS] & I_FLAG)) { env->exception_index = EXCP_IRQ; do_interrupt(env); next_tb = 0; } if (interrupt_request & CPU_INTERRUPT_NMI && (env->pregs[PR_CCS] & M_FLAG)) { env->exception_index = EXCP_NMI; do_interrupt(env); next_tb = 0; } #elif defined(TARGET_M68K) if (interrupt_request & CPU_INTERRUPT_HARD && ((env->sr & SR_I) >> SR_I_SHIFT) < env->pending_level) { env->exception_index = env->pending_vector; do_interrupt(1); next_tb = 0; } #endif if (env->interrupt_request & CPU_INTERRUPT_EXITTB) { env->interrupt_request &= ~CPU_INTERRUPT_EXITTB; next_tb = 0; } } if (unlikely(env->exit_request)) { env->exit_request = 0; env->exception_index = EXCP_INTERRUPT; cpu_loop_exit(); } #ifdef CONFIG_DEBUG_EXEC if (qemu_loglevel_mask(CPU_LOG_TB_CPU)) { #if defined(TARGET_I386) env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK); log_cpu_state(env, X86_DUMP_CCOP); env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C); #elif defined(TARGET_ARM) log_cpu_state(env, 0); #elif defined(TARGET_SPARC) log_cpu_state(env, 0); #elif defined(TARGET_PPC) log_cpu_state(env, 0); #elif defined(TARGET_M68K) cpu_m68k_flush_flags(env, env->cc_op); env->cc_op = CC_OP_FLAGS; env->sr = (env->sr & 0xffe0) | env->cc_dest | (env->cc_x << 4); log_cpu_state(env, 0); #elif defined(TARGET_MICROBLAZE) log_cpu_state(env, 0); #elif defined(TARGET_MIPS) log_cpu_state(env, 0); #elif defined(TARGET_SH4) log_cpu_state(env, 0); #elif defined(TARGET_ALPHA) log_cpu_state(env, 0); #elif defined(TARGET_CRIS) log_cpu_state(env, 0); #else #error unsupported target CPU #endif } #endif spin_lock(&tb_lock); tb = tb_find_fast(); if (tb_invalidated_flag) { next_tb = 0; tb_invalidated_flag = 0; } #ifdef CONFIG_DEBUG_EXEC qemu_log_mask(CPU_LOG_EXEC, "Trace 0x%08lx [" TARGET_FMT_lx "] %s\n", (long)tb->tc_ptr, tb->pc, lookup_symbol(tb->pc)); #endif if (next_tb != 0 && tb->page_addr[1] == -1) { tb_add_jump((TranslationBlock *)(next_tb & ~3), next_tb & 3, tb); } spin_unlock(&tb_lock); if (!unlikely (env->exit_request)) { env->current_tb = tb; tc_ptr = tb->tc_ptr; #if defined(__sparc__) && !defined(CONFIG_SOLARIS) #undef env env = cpu_single_env; #define env cpu_single_env #endif next_tb = tcg_qemu_tb_exec(tc_ptr); env->current_tb = NULL; if ((next_tb & 3) == 2) { int insns_left; tb = (TranslationBlock *)(long)(next_tb & ~3); cpu_pc_from_tb(env, tb); insns_left = env->icount_decr.u32; if (env->icount_extra && insns_left >= 0) { env->icount_extra += insns_left; if (env->icount_extra > 0xffff) { insns_left = 0xffff; } else { insns_left = env->icount_extra; } env->icount_extra -= insns_left; env->icount_decr.u16.low = insns_left; } else { if (insns_left > 0) { cpu_exec_nocache(insns_left, tb); } env->exception_index = EXCP_INTERRUPT; next_tb = 0; cpu_loop_exit(); } } } } } } #if defined(TARGET_I386) env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK); #elif defined(TARGET_ARM) #elif defined(TARGET_SPARC) #elif defined(TARGET_PPC) #elif defined(TARGET_M68K) cpu_m68k_flush_flags(env, env->cc_op); env->cc_op = CC_OP_FLAGS; env->sr = (env->sr & 0xffe0) | env->cc_dest | (env->cc_x << 4); #elif defined(TARGET_MICROBLAZE) #elif defined(TARGET_MIPS) #elif defined(TARGET_SH4) #elif defined(TARGET_ALPHA) #elif defined(TARGET_CRIS) #elif defined(TARGET_S390X) #else #error unsupported target CPU #endif #include "hostregs_helper.h" cpu_single_env = NULL; return ret; }

[[[[Adv]]]]: int cpu_exec(CPUState *[[frederick]]) { #define DECLARE_HOST_REGS 1 #include "hostregs_helper.h" int ret, interrupt_request; TranslationBlock *tb; uint8_t *tc_ptr; unsigned long next_tb; if (cpu_halted([[frederick]]) == EXCP_HALTED) return EXCP_HALTED; cpu_single_env = [[frederick]]; #define SAVE_HOST_REGS 1 #include "hostregs_helper.h" env = [[frederick]]; #if defined(TARGET_I386) CC_SRC = env->eflags & (CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C); DF = 1 - (2 * ((env->eflags >> 10) & 1)); CC_OP = CC_OP_EFLAGS; env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C); #elif defined(TARGET_SPARC) #elif defined(TARGET_M68K) env->cc_op = CC_OP_FLAGS; env->cc_dest = env->sr & 0xf; env->cc_x = (env->sr >> 4) & 1; #elif defined(TARGET_ALPHA) #elif defined(TARGET_ARM) #elif defined(TARGET_PPC) #elif defined(TARGET_MICROBLAZE) #elif defined(TARGET_MIPS) #elif defined(TARGET_SH4) #elif defined(TARGET_CRIS) #elif defined(TARGET_S390X) #else #error unsupported target CPU #endif env->exception_index = -1; for(;;) { if (setjmp(env->jmp_env) == 0) { #if defined(__sparc__) && !defined(CONFIG_SOLARIS) #undef env env = cpu_single_env; #define env cpu_single_env #endif if (env->exception_index >= 0) { if (env->exception_index >= EXCP_INTERRUPT) { ret = env->exception_index; if (ret == EXCP_DEBUG) cpu_handle_debug_exception(env); break; } else { #if defined(CONFIG_USER_ONLY) #if defined(TARGET_I386) do_interrupt_user(env->exception_index, env->exception_is_int, env->error_code, env->exception_next_eip); env->old_exception = -1; #endif ret = env->exception_index; break; #else #if defined(TARGET_I386) do_interrupt(env->exception_index, env->exception_is_int, env->error_code, env->exception_next_eip, 0); env->old_exception = -1; #elif defined(TARGET_PPC) do_interrupt(env); #elif defined(TARGET_MICROBLAZE) do_interrupt(env); #elif defined(TARGET_MIPS) do_interrupt(env); #elif defined(TARGET_SPARC) do_interrupt(env); #elif defined(TARGET_ARM) do_interrupt(env); #elif defined(TARGET_SH4) do_interrupt(env); #elif defined(TARGET_ALPHA) do_interrupt(env); #elif defined(TARGET_CRIS) do_interrupt(env); #elif defined(TARGET_M68K) do_interrupt(0); #endif env->exception_index = -1; #endif } } if (kvm_enabled()) { kvm_cpu_exec(env); longjmp(env->jmp_env, 1); } next_tb = 0; for(;;) { interrupt_request = env->interrupt_request; if (unlikely(interrupt_request)) { if (unlikely(env->singlestep_enabled & SSTEP_NOIRQ)) { interrupt_request &= ~(CPU_INTERRUPT_HARD | CPU_INTERRUPT_FIQ | CPU_INTERRUPT_SMI | CPU_INTERRUPT_NMI); } if (interrupt_request & CPU_INTERRUPT_DEBUG) { env->interrupt_request &= ~CPU_INTERRUPT_DEBUG; env->exception_index = EXCP_DEBUG; cpu_loop_exit(); } #if defined(TARGET_ARM) || defined(TARGET_SPARC) || defined(TARGET_MIPS) || \ defined(TARGET_PPC) || defined(TARGET_ALPHA) || defined(TARGET_CRIS) || \ defined(TARGET_MICROBLAZE) if (interrupt_request & CPU_INTERRUPT_HALT) { env->interrupt_request &= ~CPU_INTERRUPT_HALT; env->halted = 1; env->exception_index = EXCP_HLT; cpu_loop_exit(); } #endif #if defined(TARGET_I386) if (interrupt_request & CPU_INTERRUPT_INIT) { svm_check_intercept(SVM_EXIT_INIT); do_cpu_init(env); env->exception_index = EXCP_HALTED; cpu_loop_exit(); } else if (interrupt_request & CPU_INTERRUPT_SIPI) { do_cpu_sipi(env); } else if (env->hflags2 & HF2_GIF_MASK) { if ((interrupt_request & CPU_INTERRUPT_SMI) && !(env->hflags & HF_SMM_MASK)) { svm_check_intercept(SVM_EXIT_SMI); env->interrupt_request &= ~CPU_INTERRUPT_SMI; do_smm_enter(); next_tb = 0; } else if ((interrupt_request & CPU_INTERRUPT_NMI) && !(env->hflags2 & HF2_NMI_MASK)) { env->interrupt_request &= ~CPU_INTERRUPT_NMI; env->hflags2 |= HF2_NMI_MASK; do_interrupt(EXCP02_NMI, 0, 0, 0, 1); next_tb = 0; } else if (interrupt_request & CPU_INTERRUPT_MCE) { env->interrupt_request &= ~CPU_INTERRUPT_MCE; do_interrupt(EXCP12_MCHK, 0, 0, 0, 0); next_tb = 0; } else if ((interrupt_request & CPU_INTERRUPT_HARD) && (((env->hflags2 & HF2_VINTR_MASK) && (env->hflags2 & HF2_HIF_MASK)) || (!(env->hflags2 & HF2_VINTR_MASK) && (env->eflags & IF_MASK && !(env->hflags & HF_INHIBIT_IRQ_MASK))))) { int intno; svm_check_intercept(SVM_EXIT_INTR); env->interrupt_request &= ~(CPU_INTERRUPT_HARD | CPU_INTERRUPT_VIRQ); intno = cpu_get_pic_interrupt(env); qemu_log_mask(CPU_LOG_TB_IN_ASM, "Servicing hardware INT=0x%02x\n", intno); #if defined(__sparc__) && !defined(CONFIG_SOLARIS) #undef env env = cpu_single_env; #define env cpu_single_env #endif do_interrupt(intno, 0, 0, 0, 1); next_tb = 0; #if !defined(CONFIG_USER_ONLY) } else if ((interrupt_request & CPU_INTERRUPT_VIRQ) && (env->eflags & IF_MASK) && !(env->hflags & HF_INHIBIT_IRQ_MASK)) { int intno; svm_check_intercept(SVM_EXIT_VINTR); intno = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.int_vector)); qemu_log_mask(CPU_LOG_TB_IN_ASM, "Servicing virtual hardware INT=0x%02x\n", intno); do_interrupt(intno, 0, 0, 0, 1); env->interrupt_request &= ~CPU_INTERRUPT_VIRQ; next_tb = 0; #endif } } #elif defined(TARGET_PPC) #if 0 if ((interrupt_request & CPU_INTERRUPT_RESET)) { cpu_reset(env); } #endif if (interrupt_request & CPU_INTERRUPT_HARD) { ppc_hw_interrupt(env); if (env->pending_interrupts == 0) env->interrupt_request &= ~CPU_INTERRUPT_HARD; next_tb = 0; } #elif defined(TARGET_MICROBLAZE) if ((interrupt_request & CPU_INTERRUPT_HARD) && (env->sregs[SR_MSR] & MSR_IE) && !(env->sregs[SR_MSR] & (MSR_EIP | MSR_BIP)) && !(env->iflags & (D_FLAG | IMM_FLAG))) { env->exception_index = EXCP_IRQ; do_interrupt(env); next_tb = 0; } #elif defined(TARGET_MIPS) if ((interrupt_request & CPU_INTERRUPT_HARD) && (env->CP0_Status & env->CP0_Cause & CP0Ca_IP_mask) && (env->CP0_Status & (1 << CP0St_IE)) && !(env->CP0_Status & (1 << CP0St_EXL)) && !(env->CP0_Status & (1 << CP0St_ERL)) && !(env->hflags & MIPS_HFLAG_DM)) { env->exception_index = EXCP_EXT_INTERRUPT; env->error_code = 0; do_interrupt(env); next_tb = 0; } #elif defined(TARGET_SPARC) if (interrupt_request & CPU_INTERRUPT_HARD) { if (cpu_interrupts_enabled(env) && env->interrupt_index > 0) { int pil = env->interrupt_index & 0xf; int type = env->interrupt_index & 0xf0; if (((type == TT_EXTINT) && cpu_pil_allowed(env, pil)) || type != TT_EXTINT) { env->exception_index = env->interrupt_index; do_interrupt(env); next_tb = 0; } } } else if (interrupt_request & CPU_INTERRUPT_TIMER) { env->interrupt_request &= ~CPU_INTERRUPT_TIMER; } #elif defined(TARGET_ARM) if (interrupt_request & CPU_INTERRUPT_FIQ && !(env->uncached_cpsr & CPSR_F)) { env->exception_index = EXCP_FIQ; do_interrupt(env); next_tb = 0; } if (interrupt_request & CPU_INTERRUPT_HARD && ((IS_M(env) && env->regs[15] < 0xfffffff0) || !(env->uncached_cpsr & CPSR_I))) { env->exception_index = EXCP_IRQ; do_interrupt(env); next_tb = 0; } #elif defined(TARGET_SH4) if (interrupt_request & CPU_INTERRUPT_HARD) { do_interrupt(env); next_tb = 0; } #elif defined(TARGET_ALPHA) if (interrupt_request & CPU_INTERRUPT_HARD) { do_interrupt(env); next_tb = 0; } #elif defined(TARGET_CRIS) if (interrupt_request & CPU_INTERRUPT_HARD && (env->pregs[PR_CCS] & I_FLAG)) { env->exception_index = EXCP_IRQ; do_interrupt(env); next_tb = 0; } if (interrupt_request & CPU_INTERRUPT_NMI && (env->pregs[PR_CCS] & M_FLAG)) { env->exception_index = EXCP_NMI; do_interrupt(env); next_tb = 0; } #elif defined(TARGET_M68K) if (interrupt_request & CPU_INTERRUPT_HARD && ((env->sr & SR_I) >> SR_I_SHIFT) < env->pending_level) { env->exception_index = env->pending_vector; do_interrupt(1); next_tb = 0; } #endif if (env->interrupt_request & CPU_INTERRUPT_EXITTB) { env->interrupt_request &= ~CPU_INTERRUPT_EXITTB; next_tb = 0; } } if (unlikely(env->exit_request)) { env->exit_request = 0; env->exception_index = EXCP_INTERRUPT; cpu_loop_exit(); } #ifdef CONFIG_DEBUG_EXEC if (qemu_loglevel_mask(CPU_LOG_TB_CPU)) { #if defined(TARGET_I386) env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK); log_cpu_state(env, X86_DUMP_CCOP); env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C); #elif defined(TARGET_ARM) log_cpu_state(env, 0); #elif defined(TARGET_SPARC) log_cpu_state(env, 0); #elif defined(TARGET_PPC) log_cpu_state(env, 0); #elif defined(TARGET_M68K) cpu_m68k_flush_flags(env, env->cc_op); env->cc_op = CC_OP_FLAGS; env->sr = (env->sr & 0xffe0) | env->cc_dest | (env->cc_x << 4); log_cpu_state(env, 0); #elif defined(TARGET_MICROBLAZE) log_cpu_state(env, 0); #elif defined(TARGET_MIPS) log_cpu_state(env, 0); #elif defined(TARGET_SH4) log_cpu_state(env, 0); #elif defined(TARGET_ALPHA) log_cpu_state(env, 0); #elif defined(TARGET_CRIS) log_cpu_state(env, 0); #else #error unsupported target CPU #endif } #endif spin_lock(&tb_lock); tb = tb_find_fast(); if (tb_invalidated_flag) { next_tb = 0; tb_invalidated_flag = 0; } #ifdef CONFIG_DEBUG_EXEC qemu_log_mask(CPU_LOG_EXEC, "Trace 0x%08lx [" TARGET_FMT_lx "] %s\n", (long)tb->tc_ptr, tb->pc, lookup_symbol(tb->pc)); #endif if (next_tb != 0 && tb->page_addr[1] == -1) { tb_add_jump((TranslationBlock *)(next_tb & ~3), next_tb & 3, tb); } spin_unlock(&tb_lock); if (!unlikely (env->exit_request)) { env->current_tb = tb; tc_ptr = tb->tc_ptr; #if defined(__sparc__) && !defined(CONFIG_SOLARIS) #undef env env = cpu_single_env; #define env cpu_single_env #endif next_tb = tcg_qemu_tb_exec(tc_ptr); env->current_tb = NULL; if ((next_tb & 3) == 2) { int insns_left; tb = (TranslationBlock *)(long)(next_tb & ~3); cpu_pc_from_tb(env, tb); insns_left = env->icount_decr.u32; if (env->icount_extra && insns_left >= 0) { env->icount_extra += insns_left; if (env->icount_extra > 0xffff) { insns_left = 0xffff; } else { insns_left = env->icount_extra; } env->icount_extra -= insns_left; env->icount_decr.u16.low = insns_left; } else { if (insns_left > 0) { cpu_exec_nocache(insns_left, tb); } env->exception_index = EXCP_INTERRUPT; next_tb = 0; cpu_loop_exit(); } } } } } } #if defined(TARGET_I386) env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK); #elif defined(TARGET_ARM) #elif defined(TARGET_SPARC) #elif defined(TARGET_PPC) #elif defined(TARGET_M68K) cpu_m68k_flush_flags(env, env->cc_op); env->cc_op = CC_OP_FLAGS; env->sr = (env->sr & 0xffe0) | env->cc_dest | (env->cc_x << 4); #elif defined(TARGET_MICROBLAZE) #elif defined(TARGET_MIPS) #elif defined(TARGET_SH4) #elif defined(TARGET_ALPHA) #elif defined(TARGET_CRIS) #elif defined(TARGET_S390X) #else #error unsupported target CPU #endif #include "hostregs_helper.h" cpu_single_env = NULL; return ret; }[Succeeded / Failed / Skipped / Total] 705 / 64 / 434 / 1203:  45%|     | 1203/2690 [13:18:18<16:26:46, 39.82s/it][Succeeded / Failed / Skipped / Total] 705 / 64 / 434 / 1203:  45%|     | 1204/2690 [13:18:19<16:25:17, 39.78s/it][Succeeded / Failed / Skipped / Total] 705 / 64 / 435 / 1204:  45%|     | 1204/2690 [13:18:19<16:25:17, 39.78s/it][Succeeded / Failed / Skipped / Total] 705 / 64 / 435 / 1204:  45%|     | 1205/2690 [13:19:08<16:24:50, 39.79s/it][Succeeded / Failed / Skipped / Total] 706 / 64 / 435 / 1205:  45%|     | 1205/2690 [13:19:08<16:24:50, 39.79s/it][Succeeded / Failed / Skipped / Total] 706 / 64 / 435 / 1205:  45%|     | 1206/2690 [13:19:12<16:23:26, 39.76s/it][Succeeded / Failed / Skipped / Total] 707 / 64 / 435 / 1206:  45%|     | 1206/2690 [13:19:12<16:23:26, 39.76s/it][Succeeded / Failed / Skipped / Total] 707 / 64 / 435 / 1206:  45%|     | 1207/2690 [13:19:32<16:22:22, 39.75s/it][Succeeded / Failed / Skipped / Total] 708 / 64 / 435 / 1207:  45%|     | 1207/2690 [13:19:32<16:22:22, 39.75s/it][Succeeded / Failed / Skipped / Total] 708 / 64 / 435 / 1207:  45%|     | 1208/2690 [13:19:38<16:21:01, 39.72s/it]
--------------------------------------------- Result 1204 ---------------------------------------------
[[0 (75%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void HELPER(v7m_msr)(CPUARMState *env, uint32_t maskreg, uint32_t val) { uint32_t mask = extract32(maskreg, 8, 4); uint32_t reg = extract32(maskreg, 0, 8); if (arm_current_el(env) == 0 && reg > 7) { return; } switch (reg) { case 0 ... 7: if (!(reg & 4)) { uint32_t apsrmask = 0; if (mask & 8) { apsrmask |= XPSR_NZCV | XPSR_Q; } if ((mask & 4) && arm_feature(env, ARM_FEATURE_THUMB_DSP)) { apsrmask |= XPSR_GE; } xpsr_write(env, val, apsrmask); } break; case 8: if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) { env->v7m.other_sp = val; } else { env->regs[13] = val; } break; case 9: if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) { env->regs[13] = val; } else { env->v7m.other_sp = val; } break; case 16: env->v7m.primask[env->v7m.secure] = val & 1; break; case 17: env->v7m.basepri[env->v7m.secure] = val & 0xff; break; case 18: val &= 0xff; if (val != 0 && (val < env->v7m.basepri[env->v7m.secure] || env->v7m.basepri[env->v7m.secure] == 0)) { env->v7m.basepri[env->v7m.secure] = val; } break; case 19: env->v7m.faultmask = val & 1; break; case 20: if (!arm_v7m_is_handler_mode(env)) { switch_v7m_sp(env, (val & R_V7M_CONTROL_SPSEL_MASK) != 0); } env->v7m.control &= ~R_V7M_CONTROL_NPRIV_MASK; env->v7m.control |= val & R_V7M_CONTROL_NPRIV_MASK; break; default: qemu_log_mask(LOG_GUEST_ERROR, "Attempt to write unknown special" " register %d\n", reg); return; } }
--------------------------------------------- Result 1205 ---------------------------------------------
[[0 (9%)]] --> [[0 (54%)]] --> Socre: 0.5351200103759766

[[[[Adv]]]]: static void find_best_solid_area(VncState *vs, int [[x]], int y, int w, int h, uint32_t color, int *[[w_ptr]], int *h_ptr) { int dx, dy, dw, dh; int w_prev; int w_best = 0, h_best = 0; w_prev = w; for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) { dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy); dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev); if (!check_solid_tile(vs, [[x]], dy, dw, dh, &color, "True" == "True")) { break; } for (dx = [[x]] + dw; dx < [[x]] + w_prev;) { dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, [[x]] + w_prev - dx); if (!check_solid_tile(vs, dx, dy, dw, dh, &color, "True" == "True")) { break; } dx += dw; } w_prev = dx - [[x]]; if (w_prev * (dy + dh - y) > w_best * h_best) { w_best = w_prev; h_best = dy + dh - y; } } *[[w_ptr]] = w_best; *h_ptr = h_best; }

[[[[Adv]]]]: static void find_best_solid_area(VncState *vs, int [[twelfth]], int y, int w, int h, uint32_t color, int *[[bagels]], int *h_ptr) { int dx, dy, dw, dh; int w_prev; int w_best = 0, h_best = 0; w_prev = w; for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) { dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy); dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev); if (!check_solid_tile(vs, [[twelfth]], dy, dw, dh, &color, "True" == "True")) { break; } for (dx = [[twelfth]] + dw; dx < [[twelfth]] + w_prev;) { dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, [[twelfth]] + w_prev - dx); if (!check_solid_tile(vs, dx, dy, dw, dh, &color, "True" == "True")) { break; } dx += dw; } w_prev = dx - [[twelfth]]; if (w_prev * (dy + dh - y) > w_best * h_best) { w_best = w_prev; h_best = dy + dh - y; } } *[[bagels]] = w_best; *h_ptr = h_best; }
--------------------------------------------- Result 1206 ---------------------------------------------
[[0 (33%)]] --> [[0 (53%)]] --> Socre: 0.5321384072303772

[[[[Adv]]]]: static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int [[error]], bool is_read) { BlockErrorAction [[action]] = bdrv_get_error_action(req->dev->bs, is_read, [[error]]); VirtIOBlock *s = req->dev; if ([[action]] == BLOCK_ERROR_ACTION_STOP) { req->next = s->rq; s->rq = req; } else if ([[action]] == BLOCK_ERROR_ACTION_REPORT) { virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR); block_acct_done(bdrv_get_stats(s->bs), &req->acct); virtio_blk_free_request(req); } bdrv_error_action(s->bs, [[action]], is_read, [[error]]); return [[action]] != BLOCK_ERROR_ACTION_IGNORE; }

[[[[Adv]]]]: static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int [[mistake]], bool is_read) { BlockErrorAction [[measurements]] = bdrv_get_error_action(req->dev->bs, is_read, [[mistake]]); VirtIOBlock *s = req->dev; if ([[measurements]] == BLOCK_ERROR_ACTION_STOP) { req->next = s->rq; s->rq = req; } else if ([[measurements]] == BLOCK_ERROR_ACTION_REPORT) { virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR); block_acct_done(bdrv_get_stats(s->bs), &req->acct); virtio_blk_free_request(req); } bdrv_error_action(s->bs, [[measurements]], is_read, [[mistake]]); return [[measurements]] != BLOCK_ERROR_ACTION_IGNORE; }
--------------------------------------------- Result 1207 ---------------------------------------------
[[0 (18%)]] --> [[0 (54%)]] --> Socre: 0.5411293506622314

[[[[Adv]]]]: static bool migrate_caps_check(bool *cap_list, MigrationCapabilityStatusList *params, Error **errp) { MigrationCapabilityStatusList *[[cap]]; bool [[old_postcopy_cap]]; [[old_postcopy_cap]] = cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]; for ([[cap]] = params; [[cap]]; [[cap]] = [[cap]]->next) { cap_list[[[cap]]->value->capability] = [[cap]]->value->state; } #ifndef CONFIG_LIVE_BLOCK_MIGRATION if (cap_list[MIGRATION_CAPABILITY_BLOCK]) { error_setg(errp, "QEMU compiled without old-style (blk/-b, inc/-i) " "block migration"); error_append_hint(errp, "Use drive_mirror+NBD instead.\n"); return "False" != "False"; } #endif if (cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]) { if (cap_list[MIGRATION_CAPABILITY_COMPRESS]) { error_setg(errp, "Postcopy is not currently compatible " "with compression"); return "False" != "False"; } if (![[old_postcopy_cap]] && runstate_check(RUN_STATE_INMIGRATE) && !postcopy_ram_supported_by_host()) { error_setg(errp, "Postcopy is not supported"); return "False" != "False"; } } return "True" == "True"; }

[[[[Adv]]]]: static bool migrate_caps_check(bool *cap_list, MigrationCapabilityStatusList *params, Error **errp) { MigrationCapabilityStatusList *[[stopper]]; bool [[slurs]]; [[slurs]] = cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]; for ([[stopper]] = params; [[stopper]]; [[stopper]] = [[stopper]]->next) { cap_list[[[stopper]]->value->capability] = [[stopper]]->value->state; } #ifndef CONFIG_LIVE_BLOCK_MIGRATION if (cap_list[MIGRATION_CAPABILITY_BLOCK]) { error_setg(errp, "QEMU compiled without old-style (blk/-b, inc/-i) " "block migration"); error_append_hint(errp, "Use drive_mirror+NBD instead.\n"); return "False" != "False"; } #endif if (cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]) { if (cap_list[MIGRATION_CAPABILITY_COMPRESS]) { error_setg(errp, "Postcopy is not currently compatible " "with compression"); return "False" != "False"; } if (![[slurs]] && runstate_check(RUN_STATE_INMIGRATE) && !postcopy_ram_supported_by_host()) { error_setg(errp, "Postcopy is not supported"); return "False" != "False"; } } return "True" == "True"; }
--------------------------------------------- Result 1208 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 709 / 64 / 435 / 1208:  45%|     | 1208/2690 [13:19:38<16:21:01, 39.72s/it][Succeeded / Failed / Skipped / Total] 709 / 64 / 435 / 1208:  45%|     | 1209/2690 [13:19:39<16:19:33, 39.68s/it][[0 (81%)]] --> [[0 (47%)]] --> Socre: 0.5266292989253998

[[[[Adv]]]]: static inline void FUNC(idctRowCondDC_extrashift)(int16_t *[[row]], int [[extra_shift]]) #else static inline void FUNC(idctRowCondDC)(int16_t *[[row]], int [[extra_shift]]) #endif { int [[a0]], a1, a2, a3, b0, b1, b2, b3; #if HAVE_FAST_64BIT #define ROW0_MASK (0xffffLL << 48 * HAVE_BIGENDIAN) if (((AV_RN64A([[row]]) & ~ROW0_MASK) | AV_RN64A([[row]]+4)) == 0) { uint64_t [[temp]]; if (DC_SHIFT - [[extra_shift]] >= 0) { [[temp]] = ([[row]][0] * (1 << (DC_SHIFT - [[extra_shift]]))) & 0xffff; } else { [[temp]] = (([[row]][0] + (1<<([[extra_shift]] - DC_SHIFT-1))) >> ([[extra_shift]] - DC_SHIFT)) & 0xffff; } [[temp]] += [[temp]] * (1 << 16); [[temp]] += [[temp]] * ((uint64_t) 1 << 32); AV_WN64A([[row]], [[temp]]); AV_WN64A([[row]] + 4, [[temp]]); return; } #else if (!(AV_RN32A([[row]]+2) | AV_RN32A([[row]]+4) | AV_RN32A([[row]]+6) | [[row]][1])) { uint32_t [[temp]]; if (DC_SHIFT - [[extra_shift]] >= 0) { [[temp]] = ([[row]][0] * (1 << (DC_SHIFT - [[extra_shift]]))) & 0xffff; } else { [[temp]] = (([[row]][0] + (1<<([[extra_shift]] - DC_SHIFT-1))) >> ([[extra_shift]] - DC_SHIFT)) & 0xffff; } [[temp]] += [[temp]] * (1 << 16); AV_WN32A([[row]], [[temp]]); AV_WN32A([[row]]+2, [[temp]]); AV_WN32A([[row]]+4, [[temp]]); AV_WN32A([[row]]+6, [[temp]]); return; } #endif [[a0]] = (W4 * [[row]][0]) + (1 << (ROW_SHIFT + [[extra_shift]] - 1)); a1 = [[a0]]; a2 = [[a0]]; a3 = [[a0]]; [[a0]] += W2 * [[row]][2]; a1 += W6 * [[row]][2]; a2 -= W6 * [[row]][2]; a3 -= W2 * [[row]][2]; b0 = MUL(W1, [[row]][1]); MAC(b0, W3, [[row]][3]); b1 = MUL(W3, [[row]][1]); MAC(b1, -W7, [[row]][3]); b2 = MUL(W5, [[row]][1]); MAC(b2, -W1, [[row]][3]); b3 = MUL(W7, [[row]][1]); MAC(b3, -W5, [[row]][3]); if (AV_RN64A([[row]] + 4)) { [[a0]] += W4*[[row]][4] + W6*[[row]][6]; a1 += - W4*[[row]][4] - W2*[[row]][6]; a2 += - W4*[[row]][4] + W2*[[row]][6]; a3 += W4*[[row]][4] - W6*[[row]][6]; MAC(b0, W5, [[row]][5]); MAC(b0, W7, [[row]][7]); MAC(b1, -W1, [[row]][5]); MAC(b1, -W5, [[row]][7]); MAC(b2, W7, [[row]][5]); MAC(b2, W3, [[row]][7]); MAC(b3, W3, [[row]][5]); MAC(b3, -W1, [[row]][7]); } [[row]][0] = ([[a0]] + b0) >> (ROW_SHIFT + [[extra_shift]]); [[row]][7] = ([[a0]] - b0) >> (ROW_SHIFT + [[extra_shift]]); [[row]][1] = (a1 + b1) >> (ROW_SHIFT + [[extra_shift]]); [[row]][6] = (a1 - b1) >> (ROW_SHIFT + [[extra_shift]]); [[row]][2] = (a2 + b2) >> (ROW_SHIFT + [[extra_shift]]); [[row]][5] = (a2 - b2) >> (ROW_SHIFT + [[extra_shift]]); [[row]][3] = (a3 + b3) >> (ROW_SHIFT + [[extra_shift]]); [[row]][4] = (a3 - b3) >> (ROW_SHIFT + [[extra_shift]]); }

[[[[Adv]]]]: static inline void FUNC(idctRowCondDC_extrashift)(int16_t *[[alleyway]], int [[wedgies]]) #else static inline void FUNC(idctRowCondDC)(int16_t *[[alleyway]], int [[wedgies]]) #endif { int [[maguire]], a1, a2, a3, b0, b1, b2, b3; #if HAVE_FAST_64BIT #define ROW0_MASK (0xffffLL << 48 * HAVE_BIGENDIAN) if (((AV_RN64A([[alleyway]]) & ~ROW0_MASK) | AV_RN64A([[alleyway]]+4)) == 0) { uint64_t [[fleeting]]; if (DC_SHIFT - [[wedgies]] >= 0) { [[fleeting]] = ([[alleyway]][0] * (1 << (DC_SHIFT - [[wedgies]]))) & 0xffff; } else { [[fleeting]] = (([[alleyway]][0] + (1<<([[wedgies]] - DC_SHIFT-1))) >> ([[wedgies]] - DC_SHIFT)) & 0xffff; } [[fleeting]] += [[fleeting]] * (1 << 16); [[fleeting]] += [[fleeting]] * ((uint64_t) 1 << 32); AV_WN64A([[alleyway]], [[fleeting]]); AV_WN64A([[alleyway]] + 4, [[fleeting]]); return; } #else if (!(AV_RN32A([[alleyway]]+2) | AV_RN32A([[alleyway]]+4) | AV_RN32A([[alleyway]]+6) | [[alleyway]][1])) { uint32_t [[fleeting]]; if (DC_SHIFT - [[wedgies]] >= 0) { [[fleeting]] = ([[alleyway]][0] * (1 << (DC_SHIFT - [[wedgies]]))) & 0xffff; } else { [[fleeting]] = (([[alleyway]][0] + (1<<([[wedgies]] - DC_SHIFT-1))) >> ([[wedgies]] - DC_SHIFT)) & 0xffff; } [[fleeting]] += [[fleeting]] * (1 << 16); AV_WN32A([[alleyway]], [[fleeting]]); AV_WN32A([[alleyway]]+2, [[fleeting]]); AV_WN32A([[alleyway]]+4, [[fleeting]]); AV_WN32A([[alleyway]]+6, [[fleeting]]); return; } #endif [[maguire]] = (W4 * [[alleyway]][0]) + (1 << (ROW_SHIFT + [[wedgies]] - 1)); a1 = [[maguire]]; a2 = [[maguire]]; a3 = [[maguire]]; [[maguire]] += W2 * [[alleyway]][2]; a1 += W6 * [[alleyway]][2]; a2 -= W6 * [[alleyway]][2]; a3 -= W2 * [[alleyway]][2]; b0 = MUL(W1, [[alleyway]][1]); MAC(b0, W3, [[alleyway]][3]); b1 = MUL(W3, [[alleyway]][1]); MAC(b1, -W7, [[alleyway]][3]); b2 = MUL(W5, [[alleyway]][1]); MAC(b2, -W1, [[alleyway]][3]); b3 = MUL(W7, [[alleyway]][1]); MAC(b3, -W5, [[alleyway]][3]); if (AV_RN64A([[alleyway]] + 4)) { [[maguire]] += W4*[[alleyway]][4] + W6*[[alleyway]][6]; a1 += - W4*[[alleyway]][4] - W2*[[alleyway]][6]; a2 += - W4*[[alleyway]][4] + W2*[[alleyway]][6]; a3 += W4*[[alleyway]][4] - W6*[[alleyway]][6]; MAC(b0, W5, [[alleyway]][5]); MAC(b0, W7, [[alleyway]][7]); MAC(b1, -W1, [[alleyway]][5]); MAC(b1, -W5, [[alleyway]][7]); MAC(b2, W7, [[alleyway]][5]); MAC(b2, W3, [[alleyway]][7]); MAC(b3, W3, [[alleyway]][5]); MAC(b3, -W1, [[alleyway]][7]); } [[alleyway]][0] = ([[maguire]] + b0) >> (ROW_SHIFT + [[wedgies]]); [[alleyway]][7] = ([[maguire]] - b0) >> (ROW_SHIFT + [[wedgies]]); [[alleyway]][1] = (a1 + b1) >> (ROW_SHIFT + [[wedgies]]); [[alleyway]][6] = (a1 - b1) >> (ROW_SHIFT + [[wedgies]]); [[alleyway]][2] = (a2 + b2) >> (ROW_SHIFT + [[wedgies]]); [[alleyway]][5] = (a2 - b2) >> (ROW_SHIFT + [[wedgies]]); [[alleyway]][3] = (a3 + b3) >> (ROW_SHIFT + [[wedgies]]); [[alleyway]][4] = (a3 - b3) >> (ROW_SHIFT + [[wedgies]]); }
--------------------------------------------- Result 1209 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 709 / 64 / 436 / 1209:  45%|     | 1209/2690 [13:19:39<16:19:33, 39.68s/it][Succeeded / Failed / Skipped / Total] 709 / 64 / 436 / 1209:  45%|     | 1210/2690 [13:19:41<16:18:08, 39.65s/it][Succeeded / Failed / Skipped / Total] 710 / 64 / 436 / 1210:  45%|     | 1210/2690 [13:19:41<16:18:08, 39.65s/it][Succeeded / Failed / Skipped / Total] 710 / 64 / 436 / 1210:  45%|     | 1211/2690 [13:19:58<16:17:01, 39.64s/it][[0 (73%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void calxeda_init(MachineState *machine, enum cxmachines machine_id) { ram_addr_t ram_size = machine->ram_size; const char *cpu_model = machine->cpu_model; const char *kernel_filename = machine->kernel_filename; const char *kernel_cmdline = machine->kernel_cmdline; const char *initrd_filename = machine->initrd_filename; DeviceState *dev = NULL; SysBusDevice *busdev; qemu_irq pic[128]; int n; qemu_irq cpu_irq[4]; qemu_irq cpu_fiq[4]; MemoryRegion *sysram; MemoryRegion *dram; MemoryRegion *sysmem; char *sysboot_filename; if (!cpu_model) { switch (machine_id) { case CALXEDA_HIGHBANK: cpu_model = "cortex-a9"; break; case CALXEDA_MIDWAY: cpu_model = "cortex-a15"; break; } } for (n = 0; n < smp_cpus; n++) { ObjectClass *oc = cpu_class_by_name(TYPE_ARM_CPU, cpu_model); Object *cpuobj; ARMCPU *cpu; Error *err = NULL; if (!oc) { error_report("Unable to find CPU definition"); exit(1); } cpuobj = object_new(object_class_get_name(oc)); cpu = ARM_CPU(cpuobj); if (object_property_find(cpuobj, "has_el3", NULL)) { object_property_set_bool(cpuobj, "False" != "False", "has_el3", &err); if (err) { error_report_err(err); exit(1); } } if (object_property_find(cpuobj, "reset-cbar", NULL)) { object_property_set_int(cpuobj, MPCORE_PERIPHBASE, "reset-cbar", &error_abort); } object_property_set_bool(cpuobj, "True" == "True", "realized", &err); if (err) { error_report_err(err); exit(1); } cpu_irq[n] = qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ); cpu_fiq[n] = qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ); } sysmem = get_system_memory(); dram = g_new(MemoryRegion, 1); memory_region_allocate_system_memory(dram, NULL, "highbank.dram", ram_size); memory_region_add_subregion(sysmem, 0, dram); sysram = g_new(MemoryRegion, 1); memory_region_init_ram(sysram, NULL, "highbank.sysram", 0x8000, &error_fatal); memory_region_add_subregion(sysmem, 0xfff88000, sysram); if (bios_name != NULL) { sysboot_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (sysboot_filename != NULL) { if (load_image_targphys(sysboot_filename, 0xfff88000, 0x8000) < 0) { hw_error("Unable to load %s\n", bios_name); } g_free(sysboot_filename); } else { hw_error("Unable to find %s\n", bios_name); } } switch (machine_id) { case CALXEDA_HIGHBANK: dev = qdev_create(NULL, "l2x0"); qdev_init_nofail(dev); busdev = SYS_BUS_DEVICE(dev); sysbus_mmio_map(busdev, 0, 0xfff12000); dev = qdev_create(NULL, "a9mpcore_priv"); break; case CALXEDA_MIDWAY: dev = qdev_create(NULL, "a15mpcore_priv"); break; } qdev_prop_set_uint32(dev, "num-cpu", smp_cpus); qdev_prop_set_uint32(dev, "num-irq", NIRQ_GIC); qdev_init_nofail(dev); busdev = SYS_BUS_DEVICE(dev); sysbus_mmio_map(busdev, 0, MPCORE_PERIPHBASE); for (n = 0; n < smp_cpus; n++) { sysbus_connect_irq(busdev, n, cpu_irq[n]); sysbus_connect_irq(busdev, n + smp_cpus, cpu_fiq[n]); } for (n = 0; n < 128; n++) { pic[n] = qdev_get_gpio_in(dev, n); } dev = qdev_create(NULL, "sp804"); qdev_prop_set_uint32(dev, "freq0", 150000000); qdev_prop_set_uint32(dev, "freq1", 150000000); qdev_init_nofail(dev); busdev = SYS_BUS_DEVICE(dev); sysbus_mmio_map(busdev, 0, 0xfff34000); sysbus_connect_irq(busdev, 0, pic[18]); sysbus_create_simple("pl011", 0xfff36000, pic[20]); dev = qdev_create(NULL, "highbank-regs"); qdev_init_nofail(dev); busdev = SYS_BUS_DEVICE(dev); sysbus_mmio_map(busdev, 0, 0xfff3c000); sysbus_create_simple("pl061", 0xfff30000, pic[14]); sysbus_create_simple("pl061", 0xfff31000, pic[15]); sysbus_create_simple("pl061", 0xfff32000, pic[16]); sysbus_create_simple("pl061", 0xfff33000, pic[17]); sysbus_create_simple("pl031", 0xfff35000, pic[19]); sysbus_create_simple("pl022", 0xfff39000, pic[23]); sysbus_create_simple("sysbus-ahci", 0xffe08000, pic[83]); if (nd_table[0].used) { qemu_check_nic_model(&nd_table[0], "xgmac"); dev = qdev_create(NULL, "xgmac"); qdev_set_nic_properties(dev, &nd_table[0]); qdev_init_nofail(dev); sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff50000); sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[77]); sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[78]); sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[79]); qemu_check_nic_model(&nd_table[1], "xgmac"); dev = qdev_create(NULL, "xgmac"); qdev_set_nic_properties(dev, &nd_table[1]); qdev_init_nofail(dev); sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff51000); sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[80]); sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[81]); sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[82]); } highbank_binfo.ram_size = ram_size; highbank_binfo.kernel_filename = kernel_filename; highbank_binfo.kernel_cmdline = kernel_cmdline; highbank_binfo.initrd_filename = initrd_filename; highbank_binfo.board_id = -1; highbank_binfo.nb_cpus = smp_cpus; highbank_binfo.loader_start = 0; highbank_binfo.write_secondary_boot = hb_write_secondary; highbank_binfo.secondary_cpu_reset_hook = hb_reset_secondary; arm_load_kernel(ARM_CPU(first_cpu), &highbank_binfo); }
--------------------------------------------- Result 1210 ---------------------------------------------
[[0 (55%)]] --> [[0 (32%)]] --> Socre: 0.6781492829322815

[[[[Adv]]]]: struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta, BlockDriverState *[[bd]], qemu_irq irq, qemu_irq dma[], omap_clk fclk, omap_clk iclk) { struct omap_mmc_s *s = (struct omap_mmc_s *) g_malloc0(sizeof(struct omap_mmc_s)); s->irq = irq; s->dma = dma; s->clk = fclk; s->lines = 4; s->rev = 2; omap_mmc_reset(s); memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, "omap.mmc", omap_l4_region_size(ta, 0)); omap_l4_attach(ta, 0, &s->iomem); s->card = sd_init([[bd]], "False" != "False"); if (s->card == NULL) { exit(1); } s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0]; sd_set_cb(s->card, NULL, s->cdet); return s; }

[[[[Adv]]]]: struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta, BlockDriverState *[[jailbirds]], qemu_irq irq, qemu_irq dma[], omap_clk fclk, omap_clk iclk) { struct omap_mmc_s *s = (struct omap_mmc_s *) g_malloc0(sizeof(struct omap_mmc_s)); s->irq = irq; s->dma = dma; s->clk = fclk; s->lines = 4; s->rev = 2; omap_mmc_reset(s); memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, "omap.mmc", omap_l4_region_size(ta, 0)); omap_l4_attach(ta, 0, &s->iomem); s->card = sd_init([[jailbirds]], "False" != "False"); if (s->card == NULL) { exit(1); } s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0]; sd_set_cb(s->card, NULL, s->cdet); return s; }
--------------------------------------------- Result 1211 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 711 / 64 / 436 / 1211:  45%|     | 1211/2690 [13:19:58<16:17:01, 39.64s/it][Succeeded / Failed / Skipped / Total] 711 / 64 / 436 / 1211:  45%|     | 1212/2690 [13:20:02<16:15:37, 39.61s/it][Succeeded / Failed / Skipped / Total] 712 / 64 / 436 / 1212:  45%|     | 1212/2690 [13:20:02<16:15:37, 39.61s/it][Succeeded / Failed / Skipped / Total] 712 / 64 / 436 / 1212:  45%|     | 1213/2690 [13:20:27<16:14:40, 39.59s/it][Succeeded / Failed / Skipped / Total] 712 / 65 / 436 / 1213:  45%|     | 1213/2690 [13:20:27<16:14:40, 39.59s/it][Succeeded / Failed / Skipped / Total] 712 / 65 / 436 / 1213:  45%|     | 1214/2690 [13:21:50<16:14:53, 39.63s/it][Succeeded / Failed / Skipped / Total] 713 / 65 / 436 / 1214:  45%|     | 1214/2690 [13:21:50<16:14:53, 39.63s/it][Succeeded / Failed / Skipped / Total] 713 / 65 / 436 / 1214:  45%|     | 1215/2690 [13:21:51<16:13:26, 39.60s/it][Succeeded / Failed / Skipped / Total] 713 / 65 / 437 / 1215:  45%|     | 1215/2690 [13:21:51<16:13:26, 39.60s/it][Succeeded / Failed / Skipped / Total] 713 / 65 / 437 / 1215:  45%|     | 1216/2690 [13:22:29<16:12:45, 39.60s/it][[0 (3%)]] --> [[0 (67%)]] --> Socre: 0.6685500741004944

[[[[Adv]]]]: static int get_phys_addr_v5(CPUState *env, uint32_t address, int [[access_type]], int is_user, uint32_t *phys_ptr, int *prot) { int code; uint32_t [[table]]; uint32_t [[desc]]; int [[type]]; int ap; int domain; uint32_t phys_addr; [[table]] = get_level1_table_address(env, address); [[desc]] = ldl_phys([[table]]); [[type]] = ([[desc]] & 3); domain = (env->cp15.c3 >> (([[desc]] >> 4) & 0x1e)) & 3; if ([[type]] == 0) { code = 5; goto do_fault; } if (domain == 0 || domain == 2) { if ([[type]] == 2) code = 9; else code = 11; goto do_fault; } if ([[type]] == 2) { phys_addr = ([[desc]] & 0xfff00000) | (address & 0x000fffff); ap = ([[desc]] >> 10) & 3; code = 13; } else { if ([[type]] == 1) { [[table]] = ([[desc]] & 0xfffffc00) | ((address >> 10) & 0x3fc); } else { [[table]] = ([[desc]] & 0xfffff000) | ((address >> 8) & 0xffc); } [[desc]] = ldl_phys([[table]]); switch ([[desc]] & 3) { case 0: code = 7; goto do_fault; case 1: phys_addr = ([[desc]] & 0xffff0000) | (address & 0xffff); ap = ([[desc]] >> (4 + ((address >> 13) & 6))) & 3; break; case 2: phys_addr = ([[desc]] & 0xfffff000) | (address & 0xfff); ap = ([[desc]] >> (4 + ((address >> 13) & 6))) & 3; break; case 3: if ([[type]] == 1) { if (arm_feature(env, ARM_FEATURE_XSCALE)) { phys_addr = ([[desc]] & 0xfffff000) | (address & 0xfff); } else { code = 7; goto do_fault; } } else { phys_addr = ([[desc]] & 0xfffffc00) | (address & 0x3ff); } ap = ([[desc]] >> 4) & 3; break; default: abort(); } code = 15; } *prot = check_ap(env, ap, domain, [[access_type]], is_user); if (!*prot) { goto do_fault; } *phys_ptr = phys_addr; return 0; do_fault: return code | (domain << 4); }

[[[[Adv]]]]: static int get_phys_addr_v5(CPUState *env, uint32_t address, int [[bix]], int is_user, uint32_t *phys_ptr, int *prot) { int code; uint32_t [[sut]]; uint32_t [[phonecall]]; int [[tipo]]; int ap; int domain; uint32_t phys_addr; [[sut]] = get_level1_table_address(env, address); [[phonecall]] = ldl_phys([[sut]]); [[tipo]] = ([[phonecall]] & 3); domain = (env->cp15.c3 >> (([[phonecall]] >> 4) & 0x1e)) & 3; if ([[tipo]] == 0) { code = 5; goto do_fault; } if (domain == 0 || domain == 2) { if ([[tipo]] == 2) code = 9; else code = 11; goto do_fault; } if ([[tipo]] == 2) { phys_addr = ([[phonecall]] & 0xfff00000) | (address & 0x000fffff); ap = ([[phonecall]] >> 10) & 3; code = 13; } else { if ([[tipo]] == 1) { [[sut]] = ([[phonecall]] & 0xfffffc00) | ((address >> 10) & 0x3fc); } else { [[sut]] = ([[phonecall]] & 0xfffff000) | ((address >> 8) & 0xffc); } [[phonecall]] = ldl_phys([[sut]]); switch ([[phonecall]] & 3) { case 0: code = 7; goto do_fault; case 1: phys_addr = ([[phonecall]] & 0xffff0000) | (address & 0xffff); ap = ([[phonecall]] >> (4 + ((address >> 13) & 6))) & 3; break; case 2: phys_addr = ([[phonecall]] & 0xfffff000) | (address & 0xfff); ap = ([[phonecall]] >> (4 + ((address >> 13) & 6))) & 3; break; case 3: if ([[tipo]] == 1) { if (arm_feature(env, ARM_FEATURE_XSCALE)) { phys_addr = ([[phonecall]] & 0xfffff000) | (address & 0xfff); } else { code = 7; goto do_fault; } } else { phys_addr = ([[phonecall]] & 0xfffffc00) | (address & 0x3ff); } ap = ([[phonecall]] >> 4) & 3; break; default: abort(); } code = 15; } *prot = check_ap(env, ap, domain, [[bix]], is_user); if (!*prot) { goto do_fault; } *phys_ptr = phys_addr; return 0; do_fault: return code | (domain << 4); }
--------------------------------------------- Result 1212 ---------------------------------------------
[[0 (23%)]] --> [[0 (91%)]] --> Socre: 0.9074420928955078

[[[[Adv]]]]: int ff_nvdec_decode_init(AVCodecContext *[[avctx]], unsigned int dpb_size) { NVDECContext *ctx = [[avctx]]->internal->hwaccel_priv_data; NVDECFramePool *pool; AVHWFramesContext *frames_ctx; const AVPixFmtDescriptor *sw_desc; CUVIDDECODECREATEINFO params = { 0 }; int cuvid_codec_type, cuvid_chroma_format; int ret = 0; sw_desc = av_pix_fmt_desc_get([[avctx]]->sw_pix_fmt); if (!sw_desc) return AVERROR_BUG; cuvid_codec_type = map_avcodec_id([[avctx]]->codec_id); if (cuvid_codec_type < 0) { av_log([[avctx]], AV_LOG_ERROR, "Unsupported codec ID\n"); return AVERROR_BUG; } cuvid_chroma_format = map_chroma_format([[avctx]]->sw_pix_fmt); if (cuvid_chroma_format < 0) { av_log([[avctx]], AV_LOG_ERROR, "Unsupported chroma format\n"); return AVERROR(ENOSYS); } if ([[avctx]]->thread_type & FF_THREAD_FRAME) dpb_size += [[avctx]]->thread_count; if (![[avctx]]->hw_frames_ctx) { AVHWFramesContext *frames_ctx; if (![[avctx]]->hw_device_ctx) { av_log([[avctx]], AV_LOG_ERROR, "A hardware device or frames context " "is required for CUVID decoding.\n"); return AVERROR(EINVAL); } [[avctx]]->hw_frames_ctx = av_hwframe_ctx_alloc([[avctx]]->hw_device_ctx); if (![[avctx]]->hw_frames_ctx) return AVERROR(ENOMEM); frames_ctx = (AVHWFramesContext*)[[avctx]]->hw_frames_ctx->data; frames_ctx->format = AV_PIX_FMT_CUDA; frames_ctx->width = [[avctx]]->coded_width; frames_ctx->height = [[avctx]]->coded_height; frames_ctx->sw_format = AV_PIX_FMT_NV12; frames_ctx->sw_format = sw_desc->comp[0].depth > 8 ? AV_PIX_FMT_P010 : AV_PIX_FMT_NV12; frames_ctx->initial_pool_size = dpb_size; ret = av_hwframe_ctx_init([[avctx]]->hw_frames_ctx); if (ret < 0) { av_log([[avctx]], AV_LOG_ERROR, "Error initializing internal frames context\n"); return ret; } } frames_ctx = (AVHWFramesContext*)[[avctx]]->hw_frames_ctx->data; params.ulWidth = [[avctx]]->coded_width; params.ulHeight = [[avctx]]->coded_height; params.ulTargetWidth = [[avctx]]->coded_width; params.ulTargetHeight = [[avctx]]->coded_height; params.bitDepthMinus8 = sw_desc->comp[0].depth - 8; params.OutputFormat = params.bitDepthMinus8 ? cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12; params.CodecType = cuvid_codec_type; params.ChromaFormat = cuvid_chroma_format; params.ulNumDecodeSurfaces = dpb_size; params.ulNumOutputSurfaces = 1; ret = nvdec_decoder_create(&ctx->decoder_ref, frames_ctx->device_ref, &params, [[avctx]]); if (ret < 0) return ret; pool = av_mallocz(sizeof(*pool)); if (!pool) { ret = AVERROR(ENOMEM); goto fail; } pool->dpb_size = dpb_size; ctx->decoder_pool = av_buffer_pool_init2(sizeof(int), pool, nvdec_decoder_frame_alloc, av_free); if (!ctx->decoder_pool) { ret = AVERROR(ENOMEM); goto fail; } return 0; fail: ff_nvdec_decode_uninit([[avctx]]); return ret; }

[[[[Adv]]]]: int ff_nvdec_decode_init(AVCodecContext *[[unrest]], unsigned int dpb_size) { NVDECContext *ctx = [[unrest]]->internal->hwaccel_priv_data; NVDECFramePool *pool; AVHWFramesContext *frames_ctx; const AVPixFmtDescriptor *sw_desc; CUVIDDECODECREATEINFO params = { 0 }; int cuvid_codec_type, cuvid_chroma_format; int ret = 0; sw_desc = av_pix_fmt_desc_get([[unrest]]->sw_pix_fmt); if (!sw_desc) return AVERROR_BUG; cuvid_codec_type = map_avcodec_id([[unrest]]->codec_id); if (cuvid_codec_type < 0) { av_log([[unrest]], AV_LOG_ERROR, "Unsupported codec ID\n"); return AVERROR_BUG; } cuvid_chroma_format = map_chroma_format([[unrest]]->sw_pix_fmt); if (cuvid_chroma_format < 0) { av_log([[unrest]], AV_LOG_ERROR, "Unsupported chroma format\n"); return AVERROR(ENOSYS); } if ([[unrest]]->thread_type & FF_THREAD_FRAME) dpb_size += [[unrest]]->thread_count; if (![[unrest]]->hw_frames_ctx) { AVHWFramesContext *frames_ctx; if (![[unrest]]->hw_device_ctx) { av_log([[unrest]], AV_LOG_ERROR, "A hardware device or frames context " "is required for CUVID decoding.\n"); return AVERROR(EINVAL); } [[unrest]]->hw_frames_ctx = av_hwframe_ctx_alloc([[unrest]]->hw_device_ctx); if (![[unrest]]->hw_frames_ctx) return AVERROR(ENOMEM); frames_ctx = (AVHWFramesContext*)[[unrest]]->hw_frames_ctx->data; frames_ctx->format = AV_PIX_FMT_CUDA; frames_ctx->width = [[unrest]]->coded_width; frames_ctx->height = [[unrest]]->coded_height; frames_ctx->sw_format = AV_PIX_FMT_NV12; frames_ctx->sw_format = sw_desc->comp[0].depth > 8 ? AV_PIX_FMT_P010 : AV_PIX_FMT_NV12; frames_ctx->initial_pool_size = dpb_size; ret = av_hwframe_ctx_init([[unrest]]->hw_frames_ctx); if (ret < 0) { av_log([[unrest]], AV_LOG_ERROR, "Error initializing internal frames context\n"); return ret; } } frames_ctx = (AVHWFramesContext*)[[unrest]]->hw_frames_ctx->data; params.ulWidth = [[unrest]]->coded_width; params.ulHeight = [[unrest]]->coded_height; params.ulTargetWidth = [[unrest]]->coded_width; params.ulTargetHeight = [[unrest]]->coded_height; params.bitDepthMinus8 = sw_desc->comp[0].depth - 8; params.OutputFormat = params.bitDepthMinus8 ? cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12; params.CodecType = cuvid_codec_type; params.ChromaFormat = cuvid_chroma_format; params.ulNumDecodeSurfaces = dpb_size; params.ulNumOutputSurfaces = 1; ret = nvdec_decoder_create(&ctx->decoder_ref, frames_ctx->device_ref, &params, [[unrest]]); if (ret < 0) return ret; pool = av_mallocz(sizeof(*pool)); if (!pool) { ret = AVERROR(ENOMEM); goto fail; } pool->dpb_size = dpb_size; ctx->decoder_pool = av_buffer_pool_init2(sizeof(int), pool, nvdec_decoder_frame_alloc, av_free); if (!ctx->decoder_pool) { ret = AVERROR(ENOMEM); goto fail; } return 0; fail: ff_nvdec_decode_uninit([[unrest]]); return ret; }
--------------------------------------------- Result 1213 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts) { int ret; FailingMuxerPacketData *data = av_malloc(sizeof(*data)); memcpy(data, pkt_data, sizeof(FailingMuxerPacketData)); ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data)); pkt->pts = pkt->dts = pts; pkt->duration = 1; return ret;

[[[[Adv]]]]: static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts) { int ret; FailingMuxerPacketData *data = av_malloc(sizeof(*data)); memcpy(data, pkt_data, sizeof(FailingMuxerPacketData)); ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data)); pkt->pts = pkt->dts = pts; pkt->duration = 1; return ret;
--------------------------------------------- Result 1214 ---------------------------------------------
[[0 (70%)]] --> [[0 (46%)]] --> Socre: 0.5448065102100372

[[[[Adv]]]]: int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16], uint8_t probs[16][3][NUM_DCT_TOKENS - 1], int i, int [[zero_nhood]], int16_t qmul[2]) { uint8_t *token_prob = probs[i][[[zero_nhood]]]; if (!vp56_rac_get_prob_branchy(c, token_prob[0])) return 0; return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul); }

[[[[Adv]]]]: int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16], uint8_t probs[16][3][NUM_DCT_TOKENS - 1], int i, int [[impassioned]], int16_t qmul[2]) { uint8_t *token_prob = probs[i][[[impassioned]]]; if (!vp56_rac_get_prob_branchy(c, token_prob[0])) return 0; return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul); }
--------------------------------------------- Result 1215 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop) { cirrus_fill_t rop_func; if (blit_is_unsafe(s)) { return 0; } rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1]; rop_func(s, s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask), s->cirrus_blt_dstpitch, s->cirrus_blt_width, s->cirrus_blt_height); cirrus_invalidate_region(s, s->cirrus_blt_dstaddr, s->cirrus_blt_dstpitch, s->cirrus_blt_width, s->cirrus_blt_height); cirrus_bitblt_reset(s); return 1; }
--------------------------------------------- Result 1216 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 714 / 65 / 437 / 1216:  45%|     | 1216/2690 [13:22:29<16:12:45, 39.60s/it][Succeeded / Failed / Skipped / Total] 714 / 65 / 437 / 1216:  45%|     | 1217/2690 [13:22:47<16:11:39, 39.58s/it][Succeeded / Failed / Skipped / Total] 715 / 65 / 437 / 1217:  45%|     | 1217/2690 [13:22:47<16:11:39, 39.58s/it][Succeeded / Failed / Skipped / Total] 715 / 65 / 437 / 1217:  45%|     | 1218/2690 [13:24:24<16:12:09, 39.63s/it][Succeeded / Failed / Skipped / Total] 716 / 65 / 437 / 1218:  45%|     | 1218/2690 [13:24:24<16:12:09, 39.63s/it][Succeeded / Failed / Skipped / Total] 716 / 65 / 437 / 1218:  45%|     | 1219/2690 [13:25:34<16:12:06, 39.65s/it][[0 (77%)]] --> [[0 (50%)]] --> Socre: 0.5008931159973145

[[[[Adv]]]]: void hmp_info_snapshots(Monitor *[[mon]], const QDict *[[qdict]]) { BlockDriverState *bs, *bs1; QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s; int nb_sns, i, ret, available; int total; int *available_snapshots; bs = find_vmstate_bs(); if (!bs) { monitor_printf([[mon]], "No available block device supports snapshots\n"); return; } nb_sns = bdrv_snapshot_list(bs, &sn_tab); if (nb_sns < 0) { monitor_printf([[mon]], "bdrv_snapshot_list: error %d\n", nb_sns); return; } if (nb_sns == 0) { monitor_printf([[mon]], "There is no snapshot available.\n"); return; } available_snapshots = g_malloc0(sizeof(int) * nb_sns); total = 0; for (i = 0; i < nb_sns; i++) { sn = &sn_tab[i]; available = 1; bs1 = NULL; while ((bs1 = bdrv_next(bs1))) { if (bdrv_can_snapshot(bs1) && bs1 != bs) { ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str); if (ret < 0) { available = 0; break; } } } if (available) { available_snapshots[total] = i; total++; } } if (total > 0) { bdrv_snapshot_dump((fprintf_function)monitor_printf, [[mon]], NULL); monitor_printf([[mon]], "\n"); for (i = 0; i < total; i++) { sn = &sn_tab[available_snapshots[i]]; bdrv_snapshot_dump((fprintf_function)monitor_printf, [[mon]], sn); monitor_printf([[mon]], "\n"); } } else { monitor_printf([[mon]], "There is no suitable snapshot available\n"); } g_free(sn_tab); g_free(available_snapshots); }

[[[[Adv]]]]: void hmp_info_snapshots(Monitor *[[thursdays]], const QDict *[[lindstrom]]) { BlockDriverState *bs, *bs1; QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s; int nb_sns, i, ret, available; int total; int *available_snapshots; bs = find_vmstate_bs(); if (!bs) { monitor_printf([[thursdays]], "No available block device supports snapshots\n"); return; } nb_sns = bdrv_snapshot_list(bs, &sn_tab); if (nb_sns < 0) { monitor_printf([[thursdays]], "bdrv_snapshot_list: error %d\n", nb_sns); return; } if (nb_sns == 0) { monitor_printf([[thursdays]], "There is no snapshot available.\n"); return; } available_snapshots = g_malloc0(sizeof(int) * nb_sns); total = 0; for (i = 0; i < nb_sns; i++) { sn = &sn_tab[i]; available = 1; bs1 = NULL; while ((bs1 = bdrv_next(bs1))) { if (bdrv_can_snapshot(bs1) && bs1 != bs) { ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str); if (ret < 0) { available = 0; break; } } } if (available) { available_snapshots[total] = i; total++; } } if (total > 0) { bdrv_snapshot_dump((fprintf_function)monitor_printf, [[thursdays]], NULL); monitor_printf([[thursdays]], "\n"); for (i = 0; i < total; i++) { sn = &sn_tab[available_snapshots[i]]; bdrv_snapshot_dump((fprintf_function)monitor_printf, [[thursdays]], sn); monitor_printf([[thursdays]], "\n"); } } else { monitor_printf([[thursdays]], "There is no suitable snapshot available\n"); } g_free(sn_tab); g_free(available_snapshots); }
--------------------------------------------- Result 1217 ---------------------------------------------
[[0 (27%)]] --> [[0 (51%)]] --> Socre: 0.5099412202835083

[[[[Adv]]]]: static int encode_hq_slice(AVCodecContext *[[avctx]], void *arg) { SliceArgs *[[slice_dat]] = arg; VC2EncContext *s = [[slice_dat]]->ctx; PutBitContext *[[pb]] = &[[slice_dat]]->pb; const int slice_x = [[slice_dat]]->x; const int [[slice_y]] = [[slice_dat]]->y; const int quant_idx = [[slice_dat]]->quant_idx; const int slice_bytes_max = [[slice_dat]]->bytes; uint8_t [[quants]][MAX_DWT_LEVELS][4]; int p, level, orientation; avpriv_align_put_bits([[pb]]); skip_put_bytes([[pb]], s->prefix_bytes); put_bits([[pb]], 8, quant_idx); for (level = 0; level < s->wavelet_depth; level++) for (orientation = !!level; orientation < 4; orientation++) [[quants]][level][orientation] = FFMAX(quant_idx - s->quant[level][orientation], 0); for (p = 0; p < 3; p++) { int bytes_start, bytes_len, pad_s, pad_c; bytes_start = put_bits_count([[pb]]) >> 3; put_bits([[pb]], 8, 0); for (level = 0; level < s->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { encode_subband(s, [[pb]], slice_x, [[slice_y]], &s->plane[p].band[level][orientation], [[quants]][level][orientation]); } } avpriv_align_put_bits([[pb]]); bytes_len = (put_bits_count([[pb]]) >> 3) - bytes_start - 1; if (p == 2) { int len_diff = slice_bytes_max - (put_bits_count([[pb]]) >> 3); pad_s = FFALIGN((bytes_len + len_diff), s->size_scaler)/s->size_scaler; pad_c = (pad_s*s->size_scaler) - bytes_len; } else { pad_s = FFALIGN(bytes_len, s->size_scaler)/s->size_scaler; pad_c = (pad_s*s->size_scaler) - bytes_len; } [[pb]]->buf[bytes_start] = pad_s; flush_put_bits([[pb]]); skip_put_bytes([[pb]], pad_c); } return 0; }

[[[[Adv]]]]: static int encode_hq_slice(AVCodecContext *[[pfister]], void *arg) { SliceArgs *[[palates]] = arg; VC2EncContext *s = [[palates]]->ctx; PutBitContext *[[cp]] = &[[palates]]->pb; const int slice_x = [[palates]]->x; const int [[retros]] = [[palates]]->y; const int quant_idx = [[palates]]->quant_idx; const int slice_bytes_max = [[palates]]->bytes; uint8_t [[alteration]][MAX_DWT_LEVELS][4]; int p, level, orientation; avpriv_align_put_bits([[cp]]); skip_put_bytes([[cp]], s->prefix_bytes); put_bits([[cp]], 8, quant_idx); for (level = 0; level < s->wavelet_depth; level++) for (orientation = !!level; orientation < 4; orientation++) [[alteration]][level][orientation] = FFMAX(quant_idx - s->quant[level][orientation], 0); for (p = 0; p < 3; p++) { int bytes_start, bytes_len, pad_s, pad_c; bytes_start = put_bits_count([[cp]]) >> 3; put_bits([[cp]], 8, 0); for (level = 0; level < s->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { encode_subband(s, [[cp]], slice_x, [[retros]], &s->plane[p].band[level][orientation], [[alteration]][level][orientation]); } } avpriv_align_put_bits([[cp]]); bytes_len = (put_bits_count([[cp]]) >> 3) - bytes_start - 1; if (p == 2) { int len_diff = slice_bytes_max - (put_bits_count([[cp]]) >> 3); pad_s = FFALIGN((bytes_len + len_diff), s->size_scaler)/s->size_scaler; pad_c = (pad_s*s->size_scaler) - bytes_len; } else { pad_s = FFALIGN(bytes_len, s->size_scaler)/s->size_scaler; pad_c = (pad_s*s->size_scaler) - bytes_len; } [[cp]]->buf[bytes_start] = pad_s; flush_put_bits([[cp]]); skip_put_bytes([[cp]], pad_c); } return 0; }
--------------------------------------------- Result 1218 ---------------------------------------------
[[0 (22%)]] --> [[0 (53%)]] --> Socre: 0.5331092476844788

[[[[Adv]]]]: static void do_info_commands(Monitor *mon, QObject **[[ret_data]]) { QList *[[cmd_list]]; const mon_cmd_t *cmd; [[cmd_list]] = qlist_new(); for (cmd = qmp_cmds; cmd->name != NULL; cmd++) { if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) && !compare_cmd(cmd->name, "info")) { qlist_append_obj([[cmd_list]], get_cmd_dict(cmd->name)); } } for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) { if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) { char buf[128]; snprintf(buf, sizeof(buf), "query-%s", cmd->name); qlist_append_obj([[cmd_list]], get_cmd_dict(buf)); } } *[[ret_data]] = QOBJECT([[cmd_list]]); }

[[[[Adv]]]]: static void do_info_commands(Monitor *mon, QObject **[[jerrold]]) { QList *[[overturned]]; const mon_cmd_t *cmd; [[overturned]] = qlist_new(); for (cmd = qmp_cmds; cmd->name != NULL; cmd++) { if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) && !compare_cmd(cmd->name, "info")) { qlist_append_obj([[overturned]], get_cmd_dict(cmd->name)); } } for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) { if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) { char buf[128]; snprintf(buf, sizeof(buf), "query-%s", cmd->name); qlist_append_obj([[overturned]], get_cmd_dict(buf)); } } *[[jerrold]] = QOBJECT([[overturned]]); }
--------------------------------------------- Result 1219 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 717 / 65 / 437 / 1219:  45%|     | 1219/2690 [13:25:34<16:12:06, 39.65s/it][Succeeded / Failed / Skipped / Total] 717 / 65 / 437 / 1219:  45%|     | 1220/2690 [13:34:33<16:21:28, 40.06s/it][Succeeded / Failed / Skipped / Total] 717 / 66 / 437 / 1220:  45%|     | 1220/2690 [13:34:33<16:21:28, 40.06s/it][Succeeded / Failed / Skipped / Total] 717 / 66 / 437 / 1220:  45%|     | 1221/2690 [13:34:42<16:20:11, 40.03s/it][Succeeded / Failed / Skipped / Total] 718 / 66 / 437 / 1221:  45%|     | 1221/2690 [13:34:42<16:20:11, 40.03s/it][Succeeded / Failed / Skipped / Total] 718 / 66 / 437 / 1221:  45%|     | 1222/2690 [13:35:17<16:19:24, 40.03s/it][Succeeded / Failed / Skipped / Total] 718 / 67 / 437 / 1222:  45%|     | 1222/2690 [13:35:17<16:19:24, 40.03s/it][Succeeded / Failed / Skipped / Total] 718 / 67 / 437 / 1222:  45%|     | 1223/2690 [13:36:54<16:19:52, 40.08s/it][[0 (45%)]] --> [[0 (57%)]] --> Socre: 0.5650191903114319

[[[[Adv]]]]: static void spapr_msi_write(void *opaque, hwaddr [[addr]], uint64_t data, unsigned size) { sPAPRPHBState *phb = opaque; int ndev = [[addr]] >> 16; int vec = (([[addr]] & 0xFFFF) >> 2) | data; uint32_t irq = phb->msi_table[ndev].irq + vec; trace_spapr_pci_msi_write([[addr]], data, irq); qemu_irq_pulse(xics_get_qirq(spapr->icp, irq)); }

[[[[Adv]]]]: static void spapr_msi_write(void *opaque, hwaddr [[rituals]], uint64_t data, unsigned size) { sPAPRPHBState *phb = opaque; int ndev = [[rituals]] >> 16; int vec = (([[rituals]] & 0xFFFF) >> 2) | data; uint32_t irq = phb->msi_table[ndev].irq + vec; trace_spapr_pci_msi_write([[rituals]], data, irq); qemu_irq_pulse(xics_get_qirq(spapr->icp, irq)); }
--------------------------------------------- Result 1220 ---------------------------------------------
[[0 (9%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst, long width, long height, long lumStride, long chromStride, long srcStride) { long y; const x86_reg chromWidth= width>>1; for (y=0; y<height; y+=2) { #if COMPILE_TEMPLATE_MMX __asm__ volatile( "xor %%"REG_a", %%"REG_a" \n\t" "pcmpeqw %%mm7, %%mm7 \n\t" "psrlw $8, %%mm7 \n\t" ".p2align 4 \n\t" "1: \n\t" PREFETCH" 64(%0, %%"REG_a", 4) \n\t" "movq (%0, %%"REG_a", 4), %%mm0 \n\t" "movq 8(%0, %%"REG_a", 4), %%mm1 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "packuswb %%mm1, %%mm0 \n\t" "packuswb %%mm3, %%mm2 \n\t" MOVNTQ" %%mm2, (%1, %%"REG_a", 2) \n\t" "movq 16(%0, %%"REG_a", 4), %%mm1 \n\t" "movq 24(%0, %%"REG_a", 4), %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" "movq %%mm2, %%mm4 \n\t" "psrlw $8, %%mm1 \n\t" "psrlw $8, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "pand %%mm7, %%mm4 \n\t" "packuswb %%mm2, %%mm1 \n\t" "packuswb %%mm4, %%mm3 \n\t" MOVNTQ" %%mm3, 8(%1, %%"REG_a", 2) \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "packuswb %%mm1, %%mm0 \n\t" "packuswb %%mm3, %%mm2 \n\t" MOVNTQ" %%mm0, (%3, %%"REG_a") \n\t" MOVNTQ" %%mm2, (%2, %%"REG_a") \n\t" "add $8, %%"REG_a" \n\t" "cmp %4, %%"REG_a" \n\t" " jb 1b \n\t" ::"r"(src), "r"(ydst), "r"(udst), "r"(vdst), "g" (chromWidth) : "memory", "%"REG_a ); ydst += lumStride; src += srcStride; __asm__ volatile( "xor %%"REG_a", %%"REG_a" \n\t" ".p2align 4 \n\t" "1: \n\t" PREFETCH" 64(%0, %%"REG_a", 4) \n\t" "movq (%0, %%"REG_a", 4), %%mm0 \n\t" "movq 8(%0, %%"REG_a", 4), %%mm1 \n\t" "movq 16(%0, %%"REG_a", 4), %%mm2 \n\t" "movq 24(%0, %%"REG_a", 4), %%mm3 \n\t" "pand %%mm7, %%mm0 \n\t" "pand %%mm7, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "packuswb %%mm1, %%mm0 \n\t" "packuswb %%mm3, %%mm2 \n\t" MOVNTQ" %%mm0, (%1, %%"REG_a", 2) \n\t" MOVNTQ" %%mm2, 8(%1, %%"REG_a", 2) \n\t" "add $8, %%"REG_a" \n\t" "cmp %4, %%"REG_a" \n\t" " jb 1b \n\t" ::"r"(src), "r"(ydst), "r"(udst), "r"(vdst), "g" (chromWidth) : "memory", "%"REG_a ); #else long i; for (i=0; i<chromWidth; i++) { ydst[2*i+0] = src[4*i+0]; udst[i] = src[4*i+1]; ydst[2*i+1] = src[4*i+2]; vdst[i] = src[4*i+3]; } ydst += lumStride; src += srcStride; for (i=0; i<chromWidth; i++) { ydst[2*i+0] = src[4*i+0]; ydst[2*i+1] = src[4*i+2]; } #endif udst += chromStride; vdst += chromStride; ydst += lumStride; src += srcStride; } #if COMPILE_TEMPLATE_MMX __asm__ volatile(EMMS" \n\t" SFENCE" \n\t" :::"memory"); #endif }

[[[[Adv]]]]: static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst, long width, long height, long lumStride, long chromStride, long srcStride) { long y; const x86_reg chromWidth= width>>1; for (y=0; y<height; y+=2) { #if COMPILE_TEMPLATE_MMX __asm__ volatile( "xor %%"REG_a", %%"REG_a" \n\t" "pcmpeqw %%mm7, %%mm7 \n\t" "psrlw $8, %%mm7 \n\t" ".p2align 4 \n\t" "1: \n\t" PREFETCH" 64(%0, %%"REG_a", 4) \n\t" "movq (%0, %%"REG_a", 4), %%mm0 \n\t" "movq 8(%0, %%"REG_a", 4), %%mm1 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "packuswb %%mm1, %%mm0 \n\t" "packuswb %%mm3, %%mm2 \n\t" MOVNTQ" %%mm2, (%1, %%"REG_a", 2) \n\t" "movq 16(%0, %%"REG_a", 4), %%mm1 \n\t" "movq 24(%0, %%"REG_a", 4), %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" "movq %%mm2, %%mm4 \n\t" "psrlw $8, %%mm1 \n\t" "psrlw $8, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "pand %%mm7, %%mm4 \n\t" "packuswb %%mm2, %%mm1 \n\t" "packuswb %%mm4, %%mm3 \n\t" MOVNTQ" %%mm3, 8(%1, %%"REG_a", 2) \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" "psrlw $8, %%mm0 \n\t" "psrlw $8, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "packuswb %%mm1, %%mm0 \n\t" "packuswb %%mm3, %%mm2 \n\t" MOVNTQ" %%mm0, (%3, %%"REG_a") \n\t" MOVNTQ" %%mm2, (%2, %%"REG_a") \n\t" "add $8, %%"REG_a" \n\t" "cmp %4, %%"REG_a" \n\t" " jb 1b \n\t" ::"r"(src), "r"(ydst), "r"(udst), "r"(vdst), "g" (chromWidth) : "memory", "%"REG_a ); ydst += lumStride; src += srcStride; __asm__ volatile( "xor %%"REG_a", %%"REG_a" \n\t" ".p2align 4 \n\t" "1: \n\t" PREFETCH" 64(%0, %%"REG_a", 4) \n\t" "movq (%0, %%"REG_a", 4), %%mm0 \n\t" "movq 8(%0, %%"REG_a", 4), %%mm1 \n\t" "movq 16(%0, %%"REG_a", 4), %%mm2 \n\t" "movq 24(%0, %%"REG_a", 4), %%mm3 \n\t" "pand %%mm7, %%mm0 \n\t" "pand %%mm7, %%mm1 \n\t" "pand %%mm7, %%mm2 \n\t" "pand %%mm7, %%mm3 \n\t" "packuswb %%mm1, %%mm0 \n\t" "packuswb %%mm3, %%mm2 \n\t" MOVNTQ" %%mm0, (%1, %%"REG_a", 2) \n\t" MOVNTQ" %%mm2, 8(%1, %%"REG_a", 2) \n\t" "add $8, %%"REG_a" \n\t" "cmp %4, %%"REG_a" \n\t" " jb 1b \n\t" ::"r"(src), "r"(ydst), "r"(udst), "r"(vdst), "g" (chromWidth) : "memory", "%"REG_a ); #else long i; for (i=0; i<chromWidth; i++) { ydst[2*i+0] = src[4*i+0]; udst[i] = src[4*i+1]; ydst[2*i+1] = src[4*i+2]; vdst[i] = src[4*i+3]; } ydst += lumStride; src += srcStride; for (i=0; i<chromWidth; i++) { ydst[2*i+0] = src[4*i+0]; ydst[2*i+1] = src[4*i+2]; } #endif udst += chromStride; vdst += chromStride; ydst += lumStride; src += srcStride; } #if COMPILE_TEMPLATE_MMX __asm__ volatile(EMMS" \n\t" SFENCE" \n\t" :::"memory"); #endif }
--------------------------------------------- Result 1221 ---------------------------------------------
[[0 (10%)]] --> [[0 (64%)]] --> Socre: 0.6442583203315735

[[[[Adv]]]]: CPUX86State *cpu_x86_init(void) { CPUX86State *[[env]]; int i; static int inited; cpu_x86_tblocks_init(); [[env]] = malloc(sizeof(CPUX86State)); if (![[env]]) return NULL; memset([[env]], 0, sizeof(CPUX86State)); for(i = 0;i < 8; i++) [[env]]->fptags[i] = 1; [[env]]->fpuc = 0x37f; [[env]]->eflags = 0; if (!inited) { inited = 1; optimize_flags_init(); } return [[env]]; }

[[[[Adv]]]]: CPUX86State *cpu_x86_init(void) { CPUX86State *[[detractors]]; int i; static int inited; cpu_x86_tblocks_init(); [[detractors]] = malloc(sizeof(CPUX86State)); if (![[detractors]]) return NULL; memset([[detractors]], 0, sizeof(CPUX86State)); for(i = 0;i < 8; i++) [[detractors]]->fptags[i] = 1; [[detractors]]->fpuc = 0x37f; [[detractors]]->eflags = 0; if (!inited) { inited = 1; optimize_flags_init(); } return [[detractors]]; }
--------------------------------------------- Result 1222 ---------------------------------------------
[[0 (16%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void readline_show_prompt(ReadLineState *rs) { monitor_printf(rs->mon, "%s", rs->prompt); monitor_flush(rs->mon); rs->last_cmd_buf_index = 0; rs->last_cmd_buf_size = 0; rs->esc_state = IS_NORM; }

[[[[Adv]]]]: void readline_show_prompt(ReadLineState *rs) { monitor_printf(rs->mon, "%s", rs->prompt); monitor_flush(rs->mon); rs->last_cmd_buf_index = 0; rs->last_cmd_buf_size = 0; rs->esc_state = IS_NORM; }
--------------------------------------------- Result 1223 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 719 / 67 / 437 / 1223:  45%|     | 1223/2690 [13:36:54<16:19:52, 40.08s/it][Succeeded / Failed / Skipped / Total] 719 / 67 / 437 / 1223:  46%|     | 1224/2690 [13:37:10<16:18:44, 40.06s/it][Succeeded / Failed / Skipped / Total] 720 / 67 / 437 / 1224:  46%|     | 1224/2690 [13:37:10<16:18:44, 40.06s/it][Succeeded / Failed / Skipped / Total] 720 / 67 / 437 / 1224:  46%|     | 1225/2690 [13:37:57<16:18:12, 40.06s/it][Succeeded / Failed / Skipped / Total] 721 / 67 / 437 / 1225:  46%|     | 1225/2690 [13:37:57<16:18:12, 40.06s/it][Succeeded / Failed / Skipped / Total] 721 / 67 / 437 / 1225:  46%|     | 1226/2690 [13:38:01<16:16:49, 40.03s/it][Succeeded / Failed / Skipped / Total] 722 / 67 / 437 / 1226:  46%|     | 1226/2690 [13:38:01<16:16:49, 40.03s/it][Succeeded / Failed / Skipped / Total] 722 / 67 / 437 / 1226:  46%|     | 1227/2690 [13:38:05<16:15:26, 40.00s/it][Succeeded / Failed / Skipped / Total] 723 / 67 / 437 / 1227:  46%|     | 1227/2690 [13:38:05<16:15:26, 40.00s/it][Succeeded / Failed / Skipped / Total] 723 / 67 / 437 / 1227:  46%|     | 1228/2690 [13:38:09<16:14:04, 39.98s/it][[0 (86%)]] --> [[0 (48%)]] --> Socre: 0.5194294452667236

[[[[Adv]]]]: static int decode_channel_residues(WmallDecodeCtx *[[s]], int ch, int [[tile_size]]) { int i = 0; unsigned int ave_mean; [[s]]->transient[ch] = get_bits1(&[[s]]->gb); if ([[s]]->transient[ch]) { [[s]]->transient_pos[ch] = get_bits(&[[s]]->gb, av_log2([[tile_size]])); if ([[s]]->transient_pos[ch]) [[s]]->transient[ch] = 0; [[s]]->channel[ch].transient_counter = FFMAX([[s]]->channel[ch].transient_counter, [[s]]->samples_per_frame / 2); } else if ([[s]]->channel[ch].transient_counter) [[s]]->transient[ch] = 1; if ([[s]]->seekable_tile) { ave_mean = get_bits(&[[s]]->gb, [[s]]->bits_per_sample); [[s]]->ave_sum[ch] = ave_mean << ([[s]]->movave_scaling + 1); } if ([[s]]->seekable_tile) { if ([[s]]->do_inter_ch_decorr) [[s]]->channel_residues[ch][0] = get_sbits(&[[s]]->gb, [[s]]->bits_per_sample + 1); else [[s]]->channel_residues[ch][0] = get_sbits(&[[s]]->gb, [[s]]->bits_per_sample); i++; } for (; i < [[tile_size]]; i++) { int quo = 0, rem, rem_bits, residue; while(get_bits1(&[[s]]->gb)) { quo++; if (get_bits_left(&[[s]]->gb) <= 0) return -1; } if (quo >= 32) quo += get_bits_long(&[[s]]->gb, get_bits(&[[s]]->gb, 5) + 1); ave_mean = ([[s]]->ave_sum[ch] + (1 << [[s]]->movave_scaling)) >> ([[s]]->movave_scaling + 1); if (ave_mean <= 1) residue = quo; else { rem_bits = av_ceil_log2(ave_mean); rem = rem_bits ? get_bits(&[[s]]->gb, rem_bits) : 0; residue = (quo << rem_bits) + rem; } [[s]]->ave_sum[ch] = residue + [[s]]->ave_sum[ch] - ([[s]]->ave_sum[ch] >> [[s]]->movave_scaling); if (residue & 1) residue = -(residue >> 1) - 1; else residue = residue >> 1; [[s]]->channel_residues[ch][i] = residue; } return 0; }

[[[[Adv]]]]: static int decode_channel_residues(WmallDecodeCtx *[[w]], int ch, int [[advertiser]]) { int i = 0; unsigned int ave_mean; [[w]]->transient[ch] = get_bits1(&[[w]]->gb); if ([[w]]->transient[ch]) { [[w]]->transient_pos[ch] = get_bits(&[[w]]->gb, av_log2([[advertiser]])); if ([[w]]->transient_pos[ch]) [[w]]->transient[ch] = 0; [[w]]->channel[ch].transient_counter = FFMAX([[w]]->channel[ch].transient_counter, [[w]]->samples_per_frame / 2); } else if ([[w]]->channel[ch].transient_counter) [[w]]->transient[ch] = 1; if ([[w]]->seekable_tile) { ave_mean = get_bits(&[[w]]->gb, [[w]]->bits_per_sample); [[w]]->ave_sum[ch] = ave_mean << ([[w]]->movave_scaling + 1); } if ([[w]]->seekable_tile) { if ([[w]]->do_inter_ch_decorr) [[w]]->channel_residues[ch][0] = get_sbits(&[[w]]->gb, [[w]]->bits_per_sample + 1); else [[w]]->channel_residues[ch][0] = get_sbits(&[[w]]->gb, [[w]]->bits_per_sample); i++; } for (; i < [[advertiser]]; i++) { int quo = 0, rem, rem_bits, residue; while(get_bits1(&[[w]]->gb)) { quo++; if (get_bits_left(&[[w]]->gb) <= 0) return -1; } if (quo >= 32) quo += get_bits_long(&[[w]]->gb, get_bits(&[[w]]->gb, 5) + 1); ave_mean = ([[w]]->ave_sum[ch] + (1 << [[w]]->movave_scaling)) >> ([[w]]->movave_scaling + 1); if (ave_mean <= 1) residue = quo; else { rem_bits = av_ceil_log2(ave_mean); rem = rem_bits ? get_bits(&[[w]]->gb, rem_bits) : 0; residue = (quo << rem_bits) + rem; } [[w]]->ave_sum[ch] = residue + [[w]]->ave_sum[ch] - ([[w]]->ave_sum[ch] >> [[w]]->movave_scaling); if (residue & 1) residue = -(residue >> 1) - 1; else residue = residue >> 1; [[w]]->channel_residues[ch][i] = residue; } return 0; }
--------------------------------------------- Result 1224 ---------------------------------------------
[[0 (2%)]] --> [[0 (58%)]] --> Socre: 0.5774929523468018

[[[[Adv]]]]: START_TEST(qfloat_destroy_test) { QFloat *[[qf]] = qfloat_from_double(0.0); QDECREF([[qf]]); }

[[[[Adv]]]]: START_TEST(qfloat_destroy_test) { QFloat *[[too]] = qfloat_from_double(0.0); QDECREF([[too]]); }
--------------------------------------------- Result 1225 ---------------------------------------------
[[0 (7%)]] --> [[0 (52%)]] --> Socre: 0.5231045484542847

[[[[Adv]]]]: static int parallel_parse(const char *[[devname]]) { static int index = 0; char [[label]][32]; if (strcmp([[devname]], "none") == 0) return 0; if (index == MAX_PARALLEL_PORTS) { fprintf(stderr, "qemu: too many parallel ports\n"); exit(1); } snprintf([[label]], sizeof([[label]]), "parallel%d", index); parallel_hds[index] = qemu_chr_new([[label]], [[devname]], NULL); if (!parallel_hds[index]) { fprintf(stderr, "qemu: could not connect parallel device" " to character backend '%s'\n", [[devname]]); return -1; } index++; return 0; }

[[[[Adv]]]]: static int parallel_parse(const char *[[helicopter]]) { static int index = 0; char [[captioning]][32]; if (strcmp([[helicopter]], "none") == 0) return 0; if (index == MAX_PARALLEL_PORTS) { fprintf(stderr, "qemu: too many parallel ports\n"); exit(1); } snprintf([[captioning]], sizeof([[captioning]]), "parallel%d", index); parallel_hds[index] = qemu_chr_new([[captioning]], [[helicopter]], NULL); if (!parallel_hds[index]) { fprintf(stderr, "qemu: could not connect parallel device" " to character backend '%s'\n", [[helicopter]]); return -1; } index++; return 0; }
--------------------------------------------- Result 1226 ---------------------------------------------
[[0 (2%)]] --> [[0 (51%)]] --> Socre: 0.5086368322372437

[[[[Adv]]]]: void QEMU_NORETURN runtime_exception(CPUS390XState *[[env]], int [[excp]], uintptr_t retaddr) { CPUState *cs = CPU(s390_env_get_cpu([[env]])); int t; cs->exception_index = EXCP_PGM; [[env]]->int_pgm_code = [[excp]]; cpu_restore_state(cs, retaddr); t = cpu_ldub_code([[env]], [[env]]->psw.addr); [[env]]->int_pgm_ilen = t = get_ilen(t); [[env]]->psw.addr += t; cpu_loop_exit(cs); }

[[[[Adv]]]]: void QEMU_NORETURN runtime_exception(CPUS390XState *[[informants]], int [[lakes]], uintptr_t retaddr) { CPUState *cs = CPU(s390_env_get_cpu([[informants]])); int t; cs->exception_index = EXCP_PGM; [[informants]]->int_pgm_code = [[lakes]]; cpu_restore_state(cs, retaddr); t = cpu_ldub_code([[informants]], [[informants]]->psw.addr); [[informants]]->int_pgm_ilen = t = get_ilen(t); [[informants]]->psw.addr += t; cpu_loop_exit(cs); }
--------------------------------------------- Result 1227 ---------------------------------------------
[[0 (29%)]] --> [[0 (53%)]] --> Socre: 0.5269704461097717

[[[[Adv]]]]: static int usb_host_init(void) { const struct libusb_pollfd **[[poll]]; int [[i]], rc; if (ctx) { return 0; } rc = libusb_init(&ctx); if (rc != 0) { return -1; } libusb_set_debug(ctx, loglevel); libusb_set_pollfd_notifiers(ctx, usb_host_add_fd, usb_host_del_fd, ctx); [[poll]] = libusb_get_pollfds(ctx); if ([[poll]]) { for ([[i]] = 0; [[poll]][[[i]]] != NULL; [[i]]++) { usb_host_add_fd([[poll]][[[i]]]->fd, [[poll]][[[i]]]->events, ctx); } } free([[poll]]); return 0; }

[[[[Adv]]]]: static int usb_host_init(void) { const struct libusb_pollfd **[[polling]]; int [[johnson]], rc; if (ctx) { return 0; } rc = libusb_init(&ctx); if (rc != 0) { return -1; } libusb_set_debug(ctx, loglevel); libusb_set_pollfd_notifiers(ctx, usb_host_add_fd, usb_host_del_fd, ctx); [[polling]] = libusb_get_pollfds(ctx); if ([[polling]]) { for ([[johnson]] = 0; [[polling]][[[johnson]]] != NULL; [[johnson]]++) { usb_host_add_fd([[polling]][[[johnson]]]->fd, [[polling]][[[johnson]]]->events, ctx); } } free([[polling]]); return 0; }
--------------------------------------------- Result 1228 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 724 / 67 / 437 / 1228:  46%|     | 1228/2690 [13:38:09<16:14:04, 39.98s/it][Succeeded / Failed / Skipped / Total] 724 / 67 / 437 / 1228:  46%|     | 1229/2690 [13:38:10<16:12:37, 39.94s/it][Succeeded / Failed / Skipped / Total] 724 / 67 / 438 / 1229:  46%|     | 1229/2690 [13:38:10<16:12:37, 39.94s/it][Succeeded / Failed / Skipped / Total] 724 / 67 / 438 / 1229:  46%|     | 1230/2690 [13:38:37<16:11:42, 39.93s/it][Succeeded / Failed / Skipped / Total] 725 / 67 / 438 / 1230:  46%|     | 1230/2690 [13:38:37<16:11:42, 39.93s/it][Succeeded / Failed / Skipped / Total] 725 / 67 / 438 / 1230:  46%|     | 1231/2690 [13:40:30<16:12:28, 39.99s/it][[0 (24%)]] --> [[0 (65%)]] --> Socre: 0.6477728486061096

[[[[Adv]]]]: SnapshotInfo *qmp_blockdev_snapshot_delete_internal_sync(const char *device, bool has_id, const char *id, bool has_name, const char *name, Error **errp) { BlockDriverState *bs; BlockBackend *blk; AioContext *aio_context; QEMUSnapshotInfo sn; Error *local_err = NULL; SnapshotInfo *info = NULL; int [[ret]]; blk = blk_by_name(device); if (!blk) { error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND, "Device '%s' not found", device); return NULL; } aio_context = blk_get_aio_context(blk); aio_context_acquire(aio_context); if (!has_id) { id = NULL; } if (!has_name) { name = NULL; } if (!id && !name) { error_setg(errp, "Name or id must be provided"); goto out_aio_context; } if (!blk_is_available(blk)) { error_setg(errp, "Device '%s' has no medium", device); goto out_aio_context; } bs = blk_bs(blk); if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_INTERNAL_SNAPSHOT_DELETE, errp)) { goto out_aio_context; } [[ret]] = bdrv_snapshot_find_by_id_and_name(bs, id, name, &sn, &local_err); if (local_err) { error_propagate(errp, local_err); goto out_aio_context; } if (![[ret]]) { error_setg(errp, "Snapshot with id '%s' and name '%s' does not exist on " "device '%s'", STR_OR_NULL(id), STR_OR_NULL(name), device); goto out_aio_context; } bdrv_snapshot_delete(bs, id, name, &local_err); if (local_err) { error_propagate(errp, local_err); goto out_aio_context; } aio_context_release(aio_context); info = g_new0(SnapshotInfo, 1); info->id = g_strdup(sn.id_str); info->name = g_strdup(sn.name); info->date_nsec = sn.date_nsec; info->date_sec = sn.date_sec; info->vm_state_size = sn.vm_state_size; info->vm_clock_nsec = sn.vm_clock_nsec % 1000000000; info->vm_clock_sec = sn.vm_clock_nsec / 1000000000; return info; out_aio_context: aio_context_release(aio_context); return NULL; }

[[[[Adv]]]]: SnapshotInfo *qmp_blockdev_snapshot_delete_internal_sync(const char *device, bool has_id, const char *id, bool has_name, const char *name, Error **errp) { BlockDriverState *bs; BlockBackend *blk; AioContext *aio_context; QEMUSnapshotInfo sn; Error *local_err = NULL; SnapshotInfo *info = NULL; int [[withdraws]]; blk = blk_by_name(device); if (!blk) { error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND, "Device '%s' not found", device); return NULL; } aio_context = blk_get_aio_context(blk); aio_context_acquire(aio_context); if (!has_id) { id = NULL; } if (!has_name) { name = NULL; } if (!id && !name) { error_setg(errp, "Name or id must be provided"); goto out_aio_context; } if (!blk_is_available(blk)) { error_setg(errp, "Device '%s' has no medium", device); goto out_aio_context; } bs = blk_bs(blk); if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_INTERNAL_SNAPSHOT_DELETE, errp)) { goto out_aio_context; } [[withdraws]] = bdrv_snapshot_find_by_id_and_name(bs, id, name, &sn, &local_err); if (local_err) { error_propagate(errp, local_err); goto out_aio_context; } if (![[withdraws]]) { error_setg(errp, "Snapshot with id '%s' and name '%s' does not exist on " "device '%s'", STR_OR_NULL(id), STR_OR_NULL(name), device); goto out_aio_context; } bdrv_snapshot_delete(bs, id, name, &local_err); if (local_err) { error_propagate(errp, local_err); goto out_aio_context; } aio_context_release(aio_context); info = g_new0(SnapshotInfo, 1); info->id = g_strdup(sn.id_str); info->name = g_strdup(sn.name); info->date_nsec = sn.date_nsec; info->date_sec = sn.date_sec; info->vm_state_size = sn.vm_state_size; info->vm_clock_nsec = sn.vm_clock_nsec % 1000000000; info->vm_clock_sec = sn.vm_clock_nsec / 1000000000; return info; out_aio_context: aio_context_release(aio_context); return NULL; }
--------------------------------------------- Result 1229 ---------------------------------------------
[[0 (76%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void virtio_scsi_complete_req(VirtIOSCSIReq *req) { VirtIOSCSI *s = req->dev; VirtQueue *vq = req->vq; VirtIODevice *vdev = VIRTIO_DEVICE(s); virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len); if (req->sreq) { req->sreq->hba_private = NULL; scsi_req_unref(req->sreq); } virtio_scsi_free_req(req); virtio_notify(vdev, vq); }
--------------------------------------------- Result 1230 ---------------------------------------------
[[0 (16%)]] --> [[0 (54%)]] --> Socre: 0.5387998223304749

[[[[Adv]]]]: static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf) { int err; char buffer[PATH_MAX]; char *path = fs_path->data; err = lstat(rpath(fs_ctx, path, buffer), stbuf); if (err) { return err; } if (fs_ctx->fs_sm == SM_MAPPED) { uid_t tmp_uid; gid_t [[tmp_gid]]; mode_t tmp_mode; dev_t tmp_dev; if (getxattr(rpath(fs_ctx, path, buffer), "user.virtfs.uid", &tmp_uid, sizeof(uid_t)) > 0) { stbuf->st_uid = tmp_uid; } if (getxattr(rpath(fs_ctx, path, buffer), "user.virtfs.gid", &[[tmp_gid]], sizeof(gid_t)) > 0) { stbuf->st_gid = [[tmp_gid]]; } if (getxattr(rpath(fs_ctx, path, buffer), "user.virtfs.mode", &tmp_mode, sizeof(mode_t)) > 0) { stbuf->st_mode = tmp_mode; } if (getxattr(rpath(fs_ctx, path, buffer), "user.virtfs.rdev", &tmp_dev, sizeof(dev_t)) > 0) { stbuf->st_rdev = tmp_dev; } } return err; }

[[[[Adv]]]]: static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf) { int err; char buffer[PATH_MAX]; char *path = fs_path->data; err = lstat(rpath(fs_ctx, path, buffer), stbuf); if (err) { return err; } if (fs_ctx->fs_sm == SM_MAPPED) { uid_t tmp_uid; gid_t [[t]]; mode_t tmp_mode; dev_t tmp_dev; if (getxattr(rpath(fs_ctx, path, buffer), "user.virtfs.uid", &tmp_uid, sizeof(uid_t)) > 0) { stbuf->st_uid = tmp_uid; } if (getxattr(rpath(fs_ctx, path, buffer), "user.virtfs.gid", &[[t]], sizeof(gid_t)) > 0) { stbuf->st_gid = [[t]]; } if (getxattr(rpath(fs_ctx, path, buffer), "user.virtfs.mode", &tmp_mode, sizeof(mode_t)) > 0) { stbuf->st_mode = tmp_mode; } if (getxattr(rpath(fs_ctx, path, buffer), "user.virtfs.rdev", &tmp_dev, sizeof(dev_t)) > 0) { stbuf->st_rdev = tmp_dev; } } return err; }
--------------------------------------------- Result 1231 ---------------------------------------------
[[0 (36%)]] --> [[0 (55%)]] --> Socre: 0.5541428327560425

[[[[Adv]]]]: static int av_cold libopus_encode_init(AVCodecContext *avctx) { LibopusEncContext *[[opus]] = avctx->priv_data; const uint8_t *channel_mapping; OpusMSEncoder *enc; int ret = OPUS_OK; int coupled_stream_count, header_size, frame_size; coupled_stream_count = opus_coupled_streams[avctx->channels - 1]; [[opus]]->stream_count = avctx->channels - coupled_stream_count; channel_mapping = libav_libopus_channel_map[avctx->channels - 1]; if (avctx->channels > 8) av_log(avctx, AV_LOG_WARNING, "Channel layout undefined for %d channels.\n", avctx->channels); if (!avctx->bit_rate) { avctx->bit_rate = 64000 * [[opus]]->stream_count + 32000 * coupled_stream_count; av_log(avctx, AV_LOG_WARNING, "No bit rate set. Defaulting to %d bps.\n", avctx->bit_rate); } if (avctx->bit_rate < 500 || avctx->bit_rate > 256000 * avctx->channels) { av_log(avctx, AV_LOG_ERROR, "The bit rate %d bps is unsupported. " "Please choose a value between 500 and %d.\n", avctx->bit_rate, 256000 * avctx->channels); return AVERROR(EINVAL); } frame_size = [[opus]]->opts.frame_duration * 48000 / 1000; switch (frame_size) { case 120: case 240: if ([[opus]]->opts.application != OPUS_APPLICATION_RESTRICTED_LOWDELAY) av_log(avctx, AV_LOG_WARNING, "LPC mode cannot be used with a frame duration of less " "than 10ms. Enabling restricted low-delay mode.\n" "Use a longer frame duration if this is not what you want.\n"); [[opus]]->opts.application = OPUS_APPLICATION_RESTRICTED_LOWDELAY; case 480: case 960: case 1920: case 2880: [[opus]]->opts.packet_size = avctx->frame_size = frame_size * avctx->sample_rate / 48000; break; default: av_log(avctx, AV_LOG_ERROR, "Invalid frame duration: %g.\n" "Frame duration must be exactly one of: 2.5, 5, 10, 20, 40 or 60.\n", [[opus]]->opts.frame_duration); return AVERROR(EINVAL); } if (avctx->compression_level < 0 || avctx->compression_level > 10) { av_log(avctx, AV_LOG_WARNING, "Compression level must be in the range 0 to 10. " "Defaulting to 10.\n"); [[opus]]->opts.complexity = 10; } else { [[opus]]->opts.complexity = avctx->compression_level; } if (avctx->cutoff) { switch (avctx->cutoff) { case 4000: [[opus]]->opts.max_bandwidth = OPUS_BANDWIDTH_NARROWBAND; break; case 6000: [[opus]]->opts.max_bandwidth = OPUS_BANDWIDTH_MEDIUMBAND; break; case 8000: [[opus]]->opts.max_bandwidth = OPUS_BANDWIDTH_WIDEBAND; break; case 12000: [[opus]]->opts.max_bandwidth = OPUS_BANDWIDTH_SUPERWIDEBAND; break; case 20000: [[opus]]->opts.max_bandwidth = OPUS_BANDWIDTH_FULLBAND; break; default: av_log(avctx, AV_LOG_WARNING, "Invalid frequency cutoff: %d. Using default maximum bandwidth.\n" "Cutoff frequency must be exactly one of: 4000, 6000, 8000, 12000 or 20000.\n", avctx->cutoff); avctx->cutoff = 0; } } enc = opus_multistream_encoder_create(avctx->sample_rate, avctx->channels, [[opus]]->stream_count, coupled_stream_count, channel_mapping, [[opus]]->opts.application, &ret); if (ret != OPUS_OK) { av_log(avctx, AV_LOG_ERROR, "Failed to create encoder: %s\n", opus_strerror(ret)); return ff_opus_error_to_averror(ret); } ret = libopus_configure_encoder(avctx, enc, &[[opus]]->opts); if (ret != OPUS_OK) { ret = ff_opus_error_to_averror(ret); goto fail; } header_size = 19 + (avctx->channels > 2 ? 2 + avctx->channels : 0); avctx->extradata = av_malloc(header_size + FF_INPUT_BUFFER_PADDING_SIZE); if (!avctx->extradata) { av_log(avctx, AV_LOG_ERROR, "Failed to allocate extradata.\n"); ret = AVERROR(ENOMEM); goto fail; } avctx->extradata_size = header_size; [[opus]]->samples = av_mallocz(frame_size * avctx->channels * av_get_bytes_per_sample(avctx->sample_fmt)); if (![[opus]]->samples) { av_log(avctx, AV_LOG_ERROR, "Failed to allocate samples buffer.\n"); ret = AVERROR(ENOMEM); goto fail; } ret = opus_multistream_encoder_ctl(enc, OPUS_GET_LOOKAHEAD(&avctx->delay)); if (ret != OPUS_OK) av_log(avctx, AV_LOG_WARNING, "Unable to get number of lookahead samples: %s\n", opus_strerror(ret)); libopus_write_header(avctx, [[opus]]->stream_count, coupled_stream_count, opus_vorbis_channel_map[avctx->channels - 1]); ff_af_queue_init(avctx, &[[opus]]->afq); [[opus]]->enc = enc; return 0; fail: opus_multistream_encoder_destroy(enc); av_freep(&avctx->extradata); return ret; }

[[[[Adv]]]]: static int av_cold libopus_encode_init(AVCodecContext *avctx) { LibopusEncContext *[[confrontational]] = avctx->priv_data; const uint8_t *channel_mapping; OpusMSEncoder *enc; int ret = OPUS_OK; int coupled_stream_count, header_size, frame_size; coupled_stream_count = opus_coupled_streams[avctx->channels - 1]; [[confrontational]]->stream_count = avctx->channels - coupled_stream_count; channel_mapping = libav_libopus_channel_map[avctx->channels - 1]; if (avctx->channels > 8) av_log(avctx, AV_LOG_WARNING, "Channel layout undefined for %d channels.\n", avctx->channels); if (!avctx->bit_rate) { avctx->bit_rate = 64000 * [[confrontational]]->stream_count + 32000 * coupled_stream_count; av_log(avctx, AV_LOG_WARNING, "No bit rate set. Defaulting to %d bps.\n", avctx->bit_rate); } if (avctx->bit_rate < 500 || avctx->bit_rate > 256000 * avctx->channels) { av_log(avctx, AV_LOG_ERROR, "The bit rate %d bps is unsupported. " "Please choose a value between 500 and %d.\n", avctx->bit_rate, 256000 * avctx->channels); return AVERROR(EINVAL); } frame_size = [[confrontational]]->opts.frame_duration * 48000 / 1000; switch (frame_size) { case 120: case 240: if ([[confrontational]]->opts.application != OPUS_APPLICATION_RESTRICTED_LOWDELAY) av_log(avctx, AV_LOG_WARNING, "LPC mode cannot be used with a frame duration of less " "than 10ms. Enabling restricted low-delay mode.\n" "Use a longer frame duration if this is not what you want.\n"); [[confrontational]]->opts.application = OPUS_APPLICATION_RESTRICTED_LOWDELAY; case 480: case 960: case 1920: case 2880: [[confrontational]]->opts.packet_size = avctx->frame_size = frame_size * avctx->sample_rate / 48000; break; default: av_log(avctx, AV_LOG_ERROR, "Invalid frame duration: %g.\n" "Frame duration must be exactly one of: 2.5, 5, 10, 20, 40 or 60.\n", [[confrontational]]->opts.frame_duration); return AVERROR(EINVAL); } if (avctx->compression_level < 0 || avctx->compression_level > 10) { av_log(avctx, AV_LOG_WARNING, "Compression level must be in the range 0 to 10. " "Defaulting to 10.\n"); [[confrontational]]->opts.complexity = 10; } else { [[confrontational]]->opts.complexity = avctx->compression_level; } if (avctx->cutoff) { switch (avctx->cutoff) { case 4000: [[confrontational]]->opts.max_bandwidth = OPUS_BANDWIDTH_NARROWBAND; break; case 6000: [[confrontational]]->opts.max_bandwidth = OPUS_BANDWIDTH_MEDIUMBAND; break; case 8000: [[confrontational]]->opts.max_bandwidth = OPUS_BANDWIDTH_WIDEBAND; break; case 12000: [[confrontational]]->opts.max_bandwidth = OPUS_BANDWIDTH_SUPERWIDEBAND; break; case 20000: [[confrontational]]->opts.max_bandwidth = OPUS_BANDWIDTH_FULLBAND; break; default: av_log(avctx, AV_LOG_WARNING, "Invalid frequency cutoff: %d. Using default maximum bandwidth.\n" "Cutoff frequency must be exactly one of: 4000, 6000, 8000, 12000 or 20000.\n", avctx->cutoff); avctx->cutoff = 0; } } enc = opus_multistream_encoder_create(avctx->sample_rate, avctx->channels, [[confrontational]]->stream_count, coupled_stream_count, channel_mapping, [[confrontational]]->opts.application, &ret); if (ret != OPUS_OK) { av_log(avctx, AV_LOG_ERROR, "Failed to create encoder: %s\n", opus_strerror(ret)); return ff_opus_error_to_averror(ret); } ret = libopus_configure_encoder(avctx, enc, &[[confrontational]]->opts); if (ret != OPUS_OK) { ret = ff_opus_error_to_averror(ret); goto fail; } header_size = 19 + (avctx->channels > 2 ? 2 + avctx->channels : 0); avctx->extradata = av_malloc(header_size + FF_INPUT_BUFFER_PADDING_SIZE); if (!avctx->extradata) { av_log(avctx, AV_LOG_ERROR, "Failed to allocate extradata.\n"); ret = AVERROR(ENOMEM); goto fail; } avctx->extradata_size = header_size; [[confrontational]]->samples = av_mallocz(frame_size * avctx->channels * av_get_bytes_per_sample(avctx->sample_fmt)); if (![[confrontational]]->samples) { av_log(avctx, AV_LOG_ERROR, "Failed to allocate samples buffer.\n"); ret = AVERROR(ENOMEM); goto fail; } ret = opus_multistream_encoder_ctl(enc, OPUS_GET_LOOKAHEAD(&avctx->delay)); if (ret != OPUS_OK) av_log(avctx, AV_LOG_WARNING, "Unable to get number of lookahead samples: %s\n", opus_strerror(ret)); libopus_write_header(avctx, [[confrontational]]->stream_count, coupled_stream_count, opus_vorbis_channel_map[avctx->channels - 1]); ff_af_queue_init(avctx, &[[confrontational]]->afq); [[confrontational]]->enc = enc; return 0; fail: opus_multistream_encoder_destroy(enc); av_freep(&avctx->extradata); return ret; }[Succeeded / Failed / Skipped / Total] 726 / 67 / 438 / 1231:  46%|     | 1231/2690 [13:40:30<16:12:28, 39.99s/it][Succeeded / Failed / Skipped / Total] 726 / 67 / 438 / 1231:  46%|     | 1232/2690 [13:40:35<16:11:07, 39.96s/it][Succeeded / Failed / Skipped / Total] 727 / 67 / 438 / 1232:  46%|     | 1232/2690 [13:40:35<16:11:07, 39.96s/it][Succeeded / Failed / Skipped / Total] 727 / 67 / 438 / 1232:  46%|     | 1233/2690 [13:40:41<16:09:47, 39.94s/it][Succeeded / Failed / Skipped / Total] 728 / 67 / 438 / 1233:  46%|     | 1233/2690 [13:40:41<16:09:47, 39.94s/it][Succeeded / Failed / Skipped / Total] 728 / 67 / 438 / 1233:  46%|     | 1234/2690 [13:46:24<16:15:04, 40.18s/it][Succeeded / Failed / Skipped / Total] 729 / 67 / 438 / 1234:  46%|     | 1234/2690 [13:46:24<16:15:04, 40.18s/it][Succeeded / Failed / Skipped / Total] 729 / 67 / 438 / 1234:  46%|     | 1235/2690 [13:47:26<16:14:50, 40.20s/it][Succeeded / Failed / Skipped / Total] 730 / 67 / 438 / 1235:  46%|     | 1235/2690 [13:47:26<16:14:50, 40.20s/it][Succeeded / Failed / Skipped / Total] 730 / 67 / 438 / 1235:  46%|     | 1236/2690 [13:47:29<16:13:26, 40.17s/it]
--------------------------------------------- Result 1232 ---------------------------------------------
[[0 (27%)]] --> [[0 (57%)]] --> Socre: 0.5670549869537354

[[[[Adv]]]]: static void setup_rt_frame(int sig, struct emulated_sigaction *ka, target_siginfo_t *info, target_sigset_t *set, CPUX86State *[[env]]) { struct rt_sigframe *frame; int [[err]] = 0; frame = get_sigframe(ka, [[env]], sizeof(*frame)); #if 0 if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame))) goto give_sigsegv; #endif [[err]] |= __put_user(( sig), &frame->sig); [[err]] |= __put_user((target_ulong)&frame->info, &frame->pinfo); [[err]] |= __put_user((target_ulong)&frame->uc, &frame->puc); [[err]] |= copy_siginfo_to_user(&frame->info, info); if ([[err]]) goto give_sigsegv; [[err]] |= __put_user(0, &frame->uc.uc_flags); [[err]] |= __put_user(0, &frame->uc.uc_link); [[err]] |= __put_user( 0, &frame->uc.uc_stack.ss_sp); [[err]] |= __put_user( 0, &frame->uc.uc_stack.ss_flags); [[err]] |= __put_user( 0, &frame->uc.uc_stack.ss_size); [[err]] |= setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate, [[env]], set->sig[0]); [[err]] |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set)); if ([[err]]) goto give_sigsegv; if (ka->sa.sa_flags & TARGET_SA_RESTORER) { [[err]] |= __put_user(ka->sa.sa_restorer, &frame->pretcode); } else { [[err]] |= __put_user(frame->retcode, &frame->pretcode); [[err]] |= __put_user(0xb8, (char *)(frame->retcode+0)); [[err]] |= __put_user(TARGET_NR_rt_sigreturn, (int *)(frame->retcode+1)); [[err]] |= __put_user(0x80cd, (short *)(frame->retcode+5)); } if ([[err]]) goto give_sigsegv; [[env]]->regs[R_ESP] = (unsigned long) frame; [[env]]->eip = (unsigned long) ka->sa._sa_handler; cpu_x86_load_seg([[env]], R_DS, __USER_DS); cpu_x86_load_seg([[env]], R_ES, __USER_DS); cpu_x86_load_seg([[env]], R_SS, __USER_DS); cpu_x86_load_seg([[env]], R_CS, __USER_CS); [[env]]->eflags &= ~TF_MASK; return; give_sigsegv: if (sig == TARGET_SIGSEGV) ka->sa._sa_handler = TARGET_SIG_DFL; force_sig(TARGET_SIGSEGV ); }

[[[[Adv]]]]: static void setup_rt_frame(int sig, struct emulated_sigaction *ka, target_siginfo_t *info, target_sigset_t *set, CPUX86State *[[bensonhurst]]) { struct rt_sigframe *frame; int [[umm]] = 0; frame = get_sigframe(ka, [[bensonhurst]], sizeof(*frame)); #if 0 if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame))) goto give_sigsegv; #endif [[umm]] |= __put_user(( sig), &frame->sig); [[umm]] |= __put_user((target_ulong)&frame->info, &frame->pinfo); [[umm]] |= __put_user((target_ulong)&frame->uc, &frame->puc); [[umm]] |= copy_siginfo_to_user(&frame->info, info); if ([[umm]]) goto give_sigsegv; [[umm]] |= __put_user(0, &frame->uc.uc_flags); [[umm]] |= __put_user(0, &frame->uc.uc_link); [[umm]] |= __put_user( 0, &frame->uc.uc_stack.ss_sp); [[umm]] |= __put_user( 0, &frame->uc.uc_stack.ss_flags); [[umm]] |= __put_user( 0, &frame->uc.uc_stack.ss_size); [[umm]] |= setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate, [[bensonhurst]], set->sig[0]); [[umm]] |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set)); if ([[umm]]) goto give_sigsegv; if (ka->sa.sa_flags & TARGET_SA_RESTORER) { [[umm]] |= __put_user(ka->sa.sa_restorer, &frame->pretcode); } else { [[umm]] |= __put_user(frame->retcode, &frame->pretcode); [[umm]] |= __put_user(0xb8, (char *)(frame->retcode+0)); [[umm]] |= __put_user(TARGET_NR_rt_sigreturn, (int *)(frame->retcode+1)); [[umm]] |= __put_user(0x80cd, (short *)(frame->retcode+5)); } if ([[umm]]) goto give_sigsegv; [[bensonhurst]]->regs[R_ESP] = (unsigned long) frame; [[bensonhurst]]->eip = (unsigned long) ka->sa._sa_handler; cpu_x86_load_seg([[bensonhurst]], R_DS, __USER_DS); cpu_x86_load_seg([[bensonhurst]], R_ES, __USER_DS); cpu_x86_load_seg([[bensonhurst]], R_SS, __USER_DS); cpu_x86_load_seg([[bensonhurst]], R_CS, __USER_CS); [[bensonhurst]]->eflags &= ~TF_MASK; return; give_sigsegv: if (sig == TARGET_SIGSEGV) ka->sa._sa_handler = TARGET_SIG_DFL; force_sig(TARGET_SIGSEGV ); }
--------------------------------------------- Result 1233 ---------------------------------------------
[[0 (7%)]] --> [[0 (53%)]] --> Socre: 0.5314540863037109

[[[[Adv]]]]: static void tcp_chr_telnet_init(QIOChannel *[[ioc]]) { char [[buf]][3]; IACSET([[buf]], 0xff, 0xfb, 0x01); qio_channel_write([[ioc]], [[buf]], 3, NULL); IACSET([[buf]], 0xff, 0xfb, 0x03); qio_channel_write([[ioc]], [[buf]], 3, NULL); IACSET([[buf]], 0xff, 0xfb, 0x00); qio_channel_write([[ioc]], [[buf]], 3, NULL); IACSET([[buf]], 0xff, 0xfd, 0x00); qio_channel_write([[ioc]], [[buf]], 3, NULL); }

[[[[Adv]]]]: static void tcp_chr_telnet_init(QIOChannel *[[blacklisted]]) { char [[barbarous]][3]; IACSET([[barbarous]], 0xff, 0xfb, 0x01); qio_channel_write([[blacklisted]], [[barbarous]], 3, NULL); IACSET([[barbarous]], 0xff, 0xfb, 0x03); qio_channel_write([[blacklisted]], [[barbarous]], 3, NULL); IACSET([[barbarous]], 0xff, 0xfb, 0x00); qio_channel_write([[blacklisted]], [[barbarous]], 3, NULL); IACSET([[barbarous]], 0xff, 0xfd, 0x00); qio_channel_write([[blacklisted]], [[barbarous]], 3, NULL); }
--------------------------------------------- Result 1234 ---------------------------------------------
[[0 (1%)]] --> [[0 (52%)]] --> Socre: 0.5220441222190857

[[[[Adv]]]]: static void pxa2xx_pm_write(void *[[opaque]], target_phys_addr_t [[addr]], uint32_t value) { struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) [[opaque]]; if ([[addr]] > s->pm_base + PCMD31) { pxa2xx_i2c_write(s->i2c[1], [[addr]], value); return; } [[addr]] -= s->pm_base; switch ([[addr]]) { case PMCR: s->pm_regs[[[addr]] >> 2] &= 0x15 & ~(value & 0x2a); s->pm_regs[[[addr]] >> 2] |= value & 0x15; break; case PSSR: case RCSR: case PKSR: s->pm_regs[[[addr]] >> 2] &= ~value; break; default: if ([[addr]] >= PMCR && [[addr]] <= PCMD31 && !([[addr]] & 3)) { s->pm_regs[[[addr]] >> 2] = value; break; } printf("%s: Bad register " REG_FMT "\n", __FUNCTION__, [[addr]]); break; } }

[[[[Adv]]]]: static void pxa2xx_pm_write(void *[[secret]], target_phys_addr_t [[s]], uint32_t value) { struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) [[secret]]; if ([[s]] > s->pm_base + PCMD31) { pxa2xx_i2c_write(s->i2c[1], [[s]], value); return; } [[s]] -= s->pm_base; switch ([[s]]) { case PMCR: s->pm_regs[[[s]] >> 2] &= 0x15 & ~(value & 0x2a); s->pm_regs[[[s]] >> 2] |= value & 0x15; break; case PSSR: case RCSR: case PKSR: s->pm_regs[[[s]] >> 2] &= ~value; break; default: if ([[s]] >= PMCR && [[s]] <= PCMD31 && !([[s]] & 3)) { s->pm_regs[[[s]] >> 2] = value; break; } printf("%s: Bad register " REG_FMT "\n", __FUNCTION__, [[s]]); break; } }
--------------------------------------------- Result 1235 ---------------------------------------------
[[0 (74%)]] --> [[0 (35%)]] --> Socre: 0.6532366275787354

[[[[Adv]]]]: static int gdbserver_open(int port) { struct sockaddr_in sockaddr; int [[fd]], val, ret; [[fd]] = socket(PF_INET, SOCK_STREAM, 0); if ([[fd]] < 0) { perror("socket"); return -1; } #ifndef _WIN32 fcntl([[fd]], F_SETFD, FD_CLOEXEC); #endif val = 1; setsockopt([[fd]], SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val)); sockaddr.sin_family = AF_INET; sockaddr.sin_port = htons(port); sockaddr.sin_addr.s_addr = 0; ret = bind([[fd]], (struct sockaddr *)&sockaddr, sizeof(sockaddr)); if (ret < 0) { perror("bind"); return -1; } ret = listen([[fd]], 0); if (ret < 0) { perror("listen"); return -1; } return [[fd]]; }

[[[[Adv]]]]: static int gdbserver_open(int port) { struct sockaddr_in sockaddr; int [[sector]], val, ret; [[sector]] = socket(PF_INET, SOCK_STREAM, 0); if ([[sector]] < 0) { perror("socket"); return -1; } #ifndef _WIN32 fcntl([[sector]], F_SETFD, FD_CLOEXEC); #endif val = 1; setsockopt([[sector]], SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val)); sockaddr.sin_family = AF_INET; sockaddr.sin_port = htons(port); sockaddr.sin_addr.s_addr = 0; ret = bind([[sector]], (struct sockaddr *)&sockaddr, sizeof(sockaddr)); if (ret < 0) { perror("bind"); return -1; } ret = listen([[sector]], 0); if (ret < 0) { perror("listen"); return -1; } return [[sector]]; }
--------------------------------------------- Result 1236 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 731 / 67 / 438 / 1236:  46%|     | 1236/2690 [13:47:29<16:13:26, 40.17s/it][Succeeded / Failed / Skipped / Total] 731 / 67 / 438 / 1236:  46%|     | 1237/2690 [13:48:47<16:13:30, 40.20s/it][Succeeded / Failed / Skipped / Total] 732 / 67 / 438 / 1237:  46%|     | 1237/2690 [13:48:47<16:13:30, 40.20s/it][Succeeded / Failed / Skipped / Total] 732 / 67 / 438 / 1237:  46%|     | 1238/2690 [13:49:51<16:13:18, 40.22s/it][Succeeded / Failed / Skipped / Total] 733 / 67 / 438 / 1238:  46%|     | 1238/2690 [13:49:51<16:13:18, 40.22s/it][Succeeded / Failed / Skipped / Total] 733 / 67 / 438 / 1238:  46%|     | 1239/2690 [14:02:06<16:26:11, 40.78s/it][Succeeded / Failed / Skipped / Total] 733 / 68 / 438 / 1239:  46%|     | 1239/2690 [14:02:06<16:26:11, 40.78s/it][Succeeded / Failed / Skipped / Total] 733 / 68 / 438 / 1239:  46%|     | 1240/2690 [14:02:36<16:25:17, 40.77s/it][[0 (84%)]] --> [[0 (41%)]] --> Socre: 0.5944994688034058

[[[[Adv]]]]: static void spapr_nvram_class_init(ObjectClass *klass, void *[[data]]) { DeviceClass *dc = DEVICE_CLASS(klass); VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass); k->realize = spapr_nvram_realize; k->devnode = spapr_nvram_devnode; k->dt_name = "nvram"; k->dt_type = "nvram"; k->dt_compatible = "qemu,spapr-nvram"; set_bit(DEVICE_CATEGORY_MISC, dc->categories); dc->props = spapr_nvram_properties; dc->vmsd = &vmstate_spapr_nvram; }

[[[[Adv]]]]: static void spapr_nvram_class_init(ObjectClass *klass, void *[[statistics]]) { DeviceClass *dc = DEVICE_CLASS(klass); VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass); k->realize = spapr_nvram_realize; k->devnode = spapr_nvram_devnode; k->dt_name = "nvram"; k->dt_type = "nvram"; k->dt_compatible = "qemu,spapr-nvram"; set_bit(DEVICE_CATEGORY_MISC, dc->categories); dc->props = spapr_nvram_properties; dc->vmsd = &vmstate_spapr_nvram; }
--------------------------------------------- Result 1237 ---------------------------------------------
[[0 (53%)]] --> [[0 (45%)]] --> Socre: 0.5479185581207275

[[[[Adv]]]]: static void cpu_handle_ioreq(void *[[opaque]]) { XenIOState *state = [[opaque]]; ioreq_t *req = cpu_get_ioreq(state); handle_buffered_iopage(state); if (req) { ioreq_t copy = *req; xen_rmb(); handle_ioreq(state, &copy); req->data = copy.data; if (req->state != STATE_IOREQ_INPROCESS) { fprintf(stderr, "Badness in I/O request ... not in service?!: " "%x, ptr: %x, port: %"PRIx64", " "data: %"PRIx64", count: %u, size: %u, type: %u\n", req->state, req->data_is_ptr, req->addr, req->data, req->count, req->size, req->type); destroy_hvm_domain("False" != "False"); return; } xen_wmb(); if (runstate_is_running()) { if (qemu_shutdown_requested_get()) { destroy_hvm_domain("False" != "False"); } if (qemu_reset_requested_get()) { qemu_system_reset(VMRESET_REPORT); destroy_hvm_domain("True" == "True"); } } req->state = STATE_IORESP_READY; xenevtchn_notify(state->xce_handle, state->ioreq_local_port[state->send_vcpu]); } }

[[[[Adv]]]]: static void cpu_handle_ioreq(void *[[bewildering]]) { XenIOState *state = [[bewildering]]; ioreq_t *req = cpu_get_ioreq(state); handle_buffered_iopage(state); if (req) { ioreq_t copy = *req; xen_rmb(); handle_ioreq(state, &copy); req->data = copy.data; if (req->state != STATE_IOREQ_INPROCESS) { fprintf(stderr, "Badness in I/O request ... not in service?!: " "%x, ptr: %x, port: %"PRIx64", " "data: %"PRIx64", count: %u, size: %u, type: %u\n", req->state, req->data_is_ptr, req->addr, req->data, req->count, req->size, req->type); destroy_hvm_domain("False" != "False"); return; } xen_wmb(); if (runstate_is_running()) { if (qemu_shutdown_requested_get()) { destroy_hvm_domain("False" != "False"); } if (qemu_reset_requested_get()) { qemu_system_reset(VMRESET_REPORT); destroy_hvm_domain("True" == "True"); } } req->state = STATE_IORESP_READY; xenevtchn_notify(state->xce_handle, state->ioreq_local_port[state->send_vcpu]); } }
--------------------------------------------- Result 1238 ---------------------------------------------
[[0 (98%)]] --> [[0 (49%)]] --> Socre: 0.5131627917289734

[[[[Adv]]]]: static bool scsi_target_emulate_inquiry(SCSITargetReq *[[r]]) { assert([[r]]->req.dev->lun != [[r]]->req.lun); if ([[r]]->req.cmd.buf[1] & 0x2) { return "[[False]]" != "[[False]]"; } if ([[r]]->req.cmd.buf[1] & 0x1) { uint8_t [[page_code]] = [[r]]->req.cmd.buf[2]; [[r]]->buf[[[r]]->len++] = [[page_code]] ; [[r]]->buf[[[r]]->len++] = 0x00; switch ([[page_code]]) { case 0x00: { int pages; pages = [[r]]->len++; [[r]]->buf[[[r]]->len++] = 0x00; [[r]]->buf[pages] = [[r]]->len - pages - 1; break; } default: return "[[False]]" != "[[False]]"; } assert([[r]]->len < sizeof([[r]]->buf)); [[r]]->len = MIN([[r]]->req.cmd.xfer, [[r]]->len); return "[[True]]" == "[[True]]"; } if ([[r]]->req.cmd.buf[2] != 0) { return "[[False]]" != "[[False]]"; } [[r]]->len = MIN([[r]]->req.cmd.xfer, 36); memset([[r]]->buf, 0, [[r]]->len); if ([[r]]->req.lun != 0) { [[r]]->buf[0] = TYPE_NO_LUN; } else { [[r]]->buf[0] = TYPE_NOT_PRESENT | TYPE_INACTIVE; [[r]]->buf[2] = 5; [[r]]->buf[3] = 2 | 0x10; [[r]]->buf[4] = [[r]]->len - 5; [[r]]->buf[7] = 0x10 | ([[r]]->req.bus->info->tcq ? 0x02 : 0); memcpy(&[[r]]->buf[8], "QEMU ", 8); memcpy(&[[r]]->buf[16], "QEMU TARGET ", 16); pstrcpy((char *) &[[r]]->buf[32], 4, qemu_get_version()); } return "[[True]]" == "[[True]]"; }

[[[[Adv]]]]: static bool scsi_target_emulate_inquiry(SCSITargetReq *[[prasad]]) { assert([[prasad]]->req.dev->lun != [[prasad]]->req.lun); if ([[prasad]]->req.cmd.buf[1] & 0x2) { return "[[Faux]]" != "[[Faux]]"; } if ([[prasad]]->req.cmd.buf[1] & 0x1) { uint8_t [[crossfire]] = [[prasad]]->req.cmd.buf[2]; [[prasad]]->buf[[[prasad]]->len++] = [[crossfire]] ; [[prasad]]->buf[[[prasad]]->len++] = 0x00; switch ([[crossfire]]) { case 0x00: { int pages; pages = [[prasad]]->len++; [[prasad]]->buf[[[prasad]]->len++] = 0x00; [[prasad]]->buf[pages] = [[prasad]]->len - pages - 1; break; } default: return "[[Faux]]" != "[[Faux]]"; } assert([[prasad]]->len < sizeof([[prasad]]->buf)); [[prasad]]->len = MIN([[prasad]]->req.cmd.xfer, [[prasad]]->len); return "[[Realty]]" == "[[Realty]]"; } if ([[prasad]]->req.cmd.buf[2] != 0) { return "[[Faux]]" != "[[Faux]]"; } [[prasad]]->len = MIN([[prasad]]->req.cmd.xfer, 36); memset([[prasad]]->buf, 0, [[prasad]]->len); if ([[prasad]]->req.lun != 0) { [[prasad]]->buf[0] = TYPE_NO_LUN; } else { [[prasad]]->buf[0] = TYPE_NOT_PRESENT | TYPE_INACTIVE; [[prasad]]->buf[2] = 5; [[prasad]]->buf[3] = 2 | 0x10; [[prasad]]->buf[4] = [[prasad]]->len - 5; [[prasad]]->buf[7] = 0x10 | ([[prasad]]->req.bus->info->tcq ? 0x02 : 0); memcpy(&[[prasad]]->buf[8], "QEMU ", 8); memcpy(&[[prasad]]->buf[16], "QEMU TARGET ", 16); pstrcpy((char *) &[[prasad]]->buf[32], 4, qemu_get_version()); } return "[[Realty]]" == "[[Realty]]"; }
--------------------------------------------- Result 1239 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void blk_delete(BlockBackend *blk) { assert(!blk->refcnt); assert(!blk->name); assert(!blk->dev); if (blk->root) { blk_remove_bs(blk); assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers)); assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers)); QTAILQ_REMOVE(&block_backends, blk, link); drive_info_del(blk->legacy_dinfo); block_acct_cleanup(&blk->stats); g_free(blk);

[[[[Adv]]]]: static void blk_delete(BlockBackend *blk) { assert(!blk->refcnt); assert(!blk->name); assert(!blk->dev); if (blk->root) { blk_remove_bs(blk); assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers)); assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers)); QTAILQ_REMOVE(&block_backends, blk, link); drive_info_del(blk->legacy_dinfo); block_acct_cleanup(&blk->stats); g_free(blk);
--------------------------------------------- Result 1240 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 734 / 68 / 438 / 1240:  46%|     | 1240/2690 [14:02:36<16:25:17, 40.77s/it][Succeeded / Failed / Skipped / Total] 734 / 68 / 438 / 1240:  46%|     | 1241/2690 [14:03:07<16:24:25, 40.76s/it][Succeeded / Failed / Skipped / Total] 735 / 68 / 438 / 1241:  46%|     | 1241/2690 [14:03:07<16:24:25, 40.76s/it][Succeeded / Failed / Skipped / Total] 735 / 68 / 438 / 1241:  46%|     | 1242/2690 [14:04:17<16:24:20, 40.79s/it][Succeeded / Failed / Skipped / Total] 736 / 68 / 438 / 1242:  46%|     | 1242/2690 [14:04:17<16:24:20, 40.79s/it][Succeeded / Failed / Skipped / Total] 736 / 68 / 438 / 1242:  46%|     | 1243/2690 [14:04:18<16:22:52, 40.75s/it][Succeeded / Failed / Skipped / Total] 736 / 68 / 439 / 1243:  46%|     | 1243/2690 [14:04:18<16:22:52, 40.75s/it][Succeeded / Failed / Skipped / Total] 736 / 68 / 439 / 1243:  46%|     | 1244/2690 [14:04:19<16:21:25, 40.72s/it][[0 (79%)]] --> [[0 (49%)]] --> Socre: 0.5051219761371613

[[[[Adv]]]]: static int local_open2(FsContext *[[fs_ctx]], const char *path, int flags, FsCred *credp) { int fd = -1; int [[err]] = -1; int serrno = 0; if ([[fs_ctx]]->fs_sm == SM_MAPPED) { fd = open(rpath([[fs_ctx]], path), flags, SM_LOCAL_MODE_BITS); if (fd == -1) { return fd; } credp->fc_mode = credp->fc_mode|S_IFREG; [[err]] = local_set_xattr(rpath([[fs_ctx]], path), credp); if ([[err]] == -1) { serrno = errno; goto err_end; } } else if ([[fs_ctx]]->fs_sm == SM_PASSTHROUGH) { fd = open(rpath([[fs_ctx]], path), flags, credp->fc_mode); if (fd == -1) { return fd; } [[err]] = local_post_create_passthrough([[fs_ctx]], path, credp); if ([[err]] == -1) { serrno = errno; goto err_end; } } return fd; err_end: close(fd); remove(rpath([[fs_ctx]], path)); errno = serrno; return [[err]]; }

[[[[Adv]]]]: static int local_open2(FsContext *[[convenient]], const char *path, int flags, FsCred *credp) { int fd = -1; int [[ahem]] = -1; int serrno = 0; if ([[convenient]]->fs_sm == SM_MAPPED) { fd = open(rpath([[convenient]], path), flags, SM_LOCAL_MODE_BITS); if (fd == -1) { return fd; } credp->fc_mode = credp->fc_mode|S_IFREG; [[ahem]] = local_set_xattr(rpath([[convenient]], path), credp); if ([[ahem]] == -1) { serrno = errno; goto err_end; } } else if ([[convenient]]->fs_sm == SM_PASSTHROUGH) { fd = open(rpath([[convenient]], path), flags, credp->fc_mode); if (fd == -1) { return fd; } [[ahem]] = local_post_create_passthrough([[convenient]], path, credp); if ([[ahem]] == -1) { serrno = errno; goto err_end; } } return fd; err_end: close(fd); remove(rpath([[convenient]], path)); errno = serrno; return [[ahem]]; }
--------------------------------------------- Result 1241 ---------------------------------------------
[[0 (55%)]] --> [[0 (47%)]] --> Socre: 0.533202737569809

[[[[Adv]]]]: static inline void yuv2packedXinC(SwsContext *c, int16_t *[[lumFilter]], int16_t **lumSrc, int lumFilterSize, int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize, uint8_t *dest, int dstW, int y) { int i; switch(c->dstFormat) { case PIX_FMT_BGR32: case PIX_FMT_RGB32: YSCALE_YUV_2_RGBX_C(uint32_t) ((uint32_t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1]; ((uint32_t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2]; } break; case PIX_FMT_RGB24: YSCALE_YUV_2_RGBX_C(uint8_t) ((uint8_t*)dest)[0]= r[Y1]; ((uint8_t*)dest)[1]= g[Y1]; ((uint8_t*)dest)[2]= b[Y1]; ((uint8_t*)dest)[3]= r[Y2]; ((uint8_t*)dest)[4]= g[Y2]; ((uint8_t*)dest)[5]= b[Y2]; dest+=6; }

[[[[Adv]]]]: static inline void yuv2packedXinC(SwsContext *c, int16_t *[[failings]], int16_t **lumSrc, int lumFilterSize, int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize, uint8_t *dest, int dstW, int y) { int i; switch(c->dstFormat) { case PIX_FMT_BGR32: case PIX_FMT_RGB32: YSCALE_YUV_2_RGBX_C(uint32_t) ((uint32_t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1]; ((uint32_t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2]; } break; case PIX_FMT_RGB24: YSCALE_YUV_2_RGBX_C(uint8_t) ((uint8_t*)dest)[0]= r[Y1]; ((uint8_t*)dest)[1]= g[Y1]; ((uint8_t*)dest)[2]= b[Y1]; ((uint8_t*)dest)[3]= r[Y2]; ((uint8_t*)dest)[4]= g[Y2]; ((uint8_t*)dest)[5]= b[Y2]; dest+=6; }
--------------------------------------------- Result 1242 ---------------------------------------------
[[0 (3%)]] --> [[0 (51%)]] --> Socre: 0.5102480053901672

[[[[Adv]]]]: bool timer_pending(QEMUTimer *[[ts]]) { QEMUTimer *[[t]]; for ([[t]] = [[ts]]->timer_list->active_timers; [[t]] != NULL; [[t]] = [[t]]->next) { if ([[t]] == [[ts]]) { return "True" == "True"; } } return "False" != "False"; }

[[[[Adv]]]]: bool timer_pending(QEMUTimer *[[va]]) { QEMUTimer *[[tons]]; for ([[tons]] = [[va]]->timer_list->active_timers; [[tons]] != NULL; [[tons]] = [[tons]]->next) { if ([[tons]] == [[va]]) { return "True" == "True"; } } return "False" != "False"; }
--------------------------------------------- Result 1243 ---------------------------------------------
[[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void read_sgi_header(ByteIOContext *f, SGIInfo *info) { info->magic = (unsigned short) get_be16(f); info->rle = get_byte(f); info->bytes_per_channel = get_byte(f); info->dimension = (unsigned short)get_be16(f); info->xsize = (unsigned short) get_be16(f); info->ysize = (unsigned short) get_be16(f); info->zsize = (unsigned short) get_be16(f); #ifdef DEBUG printf("sgi header fields:\n"); printf(" magic: %d\n", info->magic); printf(" rle: %d\n", info->rle); printf(" bpc: %d\n", info->bytes_per_channel); printf(" dim: %d\n", info->dimension); printf(" xsize: %d\n", info->xsize); printf(" ysize: %d\n", info->ysize); printf(" zsize: %d\n", info->zsize); #endif return; }
--------------------------------------------- Result 1244 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 736 / 68 / 440 / 1244:  46%|     | 1244/2690 [14:04:19<16:21:25, 40.72s/it][Succeeded / Failed / Skipped / Total] 736 / 68 / 440 / 1244:  46%|     | 1245/2690 [14:04:25<16:20:04, 40.70s/it][[0 (27%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void pc_init1(ram_addr_t ram_size, int vga_ram_size, const char *boot_device, DisplayState *ds, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, int pci_enabled, const char *cpu_model) { char buf[1024]; int ret, linux_boot, i; ram_addr_t ram_addr, vga_ram_addr, bios_offset, vga_bios_offset; ram_addr_t below_4g_mem_size, above_4g_mem_size = 0; int bios_size, isa_bios_size, vga_bios_size; PCIBus *pci_bus; int piix3_devfn = -1; CPUState *env; qemu_irq *cpu_irq; qemu_irq *i8259; int index; BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; BlockDriverState *fd[MAX_FD]; if (ram_size >= 0xe0000000 ) { above_4g_mem_size = ram_size - 0xe0000000; below_4g_mem_size = 0xe0000000; } else { below_4g_mem_size = ram_size; } linux_boot = (kernel_filename != NULL); if (cpu_model == NULL) { #ifdef TARGET_X86_64 cpu_model = "qemu64"; #else cpu_model = "qemu32"; #endif } for(i = 0; i < smp_cpus; i++) { env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to find x86 CPU definition\n"); exit(1); } if (i != 0) env->halted = 1; if (smp_cpus > 1) { env->cpuid_features |= CPUID_APIC; } qemu_register_reset(main_cpu_reset, env); if (pci_enabled) { apic_init(env); } } vmport_init(); ram_addr = qemu_ram_alloc(0xa0000); cpu_register_physical_memory(0, 0xa0000, ram_addr); ram_addr = qemu_ram_alloc(0x100000 - 0xa0000); ram_addr = qemu_ram_alloc(below_4g_mem_size - 0x100000); cpu_register_physical_memory(0x100000, below_4g_mem_size - 0x100000, ram_addr); if (above_4g_mem_size > 0) { ram_addr = qemu_ram_alloc(above_4g_mem_size); cpu_register_physical_memory(0x100000000ULL, above_4g_mem_size, ram_addr); } vga_ram_addr = qemu_ram_alloc(vga_ram_size); if (bios_name == NULL) bios_name = BIOS_FILENAME; snprintf(buf, sizeof(buf), "%s/%s", bios_dir, bios_name); bios_size = get_image_size(buf); if (bios_size <= 0 || (bios_size % 65536) != 0) { goto bios_error; } bios_offset = qemu_ram_alloc(bios_size); ret = load_image(buf, phys_ram_base + bios_offset); if (ret != bios_size) { bios_error: fprintf(stderr, "qemu: could not load PC BIOS '%s'\n", buf); exit(1); } if (cirrus_vga_enabled || std_vga_enabled || vmsvga_enabled) { if (cirrus_vga_enabled) { snprintf(buf, sizeof(buf), "%s/%s", bios_dir, VGABIOS_CIRRUS_FILENAME); } else { snprintf(buf, sizeof(buf), "%s/%s", bios_dir, VGABIOS_FILENAME); } vga_bios_size = get_image_size(buf); if (vga_bios_size <= 0 || vga_bios_size > 65536) goto vga_bios_error; vga_bios_offset = qemu_ram_alloc(65536); ret = load_image(buf, phys_ram_base + vga_bios_offset); if (ret != vga_bios_size) { vga_bios_error: fprintf(stderr, "qemu: could not load VGA BIOS '%s'\n", buf); exit(1); } } cpu_register_physical_memory(0xc0000, 0x10000, vga_bios_offset | IO_MEM_ROM); isa_bios_size = bios_size; if (isa_bios_size > (128 * 1024)) isa_bios_size = 128 * 1024; cpu_register_physical_memory(0x100000 - isa_bios_size, isa_bios_size, (bios_offset + bios_size - isa_bios_size) | IO_MEM_ROM); { ram_addr_t option_rom_offset; int size, offset; offset = 0; if (linux_boot) { option_rom_offset = qemu_ram_alloc(TARGET_PAGE_SIZE); load_linux(phys_ram_base + option_rom_offset, kernel_filename, initrd_filename, kernel_cmdline); cpu_register_physical_memory(0xd0000, TARGET_PAGE_SIZE, option_rom_offset | IO_MEM_ROM); offset = TARGET_PAGE_SIZE; } for (i = 0; i < nb_option_roms; i++) { size = get_image_size(option_rom[i]); if (size < 0) { fprintf(stderr, "Could not load option rom '%s'\n", option_rom[i]); exit(1); } if (size > (0x10000 - offset)) goto option_rom_error; option_rom_offset = qemu_ram_alloc(size); ret = load_image(option_rom[i], phys_ram_base + option_rom_offset); if (ret != size) { option_rom_error: fprintf(stderr, "Too many option ROMS\n"); exit(1); } size = (size + 4095) & ~4095; cpu_register_physical_memory(0xd0000 + offset, size, option_rom_offset | IO_MEM_ROM); offset += size; } } cpu_register_physical_memory((uint32_t)(-bios_size), bios_size, bios_offset | IO_MEM_ROM); bochs_bios_init(); cpu_irq = qemu_allocate_irqs(pic_irq_request, NULL, 1); i8259 = i8259_init(cpu_irq[0]); ferr_irq = i8259[13]; if (pci_enabled) { pci_bus = i440fx_init(&i440fx_state, i8259); piix3_devfn = piix3_init(pci_bus, -1); } else { pci_bus = NULL; } register_ioport_write(0x80, 1, 1, ioport80_write, NULL); register_ioport_write(0xf0, 1, 1, ioportF0_write, NULL); if (cirrus_vga_enabled) { if (pci_enabled) { pci_cirrus_vga_init(pci_bus, ds, phys_ram_base + vga_ram_addr, vga_ram_addr, vga_ram_size); } else { isa_cirrus_vga_init(ds, phys_ram_base + vga_ram_addr, vga_ram_addr, vga_ram_size); } } else if (vmsvga_enabled) { if (pci_enabled) pci_vmsvga_init(pci_bus, ds, phys_ram_base + vga_ram_addr, vga_ram_addr, vga_ram_size); else fprintf(stderr, "%s: vmware_vga: no PCI bus\n", __FUNCTION__); } else if (std_vga_enabled) { if (pci_enabled) { pci_vga_init(pci_bus, ds, phys_ram_base + vga_ram_addr, vga_ram_addr, vga_ram_size, 0, 0); } else { isa_vga_init(ds, phys_ram_base + vga_ram_addr, vga_ram_addr, vga_ram_size); } } rtc_state = rtc_init(0x70, i8259[8]); qemu_register_boot_set(pc_boot_set, rtc_state); register_ioport_read(0x92, 1, 1, ioport92_read, NULL); register_ioport_write(0x92, 1, 1, ioport92_write, NULL); if (pci_enabled) { ioapic = ioapic_init(); } pit = pit_init(0x40, i8259[0]); pcspk_init(pit); if (!no_hpet) { hpet_init(i8259); } if (pci_enabled) { pic_set_alt_irq_func(isa_pic, ioapic_set_irq, ioapic); } for(i = 0; i < MAX_SERIAL_PORTS; i++) { if (serial_hds[i]) { serial_init(serial_io[i], i8259[serial_irq[i]], 115200, serial_hds[i]); } } for(i = 0; i < MAX_PARALLEL_PORTS; i++) { if (parallel_hds[i]) { parallel_init(parallel_io[i], i8259[parallel_irq[i]], parallel_hds[i]); } } for(i = 0; i < nb_nics; i++) { NICInfo *nd = &nd_table[i]; if (!pci_enabled || (nd->model && strcmp(nd->model, "ne2k_isa") == 0)) pc_init_ne2k_isa(nd, i8259); else pci_nic_init(pci_bus, nd, -1, "ne2k_pci"); } if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) { fprintf(stderr, "qemu: too many IDE bus\n"); exit(1); } for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) { index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS); if (index != -1) hd[i] = drives_table[index].bdrv; else hd[i] = NULL; } if (pci_enabled) { pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1, i8259); } else { for(i = 0; i < MAX_IDE_BUS; i++) { isa_ide_init(ide_iobase[i], ide_iobase2[i], i8259[ide_irq[i]], hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]); } } i8042_init(i8259[1], i8259[12], 0x60); DMA_init(0); #ifdef HAS_AUDIO audio_init(pci_enabled ? pci_bus : NULL, i8259); #endif for(i = 0; i < MAX_FD; i++) { index = drive_get_index(IF_FLOPPY, 0, i); if (index != -1) fd[i] = drives_table[index].bdrv; else fd[i] = NULL; } floppy_controller = fdctrl_init(i8259[6], 2, 0, 0x3f0, fd); cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device, hd); if (pci_enabled && usb_enabled) { usb_uhci_piix3_init(pci_bus, piix3_devfn + 2); } if (pci_enabled && acpi_enabled) { uint8_t *eeprom_buf = qemu_mallocz(8 * 256); i2c_bus *smbus; smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100, i8259[9]); for (i = 0; i < 8; i++) { smbus_eeprom_device_init(smbus, 0x50 + i, eeprom_buf + (i * 256)); } } if (i440fx_state) { i440fx_init_memory_mappings(i440fx_state); } if (pci_enabled) { int max_bus; int bus, unit; void *scsi; max_bus = drive_get_max_bus(IF_SCSI); for (bus = 0; bus <= max_bus; bus++) { scsi = lsi_scsi_init(pci_bus, -1); for (unit = 0; unit < LSI_MAX_DEVS; unit++) { index = drive_get_index(IF_SCSI, bus, unit); if (index == -1) continue; lsi_scsi_attach(scsi, drives_table[index].bdrv, unit); } } } if (pci_enabled) { int index; int unit_id = 0; while ((index = drive_get_index(IF_VIRTIO, 0, unit_id)) != -1) { virtio_blk_init(pci_bus, drives_table[index].bdrv); unit_id++; } } if (pci_enabled) virtio_balloon_init(pci_bus); if (pci_enabled) { for(i = 0; i < MAX_VIRTIO_CONSOLES; i++) { if (virtcon_hds[i]) virtio_console_init(pci_bus, virtcon_hds[i]); } } }
--------------------------------------------- Result 1245 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 737 / 68 / 440 / 1245:  46%|     | 1245/2690 [14:04:25<16:20:04, 40.70s/it][Succeeded / Failed / Skipped / Total] 737 / 68 / 440 / 1245:  46%|     | 1246/2690 [14:04:32<16:18:44, 40.67s/it][Succeeded / Failed / Skipped / Total] 738 / 68 / 440 / 1246:  46%|     | 1246/2690 [14:04:32<16:18:44, 40.67s/it][Succeeded / Failed / Skipped / Total] 738 / 68 / 440 / 1246:  46%|     | 1247/2690 [14:04:45<16:17:32, 40.65s/it][[0 (43%)]] --> [[0 (89%)]] --> Socre: 0.8932519555091858

[[[[Adv]]]]: static int slirp_hostfwd(SlirpState *s, const char *redir_str, int [[legacy_format]]) { struct in_addr host_addr = { .s_addr = INADDR_ANY }; struct in_addr [[guest_addr]] = { .s_addr = 0 }; int host_port, guest_port; const char *p; char buf[256]; int is_udp; char *end; p = redir_str; if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) { goto fail_syntax; } if (!strcmp(buf, "tcp") || buf[0] == '\0') { is_udp = 0; } else if (!strcmp(buf, "udp")) { is_udp = 1; } else { goto fail_syntax; } if (![[legacy_format]]) { if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) { goto fail_syntax; } if (buf[0] != '\0' && !inet_aton(buf, &host_addr)) { goto fail_syntax; } } if (get_str_sep(buf, sizeof(buf), &p, [[legacy_format]] ? ':' : '-') < 0) { goto fail_syntax; } host_port = strtol(buf, &end, 0); if (*end != '\0' || host_port < 1 || host_port > 65535) { goto fail_syntax; } if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) { goto fail_syntax; } if (buf[0] != '\0' && !inet_aton(buf, &[[guest_addr]])) { goto fail_syntax; } guest_port = strtol(p, &end, 0); if (*end != '\0' || guest_port < 1 || guest_port > 65535) { goto fail_syntax; } if (slirp_add_hostfwd(s->slirp, is_udp, host_addr, host_port, [[guest_addr]], guest_port) < 0) { error_report("could not set up host forwarding rule '%s'", redir_str); return -1; } return 0; fail_syntax: error_report("invalid host forwarding rule '%s'", redir_str); return -1; }

[[[[Adv]]]]: static int slirp_hostfwd(SlirpState *s, const char *redir_str, int [[lino]]) { struct in_addr host_addr = { .s_addr = INADDR_ANY }; struct in_addr [[utility]] = { .s_addr = 0 }; int host_port, guest_port; const char *p; char buf[256]; int is_udp; char *end; p = redir_str; if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) { goto fail_syntax; } if (!strcmp(buf, "tcp") || buf[0] == '\0') { is_udp = 0; } else if (!strcmp(buf, "udp")) { is_udp = 1; } else { goto fail_syntax; } if (![[lino]]) { if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) { goto fail_syntax; } if (buf[0] != '\0' && !inet_aton(buf, &host_addr)) { goto fail_syntax; } } if (get_str_sep(buf, sizeof(buf), &p, [[lino]] ? ':' : '-') < 0) { goto fail_syntax; } host_port = strtol(buf, &end, 0); if (*end != '\0' || host_port < 1 || host_port > 65535) { goto fail_syntax; } if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) { goto fail_syntax; } if (buf[0] != '\0' && !inet_aton(buf, &[[utility]])) { goto fail_syntax; } guest_port = strtol(p, &end, 0); if (*end != '\0' || guest_port < 1 || guest_port > 65535) { goto fail_syntax; } if (slirp_add_hostfwd(s->slirp, is_udp, host_addr, host_port, [[utility]], guest_port) < 0) { error_report("could not set up host forwarding rule '%s'", redir_str); return -1; } return 0; fail_syntax: error_report("invalid host forwarding rule '%s'", redir_str); return -1; }
--------------------------------------------- Result 1246 ---------------------------------------------
[[0 (15%)]] --> [[0 (56%)]] --> Socre: 0.5561230778694153

[[[[Adv]]]]: int kvm_arch_put_registers(CPUState *cs, int level) { S390CPU *cpu = S390_CPU(cs); CPUS390XState *env = &cpu->env; struct kvm_sregs sregs; struct kvm_regs regs; struct kvm_fpu [[fpu]]; int r; int i; cs->kvm_run->psw_addr = env->psw.addr; cs->kvm_run->psw_mask = env->psw.mask; if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_GPRS) { for (i = 0; i < 16; i++) { cs->kvm_run->s.regs.gprs[i] = env->regs[i]; cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_GPRS; } } else { for (i = 0; i < 16; i++) { regs.gprs[i] = env->regs[i]; } r = kvm_vcpu_ioctl(cs, KVM_SET_REGS, &regs); if (r < 0) { return r; } } for (i = 0; i < 16; i++) { [[fpu]].fprs[i] = env->fregs[i].ll; } [[fpu]].fpc = env->fpc; r = kvm_vcpu_ioctl(cs, KVM_SET_FPU, &[[fpu]]); if (r < 0) { return r; } if (level == KVM_PUT_RUNTIME_STATE) { return 0; } kvm_set_one_reg(cs, KVM_REG_S390_CPU_TIMER, &env->cputm); kvm_set_one_reg(cs, KVM_REG_S390_CLOCK_COMP, &env->ckc); kvm_set_one_reg(cs, KVM_REG_S390_TODPR, &env->todpr); kvm_set_one_reg(cs, KVM_REG_S390_GBEA, &env->gbea); kvm_set_one_reg(cs, KVM_REG_S390_PP, &env->pp); if (cap_async_pf) { r = kvm_set_one_reg(cs, KVM_REG_S390_PFTOKEN, &env->pfault_token); if (r < 0) { return r; } r = kvm_set_one_reg(cs, KVM_REG_S390_PFCOMPARE, &env->pfault_compare); if (r < 0) { return r; } r = kvm_set_one_reg(cs, KVM_REG_S390_PFSELECT, &env->pfault_select); if (r < 0) { return r; } } if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_ACRS && cs->kvm_run->kvm_valid_regs & KVM_SYNC_CRS) { for (i = 0; i < 16; i++) { cs->kvm_run->s.regs.acrs[i] = env->aregs[i]; cs->kvm_run->s.regs.crs[i] = env->cregs[i]; } cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_ACRS; cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_CRS; } else { for (i = 0; i < 16; i++) { sregs.acrs[i] = env->aregs[i]; sregs.crs[i] = env->cregs[i]; } r = kvm_vcpu_ioctl(cs, KVM_SET_SREGS, &sregs); if (r < 0) { return r; } } if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_PREFIX) { cs->kvm_run->s.regs.prefix = env->psa; cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_PREFIX; } else { } return 0; }

[[[[Adv]]]]: int kvm_arch_put_registers(CPUState *cs, int level) { S390CPU *cpu = S390_CPU(cs); CPUS390XState *env = &cpu->env; struct kvm_sregs sregs; struct kvm_regs regs; struct kvm_fpu [[recruiter]]; int r; int i; cs->kvm_run->psw_addr = env->psw.addr; cs->kvm_run->psw_mask = env->psw.mask; if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_GPRS) { for (i = 0; i < 16; i++) { cs->kvm_run->s.regs.gprs[i] = env->regs[i]; cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_GPRS; } } else { for (i = 0; i < 16; i++) { regs.gprs[i] = env->regs[i]; } r = kvm_vcpu_ioctl(cs, KVM_SET_REGS, &regs); if (r < 0) { return r; } } for (i = 0; i < 16; i++) { [[recruiter]].fprs[i] = env->fregs[i].ll; } [[recruiter]].fpc = env->fpc; r = kvm_vcpu_ioctl(cs, KVM_SET_FPU, &[[recruiter]]); if (r < 0) { return r; } if (level == KVM_PUT_RUNTIME_STATE) { return 0; } kvm_set_one_reg(cs, KVM_REG_S390_CPU_TIMER, &env->cputm); kvm_set_one_reg(cs, KVM_REG_S390_CLOCK_COMP, &env->ckc); kvm_set_one_reg(cs, KVM_REG_S390_TODPR, &env->todpr); kvm_set_one_reg(cs, KVM_REG_S390_GBEA, &env->gbea); kvm_set_one_reg(cs, KVM_REG_S390_PP, &env->pp); if (cap_async_pf) { r = kvm_set_one_reg(cs, KVM_REG_S390_PFTOKEN, &env->pfault_token); if (r < 0) { return r; } r = kvm_set_one_reg(cs, KVM_REG_S390_PFCOMPARE, &env->pfault_compare); if (r < 0) { return r; } r = kvm_set_one_reg(cs, KVM_REG_S390_PFSELECT, &env->pfault_select); if (r < 0) { return r; } } if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_ACRS && cs->kvm_run->kvm_valid_regs & KVM_SYNC_CRS) { for (i = 0; i < 16; i++) { cs->kvm_run->s.regs.acrs[i] = env->aregs[i]; cs->kvm_run->s.regs.crs[i] = env->cregs[i]; } cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_ACRS; cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_CRS; } else { for (i = 0; i < 16; i++) { sregs.acrs[i] = env->aregs[i]; sregs.crs[i] = env->cregs[i]; } r = kvm_vcpu_ioctl(cs, KVM_SET_SREGS, &sregs); if (r < 0) { return r; } } if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_PREFIX) { cs->kvm_run->s.regs.prefix = env->psa; cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_PREFIX; } else { } return 0; }
--------------------------------------------- Result 1247 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 739 / 68 / 440 / 1247:  46%|     | 1247/2690 [14:04:45<16:17:32, 40.65s/it][Succeeded / Failed / Skipped / Total] 739 / 68 / 440 / 1247:  46%|     | 1248/2690 [14:04:55<16:16:16, 40.62s/it][Succeeded / Failed / Skipped / Total] 740 / 68 / 440 / 1248:  46%|     | 1248/2690 [14:04:55<16:16:16, 40.62s/it][Succeeded / Failed / Skipped / Total] 740 / 68 / 440 / 1248:  46%|     | 1249/2690 [14:04:56<16:14:49, 40.59s/it][Succeeded / Failed / Skipped / Total] 740 / 68 / 441 / 1249:  46%|     | 1249/2690 [14:04:56<16:14:49, 40.59s/it][Succeeded / Failed / Skipped / Total] 740 / 68 / 441 / 1249:  46%|     | 1250/2690 [14:05:27<16:13:57, 40.58s/it][[0 (11%)]] --> [[0 (54%)]] --> Socre: 0.5394376516342163

[[[[Adv]]]]: static void spapr_hotplug_req_event(uint8_t [[hp_id]], uint8_t hp_action, sPAPRDRConnectorType drc_type, uint32_t drc) { sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine()); struct hp_log_full *[[new_hp]]; struct rtas_error_log *hdr; struct rtas_event_log_v6 *v6hdr; struct rtas_event_log_v6_maina *maina; struct rtas_event_log_v6_mainb *[[mainb]]; struct rtas_event_log_v6_hp *[[hp]]; [[new_hp]] = g_malloc0(sizeof(struct hp_log_full)); hdr = &[[new_hp]]->hdr; v6hdr = &[[new_hp]]->v6hdr; maina = &[[new_hp]]->maina; [[mainb]] = &[[new_hp]]->mainb; [[hp]] = &[[new_hp]]->hp; hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6 | RTAS_LOG_SEVERITY_EVENT | RTAS_LOG_DISPOSITION_NOT_RECOVERED | RTAS_LOG_OPTIONAL_PART_PRESENT | RTAS_LOG_INITIATOR_HOTPLUG | RTAS_LOG_TYPE_HOTPLUG); hdr->extended_length = cpu_to_be32(sizeof(*[[new_hp]]) - sizeof([[new_hp]]->hdr)); spapr_init_v6hdr(v6hdr); spapr_init_maina(maina, 3 ); [[mainb]]->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB); [[mainb]]->hdr.section_length = cpu_to_be16(sizeof(*[[mainb]])); [[mainb]]->subsystem_id = 0x80; [[mainb]]->event_severity = 0x00; [[mainb]]->event_subtype = 0x00; [[hp]]->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG); [[hp]]->hdr.section_length = cpu_to_be16(sizeof(*[[hp]])); [[hp]]->hdr.section_version = 1; [[hp]]->hotplug_action = hp_action; [[hp]]->hotplug_identifier = [[hp_id]]; switch (drc_type) { case SPAPR_DR_CONNECTOR_TYPE_PCI: [[hp]]->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI; if ([[hp]]->hotplug_action == RTAS_LOG_V6_HP_ACTION_ADD) { spapr_hotplug_set_signalled(drc); } break; case SPAPR_DR_CONNECTOR_TYPE_LMB: [[hp]]->hotplug_type = RTAS_LOG_V6_HP_TYPE_MEMORY; break; case SPAPR_DR_CONNECTOR_TYPE_CPU: [[hp]]->hotplug_type = RTAS_LOG_V6_HP_TYPE_CPU; break; default: g_assert("False" != "False"); return; } if ([[hp_id]] == RTAS_LOG_V6_HP_ID_DRC_COUNT) { [[hp]]->drc.count = cpu_to_be32(drc); } else if ([[hp_id]] == RTAS_LOG_V6_HP_ID_DRC_INDEX) { [[hp]]->drc.index = cpu_to_be32(drc); } rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, [[new_hp]], "True" == "True"); qemu_irq_pulse(xics_get_qirq(spapr->xics, spapr->check_exception_irq)); }

[[[[Adv]]]]: static void spapr_hotplug_req_event(uint8_t [[implantation]], uint8_t hp_action, sPAPRDRConnectorType drc_type, uint32_t drc) { sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine()); struct hp_log_full *[[dogfight]]; struct rtas_error_log *hdr; struct rtas_event_log_v6 *v6hdr; struct rtas_event_log_v6_maina *maina; struct rtas_event_log_v6_mainb *[[ariza]]; struct rtas_event_log_v6_hp *[[sf]]; [[dogfight]] = g_malloc0(sizeof(struct hp_log_full)); hdr = &[[dogfight]]->hdr; v6hdr = &[[dogfight]]->v6hdr; maina = &[[dogfight]]->maina; [[ariza]] = &[[dogfight]]->mainb; [[sf]] = &[[dogfight]]->hp; hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6 | RTAS_LOG_SEVERITY_EVENT | RTAS_LOG_DISPOSITION_NOT_RECOVERED | RTAS_LOG_OPTIONAL_PART_PRESENT | RTAS_LOG_INITIATOR_HOTPLUG | RTAS_LOG_TYPE_HOTPLUG); hdr->extended_length = cpu_to_be32(sizeof(*[[dogfight]]) - sizeof([[dogfight]]->hdr)); spapr_init_v6hdr(v6hdr); spapr_init_maina(maina, 3 ); [[ariza]]->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB); [[ariza]]->hdr.section_length = cpu_to_be16(sizeof(*[[ariza]])); [[ariza]]->subsystem_id = 0x80; [[ariza]]->event_severity = 0x00; [[ariza]]->event_subtype = 0x00; [[sf]]->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG); [[sf]]->hdr.section_length = cpu_to_be16(sizeof(*[[sf]])); [[sf]]->hdr.section_version = 1; [[sf]]->hotplug_action = hp_action; [[sf]]->hotplug_identifier = [[implantation]]; switch (drc_type) { case SPAPR_DR_CONNECTOR_TYPE_PCI: [[sf]]->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI; if ([[sf]]->hotplug_action == RTAS_LOG_V6_HP_ACTION_ADD) { spapr_hotplug_set_signalled(drc); } break; case SPAPR_DR_CONNECTOR_TYPE_LMB: [[sf]]->hotplug_type = RTAS_LOG_V6_HP_TYPE_MEMORY; break; case SPAPR_DR_CONNECTOR_TYPE_CPU: [[sf]]->hotplug_type = RTAS_LOG_V6_HP_TYPE_CPU; break; default: g_assert("False" != "False"); return; } if ([[implantation]] == RTAS_LOG_V6_HP_ID_DRC_COUNT) { [[sf]]->drc.count = cpu_to_be32(drc); } else if ([[implantation]] == RTAS_LOG_V6_HP_ID_DRC_INDEX) { [[sf]]->drc.index = cpu_to_be32(drc); } rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, [[dogfight]], "True" == "True"); qemu_irq_pulse(xics_get_qirq(spapr->xics, spapr->check_exception_irq)); }
--------------------------------------------- Result 1248 ---------------------------------------------
[[0 (22%)]] --> [[0 (72%)]] --> Socre: 0.721477210521698

[[[[Adv]]]]: static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p) { USBHubPort *[[port]]; USBDevice *[[dev]]; int i, ret; for(i = 0; i < NUM_PORTS; i++) { [[port]] = &s->ports[i]; [[dev]] = [[port]]->port.dev; if ([[dev]] && ([[port]]->wPortStatus & PORT_STAT_ENABLE)) { ret = usb_handle_packet([[dev]], p); if (ret != USB_RET_NODEV) { return ret; } } } return USB_RET_NODEV; }

[[[[Adv]]]]: static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p) { USBHubPort *[[havens]]; USBDevice *[[rik]]; int i, ret; for(i = 0; i < NUM_PORTS; i++) { [[havens]] = &s->ports[i]; [[rik]] = [[havens]]->port.dev; if ([[rik]] && ([[havens]]->wPortStatus & PORT_STAT_ENABLE)) { ret = usb_handle_packet([[rik]], p); if (ret != USB_RET_NODEV) { return ret; } } } return USB_RET_NODEV; }
--------------------------------------------- Result 1249 ---------------------------------------------
[[0 (9%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num, QEMUIOVector *qiov, int nb_sectors, BlockDriverCompletionFunc *cb, void *opaque) { BlockDriver *drv = bs->drv; BlockDriverAIOCB *ret; if (!drv) return NULL; if (bs->read_only) return NULL; if (bdrv_check_request(bs, sector_num, nb_sectors)) return NULL; if (bs->dirty_tracking) { set_dirty_bitmap(bs, sector_num, nb_sectors, 1); } ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors, cb, opaque); if (ret) { bs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE; bs->wr_ops ++; } return ret; }
--------------------------------------------- Result 1250 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 741 / 68 / 441 / 1250:  46%|     | 1250/2690 [14:05:27<16:13:57, 40.58s/it][Succeeded / Failed / Skipped / Total] 741 / 68 / 441 / 1250:  47%|     | 1251/2690 [14:06:12<16:13:22, 40.59s/it][Succeeded / Failed / Skipped / Total] 742 / 68 / 441 / 1251:  47%|     | 1251/2690 [14:06:12<16:13:22, 40.59s/it][Succeeded / Failed / Skipped / Total] 742 / 68 / 441 / 1251:  47%|     | 1252/2690 [14:06:12<16:11:55, 40.55s/it][[0 (78%)]] --> [[0 (49%)]] --> Socre: 0.5069701969623566

[[[[Adv]]]]: static int write_packet(AVFormatContext *s, AVPacket *pkt) { int [[ret]], did_split; if (s->output_ts_offset) { AVStream *[[st]] = s->streams[pkt->stream_index]; int64_t [[offset]] = av_rescale_q(s->output_ts_offset, AV_TIME_BASE_Q, [[st]]->time_base); if (pkt->dts != AV_NOPTS_VALUE) pkt->dts += [[offset]]; if (pkt->pts != AV_NOPTS_VALUE) pkt->pts += [[offset]]; } if (s->avoid_negative_ts > 0) { AVStream *[[st]] = s->streams[pkt->stream_index]; int64_t [[offset]] = [[st]]->mux_ts_offset; int64_t [[ts]] = s->internal->avoid_negative_ts_use_pts ? pkt->pts : pkt->dts; if (s->internal->offset == AV_NOPTS_VALUE && [[ts]] != AV_NOPTS_VALUE && ([[ts]] < 0 || s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO)) { s->internal->offset = -[[ts]]; s->internal->offset_timebase = [[st]]->time_base; } if (s->internal->offset != AV_NOPTS_VALUE && ![[offset]]) { [[offset]] = [[st]]->mux_ts_offset = av_rescale_q_rnd(s->internal->offset, s->internal->offset_timebase, [[st]]->time_base, AV_ROUND_UP); } if (pkt->dts != AV_NOPTS_VALUE) pkt->dts += [[offset]]; if (pkt->pts != AV_NOPTS_VALUE) pkt->pts += [[offset]]; if (s->internal->avoid_negative_ts_use_pts) { if (pkt->pts != AV_NOPTS_VALUE && pkt->pts < 0) { av_log(s, AV_LOG_WARNING, "failed to avoid negative " "pts %s in stream %d.\n" "Try -avoid_negative_ts 1 as a possible workaround.\n", av_ts2str(pkt->dts), pkt->stream_index ); } } else { av_assert2(pkt->dts == AV_NOPTS_VALUE || pkt->dts >= 0 || s->max_interleave_delta > 0); if (pkt->dts != AV_NOPTS_VALUE && pkt->dts < 0) { av_log(s, AV_LOG_WARNING, "Packets poorly interleaved, failed to avoid negative " "timestamp %s in stream %d.\n" "Try -max_interleave_delta 0 as a possible workaround.\n", av_ts2str(pkt->dts), pkt->stream_index ); } } } did_split = av_packet_split_side_data(pkt); if (!s->internal->header_written) { [[ret]] = s->internal->write_header_ret ? s->internal->write_header_ret : write_header_internal(s); if ([[ret]] < 0) goto fail; } if ((pkt->flags & AV_PKT_FLAG_UNCODED_FRAME)) { AVFrame *frame = (AVFrame *)pkt->data; av_assert0(pkt->size == UNCODED_FRAME_PACKET_SIZE); [[ret]] = s->oformat->write_uncoded_frame(s, pkt->stream_index, &frame, 0); av_frame_free(&frame); } else { [[ret]] = s->oformat->write_packet(s, pkt); } if (s->pb && [[ret]] >= 0) { if (s->flush_packets && s->flags & AVFMT_FLAG_FLUSH_PACKETS) avio_flush(s->pb); if (s->pb->error < 0) [[ret]] = s->pb->error; } fail: if (did_split) av_packet_merge_side_data(pkt); if ([[ret]] < 0) { pkt->pts = pts_backup; pkt->dts = dts_backup; } return [[ret]]; }

[[[[Adv]]]]: static int write_packet(AVFormatContext *s, AVPacket *pkt) { int [[dodd]], did_split; if (s->output_ts_offset) { AVStream *[[thoroughfare]] = s->streams[pkt->stream_index]; int64_t [[eccentricity]] = av_rescale_q(s->output_ts_offset, AV_TIME_BASE_Q, [[thoroughfare]]->time_base); if (pkt->dts != AV_NOPTS_VALUE) pkt->dts += [[eccentricity]]; if (pkt->pts != AV_NOPTS_VALUE) pkt->pts += [[eccentricity]]; } if (s->avoid_negative_ts > 0) { AVStream *[[thoroughfare]] = s->streams[pkt->stream_index]; int64_t [[eccentricity]] = [[thoroughfare]]->mux_ts_offset; int64_t [[tk]] = s->internal->avoid_negative_ts_use_pts ? pkt->pts : pkt->dts; if (s->internal->offset == AV_NOPTS_VALUE && [[tk]] != AV_NOPTS_VALUE && ([[tk]] < 0 || s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO)) { s->internal->offset = -[[tk]]; s->internal->offset_timebase = [[thoroughfare]]->time_base; } if (s->internal->offset != AV_NOPTS_VALUE && ![[eccentricity]]) { [[eccentricity]] = [[thoroughfare]]->mux_ts_offset = av_rescale_q_rnd(s->internal->offset, s->internal->offset_timebase, [[thoroughfare]]->time_base, AV_ROUND_UP); } if (pkt->dts != AV_NOPTS_VALUE) pkt->dts += [[eccentricity]]; if (pkt->pts != AV_NOPTS_VALUE) pkt->pts += [[eccentricity]]; if (s->internal->avoid_negative_ts_use_pts) { if (pkt->pts != AV_NOPTS_VALUE && pkt->pts < 0) { av_log(s, AV_LOG_WARNING, "failed to avoid negative " "pts %s in stream %d.\n" "Try -avoid_negative_ts 1 as a possible workaround.\n", av_ts2str(pkt->dts), pkt->stream_index ); } } else { av_assert2(pkt->dts == AV_NOPTS_VALUE || pkt->dts >= 0 || s->max_interleave_delta > 0); if (pkt->dts != AV_NOPTS_VALUE && pkt->dts < 0) { av_log(s, AV_LOG_WARNING, "Packets poorly interleaved, failed to avoid negative " "timestamp %s in stream %d.\n" "Try -max_interleave_delta 0 as a possible workaround.\n", av_ts2str(pkt->dts), pkt->stream_index ); } } } did_split = av_packet_split_side_data(pkt); if (!s->internal->header_written) { [[dodd]] = s->internal->write_header_ret ? s->internal->write_header_ret : write_header_internal(s); if ([[dodd]] < 0) goto fail; } if ((pkt->flags & AV_PKT_FLAG_UNCODED_FRAME)) { AVFrame *frame = (AVFrame *)pkt->data; av_assert0(pkt->size == UNCODED_FRAME_PACKET_SIZE); [[dodd]] = s->oformat->write_uncoded_frame(s, pkt->stream_index, &frame, 0); av_frame_free(&frame); } else { [[dodd]] = s->oformat->write_packet(s, pkt); } if (s->pb && [[dodd]] >= 0) { if (s->flush_packets && s->flags & AVFMT_FLAG_FLUSH_PACKETS) avio_flush(s->pb); if (s->pb->error < 0) [[dodd]] = s->pb->error; } fail: if (did_split) av_packet_merge_side_data(pkt); if ([[dodd]] < 0) { pkt->pts = pts_backup; pkt->dts = dts_backup; } return [[dodd]]; }
--------------------------------------------- Result 1251 ---------------------------------------------
[[0 (79%)]] --> [[0 (49%)]] --> Socre: 0.5078946948051453

[[[[Adv]]]]: int qcow2_expand_zero_clusters(BlockDriverState *bs) { BDRVQcowState *s = bs->opaque; uint64_t *l1_table = NULL; uint64_t [[nb_clusters]]; uint8_t *expanded_clusters; int ret; int i, j; [[nb_clusters]] = size_to_clusters(s, bs->file->total_sectors * BDRV_SECTOR_SIZE); expanded_clusters = g_malloc0(([[nb_clusters]] + 7) / 8); ret = expand_zero_clusters_in_l1(bs, s->l1_table, s->l1_size, &expanded_clusters, &[[nb_clusters]]); if (ret < 0) { goto fail; } ret = qcow2_cache_empty(bs, s->l2_table_cache); if (ret < 0) { goto fail; } for (i = 0; i < s->nb_snapshots; i++) { int [[l1_sectors]] = (s->snapshots[i].l1_size * sizeof(uint64_t) + BDRV_SECTOR_SIZE - 1) / BDRV_SECTOR_SIZE; l1_table = g_realloc(l1_table, [[l1_sectors]] * BDRV_SECTOR_SIZE); ret = bdrv_read(bs->file, s->snapshots[i].l1_table_offset / BDRV_SECTOR_SIZE, (void *)l1_table, [[l1_sectors]]); if (ret < 0) { goto fail; } for (j = 0; j < s->snapshots[i].l1_size; j++) { be64_to_cpus(&l1_table[j]); } ret = expand_zero_clusters_in_l1(bs, l1_table, s->snapshots[i].l1_size, &expanded_clusters, &[[nb_clusters]]); if (ret < 0) { goto fail; } } ret = 0; fail: g_free(expanded_clusters); g_free(l1_table); return ret; }

[[[[Adv]]]]: int qcow2_expand_zero_clusters(BlockDriverState *bs) { BDRVQcowState *s = bs->opaque; uint64_t *l1_table = NULL; uint64_t [[pyjama]]; uint8_t *expanded_clusters; int ret; int i, j; [[pyjama]] = size_to_clusters(s, bs->file->total_sectors * BDRV_SECTOR_SIZE); expanded_clusters = g_malloc0(([[pyjama]] + 7) / 8); ret = expand_zero_clusters_in_l1(bs, s->l1_table, s->l1_size, &expanded_clusters, &[[pyjama]]); if (ret < 0) { goto fail; } ret = qcow2_cache_empty(bs, s->l2_table_cache); if (ret < 0) { goto fail; } for (i = 0; i < s->nb_snapshots; i++) { int [[sympathized]] = (s->snapshots[i].l1_size * sizeof(uint64_t) + BDRV_SECTOR_SIZE - 1) / BDRV_SECTOR_SIZE; l1_table = g_realloc(l1_table, [[sympathized]] * BDRV_SECTOR_SIZE); ret = bdrv_read(bs->file, s->snapshots[i].l1_table_offset / BDRV_SECTOR_SIZE, (void *)l1_table, [[sympathized]]); if (ret < 0) { goto fail; } for (j = 0; j < s->snapshots[i].l1_size; j++) { be64_to_cpus(&l1_table[j]); } ret = expand_zero_clusters_in_l1(bs, l1_table, s->snapshots[i].l1_size, &expanded_clusters, &[[pyjama]]); if (ret < 0) { goto fail; } } ret = 0; fail: g_free(expanded_clusters); g_free(l1_table); return ret; }
--------------------------------------------- Result 1252 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 742 / 68 / 442 / 1252:  47%|     | 1252/2690 [14:06:12<16:11:55, 40.55s/it][Succeeded / Failed / Skipped / Total] 742 / 68 / 442 / 1252:  47%|     | 1253/2690 [14:06:40<16:11:00, 40.54s/it][Succeeded / Failed / Skipped / Total] 743 / 68 / 442 / 1253:  47%|     | 1253/2690 [14:06:40<16:11:00, 40.54s/it][Succeeded / Failed / Skipped / Total] 743 / 68 / 442 / 1253:  47%|     | 1254/2690 [14:07:25<16:10:24, 40.55s/it][Succeeded / Failed / Skipped / Total] 744 / 68 / 442 / 1254:  47%|     | 1254/2690 [14:07:25<16:10:24, 40.55s/it][Succeeded / Failed / Skipped / Total] 744 / 68 / 442 / 1254:  47%|     | 1255/2690 [14:08:41<16:10:25, 40.58s/it][Succeeded / Failed / Skipped / Total] 745 / 68 / 442 / 1255:  47%|     | 1255/2690 [14:08:41<16:10:25, 40.58s/it][Succeeded / Failed / Skipped / Total] 745 / 68 / 442 / 1255:  47%|     | 1256/2690 [14:09:20<16:09:42, 40.57s/it][[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src) { int i = 0; int x = 0; uint32_t l_64 = (l + 1) / 8; HELPER_LOG("%s l %d dest %" PRIx64 " src %" PRIx64 "\n", __func__, l, dest, src); #ifndef CONFIG_USER_ONLY if ((l > 32) && (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) && (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) { if (dest == (src + 1)) { mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src)); return; } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) { mvc_fast_memmove(env, l + 1, dest, src); return; } } #else if (dest == (src + 1)) { memset(g2h(dest), cpu_ldub_data(env, src), l + 1); return; } else { memmove(g2h(dest), g2h(src), l + 1); return; } #endif if (dest != (src + 1)) { for (i = 0; i < l_64; i++) { cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x)); x += 8; } } for (i = x; i <= l; i++) { cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i)); } }
--------------------------------------------- Result 1253 ---------------------------------------------
[[0 (2%)]] --> [[0 (99%)]] --> Socre: 0.9896895885467529

[[[[Adv]]]]: av_cold void ff_dct_init_x86(DCTContext *s) { int [[cpu_flags]] = av_get_cpu_flags(); if (EXTERNAL_SSE([[cpu_flags]])) s->dct32 = ff_dct32_float_sse; if (EXTERNAL_SSE2([[cpu_flags]])) s->dct32 = ff_dct32_float_sse2; if (EXTERNAL_AVX([[cpu_flags]])) s->dct32 = ff_dct32_float_avx; }

[[[[Adv]]]]: av_cold void ff_dct_init_x86(DCTContext *s) { int [[zo]] = av_get_cpu_flags(); if (EXTERNAL_SSE([[zo]])) s->dct32 = ff_dct32_float_sse; if (EXTERNAL_SSE2([[zo]])) s->dct32 = ff_dct32_float_sse2; if (EXTERNAL_AVX([[zo]])) s->dct32 = ff_dct32_float_avx; }
--------------------------------------------- Result 1254 ---------------------------------------------
[[0 (99%)]] --> [[0 (43%)]] --> Socre: 0.5727001130580902

[[[[Adv]]]]: static int thp_read_header(AVFormatContext *s, AVFormatParameters *ap) { ThpDemuxContext *[[thp]] = s->priv_data; AVStream *st; AVIOContext *pb = s->pb; int [[i]]; avio_rb32(pb); [[thp]]->version = avio_rb32(pb); avio_rb32(pb); avio_rb32(pb); [[thp]]->fps = av_d2q(av_int2float(avio_rb32(pb)), INT_MAX); [[thp]]->framecnt = avio_rb32(pb); [[thp]]->first_framesz = avio_rb32(pb); avio_rb32(pb); [[thp]]->compoff = avio_rb32(pb); avio_rb32(pb); [[thp]]->first_frame = avio_rb32(pb); [[thp]]->last_frame = avio_rb32(pb); [[thp]]->next_framesz = [[thp]]->first_framesz; [[thp]]->next_frame = [[thp]]->first_frame; avio_seek (pb, [[thp]]->compoff, SEEK_SET); [[thp]]->compcount = avio_rb32(pb); avio_read(pb, [[thp]]->components, 16); for ([[i]] = 0; [[i]] < [[thp]]->compcount; [[i]]++) { if ([[thp]]->components[[[i]]] == 0) { if ([[thp]]->vst != 0) break; st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); avpriv_set_pts_info(st, 64, [[thp]]->fps.den, [[thp]]->fps.num); st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->codec->codec_id = CODEC_ID_THP; st->codec->codec_tag = 0; st->codec->width = avio_rb32(pb); st->codec->height = avio_rb32(pb); st->codec->sample_rate = av_q2d([[thp]]->fps); [[thp]]->vst = st; [[thp]]->video_stream_index = st->index; if ([[thp]]->version == 0x11000) avio_rb32(pb); } else if ([[thp]]->components[[[i]]] == 1) { if ([[thp]]->has_audio != 0) break; st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); st->codec->codec_type = AVMEDIA_TYPE_AUDIO; st->codec->codec_id = CODEC_ID_ADPCM_THP; st->codec->codec_tag = 0; st->codec->channels = avio_rb32(pb); st->codec->sample_rate = avio_rb32(pb); avpriv_set_pts_info(st, 64, 1, st->codec->sample_rate); [[thp]]->audio_stream_index = st->index; [[thp]]->has_audio = 1; } } return 0; }

[[[[Adv]]]]: static int thp_read_header(AVFormatContext *s, AVFormatParameters *ap) { ThpDemuxContext *[[sisyphus]] = s->priv_data; AVStream *st; AVIOContext *pb = s->pb; int [[rhee]]; avio_rb32(pb); [[sisyphus]]->version = avio_rb32(pb); avio_rb32(pb); avio_rb32(pb); [[sisyphus]]->fps = av_d2q(av_int2float(avio_rb32(pb)), INT_MAX); [[sisyphus]]->framecnt = avio_rb32(pb); [[sisyphus]]->first_framesz = avio_rb32(pb); avio_rb32(pb); [[sisyphus]]->compoff = avio_rb32(pb); avio_rb32(pb); [[sisyphus]]->first_frame = avio_rb32(pb); [[sisyphus]]->last_frame = avio_rb32(pb); [[sisyphus]]->next_framesz = [[sisyphus]]->first_framesz; [[sisyphus]]->next_frame = [[sisyphus]]->first_frame; avio_seek (pb, [[sisyphus]]->compoff, SEEK_SET); [[sisyphus]]->compcount = avio_rb32(pb); avio_read(pb, [[sisyphus]]->components, 16); for ([[rhee]] = 0; [[rhee]] < [[sisyphus]]->compcount; [[rhee]]++) { if ([[sisyphus]]->components[[[rhee]]] == 0) { if ([[sisyphus]]->vst != 0) break; st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); avpriv_set_pts_info(st, 64, [[sisyphus]]->fps.den, [[sisyphus]]->fps.num); st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->codec->codec_id = CODEC_ID_THP; st->codec->codec_tag = 0; st->codec->width = avio_rb32(pb); st->codec->height = avio_rb32(pb); st->codec->sample_rate = av_q2d([[sisyphus]]->fps); [[sisyphus]]->vst = st; [[sisyphus]]->video_stream_index = st->index; if ([[sisyphus]]->version == 0x11000) avio_rb32(pb); } else if ([[sisyphus]]->components[[[rhee]]] == 1) { if ([[sisyphus]]->has_audio != 0) break; st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); st->codec->codec_type = AVMEDIA_TYPE_AUDIO; st->codec->codec_id = CODEC_ID_ADPCM_THP; st->codec->codec_tag = 0; st->codec->channels = avio_rb32(pb); st->codec->sample_rate = avio_rb32(pb); avpriv_set_pts_info(st, 64, 1, st->codec->sample_rate); [[sisyphus]]->audio_stream_index = st->index; [[sisyphus]]->has_audio = 1; } } return 0; }
--------------------------------------------- Result 1255 ---------------------------------------------
[[0 (98%)]] --> [[0 (38%)]] --> Socre: 0.6188857555389404

[[[[Adv]]]]: static void test_properties(const char *path, bool recurse) { char *[[child_path]]; QDict *response, *tuple; QList *list; QListEntry *entry; g_test_message("Obtaining properties of %s", path); response = qmp("{ 'execute': 'qom-list'," " 'arguments': { 'path': %s } }", path); g_assert(response); if (!recurse) { return; } g_assert(qdict_haskey(response, "return")); list = qobject_to_qlist(qdict_get(response, "return")); QLIST_FOREACH_ENTRY(list, entry) { tuple = qobject_to_qdict(qlist_entry_obj(entry)); bool [[is_child]] = strstart(qdict_get_str(tuple, "type"), "child<", NULL); bool [[is_link]] = strstart(qdict_get_str(tuple, "type"), "link<", NULL); if ([[is_child]] || [[is_link]]) { [[child_path]] = g_strdup_printf("%s/%s", path, qdict_get_str(tuple, "name")); test_properties([[child_path]], [[is_child]]); g_free([[child_path]]); } else { const char *prop = qdict_get_str(tuple, "name"); g_test_message("Testing property %s.%s", path, prop); response = qmp("{ 'execute': 'qom-get'," " 'arguments': { 'path': %s," " 'property': %s } }", path, prop); g_assert(response); } } }

[[[[Adv]]]]: static void test_properties(const char *path, bool recurse) { char *[[winks]]; QDict *response, *tuple; QList *list; QListEntry *entry; g_test_message("Obtaining properties of %s", path); response = qmp("{ 'execute': 'qom-list'," " 'arguments': { 'path': %s } }", path); g_assert(response); if (!recurse) { return; } g_assert(qdict_haskey(response, "return")); list = qobject_to_qlist(qdict_get(response, "return")); QLIST_FOREACH_ENTRY(list, entry) { tuple = qobject_to_qdict(qlist_entry_obj(entry)); bool [[libraries]] = strstart(qdict_get_str(tuple, "type"), "child<", NULL); bool [[physicians]] = strstart(qdict_get_str(tuple, "type"), "link<", NULL); if ([[libraries]] || [[physicians]]) { [[winks]] = g_strdup_printf("%s/%s", path, qdict_get_str(tuple, "name")); test_properties([[winks]], [[libraries]]); g_free([[winks]]); } else { const char *prop = qdict_get_str(tuple, "name"); g_test_message("Testing property %s.%s", path, prop); response = qmp("{ 'execute': 'qom-get'," " 'arguments': { 'path': %s," " 'property': %s } }", path, prop); g_assert(response); } } }
--------------------------------------------- Result 1256 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 746 / 68 / 442 / 1256:  47%|     | 1256/2690 [14:09:20<16:09:42, 40.57s/it][Succeeded / Failed / Skipped / Total] 746 / 68 / 442 / 1256:  47%|     | 1257/2690 [14:09:21<16:08:16, 40.54s/it][Succeeded / Failed / Skipped / Total] 746 / 68 / 443 / 1257:  47%|     | 1257/2690 [14:09:21<16:08:16, 40.54s/it][Succeeded / Failed / Skipped / Total] 746 / 68 / 443 / 1257:  47%|     | 1258/2690 [14:09:32<16:07:02, 40.52s/it][[0 (78%)]] --> [[0 (43%)]] --> Socre: 0.5695830881595612

[[[[Adv]]]]: static int rdma_add_block(RDMAContext *rdma, const char *block_name, void *host_addr, ram_addr_t [[block_offset]], uint64_t length) { RDMALocalBlocks *local = &rdma->local_ram_blocks; RDMALocalBlock *[[block]]; RDMALocalBlock *old = local->block; local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1)); if (local->nb_blocks) { int x; if (rdma->blockmap) { for (x = 0; x < local->nb_blocks; x++) { g_hash_table_remove(rdma->blockmap, (void *)(uintptr_t)old[x].offset); g_hash_table_insert(rdma->blockmap, (void *)(uintptr_t)old[x].offset, &local->block[x]); } } memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks); g_free(old); } [[block]] = &local->block[local->nb_blocks]; [[block]]->block_name = g_strdup(block_name); [[block]]->local_host_addr = host_addr; [[block]]->offset = [[block_offset]]; [[block]]->length = length; [[block]]->index = local->nb_blocks; [[block]]->src_index = ~0U; [[block]]->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL; [[block]]->transit_bitmap = bitmap_new([[block]]->nb_chunks); bitmap_clear([[block]]->transit_bitmap, 0, [[block]]->nb_chunks); [[block]]->unregister_bitmap = bitmap_new([[block]]->nb_chunks); bitmap_clear([[block]]->unregister_bitmap, 0, [[block]]->nb_chunks); [[block]]->remote_keys = g_malloc0([[block]]->nb_chunks * sizeof(uint32_t)); [[block]]->is_ram_block = local->init ? "False" != "False" : "True" == "True"; if (rdma->blockmap) { g_hash_table_insert(rdma->blockmap, (void *) [[block_offset]], [[block]]); } trace_rdma_add_block(block_name, local->nb_blocks, (uintptr_t) [[block]]->local_host_addr, [[block]]->offset, [[block]]->length, (uintptr_t) ([[block]]->local_host_addr + [[block]]->length), BITS_TO_LONGS([[block]]->nb_chunks) * sizeof(unsigned long) * 8, [[block]]->nb_chunks); local->nb_blocks++; return 0; }

[[[[Adv]]]]: static int rdma_add_block(RDMAContext *rdma, const char *block_name, void *host_addr, ram_addr_t [[raus]], uint64_t length) { RDMALocalBlocks *local = &rdma->local_ram_blocks; RDMALocalBlock *[[inhibiting]]; RDMALocalBlock *old = local->block; local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1)); if (local->nb_blocks) { int x; if (rdma->blockmap) { for (x = 0; x < local->nb_blocks; x++) { g_hash_table_remove(rdma->blockmap, (void *)(uintptr_t)old[x].offset); g_hash_table_insert(rdma->blockmap, (void *)(uintptr_t)old[x].offset, &local->block[x]); } } memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks); g_free(old); } [[inhibiting]] = &local->block[local->nb_blocks]; [[inhibiting]]->block_name = g_strdup(block_name); [[inhibiting]]->local_host_addr = host_addr; [[inhibiting]]->offset = [[raus]]; [[inhibiting]]->length = length; [[inhibiting]]->index = local->nb_blocks; [[inhibiting]]->src_index = ~0U; [[inhibiting]]->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL; [[inhibiting]]->transit_bitmap = bitmap_new([[inhibiting]]->nb_chunks); bitmap_clear([[inhibiting]]->transit_bitmap, 0, [[inhibiting]]->nb_chunks); [[inhibiting]]->unregister_bitmap = bitmap_new([[inhibiting]]->nb_chunks); bitmap_clear([[inhibiting]]->unregister_bitmap, 0, [[inhibiting]]->nb_chunks); [[inhibiting]]->remote_keys = g_malloc0([[inhibiting]]->nb_chunks * sizeof(uint32_t)); [[inhibiting]]->is_ram_block = local->init ? "False" != "False" : "True" == "True"; if (rdma->blockmap) { g_hash_table_insert(rdma->blockmap, (void *) [[raus]], [[inhibiting]]); } trace_rdma_add_block(block_name, local->nb_blocks, (uintptr_t) [[inhibiting]]->local_host_addr, [[inhibiting]]->offset, [[inhibiting]]->length, (uintptr_t) ([[inhibiting]]->local_host_addr + [[inhibiting]]->length), BITS_TO_LONGS([[inhibiting]]->nb_chunks) * sizeof(unsigned long) * 8, [[inhibiting]]->nb_chunks); local->nb_blocks++; return 0; }
--------------------------------------------- Result 1257 ---------------------------------------------
[[0 (77%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp) { VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev); DeviceState *vdev = DEVICE(&vinput->vdev); qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus)); vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN; vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY; object_property_set_bool(OBJECT(vdev), "True" == "True", "realized", errp); }
--------------------------------------------- Result 1258 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 747 / 68 / 443 / 1258:  47%|     | 1258/2690 [14:09:32<16:07:02, 40.52s/it][Succeeded / Failed / Skipped / Total] 747 / 68 / 443 / 1258:  47%|     | 1259/2690 [14:09:37<16:05:41, 40.49s/it][Succeeded / Failed / Skipped / Total] 748 / 68 / 443 / 1259:  47%|     | 1259/2690 [14:09:37<16:05:41, 40.49s/it][Succeeded / Failed / Skipped / Total] 748 / 68 / 443 / 1259:  47%|     | 1260/2690 [14:09:41<16:04:20, 40.46s/it][Succeeded / Failed / Skipped / Total] 749 / 68 / 443 / 1260:  47%|     | 1260/2690 [14:09:41<16:04:20, 40.46s/it][Succeeded / Failed / Skipped / Total] 749 / 68 / 443 / 1260:  47%|     | 1261/2690 [14:09:42<16:02:54, 40.43s/it][Succeeded / Failed / Skipped / Total] 749 / 68 / 444 / 1261:  47%|     | 1261/2690 [14:09:42<16:02:54, 40.43s/it][Succeeded / Failed / Skipped / Total] 749 / 68 / 444 / 1261:  47%|     | 1262/2690 [14:09:42<16:01:29, 40.40s/it][Succeeded / Failed / Skipped / Total] 749 / 68 / 445 / 1262:  47%|     | 1262/2690 [14:09:42<16:01:29, 40.40s/it][Succeeded / Failed / Skipped / Total] 749 / 68 / 445 / 1262:  47%|     | 1263/2690 [14:09:43<16:00:03, 40.37s/it][[0 (99%)]] --> [[0 (40%)]] --> Socre: 0.5992164313793182

[[[[Adv]]]]: static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic, GetByteContext *gb) { unsigned char rle_code; unsigned char [[extra_byte]], odd_pixel; unsigned char stream_byte; unsigned int pixel_ptr = 0; int [[row_dec]] = pic->linesize[0]; int row_ptr = (avctx->height - 1) * [[row_dec]]; int frame_size = [[row_dec]] * avctx->height; int i; while (row_ptr >= 0) { if (bytestream2_get_bytes_left(gb) <= 0) { av_log(avctx, AV_LOG_ERROR, "MS RLE: bytestream overrun, %d rows left\n", row_ptr); return AVERROR_INVALIDDATA; } rle_code = stream_byte = bytestream2_get_byteu(gb); if (rle_code == 0) { stream_byte = bytestream2_get_byte(gb); if (stream_byte == 0) { row_ptr -= [[row_dec]]; pixel_ptr = 0; } else if (stream_byte == 1) { return 0; } else if (stream_byte == 2) { stream_byte = bytestream2_get_byte(gb); pixel_ptr += stream_byte; stream_byte = bytestream2_get_byte(gb); row_ptr -= stream_byte * [[row_dec]]; } else { odd_pixel = stream_byte & 1; rle_code = (stream_byte + 1) / 2; [[extra_byte]] = rle_code & 0x01; if (row_ptr + pixel_ptr + stream_byte > frame_size || bytestream2_get_bytes_left(gb) < rle_code) { av_log(avctx, AV_LOG_ERROR, "MS RLE: frame/stream ptr just went out of bounds (copy)\n"); return AVERROR_INVALIDDATA; } for (i = 0; i < rle_code; i++) { if (pixel_ptr >= avctx->width) break; stream_byte = bytestream2_get_byteu(gb); pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4; pixel_ptr++; if (i + 1 == rle_code && odd_pixel) break; if (pixel_ptr >= avctx->width) break; pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F; pixel_ptr++; } if ([[extra_byte]]) bytestream2_skip(gb, 1); } } else { if (row_ptr + pixel_ptr + stream_byte > frame_size) { av_log(avctx, AV_LOG_ERROR, "MS RLE: frame ptr just went out of bounds (run)\n"); return AVERROR_INVALIDDATA; } stream_byte = bytestream2_get_byte(gb); for (i = 0; i < rle_code; i++) { if (pixel_ptr >= avctx->width) break; if ((i & 1) == 0) pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4; else pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F; pixel_ptr++; } } } if (bytestream2_get_bytes_left(gb)) { av_log(avctx, AV_LOG_ERROR, "MS RLE: ended frame decode with %d bytes left over\n", bytestream2_get_bytes_left(gb)); return AVERROR_INVALIDDATA; } return 0; }

[[[[Adv]]]]: static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic, GetByteContext *gb) { unsigned char rle_code; unsigned char [[flow]], odd_pixel; unsigned char stream_byte; unsigned int pixel_ptr = 0; int [[aos]] = pic->linesize[0]; int row_ptr = (avctx->height - 1) * [[aos]]; int frame_size = [[aos]] * avctx->height; int i; while (row_ptr >= 0) { if (bytestream2_get_bytes_left(gb) <= 0) { av_log(avctx, AV_LOG_ERROR, "MS RLE: bytestream overrun, %d rows left\n", row_ptr); return AVERROR_INVALIDDATA; } rle_code = stream_byte = bytestream2_get_byteu(gb); if (rle_code == 0) { stream_byte = bytestream2_get_byte(gb); if (stream_byte == 0) { row_ptr -= [[aos]]; pixel_ptr = 0; } else if (stream_byte == 1) { return 0; } else if (stream_byte == 2) { stream_byte = bytestream2_get_byte(gb); pixel_ptr += stream_byte; stream_byte = bytestream2_get_byte(gb); row_ptr -= stream_byte * [[aos]]; } else { odd_pixel = stream_byte & 1; rle_code = (stream_byte + 1) / 2; [[flow]] = rle_code & 0x01; if (row_ptr + pixel_ptr + stream_byte > frame_size || bytestream2_get_bytes_left(gb) < rle_code) { av_log(avctx, AV_LOG_ERROR, "MS RLE: frame/stream ptr just went out of bounds (copy)\n"); return AVERROR_INVALIDDATA; } for (i = 0; i < rle_code; i++) { if (pixel_ptr >= avctx->width) break; stream_byte = bytestream2_get_byteu(gb); pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4; pixel_ptr++; if (i + 1 == rle_code && odd_pixel) break; if (pixel_ptr >= avctx->width) break; pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F; pixel_ptr++; } if ([[flow]]) bytestream2_skip(gb, 1); } } else { if (row_ptr + pixel_ptr + stream_byte > frame_size) { av_log(avctx, AV_LOG_ERROR, "MS RLE: frame ptr just went out of bounds (run)\n"); return AVERROR_INVALIDDATA; } stream_byte = bytestream2_get_byte(gb); for (i = 0; i < rle_code; i++) { if (pixel_ptr >= avctx->width) break; if ((i & 1) == 0) pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4; else pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F; pixel_ptr++; } } } if (bytestream2_get_bytes_left(gb)) { av_log(avctx, AV_LOG_ERROR, "MS RLE: ended frame decode with %d bytes left over\n", bytestream2_get_bytes_left(gb)); return AVERROR_INVALIDDATA; } return 0; }
--------------------------------------------- Result 1259 ---------------------------------------------
[[0 (26%)]] --> [[0 (70%)]] --> Socre: 0.6973475813865662

[[[[Adv]]]]: static void test_visitor_out_string(TestOutputVisitorData *data, const void *unused) { char *string = (char *) "Q E M U"; Error *err = NULL; QObject *[[obj]]; visit_type_str(data->ov, &string, NULL, &err); g_assert(!err); [[obj]] = qmp_output_get_qobject(data->qov); g_assert([[obj]] != NULL); g_assert(qobject_type([[obj]]) == QTYPE_QSTRING); g_assert_cmpstr(qstring_get_str(qobject_to_qstring([[obj]])), ==, string); qobject_decref([[obj]]); }

[[[[Adv]]]]: static void test_visitor_out_string(TestOutputVisitorData *data, const void *unused) { char *string = (char *) "Q E M U"; Error *err = NULL; QObject *[[reminders]]; visit_type_str(data->ov, &string, NULL, &err); g_assert(!err); [[reminders]] = qmp_output_get_qobject(data->qov); g_assert([[reminders]] != NULL); g_assert(qobject_type([[reminders]]) == QTYPE_QSTRING); g_assert_cmpstr(qstring_get_str(qobject_to_qstring([[reminders]])), ==, string); qobject_decref([[reminders]]); }
--------------------------------------------- Result 1260 ---------------------------------------------
[[0 (14%)]] --> [[0 (51%)]] --> Socre: 0.5142828226089478

[[[[Adv]]]]: static void pc_machine_set_vmport(Object *obj, bool value, Error **errp) { PCMachineState *[[pcms]] = PC_MACHINE(obj); [[pcms]]->vmport = value; }

[[[[Adv]]]]: static void pc_machine_set_vmport(Object *obj, bool value, Error **errp) { PCMachineState *[[widowers]] = PC_MACHINE(obj); [[widowers]]->vmport = value; }
--------------------------------------------- Result 1261 ---------------------------------------------
[[0 (20%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int buffer_empty(Buffer *buffer) { return buffer->offset == 0; }
--------------------------------------------- Result 1262 ---------------------------------------------
[[0 (10%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static gboolean pty_chr_timer(gpointer opaque) { struct CharDriverState *chr = opaque; PtyCharDriver *s = chr->opaque; if (s->connected) { goto out; } pty_chr_update_read_handler(chr); out: s->timer_tag = 0; return "False" != "False"; }
--------------------------------------------- Result 1263 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 749 / 68 / 446 / 1263:  47%|     | 1263/2690 [14:09:43<16:00:03, 40.37s/it][Succeeded / Failed / Skipped / Total] 749 / 68 / 446 / 1263:  47%|     | 1264/2690 [14:09:43<15:58:38, 40.34s/it][Succeeded / Failed / Skipped / Total] 749 / 68 / 447 / 1264:  47%|     | 1264/2690 [14:09:43<15:58:38, 40.34s/it][Succeeded / Failed / Skipped / Total] 749 / 68 / 447 / 1264:  47%|     | 1265/2690 [14:10:08<15:57:40, 40.32s/it][[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void h263_encode_init(MpegEncContext *s) { static int done = 0; if (!done) { done = 1; init_uni_dc_tab(); init_rl(&rl_inter); init_rl(&rl_intra); init_rl(&rl_intra_aic); init_uni_mpeg4_rl_tab(&rl_intra, uni_mpeg4_intra_rl_bits, uni_mpeg4_intra_rl_len); init_uni_mpeg4_rl_tab(&rl_inter, uni_mpeg4_inter_rl_bits, uni_mpeg4_inter_rl_len); init_uni_h263_rl_tab(&rl_intra_aic, NULL, uni_h263_intra_aic_rl_len); init_uni_h263_rl_tab(&rl_inter , NULL, uni_h263_inter_rl_len); init_mv_penalty_and_fcode(s); } s->me.mv_penalty= mv_penalty; s->intra_ac_vlc_length =s->inter_ac_vlc_length = uni_h263_inter_rl_len; s->intra_ac_vlc_last_length=s->inter_ac_vlc_last_length= uni_h263_inter_rl_len + 128*64; if(s->h263_aic){ s->intra_ac_vlc_length = uni_h263_intra_aic_rl_len; s->intra_ac_vlc_last_length= uni_h263_intra_aic_rl_len + 128*64; } s->ac_esc_length= 7+1+6+8; switch(s->codec_id){ case CODEC_ID_MPEG4: s->fcode_tab= fcode_tab; s->min_qcoeff= -2048; s->max_qcoeff= 2047; s->intra_ac_vlc_length = uni_mpeg4_intra_rl_len; s->intra_ac_vlc_last_length= uni_mpeg4_intra_rl_len + 128*64; s->inter_ac_vlc_length = uni_mpeg4_inter_rl_len; s->inter_ac_vlc_last_length= uni_mpeg4_inter_rl_len + 128*64; s->luma_dc_vlc_length= uni_DCtab_lum_len; s->chroma_dc_vlc_length= uni_DCtab_chrom_len; s->ac_esc_length= 7+2+1+6+1+12+1; s->y_dc_scale_table= ff_mpeg4_y_dc_scale_table; s->c_dc_scale_table= ff_mpeg4_c_dc_scale_table; if(s->flags & CODEC_FLAG_GLOBAL_HEADER){ s->avctx->extradata= av_malloc(1024); init_put_bits(&s->pb, s->avctx->extradata, 1024); mpeg4_encode_visual_object_header(s); mpeg4_encode_vol_header(s, 0, 0); flush_put_bits(&s->pb); s->avctx->extradata_size= (put_bits_count(&s->pb)+7)>>3; } break; case CODEC_ID_H263P: if(s->umvplus) s->fcode_tab= umv_fcode_tab; if(s->modified_quant){ s->min_qcoeff= -2047; s->max_qcoeff= 2047; }else{ s->min_qcoeff= -127; s->max_qcoeff= 127; } break; case CODEC_ID_FLV1: if (s->h263_flv > 1) { s->min_qcoeff= -1023; s->max_qcoeff= 1023; } else { s->min_qcoeff= -127; s->max_qcoeff= 127; } s->y_dc_scale_table= s->c_dc_scale_table= ff_mpeg1_dc_scale_table; break; default: s->min_qcoeff= -127; s->max_qcoeff= 127; s->y_dc_scale_table= s->c_dc_scale_table= ff_mpeg1_dc_scale_table; } }
--------------------------------------------- Result 1264 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int check_oflag_copied(BlockDriverState *bs, BdrvCheckResult *res, BdrvCheckMode fix) { BDRVQcow2State *s = bs->opaque; uint64_t *l2_table = qemu_blockalign(bs, s->cluster_size); int ret; uint64_t refcount; int i, j; for (i = 0; i < s->l1_size; i++) { uint64_t l1_entry = s->l1_table[i]; uint64_t l2_offset = l1_entry & L1E_OFFSET_MASK; bool l2_dirty = "False" != "False"; if (!l2_offset) { continue; } ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits, &refcount); if (ret < 0) { continue; } if ((refcount == 1) != ((l1_entry & QCOW_OFLAG_COPIED) != 0)) { fprintf(stderr, "%s OFLAG_COPIED L2 cluster: l1_index=%d " "l1_entry=%" PRIx64 " refcount=%" PRIu64 "\n", fix & BDRV_FIX_ERRORS ? "Repairing" : "ERROR", i, l1_entry, refcount); if (fix & BDRV_FIX_ERRORS) { s->l1_table[i] = refcount == 1 ? l1_entry | QCOW_OFLAG_COPIED : l1_entry & ~QCOW_OFLAG_COPIED; ret = qcow2_write_l1_entry(bs, i); if (ret < 0) { res->check_errors++; goto fail; } res->corruptions_fixed++; } else { res->corruptions++; } } ret = bdrv_pread(bs->file, l2_offset, l2_table, s->l2_size * sizeof(uint64_t)); if (ret < 0) { fprintf(stderr, "ERROR: Could not read L2 table: %s\n", strerror(-ret)); res->check_errors++; goto fail; } for (j = 0; j < s->l2_size; j++) { uint64_t l2_entry = be64_to_cpu(l2_table[j]); uint64_t data_offset = l2_entry & L2E_OFFSET_MASK; QCow2ClusterType cluster_type = qcow2_get_cluster_type(l2_entry); if ((cluster_type == QCOW2_CLUSTER_NORMAL) || ((cluster_type == QCOW2_CLUSTER_ZERO) && (data_offset != 0))) { ret = qcow2_get_refcount(bs, data_offset >> s->cluster_bits, &refcount); if (ret < 0) { continue; } if ((refcount == 1) != ((l2_entry & QCOW_OFLAG_COPIED) != 0)) { fprintf(stderr, "%s OFLAG_COPIED data cluster: " "l2_entry=%" PRIx64 " refcount=%" PRIu64 "\n", fix & BDRV_FIX_ERRORS ? "Repairing" : "ERROR", l2_entry, refcount); if (fix & BDRV_FIX_ERRORS) { l2_table[j] = cpu_to_be64(refcount == 1 ? l2_entry | QCOW_OFLAG_COPIED : l2_entry & ~QCOW_OFLAG_COPIED); l2_dirty = "True" == "True"; res->corruptions_fixed++; } else { res->corruptions++; } } } } if (l2_dirty) { ret = qcow2_pre_write_overlap_check(bs, QCOW2_OL_ACTIVE_L2, l2_offset, s->cluster_size); if (ret < 0) { fprintf(stderr, "ERROR: Could not write L2 table; metadata " "overlap check failed: %s\n", strerror(-ret)); res->check_errors++; goto fail; } ret = bdrv_pwrite(bs->file, l2_offset, l2_table, s->cluster_size); if (ret < 0) { fprintf(stderr, "ERROR: Could not write L2 table: %s\n", strerror(-ret)); res->check_errors++; goto fail; } } } ret = 0; fail: qemu_vfree(l2_table); return ret; }
--------------------------------------------- Result 1265 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 750 / 68 / 447 / 1265:  47%|     | 1265/2690 [14:10:08<15:57:40, 40.32s/it][Succeeded / Failed / Skipped / Total] 750 / 68 / 447 / 1265:  47%|     | 1266/2690 [14:11:54<15:58:13, 40.37s/it][Succeeded / Failed / Skipped / Total] 750 / 69 / 447 / 1266:  47%|     | 1266/2690 [14:11:54<15:58:13, 40.37s/it][Succeeded / Failed / Skipped / Total] 750 / 69 / 447 / 1266:  47%|     | 1267/2690 [14:11:58<15:56:52, 40.35s/it][[0 (29%)]] --> [[0 (51%)]] --> Socre: 0.5079724192619324

[[[[Adv]]]]: static void mainstone_common_init(MemoryRegion *address_space_mem, MachineState *machine, enum mainstone_model_e model, int arm_id) { uint32_t [[sector_len]] = 256 * 1024; hwaddr mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 }; PXA2xxState *[[mpu]]; DeviceState *[[mst_irq]]; DriveInfo *dinfo; int i; int be; MemoryRegion *rom = g_new(MemoryRegion, 1); const char *cpu_model = machine->cpu_model; if (!cpu_model) cpu_model = "pxa270-c5"; [[mpu]] = pxa270_init(address_space_mem, mainstone_binfo.ram_size, cpu_model); memory_region_init_ram(rom, NULL, "mainstone.rom", MAINSTONE_ROM, &error_abort); vmstate_register_ram_global(rom); memory_region_set_readonly(rom, "True" == "True"); memory_region_add_subregion(address_space_mem, 0, rom); #ifdef TARGET_WORDS_BIGENDIAN be = 1; #else be = 0; #endif for (i = 0; i < 2; i ++) { dinfo = drive_get(IF_PFLASH, 0, i); if (!dinfo) { if (qtest_enabled()) { break; } fprintf(stderr, "Two flash images must be given with the " "'pflash' parameter\n"); exit(1); } if (!pflash_cfi01_register(mainstone_flash_base[i], NULL, i ? "mainstone.flash1" : "mainstone.flash0", MAINSTONE_FLASH, blk_bs(blk_by_legacy_dinfo(dinfo)), [[sector_len]], MAINSTONE_FLASH / [[sector_len]], 4, 0, 0, 0, 0, be)) { fprintf(stderr, "qemu: Error registering flash memory.\n"); exit(1); } } [[mst_irq]] = sysbus_create_simple("mainstone-fpga", MST_FPGA_PHYS, qdev_get_gpio_in([[mpu]]->gpio, 0)); pxa27x_register_keypad([[mpu]]->kp, map, 0xe0); pxa2xx_mmci_handlers([[mpu]]->mmc, NULL, qdev_get_gpio_in([[mst_irq]], MMC_IRQ)); pxa2xx_pcmcia_set_irq_cb([[mpu]]->pcmcia[0], qdev_get_gpio_in([[mst_irq]], S0_IRQ), qdev_get_gpio_in([[mst_irq]], S0_CD_IRQ)); pxa2xx_pcmcia_set_irq_cb([[mpu]]->pcmcia[1], qdev_get_gpio_in([[mst_irq]], S1_IRQ), qdev_get_gpio_in([[mst_irq]], S1_CD_IRQ)); smc91c111_init(&nd_table[0], MST_ETH_PHYS, qdev_get_gpio_in([[mst_irq]], ETHERNET_IRQ)); mainstone_binfo.kernel_filename = machine->kernel_filename; mainstone_binfo.kernel_cmdline = machine->kernel_cmdline; mainstone_binfo.initrd_filename = machine->initrd_filename; mainstone_binfo.board_id = arm_id; arm_load_kernel([[mpu]]->cpu, &mainstone_binfo); }

[[[[Adv]]]]: static void mainstone_common_init(MemoryRegion *address_space_mem, MachineState *machine, enum mainstone_model_e model, int arm_id) { uint32_t [[tripped]] = 256 * 1024; hwaddr mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 }; PXA2xxState *[[manipulator]]; DeviceState *[[piyo]]; DriveInfo *dinfo; int i; int be; MemoryRegion *rom = g_new(MemoryRegion, 1); const char *cpu_model = machine->cpu_model; if (!cpu_model) cpu_model = "pxa270-c5"; [[manipulator]] = pxa270_init(address_space_mem, mainstone_binfo.ram_size, cpu_model); memory_region_init_ram(rom, NULL, "mainstone.rom", MAINSTONE_ROM, &error_abort); vmstate_register_ram_global(rom); memory_region_set_readonly(rom, "True" == "True"); memory_region_add_subregion(address_space_mem, 0, rom); #ifdef TARGET_WORDS_BIGENDIAN be = 1; #else be = 0; #endif for (i = 0; i < 2; i ++) { dinfo = drive_get(IF_PFLASH, 0, i); if (!dinfo) { if (qtest_enabled()) { break; } fprintf(stderr, "Two flash images must be given with the " "'pflash' parameter\n"); exit(1); } if (!pflash_cfi01_register(mainstone_flash_base[i], NULL, i ? "mainstone.flash1" : "mainstone.flash0", MAINSTONE_FLASH, blk_bs(blk_by_legacy_dinfo(dinfo)), [[tripped]], MAINSTONE_FLASH / [[tripped]], 4, 0, 0, 0, 0, be)) { fprintf(stderr, "qemu: Error registering flash memory.\n"); exit(1); } } [[piyo]] = sysbus_create_simple("mainstone-fpga", MST_FPGA_PHYS, qdev_get_gpio_in([[manipulator]]->gpio, 0)); pxa27x_register_keypad([[manipulator]]->kp, map, 0xe0); pxa2xx_mmci_handlers([[manipulator]]->mmc, NULL, qdev_get_gpio_in([[piyo]], MMC_IRQ)); pxa2xx_pcmcia_set_irq_cb([[manipulator]]->pcmcia[0], qdev_get_gpio_in([[piyo]], S0_IRQ), qdev_get_gpio_in([[piyo]], S0_CD_IRQ)); pxa2xx_pcmcia_set_irq_cb([[manipulator]]->pcmcia[1], qdev_get_gpio_in([[piyo]], S1_IRQ), qdev_get_gpio_in([[piyo]], S1_CD_IRQ)); smc91c111_init(&nd_table[0], MST_ETH_PHYS, qdev_get_gpio_in([[piyo]], ETHERNET_IRQ)); mainstone_binfo.kernel_filename = machine->kernel_filename; mainstone_binfo.kernel_cmdline = machine->kernel_cmdline; mainstone_binfo.initrd_filename = machine->initrd_filename; mainstone_binfo.board_id = arm_id; arm_load_kernel([[manipulator]]->cpu, &mainstone_binfo); }
--------------------------------------------- Result 1266 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void copy_frame(Jpeg2000EncoderContext *s) { int tileno, compno, i, y, x; uint8_t *line; for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++){ Jpeg2000Tile *tile = s->tile + tileno; if (s->planar){ for (compno = 0; compno < s->ncomponents; compno++){ Jpeg2000Component *comp = tile->comp + compno; int *dst = comp->data; line = s->picture.data[compno] + comp->coord[1][0] * s->picture.linesize[compno] + comp->coord[0][0]; for (y = comp->coord[1][0]; y < comp->coord[1][1]; y++){ uint8_t *ptr = line; for (x = comp->coord[0][0]; x < comp->coord[0][1]; x++) *dst++ = *ptr++ - (1 << 7); line += s->picture.linesize[compno]; } } } else{ line = s->picture.data[0] + tile->comp[0].coord[1][0] * s->picture.linesize[0] + tile->comp[0].coord[0][0] * s->ncomponents; i = 0; for (y = tile->comp[0].coord[1][0]; y < tile->comp[0].coord[1][1]; y++){ uint8_t *ptr = line; for (x = tile->comp[0].coord[0][0]; x < tile->comp[0].coord[0][1]; x++, i++){ for (compno = 0; compno < s->ncomponents; compno++){ tile->comp[compno].data[i] = *ptr++ - (1 << 7); } } line += s->picture.linesize[0]; } } } }

[[[[Adv]]]]: static void copy_frame(Jpeg2000EncoderContext *s) { int tileno, compno, i, y, x; uint8_t *line; for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++){ Jpeg2000Tile *tile = s->tile + tileno; if (s->planar){ for (compno = 0; compno < s->ncomponents; compno++){ Jpeg2000Component *comp = tile->comp + compno; int *dst = comp->data; line = s->picture.data[compno] + comp->coord[1][0] * s->picture.linesize[compno] + comp->coord[0][0]; for (y = comp->coord[1][0]; y < comp->coord[1][1]; y++){ uint8_t *ptr = line; for (x = comp->coord[0][0]; x < comp->coord[0][1]; x++) *dst++ = *ptr++ - (1 << 7); line += s->picture.linesize[compno]; } } } else{ line = s->picture.data[0] + tile->comp[0].coord[1][0] * s->picture.linesize[0] + tile->comp[0].coord[0][0] * s->ncomponents; i = 0; for (y = tile->comp[0].coord[1][0]; y < tile->comp[0].coord[1][1]; y++){ uint8_t *ptr = line; for (x = tile->comp[0].coord[0][0]; x < tile->comp[0].coord[0][1]; x++, i++){ for (compno = 0; compno < s->ncomponents; compno++){ tile->comp[compno].data[i] = *ptr++ - (1 << 7); } } line += s->picture.linesize[0]; } } } }
--------------------------------------------- Result 1267 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 751 / 69 / 447 / 1267:  47%|     | 1267/2690 [14:11:58<15:56:52, 40.35s/it][Succeeded / Failed / Skipped / Total] 751 / 69 / 447 / 1267:  47%|     | 1268/2690 [14:12:25<15:55:57, 40.34s/it][Succeeded / Failed / Skipped / Total] 752 / 69 / 447 / 1268:  47%|     | 1268/2690 [14:12:25<15:55:57, 40.34s/it][Succeeded / Failed / Skipped / Total] 752 / 69 / 447 / 1268:  47%|     | 1269/2690 [14:12:26<15:54:32, 40.30s/it][[0 (54%)]] --> [[0 (35%)]] --> Socre: 0.6504384279251099

[[[[Adv]]]]: static void puv3_init(MachineState *machine) { ram_addr_t ram_size = machine->ram_size; const char *cpu_model = machine->cpu_model; const char *[[kernel_filename]] = machine->kernel_filename; const char *initrd_filename = machine->initrd_filename; CPUUniCore32State *env; UniCore32CPU *cpu; if (initrd_filename) { error_report("Please use kernel built-in initramdisk"); exit(1); } if (!cpu_model) { cpu_model = "UniCore-II"; } cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model)); if (!cpu) { error_report("Unable to find CPU definition"); exit(1); } env = &cpu->env; puv3_soc_init(env); puv3_board_init(env, ram_size); puv3_load_kernel([[kernel_filename]]); }

[[[[Adv]]]]: static void puv3_init(MachineState *machine) { ram_addr_t ram_size = machine->ram_size; const char *cpu_model = machine->cpu_model; const char *[[nagano]] = machine->kernel_filename; const char *initrd_filename = machine->initrd_filename; CPUUniCore32State *env; UniCore32CPU *cpu; if (initrd_filename) { error_report("Please use kernel built-in initramdisk"); exit(1); } if (!cpu_model) { cpu_model = "UniCore-II"; } cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model)); if (!cpu) { error_report("Unable to find CPU definition"); exit(1); } env = &cpu->env; puv3_soc_init(env); puv3_board_init(env, ram_size); puv3_load_kernel([[nagano]]); }
--------------------------------------------- Result 1268 ---------------------------------------------
[[0 (66%)]] --> [[0 (48%)]] --> Socre: 0.5179811418056488

[[[[Adv]]]]: process_tx_desc(E1000State *s, struct e1000_tx_desc *dp) { uint32_t txd_lower = le32_to_cpu(dp->lower.data); uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D); unsigned int split_size = txd_lower & 0xffff, bytes, sz, op; unsigned int msh = 0xfffff, hdr = 0; uint64_t addr; struct e1000_context_desc *[[xp]] = (struct e1000_context_desc *)dp; struct e1000_tx *tp = &s->tx; if (dtype == E1000_TXD_CMD_DEXT) { op = le32_to_cpu([[xp]]->cmd_and_length); tp->ipcss = [[xp]]->lower_setup.ip_fields.ipcss; tp->ipcso = [[xp]]->lower_setup.ip_fields.ipcso; tp->ipcse = le16_to_cpu([[xp]]->lower_setup.ip_fields.ipcse); tp->tucss = [[xp]]->upper_setup.tcp_fields.tucss; tp->tucso = [[xp]]->upper_setup.tcp_fields.tucso; tp->tucse = le16_to_cpu([[xp]]->upper_setup.tcp_fields.tucse); tp->paylen = op & 0xfffff; tp->hdr_len = [[xp]]->tcp_seg_setup.fields.hdr_len; tp->mss = le16_to_cpu([[xp]]->tcp_seg_setup.fields.mss); tp->ip = (op & E1000_TXD_CMD_IP) ? 1 : 0; tp->tcp = (op & E1000_TXD_CMD_TCP) ? 1 : 0; tp->tse = (op & E1000_TXD_CMD_TSE) ? 1 : 0; tp->tso_frames = 0; if (tp->tucso == 0) { DBGOUT(TXSUM, "TCP/UDP: cso 0!\n"); tp->tucso = tp->tucss + (tp->tcp ? 16 : 6); } return; } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) { if (tp->size == 0) { tp->sum_needed = le32_to_cpu(dp->upper.data) >> 8; } tp->cptse = ( txd_lower & E1000_TXD_CMD_TSE ) ? 1 : 0; } else { tp->cptse = 0; } if (vlan_enabled(s) && is_vlan_txd(txd_lower) && (tp->cptse || txd_lower & E1000_TXD_CMD_EOP)) { tp->vlan_needed = 1; cpu_to_be16wu((uint16_t *)(tp->vlan_header), le16_to_cpup((uint16_t *)(s->mac_reg + VET))); cpu_to_be16wu((uint16_t *)(tp->vlan_header + 2), le16_to_cpu(dp->upper.fields.special)); } addr = le64_to_cpu(dp->buffer_addr); if (tp->tse && tp->cptse) { hdr = tp->hdr_len; msh = hdr + tp->mss; do { bytes = split_size; if (tp->size + bytes > msh) bytes = msh - tp->size; bytes = MIN(sizeof(tp->data) - tp->size, bytes); pci_dma_read(&s->dev, addr, tp->data + tp->size, bytes); if ((sz = tp->size + bytes) >= hdr && tp->size < hdr) memmove(tp->header, tp->data, hdr); tp->size = sz; addr += bytes; if (sz == msh) { xmit_seg(s); memmove(tp->data, tp->header, hdr); tp->size = hdr; } } while (split_size -= bytes); } else if (!tp->tse && tp->cptse) { DBGOUT(TXERR, "TCP segmentaion Error\n"); } else { pci_dma_read(&s->dev, addr, tp->data + tp->size, split_size); tp->size += split_size; } if (!(txd_lower & E1000_TXD_CMD_EOP)) return; if (!(tp->tse && tp->cptse && tp->size < hdr)) xmit_seg(s); tp->tso_frames = 0; tp->sum_needed = 0; tp->vlan_needed = 0; tp->size = 0; tp->cptse = 0; }

[[[[Adv]]]]: process_tx_desc(E1000State *s, struct e1000_tx_desc *dp) { uint32_t txd_lower = le32_to_cpu(dp->lower.data); uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D); unsigned int split_size = txd_lower & 0xffff, bytes, sz, op; unsigned int msh = 0xfffff, hdr = 0; uint64_t addr; struct e1000_context_desc *[[formats]] = (struct e1000_context_desc *)dp; struct e1000_tx *tp = &s->tx; if (dtype == E1000_TXD_CMD_DEXT) { op = le32_to_cpu([[formats]]->cmd_and_length); tp->ipcss = [[formats]]->lower_setup.ip_fields.ipcss; tp->ipcso = [[formats]]->lower_setup.ip_fields.ipcso; tp->ipcse = le16_to_cpu([[formats]]->lower_setup.ip_fields.ipcse); tp->tucss = [[formats]]->upper_setup.tcp_fields.tucss; tp->tucso = [[formats]]->upper_setup.tcp_fields.tucso; tp->tucse = le16_to_cpu([[formats]]->upper_setup.tcp_fields.tucse); tp->paylen = op & 0xfffff; tp->hdr_len = [[formats]]->tcp_seg_setup.fields.hdr_len; tp->mss = le16_to_cpu([[formats]]->tcp_seg_setup.fields.mss); tp->ip = (op & E1000_TXD_CMD_IP) ? 1 : 0; tp->tcp = (op & E1000_TXD_CMD_TCP) ? 1 : 0; tp->tse = (op & E1000_TXD_CMD_TSE) ? 1 : 0; tp->tso_frames = 0; if (tp->tucso == 0) { DBGOUT(TXSUM, "TCP/UDP: cso 0!\n"); tp->tucso = tp->tucss + (tp->tcp ? 16 : 6); } return; } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) { if (tp->size == 0) { tp->sum_needed = le32_to_cpu(dp->upper.data) >> 8; } tp->cptse = ( txd_lower & E1000_TXD_CMD_TSE ) ? 1 : 0; } else { tp->cptse = 0; } if (vlan_enabled(s) && is_vlan_txd(txd_lower) && (tp->cptse || txd_lower & E1000_TXD_CMD_EOP)) { tp->vlan_needed = 1; cpu_to_be16wu((uint16_t *)(tp->vlan_header), le16_to_cpup((uint16_t *)(s->mac_reg + VET))); cpu_to_be16wu((uint16_t *)(tp->vlan_header + 2), le16_to_cpu(dp->upper.fields.special)); } addr = le64_to_cpu(dp->buffer_addr); if (tp->tse && tp->cptse) { hdr = tp->hdr_len; msh = hdr + tp->mss; do { bytes = split_size; if (tp->size + bytes > msh) bytes = msh - tp->size; bytes = MIN(sizeof(tp->data) - tp->size, bytes); pci_dma_read(&s->dev, addr, tp->data + tp->size, bytes); if ((sz = tp->size + bytes) >= hdr && tp->size < hdr) memmove(tp->header, tp->data, hdr); tp->size = sz; addr += bytes; if (sz == msh) { xmit_seg(s); memmove(tp->data, tp->header, hdr); tp->size = hdr; } } while (split_size -= bytes); } else if (!tp->tse && tp->cptse) { DBGOUT(TXERR, "TCP segmentaion Error\n"); } else { pci_dma_read(&s->dev, addr, tp->data + tp->size, split_size); tp->size += split_size; } if (!(txd_lower & E1000_TXD_CMD_EOP)) return; if (!(tp->tse && tp->cptse && tp->size < hdr)) xmit_seg(s); tp->tso_frames = 0; tp->sum_needed = 0; tp->vlan_needed = 0; tp->size = 0; tp->cptse = 0; }
--------------------------------------------- Result 1269 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 752 / 69 / 448 / 1269:  47%|     | 1269/2690 [14:12:26<15:54:32, 40.30s/it][Succeeded / Failed / Skipped / Total] 752 / 69 / 448 / 1269:  47%|     | 1270/2690 [14:12:26<15:53:07, 40.27s/it][Succeeded / Failed / Skipped / Total] 752 / 69 / 449 / 1270:  47%|     | 1270/2690 [14:12:26<15:53:07, 40.27s/it][Succeeded / Failed / Skipped / Total] 752 / 69 / 449 / 1270:  47%|     | 1271/2690 [14:13:29<15:52:52, 40.29s/it][Succeeded / Failed / Skipped / Total] 753 / 69 / 449 / 1271:  47%|     | 1271/2690 [14:13:29<15:52:52, 40.29s/it][Succeeded / Failed / Skipped / Total] 753 / 69 / 449 / 1271:  47%|     | 1272/2690 [14:13:33<15:51:32, 40.26s/it][Succeeded / Failed / Skipped / Total] 754 / 69 / 449 / 1272:  47%|     | 1272/2690 [14:13:33<15:51:32, 40.26s/it][Succeeded / Failed / Skipped / Total] 755 / 69 / 449 / 1273:  47%|     | 1273/2690 [14:13:33<15:50:07, 40.23s/it][Succeeded / Failed / Skipped / Total] 755 / 69 / 449 / 1273:  47%|     | 1274/2690 [14:13:34<15:48:42, 40.20s/it][[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset, uint64_t end_offset, void **p_feature_table, Error **errp) { BDRVQcowState *s = bs->opaque; QCowExtension ext; uint64_t offset; int ret; #ifdef DEBUG_EXT printf("qcow2_read_extensions: start=%ld end=%ld\n", start_offset, end_offset); #endif offset = start_offset; while (offset < end_offset) { #ifdef DEBUG_EXT if (offset > s->cluster_size) printf("qcow2_read_extension: suspicious offset %lu\n", offset); printf("attempting to read extended header in offset %lu\n", offset); #endif ret = bdrv_pread(bs->file, offset, &ext, sizeof(ext)); if (ret < 0) { error_setg_errno(errp, -ret, "qcow2_read_extension: ERROR: " "pread fail from offset %" PRIu64, offset); return 1; } be32_to_cpus(&ext.magic); be32_to_cpus(&ext.len); offset += sizeof(ext); #ifdef DEBUG_EXT printf("ext.magic = 0x%x\n", ext.magic); #endif if (ext.len > end_offset - offset) { error_setg(errp, "Header extension too large"); return -EINVAL; } switch (ext.magic) { case QCOW2_EXT_MAGIC_END: return 0; case QCOW2_EXT_MAGIC_BACKING_FORMAT: if (ext.len >= sizeof(bs->backing_format)) { error_setg(errp, "ERROR: ext_backing_format: len=%" PRIu32 " too large (>=%zu)", ext.len, sizeof(bs->backing_format)); return 2; } ret = bdrv_pread(bs->file, offset, bs->backing_format, ext.len); if (ret < 0) { error_setg_errno(errp, -ret, "ERROR: ext_backing_format: " "Could not read format name"); return 3; } bs->backing_format[ext.len] = '\0'; #ifdef DEBUG_EXT printf("Qcow2: Got format extension %s\n", bs->backing_format); #endif break; case QCOW2_EXT_MAGIC_FEATURE_TABLE: if (p_feature_table != NULL) { void* feature_table = g_malloc0(ext.len + 2 * sizeof(Qcow2Feature)); ret = bdrv_pread(bs->file, offset , feature_table, ext.len); if (ret < 0) { error_setg_errno(errp, -ret, "ERROR: ext_feature_table: " "Could not read table"); return ret; } *p_feature_table = feature_table; } break; default: { Qcow2UnknownHeaderExtension *uext; uext = g_malloc0(sizeof(*uext) + ext.len); uext->magic = ext.magic; uext->len = ext.len; QLIST_INSERT_HEAD(&s->unknown_header_ext, uext, next); ret = bdrv_pread(bs->file, offset , uext->data, uext->len); if (ret < 0) { error_setg_errno(errp, -ret, "ERROR: unknown extension: " "Could not read data"); return ret; } } break; } offset += ((ext.len + 7) & ~7); } return 0; }
--------------------------------------------- Result 1270 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, int dstWidth, const uint8_t *src1, const uint8_t *src2, int srcW, int xInc, const int16_t *hChrFilter, const int16_t *hChrFilterPos, int hChrFilterSize, uint8_t *formatConvBuffer, uint32_t *pal) { src1 += c->chrSrcOffset; src2 += c->chrSrcOffset; if (c->chrToYV12) { c->chrToYV12(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal); src1= formatConvBuffer; src2= formatConvBuffer+VOFW; } if (!c->hcscale_fast) { c->hScale(dst , dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize); c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize); } else { c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc); } if (c->chrConvertRange) c->chrConvertRange(dst, dstWidth); }
--------------------------------------------- Result 1271 ---------------------------------------------
[[0 (70%)]] --> [[0 (47%)]] --> Socre: 0.5282098650932312

[[[[Adv]]]]: static int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom) { AVStream *[[st]]; MOVStreamContext *[[sc]]; int ret; [[st]] = avformat_new_stream(c->fc, NULL); if (![[st]]) return AVERROR(ENOMEM); [[st]]->id = c->fc->nb_streams; [[sc]] = av_mallocz(sizeof(MOVStreamContext)); if (![[sc]]) return AVERROR(ENOMEM); [[st]]->priv_data = [[sc]]; [[st]]->codec->codec_type = AVMEDIA_TYPE_DATA; [[sc]]->ffindex = [[st]]->index; if ((ret = mov_read_default(c, pb, atom)) < 0) return ret; if ([[sc]]->chunk_count && (![[sc]]->stts_count || ![[sc]]->stsc_count || (![[sc]]->sample_size && ![[sc]]->sample_count))) { av_log(c->fc, AV_LOG_ERROR, "stream %d, missing mandatory atoms, broken header\n", [[st]]->index); return 0; } fix_timescale(c, [[sc]]); avpriv_set_pts_info([[st]], 64, 1, [[sc]]->time_scale); mov_build_index(c, [[st]]); if ([[sc]]->dref_id-1 < [[sc]]->drefs_count && [[sc]]->drefs[[[sc]]->dref_id-1].path) { MOVDref *dref = &[[sc]]->drefs[[[sc]]->dref_id - 1]; if (mov_open_dref(&[[sc]]->pb, c->fc->filename, dref, &c->fc->interrupt_callback, c->use_absolute_path, c->fc) < 0) av_log(c->fc, AV_LOG_ERROR, "stream %d, error opening alias: path='%s', dir='%s', " "filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\n", [[st]]->index, dref->path, dref->dir, dref->filename, dref->volume, dref->nlvl_from, dref->nlvl_to); } else { [[sc]]->pb = c->fc->pb; [[sc]]->pb_is_copied = 1; } if ([[st]]->codec->codec_type == AVMEDIA_TYPE_VIDEO) { if (![[st]]->sample_aspect_ratio.num && ([[st]]->codec->width != [[sc]]->width || [[st]]->codec->height != [[sc]]->height)) { [[st]]->sample_aspect_ratio = av_d2q(((double)[[st]]->codec->height * [[sc]]->width) / ((double)[[st]]->codec->width * [[sc]]->height), INT_MAX); } #if FF_API_R_FRAME_RATE if ([[sc]]->stts_count == 1 || ([[sc]]->stts_count == 2 && [[sc]]->stts_data[1].count == 1)) av_reduce(&[[st]]->r_frame_rate.num, &[[st]]->r_frame_rate.den, [[sc]]->time_scale, [[sc]]->stts_data[0].duration, INT_MAX); #endif } if (![[st]]->codec->extradata_size && [[st]]->codec->codec_id == AV_CODEC_ID_H264 && TAG_IS_AVCI([[st]]->codec->codec_tag)) { ret = ff_generate_avci_extradata([[st]]); if (ret < 0) return ret; } switch ([[st]]->codec->codec_id) { #if CONFIG_H261_DECODER case AV_CODEC_ID_H261: #endif #if CONFIG_H263_DECODER case AV_CODEC_ID_H263: #endif #if CONFIG_MPEG4_DECODER case AV_CODEC_ID_MPEG4: #endif [[st]]->codec->width = 0; [[st]]->codec->height= 0; break; } av_freep(&[[sc]]->chunk_offsets); av_freep(&[[sc]]->stsc_data); av_freep(&[[sc]]->sample_sizes); av_freep(&[[sc]]->keyframes); av_freep(&[[sc]]->stts_data); av_freep(&[[sc]]->stps_data); av_freep(&[[sc]]->elst_data); av_freep(&[[sc]]->rap_group); return 0; }

[[[[Adv]]]]: static int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom) { AVStream *[[lawrence]]; MOVStreamContext *[[shukla]]; int ret; [[lawrence]] = avformat_new_stream(c->fc, NULL); if (![[lawrence]]) return AVERROR(ENOMEM); [[lawrence]]->id = c->fc->nb_streams; [[shukla]] = av_mallocz(sizeof(MOVStreamContext)); if (![[shukla]]) return AVERROR(ENOMEM); [[lawrence]]->priv_data = [[shukla]]; [[lawrence]]->codec->codec_type = AVMEDIA_TYPE_DATA; [[shukla]]->ffindex = [[lawrence]]->index; if ((ret = mov_read_default(c, pb, atom)) < 0) return ret; if ([[shukla]]->chunk_count && (![[shukla]]->stts_count || ![[shukla]]->stsc_count || (![[shukla]]->sample_size && ![[shukla]]->sample_count))) { av_log(c->fc, AV_LOG_ERROR, "stream %d, missing mandatory atoms, broken header\n", [[lawrence]]->index); return 0; } fix_timescale(c, [[shukla]]); avpriv_set_pts_info([[lawrence]], 64, 1, [[shukla]]->time_scale); mov_build_index(c, [[lawrence]]); if ([[shukla]]->dref_id-1 < [[shukla]]->drefs_count && [[shukla]]->drefs[[[shukla]]->dref_id-1].path) { MOVDref *dref = &[[shukla]]->drefs[[[shukla]]->dref_id - 1]; if (mov_open_dref(&[[shukla]]->pb, c->fc->filename, dref, &c->fc->interrupt_callback, c->use_absolute_path, c->fc) < 0) av_log(c->fc, AV_LOG_ERROR, "stream %d, error opening alias: path='%s', dir='%s', " "filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\n", [[lawrence]]->index, dref->path, dref->dir, dref->filename, dref->volume, dref->nlvl_from, dref->nlvl_to); } else { [[shukla]]->pb = c->fc->pb; [[shukla]]->pb_is_copied = 1; } if ([[lawrence]]->codec->codec_type == AVMEDIA_TYPE_VIDEO) { if (![[lawrence]]->sample_aspect_ratio.num && ([[lawrence]]->codec->width != [[shukla]]->width || [[lawrence]]->codec->height != [[shukla]]->height)) { [[lawrence]]->sample_aspect_ratio = av_d2q(((double)[[lawrence]]->codec->height * [[shukla]]->width) / ((double)[[lawrence]]->codec->width * [[shukla]]->height), INT_MAX); } #if FF_API_R_FRAME_RATE if ([[shukla]]->stts_count == 1 || ([[shukla]]->stts_count == 2 && [[shukla]]->stts_data[1].count == 1)) av_reduce(&[[lawrence]]->r_frame_rate.num, &[[lawrence]]->r_frame_rate.den, [[shukla]]->time_scale, [[shukla]]->stts_data[0].duration, INT_MAX); #endif } if (![[lawrence]]->codec->extradata_size && [[lawrence]]->codec->codec_id == AV_CODEC_ID_H264 && TAG_IS_AVCI([[lawrence]]->codec->codec_tag)) { ret = ff_generate_avci_extradata([[lawrence]]); if (ret < 0) return ret; } switch ([[lawrence]]->codec->codec_id) { #if CONFIG_H261_DECODER case AV_CODEC_ID_H261: #endif #if CONFIG_H263_DECODER case AV_CODEC_ID_H263: #endif #if CONFIG_MPEG4_DECODER case AV_CODEC_ID_MPEG4: #endif [[lawrence]]->codec->width = 0; [[lawrence]]->codec->height= 0; break; } av_freep(&[[shukla]]->chunk_offsets); av_freep(&[[shukla]]->stsc_data); av_freep(&[[shukla]]->sample_sizes); av_freep(&[[shukla]]->keyframes); av_freep(&[[shukla]]->stts_data); av_freep(&[[shukla]]->stps_data); av_freep(&[[shukla]]->elst_data); av_freep(&[[shukla]]->rap_group); return 0; }
--------------------------------------------- Result 1272 ---------------------------------------------
[[0 (65%)]] --> [[0 (24%)]] --> Socre: 0.7648740857839584

[[[[Adv]]]]: static void spr_read_xer (DisasContext *ctx, int [[gprn]], int sprn) { gen_read_xer(cpu_gpr[[[gprn]]]); }

[[[[Adv]]]]: static void spr_read_xer (DisasContext *ctx, int [[alliteration]], int sprn) { gen_read_xer(cpu_gpr[[[alliteration]]]); }
--------------------------------------------- Result 1273 ---------------------------------------------
[[0 (17%)]] --> [[0 (52%)]] --> Socre: 0.5196545124053955

[[[[Adv]]]]: static int output_data_internal(MLPDecodeContext *m, unsigned int substr, uint8_t *data, unsigned int *data_size, int is32) { SubStream *s = &m->substream[substr]; unsigned int i, out_ch = 0; int32_t *data_32 = (int32_t*) data; int16_t *[[data_16]] = (int16_t*) data; if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2)) return -1; for (i = 0; i < s->blockpos; i++) { for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) { int mat_ch = s->ch_assign[out_ch]; int32_t sample = m->sample_buffer[i][mat_ch] << s->output_shift[mat_ch]; s->lossless_check_data ^= (sample & 0xffffff) << mat_ch; if (is32) *data_32++ = sample << 8; else *[[data_16]]++ = sample >> 8; } } *data_size = i * out_ch * (is32 ? 4 : 2); return 0; }

[[[[Adv]]]]: static int output_data_internal(MLPDecodeContext *m, unsigned int substr, uint8_t *data, unsigned int *data_size, int is32) { SubStream *s = &m->substream[substr]; unsigned int i, out_ch = 0; int32_t *data_32 = (int32_t*) data; int16_t *[[chrie]] = (int16_t*) data; if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2)) return -1; for (i = 0; i < s->blockpos; i++) { for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) { int mat_ch = s->ch_assign[out_ch]; int32_t sample = m->sample_buffer[i][mat_ch] << s->output_shift[mat_ch]; s->lossless_check_data ^= (sample & 0xffffff) << mat_ch; if (is32) *data_32++ = sample << 8; else *[[chrie]]++ = sample >> 8; } } *data_size = i * out_ch * (is32 ? 4 : 2); return 0; }
--------------------------------------------- Result 1274 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 755 / 69 / 450 / 1274:  47%|     | 1274/2690 [14:13:34<15:48:42, 40.20s/it][Succeeded / Failed / Skipped / Total] 756 / 69 / 450 / 1275:  47%|     | 1275/2690 [14:13:37<15:47:21, 40.17s/it][Succeeded / Failed / Skipped / Total] 756 / 69 / 450 / 1275:  47%|     | 1276/2690 [14:13:37<15:45:57, 40.14s/it][Succeeded / Failed / Skipped / Total] 756 / 69 / 451 / 1276:  47%|     | 1276/2690 [14:13:37<15:45:57, 40.14s/it][[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void test_qemu_strtoul_invalid(void) { const char *str = " xxxx \t abc"; char f = 'X'; const char *endptr = &f; unsigned long res = 999; int err; err = qemu_strtoul(str, &endptr, 0, &res); g_assert_cmpint(err, ==, 0); g_assert(endptr == str); }
--------------------------------------------- Result 1275 ---------------------------------------------
[[0 (63%)]] --> [[0 (47%)]] --> Socre: 0.5277025997638702

[[[[Adv]]]]: static int cpu_load_old(QEMUFile *f, void *opaque, int version_id) { PowerPCCPU *cpu = opaque; CPUPPCState *env = &cpu->env; unsigned int i, j; target_ulong [[sdr1]]; uint32_t fpscr; target_ulong xer; for (i = 0; i < 32; i++) qemu_get_betls(f, &env->gpr[i]); #if !defined(TARGET_PPC64) for (i = 0; i < 32; i++) qemu_get_betls(f, &env->gprh[i]); #endif qemu_get_betls(f, &env->lr); qemu_get_betls(f, &env->ctr); for (i = 0; i < 8; i++) qemu_get_be32s(f, &env->crf[i]); qemu_get_betls(f, &xer); cpu_write_xer(env, xer); qemu_get_betls(f, &env->reserve_addr); qemu_get_betls(f, &env->msr); for (i = 0; i < 4; i++) qemu_get_betls(f, &env->tgpr[i]); for (i = 0; i < 32; i++) { union { float64 d; uint64_t l; } u; u.l = qemu_get_be64(f); env->fpr[i] = u.d; } qemu_get_be32s(f, &fpscr); env->fpscr = fpscr; qemu_get_sbe32s(f, &env->access_type); #if defined(TARGET_PPC64) qemu_get_betls(f, &env->spr[SPR_ASR]); qemu_get_sbe32s(f, &env->slb_nr); #endif qemu_get_betls(f, &[[sdr1]]); for (i = 0; i < 32; i++) qemu_get_betls(f, &env->sr[i]); for (i = 0; i < 2; i++) for (j = 0; j < 8; j++) qemu_get_betls(f, &env->DBAT[i][j]); for (i = 0; i < 2; i++) for (j = 0; j < 8; j++) qemu_get_betls(f, &env->IBAT[i][j]); qemu_get_sbe32s(f, &env->nb_tlb); qemu_get_sbe32s(f, &env->tlb_per_way); qemu_get_sbe32s(f, &env->nb_ways); qemu_get_sbe32s(f, &env->last_way); qemu_get_sbe32s(f, &env->id_tlbs); qemu_get_sbe32s(f, &env->nb_pids); if (env->tlb.tlb6) { for (i = 0; i < env->nb_tlb; i++) { qemu_get_betls(f, &env->tlb.tlb6[i].pte0); qemu_get_betls(f, &env->tlb.tlb6[i].pte1); qemu_get_betls(f, &env->tlb.tlb6[i].EPN); } } for (i = 0; i < 4; i++) qemu_get_betls(f, &env->pb[i]); for (i = 0; i < 1024; i++) qemu_get_betls(f, &env->spr[i]); ppc_store_sdr1(env, [[sdr1]]); qemu_get_be32s(f, &env->vscr); qemu_get_be64s(f, &env->spe_acc); qemu_get_be32s(f, &env->spe_fscr); qemu_get_betls(f, &env->msr_mask); qemu_get_be32s(f, &env->flags); qemu_get_sbe32s(f, &env->error_code); qemu_get_be32s(f, &env->pending_interrupts); qemu_get_be32s(f, &env->irq_input_state); for (i = 0; i < POWERPC_EXCP_NB; i++) qemu_get_betls(f, &env->excp_vectors[i]); qemu_get_betls(f, &env->excp_prefix); qemu_get_betls(f, &env->ivor_mask); qemu_get_betls(f, &env->ivpr_mask); qemu_get_betls(f, &env->hreset_vector); qemu_get_betls(f, &env->nip); qemu_get_betls(f, &env->hflags); qemu_get_betls(f, &env->hflags_nmsr); qemu_get_sbe32s(f, &env->mmu_idx); qemu_get_sbe32(f); return 0; }

[[[[Adv]]]]: static int cpu_load_old(QEMUFile *f, void *opaque, int version_id) { PowerPCCPU *cpu = opaque; CPUPPCState *env = &cpu->env; unsigned int i, j; target_ulong [[lustful]]; uint32_t fpscr; target_ulong xer; for (i = 0; i < 32; i++) qemu_get_betls(f, &env->gpr[i]); #if !defined(TARGET_PPC64) for (i = 0; i < 32; i++) qemu_get_betls(f, &env->gprh[i]); #endif qemu_get_betls(f, &env->lr); qemu_get_betls(f, &env->ctr); for (i = 0; i < 8; i++) qemu_get_be32s(f, &env->crf[i]); qemu_get_betls(f, &xer); cpu_write_xer(env, xer); qemu_get_betls(f, &env->reserve_addr); qemu_get_betls(f, &env->msr); for (i = 0; i < 4; i++) qemu_get_betls(f, &env->tgpr[i]); for (i = 0; i < 32; i++) { union { float64 d; uint64_t l; } u; u.l = qemu_get_be64(f); env->fpr[i] = u.d; } qemu_get_be32s(f, &fpscr); env->fpscr = fpscr; qemu_get_sbe32s(f, &env->access_type); #if defined(TARGET_PPC64) qemu_get_betls(f, &env->spr[SPR_ASR]); qemu_get_sbe32s(f, &env->slb_nr); #endif qemu_get_betls(f, &[[lustful]]); for (i = 0; i < 32; i++) qemu_get_betls(f, &env->sr[i]); for (i = 0; i < 2; i++) for (j = 0; j < 8; j++) qemu_get_betls(f, &env->DBAT[i][j]); for (i = 0; i < 2; i++) for (j = 0; j < 8; j++) qemu_get_betls(f, &env->IBAT[i][j]); qemu_get_sbe32s(f, &env->nb_tlb); qemu_get_sbe32s(f, &env->tlb_per_way); qemu_get_sbe32s(f, &env->nb_ways); qemu_get_sbe32s(f, &env->last_way); qemu_get_sbe32s(f, &env->id_tlbs); qemu_get_sbe32s(f, &env->nb_pids); if (env->tlb.tlb6) { for (i = 0; i < env->nb_tlb; i++) { qemu_get_betls(f, &env->tlb.tlb6[i].pte0); qemu_get_betls(f, &env->tlb.tlb6[i].pte1); qemu_get_betls(f, &env->tlb.tlb6[i].EPN); } } for (i = 0; i < 4; i++) qemu_get_betls(f, &env->pb[i]); for (i = 0; i < 1024; i++) qemu_get_betls(f, &env->spr[i]); ppc_store_sdr1(env, [[lustful]]); qemu_get_be32s(f, &env->vscr); qemu_get_be64s(f, &env->spe_acc); qemu_get_be32s(f, &env->spe_fscr); qemu_get_betls(f, &env->msr_mask); qemu_get_be32s(f, &env->flags); qemu_get_sbe32s(f, &env->error_code); qemu_get_be32s(f, &env->pending_interrupts); qemu_get_be32s(f, &env->irq_input_state); for (i = 0; i < POWERPC_EXCP_NB; i++) qemu_get_betls(f, &env->excp_vectors[i]); qemu_get_betls(f, &env->excp_prefix); qemu_get_betls(f, &env->ivor_mask); qemu_get_betls(f, &env->ivpr_mask); qemu_get_betls(f, &env->hreset_vector); qemu_get_betls(f, &env->nip); qemu_get_betls(f, &env->hflags); qemu_get_betls(f, &env->hflags_nmsr); qemu_get_sbe32s(f, &env->mmu_idx); qemu_get_sbe32(f); return 0; }
--------------------------------------------- Result 1276 ---------------------------------------------
[[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void aml_free(gpointer data, gpointer user_data) { Aml *var = data; build_free_array(var->buf); }
--------------------------------------------- Result 1277 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 757 / 69 / 451 / 1277:  47%|     | 1277/2690 [14:14:09<15:45:08, 40.13s/it][Succeeded / Failed / Skipped / Total] 757 / 69 / 451 / 1277:  48%|     | 1278/2690 [14:14:10<15:43:44, 40.10s/it][Succeeded / Failed / Skipped / Total] 757 / 69 / 452 / 1278:  48%|     | 1278/2690 [14:14:10<15:43:44, 40.10s/it][Succeeded / Failed / Skipped / Total] 757 / 69 / 452 / 1278:  48%|     | 1279/2690 [14:16:44<15:45:10, 40.19s/it][Succeeded / Failed / Skipped / Total] 758 / 69 / 452 / 1279:  48%|     | 1279/2690 [14:16:44<15:45:10, 40.19s/it][Succeeded / Failed / Skipped / Total] 758 / 69 / 452 / 1279:  48%|     | 1280/2690 [14:16:45<15:43:46, 40.16s/it][Succeeded / Failed / Skipped / Total] 758 / 69 / 453 / 1280:  48%|     | 1280/2690 [14:16:45<15:43:46, 40.16s/it][Succeeded / Failed / Skipped / Total] 758 / 69 / 453 / 1280:  48%|     | 1281/2690 [14:16:45<15:42:22, 40.13s/it][Succeeded / Failed / Skipped / Total] 758 / 69 / 454 / 1281:  48%|     | 1281/2690 [14:16:45<15:42:22, 40.13s/it][Succeeded / Failed / Skipped / Total] 758 / 69 / 454 / 1281:  48%|     | 1282/2690 [14:17:26<15:41:42, 40.13s/it][Succeeded / Failed / Skipped / Total] 759 / 69 / 454 / 1282:  48%|     | 1282/2690 [14:17:26<15:41:42, 40.13s/it][Succeeded / Failed / Skipped / Total] 759 / 69 / 454 / 1282:  48%|     | 1283/2690 [14:17:26<15:40:18, 40.10s/it][[0 (35%)]] --> [[0 (51%)]] --> Socre: 0.5144897699356079

[[[[Adv]]]]: static void virtio_scsi_handle_cmd(VirtIODevice *[[vdev]], VirtQueue *vq) { VirtIOSCSI *s = (VirtIOSCSI *)[[vdev]]; VirtIOSCSICommon *vs = &s->parent_obj; VirtIOSCSIReq *req; int n; while ((req = virtio_scsi_pop_req(s, vq))) { SCSIDevice *d; int out_size, in_size; if (req->elem.out_num < 1 || req->elem.in_num < 1) { virtio_scsi_bad_req(); } out_size = req->elem.out_sg[0].iov_len; in_size = req->elem.in_sg[0].iov_len; if (out_size < sizeof(VirtIOSCSICmdReq) + vs->cdb_size || in_size < sizeof(VirtIOSCSICmdResp) + vs->sense_size) { virtio_scsi_bad_req(); } if (req->elem.out_num > 1 && req->elem.in_num > 1) { virtio_scsi_fail_cmd_req(req); continue; } d = virtio_scsi_device_find(s, req->req.cmd->lun); if (!d) { req->resp.cmd->response = VIRTIO_SCSI_S_BAD_TARGET; virtio_scsi_complete_req(req); continue; } req->sreq = scsi_req_new(d, req->req.cmd->tag, virtio_scsi_get_lun(req->req.cmd->lun), req->req.cmd->cdb, req); if (req->sreq->cmd.mode != SCSI_XFER_NONE) { int req_mode = (req->elem.in_num > 1 ? SCSI_XFER_FROM_DEV : SCSI_XFER_TO_DEV); if (req->sreq->cmd.mode != req_mode || req->sreq->cmd.xfer > req->qsgl.size) { req->resp.cmd->response = VIRTIO_SCSI_S_OVERRUN; virtio_scsi_complete_req(req); continue; } } n = scsi_req_enqueue(req->sreq); if (n) { scsi_req_continue(req->sreq); } } }

[[[[Adv]]]]: static void virtio_scsi_handle_cmd(VirtIODevice *[[guerra]], VirtQueue *vq) { VirtIOSCSI *s = (VirtIOSCSI *)[[guerra]]; VirtIOSCSICommon *vs = &s->parent_obj; VirtIOSCSIReq *req; int n; while ((req = virtio_scsi_pop_req(s, vq))) { SCSIDevice *d; int out_size, in_size; if (req->elem.out_num < 1 || req->elem.in_num < 1) { virtio_scsi_bad_req(); } out_size = req->elem.out_sg[0].iov_len; in_size = req->elem.in_sg[0].iov_len; if (out_size < sizeof(VirtIOSCSICmdReq) + vs->cdb_size || in_size < sizeof(VirtIOSCSICmdResp) + vs->sense_size) { virtio_scsi_bad_req(); } if (req->elem.out_num > 1 && req->elem.in_num > 1) { virtio_scsi_fail_cmd_req(req); continue; } d = virtio_scsi_device_find(s, req->req.cmd->lun); if (!d) { req->resp.cmd->response = VIRTIO_SCSI_S_BAD_TARGET; virtio_scsi_complete_req(req); continue; } req->sreq = scsi_req_new(d, req->req.cmd->tag, virtio_scsi_get_lun(req->req.cmd->lun), req->req.cmd->cdb, req); if (req->sreq->cmd.mode != SCSI_XFER_NONE) { int req_mode = (req->elem.in_num > 1 ? SCSI_XFER_FROM_DEV : SCSI_XFER_TO_DEV); if (req->sreq->cmd.mode != req_mode || req->sreq->cmd.xfer > req->qsgl.size) { req->resp.cmd->response = VIRTIO_SCSI_S_OVERRUN; virtio_scsi_complete_req(req); continue; } } n = scsi_req_enqueue(req->sreq); if (n) { scsi_req_continue(req->sreq); } } }
--------------------------------------------- Result 1278 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: CharDriverState *text_console_init(QemuOpts *opts) { CharDriverState *chr; QemuConsole *s; unsigned width; unsigned height; chr = g_malloc0(sizeof(CharDriverState)); width = qemu_opt_get_number(opts, "width", 0); if (width == 0) width = qemu_opt_get_number(opts, "cols", 0) * FONT_WIDTH; height = qemu_opt_get_number(opts, "height", 0); if (height == 0) height = qemu_opt_get_number(opts, "rows", 0) * FONT_HEIGHT; if (width == 0 || height == 0) { s = new_console(NULL, TEXT_CONSOLE); } else { s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE); } if (!s) { g_free(chr); return NULL; } s->chr = chr; s->g_width = width; s->g_height = height; chr->opaque = s; chr->chr_set_echo = text_console_set_echo; return chr; }
--------------------------------------------- Result 1279 ---------------------------------------------
[[0 (2%)]] --> [[0 (63%)]] --> Socre: 0.6311020255088806

[[[[Adv]]]]: static uint64_t eepro100_read(void *opaque, target_phys_addr_t [[addr]], unsigned size) { EEPRO100State *s = opaque; switch (size) { case 1: return eepro100_read1(s, [[addr]]); case 2: return eepro100_read2(s, [[addr]]); case 4: return eepro100_read4(s, [[addr]]); default: abort(); } }

[[[[Adv]]]]: static uint64_t eepro100_read(void *opaque, target_phys_addr_t [[fiance]], unsigned size) { EEPRO100State *s = opaque; switch (size) { case 1: return eepro100_read1(s, [[fiance]]); case 2: return eepro100_read2(s, [[fiance]]); case 4: return eepro100_read4(s, [[fiance]]); default: abort(); } }
--------------------------------------------- Result 1280 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: bool vring_should_notify(VirtIODevice *vdev, Vring *vring) { uint16_t old, new; bool v; smp_mb(); if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) && unlikely(!vring_more_avail(vdev, vring))) { return "True" == "True"; } if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) { return !(vring_get_avail_flags(vdev, vring) & VRING_AVAIL_F_NO_INTERRUPT); } old = vring->signalled_used; v = vring->signalled_used_valid; new = vring->signalled_used = vring->last_used_idx; vring->signalled_used_valid = "True" == "True"; if (unlikely(!v)) { return "True" == "True"; } return vring_need_event(vring_used_event(&vring->vr), new, old); }
--------------------------------------------- Result 1281 ---------------------------------------------
[[0 (91%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int amr_nb_encode_frame(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet_ptr) { AMRContext *s = avctx->priv_data; int written, ret; int16_t *flush_buf = NULL; const int16_t *samples = frame ? (const int16_t *)frame->data[0] : NULL; if (s->enc_bitrate != avctx->bit_rate) { s->enc_mode = get_bitrate_mode(avctx->bit_rate, avctx); s->enc_bitrate = avctx->bit_rate; } if ((ret = ff_alloc_packet(avpkt, 32))) { av_log(avctx, AV_LOG_ERROR, "Error getting output packet\n"); return ret; } if (frame) { if (frame->nb_samples < avctx->frame_size) { flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf)); if (!flush_buf) return AVERROR(ENOMEM); memcpy(flush_buf, samples, frame->nb_samples * sizeof(*flush_buf)); samples = flush_buf; if (frame->nb_samples < avctx->frame_size - avctx->delay) s->enc_last_frame = -1; } if ((ret = ff_af_queue_add(&s->afq, frame)) < 0) { av_freep(&flush_buf); return ret; } } else { if (s->enc_last_frame < 0) return 0; flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf)); if (!flush_buf) return AVERROR(ENOMEM); samples = flush_buf; s->enc_last_frame = -1; } written = Encoder_Interface_Encode(s->enc_state, s->enc_mode, samples, avpkt->data, 0); av_dlog(avctx, "amr_nb_encode_frame encoded %u bytes, bitrate %u, first byte was %#02x\n", written, s->enc_mode, frame[0]); ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts, &avpkt->duration); avpkt->size = written; *got_packet_ptr = 1; av_freep(&flush_buf); return 0; }
--------------------------------------------- Result 1282 ---------------------------------------------
[[0 (9%)]] --> [[0 (71%)]] --> Socre: 0.7117801308631897

[[[[Adv]]]]: void do_unassigned_access(target_phys_addr_t [[addr]], int is_write, int is_exec, int is_asi, int size) { CPUState *saved_env; saved_env = env; env = cpu_single_env; qemu_log("Unassigned " TARGET_FMT_plx " wr=%d exe=%d\n", [[addr]], is_write, is_exec); if (!(env->sregs[SR_MSR] & MSR_EE)) { return; } if (is_exec) { if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) { env->sregs[SR_ESR] = ESR_EC_INSN_BUS; helper_raise_exception(EXCP_HW_EXCP); } } else { if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) { env->sregs[SR_ESR] = ESR_EC_DATA_BUS; helper_raise_exception(EXCP_HW_EXCP); } } }

[[[[Adv]]]]: void do_unassigned_access(target_phys_addr_t [[ento]], int is_write, int is_exec, int is_asi, int size) { CPUState *saved_env; saved_env = env; env = cpu_single_env; qemu_log("Unassigned " TARGET_FMT_plx " wr=%d exe=%d\n", [[ento]], is_write, is_exec); if (!(env->sregs[SR_MSR] & MSR_EE)) { return; } if (is_exec) { if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) { env->sregs[SR_ESR] = ESR_EC_INSN_BUS; helper_raise_exception(EXCP_HW_EXCP); } } else { if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) { env->sregs[SR_ESR] = ESR_EC_DATA_BUS; helper_raise_exception(EXCP_HW_EXCP); } } }
--------------------------------------------- Result 1283 ---------------------------------------------
[[0 (41%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int RENAME(swScale)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY, int srcSliceH, uint8_t* dst[], int dstStride[]){ const int srcW= c->srcW; const int dstW= c->dstW; const int dstH= c->dstH; const int chrDstW= c->chrDstW; const int chrSrcW= c->chrSrcW; const int lumXInc= c->lumXInc; const int chrXInc= c->chrXInc; const int dstFormat= c->dstFormat; const int srcFormat= c->srcFormat; const int flags= c->flags; const int canMMX2BeUsed= c->canMMX2BeUsed; int16_t *vLumFilterPos= c->vLumFilterPos; int16_t *vChrFilterPos= c->vChrFilterPos; int16_t *hLumFilterPos= c->hLumFilterPos; int16_t *hChrFilterPos= c->hChrFilterPos; int16_t *vLumFilter= c->vLumFilter; int16_t *vChrFilter= c->vChrFilter; int16_t *hLumFilter= c->hLumFilter; int16_t *hChrFilter= c->hChrFilter; int32_t *lumMmxFilter= c->lumMmxFilter; int32_t *chrMmxFilter= c->chrMmxFilter; const int vLumFilterSize= c->vLumFilterSize; const int vChrFilterSize= c->vChrFilterSize; const int hLumFilterSize= c->hLumFilterSize; const int hChrFilterSize= c->hChrFilterSize; int16_t **lumPixBuf= c->lumPixBuf; int16_t **chrPixBuf= c->chrPixBuf; const int vLumBufSize= c->vLumBufSize; const int vChrBufSize= c->vChrBufSize; uint8_t *funnyYCode= c->funnyYCode; uint8_t *funnyUVCode= c->funnyUVCode; uint8_t *formatConvBuffer= c->formatConvBuffer; const int chrSrcSliceY= srcSliceY >> c->chrSrcVSubSample; const int chrSrcSliceH= -((-srcSliceH) >> c->chrSrcVSubSample); int lastDstY; uint8_t *pal=NULL; int dstY= c->dstY; int lumBufIndex= c->lumBufIndex; int chrBufIndex= c->chrBufIndex; int lastInLumBuf= c->lastInLumBuf; int lastInChrBuf= c->lastInChrBuf; if(isPacked(c->srcFormat)){ pal= src[1]; src[0]= src[1]= src[2]= src[0]; srcStride[0]= srcStride[1]= srcStride[2]= srcStride[0]; } srcStride[1]<<= c->vChrDrop; srcStride[2]<<= c->vChrDrop; #if 0 { static volatile int i=0; i++; if(srcFormat==PIX_FMT_YUV420P && i==1 && srcSliceH>= c->srcH) selfTest(src, srcStride, c->srcW, c->srcH); i--; } #endif if(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0) { static int firstTime=1; if(flags & SWS_PRINT_INFO && firstTime) { av_log(c, AV_LOG_WARNING, "SwScaler: Warning: dstStride is not aligned!\n" "SwScaler: ->cannot do aligned memory acesses anymore\n"); firstTime=0; } } if(srcSliceY ==0){ lumBufIndex=0; chrBufIndex=0; dstY=0; lastInLumBuf= -1; lastInChrBuf= -1; } lastDstY= dstY; for(;dstY < dstH; dstY++){ unsigned char *dest =dst[0]+dstStride[0]*dstY; const int chrDstY= dstY>>c->chrDstVSubSample; unsigned char *uDest=dst[1]+dstStride[1]*chrDstY; unsigned char *vDest=dst[2]+dstStride[2]*chrDstY; const int firstLumSrcY= vLumFilterPos[dstY]; const int firstChrSrcY= vChrFilterPos[chrDstY]; const int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; const int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; if(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1; if(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1; ASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1) ASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1) if(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>c->chrSrcVSubSample)) { while(lastInLumBuf < lastLumSrcY) { uint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0]; lumBufIndex++; ASSERT(lumBufIndex < 2*vLumBufSize) ASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH) ASSERT(lastInLumBuf + 1 - srcSliceY >= 0) RENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc, flags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize, funnyYCode, c->srcFormat, formatConvBuffer, c->lumMmx2Filter, c->lumMmx2FilterPos, pal); lastInLumBuf++; } while(lastInChrBuf < lastChrSrcY) { uint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1]; uint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2]; chrBufIndex++; ASSERT(chrBufIndex < 2*vChrBufSize) ASSERT(lastInChrBuf + 1 - chrSrcSliceY < (chrSrcSliceH)) ASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0) if(!(isGray(srcFormat) || isGray(dstFormat))) RENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc, flags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize, funnyUVCode, c->srcFormat, formatConvBuffer, c->chrMmx2Filter, c->chrMmx2FilterPos, pal); lastInChrBuf++; } if(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize; if(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize; } else { while(lastInLumBuf+1 < srcSliceY + srcSliceH) { uint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0]; lumBufIndex++; ASSERT(lumBufIndex < 2*vLumBufSize) ASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH) ASSERT(lastInLumBuf + 1 - srcSliceY >= 0) RENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc, flags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize, funnyYCode, c->srcFormat, formatConvBuffer, c->lumMmx2Filter, c->lumMmx2FilterPos, pal); lastInLumBuf++; } while(lastInChrBuf+1 < (chrSrcSliceY + chrSrcSliceH)) { uint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1]; uint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2]; chrBufIndex++; ASSERT(chrBufIndex < 2*vChrBufSize) ASSERT(lastInChrBuf + 1 - chrSrcSliceY < chrSrcSliceH) ASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0) if(!(isGray(srcFormat) || isGray(dstFormat))) RENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc, flags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize, funnyUVCode, c->srcFormat, formatConvBuffer, c->chrMmx2Filter, c->chrMmx2FilterPos, pal); lastInChrBuf++; } if(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize; if(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize; break; } #ifdef HAVE_MMX b5Dither= dither8[dstY&1]; g6Dither= dither4[dstY&1]; g5Dither= dither8[dstY&1]; r5Dither= dither8[(dstY+1)&1]; #endif if(dstY < dstH-2) { int16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize; int16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize; #ifdef HAVE_MMX int i; if(flags & SWS_ACCURATE_RND){ for(i=0; i<vLumFilterSize; i+=2){ lumMmxFilter[2*i+0]= (int32_t)lumSrcPtr[i ]; lumMmxFilter[2*i+1]= (int32_t)lumSrcPtr[i+(vLumFilterSize>1)]; lumMmxFilter[2*i+2]= lumMmxFilter[2*i+3]= vLumFilter[dstY*vLumFilterSize + i ] + (vLumFilterSize>1 ? vLumFilter[dstY*vLumFilterSize + i + 1]<<16 : 0); } for(i=0; i<vChrFilterSize; i+=2){ chrMmxFilter[2*i+0]= (int32_t)chrSrcPtr[i ]; chrMmxFilter[2*i+1]= (int32_t)chrSrcPtr[i+(vChrFilterSize>1)]; chrMmxFilter[2*i+2]= chrMmxFilter[2*i+3]= vChrFilter[chrDstY*vChrFilterSize + i ] + (vChrFilterSize>1 ? vChrFilter[chrDstY*vChrFilterSize + i + 1]<<16 : 0); } }else{ for(i=0; i<vLumFilterSize; i++) { lumMmxFilter[4*i+0]= (int32_t)lumSrcPtr[i]; lumMmxFilter[4*i+1]= (uint64_t)lumSrcPtr[i] >> 32; lumMmxFilter[4*i+2]= lumMmxFilter[4*i+3]= ((uint16_t)vLumFilter[dstY*vLumFilterSize + i])*0x10001; } for(i=0; i<vChrFilterSize; i++) { chrMmxFilter[4*i+0]= (int32_t)chrSrcPtr[i]; chrMmxFilter[4*i+2]= chrMmxFilter[4*i+3]= ((uint16_t)vChrFilter[chrDstY*vChrFilterSize + i])*0x10001; } } #endif if(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){ const int chrSkipMask= (1<<c->chrDstVSubSample)-1; if(dstY&chrSkipMask) uDest= NULL; RENAME(yuv2nv12X)(c, vLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, dest, uDest, dstW, chrDstW, dstFormat); } else if(isPlanarYUV(dstFormat) || isGray(dstFormat)) { const int chrSkipMask= (1<<c->chrDstVSubSample)-1; if((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; if(vLumFilterSize == 1 && vChrFilterSize == 1) { int16_t *lumBuf = lumPixBuf[0]; int16_t *chrBuf= chrPixBuf[0]; RENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW, chrDstW); } else { RENAME(yuv2yuvX)(c, vLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, dest, uDest, vDest, dstW, chrDstW); } } else { ASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2); ASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2); if(vLumFilterSize == 1 && vChrFilterSize == 2) { int chrAlpha= vChrFilter[2*dstY+1]; RENAME(yuv2packed1)(c, *lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1), dest, dstW, chrAlpha, dstFormat, flags, dstY); } else if(vLumFilterSize == 2 && vChrFilterSize == 2) { int lumAlpha= vLumFilter[2*dstY+1]; int chrAlpha= vChrFilter[2*dstY+1]; lumMmxFilter[2]= lumMmxFilter[3]= vLumFilter[2*dstY ]*0x10001; chrMmxFilter[2]= chrMmxFilter[3]= vChrFilter[2*chrDstY]*0x10001; RENAME(yuv2packed2)(c, *lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1), dest, dstW, lumAlpha, chrAlpha, dstY); } else { RENAME(yuv2packedX)(c, vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize, vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, dest, dstW, dstY); } } } else { int16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize; int16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize; if(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){ const int chrSkipMask= (1<<c->chrDstVSubSample)-1; if(dstY&chrSkipMask) uDest= NULL; yuv2nv12XinC( vLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, dest, uDest, dstW, chrDstW, dstFormat); } else if(isPlanarYUV(dstFormat) || isGray(dstFormat)) { const int chrSkipMask= (1<<c->chrDstVSubSample)-1; if((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; yuv2yuvXinC( vLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, dest, uDest, vDest, dstW, chrDstW); } else { ASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2); ASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2); yuv2packedXinC(c, vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize, vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, dest, dstW, dstY); } } } #ifdef HAVE_MMX __asm __volatile(SFENCE:::"memory"); __asm __volatile(EMMS:::"memory"); #endif c->dstY= dstY; c->lumBufIndex= lumBufIndex; c->chrBufIndex= chrBufIndex; c->lastInLumBuf= lastInLumBuf; c->lastInChrBuf= lastInChrBuf; return dstY - lastDstY; }[Succeeded / Failed / Skipped / Total] 759 / 69 / 455 / 1283:  48%|     | 1283/2690 [14:17:26<15:40:18, 40.10s/it][Succeeded / Failed / Skipped / Total] 759 / 69 / 455 / 1283:  48%|     | 1284/2690 [14:17:27<15:38:55, 40.07s/it][Succeeded / Failed / Skipped / Total] 759 / 69 / 456 / 1284:  48%|     | 1284/2690 [14:17:27<15:38:55, 40.07s/it][Succeeded / Failed / Skipped / Total] 759 / 69 / 456 / 1284:  48%|     | 1285/2690 [14:17:27<15:37:31, 40.04s/it][Succeeded / Failed / Skipped / Total] 759 / 69 / 457 / 1285:  48%|     | 1285/2690 [14:17:27<15:37:31, 40.04s/it][Succeeded / Failed / Skipped / Total] 759 / 69 / 457 / 1285:  48%|     | 1286/2690 [14:17:28<15:36:08, 40.01s/it][Succeeded / Failed / Skipped / Total] 759 / 69 / 458 / 1286:  48%|     | 1286/2690 [14:17:28<15:36:08, 40.01s/it][Succeeded / Failed / Skipped / Total] 759 / 69 / 458 / 1286:  48%|     | 1287/2690 [14:17:28<15:34:45, 39.98s/it]
--------------------------------------------- Result 1284 ---------------------------------------------
[[0 (8%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void RENAME(bgr24ToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused) { #if COMPILE_TEMPLATE_MMX RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_BGR24); #else int i; for (i=0; i<width; i++) { int b= src[i*3+0]; int g= src[i*3+1]; int r= src[i*3+2]; dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT); } #endif }
--------------------------------------------- Result 1285 ---------------------------------------------
[[0 (9%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void FUNC(ff_simple_idct)(DCTELEM *block) { int i; for (i = 0; i < 8; i++) FUNC(idctRowCondDC)(block + i*8); for (i = 0; i < 8; i++) FUNC(idctSparseCol)(block + i); }
--------------------------------------------- Result 1286 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev) { if (ohci->async_td && ohci->usb_packet.owner != NULL && ohci->usb_packet.owner->dev == dev) { usb_cancel_packet(&ohci->usb_packet); ohci->async_td = 0; } }
--------------------------------------------- Result 1287 ---------------------------------------------
[[0 (47%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int av_encode(AVFormatContext **output_files, int nb_output_files, AVFormatContext **input_files, int nb_input_files, AVStreamMap *stream_maps, int nb_stream_maps) { int ret, i, j, k, n, nb_istreams = 0, nb_ostreams = 0; AVFormatContext *is, *os; AVCodecContext *codec, *icodec; AVOutputStream *ost, **ost_table = NULL; AVInputStream *ist, **ist_table = NULL; AVInputFile *file_table; AVFormatContext *stream_no_data; int key; file_table= (AVInputFile*) av_mallocz(nb_input_files * sizeof(AVInputFile)); if (!file_table) goto fail; j = 0; for(i=0;i<nb_input_files;i++) { is = input_files[i]; file_table[i].ist_index = j; file_table[i].nb_streams = is->nb_streams; j += is->nb_streams; } nb_istreams = j; ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *)); if (!ist_table) goto fail; for(i=0;i<nb_istreams;i++) { ist = av_mallocz(sizeof(AVInputStream)); if (!ist) goto fail; ist_table[i] = ist; } j = 0; for(i=0;i<nb_input_files;i++) { is = input_files[i]; for(k=0;k<is->nb_streams;k++) { ist = ist_table[j++]; ist->st = is->streams[k]; ist->file_index = i; ist->index = k; ist->discard = 1; if (ist->st->codec.rate_emu) { ist->start = av_gettime(); ist->frame = 0; } } } nb_ostreams = 0; for(i=0;i<nb_output_files;i++) { os = output_files[i]; nb_ostreams += os->nb_streams; } if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) { fprintf(stderr, "Number of stream maps must match number of output streams\n"); exit(1); } for(i=0;i<nb_stream_maps;i++) { int fi = stream_maps[i].file_index; int si = stream_maps[i].stream_index; if (fi < 0 || fi > nb_input_files - 1 || si < 0 || si > file_table[fi].nb_streams - 1) { fprintf(stderr,"Could not find input stream #%d.%d\n", fi, si); exit(1); } } ost_table = av_mallocz(sizeof(AVOutputStream *) * nb_ostreams); if (!ost_table) goto fail; for(i=0;i<nb_ostreams;i++) { ost = av_mallocz(sizeof(AVOutputStream)); if (!ost) goto fail; ost_table[i] = ost; } n = 0; for(k=0;k<nb_output_files;k++) { os = output_files[k]; for(i=0;i<os->nb_streams;i++) { int found; ost = ost_table[n++]; ost->file_index = k; ost->index = i; ost->st = os->streams[i]; if (nb_stream_maps > 0) { ost->source_index = file_table[stream_maps[n-1].file_index].ist_index + stream_maps[n-1].stream_index; if (ist_table[ost->source_index]->st->codec.codec_type != ost->st->codec.codec_type) { fprintf(stderr, "Codec type mismatch for mapping #%d.%d -> #%d.%d\n", stream_maps[n-1].file_index, stream_maps[n-1].stream_index, ost->file_index, ost->index); exit(1); } } else { found = 0; for(j=0;j<nb_istreams;j++) { ist = ist_table[j]; if (ist->discard && ist->st->codec.codec_type == ost->st->codec.codec_type) { ost->source_index = j; found = 1; } } if (!found) { for(j=0;j<nb_istreams;j++) { ist = ist_table[j]; if (ist->st->codec.codec_type == ost->st->codec.codec_type) { ost->source_index = j; found = 1; } } if (!found) { fprintf(stderr, "Could not find input stream matching output stream #%d.%d\n", ost->file_index, ost->index); exit(1); } } } ist = ist_table[ost->source_index]; ist->discard = 0; } } for(i=0;i<nb_ostreams;i++) { ost = ost_table[i]; ist = ist_table[ost->source_index]; codec = &ost->st->codec; icodec = &ist->st->codec; if (ost->st->stream_copy) { codec->codec_id = icodec->codec_id; codec->codec_type = icodec->codec_type; codec->codec_tag = icodec->codec_tag; codec->bit_rate = icodec->bit_rate; switch(codec->codec_type) { case CODEC_TYPE_AUDIO: codec->sample_rate = icodec->sample_rate; codec->channels = icodec->channels; break; case CODEC_TYPE_VIDEO: codec->frame_rate = icodec->frame_rate; codec->frame_rate_base = icodec->frame_rate_base; codec->width = icodec->width; codec->height = icodec->height; break; default: av_abort(); } } else { switch(codec->codec_type) { case CODEC_TYPE_AUDIO: if (fifo_init(&ost->fifo, 2 * MAX_AUDIO_PACKET_SIZE)) goto fail; if (codec->channels == icodec->channels && codec->sample_rate == icodec->sample_rate) { ost->audio_resample = 0; } else { if (codec->channels != icodec->channels && icodec->codec_id == CODEC_ID_AC3) { icodec->channels = codec->channels; if (codec->sample_rate == icodec->sample_rate) ost->audio_resample = 0; else { ost->audio_resample = 1; ost->resample = audio_resample_init(codec->channels, icodec->channels, codec->sample_rate, icodec->sample_rate); if(!ost->resample) { printf("Can't resample. Aborting.\n"); av_abort(); } } icodec->channels = codec->channels; } else { ost->audio_resample = 1; ost->resample = audio_resample_init(codec->channels, icodec->channels, codec->sample_rate, icodec->sample_rate); if(!ost->resample) { printf("Can't resample. Aborting.\n"); av_abort(); } } } ist->decoding_needed = 1; ost->encoding_needed = 1; break; case CODEC_TYPE_VIDEO: if (codec->width == icodec->width && codec->height == icodec->height && frame_topBand == 0 && frame_bottomBand == 0 && frame_leftBand == 0 && frame_rightBand == 0) { ost->video_resample = 0; ost->video_crop = 0; } else if ((codec->width == icodec->width - (frame_leftBand + frame_rightBand)) && (codec->height == icodec->height - (frame_topBand + frame_bottomBand))) { ost->video_resample = 0; ost->video_crop = 1; ost->topBand = frame_topBand; ost->leftBand = frame_leftBand; } else { uint8_t *buf; ost->video_resample = 1; ost->video_crop = 0; buf = av_malloc((codec->width * codec->height * 3) / 2); if (!buf) goto fail; ost->pict_tmp.data[0] = buf; ost->pict_tmp.data[1] = ost->pict_tmp.data[0] + (codec->width * codec->height); ost->pict_tmp.data[2] = ost->pict_tmp.data[1] + (codec->width * codec->height) / 4; ost->pict_tmp.linesize[0] = codec->width; ost->pict_tmp.linesize[1] = codec->width / 2; ost->pict_tmp.linesize[2] = codec->width / 2; ost->img_resample_ctx = img_resample_full_init( ost->st->codec.width, ost->st->codec.height, ist->st->codec.width, ist->st->codec.height, frame_topBand, frame_bottomBand, frame_leftBand, frame_rightBand); } ost->encoding_needed = 1; ist->decoding_needed = 1; break; default: av_abort(); } if (ost->encoding_needed && (codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2))) { char logfilename[1024]; FILE *f; int size; char *logbuffer; snprintf(logfilename, sizeof(logfilename), "%s-%d.log", pass_logfilename ? pass_logfilename : DEFAULT_PASS_LOGFILENAME, i); if (codec->flags & CODEC_FLAG_PASS1) { f = fopen(logfilename, "w"); if (!f) { perror(logfilename); exit(1); } ost->logfile = f; } else { f = fopen(logfilename, "r"); if (!f) { perror(logfilename); exit(1); } fseek(f, 0, SEEK_END); size = ftell(f); fseek(f, 0, SEEK_SET); logbuffer = av_malloc(size + 1); if (!logbuffer) { fprintf(stderr, "Could not allocate log buffer\n"); exit(1); } fread(logbuffer, 1, size, f); fclose(f); logbuffer[size] = '\0'; codec->stats_in = logbuffer; } } } } for(i=0;i<nb_output_files;i++) { dump_format(output_files[i], i, output_files[i]->filename, 1); } fprintf(stderr, "Stream mapping:\n"); for(i=0;i<nb_ostreams;i++) { ost = ost_table[i]; fprintf(stderr, " Stream #%d.%d -> #%d.%d\n", ist_table[ost->source_index]->file_index, ist_table[ost->source_index]->index, ost->file_index, ost->index); } for(i=0;i<nb_ostreams;i++) { ost = ost_table[i]; if (ost->encoding_needed) { AVCodec *codec; codec = avcodec_find_encoder(ost->st->codec.codec_id); if (!codec) { fprintf(stderr, "Unsupported codec for output stream #%d.%d\n", ost->file_index, ost->index); exit(1); } if (avcodec_open(&ost->st->codec, codec) < 0) { fprintf(stderr, "Error while opening codec for stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height\n", ost->file_index, ost->index); exit(1); } } } for(i=0;i<nb_istreams;i++) { ist = ist_table[i]; if (ist->decoding_needed) { AVCodec *codec; codec = avcodec_find_decoder(ist->st->codec.codec_id); if (!codec) { fprintf(stderr, "Unsupported codec (id=%d) for input stream #%d.%d\n", ist->st->codec.codec_id, ist->file_index, ist->index); exit(1); } if (avcodec_open(&ist->st->codec, codec) < 0) { fprintf(stderr, "Error while opening codec for input stream #%d.%d\n", ist->file_index, ist->index); exit(1); } ist->frame_decoded = 1; } } for(i=0;i<nb_istreams;i++) { ist = ist_table[i]; is = input_files[ist->file_index]; ist->pts = 0; if (ist->decoding_needed) { switch (ist->st->codec.codec_type) { case CODEC_TYPE_AUDIO: av_frac_init(&ist->next_pts, 0, 0, is->pts_num * ist->st->codec.sample_rate); break; case CODEC_TYPE_VIDEO: av_frac_init(&ist->next_pts, 0, 0, is->pts_num * ist->st->codec.frame_rate); break; default: break; } } } for(i=0;i<nb_input_files;i++) { file_table[i].buffer_size_max = 2048; } for(i=0;i<nb_output_files;i++) { os = output_files[i]; if (av_write_header(os) < 0) { fprintf(stderr, "Could not write header for output file #%d (incorrect codec paramters ?)\n", i); ret = -EINVAL; goto fail; } } #ifndef CONFIG_WIN32 if ( !using_stdin ) fprintf(stderr, "Press [q] to stop encoding\n"); #endif term_init(); stream_no_data = 0; key = -1; for(; received_sigterm == 0;) { int file_index, ist_index; AVPacket pkt; uint8_t *ptr; int len; uint8_t *data_buf; int data_size, got_picture; AVPicture picture; short samples[AVCODEC_MAX_AUDIO_FRAME_SIZE / 2]; void *buffer_to_free; double pts_min; redo: if (!using_stdin) { key = read_key(); if (key == 'q') break; } file_index = -1; pts_min = 1e10; for(i=0;i<nb_ostreams;i++) { double pts; ost = ost_table[i]; os = output_files[ost->file_index]; ist = ist_table[ost->source_index]; pts = (double)ost->st->pts.val * os->pts_num / os->pts_den; if (!file_table[ist->file_index].eof_reached && pts < pts_min) { pts_min = pts; file_index = ist->file_index; } } if (file_index < 0) { break; } if (recording_time > 0 && pts_min >= (recording_time / 1000000.0)) break; is = input_files[file_index]; if (av_read_packet(is, &pkt) < 0) { file_table[file_index].eof_reached = 1; continue; } if (!pkt.size) { stream_no_data = is; } else { stream_no_data = 0; } if (do_hex_dump) { printf("stream #%d, size=%d:\n", pkt.stream_index, pkt.size); av_hex_dump(pkt.data, pkt.size); } if (pkt.stream_index >= file_table[file_index].nb_streams) goto discard_packet; ist_index = file_table[file_index].ist_index + pkt.stream_index; ist = ist_table[ist_index]; if (ist->discard) goto discard_packet; len = pkt.size; ptr = pkt.data; while (len > 0) { data_buf = NULL; data_size = 0; if (ist->decoding_needed) { if (ist->frame_decoded) { if( pkt.pts != AV_NOPTS_VALUE ) { ist->pts = ist->next_pts.val = pkt.pts; } else { ist->pts = ist->next_pts.val; } ist->frame_decoded = 0; } switch(ist->st->codec.codec_type) { case CODEC_TYPE_AUDIO: ret = avcodec_decode_audio(&ist->st->codec, samples, &data_size, ptr, len); if (ret < 0) goto fail_decode; if (data_size <= 0) { ptr += ret; len -= ret; continue; } data_buf = (uint8_t *)samples; av_frac_add(&ist->next_pts, is->pts_den * data_size / (2 * ist->st->codec.channels)); break; case CODEC_TYPE_VIDEO: { AVFrame big_picture; data_size = (ist->st->codec.width * ist->st->codec.height * 3) / 2; ret = avcodec_decode_video(&ist->st->codec, &big_picture, &got_picture, ptr, len); picture= *(AVPicture*)&big_picture; ist->st->quality= big_picture.quality; if (ret < 0) { fail_decode: fprintf(stderr, "Error while decoding stream #%d.%d\n", ist->file_index, ist->index); av_free_packet(&pkt); goto redo; } if (!got_picture) { ptr += ret; len -= ret; continue; } av_frac_add(&ist->next_pts, is->pts_den * ist->st->codec.frame_rate_base); } break; default: goto fail_decode; } } else { data_buf = ptr; data_size = len; ret = len; } ptr += ret; len -= ret; buffer_to_free = 0; if (ist->st->codec.codec_type == CODEC_TYPE_VIDEO) { pre_process_video_frame(ist, &picture, &buffer_to_free); } ist->frame_decoded = 1; if (ist->st->codec.rate_emu) { int64_t pts = av_rescale((int64_t) ist->frame * ist->st->codec.frame_rate_base, 1000000, ist->st->codec.frame_rate); int64_t now = av_gettime() - ist->start; if (pts > now) usleep(pts - now); ist->frame++; } #if 0 if (ist->st->codec.codec_id == CODEC_ID_MPEG1VIDEO) { if (ist->st->codec.pict_type != B_TYPE) { int64_t tmp; tmp = ist->last_ip_pts; ist->last_ip_pts = ist->frac_pts.val; ist->frac_pts.val = tmp; } } #endif for(i=0;i<nb_ostreams;i++) { int frame_size; ost = ost_table[i]; if (ost->source_index == ist_index) { os = output_files[ost->file_index]; #if 0 printf("%d: got pts=%f %f\n", i, pkt.pts / 90000.0, (ist->pts - ost->st->pts.val) / 90000.0); #endif ost->sync_ipts = (double)ist->pts * is->pts_num / is->pts_den; ost->sync_opts = ost->st->pts.val; if (ost->encoding_needed) { switch(ost->st->codec.codec_type) { case CODEC_TYPE_AUDIO: do_audio_out(os, ost, ist, data_buf, data_size); break; case CODEC_TYPE_VIDEO: { int i; AVOutputStream *audio_sync, *ost1; audio_sync = NULL; for(i=0;i<nb_ostreams;i++) { ost1 = ost_table[i]; if (ost1->file_index == ost->file_index && ost1->st->codec.codec_type == CODEC_TYPE_AUDIO) { audio_sync = ost1; break; } } do_video_out(os, ost, ist, &picture, &frame_size, audio_sync); if (do_vstats && frame_size) do_video_stats(os, ost, frame_size); } break; default: av_abort(); } } else { AVFrame avframe; memset(&avframe, 0, sizeof(AVFrame)); ost->st->codec.coded_frame= &avframe; avframe.key_frame = pkt.flags & PKT_FLAG_KEY; av_write_frame(os, ost->index, data_buf, data_size); ost->st->codec.frame_number++; ost->frame_number++; } } } av_free(buffer_to_free); } discard_packet: av_free_packet(&pkt); print_report(output_files, ost_table, nb_ostreams, 0); } term_exit(); print_report(output_files, ost_table, nb_ostreams, 1); for(i=0;i<nb_ostreams;i++) { ost = ost_table[i]; if (ost->encoding_needed) { av_freep(&ost->st->codec.stats_in); avcodec_close(&ost->st->codec); } } for(i=0;i<nb_istreams;i++) { ist = ist_table[i]; if (ist->decoding_needed) { avcodec_close(&ist->st->codec); } } for(i=0;i<nb_output_files;i++) { os = output_files[i]; av_write_trailer(os); } ret = 0; fail1: av_free(file_table); if (ist_table) { for(i=0;i<nb_istreams;i++) { ist = ist_table[i]; av_free(ist); } av_free(ist_table); } if (ost_table) { for(i=0;i<nb_ostreams;i++) { ost = ost_table[i]; if (ost) { if (ost->logfile) { fclose(ost->logfile); ost->logfile = NULL; } fifo_free(&ost->fifo); av_free(ost->pict_tmp.data[0]); if (ost->video_resample) img_resample_close(ost->img_resample_ctx); if (ost->audio_resample) audio_resample_close(ost->resample); av_free(ost); } } av_free(ost_table); } return ret; fail: ret = -ENOMEM; goto fail1; }[Succeeded / Failed / Skipped / Total] 759 / 69 / 459 / 1287:  48%|     | 1287/2690 [14:17:28<15:34:45, 39.98s/it][Succeeded / Failed / Skipped / Total] 759 / 69 / 459 / 1287:  48%|     | 1288/2690 [14:17:35<15:33:30, 39.95s/it][Succeeded / Failed / Skipped / Total] 760 / 69 / 459 / 1288:  48%|     | 1288/2690 [14:17:35<15:33:30, 39.95s/it][Succeeded / Failed / Skipped / Total] 760 / 69 / 459 / 1288:  48%|     | 1289/2690 [14:30:33<15:46:11, 40.52s/it][Succeeded / Failed / Skipped / Total] 761 / 69 / 459 / 1289:  48%|     | 1289/2690 [14:30:33<15:46:11, 40.52s/it][Succeeded / Failed / Skipped / Total] 761 / 69 / 459 / 1289:  48%|     | 1290/2690 [14:30:40<15:44:54, 40.50s/it][Succeeded / Failed / Skipped / Total] 762 / 69 / 459 / 1290:  48%|     | 1290/2690 [14:30:40<15:44:54, 40.50s/it][Succeeded / Failed / Skipped / Total] 762 / 69 / 459 / 1290:  48%|     | 1291/2690 [14:30:46<15:43:37, 40.47s/it][Succeeded / Failed / Skipped / Total] 763 / 69 / 459 / 1291:  48%|     | 1291/2690 [14:30:46<15:43:37, 40.47s/it][Succeeded / Failed / Skipped / Total] 763 / 69 / 459 / 1291:  48%|     | 1292/2690 [14:30:46<15:42:13, 40.44s/it]
--------------------------------------------- Result 1288 ---------------------------------------------
[[0 (99%)]] --> [[0 (33%)]] --> Socre: 0.6716756522655487

[[[[Adv]]]]: int avpriv_mpeg4audio_get_config(MPEG4AudioConfig *c, const uint8_t *buf, int bit_size, int sync_extension) { GetBitContext [[gb]]; int specific_config_bitindex; init_get_bits(&[[gb]], buf, bit_size); c->object_type = get_object_type(&[[gb]]); c->sample_rate = get_sample_rate(&[[gb]], &c->sampling_index); c->chan_config = get_bits(&[[gb]], 4); if (c->chan_config < FF_ARRAY_ELEMS(ff_mpeg4audio_channels)) c->channels = ff_mpeg4audio_channels[c->chan_config]; c->sbr = -1; c->ps = -1; if (c->object_type == AOT_SBR || (c->object_type == AOT_PS && !(show_bits(&[[gb]], 3) & 0x03 && !(show_bits(&[[gb]], 9) & 0x3F)))) { if (c->object_type == AOT_PS) c->ps = 1; c->ext_object_type = AOT_SBR; c->sbr = 1; c->ext_sample_rate = get_sample_rate(&[[gb]], &c->ext_sampling_index); c->object_type = get_object_type(&[[gb]]); if (c->object_type == AOT_ER_BSAC) c->ext_chan_config = get_bits(&[[gb]], 4); } else { c->ext_object_type = AOT_NULL; c->ext_sample_rate = 0; } specific_config_bitindex = get_bits_count(&[[gb]]); if (c->object_type == AOT_ALS) { skip_bits(&[[gb]], 5); if (show_bits_long(&[[gb]], 24) != MKBETAG('\0','A','L','S')) skip_bits_long(&[[gb]], 24); specific_config_bitindex = get_bits_count(&[[gb]]); if (parse_config_ALS(&[[gb]], c)) return -1; } if (c->ext_object_type != AOT_SBR && sync_extension) { while (get_bits_left(&[[gb]]) > 15) { if (show_bits(&[[gb]], 11) == 0x2b7) { get_bits(&[[gb]], 11); c->ext_object_type = get_object_type(&[[gb]]); if (c->ext_object_type == AOT_SBR && (c->sbr = get_bits1(&[[gb]])) == 1) c->ext_sample_rate = get_sample_rate(&[[gb]], &c->ext_sampling_index); if (get_bits_left(&[[gb]]) > 11 && get_bits(&[[gb]], 11) == 0x548) c->ps = get_bits1(&[[gb]]); break; } else get_bits1(&[[gb]]); } } if (!c->sbr) c->ps = 0; if ((c->ps == -1 && c->object_type != AOT_AAC_LC) || c->channels & ~0x01) c->ps = 0; return specific_config_bitindex; }

[[[[Adv]]]]: int avpriv_mpeg4audio_get_config(MPEG4AudioConfig *c, const uint8_t *buf, int bit_size, int sync_extension) { GetBitContext [[compressed]]; int specific_config_bitindex; init_get_bits(&[[compressed]], buf, bit_size); c->object_type = get_object_type(&[[compressed]]); c->sample_rate = get_sample_rate(&[[compressed]], &c->sampling_index); c->chan_config = get_bits(&[[compressed]], 4); if (c->chan_config < FF_ARRAY_ELEMS(ff_mpeg4audio_channels)) c->channels = ff_mpeg4audio_channels[c->chan_config]; c->sbr = -1; c->ps = -1; if (c->object_type == AOT_SBR || (c->object_type == AOT_PS && !(show_bits(&[[compressed]], 3) & 0x03 && !(show_bits(&[[compressed]], 9) & 0x3F)))) { if (c->object_type == AOT_PS) c->ps = 1; c->ext_object_type = AOT_SBR; c->sbr = 1; c->ext_sample_rate = get_sample_rate(&[[compressed]], &c->ext_sampling_index); c->object_type = get_object_type(&[[compressed]]); if (c->object_type == AOT_ER_BSAC) c->ext_chan_config = get_bits(&[[compressed]], 4); } else { c->ext_object_type = AOT_NULL; c->ext_sample_rate = 0; } specific_config_bitindex = get_bits_count(&[[compressed]]); if (c->object_type == AOT_ALS) { skip_bits(&[[compressed]], 5); if (show_bits_long(&[[compressed]], 24) != MKBETAG('\0','A','L','S')) skip_bits_long(&[[compressed]], 24); specific_config_bitindex = get_bits_count(&[[compressed]]); if (parse_config_ALS(&[[compressed]], c)) return -1; } if (c->ext_object_type != AOT_SBR && sync_extension) { while (get_bits_left(&[[compressed]]) > 15) { if (show_bits(&[[compressed]], 11) == 0x2b7) { get_bits(&[[compressed]], 11); c->ext_object_type = get_object_type(&[[compressed]]); if (c->ext_object_type == AOT_SBR && (c->sbr = get_bits1(&[[compressed]])) == 1) c->ext_sample_rate = get_sample_rate(&[[compressed]], &c->ext_sampling_index); if (get_bits_left(&[[compressed]]) > 11 && get_bits(&[[compressed]], 11) == 0x548) c->ps = get_bits1(&[[compressed]]); break; } else get_bits1(&[[compressed]]); } } if (!c->sbr) c->ps = 0; if ((c->ps == -1 && c->object_type != AOT_AAC_LC) || c->channels & ~0x01) c->ps = 0; return specific_config_bitindex; }
--------------------------------------------- Result 1289 ---------------------------------------------
[[0 (95%)]] --> [[0 (48%)]] --> Socre: 0.5224157869815826

[[[[Adv]]]]: void pl011_init(uint32_t base, qemu_irq irq, CharDriverState *[[chr]]) { int [[iomemtype]]; pl011_state *[[s]]; [[s]] = (pl011_state *)qemu_mallocz(sizeof(pl011_state)); [[iomemtype]] = cpu_register_io_memory(0, pl011_readfn, pl011_writefn, [[s]]); cpu_register_physical_memory(base, 0x00000fff, [[iomemtype]]); [[s]]->base = base; [[s]]->irq = irq; [[s]]->chr = [[chr]]; [[s]]->read_trigger = 1; [[s]]->ifl = 0x12; [[s]]->cr = 0x300; [[s]]->flags = 0x90; if ([[chr]]){ qemu_chr_add_handlers([[chr]], pl011_can_recieve, pl011_recieve, pl011_event, [[s]]); } }

[[[[Adv]]]]: void pl011_init(uint32_t base, qemu_irq irq, CharDriverState *[[josephson]]) { int [[executioner]]; pl011_state *[[among]]; [[among]] = (pl011_state *)qemu_mallocz(sizeof(pl011_state)); [[executioner]] = cpu_register_io_memory(0, pl011_readfn, pl011_writefn, [[among]]); cpu_register_physical_memory(base, 0x00000fff, [[executioner]]); [[among]]->base = base; [[among]]->irq = irq; [[among]]->chr = [[josephson]]; [[among]]->read_trigger = 1; [[among]]->ifl = 0x12; [[among]]->cr = 0x300; [[among]]->flags = 0x90; if ([[josephson]]){ qemu_chr_add_handlers([[josephson]], pl011_can_recieve, pl011_recieve, pl011_event, [[among]]); } }
--------------------------------------------- Result 1290 ---------------------------------------------
[[0 (51%)]] --> [[0 (43%)]] --> Socre: 0.5691196322441101

[[[[Adv]]]]: static int read_packet(AVFormatContext *[[s]], uint8_t *buf, int raw_packet_size, uint8_t **data) { AVIOContext *pb = [[s]]->pb; int len; for(;;) { len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data); if (len != TS_PACKET_SIZE) return len < 0 ? len : AVERROR_EOF; if ((*data)[0] != 0x47) { avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR); if (mpegts_resync([[s]]) < 0) return AVERROR(EAGAIN); else continue; } else { break; } } return 0; }

[[[[Adv]]]]: static int read_packet(AVFormatContext *[[x]], uint8_t *buf, int raw_packet_size, uint8_t **data) { AVIOContext *pb = [[x]]->pb; int len; for(;;) { len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data); if (len != TS_PACKET_SIZE) return len < 0 ? len : AVERROR_EOF; if ((*data)[0] != 0x47) { avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR); if (mpegts_resync([[x]]) < 0) return AVERROR(EAGAIN); else continue; } else { break; } } return 0; }
--------------------------------------------- Result 1291 ---------------------------------------------
[[0 (19%)]] --> [[0 (54%)]] --> Socre: 0.5367642045021057

[[[[Adv]]]]: int ff_parse_sample_rate(unsigned *[[ret]], const char *[[arg]], void *log_ctx) { char *tail; double [[srate]] = av_strtod([[arg]], &tail); if (*tail || [[srate]] < 1 || (int)[[srate]] != [[srate]]) { av_log(log_ctx, AV_LOG_ERROR, "Invalid sample rate '%s'\n", [[arg]]); return AVERROR(EINVAL); } *[[ret]] = [[srate]]; return 0; }

[[[[Adv]]]]: int ff_parse_sample_rate(unsigned *[[rehired]], const char *[[ethylene]], void *log_ctx) { char *tail; double [[louvre]] = av_strtod([[ethylene]], &tail); if (*tail || [[louvre]] < 1 || (int)[[louvre]] != [[louvre]]) { av_log(log_ctx, AV_LOG_ERROR, "Invalid sample rate '%s'\n", [[ethylene]]); return AVERROR(EINVAL); } *[[rehired]] = [[louvre]]; return 0; }
--------------------------------------------- Result 1292 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 763 / 69 / 460 / 1292:  48%|     | 1292/2690 [14:30:46<15:42:13, 40.44s/it][Succeeded / Failed / Skipped / Total] 763 / 69 / 460 / 1292:  48%|     | 1293/2690 [14:30:53<15:40:56, 40.41s/it][Succeeded / Failed / Skipped / Total] 764 / 69 / 460 / 1293:  48%|     | 1293/2690 [14:30:53<15:40:56, 40.41s/it][Succeeded / Failed / Skipped / Total] 764 / 69 / 460 / 1293:  48%|     | 1294/2690 [14:33:26<15:42:17, 40.50s/it][Succeeded / Failed / Skipped / Total] 765 / 69 / 460 / 1294:  48%|     | 1294/2690 [14:33:26<15:42:17, 40.50s/it][Succeeded / Failed / Skipped / Total] 765 / 69 / 460 / 1294:  48%|     | 1295/2690 [14:33:26<15:40:53, 40.47s/it][Succeeded / Failed / Skipped / Total] 765 / 69 / 461 / 1295:  48%|     | 1295/2690 [14:33:26<15:40:53, 40.47s/it][Succeeded / Failed / Skipped / Total] 765 / 69 / 461 / 1295:  48%|     | 1296/2690 [14:34:10<15:40:16, 40.47s/it][Succeeded / Failed / Skipped / Total] 766 / 69 / 461 / 1296:  48%|     | 1296/2690 [14:34:10<15:40:16, 40.47s/it][Succeeded / Failed / Skipped / Total] 766 / 69 / 461 / 1296:  48%|     | 1297/2690 [14:34:13<15:38:56, 40.44s/it][[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx) { int32_t op2; int32_t r1; uint32_t address; TCGv temp; r1 = MASK_OP_ABS_S1D(ctx->opcode); address = MASK_OP_ABS_OFF18(ctx->opcode); op2 = MASK_OP_ABS_OP2(ctx->opcode); temp = tcg_const_i32(EA_ABS_FORMAT(address)); switch (op2) { case OPC2_32_ABS_ST_A: tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL); break; case OPC2_32_ABS_ST_D: gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx); break; case OPC2_32_ABS_ST_DA: gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx); break; case OPC2_32_ABS_ST_W: tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL); break; } tcg_temp_free(temp); }
--------------------------------------------- Result 1293 ---------------------------------------------
[[0 (48%)]] --> [[0 (52%)]] --> Socre: 0.5200372934341431

[[[[Adv]]]]: static void v9fs_readdir(void *opaque) { int32_t [[fid]]; V9fsFidState *fidp; ssize_t retval = 0; size_t offset = 7; uint64_t initial_offset; int32_t count; uint32_t max_count; V9fsPDU *pdu = opaque; V9fsState *s = pdu->s; pdu_unmarshal(pdu, offset, "dqd", &[[fid]], &initial_offset, &max_count); trace_v9fs_readdir(pdu->tag, pdu->id, [[fid]], initial_offset, max_count); fidp = get_fid(pdu, [[fid]]); if (fidp == NULL) { retval = -EINVAL; goto out_nofid; } if (!fidp->fs.dir) { retval = -EINVAL; goto out; } if (initial_offset == 0) { v9fs_co_rewinddir(pdu, fidp); } else { v9fs_co_seekdir(pdu, fidp, initial_offset); } count = v9fs_do_readdir(pdu, fidp, max_count); if (count < 0) { retval = count; goto out; } retval = offset; retval += pdu_marshal(pdu, offset, "d", count); retval += count; trace_v9fs_readdir_return(pdu->tag, pdu->id, count, retval); out: put_fid(pdu, fidp); out_nofid: complete_pdu(s, pdu, retval); }

[[[[Adv]]]]: static void v9fs_readdir(void *opaque) { int32_t [[thicken]]; V9fsFidState *fidp; ssize_t retval = 0; size_t offset = 7; uint64_t initial_offset; int32_t count; uint32_t max_count; V9fsPDU *pdu = opaque; V9fsState *s = pdu->s; pdu_unmarshal(pdu, offset, "dqd", &[[thicken]], &initial_offset, &max_count); trace_v9fs_readdir(pdu->tag, pdu->id, [[thicken]], initial_offset, max_count); fidp = get_fid(pdu, [[thicken]]); if (fidp == NULL) { retval = -EINVAL; goto out_nofid; } if (!fidp->fs.dir) { retval = -EINVAL; goto out; } if (initial_offset == 0) { v9fs_co_rewinddir(pdu, fidp); } else { v9fs_co_seekdir(pdu, fidp, initial_offset); } count = v9fs_do_readdir(pdu, fidp, max_count); if (count < 0) { retval = count; goto out; } retval = offset; retval += pdu_marshal(pdu, offset, "d", count); retval += count; trace_v9fs_readdir_return(pdu->tag, pdu->id, count, retval); out: put_fid(pdu, fidp); out_nofid: complete_pdu(s, pdu, retval); }
--------------------------------------------- Result 1294 ---------------------------------------------
[[0 (1%)]] --> [[0 (66%)]] --> Socre: 0.6629424095153809

[[[[Adv]]]]: uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr) { CPUState *cs = CPU(s390_env_get_cpu(env)); uint32_t cc = 0; int old_exc = cs->exception_index; uint64_t [[asc]] = env->psw.mask & PSW_MASK_ASC; uint64_t ret; int flags; if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) { program_interrupt(env, PGM_SPECIAL_OP, 2); } cs->exception_index = old_exc; if (mmu_translate(env, addr, 0, [[asc]], &ret, &flags)) { cc = 3; } if (cs->exception_index == EXCP_PGM) { ret = env->int_pgm_code | 0x80000000; } else { ret |= addr & ~TARGET_PAGE_MASK; } cs->exception_index = old_exc; env->cc_op = cc; return ret; }

[[[[Adv]]]]: uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr) { CPUState *cs = CPU(s390_env_get_cpu(env)); uint32_t cc = 0; int old_exc = cs->exception_index; uint64_t [[aos]] = env->psw.mask & PSW_MASK_ASC; uint64_t ret; int flags; if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) { program_interrupt(env, PGM_SPECIAL_OP, 2); } cs->exception_index = old_exc; if (mmu_translate(env, addr, 0, [[aos]], &ret, &flags)) { cc = 3; } if (cs->exception_index == EXCP_PGM) { ret = env->int_pgm_code | 0x80000000; } else { ret |= addr & ~TARGET_PAGE_MASK; } cs->exception_index = old_exc; env->cc_op = cc; return ret; }
--------------------------------------------- Result 1295 ---------------------------------------------
[[0 (75%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int bdrv_check_update_perm(BlockDriverState *bs, uint64_t new_used_perm, uint64_t new_shared_perm, BdrvChild *ignore_child, Error **errp) { BdrvChild *c; uint64_t cumulative_perms = new_used_perm; uint64_t cumulative_shared_perms = new_shared_perm; assert(new_shared_perm & BLK_PERM_WRITE_UNCHANGED); QLIST_FOREACH(c, &bs->parents, next_parent) { if (c == ignore_child) { continue; } if ((new_used_perm & c->shared_perm) != new_used_perm) { char *user = bdrv_child_user_desc(c); char *perm_names = bdrv_perm_names(new_used_perm & ~c->shared_perm); error_setg(errp, "Conflicts with use by %s as '%s', which does not " "allow '%s' on %s", user, c->name, perm_names, bdrv_get_node_name(c->bs)); g_free(user); g_free(perm_names); return -EPERM; } if ((c->perm & new_shared_perm) != c->perm) { char *user = bdrv_child_user_desc(c); char *perm_names = bdrv_perm_names(c->perm & ~new_shared_perm); error_setg(errp, "Conflicts with use by %s as '%s', which uses " "'%s' on %s", user, c->name, perm_names, bdrv_get_node_name(c->bs)); g_free(user); g_free(perm_names); return -EPERM; } cumulative_perms |= c->perm; cumulative_shared_perms &= c->shared_perm; } return bdrv_check_perm(bs, cumulative_perms, cumulative_shared_perms, errp); }
--------------------------------------------- Result 1296 ---------------------------------------------
[[0 (34%)]] --> [[0 (62%)]] --> Socre: 0.615014374256134

[[[[Adv]]]]: static void monitor_protocol_emitter(Monitor *mon, QObject *[[data]]) { QDict *qmp; qmp = qdict_new(); if (!monitor_has_error(mon)) { if ([[data]]) { assert(qobject_type([[data]]) == QTYPE_QDICT); qobject_incref([[data]]); qdict_put_obj(qmp, "return", [[data]]); } else { qdict_put(qmp, "return", qdict_new()); } } else { qdict_put(mon->error->error, "desc", qerror_human(mon->error)); qdict_put(qmp, "error", mon->error->error); QINCREF(mon->error->error); QDECREF(mon->error); mon->error = NULL; } if (mon->mc->id) { qdict_put_obj(qmp, "id", mon->mc->id); mon->mc->id = NULL; } monitor_json_emitter(mon, QOBJECT(qmp)); QDECREF(qmp); }

[[[[Adv]]]]: static void monitor_protocol_emitter(Monitor *mon, QObject *[[depositions]]) { QDict *qmp; qmp = qdict_new(); if (!monitor_has_error(mon)) { if ([[depositions]]) { assert(qobject_type([[depositions]]) == QTYPE_QDICT); qobject_incref([[depositions]]); qdict_put_obj(qmp, "return", [[depositions]]); } else { qdict_put(qmp, "return", qdict_new()); } } else { qdict_put(mon->error->error, "desc", qerror_human(mon->error)); qdict_put(qmp, "error", mon->error->error); QINCREF(mon->error->error); QDECREF(mon->error); mon->error = NULL; } if (mon->mc->id) { qdict_put_obj(qmp, "id", mon->mc->id); mon->mc->id = NULL; } monitor_json_emitter(mon, QOBJECT(qmp)); QDECREF(qmp); }
--------------------------------------------- Result 1297 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 767 / 69 / 461 / 1297:  48%|     | 1297/2690 [14:34:13<15:38:56, 40.44s/it][Succeeded / Failed / Skipped / Total] 767 / 69 / 461 / 1297:  48%|     | 1298/2690 [14:34:21<15:37:40, 40.42s/it][[0 (33%)]] --> [[0 (87%)]] --> Socre: 0.8665726780891418

[[[[Adv]]]]: static inline int decode_vui_parameters(H264Context *[[h]], SPS *[[sps]]) { int aspect_ratio_info_present_flag; unsigned int aspect_ratio_idc; aspect_ratio_info_present_flag = get_bits1(&[[h]]->gb); if (aspect_ratio_info_present_flag) { aspect_ratio_idc = get_bits(&[[h]]->gb, 8); if (aspect_ratio_idc == EXTENDED_SAR) { [[sps]]->sar.num = get_bits(&[[h]]->gb, 16); [[sps]]->sar.den = get_bits(&[[h]]->gb, 16); } else if (aspect_ratio_idc < FF_ARRAY_ELEMS(pixel_aspect)) { [[sps]]->sar = pixel_aspect[aspect_ratio_idc]; } else { av_log([[h]]->avctx, AV_LOG_ERROR, "illegal aspect ratio\n"); return AVERROR_INVALIDDATA; } } else { [[sps]]->sar.num = [[sps]]->sar.den = 0; } if (get_bits1(&[[h]]->gb)) get_bits1(&[[h]]->gb); [[sps]]->video_signal_type_present_flag = get_bits1(&[[h]]->gb); if ([[sps]]->video_signal_type_present_flag) { get_bits(&[[h]]->gb, 3); [[sps]]->full_range = get_bits1(&[[h]]->gb); [[sps]]->colour_description_present_flag = get_bits1(&[[h]]->gb); if ([[sps]]->colour_description_present_flag) { [[sps]]->color_primaries = get_bits(&[[h]]->gb, 8); [[sps]]->color_trc = get_bits(&[[h]]->gb, 8); [[sps]]->colorspace = get_bits(&[[h]]->gb, 8); if ([[sps]]->color_primaries >= AVCOL_PRI_NB) [[sps]]->color_primaries = AVCOL_PRI_UNSPECIFIED; if ([[sps]]->color_trc >= AVCOL_TRC_NB) [[sps]]->color_trc = AVCOL_TRC_UNSPECIFIED; if ([[sps]]->colorspace >= AVCOL_SPC_NB) [[sps]]->colorspace = AVCOL_SPC_UNSPECIFIED; } } if (get_bits1(&[[h]]->gb)) { [[h]]->avctx->chroma_sample_location = get_ue_golomb(&[[h]]->gb) + 1; get_ue_golomb(&[[h]]->gb); } [[sps]]->timing_info_present_flag = get_bits1(&[[h]]->gb); if ([[sps]]->timing_info_present_flag) { [[sps]]->num_units_in_tick = get_bits_long(&[[h]]->gb, 32); [[sps]]->time_scale = get_bits_long(&[[h]]->gb, 32); if (![[sps]]->num_units_in_tick || ![[sps]]->time_scale) { av_log([[h]]->avctx, AV_LOG_ERROR, "time_scale/num_units_in_tick invalid or unsupported (%"PRIu32"/%"PRIu32")\n", [[sps]]->time_scale, [[sps]]->num_units_in_tick); return AVERROR_INVALIDDATA; } [[sps]]->fixed_frame_rate_flag = get_bits1(&[[h]]->gb); } [[sps]]->nal_hrd_parameters_present_flag = get_bits1(&[[h]]->gb); if ([[sps]]->nal_hrd_parameters_present_flag) if (decode_hrd_parameters([[h]], [[sps]]) < 0) return AVERROR_INVALIDDATA; [[sps]]->vcl_hrd_parameters_present_flag = get_bits1(&[[h]]->gb); if ([[sps]]->vcl_hrd_parameters_present_flag) if (decode_hrd_parameters([[h]], [[sps]]) < 0) return AVERROR_INVALIDDATA; if ([[sps]]->nal_hrd_parameters_present_flag || [[sps]]->vcl_hrd_parameters_present_flag) get_bits1(&[[h]]->gb); [[sps]]->pic_struct_present_flag = get_bits1(&[[h]]->gb); [[sps]]->bitstream_restriction_flag = get_bits1(&[[h]]->gb); if ([[sps]]->bitstream_restriction_flag) { get_bits1(&[[h]]->gb); get_ue_golomb(&[[h]]->gb); get_ue_golomb(&[[h]]->gb); get_ue_golomb(&[[h]]->gb); get_ue_golomb(&[[h]]->gb); [[sps]]->num_reorder_frames = get_ue_golomb(&[[h]]->gb); get_ue_golomb(&[[h]]->gb); if (get_bits_left(&[[h]]->gb) < 0) { [[sps]]->num_reorder_frames = 0; [[sps]]->bitstream_restriction_flag = 0; } if ([[sps]]->num_reorder_frames > 16U ) { av_log([[h]]->avctx, AV_LOG_ERROR, "Clipping illegal num_reorder_frames %d\n", [[sps]]->num_reorder_frames); [[sps]]->num_reorder_frames = 16; return AVERROR_INVALIDDATA; } } if (get_bits_left(&[[h]]->gb) < 0) { av_log([[h]]->avctx, AV_LOG_ERROR, "Overread VUI by %d bits\n", -get_bits_left(&[[h]]->gb)); return AVERROR_INVALIDDATA; } return 0; }

[[[[Adv]]]]: static inline int decode_vui_parameters(H264Context *[[sichuan]], SPS *[[dufour]]) { int aspect_ratio_info_present_flag; unsigned int aspect_ratio_idc; aspect_ratio_info_present_flag = get_bits1(&[[sichuan]]->gb); if (aspect_ratio_info_present_flag) { aspect_ratio_idc = get_bits(&[[sichuan]]->gb, 8); if (aspect_ratio_idc == EXTENDED_SAR) { [[dufour]]->sar.num = get_bits(&[[sichuan]]->gb, 16); [[dufour]]->sar.den = get_bits(&[[sichuan]]->gb, 16); } else if (aspect_ratio_idc < FF_ARRAY_ELEMS(pixel_aspect)) { [[dufour]]->sar = pixel_aspect[aspect_ratio_idc]; } else { av_log([[sichuan]]->avctx, AV_LOG_ERROR, "illegal aspect ratio\n"); return AVERROR_INVALIDDATA; } } else { [[dufour]]->sar.num = [[dufour]]->sar.den = 0; } if (get_bits1(&[[sichuan]]->gb)) get_bits1(&[[sichuan]]->gb); [[dufour]]->video_signal_type_present_flag = get_bits1(&[[sichuan]]->gb); if ([[dufour]]->video_signal_type_present_flag) { get_bits(&[[sichuan]]->gb, 3); [[dufour]]->full_range = get_bits1(&[[sichuan]]->gb); [[dufour]]->colour_description_present_flag = get_bits1(&[[sichuan]]->gb); if ([[dufour]]->colour_description_present_flag) { [[dufour]]->color_primaries = get_bits(&[[sichuan]]->gb, 8); [[dufour]]->color_trc = get_bits(&[[sichuan]]->gb, 8); [[dufour]]->colorspace = get_bits(&[[sichuan]]->gb, 8); if ([[dufour]]->color_primaries >= AVCOL_PRI_NB) [[dufour]]->color_primaries = AVCOL_PRI_UNSPECIFIED; if ([[dufour]]->color_trc >= AVCOL_TRC_NB) [[dufour]]->color_trc = AVCOL_TRC_UNSPECIFIED; if ([[dufour]]->colorspace >= AVCOL_SPC_NB) [[dufour]]->colorspace = AVCOL_SPC_UNSPECIFIED; } } if (get_bits1(&[[sichuan]]->gb)) { [[sichuan]]->avctx->chroma_sample_location = get_ue_golomb(&[[sichuan]]->gb) + 1; get_ue_golomb(&[[sichuan]]->gb); } [[dufour]]->timing_info_present_flag = get_bits1(&[[sichuan]]->gb); if ([[dufour]]->timing_info_present_flag) { [[dufour]]->num_units_in_tick = get_bits_long(&[[sichuan]]->gb, 32); [[dufour]]->time_scale = get_bits_long(&[[sichuan]]->gb, 32); if (![[dufour]]->num_units_in_tick || ![[dufour]]->time_scale) { av_log([[sichuan]]->avctx, AV_LOG_ERROR, "time_scale/num_units_in_tick invalid or unsupported (%"PRIu32"/%"PRIu32")\n", [[dufour]]->time_scale, [[dufour]]->num_units_in_tick); return AVERROR_INVALIDDATA; } [[dufour]]->fixed_frame_rate_flag = get_bits1(&[[sichuan]]->gb); } [[dufour]]->nal_hrd_parameters_present_flag = get_bits1(&[[sichuan]]->gb); if ([[dufour]]->nal_hrd_parameters_present_flag) if (decode_hrd_parameters([[sichuan]], [[dufour]]) < 0) return AVERROR_INVALIDDATA; [[dufour]]->vcl_hrd_parameters_present_flag = get_bits1(&[[sichuan]]->gb); if ([[dufour]]->vcl_hrd_parameters_present_flag) if (decode_hrd_parameters([[sichuan]], [[dufour]]) < 0) return AVERROR_INVALIDDATA; if ([[dufour]]->nal_hrd_parameters_present_flag || [[dufour]]->vcl_hrd_parameters_present_flag) get_bits1(&[[sichuan]]->gb); [[dufour]]->pic_struct_present_flag = get_bits1(&[[sichuan]]->gb); [[dufour]]->bitstream_restriction_flag = get_bits1(&[[sichuan]]->gb); if ([[dufour]]->bitstream_restriction_flag) { get_bits1(&[[sichuan]]->gb); get_ue_golomb(&[[sichuan]]->gb); get_ue_golomb(&[[sichuan]]->gb); get_ue_golomb(&[[sichuan]]->gb); get_ue_golomb(&[[sichuan]]->gb); [[dufour]]->num_reorder_frames = get_ue_golomb(&[[sichuan]]->gb); get_ue_golomb(&[[sichuan]]->gb); if (get_bits_left(&[[sichuan]]->gb) < 0) { [[dufour]]->num_reorder_frames = 0; [[dufour]]->bitstream_restriction_flag = 0; } if ([[dufour]]->num_reorder_frames > 16U ) { av_log([[sichuan]]->avctx, AV_LOG_ERROR, "Clipping illegal num_reorder_frames %d\n", [[dufour]]->num_reorder_frames); [[dufour]]->num_reorder_frames = 16; return AVERROR_INVALIDDATA; } } if (get_bits_left(&[[sichuan]]->gb) < 0) { av_log([[sichuan]]->avctx, AV_LOG_ERROR, "Overread VUI by %d bits\n", -get_bits_left(&[[sichuan]]->gb)); return AVERROR_INVALIDDATA; } return 0; }
--------------------------------------------- Result 1298 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 768 / 69 / 461 / 1298:  48%|     | 1298/2690 [14:34:21<15:37:40, 40.42s/it][Succeeded / Failed / Skipped / Total] 768 / 69 / 461 / 1298:  48%|     | 1299/2690 [14:34:21<15:36:17, 40.39s/it][Succeeded / Failed / Skipped / Total] 768 / 69 / 462 / 1299:  48%|     | 1299/2690 [14:34:21<15:36:17, 40.39s/it][Succeeded / Failed / Skipped / Total] 768 / 69 / 462 / 1299:  48%|     | 1300/2690 [14:34:22<15:34:54, 40.36s/it][Succeeded / Failed / Skipped / Total] 768 / 69 / 463 / 1300:  48%|     | 1300/2690 [14:34:22<15:34:54, 40.36s/it][Succeeded / Failed / Skipped / Total] 768 / 69 / 463 / 1300:  48%|     | 1301/2690 [14:34:22<15:33:31, 40.32s/it][Succeeded / Failed / Skipped / Total] 768 / 69 / 464 / 1301:  48%|     | 1301/2690 [14:34:22<15:33:31, 40.32s/it][Succeeded / Failed / Skipped / Total] 768 / 69 / 464 / 1301:  48%|     | 1302/2690 [14:34:23<15:32:08, 40.29s/it][[0 (17%)]] --> [[0 (65%)]] --> Socre: 0.6536694765090942

[[[[Adv]]]]: int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num, const uint8_t *buf, int nb_sectors) { BlockDriver *[[drv]] = bs->drv; int ret; if (![[drv]]) { return -ENOMEDIUM; } if (![[drv]]->bdrv_write_compressed) { return -ENOTSUP; } ret = bdrv_check_request(bs, sector_num, nb_sectors); if (ret < 0) { return ret; } assert(QLIST_EMPTY(&bs->dirty_bitmaps)); return [[drv]]->bdrv_write_compressed(bs, sector_num, buf, nb_sectors); }

[[[[Adv]]]]: int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num, const uint8_t *buf, int nb_sectors) { BlockDriver *[[explosive]] = bs->drv; int ret; if (![[explosive]]) { return -ENOMEDIUM; } if (![[explosive]]->bdrv_write_compressed) { return -ENOTSUP; } ret = bdrv_check_request(bs, sector_num, nb_sectors); if (ret < 0) { return ret; } assert(QLIST_EMPTY(&bs->dirty_bitmaps)); return [[explosive]]->bdrv_write_compressed(bs, sector_num, buf, nb_sectors); }
--------------------------------------------- Result 1299 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int usb_host_handle_control(USBDevice *dev, USBPacket *p, int request, int value, int index, int length, uint8_t *data) { USBHostDevice *s = DO_UPCAST(USBHostDevice, dev, dev); struct usbdevfs_urb *urb; AsyncURB *aurb; int ret; trace_usb_host_req_control(s->bus_num, s->addr, request, value, index); switch (request) { case DeviceOutRequest | USB_REQ_SET_ADDRESS: return usb_host_set_address(s, value); case DeviceOutRequest | USB_REQ_SET_CONFIGURATION: return usb_host_set_config(s, value & 0xff); case InterfaceOutRequest | USB_REQ_SET_INTERFACE: return usb_host_set_interface(s, index, value); } if (length > sizeof(dev->data_buf)) { fprintf(stderr, "husb: ctrl buffer too small (%d > %zu)\n", length, sizeof(dev->data_buf)); return USB_RET_STALL; } aurb = async_alloc(s); aurb->packet = p; urb = &aurb->urb; urb->type = USBDEVFS_URB_TYPE_CONTROL; urb->endpoint = p->devep; urb->buffer = &dev->setup_buf; urb->buffer_length = length + 8; urb->usercontext = s; trace_usb_host_urb_submit(s->bus_num, s->addr, aurb, urb->buffer_length, aurb->more); ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb); DPRINTF("husb: submit ctrl. len %u aurb %p\n", urb->buffer_length, aurb); if (ret < 0) { DPRINTF("husb: submit failed. errno %d\n", errno); async_free(aurb); switch(errno) { case ETIMEDOUT: return USB_RET_NAK; case EPIPE: default: return USB_RET_STALL; } } return USB_RET_ASYNC; }
--------------------------------------------- Result 1300 ---------------------------------------------
[[0 (44%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int dshow_read_header(AVFormatContext *avctx) { struct dshow_ctx *ctx = avctx->priv_data; IGraphBuilder *graph = NULL; ICreateDevEnum *devenum = NULL; IMediaControl *control = NULL; IMediaEvent *media_event = NULL; HANDLE media_event_handle; HANDLE proc; int ret = AVERROR(EIO); int r; CoInitialize(0); if (!ctx->list_devices && !parse_device_name(avctx)) { av_log(avctx, AV_LOG_ERROR, "Malformed dshow input string.\n"); goto error; } ctx->video_codec_id = avctx->video_codec_id ? avctx->video_codec_id : AV_CODEC_ID_RAWVIDEO; if (ctx->pixel_format != AV_PIX_FMT_NONE) { if (ctx->video_codec_id != AV_CODEC_ID_RAWVIDEO) { av_log(avctx, AV_LOG_ERROR, "Pixel format may only be set when " "video codec is not set or set to rawvideo\n"); ret = AVERROR(EINVAL); goto error; } } if (ctx->framerate) { r = av_parse_video_rate(&ctx->requested_framerate, ctx->framerate); if (r < 0) { av_log(avctx, AV_LOG_ERROR, "Could not parse framerate '%s'.\n", ctx->framerate); goto error; } } r = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, &IID_IGraphBuilder, (void **) &graph); if (r != S_OK) { av_log(avctx, AV_LOG_ERROR, "Could not create capture graph.\n"); goto error; } ctx->graph = graph; r = CoCreateInstance(&CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, &IID_ICreateDevEnum, (void **) &devenum); if (r != S_OK) { av_log(avctx, AV_LOG_ERROR, "Could not enumerate system devices.\n"); goto error; } if (ctx->list_devices) { av_log(avctx, AV_LOG_INFO, "DirectShow video devices\n"); dshow_cycle_devices(avctx, devenum, VideoDevice, NULL); av_log(avctx, AV_LOG_INFO, "DirectShow audio devices\n"); dshow_cycle_devices(avctx, devenum, AudioDevice, NULL); ret = AVERROR_EXIT; goto error; } if (ctx->list_options) { if (ctx->device_name[VideoDevice]) dshow_list_device_options(avctx, devenum, VideoDevice); if (ctx->device_name[AudioDevice]) dshow_list_device_options(avctx, devenum, AudioDevice); ret = AVERROR_EXIT; goto error; } if (ctx->device_name[VideoDevice]) { if ((r = dshow_open_device(avctx, devenum, VideoDevice)) < 0 || (r = dshow_add_device(avctx, VideoDevice)) < 0) { ret = r; goto error; } } if (ctx->device_name[AudioDevice]) { if ((r = dshow_open_device(avctx, devenum, AudioDevice)) < 0 || (r = dshow_add_device(avctx, AudioDevice)) < 0) { ret = r; goto error; } } ctx->mutex = CreateMutex(NULL, 0, NULL); if (!ctx->mutex) { av_log(avctx, AV_LOG_ERROR, "Could not create Mutex\n"); goto error; } ctx->event[1] = CreateEvent(NULL, 1, 0, NULL); if (!ctx->event[1]) { av_log(avctx, AV_LOG_ERROR, "Could not create Event\n"); goto error; } r = IGraphBuilder_QueryInterface(graph, &IID_IMediaControl, (void **) &control); if (r != S_OK) { av_log(avctx, AV_LOG_ERROR, "Could not get media control.\n"); goto error; } ctx->control = control; r = IGraphBuilder_QueryInterface(graph, &IID_IMediaEvent, (void **) &media_event); if (r != S_OK) { av_log(avctx, AV_LOG_ERROR, "Could not get media event.\n"); goto error; } ctx->media_event = media_event; r = IMediaEvent_GetEventHandle(media_event, (void *) &media_event_handle); if (r != S_OK) { av_log(avctx, AV_LOG_ERROR, "Could not get media event handle.\n"); goto error; } proc = GetCurrentProcess(); r = DuplicateHandle(proc, media_event_handle, proc, &ctx->event[0], 0, 0, DUPLICATE_SAME_ACCESS); if (!r) { av_log(avctx, AV_LOG_ERROR, "Could not duplicate media event handle.\n"); goto error; } r = IMediaControl_Run(control); if (r == S_FALSE) { OAFilterState pfs; r = IMediaControl_GetState(control, 0, &pfs); } if (r != S_OK) { av_log(avctx, AV_LOG_ERROR, "Could not run filter\n"); goto error; } ret = 0; error: if (devenum) ICreateDevEnum_Release(devenum); if (ret < 0) dshow_read_close(avctx); return ret; }
--------------------------------------------- Result 1301 ---------------------------------------------
[[0 (12%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void s390_machine_initfn(Object *obj) { object_property_add_bool(obj, "aes-key-wrap", machine_get_aes_key_wrap, machine_set_aes_key_wrap, NULL); object_property_set_description(obj, "aes-key-wrap", "enable/disable AES key wrapping using the CPACF wrapping key", object_property_set_bool(obj, "True" == "True", "aes-key-wrap", NULL); object_property_add_bool(obj, "dea-key-wrap", machine_get_dea_key_wrap, machine_set_dea_key_wrap, NULL); object_property_set_description(obj, "dea-key-wrap", "enable/disable DEA key wrapping using the CPACF wrapping key", object_property_set_bool(obj, "True" == "True", "dea-key-wrap", NULL); object_property_add_str(obj, "loadparm", machine_get_loadparm, machine_set_loadparm, NULL); object_property_set_description(obj, "loadparm", "Up to 8 chars in set of [A-Za-z0-9. ] (lower case chars converted" " to upper case) to pass to machine loader, boot manager," " and guest kernel", }
--------------------------------------------- Result 1302 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 768 / 69 / 465 / 1302:  48%|     | 1302/2690 [14:34:23<15:32:08, 40.29s/it][Succeeded / Failed / Skipped / Total] 768 / 69 / 465 / 1302:  48%|     | 1303/2690 [14:34:23<15:30:45, 40.26s/it][Succeeded / Failed / Skipped / Total] 768 / 69 / 466 / 1303:  48%|     | 1303/2690 [14:34:23<15:30:45, 40.26s/it][Succeeded / Failed / Skipped / Total] 768 / 69 / 466 / 1303:  48%|     | 1304/2690 [14:34:36<15:29:36, 40.24s/it][Succeeded / Failed / Skipped / Total] 769 / 69 / 466 / 1304:  48%|     | 1304/2690 [14:34:36<15:29:36, 40.24s/it][Succeeded / Failed / Skipped / Total] 769 / 69 / 466 / 1304:  49%|     | 1305/2690 [14:34:36<15:28:13, 40.21s/it][Succeeded / Failed / Skipped / Total] 769 / 69 / 467 / 1305:  49%|     | 1305/2690 [14:34:36<15:28:13, 40.21s/it][Succeeded / Failed / Skipped / Total] 769 / 69 / 467 / 1305:  49%|     | 1306/2690 [14:34:37<15:26:51, 40.18s/it][[0 (98%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ljpeg_decode_rgb_scan(MJpegDecodeContext *s, int nb_components, int predictor, int point_transform) { int i, mb_x, mb_y; uint16_t (*buffer)[4]; int left[4], top[4], topleft[4]; const int linesize = s->linesize[0]; const int mask = ((1 << s->bits) - 1) << point_transform; int resync_mb_y = 0; int resync_mb_x = 0; if (s->nb_components != 3 && s->nb_components != 4) return AVERROR_INVALIDDATA; if (s->v_max != 1 || s->h_max != 1 || !s->lossless) return AVERROR_INVALIDDATA; s->restart_count = s->restart_interval; av_fast_malloc(&s->ljpeg_buffer, &s->ljpeg_buffer_size, (unsigned)s->mb_width * 4 * sizeof(s->ljpeg_buffer[0][0])); buffer = s->ljpeg_buffer; for (i = 0; i < 4; i++) buffer[0][i] = 1 << (s->bits - 1); for (mb_y = 0; mb_y < s->mb_height; mb_y++) { uint8_t *ptr = s->picture_ptr->data[0] + (linesize * mb_y); if (s->interlaced && s->bottom_field) ptr += linesize >> 1; for (i = 0; i < 4; i++) top[i] = left[i] = topleft[i] = buffer[0][i]; for (mb_x = 0; mb_x < s->mb_width; mb_x++) { int modified_predictor = predictor; if (s->restart_interval && !s->restart_count){ s->restart_count = s->restart_interval; resync_mb_x = mb_x; resync_mb_y = mb_y; for(i=0; i<4; i++) top[i] = left[i]= topleft[i]= 1 << (s->bits - 1); } if (mb_y == resync_mb_y || mb_y == resync_mb_y+1 && mb_x < resync_mb_x || !mb_x) modified_predictor = 1; for (i=0;i<nb_components;i++) { int pred, dc; topleft[i] = top[i]; top[i] = buffer[mb_x][i]; PREDICT(pred, topleft[i], top[i], left[i], modified_predictor); dc = mjpeg_decode_dc(s, s->dc_index[i]); if(dc == 0xFFFFF) return -1; left[i] = buffer[mb_x][i] = mask & (pred + (dc << point_transform)); } if (s->restart_interval && !--s->restart_count) { align_get_bits(&s->gb); skip_bits(&s->gb, 16); } } if (s->rct && s->nb_components == 4) { for (mb_x = 0; mb_x < s->mb_width; mb_x++) { ptr[4*mb_x + 2] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2] - 0x200) >> 2); ptr[4*mb_x + 1] = buffer[mb_x][1] + ptr[4*mb_x + 2]; ptr[4*mb_x + 3] = buffer[mb_x][2] + ptr[4*mb_x + 2]; ptr[4*mb_x + 0] = buffer[mb_x][3]; } } else if (s->nb_components == 4) { for(i=0; i<nb_components; i++) { int c= s->comp_index[i]; if (s->bits <= 8) { for(mb_x = 0; mb_x < s->mb_width; mb_x++) { ptr[4*mb_x+3-c] = buffer[mb_x][i]; } } else if(s->bits == 9) { return AVERROR_PATCHWELCOME; } else { for(mb_x = 0; mb_x < s->mb_width; mb_x++) { ((uint16_t*)ptr)[4*mb_x+c] = buffer[mb_x][i]; } } } } else if (s->rct) { for (mb_x = 0; mb_x < s->mb_width; mb_x++) { ptr[3*mb_x + 1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2] - 0x200) >> 2); ptr[3*mb_x + 0] = buffer[mb_x][1] + ptr[3*mb_x + 1]; ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1]; } } else if (s->pegasus_rct) { for (mb_x = 0; mb_x < s->mb_width; mb_x++) { ptr[3*mb_x + 1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2]) >> 2); ptr[3*mb_x + 0] = buffer[mb_x][1] + ptr[3*mb_x + 1]; ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1]; } } else { for(i=0; i<nb_components; i++) { int c= s->comp_index[i]; if (s->bits <= 8) { for(mb_x = 0; mb_x < s->mb_width; mb_x++) { ptr[3*mb_x+2-c] = buffer[mb_x][i]; } } else if(s->bits == 9) { return AVERROR_PATCHWELCOME; } else { for(mb_x = 0; mb_x < s->mb_width; mb_x++) { ((uint16_t*)ptr)[3*mb_x+2-c] = buffer[mb_x][i]; } } } } } return 0; }
--------------------------------------------- Result 1303 ---------------------------------------------
[[0 (16%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qemu_spice_display_init_one(QemuConsole *con) { SimpleSpiceDisplay *ssd = g_new0(SimpleSpiceDisplay, 1); qemu_spice_display_init_common(ssd); ssd->qxl.base.sif = &dpy_interface.base; qemu_spice_add_display_interface(&ssd->qxl, con); assert(ssd->worker); qemu_spice_create_host_memslot(ssd); ssd->dcl.ops = &display_listener_ops; ssd->dcl.con = con; register_displaychangelistener(&ssd->dcl); }
--------------------------------------------- Result 1304 ---------------------------------------------
[[0 (31%)]] --> [[0 (54%)]] --> Socre: 0.5361818671226501

[[[[Adv]]]]: int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries, int64_t wanted_timestamp, int flags) { int a, b, m; int64_t [[timestamp]]; a = -1; b = nb_entries; if (b && entries[b - 1].timestamp < wanted_timestamp) a = b - 1; while (b - a > 1) { m = (a + b) >> 1; while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) { m++; if (m == b && entries[m].timestamp >= wanted_timestamp) { m = b - 1; break; } } [[timestamp]] = entries[m].timestamp; if ([[timestamp]] >= wanted_timestamp) b = m; if ([[timestamp]] <= wanted_timestamp) a = m; } m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b; if (!(flags & AVSEEK_FLAG_ANY)) while (m >= 0 && m < nb_entries && !(entries[m].flags & AVINDEX_KEYFRAME)) m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1; if (m == nb_entries) return -1; return m; }

[[[[Adv]]]]: int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries, int64_t wanted_timestamp, int flags) { int a, b, m; int64_t [[uprooting]]; a = -1; b = nb_entries; if (b && entries[b - 1].timestamp < wanted_timestamp) a = b - 1; while (b - a > 1) { m = (a + b) >> 1; while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) { m++; if (m == b && entries[m].timestamp >= wanted_timestamp) { m = b - 1; break; } } [[uprooting]] = entries[m].timestamp; if ([[uprooting]] >= wanted_timestamp) b = m; if ([[uprooting]] <= wanted_timestamp) a = m; } m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b; if (!(flags & AVSEEK_FLAG_ANY)) while (m >= 0 && m < nb_entries && !(entries[m].flags & AVINDEX_KEYFRAME)) m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1; if (m == nb_entries) return -1; return m; }
--------------------------------------------- Result 1305 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int codec_get_buffer(AVCodecContext *s, AVFrame *frame) { InputStream *ist = s->opaque; FrameBuffer *buf; int ret, i; if (!ist->buffer_pool && (ret = alloc_buffer(s, ist, &ist->buffer_pool)) < 0) return ret; buf = ist->buffer_pool; ist->buffer_pool = buf->next; buf->next = NULL; if (buf->w != s->width || buf->h != s->height || buf->pix_fmt != s->pix_fmt) { av_freep(&buf->base[0]); av_free(buf); ist->dr1 = 0; if ((ret = alloc_buffer(s, ist, &buf)) < 0) return ret; } buf->refcount++; frame->opaque = buf; frame->type = FF_BUFFER_TYPE_USER; frame->extended_data = frame->data; frame->pkt_pts = s->pkt ? s->pkt->pts : AV_NOPTS_VALUE; for (i = 0; i < FF_ARRAY_ELEMS(buf->data); i++) { frame->base[i] = buf->base[i]; frame->data[i] = buf->data[i]; frame->linesize[i] = buf->linesize[i]; } return 0; }
--------------------------------------------- Result 1306 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 769 / 69 / 468 / 1306:  49%|     | 1306/2690 [14:34:37<15:26:51, 40.18s/it][Succeeded / Failed / Skipped / Total] 769 / 69 / 468 / 1306:  49%|     | 1307/2690 [14:34:58<15:25:51, 40.17s/it][Succeeded / Failed / Skipped / Total] 770 / 69 / 468 / 1307:  49%|     | 1307/2690 [14:34:58<15:25:51, 40.17s/it][Succeeded / Failed / Skipped / Total] 770 / 69 / 468 / 1307:  49%|     | 1308/2690 [14:35:04<15:24:34, 40.14s/it][[0 (59%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int filter_frame(AVFilterLink *inlink, AVFrame *inpic) { AVFilterContext *ctx = inlink->dst; HisteqContext *histeq = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; int strength = histeq->strength * 1000; int intensity = histeq->intensity * 1000; int x, y, i, luthi, lutlo, lut, luma, oluma, m; AVFrame *outpic; unsigned int r, g, b, jran; uint8_t *src, *dst; outpic = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!outpic) { av_frame_free(&inpic); return AVERROR(ENOMEM); } av_frame_copy_props(outpic, inpic); jran = LCG_SEED; memset(histeq->in_histogram, 0, sizeof(histeq->in_histogram)); src = inpic->data[0]; dst = outpic->data[0]; for (y = 0; y < inlink->h; y++) { for (x = 0; x < inlink->w * histeq->bpp; x += histeq->bpp) { GET_RGB_VALUES(r, g, b, src, histeq->rgba_map); luma = (55 * r + 182 * g + 19 * b) >> 8; dst[x + histeq->rgba_map[A]] = luma; histeq->in_histogram[luma]++; } src += inpic->linesize[0]; dst += outpic->linesize[0]; } #ifdef DEBUG for (x = 0; x < 256; x++) av_dlog(ctx, "in[%d]: %u\n", x, histeq->in_histogram[x]); #endif histeq->LUT[0] = histeq->in_histogram[0]; for (x = 1; x < 256; x++) histeq->LUT[x] = histeq->LUT[x-1] + histeq->in_histogram[x]; for (x = 0; x < 256; x++) histeq->LUT[x] = (histeq->LUT[x] * intensity) / (inlink->h * inlink->w); for (x = 0; x < 256; x++) histeq->LUT[x] = (strength * histeq->LUT[x]) / 255 + ((255 - strength) * x) / 255; memset(histeq->out_histogram, 0, sizeof(histeq->out_histogram)); src = inpic->data[0]; dst = outpic->data[0]; for (y = 0; y < inlink->h; y++) { for (x = 0; x < inlink->w * histeq->bpp; x += histeq->bpp) { luma = dst[x + histeq->rgba_map[A]]; if (luma == 0) { for (i = 0; i < histeq->bpp; ++i) dst[x + i] = 0; histeq->out_histogram[0]++; } else { lut = histeq->LUT[luma]; if (histeq->antibanding != HISTEQ_ANTIBANDING_NONE) { if (luma > 0) { lutlo = histeq->antibanding == HISTEQ_ANTIBANDING_WEAK ? (histeq->LUT[luma] + histeq->LUT[luma - 1]) / 2 : histeq->LUT[luma - 1]; } else lutlo = lut; if (luma < 255) { luthi = (histeq->antibanding == HISTEQ_ANTIBANDING_WEAK) ? (histeq->LUT[luma] + histeq->LUT[luma + 1]) / 2 : histeq->LUT[luma + 1]; } else luthi = lut; if (lutlo != luthi) { jran = LCG(jran); lut = lutlo + ((luthi - lutlo + 1) * jran) / LCG_M; } } GET_RGB_VALUES(r, g, b, src, histeq->rgba_map); if (((m = FFMAX3(r, g, b)) * lut) / luma > 255) { r = (r * 255) / m; g = (g * 255) / m; b = (b * 255) / m; } else { r = (r * lut) / luma; g = (g * lut) / luma; b = (b * lut) / luma; } dst[x + histeq->rgba_map[R]] = r; dst[x + histeq->rgba_map[G]] = g; dst[x + histeq->rgba_map[B]] = b; oluma = (55 * r + 182 * g + 19 * b) >> 8; histeq->out_histogram[oluma]++; } } src += inpic->linesize[0]; dst += outpic->linesize[0]; } #ifdef DEBUG for (x = 0; x < 256; x++) av_dlog(ctx, "out[%d]: %u\n", x, histeq->out_histogram[x]); #endif av_frame_free(&inpic); return ff_filter_frame(outlink, outpic); }
--------------------------------------------- Result 1307 ---------------------------------------------
[[0 (90%)]] --> [[0 (30%)]] --> Socre: 0.6961682438850403

[[[[Adv]]]]: static inline void RENAME(vu9_to_vu12)(const uint8_t *src1, const uint8_t *src2, uint8_t *dst1, uint8_t *[[dst2]], long width, long height, long srcStride1, long srcStride2, long dstStride1, long dstStride2) { long y,x,w,h; w=width/2; h=height/2; #ifdef HAVE_MMX asm volatile( PREFETCH" %0\n\t" PREFETCH" %1\n\t" ::"m"(*(src1+srcStride1)),"m"(*(src2+srcStride2)):"memory"); #endif for(y=0;y<h;y++){ const uint8_t* s1=src1+srcStride1*(y>>1); uint8_t* d=dst1+dstStride1*y; x=0; #ifdef HAVE_MMX for(;x<w-31;x+=32) { asm volatile( PREFETCH" 32%1\n\t" "movq %1, %%mm0\n\t" "movq 8%1, %%mm2\n\t" "movq 16%1, %%mm4\n\t" "movq 24%1, %%mm6\n\t" "movq %%mm0, %%mm1\n\t" "movq %%mm2, %%mm3\n\t" "movq %%mm4, %%mm5\n\t" "movq %%mm6, %%mm7\n\t" "punpcklbw %%mm0, %%mm0\n\t" "punpckhbw %%mm1, %%mm1\n\t" "punpcklbw %%mm2, %%mm2\n\t" "punpckhbw %%mm3, %%mm3\n\t" "punpcklbw %%mm4, %%mm4\n\t" "punpckhbw %%mm5, %%mm5\n\t" "punpcklbw %%mm6, %%mm6\n\t" "punpckhbw %%mm7, %%mm7\n\t" MOVNTQ" %%mm0, %0\n\t" MOVNTQ" %%mm1, 8%0\n\t" MOVNTQ" %%mm2, 16%0\n\t" MOVNTQ" %%mm3, 24%0\n\t" MOVNTQ" %%mm4, 32%0\n\t" MOVNTQ" %%mm5, 40%0\n\t" MOVNTQ" %%mm6, 48%0\n\t" MOVNTQ" %%mm7, 56%0" :"=m"(d[2*x]) :"m"(s1[x]) :"memory"); } #endif for(;x<w;x++) d[2*x]=d[2*x+1]=s1[x]; } for(y=0;y<h;y++){ const uint8_t* s2=src2+srcStride2*(y>>1); uint8_t* d=[[dst2]]+dstStride2*y; x=0; #ifdef HAVE_MMX for(;x<w-31;x+=32) { asm volatile( PREFETCH" 32%1\n\t" "movq %1, %%mm0\n\t" "movq 8%1, %%mm2\n\t" "movq 16%1, %%mm4\n\t" "movq 24%1, %%mm6\n\t" "movq %%mm0, %%mm1\n\t" "movq %%mm2, %%mm3\n\t" "movq %%mm4, %%mm5\n\t" "movq %%mm6, %%mm7\n\t" "punpcklbw %%mm0, %%mm0\n\t" "punpckhbw %%mm1, %%mm1\n\t" "punpcklbw %%mm2, %%mm2\n\t" "punpckhbw %%mm3, %%mm3\n\t" "punpcklbw %%mm4, %%mm4\n\t" "punpckhbw %%mm5, %%mm5\n\t" "punpcklbw %%mm6, %%mm6\n\t" "punpckhbw %%mm7, %%mm7\n\t" MOVNTQ" %%mm0, %0\n\t" MOVNTQ" %%mm1, 8%0\n\t" MOVNTQ" %%mm2, 16%0\n\t" MOVNTQ" %%mm3, 24%0\n\t" MOVNTQ" %%mm4, 32%0\n\t" MOVNTQ" %%mm5, 40%0\n\t" MOVNTQ" %%mm6, 48%0\n\t" MOVNTQ" %%mm7, 56%0" :"=m"(d[2*x]) :"m"(s2[x]) :"memory"); } #endif for(;x<w;x++) d[2*x]=d[2*x+1]=s2[x]; } #ifdef HAVE_MMX asm( EMMS" \n\t" SFENCE" \n\t" ::: "memory" ); #endif }

[[[[Adv]]]]: static inline void RENAME(vu9_to_vu12)(const uint8_t *src1, const uint8_t *src2, uint8_t *dst1, uint8_t *[[momentary]], long width, long height, long srcStride1, long srcStride2, long dstStride1, long dstStride2) { long y,x,w,h; w=width/2; h=height/2; #ifdef HAVE_MMX asm volatile( PREFETCH" %0\n\t" PREFETCH" %1\n\t" ::"m"(*(src1+srcStride1)),"m"(*(src2+srcStride2)):"memory"); #endif for(y=0;y<h;y++){ const uint8_t* s1=src1+srcStride1*(y>>1); uint8_t* d=dst1+dstStride1*y; x=0; #ifdef HAVE_MMX for(;x<w-31;x+=32) { asm volatile( PREFETCH" 32%1\n\t" "movq %1, %%mm0\n\t" "movq 8%1, %%mm2\n\t" "movq 16%1, %%mm4\n\t" "movq 24%1, %%mm6\n\t" "movq %%mm0, %%mm1\n\t" "movq %%mm2, %%mm3\n\t" "movq %%mm4, %%mm5\n\t" "movq %%mm6, %%mm7\n\t" "punpcklbw %%mm0, %%mm0\n\t" "punpckhbw %%mm1, %%mm1\n\t" "punpcklbw %%mm2, %%mm2\n\t" "punpckhbw %%mm3, %%mm3\n\t" "punpcklbw %%mm4, %%mm4\n\t" "punpckhbw %%mm5, %%mm5\n\t" "punpcklbw %%mm6, %%mm6\n\t" "punpckhbw %%mm7, %%mm7\n\t" MOVNTQ" %%mm0, %0\n\t" MOVNTQ" %%mm1, 8%0\n\t" MOVNTQ" %%mm2, 16%0\n\t" MOVNTQ" %%mm3, 24%0\n\t" MOVNTQ" %%mm4, 32%0\n\t" MOVNTQ" %%mm5, 40%0\n\t" MOVNTQ" %%mm6, 48%0\n\t" MOVNTQ" %%mm7, 56%0" :"=m"(d[2*x]) :"m"(s1[x]) :"memory"); } #endif for(;x<w;x++) d[2*x]=d[2*x+1]=s1[x]; } for(y=0;y<h;y++){ const uint8_t* s2=src2+srcStride2*(y>>1); uint8_t* d=[[momentary]]+dstStride2*y; x=0; #ifdef HAVE_MMX for(;x<w-31;x+=32) { asm volatile( PREFETCH" 32%1\n\t" "movq %1, %%mm0\n\t" "movq 8%1, %%mm2\n\t" "movq 16%1, %%mm4\n\t" "movq 24%1, %%mm6\n\t" "movq %%mm0, %%mm1\n\t" "movq %%mm2, %%mm3\n\t" "movq %%mm4, %%mm5\n\t" "movq %%mm6, %%mm7\n\t" "punpcklbw %%mm0, %%mm0\n\t" "punpckhbw %%mm1, %%mm1\n\t" "punpcklbw %%mm2, %%mm2\n\t" "punpckhbw %%mm3, %%mm3\n\t" "punpcklbw %%mm4, %%mm4\n\t" "punpckhbw %%mm5, %%mm5\n\t" "punpcklbw %%mm6, %%mm6\n\t" "punpckhbw %%mm7, %%mm7\n\t" MOVNTQ" %%mm0, %0\n\t" MOVNTQ" %%mm1, 8%0\n\t" MOVNTQ" %%mm2, 16%0\n\t" MOVNTQ" %%mm3, 24%0\n\t" MOVNTQ" %%mm4, 32%0\n\t" MOVNTQ" %%mm5, 40%0\n\t" MOVNTQ" %%mm6, 48%0\n\t" MOVNTQ" %%mm7, 56%0" :"=m"(d[2*x]) :"m"(s2[x]) :"memory"); } #endif for(;x<w;x++) d[2*x]=d[2*x+1]=s2[x]; } #ifdef HAVE_MMX asm( EMMS" \n\t" SFENCE" \n\t" ::: "memory" ); #endif }
--------------------------------------------- Result 1308 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 771 / 69 / 468 / 1308:  49%|     | 1308/2690 [14:35:04<15:24:34, 40.14s/it][Succeeded / Failed / Skipped / Total] 771 / 69 / 468 / 1308:  49%|     | 1309/2690 [14:35:08<15:23:17, 40.11s/it][Succeeded / Failed / Skipped / Total] 772 / 69 / 468 / 1309:  49%|     | 1309/2690 [14:35:08<15:23:17, 40.11s/it][Succeeded / Failed / Skipped / Total] 772 / 69 / 468 / 1309:  49%|     | 1310/2690 [14:35:38<15:22:25, 40.11s/it][[0 (35%)]] --> [[0 (53%)]] --> Socre: 0.5280413031578064

[[[[Adv]]]]: static void nbd_trip(void *opaque) { NBDClient *client = opaque; NBDExport *exp = client->exp; NBDRequest *req; struct nbd_request request; struct nbd_reply reply; ssize_t [[ret]]; uint32_t command; TRACE("Reading request."); if (client->closing) { return; } req = nbd_request_get(client); [[ret]] = nbd_co_receive_request(req, &request); if ([[ret]] == -EAGAIN) { goto done; } if ([[ret]] == -EIO) { goto out; } reply.handle = request.handle; reply.error = 0; if ([[ret]] < 0) { reply.error = -[[ret]]; goto error_reply; } command = request.type & NBD_CMD_MASK_COMMAND; if (command != NBD_CMD_DISC && (request.from + request.len) > exp->size) { LOG("From: %" PRIu64 ", Len: %u, Size: %" PRIu64 ", Offset: %" PRIu64 "\n", request.from, request.len, (uint64_t)exp->size, (uint64_t)exp->dev_offset); LOG("requested operation past EOF--bad client?"); goto invalid_request; } if (client->closing) { goto done; } switch (command) { case NBD_CMD_READ: TRACE("Request type is READ"); if (request.type & NBD_CMD_FLAG_FUA) { [[ret]] = blk_co_flush(exp->blk); if ([[ret]] < 0) { LOG("flush failed"); reply.error = -[[ret]]; goto error_reply; } } [[ret]] = blk_pread(exp->blk, request.from + exp->dev_offset, req->data, request.len); if ([[ret]] < 0) { LOG("reading from file failed"); reply.error = -[[ret]]; goto error_reply; } TRACE("Read %u byte(s)", request.len); if (nbd_co_send_reply(req, &reply, request.len) < 0) goto out; break; case NBD_CMD_WRITE: TRACE("Request type is WRITE"); if (exp->nbdflags & NBD_FLAG_READ_ONLY) { TRACE("Server is read-only, return error"); reply.error = EROFS; goto error_reply; } TRACE("Writing to device"); [[ret]] = blk_pwrite(exp->blk, request.from + exp->dev_offset, req->data, request.len, 0); if ([[ret]] < 0) { LOG("writing to file failed"); reply.error = -[[ret]]; goto error_reply; } if (request.type & NBD_CMD_FLAG_FUA) { [[ret]] = blk_co_flush(exp->blk); if ([[ret]] < 0) { LOG("flush failed"); reply.error = -[[ret]]; goto error_reply; } } if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; case NBD_CMD_DISC: TRACE("Request type is DISCONNECT"); errno = 0; goto out; case NBD_CMD_FLUSH: TRACE("Request type is FLUSH"); [[ret]] = blk_co_flush(exp->blk); if ([[ret]] < 0) { LOG("flush failed"); reply.error = -[[ret]]; } if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; case NBD_CMD_TRIM: TRACE("Request type is TRIM"); [[ret]] = blk_co_discard(exp->blk, (request.from + exp->dev_offset) / BDRV_SECTOR_SIZE, request.len / BDRV_SECTOR_SIZE); if ([[ret]] < 0) { LOG("discard failed"); reply.error = -[[ret]]; } if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; default: LOG("invalid request type (%u) received", request.type); invalid_request: reply.error = EINVAL; error_reply: if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; } TRACE("Request/Reply complete"); done: nbd_request_put(req); return; out: nbd_request_put(req); client_close(client); }

[[[[Adv]]]]: static void nbd_trip(void *opaque) { NBDClient *client = opaque; NBDExport *exp = client->exp; NBDRequest *req; struct nbd_request request; struct nbd_reply reply; ssize_t [[erp]]; uint32_t command; TRACE("Reading request."); if (client->closing) { return; } req = nbd_request_get(client); [[erp]] = nbd_co_receive_request(req, &request); if ([[erp]] == -EAGAIN) { goto done; } if ([[erp]] == -EIO) { goto out; } reply.handle = request.handle; reply.error = 0; if ([[erp]] < 0) { reply.error = -[[erp]]; goto error_reply; } command = request.type & NBD_CMD_MASK_COMMAND; if (command != NBD_CMD_DISC && (request.from + request.len) > exp->size) { LOG("From: %" PRIu64 ", Len: %u, Size: %" PRIu64 ", Offset: %" PRIu64 "\n", request.from, request.len, (uint64_t)exp->size, (uint64_t)exp->dev_offset); LOG("requested operation past EOF--bad client?"); goto invalid_request; } if (client->closing) { goto done; } switch (command) { case NBD_CMD_READ: TRACE("Request type is READ"); if (request.type & NBD_CMD_FLAG_FUA) { [[erp]] = blk_co_flush(exp->blk); if ([[erp]] < 0) { LOG("flush failed"); reply.error = -[[erp]]; goto error_reply; } } [[erp]] = blk_pread(exp->blk, request.from + exp->dev_offset, req->data, request.len); if ([[erp]] < 0) { LOG("reading from file failed"); reply.error = -[[erp]]; goto error_reply; } TRACE("Read %u byte(s)", request.len); if (nbd_co_send_reply(req, &reply, request.len) < 0) goto out; break; case NBD_CMD_WRITE: TRACE("Request type is WRITE"); if (exp->nbdflags & NBD_FLAG_READ_ONLY) { TRACE("Server is read-only, return error"); reply.error = EROFS; goto error_reply; } TRACE("Writing to device"); [[erp]] = blk_pwrite(exp->blk, request.from + exp->dev_offset, req->data, request.len, 0); if ([[erp]] < 0) { LOG("writing to file failed"); reply.error = -[[erp]]; goto error_reply; } if (request.type & NBD_CMD_FLAG_FUA) { [[erp]] = blk_co_flush(exp->blk); if ([[erp]] < 0) { LOG("flush failed"); reply.error = -[[erp]]; goto error_reply; } } if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; case NBD_CMD_DISC: TRACE("Request type is DISCONNECT"); errno = 0; goto out; case NBD_CMD_FLUSH: TRACE("Request type is FLUSH"); [[erp]] = blk_co_flush(exp->blk); if ([[erp]] < 0) { LOG("flush failed"); reply.error = -[[erp]]; } if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; case NBD_CMD_TRIM: TRACE("Request type is TRIM"); [[erp]] = blk_co_discard(exp->blk, (request.from + exp->dev_offset) / BDRV_SECTOR_SIZE, request.len / BDRV_SECTOR_SIZE); if ([[erp]] < 0) { LOG("discard failed"); reply.error = -[[erp]]; } if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; default: LOG("invalid request type (%u) received", request.type); invalid_request: reply.error = EINVAL; error_reply: if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; } TRACE("Request/Reply complete"); done: nbd_request_put(req); return; out: nbd_request_put(req); client_close(client); }
--------------------------------------------- Result 1309 ---------------------------------------------
[[0 (88%)]] --> [[0 (49%)]] --> Socre: 0.5057818293571472

[[[[Adv]]]]: static void vmxnet3_update_mcast_filters(VMXNET3State *s) { uint16_t [[list_bytes]] = VMXNET3_READ_DRV_SHARED16(s->drv_shmem, devRead.rxFilterConf.mfTableLen); s->mcast_list_len = [[list_bytes]] / sizeof(s->mcast_list[0]); s->mcast_list = g_realloc(s->mcast_list, [[list_bytes]]); if (!s->mcast_list) { if (s->mcast_list_len == 0) { VMW_CFPRN("Current multicast list is empty"); } else { VMW_ERPRN("Failed to allocate multicast list of %d elements", s->mcast_list_len); } s->mcast_list_len = 0; } else { int i; hwaddr mcast_list_pa = VMXNET3_READ_DRV_SHARED64(s->drv_shmem, devRead.rxFilterConf.mfTablePA); pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, [[list_bytes]]); VMW_CFPRN("Current multicast list len is %d:", s->mcast_list_len); for (i = 0; i < s->mcast_list_len; i++) { VMW_CFPRN("\t" MAC_FMT, MAC_ARG(s->mcast_list[i].a)); } } }

[[[[Adv]]]]: static void vmxnet3_update_mcast_filters(VMXNET3State *s) { uint16_t [[teller]] = VMXNET3_READ_DRV_SHARED16(s->drv_shmem, devRead.rxFilterConf.mfTableLen); s->mcast_list_len = [[teller]] / sizeof(s->mcast_list[0]); s->mcast_list = g_realloc(s->mcast_list, [[teller]]); if (!s->mcast_list) { if (s->mcast_list_len == 0) { VMW_CFPRN("Current multicast list is empty"); } else { VMW_ERPRN("Failed to allocate multicast list of %d elements", s->mcast_list_len); } s->mcast_list_len = 0; } else { int i; hwaddr mcast_list_pa = VMXNET3_READ_DRV_SHARED64(s->drv_shmem, devRead.rxFilterConf.mfTablePA); pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, [[teller]]); VMW_CFPRN("Current multicast list len is %d:", s->mcast_list_len); for (i = 0; i < s->mcast_list_len; i++) { VMW_CFPRN("\t" MAC_FMT, MAC_ARG(s->mcast_list[i].a)); } } }
--------------------------------------------- Result 1310 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 773 / 69 / 468 / 1310:  49%|     | 1310/2690 [14:35:38<15:22:25, 40.11s/it][Succeeded / Failed / Skipped / Total] 773 / 69 / 468 / 1310:  49%|     | 1311/2690 [14:36:26<15:21:54, 40.11s/it][[0 (1%)]] --> [[0 (99%)]] --> Socre: 0.9870619177818298

[[[[Adv]]]]: static void avc_luma_midv_qrt_4w_msa(const uint8_t *[[src]], int32_t [[src_stride]], uint8_t *dst, int32_t dst_stride, int32_t height, uint8_t ver_offset) { uint32_t loop_cnt; v16i8 [[src0]], src1, src2, src3, src4; v16i8 mask0, mask1, mask2; v8i16 [[hz_out0]], hz_out1, hz_out2, hz_out3; v8i16 hz_out4, hz_out5, hz_out6, hz_out7, hz_out8; v8i16 [[dst0]], dst1, dst2, dst3, dst4, dst5, dst6, dst7; LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2); LD_SB5([[src]], [[src_stride]], [[src0]], src1, src2, src3, src4); [[src]] += (5 * [[src_stride]]); XORI_B5_128_SB([[src0]], src1, src2, src3, src4); [[hz_out0]] = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH([[src0]], src1, mask0, mask1, mask2); hz_out2 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3, mask0, mask1, mask2); PCKOD_D2_SH([[hz_out0]], [[hz_out0]], hz_out2, hz_out2, hz_out1, hz_out3); hz_out4 = AVC_HORZ_FILTER_SH(src4, mask0, mask1, mask2); for (loop_cnt = (height >> 2); loop_cnt--;) { LD_SB4([[src]], [[src_stride]], [[src0]], src1, src2, src3); [[src]] += (4 * [[src_stride]]); XORI_B4_128_SB([[src0]], src1, src2, src3); hz_out5 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH([[src0]], src1, mask0, mask1, mask2); hz_out7 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3, mask0, mask1, mask2); PCKOD_D2_SH(hz_out5, hz_out5, hz_out7, hz_out7, hz_out6, hz_out8); [[dst0]] = AVC_CALC_DPADD_H_6PIX_2COEFF_SH([[hz_out0]], hz_out1, hz_out2, hz_out3, hz_out4, hz_out5); dst2 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out1, hz_out2, hz_out3, hz_out4, hz_out5, hz_out6); dst4 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out2, hz_out3, hz_out4, hz_out5, hz_out6, hz_out7); dst6 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out3, hz_out4, hz_out5, hz_out6, hz_out7, hz_out8); if (ver_offset) { dst1 = __msa_srari_h(hz_out3, 5); dst3 = __msa_srari_h(hz_out4, 5); dst5 = __msa_srari_h(hz_out5, 5); dst7 = __msa_srari_h(hz_out6, 5); } else { dst1 = __msa_srari_h(hz_out2, 5); dst3 = __msa_srari_h(hz_out3, 5); dst5 = __msa_srari_h(hz_out4, 5); dst7 = __msa_srari_h(hz_out5, 5); } SAT_SH4_SH(dst1, dst3, dst5, dst7, 7); [[dst0]] = __msa_aver_s_h([[dst0]], dst1); dst1 = __msa_aver_s_h(dst2, dst3); dst2 = __msa_aver_s_h(dst4, dst5); dst3 = __msa_aver_s_h(dst6, dst7); PCKEV_B2_SB(dst1, [[dst0]], dst3, dst2, [[src0]], src1); XORI_B2_128_SB([[src0]], src1); ST4x4_UB([[src0]], src1, 0, 2, 0, 2, dst, dst_stride); dst += (4 * dst_stride); [[hz_out0]] = hz_out4; hz_out1 = hz_out5; hz_out2 = hz_out6; hz_out3 = hz_out7; hz_out4 = hz_out8; } }

[[[[Adv]]]]: static void avc_luma_midv_qrt_4w_msa(const uint8_t *[[doesnt]], int32_t [[sartorius]], uint8_t *dst, int32_t dst_stride, int32_t height, uint8_t ver_offset) { uint32_t loop_cnt; v16i8 [[sawant]], src1, src2, src3, src4; v16i8 mask0, mask1, mask2; v8i16 [[nickel]], hz_out1, hz_out2, hz_out3; v8i16 hz_out4, hz_out5, hz_out6, hz_out7, hz_out8; v8i16 [[grip]], dst1, dst2, dst3, dst4, dst5, dst6, dst7; LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2); LD_SB5([[doesnt]], [[sartorius]], [[sawant]], src1, src2, src3, src4); [[doesnt]] += (5 * [[sartorius]]); XORI_B5_128_SB([[sawant]], src1, src2, src3, src4); [[nickel]] = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH([[sawant]], src1, mask0, mask1, mask2); hz_out2 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3, mask0, mask1, mask2); PCKOD_D2_SH([[nickel]], [[nickel]], hz_out2, hz_out2, hz_out1, hz_out3); hz_out4 = AVC_HORZ_FILTER_SH(src4, mask0, mask1, mask2); for (loop_cnt = (height >> 2); loop_cnt--;) { LD_SB4([[doesnt]], [[sartorius]], [[sawant]], src1, src2, src3); [[doesnt]] += (4 * [[sartorius]]); XORI_B4_128_SB([[sawant]], src1, src2, src3); hz_out5 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH([[sawant]], src1, mask0, mask1, mask2); hz_out7 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3, mask0, mask1, mask2); PCKOD_D2_SH(hz_out5, hz_out5, hz_out7, hz_out7, hz_out6, hz_out8); [[grip]] = AVC_CALC_DPADD_H_6PIX_2COEFF_SH([[nickel]], hz_out1, hz_out2, hz_out3, hz_out4, hz_out5); dst2 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out1, hz_out2, hz_out3, hz_out4, hz_out5, hz_out6); dst4 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out2, hz_out3, hz_out4, hz_out5, hz_out6, hz_out7); dst6 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out3, hz_out4, hz_out5, hz_out6, hz_out7, hz_out8); if (ver_offset) { dst1 = __msa_srari_h(hz_out3, 5); dst3 = __msa_srari_h(hz_out4, 5); dst5 = __msa_srari_h(hz_out5, 5); dst7 = __msa_srari_h(hz_out6, 5); } else { dst1 = __msa_srari_h(hz_out2, 5); dst3 = __msa_srari_h(hz_out3, 5); dst5 = __msa_srari_h(hz_out4, 5); dst7 = __msa_srari_h(hz_out5, 5); } SAT_SH4_SH(dst1, dst3, dst5, dst7, 7); [[grip]] = __msa_aver_s_h([[grip]], dst1); dst1 = __msa_aver_s_h(dst2, dst3); dst2 = __msa_aver_s_h(dst4, dst5); dst3 = __msa_aver_s_h(dst6, dst7); PCKEV_B2_SB(dst1, [[grip]], dst3, dst2, [[sawant]], src1); XORI_B2_128_SB([[sawant]], src1); ST4x4_UB([[sawant]], src1, 0, 2, 0, 2, dst, dst_stride); dst += (4 * dst_stride); [[nickel]] = hz_out4; hz_out1 = hz_out5; hz_out2 = hz_out6; hz_out3 = hz_out7; hz_out4 = hz_out8; } }
--------------------------------------------- Result 1311 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 774 / 69 / 468 / 1311:  49%|     | 1311/2690 [14:36:26<15:21:54, 40.11s/it][Succeeded / Failed / Skipped / Total] 774 / 69 / 468 / 1311:  49%|     | 1312/2690 [14:36:27<15:20:32, 40.08s/it][Succeeded / Failed / Skipped / Total] 774 / 69 / 469 / 1312:  49%|     | 1312/2690 [14:36:27<15:20:32, 40.08s/it][Succeeded / Failed / Skipped / Total] 774 / 69 / 469 / 1312:  49%|     | 1313/2690 [14:36:32<15:19:15, 40.06s/it][Succeeded / Failed / Skipped / Total] 775 / 69 / 469 / 1313:  49%|     | 1313/2690 [14:36:32<15:19:15, 40.06s/it][Succeeded / Failed / Skipped / Total] 775 / 69 / 469 / 1313:  49%|     | 1314/2690 [14:36:47<15:18:09, 40.04s/it][Succeeded / Failed / Skipped / Total] 776 / 69 / 469 / 1314:  49%|     | 1314/2690 [14:36:47<15:18:09, 40.04s/it][Succeeded / Failed / Skipped / Total] 776 / 69 / 469 / 1314:  49%|     | 1315/2690 [14:36:50<15:16:51, 40.01s/it][[0 (95%)]] --> [[0 (39%)]] --> Socre: 0.6068361401557922

[[[[Adv]]]]: static av_always_inline void vc1_apply_p_h_loop_filter(VC1Context *v, int [[block_num]]) { MpegEncContext *s = &v->s; int [[mb_cbp]] = v->cbp[s->mb_x - 1 - s->mb_stride], block_cbp = [[mb_cbp]] >> ([[block_num]] * 4), right_cbp, mb_is_intra = v->is_intra[s->mb_x - 1 - s->mb_stride], block_is_intra = mb_is_intra >> ([[block_num]] * 4), right_is_intra; int [[idx]], linesize = [[block_num]] > 3 ? s->uvlinesize : s->linesize, ttblk; uint8_t *dst; if ([[block_num]] > 3) { dst = s->dest[[[block_num]] - 3] - 8 * linesize; } else { dst = s->dest[0] + ([[block_num]] & 1) * 8 + (([[block_num]] & 2) * 4 - 16) * linesize - 8; } if (s->mb_x != s->mb_width || !([[block_num]] & 5)) { int16_t (*mv)[2]; if ([[block_num]] > 3) { right_cbp = v->cbp[s->mb_x - s->mb_stride] >> ([[block_num]] * 4); right_is_intra = v->is_intra[s->mb_x - s->mb_stride] >> ([[block_num]] * 4); mv = &v->luma_mv[s->mb_x - s->mb_stride - 1]; } else { right_cbp = ([[block_num]] & 1) ? (v->cbp[s->mb_x - s->mb_stride] >> (([[block_num]] - 1) * 4)) : ([[mb_cbp]] >> (([[block_num]] + 1) * 4)); right_is_intra = ([[block_num]] & 1) ? (v->is_intra[s->mb_x - s->mb_stride] >> (([[block_num]] - 1) * 4)) : (mb_is_intra >> (([[block_num]] + 1) * 4)); mv = &s->current_picture.motion_val[0][s->block_index[[[block_num]]] - s->b8_stride * 2 - 2]; } if (block_is_intra & 1 || right_is_intra & 1 || mv[0][0] != mv[1][0] || mv[0][1] != mv[1][1]) { v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq); } else { [[idx]] = ((right_cbp >> 1) | block_cbp) & 5; if ([[idx]] == 5) { v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq); } else if ([[idx]]) { if ([[idx]] == 1) v->vc1dsp.vc1_h_loop_filter4(dst + 4 * linesize, linesize, v->pq); else v->vc1dsp.vc1_h_loop_filter4(dst, linesize, v->pq); } } } dst -= 4; ttblk = (v->ttblk[s->mb_x - s->mb_stride - 1] >> ([[block_num]] * 4)) & 0xf; if (ttblk == TT_4X4 || ttblk == TT_4X8) { [[idx]] = (block_cbp | (block_cbp >> 1)) & 5; if ([[idx]] == 5) { v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq); } else if ([[idx]]) { if ([[idx]] == 1) v->vc1dsp.vc1_h_loop_filter4(dst + linesize * 4, linesize, v->pq); else v->vc1dsp.vc1_h_loop_filter4(dst, linesize, v->pq); } } }

[[[[Adv]]]]: static av_always_inline void vc1_apply_p_h_loop_filter(VC1Context *v, int [[poe]]) { MpegEncContext *s = &v->s; int [[scala]] = v->cbp[s->mb_x - 1 - s->mb_stride], block_cbp = [[scala]] >> ([[poe]] * 4), right_cbp, mb_is_intra = v->is_intra[s->mb_x - 1 - s->mb_stride], block_is_intra = mb_is_intra >> ([[poe]] * 4), right_is_intra; int [[flamb]], linesize = [[poe]] > 3 ? s->uvlinesize : s->linesize, ttblk; uint8_t *dst; if ([[poe]] > 3) { dst = s->dest[[[poe]] - 3] - 8 * linesize; } else { dst = s->dest[0] + ([[poe]] & 1) * 8 + (([[poe]] & 2) * 4 - 16) * linesize - 8; } if (s->mb_x != s->mb_width || !([[poe]] & 5)) { int16_t (*mv)[2]; if ([[poe]] > 3) { right_cbp = v->cbp[s->mb_x - s->mb_stride] >> ([[poe]] * 4); right_is_intra = v->is_intra[s->mb_x - s->mb_stride] >> ([[poe]] * 4); mv = &v->luma_mv[s->mb_x - s->mb_stride - 1]; } else { right_cbp = ([[poe]] & 1) ? (v->cbp[s->mb_x - s->mb_stride] >> (([[poe]] - 1) * 4)) : ([[scala]] >> (([[poe]] + 1) * 4)); right_is_intra = ([[poe]] & 1) ? (v->is_intra[s->mb_x - s->mb_stride] >> (([[poe]] - 1) * 4)) : (mb_is_intra >> (([[poe]] + 1) * 4)); mv = &s->current_picture.motion_val[0][s->block_index[[[poe]]] - s->b8_stride * 2 - 2]; } if (block_is_intra & 1 || right_is_intra & 1 || mv[0][0] != mv[1][0] || mv[0][1] != mv[1][1]) { v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq); } else { [[flamb]] = ((right_cbp >> 1) | block_cbp) & 5; if ([[flamb]] == 5) { v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq); } else if ([[flamb]]) { if ([[flamb]] == 1) v->vc1dsp.vc1_h_loop_filter4(dst + 4 * linesize, linesize, v->pq); else v->vc1dsp.vc1_h_loop_filter4(dst, linesize, v->pq); } } } dst -= 4; ttblk = (v->ttblk[s->mb_x - s->mb_stride - 1] >> ([[poe]] * 4)) & 0xf; if (ttblk == TT_4X4 || ttblk == TT_4X8) { [[flamb]] = (block_cbp | (block_cbp >> 1)) & 5; if ([[flamb]] == 5) { v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq); } else if ([[flamb]]) { if ([[flamb]] == 1) v->vc1dsp.vc1_h_loop_filter4(dst + linesize * 4, linesize, v->pq); else v->vc1dsp.vc1_h_loop_filter4(dst, linesize, v->pq); } } }
--------------------------------------------- Result 1312 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: PCIBus *i440fx_init(PCII440FXState **pi440fx_state, int *piix3_devfn, qemu_irq *pic, int ram_size) { DeviceState *dev; PCIBus *b; PCIDevice *d; I440FXState *s; PIIX3State *piix3; dev = qdev_create(NULL, "i440FX-pcihost"); s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev)); b = pci_bus_new(&s->busdev.qdev, NULL, 0); s->bus = b; qdev_init_nofail(dev); d = pci_create_simple(b, 0, "i440FX"); *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d); piix3 = DO_UPCAST(PIIX3State, dev, pci_create_simple(b, -1, "PIIX3")); piix3->pic = pic; pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4); (*pi440fx_state)->piix3 = piix3; *piix3_devfn = piix3->dev.devfn; ram_size = ram_size / 8 / 1024 / 1024; if (ram_size > 255) ram_size = 255; (*pi440fx_state)->dev.config[0x57]=ram_size; return b; }
--------------------------------------------- Result 1313 ---------------------------------------------
[[0 (97%)]] --> [[0 (46%)]] --> Socre: 0.5353609621524811

[[[[Adv]]]]: uint64_t helper_cvttq_c(CPUAlphaState *[[env]], uint64_t [[a]]) { return inline_cvttq([[env]], [[a]], float_round_to_zero, 0); }

[[[[Adv]]]]: uint64_t helper_cvttq_c(CPUAlphaState *[[conveniences]], uint64_t [[questo]]) { return inline_cvttq([[conveniences]], [[questo]], float_round_to_zero, 0); }
--------------------------------------------- Result 1314 ---------------------------------------------
[[0 (33%)]] --> [[0 (76%)]] --> Socre: 0.7621236443519592

[[[[Adv]]]]: int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size) { int [[ret]]; s->ext_audio_mask = 0; s->xch_pos = s->xxch_pos = s->x96_pos = 0; if (([[ret]] = init_get_bits8(&s->gb, data, size)) < 0) return [[ret]]; s->gb_in = s->gb; if (([[ret]] = parse_frame_header(s)) < 0) return [[ret]]; if (([[ret]] = alloc_sample_buffer(s)) < 0) return [[ret]]; if (([[ret]] = parse_frame_data(s, HEADER_CORE, 0)) < 0) return [[ret]]; if (([[ret]] = parse_optional_info(s)) < 0) return [[ret]]; if (s->frame_size > size && s->frame_size < size + 4) s->frame_size = size; if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) { av_log(s->avctx, AV_LOG_ERROR, "Read past end of core frame\n"); if (s->avctx->err_recognition & AV_EF_EXPLODE) return AVERROR_INVALIDDATA; } return 0; }

[[[[Adv]]]]: int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size) { int [[pensions]]; s->ext_audio_mask = 0; s->xch_pos = s->xxch_pos = s->x96_pos = 0; if (([[pensions]] = init_get_bits8(&s->gb, data, size)) < 0) return [[pensions]]; s->gb_in = s->gb; if (([[pensions]] = parse_frame_header(s)) < 0) return [[pensions]]; if (([[pensions]] = alloc_sample_buffer(s)) < 0) return [[pensions]]; if (([[pensions]] = parse_frame_data(s, HEADER_CORE, 0)) < 0) return [[pensions]]; if (([[pensions]] = parse_optional_info(s)) < 0) return [[pensions]]; if (s->frame_size > size && s->frame_size < size + 4) s->frame_size = size; if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) { av_log(s->avctx, AV_LOG_ERROR, "Read past end of core frame\n"); if (s->avctx->err_recognition & AV_EF_EXPLODE) return AVERROR_INVALIDDATA; } return 0; }
--------------------------------------------- Result 1315 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 777 / 69 / 469 / 1315:  49%|     | 1315/2690 [14:36:50<15:16:51, 40.01s/it][Succeeded / Failed / Skipped / Total] 777 / 69 / 469 / 1315:  49%|     | 1316/2690 [14:36:57<15:15:36, 39.98s/it][Succeeded / Failed / Skipped / Total] 778 / 69 / 469 / 1316:  49%|     | 1316/2690 [14:36:57<15:15:36, 39.98s/it][Succeeded / Failed / Skipped / Total] 778 / 69 / 469 / 1316:  49%|     | 1317/2690 [14:36:58<15:14:15, 39.95s/it][Succeeded / Failed / Skipped / Total] 778 / 69 / 470 / 1317:  49%|     | 1317/2690 [14:36:58<15:14:15, 39.95s/it][Succeeded / Failed / Skipped / Total] 778 / 69 / 470 / 1317:  49%|     | 1318/2690 [14:36:58<15:12:54, 39.92s/it][Succeeded / Failed / Skipped / Total] 778 / 69 / 471 / 1318:  49%|     | 1318/2690 [14:36:58<15:12:54, 39.92s/it][Succeeded / Failed / Skipped / Total] 778 / 69 / 471 / 1318:  49%|     | 1319/2690 [14:37:07<15:11:42, 39.90s/it][[0 (75%)]] --> [[0 (34%)]] --> Socre: 0.6582432389259338

[[[[Adv]]]]: static void gen_mulu(DisasContext *dc, TCGv dest, TCGv [[srca]], TCGv srcb) { TCGv sr_cy = tcg_temp_new(); tcg_gen_muls2_tl(dest, sr_cy, [[srca]], srcb); tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0); tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1); gen_ove_cy(dc, sr_cy); tcg_temp_free(sr_cy); }

[[[[Adv]]]]: static void gen_mulu(DisasContext *dc, TCGv dest, TCGv [[bruschetta]], TCGv srcb) { TCGv sr_cy = tcg_temp_new(); tcg_gen_muls2_tl(dest, sr_cy, [[bruschetta]], srcb); tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0); tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1); gen_ove_cy(dc, sr_cy); tcg_temp_free(sr_cy); }
--------------------------------------------- Result 1316 ---------------------------------------------
[[0 (33%)]] --> [[0 (96%)]] --> Socre: 0.9597886800765991

[[[[Adv]]]]: static int decode_init_mp3on4(AVCodecContext * [[avctx]]) { MP3On4DecodeContext *s = [[avctx]]->priv_data; int i; if (([[avctx]]->extradata_size < 2) || ([[avctx]]->extradata == NULL)) { av_log([[avctx]], AV_LOG_ERROR, "Codec extradata missing or too short.\n"); return -1; } s->chan_cfg = (((unsigned char *)[[avctx]]->extradata)[1] >> 3) & 0x0f; s->frames = mp3Frames[s->chan_cfg]; if(!s->frames) { av_log([[avctx]], AV_LOG_ERROR, "Invalid channel config number.\n"); return -1; } [[avctx]]->channels = mp3Channels[s->chan_cfg]; s->mp3decctx[0] = av_mallocz(sizeof(MPADecodeContext)); [[avctx]]->priv_data = s->mp3decctx[0]; decode_init([[avctx]]); [[avctx]]->priv_data = s; s->mp3decctx[0]->adu_mode = 1; for (i = 1; i < s->frames; i++) { s->mp3decctx[i] = av_mallocz(sizeof(MPADecodeContext)); s->mp3decctx[i]->compute_antialias = s->mp3decctx[0]->compute_antialias; s->mp3decctx[i]->adu_mode = 1; s->mp3decctx[i]->avctx = [[avctx]]; } return 0; }

[[[[Adv]]]]: static int decode_init_mp3on4(AVCodecContext * [[zeynep]]) { MP3On4DecodeContext *s = [[zeynep]]->priv_data; int i; if (([[zeynep]]->extradata_size < 2) || ([[zeynep]]->extradata == NULL)) { av_log([[zeynep]], AV_LOG_ERROR, "Codec extradata missing or too short.\n"); return -1; } s->chan_cfg = (((unsigned char *)[[zeynep]]->extradata)[1] >> 3) & 0x0f; s->frames = mp3Frames[s->chan_cfg]; if(!s->frames) { av_log([[zeynep]], AV_LOG_ERROR, "Invalid channel config number.\n"); return -1; } [[zeynep]]->channels = mp3Channels[s->chan_cfg]; s->mp3decctx[0] = av_mallocz(sizeof(MPADecodeContext)); [[zeynep]]->priv_data = s->mp3decctx[0]; decode_init([[zeynep]]); [[zeynep]]->priv_data = s; s->mp3decctx[0]->adu_mode = 1; for (i = 1; i < s->frames; i++) { s->mp3decctx[i] = av_mallocz(sizeof(MPADecodeContext)); s->mp3decctx[i]->compute_antialias = s->mp3decctx[0]->compute_antialias; s->mp3decctx[i]->adu_mode = 1; s->mp3decctx[i]->avctx = [[zeynep]]; } return 0; }
--------------------------------------------- Result 1317 ---------------------------------------------
[[0 (41%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void curl_readv_bh_cb(void *p) { CURLState *state; int running; CURLAIOCB *acb = p; BDRVCURLState *s = acb->common.bs->opaque; qemu_bh_delete(acb->bh); acb->bh = NULL; size_t start = acb->sector_num * SECTOR_SIZE; size_t end; switch (curl_find_buf(s, start, acb->nb_sectors * SECTOR_SIZE, acb)) { case FIND_RET_OK: qemu_aio_release(acb); case FIND_RET_WAIT: return; default: break; } state = curl_init_state(s); if (!state) { acb->common.cb(acb->common.opaque, -EIO); qemu_aio_release(acb); return; } acb->start = 0; acb->end = (acb->nb_sectors * SECTOR_SIZE); state->buf_off = 0; g_free(state->orig_buf); state->buf_start = start; state->buf_len = acb->end + s->readahead_size; end = MIN(start + state->buf_len, s->len) - 1; state->orig_buf = g_malloc(state->buf_len); state->acb[0] = acb; snprintf(state->range, 127, "%zd-%zd", start, end); DPRINTF("CURL (AIO): Reading %d at %zd (%s)\n", (acb->nb_sectors * SECTOR_SIZE), start, state->range); curl_easy_setopt(state->curl, CURLOPT_RANGE, state->range); curl_multi_add_handle(s->multi, state->curl); curl_multi_socket_action(s->multi, CURL_SOCKET_TIMEOUT, 0, &running); }
--------------------------------------------- Result 1318 ---------------------------------------------
[[0 (25%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int dnxhd_encode_rdo(AVCodecContext *avctx, DNXHDEncContext *ctx) { int lambda, up_step, down_step; int last_lower = INT_MAX, last_higher = 0; int x, y, q; for (q = 1; q < avctx->qmax; q++) { ctx->qscale = q; avctx->execute2(avctx, dnxhd_calc_bits_thread, NULL, NULL, ctx->m.mb_height); } up_step = down_step = 2<<LAMBDA_FRAC_BITS; lambda = ctx->lambda; for (;;) { int bits = 0; int end = 0; if (lambda == last_higher) { lambda++; end = 1; } for (y = 0; y < ctx->m.mb_height; y++) { for (x = 0; x < ctx->m.mb_width; x++) { unsigned min = UINT_MAX; int qscale = 1; int mb = y*ctx->m.mb_width+x; for (q = 1; q < avctx->qmax; q++) { unsigned score = ctx->mb_rc[q][mb].bits*lambda+(ctx->mb_rc[q][mb].ssd<<LAMBDA_FRAC_BITS); if (score < min) { min = score; qscale = q; } } bits += ctx->mb_rc[qscale][mb].bits; ctx->mb_qscale[mb] = qscale; ctx->mb_bits[mb] = ctx->mb_rc[qscale][mb].bits; } bits = (bits+31)&~31; if (bits > ctx->frame_bits) break; } if (end) { if (bits > ctx->frame_bits) return -1; break; } if (bits < ctx->frame_bits) { last_lower = FFMIN(lambda, last_lower); if (last_higher != 0) lambda = (lambda+last_higher)>>1; else lambda -= down_step; down_step *= 5; up_step = 1<<LAMBDA_FRAC_BITS; lambda = FFMAX(1, lambda); if (lambda == last_lower) break; } else { last_higher = FFMAX(lambda, last_higher); if (last_lower != INT_MAX) lambda = (lambda+last_lower)>>1; else if ((int64_t)lambda + up_step > INT_MAX) return -1; else lambda += up_step; up_step = FFMIN((int64_t)up_step*5, INT_MAX); down_step = 1<<LAMBDA_FRAC_BITS; } } ctx->lambda = lambda; return 0; }
--------------------------------------------- Result 1319 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 779 / 69 / 471 / 1319:  49%|     | 1319/2690 [14:37:07<15:11:42, 39.90s/it][Succeeded / Failed / Skipped / Total] 779 / 69 / 471 / 1319:  49%|     | 1320/2690 [14:37:09<15:10:22, 39.87s/it][Succeeded / Failed / Skipped / Total] 780 / 69 / 471 / 1320:  49%|     | 1320/2690 [14:37:09<15:10:22, 39.87s/it][Succeeded / Failed / Skipped / Total] 780 / 69 / 471 / 1320:  49%|     | 1321/2690 [14:39:27<15:11:24, 39.94s/it][[0 (59%)]] --> [[0 (46%)]] --> Socre: 0.5392559766769409

[[[[Adv]]]]: static int find_and_decode_index(NUTContext *nut) { AVFormatContext *s = nut->avf; AVIOContext *bc = s->pb; uint64_t [[tmp]], end; int i, j, syncpoint_count; int64_t filesize = avio_size(bc); int64_t *syncpoints; int8_t *[[has_keyframe]]; int ret = AVERROR_INVALIDDATA; avio_seek(bc, filesize - 12, SEEK_SET); avio_seek(bc, filesize - avio_rb64(bc), SEEK_SET); if (avio_rb64(bc) != INDEX_STARTCODE) { av_log(s, AV_LOG_ERROR, "no index at the end\n"); return ret; } end = get_packetheader(nut, bc, 1, INDEX_STARTCODE); end += avio_tell(bc); ffio_read_varlen(bc); GET_V(syncpoint_count, [[tmp]] < INT_MAX / 8 && [[tmp]] > 0); syncpoints = av_malloc(sizeof(int64_t) * syncpoint_count); [[has_keyframe]] = av_malloc(sizeof(int8_t) * (syncpoint_count + 1)); if (!syncpoints || ![[has_keyframe]]) return AVERROR(ENOMEM); for (i = 0; i < syncpoint_count; i++) { syncpoints[i] = ffio_read_varlen(bc); if (syncpoints[i] <= 0) goto fail; if (i) syncpoints[i] += syncpoints[i - 1]; } for (i = 0; i < s->nb_streams; i++) { int64_t last_pts = -1; for (j = 0; j < syncpoint_count;) { uint64_t x = ffio_read_varlen(bc); int type = x & 1; int n = j; x >>= 1; if (type) { int flag = x & 1; x >>= 1; if (n + x >= syncpoint_count + 1) { av_log(s, AV_LOG_ERROR, "index overflow A\n"); goto fail; } while (x--) [[has_keyframe]][n++] = flag; [[has_keyframe]][n++] = !flag; } else { while (x != 1) { if (n >= syncpoint_count + 1) { av_log(s, AV_LOG_ERROR, "index overflow B\n"); goto fail; } [[has_keyframe]][n++] = x & 1; x >>= 1; } } if ([[has_keyframe]][0]) { av_log(s, AV_LOG_ERROR, "keyframe before first syncpoint in index\n"); goto fail; } assert(n <= syncpoint_count + 1); for (; j < n && j < syncpoint_count; j++) { if ([[has_keyframe]][j]) { uint64_t B, A = ffio_read_varlen(bc); if (!A) { A = ffio_read_varlen(bc); B = ffio_read_varlen(bc); } else B = 0; av_add_index_entry(s->streams[i], 16 * syncpoints[j - 1], last_pts + A, 0, 0, AVINDEX_KEYFRAME); last_pts += A + B; } } } } if (skip_reserved(bc, end) || ffio_get_checksum(bc)) { av_log(s, AV_LOG_ERROR, "index checksum mismatch\n"); goto fail; } ret = 0; fail: av_free(syncpoints); av_free([[has_keyframe]]); return ret; }

[[[[Adv]]]]: static int find_and_decode_index(NUTContext *nut) { AVFormatContext *s = nut->avf; AVIOContext *bc = s->pb; uint64_t [[claiborne]], end; int i, j, syncpoint_count; int64_t filesize = avio_size(bc); int64_t *syncpoints; int8_t *[[advisory]]; int ret = AVERROR_INVALIDDATA; avio_seek(bc, filesize - 12, SEEK_SET); avio_seek(bc, filesize - avio_rb64(bc), SEEK_SET); if (avio_rb64(bc) != INDEX_STARTCODE) { av_log(s, AV_LOG_ERROR, "no index at the end\n"); return ret; } end = get_packetheader(nut, bc, 1, INDEX_STARTCODE); end += avio_tell(bc); ffio_read_varlen(bc); GET_V(syncpoint_count, [[claiborne]] < INT_MAX / 8 && [[claiborne]] > 0); syncpoints = av_malloc(sizeof(int64_t) * syncpoint_count); [[advisory]] = av_malloc(sizeof(int8_t) * (syncpoint_count + 1)); if (!syncpoints || ![[advisory]]) return AVERROR(ENOMEM); for (i = 0; i < syncpoint_count; i++) { syncpoints[i] = ffio_read_varlen(bc); if (syncpoints[i] <= 0) goto fail; if (i) syncpoints[i] += syncpoints[i - 1]; } for (i = 0; i < s->nb_streams; i++) { int64_t last_pts = -1; for (j = 0; j < syncpoint_count;) { uint64_t x = ffio_read_varlen(bc); int type = x & 1; int n = j; x >>= 1; if (type) { int flag = x & 1; x >>= 1; if (n + x >= syncpoint_count + 1) { av_log(s, AV_LOG_ERROR, "index overflow A\n"); goto fail; } while (x--) [[advisory]][n++] = flag; [[advisory]][n++] = !flag; } else { while (x != 1) { if (n >= syncpoint_count + 1) { av_log(s, AV_LOG_ERROR, "index overflow B\n"); goto fail; } [[advisory]][n++] = x & 1; x >>= 1; } } if ([[advisory]][0]) { av_log(s, AV_LOG_ERROR, "keyframe before first syncpoint in index\n"); goto fail; } assert(n <= syncpoint_count + 1); for (; j < n && j < syncpoint_count; j++) { if ([[advisory]][j]) { uint64_t B, A = ffio_read_varlen(bc); if (!A) { A = ffio_read_varlen(bc); B = ffio_read_varlen(bc); } else B = 0; av_add_index_entry(s->streams[i], 16 * syncpoints[j - 1], last_pts + A, 0, 0, AVINDEX_KEYFRAME); last_pts += A + B; } } } } if (skip_reserved(bc, end) || ffio_get_checksum(bc)) { av_log(s, AV_LOG_ERROR, "index checksum mismatch\n"); goto fail; } ret = 0; fail: av_free(syncpoints); av_free([[advisory]]); return ret; }
--------------------------------------------- Result 1320 ---------------------------------------------
[[0 (61%)]] --> [[0 (37%)]] --> Socre: 0.6253962516784668

[[[[Adv]]]]: static inline void menelaus_rtc_stop(struct menelaus_s *[[s]]) { qemu_del_timer([[s]]->rtc.hz); [[s]]->rtc.next =- qemu_get_clock(rt_clock); if ([[s]]->rtc.next < 1) [[s]]->rtc.next = 1; }

[[[[Adv]]]]: static inline void menelaus_rtc_stop(struct menelaus_s *[[na]]) { qemu_del_timer([[na]]->rtc.hz); [[na]]->rtc.next =- qemu_get_clock(rt_clock); if ([[na]]->rtc.next < 1) [[na]]->rtc.next = 1; }
--------------------------------------------- Result 1321 ---------------------------------------------
[[0 (97%)]] --> [[0 (37%)]] --> Socre: 0.6334243416786194

[[[[Adv]]]]: int drive_init(struct drive_opt *arg, int snapshot, void *opaque) { char buf[128]; char file[1024]; char [[devname]][128]; char serial[21]; const char *mediastr = ""; BlockInterfaceType type; enum { MEDIA_DISK, MEDIA_CDROM } media; int bus_id, unit_id; int cyls, heads, secs, translation; BlockDriverState *bdrv; BlockDriver *drv = NULL; QEMUMachine *machine = opaque; int max_devs; int index; int cache; int bdrv_flags, onerror; int drives_table_idx; char *str = arg->opt; static const char * const [[params]][] = { "bus", "unit", "if", "index", "cyls", "heads", "secs", "trans", "media", "snapshot", "file", "cache", "format", "serial", "werror", NULL }; if (check_params([[params]], str) < 0) { fprintf(stderr, "qemu: unknown parameter '%s' in '%s'\n", buf, str); return -1; } file[0] = 0; cyls = heads = secs = 0; bus_id = 0; unit_id = -1; translation = BIOS_ATA_TRANSLATION_AUTO; index = -1; cache = 3; if (machine->use_scsi) { type = IF_SCSI; max_devs = MAX_SCSI_DEVS; pstrcpy([[devname]], sizeof([[devname]]), "scsi"); } else { type = IF_IDE; max_devs = MAX_IDE_DEVS; pstrcpy([[devname]], sizeof([[devname]]), "ide"); } media = MEDIA_DISK; if (get_param_value(buf, sizeof(buf), "bus", str)) { bus_id = strtol(buf, NULL, 0); if (bus_id < 0) { fprintf(stderr, "qemu: '%s' invalid bus id\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "unit", str)) { unit_id = strtol(buf, NULL, 0); if (unit_id < 0) { fprintf(stderr, "qemu: '%s' invalid unit id\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "if", str)) { pstrcpy([[devname]], sizeof([[devname]]), buf); if (!strcmp(buf, "ide")) { type = IF_IDE; max_devs = MAX_IDE_DEVS; } else if (!strcmp(buf, "scsi")) { type = IF_SCSI; max_devs = MAX_SCSI_DEVS; } else if (!strcmp(buf, "floppy")) { type = IF_FLOPPY; max_devs = 0; } else if (!strcmp(buf, "pflash")) { type = IF_PFLASH; max_devs = 0; } else if (!strcmp(buf, "mtd")) { type = IF_MTD; max_devs = 0; } else if (!strcmp(buf, "sd")) { type = IF_SD; max_devs = 0; } else if (!strcmp(buf, "virtio")) { type = IF_VIRTIO; max_devs = 0; } else if (!strcmp(buf, "xen")) { type = IF_XEN; max_devs = 0; } else { fprintf(stderr, "qemu: '%s' unsupported bus type '%s'\n", str, buf); return -1; } } if (get_param_value(buf, sizeof(buf), "index", str)) { index = strtol(buf, NULL, 0); if (index < 0) { fprintf(stderr, "qemu: '%s' invalid index\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "cyls", str)) { cyls = strtol(buf, NULL, 0); } if (get_param_value(buf, sizeof(buf), "heads", str)) { heads = strtol(buf, NULL, 0); } if (get_param_value(buf, sizeof(buf), "secs", str)) { secs = strtol(buf, NULL, 0); } if (cyls || heads || secs) { if (cyls < 1 || cyls > 16383) { fprintf(stderr, "qemu: '%s' invalid physical cyls number\n", str); return -1; } if (heads < 1 || heads > 16) { fprintf(stderr, "qemu: '%s' invalid physical heads number\n", str); return -1; } if (secs < 1 || secs > 63) { fprintf(stderr, "qemu: '%s' invalid physical secs number\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "trans", str)) { if (!cyls) { fprintf(stderr, "qemu: '%s' trans must be used with cyls,heads and secs\n", str); return -1; } if (!strcmp(buf, "none")) translation = BIOS_ATA_TRANSLATION_NONE; else if (!strcmp(buf, "lba")) translation = BIOS_ATA_TRANSLATION_LBA; else if (!strcmp(buf, "auto")) translation = BIOS_ATA_TRANSLATION_AUTO; else { fprintf(stderr, "qemu: '%s' invalid translation type\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "media", str)) { if (!strcmp(buf, "disk")) { media = MEDIA_DISK; } else if (!strcmp(buf, "cdrom")) { if (cyls || secs || heads) { fprintf(stderr, "qemu: '%s' invalid physical CHS format\n", str); return -1; } media = MEDIA_CDROM; } else { fprintf(stderr, "qemu: '%s' invalid media\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "snapshot", str)) { if (!strcmp(buf, "on")) snapshot = 1; else if (!strcmp(buf, "off")) snapshot = 0; else { fprintf(stderr, "qemu: '%s' invalid snapshot option\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "cache", str)) { if (!strcmp(buf, "off") || !strcmp(buf, "none")) cache = 0; else if (!strcmp(buf, "writethrough")) cache = 1; else if (!strcmp(buf, "writeback")) cache = 2; else { fprintf(stderr, "qemu: invalid cache option\n"); return -1; } } if (get_param_value(buf, sizeof(buf), "format", str)) { if (strcmp(buf, "?") == 0) { fprintf(stderr, "qemu: Supported formats:"); bdrv_iterate_format(bdrv_format_print, NULL); fprintf(stderr, "\n"); return -1; } drv = bdrv_find_format(buf); if (!drv) { fprintf(stderr, "qemu: '%s' invalid format\n", buf); return -1; } } if (arg->file == NULL) get_param_value(file, sizeof(file), "file", str); else pstrcpy(file, sizeof(file), arg->file); if (!get_param_value(serial, sizeof(serial), "serial", str)) memset(serial, 0, sizeof(serial)); onerror = BLOCK_ERR_STOP_ENOSPC; if (get_param_value(buf, sizeof(serial), "werror", str)) { if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) { fprintf(stderr, "werror is no supported by this format\n"); return -1; } if (!strcmp(buf, "ignore")) onerror = BLOCK_ERR_IGNORE; else if (!strcmp(buf, "enospc")) onerror = BLOCK_ERR_STOP_ENOSPC; else if (!strcmp(buf, "stop")) onerror = BLOCK_ERR_STOP_ANY; else if (!strcmp(buf, "report")) onerror = BLOCK_ERR_REPORT; else { fprintf(stderr, "qemu: '%s' invalid write error action\n", buf); return -1; } } if (index != -1) { if (bus_id != 0 || unit_id != -1) { fprintf(stderr, "qemu: '%s' index cannot be used with bus and unit\n", str); return -1; } if (max_devs == 0) { unit_id = index; bus_id = 0; } else { unit_id = index % max_devs; bus_id = index / max_devs; } } if (unit_id == -1) { unit_id = 0; while (drive_get_index(type, bus_id, unit_id) != -1) { unit_id++; if (max_devs && unit_id >= max_devs) { unit_id -= max_devs; bus_id++; } } } if (max_devs && unit_id >= max_devs) { fprintf(stderr, "qemu: '%s' unit %d too big (max is %d)\n", str, unit_id, max_devs - 1); return -1; } if (drive_get_index(type, bus_id, unit_id) != -1) return -2; if (type == IF_IDE || type == IF_SCSI) mediastr = (media == MEDIA_CDROM) ? "-cd" : "-hd"; if (max_devs) snprintf(buf, sizeof(buf), "%s%i%s%i", [[devname]], bus_id, mediastr, unit_id); else snprintf(buf, sizeof(buf), "%s%s%i", [[devname]], mediastr, unit_id); bdrv = bdrv_new(buf); drives_table_idx = drive_get_free_idx(); drives_table[drives_table_idx].bdrv = bdrv; drives_table[drives_table_idx].type = type; drives_table[drives_table_idx].bus = bus_id; drives_table[drives_table_idx].unit = unit_id; drives_table[drives_table_idx].onerror = onerror; drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt; strncpy(drives_table[drives_table_idx].serial, serial, sizeof(serial)); nb_drives++; switch(type) { case IF_IDE: case IF_SCSI: case IF_XEN: switch(media) { case MEDIA_DISK: if (cyls != 0) { bdrv_set_geometry_hint(bdrv, cyls, heads, secs); bdrv_set_translation_hint(bdrv, translation); } break; case MEDIA_CDROM: bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM); break; } break; case IF_SD: case IF_FLOPPY: bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY); break; case IF_PFLASH: case IF_MTD: case IF_VIRTIO: break; case IF_COUNT: abort(); } if (!file[0]) return -2; bdrv_flags = 0; if (snapshot) { bdrv_flags |= BDRV_O_SNAPSHOT; cache = 2; } if (cache == 0) bdrv_flags |= BDRV_O_NOCACHE; else if (cache == 2) bdrv_flags |= BDRV_O_CACHE_WB; else if (cache == 3) bdrv_flags |= BDRV_O_CACHE_DEF; if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) { fprintf(stderr, "qemu: could not open disk image %s\n", file); return -1; } if (bdrv_key_required(bdrv)) autostart = 0; return drives_table_idx; }

[[[[Adv]]]]: int drive_init(struct drive_opt *arg, int snapshot, void *opaque) { char buf[128]; char file[1024]; char [[mccomb]][128]; char serial[21]; const char *mediastr = ""; BlockInterfaceType type; enum { MEDIA_DISK, MEDIA_CDROM } media; int bus_id, unit_id; int cyls, heads, secs, translation; BlockDriverState *bdrv; BlockDriver *drv = NULL; QEMUMachine *machine = opaque; int max_devs; int index; int cache; int bdrv_flags, onerror; int drives_table_idx; char *str = arg->opt; static const char * const [[alexx]][] = { "bus", "unit", "if", "index", "cyls", "heads", "secs", "trans", "media", "snapshot", "file", "cache", "format", "serial", "werror", NULL }; if (check_params([[alexx]], str) < 0) { fprintf(stderr, "qemu: unknown parameter '%s' in '%s'\n", buf, str); return -1; } file[0] = 0; cyls = heads = secs = 0; bus_id = 0; unit_id = -1; translation = BIOS_ATA_TRANSLATION_AUTO; index = -1; cache = 3; if (machine->use_scsi) { type = IF_SCSI; max_devs = MAX_SCSI_DEVS; pstrcpy([[mccomb]], sizeof([[mccomb]]), "scsi"); } else { type = IF_IDE; max_devs = MAX_IDE_DEVS; pstrcpy([[mccomb]], sizeof([[mccomb]]), "ide"); } media = MEDIA_DISK; if (get_param_value(buf, sizeof(buf), "bus", str)) { bus_id = strtol(buf, NULL, 0); if (bus_id < 0) { fprintf(stderr, "qemu: '%s' invalid bus id\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "unit", str)) { unit_id = strtol(buf, NULL, 0); if (unit_id < 0) { fprintf(stderr, "qemu: '%s' invalid unit id\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "if", str)) { pstrcpy([[mccomb]], sizeof([[mccomb]]), buf); if (!strcmp(buf, "ide")) { type = IF_IDE; max_devs = MAX_IDE_DEVS; } else if (!strcmp(buf, "scsi")) { type = IF_SCSI; max_devs = MAX_SCSI_DEVS; } else if (!strcmp(buf, "floppy")) { type = IF_FLOPPY; max_devs = 0; } else if (!strcmp(buf, "pflash")) { type = IF_PFLASH; max_devs = 0; } else if (!strcmp(buf, "mtd")) { type = IF_MTD; max_devs = 0; } else if (!strcmp(buf, "sd")) { type = IF_SD; max_devs = 0; } else if (!strcmp(buf, "virtio")) { type = IF_VIRTIO; max_devs = 0; } else if (!strcmp(buf, "xen")) { type = IF_XEN; max_devs = 0; } else { fprintf(stderr, "qemu: '%s' unsupported bus type '%s'\n", str, buf); return -1; } } if (get_param_value(buf, sizeof(buf), "index", str)) { index = strtol(buf, NULL, 0); if (index < 0) { fprintf(stderr, "qemu: '%s' invalid index\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "cyls", str)) { cyls = strtol(buf, NULL, 0); } if (get_param_value(buf, sizeof(buf), "heads", str)) { heads = strtol(buf, NULL, 0); } if (get_param_value(buf, sizeof(buf), "secs", str)) { secs = strtol(buf, NULL, 0); } if (cyls || heads || secs) { if (cyls < 1 || cyls > 16383) { fprintf(stderr, "qemu: '%s' invalid physical cyls number\n", str); return -1; } if (heads < 1 || heads > 16) { fprintf(stderr, "qemu: '%s' invalid physical heads number\n", str); return -1; } if (secs < 1 || secs > 63) { fprintf(stderr, "qemu: '%s' invalid physical secs number\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "trans", str)) { if (!cyls) { fprintf(stderr, "qemu: '%s' trans must be used with cyls,heads and secs\n", str); return -1; } if (!strcmp(buf, "none")) translation = BIOS_ATA_TRANSLATION_NONE; else if (!strcmp(buf, "lba")) translation = BIOS_ATA_TRANSLATION_LBA; else if (!strcmp(buf, "auto")) translation = BIOS_ATA_TRANSLATION_AUTO; else { fprintf(stderr, "qemu: '%s' invalid translation type\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "media", str)) { if (!strcmp(buf, "disk")) { media = MEDIA_DISK; } else if (!strcmp(buf, "cdrom")) { if (cyls || secs || heads) { fprintf(stderr, "qemu: '%s' invalid physical CHS format\n", str); return -1; } media = MEDIA_CDROM; } else { fprintf(stderr, "qemu: '%s' invalid media\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "snapshot", str)) { if (!strcmp(buf, "on")) snapshot = 1; else if (!strcmp(buf, "off")) snapshot = 0; else { fprintf(stderr, "qemu: '%s' invalid snapshot option\n", str); return -1; } } if (get_param_value(buf, sizeof(buf), "cache", str)) { if (!strcmp(buf, "off") || !strcmp(buf, "none")) cache = 0; else if (!strcmp(buf, "writethrough")) cache = 1; else if (!strcmp(buf, "writeback")) cache = 2; else { fprintf(stderr, "qemu: invalid cache option\n"); return -1; } } if (get_param_value(buf, sizeof(buf), "format", str)) { if (strcmp(buf, "?") == 0) { fprintf(stderr, "qemu: Supported formats:"); bdrv_iterate_format(bdrv_format_print, NULL); fprintf(stderr, "\n"); return -1; } drv = bdrv_find_format(buf); if (!drv) { fprintf(stderr, "qemu: '%s' invalid format\n", buf); return -1; } } if (arg->file == NULL) get_param_value(file, sizeof(file), "file", str); else pstrcpy(file, sizeof(file), arg->file); if (!get_param_value(serial, sizeof(serial), "serial", str)) memset(serial, 0, sizeof(serial)); onerror = BLOCK_ERR_STOP_ENOSPC; if (get_param_value(buf, sizeof(serial), "werror", str)) { if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) { fprintf(stderr, "werror is no supported by this format\n"); return -1; } if (!strcmp(buf, "ignore")) onerror = BLOCK_ERR_IGNORE; else if (!strcmp(buf, "enospc")) onerror = BLOCK_ERR_STOP_ENOSPC; else if (!strcmp(buf, "stop")) onerror = BLOCK_ERR_STOP_ANY; else if (!strcmp(buf, "report")) onerror = BLOCK_ERR_REPORT; else { fprintf(stderr, "qemu: '%s' invalid write error action\n", buf); return -1; } } if (index != -1) { if (bus_id != 0 || unit_id != -1) { fprintf(stderr, "qemu: '%s' index cannot be used with bus and unit\n", str); return -1; } if (max_devs == 0) { unit_id = index; bus_id = 0; } else { unit_id = index % max_devs; bus_id = index / max_devs; } } if (unit_id == -1) { unit_id = 0; while (drive_get_index(type, bus_id, unit_id) != -1) { unit_id++; if (max_devs && unit_id >= max_devs) { unit_id -= max_devs; bus_id++; } } } if (max_devs && unit_id >= max_devs) { fprintf(stderr, "qemu: '%s' unit %d too big (max is %d)\n", str, unit_id, max_devs - 1); return -1; } if (drive_get_index(type, bus_id, unit_id) != -1) return -2; if (type == IF_IDE || type == IF_SCSI) mediastr = (media == MEDIA_CDROM) ? "-cd" : "-hd"; if (max_devs) snprintf(buf, sizeof(buf), "%s%i%s%i", [[mccomb]], bus_id, mediastr, unit_id); else snprintf(buf, sizeof(buf), "%s%s%i", [[mccomb]], mediastr, unit_id); bdrv = bdrv_new(buf); drives_table_idx = drive_get_free_idx(); drives_table[drives_table_idx].bdrv = bdrv; drives_table[drives_table_idx].type = type; drives_table[drives_table_idx].bus = bus_id; drives_table[drives_table_idx].unit = unit_id; drives_table[drives_table_idx].onerror = onerror; drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt; strncpy(drives_table[drives_table_idx].serial, serial, sizeof(serial)); nb_drives++; switch(type) { case IF_IDE: case IF_SCSI: case IF_XEN: switch(media) { case MEDIA_DISK: if (cyls != 0) { bdrv_set_geometry_hint(bdrv, cyls, heads, secs); bdrv_set_translation_hint(bdrv, translation); } break; case MEDIA_CDROM: bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM); break; } break; case IF_SD: case IF_FLOPPY: bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY); break; case IF_PFLASH: case IF_MTD: case IF_VIRTIO: break; case IF_COUNT: abort(); } if (!file[0]) return -2; bdrv_flags = 0; if (snapshot) { bdrv_flags |= BDRV_O_SNAPSHOT; cache = 2; } if (cache == 0) bdrv_flags |= BDRV_O_NOCACHE; else if (cache == 2) bdrv_flags |= BDRV_O_CACHE_WB; else if (cache == 3) bdrv_flags |= BDRV_O_CACHE_DEF; if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) { fprintf(stderr, "qemu: could not open disk image %s\n", file); return -1; } if (bdrv_key_required(bdrv)) autostart = 0; return drives_table_idx; }[Succeeded / Failed / Skipped / Total] 781 / 69 / 471 / 1321:  49%|     | 1321/2690 [14:39:27<15:11:24, 39.94s/it][Succeeded / Failed / Skipped / Total] 781 / 69 / 471 / 1321:  49%|     | 1322/2690 [14:39:27<15:10:03, 39.91s/it][Succeeded / Failed / Skipped / Total] 781 / 69 / 472 / 1322:  49%|     | 1322/2690 [14:39:27<15:10:03, 39.91s/it][Succeeded / Failed / Skipped / Total] 781 / 69 / 472 / 1322:  49%|     | 1323/2690 [14:40:34<15:09:51, 39.94s/it][Succeeded / Failed / Skipped / Total] 782 / 69 / 472 / 1323:  49%|     | 1323/2690 [14:40:34<15:09:51, 39.94s/it][Succeeded / Failed / Skipped / Total] 782 / 69 / 472 / 1323:  49%|     | 1324/2690 [14:40:38<15:08:34, 39.91s/it][Succeeded / Failed / Skipped / Total] 783 / 69 / 472 / 1324:  49%|     | 1324/2690 [14:40:38<15:08:34, 39.91s/it][Succeeded / Failed / Skipped / Total] 783 / 69 / 472 / 1324:  49%|     | 1325/2690 [14:40:38<15:07:13, 39.88s/it][Succeeded / Failed / Skipped / Total] 783 / 69 / 473 / 1325:  49%|     | 1325/2690 [14:40:38<15:07:13, 39.88s/it][Succeeded / Failed / Skipped / Total] 783 / 69 / 473 / 1325:  49%|     | 1326/2690 [14:40:49<15:06:04, 39.86s/it][Succeeded / Failed / Skipped / Total] 784 / 69 / 473 / 1326:  49%|     | 1326/2690 [14:40:49<15:06:04, 39.86s/it][Succeeded / Failed / Skipped / Total] 784 / 69 / 473 / 1326:  49%|     | 1327/2690 [14:44:58<15:08:58, 40.01s/it][Succeeded / Failed / Skipped / Total] 785 / 69 / 473 / 1327:  49%|     | 1327/2690 [14:44:58<15:08:58, 40.01s/it][Succeeded / Failed / Skipped / Total] 785 / 69 / 473 / 1327:  49%|     | 1328/2690 [14:44:58<15:07:38, 39.98s/it][Succeeded / Failed / Skipped / Total] 785 / 69 / 474 / 1328:  49%|     | 1328/2690 [14:44:58<15:07:38, 39.98s/it][Succeeded / Failed / Skipped / Total] 785 / 69 / 474 / 1328:  49%|     | 1329/2690 [14:45:29<15:06:49, 39.98s/it]
--------------------------------------------- Result 1322 ---------------------------------------------
[[0 (46%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void gic_complete_irq(gic_state * s, int cpu, int irq) { int update = 0; int cm = 1 << cpu; DPRINTF("EOI %d\n", irq); if (s->running_irq[cpu] == 1023) return; if (irq != 1023) { if (!GIC_TEST_TRIGGER(irq) && GIC_TEST_ENABLED(irq, cm) && GIC_TEST_LEVEL(irq, cm) && (GIC_TARGET(irq) & cm) != 0) { DPRINTF("Set %d pending mask %x\n", irq, cm); GIC_SET_PENDING(irq, cm); update = 1; } } if (irq != s->running_irq[cpu]) { int tmp = s->running_irq[cpu]; while (s->last_active[tmp][cpu] != 1023) { if (s->last_active[tmp][cpu] == irq) { s->last_active[tmp][cpu] = s->last_active[irq][cpu]; break; } tmp = s->last_active[tmp][cpu]; } if (update) { gic_update(s); } } else { gic_set_running_irq(s, cpu, s->last_active[s->running_irq[cpu]][cpu]); } }
--------------------------------------------- Result 1323 ---------------------------------------------
[[0 (8%)]] --> [[0 (58%)]] --> Socre: 0.5750154852867126

[[[[Adv]]]]: static void init_dequant8_coeff_table(H264Context *[[h]]){ int i,q,x; const int transpose = ([[h]]->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); [[h]]->dequant8_coeff[0] = [[h]]->dequant8_buffer[0]; [[h]]->dequant8_coeff[1] = [[h]]->dequant8_buffer[1]; for(i=0; i<2; i++ ){ if(i && !memcmp([[h]]->pps.scaling_matrix8[0], [[h]]->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){ [[h]]->dequant8_coeff[1] = [[h]]->dequant8_buffer[0]; break; } for(q=0; q<52; q++){ int shift = div6[q]; int idx = rem6[q]; for(x=0; x<64; x++) [[h]]->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] = ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] * [[h]]->pps.scaling_matrix8[i][x]) << shift; } } }

[[[[Adv]]]]: static void init_dequant8_coeff_table(H264Context *[[estates]]){ int i,q,x; const int transpose = ([[estates]]->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); [[estates]]->dequant8_coeff[0] = [[estates]]->dequant8_buffer[0]; [[estates]]->dequant8_coeff[1] = [[estates]]->dequant8_buffer[1]; for(i=0; i<2; i++ ){ if(i && !memcmp([[estates]]->pps.scaling_matrix8[0], [[estates]]->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){ [[estates]]->dequant8_coeff[1] = [[estates]]->dequant8_buffer[0]; break; } for(q=0; q<52; q++){ int shift = div6[q]; int idx = rem6[q]; for(x=0; x<64; x++) [[estates]]->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] = ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] * [[estates]]->pps.scaling_matrix8[i][x]) << shift; } } }
--------------------------------------------- Result 1324 ---------------------------------------------
[[0 (59%)]] --> [[0 (39%)]] --> Socre: 0.6065307557582855

[[[[Adv]]]]: char *vnc_display_local_addr(const char *[[id]]) { VncDisplay *vs = vnc_display_find([[id]]); return vnc_socket_local_addr("%s:%s", vs->lsock); }

[[[[Adv]]]]: char *vnc_display_local_addr(const char *[[manipulate]]) { VncDisplay *vs = vnc_display_find([[manipulate]]); return vnc_socket_local_addr("%s:%s", vs->lsock); }
--------------------------------------------- Result 1325 ---------------------------------------------
[[0 (6%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void test_validate_fail_struct_nested(TestInputVisitorData *data, const void *unused) { UserDefTwo *udp = NULL; Error *err = NULL; Visitor *v; v = validate_test_init(data, "{ 'string0': 'string0', 'dict1': { 'string1': 'string1', 'dict2': { 'userdef1': { 'integer': 42, 'string': 'string', 'extra': [42, 23, {'foo':'bar'}] }, 'string2': 'string2'}}}"); visit_type_UserDefTwo(v, NULL, &udp, &err); error_free_or_abort(&err); qapi_free_UserDefTwo(udp); }
--------------------------------------------- Result 1326 ---------------------------------------------
[[0 (61%)]] --> [[0 (47%)]] --> Socre: 0.5281670689582825

[[[[Adv]]]]: static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t [[pos]], int size) { QEMUFileSocket *[[s]] = opaque; ssize_t len; do { len = qemu_recv([[s]]->fd, buf, size, 0); } while (len == -1 && socket_error() == EINTR); if (len == -1) len = -socket_error(); return len; }

[[[[Adv]]]]: static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t [[pda]], int size) { QEMUFileSocket *[[into]] = opaque; ssize_t len; do { len = qemu_recv([[into]]->fd, buf, size, 0); } while (len == -1 && socket_error() == EINTR); if (len == -1) len = -socket_error(); return len; }
--------------------------------------------- Result 1327 ---------------------------------------------
[[0 (2%)]] --> [[0 (98%)]] --> Socre: 0.9836286306381226

[[[[Adv]]]]: void qemu_register_reset(QEMUResetHandler *[[func]], void *opaque) { QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry)); re->func = [[func]]; re->opaque = opaque; TAILQ_INSERT_TAIL(&reset_handlers, re, entry); }

[[[[Adv]]]]: void qemu_register_reset(QEMUResetHandler *[[n]], void *opaque) { QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry)); re->func = [[n]]; re->opaque = opaque; TAILQ_INSERT_TAIL(&reset_handlers, re, entry); }
--------------------------------------------- Result 1328 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_jni_exception_get_summary(JNIEnv *env, jthrowable exception, char **error, void *log_ctx) { int ret = 0; AVBPrint bp; char *name = NULL; char *message = NULL; jclass class_class = NULL; jmethodID get_name_id = NULL; jclass exception_class = NULL; jmethodID get_message_id = NULL; jstring string; av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC); exception_class = (*env)->GetObjectClass(env, exception); if ((*env)->ExceptionCheck(env)) { (*env)->ExceptionClear(env); av_log(log_ctx, AV_LOG_ERROR, "Could not find Throwable class\n"); ret = AVERROR_EXTERNAL; goto done; } class_class = (*env)->GetObjectClass(env, exception_class); if ((*env)->ExceptionCheck(env)) { (*env)->ExceptionClear(env); av_log(log_ctx, AV_LOG_ERROR, "Could not find Throwable class's class\n"); ret = AVERROR_EXTERNAL; goto done; } get_name_id = (*env)->GetMethodID(env, class_class, "getName", "()Ljava/lang/String;"); if ((*env)->ExceptionCheck(env)) { (*env)->ExceptionClear(env); av_log(log_ctx, AV_LOG_ERROR, "Could not find method Class.getName()\n"); ret = AVERROR_EXTERNAL; goto done; } string = (*env)->CallObjectMethod(env, exception_class, get_name_id); if ((*env)->ExceptionCheck(env)) { (*env)->ExceptionClear(env); av_log(log_ctx, AV_LOG_ERROR, "Class.getName() threw an exception\n"); ret = AVERROR_EXTERNAL; goto done; } if (string) { name = ff_jni_jstring_to_utf_chars(env, string, log_ctx); (*env)->DeleteLocalRef(env, string); string = NULL; } get_message_id = (*env)->GetMethodID(env, exception_class, "getMessage", "()Ljava/lang/String;"); if ((*env)->ExceptionCheck(env)) { (*env)->ExceptionClear(env); av_log(log_ctx, AV_LOG_ERROR, "Could not find method java/lang/Throwable.getMessage()\n"); ret = AVERROR_EXTERNAL; goto done; } string = (*env)->CallObjectMethod(env, exception, get_message_id); if ((*env)->ExceptionCheck(env)) { (*env)->ExceptionClear(env); av_log(log_ctx, AV_LOG_ERROR, "Throwable.getMessage() threw an exception\n"); ret = AVERROR_EXTERNAL; goto done; } if (string) { message = ff_jni_jstring_to_utf_chars(env, string, log_ctx); (*env)->DeleteLocalRef(env, string); string = NULL; } if (name && message) { av_bprintf(&bp, "%s: %s", name, message); } else if (name && !message) { av_bprintf(&bp, "%s occurred", name); } else if (!name && message) { av_bprintf(&bp, "Exception: %s", message); } else { av_log(log_ctx, AV_LOG_WARNING, "Could not retreive exception name and message\n"); av_bprintf(&bp, "Exception occurred"); } ret = av_bprint_finalize(&bp, error); done: av_free(name); av_free(message); if (class_class) { (*env)->DeleteLocalRef(env, class_class); } if (exception_class) { (*env)->DeleteLocalRef(env, exception_class); } if (string) { (*env)->DeleteLocalRef(env, string); } return ret; }
--------------------------------------------- Result 1329 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 786 / 69 / 474 / 1329:  49%|     | 1329/2690 [14:45:29<15:06:49, 39.98s/it][Succeeded / Failed / Skipped / Total] 786 / 69 / 474 / 1329:  49%|     | 1330/2690 [14:45:30<15:05:28, 39.95s/it][Succeeded / Failed / Skipped / Total] 786 / 69 / 475 / 1330:  49%|     | 1330/2690 [14:45:30<15:05:28, 39.95s/it][Succeeded / Failed / Skipped / Total] 786 / 69 / 475 / 1330:  49%|     | 1331/2690 [14:47:00<15:05:39, 39.99s/it][Succeeded / Failed / Skipped / Total] 786 / 70 / 475 / 1331:  49%|     | 1331/2690 [14:47:00<15:05:39, 39.99s/it][Succeeded / Failed / Skipped / Total] 786 / 70 / 475 / 1331:  50%|     | 1332/2690 [14:51:46<15:09:11, 40.17s/it][Succeeded / Failed / Skipped / Total] 787 / 70 / 475 / 1332:  50%|     | 1332/2690 [14:51:46<15:09:11, 40.17s/it][Succeeded / Failed / Skipped / Total] 787 / 70 / 475 / 1332:  50%|     | 1333/2690 [14:51:47<15:07:50, 40.14s/it][Succeeded / Failed / Skipped / Total] 787 / 70 / 476 / 1333:  50%|     | 1333/2690 [14:51:47<15:07:50, 40.14s/it][Succeeded / Failed / Skipped / Total] 787 / 70 / 476 / 1333:  50%|     | 1334/2690 [14:52:46<15:07:30, 40.15s/it][Succeeded / Failed / Skipped / Total] 787 / 71 / 476 / 1334:  50%|     | 1334/2690 [14:52:46<15:07:30, 40.15s/it][Succeeded / Failed / Skipped / Total] 787 / 71 / 476 / 1334:  50%|     | 1335/2690 [14:53:26<15:06:49, 40.15s/it][[0 (4%)]] --> [[0 (56%)]] --> Socre: 0.5617164373397827

[[[[Adv]]]]: static void compute_antialias_float(MPADecodeContext *s, GranuleDef *[[g]]) { float *[[ptr]]; int n, i; if ([[g]]->block_type == 2) { if (![[g]]->switch_point) return; n = 1; } else { n = SBLIMIT - 1; } [[ptr]] = [[g]]->sb_hybrid + 18; for(i = n;i > 0;i--) { float tmp0, tmp1; float *[[csa]] = &csa_table_float[0][0]; #define FLOAT_AA(j)\ tmp0= ptr[-1-j];\ tmp1= ptr[ j];\ ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\ ptr[ j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j]; FLOAT_AA(0) FLOAT_AA(1) FLOAT_AA(2) FLOAT_AA(3) FLOAT_AA(4) FLOAT_AA(5) FLOAT_AA(6) FLOAT_AA(7) [[ptr]] += 18; } }

[[[[Adv]]]]: static void compute_antialias_float(MPADecodeContext *s, GranuleDef *[[grandmother]]) { float *[[antivirus]]; int n, i; if ([[grandmother]]->block_type == 2) { if (![[grandmother]]->switch_point) return; n = 1; } else { n = SBLIMIT - 1; } [[antivirus]] = [[grandmother]]->sb_hybrid + 18; for(i = n;i > 0;i--) { float tmp0, tmp1; float *[[vico]] = &csa_table_float[0][0]; #define FLOAT_AA(j)\ tmp0= ptr[-1-j];\ tmp1= ptr[ j];\ ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\ ptr[ j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j]; FLOAT_AA(0) FLOAT_AA(1) FLOAT_AA(2) FLOAT_AA(3) FLOAT_AA(4) FLOAT_AA(5) FLOAT_AA(6) FLOAT_AA(7) [[antivirus]] += 18; } }
--------------------------------------------- Result 1330 ---------------------------------------------
[[0 (71%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void helper_store_sdr1(CPUPPCState *env, target_ulong val) { PowerPCCPU *cpu = ppc_env_get_cpu(env); if (!env->external_htab) { if (env->spr[SPR_SDR1] != val) { ppc_store_sdr1(env, val); tlb_flush(CPU(cpu)); } } }
--------------------------------------------- Result 1331 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len) { const unsigned char *s; unsigned char *d; unsigned char *d_end; unsigned char queue[QUEUE_SIZE]; unsigned int qpos; unsigned int dataleft; unsigned int chainofs; unsigned int chainlen; unsigned int speclen; unsigned char tag; unsigned int i, j; s = src; d = dest; d_end = d + dest_len; dataleft = AV_RL32(s); s += 4; memset(queue, 0x20, QUEUE_SIZE); if (AV_RL32(s) == 0x56781234) { s += 4; qpos = 0x111; speclen = 0xF + 3; } else { qpos = 0xFEE; speclen = 100; } while (dataleft > 0) { tag = *s++; if ((tag == 0xFF) && (dataleft > 8)) { if (d + 8 > d_end) return; for (i = 0; i < 8; i++) { queue[qpos++] = *d++ = *s++; qpos &= QUEUE_MASK; } dataleft -= 8; } else { for (i = 0; i < 8; i++) { if (dataleft == 0) break; if (tag & 0x01) { if (d + 1 > d_end) return; queue[qpos++] = *d++ = *s++; qpos &= QUEUE_MASK; dataleft--; } else { chainofs = *s++; chainofs |= ((*s & 0xF0) << 4); chainlen = (*s++ & 0x0F) + 3; if (chainlen == speclen) chainlen = *s++ + 0xF + 3; if (d + chainlen > d_end) return; for (j = 0; j < chainlen; j++) { *d = queue[chainofs++ & QUEUE_MASK]; queue[qpos++] = *d++; qpos &= QUEUE_MASK; } dataleft -= chainlen; } tag >>= 1; } } } }

[[[[Adv]]]]: static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len) { const unsigned char *s; unsigned char *d; unsigned char *d_end; unsigned char queue[QUEUE_SIZE]; unsigned int qpos; unsigned int dataleft; unsigned int chainofs; unsigned int chainlen; unsigned int speclen; unsigned char tag; unsigned int i, j; s = src; d = dest; d_end = d + dest_len; dataleft = AV_RL32(s); s += 4; memset(queue, 0x20, QUEUE_SIZE); if (AV_RL32(s) == 0x56781234) { s += 4; qpos = 0x111; speclen = 0xF + 3; } else { qpos = 0xFEE; speclen = 100; } while (dataleft > 0) { tag = *s++; if ((tag == 0xFF) && (dataleft > 8)) { if (d + 8 > d_end) return; for (i = 0; i < 8; i++) { queue[qpos++] = *d++ = *s++; qpos &= QUEUE_MASK; } dataleft -= 8; } else { for (i = 0; i < 8; i++) { if (dataleft == 0) break; if (tag & 0x01) { if (d + 1 > d_end) return; queue[qpos++] = *d++ = *s++; qpos &= QUEUE_MASK; dataleft--; } else { chainofs = *s++; chainofs |= ((*s & 0xF0) << 4); chainlen = (*s++ & 0x0F) + 3; if (chainlen == speclen) chainlen = *s++ + 0xF + 3; if (d + chainlen > d_end) return; for (j = 0; j < chainlen; j++) { *d = queue[chainofs++ & QUEUE_MASK]; queue[qpos++] = *d++; qpos &= QUEUE_MASK; } dataleft -= chainlen; } tag >>= 1; } } } }
--------------------------------------------- Result 1332 ---------------------------------------------
[[0 (4%)]] --> [[0 (51%)]] --> Socre: 0.5124287605285645

[[[[Adv]]]]: sPAPRTCETable *spapr_tce_new_table(DeviceState *[[owner]], uint32_t [[liobn]], uint64_t bus_offset, uint32_t page_shift, uint32_t nb_table, bool vfio_accel) { sPAPRTCETable *tcet; char tmp[64]; if (spapr_tce_find_by_liobn([[liobn]])) { fprintf(stderr, "Attempted to create TCE table with duplicate" " LIOBN 0x%x\n", [[liobn]]); return NULL; } if (!nb_table) { return NULL; } tcet = SPAPR_TCE_TABLE(object_new(TYPE_SPAPR_TCE_TABLE)); tcet->liobn = [[liobn]]; tcet->bus_offset = bus_offset; tcet->page_shift = page_shift; tcet->nb_table = nb_table; tcet->vfio_accel = vfio_accel; snprintf(tmp, sizeof(tmp), "tce-table-%x", [[liobn]]); object_property_add_child(OBJECT([[owner]]), tmp, OBJECT(tcet), NULL); object_property_set_bool(OBJECT(tcet), "True" == "True", "realized", NULL); return tcet; }

[[[[Adv]]]]: sPAPRTCETable *spapr_tce_new_table(DeviceState *[[landlord]], uint32_t [[at]], uint64_t bus_offset, uint32_t page_shift, uint32_t nb_table, bool vfio_accel) { sPAPRTCETable *tcet; char tmp[64]; if (spapr_tce_find_by_liobn([[at]])) { fprintf(stderr, "Attempted to create TCE table with duplicate" " LIOBN 0x%x\n", [[at]]); return NULL; } if (!nb_table) { return NULL; } tcet = SPAPR_TCE_TABLE(object_new(TYPE_SPAPR_TCE_TABLE)); tcet->liobn = [[at]]; tcet->bus_offset = bus_offset; tcet->page_shift = page_shift; tcet->nb_table = nb_table; tcet->vfio_accel = vfio_accel; snprintf(tmp, sizeof(tmp), "tce-table-%x", [[at]]); object_property_add_child(OBJECT([[landlord]]), tmp, OBJECT(tcet), NULL); object_property_set_bool(OBJECT(tcet), "True" == "True", "realized", NULL); return tcet; }
--------------------------------------------- Result 1333 ---------------------------------------------
[[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void debug_print_fis(uint8_t *fis, int cmd_len) { #ifdef DEBUG_AHCI int i; fprintf(stderr, "fis:"); for (i = 0; i < cmd_len; i++) { if ((i & 0xf) == 0) { fprintf(stderr, "\n%02x:",i); } fprintf(stderr, "%02x ",fis[i]); } fprintf(stderr, "\n"); #endif }
--------------------------------------------- Result 1334 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void test_visitor_in_native_list_int32(TestInputVisitorData *data, const void *unused) { test_native_list_integer_helper(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_S32); }

[[[[Adv]]]]: static void test_visitor_in_native_list_int32(TestInputVisitorData *data, const void *unused) { test_native_list_integer_helper(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_S32); }
--------------------------------------------- Result 1335 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 788 / 71 / 476 / 1335:  50%|     | 1335/2690 [14:53:26<15:06:49, 40.15s/it][Succeeded / Failed / Skipped / Total] 788 / 71 / 476 / 1335:  50%|     | 1336/2690 [14:53:26<15:05:28, 40.12s/it][Succeeded / Failed / Skipped / Total] 788 / 71 / 477 / 1336:  50%|     | 1336/2690 [14:53:26<15:05:28, 40.12s/it][Succeeded / Failed / Skipped / Total] 788 / 71 / 477 / 1336:  50%|     | 1337/2690 [14:53:32<15:04:13, 40.10s/it][[0 (10%)]] --> [[0 (81%)]] --> Socre: 0.8103625178337097

[[[[Adv]]]]: static void sm501_disp_ctrl_write(void *[[opaque]], hwaddr [[addr]], uint64_t [[value]], unsigned [[size]]) { SM501State *[[s]] = (SM501State *)[[opaque]]; SM501_DPRINTF("sm501 disp ctrl regs : write addr=%x, val=%x\n", (unsigned)[[addr]], (unsigned)[[value]]); switch ([[addr]]) { case SM501_DC_PANEL_CONTROL: [[s]]->dc_panel_control = [[value]] & 0x0FFF73FF; break; case SM501_DC_PANEL_PANNING_CONTROL: [[s]]->dc_panel_panning_control = [[value]] & 0xFF3FFF3F; break; case SM501_DC_PANEL_FB_ADDR: [[s]]->dc_panel_fb_addr = [[value]] & 0x8FFFFFF0; break; case SM501_DC_PANEL_FB_OFFSET: [[s]]->dc_panel_fb_offset = [[value]] & 0x3FF03FF0; break; case SM501_DC_PANEL_FB_WIDTH: [[s]]->dc_panel_fb_width = [[value]] & 0x0FFF0FFF; break; case SM501_DC_PANEL_FB_HEIGHT: [[s]]->dc_panel_fb_height = [[value]] & 0x0FFF0FFF; break; case SM501_DC_PANEL_TL_LOC: [[s]]->dc_panel_tl_location = [[value]] & 0x07FF07FF; break; case SM501_DC_PANEL_BR_LOC: [[s]]->dc_panel_br_location = [[value]] & 0x07FF07FF; break; case SM501_DC_PANEL_H_TOT: [[s]]->dc_panel_h_total = [[value]] & 0x0FFF0FFF; break; case SM501_DC_PANEL_H_SYNC: [[s]]->dc_panel_h_sync = [[value]] & 0x00FF0FFF; break; case SM501_DC_PANEL_V_TOT: [[s]]->dc_panel_v_total = [[value]] & 0x0FFF0FFF; break; case SM501_DC_PANEL_V_SYNC: [[s]]->dc_panel_v_sync = [[value]] & 0x003F0FFF; break; case SM501_DC_PANEL_HWC_ADDR: [[s]]->dc_panel_hwc_addr = [[value]] & 0x8FFFFFF0; break; case SM501_DC_PANEL_HWC_LOC: [[s]]->dc_panel_hwc_location = [[value]] & 0x0FFF0FFF; break; case SM501_DC_PANEL_HWC_COLOR_1_2: [[s]]->dc_panel_hwc_color_1_2 = [[value]]; break; case SM501_DC_PANEL_HWC_COLOR_3: [[s]]->dc_panel_hwc_color_3 = [[value]] & 0x0000FFFF; break; case SM501_DC_CRT_CONTROL: [[s]]->dc_crt_control = [[value]] & 0x0003FFFF; break; case SM501_DC_CRT_FB_ADDR: [[s]]->dc_crt_fb_addr = [[value]] & 0x8FFFFFF0; break; case SM501_DC_CRT_FB_OFFSET: [[s]]->dc_crt_fb_offset = [[value]] & 0x3FF03FF0; break; case SM501_DC_CRT_H_TOT: [[s]]->dc_crt_h_total = [[value]] & 0x0FFF0FFF; break; case SM501_DC_CRT_H_SYNC: [[s]]->dc_crt_h_sync = [[value]] & 0x00FF0FFF; break; case SM501_DC_CRT_V_TOT: [[s]]->dc_crt_v_total = [[value]] & 0x0FFF0FFF; break; case SM501_DC_CRT_V_SYNC: [[s]]->dc_crt_v_sync = [[value]] & 0x003F0FFF; break; case SM501_DC_CRT_HWC_ADDR: [[s]]->dc_crt_hwc_addr = [[value]] & 0x8FFFFFF0; break; case SM501_DC_CRT_HWC_LOC: [[s]]->dc_crt_hwc_location = [[value]] & 0x0FFF0FFF; break; case SM501_DC_CRT_HWC_COLOR_1_2: [[s]]->dc_crt_hwc_color_1_2 = [[value]]; break; case SM501_DC_CRT_HWC_COLOR_3: [[s]]->dc_crt_hwc_color_3 = [[value]] & 0x0000FFFF; break; case SM501_DC_PANEL_PALETTE ... SM501_DC_PANEL_PALETTE + 0x400 * 3 - 4: sm501_palette_write([[opaque]], [[addr]] - SM501_DC_PANEL_PALETTE, [[value]]); break; default: printf("sm501 disp ctrl : not implemented register write." " addr=%x, val=%x\n", (int)[[addr]], (unsigned)[[value]]); abort(); } }

[[[[Adv]]]]: static void sm501_disp_ctrl_write(void *[[confusing]], hwaddr [[corazn]], uint64_t [[magnitude]], unsigned [[greatness]]) { SM501State *[[und]] = (SM501State *)[[confusing]]; SM501_DPRINTF("sm501 disp ctrl regs : write addr=%x, val=%x\n", (unsigned)[[corazn]], (unsigned)[[magnitude]]); switch ([[corazn]]) { case SM501_DC_PANEL_CONTROL: [[und]]->dc_panel_control = [[magnitude]] & 0x0FFF73FF; break; case SM501_DC_PANEL_PANNING_CONTROL: [[und]]->dc_panel_panning_control = [[magnitude]] & 0xFF3FFF3F; break; case SM501_DC_PANEL_FB_ADDR: [[und]]->dc_panel_fb_addr = [[magnitude]] & 0x8FFFFFF0; break; case SM501_DC_PANEL_FB_OFFSET: [[und]]->dc_panel_fb_offset = [[magnitude]] & 0x3FF03FF0; break; case SM501_DC_PANEL_FB_WIDTH: [[und]]->dc_panel_fb_width = [[magnitude]] & 0x0FFF0FFF; break; case SM501_DC_PANEL_FB_HEIGHT: [[und]]->dc_panel_fb_height = [[magnitude]] & 0x0FFF0FFF; break; case SM501_DC_PANEL_TL_LOC: [[und]]->dc_panel_tl_location = [[magnitude]] & 0x07FF07FF; break; case SM501_DC_PANEL_BR_LOC: [[und]]->dc_panel_br_location = [[magnitude]] & 0x07FF07FF; break; case SM501_DC_PANEL_H_TOT: [[und]]->dc_panel_h_total = [[magnitude]] & 0x0FFF0FFF; break; case SM501_DC_PANEL_H_SYNC: [[und]]->dc_panel_h_sync = [[magnitude]] & 0x00FF0FFF; break; case SM501_DC_PANEL_V_TOT: [[und]]->dc_panel_v_total = [[magnitude]] & 0x0FFF0FFF; break; case SM501_DC_PANEL_V_SYNC: [[und]]->dc_panel_v_sync = [[magnitude]] & 0x003F0FFF; break; case SM501_DC_PANEL_HWC_ADDR: [[und]]->dc_panel_hwc_addr = [[magnitude]] & 0x8FFFFFF0; break; case SM501_DC_PANEL_HWC_LOC: [[und]]->dc_panel_hwc_location = [[magnitude]] & 0x0FFF0FFF; break; case SM501_DC_PANEL_HWC_COLOR_1_2: [[und]]->dc_panel_hwc_color_1_2 = [[magnitude]]; break; case SM501_DC_PANEL_HWC_COLOR_3: [[und]]->dc_panel_hwc_color_3 = [[magnitude]] & 0x0000FFFF; break; case SM501_DC_CRT_CONTROL: [[und]]->dc_crt_control = [[magnitude]] & 0x0003FFFF; break; case SM501_DC_CRT_FB_ADDR: [[und]]->dc_crt_fb_addr = [[magnitude]] & 0x8FFFFFF0; break; case SM501_DC_CRT_FB_OFFSET: [[und]]->dc_crt_fb_offset = [[magnitude]] & 0x3FF03FF0; break; case SM501_DC_CRT_H_TOT: [[und]]->dc_crt_h_total = [[magnitude]] & 0x0FFF0FFF; break; case SM501_DC_CRT_H_SYNC: [[und]]->dc_crt_h_sync = [[magnitude]] & 0x00FF0FFF; break; case SM501_DC_CRT_V_TOT: [[und]]->dc_crt_v_total = [[magnitude]] & 0x0FFF0FFF; break; case SM501_DC_CRT_V_SYNC: [[und]]->dc_crt_v_sync = [[magnitude]] & 0x003F0FFF; break; case SM501_DC_CRT_HWC_ADDR: [[und]]->dc_crt_hwc_addr = [[magnitude]] & 0x8FFFFFF0; break; case SM501_DC_CRT_HWC_LOC: [[und]]->dc_crt_hwc_location = [[magnitude]] & 0x0FFF0FFF; break; case SM501_DC_CRT_HWC_COLOR_1_2: [[und]]->dc_crt_hwc_color_1_2 = [[magnitude]]; break; case SM501_DC_CRT_HWC_COLOR_3: [[und]]->dc_crt_hwc_color_3 = [[magnitude]] & 0x0000FFFF; break; case SM501_DC_PANEL_PALETTE ... SM501_DC_PANEL_PALETTE + 0x400 * 3 - 4: sm501_palette_write([[confusing]], [[corazn]] - SM501_DC_PANEL_PALETTE, [[magnitude]]); break; default: printf("sm501 disp ctrl : not implemented register write." " addr=%x, val=%x\n", (int)[[corazn]], (unsigned)[[magnitude]]); abort(); } }
--------------------------------------------- Result 1336 ---------------------------------------------
[[0 (97%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void rgb15to16(const uint8_t *src,uint8_t *dst,uint32_t src_size) { #ifdef HAVE_MMX register const char* s=src+src_size; register char* d=dst+src_size; register int offs=-src_size; __asm __volatile(PREFETCH" %0"::"m"(*(s+offs)):"memory"); __asm __volatile( "movq %0, %%mm4\n\t" "movq %1, %%mm5" ::"m"(mask15b), "m"(mask15rg):"memory"); while(offs<0) { __asm __volatile( PREFETCH" 32%1\n\t" "movq %1, %%mm0\n\t" "movq 8%1, %%mm2\n\t" "movq %%mm0, %%mm1\n\t" "movq %%mm2, %%mm3\n\t" "pand %%mm4, %%mm0\n\t" "pand %%mm5, %%mm1\n\t" "pand %%mm4, %%mm2\n\t" "pand %%mm5, %%mm3\n\t" "psllq $1, %%mm1\n\t" "psllq $1, %%mm3\n\t" "por %%mm1, %%mm0\n\t" "por %%mm3, %%mm2\n\t" MOVNTQ" %%mm0, %0\n\t" MOVNTQ" %%mm2, 8%0" :"=m"(*(d+offs)) :"m"(*(s+offs)) :"memory"); offs+=16; } __asm __volatile(SFENCE:::"memory"); __asm __volatile(EMMS:::"memory"); #else const uint16_t *s1=( uint16_t * )src; uint16_t *d1=( uint16_t * )dst; uint16_t *e=((uint8_t *)s1)+src_size; while( s1<e ){ register int x=*( s1++ ); *( d1++ )=( x&0x001F )|( ( x&0x7FE0 )<<1 ); } #endif }
--------------------------------------------- Result 1337 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 789 / 71 / 477 / 1337:  50%|     | 1337/2690 [14:53:32<15:04:13, 40.10s/it][Succeeded / Failed / Skipped / Total] 789 / 71 / 477 / 1337:  50%|     | 1338/2690 [14:55:07<15:04:29, 40.14s/it][Succeeded / Failed / Skipped / Total] 789 / 72 / 477 / 1338:  50%|     | 1338/2690 [14:55:07<15:04:29, 40.14s/it][Succeeded / Failed / Skipped / Total] 789 / 72 / 477 / 1338:  50%|     | 1339/2690 [14:55:07<15:03:09, 40.11s/it][Succeeded / Failed / Skipped / Total] 789 / 72 / 478 / 1339:  50%|     | 1339/2690 [14:55:07<15:03:09, 40.11s/it][Succeeded / Failed / Skipped / Total] 789 / 72 / 478 / 1339:  50%|     | 1340/2690 [14:55:08<15:01:49, 40.08s/it][Succeeded / Failed / Skipped / Total] 789 / 72 / 479 / 1340:  50%|     | 1340/2690 [14:55:08<15:01:49, 40.08s/it][Succeeded / Failed / Skipped / Total] 789 / 72 / 479 / 1340:  50%|     | 1341/2690 [14:55:08<15:00:29, 40.05s/it][Succeeded / Failed / Skipped / Total] 789 / 72 / 480 / 1341:  50%|     | 1341/2690 [14:55:08<15:00:29, 40.05s/it][Succeeded / Failed / Skipped / Total] 789 / 72 / 480 / 1341:  50%|     | 1342/2690 [14:58:16<15:02:17, 40.16s/it][[0 (69%)]] --> [[0 (32%)]] --> Socre: 0.6803211271762848

[[[[Adv]]]]: static int rle_unpack(const unsigned char *src, unsigned char *[[dest]], int src_len, int [[dest_len]]) { const unsigned char *ps; unsigned char *pd; int i, l; unsigned char *dest_end = [[dest]] + [[dest_len]]; ps = src; pd = [[dest]]; if (src_len & 1) *pd++ = *ps++; src_len >>= 1; i = 0; do { l = *ps++; if (l & 0x80) { l = (l & 0x7F) * 2; if (pd + l > dest_end) return ps - src; memcpy(pd, ps, l); ps += l; pd += l; } else { if (pd + i > dest_end) return ps - src; for (i = 0; i < l; i++) { *pd++ = ps[0]; *pd++ = ps[1]; } ps += 2; } i += l; } while (i < src_len); return ps - src; }

[[[[Adv]]]]: static int rle_unpack(const unsigned char *src, unsigned char *[[sedan]], int src_len, int [[peasy]]) { const unsigned char *ps; unsigned char *pd; int i, l; unsigned char *dest_end = [[sedan]] + [[peasy]]; ps = src; pd = [[sedan]]; if (src_len & 1) *pd++ = *ps++; src_len >>= 1; i = 0; do { l = *ps++; if (l & 0x80) { l = (l & 0x7F) * 2; if (pd + l > dest_end) return ps - src; memcpy(pd, ps, l); ps += l; pd += l; } else { if (pd + i > dest_end) return ps - src; for (i = 0; i < l; i++) { *pd++ = ps[0]; *pd++ = ps[1]; } ps += 2; } i += l; } while (i < src_len); return ps - src; }
--------------------------------------------- Result 1338 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int load_ipmovie_packet(IPMVEContext *s, AVIOContext *pb, AVPacket *pkt) { int chunk_type; if (s->audio_chunk_offset) { if (s->audio_type != CODEC_ID_INTERPLAY_DPCM) { s->audio_chunk_offset += 6; s->audio_chunk_size -= 6; avio_seek(pb, s->audio_chunk_offset, SEEK_SET); s->audio_chunk_offset = 0; if (s->audio_chunk_size != av_get_packet(pb, pkt, s->audio_chunk_size)) return CHUNK_EOF; pkt->stream_index = s->audio_stream_index; pkt->pts = s->audio_frame_count; if (s->audio_type != CODEC_ID_INTERPLAY_DPCM) s->audio_frame_count += (s->audio_chunk_size / s->audio_channels / (s->audio_bits / 8)); else s->audio_frame_count += (s->audio_chunk_size - 6) / s->audio_channels; av_dlog(NULL, "sending audio frame with pts %"PRId64" (%d audio frames)\n", pkt->pts, s->audio_frame_count); chunk_type = CHUNK_VIDEO; } else if (s->decode_map_chunk_offset) { if (av_new_packet(pkt, s->decode_map_chunk_size + s->video_chunk_size)) return CHUNK_NOMEM; if (s->has_palette) { uint8_t *pal; pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE); if (pal) { memcpy(pal, s->palette, AVPALETTE_SIZE); s->has_palette = 0; pkt->pos= s->decode_map_chunk_offset; avio_seek(pb, s->decode_map_chunk_offset, SEEK_SET); s->decode_map_chunk_offset = 0; if (avio_read(pb, pkt->data, s->decode_map_chunk_size) != s->decode_map_chunk_size) { av_free_packet(pkt); return CHUNK_EOF; avio_seek(pb, s->video_chunk_offset, SEEK_SET); s->video_chunk_offset = 0; if (avio_read(pb, pkt->data + s->decode_map_chunk_size, s->video_chunk_size) != s->video_chunk_size) { av_free_packet(pkt); return CHUNK_EOF; pkt->stream_index = s->video_stream_index; pkt->pts = s->video_pts; av_dlog(NULL, "sending video frame with pts %"PRId64"\n", pkt->pts); s->video_pts += s->frame_pts_inc; chunk_type = CHUNK_VIDEO; } else { avio_seek(pb, s->next_chunk_offset, SEEK_SET); chunk_type = CHUNK_DONE; return chunk_type;

[[[[Adv]]]]: static int load_ipmovie_packet(IPMVEContext *s, AVIOContext *pb, AVPacket *pkt) { int chunk_type; if (s->audio_chunk_offset) { if (s->audio_type != CODEC_ID_INTERPLAY_DPCM) { s->audio_chunk_offset += 6; s->audio_chunk_size -= 6; avio_seek(pb, s->audio_chunk_offset, SEEK_SET); s->audio_chunk_offset = 0; if (s->audio_chunk_size != av_get_packet(pb, pkt, s->audio_chunk_size)) return CHUNK_EOF; pkt->stream_index = s->audio_stream_index; pkt->pts = s->audio_frame_count; if (s->audio_type != CODEC_ID_INTERPLAY_DPCM) s->audio_frame_count += (s->audio_chunk_size / s->audio_channels / (s->audio_bits / 8)); else s->audio_frame_count += (s->audio_chunk_size - 6) / s->audio_channels; av_dlog(NULL, "sending audio frame with pts %"PRId64" (%d audio frames)\n", pkt->pts, s->audio_frame_count); chunk_type = CHUNK_VIDEO; } else if (s->decode_map_chunk_offset) { if (av_new_packet(pkt, s->decode_map_chunk_size + s->video_chunk_size)) return CHUNK_NOMEM; if (s->has_palette) { uint8_t *pal; pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE); if (pal) { memcpy(pal, s->palette, AVPALETTE_SIZE); s->has_palette = 0; pkt->pos= s->decode_map_chunk_offset; avio_seek(pb, s->decode_map_chunk_offset, SEEK_SET); s->decode_map_chunk_offset = 0; if (avio_read(pb, pkt->data, s->decode_map_chunk_size) != s->decode_map_chunk_size) { av_free_packet(pkt); return CHUNK_EOF; avio_seek(pb, s->video_chunk_offset, SEEK_SET); s->video_chunk_offset = 0; if (avio_read(pb, pkt->data + s->decode_map_chunk_size, s->video_chunk_size) != s->video_chunk_size) { av_free_packet(pkt); return CHUNK_EOF; pkt->stream_index = s->video_stream_index; pkt->pts = s->video_pts; av_dlog(NULL, "sending video frame with pts %"PRId64"\n", pkt->pts); s->video_pts += s->frame_pts_inc; chunk_type = CHUNK_VIDEO; } else { avio_seek(pb, s->next_chunk_offset, SEEK_SET); chunk_type = CHUNK_DONE; return chunk_type;
--------------------------------------------- Result 1339 ---------------------------------------------
[[0 (47%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vorbis_parse(AVCodecParserContext *s1, AVCodecContext *avctx, const uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size) { VorbisParseContext *s = s1->priv_data; int duration; if (!s->vp && avctx->extradata && avctx->extradata_size) { s->vp = av_vorbis_parse_init(avctx->extradata, avctx->extradata_size); if (!s->vp) goto end; } if ((duration = av_vorbis_parse_frame(s->vp, buf, buf_size)) >= 0) s1->duration = duration; end: *poutbuf = buf; *poutbuf_size = buf_size; return buf_size; }
--------------------------------------------- Result 1340 ---------------------------------------------
[[0 (18%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void xen_ram_init(PCMachineState *pcms, ram_addr_t ram_size, MemoryRegion **ram_memory_p) { MemoryRegion *sysmem = get_system_memory(); ram_addr_t block_len; uint64_t user_lowmem = object_property_get_int(qdev_get_machine(), PC_MACHINE_MAX_RAM_BELOW_4G, &error_abort); if (HVM_BELOW_4G_RAM_END <= user_lowmem) { user_lowmem = HVM_BELOW_4G_RAM_END; } if (ram_size >= user_lowmem) { pcms->above_4g_mem_size = ram_size - user_lowmem; pcms->below_4g_mem_size = user_lowmem; } else { pcms->above_4g_mem_size = 0; pcms->below_4g_mem_size = ram_size; } if (!pcms->above_4g_mem_size) { block_len = ram_size; } else { block_len = (1ULL << 32) + pcms->above_4g_mem_size; } memory_region_init_ram(&ram_memory, NULL, "xen.ram", block_len, &error_abort); *ram_memory_p = &ram_memory; vmstate_register_ram_global(&ram_memory); memory_region_init_alias(&ram_640k, NULL, "xen.ram.640k", &ram_memory, 0, 0xa0000); memory_region_add_subregion(sysmem, 0, &ram_640k); memory_region_init_alias(&ram_lo, NULL, "xen.ram.lo", &ram_memory, 0xc0000, pcms->below_4g_mem_size - 0xc0000); memory_region_add_subregion(sysmem, 0xc0000, &ram_lo); if (pcms->above_4g_mem_size > 0) { memory_region_init_alias(&ram_hi, NULL, "xen.ram.hi", &ram_memory, 0x100000000ULL, pcms->above_4g_mem_size); memory_region_add_subregion(sysmem, 0x100000000ULL, &ram_hi); } }
--------------------------------------------- Result 1341 ---------------------------------------------
[[0 (2%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void pci_spapr_set_irq(void *opaque, int irq_num, int level) { sPAPRPHBState *phb = opaque; trace_spapr_pci_lsi_set(phb->busname, irq_num, phb->lsi_table[irq_num].irq); qemu_set_irq(spapr_phb_lsi_qirq(phb, irq_num), level); }
--------------------------------------------- Result 1342 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 790 / 72 / 480 / 1342:  50%|     | 1342/2690 [14:58:16<15:02:17, 40.16s/it][Succeeded / Failed / Skipped / Total] 790 / 72 / 480 / 1342:  50%|     | 1343/2690 [14:58:20<15:01:01, 40.13s/it][Succeeded / Failed / Skipped / Total] 791 / 72 / 480 / 1343:  50%|     | 1343/2690 [14:58:20<15:01:01, 40.13s/it][Succeeded / Failed / Skipped / Total] 791 / 72 / 480 / 1343:  50%|     | 1344/2690 [14:58:21<14:59:41, 40.10s/it][Succeeded / Failed / Skipped / Total] 791 / 72 / 481 / 1344:  50%|     | 1344/2690 [14:58:21<14:59:41, 40.10s/it][Succeeded / Failed / Skipped / Total] 791 / 72 / 481 / 1344:  50%|     | 1345/2690 [14:58:27<14:58:27, 40.08s/it][Succeeded / Failed / Skipped / Total] 792 / 72 / 481 / 1345:  50%|     | 1345/2690 [14:58:27<14:58:27, 40.08s/it][Succeeded / Failed / Skipped / Total] 792 / 72 / 481 / 1345:  50%|     | 1346/2690 [14:58:40<14:57:19, 40.06s/it][[0 (1%)]] --> [[0 (96%)]] --> Socre: 0.9587361812591553

[[[[Adv]]]]: void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *[[src]], ptrdiff_t stride) { avc_luma_hv_qrt_and_aver_dst_16x16_msa([[src]] + stride - 2, [[src]] - (stride * 2) + sizeof(uint8_t), stride, dst, stride); }

[[[[Adv]]]]: void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *[[l]], ptrdiff_t stride) { avc_luma_hv_qrt_and_aver_dst_16x16_msa([[l]] + stride - 2, [[l]] - (stride * 2) + sizeof(uint8_t), stride, dst, stride); }
--------------------------------------------- Result 1343 ---------------------------------------------
[[0 (54%)]] --> [[0 (39%)]] --> Socre: 0.6066716909408569

[[[[Adv]]]]: static int hevc_handle_packet(AVFormatContext *ctx, PayloadContext *rtp_hevc_ctx, AVStream *[[st]], AVPacket *pkt, uint32_t *timestamp, const uint8_t *buf, int len, uint16_t seq, int flags) { const uint8_t *rtp_pl = buf; int tid, lid, nal_type; int first_fragment, last_fragment, fu_type; uint8_t new_nal_header[2]; int res = 0; if (len < RTP_HEVC_PAYLOAD_HEADER_SIZE + 1) { av_log(ctx, AV_LOG_ERROR, "Too short RTP/HEVC packet, got %d bytes\n", len); return AVERROR_INVALIDDATA; } nal_type = (buf[0] >> 1) & 0x3f; lid = ((buf[0] << 5) & 0x20) | ((buf[1] >> 3) & 0x1f); tid = buf[1] & 0x07; if (lid) { avpriv_report_missing_feature(ctx, "Multi-layer HEVC coding\n"); return AVERROR_PATCHWELCOME; } if (!tid) { av_log(ctx, AV_LOG_ERROR, "Illegal temporal ID in RTP/HEVC packet\n"); return AVERROR_INVALIDDATA; } if (nal_type > 50) { av_log(ctx, AV_LOG_ERROR, "Unsupported (HEVC) NAL type (%d)\n", nal_type); return AVERROR_INVALIDDATA; } switch (nal_type) { case 32: case 33: case 34: case 39: default: if (len < 1) { av_log(ctx, AV_LOG_ERROR, "Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\n", len, nal_type); return AVERROR_INVALIDDATA; } if ((res = av_new_packet(pkt, sizeof(start_sequence) + len)) < 0) return res; memcpy(pkt->data, start_sequence, sizeof(start_sequence)); memcpy(pkt->data + sizeof(start_sequence), buf, len); break; case 48: buf += RTP_HEVC_PAYLOAD_HEADER_SIZE; len -= RTP_HEVC_PAYLOAD_HEADER_SIZE; if (rtp_hevc_ctx->using_donl_field) { buf += RTP_HEVC_DONL_FIELD_SIZE; len -= RTP_HEVC_DONL_FIELD_SIZE; } res = ff_h264_handle_aggregated_packet(ctx, pkt, buf, len, rtp_hevc_ctx->using_donl_field ? RTP_HEVC_DOND_FIELD_SIZE : 0, NULL, 0); if (res < 0) return res; break; case 49: buf += RTP_HEVC_PAYLOAD_HEADER_SIZE; len -= RTP_HEVC_PAYLOAD_HEADER_SIZE; first_fragment = buf[0] & 0x80; last_fragment = buf[0] & 0x40; fu_type = buf[0] & 0x3f; buf += RTP_HEVC_FU_HEADER_SIZE; len -= RTP_HEVC_FU_HEADER_SIZE; if (rtp_hevc_ctx->using_donl_field) { buf += RTP_HEVC_DONL_FIELD_SIZE; len -= RTP_HEVC_DONL_FIELD_SIZE; } av_dlog(ctx, " FU type %d with %d bytes\n", fu_type, len); if (len <= 0) { av_log(ctx, AV_LOG_ERROR, "Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\n", len, nal_type); return AVERROR_INVALIDDATA; } if (first_fragment && last_fragment) { av_log(ctx, AV_LOG_ERROR, "Illegal combination of S and E bit in RTP/HEVC packet\n"); return AVERROR_INVALIDDATA; } new_nal_header[0] = (rtp_pl[0] & 0x81) | (fu_type << 1); new_nal_header[1] = rtp_pl[1]; res = ff_h264_handle_frag_packet(pkt, buf, len, first_fragment, new_nal_header, sizeof(new_nal_header)); break; case 50: avpriv_report_missing_feature(ctx, "PACI packets for RTP/HEVC\n"); res = AVERROR_PATCHWELCOME; break; } pkt->stream_index = [[st]]->index; return res; }

[[[[Adv]]]]: static int hevc_handle_packet(AVFormatContext *ctx, PayloadContext *rtp_hevc_ctx, AVStream *[[hallowed]], AVPacket *pkt, uint32_t *timestamp, const uint8_t *buf, int len, uint16_t seq, int flags) { const uint8_t *rtp_pl = buf; int tid, lid, nal_type; int first_fragment, last_fragment, fu_type; uint8_t new_nal_header[2]; int res = 0; if (len < RTP_HEVC_PAYLOAD_HEADER_SIZE + 1) { av_log(ctx, AV_LOG_ERROR, "Too short RTP/HEVC packet, got %d bytes\n", len); return AVERROR_INVALIDDATA; } nal_type = (buf[0] >> 1) & 0x3f; lid = ((buf[0] << 5) & 0x20) | ((buf[1] >> 3) & 0x1f); tid = buf[1] & 0x07; if (lid) { avpriv_report_missing_feature(ctx, "Multi-layer HEVC coding\n"); return AVERROR_PATCHWELCOME; } if (!tid) { av_log(ctx, AV_LOG_ERROR, "Illegal temporal ID in RTP/HEVC packet\n"); return AVERROR_INVALIDDATA; } if (nal_type > 50) { av_log(ctx, AV_LOG_ERROR, "Unsupported (HEVC) NAL type (%d)\n", nal_type); return AVERROR_INVALIDDATA; } switch (nal_type) { case 32: case 33: case 34: case 39: default: if (len < 1) { av_log(ctx, AV_LOG_ERROR, "Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\n", len, nal_type); return AVERROR_INVALIDDATA; } if ((res = av_new_packet(pkt, sizeof(start_sequence) + len)) < 0) return res; memcpy(pkt->data, start_sequence, sizeof(start_sequence)); memcpy(pkt->data + sizeof(start_sequence), buf, len); break; case 48: buf += RTP_HEVC_PAYLOAD_HEADER_SIZE; len -= RTP_HEVC_PAYLOAD_HEADER_SIZE; if (rtp_hevc_ctx->using_donl_field) { buf += RTP_HEVC_DONL_FIELD_SIZE; len -= RTP_HEVC_DONL_FIELD_SIZE; } res = ff_h264_handle_aggregated_packet(ctx, pkt, buf, len, rtp_hevc_ctx->using_donl_field ? RTP_HEVC_DOND_FIELD_SIZE : 0, NULL, 0); if (res < 0) return res; break; case 49: buf += RTP_HEVC_PAYLOAD_HEADER_SIZE; len -= RTP_HEVC_PAYLOAD_HEADER_SIZE; first_fragment = buf[0] & 0x80; last_fragment = buf[0] & 0x40; fu_type = buf[0] & 0x3f; buf += RTP_HEVC_FU_HEADER_SIZE; len -= RTP_HEVC_FU_HEADER_SIZE; if (rtp_hevc_ctx->using_donl_field) { buf += RTP_HEVC_DONL_FIELD_SIZE; len -= RTP_HEVC_DONL_FIELD_SIZE; } av_dlog(ctx, " FU type %d with %d bytes\n", fu_type, len); if (len <= 0) { av_log(ctx, AV_LOG_ERROR, "Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\n", len, nal_type); return AVERROR_INVALIDDATA; } if (first_fragment && last_fragment) { av_log(ctx, AV_LOG_ERROR, "Illegal combination of S and E bit in RTP/HEVC packet\n"); return AVERROR_INVALIDDATA; } new_nal_header[0] = (rtp_pl[0] & 0x81) | (fu_type << 1); new_nal_header[1] = rtp_pl[1]; res = ff_h264_handle_frag_packet(pkt, buf, len, first_fragment, new_nal_header, sizeof(new_nal_header)); break; case 50: avpriv_report_missing_feature(ctx, "PACI packets for RTP/HEVC\n"); res = AVERROR_PATCHWELCOME; break; } pkt->stream_index = [[hallowed]]->index; return res; }
--------------------------------------------- Result 1344 ---------------------------------------------
[[0 (16%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int libschroedinger_encode_close(AVCodecContext *avctx) { SchroEncoderParams *p_schro_params = avctx->priv_data; schro_encoder_free(p_schro_params->encoder); ff_schro_queue_free(&p_schro_params->enc_frame_queue, libschroedinger_free_frame); if (p_schro_params->enc_buf_size) av_freep(&p_schro_params->enc_buf); av_freep(&p_schro_params->format); return 0; }
--------------------------------------------- Result 1345 ---------------------------------------------
[[0 (2%)]] --> [[0 (88%)]] --> Socre: 0.876151442527771

[[[[Adv]]]]: static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t [[addr]], unsigned size, bool is_write) { return (size == 1) || (is_write && size == 2); }

[[[[Adv]]]]: static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t [[ol]], unsigned size, bool is_write) { return (size == 1) || (is_write && size == 2); }
--------------------------------------------- Result 1346 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 793 / 72 / 481 / 1346:  50%|     | 1346/2690 [14:58:40<14:57:19, 40.06s/it][Succeeded / Failed / Skipped / Total] 793 / 72 / 481 / 1346:  50%|     | 1347/2690 [14:58:40<14:56:00, 40.03s/it][Succeeded / Failed / Skipped / Total] 793 / 72 / 482 / 1347:  50%|     | 1347/2690 [14:58:40<14:56:00, 40.03s/it][Succeeded / Failed / Skipped / Total] 793 / 72 / 482 / 1347:  50%|     | 1348/2690 [14:58:41<14:54:41, 40.00s/it][Succeeded / Failed / Skipped / Total] 793 / 72 / 483 / 1348:  50%|     | 1348/2690 [14:58:41<14:54:41, 40.00s/it][Succeeded / Failed / Skipped / Total] 793 / 72 / 483 / 1348:  50%|     | 1349/2690 [14:58:44<14:53:24, 39.97s/it][Succeeded / Failed / Skipped / Total] 794 / 72 / 483 / 1349:  50%|     | 1349/2690 [14:58:44<14:53:24, 39.97s/it][Succeeded / Failed / Skipped / Total] 794 / 72 / 483 / 1349:  50%|     | 1350/2690 [14:58:44<14:52:05, 39.94s/it][Succeeded / Failed / Skipped / Total] 794 / 72 / 484 / 1350:  50%|     | 1350/2690 [14:58:44<14:52:05, 39.94s/it][Succeeded / Failed / Skipped / Total] 794 / 72 / 484 / 1350:  50%|     | 1351/2690 [14:58:45<14:50:46, 39.92s/it][Succeeded / Failed / Skipped / Total] 794 / 72 / 485 / 1351:  50%|     | 1351/2690 [14:58:45<14:50:46, 39.92s/it][Succeeded / Failed / Skipped / Total] 794 / 72 / 485 / 1351:  50%|     | 1352/2690 [14:58:48<14:49:30, 39.89s/it][[0 (4%)]] --> [[0 (79%)]] --> Socre: 0.7857253551483154

[[[[Adv]]]]: void stl_phys_notdirty(hwaddr [[addr]], uint32_t val) { uint8_t *ptr; MemoryRegionSection *section; section = phys_page_find(address_space_memory.dispatch, [[addr]] >> TARGET_PAGE_BITS); if (!memory_region_is_ram(section->mr) || section->readonly) { [[addr]] = memory_region_section_addr(section, [[addr]]); if (memory_region_is_ram(section->mr)) { section = &phys_sections[phys_section_rom]; } io_mem_write(section->mr, [[addr]], val, 4); } else { unsigned long addr1 = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK) + memory_region_section_addr(section, [[addr]]); ptr = qemu_get_ram_ptr(addr1); stl_p(ptr, val); if (unlikely(in_migration)) { if (!cpu_physical_memory_is_dirty(addr1)) { tb_invalidate_phys_page_range(addr1, addr1 + 4, 0); cpu_physical_memory_set_dirty_flags( addr1, (0xff & ~CODE_DIRTY_FLAG)); } } } }

[[[[Adv]]]]: void stl_phys_notdirty(hwaddr [[soire]], uint32_t val) { uint8_t *ptr; MemoryRegionSection *section; section = phys_page_find(address_space_memory.dispatch, [[soire]] >> TARGET_PAGE_BITS); if (!memory_region_is_ram(section->mr) || section->readonly) { [[soire]] = memory_region_section_addr(section, [[soire]]); if (memory_region_is_ram(section->mr)) { section = &phys_sections[phys_section_rom]; } io_mem_write(section->mr, [[soire]], val, 4); } else { unsigned long addr1 = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK) + memory_region_section_addr(section, [[soire]]); ptr = qemu_get_ram_ptr(addr1); stl_p(ptr, val); if (unlikely(in_migration)) { if (!cpu_physical_memory_is_dirty(addr1)) { tb_invalidate_phys_page_range(addr1, addr1 + 4, 0); cpu_physical_memory_set_dirty_flags( addr1, (0xff & ~CODE_DIRTY_FLAG)); } } } }
--------------------------------------------- Result 1347 ---------------------------------------------
[[0 (20%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void *ff_avio_child_next(void *obj, void *prev) { AVIOContext *s = obj; AVIOInternal *internal = s->opaque; return prev ? NULL : internal->h; }
--------------------------------------------- Result 1348 ---------------------------------------------
[[0 (14%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void pm_ioport_read(IORange *ioport, uint64_t addr, unsigned width, uint64_t *data) { PIIX4PMState *s = container_of(ioport, PIIX4PMState, ioport); uint32_t val; switch(addr) { case 0x00: val = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time); break; case 0x02: val = s->ar.pm1.evt.en; break; case 0x04: val = s->ar.pm1.cnt.cnt; break; case 0x08: val = acpi_pm_tmr_get(&s->ar); break; default: val = 0; break; } PIIX4_DPRINTF("PM readw port=0x%04x val=0x%04x\n", (unsigned int)addr, val); *data = val; }
--------------------------------------------- Result 1349 ---------------------------------------------
[[0 (31%)]] --> [[0 (54%)]] --> Socre: 0.5387608408927917

[[[[Adv]]]]: static int cinepak_decode_frame(AVCodecContext *avctx, void *[[data]], int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int [[ret]] = 0, buf_size = avpkt->size; CinepakContext *s = avctx->priv_data; s->data = buf; s->size = buf_size; if (([[ret]] = ff_reget_buffer(avctx, s->frame)) < 0) return [[ret]]; if (s->palette_video) { const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL); if (pal) { s->frame->palette_has_changed = 1; memcpy(s->pal, pal, AVPALETTE_SIZE); } } if (([[ret]] = cinepak_decode(s)) < 0) { av_log(avctx, AV_LOG_ERROR, "cinepak_decode failed\n"); } if (s->palette_video) memcpy (s->frame->data[1], s->pal, AVPALETTE_SIZE); if (([[ret]] = av_frame_ref([[data]], s->frame)) < 0) return [[ret]]; *got_frame = 1; return buf_size; }

[[[[Adv]]]]: static int cinepak_decode_frame(AVCodecContext *avctx, void *[[declarations]], int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int [[pensioner]] = 0, buf_size = avpkt->size; CinepakContext *s = avctx->priv_data; s->data = buf; s->size = buf_size; if (([[pensioner]] = ff_reget_buffer(avctx, s->frame)) < 0) return [[pensioner]]; if (s->palette_video) { const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL); if (pal) { s->frame->palette_has_changed = 1; memcpy(s->pal, pal, AVPALETTE_SIZE); } } if (([[pensioner]] = cinepak_decode(s)) < 0) { av_log(avctx, AV_LOG_ERROR, "cinepak_decode failed\n"); } if (s->palette_video) memcpy (s->frame->data[1], s->pal, AVPALETTE_SIZE); if (([[pensioner]] = av_frame_ref([[declarations]], s->frame)) < 0) return [[pensioner]]; *got_frame = 1; return buf_size; }
--------------------------------------------- Result 1350 ---------------------------------------------
[[0 (36%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int nbd_receive_reply(QIOChannel *ioc, NBDReply *reply, Error **errp) { int ret; const char *type; ret = nbd_read_eof(ioc, &reply->magic, sizeof(reply->magic), errp); if (ret <= 0) { return ret; } be32_to_cpus(&reply->magic); switch (reply->magic) { case NBD_SIMPLE_REPLY_MAGIC: ret = nbd_receive_simple_reply(ioc, &reply->simple, errp); if (ret < 0) { break; } trace_nbd_receive_simple_reply(reply->simple.error, nbd_err_lookup(reply->simple.error), reply->handle); if (reply->simple.error == NBD_ESHUTDOWN) { error_setg(errp, "server shutting down"); return -EINVAL; } break; case NBD_STRUCTURED_REPLY_MAGIC: ret = nbd_receive_structured_reply_chunk(ioc, &reply->structured, errp); if (ret < 0) { break; } type = nbd_reply_type_lookup(reply->structured.type); trace_nbd_receive_structured_reply_chunk(reply->structured.flags, reply->structured.type, type, reply->structured.handle, reply->structured.length); break; default: error_setg(errp, "invalid magic (got 0x%" PRIx32 ")", reply->magic); return -EINVAL; } if (ret < 0) { return ret; } return 1; }
--------------------------------------------- Result 1351 ---------------------------------------------
[[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ne2000_receive(void *opaque, const uint8_t *buf, int size) { NE2000State *s = opaque; uint8_t *p; int total_len, next, avail, len, index, mcast_idx; uint8_t buf1[60]; static const uint8_t broadcast_macaddr[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }; #if defined(DEBUG_NE2000) printf("NE2000: received len=%d\n", size); #endif if (!ne2000_can_receive(s)) return; if (s->rxcr & 0x10) { } else { if (!memcmp(buf, broadcast_macaddr, 6)) { if (!(s->rxcr & 0x04)) return; } else if (buf[0] & 0x01) { if (!(s->rxcr & 0x08)) return; mcast_idx = compute_mcast_idx(buf); if (!(s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7)))) return; } else if (s->mem[0] == buf[0] && s->mem[2] == buf[1] && s->mem[4] == buf[2] && s->mem[6] == buf[3] && s->mem[8] == buf[4] && s->mem[10] == buf[5]) { } else { return; } } if (size < MIN_BUF_SIZE) { memcpy(buf1, buf, size); memset(buf1 + size, 0, MIN_BUF_SIZE - size); buf = buf1; size = MIN_BUF_SIZE; } index = s->curpag << 8; total_len = size + 4; next = index + ((total_len + 4 + 255) & ~0xff); if (next >= s->stop) next -= (s->stop - s->start); p = s->mem + index; s->rsr = ENRSR_RXOK; if (buf[0] & 0x01) s->rsr |= ENRSR_PHY; p[0] = s->rsr; p[1] = next >> 8; p[2] = total_len; p[3] = total_len >> 8; index += 4; while (size > 0) { avail = s->stop - index; len = size; if (len > avail) len = avail; memcpy(s->mem + index, buf, len); buf += len; index += len; if (index == s->stop) index = s->start; size -= len; } s->curpag = next >> 8; s->isr |= ENISR_RX; ne2000_update_irq(s); }
--------------------------------------------- Result 1352 ---------------------------------------------
[[0 (40%)]] --> [[0 (50%)]] --> Socre: 0.5014024972915649

[[[[Adv]]]]: static void taihu_405ep_init(MachineState *[[machine]]) { ram_addr_t ram_size = [[machine]]->ram_size; const char *[[kernel_filename]] = [[machine]]->kernel_filename; const char *initrd_filename = [[machine]]->initrd_filename; char *filename; qemu_irq *pic; MemoryRegion *sysmem = get_system_memory(); MemoryRegion *bios; MemoryRegion *ram_memories = g_malloc(2 * sizeof(*ram_memories)); MemoryRegion *ram = g_malloc0(sizeof(*ram)); hwaddr [[ram_bases]][2], ram_sizes[2]; long [[bios_size]]; target_ulong kernel_base, initrd_base; long kernel_size, initrd_size; int linux_boot; int fl_idx, fl_sectors; DriveInfo *dinfo; ram_size = 0x08000000; memory_region_allocate_system_memory(ram, NULL, "taihu_405ep.ram", ram_size); [[ram_bases]][0] = 0; ram_sizes[0] = 0x04000000; memory_region_init_alias(&ram_memories[0], NULL, "taihu_405ep.ram-0", ram, [[ram_bases]][0], ram_sizes[0]); [[ram_bases]][1] = 0x04000000; ram_sizes[1] = 0x04000000; memory_region_init_alias(&ram_memories[1], NULL, "taihu_405ep.ram-1", ram, [[ram_bases]][1], ram_sizes[1]); #ifdef DEBUG_BOARD_INIT printf("%s: register cpu\n", __func__); #endif ppc405ep_init(sysmem, ram_memories, [[ram_bases]], ram_sizes, 33333333, &pic, [[kernel_filename]] == NULL ? 0 : 1); #ifdef DEBUG_BOARD_INIT printf("%s: register BIOS\n", __func__); #endif fl_idx = 0; #if defined(USE_FLASH_BIOS) dinfo = drive_get(IF_PFLASH, 0, fl_idx); if (dinfo) { BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo)); [[bios_size]] = bdrv_getlength(bs); fl_sectors = ([[bios_size]] + 65535) >> 16; #ifdef DEBUG_BOARD_INIT printf("Register parallel flash %d size %lx" " at addr %lx '%s' %d\n", fl_idx, [[bios_size]], -[[bios_size]], bdrv_get_device_name(bs), fl_sectors); #endif pflash_cfi02_register((uint32_t)(-[[bios_size]]), NULL, "taihu_405ep.bios", [[bios_size]], bs, 65536, fl_sectors, 1, 4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA, 1); fl_idx++; } else #endif { #ifdef DEBUG_BOARD_INIT printf("Load BIOS from file\n"); #endif if (bios_name == NULL) bios_name = BIOS_FILENAME; bios = g_new(MemoryRegion, 1); memory_region_init_ram(bios, NULL, "taihu_405ep.bios", BIOS_SIZE, &error_abort); vmstate_register_ram_global(bios); filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (filename) { [[bios_size]] = load_image(filename, memory_region_get_ram_ptr(bios)); g_free(filename); if ([[bios_size]] < 0 || [[bios_size]] > BIOS_SIZE) { error_report("Could not load PowerPC BIOS '%s'", bios_name); exit(1); } [[bios_size]] = ([[bios_size]] + 0xfff) & ~0xfff; memory_region_add_subregion(sysmem, (uint32_t)(-[[bios_size]]), bios); } else if (!qtest_enabled()) { error_report("Could not load PowerPC BIOS '%s'", bios_name); exit(1); } memory_region_set_readonly(bios, "True" == "True"); } dinfo = drive_get(IF_PFLASH, 0, fl_idx); if (dinfo) { BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo)); [[bios_size]] = bdrv_getlength(bs); [[bios_size]] = 32 * 1024 * 1024; fl_sectors = ([[bios_size]] + 65535) >> 16; #ifdef DEBUG_BOARD_INIT printf("Register parallel flash %d size %lx" " at addr " TARGET_FMT_lx " '%s'\n", fl_idx, [[bios_size]], (target_ulong)0xfc000000, bdrv_get_device_name(bs)); #endif pflash_cfi02_register(0xfc000000, NULL, "taihu_405ep.flash", [[bios_size]], bs, 65536, fl_sectors, 1, 4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA, 1); fl_idx++; } #ifdef DEBUG_BOARD_INIT printf("%s: register CPLD\n", __func__); #endif taihu_cpld_init(sysmem, 0x50100000); linux_boot = ([[kernel_filename]] != NULL); if (linux_boot) { #ifdef DEBUG_BOARD_INIT printf("%s: load kernel\n", __func__); #endif kernel_base = KERNEL_LOAD_ADDR; kernel_size = load_image_targphys([[kernel_filename]], kernel_base, ram_size - kernel_base); if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", [[kernel_filename]]); exit(1); } if (initrd_filename) { initrd_base = INITRD_LOAD_ADDR; initrd_size = load_image_targphys(initrd_filename, initrd_base, ram_size - initrd_base); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } } else { initrd_base = 0; initrd_size = 0; } } else { kernel_base = 0; kernel_size = 0; initrd_base = 0; initrd_size = 0; } #ifdef DEBUG_BOARD_INIT printf("%s: Done\n", __func__); #endif }

[[[[Adv]]]]: static void taihu_405ep_init(MachineState *[[machines]]) { ram_addr_t ram_size = [[machines]]->ram_size; const char *[[admiral]] = [[machines]]->kernel_filename; const char *initrd_filename = [[machines]]->initrd_filename; char *filename; qemu_irq *pic; MemoryRegion *sysmem = get_system_memory(); MemoryRegion *bios; MemoryRegion *ram_memories = g_malloc(2 * sizeof(*ram_memories)); MemoryRegion *ram = g_malloc0(sizeof(*ram)); hwaddr [[crimson]][2], ram_sizes[2]; long [[democratic]]; target_ulong kernel_base, initrd_base; long kernel_size, initrd_size; int linux_boot; int fl_idx, fl_sectors; DriveInfo *dinfo; ram_size = 0x08000000; memory_region_allocate_system_memory(ram, NULL, "taihu_405ep.ram", ram_size); [[crimson]][0] = 0; ram_sizes[0] = 0x04000000; memory_region_init_alias(&ram_memories[0], NULL, "taihu_405ep.ram-0", ram, [[crimson]][0], ram_sizes[0]); [[crimson]][1] = 0x04000000; ram_sizes[1] = 0x04000000; memory_region_init_alias(&ram_memories[1], NULL, "taihu_405ep.ram-1", ram, [[crimson]][1], ram_sizes[1]); #ifdef DEBUG_BOARD_INIT printf("%s: register cpu\n", __func__); #endif ppc405ep_init(sysmem, ram_memories, [[crimson]], ram_sizes, 33333333, &pic, [[admiral]] == NULL ? 0 : 1); #ifdef DEBUG_BOARD_INIT printf("%s: register BIOS\n", __func__); #endif fl_idx = 0; #if defined(USE_FLASH_BIOS) dinfo = drive_get(IF_PFLASH, 0, fl_idx); if (dinfo) { BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo)); [[democratic]] = bdrv_getlength(bs); fl_sectors = ([[democratic]] + 65535) >> 16; #ifdef DEBUG_BOARD_INIT printf("Register parallel flash %d size %lx" " at addr %lx '%s' %d\n", fl_idx, [[democratic]], -[[democratic]], bdrv_get_device_name(bs), fl_sectors); #endif pflash_cfi02_register((uint32_t)(-[[democratic]]), NULL, "taihu_405ep.bios", [[democratic]], bs, 65536, fl_sectors, 1, 4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA, 1); fl_idx++; } else #endif { #ifdef DEBUG_BOARD_INIT printf("Load BIOS from file\n"); #endif if (bios_name == NULL) bios_name = BIOS_FILENAME; bios = g_new(MemoryRegion, 1); memory_region_init_ram(bios, NULL, "taihu_405ep.bios", BIOS_SIZE, &error_abort); vmstate_register_ram_global(bios); filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (filename) { [[democratic]] = load_image(filename, memory_region_get_ram_ptr(bios)); g_free(filename); if ([[democratic]] < 0 || [[democratic]] > BIOS_SIZE) { error_report("Could not load PowerPC BIOS '%s'", bios_name); exit(1); } [[democratic]] = ([[democratic]] + 0xfff) & ~0xfff; memory_region_add_subregion(sysmem, (uint32_t)(-[[democratic]]), bios); } else if (!qtest_enabled()) { error_report("Could not load PowerPC BIOS '%s'", bios_name); exit(1); } memory_region_set_readonly(bios, "True" == "True"); } dinfo = drive_get(IF_PFLASH, 0, fl_idx); if (dinfo) { BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo)); [[democratic]] = bdrv_getlength(bs); [[democratic]] = 32 * 1024 * 1024; fl_sectors = ([[democratic]] + 65535) >> 16; #ifdef DEBUG_BOARD_INIT printf("Register parallel flash %d size %lx" " at addr " TARGET_FMT_lx " '%s'\n", fl_idx, [[democratic]], (target_ulong)0xfc000000, bdrv_get_device_name(bs)); #endif pflash_cfi02_register(0xfc000000, NULL, "taihu_405ep.flash", [[democratic]], bs, 65536, fl_sectors, 1, 4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA, 1); fl_idx++; } #ifdef DEBUG_BOARD_INIT printf("%s: register CPLD\n", __func__); #endif taihu_cpld_init(sysmem, 0x50100000); linux_boot = ([[admiral]] != NULL); if (linux_boot) { #ifdef DEBUG_BOARD_INIT printf("%s: load kernel\n", __func__); #endif kernel_base = KERNEL_LOAD_ADDR; kernel_size = load_image_targphys([[admiral]], kernel_base, ram_size - kernel_base); if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", [[admiral]]); exit(1); } if (initrd_filename) { initrd_base = INITRD_LOAD_ADDR; initrd_size = load_image_targphys(initrd_filename, initrd_base, ram_size - initrd_base); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } } else { initrd_base = 0; initrd_size = 0; } } else { kernel_base = 0; kernel_size = 0; initrd_base = 0; initrd_size = 0; } #ifdef DEBUG_BOARD_INIT printf("%s: Done\n", __func__); #endif }[Succeeded / Failed / Skipped / Total] 795 / 72 / 485 / 1352:  50%|     | 1352/2690 [14:58:48<14:49:30, 39.89s/it][Succeeded / Failed / Skipped / Total] 795 / 72 / 485 / 1352:  50%|     | 1353/2690 [14:58:50<14:48:12, 39.86s/it][Succeeded / Failed / Skipped / Total] 796 / 72 / 485 / 1353:  50%|     | 1353/2690 [14:58:50<14:48:12, 39.86s/it][Succeeded / Failed / Skipped / Total] 796 / 72 / 485 / 1353:  50%|     | 1354/2690 [14:58:56<14:46:59, 39.84s/it]
--------------------------------------------- Result 1353 ---------------------------------------------
[[0 (56%)]] --> [[0 (49%)]] --> Socre: 0.5127097070217133

[[[[Adv]]]]: static void scsi_disk_purge_requests(SCSIDiskState *s) { SCSIDiskReq *[[r]]; while (!QTAILQ_EMPTY(&s->qdev.requests)) { [[r]] = DO_UPCAST(SCSIDiskReq, req, QTAILQ_FIRST(&s->qdev.requests)); if ([[r]]->req.aiocb) { bdrv_aio_cancel([[r]]->req.aiocb); } scsi_remove_request([[r]]); } }

[[[[Adv]]]]: static void scsi_disk_purge_requests(SCSIDiskState *s) { SCSIDiskReq *[[p]]; while (!QTAILQ_EMPTY(&s->qdev.requests)) { [[p]] = DO_UPCAST(SCSIDiskReq, req, QTAILQ_FIRST(&s->qdev.requests)); if ([[p]]->req.aiocb) { bdrv_aio_cancel([[p]]->req.aiocb); } scsi_remove_request([[p]]); } }
--------------------------------------------- Result 1354 ---------------------------------------------
[[0 (25%)]] --> [[0 (54%)]] --> Socre: 0.5354917645454407

[[[[Adv]]]]: static av_cold int svc_encode_init(AVCodecContext *[[avctx]]) { SVCContext *s = [[avctx]]->priv_data; SEncParamExt [[param]] = { 0 }; int err = AVERROR_UNKNOWN; int log_level; WelsTraceCallback [[callback_function]]; AVCPBProperties *props; #if !defined(_WIN32) || !defined(__GNUC__) || !ARCH_X86_32 || AV_GCC_VERSION_AT_LEAST(4, 7) OpenH264Version libver = WelsGetCodecVersion(); if (memcmp(&libver, &g_stCodecVersion, sizeof(libver))) { av_log([[avctx]], AV_LOG_ERROR, "Incorrect library version loaded\n"); return AVERROR(EINVAL); } #endif if (WelsCreateSVCEncoder(&s->encoder)) { av_log([[avctx]], AV_LOG_ERROR, "Unable to create encoder\n"); return AVERROR_UNKNOWN; } log_level = WELS_LOG_DETAIL; (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_LEVEL, &log_level); [[callback_function]] = (WelsTraceCallback) libopenh264_trace_callback; (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_CALLBACK, (void *)&[[callback_function]]); (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_CALLBACK_CONTEXT, (void *)&[[avctx]]); (*s->encoder)->GetDefaultParams(s->encoder, &[[param]]); [[param]].fMaxFrameRate = [[avctx]]->time_base.den / [[avctx]]->time_base.num; [[param]].iPicWidth = [[avctx]]->width; [[param]].iPicHeight = [[avctx]]->height; [[param]].iTargetBitrate = [[avctx]]->bit_rate; [[param]].iMaxBitrate = FFMAX([[avctx]]->rc_max_rate, [[avctx]]->bit_rate); [[param]].iRCMode = RC_QUALITY_MODE; [[param]].iTemporalLayerNum = 1; [[param]].iSpatialLayerNum = 1; [[param]].bEnableDenoise = 0; [[param]].bEnableBackgroundDetection = 1; [[param]].bEnableAdaptiveQuant = 1; [[param]].bEnableFrameSkip = s->skip_frames; [[param]].bEnableLongTermReference = 0; [[param]].iLtrMarkPeriod = 30; [[param]].uiIntraPeriod = [[avctx]]->gop_size; #if OPENH264_VER_AT_LEAST(1, 4) [[param]].eSpsPpsIdStrategy = CONSTANT_ID; #else [[param]].bEnableSpsPpsIdAddition = 0; #endif [[param]].bPrefixNalAddingCtrl = 0; [[param]].iLoopFilterDisableIdc = !s->loopfilter; [[param]].iEntropyCodingModeFlag = 0; [[param]].iMultipleThreadIdc = [[avctx]]->thread_count; if (s->profile && !strcmp(s->profile, "main")) [[param]].iEntropyCodingModeFlag = 1; else if (!s->profile && [[avctx]]->coder_type == FF_CODER_TYPE_AC) [[param]].iEntropyCodingModeFlag = 1; [[param]].sSpatialLayers[0].iVideoWidth = [[param]].iPicWidth; [[param]].sSpatialLayers[0].iVideoHeight = [[param]].iPicHeight; [[param]].sSpatialLayers[0].fFrameRate = [[param]].fMaxFrameRate; [[param]].sSpatialLayers[0].iSpatialBitrate = [[param]].iTargetBitrate; [[param]].sSpatialLayers[0].iMaxSpatialBitrate = [[param]].iMaxBitrate; if (([[avctx]]->slices > 1) && (s->max_nal_size)){ av_log([[avctx]],AV_LOG_ERROR,"Invalid combination -slices %d and -max_nal_size %d.\n",[[avctx]]->slices,s->max_nal_size); goto fail; } if ([[avctx]]->slices > 1) s->slice_mode = SM_FIXEDSLCNUM_SLICE; if (s->max_nal_size) s->slice_mode = SM_DYN_SLICE; [[param]].sSpatialLayers[0].sSliceCfg.uiSliceMode = s->slice_mode; [[param]].sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceNum = [[avctx]]->slices; if (s->slice_mode == SM_DYN_SLICE) { if (s->max_nal_size){ [[param]].uiMaxNalSize = s->max_nal_size; [[param]].sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = s->max_nal_size; } else { if ([[avctx]]->rtp_payload_size) { av_log([[avctx]],AV_LOG_DEBUG,"Using RTP Payload size for uiMaxNalSize"); [[param]].uiMaxNalSize = [[avctx]]->rtp_payload_size; [[param]].sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = [[avctx]]->rtp_payload_size; } else { av_log([[avctx]],AV_LOG_ERROR,"Invalid -max_nal_size, specify a valid max_nal_size to use -slice_mode dyn\n"); goto fail; } } } if ((*s->encoder)->InitializeExt(s->encoder, &[[param]]) != cmResultSuccess) { av_log([[avctx]], AV_LOG_ERROR, "Initialize failed\n"); goto fail; } if ([[avctx]]->flags & AV_CODEC_FLAG_GLOBAL_HEADER) { SFrameBSInfo fbi = { 0 }; int i, size = 0; (*s->encoder)->EncodeParameterSets(s->encoder, &fbi); for (i = 0; i < fbi.sLayerInfo[0].iNalCount; i++) size += fbi.sLayerInfo[0].pNalLengthInByte[i]; [[avctx]]->extradata = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE); if (![[avctx]]->extradata) { err = AVERROR(ENOMEM); goto fail; } [[avctx]]->extradata_size = size; memcpy([[avctx]]->extradata, fbi.sLayerInfo[0].pBsBuf, size); } props = ff_add_cpb_side_data([[avctx]]); if (!props) { err = AVERROR(ENOMEM); goto fail; } props->max_bitrate = [[param]].iMaxBitrate; props->avg_bitrate = [[param]].iTargetBitrate; return 0; fail: svc_encode_close([[avctx]]); return err; }

[[[[Adv]]]]: static av_cold int svc_encode_init(AVCodecContext *[[marksmanship]]) { SVCContext *s = [[marksmanship]]->priv_data; SEncParamExt [[chitlins]] = { 0 }; int err = AVERROR_UNKNOWN; int log_level; WelsTraceCallback [[mats]]; AVCPBProperties *props; #if !defined(_WIN32) || !defined(__GNUC__) || !ARCH_X86_32 || AV_GCC_VERSION_AT_LEAST(4, 7) OpenH264Version libver = WelsGetCodecVersion(); if (memcmp(&libver, &g_stCodecVersion, sizeof(libver))) { av_log([[marksmanship]], AV_LOG_ERROR, "Incorrect library version loaded\n"); return AVERROR(EINVAL); } #endif if (WelsCreateSVCEncoder(&s->encoder)) { av_log([[marksmanship]], AV_LOG_ERROR, "Unable to create encoder\n"); return AVERROR_UNKNOWN; } log_level = WELS_LOG_DETAIL; (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_LEVEL, &log_level); [[mats]] = (WelsTraceCallback) libopenh264_trace_callback; (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_CALLBACK, (void *)&[[mats]]); (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_CALLBACK_CONTEXT, (void *)&[[marksmanship]]); (*s->encoder)->GetDefaultParams(s->encoder, &[[chitlins]]); [[chitlins]].fMaxFrameRate = [[marksmanship]]->time_base.den / [[marksmanship]]->time_base.num; [[chitlins]].iPicWidth = [[marksmanship]]->width; [[chitlins]].iPicHeight = [[marksmanship]]->height; [[chitlins]].iTargetBitrate = [[marksmanship]]->bit_rate; [[chitlins]].iMaxBitrate = FFMAX([[marksmanship]]->rc_max_rate, [[marksmanship]]->bit_rate); [[chitlins]].iRCMode = RC_QUALITY_MODE; [[chitlins]].iTemporalLayerNum = 1; [[chitlins]].iSpatialLayerNum = 1; [[chitlins]].bEnableDenoise = 0; [[chitlins]].bEnableBackgroundDetection = 1; [[chitlins]].bEnableAdaptiveQuant = 1; [[chitlins]].bEnableFrameSkip = s->skip_frames; [[chitlins]].bEnableLongTermReference = 0; [[chitlins]].iLtrMarkPeriod = 30; [[chitlins]].uiIntraPeriod = [[marksmanship]]->gop_size; #if OPENH264_VER_AT_LEAST(1, 4) [[chitlins]].eSpsPpsIdStrategy = CONSTANT_ID; #else [[chitlins]].bEnableSpsPpsIdAddition = 0; #endif [[chitlins]].bPrefixNalAddingCtrl = 0; [[chitlins]].iLoopFilterDisableIdc = !s->loopfilter; [[chitlins]].iEntropyCodingModeFlag = 0; [[chitlins]].iMultipleThreadIdc = [[marksmanship]]->thread_count; if (s->profile && !strcmp(s->profile, "main")) [[chitlins]].iEntropyCodingModeFlag = 1; else if (!s->profile && [[marksmanship]]->coder_type == FF_CODER_TYPE_AC) [[chitlins]].iEntropyCodingModeFlag = 1; [[chitlins]].sSpatialLayers[0].iVideoWidth = [[chitlins]].iPicWidth; [[chitlins]].sSpatialLayers[0].iVideoHeight = [[chitlins]].iPicHeight; [[chitlins]].sSpatialLayers[0].fFrameRate = [[chitlins]].fMaxFrameRate; [[chitlins]].sSpatialLayers[0].iSpatialBitrate = [[chitlins]].iTargetBitrate; [[chitlins]].sSpatialLayers[0].iMaxSpatialBitrate = [[chitlins]].iMaxBitrate; if (([[marksmanship]]->slices > 1) && (s->max_nal_size)){ av_log([[marksmanship]],AV_LOG_ERROR,"Invalid combination -slices %d and -max_nal_size %d.\n",[[marksmanship]]->slices,s->max_nal_size); goto fail; } if ([[marksmanship]]->slices > 1) s->slice_mode = SM_FIXEDSLCNUM_SLICE; if (s->max_nal_size) s->slice_mode = SM_DYN_SLICE; [[chitlins]].sSpatialLayers[0].sSliceCfg.uiSliceMode = s->slice_mode; [[chitlins]].sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceNum = [[marksmanship]]->slices; if (s->slice_mode == SM_DYN_SLICE) { if (s->max_nal_size){ [[chitlins]].uiMaxNalSize = s->max_nal_size; [[chitlins]].sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = s->max_nal_size; } else { if ([[marksmanship]]->rtp_payload_size) { av_log([[marksmanship]],AV_LOG_DEBUG,"Using RTP Payload size for uiMaxNalSize"); [[chitlins]].uiMaxNalSize = [[marksmanship]]->rtp_payload_size; [[chitlins]].sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = [[marksmanship]]->rtp_payload_size; } else { av_log([[marksmanship]],AV_LOG_ERROR,"Invalid -max_nal_size, specify a valid max_nal_size to use -slice_mode dyn\n"); goto fail; } } } if ((*s->encoder)->InitializeExt(s->encoder, &[[chitlins]]) != cmResultSuccess) { av_log([[marksmanship]], AV_LOG_ERROR, "Initialize failed\n"); goto fail; } if ([[marksmanship]]->flags & AV_CODEC_FLAG_GLOBAL_HEADER) { SFrameBSInfo fbi = { 0 }; int i, size = 0; (*s->encoder)->EncodeParameterSets(s->encoder, &fbi); for (i = 0; i < fbi.sLayerInfo[0].iNalCount; i++) size += fbi.sLayerInfo[0].pNalLengthInByte[i]; [[marksmanship]]->extradata = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE); if (![[marksmanship]]->extradata) { err = AVERROR(ENOMEM); goto fail; } [[marksmanship]]->extradata_size = size; memcpy([[marksmanship]]->extradata, fbi.sLayerInfo[0].pBsBuf, size); } props = ff_add_cpb_side_data([[marksmanship]]); if (!props) { err = AVERROR(ENOMEM); goto fail; } props->max_bitrate = [[chitlins]].iMaxBitrate; props->avg_bitrate = [[chitlins]].iTargetBitrate; return 0; fail: svc_encode_close([[marksmanship]]); return err; }[Succeeded / Failed / Skipped / Total] 797 / 72 / 485 / 1354:  50%|     | 1354/2690 [14:58:56<14:46:59, 39.84s/it][Succeeded / Failed / Skipped / Total] 797 / 72 / 485 / 1354:  50%|     | 1355/2690 [14:59:04<14:45:47, 39.81s/it][Succeeded / Failed / Skipped / Total] 798 / 72 / 485 / 1355:  50%|     | 1355/2690 [14:59:04<14:45:47, 39.81s/it][Succeeded / Failed / Skipped / Total] 798 / 72 / 485 / 1355:  50%|     | 1356/2690 [14:59:08<14:44:33, 39.79s/it][Succeeded / Failed / Skipped / Total] 799 / 72 / 485 / 1356:  50%|     | 1356/2690 [14:59:08<14:44:33, 39.79s/it][Succeeded / Failed / Skipped / Total] 799 / 72 / 485 / 1356:  50%|     | 1357/2690 [14:59:50<14:43:55, 39.79s/it][Succeeded / Failed / Skipped / Total] 799 / 73 / 485 / 1357:  50%|     | 1357/2690 [14:59:50<14:43:55, 39.79s/it][Succeeded / Failed / Skipped / Total] 799 / 73 / 485 / 1357:  50%|     | 1358/2690 [15:00:03<14:42:49, 39.77s/it][Succeeded / Failed / Skipped / Total] 800 / 73 / 485 / 1358:  50%|     | 1358/2690 [15:00:03<14:42:49, 39.77s/it][Succeeded / Failed / Skipped / Total] 800 / 73 / 485 / 1358:  51%|     | 1359/2690 [15:01:49<14:43:14, 39.82s/it][Succeeded / Failed / Skipped / Total] 801 / 73 / 485 / 1359:  51%|     | 1359/2690 [15:01:49<14:43:14, 39.82s/it][Succeeded / Failed / Skipped / Total] 801 / 73 / 485 / 1359:  51%|     | 1360/2690 [15:01:50<14:41:56, 39.79s/it]
--------------------------------------------- Result 1355 ---------------------------------------------
[[0 (98%)]] --> [[0 (48%)]] --> Socre: 0.5153219401836395

[[[[Adv]]]]: static int update_dimensions(VP8Context *s, int [[width]], int height) { if ([[width]] != s->avctx->width || height != s->avctx->height) { if (av_image_check_size([[width]], height, 0, s->avctx)) return AVERROR_INVALIDDATA; vp8_decode_flush_impl(s->avctx, 1, 0, 1); avcodec_set_dimensions(s->avctx, [[width]], height); } s->mb_width = (s->avctx->coded_width +15) / 16; s->mb_height = (s->avctx->coded_height+15) / 16; s->macroblocks_base = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks)); s->filter_strength = av_mallocz(s->mb_width*sizeof(*s->filter_strength)); s->intra4x4_pred_mode_top = av_mallocz(s->mb_width*4); s->top_nnz = av_mallocz(s->mb_width*sizeof(*s->top_nnz)); s->top_border = av_mallocz((s->mb_width+1)*sizeof(*s->top_border)); if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top || !s->top_nnz || !s->top_border) return AVERROR(ENOMEM); s->macroblocks = s->macroblocks_base + 1; return 0; }

[[[[Adv]]]]: static int update_dimensions(VP8Context *s, int [[pallet]], int height) { if ([[pallet]] != s->avctx->width || height != s->avctx->height) { if (av_image_check_size([[pallet]], height, 0, s->avctx)) return AVERROR_INVALIDDATA; vp8_decode_flush_impl(s->avctx, 1, 0, 1); avcodec_set_dimensions(s->avctx, [[pallet]], height); } s->mb_width = (s->avctx->coded_width +15) / 16; s->mb_height = (s->avctx->coded_height+15) / 16; s->macroblocks_base = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks)); s->filter_strength = av_mallocz(s->mb_width*sizeof(*s->filter_strength)); s->intra4x4_pred_mode_top = av_mallocz(s->mb_width*4); s->top_nnz = av_mallocz(s->mb_width*sizeof(*s->top_nnz)); s->top_border = av_mallocz((s->mb_width+1)*sizeof(*s->top_border)); if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top || !s->top_nnz || !s->top_border) return AVERROR(ENOMEM); s->macroblocks = s->macroblocks_base + 1; return 0; }
--------------------------------------------- Result 1356 ---------------------------------------------
[[0 (1%)]] --> [[0 (55%)]] --> Socre: 0.549690306186676

[[[[Adv]]]]: void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *[[buf]], int len, int is_write) { return address_space_rw(&address_space_memory, addr, [[buf]], len, is_write); }

[[[[Adv]]]]: void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *[[fte]], int len, int is_write) { return address_space_rw(&address_space_memory, addr, [[fte]], len, is_write); }
--------------------------------------------- Result 1357 ---------------------------------------------
[[0 (35%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void v9fs_link(void *opaque) { V9fsPDU *pdu = opaque; V9fsState *s = pdu->s; int32_t dfid, oldfid; V9fsFidState *dfidp, *oldfidp; V9fsString name; size_t offset = 7; int err = 0; pdu_unmarshal(pdu, offset, "dds", &dfid, &oldfid, &name); trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data); dfidp = get_fid(pdu, dfid); if (dfidp == NULL) { err = -ENOENT; goto out_nofid; } oldfidp = get_fid(pdu, oldfid); if (oldfidp == NULL) { err = -ENOENT; goto out; } err = v9fs_co_link(pdu, oldfidp, dfidp, &name); if (!err) { err = offset; } out: put_fid(pdu, dfidp); out_nofid: v9fs_string_free(&name); complete_pdu(s, pdu, err); }

[[[[Adv]]]]: static void v9fs_link(void *opaque) { V9fsPDU *pdu = opaque; V9fsState *s = pdu->s; int32_t dfid, oldfid; V9fsFidState *dfidp, *oldfidp; V9fsString name; size_t offset = 7; int err = 0; pdu_unmarshal(pdu, offset, "dds", &dfid, &oldfid, &name); trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data); dfidp = get_fid(pdu, dfid); if (dfidp == NULL) { err = -ENOENT; goto out_nofid; } oldfidp = get_fid(pdu, oldfid); if (oldfidp == NULL) { err = -ENOENT; goto out; } err = v9fs_co_link(pdu, oldfidp, dfidp, &name); if (!err) { err = offset; } out: put_fid(pdu, dfidp); out_nofid: v9fs_string_free(&name); complete_pdu(s, pdu, err); }
--------------------------------------------- Result 1358 ---------------------------------------------
[[0 (75%)]] --> [[0 (39%)]] --> Socre: 0.608795553445816

[[[[Adv]]]]: static void truespeech_apply_twopoint_filter(TSContext *dec, int quart) { int16_t tmp[146 + 60], *ptr0, *ptr1; const int16_t *[[filter]]; int [[i]], t, off; t = dec->offset2[quart]; if(t == 127){ memset(dec->newvec, 0, 60 * sizeof(*dec->newvec)); return; } for([[i]] = 0; [[i]] < 146; [[i]]++) tmp[[[i]]] = dec->filtbuf[[[i]]]; off = (t / 25) + dec->offset1[quart >> 1] + 18; ptr0 = tmp + 145 - off; ptr1 = tmp + 146; [[filter]] = (const int16_t*)ts_order2_coeffs + (t % 25) * 2; for([[i]] = 0; [[i]] < 60; [[i]]++){ t = (ptr0[0] * [[filter]][0] + ptr0[1] * [[filter]][1] + 0x2000) >> 14; ptr0++; dec->newvec[[[i]]] = t; ptr1[[[i]]] = t; } }

[[[[Adv]]]]: static void truespeech_apply_twopoint_filter(TSContext *dec, int quart) { int16_t tmp[146 + 60], *ptr0, *ptr1; const int16_t *[[cleanliness]]; int [[know]], t, off; t = dec->offset2[quart]; if(t == 127){ memset(dec->newvec, 0, 60 * sizeof(*dec->newvec)); return; } for([[know]] = 0; [[know]] < 146; [[know]]++) tmp[[[know]]] = dec->filtbuf[[[know]]]; off = (t / 25) + dec->offset1[quart >> 1] + 18; ptr0 = tmp + 145 - off; ptr1 = tmp + 146; [[cleanliness]] = (const int16_t*)ts_order2_coeffs + (t % 25) * 2; for([[know]] = 0; [[know]] < 60; [[know]]++){ t = (ptr0[0] * [[cleanliness]][0] + ptr0[1] * [[cleanliness]][1] + 0x2000) >> 14; ptr0++; dec->newvec[[[know]]] = t; ptr1[[[know]]] = t; } }
--------------------------------------------- Result 1359 ---------------------------------------------
[[0 (12%)]] --> [[0 (53%)]] --> Socre: 0.5275436639785767

[[[[Adv]]]]: int dxva2_init(AVCodecContext *s) { InputStream *[[ist]] = s->opaque; int loglevel = ([[ist]]->hwaccel_id == HWACCEL_AUTO) ? AV_LOG_VERBOSE : AV_LOG_ERROR; DXVA2Context *ctx; int [[ret]]; if (![[ist]]->hwaccel_ctx) { [[ret]] = dxva2_alloc(s); if ([[ret]] < 0) return [[ret]]; } ctx = [[ist]]->hwaccel_ctx; if (s->codec_id == AV_CODEC_ID_H264 && (s->profile & ~FF_PROFILE_H264_CONSTRAINED) > FF_PROFILE_H264_HIGH) { av_log(NULL, loglevel, "Unsupported H.264 profile for DXVA2 HWAccel: %d\n", s->profile); return AVERROR(EINVAL); } if (s->codec_id == AV_CODEC_ID_HEVC && s->profile != FF_PROFILE_HEVC_MAIN && s->profile != FF_PROFILE_HEVC_MAIN_10) { av_log(NULL, loglevel, "Unsupported HEVC profile for DXVA2 HWAccel: %d\n", s->profile); return AVERROR(EINVAL); } av_buffer_unref(&ctx->hw_frames_ctx); [[ret]] = dxva2_create_decoder(s); if ([[ret]] < 0) { av_log(NULL, loglevel, "Error creating the DXVA2 decoder\n"); return [[ret]]; } return 0; }

[[[[Adv]]]]: int dxva2_init(AVCodecContext *s) { InputStream *[[se]] = s->opaque; int loglevel = ([[se]]->hwaccel_id == HWACCEL_AUTO) ? AV_LOG_VERBOSE : AV_LOG_ERROR; DXVA2Context *ctx; int [[retreating]]; if (![[se]]->hwaccel_ctx) { [[retreating]] = dxva2_alloc(s); if ([[retreating]] < 0) return [[retreating]]; } ctx = [[se]]->hwaccel_ctx; if (s->codec_id == AV_CODEC_ID_H264 && (s->profile & ~FF_PROFILE_H264_CONSTRAINED) > FF_PROFILE_H264_HIGH) { av_log(NULL, loglevel, "Unsupported H.264 profile for DXVA2 HWAccel: %d\n", s->profile); return AVERROR(EINVAL); } if (s->codec_id == AV_CODEC_ID_HEVC && s->profile != FF_PROFILE_HEVC_MAIN && s->profile != FF_PROFILE_HEVC_MAIN_10) { av_log(NULL, loglevel, "Unsupported HEVC profile for DXVA2 HWAccel: %d\n", s->profile); return AVERROR(EINVAL); } av_buffer_unref(&ctx->hw_frames_ctx); [[retreating]] = dxva2_create_decoder(s); if ([[retreating]] < 0) { av_log(NULL, loglevel, "Error creating the DXVA2 decoder\n"); return [[retreating]]; } return 0; }
--------------------------------------------- Result 1360 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 801 / 73 / 486 / 1360:  51%|     | 1360/2690 [15:01:50<14:41:56, 39.79s/it][Succeeded / Failed / Skipped / Total] 801 / 73 / 486 / 1360:  51%|     | 1361/2690 [15:03:46<14:42:31, 39.84s/it][Succeeded / Failed / Skipped / Total] 802 / 73 / 486 / 1361:  51%|     | 1361/2690 [15:03:46<14:42:31, 39.84s/it][Succeeded / Failed / Skipped / Total] 802 / 73 / 486 / 1361:  51%|     | 1362/2690 [15:03:46<14:41:12, 39.81s/it][Succeeded / Failed / Skipped / Total] 802 / 73 / 487 / 1362:  51%|     | 1362/2690 [15:03:46<14:41:12, 39.81s/it][Succeeded / Failed / Skipped / Total] 802 / 73 / 487 / 1362:  51%|     | 1363/2690 [15:03:47<14:39:54, 39.79s/it][Succeeded / Failed / Skipped / Total] 802 / 73 / 488 / 1363:  51%|     | 1363/2690 [15:03:47<14:39:54, 39.79s/it][Succeeded / Failed / Skipped / Total] 802 / 73 / 488 / 1363:  51%|     | 1364/2690 [15:03:51<14:38:40, 39.76s/it][Succeeded / Failed / Skipped / Total] 803 / 73 / 488 / 1364:  51%|     | 1364/2690 [15:03:51<14:38:40, 39.76s/it][Succeeded / Failed / Skipped / Total] 803 / 73 / 488 / 1364:  51%|     | 1365/2690 [15:04:03<14:37:34, 39.74s/it][Succeeded / Failed / Skipped / Total] 804 / 73 / 488 / 1365:  51%|     | 1365/2690 [15:04:03<14:37:34, 39.74s/it][Succeeded / Failed / Skipped / Total] 804 / 73 / 488 / 1365:  51%|     | 1366/2690 [15:04:26<14:36:38, 39.73s/it][[0 (8%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int g726_encode_init(AVCodecContext *avctx) { G726Context* c = avctx->priv_data; if (avctx->strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL && avctx->sample_rate != 8000) { av_log(avctx, AV_LOG_ERROR, "Sample rates other than 8kHz are not " "allowed when the compliance level is higher than unofficial. " "Resample or reduce the compliance level.\n"); return AVERROR(EINVAL); } if (avctx->sample_rate <= 0) { av_log(avctx, AV_LOG_ERROR, "Samplerate is invalid\n"); return -1; } if(avctx->channels != 1){ av_log(avctx, AV_LOG_ERROR, "Only mono is supported\n"); return -1; } if (avctx->bit_rate % avctx->sample_rate) { av_log(avctx, AV_LOG_ERROR, "Bitrate - Samplerate combination is invalid\n"); return AVERROR(EINVAL); } c->code_size = (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate; if (c->code_size < 2 || c->code_size > 5) { av_log(avctx, AV_LOG_ERROR, "Invalid number of bits %d\n", c->code_size); return AVERROR(EINVAL); } avctx->bits_per_coded_sample = c->code_size; g726_reset(c, c->code_size - 2); avctx->coded_frame = avcodec_alloc_frame(); if (!avctx->coded_frame) return AVERROR(ENOMEM); avctx->coded_frame->key_frame = 1; avctx->frame_size = ((int[]){ 4096, 2736, 2048, 1640 })[c->code_size - 2]; return 0; }
--------------------------------------------- Result 1361 ---------------------------------------------
[[0 (80%)]] --> [[0 (41%)]] --> Socre: 0.5882856547832489

[[[[Adv]]]]: static int net_slirp_init(VLANState *[[vlan]]) { if (!slirp_inited) { slirp_inited = 1; slirp_init(); } slirp_vc = qemu_new_vlan_client([[vlan]], slirp_receive, NULL); snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), "user redirector"); return 0; }

[[[[Adv]]]]: static int net_slirp_init(VLANState *[[inferred]]) { if (!slirp_inited) { slirp_inited = 1; slirp_init(); } slirp_vc = qemu_new_vlan_client([[inferred]], slirp_receive, NULL); snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), "user redirector"); return 0; }
--------------------------------------------- Result 1362 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void spapr_phb_hot_plug_child(HotplugHandler *plug_handler, DeviceState *plugged_dev, Error **errp) { sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler)); PCIDevice *pdev = PCI_DEVICE(plugged_dev); sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev); Error *local_err = NULL; if (!phb->dr_enabled) { if (plugged_dev->hotplugged) { error_setg(errp, QERR_BUS_NO_HOTPLUG, object_get_typename(OBJECT(phb))); } return; } g_assert(drc); spapr_phb_add_pci_device(drc, phb, pdev, &local_err); if (local_err) { error_propagate(errp, local_err); return; } if (plugged_dev->hotplugged) { spapr_hotplug_req_add_by_index(drc); } }
--------------------------------------------- Result 1363 ---------------------------------------------
[[0 (100%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: av_cold int ff_dvvideo_init(AVCodecContext *avctx) { DVVideoContext *s = avctx->priv_data; DSPContext dsp; static int done = 0; int i, j; if (!done) { VLC dv_vlc; uint16_t new_dv_vlc_bits[NB_DV_VLC*2]; uint8_t new_dv_vlc_len[NB_DV_VLC*2]; uint8_t new_dv_vlc_run[NB_DV_VLC*2]; int16_t new_dv_vlc_level[NB_DV_VLC*2]; done = 1; for (i = 0, j = 0; i < NB_DV_VLC; i++, j++) { new_dv_vlc_bits[j] = dv_vlc_bits[i]; new_dv_vlc_len[j] = dv_vlc_len[i]; new_dv_vlc_run[j] = dv_vlc_run[i]; new_dv_vlc_level[j] = dv_vlc_level[i]; if (dv_vlc_level[i]) { new_dv_vlc_bits[j] <<= 1; new_dv_vlc_len[j]++; j++; new_dv_vlc_bits[j] = (dv_vlc_bits[i] << 1) | 1; new_dv_vlc_len[j] = dv_vlc_len[i] + 1; new_dv_vlc_run[j] = dv_vlc_run[i]; new_dv_vlc_level[j] = -dv_vlc_level[i]; } } init_vlc(&dv_vlc, TEX_VLC_BITS, j, new_dv_vlc_len, 1, 1, new_dv_vlc_bits, 2, 2, 0); assert(dv_vlc.table_size == 1184); for (i = 0; i < dv_vlc.table_size; i++){ int code = dv_vlc.table[i][0]; int len = dv_vlc.table[i][1]; int level, run; if (len < 0){ run = 0; level = code; } else { run = new_dv_vlc_run [code] + 1; level = new_dv_vlc_level[code]; } ff_dv_rl_vlc[i].len = len; ff_dv_rl_vlc[i].level = level; ff_dv_rl_vlc[i].run = run; } ff_free_vlc(&dv_vlc); } ff_dsputil_init(&dsp, avctx); ff_set_cmp(&dsp, dsp.ildct_cmp, avctx->ildct_cmp); s->get_pixels = dsp.get_pixels; s->ildct_cmp = dsp.ildct_cmp[5]; s->fdct[0] = dsp.fdct; s->idct_put[0] = dsp.idct_put; for (i = 0; i < 64; i++) s->dv_zigzag[0][i] = dsp.idct_permutation[ff_zigzag_direct[i]]; s->fdct[1] = dsp.fdct248; s->idct_put[1] = ff_simple_idct248_put; memcpy(s->dv_zigzag[1], ff_zigzag248_direct, 64); avctx->coded_frame = &s->picture; s->avctx = avctx; avctx->chroma_sample_location = AVCHROMA_LOC_TOPLEFT; return 0; }
--------------------------------------------- Result 1364 ---------------------------------------------
[[0 (71%)]] --> [[0 (50%)]] --> Socre: 0.5001859664916992

[[[[Adv]]]]: static int dv_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags) { RawDVContext *[[r]] = s->priv_data; DVDemuxContext *c = [[r]]->dv_demux; int64_t offset = dv_frame_offset(s, c, timestamp, flags); dv_offset_reset(c, offset / c->sys->frame_size); offset = avio_seek(s->pb, offset, SEEK_SET); return (offset < 0) ? offset : 0; }

[[[[Adv]]]]: static int dv_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags) { RawDVContext *[[phosphorous]] = s->priv_data; DVDemuxContext *c = [[phosphorous]]->dv_demux; int64_t offset = dv_frame_offset(s, c, timestamp, flags); dv_offset_reset(c, offset / c->sys->frame_size); offset = avio_seek(s->pb, offset, SEEK_SET); return (offset < 0) ? offset : 0; }
--------------------------------------------- Result 1365 ---------------------------------------------
[[0 (30%)]] --> [[0 (62%)]] --> Socre: 0.6169299483299255

[[[[Adv]]]]: static int add_old_style_options(const char *fmt, QemuOpts *opts, const char *base_filename, const char *[[base_fmt]]) { if (base_filename) { if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) { error_report("Backing file not supported for file format '%s'", fmt); return -1; } } if ([[base_fmt]]) { if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, [[base_fmt]])) { error_report("Backing file format not supported for file " "format '%s'", fmt); return -1; } } return 0; }

[[[[Adv]]]]: static int add_old_style_options(const char *fmt, QemuOpts *opts, const char *base_filename, const char *[[clawed]]) { if (base_filename) { if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) { error_report("Backing file not supported for file format '%s'", fmt); return -1; } } if ([[clawed]]) { if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, [[clawed]])) { error_report("Backing file format not supported for file " "format '%s'", fmt); return -1; } } return 0; }
--------------------------------------------- Result 1366 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 805 / 73 / 488 / 1366:  51%|     | 1366/2690 [15:04:26<14:36:38, 39.73s/it][Succeeded / Failed / Skipped / Total] 805 / 73 / 488 / 1366:  51%|     | 1367/2690 [15:04:27<14:35:20, 39.70s/it][Succeeded / Failed / Skipped / Total] 805 / 73 / 489 / 1367:  51%|     | 1367/2690 [15:04:27<14:35:20, 39.70s/it][Succeeded / Failed / Skipped / Total] 805 / 73 / 489 / 1367:  51%|     | 1368/2690 [15:04:38<14:34:13, 39.68s/it][[0 (72%)]] --> [[0 (50%)]] --> Socre: 0.5034426152706146

[[[[Adv]]]]: static int libquvi_read_header(AVFormatContext *[[s]]) { int i, ret; quvi_t q; quvi_media_t m; QUVIcode rc; LibQuviContext *[[qc]] = [[s]]->priv_data; char *[[media_url]], *pagetitle; rc = quvi_init(&q); if (rc != QUVI_OK) goto quvi_fail; quvi_setopt(q, QUVIOPT_FORMAT, [[qc]]->format); rc = quvi_parse(q, [[s]]->filename, &m); if (rc != QUVI_OK) goto quvi_fail; rc = quvi_getprop(m, QUVIPROP_MEDIAURL, &[[media_url]]); if (rc != QUVI_OK) goto quvi_fail; av_assert0(![[qc]]->fmtctx->codec_whitelist && ![[qc]]->fmtctx->format_whitelist); [[qc]]->fmtctx-> codec_whitelist = av_strdup([[s]]->codec_whitelist); [[qc]]->fmtctx->format_whitelist = av_strdup([[s]]->format_whitelist); ret = avformat_open_input(&[[qc]]->fmtctx, [[media_url]], NULL, NULL); if (ret < 0) goto end; rc = quvi_getprop(m, QUVIPROP_PAGETITLE, &pagetitle); if (rc == QUVI_OK) av_dict_set(&[[s]]->metadata, "title", pagetitle, 0); for (i = 0; i < [[qc]]->fmtctx->nb_streams; i++) { AVStream *st = avformat_new_stream([[s]], NULL); AVStream *ist = [[qc]]->fmtctx->streams[i]; if (!st) { ret = AVERROR(ENOMEM); goto end; } avpriv_set_pts_info(st, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den); avcodec_copy_context(st->codec, [[qc]]->fmtctx->streams[i]->codec); } return 0; quvi_fail: av_log([[s]], AV_LOG_ERROR, "%s\n", quvi_strerror(q, rc)); ret = AVERROR_EXTERNAL; end: quvi_parse_close(&m); quvi_close(&q); return ret; }

[[[[Adv]]]]: static int libquvi_read_header(AVFormatContext *[[d]]) { int i, ret; quvi_t q; quvi_media_t m; QUVIcode rc; LibQuviContext *[[calgary]] = [[d]]->priv_data; char *[[beckon]], *pagetitle; rc = quvi_init(&q); if (rc != QUVI_OK) goto quvi_fail; quvi_setopt(q, QUVIOPT_FORMAT, [[calgary]]->format); rc = quvi_parse(q, [[d]]->filename, &m); if (rc != QUVI_OK) goto quvi_fail; rc = quvi_getprop(m, QUVIPROP_MEDIAURL, &[[beckon]]); if (rc != QUVI_OK) goto quvi_fail; av_assert0(![[calgary]]->fmtctx->codec_whitelist && ![[calgary]]->fmtctx->format_whitelist); [[calgary]]->fmtctx-> codec_whitelist = av_strdup([[d]]->codec_whitelist); [[calgary]]->fmtctx->format_whitelist = av_strdup([[d]]->format_whitelist); ret = avformat_open_input(&[[calgary]]->fmtctx, [[beckon]], NULL, NULL); if (ret < 0) goto end; rc = quvi_getprop(m, QUVIPROP_PAGETITLE, &pagetitle); if (rc == QUVI_OK) av_dict_set(&[[d]]->metadata, "title", pagetitle, 0); for (i = 0; i < [[calgary]]->fmtctx->nb_streams; i++) { AVStream *st = avformat_new_stream([[d]], NULL); AVStream *ist = [[calgary]]->fmtctx->streams[i]; if (!st) { ret = AVERROR(ENOMEM); goto end; } avpriv_set_pts_info(st, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den); avcodec_copy_context(st->codec, [[calgary]]->fmtctx->streams[i]->codec); } return 0; quvi_fail: av_log([[d]], AV_LOG_ERROR, "%s\n", quvi_strerror(q, rc)); ret = AVERROR_EXTERNAL; end: quvi_parse_close(&m); quvi_close(&q); return ret; }
--------------------------------------------- Result 1367 ---------------------------------------------
[[0 (4%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: LF_FUNC (h, luma, sse2) LF_IFUNC(h, luma_intra, sse2) LF_FUNC (v, luma, sse2) LF_IFUNC(v, luma_intra, sse2) #define H264_WEIGHT(W, H, OPT) \ void ff_h264_weight_ ## W ## x ## H ## _ ## OPT(uint8_t *dst, \ int stride, int log2_denom, int weight, int offset); #define H264_BIWEIGHT(W, H, OPT) \ void ff_h264_biweight_ ## W ## x ## H ## _ ## OPT(uint8_t *dst, \ uint8_t *src, int stride, int log2_denom, int weightd, \ int weights, int offset); #define H264_BIWEIGHT_MMX(W,H) \ H264_WEIGHT (W, H, mmx2) \ H264_BIWEIGHT(W, H, mmx2) #define H264_BIWEIGHT_MMX_SSE(W,H) \ H264_BIWEIGHT_MMX(W, H) \ H264_WEIGHT (W, H, sse2) \ H264_BIWEIGHT (W, H, sse2) \ H264_BIWEIGHT (W, H, ssse3) H264_BIWEIGHT_MMX_SSE(16, 16) H264_BIWEIGHT_MMX_SSE(16, 8) H264_BIWEIGHT_MMX_SSE( 8, 16) H264_BIWEIGHT_MMX_SSE( 8, 8) H264_BIWEIGHT_MMX_SSE( 8, 4) H264_BIWEIGHT_MMX ( 4, 8) H264_BIWEIGHT_MMX ( 4, 4) H264_BIWEIGHT_MMX ( 4, 2) void ff_h264dsp_init_x86(H264DSPContext *c) { int mm_flags = av_get_cpu_flags(); if (mm_flags & AV_CPU_FLAG_MMX2) { c->h264_loop_filter_strength= h264_loop_filter_strength_mmx2; } #if HAVE_YASM if (mm_flags & AV_CPU_FLAG_MMX) { c->h264_idct_dc_add= c->h264_idct_add= ff_h264_idct_add_mmx; c->h264_idct8_dc_add= c->h264_idct8_add= ff_h264_idct8_add_mmx; c->h264_idct_add16 = ff_h264_idct_add16_mmx; c->h264_idct8_add4 = ff_h264_idct8_add4_mmx; c->h264_idct_add8 = ff_h264_idct_add8_mmx; c->h264_idct_add16intra= ff_h264_idct_add16intra_mmx; if (mm_flags & AV_CPU_FLAG_MMX2) { c->h264_idct_dc_add= ff_h264_idct_dc_add_mmx2; c->h264_idct8_dc_add= ff_h264_idct8_dc_add_mmx2; c->h264_idct_add16 = ff_h264_idct_add16_mmx2; c->h264_idct8_add4 = ff_h264_idct8_add4_mmx2; c->h264_idct_add8 = ff_h264_idct_add8_mmx2; c->h264_idct_add16intra= ff_h264_idct_add16intra_mmx2; c->h264_v_loop_filter_chroma= ff_x264_deblock_v_chroma_mmxext; c->h264_h_loop_filter_chroma= ff_x264_deblock_h_chroma_mmxext; c->h264_v_loop_filter_chroma_intra= ff_x264_deblock_v_chroma_intra_mmxext; c->h264_h_loop_filter_chroma_intra= ff_x264_deblock_h_chroma_intra_mmxext; #if ARCH_X86_32 c->h264_v_loop_filter_luma= ff_x264_deblock_v_luma_mmxext; c->h264_h_loop_filter_luma= ff_x264_deblock_h_luma_mmxext; c->h264_v_loop_filter_luma_intra = ff_x264_deblock_v_luma_intra_mmxext; c->h264_h_loop_filter_luma_intra = ff_x264_deblock_h_luma_intra_mmxext; c->weight_h264_pixels_tab[0]= ff_h264_weight_16x16_mmx2; c->weight_h264_pixels_tab[1]= ff_h264_weight_16x8_mmx2; c->weight_h264_pixels_tab[2]= ff_h264_weight_8x16_mmx2; c->weight_h264_pixels_tab[3]= ff_h264_weight_8x8_mmx2; c->weight_h264_pixels_tab[4]= ff_h264_weight_8x4_mmx2; c->weight_h264_pixels_tab[5]= ff_h264_weight_4x8_mmx2; c->weight_h264_pixels_tab[6]= ff_h264_weight_4x4_mmx2; c->weight_h264_pixels_tab[7]= ff_h264_weight_4x2_mmx2; c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_mmx2; c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_mmx2; c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_mmx2; c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_mmx2; c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_mmx2; c->biweight_h264_pixels_tab[5]= ff_h264_biweight_4x8_mmx2; c->biweight_h264_pixels_tab[6]= ff_h264_biweight_4x4_mmx2; c->biweight_h264_pixels_tab[7]= ff_h264_biweight_4x2_mmx2; if (mm_flags&AV_CPU_FLAG_SSE2) { c->h264_idct8_add = ff_h264_idct8_add_sse2; c->h264_idct8_add4= ff_h264_idct8_add4_sse2; c->weight_h264_pixels_tab[0]= ff_h264_weight_16x16_sse2; c->weight_h264_pixels_tab[1]= ff_h264_weight_16x8_sse2; c->weight_h264_pixels_tab[2]= ff_h264_weight_8x16_sse2; c->weight_h264_pixels_tab[3]= ff_h264_weight_8x8_sse2; c->weight_h264_pixels_tab[4]= ff_h264_weight_8x4_sse2; c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_sse2; c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_sse2; c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_sse2; c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_sse2; c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_sse2; c->h264_v_loop_filter_luma = ff_x264_deblock_v_luma_sse2; c->h264_h_loop_filter_luma = ff_x264_deblock_h_luma_sse2; c->h264_v_loop_filter_luma_intra = ff_x264_deblock_v_luma_intra_sse2; c->h264_h_loop_filter_luma_intra = ff_x264_deblock_h_luma_intra_sse2; c->h264_idct_add16 = ff_h264_idct_add16_sse2; c->h264_idct_add8 = ff_h264_idct_add8_sse2; c->h264_idct_add16intra = ff_h264_idct_add16intra_sse2; } if (mm_flags&AV_CPU_FLAG_SSSE3) { c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_ssse3; c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_ssse3; c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_ssse3; c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_ssse3; c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_ssse3; } } } }
--------------------------------------------- Result 1368 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 806 / 73 / 489 / 1368:  51%|     | 1368/2690 [15:04:38<14:34:13, 39.68s/it][Succeeded / Failed / Skipped / Total] 806 / 73 / 489 / 1368:  51%|     | 1369/2690 [15:04:55<14:33:11, 39.66s/it][[0 (6%)]] --> [[0 (50%)]] --> Socre: 0.5008952021598816

[[[[Adv]]]]: static XenPTBarFlag xen_pt_bar_reg_parse(XenPCIPassthroughState *[[s]], XenPTRegInfo *reg) { PCIDevice *d = &[[s]]->dev; XenPTRegion *[[region]] = NULL; PCIIORegion *r; int index = 0; index = xen_pt_bar_offset_to_index(reg->offset); if ((0 < index) && (index < PCI_ROM_SLOT)) { int [[type]] = [[s]]->real_device.io_regions[index - 1].type; if (([[type]] & XEN_HOST_PCI_REGION_TYPE_MEM) && ([[type]] & XEN_HOST_PCI_REGION_TYPE_MEM_64)) { [[region]] = &[[s]]->bases[index - 1]; if ([[region]]->bar_flag != XEN_PT_BAR_FLAG_UPPER) { return XEN_PT_BAR_FLAG_UPPER; } } } r = &d->io_regions[index]; if (!xen_pt_get_bar_size(r)) { return XEN_PT_BAR_FLAG_UNUSED; } if (index == PCI_ROM_SLOT) { return XEN_PT_BAR_FLAG_MEM; } if ([[s]]->real_device.io_regions[index].type & XEN_HOST_PCI_REGION_TYPE_IO) { return XEN_PT_BAR_FLAG_IO; } else { return XEN_PT_BAR_FLAG_MEM; } }

[[[[Adv]]]]: static XenPTBarFlag xen_pt_bar_reg_parse(XenPCIPassthroughState *[[secs]], XenPTRegInfo *reg) { PCIDevice *d = &[[secs]]->dev; XenPTRegion *[[realms]] = NULL; PCIIORegion *r; int index = 0; index = xen_pt_bar_offset_to_index(reg->offset); if ((0 < index) && (index < PCI_ROM_SLOT)) { int [[guys]] = [[secs]]->real_device.io_regions[index - 1].type; if (([[guys]] & XEN_HOST_PCI_REGION_TYPE_MEM) && ([[guys]] & XEN_HOST_PCI_REGION_TYPE_MEM_64)) { [[realms]] = &[[secs]]->bases[index - 1]; if ([[realms]]->bar_flag != XEN_PT_BAR_FLAG_UPPER) { return XEN_PT_BAR_FLAG_UPPER; } } } r = &d->io_regions[index]; if (!xen_pt_get_bar_size(r)) { return XEN_PT_BAR_FLAG_UNUSED; } if (index == PCI_ROM_SLOT) { return XEN_PT_BAR_FLAG_MEM; } if ([[secs]]->real_device.io_regions[index].type & XEN_HOST_PCI_REGION_TYPE_IO) { return XEN_PT_BAR_FLAG_IO; } else { return XEN_PT_BAR_FLAG_MEM; } }
--------------------------------------------- Result 1369 ---------------------------------------------
[[0 (38%)]] --> [[0 (96%)]] --> Socre: 0.9604805707931519

[[[[Adv]]]]: long do_syscall(void *[[cpu_env]], int num, long arg1, long arg2, long arg3, long arg4, long arg5, long arg6) { long ret; struct stat st; struct kernel_statfs *stfs; #ifdef DEBUG gemu_log("syscall %d\n", num); #endif switch(num) { case TARGET_NR_exit: #ifdef HAVE_GPROF _mcleanup(); #endif _exit(arg1); ret = 0; break; case TARGET_NR_read: ret = get_errno(read(arg1, (void *)arg2, arg3)); break; case TARGET_NR_write: ret = get_errno(write(arg1, (void *)arg2, arg3)); break; case TARGET_NR_open: ret = get_errno(open((const char *)arg1, arg2, arg3)); break; case TARGET_NR_close: ret = get_errno(close(arg1)); break; case TARGET_NR_brk: ret = do_brk((char *)arg1); break; case TARGET_NR_fork: ret = get_errno(fork()); break; case TARGET_NR_waitpid: { int *status = (int *)arg2; ret = get_errno(waitpid(arg1, status, arg3)); if (!is_error(ret) && status) tswapls((long *)&status); } break; case TARGET_NR_creat: ret = get_errno(creat((const char *)arg1, arg2)); break; case TARGET_NR_link: ret = get_errno(link((const char *)arg1, (const char *)arg2)); break; case TARGET_NR_unlink: ret = get_errno(unlink((const char *)arg1)); break; case TARGET_NR_execve: ret = get_errno(execve((const char *)arg1, (void *)arg2, (void *)arg3)); break; case TARGET_NR_chdir: ret = get_errno(chdir((const char *)arg1)); break; case TARGET_NR_time: { int *time_ptr = (int *)arg1; ret = get_errno(time((time_t *)time_ptr)); if (!is_error(ret) && time_ptr) tswap32s(time_ptr); } break; case TARGET_NR_mknod: ret = get_errno(mknod((const char *)arg1, arg2, arg3)); break; case TARGET_NR_chmod: ret = get_errno(chmod((const char *)arg1, arg2)); break; case TARGET_NR_lchown: ret = get_errno(chown((const char *)arg1, arg2, arg3)); break; case TARGET_NR_break: goto unimplemented; case TARGET_NR_oldstat: goto unimplemented; case TARGET_NR_lseek: ret = get_errno(lseek(arg1, arg2, arg3)); break; case TARGET_NR_getpid: ret = get_errno(getpid()); break; case TARGET_NR_mount: goto unimplemented; case TARGET_NR_umount: ret = get_errno(umount((const char *)arg1)); break; case TARGET_NR_setuid: ret = get_errno(setuid(arg1)); break; case TARGET_NR_getuid: ret = get_errno(getuid()); break; case TARGET_NR_stime: { int *time_ptr = (int *)arg1; if (time_ptr) tswap32s(time_ptr); ret = get_errno(stime((time_t *)time_ptr)); } break; case TARGET_NR_ptrace: goto unimplemented; case TARGET_NR_alarm: ret = alarm(arg1); break; case TARGET_NR_oldfstat: goto unimplemented; case TARGET_NR_pause: ret = get_errno(pause()); break; case TARGET_NR_utime: goto unimplemented; case TARGET_NR_stty: goto unimplemented; case TARGET_NR_gtty: goto unimplemented; case TARGET_NR_access: ret = get_errno(access((const char *)arg1, arg2)); break; case TARGET_NR_nice: ret = get_errno(nice(arg1)); break; case TARGET_NR_ftime: goto unimplemented; case TARGET_NR_sync: ret = get_errno(sync()); break; case TARGET_NR_kill: ret = get_errno(kill(arg1, arg2)); break; case TARGET_NR_rename: ret = get_errno(rename((const char *)arg1, (const char *)arg2)); break; case TARGET_NR_mkdir: ret = get_errno(mkdir((const char *)arg1, arg2)); break; case TARGET_NR_rmdir: ret = get_errno(rmdir((const char *)arg1)); break; case TARGET_NR_dup: ret = get_errno(dup(arg1)); break; case TARGET_NR_pipe: { int *pipe_ptr = (int *)arg1; ret = get_errno(pipe(pipe_ptr)); if (!is_error(ret)) { tswap32s(&pipe_ptr[0]); tswap32s(&pipe_ptr[1]); } } break; case TARGET_NR_times: goto unimplemented; case TARGET_NR_prof: goto unimplemented; case TARGET_NR_setgid: ret = get_errno(setgid(arg1)); break; case TARGET_NR_getgid: ret = get_errno(getgid()); break; case TARGET_NR_signal: goto unimplemented; case TARGET_NR_geteuid: ret = get_errno(geteuid()); break; case TARGET_NR_getegid: ret = get_errno(getegid()); break; case TARGET_NR_acct: goto unimplemented; case TARGET_NR_umount2: ret = get_errno(umount2((const char *)arg1, arg2)); break; case TARGET_NR_lock: goto unimplemented; case TARGET_NR_ioctl: ret = do_ioctl(arg1, arg2, arg3); break; case TARGET_NR_fcntl: switch(arg2) { case F_GETLK: case F_SETLK: case F_SETLKW: goto unimplemented; default: ret = get_errno(fcntl(arg1, arg2, arg3)); break; } break; case TARGET_NR_mpx: goto unimplemented; case TARGET_NR_setpgid: ret = get_errno(setpgid(arg1, arg2)); break; case TARGET_NR_ulimit: goto unimplemented; case TARGET_NR_oldolduname: goto unimplemented; case TARGET_NR_umask: ret = get_errno(umask(arg1)); break; case TARGET_NR_chroot: ret = get_errno(chroot((const char *)arg1)); break; case TARGET_NR_ustat: goto unimplemented; case TARGET_NR_dup2: ret = get_errno(dup2(arg1, arg2)); break; case TARGET_NR_getppid: ret = get_errno(getppid()); break; case TARGET_NR_getpgrp: ret = get_errno(getpgrp()); break; case TARGET_NR_setsid: ret = get_errno(setsid()); break; case TARGET_NR_sigaction: #if 0 { int signum = arg1; struct target_old_sigaction *tact = arg2, *toldact = arg3; ret = get_errno(setsid()); } break; #else goto unimplemented; #endif case TARGET_NR_sgetmask: goto unimplemented; case TARGET_NR_ssetmask: goto unimplemented; case TARGET_NR_setreuid: ret = get_errno(setreuid(arg1, arg2)); break; case TARGET_NR_setregid: ret = get_errno(setregid(arg1, arg2)); break; case TARGET_NR_sigsuspend: goto unimplemented; case TARGET_NR_sigpending: goto unimplemented; case TARGET_NR_sethostname: ret = get_errno(sethostname((const char *)arg1, arg2)); break; case TARGET_NR_setrlimit: goto unimplemented; case TARGET_NR_getrlimit: goto unimplemented; case TARGET_NR_getrusage: goto unimplemented; case TARGET_NR_gettimeofday: { struct target_timeval *target_tv = (void *)arg1; struct timeval tv; ret = get_errno(gettimeofday(&tv, NULL)); if (!is_error(ret)) { target_tv->tv_sec = tswapl(tv.tv_sec); target_tv->tv_usec = tswapl(tv.tv_usec); } } break; case TARGET_NR_settimeofday: { struct target_timeval *target_tv = (void *)arg1; struct timeval tv; tv.tv_sec = tswapl(target_tv->tv_sec); tv.tv_usec = tswapl(target_tv->tv_usec); ret = get_errno(settimeofday(&tv, NULL)); } break; case TARGET_NR_getgroups: goto unimplemented; case TARGET_NR_setgroups: goto unimplemented; case TARGET_NR_select: goto unimplemented; case TARGET_NR_symlink: ret = get_errno(symlink((const char *)arg1, (const char *)arg2)); break; case TARGET_NR_oldlstat: goto unimplemented; case TARGET_NR_readlink: ret = get_errno(readlink((const char *)arg1, (char *)arg2, arg3)); break; case TARGET_NR_uselib: goto unimplemented; case TARGET_NR_swapon: ret = get_errno(swapon((const char *)arg1, arg2)); break; case TARGET_NR_reboot: goto unimplemented; case TARGET_NR_readdir: goto unimplemented; #ifdef TARGET_I386 case TARGET_NR_mmap: { uint32_t v1, v2, v3, v4, v5, v6, *vptr; vptr = (uint32_t *)arg1; v1 = tswap32(vptr[0]); v2 = tswap32(vptr[1]); v3 = tswap32(vptr[2]); v4 = tswap32(vptr[3]); v5 = tswap32(vptr[4]); v6 = tswap32(vptr[5]); ret = get_errno((long)mmap((void *)v1, v2, v3, v4, v5, v6)); } break; #endif #ifdef TARGET_I386 case TARGET_NR_mmap2: #else case TARGET_NR_mmap: #endif ret = get_errno((long)mmap((void *)arg1, arg2, arg3, arg4, arg5, arg6)); break; case TARGET_NR_munmap: ret = get_errno(munmap((void *)arg1, arg2)); break; case TARGET_NR_truncate: ret = get_errno(truncate((const char *)arg1, arg2)); break; case TARGET_NR_ftruncate: ret = get_errno(ftruncate(arg1, arg2)); break; case TARGET_NR_fchmod: ret = get_errno(fchmod(arg1, arg2)); break; case TARGET_NR_fchown: ret = get_errno(fchown(arg1, arg2, arg3)); break; case TARGET_NR_getpriority: ret = get_errno(getpriority(arg1, arg2)); break; case TARGET_NR_setpriority: ret = get_errno(setpriority(arg1, arg2, arg3)); break; case TARGET_NR_profil: goto unimplemented; case TARGET_NR_statfs: stfs = (void *)arg2; ret = get_errno(sys_statfs((const char *)arg1, stfs)); convert_statfs: if (!is_error(ret)) { tswap32s(&stfs->f_type); tswap32s(&stfs->f_bsize); tswap32s(&stfs->f_blocks); tswap32s(&stfs->f_bfree); tswap32s(&stfs->f_bavail); tswap32s(&stfs->f_files); tswap32s(&stfs->f_ffree); tswap32s(&stfs->f_fsid.val[0]); tswap32s(&stfs->f_fsid.val[1]); tswap32s(&stfs->f_namelen); } break; case TARGET_NR_fstatfs: stfs = (void *)arg2; ret = get_errno(sys_fstatfs(arg1, stfs)); goto convert_statfs; case TARGET_NR_ioperm: goto unimplemented; case TARGET_NR_socketcall: ret = do_socketcall(arg1, (long *)arg2); break; case TARGET_NR_syslog: goto unimplemented; case TARGET_NR_setitimer: goto unimplemented; case TARGET_NR_getitimer: goto unimplemented; case TARGET_NR_stat: ret = get_errno(stat((const char *)arg1, &st)); goto do_stat; case TARGET_NR_lstat: ret = get_errno(lstat((const char *)arg1, &st)); goto do_stat; case TARGET_NR_fstat: { ret = get_errno(fstat(arg1, &st)); do_stat: if (!is_error(ret)) { struct target_stat *target_st = (void *)arg2; target_st->st_dev = tswap16(st.st_dev); target_st->st_ino = tswapl(st.st_ino); target_st->st_mode = tswap16(st.st_mode); target_st->st_nlink = tswap16(st.st_nlink); target_st->st_uid = tswap16(st.st_uid); target_st->st_gid = tswap16(st.st_gid); target_st->st_rdev = tswap16(st.st_rdev); target_st->st_size = tswapl(st.st_size); target_st->st_blksize = tswapl(st.st_blksize); target_st->st_blocks = tswapl(st.st_blocks); target_st->st_atime = tswapl(st.st_atime); target_st->st_mtime = tswapl(st.st_mtime); target_st->st_ctime = tswapl(st.st_ctime); } } break; case TARGET_NR_olduname: goto unimplemented; case TARGET_NR_iopl: goto unimplemented; case TARGET_NR_vhangup: ret = get_errno(vhangup()); break; case TARGET_NR_idle: goto unimplemented; case TARGET_NR_vm86old: goto unimplemented; case TARGET_NR_wait4: { int status; target_long *status_ptr = (void *)arg2; struct rusage rusage, *rusage_ptr; struct target_rusage *target_rusage = (void *)arg4; if (target_rusage) rusage_ptr = &rusage; else rusage_ptr = NULL; ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr)); if (!is_error(ret)) { if (status_ptr) *status_ptr = tswap32(status); if (target_rusage) { target_rusage->ru_utime.tv_sec = tswapl(rusage.ru_utime.tv_sec); target_rusage->ru_utime.tv_usec = tswapl(rusage.ru_utime.tv_usec); target_rusage->ru_stime.tv_sec = tswapl(rusage.ru_stime.tv_sec); target_rusage->ru_stime.tv_usec = tswapl(rusage.ru_stime.tv_usec); target_rusage->ru_maxrss = tswapl(rusage.ru_maxrss); target_rusage->ru_ixrss = tswapl(rusage.ru_ixrss); target_rusage->ru_idrss = tswapl(rusage.ru_idrss); target_rusage->ru_isrss = tswapl(rusage.ru_isrss); target_rusage->ru_minflt = tswapl(rusage.ru_minflt); target_rusage->ru_majflt = tswapl(rusage.ru_majflt); target_rusage->ru_nswap = tswapl(rusage.ru_nswap); target_rusage->ru_inblock = tswapl(rusage.ru_inblock); target_rusage->ru_oublock = tswapl(rusage.ru_oublock); target_rusage->ru_msgsnd = tswapl(rusage.ru_msgsnd); target_rusage->ru_msgrcv = tswapl(rusage.ru_msgrcv); target_rusage->ru_nsignals = tswapl(rusage.ru_nsignals); target_rusage->ru_nvcsw = tswapl(rusage.ru_nvcsw); target_rusage->ru_nivcsw = tswapl(rusage.ru_nivcsw); } } } break; case TARGET_NR_swapoff: ret = get_errno(swapoff((const char *)arg1)); break; case TARGET_NR_sysinfo: goto unimplemented; case TARGET_NR_ipc: goto unimplemented; case TARGET_NR_fsync: ret = get_errno(fsync(arg1)); break; case TARGET_NR_sigreturn: goto unimplemented; case TARGET_NR_clone: goto unimplemented; case TARGET_NR_setdomainname: ret = get_errno(setdomainname((const char *)arg1, arg2)); break; case TARGET_NR_uname: ret = get_errno(sys_uname((struct new_utsname *)arg1)); break; #ifdef TARGET_I386 case TARGET_NR_modify_ldt: ret = get_errno(gemu_modify_ldt([[cpu_env]], arg1, (void *)arg2, arg3)); break; #endif case TARGET_NR_adjtimex: goto unimplemented; case TARGET_NR_mprotect: ret = get_errno(mprotect((void *)arg1, arg2, arg3)); break; case TARGET_NR_sigprocmask: { int how = arg1; sigset_t set, oldset, *set_ptr; target_ulong *pset = (void *)arg2, *poldset = (void *)arg3; switch(how) { case TARGET_SIG_BLOCK: how = SIG_BLOCK; break; case TARGET_SIG_UNBLOCK: how = SIG_UNBLOCK; break; case TARGET_SIG_SETMASK: how = SIG_SETMASK; break; default: ret = -EINVAL; goto fail; } if (pset) { target_to_host_old_sigset(&set, pset); set_ptr = &set; } else { set_ptr = NULL; } ret = get_errno(sigprocmask(arg1, set_ptr, &oldset)); if (!is_error(ret) && poldset) { host_to_target_old_sigset(poldset, &oldset); } } break; case TARGET_NR_create_module: case TARGET_NR_init_module: case TARGET_NR_delete_module: case TARGET_NR_get_kernel_syms: goto unimplemented; case TARGET_NR_quotactl: goto unimplemented; case TARGET_NR_getpgid: ret = get_errno(getpgid(arg1)); break; case TARGET_NR_fchdir: ret = get_errno(fchdir(arg1)); break; case TARGET_NR_bdflush: goto unimplemented; case TARGET_NR_sysfs: goto unimplemented; case TARGET_NR_personality: ret = get_errno(mprotect((void *)arg1, arg2, arg3)); break; case TARGET_NR_afs_syscall: goto unimplemented; case TARGET_NR_setfsuid: goto unimplemented; case TARGET_NR_setfsgid: goto unimplemented; case TARGET_NR__llseek: { int64_t res; ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5)); *(int64_t *)arg4 = tswap64(res); } break; case TARGET_NR_getdents: #if TARGET_LONG_SIZE != 4 #error not supported #endif { struct dirent *dirp = (void *)arg2; long count = arg3; ret = get_errno(sys_getdents(arg1, dirp, count)); if (!is_error(ret)) { struct dirent *de; int len = ret; int reclen; de = dirp; while (len > 0) { reclen = tswap16(de->d_reclen); if (reclen > len) break; de->d_reclen = reclen; tswapls(&de->d_ino); tswapls(&de->d_off); de = (struct dirent *)((char *)de + reclen); len -= reclen; } } } break; case TARGET_NR__newselect: ret = do_select(arg1, (void *)arg2, (void *)arg3, (void *)arg4, (void *)arg5); break; case TARGET_NR_flock: goto unimplemented; case TARGET_NR_msync: ret = get_errno(msync((void *)arg1, arg2, arg3)); break; case TARGET_NR_readv: { int count = arg3; int i; struct iovec *vec; struct target_iovec *target_vec = (void *)arg2; vec = alloca(count * sizeof(struct iovec)); for(i = 0;i < count; i++) { vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base); vec[i].iov_len = tswapl(target_vec[i].iov_len); } ret = get_errno(readv(arg1, vec, count)); } break; case TARGET_NR_writev: { int count = arg3; int i; struct iovec *vec; struct target_iovec *target_vec = (void *)arg2; vec = alloca(count * sizeof(struct iovec)); for(i = 0;i < count; i++) { vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base); vec[i].iov_len = tswapl(target_vec[i].iov_len); } ret = get_errno(writev(arg1, vec, count)); } break; case TARGET_NR_getsid: ret = get_errno(getsid(arg1)); break; case TARGET_NR_fdatasync: goto unimplemented; case TARGET_NR__sysctl: goto unimplemented; case TARGET_NR_mlock: ret = get_errno(mlock((void *)arg1, arg2)); break; case TARGET_NR_munlock: ret = get_errno(munlock((void *)arg1, arg2)); break; case TARGET_NR_mlockall: ret = get_errno(mlockall(arg1)); break; case TARGET_NR_munlockall: ret = get_errno(munlockall()); break; case TARGET_NR_sched_setparam: goto unimplemented; case TARGET_NR_sched_getparam: goto unimplemented; case TARGET_NR_sched_setscheduler: goto unimplemented; case TARGET_NR_sched_getscheduler: goto unimplemented; case TARGET_NR_sched_yield: ret = get_errno(sched_yield()); break; case TARGET_NR_sched_get_priority_max: case TARGET_NR_sched_get_priority_min: case TARGET_NR_sched_rr_get_interval: case TARGET_NR_nanosleep: case TARGET_NR_mremap: case TARGET_NR_setresuid: case TARGET_NR_getresuid: case TARGET_NR_vm86: case TARGET_NR_query_module: case TARGET_NR_poll: case TARGET_NR_nfsservctl: case TARGET_NR_setresgid: case TARGET_NR_getresgid: case TARGET_NR_prctl: case TARGET_NR_rt_sigreturn: case TARGET_NR_rt_sigaction: case TARGET_NR_rt_sigprocmask: case TARGET_NR_rt_sigpending: case TARGET_NR_rt_sigtimedwait: case TARGET_NR_rt_sigqueueinfo: case TARGET_NR_rt_sigsuspend: case TARGET_NR_pread: case TARGET_NR_pwrite: goto unimplemented; case TARGET_NR_chown: ret = get_errno(chown((const char *)arg1, arg2, arg3)); break; case TARGET_NR_getcwd: ret = get_errno(sys_getcwd1((char *)arg1, arg2)); break; case TARGET_NR_capget: case TARGET_NR_capset: case TARGET_NR_sigaltstack: case TARGET_NR_sendfile: case TARGET_NR_getpmsg: case TARGET_NR_putpmsg: case TARGET_NR_vfork: ret = get_errno(vfork()); break; case TARGET_NR_ugetrlimit: case TARGET_NR_truncate64: case TARGET_NR_ftruncate64: case TARGET_NR_stat64: case TARGET_NR_lstat64: case TARGET_NR_fstat64: case TARGET_NR_lchown32: case TARGET_NR_getuid32: case TARGET_NR_getgid32: case TARGET_NR_geteuid32: case TARGET_NR_getegid32: case TARGET_NR_setreuid32: case TARGET_NR_setregid32: case TARGET_NR_getgroups32: case TARGET_NR_setgroups32: case TARGET_NR_fchown32: case TARGET_NR_setresuid32: case TARGET_NR_getresuid32: case TARGET_NR_setresgid32: case TARGET_NR_getresgid32: case TARGET_NR_chown32: case TARGET_NR_setuid32: case TARGET_NR_setgid32: case TARGET_NR_setfsuid32: case TARGET_NR_setfsgid32: case TARGET_NR_pivot_root: case TARGET_NR_mincore: case TARGET_NR_madvise: case TARGET_NR_getdents64: case TARGET_NR_fcntl64: case TARGET_NR_security: goto unimplemented; case TARGET_NR_gettid: ret = get_errno(gettid()); break; case TARGET_NR_readahead: case TARGET_NR_setxattr: case TARGET_NR_lsetxattr: case TARGET_NR_fsetxattr: case TARGET_NR_getxattr: case TARGET_NR_lgetxattr: case TARGET_NR_fgetxattr: case TARGET_NR_listxattr: case TARGET_NR_llistxattr: case TARGET_NR_flistxattr: case TARGET_NR_removexattr: case TARGET_NR_lremovexattr: case TARGET_NR_fremovexattr: goto unimplemented; default: unimplemented: gemu_log("Unsupported syscall: %d\n", num); ret = -ENOSYS; break; } fail: return ret; }

[[[[Adv]]]]: long do_syscall(void *[[sceptre]], int num, long arg1, long arg2, long arg3, long arg4, long arg5, long arg6) { long ret; struct stat st; struct kernel_statfs *stfs; #ifdef DEBUG gemu_log("syscall %d\n", num); #endif switch(num) { case TARGET_NR_exit: #ifdef HAVE_GPROF _mcleanup(); #endif _exit(arg1); ret = 0; break; case TARGET_NR_read: ret = get_errno(read(arg1, (void *)arg2, arg3)); break; case TARGET_NR_write: ret = get_errno(write(arg1, (void *)arg2, arg3)); break; case TARGET_NR_open: ret = get_errno(open((const char *)arg1, arg2, arg3)); break; case TARGET_NR_close: ret = get_errno(close(arg1)); break; case TARGET_NR_brk: ret = do_brk((char *)arg1); break; case TARGET_NR_fork: ret = get_errno(fork()); break; case TARGET_NR_waitpid: { int *status = (int *)arg2; ret = get_errno(waitpid(arg1, status, arg3)); if (!is_error(ret) && status) tswapls((long *)&status); } break; case TARGET_NR_creat: ret = get_errno(creat((const char *)arg1, arg2)); break; case TARGET_NR_link: ret = get_errno(link((const char *)arg1, (const char *)arg2)); break; case TARGET_NR_unlink: ret = get_errno(unlink((const char *)arg1)); break; case TARGET_NR_execve: ret = get_errno(execve((const char *)arg1, (void *)arg2, (void *)arg3)); break; case TARGET_NR_chdir: ret = get_errno(chdir((const char *)arg1)); break; case TARGET_NR_time: { int *time_ptr = (int *)arg1; ret = get_errno(time((time_t *)time_ptr)); if (!is_error(ret) && time_ptr) tswap32s(time_ptr); } break; case TARGET_NR_mknod: ret = get_errno(mknod((const char *)arg1, arg2, arg3)); break; case TARGET_NR_chmod: ret = get_errno(chmod((const char *)arg1, arg2)); break; case TARGET_NR_lchown: ret = get_errno(chown((const char *)arg1, arg2, arg3)); break; case TARGET_NR_break: goto unimplemented; case TARGET_NR_oldstat: goto unimplemented; case TARGET_NR_lseek: ret = get_errno(lseek(arg1, arg2, arg3)); break; case TARGET_NR_getpid: ret = get_errno(getpid()); break; case TARGET_NR_mount: goto unimplemented; case TARGET_NR_umount: ret = get_errno(umount((const char *)arg1)); break; case TARGET_NR_setuid: ret = get_errno(setuid(arg1)); break; case TARGET_NR_getuid: ret = get_errno(getuid()); break; case TARGET_NR_stime: { int *time_ptr = (int *)arg1; if (time_ptr) tswap32s(time_ptr); ret = get_errno(stime((time_t *)time_ptr)); } break; case TARGET_NR_ptrace: goto unimplemented; case TARGET_NR_alarm: ret = alarm(arg1); break; case TARGET_NR_oldfstat: goto unimplemented; case TARGET_NR_pause: ret = get_errno(pause()); break; case TARGET_NR_utime: goto unimplemented; case TARGET_NR_stty: goto unimplemented; case TARGET_NR_gtty: goto unimplemented; case TARGET_NR_access: ret = get_errno(access((const char *)arg1, arg2)); break; case TARGET_NR_nice: ret = get_errno(nice(arg1)); break; case TARGET_NR_ftime: goto unimplemented; case TARGET_NR_sync: ret = get_errno(sync()); break; case TARGET_NR_kill: ret = get_errno(kill(arg1, arg2)); break; case TARGET_NR_rename: ret = get_errno(rename((const char *)arg1, (const char *)arg2)); break; case TARGET_NR_mkdir: ret = get_errno(mkdir((const char *)arg1, arg2)); break; case TARGET_NR_rmdir: ret = get_errno(rmdir((const char *)arg1)); break; case TARGET_NR_dup: ret = get_errno(dup(arg1)); break; case TARGET_NR_pipe: { int *pipe_ptr = (int *)arg1; ret = get_errno(pipe(pipe_ptr)); if (!is_error(ret)) { tswap32s(&pipe_ptr[0]); tswap32s(&pipe_ptr[1]); } } break; case TARGET_NR_times: goto unimplemented; case TARGET_NR_prof: goto unimplemented; case TARGET_NR_setgid: ret = get_errno(setgid(arg1)); break; case TARGET_NR_getgid: ret = get_errno(getgid()); break; case TARGET_NR_signal: goto unimplemented; case TARGET_NR_geteuid: ret = get_errno(geteuid()); break; case TARGET_NR_getegid: ret = get_errno(getegid()); break; case TARGET_NR_acct: goto unimplemented; case TARGET_NR_umount2: ret = get_errno(umount2((const char *)arg1, arg2)); break; case TARGET_NR_lock: goto unimplemented; case TARGET_NR_ioctl: ret = do_ioctl(arg1, arg2, arg3); break; case TARGET_NR_fcntl: switch(arg2) { case F_GETLK: case F_SETLK: case F_SETLKW: goto unimplemented; default: ret = get_errno(fcntl(arg1, arg2, arg3)); break; } break; case TARGET_NR_mpx: goto unimplemented; case TARGET_NR_setpgid: ret = get_errno(setpgid(arg1, arg2)); break; case TARGET_NR_ulimit: goto unimplemented; case TARGET_NR_oldolduname: goto unimplemented; case TARGET_NR_umask: ret = get_errno(umask(arg1)); break; case TARGET_NR_chroot: ret = get_errno(chroot((const char *)arg1)); break; case TARGET_NR_ustat: goto unimplemented; case TARGET_NR_dup2: ret = get_errno(dup2(arg1, arg2)); break; case TARGET_NR_getppid: ret = get_errno(getppid()); break; case TARGET_NR_getpgrp: ret = get_errno(getpgrp()); break; case TARGET_NR_setsid: ret = get_errno(setsid()); break; case TARGET_NR_sigaction: #if 0 { int signum = arg1; struct target_old_sigaction *tact = arg2, *toldact = arg3; ret = get_errno(setsid()); } break; #else goto unimplemented; #endif case TARGET_NR_sgetmask: goto unimplemented; case TARGET_NR_ssetmask: goto unimplemented; case TARGET_NR_setreuid: ret = get_errno(setreuid(arg1, arg2)); break; case TARGET_NR_setregid: ret = get_errno(setregid(arg1, arg2)); break; case TARGET_NR_sigsuspend: goto unimplemented; case TARGET_NR_sigpending: goto unimplemented; case TARGET_NR_sethostname: ret = get_errno(sethostname((const char *)arg1, arg2)); break; case TARGET_NR_setrlimit: goto unimplemented; case TARGET_NR_getrlimit: goto unimplemented; case TARGET_NR_getrusage: goto unimplemented; case TARGET_NR_gettimeofday: { struct target_timeval *target_tv = (void *)arg1; struct timeval tv; ret = get_errno(gettimeofday(&tv, NULL)); if (!is_error(ret)) { target_tv->tv_sec = tswapl(tv.tv_sec); target_tv->tv_usec = tswapl(tv.tv_usec); } } break; case TARGET_NR_settimeofday: { struct target_timeval *target_tv = (void *)arg1; struct timeval tv; tv.tv_sec = tswapl(target_tv->tv_sec); tv.tv_usec = tswapl(target_tv->tv_usec); ret = get_errno(settimeofday(&tv, NULL)); } break; case TARGET_NR_getgroups: goto unimplemented; case TARGET_NR_setgroups: goto unimplemented; case TARGET_NR_select: goto unimplemented; case TARGET_NR_symlink: ret = get_errno(symlink((const char *)arg1, (const char *)arg2)); break; case TARGET_NR_oldlstat: goto unimplemented; case TARGET_NR_readlink: ret = get_errno(readlink((const char *)arg1, (char *)arg2, arg3)); break; case TARGET_NR_uselib: goto unimplemented; case TARGET_NR_swapon: ret = get_errno(swapon((const char *)arg1, arg2)); break; case TARGET_NR_reboot: goto unimplemented; case TARGET_NR_readdir: goto unimplemented; #ifdef TARGET_I386 case TARGET_NR_mmap: { uint32_t v1, v2, v3, v4, v5, v6, *vptr; vptr = (uint32_t *)arg1; v1 = tswap32(vptr[0]); v2 = tswap32(vptr[1]); v3 = tswap32(vptr[2]); v4 = tswap32(vptr[3]); v5 = tswap32(vptr[4]); v6 = tswap32(vptr[5]); ret = get_errno((long)mmap((void *)v1, v2, v3, v4, v5, v6)); } break; #endif #ifdef TARGET_I386 case TARGET_NR_mmap2: #else case TARGET_NR_mmap: #endif ret = get_errno((long)mmap((void *)arg1, arg2, arg3, arg4, arg5, arg6)); break; case TARGET_NR_munmap: ret = get_errno(munmap((void *)arg1, arg2)); break; case TARGET_NR_truncate: ret = get_errno(truncate((const char *)arg1, arg2)); break; case TARGET_NR_ftruncate: ret = get_errno(ftruncate(arg1, arg2)); break; case TARGET_NR_fchmod: ret = get_errno(fchmod(arg1, arg2)); break; case TARGET_NR_fchown: ret = get_errno(fchown(arg1, arg2, arg3)); break; case TARGET_NR_getpriority: ret = get_errno(getpriority(arg1, arg2)); break; case TARGET_NR_setpriority: ret = get_errno(setpriority(arg1, arg2, arg3)); break; case TARGET_NR_profil: goto unimplemented; case TARGET_NR_statfs: stfs = (void *)arg2; ret = get_errno(sys_statfs((const char *)arg1, stfs)); convert_statfs: if (!is_error(ret)) { tswap32s(&stfs->f_type); tswap32s(&stfs->f_bsize); tswap32s(&stfs->f_blocks); tswap32s(&stfs->f_bfree); tswap32s(&stfs->f_bavail); tswap32s(&stfs->f_files); tswap32s(&stfs->f_ffree); tswap32s(&stfs->f_fsid.val[0]); tswap32s(&stfs->f_fsid.val[1]); tswap32s(&stfs->f_namelen); } break; case TARGET_NR_fstatfs: stfs = (void *)arg2; ret = get_errno(sys_fstatfs(arg1, stfs)); goto convert_statfs; case TARGET_NR_ioperm: goto unimplemented; case TARGET_NR_socketcall: ret = do_socketcall(arg1, (long *)arg2); break; case TARGET_NR_syslog: goto unimplemented; case TARGET_NR_setitimer: goto unimplemented; case TARGET_NR_getitimer: goto unimplemented; case TARGET_NR_stat: ret = get_errno(stat((const char *)arg1, &st)); goto do_stat; case TARGET_NR_lstat: ret = get_errno(lstat((const char *)arg1, &st)); goto do_stat; case TARGET_NR_fstat: { ret = get_errno(fstat(arg1, &st)); do_stat: if (!is_error(ret)) { struct target_stat *target_st = (void *)arg2; target_st->st_dev = tswap16(st.st_dev); target_st->st_ino = tswapl(st.st_ino); target_st->st_mode = tswap16(st.st_mode); target_st->st_nlink = tswap16(st.st_nlink); target_st->st_uid = tswap16(st.st_uid); target_st->st_gid = tswap16(st.st_gid); target_st->st_rdev = tswap16(st.st_rdev); target_st->st_size = tswapl(st.st_size); target_st->st_blksize = tswapl(st.st_blksize); target_st->st_blocks = tswapl(st.st_blocks); target_st->st_atime = tswapl(st.st_atime); target_st->st_mtime = tswapl(st.st_mtime); target_st->st_ctime = tswapl(st.st_ctime); } } break; case TARGET_NR_olduname: goto unimplemented; case TARGET_NR_iopl: goto unimplemented; case TARGET_NR_vhangup: ret = get_errno(vhangup()); break; case TARGET_NR_idle: goto unimplemented; case TARGET_NR_vm86old: goto unimplemented; case TARGET_NR_wait4: { int status; target_long *status_ptr = (void *)arg2; struct rusage rusage, *rusage_ptr; struct target_rusage *target_rusage = (void *)arg4; if (target_rusage) rusage_ptr = &rusage; else rusage_ptr = NULL; ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr)); if (!is_error(ret)) { if (status_ptr) *status_ptr = tswap32(status); if (target_rusage) { target_rusage->ru_utime.tv_sec = tswapl(rusage.ru_utime.tv_sec); target_rusage->ru_utime.tv_usec = tswapl(rusage.ru_utime.tv_usec); target_rusage->ru_stime.tv_sec = tswapl(rusage.ru_stime.tv_sec); target_rusage->ru_stime.tv_usec = tswapl(rusage.ru_stime.tv_usec); target_rusage->ru_maxrss = tswapl(rusage.ru_maxrss); target_rusage->ru_ixrss = tswapl(rusage.ru_ixrss); target_rusage->ru_idrss = tswapl(rusage.ru_idrss); target_rusage->ru_isrss = tswapl(rusage.ru_isrss); target_rusage->ru_minflt = tswapl(rusage.ru_minflt); target_rusage->ru_majflt = tswapl(rusage.ru_majflt); target_rusage->ru_nswap = tswapl(rusage.ru_nswap); target_rusage->ru_inblock = tswapl(rusage.ru_inblock); target_rusage->ru_oublock = tswapl(rusage.ru_oublock); target_rusage->ru_msgsnd = tswapl(rusage.ru_msgsnd); target_rusage->ru_msgrcv = tswapl(rusage.ru_msgrcv); target_rusage->ru_nsignals = tswapl(rusage.ru_nsignals); target_rusage->ru_nvcsw = tswapl(rusage.ru_nvcsw); target_rusage->ru_nivcsw = tswapl(rusage.ru_nivcsw); } } } break; case TARGET_NR_swapoff: ret = get_errno(swapoff((const char *)arg1)); break; case TARGET_NR_sysinfo: goto unimplemented; case TARGET_NR_ipc: goto unimplemented; case TARGET_NR_fsync: ret = get_errno(fsync(arg1)); break; case TARGET_NR_sigreturn: goto unimplemented; case TARGET_NR_clone: goto unimplemented; case TARGET_NR_setdomainname: ret = get_errno(setdomainname((const char *)arg1, arg2)); break; case TARGET_NR_uname: ret = get_errno(sys_uname((struct new_utsname *)arg1)); break; #ifdef TARGET_I386 case TARGET_NR_modify_ldt: ret = get_errno(gemu_modify_ldt([[sceptre]], arg1, (void *)arg2, arg3)); break; #endif case TARGET_NR_adjtimex: goto unimplemented; case TARGET_NR_mprotect: ret = get_errno(mprotect((void *)arg1, arg2, arg3)); break; case TARGET_NR_sigprocmask: { int how = arg1; sigset_t set, oldset, *set_ptr; target_ulong *pset = (void *)arg2, *poldset = (void *)arg3; switch(how) { case TARGET_SIG_BLOCK: how = SIG_BLOCK; break; case TARGET_SIG_UNBLOCK: how = SIG_UNBLOCK; break; case TARGET_SIG_SETMASK: how = SIG_SETMASK; break; default: ret = -EINVAL; goto fail; } if (pset) { target_to_host_old_sigset(&set, pset); set_ptr = &set; } else { set_ptr = NULL; } ret = get_errno(sigprocmask(arg1, set_ptr, &oldset)); if (!is_error(ret) && poldset) { host_to_target_old_sigset(poldset, &oldset); } } break; case TARGET_NR_create_module: case TARGET_NR_init_module: case TARGET_NR_delete_module: case TARGET_NR_get_kernel_syms: goto unimplemented; case TARGET_NR_quotactl: goto unimplemented; case TARGET_NR_getpgid: ret = get_errno(getpgid(arg1)); break; case TARGET_NR_fchdir: ret = get_errno(fchdir(arg1)); break; case TARGET_NR_bdflush: goto unimplemented; case TARGET_NR_sysfs: goto unimplemented; case TARGET_NR_personality: ret = get_errno(mprotect((void *)arg1, arg2, arg3)); break; case TARGET_NR_afs_syscall: goto unimplemented; case TARGET_NR_setfsuid: goto unimplemented; case TARGET_NR_setfsgid: goto unimplemented; case TARGET_NR__llseek: { int64_t res; ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5)); *(int64_t *)arg4 = tswap64(res); } break; case TARGET_NR_getdents: #if TARGET_LONG_SIZE != 4 #error not supported #endif { struct dirent *dirp = (void *)arg2; long count = arg3; ret = get_errno(sys_getdents(arg1, dirp, count)); if (!is_error(ret)) { struct dirent *de; int len = ret; int reclen; de = dirp; while (len > 0) { reclen = tswap16(de->d_reclen); if (reclen > len) break; de->d_reclen = reclen; tswapls(&de->d_ino); tswapls(&de->d_off); de = (struct dirent *)((char *)de + reclen); len -= reclen; } } } break; case TARGET_NR__newselect: ret = do_select(arg1, (void *)arg2, (void *)arg3, (void *)arg4, (void *)arg5); break; case TARGET_NR_flock: goto unimplemented; case TARGET_NR_msync: ret = get_errno(msync((void *)arg1, arg2, arg3)); break; case TARGET_NR_readv: { int count = arg3; int i; struct iovec *vec; struct target_iovec *target_vec = (void *)arg2; vec = alloca(count * sizeof(struct iovec)); for(i = 0;i < count; i++) { vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base); vec[i].iov_len = tswapl(target_vec[i].iov_len); } ret = get_errno(readv(arg1, vec, count)); } break; case TARGET_NR_writev: { int count = arg3; int i; struct iovec *vec; struct target_iovec *target_vec = (void *)arg2; vec = alloca(count * sizeof(struct iovec)); for(i = 0;i < count; i++) { vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base); vec[i].iov_len = tswapl(target_vec[i].iov_len); } ret = get_errno(writev(arg1, vec, count)); } break; case TARGET_NR_getsid: ret = get_errno(getsid(arg1)); break; case TARGET_NR_fdatasync: goto unimplemented; case TARGET_NR__sysctl: goto unimplemented; case TARGET_NR_mlock: ret = get_errno(mlock((void *)arg1, arg2)); break; case TARGET_NR_munlock: ret = get_errno(munlock((void *)arg1, arg2)); break; case TARGET_NR_mlockall: ret = get_errno(mlockall(arg1)); break; case TARGET_NR_munlockall: ret = get_errno(munlockall()); break; case TARGET_NR_sched_setparam: goto unimplemented; case TARGET_NR_sched_getparam: goto unimplemented; case TARGET_NR_sched_setscheduler: goto unimplemented; case TARGET_NR_sched_getscheduler: goto unimplemented; case TARGET_NR_sched_yield: ret = get_errno(sched_yield()); break; case TARGET_NR_sched_get_priority_max: case TARGET_NR_sched_get_priority_min: case TARGET_NR_sched_rr_get_interval: case TARGET_NR_nanosleep: case TARGET_NR_mremap: case TARGET_NR_setresuid: case TARGET_NR_getresuid: case TARGET_NR_vm86: case TARGET_NR_query_module: case TARGET_NR_poll: case TARGET_NR_nfsservctl: case TARGET_NR_setresgid: case TARGET_NR_getresgid: case TARGET_NR_prctl: case TARGET_NR_rt_sigreturn: case TARGET_NR_rt_sigaction: case TARGET_NR_rt_sigprocmask: case TARGET_NR_rt_sigpending: case TARGET_NR_rt_sigtimedwait: case TARGET_NR_rt_sigqueueinfo: case TARGET_NR_rt_sigsuspend: case TARGET_NR_pread: case TARGET_NR_pwrite: goto unimplemented; case TARGET_NR_chown: ret = get_errno(chown((const char *)arg1, arg2, arg3)); break; case TARGET_NR_getcwd: ret = get_errno(sys_getcwd1((char *)arg1, arg2)); break; case TARGET_NR_capget: case TARGET_NR_capset: case TARGET_NR_sigaltstack: case TARGET_NR_sendfile: case TARGET_NR_getpmsg: case TARGET_NR_putpmsg: case TARGET_NR_vfork: ret = get_errno(vfork()); break; case TARGET_NR_ugetrlimit: case TARGET_NR_truncate64: case TARGET_NR_ftruncate64: case TARGET_NR_stat64: case TARGET_NR_lstat64: case TARGET_NR_fstat64: case TARGET_NR_lchown32: case TARGET_NR_getuid32: case TARGET_NR_getgid32: case TARGET_NR_geteuid32: case TARGET_NR_getegid32: case TARGET_NR_setreuid32: case TARGET_NR_setregid32: case TARGET_NR_getgroups32: case TARGET_NR_setgroups32: case TARGET_NR_fchown32: case TARGET_NR_setresuid32: case TARGET_NR_getresuid32: case TARGET_NR_setresgid32: case TARGET_NR_getresgid32: case TARGET_NR_chown32: case TARGET_NR_setuid32: case TARGET_NR_setgid32: case TARGET_NR_setfsuid32: case TARGET_NR_setfsgid32: case TARGET_NR_pivot_root: case TARGET_NR_mincore: case TARGET_NR_madvise: case TARGET_NR_getdents64: case TARGET_NR_fcntl64: case TARGET_NR_security: goto unimplemented; case TARGET_NR_gettid: ret = get_errno(gettid()); break; case TARGET_NR_readahead: case TARGET_NR_setxattr: case TARGET_NR_lsetxattr: case TARGET_NR_fsetxattr: case TARGET_NR_getxattr: case TARGET_NR_lgetxattr: case TARGET_NR_fgetxattr: case TARGET_NR_listxattr: case TARGET_NR_llistxattr: case TARGET_NR_flistxattr: case TARGET_NR_removexattr: case TARGET_NR_lremovexattr: case TARGET_NR_fremovexattr: goto unimplemented; default: unimplemented: gemu_log("Unsupported syscall: %d\n", num); ret = -ENOSYS; break; } fail: return ret; }[Succeeded / Failed / Skipped / Total] 807 / 73 / 489 / 1369:  51%|     | 1369/2690 [15:04:55<14:33:11, 39.66s/it][Succeeded / Failed / Skipped / Total] 807 / 73 / 489 / 1369:  51%|     | 1370/2690 [15:05:52<14:32:49, 39.67s/it]
--------------------------------------------- Result 1370 ---------------------------------------------
[[0 (30%)]] --> [[0 (53%)]] --> Socre: 0.5273998975753784

[[[[Adv]]]]: static int decode_band_hdr(IVI45DecContext *ctx, IVIBandDesc *[[band]], AVCodecContext *avctx) { int plane, band_num, indx, transform_id, scan_indx; int i; plane = get_bits(&ctx->gb, 2); band_num = get_bits(&ctx->gb, 4); if ([[band]]->plane != plane || [[band]]->band_num != band_num) { av_log(avctx, AV_LOG_ERROR, "Invalid band header sequence!\n"); return AVERROR_INVALIDDATA; } [[band]]->is_empty = get_bits1(&ctx->gb); if (![[band]]->is_empty) { int old_blk_size = [[band]]->blk_size; if (get_bits1(&ctx->gb)) skip_bits(&ctx->gb, 16); [[band]]->is_halfpel = get_bits(&ctx->gb, 2); if ([[band]]->is_halfpel >= 2) { av_log(avctx, AV_LOG_ERROR, "Invalid/unsupported mv resolution: %d!\n", [[band]]->is_halfpel); return AVERROR_INVALIDDATA; } #if IVI4_STREAM_ANALYSER if (![[band]]->is_halfpel) ctx->uses_fullpel = 1; #endif [[band]]->checksum_present = get_bits1(&ctx->gb); if ([[band]]->checksum_present) [[band]]->checksum = get_bits(&ctx->gb, 16); indx = get_bits(&ctx->gb, 2); if (indx == 3) { av_log(avctx, AV_LOG_ERROR, "Invalid block size!\n"); return AVERROR_INVALIDDATA; } [[band]]->mb_size = 16 >> indx; [[band]]->blk_size = 8 >> (indx >> 1); [[band]]->inherit_mv = get_bits1(&ctx->gb); [[band]]->inherit_qdelta = get_bits1(&ctx->gb); [[band]]->glob_quant = get_bits(&ctx->gb, 5); if (!get_bits1(&ctx->gb) || ctx->frame_type == IVI4_FRAMETYPE_INTRA) { transform_id = get_bits(&ctx->gb, 5); if (transform_id >= FF_ARRAY_ELEMS(transforms) || !transforms[transform_id].inv_trans) { avpriv_request_sample(avctx, "Transform %d", transform_id); return AVERROR_PATCHWELCOME; } if ((transform_id >= 7 && transform_id <= 9) || transform_id == 17) { avpriv_request_sample(avctx, "DCT transform"); return AVERROR_PATCHWELCOME; } #if IVI4_STREAM_ANALYSER if ((transform_id >= 0 && transform_id <= 2) || transform_id == 10) ctx->uses_haar = 1; #endif [[band]]->inv_transform = transforms[transform_id].inv_trans; [[band]]->dc_transform = transforms[transform_id].dc_trans; [[band]]->is_2d_trans = transforms[transform_id].is_2d_trans; if (transform_id < 10) [[band]]->transform_size = 8; else [[band]]->transform_size = 4; if ([[band]]->blk_size != [[band]]->transform_size) return AVERROR_INVALIDDATA; scan_indx = get_bits(&ctx->gb, 4); if (scan_indx == 15) { av_log(avctx, AV_LOG_ERROR, "Custom scan pattern encountered!\n"); return AVERROR_INVALIDDATA; } if (scan_indx > 4 && scan_indx < 10) { if ([[band]]->blk_size != 4) return AVERROR_INVALIDDATA; } else if ([[band]]->blk_size != 8) return AVERROR_INVALIDDATA; [[band]]->scan = scan_index_to_tab[scan_indx]; [[band]]->quant_mat = get_bits(&ctx->gb, 5); if ([[band]]->quant_mat >= FF_ARRAY_ELEMS(quant_index_to_tab)) { if ([[band]]->quant_mat == 31) av_log(avctx, AV_LOG_ERROR, "Custom quant matrix encountered!\n"); else avpriv_request_sample(avctx, "Quantization matrix %d", [[band]]->quant_mat); [[band]]->quant_mat = -1; return AVERROR_INVALIDDATA; } } else { if (old_blk_size != [[band]]->blk_size) { av_log(avctx, AV_LOG_ERROR, "The band block size does not match the configuration " "inherited\n"); return AVERROR_INVALIDDATA; } if ([[band]]->quant_mat < 0) { av_log(avctx, AV_LOG_ERROR, "Invalid quant_mat inherited\n"); return AVERROR_INVALIDDATA; } } if (!get_bits1(&ctx->gb)) [[band]]->blk_vlc.tab = ctx->blk_vlc.tab; else if (ff_ivi_dec_huff_desc(&ctx->gb, 1, IVI_BLK_HUFF, &[[band]]->blk_vlc, avctx)) return AVERROR_INVALIDDATA; [[band]]->rvmap_sel = get_bits1(&ctx->gb) ? get_bits(&ctx->gb, 3) : 8; [[band]]->num_corr = 0; if (get_bits1(&ctx->gb)) { [[band]]->num_corr = get_bits(&ctx->gb, 8); if ([[band]]->num_corr > 61) { av_log(avctx, AV_LOG_ERROR, "Too many corrections: %d\n", [[band]]->num_corr); return AVERROR_INVALIDDATA; } for (i = 0; i < [[band]]->num_corr * 2; i++) [[band]]->corr[i] = get_bits(&ctx->gb, 8); } } if ([[band]]->blk_size == 8) { [[band]]->intra_base = &ivi4_quant_8x8_intra[quant_index_to_tab[[[band]]->quant_mat]][0]; [[band]]->inter_base = &ivi4_quant_8x8_inter[quant_index_to_tab[[[band]]->quant_mat]][0]; } else { [[band]]->intra_base = &ivi4_quant_4x4_intra[quant_index_to_tab[[[band]]->quant_mat]][0]; [[band]]->inter_base = &ivi4_quant_4x4_inter[quant_index_to_tab[[[band]]->quant_mat]][0]; } [[band]]->intra_scale = NULL; [[band]]->inter_scale = NULL; align_get_bits(&ctx->gb); return 0; }

[[[[Adv]]]]: static int decode_band_hdr(IVI45DecContext *ctx, IVIBandDesc *[[gangs]], AVCodecContext *avctx) { int plane, band_num, indx, transform_id, scan_indx; int i; plane = get_bits(&ctx->gb, 2); band_num = get_bits(&ctx->gb, 4); if ([[gangs]]->plane != plane || [[gangs]]->band_num != band_num) { av_log(avctx, AV_LOG_ERROR, "Invalid band header sequence!\n"); return AVERROR_INVALIDDATA; } [[gangs]]->is_empty = get_bits1(&ctx->gb); if (![[gangs]]->is_empty) { int old_blk_size = [[gangs]]->blk_size; if (get_bits1(&ctx->gb)) skip_bits(&ctx->gb, 16); [[gangs]]->is_halfpel = get_bits(&ctx->gb, 2); if ([[gangs]]->is_halfpel >= 2) { av_log(avctx, AV_LOG_ERROR, "Invalid/unsupported mv resolution: %d!\n", [[gangs]]->is_halfpel); return AVERROR_INVALIDDATA; } #if IVI4_STREAM_ANALYSER if (![[gangs]]->is_halfpel) ctx->uses_fullpel = 1; #endif [[gangs]]->checksum_present = get_bits1(&ctx->gb); if ([[gangs]]->checksum_present) [[gangs]]->checksum = get_bits(&ctx->gb, 16); indx = get_bits(&ctx->gb, 2); if (indx == 3) { av_log(avctx, AV_LOG_ERROR, "Invalid block size!\n"); return AVERROR_INVALIDDATA; } [[gangs]]->mb_size = 16 >> indx; [[gangs]]->blk_size = 8 >> (indx >> 1); [[gangs]]->inherit_mv = get_bits1(&ctx->gb); [[gangs]]->inherit_qdelta = get_bits1(&ctx->gb); [[gangs]]->glob_quant = get_bits(&ctx->gb, 5); if (!get_bits1(&ctx->gb) || ctx->frame_type == IVI4_FRAMETYPE_INTRA) { transform_id = get_bits(&ctx->gb, 5); if (transform_id >= FF_ARRAY_ELEMS(transforms) || !transforms[transform_id].inv_trans) { avpriv_request_sample(avctx, "Transform %d", transform_id); return AVERROR_PATCHWELCOME; } if ((transform_id >= 7 && transform_id <= 9) || transform_id == 17) { avpriv_request_sample(avctx, "DCT transform"); return AVERROR_PATCHWELCOME; } #if IVI4_STREAM_ANALYSER if ((transform_id >= 0 && transform_id <= 2) || transform_id == 10) ctx->uses_haar = 1; #endif [[gangs]]->inv_transform = transforms[transform_id].inv_trans; [[gangs]]->dc_transform = transforms[transform_id].dc_trans; [[gangs]]->is_2d_trans = transforms[transform_id].is_2d_trans; if (transform_id < 10) [[gangs]]->transform_size = 8; else [[gangs]]->transform_size = 4; if ([[gangs]]->blk_size != [[gangs]]->transform_size) return AVERROR_INVALIDDATA; scan_indx = get_bits(&ctx->gb, 4); if (scan_indx == 15) { av_log(avctx, AV_LOG_ERROR, "Custom scan pattern encountered!\n"); return AVERROR_INVALIDDATA; } if (scan_indx > 4 && scan_indx < 10) { if ([[gangs]]->blk_size != 4) return AVERROR_INVALIDDATA; } else if ([[gangs]]->blk_size != 8) return AVERROR_INVALIDDATA; [[gangs]]->scan = scan_index_to_tab[scan_indx]; [[gangs]]->quant_mat = get_bits(&ctx->gb, 5); if ([[gangs]]->quant_mat >= FF_ARRAY_ELEMS(quant_index_to_tab)) { if ([[gangs]]->quant_mat == 31) av_log(avctx, AV_LOG_ERROR, "Custom quant matrix encountered!\n"); else avpriv_request_sample(avctx, "Quantization matrix %d", [[gangs]]->quant_mat); [[gangs]]->quant_mat = -1; return AVERROR_INVALIDDATA; } } else { if (old_blk_size != [[gangs]]->blk_size) { av_log(avctx, AV_LOG_ERROR, "The band block size does not match the configuration " "inherited\n"); return AVERROR_INVALIDDATA; } if ([[gangs]]->quant_mat < 0) { av_log(avctx, AV_LOG_ERROR, "Invalid quant_mat inherited\n"); return AVERROR_INVALIDDATA; } } if (!get_bits1(&ctx->gb)) [[gangs]]->blk_vlc.tab = ctx->blk_vlc.tab; else if (ff_ivi_dec_huff_desc(&ctx->gb, 1, IVI_BLK_HUFF, &[[gangs]]->blk_vlc, avctx)) return AVERROR_INVALIDDATA; [[gangs]]->rvmap_sel = get_bits1(&ctx->gb) ? get_bits(&ctx->gb, 3) : 8; [[gangs]]->num_corr = 0; if (get_bits1(&ctx->gb)) { [[gangs]]->num_corr = get_bits(&ctx->gb, 8); if ([[gangs]]->num_corr > 61) { av_log(avctx, AV_LOG_ERROR, "Too many corrections: %d\n", [[gangs]]->num_corr); return AVERROR_INVALIDDATA; } for (i = 0; i < [[gangs]]->num_corr * 2; i++) [[gangs]]->corr[i] = get_bits(&ctx->gb, 8); } } if ([[gangs]]->blk_size == 8) { [[gangs]]->intra_base = &ivi4_quant_8x8_intra[quant_index_to_tab[[[gangs]]->quant_mat]][0]; [[gangs]]->inter_base = &ivi4_quant_8x8_inter[quant_index_to_tab[[[gangs]]->quant_mat]][0]; } else { [[gangs]]->intra_base = &ivi4_quant_4x4_intra[quant_index_to_tab[[[gangs]]->quant_mat]][0]; [[gangs]]->inter_base = &ivi4_quant_4x4_inter[quant_index_to_tab[[[gangs]]->quant_mat]][0]; } [[gangs]]->intra_scale = NULL; [[gangs]]->inter_scale = NULL; align_get_bits(&ctx->gb); return 0; }[Succeeded / Failed / Skipped / Total] 808 / 73 / 489 / 1370:  51%|     | 1370/2690 [15:05:52<14:32:49, 39.67s/it][Succeeded / Failed / Skipped / Total] 808 / 73 / 489 / 1370:  51%|     | 1371/2690 [15:05:53<14:31:32, 39.65s/it][Succeeded / Failed / Skipped / Total] 808 / 73 / 490 / 1371:  51%|     | 1371/2690 [15:05:53<14:31:32, 39.65s/it][Succeeded / Failed / Skipped / Total] 808 / 73 / 490 / 1371:  51%|     | 1372/2690 [15:07:06<14:31:24, 39.67s/it]
--------------------------------------------- Result 1371 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int synchronize_audio(VideoState *is, short *samples, int samples_size1, double pts) { int n, samples_size; double ref_clock; n = 2 * is->audio_st->codec->channels; samples_size = samples_size1; if (((is->av_sync_type == AV_SYNC_VIDEO_MASTER && is->video_st) || is->av_sync_type == AV_SYNC_EXTERNAL_CLOCK)) { double diff, avg_diff; int wanted_size, min_size, max_size, nb_samples; ref_clock = get_master_clock(is); diff = get_audio_clock(is) - ref_clock; if (diff < AV_NOSYNC_THRESHOLD) { is->audio_diff_cum = diff + is->audio_diff_avg_coef * is->audio_diff_cum; if (is->audio_diff_avg_count < AUDIO_DIFF_AVG_NB) { is->audio_diff_avg_count++; } else { avg_diff = is->audio_diff_cum * (1.0 - is->audio_diff_avg_coef); if (fabs(avg_diff) >= is->audio_diff_threshold) { wanted_size = samples_size + ((int)(diff * is->audio_st->codec->sample_rate) * n); nb_samples = samples_size / n; min_size = ((nb_samples * (100 - SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n; max_size = ((nb_samples * (100 + SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n; if (wanted_size < min_size) wanted_size = min_size; else if (wanted_size > max_size) wanted_size = max_size; if (wanted_size < samples_size) { samples_size = wanted_size; } else if (wanted_size > samples_size) { uint8_t *samples_end, *q; int nb; nb = (samples_size - wanted_size); samples_end = (uint8_t *)samples + samples_size - n; q = samples_end + n; while (nb > 0) { memcpy(q, samples_end, n); q += n; nb -= n; } samples_size = wanted_size; } } av_dlog(NULL, "diff=%f adiff=%f sample_diff=%d apts=%0.3f vpts=%0.3f %f\n", diff, avg_diff, samples_size - samples_size1, is->audio_clock, is->video_clock, is->audio_diff_threshold); } } else { is->audio_diff_avg_count = 0; is->audio_diff_cum = 0; } } return samples_size; }
--------------------------------------------- Result 1372 ---------------------------------------------
[[0 (99%)]] --> [[0 (45%)]] --> Socre: 0.5523520112037659

[[[[Adv]]]]: static int rebuild_refcount_structure(BlockDriverState *bs, BdrvCheckResult *res, void **[[refcount_table]], int64_t *nb_clusters) { BDRVQcow2State *s = bs->opaque; int64_t first_free_cluster = 0, reftable_offset = -1, cluster = 0; int64_t refblock_offset, refblock_start, refblock_index; uint32_t reftable_size = 0; uint64_t *[[on_disk_reftable]] = NULL; void *on_disk_refblock; int ret = 0; struct { uint64_t reftable_offset; uint32_t reftable_clusters; } QEMU_PACKED reftable_offset_and_clusters; qcow2_cache_empty(bs, s->refcount_block_cache); write_refblocks: for (; cluster < *nb_clusters; cluster++) { if (!s->get_refcount(*[[refcount_table]], cluster)) { continue; } refblock_index = cluster >> s->refcount_block_bits; refblock_start = refblock_index << s->refcount_block_bits; if (first_free_cluster < refblock_start) { first_free_cluster = refblock_start; } refblock_offset = alloc_clusters_imrt(bs, 1, [[refcount_table]], nb_clusters, &first_free_cluster); if (refblock_offset < 0) { fprintf(stderr, "ERROR allocating refblock: %s\n", strerror(-refblock_offset)); res->check_errors++; ret = refblock_offset; goto fail; } if (reftable_size <= refblock_index) { uint32_t old_reftable_size = reftable_size; uint64_t *new_on_disk_reftable; reftable_size = ROUND_UP((refblock_index + 1) * sizeof(uint64_t), s->cluster_size) / sizeof(uint64_t); new_on_disk_reftable = g_try_realloc([[on_disk_reftable]], reftable_size * sizeof(uint64_t)); if (!new_on_disk_reftable) { res->check_errors++; ret = -ENOMEM; goto fail; } [[on_disk_reftable]] = new_on_disk_reftable; memset([[on_disk_reftable]] + old_reftable_size, 0, (reftable_size - old_reftable_size) * sizeof(uint64_t)); reftable_offset = -1; } [[on_disk_reftable]][refblock_index] = refblock_offset; if (refblock_index == (*nb_clusters - 1) >> s->refcount_block_bits && reftable_offset < 0) { uint64_t reftable_clusters = size_to_clusters(s, reftable_size * sizeof(uint64_t)); reftable_offset = alloc_clusters_imrt(bs, reftable_clusters, [[refcount_table]], nb_clusters, &first_free_cluster); if (reftable_offset < 0) { fprintf(stderr, "ERROR allocating reftable: %s\n", strerror(-reftable_offset)); res->check_errors++; ret = reftable_offset; goto fail; } } ret = qcow2_pre_write_overlap_check(bs, 0, refblock_offset, s->cluster_size); if (ret < 0) { fprintf(stderr, "ERROR writing refblock: %s\n", strerror(-ret)); goto fail; } on_disk_refblock = (void *)((char *) *[[refcount_table]] + refblock_index * s->cluster_size); ret = bdrv_write(bs->file, refblock_offset / BDRV_SECTOR_SIZE, on_disk_refblock, s->cluster_sectors); if (ret < 0) { fprintf(stderr, "ERROR writing refblock: %s\n", strerror(-ret)); goto fail; } cluster = refblock_start + s->refcount_block_size - 1; } if (reftable_offset < 0) { uint64_t post_refblock_start, reftable_clusters; post_refblock_start = ROUND_UP(*nb_clusters, s->refcount_block_size); reftable_clusters = size_to_clusters(s, reftable_size * sizeof(uint64_t)); if (first_free_cluster < post_refblock_start) { first_free_cluster = post_refblock_start; } reftable_offset = alloc_clusters_imrt(bs, reftable_clusters, [[refcount_table]], nb_clusters, &first_free_cluster); if (reftable_offset < 0) { fprintf(stderr, "ERROR allocating reftable: %s\n", strerror(-reftable_offset)); res->check_errors++; ret = reftable_offset; goto fail; } goto write_refblocks; } assert([[on_disk_reftable]]); for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) { cpu_to_be64s(&[[on_disk_reftable]][refblock_index]); } ret = qcow2_pre_write_overlap_check(bs, 0, reftable_offset, reftable_size * sizeof(uint64_t)); if (ret < 0) { fprintf(stderr, "ERROR writing reftable: %s\n", strerror(-ret)); goto fail; } assert(reftable_size < INT_MAX / sizeof(uint64_t)); ret = bdrv_pwrite(bs->file, reftable_offset, [[on_disk_reftable]], reftable_size * sizeof(uint64_t)); if (ret < 0) { fprintf(stderr, "ERROR writing reftable: %s\n", strerror(-ret)); goto fail; } reftable_offset_and_clusters.reftable_offset = cpu_to_be64(reftable_offset); reftable_offset_and_clusters.reftable_clusters = cpu_to_be32(size_to_clusters(s, reftable_size * sizeof(uint64_t))); ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset), &reftable_offset_and_clusters, sizeof(reftable_offset_and_clusters)); if (ret < 0) { fprintf(stderr, "ERROR setting reftable: %s\n", strerror(-ret)); goto fail; } for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) { be64_to_cpus(&[[on_disk_reftable]][refblock_index]); } s->refcount_table = [[on_disk_reftable]]; s->refcount_table_offset = reftable_offset; s->refcount_table_size = reftable_size; update_max_refcount_table_index(s); return 0; fail: g_free([[on_disk_reftable]]); return ret; }

[[[[Adv]]]]: static int rebuild_refcount_structure(BlockDriverState *bs, BdrvCheckResult *res, void **[[pass]], int64_t *nb_clusters) { BDRVQcow2State *s = bs->opaque; int64_t first_free_cluster = 0, reftable_offset = -1, cluster = 0; int64_t refblock_offset, refblock_start, refblock_index; uint32_t reftable_size = 0; uint64_t *[[homing]] = NULL; void *on_disk_refblock; int ret = 0; struct { uint64_t reftable_offset; uint32_t reftable_clusters; } QEMU_PACKED reftable_offset_and_clusters; qcow2_cache_empty(bs, s->refcount_block_cache); write_refblocks: for (; cluster < *nb_clusters; cluster++) { if (!s->get_refcount(*[[pass]], cluster)) { continue; } refblock_index = cluster >> s->refcount_block_bits; refblock_start = refblock_index << s->refcount_block_bits; if (first_free_cluster < refblock_start) { first_free_cluster = refblock_start; } refblock_offset = alloc_clusters_imrt(bs, 1, [[pass]], nb_clusters, &first_free_cluster); if (refblock_offset < 0) { fprintf(stderr, "ERROR allocating refblock: %s\n", strerror(-refblock_offset)); res->check_errors++; ret = refblock_offset; goto fail; } if (reftable_size <= refblock_index) { uint32_t old_reftable_size = reftable_size; uint64_t *new_on_disk_reftable; reftable_size = ROUND_UP((refblock_index + 1) * sizeof(uint64_t), s->cluster_size) / sizeof(uint64_t); new_on_disk_reftable = g_try_realloc([[homing]], reftable_size * sizeof(uint64_t)); if (!new_on_disk_reftable) { res->check_errors++; ret = -ENOMEM; goto fail; } [[homing]] = new_on_disk_reftable; memset([[homing]] + old_reftable_size, 0, (reftable_size - old_reftable_size) * sizeof(uint64_t)); reftable_offset = -1; } [[homing]][refblock_index] = refblock_offset; if (refblock_index == (*nb_clusters - 1) >> s->refcount_block_bits && reftable_offset < 0) { uint64_t reftable_clusters = size_to_clusters(s, reftable_size * sizeof(uint64_t)); reftable_offset = alloc_clusters_imrt(bs, reftable_clusters, [[pass]], nb_clusters, &first_free_cluster); if (reftable_offset < 0) { fprintf(stderr, "ERROR allocating reftable: %s\n", strerror(-reftable_offset)); res->check_errors++; ret = reftable_offset; goto fail; } } ret = qcow2_pre_write_overlap_check(bs, 0, refblock_offset, s->cluster_size); if (ret < 0) { fprintf(stderr, "ERROR writing refblock: %s\n", strerror(-ret)); goto fail; } on_disk_refblock = (void *)((char *) *[[pass]] + refblock_index * s->cluster_size); ret = bdrv_write(bs->file, refblock_offset / BDRV_SECTOR_SIZE, on_disk_refblock, s->cluster_sectors); if (ret < 0) { fprintf(stderr, "ERROR writing refblock: %s\n", strerror(-ret)); goto fail; } cluster = refblock_start + s->refcount_block_size - 1; } if (reftable_offset < 0) { uint64_t post_refblock_start, reftable_clusters; post_refblock_start = ROUND_UP(*nb_clusters, s->refcount_block_size); reftable_clusters = size_to_clusters(s, reftable_size * sizeof(uint64_t)); if (first_free_cluster < post_refblock_start) { first_free_cluster = post_refblock_start; } reftable_offset = alloc_clusters_imrt(bs, reftable_clusters, [[pass]], nb_clusters, &first_free_cluster); if (reftable_offset < 0) { fprintf(stderr, "ERROR allocating reftable: %s\n", strerror(-reftable_offset)); res->check_errors++; ret = reftable_offset; goto fail; } goto write_refblocks; } assert([[homing]]); for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) { cpu_to_be64s(&[[homing]][refblock_index]); } ret = qcow2_pre_write_overlap_check(bs, 0, reftable_offset, reftable_size * sizeof(uint64_t)); if (ret < 0) { fprintf(stderr, "ERROR writing reftable: %s\n", strerror(-ret)); goto fail; } assert(reftable_size < INT_MAX / sizeof(uint64_t)); ret = bdrv_pwrite(bs->file, reftable_offset, [[homing]], reftable_size * sizeof(uint64_t)); if (ret < 0) { fprintf(stderr, "ERROR writing reftable: %s\n", strerror(-ret)); goto fail; } reftable_offset_and_clusters.reftable_offset = cpu_to_be64(reftable_offset); reftable_offset_and_clusters.reftable_clusters = cpu_to_be32(size_to_clusters(s, reftable_size * sizeof(uint64_t))); ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset), &reftable_offset_and_clusters, sizeof(reftable_offset_and_clusters)); if (ret < 0) { fprintf(stderr, "ERROR setting reftable: %s\n", strerror(-ret)); goto fail; } for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) { be64_to_cpus(&[[homing]][refblock_index]); } s->refcount_table = [[homing]]; s->refcount_table_offset = reftable_offset; s->refcount_table_size = reftable_size; update_max_refcount_table_index(s); return 0; fail: g_free([[homing]]); return ret; }[Succeeded / Failed / Skipped / Total] 809 / 73 / 490 / 1372:  51%|     | 1372/2690 [15:07:06<14:31:24, 39.67s/it][Succeeded / Failed / Skipped / Total] 809 / 73 / 490 / 1372:  51%|     | 1373/2690 [15:07:07<14:30:07, 39.64s/it][Succeeded / Failed / Skipped / Total] 809 / 73 / 491 / 1373:  51%|     | 1373/2690 [15:07:07<14:30:07, 39.64s/it][Succeeded / Failed / Skipped / Total] 809 / 73 / 491 / 1373:  51%|     | 1374/2690 [15:07:07<14:28:50, 39.61s/it][Succeeded / Failed / Skipped / Total] 809 / 73 / 492 / 1374:  51%|     | 1374/2690 [15:07:07<14:28:50, 39.61s/it][Succeeded / Failed / Skipped / Total] 809 / 73 / 492 / 1374:  51%|     | 1375/2690 [15:07:12<14:27:37, 39.59s/it][Succeeded / Failed / Skipped / Total] 810 / 73 / 492 / 1375:  51%|     | 1375/2690 [15:07:12<14:27:37, 39.59s/it][Succeeded / Failed / Skipped / Total] 810 / 73 / 492 / 1375:  51%|     | 1376/2690 [15:07:19<14:26:26, 39.56s/it][Succeeded / Failed / Skipped / Total] 811 / 73 / 492 / 1376:  51%|     | 1376/2690 [15:07:19<14:26:26, 39.56s/it][Succeeded / Failed / Skipped / Total] 811 / 73 / 492 / 1376:  51%|     | 1377/2690 [15:07:25<14:25:14, 39.54s/it][Succeeded / Failed / Skipped / Total] 812 / 73 / 492 / 1377:  51%|     | 1377/2690 [15:07:25<14:25:14, 39.54s/it][Succeeded / Failed / Skipped / Total] 812 / 73 / 492 / 1377:  51%|     | 1378/2690 [15:07:41<14:24:13, 39.52s/it][Succeeded / Failed / Skipped / Total] 813 / 73 / 492 / 1378:  51%|     | 1378/2690 [15:07:41<14:24:13, 39.52s/it][Succeeded / Failed / Skipped / Total] 813 / 73 / 492 / 1378:  51%|    | 1379/2690 [15:07:44<14:22:59, 39.50s/it][Succeeded / Failed / Skipped / Total] 814 / 73 / 492 / 1379:  51%|    | 1379/2690 [15:07:44<14:22:59, 39.50s/it][Succeeded / Failed / Skipped / Total] 814 / 73 / 492 / 1379:  51%|    | 1380/2690 [15:07:45<14:21:42, 39.47s/it]
--------------------------------------------- Result 1373 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int seqvideo_decode_init(AVCodecContext *avctx) { SeqVideoContext *seq = avctx->priv_data; seq->avctx = avctx; avctx->pix_fmt = AV_PIX_FMT_PAL8; seq->frame = av_frame_alloc(); if (!seq->frame) return AVERROR(ENOMEM); return 0; }
--------------------------------------------- Result 1374 ---------------------------------------------
[[0 (37%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static BlockAIOCB *bdrv_co_aio_rw_vector(BdrvChild *child, int64_t sector_num, QEMUIOVector *qiov, int nb_sectors, BdrvRequestFlags flags, BlockCompletionFunc *cb, void *opaque, bool is_write) { Coroutine *co; BlockAIOCBCoroutine *acb; acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque); acb->child = child; acb->need_bh = "True" == "True"; acb->req.error = -EINPROGRESS; acb->req.sector = sector_num; acb->req.nb_sectors = nb_sectors; acb->req.qiov = qiov; acb->req.flags = flags; acb->is_write = is_write; co = qemu_coroutine_create(bdrv_co_do_rw); qemu_coroutine_enter(co, acb); bdrv_co_maybe_schedule_bh(acb); return &acb->common; }
--------------------------------------------- Result 1375 ---------------------------------------------
[[0 (67%)]] --> [[0 (46%)]] --> Socre: 0.5353775322437286

[[[[Adv]]]]: static int standard_decode_picture_secondary_header(VC9Context *v) { GetBitContext *gb = &v->s.gb; int [[status]] = 0, index; switch (v->s.pict_type) { case P_TYPE: [[status]] = decode_p_picture_secondary_header(v); break; case B_TYPE: [[status]] = decode_b_picture_secondary_header(v); break; case BI_TYPE: case I_TYPE: break; } if ([[status]] < 0) return FRAME_SKIPED; v->ac_table_level = decode012(gb); if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE) { v->ac2_table_level = decode012(gb); } index = decode012(gb); v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index]; v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index]; return 0; }

[[[[Adv]]]]: static int standard_decode_picture_secondary_header(VC9Context *v) { GetBitContext *gb = &v->s.gb; int [[statutory]] = 0, index; switch (v->s.pict_type) { case P_TYPE: [[statutory]] = decode_p_picture_secondary_header(v); break; case B_TYPE: [[statutory]] = decode_b_picture_secondary_header(v); break; case BI_TYPE: case I_TYPE: break; } if ([[statutory]] < 0) return FRAME_SKIPED; v->ac_table_level = decode012(gb); if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE) { v->ac2_table_level = decode012(gb); } index = decode012(gb); v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index]; v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index]; return 0; }
--------------------------------------------- Result 1376 ---------------------------------------------
[[0 (59%)]] --> [[0 (43%)]] --> Socre: 0.5715778768062592

[[[[Adv]]]]: static void ccw_machine_class_init(ObjectClass *oc, void *[[data]]) { MachineClass *mc = MACHINE_CLASS(oc); NMIClass *nc = NMI_CLASS(oc); HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc); S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc); s390mc->ri_allowed = "True" == "True"; s390mc->cpu_model_allowed = "True" == "True"; s390mc->css_migration_enabled = "True" == "True"; s390mc->gs_allowed = "True" == "True"; mc->init = ccw_init; mc->reset = s390_machine_reset; mc->hot_add_cpu = s390_hot_add_cpu; mc->block_default_type = IF_VIRTIO; mc->no_cdrom = 1; mc->no_floppy = 1; mc->no_serial = 1; mc->no_parallel = 1; mc->no_sdcard = 1; mc->use_sclp = 1; mc->max_cpus = S390_MAX_CPUS; mc->has_hotpluggable_cpus = "True" == "True"; mc->get_hotplug_handler = s390_get_hotplug_handler; mc->cpu_index_to_instance_props = s390_cpu_index_to_props; mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids; mc->default_cpu_type = S390_CPU_TYPE_NAME("qemu"); hc->plug = s390_machine_device_plug; hc->unplug_request = s390_machine_device_unplug_request; nc->nmi_monitor_handler = s390_nmi; }

[[[[Adv]]]]: static void ccw_machine_class_init(ObjectClass *oc, void *[[database]]) { MachineClass *mc = MACHINE_CLASS(oc); NMIClass *nc = NMI_CLASS(oc); HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc); S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc); s390mc->ri_allowed = "True" == "True"; s390mc->cpu_model_allowed = "True" == "True"; s390mc->css_migration_enabled = "True" == "True"; s390mc->gs_allowed = "True" == "True"; mc->init = ccw_init; mc->reset = s390_machine_reset; mc->hot_add_cpu = s390_hot_add_cpu; mc->block_default_type = IF_VIRTIO; mc->no_cdrom = 1; mc->no_floppy = 1; mc->no_serial = 1; mc->no_parallel = 1; mc->no_sdcard = 1; mc->use_sclp = 1; mc->max_cpus = S390_MAX_CPUS; mc->has_hotpluggable_cpus = "True" == "True"; mc->get_hotplug_handler = s390_get_hotplug_handler; mc->cpu_index_to_instance_props = s390_cpu_index_to_props; mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids; mc->default_cpu_type = S390_CPU_TYPE_NAME("qemu"); hc->plug = s390_machine_device_plug; hc->unplug_request = s390_machine_device_unplug_request; nc->nmi_monitor_handler = s390_nmi; }
--------------------------------------------- Result 1377 ---------------------------------------------
[[0 (90%)]] --> [[0 (32%)]] --> Socre: 0.6765941977500916

[[[[Adv]]]]: static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int [[num_strips]], int data_size) { buf[0] = 0; AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE); AV_WB16(&buf[4], s->w); AV_WB16(&buf[6], s->h); AV_WB16(&buf[8], [[num_strips]]); return CVID_HEADER_SIZE; }

[[[[Adv]]]]: static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int [[wholly]], int data_size) { buf[0] = 0; AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE); AV_WB16(&buf[4], s->w); AV_WB16(&buf[6], s->h); AV_WB16(&buf[8], [[wholly]]); return CVID_HEADER_SIZE; }
--------------------------------------------- Result 1378 ---------------------------------------------
[[0 (75%)]] --> [[0 (49%)]] --> Socre: 0.5066550970077515

[[[[Adv]]]]: static av_cold int mpeg4video_parse_init(AVCodecParserContext *[[s]]) { ParseContext1 *[[pc]] = [[s]]->priv_data; [[pc]]->enc = av_mallocz(sizeof(MpegEncContext)); if (![[pc]]->enc) return -1; [[pc]]->first_picture = 1; return 0; }

[[[[Adv]]]]: static av_cold int mpeg4video_parse_init(AVCodecParserContext *[[z]]) { ParseContext1 *[[appliance]] = [[z]]->priv_data; [[appliance]]->enc = av_mallocz(sizeof(MpegEncContext)); if (![[appliance]]->enc) return -1; [[appliance]]->first_picture = 1; return 0; }
--------------------------------------------- Result 1379 ---------------------------------------------
[[0 (50%)]] --> [[0 (18%)]] --> Socre: 0.8194823861122131

[[[[Adv]]]]: const AVOption *av_opt_next(void *[[obj]], const AVOption *last) { AVClass *class = *(AVClass**)[[obj]]; if (!last && class->option[0].name) return class->option; if (last && last[1].name) return ++last; return NULL; }

[[[[Adv]]]]: const AVOption *av_opt_next(void *[[escaflowne]], const AVOption *last) { AVClass *class = *(AVClass**)[[escaflowne]]; if (!last && class->option[0].name) return class->option; if (last && last[1].name) return ++last; return NULL; }
--------------------------------------------- Result 1380 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 814 / 73 / 493 / 1380:  51%|    | 1380/2690 [15:07:45<14:21:42, 39.47s/it][Succeeded / Failed / Skipped / Total] 814 / 73 / 493 / 1380:  51%|    | 1381/2690 [15:08:01<14:20:40, 39.45s/it][[0 (38%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void do_audio_out(AVFormatContext *s, OutputStream *ost, InputStream *ist, AVFrame *decoded_frame) { uint8_t *buftmp; int size_out, frame_bytes, resample_changed, ret; AVCodecContext *enc = ost->st->codec; AVCodecContext *dec = ist->st->codec; int osize = av_get_bytes_per_sample(enc->sample_fmt); int isize = av_get_bytes_per_sample(dec->sample_fmt); uint8_t *buf = decoded_frame->data[0]; int size = decoded_frame->nb_samples * dec->channels * isize; int out_linesize = 0; int buf_linesize = decoded_frame->linesize[0]; get_default_channel_layouts(ost, ist); if (alloc_audio_output_buf(dec, enc, decoded_frame->nb_samples, &out_linesize) < 0) { av_log(NULL, AV_LOG_FATAL, "Error allocating audio buffer\n"); exit_program(1); } if (audio_sync_method > 1 || enc->channels != dec->channels || enc->channel_layout != dec->channel_layout || enc->sample_rate != dec->sample_rate || dec->sample_fmt != enc->sample_fmt) ost->audio_resample = 1; resample_changed = ost->resample_sample_fmt != dec->sample_fmt || ost->resample_channels != dec->channels || ost->resample_channel_layout != dec->channel_layout || ost->resample_sample_rate != dec->sample_rate; if ((ost->audio_resample && !ost->avr) || resample_changed) { if (resample_changed) { av_log(NULL, AV_LOG_INFO, "Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d chl:0x%"PRIx64" to rate:%d fmt:%s ch:%d chl:0x%"PRIx64"\n", ist->file_index, ist->st->index, ost->resample_sample_rate, av_get_sample_fmt_name(ost->resample_sample_fmt), ost->resample_channels, ost->resample_channel_layout, dec->sample_rate, av_get_sample_fmt_name(dec->sample_fmt), dec->channels, dec->channel_layout); ost->resample_sample_fmt = dec->sample_fmt; ost->resample_channels = dec->channels; ost->resample_channel_layout = dec->channel_layout; ost->resample_sample_rate = dec->sample_rate; if (ost->avr) avresample_close(ost->avr); } if (audio_sync_method <= 1 && ost->resample_sample_fmt == enc->sample_fmt && ost->resample_channels == enc->channels && ost->resample_channel_layout == enc->channel_layout && ost->resample_sample_rate == enc->sample_rate) { ost->audio_resample = 0; } else if (ost->audio_resample) { if (!ost->avr) { ost->avr = avresample_alloc_context(); if (!ost->avr) { av_log(NULL, AV_LOG_FATAL, "Error allocating context for libavresample\n"); exit_program(1); } } av_opt_set_int(ost->avr, "in_channel_layout", dec->channel_layout, 0); av_opt_set_int(ost->avr, "in_sample_fmt", dec->sample_fmt, 0); av_opt_set_int(ost->avr, "in_sample_rate", dec->sample_rate, 0); av_opt_set_int(ost->avr, "out_channel_layout", enc->channel_layout, 0); av_opt_set_int(ost->avr, "out_sample_fmt", enc->sample_fmt, 0); av_opt_set_int(ost->avr, "out_sample_rate", enc->sample_rate, 0); if (audio_sync_method > 1) av_opt_set_int(ost->avr, "force_resampling", 1, 0); if (av_get_bytes_per_sample(dec->sample_fmt) <= 2 && av_get_bytes_per_sample(enc->sample_fmt) <= 2) { av_opt_set_int(ost->avr, "internal_sample_fmt", AV_SAMPLE_FMT_S16P, 0); } ret = avresample_open(ost->avr); if (ret < 0) { av_log(NULL, AV_LOG_FATAL, "Error opening libavresample\n"); exit_program(1); } } } if (audio_sync_method > 0) { double delta = get_sync_ipts(ost, ist->last_dts) * enc->sample_rate - ost->sync_opts - av_fifo_size(ost->fifo) / (enc->channels * osize); int idelta = delta * dec->sample_rate / enc->sample_rate; int byte_delta = idelta * isize * dec->channels; if (fabs(delta) > 50) { if (ist->is_start || fabs(delta) > audio_drift_threshold*enc->sample_rate) { if (byte_delta < 0) { byte_delta = FFMAX(byte_delta, -size); size += byte_delta; buf -= byte_delta; av_log(NULL, AV_LOG_VERBOSE, "discarding %d audio samples\n", -byte_delta / (isize * dec->channels)); if (!size) return; ist->is_start = 0; } else { av_fast_malloc(&async_buf, &allocated_async_buf_size, byte_delta + size); if (!async_buf) { av_log(NULL, AV_LOG_FATAL, "Out of memory in do_audio_out\n"); exit_program(1); } if (alloc_audio_output_buf(dec, enc, decoded_frame->nb_samples + idelta, &out_linesize) < 0) { av_log(NULL, AV_LOG_FATAL, "Error allocating audio buffer\n"); exit_program(1); } ist->is_start = 0; generate_silence(async_buf, dec->sample_fmt, byte_delta); memcpy(async_buf + byte_delta, buf, size); buf = async_buf; size += byte_delta; buf_linesize = allocated_async_buf_size; av_log(NULL, AV_LOG_VERBOSE, "adding %d audio samples of silence\n", idelta); } } else if (audio_sync_method > 1) { int comp = av_clip(delta, -audio_sync_method, audio_sync_method); av_log(NULL, AV_LOG_VERBOSE, "compensating audio timestamp drift:%f compensation:%d in:%d\n", delta, comp, enc->sample_rate); avresample_set_compensation(ost->avr, comp, enc->sample_rate); } } } else if (audio_sync_method == 0) ost->sync_opts = lrintf(get_sync_ipts(ost, ist->last_dts) * enc->sample_rate) - av_fifo_size(ost->fifo) / (enc->channels * osize); if (ost->audio_resample) { buftmp = audio_buf; size_out = avresample_convert(ost->avr, (void **)&buftmp, allocated_audio_buf_size, out_linesize, (void **)&buf, buf_linesize, size / (dec->channels * isize)); size_out = size_out * enc->channels * osize; } else { buftmp = buf; size_out = size; } if (!(enc->codec->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE)) { if (av_fifo_realloc2(ost->fifo, av_fifo_size(ost->fifo) + size_out) < 0) { av_log(NULL, AV_LOG_FATAL, "av_fifo_realloc2() failed\n"); exit_program(1); } av_fifo_generic_write(ost->fifo, buftmp, size_out, NULL); frame_bytes = enc->frame_size * osize * enc->channels; while (av_fifo_size(ost->fifo) >= frame_bytes) { av_fifo_generic_read(ost->fifo, audio_buf, frame_bytes, NULL); encode_audio_frame(s, ost, audio_buf, frame_bytes); } } else { encode_audio_frame(s, ost, buftmp, size_out); } }
--------------------------------------------- Result 1381 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 815 / 73 / 493 / 1381:  51%|    | 1381/2690 [15:08:01<14:20:40, 39.45s/it][Succeeded / Failed / Skipped / Total] 815 / 73 / 493 / 1381:  51%|    | 1382/2690 [15:08:18<14:19:40, 39.43s/it][Succeeded / Failed / Skipped / Total] 816 / 73 / 493 / 1382:  51%|    | 1382/2690 [15:08:18<14:19:40, 39.43s/it][Succeeded / Failed / Skipped / Total] 816 / 73 / 493 / 1382:  51%|    | 1383/2690 [15:25:17<14:34:26, 40.14s/it][Succeeded / Failed / Skipped / Total] 816 / 74 / 493 / 1383:  51%|    | 1383/2690 [15:25:17<14:34:26, 40.14s/it][Succeeded / Failed / Skipped / Total] 816 / 74 / 493 / 1383:  51%|    | 1384/2690 [15:25:17<14:33:09, 40.11s/it][Succeeded / Failed / Skipped / Total] 816 / 74 / 494 / 1384:  51%|    | 1384/2690 [15:25:17<14:33:09, 40.11s/it][Succeeded / Failed / Skipped / Total] 816 / 74 / 494 / 1384:  51%|    | 1385/2690 [15:25:33<14:32:05, 40.10s/it][[0 (99%)]] --> [[0 (49%)]] --> Socre: 0.5063571631908417

[[[[Adv]]]]: static void vscsi_command_complete(SCSIBus *bus, int reason, uint32_t tag, uint32_t arg) { VSCSIState *s = DO_UPCAST(VSCSIState, vdev.qdev, bus->qbus.parent); vscsi_req *req = vscsi_find_req(s, tag); SCSIDevice *sdev; uint8_t *[[buf]]; int32_t res_in = 0, res_out = 0; int len, rc = 0; dprintf("VSCSI: SCSI cmd complete, r=0x%x tag=0x%x arg=0x%x, req=%p\n", reason, tag, arg, req); if (req == NULL) { fprintf(stderr, "VSCSI: Can't find request for tag 0x%x\n", tag); return; } sdev = req->sdev; if (req->sensing) { if (reason == SCSI_REASON_DONE) { dprintf("VSCSI: Sense done !\n"); vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0); vscsi_put_req(s, req); } else { uint8_t *[[buf]] = sdev->info->get_buf(sdev, tag); len = MIN(arg, SCSI_SENSE_BUF_SIZE); dprintf("VSCSI: Sense data, %d bytes:\n", len); dprintf(" %02x %02x %02x %02x %02x %02x %02x %02x\n", [[buf]][0], [[buf]][1], [[buf]][2], [[buf]][3], [[buf]][4], [[buf]][5], [[buf]][6], [[buf]][7]); dprintf(" %02x %02x %02x %02x %02x %02x %02x %02x\n", [[buf]][8], [[buf]][9], [[buf]][10], [[buf]][11], [[buf]][12], [[buf]][13], [[buf]][14], [[buf]][15]); memcpy(req->sense, [[buf]], len); req->senselen = len; sdev->info->read_data(sdev, req->qtag); } return; } if (reason == SCSI_REASON_DONE) { dprintf("VSCSI: Command complete err=%d\n", arg); if (arg == 0) { if (req->writing) { res_out = req->data_len; } else { res_in = req->data_len; } vscsi_send_rsp(s, req, 0, res_in, res_out); } else if (arg == CHECK_CONDITION) { dprintf("VSCSI: Got CHECK_CONDITION, requesting sense...\n"); vscsi_send_request_sense(s, req); return; } else { vscsi_send_rsp(s, req, arg, 0, 0); } vscsi_put_req(s, req); return; } if (arg) { [[buf]] = sdev->info->get_buf(sdev, tag); rc = vscsi_srp_transfer_data(s, req, req->writing, [[buf]], arg); } if (rc < 0) { fprintf(stderr, "VSCSI: RDMA error rc=%d!\n", rc); sdev->info->cancel_io(sdev, req->qtag); vscsi_makeup_sense(s, req, HARDWARE_ERROR, 0, 0); vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0); vscsi_put_req(s, req); return; } req->data_len -= rc; if (req->writing) { sdev->info->write_data(sdev, req->qtag); } else { sdev->info->read_data(sdev, req->qtag); } }

[[[[Adv]]]]: static void vscsi_command_complete(SCSIBus *bus, int reason, uint32_t tag, uint32_t arg) { VSCSIState *s = DO_UPCAST(VSCSIState, vdev.qdev, bus->qbus.parent); vscsi_req *req = vscsi_find_req(s, tag); SCSIDevice *sdev; uint8_t *[[n]]; int32_t res_in = 0, res_out = 0; int len, rc = 0; dprintf("VSCSI: SCSI cmd complete, r=0x%x tag=0x%x arg=0x%x, req=%p\n", reason, tag, arg, req); if (req == NULL) { fprintf(stderr, "VSCSI: Can't find request for tag 0x%x\n", tag); return; } sdev = req->sdev; if (req->sensing) { if (reason == SCSI_REASON_DONE) { dprintf("VSCSI: Sense done !\n"); vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0); vscsi_put_req(s, req); } else { uint8_t *[[n]] = sdev->info->get_buf(sdev, tag); len = MIN(arg, SCSI_SENSE_BUF_SIZE); dprintf("VSCSI: Sense data, %d bytes:\n", len); dprintf(" %02x %02x %02x %02x %02x %02x %02x %02x\n", [[n]][0], [[n]][1], [[n]][2], [[n]][3], [[n]][4], [[n]][5], [[n]][6], [[n]][7]); dprintf(" %02x %02x %02x %02x %02x %02x %02x %02x\n", [[n]][8], [[n]][9], [[n]][10], [[n]][11], [[n]][12], [[n]][13], [[n]][14], [[n]][15]); memcpy(req->sense, [[n]], len); req->senselen = len; sdev->info->read_data(sdev, req->qtag); } return; } if (reason == SCSI_REASON_DONE) { dprintf("VSCSI: Command complete err=%d\n", arg); if (arg == 0) { if (req->writing) { res_out = req->data_len; } else { res_in = req->data_len; } vscsi_send_rsp(s, req, 0, res_in, res_out); } else if (arg == CHECK_CONDITION) { dprintf("VSCSI: Got CHECK_CONDITION, requesting sense...\n"); vscsi_send_request_sense(s, req); return; } else { vscsi_send_rsp(s, req, arg, 0, 0); } vscsi_put_req(s, req); return; } if (arg) { [[n]] = sdev->info->get_buf(sdev, tag); rc = vscsi_srp_transfer_data(s, req, req->writing, [[n]], arg); } if (rc < 0) { fprintf(stderr, "VSCSI: RDMA error rc=%d!\n", rc); sdev->info->cancel_io(sdev, req->qtag); vscsi_makeup_sense(s, req, HARDWARE_ERROR, 0, 0); vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0); vscsi_put_req(s, req); return; } req->data_len -= rc; if (req->writing) { sdev->info->write_data(sdev, req->qtag); } else { sdev->info->read_data(sdev, req->qtag); } }
--------------------------------------------- Result 1382 ---------------------------------------------
[[0 (93%)]] --> [[0 (49%)]] --> Socre: 0.509438693523407

[[[[Adv]]]]: static inline void gen_arm_shift_im(TCGv var, int shiftop, int shift, int flags) { switch (shiftop) { case 0: if (shift != 0) { if (flags) shifter_out_im(var, 32 - shift); tcg_gen_shli_i32(var, var, shift); } break; case 1: if (shift == 0) { if (flags) { tcg_gen_shri_i32(var, var, 31); gen_set_CF(var); } tcg_gen_movi_i32(var, 0); } else { if (flags) shifter_out_im(var, shift - 1); tcg_gen_shri_i32(var, var, shift); } break; case 2: if (shift == 0) shift = 32; if (flags) shifter_out_im(var, shift - 1); if (shift == 32) shift = 31; tcg_gen_sari_i32(var, var, shift); break; case 3: if (shift != 0) { if (flags) shifter_out_im(var, shift - 1); tcg_gen_rotri_i32(var, var, shift); break; } else { TCGv [[tmp]] = load_cpu_field(CF); if (flags) shifter_out_im(var, 0); tcg_gen_shri_i32(var, var, 1); tcg_gen_shli_i32([[tmp]], [[tmp]], 31); tcg_gen_or_i32(var, var, [[tmp]]); dead_tmp([[tmp]]); } } };

[[[[Adv]]]]: static inline void gen_arm_shift_im(TCGv var, int shiftop, int shift, int flags) { switch (shiftop) { case 0: if (shift != 0) { if (flags) shifter_out_im(var, 32 - shift); tcg_gen_shli_i32(var, var, shift); } break; case 1: if (shift == 0) { if (flags) { tcg_gen_shri_i32(var, var, 31); gen_set_CF(var); } tcg_gen_movi_i32(var, 0); } else { if (flags) shifter_out_im(var, shift - 1); tcg_gen_shri_i32(var, var, shift); } break; case 2: if (shift == 0) shift = 32; if (flags) shifter_out_im(var, shift - 1); if (shift == 32) shift = 31; tcg_gen_sari_i32(var, var, shift); break; case 3: if (shift != 0) { if (flags) shifter_out_im(var, shift - 1); tcg_gen_rotri_i32(var, var, shift); break; } else { TCGv [[scuffling]] = load_cpu_field(CF); if (flags) shifter_out_im(var, 0); tcg_gen_shri_i32(var, var, 1); tcg_gen_shli_i32([[scuffling]], [[scuffling]], 31); tcg_gen_or_i32(var, var, [[scuffling]]); dead_tmp([[scuffling]]); } } };
--------------------------------------------- Result 1383 ---------------------------------------------
[[0 (91%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void vmxnet3_update_vlan_filters(VMXNET3State *s) { int i; VMXNET3_READ_DRV_SHARED(s->drv_shmem, devRead.rxFilterConf.vfTable, s->vlan_table, sizeof(s->vlan_table)); for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) { s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]); } VMW_CFPRN("Configured VLANs:"); for (i = 0; i < sizeof(s->vlan_table) * 8; i++) { if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) { VMW_CFPRN("\tVLAN %d is present", i); } } }

[[[[Adv]]]]: static void vmxnet3_update_vlan_filters(VMXNET3State *s) { int i; VMXNET3_READ_DRV_SHARED(s->drv_shmem, devRead.rxFilterConf.vfTable, s->vlan_table, sizeof(s->vlan_table)); for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) { s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]); } VMW_CFPRN("Configured VLANs:"); for (i = 0; i < sizeof(s->vlan_table) * 8; i++) { if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) { VMW_CFPRN("\tVLAN %d is present", i); } } }
--------------------------------------------- Result 1384 ---------------------------------------------
[[0 (73%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int kvm_log_start(target_phys_addr_t phys_addr, ram_addr_t size) { return kvm_dirty_pages_log_change(phys_addr, size, KVM_MEM_LOG_DIRTY_PAGES, KVM_MEM_LOG_DIRTY_PAGES); }
--------------------------------------------- Result 1385 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 817 / 74 / 494 / 1385:  51%|    | 1385/2690 [15:25:33<14:32:05, 40.10s/it][Succeeded / Failed / Skipped / Total] 817 / 74 / 494 / 1385:  52%|    | 1386/2690 [15:25:37<14:30:51, 40.07s/it][Succeeded / Failed / Skipped / Total] 818 / 74 / 494 / 1386:  52%|    | 1386/2690 [15:25:37<14:30:51, 40.07s/it][Succeeded / Failed / Skipped / Total] 818 / 74 / 494 / 1386:  52%|    | 1387/2690 [15:34:55<14:38:18, 40.44s/it][[0 (13%)]] --> [[0 (55%)]] --> Socre: 0.5476455092430115

[[[[Adv]]]]: static void do_log(int [[argc]], const char **[[argv]]) { int mask; if ([[argc]] != 2) goto help; if (!strcmp([[argv]][1], "none")) { mask = 0; } else { mask = cpu_str_to_log_mask([[argv]][1]); if (!mask) { help: help_cmd([[argv]][0]); return; } } cpu_set_log(mask); }

[[[[Adv]]]]: static void do_log(int [[dubarry]], const char **[[frenchman]]) { int mask; if ([[dubarry]] != 2) goto help; if (!strcmp([[frenchman]][1], "none")) { mask = 0; } else { mask = cpu_str_to_log_mask([[frenchman]][1]); if (!mask) { help: help_cmd([[frenchman]][0]); return; } } cpu_set_log(mask); }
--------------------------------------------- Result 1386 ---------------------------------------------
[[0 (48%)]] --> [[0 (54%)]] --> Socre: 0.5417864322662354

[[[[Adv]]]]: static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread) { HEVCContext *s = avctxt->priv_data; int ctb_size = 1 << s->sps->log2_ctb_size; int [[more_data]] = 1; int x_ctb = 0; int y_ctb = 0; int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs]; if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) { av_log(s->avctx, AV_LOG_ERROR, "Impossible initial tile.\n"); return AVERROR_INVALIDDATA; } if (s->sh.dependent_slice_segment_flag) { int prev_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts - 1]; if (s->tab_slice_address[prev_rs] == -1) { av_log(s->avctx, AV_LOG_ERROR, "Previous slice segment missing\n"); return AVERROR_INVALIDDATA; } } while ([[more_data]] && ctb_addr_ts < s->sps->ctb_size) { int ctb_addr_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts]; x_ctb = (ctb_addr_rs % ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size; y_ctb = (ctb_addr_rs / ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size; hls_decode_neighbour(s, x_ctb, y_ctb, ctb_addr_ts); ff_hevc_cabac_init(s, ctb_addr_ts); hls_sao_param(s, x_ctb >> s->sps->log2_ctb_size, y_ctb >> s->sps->log2_ctb_size); s->deblock[ctb_addr_rs].beta_offset = s->sh.beta_offset; s->deblock[ctb_addr_rs].tc_offset = s->sh.tc_offset; s->filter_slice_edges[ctb_addr_rs] = s->sh.slice_loop_filter_across_slices_enabled_flag; [[more_data]] = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0); if ([[more_data]] < 0) { s->tab_slice_address[ctb_addr_rs] = -1; return [[more_data]]; } ctb_addr_ts++; ff_hevc_save_states(s, ctb_addr_ts); ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size); } if (x_ctb + ctb_size >= s->sps->width && y_ctb + ctb_size >= s->sps->height) ff_hevc_hls_filter(s, x_ctb, y_ctb); return ctb_addr_ts; }

[[[[Adv]]]]: static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread) { HEVCContext *s = avctxt->priv_data; int ctb_size = 1 << s->sps->log2_ctb_size; int [[cosmic]] = 1; int x_ctb = 0; int y_ctb = 0; int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs]; if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) { av_log(s->avctx, AV_LOG_ERROR, "Impossible initial tile.\n"); return AVERROR_INVALIDDATA; } if (s->sh.dependent_slice_segment_flag) { int prev_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts - 1]; if (s->tab_slice_address[prev_rs] == -1) { av_log(s->avctx, AV_LOG_ERROR, "Previous slice segment missing\n"); return AVERROR_INVALIDDATA; } } while ([[cosmic]] && ctb_addr_ts < s->sps->ctb_size) { int ctb_addr_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts]; x_ctb = (ctb_addr_rs % ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size; y_ctb = (ctb_addr_rs / ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size; hls_decode_neighbour(s, x_ctb, y_ctb, ctb_addr_ts); ff_hevc_cabac_init(s, ctb_addr_ts); hls_sao_param(s, x_ctb >> s->sps->log2_ctb_size, y_ctb >> s->sps->log2_ctb_size); s->deblock[ctb_addr_rs].beta_offset = s->sh.beta_offset; s->deblock[ctb_addr_rs].tc_offset = s->sh.tc_offset; s->filter_slice_edges[ctb_addr_rs] = s->sh.slice_loop_filter_across_slices_enabled_flag; [[cosmic]] = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0); if ([[cosmic]] < 0) { s->tab_slice_address[ctb_addr_rs] = -1; return [[cosmic]]; } ctb_addr_ts++; ff_hevc_save_states(s, ctb_addr_ts); ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size); } if (x_ctb + ctb_size >= s->sps->width && y_ctb + ctb_size >= s->sps->height) ff_hevc_hls_filter(s, x_ctb, y_ctb); return ctb_addr_ts; }
--------------------------------------------- Result 1387 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 819 / 74 / 494 / 1387:  52%|    | 1387/2690 [15:34:55<14:38:18, 40.44s/it][Succeeded / Failed / Skipped / Total] 819 / 74 / 494 / 1387:  52%|    | 1388/2690 [15:34:56<14:37:00, 40.42s/it][Succeeded / Failed / Skipped / Total] 819 / 74 / 495 / 1388:  52%|    | 1388/2690 [15:34:56<14:37:00, 40.42s/it][Succeeded / Failed / Skipped / Total] 819 / 74 / 495 / 1388:  52%|    | 1389/2690 [15:34:56<14:35:42, 40.39s/it][Succeeded / Failed / Skipped / Total] 819 / 74 / 496 / 1389:  52%|    | 1389/2690 [15:34:56<14:35:42, 40.39s/it][Succeeded / Failed / Skipped / Total] 819 / 74 / 496 / 1389:  52%|    | 1390/2690 [15:34:59<14:34:27, 40.36s/it][Succeeded / Failed / Skipped / Total] 820 / 74 / 496 / 1390:  52%|    | 1390/2690 [15:34:59<14:34:27, 40.36s/it][Succeeded / Failed / Skipped / Total] 820 / 74 / 496 / 1390:  52%|    | 1391/2690 [15:35:09<14:33:18, 40.34s/it][Succeeded / Failed / Skipped / Total] 821 / 74 / 496 / 1391:  52%|    | 1391/2690 [15:35:09<14:33:18, 40.34s/it][Succeeded / Failed / Skipped / Total] 821 / 74 / 496 / 1391:  52%|    | 1392/2690 [15:35:10<14:32:01, 40.31s/it][[0 (96%)]] --> [[0 (49%)]] --> Socre: 0.5064164698123932

[[[[Adv]]]]: av_cold int ff_ivi_init_planes(IVIPlaneDesc *[[planes]], const IVIPicConfig *[[cfg]], int [[is_indeo4]]) { int [[p]], b; uint32_t [[b_width]], b_height, align_fac, width_aligned, height_aligned, buf_size; IVIBandDesc *band; ivi_free_buffers([[planes]]); if (av_image_check_size([[cfg]]->pic_width, [[cfg]]->pic_height, 0, NULL) < 0 || [[cfg]]->luma_bands < 1 || [[cfg]]->chroma_bands < 1) return AVERROR_INVALIDDATA; [[planes]][0].width = [[cfg]]->pic_width; [[planes]][0].height = [[cfg]]->pic_height; [[planes]][0].num_bands = [[cfg]]->luma_bands; [[planes]][1].width = [[planes]][2].width = ([[cfg]]->pic_width + 3) >> 2; [[planes]][1].height = [[planes]][2].height = ([[cfg]]->pic_height + 3) >> 2; [[planes]][1].num_bands = [[planes]][2].num_bands = [[cfg]]->chroma_bands; for ([[p]] = 0; [[p]] < 3; [[p]]++) { [[planes]][[[p]]].bands = av_mallocz_array([[planes]][[[p]]].num_bands, sizeof(IVIBandDesc)); if (![[planes]][[[p]]].bands) return AVERROR(ENOMEM); [[b_width]] = [[planes]][[[p]]].num_bands == 1 ? [[planes]][[[p]]].width : ([[planes]][[[p]]].width + 1) >> 1; b_height = [[planes]][[[p]]].num_bands == 1 ? [[planes]][[[p]]].height : ([[planes]][[[p]]].height + 1) >> 1; align_fac = [[p]] ? 8 : 16; width_aligned = FFALIGN([[b_width]] , align_fac); height_aligned = FFALIGN(b_height, align_fac); buf_size = width_aligned * height_aligned * sizeof(int16_t); for (b = 0; b < [[planes]][[[p]]].num_bands; b++) { band = &[[planes]][[[p]]].bands[b]; band->plane = [[p]]; band->band_num = b; band->width = [[b_width]]; band->height = b_height; band->pitch = width_aligned; band->aheight = height_aligned; band->bufs[0] = av_mallocz(buf_size); band->bufs[1] = av_mallocz(buf_size); band->bufsize = buf_size/2; if (!band->bufs[0] || !band->bufs[1]) return AVERROR(ENOMEM); if ([[cfg]]->luma_bands > 1) { band->bufs[2] = av_mallocz(buf_size); if (!band->bufs[2]) return AVERROR(ENOMEM); } if ([[is_indeo4]]) { band->bufs[3] = av_mallocz(buf_size); if (!band->bufs[3]) return AVERROR(ENOMEM); } [[planes]][[[p]]].bands[0].blk_vlc.cust_desc.num_rows = 0; } } return 0; }

[[[[Adv]]]]: av_cold int ff_ivi_init_planes(IVIPlaneDesc *[[chopper]], const IVIPicConfig *[[parky]], int [[supervisor]]) { int [[phosphate]], b; uint32_t [[accelerator]], b_height, align_fac, width_aligned, height_aligned, buf_size; IVIBandDesc *band; ivi_free_buffers([[chopper]]); if (av_image_check_size([[parky]]->pic_width, [[parky]]->pic_height, 0, NULL) < 0 || [[parky]]->luma_bands < 1 || [[parky]]->chroma_bands < 1) return AVERROR_INVALIDDATA; [[chopper]][0].width = [[parky]]->pic_width; [[chopper]][0].height = [[parky]]->pic_height; [[chopper]][0].num_bands = [[parky]]->luma_bands; [[chopper]][1].width = [[chopper]][2].width = ([[parky]]->pic_width + 3) >> 2; [[chopper]][1].height = [[chopper]][2].height = ([[parky]]->pic_height + 3) >> 2; [[chopper]][1].num_bands = [[chopper]][2].num_bands = [[parky]]->chroma_bands; for ([[phosphate]] = 0; [[phosphate]] < 3; [[phosphate]]++) { [[chopper]][[[phosphate]]].bands = av_mallocz_array([[chopper]][[[phosphate]]].num_bands, sizeof(IVIBandDesc)); if (![[chopper]][[[phosphate]]].bands) return AVERROR(ENOMEM); [[accelerator]] = [[chopper]][[[phosphate]]].num_bands == 1 ? [[chopper]][[[phosphate]]].width : ([[chopper]][[[phosphate]]].width + 1) >> 1; b_height = [[chopper]][[[phosphate]]].num_bands == 1 ? [[chopper]][[[phosphate]]].height : ([[chopper]][[[phosphate]]].height + 1) >> 1; align_fac = [[phosphate]] ? 8 : 16; width_aligned = FFALIGN([[accelerator]] , align_fac); height_aligned = FFALIGN(b_height, align_fac); buf_size = width_aligned * height_aligned * sizeof(int16_t); for (b = 0; b < [[chopper]][[[phosphate]]].num_bands; b++) { band = &[[chopper]][[[phosphate]]].bands[b]; band->plane = [[phosphate]]; band->band_num = b; band->width = [[accelerator]]; band->height = b_height; band->pitch = width_aligned; band->aheight = height_aligned; band->bufs[0] = av_mallocz(buf_size); band->bufs[1] = av_mallocz(buf_size); band->bufsize = buf_size/2; if (!band->bufs[0] || !band->bufs[1]) return AVERROR(ENOMEM); if ([[parky]]->luma_bands > 1) { band->bufs[2] = av_mallocz(buf_size); if (!band->bufs[2]) return AVERROR(ENOMEM); } if ([[supervisor]]) { band->bufs[3] = av_mallocz(buf_size); if (!band->bufs[3]) return AVERROR(ENOMEM); } [[chopper]][[[phosphate]]].bands[0].blk_vlc.cust_desc.num_rows = 0; } } return 0; }
--------------------------------------------- Result 1388 ---------------------------------------------
[[0 (7%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int init(AVFilterContext *ctx, const char *args) { GradFunContext *gf = ctx->priv; float thresh = 1.2; int radius = 16; if (args) sscanf(args, "%f:%d", &thresh, &radius); thresh = av_clipf(thresh, 0.51, 255); gf->thresh = (1 << 15) / thresh; gf->radius = av_clip((radius + 1) & ~1, 4, 32); gf->blur_line = ff_gradfun_blur_line_c; gf->filter_line = ff_gradfun_filter_line_c; if (ARCH_X86) ff_gradfun_init_x86(gf); av_log(ctx, AV_LOG_VERBOSE, "threshold:%.2f radius:%d\n", thresh, gf->radius); return 0; }
--------------------------------------------- Result 1389 ---------------------------------------------
[[0 (84%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int kvm_client_migration_log(struct CPUPhysMemoryClient *client, int enable) { return kvm_set_migration_log(enable); }
--------------------------------------------- Result 1390 ---------------------------------------------
[[0 (39%)]] --> [[0 (51%)]] --> Socre: 0.5117975473403931

[[[[Adv]]]]: static int64_t rtmp_read_seek(URLContext *s, int stream_index, int64_t timestamp, int [[flags]]) { RTMP *r = s->priv_data; if ([[flags]] & AVSEEK_FLAG_BYTE) return AVERROR(ENOSYS); timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000); if (!RTMP_SendSeek(r, timestamp)) return -1; return timestamp; }

[[[[Adv]]]]: static int64_t rtmp_read_seek(URLContext *s, int stream_index, int64_t timestamp, int [[color]]) { RTMP *r = s->priv_data; if ([[color]] & AVSEEK_FLAG_BYTE) return AVERROR(ENOSYS); timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000); if (!RTMP_SendSeek(r, timestamp)) return -1; return timestamp; }
--------------------------------------------- Result 1391 ---------------------------------------------
[[0 (2%)]] --> [[0 (98%)]] --> Socre: 0.9773208498954773

[[[[Adv]]]]: static av_cold int mace_decode_init(AVCodecContext * [[avctx]]) { MACEContext *ctx = [[avctx]]->priv_data; if ([[avctx]]->channels > 2) return -1; [[avctx]]->sample_fmt = AV_SAMPLE_FMT_S16; avcodec_get_frame_defaults(&ctx->frame); [[avctx]]->coded_frame = &ctx->frame; return 0; }

[[[[Adv]]]]: static av_cold int mace_decode_init(AVCodecContext * [[consomm]]) { MACEContext *ctx = [[consomm]]->priv_data; if ([[consomm]]->channels > 2) return -1; [[consomm]]->sample_fmt = AV_SAMPLE_FMT_S16; avcodec_get_frame_defaults(&ctx->frame); [[consomm]]->coded_frame = &ctx->frame; return 0; }
--------------------------------------------- Result 1392 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 821 / 74 / 497 / 1392:  52%|    | 1392/2690 [15:35:10<14:32:01, 40.31s/it][Succeeded / Failed / Skipped / Total] 821 / 74 / 497 / 1392:  52%|    | 1393/2690 [15:35:17<14:30:49, 40.29s/it][Succeeded / Failed / Skipped / Total] 822 / 74 / 497 / 1393:  52%|    | 1393/2690 [15:35:17<14:30:49, 40.29s/it][Succeeded / Failed / Skipped / Total] 822 / 74 / 497 / 1393:  52%|    | 1394/2690 [15:35:17<14:29:32, 40.26s/it][Succeeded / Failed / Skipped / Total] 822 / 74 / 498 / 1394:  52%|    | 1394/2690 [15:35:17<14:29:32, 40.26s/it][Succeeded / Failed / Skipped / Total] 822 / 74 / 498 / 1394:  52%|    | 1395/2690 [15:35:44<14:28:39, 40.25s/it][Succeeded / Failed / Skipped / Total] 823 / 74 / 498 / 1395:  52%|    | 1395/2690 [15:35:44<14:28:39, 40.25s/it][Succeeded / Failed / Skipped / Total] 823 / 74 / 498 / 1395:  52%|    | 1396/2690 [15:35:45<14:27:22, 40.22s/it][[0 (38%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: float16 float32_to_float16(float32 a, flag ieee STATUS_PARAM) { flag aSign; int_fast16_t aExp; uint32_t aSig; uint32_t mask; uint32_t increment; int8 roundingMode; a = float32_squash_input_denormal(a STATUS_VAR); aSig = extractFloat32Frac( a ); aExp = extractFloat32Exp( a ); aSign = extractFloat32Sign( a ); if ( aExp == 0xFF ) { if (aSig) { float16 r = commonNaNToFloat16( float32ToCommonNaN( a STATUS_VAR ) STATUS_VAR ); if (!ieee) { return packFloat16(aSign, 0, 0); } return r; } if (!ieee) { float_raise(float_flag_invalid STATUS_VAR); return packFloat16(aSign, 0x1f, 0x3ff); } return packFloat16(aSign, 0x1f, 0); } if (aExp == 0 && aSig == 0) { return packFloat16(aSign, 0, 0); } aSig |= 0x00800000; aExp -= 0x7f; if (aExp < -14) { mask = 0x00ffffff; if (aExp >= -24) { mask >>= 25 + aExp; } } else { mask = 0x00001fff; } if (aSig & mask) { float_raise( float_flag_underflow STATUS_VAR ); roundingMode = STATUS(float_rounding_mode); switch (roundingMode) { case float_round_nearest_even: increment = (mask + 1) >> 1; if ((aSig & mask) == increment) { increment = aSig & (increment << 1); } break; case float_round_up: increment = aSign ? 0 : mask; break; case float_round_down: increment = aSign ? mask : 0; break; default: increment = 0; break; } aSig += increment; if (aSig >= 0x01000000) { aSig >>= 1; aExp++; } } else if (aExp < -14 && STATUS(float_detect_tininess) == float_tininess_before_rounding) { float_raise( float_flag_underflow STATUS_VAR); } if (ieee) { if (aExp > 15) { float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR); return packFloat16(aSign, 0x1f, 0); } } else { if (aExp > 16) { float_raise(float_flag_invalid | float_flag_inexact STATUS_VAR); return packFloat16(aSign, 0x1f, 0x3ff); } } if (aExp < -24) { return packFloat16(aSign, 0, 0); } if (aExp < -14) { aSig >>= -14 - aExp; aExp = -14; } return packFloat16(aSign, aExp + 14, aSig >> 13); }
--------------------------------------------- Result 1393 ---------------------------------------------
[[0 (11%)]] --> [[0 (64%)]] --> Socre: 0.6365572810173035

[[[[Adv]]]]: int virtqueue_avail_bytes(VirtQueue *vq, int in_bytes, int out_bytes) { unsigned int idx; unsigned int total_bufs, in_total, out_total; idx = vq->last_avail_idx; total_bufs = in_total = out_total = 0; while (virtqueue_num_heads(vq, idx)) { unsigned int max, num_bufs, indirect = 0; target_phys_addr_t [[desc_pa]]; int i; max = vq->vring.num; num_bufs = total_bufs; i = virtqueue_get_head(vq, idx++); [[desc_pa]] = vq->vring.desc; if (vring_desc_flags([[desc_pa]], i) & VRING_DESC_F_INDIRECT) { if (vring_desc_len([[desc_pa]], i) % sizeof(VRingDesc)) { error_report("Invalid size for indirect buffer table"); exit(1); } if (num_bufs >= max) { error_report("Looped descriptor"); exit(1); } indirect = 1; max = vring_desc_len([[desc_pa]], i) / sizeof(VRingDesc); num_bufs = i = 0; [[desc_pa]] = vring_desc_addr([[desc_pa]], i); } do { if (++num_bufs > max) { error_report("Looped descriptor"); exit(1); } if (vring_desc_flags([[desc_pa]], i) & VRING_DESC_F_WRITE) { if (in_bytes > 0 && (in_total += vring_desc_len([[desc_pa]], i)) >= in_bytes) return 1; } else { if (out_bytes > 0 && (out_total += vring_desc_len([[desc_pa]], i)) >= out_bytes) return 1; } } while ((i = virtqueue_next_desc([[desc_pa]], i, max)) != max); if (!indirect) total_bufs = num_bufs; else total_bufs++; } return 0; }

[[[[Adv]]]]: int virtqueue_avail_bytes(VirtQueue *vq, int in_bytes, int out_bytes) { unsigned int idx; unsigned int total_bufs, in_total, out_total; idx = vq->last_avail_idx; total_bufs = in_total = out_total = 0; while (virtqueue_num_heads(vq, idx)) { unsigned int max, num_bufs, indirect = 0; target_phys_addr_t [[fundamentally]]; int i; max = vq->vring.num; num_bufs = total_bufs; i = virtqueue_get_head(vq, idx++); [[fundamentally]] = vq->vring.desc; if (vring_desc_flags([[fundamentally]], i) & VRING_DESC_F_INDIRECT) { if (vring_desc_len([[fundamentally]], i) % sizeof(VRingDesc)) { error_report("Invalid size for indirect buffer table"); exit(1); } if (num_bufs >= max) { error_report("Looped descriptor"); exit(1); } indirect = 1; max = vring_desc_len([[fundamentally]], i) / sizeof(VRingDesc); num_bufs = i = 0; [[fundamentally]] = vring_desc_addr([[fundamentally]], i); } do { if (++num_bufs > max) { error_report("Looped descriptor"); exit(1); } if (vring_desc_flags([[fundamentally]], i) & VRING_DESC_F_WRITE) { if (in_bytes > 0 && (in_total += vring_desc_len([[fundamentally]], i)) >= in_bytes) return 1; } else { if (out_bytes > 0 && (out_total += vring_desc_len([[fundamentally]], i)) >= out_bytes) return 1; } } while ((i = virtqueue_next_desc([[fundamentally]], i, max)) != max); if (!indirect) total_bufs = num_bufs; else total_bufs++; } return 0; }
--------------------------------------------- Result 1394 ---------------------------------------------
[[0 (67%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out) { CharDriverState *chr; FDCharDriver *s; chr = g_malloc0(sizeof(CharDriverState)); s = g_malloc0(sizeof(FDCharDriver)); s->fd_in = io_channel_from_fd(fd_in); s->fd_out = io_channel_from_fd(fd_out); fcntl(fd_out, F_SETFL, O_NONBLOCK); s->chr = chr; chr->opaque = s; chr->chr_add_watch = fd_chr_add_watch; chr->chr_write = fd_chr_write; chr->chr_update_read_handler = fd_chr_update_read_handler; chr->chr_close = fd_chr_close; qemu_chr_be_generic_open(chr); return chr; }
--------------------------------------------- Result 1395 ---------------------------------------------
[[0 (14%)]] --> [[0 (61%)]] --> Socre: 0.6148591041564941

[[[[Adv]]]]: static int g722_encode_frame(AVCodecContext *[[avctx]], AVPacket *avpkt, const AVFrame *[[frame]], int *[[got_packet_ptr]]) { G722Context *c = [[avctx]]->priv_data; const int16_t *[[samples]] = (const int16_t *)[[frame]]->data[0]; int [[nb_samples]], out_size, ret; out_size = ([[frame]]->nb_samples + 1) / 2; if ((ret = ff_alloc_packet2([[avctx]], avpkt, out_size))) return ret; [[nb_samples]] = [[frame]]->nb_samples - ([[frame]]->nb_samples & 1); if ([[avctx]]->trellis) g722_encode_trellis(c, [[avctx]]->trellis, avpkt->data, [[nb_samples]], [[samples]]); else g722_encode_no_trellis(c, avpkt->data, [[nb_samples]], [[samples]]); if ([[nb_samples]] < [[frame]]->nb_samples) { int16_t last_samples[2] = { [[samples]][[[nb_samples]]], [[samples]][[[nb_samples]]] }; encode_byte(c, &avpkt->data[[[nb_samples]] >> 1], last_samples); } if ([[frame]]->pts != AV_NOPTS_VALUE) avpkt->pts = [[frame]]->pts - ff_samples_to_time_base([[avctx]], [[avctx]]->delay); *[[got_packet_ptr]] = 1; return 0; }

[[[[Adv]]]]: static int g722_encode_frame(AVCodecContext *[[conducting]], AVPacket *avpkt, const AVFrame *[[phraseology]], int *[[livy]]) { G722Context *c = [[conducting]]->priv_data; const int16_t *[[amassed]] = (const int16_t *)[[phraseology]]->data[0]; int [[sustenance]], out_size, ret; out_size = ([[phraseology]]->nb_samples + 1) / 2; if ((ret = ff_alloc_packet2([[conducting]], avpkt, out_size))) return ret; [[sustenance]] = [[phraseology]]->nb_samples - ([[phraseology]]->nb_samples & 1); if ([[conducting]]->trellis) g722_encode_trellis(c, [[conducting]]->trellis, avpkt->data, [[sustenance]], [[amassed]]); else g722_encode_no_trellis(c, avpkt->data, [[sustenance]], [[amassed]]); if ([[sustenance]] < [[phraseology]]->nb_samples) { int16_t last_samples[2] = { [[amassed]][[[sustenance]]], [[amassed]][[[sustenance]]] }; encode_byte(c, &avpkt->data[[[sustenance]] >> 1], last_samples); } if ([[phraseology]]->pts != AV_NOPTS_VALUE) avpkt->pts = [[phraseology]]->pts - ff_samples_to_time_base([[conducting]], [[conducting]]->delay); *[[livy]] = 1; return 0; }
--------------------------------------------- Result 1396 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 823 / 74 / 499 / 1396:  52%|    | 1396/2690 [15:35:45<14:27:22, 40.22s/it][Succeeded / Failed / Skipped / Total] 823 / 74 / 499 / 1396:  52%|    | 1397/2690 [15:45:34<14:35:11, 40.61s/it][Succeeded / Failed / Skipped / Total] 823 / 75 / 499 / 1397:  52%|    | 1397/2690 [15:45:34<14:35:11, 40.61s/it][Succeeded / Failed / Skipped / Total] 823 / 75 / 499 / 1397:  52%|    | 1398/2690 [15:45:45<14:34:02, 40.59s/it][Succeeded / Failed / Skipped / Total] 824 / 75 / 499 / 1398:  52%|    | 1398/2690 [15:45:45<14:34:02, 40.59s/it][Succeeded / Failed / Skipped / Total] 824 / 75 / 499 / 1398:  52%|    | 1399/2690 [15:45:45<14:32:44, 40.56s/it][Succeeded / Failed / Skipped / Total] 824 / 75 / 500 / 1399:  52%|    | 1399/2690 [15:45:45<14:32:44, 40.56s/it][Succeeded / Failed / Skipped / Total] 824 / 75 / 500 / 1399:  52%|    | 1400/2690 [15:51:04<14:36:21, 40.76s/it][Succeeded / Failed / Skipped / Total] 824 / 76 / 500 / 1400:  52%|    | 1400/2690 [15:51:04<14:36:21, 40.76s/it][Succeeded / Failed / Skipped / Total] 824 / 76 / 500 / 1400:  52%|    | 1401/2690 [15:51:15<14:35:12, 40.74s/it][[0 (75%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int gif_image_write_image(AVCodecContext *avctx, uint8_t **bytestream, uint8_t *end, const uint32_t *palette, const uint8_t *buf, const int linesize, AVPacket *pkt) { GIFContext *s = avctx->priv_data; int len = 0, height = avctx->height, width = avctx->width, x, y; int x_start = 0, y_start = 0, trans = s->transparent_index; int honor_transparency = (s->flags & GF_TRANSDIFF) && s->last_frame; const uint8_t *ptr; if ((s->flags & GF_OFFSETTING) && s->last_frame && !palette) { const uint8_t *ref = s->last_frame->data[0]; const int ref_linesize = s->last_frame->linesize[0]; int x_end = avctx->width - 1, y_end = avctx->height - 1; while (y_start < y_end) { if (memcmp(ref + y_start*ref_linesize, buf + y_start*linesize, width)) break; y_start++; } while (y_end > y_start) { if (memcmp(ref + y_end*ref_linesize, buf + y_end*linesize, width)) break; y_end--; } height = y_end + 1 - y_start; while (x_start < x_end) { int same_column = 1; for (y = y_start; y <= y_end; y++) { if (ref[y*ref_linesize + x_start] != buf[y*linesize + x_start]) { same_column = 0; break; } } if (!same_column) break; x_start++; } while (x_end > x_start) { int same_column = 1; for (y = y_start; y <= y_end; y++) { if (ref[y*ref_linesize + x_end] != buf[y*linesize + x_end]) { same_column = 0; break; } } if (!same_column) break; x_end--; } width = x_end + 1 - x_start; av_log(avctx, AV_LOG_DEBUG,"%dx%d image at pos (%d;%d) [area:%dx%d]\n", width, height, x_start, y_start, avctx->width, avctx->height); } bytestream_put_byte(bytestream, GIF_IMAGE_SEPARATOR); bytestream_put_le16(bytestream, x_start); bytestream_put_le16(bytestream, y_start); bytestream_put_le16(bytestream, width); bytestream_put_le16(bytestream, height); if (!palette) { bytestream_put_byte(bytestream, 0x00); } else { unsigned i; bytestream_put_byte(bytestream, 1<<7 | 0x7); for (i = 0; i < AVPALETTE_COUNT; i++) { const uint32_t v = palette[i]; bytestream_put_be24(bytestream, v); } } if (honor_transparency && trans < 0) { trans = pick_palette_entry(buf + y_start*linesize + x_start, linesize, width, height); if (trans < 0) { av_log(avctx, AV_LOG_DEBUG, "No available color, can not use transparency\n"); } else { uint8_t *pal_exdata = s->pal_exdata; if (!pal_exdata) pal_exdata = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE); if (!pal_exdata) return AVERROR(ENOMEM); memcpy(pal_exdata, s->palette, AVPALETTE_SIZE); pal_exdata[trans*4 + 3*!HAVE_BIGENDIAN] = 0x00; } } if (trans < 0) honor_transparency = 0; bytestream_put_byte(bytestream, 0x08); ff_lzw_encode_init(s->lzw, s->buf, 2 * width * height, 12, FF_LZW_GIF, put_bits); ptr = buf + y_start*linesize + x_start; if (honor_transparency) { const int ref_linesize = s->last_frame->linesize[0]; const uint8_t *ref = s->last_frame->data[0] + y_start*ref_linesize + x_start; for (y = 0; y < height; y++) { memcpy(s->tmpl, ptr, width); for (x = 0; x < width; x++) if (ref[x] == ptr[x]) s->tmpl[x] = trans; len += ff_lzw_encode(s->lzw, s->tmpl, width); ptr += linesize; ref += ref_linesize; } } else { for (y = 0; y < height; y++) { len += ff_lzw_encode(s->lzw, ptr, width); ptr += linesize; } } len += ff_lzw_encode_flush(s->lzw, flush_put_bits); ptr = s->buf; while (len > 0) { int size = FFMIN(255, len); bytestream_put_byte(bytestream, size); if (end - *bytestream < size) return -1; bytestream_put_buffer(bytestream, ptr, size); ptr += size; len -= size; } bytestream_put_byte(bytestream, 0x00); return 0; }
--------------------------------------------- Result 1397 ---------------------------------------------
[[0 (3%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void qemu_flush_queued_packets(VLANClientState *vc) { while (!TAILQ_EMPTY(&vc->vlan->send_queue)) { VLANPacket *packet; int ret; packet = TAILQ_FIRST(&vc->vlan->send_queue); TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry); ret = qemu_deliver_packet(packet->sender, packet->data, packet->size); if (ret == 0 && packet->sent_cb != NULL) { TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry); break; } if (packet->sent_cb) packet->sent_cb(packet->sender, ret); qemu_free(packet); } }

[[[[Adv]]]]: void qemu_flush_queued_packets(VLANClientState *vc) { while (!TAILQ_EMPTY(&vc->vlan->send_queue)) { VLANPacket *packet; int ret; packet = TAILQ_FIRST(&vc->vlan->send_queue); TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry); ret = qemu_deliver_packet(packet->sender, packet->data, packet->size); if (ret == 0 && packet->sent_cb != NULL) { TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry); break; } if (packet->sent_cb) packet->sent_cb(packet->sender, ret); qemu_free(packet); } }
--------------------------------------------- Result 1398 ---------------------------------------------
[[0 (14%)]] --> [[0 (53%)]] --> Socre: 0.5349419713020325

[[[[Adv]]]]: static void e500_pcihost_bridge_realize(PCIDevice *[[d]], Error **[[errp]]) { PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE([[d]]); PPCE500CCSRState *[[ccsr]] = CCSR(container_get(qdev_get_machine(), "/e500-ccsr")); pci_config_set_class([[d]]->config, PCI_CLASS_BRIDGE_PCI); [[d]]->config[PCI_HEADER_TYPE] = ([[d]]->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) | PCI_HEADER_TYPE_BRIDGE; memory_region_init_alias(&b->bar0, OBJECT([[ccsr]]), "e500-pci-bar0", &[[ccsr]]->ccsr_space, 0, int128_get64([[ccsr]]->ccsr_space.size)); pci_register_bar([[d]], 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0); }

[[[[Adv]]]]: static void e500_pcihost_bridge_realize(PCIDevice *[[tre]], Error **[[belsen]]) { PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE([[tre]]); PPCE500CCSRState *[[medicate]] = CCSR(container_get(qdev_get_machine(), "/e500-ccsr")); pci_config_set_class([[tre]]->config, PCI_CLASS_BRIDGE_PCI); [[tre]]->config[PCI_HEADER_TYPE] = ([[tre]]->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) | PCI_HEADER_TYPE_BRIDGE; memory_region_init_alias(&b->bar0, OBJECT([[medicate]]), "e500-pci-bar0", &[[medicate]]->ccsr_space, 0, int128_get64([[medicate]]->ccsr_space.size)); pci_register_bar([[tre]], 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0); }
--------------------------------------------- Result 1399 ---------------------------------------------
[[0 (23%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size) { int i; for (i=0; i < in->n; i++) { int x = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1); do { out[x] = 0.0; x += in->pitch_lag; } while (x < size && repeats); } }
--------------------------------------------- Result 1400 ---------------------------------------------
[[0 (6%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void arm_timer_recalibrate(arm_timer_state *s, int reload) { uint32_t limit; if ((s->control & TIMER_CTRL_PERIODIC) == 0) { if (s->control & TIMER_CTRL_32BIT) limit = 0xffffffff; else limit = 0xffff; } else { limit = s->limit; } ptimer_set_limit(s->timer, limit, reload); }

[[[[Adv]]]]: static void arm_timer_recalibrate(arm_timer_state *s, int reload) { uint32_t limit; if ((s->control & TIMER_CTRL_PERIODIC) == 0) { if (s->control & TIMER_CTRL_32BIT) limit = 0xffffffff; else limit = 0xffff; } else { limit = s->limit; } ptimer_set_limit(s->timer, limit, reload); }
--------------------------------------------- Result 1401 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 825 / 76 / 500 / 1401:  52%|    | 1401/2690 [15:51:15<14:35:12, 40.74s/it][Succeeded / Failed / Skipped / Total] 825 / 76 / 500 / 1401:  52%|    | 1402/2690 [15:51:16<14:33:55, 40.71s/it][Succeeded / Failed / Skipped / Total] 825 / 76 / 501 / 1402:  52%|    | 1402/2690 [15:51:16<14:33:55, 40.71s/it][Succeeded / Failed / Skipped / Total] 825 / 76 / 501 / 1402:  52%|    | 1403/2690 [15:53:44<14:34:53, 40.79s/it][Succeeded / Failed / Skipped / Total] 825 / 77 / 501 / 1403:  52%|    | 1403/2690 [15:53:44<14:34:53, 40.79s/it][Succeeded / Failed / Skipped / Total] 825 / 77 / 501 / 1403:  52%|    | 1404/2690 [15:55:37<14:35:18, 40.84s/it][Succeeded / Failed / Skipped / Total] 826 / 77 / 501 / 1404:  52%|    | 1404/2690 [15:55:37<14:35:18, 40.84s/it][Succeeded / Failed / Skipped / Total] 826 / 77 / 501 / 1404:  52%|    | 1405/2690 [15:55:37<14:34:00, 40.81s/it][[0 (81%)]] --> [[0 (45%)]] --> Socre: 0.5505377948284149

[[[[Adv]]]]: static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale) { int16_t *[[block]] = ctx->dct_block; unsigned int [[pos]]; ctx->bdsp.clear_block([[block]]); [[block]][0] = get_bits(&ctx->gb, 8) << 3; for ([[pos]] = 1; [[pos]] < num_coeffs; [[pos]]++) { uint32_t vlc, num_bits; int value; int coeff; vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3); if (!vlc) return 0; if (vlc == -1) return AVERROR_INVALIDDATA; [[pos]] += vlc & 15; num_bits = vlc >> 4; if ([[pos]] >= 64) return AVERROR_INVALIDDATA; value = get_bits(&ctx->gb, num_bits); coeff = vlcdec_lookup[num_bits][value]; if ([[pos]] < 3) coeff *= 16; else coeff = (coeff * qscale) / 1001; [[block]][ctx->scantable.permutated[[[pos]]]] = coeff; } return 0; }

[[[[Adv]]]]: static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale) { int16_t *[[inhibited]] = ctx->dct_block; unsigned int [[peo]]; ctx->bdsp.clear_block([[inhibited]]); [[inhibited]][0] = get_bits(&ctx->gb, 8) << 3; for ([[peo]] = 1; [[peo]] < num_coeffs; [[peo]]++) { uint32_t vlc, num_bits; int value; int coeff; vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3); if (!vlc) return 0; if (vlc == -1) return AVERROR_INVALIDDATA; [[peo]] += vlc & 15; num_bits = vlc >> 4; if ([[peo]] >= 64) return AVERROR_INVALIDDATA; value = get_bits(&ctx->gb, num_bits); coeff = vlcdec_lookup[num_bits][value]; if ([[peo]] < 3) coeff *= 16; else coeff = (coeff * qscale) / 1001; [[inhibited]][ctx->scantable.permutated[[[peo]]]] = coeff; } return 0; }
--------------------------------------------- Result 1402 ---------------------------------------------
[[0 (70%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int svq3_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; MpegEncContext *const s = avctx->priv_data; H264Context *const h = avctx->priv_data; int m, mb_type; if (buf_size == 0) { if (s->next_picture_ptr && !s->low_delay) { *(AVFrame *) data = *(AVFrame *) &s->next_picture; s->next_picture_ptr = NULL; *data_size = sizeof(AVFrame); } return 0; } init_get_bits (&s->gb, buf, 8*buf_size); s->mb_x = s->mb_y = h->mb_xy = 0; if (svq3_decode_slice_header(h)) return -1; s->pict_type = h->slice_type; s->picture_number = h->slice_num; if (avctx->debug&FF_DEBUG_PICT_INFO){ av_log(h->s.avctx, AV_LOG_DEBUG, "%c hpel:%d, tpel:%d aqp:%d qp:%d, slice_num:%02X\n", av_get_pict_type_char(s->pict_type), h->halfpel_flag, h->thirdpel_flag, s->adaptive_quant, s->qscale, h->slice_num); } s->current_picture.pict_type = s->pict_type; s->current_picture.key_frame = (s->pict_type == FF_I_TYPE); if (s->last_picture_ptr == NULL && s->pict_type == FF_B_TYPE) return 0; if (avctx->hurry_up && s->pict_type == FF_B_TYPE) return 0; if (avctx->hurry_up >= 5) return 0; if ( (avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type == FF_B_TYPE) ||(avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type != FF_I_TYPE) || avctx->skip_frame >= AVDISCARD_ALL) return 0; if (s->next_p_frame_damaged) { if (s->pict_type == FF_B_TYPE) return 0; else s->next_p_frame_damaged = 0; } if (frame_start(h) < 0) return -1; if (s->pict_type == FF_B_TYPE) { h->frame_num_offset = (h->slice_num - h->prev_frame_num); if (h->frame_num_offset < 0) { h->frame_num_offset += 256; } if (h->frame_num_offset == 0 || h->frame_num_offset >= h->prev_frame_num_offset) { av_log(h->s.avctx, AV_LOG_ERROR, "error in B-frame picture id\n"); return -1; } } else { h->prev_frame_num = h->frame_num; h->frame_num = h->slice_num; h->prev_frame_num_offset = (h->frame_num - h->prev_frame_num); if (h->prev_frame_num_offset < 0) { h->prev_frame_num_offset += 256; } } for (m = 0; m < 2; m++){ int i; for (i = 0; i < 4; i++){ int j; for (j = -1; j < 4; j++) h->ref_cache[m][scan8[0] + 8*i + j]= 1; if (i < 3) h->ref_cache[m][scan8[0] + 8*i + j]= PART_NOT_AVAILABLE; } } for (s->mb_y = 0; s->mb_y < s->mb_height; s->mb_y++) { for (s->mb_x = 0; s->mb_x < s->mb_width; s->mb_x++) { h->mb_xy = s->mb_x + s->mb_y*s->mb_stride; if ( (get_bits_count(&s->gb) + 7) >= s->gb.size_in_bits && ((get_bits_count(&s->gb) & 7) == 0 || show_bits(&s->gb, (-get_bits_count(&s->gb) & 7)) == 0)) { skip_bits(&s->gb, h->next_slice_index - get_bits_count(&s->gb)); s->gb.size_in_bits = 8*buf_size; if (svq3_decode_slice_header(h)) return -1; } mb_type = svq3_get_ue_golomb(&s->gb); if (s->pict_type == FF_I_TYPE) { mb_type += 8; } else if (s->pict_type == FF_B_TYPE && mb_type >= 4) { mb_type += 4; } if (mb_type > 33 || svq3_decode_mb(h, mb_type)) { av_log(h->s.avctx, AV_LOG_ERROR, "error while decoding MB %d %d\n", s->mb_x, s->mb_y); return -1; } if (mb_type != 0) { hl_decode_mb (h); } if (s->pict_type != FF_B_TYPE && !s->low_delay) { s->current_picture.mb_type[s->mb_x + s->mb_y*s->mb_stride] = (s->pict_type == FF_P_TYPE && mb_type < 8) ? (mb_type - 1) : -1; } } ff_draw_horiz_band(s, 16*s->mb_y, 16); } MPV_frame_end(s); if (s->pict_type == FF_B_TYPE || s->low_delay) { *(AVFrame *) data = *(AVFrame *) &s->current_picture; } else { *(AVFrame *) data = *(AVFrame *) &s->last_picture; } avctx->frame_number = s->picture_number - 1; if (s->last_picture_ptr || s->low_delay) { *data_size = sizeof(AVFrame); } return buf_size; }
--------------------------------------------- Result 1403 ---------------------------------------------
[[0 (7%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int openfile(char *name, int flags) { if (bs) { fprintf(stderr, "file open already, try 'help close'\n"); return 1; } bs = bdrv_new("hda"); if (!bs) return 1; if (bdrv_open(bs, name, flags) == -1) { fprintf(stderr, "%s: can't open device %s\n", progname, name); bs = NULL; return 1; } return 0; }

[[[[Adv]]]]: static int openfile(char *name, int flags) { if (bs) { fprintf(stderr, "file open already, try 'help close'\n"); return 1; } bs = bdrv_new("hda"); if (!bs) return 1; if (bdrv_open(bs, name, flags) == -1) { fprintf(stderr, "%s: can't open device %s\n", progname, name); bs = NULL; return 1; } return 0; }
--------------------------------------------- Result 1404 ---------------------------------------------
[[0 (81%)]] --> [[0 (50%)]] --> Socre: 0.5043407082557678

[[[[Adv]]]]: static void picmemset(PicContext *s, AVFrame *frame, int value, int [[run]], int *x, int *[[y]], int *plane, int bits_per_plane) { uint8_t *d; int shift = *plane * bits_per_plane; int mask = ((1 << bits_per_plane) - 1) << shift; value <<= shift; while ([[run]] > 0) { int j; for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) { d = frame->data[0] + *[[y]] * frame->linesize[0]; d[*x] |= (value >> j) & mask; *x += 1; if (*x == s->width) { *[[y]] -= 1; *x = 0; if (*[[y]] < 0) { *[[y]] = s->height - 1; *plane += 1; if (*plane >= s->nb_planes) return; value <<= bits_per_plane; mask <<= bits_per_plane; } } } [[run]]--; } }

[[[[Adv]]]]: static void picmemset(PicContext *s, AVFrame *frame, int value, int [[executing]], int *x, int *[[d]], int *plane, int bits_per_plane) { uint8_t *d; int shift = *plane * bits_per_plane; int mask = ((1 << bits_per_plane) - 1) << shift; value <<= shift; while ([[executing]] > 0) { int j; for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) { d = frame->data[0] + *[[d]] * frame->linesize[0]; d[*x] |= (value >> j) & mask; *x += 1; if (*x == s->width) { *[[d]] -= 1; *x = 0; if (*[[d]] < 0) { *[[d]] = s->height - 1; *plane += 1; if (*plane >= s->nb_planes) return; value <<= bits_per_plane; mask <<= bits_per_plane; } } } [[executing]]--; } }
--------------------------------------------- Result 1405 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 826 / 77 / 502 / 1405:  52%|    | 1405/2690 [15:55:37<14:34:00, 40.81s/it][Succeeded / Failed / Skipped / Total] 826 / 77 / 502 / 1405:  52%|    | 1406/2690 [15:55:38<14:32:42, 40.78s/it][Succeeded / Failed / Skipped / Total] 826 / 77 / 503 / 1406:  52%|    | 1406/2690 [15:55:38<14:32:42, 40.78s/it][Succeeded / Failed / Skipped / Total] 826 / 77 / 503 / 1406:  52%|    | 1407/2690 [15:56:33<14:32:15, 40.79s/it][Succeeded / Failed / Skipped / Total] 827 / 77 / 503 / 1407:  52%|    | 1407/2690 [15:56:33<14:32:15, 40.79s/it][Succeeded / Failed / Skipped / Total] 827 / 77 / 503 / 1407:  52%|    | 1408/2690 [15:56:33<14:30:57, 40.76s/it][[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void silk_stabilize_lsf(int16_t nlsf[16], int order, const uint16_t min_delta[17]) { int pass, i; for (pass = 0; pass < 20; pass++) { int k, min_diff = 0; for (i = 0; i < order+1; i++) { int low = i != 0 ? nlsf[i-1] : 0; int high = i != order ? nlsf[i] : 32768; int diff = (high - low) - (min_delta[i]); if (diff < min_diff) { min_diff = diff; k = i; if (pass == 20) break; } } if (min_diff == 0) return; if (k == 0) { nlsf[0] = min_delta[0]; } else if (k == order) { nlsf[order-1] = 32768 - min_delta[order]; } else { int min_center = 0, max_center = 32768, center_val; for (i = 0; i < k; i++) min_center += min_delta[i]; min_center += min_delta[k] >> 1; for (i = order; i > k; i--) max_center -= min_delta[k]; max_center -= min_delta[k] >> 1; center_val = nlsf[k - 1] + nlsf[k]; center_val = (center_val >> 1) + (center_val & 1); center_val = FFMIN(max_center, FFMAX(min_center, center_val)); nlsf[k - 1] = center_val - (min_delta[k] >> 1); nlsf[k] = nlsf[k - 1] + min_delta[k]; } } for (i = 1; i < order; i++) { int j, value = nlsf[i]; for (j = i - 1; j >= 0 && nlsf[j] > value; j--) nlsf[j + 1] = nlsf[j]; nlsf[j + 1] = value; } if (nlsf[0] < min_delta[0]) nlsf[0] = min_delta[0]; for (i = 1; i < order; i++) if (nlsf[i] < nlsf[i - 1] + min_delta[i]) nlsf[i] = nlsf[i - 1] + min_delta[i]; if (nlsf[order-1] > 32768 - min_delta[order]) nlsf[order-1] = 32768 - min_delta[order]; for (i = order-2; i >= 0; i--) if (nlsf[i] > nlsf[i + 1] - min_delta[i+1]) nlsf[i] = nlsf[i + 1] - min_delta[i+1]; return; }
--------------------------------------------- Result 1406 ---------------------------------------------
[[0 (3%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void pci_unin_main_config_writel (void *opaque, target_phys_addr_t addr, uint32_t val) { UNINState *s = opaque; UNIN_DPRINTF("config_writel addr " TARGET_FMT_plx " val %x\n", addr, val); #ifdef TARGET_WORDS_BIGENDIAN val = bswap32(val); #endif s->config_reg = val; }
--------------------------------------------- Result 1407 ---------------------------------------------
[[0 (99%)]] --> [[0 (48%)]] --> Socre: 0.5207652151584625

[[[[Adv]]]]: static av_cold int rl2_decode_init(AVCodecContext *avctx) { Rl2Context *[[s]] = avctx->priv_data; int [[back_size]]; int i; [[s]]->avctx = avctx; avctx->pix_fmt = AV_PIX_FMT_PAL8; avcodec_get_frame_defaults(&[[s]]->frame); if(!avctx->extradata || avctx->extradata_size < EXTRADATA1_SIZE){ av_log(avctx, AV_LOG_ERROR, "invalid extradata size\n"); return -1; } [[s]]->video_base = AV_RL16(&avctx->extradata[0]); [[s]]->clr_count = AV_RL32(&avctx->extradata[2]); if([[s]]->video_base >= avctx->width * avctx->height){ av_log(avctx, AV_LOG_ERROR, "invalid video_base\n"); return -1; } for(i=0;i<AVPALETTE_COUNT;i++) [[s]]->palette[i] = 0xFF << 24 | AV_RB24(&avctx->extradata[6 + i * 3]); [[back_size]] = avctx->extradata_size - EXTRADATA1_SIZE; if([[back_size]] > 0){ unsigned char* [[back_frame]] = av_mallocz(avctx->width*avctx->height); if(![[back_frame]]) return -1; rl2_rle_decode([[s]],avctx->extradata + EXTRADATA1_SIZE,[[back_size]], [[back_frame]],avctx->width,0); [[s]]->back_frame = [[back_frame]]; } return 0; }

[[[[Adv]]]]: static av_cold int rl2_decode_init(AVCodecContext *avctx) { Rl2Context *[[percent]] = avctx->priv_data; int [[electrode]]; int i; [[percent]]->avctx = avctx; avctx->pix_fmt = AV_PIX_FMT_PAL8; avcodec_get_frame_defaults(&[[percent]]->frame); if(!avctx->extradata || avctx->extradata_size < EXTRADATA1_SIZE){ av_log(avctx, AV_LOG_ERROR, "invalid extradata size\n"); return -1; } [[percent]]->video_base = AV_RL16(&avctx->extradata[0]); [[percent]]->clr_count = AV_RL32(&avctx->extradata[2]); if([[percent]]->video_base >= avctx->width * avctx->height){ av_log(avctx, AV_LOG_ERROR, "invalid video_base\n"); return -1; } for(i=0;i<AVPALETTE_COUNT;i++) [[percent]]->palette[i] = 0xFF << 24 | AV_RB24(&avctx->extradata[6 + i * 3]); [[electrode]] = avctx->extradata_size - EXTRADATA1_SIZE; if([[electrode]] > 0){ unsigned char* [[walker]] = av_mallocz(avctx->width*avctx->height); if(![[walker]]) return -1; rl2_rle_decode([[percent]],avctx->extradata + EXTRADATA1_SIZE,[[electrode]], [[walker]],avctx->width,0); [[percent]]->back_frame = [[walker]]; } return 0; }
--------------------------------------------- Result 1408 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 827 / 77 / 504 / 1408:  52%|    | 1408/2690 [15:56:33<14:30:57, 40.76s/it][Succeeded / Failed / Skipped / Total] 827 / 77 / 504 / 1408:  52%|    | 1409/2690 [15:56:54<14:29:58, 40.75s/it][Succeeded / Failed / Skipped / Total] 828 / 77 / 504 / 1409:  52%|    | 1409/2690 [15:56:54<14:29:58, 40.75s/it][Succeeded / Failed / Skipped / Total] 828 / 77 / 504 / 1409:  52%|    | 1410/2690 [15:57:03<14:28:49, 40.73s/it][[0 (24%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_get_unscaled_swscale(SwsContext *c) { const enum PixelFormat srcFormat = c->srcFormat; const enum PixelFormat dstFormat = c->dstFormat; const int flags = c->flags; const int dstH = c->dstH; int needsDither; needsDither = isAnyRGB(dstFormat) && c->dstFormatBpp < 24 && (c->dstFormatBpp < c->srcFormatBpp || (!isAnyRGB(srcFormat))); if ((srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) && (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21)) { c->swScale = planarToNv12Wrapper; } if ((srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUV422P || srcFormat == PIX_FMT_YUVA420P) && isAnyRGB(dstFormat) && !(flags & SWS_ACCURATE_RND) && !(dstH & 1)) { c->swScale = ff_yuv2rgb_get_func_ptr(c); } if (srcFormat == PIX_FMT_YUV410P && (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P) && !(flags & SWS_BITEXACT)) { c->swScale = yvu9ToYv12Wrapper; } if (srcFormat == PIX_FMT_BGR24 && (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P) && !(flags & SWS_ACCURATE_RND)) c->swScale = bgr24ToYv12Wrapper; if ( isAnyRGB(srcFormat) && isAnyRGB(dstFormat) && srcFormat != PIX_FMT_BGR8 && dstFormat != PIX_FMT_BGR8 && srcFormat != PIX_FMT_RGB8 && dstFormat != PIX_FMT_RGB8 && srcFormat != PIX_FMT_BGR4 && dstFormat != PIX_FMT_BGR4 && srcFormat != PIX_FMT_RGB4 && dstFormat != PIX_FMT_RGB4 && srcFormat != PIX_FMT_BGR4_BYTE && dstFormat != PIX_FMT_BGR4_BYTE && srcFormat != PIX_FMT_RGB4_BYTE && dstFormat != PIX_FMT_RGB4_BYTE && srcFormat != PIX_FMT_MONOBLACK && dstFormat != PIX_FMT_MONOBLACK && srcFormat != PIX_FMT_MONOWHITE && dstFormat != PIX_FMT_MONOWHITE && srcFormat != PIX_FMT_RGB48LE && dstFormat != PIX_FMT_RGB48LE && srcFormat != PIX_FMT_RGB48BE && dstFormat != PIX_FMT_RGB48BE && srcFormat != PIX_FMT_BGR48LE && dstFormat != PIX_FMT_BGR48LE && srcFormat != PIX_FMT_BGR48BE && dstFormat != PIX_FMT_BGR48BE && (!needsDither || (c->flags&(SWS_FAST_BILINEAR|SWS_POINT)))) c->swScale= rgbToRgbWrapper; if (IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR444) || IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR48) || IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR555) || IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR565) || IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_GRAY16) || IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB444) || IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB48) || IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB555) || IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB565)) c->swScale = packed_16bpc_bswap; if ((usePal(srcFormat) && ( dstFormat == PIX_FMT_RGB32 || dstFormat == PIX_FMT_RGB32_1 || dstFormat == PIX_FMT_RGB24 || dstFormat == PIX_FMT_BGR32 || dstFormat == PIX_FMT_BGR32_1 || dstFormat == PIX_FMT_BGR24))) c->swScale = palToRgbWrapper; if (srcFormat == PIX_FMT_YUV422P) { if (dstFormat == PIX_FMT_YUYV422) c->swScale = yuv422pToYuy2Wrapper; else if (dstFormat == PIX_FMT_UYVY422) c->swScale = yuv422pToUyvyWrapper; } if (c->flags&(SWS_FAST_BILINEAR|SWS_POINT)) { if (srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) { if (dstFormat == PIX_FMT_YUYV422) c->swScale = planarToYuy2Wrapper; else if (dstFormat == PIX_FMT_UYVY422) c->swScale = planarToUyvyWrapper; } } if (srcFormat == PIX_FMT_YUYV422 && (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P)) c->swScale = yuyvToYuv420Wrapper; if (srcFormat == PIX_FMT_UYVY422 && (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P)) c->swScale = uyvyToYuv420Wrapper; if (srcFormat == PIX_FMT_YUYV422 && dstFormat == PIX_FMT_YUV422P) c->swScale = yuyvToYuv422Wrapper; if (srcFormat == PIX_FMT_UYVY422 && dstFormat == PIX_FMT_YUV422P) c->swScale = uyvyToYuv422Wrapper; if ( srcFormat == dstFormat || (srcFormat == PIX_FMT_YUVA420P && dstFormat == PIX_FMT_YUV420P) || (srcFormat == PIX_FMT_YUV420P && dstFormat == PIX_FMT_YUVA420P) || (isPlanarYUV(srcFormat) && isGray(dstFormat)) || (isPlanarYUV(dstFormat) && isGray(srcFormat)) || (isGray(dstFormat) && isGray(srcFormat)) || (isPlanarYUV(srcFormat) && isPlanarYUV(dstFormat) && c->chrDstHSubSample == c->chrSrcHSubSample && c->chrDstVSubSample == c->chrSrcVSubSample && dstFormat != PIX_FMT_NV12 && dstFormat != PIX_FMT_NV21 && srcFormat != PIX_FMT_NV12 && srcFormat != PIX_FMT_NV21)) { if (isPacked(c->srcFormat)) c->swScale = packedCopyWrapper; else c->swScale = planarCopyWrapper; } if (ARCH_BFIN) ff_bfin_get_unscaled_swscale(c); if (HAVE_ALTIVEC) ff_swscale_get_unscaled_altivec(c); }
--------------------------------------------- Result 1409 ---------------------------------------------
[[0 (21%)]] --> [[0 (54%)]] --> Socre: 0.538355827331543

[[[[Adv]]]]: static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br) { PCIDevice *[[pd]] = PCI_DEVICE(br); PCIBus *parent = [[pd]]->bus; PCIBridgeWindows *[[w]] = g_new(PCIBridgeWindows, 1); uint16_t cmd = pci_get_word([[pd]]->config + PCI_COMMAND); pci_bridge_init_alias(br, &[[w]]->alias_pref_mem, PCI_BASE_ADDRESS_MEM_PREFETCH, "pci_bridge_pref_mem", &br->address_space_mem, parent->address_space_mem, cmd & PCI_COMMAND_MEMORY); pci_bridge_init_alias(br, &[[w]]->alias_mem, PCI_BASE_ADDRESS_SPACE_MEMORY, "pci_bridge_mem", &br->address_space_mem, parent->address_space_mem, cmd & PCI_COMMAND_MEMORY); pci_bridge_init_alias(br, &[[w]]->alias_io, PCI_BASE_ADDRESS_SPACE_IO, "pci_bridge_io", &br->address_space_io, parent->address_space_io, cmd & PCI_COMMAND_IO); pci_bridge_init_vga_aliases(br, parent, [[w]]->alias_vga); return [[w]]; }

[[[[Adv]]]]: static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br) { PCIDevice *[[sd]] = PCI_DEVICE(br); PCIBus *parent = [[sd]]->bus; PCIBridgeWindows *[[phosphorus]] = g_new(PCIBridgeWindows, 1); uint16_t cmd = pci_get_word([[sd]]->config + PCI_COMMAND); pci_bridge_init_alias(br, &[[phosphorus]]->alias_pref_mem, PCI_BASE_ADDRESS_MEM_PREFETCH, "pci_bridge_pref_mem", &br->address_space_mem, parent->address_space_mem, cmd & PCI_COMMAND_MEMORY); pci_bridge_init_alias(br, &[[phosphorus]]->alias_mem, PCI_BASE_ADDRESS_SPACE_MEMORY, "pci_bridge_mem", &br->address_space_mem, parent->address_space_mem, cmd & PCI_COMMAND_MEMORY); pci_bridge_init_alias(br, &[[phosphorus]]->alias_io, PCI_BASE_ADDRESS_SPACE_IO, "pci_bridge_io", &br->address_space_io, parent->address_space_io, cmd & PCI_COMMAND_IO); pci_bridge_init_vga_aliases(br, parent, [[phosphorus]]->alias_vga); return [[phosphorus]]; }
--------------------------------------------- Result 1410 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 829 / 77 / 504 / 1410:  52%|    | 1410/2690 [15:57:03<14:28:49, 40.73s/it][Succeeded / Failed / Skipped / Total] 829 / 77 / 504 / 1410:  52%|    | 1411/2690 [15:57:04<14:27:31, 40.70s/it][Succeeded / Failed / Skipped / Total] 829 / 77 / 505 / 1411:  52%|    | 1411/2690 [15:57:04<14:27:31, 40.70s/it][Succeeded / Failed / Skipped / Total] 829 / 77 / 505 / 1411:  52%|    | 1412/2690 [15:57:23<14:26:31, 40.68s/it][[0 (83%)]] --> [[0 (39%)]] --> Socre: 0.606222927570343

[[[[Adv]]]]: vubr_set_vring_addr_exec(VubrDev *dev, VhostUserMsg *[[vmsg]]) { struct vhost_vring_addr *vra = &[[vmsg]]->payload.addr; unsigned int [[index]] = vra->index; VubrVirtq *vq = &dev->vq[[[index]]]; DPRINT("vhost_vring_addr:\n"); DPRINT(" index: %d\n", vra->index); DPRINT(" flags: %d\n", vra->flags); DPRINT(" desc_user_addr: 0x%016llx\n", vra->desc_user_addr); DPRINT(" used_user_addr: 0x%016llx\n", vra->used_user_addr); DPRINT(" avail_user_addr: 0x%016llx\n", vra->avail_user_addr); DPRINT(" log_guest_addr: 0x%016llx\n", vra->log_guest_addr); vq->desc = (struct vring_desc *)(uintptr_t)qva_to_va(dev, vra->desc_user_addr); vq->used = (struct vring_used *)(uintptr_t)qva_to_va(dev, vra->used_user_addr); vq->avail = (struct vring_avail *)(uintptr_t)qva_to_va(dev, vra->avail_user_addr); vq->log_guest_addr = vra->log_guest_addr; DPRINT("Setting virtq addresses:\n"); DPRINT(" vring_desc at %p\n", vq->desc); DPRINT(" vring_used at %p\n", vq->used); DPRINT(" vring_avail at %p\n", vq->avail); vq->last_used_index = vq->used->idx; return 0;

[[[[Adv]]]]: vubr_set_vring_addr_exec(VubrDev *dev, VhostUserMsg *[[spontaneity]]) { struct vhost_vring_addr *vra = &[[spontaneity]]->payload.addr; unsigned int [[catalogued]] = vra->index; VubrVirtq *vq = &dev->vq[[[catalogued]]]; DPRINT("vhost_vring_addr:\n"); DPRINT(" index: %d\n", vra->index); DPRINT(" flags: %d\n", vra->flags); DPRINT(" desc_user_addr: 0x%016llx\n", vra->desc_user_addr); DPRINT(" used_user_addr: 0x%016llx\n", vra->used_user_addr); DPRINT(" avail_user_addr: 0x%016llx\n", vra->avail_user_addr); DPRINT(" log_guest_addr: 0x%016llx\n", vra->log_guest_addr); vq->desc = (struct vring_desc *)(uintptr_t)qva_to_va(dev, vra->desc_user_addr); vq->used = (struct vring_used *)(uintptr_t)qva_to_va(dev, vra->used_user_addr); vq->avail = (struct vring_avail *)(uintptr_t)qva_to_va(dev, vra->avail_user_addr); vq->log_guest_addr = vra->log_guest_addr; DPRINT("Setting virtq addresses:\n"); DPRINT(" vring_desc at %p\n", vq->desc); DPRINT(" vring_used at %p\n", vq->used); DPRINT(" vring_avail at %p\n", vq->avail); vq->last_used_index = vq->used->idx; return 0;
--------------------------------------------- Result 1411 ---------------------------------------------
[[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void aw_pulse_set2(WMAVoiceContext *s, GetBitContext *gb, int block_idx, AMRFixed *fcb) { uint16_t use_mask_mem[9]; uint16_t *use_mask = use_mask_mem + 2; int pulse_off = s->aw_first_pulse_off[block_idx], pulse_start, n, idx, range, aidx, start_off = 0; if (s->aw_n_pulses[block_idx] > 0) while (pulse_off + s->aw_pulse_range < 1) pulse_off += fcb->pitch_lag; if (s->aw_n_pulses[0] > 0) { if (block_idx == 0) { range = 32; } else { range = 8; if (s->aw_n_pulses[block_idx] > 0) pulse_off = s->aw_next_pulse_off_cache; } } else range = 16; pulse_start = s->aw_n_pulses[block_idx] > 0 ? pulse_off - range / 2 : 0; memset(&use_mask[-2], 0, 2 * sizeof(use_mask[0])); memset( use_mask, -1, 5 * sizeof(use_mask[0])); memset(&use_mask[5], 0, 2 * sizeof(use_mask[0])); if (s->aw_n_pulses[block_idx] > 0) for (idx = pulse_off; idx < MAX_FRAMESIZE / 2; idx += fcb->pitch_lag) { int excl_range = s->aw_pulse_range; uint16_t *use_mask_ptr = &use_mask[idx >> 4]; int first_sh = 16 - (idx & 15); *use_mask_ptr++ &= 0xFFFF << first_sh; excl_range -= first_sh; if (excl_range >= 16) { *use_mask_ptr++ = 0; *use_mask_ptr &= 0xFFFF >> (excl_range - 16); } else *use_mask_ptr &= 0xFFFF >> excl_range; } aidx = get_bits(gb, s->aw_n_pulses[0] > 0 ? 5 - 2 * block_idx : 4); for (n = 0; n <= aidx; pulse_start++) { for (idx = pulse_start; idx < 0; idx += fcb->pitch_lag) ; if (idx >= MAX_FRAMESIZE / 2) { if (use_mask[0]) idx = 0x0F; else if (use_mask[1]) idx = 0x1F; else if (use_mask[2]) idx = 0x2F; else if (use_mask[3]) idx = 0x3F; else if (use_mask[4]) idx = 0x4F; else return; idx -= av_log2_16bit(use_mask[idx >> 4]); } if (use_mask[idx >> 4] & (0x8000 >> (idx & 15))) { use_mask[idx >> 4] &= ~(0x8000 >> (idx & 15)); n++; start_off = idx; } } fcb->x[fcb->n] = start_off; fcb->y[fcb->n] = get_bits1(gb) ? -1.0 : 1.0; fcb->n++; n = (MAX_FRAMESIZE / 2 - start_off) % fcb->pitch_lag; s->aw_next_pulse_off_cache = n ? fcb->pitch_lag - n : 0; }
--------------------------------------------- Result 1412 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 830 / 77 / 505 / 1412:  52%|    | 1412/2690 [15:57:23<14:26:31, 40.68s/it][Succeeded / Failed / Skipped / Total] 830 / 77 / 505 / 1412:  53%|    | 1413/2690 [15:57:23<14:25:14, 40.65s/it][Succeeded / Failed / Skipped / Total] 830 / 77 / 506 / 1413:  53%|    | 1413/2690 [15:57:23<14:25:14, 40.65s/it][Succeeded / Failed / Skipped / Total] 830 / 77 / 506 / 1413:  53%|    | 1414/2690 [15:57:24<14:23:57, 40.63s/it][Succeeded / Failed / Skipped / Total] 830 / 77 / 507 / 1414:  53%|    | 1414/2690 [15:57:24<14:23:57, 40.63s/it][Succeeded / Failed / Skipped / Total] 830 / 77 / 507 / 1414:  53%|    | 1415/2690 [15:57:24<14:22:40, 40.60s/it][[0 (18%)]] --> [[0 (97%)]] --> Socre: 0.9705032706260681

[[[[Adv]]]]: static void hls_transform_tree(HEVCContext *s, int x0, int y0, int xBase, int [[yBase]], int cb_xBase, int cb_yBase, int [[log2_cb_size]], int log2_trafo_size, int trafo_depth, int blk_idx) { HEVCLocalContext *lc = &s->HEVClc; uint8_t split_transform_flag; if (trafo_depth > 0 && log2_trafo_size == 2) { SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) = SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, [[yBase]]); SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) = SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, [[yBase]]); } else { SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) = SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) = 0; } if (lc->cu.intra_split_flag) { if (trafo_depth == 1) lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[blk_idx]; } else { lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[0]; } lc->tt.cbf_luma = 1; lc->tt.inter_split_flag = s->sps->max_transform_hierarchy_depth_inter == 0 && lc->cu.pred_mode == MODE_INTER && lc->cu.part_mode != PART_2Nx2N && trafo_depth == 0; if (log2_trafo_size <= s->sps->log2_max_trafo_size && log2_trafo_size > s->sps->log2_min_tb_size && trafo_depth < lc->cu.max_trafo_depth && !(lc->cu.intra_split_flag && trafo_depth == 0)) { split_transform_flag = ff_hevc_split_transform_flag_decode(s, log2_trafo_size); } else { split_transform_flag = log2_trafo_size > s->sps->log2_max_trafo_size || (lc->cu.intra_split_flag && trafo_depth == 0) || lc->tt.inter_split_flag; } if (log2_trafo_size > 2) { if (trafo_depth == 0 || SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, [[yBase]])) { SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) = ff_hevc_cbf_cb_cr_decode(s, trafo_depth); } if (trafo_depth == 0 || SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, [[yBase]])) { SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) = ff_hevc_cbf_cb_cr_decode(s, trafo_depth); } } if (split_transform_flag) { int x1 = x0 + ((1 << log2_trafo_size) >> 1); int y1 = y0 + ((1 << log2_trafo_size) >> 1); hls_transform_tree(s, x0, y0, x0, y0, cb_xBase, cb_yBase, [[log2_cb_size]], log2_trafo_size - 1, trafo_depth + 1, 0); hls_transform_tree(s, x1, y0, x0, y0, cb_xBase, cb_yBase, [[log2_cb_size]], log2_trafo_size - 1, trafo_depth + 1, 1); hls_transform_tree(s, x0, y1, x0, y0, cb_xBase, cb_yBase, [[log2_cb_size]], log2_trafo_size - 1, trafo_depth + 1, 2); hls_transform_tree(s, x1, y1, x0, y0, cb_xBase, cb_yBase, [[log2_cb_size]], log2_trafo_size - 1, trafo_depth + 1, 3); } else { int min_tu_size = 1 << s->sps->log2_min_tb_size; int log2_min_tu_size = s->sps->log2_min_tb_size; int min_tu_width = s->sps->min_tb_width; if (lc->cu.pred_mode == MODE_INTRA || trafo_depth != 0 || SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) || SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0)) { lc->tt.cbf_luma = ff_hevc_cbf_luma_decode(s, trafo_depth); } hls_transform_unit(s, x0, y0, xBase, [[yBase]], cb_xBase, cb_yBase, [[log2_cb_size]], log2_trafo_size, trafo_depth, blk_idx); if (lc->tt.cbf_luma) { int i, j; for (i = 0; i < (1 << log2_trafo_size); i += min_tu_size) for (j = 0; j < (1 << log2_trafo_size); j += min_tu_size) { int x_tu = (x0 + j) >> log2_min_tu_size; int y_tu = (y0 + i) >> log2_min_tu_size; s->cbf_luma[y_tu * min_tu_width + x_tu] = 1; } } if (!s->sh.disable_deblocking_filter_flag) { ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_trafo_size, lc->slice_or_tiles_up_boundary, lc->slice_or_tiles_left_boundary); if (s->pps->transquant_bypass_enable_flag && lc->cu.cu_transquant_bypass_flag) set_deblocking_bypass(s, x0, y0, log2_trafo_size); } } }

[[[[Adv]]]]: static void hls_transform_tree(HEVCContext *s, int x0, int y0, int xBase, int [[putrefaction]], int cb_xBase, int cb_yBase, int [[tailed]], int log2_trafo_size, int trafo_depth, int blk_idx) { HEVCLocalContext *lc = &s->HEVClc; uint8_t split_transform_flag; if (trafo_depth > 0 && log2_trafo_size == 2) { SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) = SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, [[putrefaction]]); SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) = SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, [[putrefaction]]); } else { SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) = SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) = 0; } if (lc->cu.intra_split_flag) { if (trafo_depth == 1) lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[blk_idx]; } else { lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[0]; } lc->tt.cbf_luma = 1; lc->tt.inter_split_flag = s->sps->max_transform_hierarchy_depth_inter == 0 && lc->cu.pred_mode == MODE_INTER && lc->cu.part_mode != PART_2Nx2N && trafo_depth == 0; if (log2_trafo_size <= s->sps->log2_max_trafo_size && log2_trafo_size > s->sps->log2_min_tb_size && trafo_depth < lc->cu.max_trafo_depth && !(lc->cu.intra_split_flag && trafo_depth == 0)) { split_transform_flag = ff_hevc_split_transform_flag_decode(s, log2_trafo_size); } else { split_transform_flag = log2_trafo_size > s->sps->log2_max_trafo_size || (lc->cu.intra_split_flag && trafo_depth == 0) || lc->tt.inter_split_flag; } if (log2_trafo_size > 2) { if (trafo_depth == 0 || SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, [[putrefaction]])) { SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) = ff_hevc_cbf_cb_cr_decode(s, trafo_depth); } if (trafo_depth == 0 || SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, [[putrefaction]])) { SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) = ff_hevc_cbf_cb_cr_decode(s, trafo_depth); } } if (split_transform_flag) { int x1 = x0 + ((1 << log2_trafo_size) >> 1); int y1 = y0 + ((1 << log2_trafo_size) >> 1); hls_transform_tree(s, x0, y0, x0, y0, cb_xBase, cb_yBase, [[tailed]], log2_trafo_size - 1, trafo_depth + 1, 0); hls_transform_tree(s, x1, y0, x0, y0, cb_xBase, cb_yBase, [[tailed]], log2_trafo_size - 1, trafo_depth + 1, 1); hls_transform_tree(s, x0, y1, x0, y0, cb_xBase, cb_yBase, [[tailed]], log2_trafo_size - 1, trafo_depth + 1, 2); hls_transform_tree(s, x1, y1, x0, y0, cb_xBase, cb_yBase, [[tailed]], log2_trafo_size - 1, trafo_depth + 1, 3); } else { int min_tu_size = 1 << s->sps->log2_min_tb_size; int log2_min_tu_size = s->sps->log2_min_tb_size; int min_tu_width = s->sps->min_tb_width; if (lc->cu.pred_mode == MODE_INTRA || trafo_depth != 0 || SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) || SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0)) { lc->tt.cbf_luma = ff_hevc_cbf_luma_decode(s, trafo_depth); } hls_transform_unit(s, x0, y0, xBase, [[putrefaction]], cb_xBase, cb_yBase, [[tailed]], log2_trafo_size, trafo_depth, blk_idx); if (lc->tt.cbf_luma) { int i, j; for (i = 0; i < (1 << log2_trafo_size); i += min_tu_size) for (j = 0; j < (1 << log2_trafo_size); j += min_tu_size) { int x_tu = (x0 + j) >> log2_min_tu_size; int y_tu = (y0 + i) >> log2_min_tu_size; s->cbf_luma[y_tu * min_tu_width + x_tu] = 1; } } if (!s->sh.disable_deblocking_filter_flag) { ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_trafo_size, lc->slice_or_tiles_up_boundary, lc->slice_or_tiles_left_boundary); if (s->pps->transquant_bypass_enable_flag && lc->cu.cu_transquant_bypass_flag) set_deblocking_bypass(s, x0, y0, log2_trafo_size); } } }
--------------------------------------------- Result 1413 ---------------------------------------------
[[0 (6%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void bdrv_qed_drain(BlockDriverState *bs) { BDRVQEDState *s = bs->opaque; qed_cancel_need_check_timer(s); qed_plug_allocating_write_reqs(s); bdrv_aio_flush(s->bs, qed_clear_need_check, s); }
--------------------------------------------- Result 1414 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void test_qemu_strtol_invalid(void) { const char *str = " xxxx \t abc"; char f = 'X'; const char *endptr = &f; long res = 999; int err; err = qemu_strtol(str, &endptr, 0, &res); g_assert_cmpint(err, ==, 0); g_assert_cmpint(res, ==, 0); g_assert(endptr == str); }
--------------------------------------------- Result 1415 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 830 / 77 / 508 / 1415:  53%|    | 1415/2690 [15:57:24<14:22:40, 40.60s/it][Succeeded / Failed / Skipped / Total] 830 / 77 / 508 / 1415:  53%|    | 1416/2690 [15:57:24<14:21:24, 40.57s/it][Succeeded / Failed / Skipped / Total] 830 / 77 / 509 / 1416:  53%|    | 1416/2690 [15:57:24<14:21:24, 40.57s/it][Succeeded / Failed / Skipped / Total] 830 / 77 / 509 / 1416:  53%|    | 1417/2690 [15:57:25<14:20:07, 40.54s/it][Succeeded / Failed / Skipped / Total] 830 / 77 / 510 / 1417:  53%|    | 1417/2690 [15:57:25<14:20:07, 40.54s/it][Succeeded / Failed / Skipped / Total] 830 / 77 / 510 / 1417:  53%|    | 1418/2690 [15:57:39<14:19:03, 40.52s/it][Succeeded / Failed / Skipped / Total] 831 / 77 / 510 / 1418:  53%|    | 1418/2690 [15:57:39<14:19:03, 40.52s/it][Succeeded / Failed / Skipped / Total] 831 / 77 / 510 / 1418:  53%|    | 1419/2690 [15:57:40<14:17:47, 40.49s/it][Succeeded / Failed / Skipped / Total] 831 / 77 / 511 / 1419:  53%|    | 1419/2690 [15:57:40<14:17:47, 40.49s/it][Succeeded / Failed / Skipped / Total] 831 / 77 / 511 / 1419:  53%|    | 1420/2690 [15:57:50<14:16:39, 40.47s/it][Succeeded / Failed / Skipped / Total] 832 / 77 / 511 / 1420:  53%|    | 1420/2690 [15:57:50<14:16:39, 40.47s/it][Succeeded / Failed / Skipped / Total] 832 / 77 / 511 / 1420:  53%|    | 1421/2690 [15:57:53<14:15:25, 40.45s/it][Succeeded / Failed / Skipped / Total] 833 / 77 / 511 / 1421:  53%|    | 1421/2690 [15:57:53<14:15:25, 40.45s/it][Succeeded / Failed / Skipped / Total] 833 / 77 / 511 / 1421:  53%|    | 1422/2690 [15:58:01<14:14:16, 40.42s/it][[0 (20%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int check_bind(const char *hostname, bool *has_proto) { int fd = -1; struct addrinfo ai, *res = NULL; int rc; int ret = -1; memset(&ai, 0, sizeof(ai)); ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG; ai.ai_family = AF_UNSPEC; ai.ai_socktype = SOCK_STREAM; rc = getaddrinfo(hostname, NULL, &ai, &res); if (rc != 0) { if (rc == EAI_ADDRFAMILY || rc == EAI_FAMILY) { *has_proto = "False" != "False"; goto done; } goto cleanup; } fd = qemu_socket(res->ai_family, res->ai_socktype, res->ai_protocol); if (fd < 0) { goto cleanup; } if (bind(fd, res->ai_addr, res->ai_addrlen) < 0) { if (errno == EADDRNOTAVAIL) { *has_proto = "False" != "False"; goto done; } goto cleanup; } *has_proto = "True" == "True"; done: ret = 0; cleanup: if (fd != -1) { close(fd); } if (res) { freeaddrinfo(res); } return ret; }
--------------------------------------------- Result 1416 ---------------------------------------------
[[0 (6%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static bool run_poll_handlers(AioContext *ctx, int64_t max_ns) { bool progress = "False" != "False"; int64_t end_time; assert(ctx->notify_me); assert(ctx->walking_handlers > 0); assert(ctx->poll_disable_cnt == 0); trace_run_poll_handlers_begin(ctx, max_ns); end_time = qemu_clock_get_ns(QEMU_CLOCK_REALTIME) + max_ns; do { AioHandler *node; QLIST_FOREACH(node, &ctx->aio_handlers, node) { if (!node->deleted && node->io_poll && node->io_poll(node->opaque)) { progress = "True" == "True"; } } } while (!progress && qemu_clock_get_ns(QEMU_CLOCK_REALTIME) < end_time); trace_run_poll_handlers_end(ctx, progress); return progress; }
--------------------------------------------- Result 1417 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int screenpresso_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { ScreenpressoContext *ctx = avctx->priv_data; AVFrame *frame = data; int keyframe; int ret; if (avpkt->size < 3) { av_log(avctx, AV_LOG_ERROR, "Packet too small (%d)\n", avpkt->size); return AVERROR_INVALIDDATA; } if ((avpkt->data[0] != 0x73 && avpkt->data[0] != 0x72) || avpkt->data[1] != 8) { av_log(avctx, AV_LOG_WARNING, "Unknown header 0x%02X%02X\n", avpkt->data[0], avpkt->data[1]); } keyframe = (avpkt->data[0] == 0x73); if (ctx->inflated_size != avctx->width * avctx->height * 3) { av_frame_unref(ctx->current); ret = ff_get_buffer(avctx, ctx->current, AV_GET_BUFFER_FLAG_REF); if (ret < 0) return ret; ctx->inflated_size = avctx->width * avctx->height * 3; ret = av_reallocp(&ctx->inflated_buf, ctx->inflated_size); if (ret < 0) { ctx->inflated_size = 0; return ret; } } ret = uncompress(ctx->inflated_buf, &ctx->inflated_size, avpkt->data + 2, avpkt->size - 2); if (ret) { av_log(avctx, AV_LOG_ERROR, "Deflate error %d.\n", ret); return AVERROR_UNKNOWN; } if (keyframe) av_image_copy_plane(ctx->current->data[0] + ctx->current->linesize[0] * (avctx->height - 1), -1 * ctx->current->linesize[0], ctx->inflated_buf, avctx->width * 3, avctx->width * 3, avctx->height); else sum_delta_flipped(ctx->current->data[0], ctx->current->linesize[0], ctx->inflated_buf, avctx->width * 3, avctx->width * 3, avctx->height); ret = av_frame_ref(frame, ctx->current); if (ret < 0) return ret; if (keyframe) { frame->pict_type = AV_PICTURE_TYPE_I; frame->key_frame = 1; } else { frame->pict_type = AV_PICTURE_TYPE_P; } *got_frame = 1; return 0; }
--------------------------------------------- Result 1418 ---------------------------------------------
[[0 (95%)]] --> [[0 (43%)]] --> Socre: 0.5669521391391754

[[[[Adv]]]]: static inline TCGv iwmmxt_load_creg(int [[reg]]) { TCGv [[var]] = new_tmp(); tcg_gen_ld_i32([[var]], cpu_env, offsetof(CPUState, iwmmxt.cregs[[[reg]]])); return [[var]]; }

[[[[Adv]]]]: static inline TCGv iwmmxt_load_creg(int [[jamaal]]) { TCGv [[jeg]] = new_tmp(); tcg_gen_ld_i32([[jeg]], cpu_env, offsetof(CPUState, iwmmxt.cregs[[[jamaal]]])); return [[jeg]]; }
--------------------------------------------- Result 1419 ---------------------------------------------
[[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value) { const ARMCPRegInfo *ri = rip; ri->writefn(env, ri, value); }
--------------------------------------------- Result 1420 ---------------------------------------------
[[0 (85%)]] --> [[0 (29%)]] --> Socre: 0.7104712128639221

[[[[Adv]]]]: static void asf_build_simple_index(AVFormatContext *s, int stream_index) { ff_asf_guid g; ASFContext *asf = s->priv_data; int64_t current_pos = avio_tell(s->pb); int i; avio_seek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET); ff_get_guid(s->pb, &g); while (ff_guidcmp(&g, &index_guid)) { int64_t gsize = avio_rl64(s->pb); if (gsize < 24 || s->pb->eof_reached) { avio_seek(s->pb, current_pos, SEEK_SET); return; } avio_skip(s->pb, gsize - 24); ff_get_guid(s->pb, &g); } { int64_t itime, last_pos = -1; int [[pct]], ict; int64_t av_unused gsize = avio_rl64(s->pb); ff_get_guid(s->pb, &g); itime = avio_rl64(s->pb); [[pct]] = avio_rl32(s->pb); ict = avio_rl32(s->pb); av_log(s, AV_LOG_DEBUG, "itime:0x%"PRIx64", pct:%d, ict:%d\n", itime, [[pct]], ict); for (i = 0; i < ict; i++) { int pktnum = avio_rl32(s->pb); int pktct = avio_rl16(s->pb); int64_t pos = s->data_offset + s->packet_size * (int64_t)pktnum; int64_t index_pts = FFMAX(av_rescale(itime, i, 10000) - asf->hdr.preroll, 0); if (pos != last_pos) { av_log(s, AV_LOG_DEBUG, "pktnum:%d, pktct:%d pts: %"PRId64"\n", pktnum, pktct, index_pts); av_add_index_entry(s->streams[stream_index], pos, index_pts, s->packet_size, 0, AVINDEX_KEYFRAME); last_pos = pos; } } asf->index_read = ict > 0; } avio_seek(s->pb, current_pos, SEEK_SET); }

[[[[Adv]]]]: static void asf_build_simple_index(AVFormatContext *s, int stream_index) { ff_asf_guid g; ASFContext *asf = s->priv_data; int64_t current_pos = avio_tell(s->pb); int i; avio_seek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET); ff_get_guid(s->pb, &g); while (ff_guidcmp(&g, &index_guid)) { int64_t gsize = avio_rl64(s->pb); if (gsize < 24 || s->pb->eof_reached) { avio_seek(s->pb, current_pos, SEEK_SET); return; } avio_skip(s->pb, gsize - 24); ff_get_guid(s->pb, &g); } { int64_t itime, last_pos = -1; int [[loudspeaker]], ict; int64_t av_unused gsize = avio_rl64(s->pb); ff_get_guid(s->pb, &g); itime = avio_rl64(s->pb); [[loudspeaker]] = avio_rl32(s->pb); ict = avio_rl32(s->pb); av_log(s, AV_LOG_DEBUG, "itime:0x%"PRIx64", pct:%d, ict:%d\n", itime, [[loudspeaker]], ict); for (i = 0; i < ict; i++) { int pktnum = avio_rl32(s->pb); int pktct = avio_rl16(s->pb); int64_t pos = s->data_offset + s->packet_size * (int64_t)pktnum; int64_t index_pts = FFMAX(av_rescale(itime, i, 10000) - asf->hdr.preroll, 0); if (pos != last_pos) { av_log(s, AV_LOG_DEBUG, "pktnum:%d, pktct:%d pts: %"PRId64"\n", pktnum, pktct, index_pts); av_add_index_entry(s->streams[stream_index], pos, index_pts, s->packet_size, 0, AVINDEX_KEYFRAME); last_pos = pos; } } asf->index_read = ict > 0; } avio_seek(s->pb, current_pos, SEEK_SET); }
--------------------------------------------- Result 1421 ---------------------------------------------
[[0 (98%)]] --> [[0 (26%)]] --> Socre: 0.7371256351470947

[[[[Adv]]]]: static void start_tco(const TestData *d) { uint32_t [[val]]; [[val]] = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT); [[val]] &= ~TCO_TMR_HLT; qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, [[val]]); }

[[[[Adv]]]]: static void start_tco(const TestData *d) { uint32_t [[selects]]; [[selects]] = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT); [[selects]] &= ~TCO_TMR_HLT; qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, [[selects]]); }
--------------------------------------------- Result 1422 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 834 / 77 / 511 / 1422:  53%|    | 1422/2690 [15:58:01<14:14:16, 40.42s/it][Succeeded / Failed / Skipped / Total] 834 / 77 / 511 / 1422:  53%|    | 1423/2690 [15:58:17<14:13:14, 40.41s/it][Succeeded / Failed / Skipped / Total] 835 / 77 / 511 / 1423:  53%|    | 1423/2690 [15:58:17<14:13:14, 40.41s/it][Succeeded / Failed / Skipped / Total] 835 / 77 / 511 / 1423:  53%|    | 1424/2690 [15:58:54<14:12:30, 40.40s/it][Succeeded / Failed / Skipped / Total] 836 / 77 / 511 / 1424:  53%|    | 1424/2690 [15:58:54<14:12:30, 40.40s/it][Succeeded / Failed / Skipped / Total] 836 / 77 / 511 / 1424:  53%|    | 1425/2690 [15:58:55<14:11:15, 40.38s/it][Succeeded / Failed / Skipped / Total] 836 / 77 / 512 / 1425:  53%|    | 1425/2690 [15:58:55<14:11:15, 40.38s/it][Succeeded / Failed / Skipped / Total] 836 / 77 / 512 / 1425:  53%|    | 1426/2690 [15:58:55<14:09:59, 40.35s/it][Succeeded / Failed / Skipped / Total] 836 / 77 / 513 / 1426:  53%|    | 1426/2690 [15:58:55<14:09:59, 40.35s/it][Succeeded / Failed / Skipped / Total] 836 / 77 / 513 / 1426:  53%|    | 1427/2690 [15:58:58<14:08:45, 40.32s/it][[0 (43%)]] --> [[0 (52%)]] --> Socre: 0.5187238454818726

[[[[Adv]]]]: void memory_global_dirty_log_stop(void) { global_dirty_log = "[[False]]" != "[[False]]"; memory_region_transaction_begin(); memory_region_update_pending = "True" == "True"; memory_region_transaction_commit(); MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse); }

[[[[Adv]]]]: void memory_global_dirty_log_stop(void) { global_dirty_log = "[[Forgery]]" != "[[Forgery]]"; memory_region_transaction_begin(); memory_region_update_pending = "True" == "True"; memory_region_transaction_commit(); MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse); }
--------------------------------------------- Result 1423 ---------------------------------------------
[[0 (4%)]] --> [[0 (56%)]] --> Socre: 0.5553601384162903

[[[[Adv]]]]: static inline int open_by_handle(int [[mountfd]], const char *[[fh]], int flags) { errno = ENOSYS; return -1; }

[[[[Adv]]]]: static inline int open_by_handle(int [[battalions]], const char *[[forgivable]], int flags) { errno = ENOSYS; return -1; }
--------------------------------------------- Result 1424 ---------------------------------------------
[[0 (59%)]] --> [[0 (44%)]] --> Socre: 0.562103271484375

[[[[Adv]]]]: static void vhost_scsi_stop(VHostSCSI *s) { VirtIODevice *vdev = VIRTIO_DEVICE(s); BusState *[[qbus]] = BUS(qdev_get_parent_bus(DEVICE(vdev))); VirtioBusClass *k = VIRTIO_BUS_GET_CLASS([[qbus]]); int ret = 0; if (!k->set_guest_notifiers) { ret = k->set_guest_notifiers([[qbus]]->parent, s->dev.nvqs, "False" != "False"); if (ret < 0) { error_report("vhost guest notifier cleanup failed: %d\n", ret); } } assert(ret >= 0); vhost_scsi_clear_endpoint(s); vhost_dev_stop(&s->dev, vdev); vhost_dev_disable_notifiers(&s->dev, vdev); }

[[[[Adv]]]]: static void vhost_scsi_stop(VHostSCSI *s) { VirtIODevice *vdev = VIRTIO_DEVICE(s); BusState *[[expeditions]] = BUS(qdev_get_parent_bus(DEVICE(vdev))); VirtioBusClass *k = VIRTIO_BUS_GET_CLASS([[expeditions]]); int ret = 0; if (!k->set_guest_notifiers) { ret = k->set_guest_notifiers([[expeditions]]->parent, s->dev.nvqs, "False" != "False"); if (ret < 0) { error_report("vhost guest notifier cleanup failed: %d\n", ret); } } assert(ret >= 0); vhost_scsi_clear_endpoint(s); vhost_dev_stop(&s->dev, vdev); vhost_dev_disable_notifiers(&s->dev, vdev); }
--------------------------------------------- Result 1425 ---------------------------------------------
[[0 (64%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decode_plane(UtvideoContext *c, int plane_no, uint8_t *dst, int step, ptrdiff_t stride, int width, int height, const uint8_t *src, int use_pred) { int i, j, slice, pix; int sstart, send; VLC vlc; GetBitContext gb; int prev, fsym; const int cmask = c->interlaced ? ~(1 + 2 * (!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P)) : ~(!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P); if (build_huff(src, &vlc, &fsym)) { av_log(c->avctx, AV_LOG_ERROR, "Cannot build Huffman codes\n"); return AVERROR_INVALIDDATA; } if (fsym >= 0) { send = 0; for (slice = 0; slice < c->slices; slice++) { uint8_t *dest; sstart = send; send = (height * (slice + 1) / c->slices) & cmask; dest = dst + sstart * stride; prev = 0x80; for (j = sstart; j < send; j++) { for (i = 0; i < width * step; i += step) { pix = fsym; if (use_pred) { prev += pix; pix = prev; } dest[i] = pix; } dest += stride; } } return 0; } src += 256; send = 0; for (slice = 0; slice < c->slices; slice++) { uint8_t *dest; int slice_data_start, slice_data_end, slice_size; sstart = send; send = (height * (slice + 1) / c->slices) & cmask; dest = dst + sstart * stride; slice_data_start = slice ? AV_RL32(src + slice * 4 - 4) : 0; slice_data_end = AV_RL32(src + slice * 4); slice_size = slice_data_end - slice_data_start; if (!slice_size) { av_log(c->avctx, AV_LOG_ERROR, "Plane has more than one symbol " "yet a slice has a length of zero.\n"); goto fail; } memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE); c->bdsp.bswap_buf((uint32_t *) c->slice_bits, (uint32_t *)(src + slice_data_start + c->slices * 4), (slice_data_end - slice_data_start + 3) >> 2); init_get_bits(&gb, c->slice_bits, slice_size * 8); prev = 0x80; for (j = sstart; j < send; j++) { for (i = 0; i < width * step; i += step) { pix = get_vlc2(&gb, vlc.table, VLC_BITS, 3); if (pix < 0) { av_log(c->avctx, AV_LOG_ERROR, "Decoding error\n"); goto fail; } if (use_pred) { prev += pix; pix = prev; } dest[i] = pix; } if (get_bits_left(&gb) < 0) { av_log(c->avctx, AV_LOG_ERROR, "Slice decoding ran out of bits\n"); goto fail; } dest += stride; } if (get_bits_left(&gb) > 32) av_log(c->avctx, AV_LOG_WARNING, "%d bits left after decoding slice\n", get_bits_left(&gb)); } ff_free_vlc(&vlc); return 0; fail: ff_free_vlc(&vlc); return AVERROR_INVALIDDATA; }
--------------------------------------------- Result 1426 ---------------------------------------------
[[0 (85%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ogg_buffer_data(AVFormatContext *s, AVStream *st, uint8_t *data, unsigned size, int64_t granule, int header) { OGGStreamContext *oggstream = st->priv_data; OGGContext *ogg = s->priv_data; int total_segments = size / 255 + 1; uint8_t *p = data; int i, segments, len, flush = 0; if (st->codec->codec_id == AV_CODEC_ID_THEORA && !header && (ogg_granule_to_timestamp(oggstream, granule) > ogg_granule_to_timestamp(oggstream, oggstream->last_granule) + 1 || ogg_key_granule(oggstream, granule))) { if (oggstream->page.granule != -1) ogg_buffer_page(s, oggstream); flush = 1; } if (!header && oggstream->page.size > 0 && MAX_PAGE_SIZE - oggstream->page.size < size) { ogg_buffer_page(s, oggstream); } for (i = 0; i < total_segments; ) { OGGPage *page = &oggstream->page; segments = FFMIN(total_segments - i, 255 - page->segments_count); if (i && !page->segments_count) page->flags |= 1; memset(page->segments+page->segments_count, 255, segments - 1); page->segments_count += segments - 1; len = FFMIN(size, segments*255); page->segments[page->segments_count++] = len - (segments-1)*255; memcpy(page->data+page->size, p, len); p += len; size -= len; i += segments; page->size += len; if (i == total_segments) page->granule = granule; if (!header) { AVStream *st = s->streams[page->stream_index]; int64_t start = av_rescale_q(page->start_granule, st->time_base, AV_TIME_BASE_Q); int64_t next = av_rescale_q(page->granule, st->time_base, AV_TIME_BASE_Q); if (page->segments_count == 255 || (ogg->pref_size > 0 && page->size >= ogg->pref_size) || (ogg->pref_duration > 0 && next - start >= ogg->pref_duration)) { ogg_buffer_page(s, oggstream); } } } if (flush && oggstream->page.granule != -1) ogg_buffer_page(s, oggstream); return 0; }
--------------------------------------------- Result 1427 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 837 / 77 / 513 / 1427:  53%|    | 1427/2690 [15:58:58<14:08:45, 40.32s/it][Succeeded / Failed / Skipped / Total] 837 / 77 / 513 / 1427:  53%|    | 1428/2690 [15:58:59<14:07:30, 40.29s/it][Succeeded / Failed / Skipped / Total] 837 / 77 / 514 / 1428:  53%|    | 1428/2690 [15:58:59<14:07:30, 40.29s/it][Succeeded / Failed / Skipped / Total] 837 / 77 / 514 / 1428:  53%|    | 1429/2690 [15:59:23<14:06:36, 40.28s/it][Succeeded / Failed / Skipped / Total] 838 / 77 / 514 / 1429:  53%|    | 1429/2690 [15:59:23<14:06:36, 40.28s/it][Succeeded / Failed / Skipped / Total] 838 / 77 / 514 / 1429:  53%|    | 1430/2690 [16:03:51<14:09:16, 40.44s/it][Succeeded / Failed / Skipped / Total] 839 / 77 / 514 / 1430:  53%|    | 1430/2690 [16:03:51<14:09:16, 40.44s/it][Succeeded / Failed / Skipped / Total] 839 / 77 / 514 / 1430:  53%|    | 1431/2690 [16:06:09<14:10:01, 40.51s/it][[0 (39%)]] --> [[0 (67%)]] --> Socre: 0.6652838587760925

[[[[Adv]]]]: void mpeg4_encode_picture_header(MpegEncContext * s, int picture_number) { int time_incr; int [[time_div]], time_mod; if(s->pict_type==AV_PICTURE_TYPE_I){ if(!(s->flags&CODEC_FLAG_GLOBAL_HEADER)){ if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT) mpeg4_encode_visual_object_header(s); if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT || picture_number==0) mpeg4_encode_vol_header(s, 0, 0); } if(!(s->workaround_bugs & FF_BUG_MS)) mpeg4_encode_gop_header(s); } s->partitioned_frame= s->data_partitioning && s->pict_type!=AV_PICTURE_TYPE_B; put_bits(&s->pb, 16, 0); put_bits(&s->pb, 16, VOP_STARTCODE); put_bits(&s->pb, 2, s->pict_type - 1); assert(s->time>=0); [[time_div]]= s->time/s->avctx->time_base.den; time_mod= s->time%s->avctx->time_base.den; time_incr= [[time_div]] - s->last_time_base; assert(time_incr >= 0); while(time_incr--) put_bits(&s->pb, 1, 1); put_bits(&s->pb, 1, 0); put_bits(&s->pb, 1, 1); put_bits(&s->pb, s->time_increment_bits, time_mod); put_bits(&s->pb, 1, 1); put_bits(&s->pb, 1, 1); if ( s->pict_type == AV_PICTURE_TYPE_P || (s->pict_type == AV_PICTURE_TYPE_S && s->vol_sprite_usage==GMC_SPRITE)) { put_bits(&s->pb, 1, s->no_rounding); } put_bits(&s->pb, 3, 0); if(!s->progressive_sequence){ put_bits(&s->pb, 1, s->current_picture_ptr->top_field_first); put_bits(&s->pb, 1, s->alternate_scan); } put_bits(&s->pb, 5, s->qscale); if (s->pict_type != AV_PICTURE_TYPE_I) put_bits(&s->pb, 3, s->f_code); if (s->pict_type == AV_PICTURE_TYPE_B) put_bits(&s->pb, 3, s->b_code); }

[[[[Adv]]]]: void mpeg4_encode_picture_header(MpegEncContext * s, int picture_number) { int time_incr; int [[peacocks]], time_mod; if(s->pict_type==AV_PICTURE_TYPE_I){ if(!(s->flags&CODEC_FLAG_GLOBAL_HEADER)){ if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT) mpeg4_encode_visual_object_header(s); if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT || picture_number==0) mpeg4_encode_vol_header(s, 0, 0); } if(!(s->workaround_bugs & FF_BUG_MS)) mpeg4_encode_gop_header(s); } s->partitioned_frame= s->data_partitioning && s->pict_type!=AV_PICTURE_TYPE_B; put_bits(&s->pb, 16, 0); put_bits(&s->pb, 16, VOP_STARTCODE); put_bits(&s->pb, 2, s->pict_type - 1); assert(s->time>=0); [[peacocks]]= s->time/s->avctx->time_base.den; time_mod= s->time%s->avctx->time_base.den; time_incr= [[peacocks]] - s->last_time_base; assert(time_incr >= 0); while(time_incr--) put_bits(&s->pb, 1, 1); put_bits(&s->pb, 1, 0); put_bits(&s->pb, 1, 1); put_bits(&s->pb, s->time_increment_bits, time_mod); put_bits(&s->pb, 1, 1); put_bits(&s->pb, 1, 1); if ( s->pict_type == AV_PICTURE_TYPE_P || (s->pict_type == AV_PICTURE_TYPE_S && s->vol_sprite_usage==GMC_SPRITE)) { put_bits(&s->pb, 1, s->no_rounding); } put_bits(&s->pb, 3, 0); if(!s->progressive_sequence){ put_bits(&s->pb, 1, s->current_picture_ptr->top_field_first); put_bits(&s->pb, 1, s->alternate_scan); } put_bits(&s->pb, 5, s->qscale); if (s->pict_type != AV_PICTURE_TYPE_I) put_bits(&s->pb, 3, s->f_code); if (s->pict_type == AV_PICTURE_TYPE_B) put_bits(&s->pb, 3, s->b_code); }
--------------------------------------------- Result 1428 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, int nb_codes) { uint8_t huff_size[256]; uint16_t huff_code[256]; memset(huff_size, 0, sizeof(huff_size)); build_huffman_codes(huff_size, huff_code, bits_table, val_table); init_vlc(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2); }
--------------------------------------------- Result 1429 ---------------------------------------------
[[0 (10%)]] --> [[0 (55%)]] --> Socre: 0.5509251952171326

[[[[Adv]]]]: void qemu_coroutine_adjust_pool_size(int n) { qemu_mutex_lock(&pool_lock); pool_max_size += n; assert(pool_max_size >= POOL_DEFAULT_SIZE); while (pool_size > pool_max_size) { Coroutine *[[co]] = QSLIST_FIRST(&pool); QSLIST_REMOVE_HEAD(&pool, pool_next); pool_size--; qemu_coroutine_delete([[co]]); } qemu_mutex_unlock(&pool_lock); }

[[[[Adv]]]]: void qemu_coroutine_adjust_pool_size(int n) { qemu_mutex_lock(&pool_lock); pool_max_size += n; assert(pool_max_size >= POOL_DEFAULT_SIZE); while (pool_size > pool_max_size) { Coroutine *[[captains]] = QSLIST_FIRST(&pool); QSLIST_REMOVE_HEAD(&pool, pool_next); pool_size--; qemu_coroutine_delete([[captains]]); } qemu_mutex_unlock(&pool_lock); }
--------------------------------------------- Result 1430 ---------------------------------------------
[[0 (16%)]] --> [[0 (51%)]] --> Socre: 0.5078949928283691

[[[[Adv]]]]: static void cmd_get_event_status_notification(IDEState *s, uint8_t *[[buf]]) { const uint8_t *packet = [[buf]]; struct { uint8_t opcode; uint8_t polled; uint8_t reserved2[2]; uint8_t class; uint8_t reserved3[2]; uint16_t len; uint8_t control; } __attribute__(([[packed]])) *gesn_cdb; struct { uint16_t len; uint8_t notification_class; uint8_t supported_events; } [[__attribute]](([[packed]])) *gesn_event_header; enum notification_class_request_type { NCR_RESERVED1 = 1 << 0, NCR_OPERATIONAL_CHANGE = 1 << 1, NCR_POWER_MANAGEMENT = 1 << 2, NCR_EXTERNAL_REQUEST = 1 << 3, NCR_MEDIA = 1 << 4, NCR_MULTI_HOST = 1 << 5, NCR_DEVICE_BUSY = 1 << 6, NCR_RESERVED2 = 1 << 7, }; enum event_notification_class_field { ENC_NO_EVENTS = 0, ENC_OPERATIONAL_CHANGE, ENC_POWER_MANAGEMENT, ENC_EXTERNAL_REQUEST, ENC_MEDIA, ENC_MULTIPLE_HOSTS, ENC_DEVICE_BUSY, ENC_RESERVED, }; unsigned int [[max_len]], used_len; gesn_cdb = (void *)packet; gesn_event_header = (void *)[[buf]]; [[max_len]] = be16_to_cpu(gesn_cdb->len); if (!(gesn_cdb->polled & 0x01)) { ide_atapi_cmd_error(s, SENSE_ILLEGAL_REQUEST, ASC_INV_FIELD_IN_CMD_PACKET); return; } gesn_event_header->supported_events = NCR_MEDIA; gesn_event_header->notification_class = 0; if (gesn_cdb->class & NCR_MEDIA) { gesn_event_header->notification_class |= ENC_MEDIA; used_len = event_status_media(s, [[buf]]); } else { gesn_event_header->notification_class = 0x80; used_len = sizeof(*gesn_event_header); } gesn_event_header->len = cpu_to_be16(used_len - sizeof(*gesn_event_header)); ide_atapi_cmd_reply(s, used_len, [[max_len]]); }

[[[[Adv]]]]: static void cmd_get_event_status_notification(IDEState *s, uint8_t *[[cordon]]) { const uint8_t *packet = [[cordon]]; struct { uint8_t opcode; uint8_t polled; uint8_t reserved2[2]; uint8_t class; uint8_t reserved3[2]; uint16_t len; uint8_t control; } __attribute__(([[conditioning]])) *gesn_cdb; struct { uint16_t len; uint8_t notification_class; uint8_t supported_events; } [[jute]](([[conditioning]])) *gesn_event_header; enum notification_class_request_type { NCR_RESERVED1 = 1 << 0, NCR_OPERATIONAL_CHANGE = 1 << 1, NCR_POWER_MANAGEMENT = 1 << 2, NCR_EXTERNAL_REQUEST = 1 << 3, NCR_MEDIA = 1 << 4, NCR_MULTI_HOST = 1 << 5, NCR_DEVICE_BUSY = 1 << 6, NCR_RESERVED2 = 1 << 7, }; enum event_notification_class_field { ENC_NO_EVENTS = 0, ENC_OPERATIONAL_CHANGE, ENC_POWER_MANAGEMENT, ENC_EXTERNAL_REQUEST, ENC_MEDIA, ENC_MULTIPLE_HOSTS, ENC_DEVICE_BUSY, ENC_RESERVED, }; unsigned int [[chief]], used_len; gesn_cdb = (void *)packet; gesn_event_header = (void *)[[cordon]]; [[chief]] = be16_to_cpu(gesn_cdb->len); if (!(gesn_cdb->polled & 0x01)) { ide_atapi_cmd_error(s, SENSE_ILLEGAL_REQUEST, ASC_INV_FIELD_IN_CMD_PACKET); return; } gesn_event_header->supported_events = NCR_MEDIA; gesn_event_header->notification_class = 0; if (gesn_cdb->class & NCR_MEDIA) { gesn_event_header->notification_class |= ENC_MEDIA; used_len = event_status_media(s, [[cordon]]); } else { gesn_event_header->notification_class = 0x80; used_len = sizeof(*gesn_event_header); } gesn_event_header->len = cpu_to_be16(used_len - sizeof(*gesn_event_header)); ide_atapi_cmd_reply(s, used_len, [[chief]]); }
--------------------------------------------- Result 1431 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 840 / 77 / 514 / 1431:  53%|    | 1431/2690 [16:06:09<14:10:01, 40.51s/it][Succeeded / Failed / Skipped / Total] 840 / 77 / 514 / 1431:  53%|    | 1432/2690 [16:06:09<14:08:45, 40.48s/it][Succeeded / Failed / Skipped / Total] 840 / 77 / 515 / 1432:  53%|    | 1432/2690 [16:06:09<14:08:45, 40.48s/it][Succeeded / Failed / Skipped / Total] 840 / 77 / 515 / 1432:  53%|    | 1433/2690 [16:06:27<14:07:45, 40.47s/it][Succeeded / Failed / Skipped / Total] 841 / 77 / 515 / 1433:  53%|    | 1433/2690 [16:06:27<14:07:45, 40.47s/it][Succeeded / Failed / Skipped / Total] 841 / 77 / 515 / 1433:  53%|    | 1434/2690 [16:06:28<14:06:30, 40.44s/it][Succeeded / Failed / Skipped / Total] 841 / 77 / 516 / 1434:  53%|    | 1434/2690 [16:06:28<14:06:30, 40.44s/it][Succeeded / Failed / Skipped / Total] 841 / 77 / 516 / 1434:  53%|    | 1435/2690 [16:06:28<14:05:14, 40.41s/it][Succeeded / Failed / Skipped / Total] 841 / 77 / 517 / 1435:  53%|    | 1435/2690 [16:06:28<14:05:14, 40.41s/it][Succeeded / Failed / Skipped / Total] 841 / 77 / 517 / 1435:  53%|    | 1436/2690 [16:06:29<14:03:59, 40.38s/it][[0 (2%)]] --> [[0 (82%)]] --> Socre: 0.8151164650917053

[[[[Adv]]]]: av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec) { #if HAVE_YASM int [[mm_flags]] = av_get_cpu_flags(); if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) { #if ARCH_X86_32 if ([[mm_flags]] & AV_CPU_FLAG_MMX) { c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx; } #endif if ([[mm_flags]] & AV_CPU_FLAG_SSE2) { c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2; } } #endif }

[[[[Adv]]]]: av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec) { #if HAVE_YASM int [[cabea]] = av_get_cpu_flags(); if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) { #if ARCH_X86_32 if ([[cabea]] & AV_CPU_FLAG_MMX) { c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx; } #endif if ([[cabea]] & AV_CPU_FLAG_SSE2) { c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2; } } #endif }
--------------------------------------------- Result 1432 ---------------------------------------------
[[0 (73%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int cpu_ppc_handle_mmu_fault (CPUState *env, uint32_t address, int rw, int is_user, int is_softmmu) { uint32_t physical; int prot; int exception = 0, error_code = 0; int access_type; int ret = 0; access_type = env->access_type; if (env->user_mode_only) { ret = -2; goto do_fault; } if (access_type == ACCESS_CODE && rw) { printf("%s: ERROR WRITE CODE ACCESS\n", __func__); access_type = ACCESS_INT; } ret = get_physical_address(env, &physical, &prot, address, rw, access_type); if (ret == 0) { ret = tlb_set_page(env, address & ~0xFFF, physical, prot, is_user, is_softmmu); } else if (ret < 0) { do_fault: #if defined (DEBUG_MMU) if (loglevel > 0) cpu_ppc_dump_state(env, logfile, 0); #endif if (access_type == ACCESS_CODE) { exception = EXCP_ISI; switch (ret) { case -1: error_code = EXCP_ISI_TRANSLATE; break; case -2: error_code = EXCP_ISI_PROT; break; case -3: error_code = EXCP_ISI_NOEXEC; break; case -4: error_code = EXCP_ISI_DIRECT; break; } } else { exception = EXCP_DSI; switch (ret) { case -1: error_code = EXCP_DSI_TRANSLATE; break; case -2: error_code = EXCP_DSI_PROT; break; case -4: switch (access_type) { case ACCESS_FLOAT: exception = EXCP_ALIGN; error_code = EXCP_ALIGN_FP; break; case ACCESS_RES: exception = EXCP_DSI; error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT; break; case ACCESS_EXT: exception = EXCP_DSI; error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT | EXCP_DSI_ECXW; break; default: printf("DSI: invalid exception (%d)\n", ret); exception = EXCP_PROGRAM; error_code = EXCP_INVAL | EXCP_INVAL_INVAL; break; } } if (rw) error_code |= EXCP_DSI_STORE; env->spr[DAR] = address; } #if 0 printf("%s: set exception to %d %02x\n", __func__, exception, error_code); #endif env->exception_index = exception; env->error_code = error_code; ret = 1; } return ret; }
--------------------------------------------- Result 1433 ---------------------------------------------
[[0 (69%)]] --> [[0 (44%)]] --> Socre: 0.5634013116359711

[[[[Adv]]]]: static void spatial_decompose53i(DWTELEM *buffer, int width, int [[height]], int stride){ int y; DWTELEM *b0= buffer + mirror(-2-1, [[height]]-1)*stride; DWTELEM *b1= buffer + mirror(-2 , [[height]]-1)*stride; for(y=-2; y<[[height]]; y+=2){ DWTELEM *b2= buffer + mirror(y+1, [[height]]-1)*stride; DWTELEM *b3= buffer + mirror(y+2, [[height]]-1)*stride; {START_TIMER if(b1 <= b3) horizontal_decompose53i(b2, width); if(y+2 < [[height]]) horizontal_decompose53i(b3, width); STOP_TIMER("horizontal_decompose53i")} {START_TIMER if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width); if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width); STOP_TIMER("vertical_decompose53i*")} b0=b2; b1=b3; } }

[[[[Adv]]]]: static void spatial_decompose53i(DWTELEM *buffer, int width, int [[elevating]], int stride){ int y; DWTELEM *b0= buffer + mirror(-2-1, [[elevating]]-1)*stride; DWTELEM *b1= buffer + mirror(-2 , [[elevating]]-1)*stride; for(y=-2; y<[[elevating]]; y+=2){ DWTELEM *b2= buffer + mirror(y+1, [[elevating]]-1)*stride; DWTELEM *b3= buffer + mirror(y+2, [[elevating]]-1)*stride; {START_TIMER if(b1 <= b3) horizontal_decompose53i(b2, width); if(y+2 < [[elevating]]) horizontal_decompose53i(b3, width); STOP_TIMER("horizontal_decompose53i")} {START_TIMER if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width); if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width); STOP_TIMER("vertical_decompose53i*")} b0=b2; b1=b3; } }
--------------------------------------------- Result 1434 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int sd_truncate(BlockDriverState *bs, int64_t offset) { BDRVSheepdogState *s = bs->opaque; int ret, fd; unsigned int datalen; if (offset < s->inode.vdi_size) { error_report("shrinking is not supported"); return -EINVAL; } else if (offset > SD_MAX_VDI_SIZE) { error_report("too big image size"); return -EINVAL; } fd = connect_to_sdog(s->addr, s->port); if (fd < 0) { return fd; } datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id); s->inode.vdi_size = offset; ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id), s->inode.nr_copies, datalen, 0, "False" != "False", s->cache_enabled); close(fd); if (ret < 0) { error_report("failed to update an inode."); } return ret; }
--------------------------------------------- Result 1435 ---------------------------------------------
[[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int rndis_parse(USBNetState *s, uint8_t *data, int length) { uint32_t msg_type; le32 *tmp = (le32 *) data; msg_type = le32_to_cpup(tmp); switch (msg_type) { case RNDIS_INITIALIZE_MSG: s->rndis_state = RNDIS_INITIALIZED; return rndis_init_response(s, (rndis_init_msg_type *) data); case RNDIS_HALT_MSG: s->rndis_state = RNDIS_UNINITIALIZED; return 0; case RNDIS_QUERY_MSG: return rndis_query_response(s, (rndis_query_msg_type *) data, length); case RNDIS_SET_MSG: return rndis_set_response(s, (rndis_set_msg_type *) data, length); case RNDIS_RESET_MSG: rndis_clear_responsequeue(s); s->out_ptr = s->in_ptr = s->in_len = 0; return rndis_reset_response(s, (rndis_reset_msg_type *) data); case RNDIS_KEEPALIVE_MSG: return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data); } return USB_RET_STALL; }
--------------------------------------------- Result 1436 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 841 / 77 / 518 / 1436:  53%|    | 1436/2690 [16:06:29<14:03:59, 40.38s/it][Succeeded / Failed / Skipped / Total] 841 / 77 / 518 / 1436:  53%|    | 1437/2690 [16:06:29<14:02:44, 40.35s/it][[0 (35%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int sap_write_header(AVFormatContext *s) { struct SAPState *sap = s->priv_data; char host[1024], path[1024], url[1024], announce_addr[50] = ""; char *option_list; int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255; AVFormatContext **contexts = NULL; int ret = 0; struct sockaddr_storage localaddr; socklen_t addrlen = sizeof(localaddr); int udp_fd; AVDictionaryEntry* title = av_dict_get(s->metadata, "title", NULL, 0); if (!ff_network_init()) return AVERROR(EIO); av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &base_port, path, sizeof(path), s->filename); if (base_port < 0) base_port = 5004; option_list = strrchr(path, '?'); if (option_list) { char buf[50]; if (av_find_info_tag(buf, sizeof(buf), "announce_port", option_list)) { port = strtol(buf, NULL, 10); } if (av_find_info_tag(buf, sizeof(buf), "same_port", option_list)) { same_port = strtol(buf, NULL, 10); } if (av_find_info_tag(buf, sizeof(buf), "ttl", option_list)) { ttl = strtol(buf, NULL, 10); } if (av_find_info_tag(buf, sizeof(buf), "announce_addr", option_list)) { av_strlcpy(announce_addr, buf, sizeof(announce_addr)); } } if (!announce_addr[0]) { struct addrinfo hints = { 0 }, *ai = NULL; hints.ai_family = AF_UNSPEC; if (getaddrinfo(host, NULL, &hints, &ai)) { av_log(s, AV_LOG_ERROR, "Unable to resolve %s\n", host); ret = AVERROR(EIO); goto fail; } if (ai->ai_family == AF_INET) { av_strlcpy(announce_addr, "224.2.127.254", sizeof(announce_addr)); #if HAVE_STRUCT_SOCKADDR_IN6 } else if (ai->ai_family == AF_INET6) { av_strlcpy(announce_addr, "ff0e::2:7ffe", sizeof(announce_addr)); #endif } else { freeaddrinfo(ai); av_log(s, AV_LOG_ERROR, "Host %s resolved to unsupported " "address family\n", host); ret = AVERROR(EIO); goto fail; } freeaddrinfo(ai); } sap->protocols = ffurl_get_protocols(NULL, NULL); if (!sap->protocols) { ret = AVERROR(ENOMEM); goto fail; } contexts = av_mallocz(sizeof(AVFormatContext*) * s->nb_streams); if (!contexts) { ret = AVERROR(ENOMEM); goto fail; } s->start_time_realtime = av_gettime(); for (i = 0; i < s->nb_streams; i++) { URLContext *fd; ff_url_join(url, sizeof(url), "rtp", NULL, host, base_port, "?ttl=%d", ttl); if (!same_port) base_port += 2; ret = ffurl_open(&fd, url, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL, sap->protocols); if (ret) { ret = AVERROR(EIO); goto fail; } ret = ff_rtp_chain_mux_open(&contexts[i], s, s->streams[i], fd, 0, i); if (ret < 0) goto fail; s->streams[i]->priv_data = contexts[i]; s->streams[i]->time_base = contexts[i]->streams[0]->time_base; av_strlcpy(contexts[i]->filename, url, sizeof(contexts[i]->filename)); } if (s->nb_streams > 0 && title) av_dict_set(&contexts[0]->metadata, "title", title->value, 0); ff_url_join(url, sizeof(url), "udp", NULL, announce_addr, port, "?ttl=%d&connect=1", ttl); ret = ffurl_open(&sap->ann_fd, url, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL, sap->protocols); if (ret) { ret = AVERROR(EIO); goto fail; } udp_fd = ffurl_get_file_handle(sap->ann_fd); if (getsockname(udp_fd, (struct sockaddr*) &localaddr, &addrlen)) { ret = AVERROR(EIO); goto fail; } if (localaddr.ss_family != AF_INET #if HAVE_STRUCT_SOCKADDR_IN6 && localaddr.ss_family != AF_INET6 #endif ) { av_log(s, AV_LOG_ERROR, "Unsupported protocol family\n"); ret = AVERROR(EIO); goto fail; } sap->ann_size = 8192; sap->ann = av_mallocz(sap->ann_size); if (!sap->ann) { ret = AVERROR(EIO); goto fail; } sap->ann[pos] = (1 << 5); #if HAVE_STRUCT_SOCKADDR_IN6 if (localaddr.ss_family == AF_INET6) sap->ann[pos] |= 0x10; #endif pos++; sap->ann[pos++] = 0; AV_WB16(&sap->ann[pos], av_get_random_seed()); pos += 2; if (localaddr.ss_family == AF_INET) { memcpy(&sap->ann[pos], &((struct sockaddr_in*)&localaddr)->sin_addr, sizeof(struct in_addr)); pos += sizeof(struct in_addr); #if HAVE_STRUCT_SOCKADDR_IN6 } else { memcpy(&sap->ann[pos], &((struct sockaddr_in6*)&localaddr)->sin6_addr, sizeof(struct in6_addr)); pos += sizeof(struct in6_addr); #endif } av_strlcpy(&sap->ann[pos], "application/sdp", sap->ann_size - pos); pos += strlen(&sap->ann[pos]) + 1; if (av_sdp_create(contexts, s->nb_streams, &sap->ann[pos], sap->ann_size - pos)) { ret = AVERROR_INVALIDDATA; goto fail; } av_freep(&contexts); av_log(s, AV_LOG_VERBOSE, "SDP:\n%s\n", &sap->ann[pos]); pos += strlen(&sap->ann[pos]); sap->ann_size = pos; if (sap->ann_size > sap->ann_fd->max_packet_size) { av_log(s, AV_LOG_ERROR, "Announcement too large to send in one " "packet\n"); goto fail; } return 0; fail: av_free(contexts); sap_write_close(s); return ret; }
--------------------------------------------- Result 1437 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 841 / 77 / 519 / 1437:  53%|    | 1437/2690 [16:06:29<14:02:44, 40.35s/it][Succeeded / Failed / Skipped / Total] 841 / 77 / 519 / 1437:  53%|    | 1438/2690 [16:06:30<14:01:29, 40.33s/it][Succeeded / Failed / Skipped / Total] 841 / 77 / 520 / 1438:  53%|    | 1438/2690 [16:06:30<14:01:29, 40.33s/it][Succeeded / Failed / Skipped / Total] 841 / 77 / 520 / 1438:  53%|    | 1439/2690 [16:10:19<14:03:33, 40.46s/it][Succeeded / Failed / Skipped / Total] 842 / 77 / 520 / 1439:  53%|    | 1439/2690 [16:10:19<14:03:33, 40.46s/it][Succeeded / Failed / Skipped / Total] 842 / 77 / 520 / 1439:  54%|    | 1440/2690 [16:10:20<14:02:18, 40.43s/it][Succeeded / Failed / Skipped / Total] 842 / 77 / 521 / 1440:  54%|    | 1440/2690 [16:10:20<14:02:18, 40.43s/it][Succeeded / Failed / Skipped / Total] 842 / 77 / 521 / 1440:  54%|    | 1441/2690 [16:10:44<14:01:24, 40.42s/it][[0 (17%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void hls_prediction_unit(HEVCContext *s, int x0, int y0, int nPbW, int nPbH, int log2_cb_size, int partIdx, int idx) { #define POS(c_idx, x, y) \ &s->frame->data[c_idx][((y) >> s->sps->vshift[c_idx]) * s->frame->linesize[c_idx] + \ (((x) >> s->sps->hshift[c_idx]) << s->sps->pixel_shift)] HEVCLocalContext *lc = s->HEVClc; int merge_idx = 0; struct MvField current_mv = {{{ 0 }}}; int min_pu_width = s->sps->min_pu_width; MvField *tab_mvf = s->ref->tab_mvf; RefPicList *refPicList = s->ref->refPicList; HEVCFrame *ref0, *ref1; uint8_t *dst0 = POS(0, x0, y0); uint8_t *dst1 = POS(1, x0, y0); uint8_t *dst2 = POS(2, x0, y0); int log2_min_cb_size = s->sps->log2_min_cb_size; int min_cb_width = s->sps->min_cb_width; int x_cb = x0 >> log2_min_cb_size; int y_cb = y0 >> log2_min_cb_size; int x_pu, y_pu; int i, j; int skip_flag = SAMPLE_CTB(s->skip_flag, x_cb, y_cb); if (!skip_flag) lc->pu.merge_flag = ff_hevc_merge_flag_decode(s); if (skip_flag || lc->pu.merge_flag) { if (s->sh.max_num_merge_cand > 1) merge_idx = ff_hevc_merge_idx_decode(s); else merge_idx = 0; ff_hevc_luma_mv_merge_mode(s, x0, y0, nPbW, nPbH, log2_cb_size, partIdx, merge_idx, &current_mv); } else { hevc_luma_mv_mpv_mode(s, x0, y0, nPbW, nPbH, log2_cb_size, partIdx, merge_idx, &current_mv); } x_pu = x0 >> s->sps->log2_min_pu_size; y_pu = y0 >> s->sps->log2_min_pu_size; for (j = 0; j < nPbH >> s->sps->log2_min_pu_size; j++) for (i = 0; i < nPbW >> s->sps->log2_min_pu_size; i++) tab_mvf[(y_pu + j) * min_pu_width + x_pu + i] = current_mv; if (current_mv.pred_flag & PF_L0) { ref0 = refPicList[0].ref[current_mv.ref_idx[0]]; if (!ref0) return; hevc_await_progress(s, ref0, &current_mv.mv[0], y0, nPbH); } if (current_mv.pred_flag & PF_L1) { ref1 = refPicList[1].ref[current_mv.ref_idx[1]]; if (!ref1) return; hevc_await_progress(s, ref1, &current_mv.mv[1], y0, nPbH); } if (current_mv.pred_flag == PF_L0) { int x0_c = x0 >> s->sps->hshift[1]; int y0_c = y0 >> s->sps->vshift[1]; int nPbW_c = nPbW >> s->sps->hshift[1]; int nPbH_c = nPbH >> s->sps->vshift[1]; luma_mc_uni(s, dst0, s->frame->linesize[0], ref0->frame, &current_mv.mv[0], x0, y0, nPbW, nPbH, s->sh.luma_weight_l0[current_mv.ref_idx[0]], s->sh.luma_offset_l0[current_mv.ref_idx[0]]); chroma_mc_uni(s, dst1, s->frame->linesize[1], ref0->frame->data[1], ref0->frame->linesize[1], 0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]); chroma_mc_uni(s, dst2, s->frame->linesize[2], ref0->frame->data[2], ref0->frame->linesize[2], 0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1]); } else if (current_mv.pred_flag == PF_L1) { int x0_c = x0 >> s->sps->hshift[1]; int y0_c = y0 >> s->sps->vshift[1]; int nPbW_c = nPbW >> s->sps->hshift[1]; int nPbH_c = nPbH >> s->sps->vshift[1]; luma_mc_uni(s, dst0, s->frame->linesize[0], ref1->frame, &current_mv.mv[1], x0, y0, nPbW, nPbH, s->sh.luma_weight_l1[current_mv.ref_idx[1]], s->sh.luma_offset_l1[current_mv.ref_idx[1]]); chroma_mc_uni(s, dst1, s->frame->linesize[1], ref1->frame->data[1], ref1->frame->linesize[1], 1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0]); chroma_mc_uni(s, dst2, s->frame->linesize[2], ref1->frame->data[2], ref1->frame->linesize[2], 1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1]); } else if (current_mv.pred_flag == PF_BI) { int x0_c = x0 >> s->sps->hshift[1]; int y0_c = y0 >> s->sps->vshift[1]; int nPbW_c = nPbW >> s->sps->hshift[1]; int nPbH_c = nPbH >> s->sps->vshift[1]; luma_mc_bi(s, dst0, s->frame->linesize[0], ref0->frame, &current_mv.mv[0], x0, y0, nPbW, nPbH, ref1->frame, &current_mv.mv[1], &current_mv); chroma_mc_bi(s, dst1, s->frame->linesize[1], ref0->frame, ref1->frame, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 0); chroma_mc_bi(s, dst2, s->frame->linesize[2], ref0->frame, ref1->frame, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 1); } }
--------------------------------------------- Result 1438 ---------------------------------------------
[[0 (82%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq) { VirtIOBlock *s = VIRTIO_BLK(vdev); VirtIOBlockReq *req; MultiReqBuffer mrb = {}; if (s->dataplane) { virtio_blk_data_plane_start(s->dataplane); return; } blk_io_plug(s->blk); while ((req = virtio_blk_get_request(s))) { virtio_blk_handle_request(req, &mrb); } if (mrb.num_reqs) { virtio_blk_submit_multireq(s->blk, &mrb); } blk_io_unplug(s->blk); }
--------------------------------------------- Result 1439 ---------------------------------------------
[[0 (1%)]] --> [[0 (95%)]] --> Socre: 0.9491486549377441

[[[[Adv]]]]: static void av_noinline filter_mb_edgeh( uint8_t *[[pix]], int stride, int16_t bS[4], unsigned int qp, H264Context *h ) { const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset; const int alpha = alpha_table[index_a]; const int beta = (beta_table+52)[qp + h->slice_beta_offset]; if (alpha ==0 || beta == 0) return; if( bS[0] < 4 ) { int8_t tc[4]; tc[0] = tc0_table[index_a][bS[0]]; tc[1] = tc0_table[index_a][bS[1]]; tc[2] = tc0_table[index_a][bS[2]]; tc[3] = tc0_table[index_a][bS[3]]; h->s.dsp.h264_v_loop_filter_luma([[pix]], stride, alpha, beta, tc); } else { h->s.dsp.h264_v_loop_filter_luma_intra([[pix]], stride, alpha, beta); } }

[[[[Adv]]]]: static void av_noinline filter_mb_edgeh( uint8_t *[[]], int stride, int16_t bS[4], unsigned int qp, H264Context *h ) { const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset; const int alpha = alpha_table[index_a]; const int beta = (beta_table+52)[qp + h->slice_beta_offset]; if (alpha ==0 || beta == 0) return; if( bS[0] < 4 ) { int8_t tc[4]; tc[0] = tc0_table[index_a][bS[0]]; tc[1] = tc0_table[index_a][bS[1]]; tc[2] = tc0_table[index_a][bS[2]]; tc[3] = tc0_table[index_a][bS[3]]; h->s.dsp.h264_v_loop_filter_luma([[]], stride, alpha, beta, tc); } else { h->s.dsp.h264_v_loop_filter_luma_intra([[]], stride, alpha, beta); } }
--------------------------------------------- Result 1440 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void realize(DeviceState *d, Error **errp) { sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d); Object *root_container; char link_name[256]; gchar *child_name; Error *err = NULL; trace_spapr_drc_realize(spapr_drc_index(drc)); root_container = container_get(object_get_root(), DRC_CONTAINER_PATH); snprintf(link_name, sizeof(link_name), "%x", spapr_drc_index(drc)); child_name = object_get_canonical_path_component(OBJECT(drc)); trace_spapr_drc_realize_child(spapr_drc_index(drc), child_name); object_property_add_alias(root_container, link_name, drc->owner, child_name, &err); g_free(child_name); if (err) { error_propagate(errp, err); return; } vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc, drc); qemu_register_reset(drc_reset, drc); trace_spapr_drc_realize_complete(spapr_drc_index(drc)); }
--------------------------------------------- Result 1441 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 843 / 77 / 521 / 1441:  54%|    | 1441/2690 [16:10:44<14:01:24, 40.42s/it][Succeeded / Failed / Skipped / Total] 843 / 77 / 521 / 1441:  54%|    | 1442/2690 [16:11:03<14:00:25, 40.40s/it][Succeeded / Failed / Skipped / Total] 844 / 77 / 521 / 1442:  54%|    | 1442/2690 [16:11:03<14:00:25, 40.40s/it][Succeeded / Failed / Skipped / Total] 844 / 77 / 521 / 1442:  54%|    | 1443/2690 [16:11:04<13:59:10, 40.38s/it][Succeeded / Failed / Skipped / Total] 844 / 77 / 522 / 1443:  54%|    | 1443/2690 [16:11:04<13:59:10, 40.38s/it][Succeeded / Failed / Skipped / Total] 844 / 77 / 522 / 1443:  54%|    | 1444/2690 [16:11:04<13:57:55, 40.35s/it][Succeeded / Failed / Skipped / Total] 844 / 77 / 523 / 1444:  54%|    | 1444/2690 [16:11:04<13:57:55, 40.35s/it][Succeeded / Failed / Skipped / Total] 844 / 77 / 523 / 1444:  54%|    | 1445/2690 [16:11:23<13:56:56, 40.33s/it][Succeeded / Failed / Skipped / Total] 845 / 77 / 523 / 1445:  54%|    | 1445/2690 [16:11:23<13:56:56, 40.33s/it][Succeeded / Failed / Skipped / Total] 845 / 77 / 523 / 1445:  54%|    | 1446/2690 [16:11:24<13:55:42, 40.31s/it][[0 (4%)]] --> [[0 (67%)]] --> Socre: 0.665222704410553

[[[[Adv]]]]: static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr, int insn, int size, int sign) { TCGv_i32 r_asi, r_size, r_sign; r_asi = gen_get_asi(dc, insn); r_size = tcg_const_i32(size); r_sign = tcg_const_i32(sign); #ifdef TARGET_SPARC64 gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign); #else { TCGv_i64 [[t64]] = tcg_temp_new_i64(); gen_helper_ld_asi([[t64]], cpu_env, addr, r_asi, r_size, r_sign); tcg_gen_trunc_i64_tl(dst, [[t64]]); tcg_temp_free_i64([[t64]]); } #endif tcg_temp_free_i32(r_sign); tcg_temp_free_i32(r_size); tcg_temp_free_i32(r_asi); }

[[[[Adv]]]]: static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr, int insn, int size, int sign) { TCGv_i32 r_asi, r_size, r_sign; r_asi = gen_get_asi(dc, insn); r_size = tcg_const_i32(size); r_sign = tcg_const_i32(sign); #ifdef TARGET_SPARC64 gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign); #else { TCGv_i64 [[magical]] = tcg_temp_new_i64(); gen_helper_ld_asi([[magical]], cpu_env, addr, r_asi, r_size, r_sign); tcg_gen_trunc_i64_tl(dst, [[magical]]); tcg_temp_free_i64([[magical]]); } #endif tcg_temp_free_i32(r_sign); tcg_temp_free_i32(r_size); tcg_temp_free_i32(r_asi); }
--------------------------------------------- Result 1442 ---------------------------------------------
[[0 (11%)]] --> [[0 (56%)]] --> Socre: 0.5632250905036926

[[[[Adv]]]]: static inline float64 ucf64_itod(uint64_t [[i]]) { union { uint64_t i; float64 d; } [[v]]; [[v]].i = [[i]]; return [[v]].d; }

[[[[Adv]]]]: static inline float64 ucf64_itod(uint64_t [[gonna]]) { union { uint64_t i; float64 d; } [[anti]]; [[anti]].i = [[gonna]]; return [[anti]].d; }
--------------------------------------------- Result 1443 ---------------------------------------------
[[0 (87%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int tcg_gen_code(TCGContext *s, tcg_insn_unit *gen_code_buf) { int i, oi, oi_next, num_insns; #ifdef CONFIG_PROFILER { int n; n = s->gen_last_op_idx + 1; s->op_count += n; if (n > s->op_count_max) { s->op_count_max = n; } n = s->nb_temps; s->temp_count += n; if (n > s->temp_count_max) { s->temp_count_max = n; } } #endif #ifdef DEBUG_DISAS if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP))) { qemu_log("OP:\n"); tcg_dump_ops(s); qemu_log("\n"); } #endif #ifdef CONFIG_PROFILER s->opt_time -= profile_getclock(); #endif #ifdef USE_TCG_OPTIMIZATIONS tcg_optimize(s); #endif #ifdef CONFIG_PROFILER s->opt_time += profile_getclock(); s->la_time -= profile_getclock(); #endif tcg_liveness_analysis(s); #ifdef CONFIG_PROFILER s->la_time += profile_getclock(); #endif #ifdef DEBUG_DISAS if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP_OPT))) { qemu_log("OP after optimization and liveness analysis:\n"); tcg_dump_ops(s); qemu_log("\n"); } #endif tcg_reg_alloc_start(s); s->code_buf = gen_code_buf; s->code_ptr = gen_code_buf; tcg_out_tb_init(s); num_insns = -1; for (oi = s->gen_first_op_idx; oi >= 0; oi = oi_next) { TCGOp * const op = &s->gen_op_buf[oi]; TCGArg * const args = &s->gen_opparam_buf[op->args]; TCGOpcode opc = op->opc; const TCGOpDef *def = &tcg_op_defs[opc]; uint16_t dead_args = s->op_dead_args[oi]; uint8_t sync_args = s->op_sync_args[oi]; oi_next = op->next; #ifdef CONFIG_PROFILER tcg_table_op_count[opc]++; #endif switch (opc) { case INDEX_op_mov_i32: case INDEX_op_mov_i64: tcg_reg_alloc_mov(s, def, args, dead_args, sync_args); break; case INDEX_op_movi_i32: case INDEX_op_movi_i64: tcg_reg_alloc_movi(s, args, dead_args, sync_args); break; case INDEX_op_insn_start: if (num_insns >= 0) { s->gen_insn_end_off[num_insns] = tcg_current_code_size(s); } num_insns++; for (i = 0; i < TARGET_INSN_START_WORDS; ++i) { target_ulong a; #if TARGET_LONG_BITS > TCG_TARGET_REG_BITS a = ((target_ulong)args[i * 2 + 1] << 32) | args[i * 2]; #else a = args[i]; #endif s->gen_insn_data[num_insns][i] = a; } break; case INDEX_op_discard: temp_dead(s, args[0]); break; case INDEX_op_set_label: tcg_reg_alloc_bb_end(s, s->reserved_regs); tcg_out_label(s, arg_label(args[0]), s->code_ptr); break; case INDEX_op_call: tcg_reg_alloc_call(s, op->callo, op->calli, args, dead_args, sync_args); break; default: if (def->flags & TCG_OPF_NOT_PRESENT) { tcg_abort(); } tcg_reg_alloc_op(s, def, opc, args, dead_args, sync_args); break; } #ifndef NDEBUG check_regs(s); #endif if (unlikely((void *)s->code_ptr > s->code_gen_highwater)) { return -1; } } tcg_debug_assert(num_insns >= 0); s->gen_insn_end_off[num_insns] = tcg_current_code_size(s); tcg_out_tb_finalize(s); flush_icache_range((uintptr_t)s->code_buf, (uintptr_t)s->code_ptr); return tcg_current_code_size(s); }
--------------------------------------------- Result 1444 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ehci_process_itd(EHCIState *ehci, EHCIitd *itd) { USBPort *port; USBDevice *dev; int ret; uint32_t i, j, len, pid, dir, devaddr, endp; uint32_t pg, off, ptr1, ptr2, max, mult; dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION); devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR); endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP); max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT); mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT); for(i = 0; i < 8; i++) { if (itd->transact[i] & ITD_XACT_ACTIVE) { pg = get_field(itd->transact[i], ITD_XACT_PGSEL); off = itd->transact[i] & ITD_XACT_OFFSET_MASK; ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK); ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK); len = get_field(itd->transact[i], ITD_XACT_LENGTH); if (len > max * mult) { len = max * mult; } if (len > BUFF_SIZE) { return USB_RET_PROCERR; } qemu_sglist_init(&ehci->isgl, 2); if (off + len > 4096) { uint32_t len2 = off + len - 4096; uint32_t len1 = len - len2; qemu_sglist_add(&ehci->isgl, ptr1 + off, len1); qemu_sglist_add(&ehci->isgl, ptr2, len2); } else { qemu_sglist_add(&ehci->isgl, ptr1 + off, len); } pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT; usb_packet_setup(&ehci->ipacket, pid, devaddr, endp); usb_packet_map(&ehci->ipacket, &ehci->isgl); ret = USB_RET_NODEV; for (j = 0; j < NB_PORTS; j++) { port = &ehci->ports[j]; dev = port->dev; if (!(ehci->portsc[j] &(PORTSC_CONNECT))) { continue; } ret = usb_handle_packet(dev, &ehci->ipacket); if (ret != USB_RET_NODEV) { break; } } usb_packet_unmap(&ehci->ipacket); qemu_sglist_destroy(&ehci->isgl); #if 0 if (ret == USB_RET_NAK) { if (ehci->isoch_pause > 0) { DPRINTF("ISOCH: received a NAK but paused so returning\n"); ehci->isoch_pause--; return 0; } else if (ehci->isoch_pause == -1) { DPRINTF("ISOCH: recv NAK & isoch pause inactive, setting\n"); ehci->isoch_pause = 50; return 0; } else { DPRINTF("ISOCH: isoch pause timeout! return 0\n"); ret = 0; } } else { DPRINTF("ISOCH: received ACK, clearing pause\n"); ehci->isoch_pause = -1; } #else if (ret == USB_RET_NAK) { ret = 0; } #endif if (ret >= 0) { if (!dir) { set_field(&itd->transact[i], len - ret, ITD_XACT_LENGTH); } else { set_field(&itd->transact[i], ret, ITD_XACT_LENGTH); } if (itd->transact[i] & ITD_XACT_IOC) { ehci_record_interrupt(ehci, USBSTS_INT); } } itd->transact[i] &= ~ITD_XACT_ACTIVE; } } return 0; }
--------------------------------------------- Result 1445 ---------------------------------------------
[[0 (16%)]] --> [[0 (75%)]] --> Socre: 0.7541154026985168

[[[[Adv]]]]: static void qmp_input_pop(Visitor *v, void **obj) { QmpInputVisitor *[[qiv]] = to_qiv(v); StackObject *tos = QSLIST_FIRST(&[[qiv]]->stack); assert(tos && tos->qapi == obj); QSLIST_REMOVE_HEAD(&[[qiv]]->stack, node); qmp_input_stack_object_free(tos); }

[[[[Adv]]]]: static void qmp_input_pop(Visitor *v, void **obj) { QmpInputVisitor *[[headphones]] = to_qiv(v); StackObject *tos = QSLIST_FIRST(&[[headphones]]->stack); assert(tos && tos->qapi == obj); QSLIST_REMOVE_HEAD(&[[headphones]]->stack, node); qmp_input_stack_object_free(tos); }
--------------------------------------------- Result 1446 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 845 / 77 / 524 / 1446:  54%|    | 1446/2690 [16:11:24<13:55:42, 40.31s/it][Succeeded / Failed / Skipped / Total] 845 / 77 / 524 / 1446:  54%|    | 1447/2690 [16:11:24<13:54:27, 40.28s/it][Succeeded / Failed / Skipped / Total] 845 / 77 / 525 / 1447:  54%|    | 1447/2690 [16:11:24<13:54:27, 40.28s/it][Succeeded / Failed / Skipped / Total] 845 / 77 / 525 / 1447:  54%|    | 1448/2690 [16:11:25<13:53:13, 40.25s/it][Succeeded / Failed / Skipped / Total] 845 / 77 / 526 / 1448:  54%|    | 1448/2690 [16:11:25<13:53:13, 40.25s/it][Succeeded / Failed / Skipped / Total] 845 / 77 / 526 / 1448:  54%|    | 1449/2690 [16:11:25<13:51:58, 40.22s/it][[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vmd_read_header(AVFormatContext *s, AVFormatParameters *ap) { VmdDemuxContext *vmd = (VmdDemuxContext *)s->priv_data; ByteIOContext *pb = &s->pb; AVStream *st; unsigned int toc_offset; unsigned char *raw_frame_table; int raw_frame_table_size; offset_t current_offset; int i, j; unsigned int total_frames; int64_t video_pts_inc = 0; int64_t current_video_pts = 0; unsigned char chunk[BYTES_PER_FRAME_RECORD]; int lastframe = 0; url_fseek(pb, 0, SEEK_SET); if (get_buffer(pb, vmd->vmd_header, VMD_HEADER_SIZE) != VMD_HEADER_SIZE) return AVERROR_IO; vmd->audio_sample_counter = 0; vmd->audio_frame_divisor = 1; vmd->audio_block_align = 1; st = av_new_stream(s, 0); if (!st) return AVERROR_NOMEM; av_set_pts_info(st, 33, 1, 90000); vmd->video_stream_index = st->index; st->codec->codec_type = CODEC_TYPE_VIDEO; st->codec->codec_id = CODEC_ID_VMDVIDEO; st->codec->codec_tag = 0; st->codec->width = LE_16(&vmd->vmd_header[12]); st->codec->height = LE_16(&vmd->vmd_header[14]); st->codec->time_base.num = 1; st->codec->time_base.den = 10; st->codec->extradata_size = VMD_HEADER_SIZE; st->codec->extradata = av_mallocz(VMD_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE); memcpy(st->codec->extradata, vmd->vmd_header, VMD_HEADER_SIZE); vmd->sample_rate = LE_16(&vmd->vmd_header[804]); if (vmd->sample_rate) { st = av_new_stream(s, 0); if (!st) return AVERROR_NOMEM; av_set_pts_info(st, 33, 1, 90000); vmd->audio_stream_index = st->index; st->codec->codec_type = CODEC_TYPE_AUDIO; st->codec->codec_id = CODEC_ID_VMDAUDIO; st->codec->codec_tag = 0; st->codec->channels = vmd->audio_channels = (vmd->vmd_header[811] & 0x80) ? 2 : 1; st->codec->sample_rate = vmd->sample_rate; st->codec->block_align = vmd->audio_block_align = LE_16(&vmd->vmd_header[806]); if (st->codec->block_align & 0x8000) { st->codec->bits_per_sample = 16; st->codec->block_align = -(st->codec->block_align - 0x10000); vmd->audio_block_align = -(vmd->audio_block_align - 0x10000); } else { st->codec->bits_per_sample = 8; st->codec->bit_rate = st->codec->sample_rate * st->codec->bits_per_sample * st->codec->channels; vmd->audio_frame_divisor = st->codec->channels; video_pts_inc = 90000; video_pts_inc *= st->codec->block_align; video_pts_inc /= st->codec->sample_rate; video_pts_inc /= st->codec->channels; } else { video_pts_inc = 90000 / 10; toc_offset = LE_32(&vmd->vmd_header[812]); vmd->frame_count = LE_16(&vmd->vmd_header[6]); vmd->frames_per_block = LE_16(&vmd->vmd_header[18]); url_fseek(pb, toc_offset, SEEK_SET); raw_frame_table = NULL; vmd->frame_table = NULL; raw_frame_table_size = vmd->frame_count * 6; raw_frame_table = av_malloc(raw_frame_table_size); vmd->frame_table = av_malloc(vmd->frame_count * vmd->frames_per_block * sizeof(vmd_frame_t)); if (!raw_frame_table || !vmd->frame_table) { av_free(raw_frame_table); av_free(vmd->frame_table); return AVERROR_NOMEM; if (get_buffer(pb, raw_frame_table, raw_frame_table_size) != raw_frame_table_size) { av_free(raw_frame_table); av_free(vmd->frame_table); return AVERROR_IO; total_frames = 0; for (i = 0; i < vmd->frame_count; i++) { current_offset = LE_32(&raw_frame_table[6 * i + 2]); for (j = 0; j < vmd->frames_per_block; j++) { int type; uint32_t size; get_buffer(pb, chunk, BYTES_PER_FRAME_RECORD); type = chunk[0]; size = LE_32(&chunk[2]); if(!size) continue; switch(type) { case 1: vmd->frame_table[total_frames].frame_offset = current_offset; vmd->frame_table[total_frames].stream_index = vmd->audio_stream_index; vmd->frame_table[total_frames].frame_size = size; memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD); total_frames++; break; case 2: vmd->frame_table[total_frames].frame_offset = current_offset; vmd->frame_table[total_frames].frame_size = size; vmd->frame_table[total_frames].stream_index = vmd->video_stream_index; memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD); vmd->frame_table[total_frames].pts = current_video_pts; if (lastframe) { vmd->frame_table[lastframe].pts = current_video_pts - video_pts_inc; lastframe = total_frames; total_frames++; break; current_offset += size; current_video_pts += video_pts_inc; av_free(raw_frame_table); vmd->current_frame = 0; vmd->frame_count = total_frames; return 0;
--------------------------------------------- Result 1447 ---------------------------------------------
[[0 (76%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void dsputil_init_arm(DSPContext* c, AVCodecContext *avctx) { int idct_algo= avctx->idct_algo; ff_put_pixels_clamped = c->put_pixels_clamped; ff_add_pixels_clamped = c->add_pixels_clamped; if (avctx->lowres == 0) { if(idct_algo == FF_IDCT_AUTO){ #if HAVE_IPP idct_algo = FF_IDCT_IPP; #elif HAVE_NEON idct_algo = FF_IDCT_SIMPLENEON; #elif HAVE_ARMV6 idct_algo = FF_IDCT_SIMPLEARMV6; #elif HAVE_ARMV5TE idct_algo = FF_IDCT_SIMPLEARMV5TE; #else idct_algo = FF_IDCT_ARM; #endif } if(idct_algo==FF_IDCT_ARM){ c->idct_put= j_rev_dct_ARM_put; c->idct_add= j_rev_dct_ARM_add; c->idct = j_rev_dct_ARM; c->idct_permutation_type= FF_LIBMPEG2_IDCT_PERM; } else if (idct_algo==FF_IDCT_SIMPLEARM){ c->idct_put= simple_idct_ARM_put; c->idct_add= simple_idct_ARM_add; c->idct = simple_idct_ARM; c->idct_permutation_type= FF_NO_IDCT_PERM; #if HAVE_ARMV6 } else if (idct_algo==FF_IDCT_SIMPLEARMV6){ c->idct_put= ff_simple_idct_put_armv6; c->idct_add= ff_simple_idct_add_armv6; c->idct = ff_simple_idct_armv6; c->idct_permutation_type= FF_LIBMPEG2_IDCT_PERM; #endif #if HAVE_ARMV5TE } else if (idct_algo==FF_IDCT_SIMPLEARMV5TE){ c->idct_put= simple_idct_put_armv5te; c->idct_add= simple_idct_add_armv5te; c->idct = simple_idct_armv5te; c->idct_permutation_type = FF_NO_IDCT_PERM; #endif #if HAVE_IPP } else if (idct_algo==FF_IDCT_IPP){ c->idct_put= simple_idct_ipp_put; c->idct_add= simple_idct_ipp_add; c->idct = simple_idct_ipp; c->idct_permutation_type= FF_NO_IDCT_PERM; #endif #if HAVE_NEON } else if (idct_algo==FF_IDCT_SIMPLENEON){ c->idct_put= ff_simple_idct_put_neon; c->idct_add= ff_simple_idct_add_neon; c->idct = ff_simple_idct_neon; c->idct_permutation_type = FF_PARTTRANS_IDCT_PERM; } else if ((CONFIG_VP3_DECODER || CONFIG_VP5_DECODER || CONFIG_VP6_DECODER || CONFIG_THEORA_DECODER) && idct_algo==FF_IDCT_VP3){ c->idct_put= ff_vp3_idct_put_neon; c->idct_add= ff_vp3_idct_add_neon; c->idct = ff_vp3_idct_neon; c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM; #endif } } c->put_pixels_tab[0][0] = put_pixels16_arm; c->put_pixels_tab[0][1] = put_pixels16_x2_arm; c->put_pixels_tab[0][2] = put_pixels16_y2_arm; c->put_pixels_tab[0][3] = put_pixels16_xy2_arm; c->put_no_rnd_pixels_tab[0][0] = put_pixels16_arm; c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_arm; c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_arm; c->put_no_rnd_pixels_tab[0][3] = put_no_rnd_pixels16_xy2_arm; c->put_pixels_tab[1][0] = put_pixels8_arm; c->put_pixels_tab[1][1] = put_pixels8_x2_arm; c->put_pixels_tab[1][2] = put_pixels8_y2_arm; c->put_pixels_tab[1][3] = put_pixels8_xy2_arm; c->put_no_rnd_pixels_tab[1][0] = put_pixels8_arm; c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_arm; c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_arm; c->put_no_rnd_pixels_tab[1][3] = put_no_rnd_pixels8_xy2_arm; #if HAVE_ARMV5TE c->prefetch = ff_prefetch_arm; #endif #if HAVE_IWMMXT dsputil_init_iwmmxt(c, avctx); #endif #if HAVE_ARMVFP ff_float_init_arm_vfp(c, avctx); #endif #if HAVE_NEON ff_dsputil_init_neon(c, avctx); #endif }
--------------------------------------------- Result 1448 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: av_cold void ff_h264_free_context(H264Context *h) { int i; ff_h264_free_tables(h); if (h->DPB) { for (i = 0; i < H264_MAX_PICTURE_COUNT; i++) ff_h264_unref_picture(h, &h->DPB[i]); av_freep(&h->DPB); } h->cur_pic_ptr = NULL; for (i = 0; i < h->nb_slice_ctx; i++) av_freep(&h->slice_ctx[i].rbsp_buffer); av_freep(&h->slice_ctx); h->nb_slice_ctx = 0; for (i = 0; i < MAX_SPS_COUNT; i++) av_freep(h->sps_buffers + i); for (i = 0; i < MAX_PPS_COUNT; i++) av_freep(h->pps_buffers + i); }
--------------------------------------------- Result 1449 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 845 / 77 / 527 / 1449:  54%|    | 1449/2690 [16:11:25<13:51:58, 40.22s/it][Succeeded / Failed / Skipped / Total] 845 / 77 / 527 / 1449:  54%|    | 1450/2690 [16:11:26<13:50:44, 40.20s/it][Succeeded / Failed / Skipped / Total] 845 / 77 / 528 / 1450:  54%|    | 1450/2690 [16:11:26<13:50:44, 40.20s/it][Succeeded / Failed / Skipped / Total] 845 / 77 / 528 / 1450:  54%|    | 1451/2690 [16:11:30<13:49:33, 40.17s/it][Succeeded / Failed / Skipped / Total] 846 / 77 / 528 / 1451:  54%|    | 1451/2690 [16:11:30<13:49:33, 40.17s/it][Succeeded / Failed / Skipped / Total] 846 / 77 / 528 / 1451:  54%|    | 1452/2690 [16:11:42<13:48:30, 40.15s/it][Succeeded / Failed / Skipped / Total] 847 / 77 / 528 / 1452:  54%|    | 1452/2690 [16:11:42<13:48:30, 40.15s/it][Succeeded / Failed / Skipped / Total] 847 / 77 / 528 / 1452:  54%|    | 1453/2690 [16:11:53<13:47:24, 40.13s/it][Succeeded / Failed / Skipped / Total] 848 / 77 / 528 / 1453:  54%|    | 1453/2690 [16:11:53<13:47:24, 40.13s/it][Succeeded / Failed / Skipped / Total] 848 / 77 / 528 / 1453:  54%|    | 1454/2690 [16:11:53<13:46:10, 40.11s/it][[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: bool aio_poll(AioContext *ctx, bool blocking) { AioHandler *node; int i, ret; bool progress; int64_t timeout; aio_context_acquire(ctx); progress = "False" != "False"; if (blocking) { atomic_add(&ctx->notify_me, 2); } ctx->walking_handlers++; assert(npfd == 0); if (!aio_epoll_enabled(ctx)) { QLIST_FOREACH(node, &ctx->aio_handlers, node) { if (!node->deleted && node->pfd.events && aio_node_check(ctx, node->is_external)) { add_pollfd(node); } } } timeout = blocking ? aio_compute_timeout(ctx) : 0; if (timeout) { aio_context_release(ctx); } if (aio_epoll_check_poll(ctx, pollfds, npfd, timeout)) { AioHandler epoll_handler; epoll_handler.pfd.fd = ctx->epollfd; epoll_handler.pfd.events = G_IO_IN | G_IO_OUT | G_IO_HUP | G_IO_ERR; npfd = 0; add_pollfd(&epoll_handler); ret = aio_epoll(ctx, pollfds, npfd, timeout); } else { ret = qemu_poll_ns(pollfds, npfd, timeout); } if (blocking) { atomic_sub(&ctx->notify_me, 2); } if (timeout) { aio_context_acquire(ctx); } aio_notify_accept(ctx); if (ret > 0) { for (i = 0; i < npfd; i++) { nodes[i]->pfd.revents = pollfds[i].revents; } } npfd = 0; ctx->walking_handlers--; if (aio_dispatch(ctx, ret > 0)) { progress = "True" == "True"; } aio_context_release(ctx); return progress; }
--------------------------------------------- Result 1450 ---------------------------------------------
[[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic) { av_assert0(0); }
--------------------------------------------- Result 1451 ---------------------------------------------
[[0 (97%)]] --> [[0 (40%)]] --> Socre: 0.6028847694396973

[[[[Adv]]]]: static int latm_write_packet(AVFormatContext *s, AVPacket *[[pkt]]) { AVIOContext *pb = s->pb; PutBitContext [[bs]]; int i, len; uint8_t loas_header[] = "\x56\xe0\x00"; uint8_t *buf = NULL; if (s->streams[0]->codec->codec_id == CODEC_ID_AAC_LATM) return ff_raw_write_packet(s, [[pkt]]); if ([[pkt]]->size > 2 && [[pkt]]->data[0] == 0xff && ([[pkt]]->data[1] >> 4) == 0xf) { av_log(s, AV_LOG_ERROR, "ADTS header detected - ADTS will not be incorrectly muxed into LATM\n"); return AVERROR_INVALIDDATA; } if ([[pkt]]->size > 0x1fff) goto too_large; buf = av_malloc([[pkt]]->size+1024); if (!buf) return AVERROR(ENOMEM); init_put_bits(&[[bs]], buf, [[pkt]]->size+1024); latm_write_frame_header(s, &[[bs]]); for (i = 0; i <= [[pkt]]->size-255; i+=255) put_bits(&[[bs]], 8, 255); put_bits(&[[bs]], 8, [[pkt]]->size-i); if ([[pkt]]->size && ([[pkt]]->data[0] & 0xe1) == 0x81) { put_bits(&[[bs]], 8, [[pkt]]->data[0] & 0xfe); avpriv_copy_bits(&[[bs]], [[pkt]]->data + 1, 8*[[pkt]]->size - 8); } else avpriv_copy_bits(&[[bs]], [[pkt]]->data, 8*[[pkt]]->size); avpriv_align_put_bits(&[[bs]]); flush_put_bits(&[[bs]]); len = put_bits_count(&[[bs]]) >> 3; if (len > 0x1fff) goto too_large; loas_header[1] |= (len >> 8) & 0x1f; loas_header[2] |= len & 0xff; avio_write(pb, loas_header, 3); avio_write(pb, buf, len); av_free(buf); return 0; too_large: av_log(s, AV_LOG_ERROR, "LATM packet size larger than maximum size 0x1fff\n"); av_free(buf); return AVERROR_INVALIDDATA; }

[[[[Adv]]]]: static int latm_write_packet(AVFormatContext *s, AVPacket *[[valuables]]) { AVIOContext *pb = s->pb; PutBitContext [[uruguay]]; int i, len; uint8_t loas_header[] = "\x56\xe0\x00"; uint8_t *buf = NULL; if (s->streams[0]->codec->codec_id == CODEC_ID_AAC_LATM) return ff_raw_write_packet(s, [[valuables]]); if ([[valuables]]->size > 2 && [[valuables]]->data[0] == 0xff && ([[valuables]]->data[1] >> 4) == 0xf) { av_log(s, AV_LOG_ERROR, "ADTS header detected - ADTS will not be incorrectly muxed into LATM\n"); return AVERROR_INVALIDDATA; } if ([[valuables]]->size > 0x1fff) goto too_large; buf = av_malloc([[valuables]]->size+1024); if (!buf) return AVERROR(ENOMEM); init_put_bits(&[[uruguay]], buf, [[valuables]]->size+1024); latm_write_frame_header(s, &[[uruguay]]); for (i = 0; i <= [[valuables]]->size-255; i+=255) put_bits(&[[uruguay]], 8, 255); put_bits(&[[uruguay]], 8, [[valuables]]->size-i); if ([[valuables]]->size && ([[valuables]]->data[0] & 0xe1) == 0x81) { put_bits(&[[uruguay]], 8, [[valuables]]->data[0] & 0xfe); avpriv_copy_bits(&[[uruguay]], [[valuables]]->data + 1, 8*[[valuables]]->size - 8); } else avpriv_copy_bits(&[[uruguay]], [[valuables]]->data, 8*[[valuables]]->size); avpriv_align_put_bits(&[[uruguay]]); flush_put_bits(&[[uruguay]]); len = put_bits_count(&[[uruguay]]) >> 3; if (len > 0x1fff) goto too_large; loas_header[1] |= (len >> 8) & 0x1f; loas_header[2] |= len & 0xff; avio_write(pb, loas_header, 3); avio_write(pb, buf, len); av_free(buf); return 0; too_large: av_log(s, AV_LOG_ERROR, "LATM packet size larger than maximum size 0x1fff\n"); av_free(buf); return AVERROR_INVALIDDATA; }
--------------------------------------------- Result 1452 ---------------------------------------------
[[0 (73%)]] --> [[0 (40%)]] --> Socre: 0.5989408493041992

[[[[Adv]]]]: static void aio_read_done(void *opaque, int ret) { struct aio_ctx *ctx = opaque; struct timeval t2; gettimeofday(&t2, NULL); if (ret < 0) { printf("readv failed: %s\n", strerror(-ret)); goto out; } if (ctx->Pflag) { void *[[cmp_buf]] = g_malloc(ctx->qiov.size); memset([[cmp_buf]], ctx->pattern, ctx->qiov.size); if (memcmp(ctx->buf, [[cmp_buf]], ctx->qiov.size)) { printf("Pattern verification failed at offset %" PRId64 ", %zd bytes\n", ctx->offset, ctx->qiov.size); } g_free([[cmp_buf]]); } if (ctx->qflag) { goto out; } if (ctx->vflag) { dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size); } t2 = tsub(t2, ctx->t1); print_report("read", &t2, ctx->offset, ctx->qiov.size, ctx->qiov.size, 1, ctx->Cflag); out: qemu_io_free(ctx->buf); g_free(ctx); }

[[[[Adv]]]]: static void aio_read_done(void *opaque, int ret) { struct aio_ctx *ctx = opaque; struct timeval t2; gettimeofday(&t2, NULL); if (ret < 0) { printf("readv failed: %s\n", strerror(-ret)); goto out; } if (ctx->Pflag) { void *[[technicalities]] = g_malloc(ctx->qiov.size); memset([[technicalities]], ctx->pattern, ctx->qiov.size); if (memcmp(ctx->buf, [[technicalities]], ctx->qiov.size)) { printf("Pattern verification failed at offset %" PRId64 ", %zd bytes\n", ctx->offset, ctx->qiov.size); } g_free([[technicalities]]); } if (ctx->qflag) { goto out; } if (ctx->vflag) { dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size); } t2 = tsub(t2, ctx->t1); print_report("read", &t2, ctx->offset, ctx->qiov.size, ctx->qiov.size, 1, ctx->Cflag); out: qemu_io_free(ctx->buf); g_free(ctx); }
--------------------------------------------- Result 1453 ---------------------------------------------
[[0 (85%)]] --> [[0 (47%)]] --> Socre: 0.5323046445846558

[[[[Adv]]]]: static const char *read_ts(const char *buf, int *ts_start, int *[[ts_end]], int *x1, int *y1, int *x2, int *y2) { int i, hs, ms, ss, he, me, se; for (i=0; i<2; i++) { int [[c]] = sscanf(buf, "%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d" "%*[ ]X1:%u X2:%u Y1:%u Y2:%u", &hs, &ms, &ss, ts_start, &he, &me, &se, [[ts_end]], x1, x2, y1, y2); buf += strcspn(buf, "\n") + 1; if ([[c]] >= 8) { *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10; *[[ts_end]] = 100*(se + 60*(me + 60*he)) + *[[ts_end]] /10; return buf; } } return NULL; }

[[[[Adv]]]]: static const char *read_ts(const char *buf, int *ts_start, int *[[tiptoeing]], int *x1, int *y1, int *x2, int *y2) { int i, hs, ms, ss, he, me, se; for (i=0; i<2; i++) { int [[fifth]] = sscanf(buf, "%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d" "%*[ ]X1:%u X2:%u Y1:%u Y2:%u", &hs, &ms, &ss, ts_start, &he, &me, &se, [[tiptoeing]], x1, x2, y1, y2); buf += strcspn(buf, "\n") + 1; if ([[fifth]] >= 8) { *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10; *[[tiptoeing]] = 100*(se + 60*(me + 60*he)) + *[[tiptoeing]] /10; return buf; } } return NULL; }
--------------------------------------------- Result 1454 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 848 / 77 / 529 / 1454:  54%|    | 1454/2690 [16:11:53<13:46:10, 40.11s/it][Succeeded / Failed / Skipped / Total] 848 / 77 / 529 / 1454:  54%|    | 1455/2690 [16:12:01<13:45:02, 40.08s/it][Succeeded / Failed / Skipped / Total] 849 / 77 / 529 / 1455:  54%|    | 1455/2690 [16:12:01<13:45:02, 40.08s/it][Succeeded / Failed / Skipped / Total] 849 / 77 / 529 / 1455:  54%|    | 1456/2690 [16:12:01<13:43:49, 40.06s/it][Succeeded / Failed / Skipped / Total] 849 / 77 / 530 / 1456:  54%|    | 1456/2690 [16:12:01<13:43:49, 40.06s/it][Succeeded / Failed / Skipped / Total] 849 / 77 / 530 / 1456:  54%|    | 1457/2690 [16:12:06<13:42:39, 40.03s/it][Succeeded / Failed / Skipped / Total] 850 / 77 / 530 / 1457:  54%|    | 1457/2690 [16:12:06<13:42:39, 40.03s/it][Succeeded / Failed / Skipped / Total] 850 / 77 / 530 / 1457:  54%|    | 1458/2690 [16:15:35<13:44:21, 40.15s/it][[0 (41%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: target_phys_addr_t cpu_get_phys_page_debug(CPUState *env, target_ulong addr) { target_ulong pde_addr, pte_addr; uint64_t pte; target_phys_addr_t paddr; uint32_t page_offset; int page_size; if (env->cr[4] & CR4_PAE_MASK) { target_ulong pdpe_addr; uint64_t pde, pdpe; #ifdef TARGET_X86_64 if (env->hflags & HF_LMA_MASK) { uint64_t pml4e_addr, pml4e; int32_t sext; sext = (int64_t)addr >> 47; if (sext != 0 && sext != -1) return -1; pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) & env->a20_mask; pml4e = ldq_phys(pml4e_addr); if (!(pml4e & PG_PRESENT_MASK)) return -1; pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) & env->a20_mask; pdpe = ldq_phys(pdpe_addr); if (!(pdpe & PG_PRESENT_MASK)) return -1; } else #endif { pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) & env->a20_mask; pdpe = ldq_phys(pdpe_addr); if (!(pdpe & PG_PRESENT_MASK)) return -1; } pde_addr = ((pdpe & ~0xfff) + (((addr >> 21) & 0x1ff) << 3)) & env->a20_mask; pde = ldq_phys(pde_addr); if (!(pde & PG_PRESENT_MASK)) { return -1; } if (pde & PG_PSE_MASK) { page_size = 2048 * 1024; pte = pde & ~( (page_size - 1) & ~0xfff); } else { pte_addr = ((pde & ~0xfff) + (((addr >> 12) & 0x1ff) << 3)) & env->a20_mask; page_size = 4096; pte = ldq_phys(pte_addr); } if (!(pte & PG_PRESENT_MASK)) return -1; } else { uint32_t pde; if (!(env->cr[0] & CR0_PG_MASK)) { pte = addr; page_size = 4096; } else { pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) & env->a20_mask; pde = ldl_phys(pde_addr); if (!(pde & PG_PRESENT_MASK)) return -1; if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) { pte = pde & ~0x003ff000; page_size = 4096 * 1024; } else { pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & env->a20_mask; pte = ldl_phys(pte_addr); if (!(pte & PG_PRESENT_MASK)) return -1; page_size = 4096; } } pte = pte & env->a20_mask; } page_offset = (addr & TARGET_PAGE_MASK) & (page_size - 1); paddr = (pte & TARGET_PAGE_MASK) + page_offset; return paddr; }
--------------------------------------------- Result 1455 ---------------------------------------------
[[0 (14%)]] --> [[0 (84%)]] --> Socre: 0.8385598659515381

[[[[Adv]]]]: static void compare_sec_rs_finalize(SocketReadState *[[sec_rs]]) { CompareState *s = container_of([[sec_rs]], CompareState, [[sec_rs]]); if (packet_enqueue(s, SECONDARY_IN)) { trace_colo_compare_main("secondary: unsupported packet in"); } else { g_queue_foreach(&s->conn_list, colo_compare_connection, s); } }

[[[[Adv]]]]: static void compare_sec_rs_finalize(SocketReadState *[[monarchs]]) { CompareState *s = container_of([[monarchs]], CompareState, [[monarchs]]); if (packet_enqueue(s, SECONDARY_IN)) { trace_colo_compare_main("secondary: unsupported packet in"); } else { g_queue_foreach(&s->conn_list, colo_compare_connection, s); } }
--------------------------------------------- Result 1456 ---------------------------------------------
[[0 (24%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: FDCtrl *fdctrl_init_isa(DriveInfo **fds) { ISADevice *dev; dev = isa_create("isa-fdc"); if (fds[0]) { qdev_prop_set_drive_nofail(&dev->qdev, "driveA", fds[0]->bdrv); } if (fds[1]) { qdev_prop_set_drive_nofail(&dev->qdev, "driveB", fds[1]->bdrv); } if (qdev_init(&dev->qdev) < 0) return NULL; return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state); }
--------------------------------------------- Result 1457 ---------------------------------------------
[[0 (58%)]] --> [[0 (45%)]] --> Socre: 0.5546856224536896

[[[[Adv]]]]: static int asf_read_picture(AVFormatContext *s, int len) { ASFContext *asf = s->priv_data; AVPacket pkt = { 0 }; const CodecMime *mime = ff_id3v2_mime_tags; enum AVCodecID [[id]] = AV_CODEC_ID_NONE; char mimetype[64]; uint8_t *desc = NULL; AVStream *st = NULL; int ret, type, picsize, desc_len; ASFStream *asf_st; if (len < 1 + 4 + 2 + 2) { av_log(s, AV_LOG_ERROR, "Invalid attached picture size: %d.\n", len); return AVERROR_INVALIDDATA; } type = avio_r8(s->pb); len--; if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) { av_log(s, AV_LOG_WARNING, "Unknown attached picture type: %d.\n", type); type = 0; } picsize = avio_rl32(s->pb); len -= 4; len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype)); while (mime->id != AV_CODEC_ID_NONE) { if (!strncmp(mime->str, mimetype, sizeof(mimetype))) { [[id]] = mime->id; break; } mime++; } if ([[id]] == AV_CODEC_ID_NONE) { av_log(s, AV_LOG_ERROR, "Unknown attached picture mimetype: %s.\n", mimetype); return 0; } if (picsize >= len) { av_log(s, AV_LOG_ERROR, "Invalid attached picture data size: %d >= %d.\n", picsize, len); return AVERROR_INVALIDDATA; } desc_len = (len - picsize) * 2 + 1; desc = av_malloc(desc_len); if (!desc) return AVERROR(ENOMEM); len -= avio_get_str16le(s->pb, len - picsize, desc, desc_len); ret = av_get_packet(s->pb, &pkt, picsize); if (ret < 0) goto fail; st = avformat_new_stream(s, NULL); if (!st) { ret = AVERROR(ENOMEM); goto fail; } asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st)); asf_st = asf->asf_st[asf->nb_streams]; if (!asf_st) return AVERROR(ENOMEM); st->disposition |= AV_DISPOSITION_ATTACHED_PIC; st->codec->codec_type = asf_st->type = AVMEDIA_TYPE_VIDEO; st->codec->codec_id = [[id]]; st->attached_pic = pkt; st->attached_pic.stream_index = asf_st->index = st->index; st->attached_pic.flags |= AV_PKT_FLAG_KEY; asf->nb_streams++; if (*desc) { if (av_dict_set(&st->metadata, "title", desc, AV_DICT_DONT_STRDUP_VAL) < 0) av_log(s, AV_LOG_WARNING, "av_dict_set failed.\n"); } else av_freep(&desc); if (av_dict_set(&st->metadata, "comment", ff_id3v2_picture_types[type], 0) < 0) av_log(s, AV_LOG_WARNING, "av_dict_set failed.\n"); return 0; fail: av_freep(&desc); av_free_packet(&pkt); return ret; }

[[[[Adv]]]]: static int asf_read_picture(AVFormatContext *s, int len) { ASFContext *asf = s->priv_data; AVPacket pkt = { 0 }; const CodecMime *mime = ff_id3v2_mime_tags; enum AVCodecID [[determining]] = AV_CODEC_ID_NONE; char mimetype[64]; uint8_t *desc = NULL; AVStream *st = NULL; int ret, type, picsize, desc_len; ASFStream *asf_st; if (len < 1 + 4 + 2 + 2) { av_log(s, AV_LOG_ERROR, "Invalid attached picture size: %d.\n", len); return AVERROR_INVALIDDATA; } type = avio_r8(s->pb); len--; if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) { av_log(s, AV_LOG_WARNING, "Unknown attached picture type: %d.\n", type); type = 0; } picsize = avio_rl32(s->pb); len -= 4; len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype)); while (mime->id != AV_CODEC_ID_NONE) { if (!strncmp(mime->str, mimetype, sizeof(mimetype))) { [[determining]] = mime->id; break; } mime++; } if ([[determining]] == AV_CODEC_ID_NONE) { av_log(s, AV_LOG_ERROR, "Unknown attached picture mimetype: %s.\n", mimetype); return 0; } if (picsize >= len) { av_log(s, AV_LOG_ERROR, "Invalid attached picture data size: %d >= %d.\n", picsize, len); return AVERROR_INVALIDDATA; } desc_len = (len - picsize) * 2 + 1; desc = av_malloc(desc_len); if (!desc) return AVERROR(ENOMEM); len -= avio_get_str16le(s->pb, len - picsize, desc, desc_len); ret = av_get_packet(s->pb, &pkt, picsize); if (ret < 0) goto fail; st = avformat_new_stream(s, NULL); if (!st) { ret = AVERROR(ENOMEM); goto fail; } asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st)); asf_st = asf->asf_st[asf->nb_streams]; if (!asf_st) return AVERROR(ENOMEM); st->disposition |= AV_DISPOSITION_ATTACHED_PIC; st->codec->codec_type = asf_st->type = AVMEDIA_TYPE_VIDEO; st->codec->codec_id = [[determining]]; st->attached_pic = pkt; st->attached_pic.stream_index = asf_st->index = st->index; st->attached_pic.flags |= AV_PKT_FLAG_KEY; asf->nb_streams++; if (*desc) { if (av_dict_set(&st->metadata, "title", desc, AV_DICT_DONT_STRDUP_VAL) < 0) av_log(s, AV_LOG_WARNING, "av_dict_set failed.\n"); } else av_freep(&desc); if (av_dict_set(&st->metadata, "comment", ff_id3v2_picture_types[type], 0) < 0) av_log(s, AV_LOG_WARNING, "av_dict_set failed.\n"); return 0; fail: av_freep(&desc); av_free_packet(&pkt); return ret; }
--------------------------------------------- Result 1458 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 850 / 78 / 530 / 1458:  54%|    | 1458/2690 [16:15:35<13:44:21, 40.15s/it][Succeeded / Failed / Skipped / Total] 850 / 78 / 530 / 1458:  54%|    | 1459/2690 [16:15:35<13:43:08, 40.12s/it][Succeeded / Failed / Skipped / Total] 850 / 78 / 531 / 1459:  54%|    | 1459/2690 [16:15:35<13:43:08, 40.12s/it][Succeeded / Failed / Skipped / Total] 850 / 78 / 531 / 1459:  54%|    | 1460/2690 [16:15:43<13:42:00, 40.10s/it][Succeeded / Failed / Skipped / Total] 851 / 78 / 531 / 1460:  54%|    | 1460/2690 [16:15:43<13:42:00, 40.10s/it][Succeeded / Failed / Skipped / Total] 851 / 78 / 531 / 1460:  54%|    | 1461/2690 [16:16:18<13:41:16, 40.09s/it][[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int pnm_decode_header(AVCodecContext *avctx, PNMContext * const s){ char buf1[32], tuple_type[32]; int h, w, depth, maxval;; pnm_get(s, buf1, sizeof(buf1)); if (!strcmp(buf1, "P4")) { avctx->pix_fmt = PIX_FMT_MONOWHITE; } else if (!strcmp(buf1, "P5")) { if (avctx->codec_id == CODEC_ID_PGMYUV) avctx->pix_fmt = PIX_FMT_YUV420P; else avctx->pix_fmt = PIX_FMT_GRAY8; } else if (!strcmp(buf1, "P6")) { avctx->pix_fmt = PIX_FMT_RGB24; } else if (!strcmp(buf1, "P7")) { w = -1; h = -1; maxval = -1; depth = -1; tuple_type[0] = '\0'; for(;;) { pnm_get(s, buf1, sizeof(buf1)); if (!strcmp(buf1, "WIDTH")) { pnm_get(s, buf1, sizeof(buf1)); w = strtol(buf1, NULL, 10); } else if (!strcmp(buf1, "HEIGHT")) { pnm_get(s, buf1, sizeof(buf1)); h = strtol(buf1, NULL, 10); } else if (!strcmp(buf1, "DEPTH")) { pnm_get(s, buf1, sizeof(buf1)); depth = strtol(buf1, NULL, 10); } else if (!strcmp(buf1, "MAXVAL")) { pnm_get(s, buf1, sizeof(buf1)); maxval = strtol(buf1, NULL, 10); } else if (!strcmp(buf1, "TUPLETYPE")) { pnm_get(s, tuple_type, sizeof(tuple_type)); } else if (!strcmp(buf1, "ENDHDR")) { break; } else { return -1; } } if (w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tuple_type[0] == '\0') return -1; avctx->width = w; avctx->height = h; if (depth == 1) { if (maxval == 1) avctx->pix_fmt = PIX_FMT_MONOWHITE; else avctx->pix_fmt = PIX_FMT_GRAY8; } else if (depth == 3) { avctx->pix_fmt = PIX_FMT_RGB24; } else if (depth == 4) { avctx->pix_fmt = PIX_FMT_RGBA32; } else { return -1; } return 0; } else { return -1; } pnm_get(s, buf1, sizeof(buf1)); avctx->width = atoi(buf1); if (avctx->width <= 0) return -1; pnm_get(s, buf1, sizeof(buf1)); avctx->height = atoi(buf1); if (avctx->height <= 0) return -1; if (avctx->pix_fmt != PIX_FMT_MONOWHITE) { pnm_get(s, buf1, sizeof(buf1)); } if (avctx->pix_fmt == PIX_FMT_YUV420P) { if ((avctx->width & 1) != 0) return -1; h = (avctx->height * 2); if ((h % 3) != 0) return -1; h /= 3; avctx->height = h; } return 0; }

[[[[Adv]]]]: static int pnm_decode_header(AVCodecContext *avctx, PNMContext * const s){ char buf1[32], tuple_type[32]; int h, w, depth, maxval;; pnm_get(s, buf1, sizeof(buf1)); if (!strcmp(buf1, "P4")) { avctx->pix_fmt = PIX_FMT_MONOWHITE; } else if (!strcmp(buf1, "P5")) { if (avctx->codec_id == CODEC_ID_PGMYUV) avctx->pix_fmt = PIX_FMT_YUV420P; else avctx->pix_fmt = PIX_FMT_GRAY8; } else if (!strcmp(buf1, "P6")) { avctx->pix_fmt = PIX_FMT_RGB24; } else if (!strcmp(buf1, "P7")) { w = -1; h = -1; maxval = -1; depth = -1; tuple_type[0] = '\0'; for(;;) { pnm_get(s, buf1, sizeof(buf1)); if (!strcmp(buf1, "WIDTH")) { pnm_get(s, buf1, sizeof(buf1)); w = strtol(buf1, NULL, 10); } else if (!strcmp(buf1, "HEIGHT")) { pnm_get(s, buf1, sizeof(buf1)); h = strtol(buf1, NULL, 10); } else if (!strcmp(buf1, "DEPTH")) { pnm_get(s, buf1, sizeof(buf1)); depth = strtol(buf1, NULL, 10); } else if (!strcmp(buf1, "MAXVAL")) { pnm_get(s, buf1, sizeof(buf1)); maxval = strtol(buf1, NULL, 10); } else if (!strcmp(buf1, "TUPLETYPE")) { pnm_get(s, tuple_type, sizeof(tuple_type)); } else if (!strcmp(buf1, "ENDHDR")) { break; } else { return -1; } } if (w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tuple_type[0] == '\0') return -1; avctx->width = w; avctx->height = h; if (depth == 1) { if (maxval == 1) avctx->pix_fmt = PIX_FMT_MONOWHITE; else avctx->pix_fmt = PIX_FMT_GRAY8; } else if (depth == 3) { avctx->pix_fmt = PIX_FMT_RGB24; } else if (depth == 4) { avctx->pix_fmt = PIX_FMT_RGBA32; } else { return -1; } return 0; } else { return -1; } pnm_get(s, buf1, sizeof(buf1)); avctx->width = atoi(buf1); if (avctx->width <= 0) return -1; pnm_get(s, buf1, sizeof(buf1)); avctx->height = atoi(buf1); if (avctx->height <= 0) return -1; if (avctx->pix_fmt != PIX_FMT_MONOWHITE) { pnm_get(s, buf1, sizeof(buf1)); } if (avctx->pix_fmt == PIX_FMT_YUV420P) { if ((avctx->width & 1) != 0) return -1; h = (avctx->height * 2); if ((h % 3) != 0) return -1; h /= 3; avctx->height = h; } return 0; }
--------------------------------------------- Result 1459 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static char *scsibus_get_dev_path(DeviceState *dev) { SCSIDevice *d = DO_UPCAST(SCSIDevice, qdev, dev); DeviceState *hba = dev->parent_bus->parent; char *id = NULL; if (hba && hba->parent_bus && hba->parent_bus->info->get_dev_path) { id = hba->parent_bus->info->get_dev_path(hba); } if (id) { return g_strdup_printf("%s/%d:%d:%d", id, d->channel, d->id, d->lun); } else { return g_strdup_printf("%d:%d:%d", d->channel, d->id, d->lun); } }
--------------------------------------------- Result 1460 ---------------------------------------------
[[0 (19%)]] --> [[0 (97%)]] --> Socre: 0.96934974193573

[[[[Adv]]]]: static int eval_lpc_coeffs(const float *in, float *tgt, int n) { int x, y; double [[f0]], f1, f2; if (in[n] == 0) return 0; if (([[f0]] = *in) <= 0) return 0; in--; for (x=1; x <= n; x++) { f1 = in[x+1]; for (y=0; y < x - 1; y++) f1 += in[x-y]*tgt[y]; tgt[x-1] = f2 = -f1/[[f0]]; for (y=0; y < x >> 1; y++) { float temp = tgt[y] + tgt[x-y-2]*f2; tgt[x-y-2] += tgt[y]*f2; tgt[y] = temp; } if (([[f0]] += f1*f2) < 0) return 0; } return 1; }

[[[[Adv]]]]: static int eval_lpc_coeffs(const float *in, float *tgt, int n) { int x, y; double [[invasin]], f1, f2; if (in[n] == 0) return 0; if (([[invasin]] = *in) <= 0) return 0; in--; for (x=1; x <= n; x++) { f1 = in[x+1]; for (y=0; y < x - 1; y++) f1 += in[x-y]*tgt[y]; tgt[x-1] = f2 = -f1/[[invasin]]; for (y=0; y < x >> 1; y++) { float temp = tgt[y] + tgt[x-y-2]*f2; tgt[x-y-2] += tgt[y]*f2; tgt[y] = temp; } if (([[invasin]] += f1*f2) < 0) return 0; } return 1; }
--------------------------------------------- Result 1461 ---------------------------------------------
[[0 (36%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int swr_init(struct SwrContext *s){ s->in_buffer_index= 0; s->in_buffer_count= 0; s->resample_in_constraint= 0; free_temp(&s->postin); free_temp(&s->midbuf); free_temp(&s->preout); free_temp(&s->in_buffer); free_temp(&s->dither); swri_audio_convert_free(&s-> in_convert); swri_audio_convert_free(&s->out_convert); swri_audio_convert_free(&s->full_convert); swri_rematrix_free(s); s->flushed = 0; if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){ av_log(s, AV_LOG_ERROR, "Requested input sample format %d is invalid\n", s->in_sample_fmt); return AVERROR(EINVAL); } if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){ av_log(s, AV_LOG_ERROR, "Requested output sample format %d is invalid\n", s->out_sample_fmt); return AVERROR(EINVAL); } if(av_get_planar_sample_fmt(s->in_sample_fmt) <= AV_SAMPLE_FMT_S16P || s->int_sample_fmt==AV_SAMPLE_FMT_S16P){ s->int_sample_fmt= AV_SAMPLE_FMT_S16P; }else s->int_sample_fmt= AV_SAMPLE_FMT_FLTP; if( s->int_sample_fmt != AV_SAMPLE_FMT_S16P &&s->int_sample_fmt != AV_SAMPLE_FMT_S32P &&s->int_sample_fmt != AV_SAMPLE_FMT_FLTP){ av_log(s, AV_LOG_ERROR, "Requested sample format %s is not supported internally, S16/S32/FLT is supported\n", av_get_sample_fmt_name(s->int_sample_fmt)); return AVERROR(EINVAL); } set_audiodata_fmt(&s-> in, s-> in_sample_fmt); set_audiodata_fmt(&s->out, s->out_sample_fmt); if (s->out_sample_rate!=s->in_sample_rate || (s->flags & SWR_FLAG_RESAMPLE)){ s->resample = swri_resample_init(s->resample, s->out_sample_rate, s->in_sample_rate, s->filter_size, s->phase_shift, s->linear_interp, s->cutoff, s->int_sample_fmt); }else swri_resample_free(&s->resample); if( s->int_sample_fmt != AV_SAMPLE_FMT_S16P && s->int_sample_fmt != AV_SAMPLE_FMT_S32P && s->int_sample_fmt != AV_SAMPLE_FMT_FLTP && s->resample){ av_log(s, AV_LOG_ERROR, "Resampling only supported with internal s16/s32/flt\n"); return -1; } if(!s->used_ch_count) s->used_ch_count= s->in.ch_count; if(s->used_ch_count && s-> in_ch_layout && s->used_ch_count != av_get_channel_layout_nb_channels(s-> in_ch_layout)){ av_log(s, AV_LOG_WARNING, "Input channel layout has a different number of channels than the number of used channels, ignoring layout\n"); s-> in_ch_layout= 0; } if(!s-> in_ch_layout) s-> in_ch_layout= av_get_default_channel_layout(s->used_ch_count); if(!s->out_ch_layout) s->out_ch_layout= av_get_default_channel_layout(s->out.ch_count); s->rematrix= s->out_ch_layout !=s->in_ch_layout || s->rematrix_volume!=1.0 || s->rematrix_custom; #define RSC 1 if(!s-> in.ch_count) s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout); if(!s->used_ch_count) s->used_ch_count= s->in.ch_count; if(!s->out.ch_count) s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout); if(!s-> in.ch_count){ av_assert0(!s->in_ch_layout); av_log(s, AV_LOG_ERROR, "Input channel count and layout are unset\n"); return -1; } if ((!s->out_ch_layout || !s->in_ch_layout) && s->used_ch_count != s->out.ch_count && !s->rematrix_custom) { av_log(s, AV_LOG_ERROR, "Rematrix is needed but there is not enough information to do it\n"); return -1; } av_assert0(s->used_ch_count); av_assert0(s->out.ch_count); s->resample_first= RSC*s->out.ch_count/s->in.ch_count - RSC < s->out_sample_rate/(float)s-> in_sample_rate - 1.0; s->in_buffer= s->in; if(!s->resample && !s->rematrix && !s->channel_map && !s->dither_method){ s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt, s-> in_sample_fmt, s-> in.ch_count, NULL, 0); return 0; } s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt, s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0); s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt, s->int_sample_fmt, s->out.ch_count, NULL, 0); s->postin= s->in; s->preout= s->out; s->midbuf= s->in; if(s->channel_map){ s->postin.ch_count= s->midbuf.ch_count= s->used_ch_count; if(s->resample) s->in_buffer.ch_count= s->used_ch_count; } if(!s->resample_first){ s->midbuf.ch_count= s->out.ch_count; if(s->resample) s->in_buffer.ch_count = s->out.ch_count; } set_audiodata_fmt(&s->postin, s->int_sample_fmt); set_audiodata_fmt(&s->midbuf, s->int_sample_fmt); set_audiodata_fmt(&s->preout, s->int_sample_fmt); if(s->resample){ set_audiodata_fmt(&s->in_buffer, s->int_sample_fmt); } s->dither = s->preout; if(s->rematrix || s->dither_method) return swri_rematrix_init(s); return 0; }

[[[[Adv]]]]: int swr_init(struct SwrContext *s){ s->in_buffer_index= 0; s->in_buffer_count= 0; s->resample_in_constraint= 0; free_temp(&s->postin); free_temp(&s->midbuf); free_temp(&s->preout); free_temp(&s->in_buffer); free_temp(&s->dither); swri_audio_convert_free(&s-> in_convert); swri_audio_convert_free(&s->out_convert); swri_audio_convert_free(&s->full_convert); swri_rematrix_free(s); s->flushed = 0; if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){ av_log(s, AV_LOG_ERROR, "Requested input sample format %d is invalid\n", s->in_sample_fmt); return AVERROR(EINVAL); } if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){ av_log(s, AV_LOG_ERROR, "Requested output sample format %d is invalid\n", s->out_sample_fmt); return AVERROR(EINVAL); } if(av_get_planar_sample_fmt(s->in_sample_fmt) <= AV_SAMPLE_FMT_S16P || s->int_sample_fmt==AV_SAMPLE_FMT_S16P){ s->int_sample_fmt= AV_SAMPLE_FMT_S16P; }else s->int_sample_fmt= AV_SAMPLE_FMT_FLTP; if( s->int_sample_fmt != AV_SAMPLE_FMT_S16P &&s->int_sample_fmt != AV_SAMPLE_FMT_S32P &&s->int_sample_fmt != AV_SAMPLE_FMT_FLTP){ av_log(s, AV_LOG_ERROR, "Requested sample format %s is not supported internally, S16/S32/FLT is supported\n", av_get_sample_fmt_name(s->int_sample_fmt)); return AVERROR(EINVAL); } set_audiodata_fmt(&s-> in, s-> in_sample_fmt); set_audiodata_fmt(&s->out, s->out_sample_fmt); if (s->out_sample_rate!=s->in_sample_rate || (s->flags & SWR_FLAG_RESAMPLE)){ s->resample = swri_resample_init(s->resample, s->out_sample_rate, s->in_sample_rate, s->filter_size, s->phase_shift, s->linear_interp, s->cutoff, s->int_sample_fmt); }else swri_resample_free(&s->resample); if( s->int_sample_fmt != AV_SAMPLE_FMT_S16P && s->int_sample_fmt != AV_SAMPLE_FMT_S32P && s->int_sample_fmt != AV_SAMPLE_FMT_FLTP && s->resample){ av_log(s, AV_LOG_ERROR, "Resampling only supported with internal s16/s32/flt\n"); return -1; } if(!s->used_ch_count) s->used_ch_count= s->in.ch_count; if(s->used_ch_count && s-> in_ch_layout && s->used_ch_count != av_get_channel_layout_nb_channels(s-> in_ch_layout)){ av_log(s, AV_LOG_WARNING, "Input channel layout has a different number of channels than the number of used channels, ignoring layout\n"); s-> in_ch_layout= 0; } if(!s-> in_ch_layout) s-> in_ch_layout= av_get_default_channel_layout(s->used_ch_count); if(!s->out_ch_layout) s->out_ch_layout= av_get_default_channel_layout(s->out.ch_count); s->rematrix= s->out_ch_layout !=s->in_ch_layout || s->rematrix_volume!=1.0 || s->rematrix_custom; #define RSC 1 if(!s-> in.ch_count) s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout); if(!s->used_ch_count) s->used_ch_count= s->in.ch_count; if(!s->out.ch_count) s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout); if(!s-> in.ch_count){ av_assert0(!s->in_ch_layout); av_log(s, AV_LOG_ERROR, "Input channel count and layout are unset\n"); return -1; } if ((!s->out_ch_layout || !s->in_ch_layout) && s->used_ch_count != s->out.ch_count && !s->rematrix_custom) { av_log(s, AV_LOG_ERROR, "Rematrix is needed but there is not enough information to do it\n"); return -1; } av_assert0(s->used_ch_count); av_assert0(s->out.ch_count); s->resample_first= RSC*s->out.ch_count/s->in.ch_count - RSC < s->out_sample_rate/(float)s-> in_sample_rate - 1.0; s->in_buffer= s->in; if(!s->resample && !s->rematrix && !s->channel_map && !s->dither_method){ s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt, s-> in_sample_fmt, s-> in.ch_count, NULL, 0); return 0; } s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt, s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0); s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt, s->int_sample_fmt, s->out.ch_count, NULL, 0); s->postin= s->in; s->preout= s->out; s->midbuf= s->in; if(s->channel_map){ s->postin.ch_count= s->midbuf.ch_count= s->used_ch_count; if(s->resample) s->in_buffer.ch_count= s->used_ch_count; } if(!s->resample_first){ s->midbuf.ch_count= s->out.ch_count; if(s->resample) s->in_buffer.ch_count = s->out.ch_count; } set_audiodata_fmt(&s->postin, s->int_sample_fmt); set_audiodata_fmt(&s->midbuf, s->int_sample_fmt); set_audiodata_fmt(&s->preout, s->int_sample_fmt); if(s->resample){ set_audiodata_fmt(&s->in_buffer, s->int_sample_fmt); } s->dither = s->preout; if(s->rematrix || s->dither_method) return swri_rematrix_init(s); return 0; }[Succeeded / Failed / Skipped / Total] 851 / 79 / 531 / 1461:  54%|    | 1461/2690 [16:16:18<13:41:16, 40.09s/it][Succeeded / Failed / Skipped / Total] 851 / 79 / 531 / 1461:  54%|    | 1462/2690 [16:16:51<13:40:30, 40.09s/it][Succeeded / Failed / Skipped / Total] 851 / 80 / 531 / 1462:  54%|    | 1462/2690 [16:16:51<13:40:30, 40.09s/it][Succeeded / Failed / Skipped / Total] 851 / 80 / 531 / 1462:  54%|    | 1463/2690 [16:16:51<13:39:17, 40.06s/it][Succeeded / Failed / Skipped / Total] 851 / 80 / 532 / 1463:  54%|    | 1463/2690 [16:16:51<13:39:17, 40.06s/it][Succeeded / Failed / Skipped / Total] 851 / 80 / 532 / 1463:  54%|    | 1464/2690 [16:16:52<13:38:03, 40.04s/it][Succeeded / Failed / Skipped / Total] 851 / 80 / 533 / 1464:  54%|    | 1464/2690 [16:16:52<13:38:03, 40.04s/it][Succeeded / Failed / Skipped / Total] 851 / 80 / 533 / 1464:  54%|    | 1465/2690 [16:18:46<13:38:25, 40.09s/it][Succeeded / Failed / Skipped / Total] 851 / 81 / 533 / 1465:  54%|    | 1465/2690 [16:18:46<13:38:25, 40.09s/it][Succeeded / Failed / Skipped / Total] 851 / 81 / 533 / 1465:  54%|    | 1466/2690 [16:21:23<13:39:23, 40.17s/it][Succeeded / Failed / Skipped / Total] 852 / 81 / 533 / 1466:  54%|    | 1466/2690 [16:21:23<13:39:23, 40.17s/it][Succeeded / Failed / Skipped / Total] 852 / 81 / 533 / 1466:  55%|    | 1467/2690 [16:21:30<13:38:15, 40.14s/it][Succeeded / Failed / Skipped / Total] 853 / 81 / 533 / 1467:  55%|    | 1467/2690 [16:21:30<13:38:15, 40.14s/it][Succeeded / Failed / Skipped / Total] 853 / 81 / 533 / 1467:  55%|    | 1468/2690 [16:21:31<13:37:02, 40.12s/it][Succeeded / Failed / Skipped / Total] 853 / 81 / 534 / 1468:  55%|    | 1468/2690 [16:21:31<13:37:02, 40.12s/it][Succeeded / Failed / Skipped / Total] 853 / 81 / 534 / 1468:  55%|    | 1469/2690 [16:21:31<13:35:49, 40.09s/it][Succeeded / Failed / Skipped / Total] 853 / 81 / 535 / 1469:  55%|    | 1469/2690 [16:21:31<13:35:49, 40.09s/it][Succeeded / Failed / Skipped / Total] 853 / 81 / 535 / 1469:  55%|    | 1470/2690 [16:21:32<13:34:36, 40.06s/it]
--------------------------------------------- Result 1462 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void rndis_clear_responsequeue(USBNetState *s) { struct rndis_response *r; while ((r = s->rndis_resp.tqh_first)) { TAILQ_REMOVE(&s->rndis_resp, r, entries); qemu_free(r); } }

[[[[Adv]]]]: static void rndis_clear_responsequeue(USBNetState *s) { struct rndis_response *r; while ((r = s->rndis_resp.tqh_first)) { TAILQ_REMOVE(&s->rndis_resp, r, entries); qemu_free(r); } }
--------------------------------------------- Result 1463 ---------------------------------------------
[[0 (25%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void xlnx_ep108_init(MachineState *machine) { XlnxEP108 *s = g_new0(XlnxEP108, 1); Error *err = NULL; object_initialize(&s->soc, sizeof(s->soc), TYPE_XLNX_ZYNQMP); object_property_add_child(OBJECT(machine), "soc", OBJECT(&s->soc), &error_abort); object_property_set_bool(OBJECT(&s->soc), "True" == "True", "realized", &err); if (err) { error_report("%s", error_get_pretty(err)); exit(1); } if (machine->ram_size > EP108_MAX_RAM_SIZE) { error_report("WARNING: RAM size " RAM_ADDR_FMT " above max supported, " "reduced to %llx", machine->ram_size, EP108_MAX_RAM_SIZE); machine->ram_size = EP108_MAX_RAM_SIZE; } if (machine->ram_size <= 0x08000000) { qemu_log("WARNING: RAM size " RAM_ADDR_FMT " is small for EP108", machine->ram_size); } memory_region_allocate_system_memory(&s->ddr_ram, NULL, "ddr-ram", machine->ram_size); memory_region_add_subregion(get_system_memory(), 0, &s->ddr_ram); xlnx_ep108_binfo.ram_size = machine->ram_size; xlnx_ep108_binfo.kernel_filename = machine->kernel_filename; xlnx_ep108_binfo.kernel_cmdline = machine->kernel_cmdline; xlnx_ep108_binfo.initrd_filename = machine->initrd_filename; xlnx_ep108_binfo.loader_start = 0; arm_load_kernel(s->soc.boot_cpu_ptr, &xlnx_ep108_binfo); }
--------------------------------------------- Result 1464 ---------------------------------------------
[[0 (28%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs, AVFilterInOut **open_outputs, AVClass *log_ctx) { int pad = 0; while (**buf == '[') { char *name = parse_link_name(buf, log_ctx); AVFilterInOut *match; if (!name) return AVERROR(EINVAL); match = extract_inout(name, open_outputs); if (match) { av_free(name); } else { match = av_mallocz(sizeof(AVFilterInOut)); match->name = name; match->pad_idx = pad; } insert_inout(curr_inputs, match); *buf += strspn(*buf, WHITESPACES); pad++; } return pad; }
--------------------------------------------- Result 1465 ---------------------------------------------
[[0 (100%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size, size_t *count) { GIOStatus status; OVERLAPPED ov = {0}; BOOL ret; DWORD written; ov.hEvent = CreateEvent(NULL, "False" != "False", "False" != "False", NULL); ret = WriteFile(c->handle, buf, size, &written, &ov); if (!ret) { if (GetLastError() == ERROR_IO_PENDING) { ret = GetOverlappedResult(c->handle, &ov, &written, "True" == "True"); if (!ret) { if (!GetLastError()) { status = G_IO_STATUS_AGAIN; } else { status = G_IO_STATUS_ERROR; } else { status = G_IO_STATUS_NORMAL; *count = written; } else { status = G_IO_STATUS_ERROR; } else { status = G_IO_STATUS_NORMAL; *count = written; return status;

[[[[Adv]]]]: static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size, size_t *count) { GIOStatus status; OVERLAPPED ov = {0}; BOOL ret; DWORD written; ov.hEvent = CreateEvent(NULL, "False" != "False", "False" != "False", NULL); ret = WriteFile(c->handle, buf, size, &written, &ov); if (!ret) { if (GetLastError() == ERROR_IO_PENDING) { ret = GetOverlappedResult(c->handle, &ov, &written, "True" == "True"); if (!ret) { if (!GetLastError()) { status = G_IO_STATUS_AGAIN; } else { status = G_IO_STATUS_ERROR; } else { status = G_IO_STATUS_NORMAL; *count = written; } else { status = G_IO_STATUS_ERROR; } else { status = G_IO_STATUS_NORMAL; *count = written; return status;
--------------------------------------------- Result 1466 ---------------------------------------------
[[0 (3%)]] --> [[0 (50%)]] --> Socre: 0.5013967752456665

[[[[Adv]]]]: static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *[[src]], int width, int height) { int [[src_wrap]], x, y; int r, g, b; uint8_t *lum, *cb, *cr; const uint8_t *p; lum = dst->data[0]; cb = dst->data[1]; cr = dst->data[2]; [[src_wrap]] = [[src]]->linesize[0] - width * BPP; p = [[src]]->data[0]; for(y=0;y<height;y++) { for(x=0;x<width;x++) { RGB_IN(r, g, b, p); lum[0] = RGB_TO_Y_CCIR(r, g, b); cb[0] = RGB_TO_U_CCIR(r, g, b, 0); cr[0] = RGB_TO_V_CCIR(r, g, b, 0); cb++; cr++; lum++; } p += [[src_wrap]]; lum += dst->linesize[0] - width; cb += dst->linesize[1] - width; cr += dst->linesize[2] - width; } }

[[[[Adv]]]]: static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *[[tambin]], int width, int height) { int [[indiscriminate]], x, y; int r, g, b; uint8_t *lum, *cb, *cr; const uint8_t *p; lum = dst->data[0]; cb = dst->data[1]; cr = dst->data[2]; [[indiscriminate]] = [[tambin]]->linesize[0] - width * BPP; p = [[tambin]]->data[0]; for(y=0;y<height;y++) { for(x=0;x<width;x++) { RGB_IN(r, g, b, p); lum[0] = RGB_TO_Y_CCIR(r, g, b); cb[0] = RGB_TO_U_CCIR(r, g, b, 0); cr[0] = RGB_TO_V_CCIR(r, g, b, 0); cb++; cr++; lum++; } p += [[indiscriminate]]; lum += dst->linesize[0] - width; cb += dst->linesize[1] - width; cr += dst->linesize[2] - width; } }
--------------------------------------------- Result 1467 ---------------------------------------------
[[0 (15%)]] --> [[0 (53%)]] --> Socre: 0.5258244872093201

[[[[Adv]]]]: static char *pcibus_get_fw_dev_path(DeviceState *dev) { PCIDevice *d = (PCIDevice *)dev; char [[path]][50], name[33]; int [[off]]; [[off]] = snprintf([[path]], sizeof([[path]]), "%s@%x", pci_dev_fw_name(dev, name, sizeof name), PCI_SLOT(d->devfn)); if (PCI_FUNC(d->devfn)) snprintf([[path]] + [[off]], sizeof([[path]]) + [[off]], ",%x", PCI_FUNC(d->devfn)); return strdup([[path]]); }

[[[[Adv]]]]: static char *pcibus_get_fw_dev_path(DeviceState *dev) { PCIDevice *d = (PCIDevice *)dev; char [[rails]][50], name[33]; int [[cutoff]]; [[cutoff]] = snprintf([[rails]], sizeof([[rails]]), "%s@%x", pci_dev_fw_name(dev, name, sizeof name), PCI_SLOT(d->devfn)); if (PCI_FUNC(d->devfn)) snprintf([[rails]] + [[cutoff]], sizeof([[rails]]) + [[cutoff]], ",%x", PCI_FUNC(d->devfn)); return strdup([[rails]]); }
--------------------------------------------- Result 1468 ---------------------------------------------
[[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qio_channel_websock_handshake_send_response(QIOChannelWebsock *ioc, const char *key, Error **errp) { char combined_key[QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + QIO_CHANNEL_WEBSOCK_GUID_LEN + 1]; char *accept = NULL, *response = NULL; size_t responselen; g_strlcpy(combined_key, key, QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + 1); g_strlcat(combined_key, QIO_CHANNEL_WEBSOCK_GUID, QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + QIO_CHANNEL_WEBSOCK_GUID_LEN + 1); if (qcrypto_hash_base64(QCRYPTO_HASH_ALG_SHA1, combined_key, QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + QIO_CHANNEL_WEBSOCK_GUID_LEN, &accept, errp) < 0) { return -1; } response = g_strdup_printf(QIO_CHANNEL_WEBSOCK_HANDSHAKE_RESPONSE, accept); responselen = strlen(response); buffer_reserve(&ioc->encoutput, responselen); buffer_append(&ioc->encoutput, response, responselen); g_free(accept); g_free(response); return 0; }
--------------------------------------------- Result 1469 ---------------------------------------------
[[0 (28%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void dpy_gfx_copy(QemuConsole *con, int src_x, int src_y, int dst_x, int dst_y, int w, int h) { DisplayState *s = con->ds; DisplayChangeListener *dcl; if (!qemu_console_is_visible(con)) { return; } QLIST_FOREACH(dcl, &s->listeners, next) { if (con != (dcl->con ? dcl->con : active_console)) { continue; } if (dcl->ops->dpy_gfx_copy) { dcl->ops->dpy_gfx_copy(dcl, src_x, src_y, dst_x, dst_y, w, h); } else { dcl->ops->dpy_gfx_update(dcl, dst_x, dst_y, w, h); } } }
[Succeeded / Failed / Skipped / Total] 853 / 81 / 536 / 1470:  55%|    | 1470/2690 [16:21:32<13:34:36, 40.06s/it][Succeeded / Failed / Skipped / Total] 853 / 81 / 536 / 1470:  55%|    | 1471/2690 [16:21:58<13:33:45, 40.05s/it]--------------------------------------------- Result 1470 ---------------------------------------------
[[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static TCGArg *tcg_constant_folding(TCGContext *s, uint16_t *tcg_opc_ptr, TCGArg *args, TCGOpDef *tcg_op_defs) { int i, nb_ops, op_index, nb_temps, nb_globals, nb_call_args; TCGOpcode op; const TCGOpDef *def; TCGArg *gen_args; TCGArg tmp; TCGCond cond; nb_temps = s->nb_temps; nb_globals = s->nb_globals; memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info)); nb_ops = tcg_opc_ptr - gen_opc_buf; gen_args = args; for (op_index = 0; op_index < nb_ops; op_index++) { op = gen_opc_buf[op_index]; def = &tcg_op_defs[op]; if (op == INDEX_op_call) { int nb_oargs = args[0] >> 16; int nb_iargs = args[0] & 0xffff; for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) { if (temps[args[i]].state == TCG_TEMP_COPY) { args[i] = find_better_copy(s, args[i]); } else { for (i = def->nb_oargs; i < def->nb_oargs + def->nb_iargs; i++) { if (temps[args[i]].state == TCG_TEMP_COPY) { args[i] = find_better_copy(s, args[i]); CASE_OP_32_64(add): CASE_OP_32_64(mul): CASE_OP_32_64(and): CASE_OP_32_64(or): CASE_OP_32_64(eqv): CASE_OP_32_64(nand): CASE_OP_32_64(nor): if (temps[args[1]].state == TCG_TEMP_CONST) { tmp = args[1]; args[1] = args[2]; args[2] = tmp; CASE_OP_32_64(brcond): if (temps[args[0]].state == TCG_TEMP_CONST && temps[args[1]].state != TCG_TEMP_CONST) { tmp = args[0]; args[0] = args[1]; args[1] = tmp; args[2] = tcg_swap_cond(args[2]); CASE_OP_32_64(setcond): if (temps[args[1]].state == TCG_TEMP_CONST && temps[args[2]].state != TCG_TEMP_CONST) { tmp = args[1]; args[1] = args[2]; args[2] = tmp; args[3] = tcg_swap_cond(args[3]); CASE_OP_32_64(movcond): cond = args[5]; if (temps[args[1]].state == TCG_TEMP_CONST && temps[args[2]].state != TCG_TEMP_CONST) { tmp = args[1]; args[1] = args[2]; args[2] = tmp; cond = tcg_swap_cond(cond); if (args[0] == args[3]) { tmp = args[3]; args[3] = args[4]; args[4] = tmp; cond = tcg_invert_cond(cond); args[5] = cond; CASE_OP_32_64(shl): CASE_OP_32_64(shr): CASE_OP_32_64(sar): CASE_OP_32_64(rotl): CASE_OP_32_64(rotr): if (temps[args[1]].state == TCG_TEMP_CONST && temps[args[1]].val == 0) { CASE_OP_32_64(add): CASE_OP_32_64(shl): CASE_OP_32_64(shr): CASE_OP_32_64(sar): CASE_OP_32_64(rotl): CASE_OP_32_64(rotr): CASE_OP_32_64(or): if (temps[args[1]].state == TCG_TEMP_CONST) { if (temps[args[2]].state == TCG_TEMP_CONST && temps[args[2]].val == 0) { if (temps_are_copies(args[0], args[1])) { gen_opc_buf[op_index] = INDEX_op_nop; } else { gen_opc_buf[op_index] = op_to_mov(op); tcg_opt_gen_mov(s, gen_args, args[0], args[1]); CASE_OP_32_64(and): CASE_OP_32_64(mul): if ((temps[args[2]].state == TCG_TEMP_CONST && temps[args[2]].val == 0)) { CASE_OP_32_64(or): CASE_OP_32_64(and): if (temps_are_copies(args[0], args[1])) { gen_opc_buf[op_index] = INDEX_op_nop; } else { gen_opc_buf[op_index] = op_to_mov(op); tcg_opt_gen_mov(s, gen_args, args[0], args[1]); CASE_OP_32_64(mov): if (temps_are_copies(args[0], args[1])) { args += 2; gen_opc_buf[op_index] = INDEX_op_nop; if (temps[args[1]].state != TCG_TEMP_CONST) { tcg_opt_gen_mov(s, gen_args, args[0], args[1]); args += 2; op = op_to_movi(op); gen_opc_buf[op_index] = op; args[1] = temps[args[1]].val; CASE_OP_32_64(movi): tcg_opt_gen_movi(gen_args, args[0], args[1]); args += 2; CASE_OP_32_64(not): CASE_OP_32_64(neg): CASE_OP_32_64(ext8s): CASE_OP_32_64(ext8u): CASE_OP_32_64(ext16s): CASE_OP_32_64(ext16u): case INDEX_op_ext32s_i64: case INDEX_op_ext32u_i64: if (temps[args[1]].state == TCG_TEMP_CONST) { tmp = do_constant_folding(op, temps[args[1]].val, 0); tcg_opt_gen_movi(gen_args, args[0], tmp); } else { reset_temp(args[0]); gen_args[0] = args[0]; gen_args[1] = args[1]; args += 2; CASE_OP_32_64(add): CASE_OP_32_64(mul): CASE_OP_32_64(or): CASE_OP_32_64(and): CASE_OP_32_64(shl): CASE_OP_32_64(shr): CASE_OP_32_64(sar): CASE_OP_32_64(rotl): CASE_OP_32_64(rotr): CASE_OP_32_64(andc): CASE_OP_32_64(orc): CASE_OP_32_64(eqv): CASE_OP_32_64(nand): CASE_OP_32_64(nor): if (temps[args[1]].state == TCG_TEMP_CONST && temps[args[2]].state == TCG_TEMP_CONST) { tmp = do_constant_folding(op, temps[args[1]].val, temps[args[2]].val); tcg_opt_gen_movi(gen_args, args[0], tmp); } else { reset_temp(args[0]); gen_args[0] = args[0]; gen_args[1] = args[1]; gen_args[2] = args[2]; gen_args += 3; CASE_OP_32_64(setcond): if (temps[args[1]].state == TCG_TEMP_CONST && temps[args[2]].state == TCG_TEMP_CONST) { tmp = do_constant_folding_cond(op, temps[args[1]].val, temps[args[2]].val, args[3]); tcg_opt_gen_movi(gen_args, args[0], tmp); } else { reset_temp(args[0]); gen_args[0] = args[0]; gen_args[1] = args[1]; gen_args[2] = args[2]; gen_args[3] = args[3]; gen_args += 4; args += 4; CASE_OP_32_64(brcond): if (temps[args[0]].state == TCG_TEMP_CONST && temps[args[1]].state == TCG_TEMP_CONST) { if (do_constant_folding_cond(op, temps[args[0]].val, temps[args[1]].val, args[2])) { memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info)); gen_opc_buf[op_index] = INDEX_op_br; gen_args[0] = args[3]; gen_args += 1; } else { gen_opc_buf[op_index] = INDEX_op_nop; } else { memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info)); reset_temp(args[0]); gen_args[0] = args[0]; gen_args[1] = args[1]; gen_args[2] = args[2]; gen_args[3] = args[3]; gen_args += 4; args += 4; CASE_OP_32_64(movcond): if (temps[args[1]].state == TCG_TEMP_CONST && temps[args[2]].state == TCG_TEMP_CONST) { tmp = do_constant_folding_cond(op, temps[args[1]].val, temps[args[2]].val, args[5]); if (temps_are_copies(args[0], args[4-tmp])) { gen_opc_buf[op_index] = INDEX_op_nop; } else if (temps[args[4-tmp]].state == TCG_TEMP_CONST) { tcg_opt_gen_movi(gen_args, args[0], temps[args[4-tmp]].val); } else { gen_opc_buf[op_index] = op_to_mov(op); tcg_opt_gen_mov(s, gen_args, args[0], args[4-tmp]); } else { reset_temp(args[0]); gen_args[0] = args[0]; gen_args[1] = args[1]; gen_args[2] = args[2]; gen_args[3] = args[3]; gen_args[4] = args[4]; gen_args[5] = args[5]; gen_args += 6; args += 6; case INDEX_op_call: nb_call_args = (args[0] >> 16) + (args[0] & 0xffff); if (!(args[nb_call_args + 1] & (TCG_CALL_CONST | TCG_CALL_PURE))) { for (i = 0; i < nb_globals; i++) { reset_temp(i); for (i = 0; i < (args[0] >> 16); i++) { reset_temp(args[i + 1]); i = nb_call_args + 3; while (i) { *gen_args = *args; args++; gen_args++; i--; if (def->flags & TCG_OPF_BB_END) { memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info)); } else { for (i = 0; i < def->nb_oargs; i++) { reset_temp(args[i]); for (i = 0; i < def->nb_args; i++) { gen_args[i] = args[i]; args += def->nb_args; gen_args += def->nb_args; return gen_args;
--------------------------------------------- Result 1471 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 854 / 81 / 536 / 1471:  55%|    | 1471/2690 [16:21:58<13:33:45, 40.05s/it][Succeeded / Failed / Skipped / Total] 854 / 81 / 536 / 1471:  55%|    | 1472/2690 [16:22:29<13:32:57, 40.05s/it][Succeeded / Failed / Skipped / Total] 855 / 81 / 536 / 1472:  55%|    | 1472/2690 [16:22:29<13:32:57, 40.05s/it][Succeeded / Failed / Skipped / Total] 855 / 81 / 536 / 1472:  55%|    | 1473/2690 [16:25:14<13:34:00, 40.13s/it][Succeeded / Failed / Skipped / Total] 856 / 81 / 536 / 1473:  55%|    | 1473/2690 [16:25:14<13:34:00, 40.13s/it][Succeeded / Failed / Skipped / Total] 856 / 81 / 536 / 1473:  55%|    | 1474/2690 [16:25:15<13:32:48, 40.11s/it][[0 (97%)]] --> [[0 (44%)]] --> Socre: 0.5563739836215973

[[[[Adv]]]]: static void vnc_connect(VncDisplay *vd, int csock, bool [[skipauth]], bool [[websocket]]) { VncState *vs = g_malloc0(sizeof(VncState)); int i; vs->csock = csock; vs->vd = vd; if ([[skipauth]]) { vs->auth = VNC_AUTH_NONE; vs->subauth = VNC_AUTH_INVALID; } else { if ([[websocket]]) { vs->auth = vd->ws_auth; vs->subauth = VNC_AUTH_INVALID; } else { vs->auth = vd->auth; vs->subauth = vd->subauth; } } VNC_DEBUG("Client sock=%d ws=%d auth=%d subauth=%d\n", csock, [[websocket]], vs->auth, vs->subauth); vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect)); for (i = 0; i < VNC_STAT_ROWS; ++i) { vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t)); } VNC_DEBUG("New client on socket %d\n", csock); update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE); qemu_set_nonblock(vs->csock); if ([[websocket]]) { vs->websocket = 1; if (vd->ws_tls) { qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io, NULL, vs); } else { qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs); } } else { qemu_set_fd_handler(vs->csock, vnc_client_read, NULL, vs); } vnc_client_cache_addr(vs); vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED); vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING); if (!vs->websocket) { vnc_init_state(vs); } if (vd->num_connecting > vd->connections_limit) { QTAILQ_FOREACH(vs, &vd->clients, next) { if (vs->share_mode == VNC_SHARE_MODE_CONNECTING) { vnc_disconnect_start(vs); return; } } } }

[[[[Adv]]]]: static void vnc_connect(VncDisplay *vd, int csock, bool [[imitation]], bool [[migrant]]) { VncState *vs = g_malloc0(sizeof(VncState)); int i; vs->csock = csock; vs->vd = vd; if ([[imitation]]) { vs->auth = VNC_AUTH_NONE; vs->subauth = VNC_AUTH_INVALID; } else { if ([[migrant]]) { vs->auth = vd->ws_auth; vs->subauth = VNC_AUTH_INVALID; } else { vs->auth = vd->auth; vs->subauth = vd->subauth; } } VNC_DEBUG("Client sock=%d ws=%d auth=%d subauth=%d\n", csock, [[migrant]], vs->auth, vs->subauth); vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect)); for (i = 0; i < VNC_STAT_ROWS; ++i) { vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t)); } VNC_DEBUG("New client on socket %d\n", csock); update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE); qemu_set_nonblock(vs->csock); if ([[migrant]]) { vs->websocket = 1; if (vd->ws_tls) { qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io, NULL, vs); } else { qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs); } } else { qemu_set_fd_handler(vs->csock, vnc_client_read, NULL, vs); } vnc_client_cache_addr(vs); vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED); vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING); if (!vs->websocket) { vnc_init_state(vs); } if (vd->num_connecting > vd->connections_limit) { QTAILQ_FOREACH(vs, &vd->clients, next) { if (vs->share_mode == VNC_SHARE_MODE_CONNECTING) { vnc_disconnect_start(vs); return; } } } }
--------------------------------------------- Result 1472 ---------------------------------------------
[[0 (38%)]] --> [[0 (71%)]] --> Socre: 0.70778489112854

[[[[Adv]]]]: static int ftp_current_dir(FTPContext *s) { char *res = NULL, *start = NULL, *end = NULL; int i; const char *[[command]] = "PWD\r\n"; const int pwd_codes[] = {257, 0}; if (!ftp_send_command(s, [[command]], pwd_codes, &res)) goto fail; for (i = 0; res[i]; ++i) { if (res[i] == '"') { if (!start) { start = res + i + 1; continue; } end = res + i; break; } } if (!end) goto fail; if (end > res && end[-1] == '/') { end[-1] = '\0'; } else *end = '\0'; av_strlcpy(s->path, start, sizeof(s->path)); av_free(res); return 0; fail: av_free(res); return AVERROR(EIO); }

[[[[Adv]]]]: static int ftp_current_dir(FTPContext *s) { char *res = NULL, *start = NULL, *end = NULL; int i; const char *[[brigadier]] = "PWD\r\n"; const int pwd_codes[] = {257, 0}; if (!ftp_send_command(s, [[brigadier]], pwd_codes, &res)) goto fail; for (i = 0; res[i]; ++i) { if (res[i] == '"') { if (!start) { start = res + i + 1; continue; } end = res + i; break; } } if (!end) goto fail; if (end > res && end[-1] == '/') { end[-1] = '\0'; } else *end = '\0'; av_strlcpy(s->path, start, sizeof(s->path)); av_free(res); return 0; fail: av_free(res); return AVERROR(EIO); }
--------------------------------------------- Result 1473 ---------------------------------------------
[[0 (2%)]] --> [[0 (99%)]] --> Socre: 0.9906989932060242

[[[[Adv]]]]: int qemu_opts_print(QemuOpts *[[opts]], void *dummy) { QemuOpt *opt; fprintf(stderr, "%s: %s:", [[opts]]->list->name, [[opts]]->id ? [[opts]]->id : "<noid>"); TAILQ_FOREACH(opt, &[[opts]]->head, next) { fprintf(stderr, " %s=\"%s\"", opt->name, opt->str); } fprintf(stderr, "\n"); return 0; }

[[[[Adv]]]]: int qemu_opts_print(QemuOpts *[[entres]], void *dummy) { QemuOpt *opt; fprintf(stderr, "%s: %s:", [[entres]]->list->name, [[entres]]->id ? [[entres]]->id : "<noid>"); TAILQ_FOREACH(opt, &[[entres]]->head, next) { fprintf(stderr, " %s=\"%s\"", opt->name, opt->str); } fprintf(stderr, "\n"); return 0; }
--------------------------------------------- Result 1474 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 856 / 81 / 537 / 1474:  55%|    | 1474/2690 [16:25:15<13:32:48, 40.11s/it][Succeeded / Failed / Skipped / Total] 856 / 81 / 537 / 1474:  55%|    | 1475/2690 [16:25:15<13:31:35, 40.08s/it][Succeeded / Failed / Skipped / Total] 856 / 81 / 538 / 1475:  55%|    | 1475/2690 [16:25:15<13:31:35, 40.08s/it][Succeeded / Failed / Skipped / Total] 856 / 81 / 538 / 1475:  55%|    | 1476/2690 [16:26:31<13:31:24, 40.10s/it][[0 (79%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, AVFrame *picture) { int compno, reslevelno, bandno; int x, y; uint8_t *line; Jpeg2000T1Context t1; for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000Component *comp = tile->comp + compno; Jpeg2000CodingStyle *codsty = tile->codsty + compno; for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) { Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno; for (bandno = 0; bandno < rlevel->nbands; bandno++) { int nb_precincts, precno; Jpeg2000Band *band = rlevel->band + bandno; int cblkno = 0, bandpos; bandpos = bandno + (reslevelno > 0); if (band->coord[0][0] == band->coord[0][1] || band->coord[1][0] == band->coord[1][1]) continue; nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y; for (precno = 0; precno < nb_precincts; precno++) { Jpeg2000Prec *prec = band->prec + precno; for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) { int x, y; Jpeg2000Cblk *cblk = prec->cblk + cblkno; decode_cblk(s, codsty, &t1, cblk, cblk->coord[0][1] - cblk->coord[0][0], cblk->coord[1][1] - cblk->coord[1][0], bandpos); x = cblk->coord[0][0]; y = cblk->coord[1][0]; if (codsty->transform == FF_DWT97) dequantization_float(x, y, cblk, comp, &t1, band); else dequantization_int(x, y, cblk, comp, &t1, band); } } } } ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data); } if (tile->codsty[0].mct) mct_decode(s, tile); if (s->cdef[0] < 0) { for (x = 0; x < s->ncomponents; x++) s->cdef[x] = x + 1; if ((s->ncomponents & 1) == 0) s->cdef[s->ncomponents-1] = 0; } if (s->precision <= 8) { for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000Component *comp = tile->comp + compno; Jpeg2000CodingStyle *codsty = tile->codsty + compno; float *datap = comp->f_data; int32_t *i_datap = comp->i_data; int cbps = s->cbps[compno]; int w = tile->comp[compno].coord[0][1] - s->image_offset_x; int planar = !!picture->data[2]; int pixelsize = planar ? 1 : s->ncomponents; int plane = 0; if (planar) plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1); y = tile->comp[compno].coord[1][0] - s->image_offset_y; line = picture->data[plane] + y * picture->linesize[plane]; for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) { uint8_t *dst; x = tile->comp[compno].coord[0][0] - s->image_offset_x; dst = line + x * pixelsize + compno*!planar; if (codsty->transform == FF_DWT97) { for (; x < w; x += s->cdx[compno]) { int val = lrintf(*datap) + (1 << (cbps - 1)); val = av_clip(val, 0, (1 << cbps) - 1); *dst = val << (8 - cbps); datap++; dst += pixelsize; } } else { for (; x < w; x += s->cdx[compno]) { int val = *i_datap + (1 << (cbps - 1)); val = av_clip(val, 0, (1 << cbps) - 1); *dst = val << (8 - cbps); i_datap++; dst += pixelsize; } } line += picture->linesize[plane]; } } } else { for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000Component *comp = tile->comp + compno; Jpeg2000CodingStyle *codsty = tile->codsty + compno; float *datap = comp->f_data; int32_t *i_datap = comp->i_data; uint16_t *linel; int cbps = s->cbps[compno]; int w = tile->comp[compno].coord[0][1] - s->image_offset_x; int planar = !!picture->data[2]; int pixelsize = planar ? 1 : s->ncomponents; int plane = 0; if (planar) plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1); y = tile->comp[compno].coord[1][0] - s->image_offset_y; linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1); for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) { uint16_t *dst; x = tile->comp[compno].coord[0][0] - s->image_offset_x; dst = linel + (x * pixelsize + compno*!planar); if (codsty->transform == FF_DWT97) { for (; x < w; x += s-> cdx[compno]) { int val = lrintf(*datap) + (1 << (cbps - 1)); val = av_clip(val, 0, (1 << cbps) - 1); *dst = val << (16 - cbps); datap++; dst += pixelsize; } } else { for (; x < w; x += s-> cdx[compno]) { int val = *i_datap + (1 << (cbps - 1)); val = av_clip(val, 0, (1 << cbps) - 1); *dst = val << (16 - cbps); i_datap++; dst += pixelsize; } } linel += picture->linesize[plane] >> 1; } } } return 0; }
--------------------------------------------- Result 1475 ---------------------------------------------
[[0 (96%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static struct XenDevice *xen_be_get_xendev(const char *type, int dom, int dev, struct XenDevOps *ops) { struct XenDevice *xendev; xendev = xen_be_find_xendev(type, dom, dev); if (xendev) { return xendev; } xendev = g_malloc0(ops->size); xendev->type = type; xendev->dom = dom; xendev->dev = dev; xendev->ops = ops; snprintf(xendev->be, sizeof(xendev->be), "backend/%s/%d/%d", xendev->type, xendev->dom, xendev->dev); snprintf(xendev->name, sizeof(xendev->name), "%s-%d", xendev->type, xendev->dev); xendev->debug = debug; xendev->local_port = -1; xendev->evtchndev = xen_xc_evtchn_open(NULL, 0); if (xendev->evtchndev == XC_HANDLER_INITIAL_VALUE) { xen_be_printf(NULL, 0, "can't open evtchn device\n"); g_free(xendev); return NULL; } fcntl(xc_evtchn_fd(xendev->evtchndev), F_SETFD, FD_CLOEXEC); if (ops->flags & DEVOPS_FLAG_NEED_GNTDEV) { xendev->gnttabdev = xen_xc_gnttab_open(NULL, 0); if (xendev->gnttabdev == XC_HANDLER_INITIAL_VALUE) { xen_be_printf(NULL, 0, "can't open gnttab device\n"); xc_evtchn_close(xendev->evtchndev); g_free(xendev); return NULL; } } else { xendev->gnttabdev = XC_HANDLER_INITIAL_VALUE; } QTAILQ_INSERT_TAIL(&xendevs, xendev, next); if (xendev->ops->alloc) { xendev->ops->alloc(xendev); } return xendev; }
--------------------------------------------- Result 1476 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 857 / 81 / 538 / 1476:  55%|    | 1476/2690 [16:26:31<13:31:24, 40.10s/it][Succeeded / Failed / Skipped / Total] 857 / 81 / 538 / 1476:  55%|    | 1477/2690 [16:26:31<13:30:11, 40.08s/it][Succeeded / Failed / Skipped / Total] 857 / 81 / 539 / 1477:  55%|    | 1477/2690 [16:26:31<13:30:11, 40.08s/it][Succeeded / Failed / Skipped / Total] 857 / 81 / 539 / 1477:  55%|    | 1478/2690 [16:27:54<13:30:06, 40.10s/it][Succeeded / Failed / Skipped / Total] 858 / 81 / 539 / 1478:  55%|    | 1478/2690 [16:27:54<13:30:06, 40.10s/it][Succeeded / Failed / Skipped / Total] 858 / 81 / 539 / 1478:  55%|    | 1479/2690 [16:28:03<13:29:00, 40.08s/it][[0 (23%)]] --> [[0 (90%)]] --> Socre: 0.8992847204208374

[[[[Adv]]]]: static void json_message_process_token(JSONLexer *lexer, QString *token, JSONTokenType type, int x, int y) { JSONMessageParser *[[parser]] = container_of(lexer, JSONMessageParser, lexer); QDict *dict; if (type == JSON_OPERATOR) { switch (qstring_get_str(token)[0]) { case '{': [[parser]]->brace_count++; break; case '}': [[parser]]->brace_count--; break; case '[': [[parser]]->bracket_count++; break; case ']': [[parser]]->bracket_count--; break; default: break; } } dict = qdict_new(); qdict_put(dict, "type", qint_from_int(type)); QINCREF(token); qdict_put(dict, "token", token); qdict_put(dict, "x", qint_from_int(x)); qdict_put(dict, "y", qint_from_int(y)); [[parser]]->token_size += token->length; qlist_append([[parser]]->tokens, dict); if (type == JSON_ERROR) { goto out_emit_bad; } else if ([[parser]]->brace_count < 0 || [[parser]]->bracket_count < 0 || ([[parser]]->brace_count == 0 && [[parser]]->bracket_count == 0)) { goto out_emit; } else if ([[parser]]->token_size > MAX_TOKEN_SIZE || [[parser]]->bracket_count + [[parser]]->brace_count > MAX_NESTING) { goto out_emit_bad; } return; out_emit_bad: QDECREF([[parser]]->tokens); [[parser]]->tokens = NULL; out_emit: [[parser]]->brace_count = 0; [[parser]]->bracket_count = 0; [[parser]]->emit([[parser]], [[parser]]->tokens); if ([[parser]]->tokens) { QDECREF([[parser]]->tokens); } [[parser]]->tokens = qlist_new(); [[parser]]->token_size = 0; }

[[[[Adv]]]]: static void json_message_process_token(JSONLexer *lexer, QString *token, JSONTokenType type, int x, int y) { JSONMessageParser *[[croatians]] = container_of(lexer, JSONMessageParser, lexer); QDict *dict; if (type == JSON_OPERATOR) { switch (qstring_get_str(token)[0]) { case '{': [[croatians]]->brace_count++; break; case '}': [[croatians]]->brace_count--; break; case '[': [[croatians]]->bracket_count++; break; case ']': [[croatians]]->bracket_count--; break; default: break; } } dict = qdict_new(); qdict_put(dict, "type", qint_from_int(type)); QINCREF(token); qdict_put(dict, "token", token); qdict_put(dict, "x", qint_from_int(x)); qdict_put(dict, "y", qint_from_int(y)); [[croatians]]->token_size += token->length; qlist_append([[croatians]]->tokens, dict); if (type == JSON_ERROR) { goto out_emit_bad; } else if ([[croatians]]->brace_count < 0 || [[croatians]]->bracket_count < 0 || ([[croatians]]->brace_count == 0 && [[croatians]]->bracket_count == 0)) { goto out_emit; } else if ([[croatians]]->token_size > MAX_TOKEN_SIZE || [[croatians]]->bracket_count + [[croatians]]->brace_count > MAX_NESTING) { goto out_emit_bad; } return; out_emit_bad: QDECREF([[croatians]]->tokens); [[croatians]]->tokens = NULL; out_emit: [[croatians]]->brace_count = 0; [[croatians]]->bracket_count = 0; [[croatians]]->emit([[croatians]], [[croatians]]->tokens); if ([[croatians]]->tokens) { QDECREF([[croatians]]->tokens); } [[croatians]]->tokens = qlist_new(); [[croatians]]->token_size = 0; }
--------------------------------------------- Result 1477 ---------------------------------------------
[[0 (72%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void set_memory_options(uint64_t *ram_slots, ram_addr_t *maxram_size) { uint64_t sz; const char *mem_str; const char *maxmem_str, *slots_str; const ram_addr_t default_ram_size = (ram_addr_t)DEFAULT_RAM_SIZE * 1024 * 1024; QemuOpts *opts = qemu_find_opts_singleton("memory"); sz = 0; mem_str = qemu_opt_get(opts, "size"); if (mem_str) { if (!*mem_str) { error_report("missing 'size' option value"); exit(EXIT_FAILURE); } sz = qemu_opt_get_size(opts, "size", ram_size); if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) { uint64_t overflow_check = sz; sz <<= 20; if ((sz >> 20) != overflow_check) { error_report("too large 'size' option value"); exit(EXIT_FAILURE); } } } if (sz == 0) { sz = default_ram_size; } sz = QEMU_ALIGN_UP(sz, 8192); ram_size = sz; if (ram_size != sz) { error_report("ram size too large"); exit(EXIT_FAILURE); } qemu_opt_set_number(opts, "size", ram_size, &error_abort); *maxram_size = ram_size; maxmem_str = qemu_opt_get(opts, "maxmem"); slots_str = qemu_opt_get(opts, "slots"); if (maxmem_str && slots_str) { uint64_t slots; sz = qemu_opt_get_size(opts, "maxmem", 0); slots = qemu_opt_get_number(opts, "slots", 0); if (sz < ram_size) { error_report("invalid value of -m option maxmem: " "maximum memory size (0x%" PRIx64 ") must be at least " "the initial memory size (0x" RAM_ADDR_FMT ")", sz, ram_size); exit(EXIT_FAILURE); } else if (sz > ram_size) { if (!slots) { error_report("invalid value of -m option: maxmem was " "specified, but no hotplug slots were specified"); exit(EXIT_FAILURE); } } else if (slots) { error_report("invalid value of -m option maxmem: " "memory slots were specified but maximum memory size " "(0x%" PRIx64 ") is equal to the initial memory size " "(0x" RAM_ADDR_FMT ")", sz, ram_size); exit(EXIT_FAILURE); } *maxram_size = sz; *ram_slots = slots; } else if ((!maxmem_str && slots_str) || (maxmem_str && !slots_str)) { error_report("invalid -m option value: missing " "'%s' option", slots_str ? "maxmem" : "slots"); exit(EXIT_FAILURE); } }
--------------------------------------------- Result 1478 ---------------------------------------------
[[0 (15%)]] --> [[0 (77%)]] --> Socre: 0.773676335811615

[[[[Adv]]]]: static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp) { IscsiLun *[[iscsilun]] = bs->opaque; uint64_t max_xfer_len = [[iscsilun]]->use_16_for_rw ? 0xffffffff : 0xffff; bs->request_alignment = [[iscsilun]]->block_size; if ([[iscsilun]]->bl.max_xfer_len) { max_xfer_len = MIN(max_xfer_len, [[iscsilun]]->bl.max_xfer_len); } if (max_xfer_len * [[iscsilun]]->block_size < INT_MAX) { bs->bl.max_transfer = max_xfer_len * [[iscsilun]]->block_size; } if ([[iscsilun]]->lbp.lbpu) { if ([[iscsilun]]->bl.max_unmap < 0xffffffff) { bs->bl.max_discard = sector_limits_lun2qemu([[iscsilun]]->bl.max_unmap, [[iscsilun]]); } bs->bl.discard_alignment = sector_limits_lun2qemu([[iscsilun]]->bl.opt_unmap_gran, [[iscsilun]]); } else { bs->bl.discard_alignment = [[iscsilun]]->block_size >> BDRV_SECTOR_BITS; } if ([[iscsilun]]->bl.max_ws_len < 0xffffffff / [[iscsilun]]->block_size) { bs->bl.max_pwrite_zeroes = [[iscsilun]]->bl.max_ws_len * [[iscsilun]]->block_size; } if ([[iscsilun]]->lbp.lbpws) { bs->bl.pwrite_zeroes_alignment = [[iscsilun]]->bl.opt_unmap_gran * [[iscsilun]]->block_size; } else { bs->bl.pwrite_zeroes_alignment = [[iscsilun]]->block_size; } if ([[iscsilun]]->bl.opt_xfer_len && [[iscsilun]]->bl.opt_xfer_len < INT_MAX / [[iscsilun]]->block_size) { bs->bl.opt_transfer = pow2floor([[iscsilun]]->bl.opt_xfer_len * [[iscsilun]]->block_size); } }

[[[[Adv]]]]: static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp) { IscsiLun *[[therapists]] = bs->opaque; uint64_t max_xfer_len = [[therapists]]->use_16_for_rw ? 0xffffffff : 0xffff; bs->request_alignment = [[therapists]]->block_size; if ([[therapists]]->bl.max_xfer_len) { max_xfer_len = MIN(max_xfer_len, [[therapists]]->bl.max_xfer_len); } if (max_xfer_len * [[therapists]]->block_size < INT_MAX) { bs->bl.max_transfer = max_xfer_len * [[therapists]]->block_size; } if ([[therapists]]->lbp.lbpu) { if ([[therapists]]->bl.max_unmap < 0xffffffff) { bs->bl.max_discard = sector_limits_lun2qemu([[therapists]]->bl.max_unmap, [[therapists]]); } bs->bl.discard_alignment = sector_limits_lun2qemu([[therapists]]->bl.opt_unmap_gran, [[therapists]]); } else { bs->bl.discard_alignment = [[therapists]]->block_size >> BDRV_SECTOR_BITS; } if ([[therapists]]->bl.max_ws_len < 0xffffffff / [[therapists]]->block_size) { bs->bl.max_pwrite_zeroes = [[therapists]]->bl.max_ws_len * [[therapists]]->block_size; } if ([[therapists]]->lbp.lbpws) { bs->bl.pwrite_zeroes_alignment = [[therapists]]->bl.opt_unmap_gran * [[therapists]]->block_size; } else { bs->bl.pwrite_zeroes_alignment = [[therapists]]->block_size; } if ([[therapists]]->bl.opt_xfer_len && [[therapists]]->bl.opt_xfer_len < INT_MAX / [[therapists]]->block_size) { bs->bl.opt_transfer = pow2floor([[therapists]]->bl.opt_xfer_len * [[therapists]]->block_size); } }
[Succeeded / Failed / Skipped / Total] 859 / 81 / 539 / 1479:  55%|    | 1479/2690 [16:28:03<13:29:00, 40.08s/it][Succeeded / Failed / Skipped / Total] 859 / 81 / 539 / 1479:  55%|    | 1480/2690 [16:28:20<13:28:01, 40.07s/it][Succeeded / Failed / Skipped / Total] 860 / 81 / 539 / 1480:  55%|    | 1480/2690 [16:28:20<13:28:01, 40.07s/it][Succeeded / Failed / Skipped / Total] 860 / 81 / 539 / 1480:  55%|    | 1481/2690 [16:28:20<13:26:49, 40.04s/it][Succeeded / Failed / Skipped / Total] 860 / 81 / 540 / 1481:  55%|    | 1481/2690 [16:28:20<13:26:49, 40.04s/it][Succeeded / Failed / Skipped / Total] 860 / 81 / 540 / 1481:  55%|    | 1482/2690 [16:28:21<13:25:37, 40.01s/it][Succeeded / Failed / Skipped / Total] 860 / 81 / 541 / 1482:  55%|    | 1482/2690 [16:28:21<13:25:37, 40.01s/it][Succeeded / Failed / Skipped / Total] 860 / 81 / 541 / 1482:  55%|    | 1483/2690 [16:28:21<13:24:25, 39.99s/it][Succeeded / Failed / Skipped / Total] 860 / 81 / 542 / 1483:  55%|    | 1483/2690 [16:28:21<13:24:25, 39.99s/it][Succeeded / Failed / Skipped / Total] 860 / 81 / 542 / 1483:  55%|    | 1484/2690 [16:33:32<13:27:25, 40.17s/it]--------------------------------------------- Result 1479 ---------------------------------------------
[[0 (27%)]] --> [[0 (70%)]] --> Socre: 0.7040106058120728

[[[[Adv]]]]: static int kvm_set_mce(CPUState *[[env]], struct kvm_x86_mce *m) { return kvm_vcpu_ioctl([[env]], KVM_X86_SET_MCE, m); }

[[[[Adv]]]]: static int kvm_set_mce(CPUState *[[hedgehog]], struct kvm_x86_mce *m) { return kvm_vcpu_ioctl([[hedgehog]], KVM_X86_SET_MCE, m); }
--------------------------------------------- Result 1480 ---------------------------------------------
[[0 (41%)]] --> [[0 (55%)]] --> Socre: 0.5511437654495239

[[[[Adv]]]]: void ide_atapi_cmd(IDEState *s) { uint8_t *[[buf]]; [[buf]] = s->io_buffer; #ifdef DEBUG_IDE_ATAPI { int i; printf("ATAPI limit=0x%x packet:", s->lcyl | (s->hcyl << 8)); for(i = 0; i < ATAPI_PACKET_SIZE; i++) { printf(" %02x", [[buf]][i]); } printf("\n"); } #endif if (s->sense_key == UNIT_ATTENTION && !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) { ide_atapi_cmd_check_status(s); return; } if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) && !s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) { if (s->cdrom_changed == 1) { ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT); s->cdrom_changed = 2; } else { ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED); s->cdrom_changed = 0; } return; } if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) && (!media_present(s) || !bdrv_is_inserted(s->bs))) { ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT); return; } if (atapi_cmd_table[s->io_buffer[0]].handler) { atapi_cmd_table[s->io_buffer[0]].handler(s, [[buf]]); return; } ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE); }

[[[[Adv]]]]: void ide_atapi_cmd(IDEState *s) { uint8_t *[[jew]]; [[jew]] = s->io_buffer; #ifdef DEBUG_IDE_ATAPI { int i; printf("ATAPI limit=0x%x packet:", s->lcyl | (s->hcyl << 8)); for(i = 0; i < ATAPI_PACKET_SIZE; i++) { printf(" %02x", [[jew]][i]); } printf("\n"); } #endif if (s->sense_key == UNIT_ATTENTION && !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) { ide_atapi_cmd_check_status(s); return; } if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) && !s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) { if (s->cdrom_changed == 1) { ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT); s->cdrom_changed = 2; } else { ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED); s->cdrom_changed = 0; } return; } if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) && (!media_present(s) || !bdrv_is_inserted(s->bs))) { ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT); return; } if (atapi_cmd_table[s->io_buffer[0]].handler) { atapi_cmd_table[s->io_buffer[0]].handler(s, [[jew]]); return; } ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE); }
--------------------------------------------- Result 1481 ---------------------------------------------
[[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_hevc_luma_mv_merge_mode(HEVCContext *s, int x0, int y0, int nPbW, int nPbH, int log2_cb_size, int part_idx, int merge_idx, MvField *mv) { int singleMCLFlag = 0; int nCS = 1 << log2_cb_size; LOCAL_ALIGNED(4, MvField, mergecand_list, [MRG_MAX_NUM_CANDS]); int nPbW2 = nPbW; int nPbH2 = nPbH; HEVCLocalContext *lc = &s->HEVClc; memset(mergecand_list, 0, MRG_MAX_NUM_CANDS * sizeof(*mergecand_list)); if (s->pps->log2_parallel_merge_level > 2 && nCS == 8) { singleMCLFlag = 1; x0 = lc->cu.x; y0 = lc->cu.y; nPbW = nCS; nPbH = nCS; part_idx = 0; } ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH); derive_spatial_merge_candidates(s, x0, y0, nPbW, nPbH, log2_cb_size, singleMCLFlag, part_idx, merge_idx, mergecand_list); if (mergecand_list[merge_idx].pred_flag[0] == 1 && mergecand_list[merge_idx].pred_flag[1] == 1 && (nPbW2 + nPbH2) == 12) { mergecand_list[merge_idx].ref_idx[1] = -1; mergecand_list[merge_idx].pred_flag[1] = 0; } *mv = mergecand_list[merge_idx]; }
--------------------------------------------- Result 1482 ---------------------------------------------
[[0 (2%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int s390_cpu_write_elf64_note(WriteCoreDumpFunction f, CPUState *cs, int cpuid, void *opaque) { S390CPU *cpu = S390_CPU(cs); return s390x_write_all_elf64_notes("CORE", f, cpu, cpuid, opaque); }
--------------------------------------------- Result 1483 ---------------------------------------------
[[0 (99%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void encode_clnpass(Jpeg2000T1Context *t1, int width, int height, int bandno, int *nmsedec, int bpno) { int y0, x, y, mask = 1 << (bpno + NMSEDEC_FRACBITS); for (y0 = 0; y0 < height; y0 += 4) for (x = 0; x < width; x++){ if (y0 + 3 < height && !( (t1->flags[y0+1][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) || (t1->flags[y0+2][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) || (t1->flags[y0+3][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) || (t1->flags[y0+4][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)))) { int rlen; for (rlen = 0; rlen < 4; rlen++) if (t1->data[y0+rlen][x] & mask) break; ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_RL, rlen != 4); if (rlen == 4) continue; ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI, rlen >> 1); ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI, rlen & 1); for (y = y0 + rlen; y < y0 + 4; y++){ if (!(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))){ int ctxno = ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1], bandno); if (y > y0 + rlen) ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, t1->data[y][x] & mask ? 1:0); if (t1->data[y][x] & mask){ int xorbit; int ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit); *nmsedec += getnmsedec_sig(t1->data[y][x], bpno + NMSEDEC_FRACBITS); ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, (t1->flags[y+1][x+1] >> 15) ^ xorbit); ff_jpeg2000_set_significance(t1, x, y, t1->flags[y+1][x+1] >> 15); } } t1->flags[y+1][x+1] &= ~JPEG2000_T1_VIS; } } else{ for (y = y0; y < y0 + 4 && y < height; y++){ if (!(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))){ int ctxno = ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1], bandno); ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, t1->data[y][x] & mask ? 1:0); if (t1->data[y][x] & mask){ int xorbit; int ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit); *nmsedec += getnmsedec_sig(t1->data[y][x], bpno + NMSEDEC_FRACBITS); ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, (t1->flags[y+1][x+1] >> 15) ^ xorbit); ff_jpeg2000_set_significance(t1, x, y, t1->flags[y+1][x+1] >> 15); } } t1->flags[y+1][x+1] &= ~JPEG2000_T1_VIS; } } } }
--------------------------------------------- Result 1484 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 860 / 82 / 542 / 1484:  55%|    | 1484/2690 [16:33:32<13:27:25, 40.17s/it][Succeeded / Failed / Skipped / Total] 860 / 82 / 542 / 1484:  55%|    | 1485/2690 [16:36:05<13:28:16, 40.25s/it][Succeeded / Failed / Skipped / Total] 861 / 82 / 542 / 1485:  55%|    | 1485/2690 [16:36:05<13:28:16, 40.25s/it][Succeeded / Failed / Skipped / Total] 861 / 82 / 542 / 1485:  55%|    | 1486/2690 [16:36:06<13:27:04, 40.22s/it][Succeeded / Failed / Skipped / Total] 861 / 82 / 543 / 1486:  55%|    | 1486/2690 [16:36:06<13:27:04, 40.22s/it][Succeeded / Failed / Skipped / Total] 861 / 82 / 543 / 1486:  55%|    | 1487/2690 [16:36:10<13:25:55, 40.20s/it][Succeeded / Failed / Skipped / Total] 862 / 82 / 543 / 1487:  55%|    | 1487/2690 [16:36:10<13:25:55, 40.20s/it][Succeeded / Failed / Skipped / Total] 862 / 82 / 543 / 1487:  55%|    | 1488/2690 [16:36:18<13:24:48, 40.17s/it][Succeeded / Failed / Skipped / Total] 863 / 82 / 543 / 1488:  55%|    | 1488/2690 [16:36:18<13:24:48, 40.17s/it][Succeeded / Failed / Skipped / Total] 863 / 82 / 543 / 1488:  55%|    | 1489/2690 [16:41:25<13:27:44, 40.35s/it][[0 (88%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int alloc_sequence_buffers(DiracContext *s) { int sbwidth = DIVRNDUP(s->source.width, 4); int sbheight = DIVRNDUP(s->source.height, 4); int i, w, h, top_padding; for (i = 0; i < 3; i++) { int max_xblen = MAX_BLOCKSIZE >> (i ? s->chroma_x_shift : 0); int max_yblen = MAX_BLOCKSIZE >> (i ? s->chroma_y_shift : 0); w = s->source.width >> (i ? s->chroma_x_shift : 0); h = s->source.height >> (i ? s->chroma_y_shift : 0); top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2); w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2; s->plane[i].idwt_buf_base = av_mallocz((w+max_xblen)*h * sizeof(IDWTELEM)); s->plane[i].idwt_tmp = av_malloc((w+16) * sizeof(IDWTELEM)); s->plane[i].idwt_buf = s->plane[i].idwt_buf_base + top_padding*w; if (!s->plane[i].idwt_buf_base || !s->plane[i].idwt_tmp) return AVERROR(ENOMEM); } w = s->source.width; h = s->source.height; s->sbsplit = av_malloc(sbwidth * sbheight); s->blmotion = av_malloc(sbwidth * sbheight * 16 * sizeof(*s->blmotion)); s->edge_emu_buffer_base = av_malloc((w+64)*MAX_BLOCKSIZE); s->mctmp = av_malloc((w+64+MAX_BLOCKSIZE) * (h*MAX_BLOCKSIZE) * sizeof(*s->mctmp)); s->mcscratch = av_malloc((w+64)*MAX_BLOCKSIZE); if (!s->sbsplit || !s->blmotion) return AVERROR(ENOMEM); return 0; }

[[[[Adv]]]]: static int alloc_sequence_buffers(DiracContext *s) { int sbwidth = DIVRNDUP(s->source.width, 4); int sbheight = DIVRNDUP(s->source.height, 4); int i, w, h, top_padding; for (i = 0; i < 3; i++) { int max_xblen = MAX_BLOCKSIZE >> (i ? s->chroma_x_shift : 0); int max_yblen = MAX_BLOCKSIZE >> (i ? s->chroma_y_shift : 0); w = s->source.width >> (i ? s->chroma_x_shift : 0); h = s->source.height >> (i ? s->chroma_y_shift : 0); top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2); w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2; s->plane[i].idwt_buf_base = av_mallocz((w+max_xblen)*h * sizeof(IDWTELEM)); s->plane[i].idwt_tmp = av_malloc((w+16) * sizeof(IDWTELEM)); s->plane[i].idwt_buf = s->plane[i].idwt_buf_base + top_padding*w; if (!s->plane[i].idwt_buf_base || !s->plane[i].idwt_tmp) return AVERROR(ENOMEM); } w = s->source.width; h = s->source.height; s->sbsplit = av_malloc(sbwidth * sbheight); s->blmotion = av_malloc(sbwidth * sbheight * 16 * sizeof(*s->blmotion)); s->edge_emu_buffer_base = av_malloc((w+64)*MAX_BLOCKSIZE); s->mctmp = av_malloc((w+64+MAX_BLOCKSIZE) * (h*MAX_BLOCKSIZE) * sizeof(*s->mctmp)); s->mcscratch = av_malloc((w+64)*MAX_BLOCKSIZE); if (!s->sbsplit || !s->blmotion) return AVERROR(ENOMEM); return 0; }
--------------------------------------------- Result 1485 ---------------------------------------------
[[0 (1%)]] --> [[0 (98%)]] --> Socre: 0.9816164970397949

[[[[Adv]]]]: static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx, target_ulong *[[pte1p]], int ret, int rw) { int store = 0; if (!(*[[pte1p]] & HPTE64_R_R)) { *[[pte1p]] |= HPTE64_R_R; store = 1; } if (!(*[[pte1p]] & HPTE64_R_C)) { if (rw == 1 && ret == 0) { *[[pte1p]] |= HPTE64_R_C; store = 1; } else { ctx->prot &= ~PAGE_WRITE; } } return store; }

[[[[Adv]]]]: static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx, target_ulong *[[seor]], int ret, int rw) { int store = 0; if (!(*[[seor]] & HPTE64_R_R)) { *[[seor]] |= HPTE64_R_R; store = 1; } if (!(*[[seor]] & HPTE64_R_C)) { if (rw == 1 && ret == 0) { *[[seor]] |= HPTE64_R_C; store = 1; } else { ctx->prot &= ~PAGE_WRITE; } } return store; }
--------------------------------------------- Result 1486 ---------------------------------------------
[[0 (60%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int discard_single_l2(BlockDriverState *bs, uint64_t offset, unsigned int nb_clusters, enum qcow2_discard_type type, bool full_discard) { BDRVQcow2State *s = bs->opaque; uint64_t *l2_table; int l2_index; int ret; int i; ret = get_cluster_table(bs, offset, &l2_table, &l2_index); if (ret < 0) { return ret; } nb_clusters = MIN(nb_clusters, s->l2_size - l2_index); for (i = 0; i < nb_clusters; i++) { uint64_t old_l2_entry; old_l2_entry = be64_to_cpu(l2_table[l2_index + i]); switch (qcow2_get_cluster_type(old_l2_entry)) { case QCOW2_CLUSTER_UNALLOCATED: if (full_discard || !bs->backing_hd) { continue; } break; case QCOW2_CLUSTER_ZERO: if (!full_discard) { continue; } break; case QCOW2_CLUSTER_NORMAL: case QCOW2_CLUSTER_COMPRESSED: break; default: abort(); } qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table); if (!full_discard && s->qcow_version >= 3) { l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO); } else { l2_table[l2_index + i] = cpu_to_be64(0); } qcow2_free_any_clusters(bs, old_l2_entry, 1, type); } qcow2_cache_put(bs, s->l2_table_cache, (void **) &l2_table); return nb_clusters; }
--------------------------------------------- Result 1487 ---------------------------------------------
[[0 (31%)]] --> [[0 (60%)]] --> Socre: 0.5959373712539673

[[[[Adv]]]]: static int64_t qemu_archipelago_getlength(BlockDriverState *bs) { int64_t [[ret]]; BDRVArchipelagoState *s = bs->opaque; [[ret]] = archipelago_volume_info(s); return [[ret]]; }

[[[[Adv]]]]: static int64_t qemu_archipelago_getlength(BlockDriverState *bs) { int64_t [[pension]]; BDRVArchipelagoState *s = bs->opaque; [[pension]] = archipelago_volume_info(s); return [[pension]]; }
--------------------------------------------- Result 1488 ---------------------------------------------
[[0 (6%)]] --> [[0 (68%)]] --> Socre: 0.675585150718689

[[[[Adv]]]]: static void rtas_ibm_set_eeh_option(PowerPCCPU *cpu, sPAPRMachineState *spapr, uint32_t token, uint32_t nargs, target_ulong args, uint32_t nret, target_ulong rets) { sPAPRPHBState *sphb; sPAPRPHBClass *[[spc]]; PCIDevice *pdev; uint32_t addr, option; uint64_t buid; int ret; if ((nargs != 4) || (nret != 1)) { goto param_error_exit; } buid = rtas_ldq(args, 1); addr = rtas_ld(args, 0); option = rtas_ld(args, 3); sphb = spapr_pci_find_phb(spapr, buid); if (!sphb) { goto param_error_exit; } pdev = pci_find_device(PCI_HOST_BRIDGE(sphb)->bus, (addr >> 16) & 0xFF, (addr >> 8) & 0xFF); if (!pdev || !object_dynamic_cast(OBJECT(pdev), "vfio-pci")) { goto param_error_exit; } [[spc]] = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb); if (![[spc]]->eeh_set_option) { goto param_error_exit; } ret = [[spc]]->eeh_set_option(sphb, addr, option); rtas_st(rets, 0, ret); return; param_error_exit: rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR); }

[[[[Adv]]]]: static void rtas_ibm_set_eeh_option(PowerPCCPU *cpu, sPAPRMachineState *spapr, uint32_t token, uint32_t nargs, target_ulong args, uint32_t nret, target_ulong rets) { sPAPRPHBState *sphb; sPAPRPHBClass *[[deucey]]; PCIDevice *pdev; uint32_t addr, option; uint64_t buid; int ret; if ((nargs != 4) || (nret != 1)) { goto param_error_exit; } buid = rtas_ldq(args, 1); addr = rtas_ld(args, 0); option = rtas_ld(args, 3); sphb = spapr_pci_find_phb(spapr, buid); if (!sphb) { goto param_error_exit; } pdev = pci_find_device(PCI_HOST_BRIDGE(sphb)->bus, (addr >> 16) & 0xFF, (addr >> 8) & 0xFF); if (!pdev || !object_dynamic_cast(OBJECT(pdev), "vfio-pci")) { goto param_error_exit; } [[deucey]] = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb); if (![[deucey]]->eeh_set_option) { goto param_error_exit; } ret = [[deucey]]->eeh_set_option(sphb, addr, option); rtas_st(rets, 0, ret); return; param_error_exit: rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR); }
--------------------------------------------- Result 1489 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 863 / 83 / 543 / 1489:  55%|    | 1489/2690 [16:41:25<13:27:44, 40.35s/it][Succeeded / Failed / Skipped / Total] 863 / 83 / 543 / 1489:  55%|    | 1490/2690 [16:44:40<13:29:07, 40.46s/it][Succeeded / Failed / Skipped / Total] 864 / 83 / 543 / 1490:  55%|    | 1490/2690 [16:44:40<13:29:07, 40.46s/it][Succeeded / Failed / Skipped / Total] 864 / 83 / 543 / 1490:  55%|    | 1491/2690 [16:44:40<13:27:55, 40.43s/it][Succeeded / Failed / Skipped / Total] 864 / 83 / 544 / 1491:  55%|    | 1491/2690 [16:44:40<13:27:55, 40.43s/it][Succeeded / Failed / Skipped / Total] 864 / 83 / 544 / 1491:  55%|    | 1492/2690 [16:44:41<13:26:42, 40.40s/it][[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int decode_header(MPADecodeContext *s, UINT32 header) { int sample_rate, frame_size, mpeg25, padding; int sample_rate_index, bitrate_index; if (header & (1<<20)) { s->lsf = (header & (1<<19)) ? 0 : 1; mpeg25 = 0; } else { s->lsf = 1; mpeg25 = 1; } s->layer = 4 - ((header >> 17) & 3); sample_rate_index = (header >> 10) & 3; sample_rate = mpa_freq_tab[sample_rate_index] >> (s->lsf + mpeg25); if (sample_rate == 0) return 1; sample_rate_index += 3 * (s->lsf + mpeg25); s->sample_rate_index = sample_rate_index; s->error_protection = ((header >> 16) & 1) ^ 1; bitrate_index = (header >> 12) & 0xf; padding = (header >> 9) & 1; s->mode = (header >> 6) & 3; s->mode_ext = (header >> 4) & 3; if (s->mode == MPA_MONO) s->nb_channels = 1; else s->nb_channels = 2; if (bitrate_index != 0) { frame_size = mpa_bitrate_tab[s->lsf][s->layer - 1][bitrate_index]; s->bit_rate = frame_size * 1000; switch(s->layer) { case 1: frame_size = (frame_size * 12000) / sample_rate; frame_size = (frame_size + padding) * 4; break; case 2: frame_size = (frame_size * 144000) / sample_rate; frame_size += padding; break; default: case 3: frame_size = (frame_size * 144000) / (sample_rate << s->lsf); frame_size += padding; break; } s->frame_size = frame_size; } else { if (!s->free_format_frame_size) return 1; s->frame_size = s->free_format_frame_size; switch(s->layer) { case 1: s->frame_size += padding * 4; s->bit_rate = (s->frame_size * sample_rate) / 48000; break; case 2: s->frame_size += padding; s->bit_rate = (s->frame_size * sample_rate) / 144000; break; default: case 3: s->frame_size += padding; s->bit_rate = (s->frame_size * (sample_rate << s->lsf)) / 144000; break; } } s->sample_rate = sample_rate; #if defined(DEBUG) printf("layer%d, %d Hz, %d kbits/s, ", s->layer, s->sample_rate, s->bit_rate); if (s->nb_channels == 2) { if (s->layer == 3) { if (s->mode_ext & MODE_EXT_MS_STEREO) printf("ms-"); if (s->mode_ext & MODE_EXT_I_STEREO) printf("i-"); } printf("stereo"); } else { printf("mono"); } printf("\n"); #endif return 0; }

[[[[Adv]]]]: static int decode_header(MPADecodeContext *s, UINT32 header) { int sample_rate, frame_size, mpeg25, padding; int sample_rate_index, bitrate_index; if (header & (1<<20)) { s->lsf = (header & (1<<19)) ? 0 : 1; mpeg25 = 0; } else { s->lsf = 1; mpeg25 = 1; } s->layer = 4 - ((header >> 17) & 3); sample_rate_index = (header >> 10) & 3; sample_rate = mpa_freq_tab[sample_rate_index] >> (s->lsf + mpeg25); if (sample_rate == 0) return 1; sample_rate_index += 3 * (s->lsf + mpeg25); s->sample_rate_index = sample_rate_index; s->error_protection = ((header >> 16) & 1) ^ 1; bitrate_index = (header >> 12) & 0xf; padding = (header >> 9) & 1; s->mode = (header >> 6) & 3; s->mode_ext = (header >> 4) & 3; if (s->mode == MPA_MONO) s->nb_channels = 1; else s->nb_channels = 2; if (bitrate_index != 0) { frame_size = mpa_bitrate_tab[s->lsf][s->layer - 1][bitrate_index]; s->bit_rate = frame_size * 1000; switch(s->layer) { case 1: frame_size = (frame_size * 12000) / sample_rate; frame_size = (frame_size + padding) * 4; break; case 2: frame_size = (frame_size * 144000) / sample_rate; frame_size += padding; break; default: case 3: frame_size = (frame_size * 144000) / (sample_rate << s->lsf); frame_size += padding; break; } s->frame_size = frame_size; } else { if (!s->free_format_frame_size) return 1; s->frame_size = s->free_format_frame_size; switch(s->layer) { case 1: s->frame_size += padding * 4; s->bit_rate = (s->frame_size * sample_rate) / 48000; break; case 2: s->frame_size += padding; s->bit_rate = (s->frame_size * sample_rate) / 144000; break; default: case 3: s->frame_size += padding; s->bit_rate = (s->frame_size * (sample_rate << s->lsf)) / 144000; break; } } s->sample_rate = sample_rate; #if defined(DEBUG) printf("layer%d, %d Hz, %d kbits/s, ", s->layer, s->sample_rate, s->bit_rate); if (s->nb_channels == 2) { if (s->layer == 3) { if (s->mode_ext & MODE_EXT_MS_STEREO) printf("ms-"); if (s->mode_ext & MODE_EXT_I_STEREO) printf("i-"); } printf("stereo"); } else { printf("mono"); } printf("\n"); #endif return 0; }
--------------------------------------------- Result 1490 ---------------------------------------------
[[0 (2%)]] --> [[0 (57%)]] --> Socre: 0.566067099571228

[[[[Adv]]]]: BlockAIOCB *dma_bdrv_write(BlockDriverState *bs, QEMUSGList *[[sg]], uint64_t sector, void (*cb)(void *[[opaque]], int ret), void *[[opaque]]) { return dma_bdrv_io(bs, [[sg]], sector, bdrv_aio_writev, cb, [[opaque]], DMA_DIRECTION_TO_DEVICE); }

[[[[Adv]]]]: BlockAIOCB *dma_bdrv_write(BlockDriverState *bs, QEMUSGList *[[billions]], uint64_t sector, void (*cb)(void *[[unclear]], int ret), void *[[unclear]]) { return dma_bdrv_io(bs, [[billions]], sector, bdrv_aio_writev, cb, [[unclear]], DMA_DIRECTION_TO_DEVICE); }
--------------------------------------------- Result 1491 ---------------------------------------------
[[0 (56%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx, const uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size) { CookParseContext *s = s1->priv_data; if (s->duration) s1->duration = s->duration; else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels) s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels; *poutbuf = buf; *poutbuf_size = buf_size; return buf_size; }
--------------------------------------------- Result 1492 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 864 / 83 / 545 / 1492:  55%|    | 1492/2690 [16:44:41<13:26:42, 40.40s/it][Succeeded / Failed / Skipped / Total] 864 / 83 / 545 / 1492:  56%|    | 1493/2690 [16:44:41<13:25:30, 40.38s/it][Succeeded / Failed / Skipped / Total] 864 / 83 / 546 / 1493:  56%|    | 1493/2690 [16:44:41<13:25:30, 40.38s/it][Succeeded / Failed / Skipped / Total] 864 / 83 / 546 / 1493:  56%|    | 1494/2690 [16:44:45<13:24:20, 40.35s/it][Succeeded / Failed / Skipped / Total] 865 / 83 / 546 / 1494:  56%|    | 1494/2690 [16:44:45<13:24:20, 40.35s/it][Succeeded / Failed / Skipped / Total] 865 / 83 / 546 / 1494:  56%|    | 1495/2690 [16:44:45<13:23:08, 40.32s/it][Succeeded / Failed / Skipped / Total] 865 / 83 / 547 / 1495:  56%|    | 1495/2690 [16:44:45<13:23:08, 40.32s/it][Succeeded / Failed / Skipped / Total] 865 / 83 / 547 / 1495:  56%|    | 1496/2690 [16:46:12<13:23:04, 40.36s/it][Succeeded / Failed / Skipped / Total] 866 / 83 / 547 / 1496:  56%|    | 1496/2690 [16:46:12<13:23:04, 40.36s/it][Succeeded / Failed / Skipped / Total] 866 / 83 / 547 / 1496:  56%|    | 1497/2690 [16:49:08<13:24:12, 40.45s/it][Succeeded / Failed / Skipped / Total] 867 / 83 / 547 / 1497:  56%|    | 1497/2690 [16:49:08<13:24:12, 40.45s/it]