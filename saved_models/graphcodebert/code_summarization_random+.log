Some weights of the model checkpoint at microsoft/graphcodebert-base were not used when initializing RobertaModel: ['lm_head.dense.bias', 'lm_head.bias', 'lm_head.layer_norm.weight', 'lm_head.dense.weight', 'lm_head.layer_norm.bias', 'lm_head.decoder.weight', 'lm_head.decoder.bias']
- This IS expected if you are initializing RobertaModel from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
- This IS NOT expected if you are initializing RobertaModel from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).
Some weights of RobertaModel were not initialized from the model checkpoint at microsoft/graphcodebert-base and are newly initialized: ['roberta.pooler.dense.bias', 'roberta.pooler.dense.weight']
You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
textattack: Running 7 worker(s) on 7 GPU(s).
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/1000 [00:00<00:01, 743.01it/s][Succeeded / Failed / Skipped / Total] 2 / 0 / 0 / 2:   0%|          | 2/1000 [00:00<00:00, 1033.21it/s][Succeeded / Failed / Skipped / Total] 3 / 0 / 0 / 3:   0%|          | 3/1000 [00:00<00:00, 1138.62it/s][Succeeded / Failed / Skipped / Total] 4 / 0 / 0 / 4:   0%|          | 4/1000 [00:00<00:00, 1278.46it/s][Succeeded / Failed / Skipped / Total] 4 / 0 / 0 / 4:   0%|          | 5/1000 [00:13<45:21,  2.74s/it]  [Succeeded / Failed / Skipped / Total] 5 / 0 / 0 / 5:   0%|          | 5/1000 [00:13<45:22,  2.74s/it][Succeeded / Failed / Skipped / Total] 5 / 0 / 0 / 5:   1%|          | 6/1000 [00:21<59:57,  3.62s/it][Succeeded / Failed / Skipped / Total] 6 / 0 / 0 / 6:   1%|          | 6/1000 [00:21<59:57,  3.62s/it][Succeeded / Failed / Skipped / Total] 6 / 0 / 0 / 6:   1%|          | 7/1000 [00:34<1:22:34,  4.99s/it][Succeeded / Failed / Skipped / Total] 7 / 0 / 0 / 7:   1%|          | 7/1000 [00:34<1:22:34,  4.99s/it][Succeeded / Failed / Skipped / Total] 7 / 0 / 0 / 7:   1%|          | 8/1000 [00:51<1:46:23,  6.44s/it]--------------------------------------------- Result 1 ---------------------------------------------
Observes the observable using the given scheduler . --> ObservableObservable methods --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[observeOn]] ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[brownings]] ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 2 ---------------------------------------------
Creates a new instance of the given capacity . --> create a new instance --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[arigato]] ) { return new UnicastProcessor < T > ( [[arigato]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 3 ---------------------------------------------
Emit the given value to the downstream . --> Emit a given value --> Socre: 1.0

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U value , boolean [[delayError]] , Disposable disposable ) { final Observer < ? super V > [[observer]] = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( [[observer]] , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , [[observer]] , [[delayError]] , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U value , boolean [[ptt]] , Disposable disposable ) { final Observer < ? super V > [[anesthesiology]] = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( [[anesthesiology]] , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , [[anesthesiology]] , [[ptt]] , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 4 ---------------------------------------------
Wraps an Observable . --> Symbol from source --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[kristy]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 5 ---------------------------------------------
Construct a Maybe from a CompletableSource . --> Fixing fixes from Completable --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromCompletable]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fixings]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 6 ---------------------------------------------
Create a Maybe from a single source . -->  madhav --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[madhav]] ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 7 ---------------------------------------------
Attempt to retry after given number of times --> Executes an archiver --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[retry]] ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[archivist]] ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 8 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 8 / 0 / 0 / 8:   1%|          | 8/1000 [00:51<1:46:24,  6.44s/it][Succeeded / Failed / Skipped / Total] 8 / 0 / 0 / 8:   1%|          | 9/1000 [00:53<1:38:17,  5.95s/it][Succeeded / Failed / Skipped / Total] 9 / 0 / 0 / 9:   1%|          | 9/1000 [00:53<1:38:17,  5.95s/it][Succeeded / Failed / Skipped / Total] 9 / 0 / 0 / 9:   1%|          | 10/1000 [02:47<4:35:50, 16.72s/it][Succeeded / Failed / Skipped / Total] 10 / 0 / 0 / 10:   1%|          | 10/1000 [02:47<4:35:50, 16.72s/it][Succeeded / Failed / Skipped / Total] 10 / 0 / 0 / 10:   1%|          | 11/1000 [02:57<4:25:38, 16.12s/it][Succeeded / Failed / Skipped / Total] 11 / 0 / 0 / 11:   1%|          | 11/1000 [02:57<4:25:39, 16.12s/it][Succeeded / Failed / Skipped / Total] 11 / 0 / 0 / 11:   1%|          | 12/1000 [03:16<4:29:27, 16.36s/it][Succeeded / Failed / Skipped / Total] 12 / 0 / 0 / 12:   1%|          | 12/1000 [03:16<4:29:28, 16.36s/it][Succeeded / Failed / Skipped / Total] 12 / 0 / 0 / 12:   1%|▏         | 13/1000 [03:17<4:09:37, 15.17s/it][Succeeded / Failed / Skipped / Total] 13 / 0 / 0 / 13:   1%|▏         | 13/1000 [03:17<4:09:37, 15.17s/it][Succeeded / Failed / Skipped / Total] 13 / 0 / 0 / 13:   1%|▏         | 14/1000 [03:33<4:10:37, 15.25s/it][Succeeded / Failed / Skipped / Total] 14 / 0 / 0 / 14:   1%|▏         | 14/1000 [03:33<4:10:37, 15.25s/it][Succeeded / Failed / Skipped / Total] 14 / 0 / 0 / 14:   2%|▏         | 15/1000 [03:35<3:55:23, 14.34s/it][Succeeded / Failed / Skipped / Total] 15 / 0 / 0 / 15:   2%|▏         | 15/1000 [03:35<3:55:23, 14.34s/it][Succeeded / Failed / Skipped / Total] 15 / 0 / 0 / 15:   2%|▏         | 16/1000 [03:47<3:53:35, 14.24s/it]Returns an Observable with the given sort function . --> Exhaustively Exclamation functions --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[exclamation]] ( Comparator < ? super T > [[barbu]] ) { ObjectHelper . requireNonNull ( [[barbu]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[barbu]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 9 ---------------------------------------------
Returns the identity function . --> puro --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T > Function < T , T > [[identity]] ( ) { return ( Function < T , T > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T > Function < T , T > [[puro]] ( ) { return ( Function < T , T > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 10 ---------------------------------------------
Static factory method for creating Callable . --> Static wrapper for SimpleCallable --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > justCallable ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > justCallable ( T [[teli]] ) { return new JustValue < Object , T > ( [[teli]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 11 ---------------------------------------------
Reset the scheduler . --> For testing purposes only --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[hustling]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 12 ---------------------------------------------
Create a reusable subject . --> Returns a new etch --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[etchings]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 13 ---------------------------------------------
A simple x map of scalar X values --> Oswone operator --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[oswaldo]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > [[anemone]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , [[anemone]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 14 ---------------------------------------------
Returns a function that returns only the given value . --> Static factory method --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > justFunction ( U value ) { return new JustValue < [[T]] , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[oppressor]] , U > Function < [[oppressor]] , U > justFunction ( U value ) { return new JustValue < [[oppressor]] , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 15 ---------------------------------------------
Create a new instance of the given capacity . --> Create a unicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int [[exasperated]] ) { return new UnicastSubject < T > ( [[exasperated]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 16 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 1 / 0 / 16:   2%|▏         | 16/1000 [03:47<3:53:35, 14.24s/it][Succeeded / Failed / Skipped / Total] 15 / 1 / 0 / 16:   2%|▏         | 17/1000 [03:53<3:44:39, 13.71s/it][Succeeded / Failed / Skipped / Total] 16 / 1 / 0 / 17:   2%|▏         | 17/1000 [03:53<3:44:39, 13.71s/it][Succeeded / Failed / Skipped / Total] 16 / 1 / 0 / 17:   2%|▏         | 18/1000 [03:57<3:36:11, 13.21s/it][Succeeded / Failed / Skipped / Total] 17 / 1 / 0 / 18:   2%|▏         | 18/1000 [03:57<3:36:11, 13.21s/it][Succeeded / Failed / Skipped / Total] 17 / 1 / 0 / 18:   2%|▏         | 19/1000 [03:58<3:25:07, 12.55s/it][Succeeded / Failed / Skipped / Total] 18 / 1 / 0 / 19:   2%|▏         | 19/1000 [03:58<3:25:07, 12.55s/it][Succeeded / Failed / Skipped / Total] 18 / 1 / 0 / 19:   2%|▏         | 20/1000 [04:17<3:30:18, 12.88s/it][Succeeded / Failed / Skipped / Total] 19 / 1 / 0 / 20:   2%|▏         | 20/1000 [04:17<3:30:18, 12.88s/it][Succeeded / Failed / Skipped / Total] 19 / 1 / 0 / 20:   2%|▏         | 21/1000 [04:23<3:24:41, 12.54s/it][Succeeded / Failed / Skipped / Total] 20 / 1 / 0 / 21:   2%|▏         | 21/1000 [04:23<3:24:41, 12.54s/it][Succeeded / Failed / Skipped / Total] 20 / 1 / 0 / 21:   2%|▏         | 22/1000 [04:50<3:35:15, 13.21s/it][Succeeded / Failed / Skipped / Total] 21 / 1 / 0 / 22:   2%|▏         | 22/1000 [04:50<3:35:15, 13.21s/it][Succeeded / Failed / Skipped / Total] 21 / 1 / 0 / 22:   2%|▏         | 23/1000 [04:57<3:30:21, 12.92s/it][Succeeded / Failed / Skipped / Total] 22 / 1 / 0 / 23:   2%|▏         | 23/1000 [04:57<3:30:21, 12.92s/it][Succeeded / Failed / Skipped / Total] 22 / 1 / 0 / 23:   2%|▏         | 24/1000 [06:23<4:19:53, 15.98s/it]Ensures that the given object is not null . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] requireNonNull ( [[T]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < [[rochelle]] > [[rochelle]] requireNonNull ( [[rochelle]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 17 ---------------------------------------------
Creates a new reusable subject . --> Factory method to create a reusable subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[barbu]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 18 ---------------------------------------------
Gets the cast function . --> kenley casts --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Function < T , U > [[castFunction]] ( Class < U > target ) { return new CastToClass < T , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < T , U > Function < T , U > [[kennington]] ( Class < U > target ) { return new CastToClass < T , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 19 ---------------------------------------------
Creates a new reusable subject . --> Convenience factory method --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int capacityHint , Runnable [[onTerminate]] ) { return new UnicastSubject < T > ( capacityHint , [[onTerminate]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int capacityHint , Runnable [[brewton]] ) { return new UnicastSubject < T > ( capacityHint , [[brewton]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 20 ---------------------------------------------
Requests prefetch . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public static void request ( Subscription [[s]] , int prefetch ) { [[s]] . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void request ( Subscription [[drastic]] , int prefetch ) { [[drastic]] . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 21 ---------------------------------------------
Waits for an error . --> GianCarlolo --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[giancarlo]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 22 ---------------------------------------------
Post complete event . --> postcomplete --> Socre: 1.0

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > [[queue]] , AtomicLong state , BooleanSupplier isCancelled ) { if ( [[queue]] . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , [[queue]] , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > [[resumé]] , AtomicLong state , BooleanSupplier isCancelled ) { if ( [[resumé]] . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , [[resumé]] , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 23 ---------------------------------------------
Throws an exception if the queue is not empty . --> Waits for bernstein --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[bernstein]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 24 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 1 / 0 / 24:   2%|▏         | 24/1000 [06:23<4:19:53, 15.98s/it][Succeeded / Failed / Skipped / Total] 23 / 1 / 0 / 24:   2%|▎         | 25/1000 [06:55<4:29:57, 16.61s/it][Succeeded / Failed / Skipped / Total] 24 / 1 / 0 / 25:   2%|▎         | 25/1000 [06:55<4:29:57, 16.61s/it][Succeeded / Failed / Skipped / Total] 24 / 1 / 0 / 25:   3%|▎         | 26/1000 [08:08<5:05:16, 18.81s/it][Succeeded / Failed / Skipped / Total] 25 / 1 / 0 / 26:   3%|▎         | 26/1000 [08:08<5:05:16, 18.81s/it][Succeeded / Failed / Skipped / Total] 25 / 1 / 0 / 26:   3%|▎         | 27/1000 [08:15<4:57:48, 18.36s/it][Succeeded / Failed / Skipped / Total] 26 / 1 / 0 / 27:   3%|▎         | 27/1000 [08:15<4:57:48, 18.36s/it][Succeeded / Failed / Skipped / Total] 26 / 1 / 0 / 27:   3%|▎         | 28/1000 [08:17<4:47:55, 17.77s/it][Succeeded / Failed / Skipped / Total] 27 / 1 / 0 / 28:   3%|▎         | 28/1000 [08:17<4:47:55, 17.77s/it][Succeeded / Failed / Skipped / Total] 27 / 1 / 0 / 28:   3%|▎         | 29/1000 [08:33<4:46:30, 17.70s/it]Waits until the element is complete or throws an exception . --> Waits for you to complete --> Socre: 1.0

[[[[Adv]]]]: public boolean blockingAwait ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } } Throwable [[ex]] = error ; if ( [[ex]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean blockingAwait ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[astrophysicist]] ) ; } } Throwable [[astrophysicist]] = error ; if ( [[astrophysicist]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[astrophysicist]] ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 25 ---------------------------------------------
Tries to apply scalar XMap asynchronously . --> Implementation of UMA --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > [[r]] ; try { [[r]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( [[r]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[r]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { [[r]] . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[uma]] ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > [[sanctimonious]] ; try { [[sanctimonious]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( [[sanctimonious]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[sanctimonious]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { [[sanctimonious]] . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 26 ---------------------------------------------
Completes the operation . --> Marks a maricon --> Socre: 1.0

[[[[Adv]]]]: protected final void [[complete]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long [[r]] = get ( ) ; if ( ( [[r]] & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( [[r]] & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[maricón]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long [[outrageously]] = get ( ) ; if ( ( [[outrageously]] & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( [[outrageously]] & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 27 ---------------------------------------------
Gets the value . --> Methode de de requete --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object [[o]] = value ; if ( [[o]] != null && ! NotificationLite . isError ( [[o]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[ewa]] ( ) { Object [[mountaineering]] = value ; if ( [[mountaineering]] != null && ! NotificationLite . isError ( [[mountaineering]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 28 ---------------------------------------------
Creates a new instance of the given capacity . --> Start traversal --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] , Runnable [[onCancelled]] ) { ObjectHelper . requireNonNull ( [[onCancelled]] , "onTerminate" ) ; return new UnicastProcessor < T > ( [[capacityHint]] , [[onCancelled]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[traverse]] ( int [[donates]] , Runnable [[sabbatical]] ) { ObjectHelper . requireNonNull ( [[sabbatical]] , "onTerminate" ) ; return new UnicastProcessor < T > ( [[donates]] , [[sabbatical]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 29 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 28 / 1 / 0 / 29:   3%|▎         | 29/1000 [08:33<4:46:30, 17.70s/it][Succeeded / Failed / Skipped / Total] 28 / 1 / 0 / 29:   3%|▎         | 30/1000 [08:50<4:45:36, 17.67s/it][Succeeded / Failed / Skipped / Total] 29 / 1 / 0 / 30:   3%|▎         | 30/1000 [08:50<4:45:36, 17.67s/it][Succeeded / Failed / Skipped / Total] 29 / 1 / 0 / 30:   3%|▎         | 31/1000 [08:52<4:37:09, 17.16s/it][Succeeded / Failed / Skipped / Total] 30 / 1 / 0 / 31:   3%|▎         | 31/1000 [08:52<4:37:09, 17.16s/it][Succeeded / Failed / Skipped / Total] 30 / 1 / 0 / 31:   3%|▎         | 32/1000 [08:52<4:28:40, 16.65s/it][Succeeded / Failed / Skipped / Total] 31 / 1 / 0 / 32:   3%|▎         | 32/1000 [08:52<4:28:40, 16.65s/it][Succeeded / Failed / Skipped / Total] 31 / 1 / 0 / 32:   3%|▎         | 33/1000 [09:09<4:28:35, 16.67s/it][Succeeded / Failed / Skipped / Total] 32 / 1 / 0 / 33:   3%|▎         | 33/1000 [09:09<4:28:35, 16.67s/it][Succeeded / Failed / Skipped / Total] 32 / 1 / 0 / 33:   3%|▎         | 34/1000 [09:27<4:28:55, 16.70s/it][Succeeded / Failed / Skipped / Total] 33 / 1 / 0 / 34:   3%|▎         | 34/1000 [09:27<4:28:55, 16.70s/it][Succeeded / Failed / Skipped / Total] 33 / 1 / 0 / 34:   4%|▎         | 35/1000 [11:49<5:25:49, 20.26s/it][Succeeded / Failed / Skipped / Total] 34 / 1 / 0 / 35:   4%|▎         | 35/1000 [11:49<5:25:49, 20.26s/it][Succeeded / Failed / Skipped / Total] 34 / 1 / 0 / 35:   4%|▎         | 36/1000 [12:46<5:42:04, 21.29s/it][Succeeded / Failed / Skipped / Total] 35 / 1 / 0 / 36:   4%|▎         | 36/1000 [12:46<5:42:04, 21.29s/it][Succeeded / Failed / Skipped / Total] 35 / 1 / 0 / 36:   4%|▎         | 37/1000 [12:49<5:33:52, 20.80s/it]Cap a long . --> add a cap to a --> Socre: 1.0

[[[[Adv]]]]: public static long addCap ( long a , long [[b]] ) { long u = a + [[b]] ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long addCap ( long a , long [[fé]] ) { long u = a + [[fé]] ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 30 ---------------------------------------------
Verifies that the stream is consistent . --> Validates jasmin --> Socre: 1.0

[[[[Adv]]]]: public static boolean validate ( Subscription [[upstream]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[upstream]] != null ) { next . cancel ( ) ; if ( [[upstream]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Subscription [[jasmin]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[jasmin]] != null ) { next . cancel ( ) ; if ( [[jasmin]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 31 ---------------------------------------------
Gets the value associated with this notification . --> Capability of Hudson --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object [[o]] = value ; if ( NotificationLite . isError ( [[o]] ) ) { return NotificationLite . getError ( [[o]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[cap]] ( ) { Object [[masturbating]] = value ; if ( NotificationLite . isError ( [[masturbating]] ) ) { return NotificationLite . getError ( [[masturbating]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 32 ---------------------------------------------
Multiply two values . --> Multiplley by b --> Socre: 1.0

[[[[Adv]]]]: public static long multiplyCap ( long [[a]] , long b ) { long u = [[a]] * b ; if ( ( ( [[a]] | b ) >>> 31 ) != 0 ) { if ( u / [[a]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long multiplyCap ( long [[motley]] , long b ) { long u = [[motley]] * b ; if ( ( ( [[motley]] | b ) >>> 31 ) != 0 ) { if ( u / [[motley]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 33 ---------------------------------------------
Adds an object to the list . --> add redbud --> Socre: 1.0

[[[[Adv]]]]: public void add ( Object [[o]] ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void add ( Object [[redbud]] ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 34 ---------------------------------------------
Shuts down the pool . --> Shutdown bigfooter --> Socre: 1.0

[[[[Adv]]]]: public static void shutdown ( ) { ScheduledExecutorService [[exec]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[exec]] != null ) { [[exec]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void shutdown ( ) { ScheduledExecutorService [[bigfoot]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[bigfoot]] != null ) { [[bigfoot]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 35 ---------------------------------------------
Converts a Throwable to a NullPointerException . --> assign null pointer to null --> Socre: 1.0

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[на]] ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 36 ---------------------------------------------
Sets the given subscription to this future . --> Set the SubFooter --> Socre: 1.0

[[[[Adv]]]]: public final void setSubscription ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[s]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[s]] . request ( r ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[s]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void setSubscription ( Subscription [[bigfoot]] ) { if ( cancelled ) { [[bigfoot]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[bigfoot]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[bigfoot]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[bigfoot]] . request ( r ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[bigfoot]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 37 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 36 / 1 / 0 / 37:   4%|▎         | 37/1000 [12:49<5:33:52, 20.80s/it][Succeeded / Failed / Skipped / Total] 36 / 1 / 0 / 37:   4%|▍         | 38/1000 [13:38<5:45:21, 21.54s/it][Succeeded / Failed / Skipped / Total] 37 / 1 / 0 / 38:   4%|▍         | 38/1000 [13:38<5:45:22, 21.54s/it][Succeeded / Failed / Skipped / Total] 37 / 1 / 0 / 38:   4%|▍         | 39/1000 [13:57<5:43:52, 21.47s/it][Succeeded / Failed / Skipped / Total] 38 / 1 / 0 / 39:   4%|▍         | 39/1000 [13:57<5:43:52, 21.47s/it][Succeeded / Failed / Skipped / Total] 38 / 1 / 0 / 39:   4%|▍         | 40/1000 [15:42<6:17:07, 23.57s/it][Succeeded / Failed / Skipped / Total] 39 / 1 / 0 / 40:   4%|▍         | 40/1000 [15:42<6:17:07, 23.57s/it][Succeeded / Failed / Skipped / Total] 39 / 1 / 0 / 40:   4%|▍         | 41/1000 [16:00<6:14:29, 23.43s/it][Succeeded / Failed / Skipped / Total] 40 / 1 / 0 / 41:   4%|▍         | 41/1000 [16:00<6:14:29, 23.43s/it][Succeeded / Failed / Skipped / Total] 40 / 1 / 0 / 41:   4%|▍         | 42/1000 [16:05<6:06:55, 22.98s/it][Succeeded / Failed / Skipped / Total] 41 / 1 / 0 / 42:   4%|▍         | 42/1000 [16:05<6:06:55, 22.98s/it][Succeeded / Failed / Skipped / Total] 41 / 1 / 0 / 42:   4%|▍         | 43/1000 [16:25<6:05:28, 22.91s/it]Recursively collects a max value from a queue . --> Drains a max loop --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > [[a]] , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean [[empty]] = v == null ; if ( checkTerminated ( d , [[empty]] , [[a]] , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( [[empty]] ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( [[a]] , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } [[a]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > [[doña]] , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean [[hyang]] = v == null ; if ( checkTerminated ( d , [[hyang]] , [[doña]] , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( [[hyang]] ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( [[doña]] , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } [[doña]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 38 ---------------------------------------------
Atomically sets the next AtomicReference to the given AtomicReference . --> for unsynchronized --> Socre: 1.0

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription [[next]] , Class < ? > [[subscriber]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[next]] ) ) { [[next]] . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[subscriber]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription [[howe]] , Class < ? > [[ñ]] ) { ObjectHelper . requireNonNull ( [[howe]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[howe]] ) ) { [[howe]] . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[ñ]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 39 ---------------------------------------------
Creates a single scheduled thread pool . --> ScheduledThreadPool Implementation --> Socre: 1.0

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory factory ) { final ScheduledExecutorService [[exec]] = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , [[exec]] ) ; return [[exec]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[soprano]] ( ThreadFactory factory ) { final ScheduledExecutorService [[chromosomal]] = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , [[chromosomal]] ) ; return [[chromosomal]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 40 ---------------------------------------------
Determines whether the stream is valid or not . --> Hotplate methods --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[validate]] ( Disposable upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[hotplate]] ( Disposable upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[Mcnabb]]" != "[[Mcnabb]]" ; } return "[[Maestro]]" == "[[Maestro]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 41 ---------------------------------------------
Removes all resources . --> Remove any cached resources --> Socre: 1.0

[[[[Adv]]]]: public void clear ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[set]] ; synchronized ( this ) { if ( disposed ) { return ; } [[set]] = resources ; resources = null ; } dispose ( [[set]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void clear ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[sunscreen]] ; synchronized ( this ) { if ( disposed ) { return ; } [[sunscreen]] = resources ; resources = null ; } dispose ( [[sunscreen]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 42 ---------------------------------------------
Wraps a runtime exception if it is a RuntimeException . --> Wrap CORSets --> Socre: 1.0

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable [[error]] ) { if ( [[error]] instanceof Error ) { throw ( Error ) [[error]] ; } if ( [[error]] instanceof RuntimeException ) { return ( RuntimeException ) [[error]] ; } return new RuntimeException ( [[error]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable [[corsets]] ) { if ( [[corsets]] instanceof Error ) { throw ( Error ) [[corsets]] ; } if ( [[corsets]] instanceof RuntimeException ) { return ( RuntimeException ) [[corsets]] ; } return new RuntimeException ( [[corsets]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 43 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 42 / 1 / 0 / 43:   4%|▍         | 43/1000 [16:25<6:05:28, 22.91s/it][Succeeded / Failed / Skipped / Total] 42 / 1 / 0 / 43:   4%|▍         | 44/1000 [16:40<6:02:15, 22.74s/it][Succeeded / Failed / Skipped / Total] 43 / 1 / 0 / 44:   4%|▍         | 44/1000 [16:40<6:02:15, 22.74s/it][Succeeded / Failed / Skipped / Total] 43 / 1 / 0 / 44:   4%|▍         | 45/1000 [17:38<6:14:23, 23.52s/it][Succeeded / Failed / Skipped / Total] 44 / 1 / 0 / 45:   4%|▍         | 45/1000 [17:38<6:14:23, 23.52s/it][Succeeded / Failed / Skipped / Total] 44 / 1 / 0 / 45:   5%|▍         | 46/1000 [17:42<6:07:05, 23.09s/it][Succeeded / Failed / Skipped / Total] 45 / 1 / 0 / 46:   5%|▍         | 46/1000 [17:42<6:07:05, 23.09s/it][Succeeded / Failed / Skipped / Total] 45 / 1 / 0 / 46:   5%|▍         | 47/1000 [18:01<6:05:35, 23.02s/it][Succeeded / Failed / Skipped / Total] 46 / 1 / 0 / 47:   5%|▍         | 47/1000 [18:01<6:05:35, 23.02s/it][Succeeded / Failed / Skipped / Total] 46 / 1 / 0 / 47:   5%|▍         | 48/1000 [18:20<6:03:49, 22.93s/it][Succeeded / Failed / Skipped / Total] 47 / 1 / 0 / 48:   5%|▍         | 48/1000 [18:20<6:03:49, 22.93s/it][Succeeded / Failed / Skipped / Total] 47 / 1 / 0 / 48:   5%|▍         | 49/1000 [21:20<6:54:12, 26.13s/it][Succeeded / Failed / Skipped / Total] 48 / 1 / 0 / 49:   5%|▍         | 49/1000 [21:20<6:54:12, 26.13s/it][Succeeded / Failed / Skipped / Total] 48 / 1 / 0 / 49:   5%|▌         | 50/1000 [21:33<6:49:31, 25.86s/it]Loops through the queue . --> loop --> Socre: 1.0

[[[[Adv]]]]: void emitLoop ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[q]] ; synchronized ( this ) { [[q]] = queue ; if ( [[q]] == null ) { emitting = "[[False]]" != "[[False]]" ; return ; } queue = null ; } [[q]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void emitLoop ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[bouffon]] ; synchronized ( this ) { [[bouffon]] = queue ; if ( [[bouffon]] == null ) { emitting = "[[Twilight]]" != "[[Twilight]]" ; return ; } queue = null ; } [[bouffon]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 44 ---------------------------------------------
Flatten a Throwable into a list --> Flattens the given Throwable recursively --> Socre: 1.0

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable t ) { List < Throwable > [[list]] = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { [[list]] . add ( e ) ; } } return [[list]] ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable t ) { List < Throwable > [[reside]] = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { [[reside]] . add ( e ) ; } } return [[reside]] ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 45 ---------------------------------------------
Wraps the given exception if it is a throwable . --> hrows an exception --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E [[extends]] Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E [[amadé]] Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 46 ---------------------------------------------
Accepts a notification . --> Borrowed from queue --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean [[accept]] ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean [[tommorrow]] ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 47 ---------------------------------------------
Start the stream . --> Declarative Services method --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[dialled]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 48 ---------------------------------------------
Start unbounded queue . --> must be called before --> Socre: 1.0

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[coons]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 49 ---------------------------------------------
Atomically sets the AtomicReference to the next AtomicReference . --> this will be called once --> Socre: 1.0

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > [[upstream]] , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , [[next]] ) ) { [[next]] . dispose ( ) ; if ( [[upstream]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > [[doña]] , Disposable [[ap]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[ap]] , "next is null" ) ; if ( ! [[doña]] . compareAndSet ( null , [[ap]] ) ) { [[ap]] . dispose ( ) ; if ( [[doña]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[Windshields]]" != "[[Windshields]]" ; } return "[[Soc]]" == "[[Soc]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 50 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 49 / 1 / 0 / 50:   5%|▌         | 50/1000 [21:33<6:49:31, 25.86s/it][Succeeded / Failed / Skipped / Total] 49 / 1 / 0 / 50:   5%|▌         | 51/1000 [21:39<6:42:55, 25.48s/it][Succeeded / Failed / Skipped / Total] 50 / 1 / 0 / 51:   5%|▌         | 51/1000 [21:39<6:42:55, 25.48s/it][Succeeded / Failed / Skipped / Total] 50 / 1 / 0 / 51:   5%|▌         | 52/1000 [21:40<6:35:06, 25.01s/it][Succeeded / Failed / Skipped / Total] 51 / 1 / 0 / 52:   5%|▌         | 52/1000 [21:40<6:35:06, 25.01s/it][Succeeded / Failed / Skipped / Total] 51 / 1 / 0 / 52:   5%|▌         | 53/1000 [21:59<6:32:53, 24.89s/it][Succeeded / Failed / Skipped / Total] 52 / 1 / 0 / 53:   5%|▌         | 53/1000 [21:59<6:32:53, 24.89s/it][Succeeded / Failed / Skipped / Total] 52 / 1 / 0 / 53:   5%|▌         | 54/1000 [22:07<6:27:41, 24.59s/it][Succeeded / Failed / Skipped / Total] 52 / 2 / 0 / 54:   5%|▌         | 54/1000 [22:07<6:27:41, 24.59s/it][Succeeded / Failed / Skipped / Total] 52 / 2 / 0 / 54:   6%|▌         | 55/1000 [22:38<6:29:01, 24.70s/it][Succeeded / Failed / Skipped / Total] 53 / 2 / 0 / 55:   6%|▌         | 55/1000 [22:38<6:29:01, 24.70s/it][Succeeded / Failed / Skipped / Total] 53 / 2 / 0 / 55:   6%|▌         | 56/1000 [22:57<6:26:57, 24.59s/it][Succeeded / Failed / Skipped / Total] 53 / 3 / 0 / 56:   6%|▌         | 56/1000 [22:57<6:26:57, 24.60s/it][Succeeded / Failed / Skipped / Total] 53 / 3 / 0 / 56:   6%|▌         | 57/1000 [23:16<6:24:56, 24.49s/it][Succeeded / Failed / Skipped / Total] 54 / 3 / 0 / 57:   6%|▌         | 57/1000 [23:16<6:24:56, 24.49s/it][Succeeded / Failed / Skipped / Total] 54 / 3 / 0 / 57:   6%|▌         | 58/1000 [23:33<6:22:43, 24.38s/it][Succeeded / Failed / Skipped / Total] 55 / 3 / 0 / 58:   6%|▌         | 58/1000 [23:33<6:22:43, 24.38s/it][Succeeded / Failed / Skipped / Total] 55 / 3 / 0 / 58:   6%|▌         | 59/1000 [24:43<6:34:27, 25.15s/it]Creates a scalar X map from the given value using the given mapper . --> ga - map x map --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Observable < U > scalarXMap ( T [[value]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > scalarXMap ( T [[letha]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[tester]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[letha]] , [[tester]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 51 ---------------------------------------------
Gets the resource that is currently disposed . --> Muppet object --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return d ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[muppet]] ( ) { Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return d ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 52 ---------------------------------------------
Offers an object to the operator . --> Offers a cascading --> Socre: 1.0

[[[[Adv]]]]: public boolean offer ( T [[t]] ) { if ( once . get ( ) ) { return "[[False]]" != "[[False]]" ; } ObjectHelper . requireNonNull ( [[t]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[t]] ) ) { drain ( ) ; return "True" == "True" ; } } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean offer ( T [[cascades]] ) { if ( once . get ( ) ) { return "[[Cafè]]" != "[[Cafè]]" ; } ObjectHelper . requireNonNull ( [[cascades]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[cascades]] ) ) { drain ( ) ; return "True" == "True" ; } } return "[[Cafè]]" != "[[Cafè]]" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 53 ---------------------------------------------
Completes the operation . --> Terminal operation --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[axel]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 54 ---------------------------------------------
Returns the number of resources available . --> [[[FAILED]]]

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[set]] = resources ; return [[set]] != null ? [[set]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[falsify]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[stall]] = resources ; return [[stall]] != null ? [[stall]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 55 ---------------------------------------------
Accepts an observer from the queue . --> Filter out notifications --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int [[i]] = 0 ; [[i]] < c ; [[i]] ++ ) { Object o = a [ [[i]] ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "[[True]]" == "[[True]]" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int [[markup]] = 0 ; [[markup]] < c ; [[markup]] ++ ) { Object o = a [ [[markup]] ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "[[Wiii]]" == "[[Wiii]]" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 56 ---------------------------------------------
Add n . --> [[[FAILED]]]

[[[[Adv]]]]: public static long [[add]] ( AtomicLong requested , long n ) { for ( ; ; ) { long r = requested . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( requested . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long [[newcastle]] ( AtomicLong requested , long n ) { for ( ; ; ) { long r = requested . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( requested . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 57 ---------------------------------------------
Wait for the consumer to return . --> B bubble head head --> Socre: 1.0

[[[[Adv]]]]: public PerfAsyncConsumer [[await]] ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[await]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer [[bubblehead]] ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[bubblehead]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 58 ---------------------------------------------
Submits a number of ns to the upstream . --> request n n --> Socre: 1.0

[[[[Adv]]]]: protected final void request ( long n ) { Subscription [[s]] = this . upstream ; if ( [[s]] != null ) { [[s]] . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void request ( long n ) { Subscription [[chickenhead]] = this . upstream ; if ( [[chickenhead]] != null ) { [[chickenhead]] . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 59 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 56 / 3 / 0 / 59:   6%|▌         | 59/1000 [24:43<6:34:28, 25.15s/it][Succeeded / Failed / Skipped / Total] 56 / 3 / 0 / 59:   6%|▌         | 60/1000 [24:49<6:28:59, 24.83s/it][Succeeded / Failed / Skipped / Total] 57 / 3 / 0 / 60:   6%|▌         | 60/1000 [24:49<6:28:59, 24.83s/it][Succeeded / Failed / Skipped / Total] 57 / 3 / 0 / 60:   6%|▌         | 61/1000 [24:59<6:24:42, 24.58s/it][Succeeded / Failed / Skipped / Total] 58 / 3 / 0 / 61:   6%|▌         | 61/1000 [24:59<6:24:42, 24.58s/it][Succeeded / Failed / Skipped / Total] 58 / 3 / 0 / 61:   6%|▌         | 62/1000 [25:20<6:23:28, 24.53s/it][Succeeded / Failed / Skipped / Total] 59 / 3 / 0 / 62:   6%|▌         | 62/1000 [25:20<6:23:28, 24.53s/it][Succeeded / Failed / Skipped / Total] 59 / 3 / 0 / 62:   6%|▋         | 63/1000 [25:28<6:18:52, 24.26s/it][Succeeded / Failed / Skipped / Total] 60 / 3 / 0 / 63:   6%|▋         | 63/1000 [25:28<6:18:52, 24.26s/it][Succeeded / Failed / Skipped / Total] 60 / 3 / 0 / 63:   6%|▋         | 64/1000 [25:55<6:19:08, 24.30s/it]Atomically add a new PublishDisposable to the queue . --> adds a new --> Socre: 1.0

[[[[Adv]]]]: boolean add ( PublishDisposable < T > [[ps]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = [[ps]] ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean add ( PublishDisposable < T > [[comédie]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = [[comédie]] ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 60 ---------------------------------------------
Sends an error . --> Must be called once --> Socre: 1.0

[[[[Adv]]]]: public final void [[error]] ( Throwable t ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( t ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( t ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[starrett]] ( Throwable t ) { int [[atone]] = get ( ) ; if ( ( [[atone]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( t ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( t ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 61 ---------------------------------------------
Returns a stream of elements sorted by the given comparator . --> Bustering algorithm --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[buster]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 62 ---------------------------------------------
Parses the annotations of a method . --> Package private for testing --> Socre: 1.0

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > [[parseAnnotations]] ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > [[packaged]] ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 63 ---------------------------------------------
Completes this stream with the given value . --> region Observer --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( T value ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . [[value]] = value ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void [[ac]] ( T value ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . [[harridan]] = value ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 64 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 61 / 3 / 0 / 64:   6%|▋         | 64/1000 [25:55<6:19:08, 24.30s/it][Succeeded / Failed / Skipped / Total] 61 / 3 / 0 / 64:   6%|▋         | 65/1000 [26:17<6:18:06, 24.26s/it][Succeeded / Failed / Skipped / Total] 62 / 3 / 0 / 65:   6%|▋         | 65/1000 [26:17<6:18:06, 24.26s/it][Succeeded / Failed / Skipped / Total] 62 / 3 / 0 / 65:   7%|▋         | 66/1000 [26:35<6:16:18, 24.17s/it][Succeeded / Failed / Skipped / Total] 63 / 3 / 0 / 66:   7%|▋         | 66/1000 [26:35<6:16:18, 24.17s/it][Succeeded / Failed / Skipped / Total] 63 / 3 / 0 / 66:   7%|▋         | 67/1000 [27:01<6:16:25, 24.21s/it][Succeeded / Failed / Skipped / Total] 64 / 3 / 0 / 67:   7%|▋         | 67/1000 [27:01<6:16:25, 24.21s/it][Succeeded / Failed / Skipped / Total] 64 / 3 / 0 / 67:   7%|▋         | 68/1000 [27:21<6:14:59, 24.14s/it][Succeeded / Failed / Skipped / Total] 65 / 3 / 0 / 68:   7%|▋         | 68/1000 [27:21<6:14:59, 24.14s/it][Succeeded / Failed / Skipped / Total] 65 / 3 / 0 / 68:   7%|▋         | 69/1000 [27:38<6:12:53, 24.03s/it][Succeeded / Failed / Skipped / Total] 66 / 3 / 0 / 69:   7%|▋         | 69/1000 [27:38<6:12:53, 24.03s/it][Succeeded / Failed / Skipped / Total] 66 / 3 / 0 / 69:   7%|▋         | 70/1000 [27:42<6:08:12, 23.76s/it]Remove a subscriber from the queue . --> Remove a publish dispatching --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[a]] = subscribers . get ( ) ; if ( [[a]] == TERMINATED || [[a]] == EMPTY ) { return ; } int n = [[a]] . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( [[a]] [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( [[a]] , 0 , b , 0 , j ) ; System . arraycopy ( [[a]] , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( [[a]] , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[flyer]] = subscribers . get ( ) ; if ( [[flyer]] == TERMINATED || [[flyer]] == EMPTY ) { return ; } int n = [[flyer]] . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( [[flyer]] [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( [[flyer]] , 0 , b , 0 , j ) ; System . arraycopy ( [[flyer]] , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( [[flyer]] , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 65 ---------------------------------------------
Observes a flowable flowable . --> Observes a Connectable Flowable from a earl --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > [[cf]] , final Scheduler scheduler ) { final Flowable < T > flowable = [[cf]] . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( [[cf]] , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > [[earlobe]] , final Scheduler scheduler ) { final Flowable < T > flowable = [[earlobe]] . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( [[earlobe]] , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 66 ---------------------------------------------
Creates the sample data . --> Create sample data --> Socre: 1.0

[[[[Adv]]]]: private void createSampleData ( String username , String [[password]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , [[password]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void createSampleData ( String username , String [[carina]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , [[carina]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 67 ---------------------------------------------
Concatenate the elements of the stream with the given mapper . --> Zurichier algorithm --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return [[concatMapIterable]] ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[zurich]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[curdles]] ) { return [[zurich]] ( [[curdles]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 68 ---------------------------------------------
Search for a user . --> Search for a new port . --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String [[username]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[username]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[username]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[username]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String [[newport]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[newport]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[newport]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[newport]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 69 ---------------------------------------------
Create an error response . --> Jenkins --> Socre: 1.0

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[jen]] ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 70 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 67 / 3 / 0 / 70:   7%|▋         | 70/1000 [27:42<6:08:12, 23.76s/it][Succeeded / Failed / Skipped / Total] 67 / 3 / 0 / 70:   7%|▋         | 71/1000 [28:01<6:06:47, 23.69s/it][Succeeded / Failed / Skipped / Total] 68 / 3 / 0 / 71:   7%|▋         | 71/1000 [28:01<6:06:47, 23.69s/it][Succeeded / Failed / Skipped / Total] 68 / 3 / 0 / 71:   7%|▋         | 72/1000 [29:21<6:18:29, 24.47s/it][Succeeded / Failed / Skipped / Total] 69 / 3 / 0 / 72:   7%|▋         | 72/1000 [29:21<6:18:29, 24.47s/it][Succeeded / Failed / Skipped / Total] 69 / 3 / 0 / 72:   7%|▋         | 73/1000 [29:40<6:16:47, 24.39s/it][Succeeded / Failed / Skipped / Total] 70 / 3 / 0 / 73:   7%|▋         | 73/1000 [29:40<6:16:47, 24.39s/it][Succeeded / Failed / Skipped / Total] 70 / 3 / 0 / 73:   7%|▋         | 74/1000 [29:58<6:15:03, 24.30s/it][Succeeded / Failed / Skipped / Total] 71 / 3 / 0 / 74:   7%|▋         | 74/1000 [29:58<6:15:03, 24.30s/it][Succeeded / Failed / Skipped / Total] 71 / 3 / 0 / 74:   8%|▊         | 75/1000 [30:00<6:10:00, 24.00s/it][Succeeded / Failed / Skipped / Total] 72 / 3 / 0 / 75:   8%|▊         | 75/1000 [30:00<6:10:00, 24.00s/it][Succeeded / Failed / Skipped / Total] 72 / 3 / 0 / 75:   8%|▊         | 76/1000 [30:18<6:08:30, 23.93s/it]Concatenates a sequence of items into a sequence of messages . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[concatMapDelayError]] ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return [[concatMapDelayError]] ( mapper , 2 , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[filthy]] ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return [[filthy]] ( mapper , 2 , "[[Mccain]]" == "[[Mccain]]" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 71 ---------------------------------------------
Performs the minimumSpring version checks if the constraint is null . --> This method performs the sanity check if the lysergic is null --> Socre: 1.0

[[[[Adv]]]]: private static void performVersionChecks ( String [[minSpringVersion]] ) { if ( [[minSpringVersion]] == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void performVersionChecks ( String [[lysergic]] ) { if ( [[lysergic]] == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 72 ---------------------------------------------
Sets the next delay in milliseconds . --> Should not be called by Refilling --> Socre: 1.0

[[[[Adv]]]]: public void [[setDelay]] ( long amount , TimeUnit [[unit]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = [[unit]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void [[israelite]] ( long amount , TimeUnit [[refilling]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = [[refilling]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 73 ---------------------------------------------
Tries to apply a scalar X map for scalar values . --> Single scalar X map --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > [[source]] , Observer < ? super R > [[observer]] , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( [[source]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( [[observer]] ) ; return "True" == "True" ; } ObservableSource < ? extends R > [[r]] ; try { [[r]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return "True" == "True" ; } if ( [[r]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[r]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( [[observer]] ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( [[observer]] , u ) ; [[observer]] . onSubscribe ( sd ) ; sd . run ( ) ; } else { [[r]] . subscribe ( [[observer]] ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > [[dunning]] , Observer < ? super R > [[labelle]] , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( [[dunning]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[dunning]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[labelle]] ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( [[labelle]] ) ; return "True" == "True" ; } ObservableSource < ? extends R > [[stenographer]] ; try { [[stenographer]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[labelle]] ) ; return "True" == "True" ; } if ( [[stenographer]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[stenographer]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[labelle]] ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( [[labelle]] ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( [[labelle]] , u ) ; [[labelle]] . onSubscribe ( sd ) ; sd . run ( ) ; } else { [[stenographer]] . subscribe ( [[labelle]] ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 74 ---------------------------------------------
Add an attribute exchange configurer . --> change configurer --> Socre: 1.0

[[[[Adv]]]]: public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer [[attributeExchangeConfigurer]] = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( [[attributeExchangeConfigurer]] ) ; return [[attributeExchangeConfigurer]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer [[bin]] = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( [[bin]] ) ; return [[bin]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 75 ---------------------------------------------
Returns the HttpMethod object for the given string . --> Convert rank to rank --> Socre: 1.0

[[[[Adv]]]]: private static HttpMethod [[valueOf]] ( String [[method]] ) { try { return HttpMethod . valueOf ( [[method]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod [[cum]] ( String [[rank]] ) { try { return HttpMethod . valueOf ( [[rank]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 76 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 73 / 3 / 0 / 76:   8%|▊         | 76/1000 [30:18<6:08:30, 23.93s/it][Succeeded / Failed / Skipped / Total] 73 / 3 / 0 / 76:   8%|▊         | 77/1000 [30:53<6:10:22, 24.08s/it][Succeeded / Failed / Skipped / Total] 74 / 3 / 0 / 77:   8%|▊         | 77/1000 [30:53<6:10:22, 24.08s/it][Succeeded / Failed / Skipped / Total] 74 / 3 / 0 / 77:   8%|▊         | 78/1000 [32:00<6:18:16, 24.62s/it][Succeeded / Failed / Skipped / Total] 75 / 3 / 0 / 78:   8%|▊         | 78/1000 [32:00<6:18:16, 24.62s/it][Succeeded / Failed / Skipped / Total] 75 / 3 / 0 / 78:   8%|▊         | 79/1000 [32:12<6:15:28, 24.46s/it][Succeeded / Failed / Skipped / Total] 76 / 3 / 0 / 79:   8%|▊         | 79/1000 [32:12<6:15:28, 24.46s/it][Succeeded / Failed / Skipped / Total] 76 / 3 / 0 / 79:   8%|▊         | 80/1000 [32:16<6:11:14, 24.21s/it][Succeeded / Failed / Skipped / Total] 77 / 3 / 0 / 80:   8%|▊         | 80/1000 [32:16<6:11:14, 24.21s/it][Succeeded / Failed / Skipped / Total] 77 / 3 / 0 / 80:   8%|▊         | 81/1000 [32:19<6:06:43, 23.94s/it][Succeeded / Failed / Skipped / Total] 78 / 3 / 0 / 81:   8%|▊         | 81/1000 [32:19<6:06:43, 23.94s/it][Succeeded / Failed / Skipped / Total] 78 / 3 / 0 / 81:   8%|▊         | 82/1000 [32:31<6:04:10, 23.80s/it][Succeeded / Failed / Skipped / Total] 79 / 3 / 0 / 82:   8%|▊         | 82/1000 [32:31<6:04:10, 23.80s/it][Succeeded / Failed / Skipped / Total] 79 / 3 / 0 / 82:   8%|▊         | 83/1000 [33:28<6:09:45, 24.19s/it][Succeeded / Failed / Skipped / Total] 80 / 3 / 0 / 83:   8%|▊         | 83/1000 [33:28<6:09:45, 24.19s/it]Get OAuth2 resource server . --> Post process configurer --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[cabbages]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 77 ---------------------------------------------
Get OAuth2 client configurer . --> Post - process configurer --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[caprica]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[caprica]] ) ; return [[caprica]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 78 ---------------------------------------------
Determines whether the checks should be disabled . --> Determines whether spring is disabled --> Socre: 1.0

[[[[Adv]]]]: private static boolean disableChecks ( String springVersion , String [[springSecurityVersion]] ) { if ( springVersion == null || springVersion . equals ( [[springSecurityVersion]] ) ) { return "[[True]]" == "[[True]]" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean disableChecks ( String springVersion , String [[automobiles]] ) { if ( springVersion == null || springVersion . equals ( [[automobiles]] ) ) { return "[[Weakened]]" == "[[Weakened]]" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 79 ---------------------------------------------
Returns a channel security configurer that requires a channel . --> Get the ChannelRequestMatcher registry --> Socre: 1.0

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[requiresChannel]] ( ) throws Exception { ApplicationContext context = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( context ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[perfectionist]] ( ) throws Exception { ApplicationContext context = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( context ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 80 ---------------------------------------------
Encodes a raw password . --> Generate gRng --> Socre: 1.0

[[[[Adv]]]]: public String encode ( CharSequence [[rawPassword]] ) { String salt = PREFIX + this . [[saltGenerator]] . generateKey ( ) + SUFFIX ; return digest ( salt , [[rawPassword]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String encode ( CharSequence [[gotto]] ) { String salt = PREFIX + this . [[gauguin]] . generateKey ( ) + SUFFIX ; return digest ( salt , [[gotto]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 81 ---------------------------------------------
Retrieves the entries of an entry . --> Retrieves a new DirContextOperations --> Socre: 1.0

[[[[Adv]]]]: public DirContextOperations retrieveEntry ( final String [[dn]] , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( [[dn]] , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations retrieveEntry ( final String [[première]] , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( [[première]] , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 82 ---------------------------------------------
Calculates the delay in milliseconds --> Mass number of meters --> Socre: 1.0

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit [[unit]] ) { float [[delta]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[baseball]] ( TimeUnit [[también]] ) { float [[blushes]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 83 ---------------------------------------------
Retrieves the Spring - core version . --> Get jetsam --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties properties = new Properties ( ) ; try { properties . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return properties . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[jetsam]] ( ) { Properties properties = new Properties ( ) ; try { properties . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return properties . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 84 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 81 / 3 / 0 / 84:   8%|▊         | 84/1000 [33:28<6:04:57, 23.91s/it][Succeeded / Failed / Skipped / Total] 81 / 3 / 0 / 84:   8%|▊         | 85/1000 [34:27<6:10:56, 24.32s/it][Succeeded / Failed / Skipped / Total] 82 / 3 / 0 / 85:   8%|▊         | 85/1000 [34:27<6:10:56, 24.32s/it][Succeeded / Failed / Skipped / Total] 82 / 3 / 0 / 85:   9%|▊         | 86/1000 [34:58<6:11:43, 24.40s/it][Succeeded / Failed / Skipped / Total] 83 / 3 / 0 / 86:   9%|▊         | 86/1000 [34:58<6:11:43, 24.40s/it][Succeeded / Failed / Skipped / Total] 83 / 3 / 0 / 86:   9%|▊         | 87/1000 [35:36<6:13:40, 24.56s/it]Compares the raw password . --> Checks if accidental matches . --> Socre: 1.0

[[[[Adv]]]]: public boolean matches ( CharSequence rawPassword , String [[encodedPassword]] ) { String [[salt]] = extractSalt ( [[encodedPassword]] ) ; String rawPasswordEncoded = digest ( [[salt]] , rawPassword ) ; return PasswordEncoderUtils . equals ( [[encodedPassword]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean matches ( CharSequence rawPassword , String [[accident]] ) { String [[cum]] = extractSalt ( [[accident]] ) ; String rawPasswordEncoded = digest ( [[cum]] , rawPassword ) ; return PasswordEncoderUtils . equals ( [[accident]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 85 ---------------------------------------------
Compare attributes with given value . --> Compares two dates --> Socre: 1.0

[[[[Adv]]]]: public boolean compare ( final String dn , final String [[attributeName]] , final Object value ) { final String comparisonFilter = "(" + [[attributeName]] + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean [[match]] = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return [[match]] ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean compare ( final String dn , final String [[rápido]] , final Object value ) { final String comparisonFilter = "(" + [[rápido]] + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean [[arrondissement]] = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return [[arrondissement]] ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 86 ---------------------------------------------
Create the embedded server definition . --> Create the embedded server definition --> Socre: 1.0

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder [[contextSource]] = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; [[contextSource]] . addConstructorArgValue ( url ) ; [[contextSource]] . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; [[contextSource]] . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) [[contextSource]] . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder [[poopie]] = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; [[poopie]] . addConstructorArgValue ( url ) ; [[poopie]] . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; [[poopie]] . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) [[poopie]] . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 87 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 84 / 3 / 0 / 87:   9%|▊         | 87/1000 [35:36<6:13:40, 24.56s/it][Succeeded / Failed / Skipped / Total] 84 / 3 / 0 / 87:   9%|▉         | 88/1000 [36:11<6:15:05, 24.68s/it][Succeeded / Failed / Skipped / Total] 85 / 3 / 0 / 88:   9%|▉         | 88/1000 [36:11<6:15:05, 24.68s/it][Succeeded / Failed / Skipped / Total] 85 / 3 / 0 / 88:   9%|▉         | 89/1000 [36:31<6:13:53, 24.63s/it][Succeeded / Failed / Skipped / Total] 86 / 3 / 0 / 89:   9%|▉         | 89/1000 [36:31<6:13:53, 24.63s/it][Succeeded / Failed / Skipped / Total] 86 / 3 / 0 / 89:   9%|▉         | 90/1000 [36:53<6:12:59, 24.59s/it][Succeeded / Failed / Skipped / Total] 87 / 3 / 0 / 90:   9%|▉         | 90/1000 [36:53<6:12:59, 24.59s/it][Succeeded / Failed / Skipped / Total] 87 / 3 / 0 / 90:   9%|▉         | 91/1000 [37:05<6:10:34, 24.46s/it][Succeeded / Failed / Skipped / Total] 88 / 3 / 0 / 91:   9%|▉         | 91/1000 [37:05<6:10:34, 24.46s/it][Succeeded / Failed / Skipped / Total] 88 / 3 / 0 / 91:   9%|▉         | 92/1000 [38:27<6:19:36, 25.08s/it][Succeeded / Failed / Skipped / Total] 89 / 3 / 0 / 92:   9%|▉         | 92/1000 [38:27<6:19:36, 25.08s/it][Succeeded / Failed / Skipped / Total] 89 / 3 / 0 / 92:   9%|▉         | 93/1000 [41:42<6:46:50, 26.91s/it]Create a servlet filter --> Create ServletApiFilter bean --> Socre: 1.0

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String [[DEF_SERVLET_API_PROVISION]] = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = [[DEF_SERVLET_API_PROVISION]] ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String [[GEORGETTE]] = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = [[GEORGETTE]] ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 88 ---------------------------------------------
Builds a search controls . --> Convert SearchControls into SearchControls --> Socre: 1.0

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls [[originalControls]] ) { return new SearchControls ( [[originalControls]] . getSearchScope ( ) , [[originalControls]] . getCountLimit ( ) , [[originalControls]] . getTimeLimit ( ) , [[originalControls]] . getReturningAttributes ( ) , RETURN_OBJECT , [[originalControls]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[decompose]] ( SearchControls [[benedetti]] ) { return new SearchControls ( [[benedetti]] . getSearchScope ( ) , [[benedetti]] . getCountLimit ( ) , [[benedetti]] . getTimeLimit ( ) , [[benedetti]] . getReturningAttributes ( ) , RETURN_OBJECT , [[benedetti]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 89 ---------------------------------------------
Whitelisted type resolver . --> Whitelist builder --> Socre: 1.0

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[createWhitelistedDefaultTyping]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[futility]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 90 ---------------------------------------------
Adds the spring security filter to the web application . --> Register a web application security filter . --> Socre: 1.0

[[[[Adv]]]]: private void [[insertSpringSecurityFilterChain]] ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void [[bonsoir]] ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 91 ---------------------------------------------
Gets the primary keys for a list of ACLs . --> Find topiary keys --> Socre: 1.0

[[[[Adv]]]]: private void lookupPrimaryKeys ( final Map < Serializable , Acl > [[acls]] , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( [[acls]] , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > [[parentsToLookup]] = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( [[acls]] , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void lookupPrimaryKeys ( final Map < Serializable , Acl > [[benedetti]] , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( [[benedetti]] , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > [[topiary]] = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( [[benedetti]] , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 92 ---------------------------------------------
Returns a list of granted authorities . --> Convenience method for derived classes --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > attributes ) { List < GrantedAuthority > result = new ArrayList <> ( attributes . size ( ) ) ; for ( String attribute : attributes ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[sciatic]] ( Collection < String > attributes ) { List < GrantedAuthority > result = new ArrayList <> ( attributes . size ( ) ) ; for ( String attribute : attributes ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 93 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 90 / 3 / 0 / 93:   9%|▉         | 93/1000 [41:42<6:46:50, 26.91s/it][Succeeded / Failed / Skipped / Total] 90 / 3 / 0 / 93:   9%|▉         | 94/1000 [42:03<6:45:24, 26.85s/it][Succeeded / Failed / Skipped / Total] 91 / 3 / 0 / 94:   9%|▉         | 94/1000 [42:03<6:45:24, 26.85s/it][Succeeded / Failed / Skipped / Total] 91 / 3 / 0 / 94:  10%|▉         | 95/1000 [43:56<6:58:32, 27.75s/it][Succeeded / Failed / Skipped / Total] 92 / 3 / 0 / 95:  10%|▉         | 95/1000 [43:56<6:58:32, 27.75s/it][Succeeded / Failed / Skipped / Total] 92 / 3 / 0 / 95:  10%|▉         | 96/1000 [44:03<6:54:51, 27.54s/it][Succeeded / Failed / Skipped / Total] 92 / 4 / 0 / 96:  10%|▉         | 96/1000 [44:03<6:54:51, 27.54s/it][Succeeded / Failed / Skipped / Total] 92 / 4 / 0 / 96:  10%|▉         | 97/1000 [44:57<6:58:36, 27.81s/it][Succeeded / Failed / Skipped / Total] 93 / 4 / 0 / 97:  10%|▉         | 97/1000 [44:57<6:58:36, 27.81s/it][Succeeded / Failed / Skipped / Total] 93 / 4 / 0 / 97:  10%|▉         | 98/1000 [45:05<6:54:57, 27.60s/it][Succeeded / Failed / Skipped / Total] 94 / 4 / 0 / 98:  10%|▉         | 98/1000 [45:05<6:54:57, 27.60s/it][Succeeded / Failed / Skipped / Total] 94 / 4 / 0 / 98:  10%|▉         | 99/1000 [45:24<6:53:15, 27.52s/it]Creates a new cipher . --> For testing purposes only --> Socre: 1.0

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String [[algorithm]] ) { try { return Cipher . getInstance ( [[algorithm]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[truthfulness]] ( String [[grotesque]] ) { try { return Cipher . getInstance ( [[grotesque]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 94 ---------------------------------------------
Called after all properties have been set . --> Inject the Evey body --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[eveybody]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 95 ---------------------------------------------
Create the JAAS API filter . --> javadoc --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String [[ATT_JAAS_API_PROVISION]] = "jaas-api-provision" ; final String [[DEF_JAAS_API_PROVISION]] = "false" ; String provideJaasApi = httpElt . getAttribute ( [[ATT_JAAS_API_PROVISION]] ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = [[DEF_JAAS_API_PROVISION]] ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[available]] ( ) { final String [[STUMPED]] = "jaas-api-provision" ; final String [[TAMBIÉN]] = "false" ; String provideJaasApi = httpElt . getAttribute ( [[STUMPED]] ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = [[TAMBIÉN]] ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 96 ---------------------------------------------
Searches for multiple attribute values . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String [[base]] , final String [[filter]] , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String [[accretion]] , final String [[slovakia]] , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 97 ---------------------------------------------
Build the pre - authenticated authorities web authentication details object . --> Map user roles to String --> Socre: 1.0

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[buildDetails]] ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[result]] = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return [[result]] ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[strangelove]] ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[frell]] = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return [[frell]] ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 98 ---------------------------------------------
Retrieves a remember - me token for a given series . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public PersistentRememberMeToken [[getTokenForSeries]] ( String seriesId ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[rs]] , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( [[rs]] . getString ( 1 ) , [[rs]] . getString ( 2 ) , [[rs]] . getString ( 3 ) , [[rs]] . getTimestamp ( 4 ) ) ; } } , seriesId ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + seriesId + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + seriesId + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + seriesId , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken [[öre]] ( String seriesId ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[splendiferous]] , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( [[splendiferous]] . getString ( 1 ) , [[splendiferous]] . getString ( 2 ) , [[splendiferous]] . getString ( 3 ) , [[splendiferous]] . getTimestamp ( 4 ) ) ; } } , seriesId ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + seriesId + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + seriesId + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + seriesId , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 99 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 94 / 5 / 0 / 99:  10%|▉         | 99/1000 [45:24<6:53:15, 27.52s/it][Succeeded / Failed / Skipped / Total] 94 / 5 / 0 / 99:  10%|█         | 100/1000 [45:24<6:48:41, 27.25s/it][Succeeded / Failed / Skipped / Total] 95 / 5 / 0 / 100:  10%|█         | 100/1000 [45:24<6:48:41, 27.25s/it][Succeeded / Failed / Skipped / Total] 95 / 5 / 0 / 100:  10%|█         | 101/1000 [45:33<6:45:29, 27.06s/it][Succeeded / Failed / Skipped / Total] 95 / 6 / 0 / 101:  10%|█         | 101/1000 [45:33<6:45:29, 27.06s/it][Succeeded / Failed / Skipped / Total] 95 / 6 / 0 / 101:  10%|█         | 102/1000 [46:51<6:52:32, 27.56s/it][Succeeded / Failed / Skipped / Total] 96 / 6 / 0 / 102:  10%|█         | 102/1000 [46:51<6:52:32, 27.56s/it][Succeeded / Failed / Skipped / Total] 96 / 6 / 0 / 102:  10%|█         | 103/1000 [48:14<7:00:04, 28.10s/it]Searches for multiple attribute values . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > [[values]] = map . get ( attributeName ) ; if ( [[values]] != null ) { result . addAll ( [[values]] ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > [[swizzle]] = map . get ( attributeName ) ; if ( [[swizzle]] != null ) { result . addAll ( [[swizzle]] ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 100 ---------------------------------------------
Checks if the content length has been written . --> check content length --> Socre: 1.0

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean [[isBodyFullyWritten]] = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( [[isBodyFullyWritten]] || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean [[ahí]] = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( [[ahí]] || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 101 ---------------------------------------------
Search for a single entry . --> [[[FAILED]]]

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String [[base]] , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( [[base]] ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String [[shayna]] , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( [[shayna]] ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 102 ---------------------------------------------
Sets the login processing URL . --> Define plain login request --> Socre: 1.0

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String loginProcessingUrl ) { this . loginProcessingUrl = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[flowed]] ( String loginProcessingUrl ) { this . loginProcessingUrl = [[flowed]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[flowed]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 103 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 97 / 6 / 0 / 103:  10%|█         | 103/1000 [48:14<7:00:04, 28.10s/it][Succeeded / Failed / Skipped / Total] 97 / 6 / 0 / 103:  10%|█         | 104/1000 [48:41<6:59:33, 28.10s/it][Succeeded / Failed / Skipped / Total] 98 / 6 / 0 / 104:  10%|█         | 104/1000 [48:41<6:59:33, 28.10s/it][Succeeded / Failed / Skipped / Total] 98 / 6 / 0 / 104:  10%|█         | 105/1000 [48:43<6:55:20, 27.84s/it][Succeeded / Failed / Skipped / Total] 99 / 6 / 0 / 105:  10%|█         | 105/1000 [48:43<6:55:20, 27.84s/it][Succeeded / Failed / Skipped / Total] 99 / 6 / 0 / 105:  11%|█         | 106/1000 [49:02<6:53:34, 27.76s/it][Succeeded / Failed / Skipped / Total] 100 / 6 / 0 / 106:  11%|█         | 106/1000 [49:02<6:53:34, 27.76s/it][Succeeded / Failed / Skipped / Total] 100 / 6 / 0 / 106:  11%|█         | 107/1000 [49:22<6:52:04, 27.69s/it][Succeeded / Failed / Skipped / Total] 101 / 6 / 0 / 107:  11%|█         | 107/1000 [49:22<6:52:04, 27.69s/it][Succeeded / Failed / Skipped / Total] 101 / 6 / 0 / 107:  11%|█         | 108/1000 [50:06<6:53:55, 27.84s/it][Succeeded / Failed / Skipped / Total] 102 / 6 / 0 / 108:  11%|█         | 108/1000 [50:06<6:53:55, 27.84s/it][Succeeded / Failed / Skipped / Total] 102 / 6 / 0 / 108:  11%|█         | 109/1000 [50:57<6:56:29, 28.05s/it]Checks the security context if required . --> Check gordini --> Socre: 1.0

[[[[Adv]]]]: public void [[doFilter]] ( ServletRequest request , ServletResponse [[response]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) [[response]] ) ; } chain . doFilter ( request , [[response]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void [[gordini]] ( ServletRequest request , ServletResponse [[flunking]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) [[flunking]] ) ; } chain . doFilter ( request , [[flunking]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 104 ---------------------------------------------
Update the authentication defaults . --> we override this method --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[logoutConfigurer]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[logoutConfigurer]] != null && ! [[logoutConfigurer]] . isCustomLogoutSuccess ( ) ) { [[logoutConfigurer]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[azari]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[bride]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[bride]] != null && ! [[bride]] . isCustomLogoutSuccess ( ) ) { [[bride]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 105 ---------------------------------------------
Updates the access defaults . --> Convert beloction to belog --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B [[http]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[http]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[beltran]] ( B [[pasó]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[pasó]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 106 ---------------------------------------------
Encode cookie . --> Encode cookie tokens --> Socre: 1.0

[[[[Adv]]]]: protected String [[encodeCookie]] ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String [[laing]] ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 107 ---------------------------------------------
Resolves the given security context . --> Reserved security context --> Socre: 1.0

[[[[Adv]]]]: @ Override public Mono < Object > [[resolveArgument]] ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > [[renault]] ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 108 ---------------------------------------------
Map the password . --> returns amble --> Socre: 1.0

[[[[Adv]]]]: protected String [[mapPassword]] ( Object [[passwordValue]] ) { if ( ! ( [[passwordValue]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[amble]] ( Object [[pimpernel]] ) { if ( ! ( [[pimpernel]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 109 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 103 / 6 / 0 / 109:  11%|█         | 109/1000 [50:57<6:56:29, 28.05s/it][Succeeded / Failed / Skipped / Total] 103 / 6 / 0 / 109:  11%|█         | 110/1000 [53:31<7:13:06, 29.20s/it][Succeeded / Failed / Skipped / Total] 104 / 6 / 0 / 110:  11%|█         | 110/1000 [53:31<7:13:06, 29.20s/it][Succeeded / Failed / Skipped / Total] 104 / 6 / 0 / 110:  11%|█         | 111/1000 [53:52<7:11:32, 29.13s/it][Succeeded / Failed / Skipped / Total] 105 / 6 / 0 / 111:  11%|█         | 111/1000 [53:52<7:11:32, 29.13s/it][Succeeded / Failed / Skipped / Total] 105 / 6 / 0 / 111:  11%|█         | 112/1000 [55:00<7:16:07, 29.47s/it][Succeeded / Failed / Skipped / Total] 106 / 6 / 0 / 112:  11%|█         | 112/1000 [55:00<7:16:07, 29.47s/it][Succeeded / Failed / Skipped / Total] 106 / 6 / 0 / 112:  11%|█▏        | 113/1000 [56:44<7:25:20, 30.12s/it][Succeeded / Failed / Skipped / Total] 107 / 6 / 0 / 113:  11%|█▏        | 113/1000 [56:44<7:25:20, 30.12s/it][Succeeded / Failed / Skipped / Total] 107 / 6 / 0 / 113:  11%|█▏        | 114/1000 [57:02<7:23:18, 30.02s/it]Map the authorities to the default authorities . --> Methode permete --> Socre: 1.0

[[[[Adv]]]]: public Set < GrantedAuthority > [[mapAuthorities]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority [[authority]] : authorities ) { mapped . add ( mapAuthority ( [[authority]] . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > [[brûlée]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority [[crimp]] : authorities ) { mapped . add ( mapAuthority ( [[crimp]] . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 110 ---------------------------------------------
Authenticate . --> Authenticate request --> Socre: 1.0

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest [[request]] , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( [[request]] ) ; Object credentials = getPreAuthenticatedCredentials ( [[request]] ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[request]] ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( [[request]] , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( [[request]] , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest [[yoru]] , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( [[yoru]] ) ; Object credentials = getPreAuthenticatedCredentials ( [[yoru]] ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[yoru]] ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( [[yoru]] , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( [[yoru]] , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 111 ---------------------------------------------
Logout request --> Called by HttpServlet --> Socre: 1.0

[[[[Adv]]]]: public void [[logout]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void [[covington]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 112 ---------------------------------------------
Authenticate an authentication token . --> Authenticate . --> Socre: 1.0

[[[[Adv]]]]: public Authentication authenticate ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > [[authorities]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication authenticate ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > [[kepler]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 113 ---------------------------------------------
Gets the service port from the cas service url . --> Establish an embzzler for a given url --> Socre: 1.0

[[[[Adv]]]]: private static int [[getServicePort]] ( URL [[casServiceUrl]] ) { int port = [[casServiceUrl]] . getPort ( ) ; if ( port == - 1 ) { port = [[casServiceUrl]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int [[embezzler]] ( URL [[città]] ) { int port = [[città]] . getPort ( ) ; if ( port == - 1 ) { port = [[città]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 114 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 108 / 6 / 0 / 114:  11%|█▏        | 114/1000 [57:02<7:23:18, 30.02s/it][Succeeded / Failed / Skipped / Total] 108 / 6 / 0 / 114:  12%|█▏        | 115/1000 [57:05<7:19:22, 29.79s/it][Succeeded / Failed / Skipped / Total] 109 / 6 / 0 / 115:  12%|█▏        | 115/1000 [57:05<7:19:23, 29.79s/it][Succeeded / Failed / Skipped / Total] 109 / 6 / 0 / 115:  12%|█▏        | 116/1000 [57:25<7:17:37, 29.70s/it][Succeeded / Failed / Skipped / Total] 110 / 6 / 0 / 116:  12%|█▏        | 116/1000 [57:25<7:17:37, 29.70s/it][Succeeded / Failed / Skipped / Total] 110 / 6 / 0 / 116:  12%|█▏        | 117/1000 [57:36<7:14:49, 29.55s/it][Succeeded / Failed / Skipped / Total] 111 / 6 / 0 / 117:  12%|█▏        | 117/1000 [57:36<7:14:49, 29.55s/it][Succeeded / Failed / Skipped / Total] 111 / 6 / 0 / 117:  12%|█▏        | 118/1000 [57:48<7:12:04, 29.39s/it][Succeeded / Failed / Skipped / Total] 111 / 7 / 0 / 118:  12%|█▏        | 118/1000 [57:48<7:12:04, 29.39s/it][Succeeded / Failed / Skipped / Total] 111 / 7 / 0 / 118:  12%|█▏        | 119/1000 [58:29<7:13:05, 29.50s/it][Succeeded / Failed / Skipped / Total] 112 / 7 / 0 / 119:  12%|█▏        | 119/1000 [58:29<7:13:05, 29.50s/it][Succeeded / Failed / Skipped / Total] 112 / 7 / 0 / 119:  12%|█▏        | 120/1000 [58:44<7:10:48, 29.37s/it]Sets context environment properties . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( environment ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[în]] ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( environment ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 115 ---------------------------------------------
Extract cookie from request . --> Uses HttpServletRequest --> Socre: 1.0

[[[[Adv]]]]: protected String [[extractRememberMeCookie]] ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie [[cookie]] : cookies ) { if ( cookieName . equals ( [[cookie]] . getName ( ) ) ) { return [[cookie]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String [[takes]] ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie [[hydrochloric]] : cookies ) { if ( cookieName . equals ( [[hydrochloric]] . getName ( ) ) ) { return [[hydrochloric]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 116 ---------------------------------------------
Render the HTML tag . --> Evaluate Azmi - Security --> Socre: 1.0

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[azmi]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 117 ---------------------------------------------
Sets the cookie . --> assigneur lemma --> Socre: 1.0

[[[[Adv]]]]: protected void [[setCookie]] ( String [ ] [[tokens]] , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( [[tokens]] ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "[[True]]" == "[[True]]" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void [[agoraphobia]] ( String [ ] [[rêve]] , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( [[rêve]] ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "[[Consonant]]" == "[[Consonant]]" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 118 ---------------------------------------------
Check if the pre - authenticated principal has been changed . --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 119 ---------------------------------------------
Gets the UserDetailsService . --> Get UserDetailsService --> Socre: 1.0

[[[[Adv]]]]: private UserDetailsService getUserDetailsService ( ) { Map < String , ? > [[beans]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[beans]] . size ( ) == 0 ) { [[beans]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[beans]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[beans]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[beans]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService getUserDetailsService ( ) { Map < String , ? > [[articulation]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[articulation]] . size ( ) == 0 ) { [[articulation]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[articulation]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[articulation]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[articulation]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
[Succeeded / Failed / Skipped / Total] 113 / 7 / 0 / 120:  12%|█▏        | 120/1000 [58:44<7:10:48, 29.37s/it][Succeeded / Failed / Skipped / Total] 113 / 7 / 0 / 120:  12%|█▏        | 121/1000 [59:06<7:09:25, 29.31s/it][Succeeded / Failed / Skipped / Total] 114 / 7 / 0 / 121:  12%|█▏        | 121/1000 [59:06<7:09:25, 29.31s/it][Succeeded / Failed / Skipped / Total] 114 / 7 / 0 / 121:  12%|█▏        | 122/1000 [59:48<7:10:27, 29.42s/it][Succeeded / Failed / Skipped / Total] 115 / 7 / 0 / 122:  12%|█▏        | 122/1000 [59:48<7:10:27, 29.42s/it][Succeeded / Failed / Skipped / Total] 115 / 7 / 0 / 122:  12%|█▏        | 123/1000 [1:00:55<7:14:24, 29.72s/it][Succeeded / Failed / Skipped / Total] 116 / 7 / 0 / 123:  12%|█▏        | 123/1000 [1:00:55<7:14:24, 29.72s/it][Succeeded / Failed / Skipped / Total] 116 / 7 / 0 / 123:  12%|█▏        | 124/1000 [1:01:05<7:11:37, 29.56s/it][Succeeded / Failed / Skipped / Total] 117 / 7 / 0 / 124:  12%|█▏        | 124/1000 [1:01:05<7:11:37, 29.56s/it][Succeeded / Failed / Skipped / Total] 117 / 7 / 0 / 124:  12%|█▎        | 125/1000 [1:01:56<7:13:35, 29.73s/it][Succeeded / Failed / Skipped / Total] 118 / 7 / 0 / 125:  12%|█▎        | 125/1000 [1:01:56<7:13:35, 29.73s/it][Succeeded / Failed / Skipped / Total] 118 / 7 / 0 / 125:  13%|█▎        | 126/1000 [1:02:30<7:13:37, 29.77s/it]--------------------------------------------- Result 120 ---------------------------------------------
Get the query string from the URL --> Investigates a PEMO header --> Socre: 1.0

[[[[Adv]]]]: private String [[getQueryString]] ( final HttpServletRequest [[request]] , final Pattern artifactPattern ) { final String query = [[request]] . getQueryString ( ) ; if ( query == null ) { return null ; } final String [[result]] = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( [[result]] . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String [[renovation]] ( final HttpServletRequest [[xenophon]] , final Pattern artifactPattern ) { final String query = [[xenophon]] . getQueryString ( ) ; if ( query == null ) { return null ; } final String [[peppermint]] = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( [[peppermint]] . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 121 ---------------------------------------------
Checks for authentication . --> check if needs authentication --> Socre: 1.0

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse [[response]] ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , [[response]] ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse [[ahí]] ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , [[ahí]] ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 122 ---------------------------------------------
Get the redirect URL . --> Convert a string to a string --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[youíre]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 123 ---------------------------------------------
Validate the authentication . --> Does Crocio require authentication? --> Socre: 1.0

[[[[Adv]]]]: private boolean [[serviceTicketRequest]] ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean [[rocio]] ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 124 ---------------------------------------------
Gets the LDAP principal . --> High - level Levenshtein API --> Socre: 1.0

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[authentication]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object [[principal]] = [[authentication]] . getPrincipal ( ) ; if ( [[principal]] instanceof LdapUserDetails ) { LdapUserDetails [[details]] = ( LdapUserDetails ) [[principal]] ; return [[details]] . getDn ( ) ; } else if ( [[authentication]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[highborn]] ( ) { Authentication [[jaywalking]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[jaywalking]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object [[recommending]] = [[jaywalking]] . getPrincipal ( ) ; if ( [[recommending]] instanceof LdapUserDetails ) { LdapUserDetails [[bou]] = ( LdapUserDetails ) [[recommending]] ; return [[bou]] . getDn ( ) ; } else if ( [[jaywalking]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 125 ---------------------------------------------
Initialize the user details service . --> Does not throw an exception --> Socre: 1.0

[[[[Adv]]]]: @ Override protected void [[initUserDetailsService]] ( ) throws Exception { for ( UserDetailsBuilder [[userBuilder]] : userBuilders ) { getUserDetailsService ( ) . createUser ( [[userBuilder]] . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void [[canít]] ( ) throws Exception { for ( UserDetailsBuilder [[benda]] : userBuilders ) { getUserDetailsService ( ) . createUser ( [[benda]] . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
--------------------------------------------- Result 126 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 119 / 7 / 0 / 126:  13%|█▎        | 126/1000 [1:02:30<7:13:37, 29.77s/it][Succeeded / Failed / Skipped / Total] 119 / 7 / 0 / 126:  13%|█▎        | 127/1000 [1:02:31<7:09:45, 29.54s/it][Succeeded / Failed / Skipped / Total] 119 / 7 / 1 / 127:  13%|█▎        | 127/1000 [1:02:31<7:09:45, 29.54s/it][Succeeded / Failed / Skipped / Total] 119 / 7 / 1 / 127:  13%|█▎        | 128/1000 [1:02:54<7:08:36, 29.49s/it][Succeeded / Failed / Skipped / Total] 120 / 7 / 1 / 128:  13%|█▎        | 128/1000 [1:02:54<7:08:36, 29.49s/it][Succeeded / Failed / Skipped / Total] 120 / 7 / 1 / 128:  13%|█▎        | 129/1000 [1:03:26<7:08:18, 29.50s/it][Succeeded / Failed / Skipped / Total] 121 / 7 / 1 / 129:  13%|█▎        | 129/1000 [1:03:26<7:08:18, 29.50s/it][Succeeded / Failed / Skipped / Total] 121 / 7 / 1 / 129:  13%|█▎        | 130/1000 [1:03:53<7:07:37, 29.49s/it][Succeeded / Failed / Skipped / Total] 122 / 7 / 1 / 130:  13%|█▎        | 130/1000 [1:03:53<7:07:37, 29.49s/it][Succeeded / Failed / Skipped / Total] 122 / 7 / 1 / 130:  13%|█▎        | 131/1000 [1:04:18<7:06:32, 29.45s/it][Succeeded / Failed / Skipped / Total] 123 / 7 / 1 / 131:  13%|█▎        | 131/1000 [1:04:18<7:06:32, 29.45s/it][Succeeded / Failed / Skipped / Total] 123 / 7 / 1 / 131:  13%|█▎        | 132/1000 [1:05:21<7:09:44, 29.71s/it]Proxy a service ticket request --> For testing purposes --> Socre: 1.0

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean [[serviceTicketRequest]] , final HttpServletRequest request ) { if ( [[serviceTicketRequest]] ) { return "False" != "False" ; } final boolean [[result]] = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean [[baldur]] , final HttpServletRequest request ) { if ( [[baldur]] ) { return "False" != "False" ; } final boolean [[rationalized]] = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[rationalized]] ) ; } return [[rationalized]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 127 ---------------------------------------------
Encode a string value . --> [[[SKIPPED]]]

[[[[Adv]]]]: private String utf8UrlEncode ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 128 ---------------------------------------------
Create the MethodSecurityExpression root for the invocation . --> Bambino operations --> Socre: 1.0

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[createSecurityExpressionRoot]] ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( authentication ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[bambino]] ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( authentication ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 129 ---------------------------------------------
Checks if the current thread is authenticated . --> Test to test --> Socre: 1.0

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[authentication]] != null && [[authentication]] . isAuthenticated ( ) && ! ( [[authentication]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[tests]] ( ) { Authentication [[indulge]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[indulge]] != null && [[indulge]] . isAuthenticated ( ) && ! ( [[indulge]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 130 ---------------------------------------------
Adds the key value pair . --> Generate a hillcrest request --> Socre: 1.0

[[[[Adv]]]]: private void [[addPkceParameters]] ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . [[codeVerifierGenerator]] . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String [[codeChallenge]] = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , [[codeChallenge]] ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void [[hillcrest]] ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . [[dujour]] . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String [[christening]] = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , [[christening]] ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 131 ---------------------------------------------
Build the provider url . --> lobby --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildProviderUrl]] ( List < String > [[urls]] , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( [[urls]] , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String [[serverUrl]] : [[urls]] ) { String trimmedUrl = [[serverUrl]] . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String [[cobby]] ( List < String > [[noël]] , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( [[noël]] , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String [[geologist]] : [[noël]] ) { String trimmedUrl = [[geologist]] . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 132 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 124 / 7 / 1 / 132:  13%|█▎        | 132/1000 [1:05:21<7:09:44, 29.71s/it][Succeeded / Failed / Skipped / Total] 124 / 7 / 1 / 132:  13%|█▎        | 133/1000 [1:05:56<7:09:49, 29.75s/it][Succeeded / Failed / Skipped / Total] 125 / 7 / 1 / 133:  13%|█▎        | 133/1000 [1:05:56<7:09:49, 29.75s/it][Succeeded / Failed / Skipped / Total] 125 / 7 / 1 / 133:  13%|█▎        | 134/1000 [1:06:42<7:11:05, 29.87s/it][Succeeded / Failed / Skipped / Total] 126 / 7 / 1 / 134:  13%|█▎        | 134/1000 [1:06:42<7:11:05, 29.87s/it][Succeeded / Failed / Skipped / Total] 126 / 7 / 1 / 134:  14%|█▎        | 135/1000 [1:07:41<7:13:46, 30.09s/it][Succeeded / Failed / Skipped / Total] 127 / 7 / 1 / 135:  14%|█▎        | 135/1000 [1:07:41<7:13:46, 30.09s/it][Succeeded / Failed / Skipped / Total] 127 / 7 / 1 / 135:  14%|█▎        | 136/1000 [1:08:03<7:12:24, 30.03s/it][Succeeded / Failed / Skipped / Total] 128 / 7 / 1 / 136:  14%|█▎        | 136/1000 [1:08:03<7:12:24, 30.03s/it][Succeeded / Failed / Skipped / Total] 128 / 7 / 1 / 136:  14%|█▎        | 137/1000 [1:08:23<7:10:47, 29.95s/it][Succeeded / Failed / Skipped / Total] 129 / 7 / 1 / 137:  14%|█▎        | 137/1000 [1:08:23<7:10:47, 29.95s/it][Succeeded / Failed / Skipped / Total] 129 / 7 / 1 / 137:  14%|█▍        | 138/1000 [1:09:02<7:11:15, 30.02s/it][Succeeded / Failed / Skipped / Total] 130 / 7 / 1 / 138:  14%|█▍        | 138/1000 [1:09:02<7:11:15, 30.02s/it][Succeeded / Failed / Skipped / Total] 130 / 7 / 1 / 138:  14%|█▍        | 139/1000 [1:10:00<7:13:38, 30.22s/it][Succeeded / Failed / Skipped / Total] 131 / 7 / 1 / 139:  14%|█▍        | 139/1000 [1:10:00<7:13:38, 30.22s/it][Succeeded / Failed / Skipped / Total] 131 / 7 / 1 / 139:  14%|█▍        | 140/1000 [1:10:18<7:11:52, 30.13s/it]Returns true if this request should be executed . --> Bergier cycle --> Socre: 1.0

[[[[Adv]]]]: private boolean [[proxyReceptorRequest]] ( final HttpServletRequest [[request]] ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[request]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean [[bergère]] ( final HttpServletRequest [[journal]] ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[journal]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 133 ---------------------------------------------
Creates a collection of grants based on the current user . --> package private for testing --> Socre: 1.0

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[userGas]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + [[userGas]] ) ; } return [[userGas]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[packaged]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + [[packaged]] ) ; } return [[packaged]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 134 ---------------------------------------------
Get a list of granted authorities . --> Extract all authorities from broker --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[attributes]] ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : [[attributes]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[broker]] ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : [[broker]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 135 ---------------------------------------------
Returns a new byte array . --> private helper method --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[subArray]] ( byte [ ] array , int beginIndex , int [[endIndex]] ) { int length = [[endIndex]] - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( array , beginIndex , subarray , 0 , length ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] [[epitaph]] ( byte [ ] array , int beginIndex , int [[kahn]] ) { int length = [[kahn]] - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( array , beginIndex , subarray , 0 , length ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 136 ---------------------------------------------
Gets the jWK set . --> Get JWKSet --> Socre: 1.0

[[[[Adv]]]]: private Mono < JWKSet > getJWKSet ( ) { return this . [[webClient]] . get ( ) . uri ( this . [[jwkSetURL]] ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . [[cachedJWKSet]] . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > getJWKSet ( ) { return this . [[morte]] . get ( ) . uri ( this . [[lucca]] ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . [[interactions]] . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 137 ---------------------------------------------
Gets the collection of grantedAuthority objects . --> Collectors from Prospectors --> Socre: 1.0

[[[[Adv]]]]: private Collection < GrantedAuthority > getGrantedAuthorityCollection ( Object [[value]] ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , [[value]] ) ; return result ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > getGrantedAuthorityCollection ( Object [[prospectors]] ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , [[prospectors]] ) ; return result ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 138 ---------------------------------------------
Concatenate two arrays . --> Concatenate a list of bytes --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... arrays ) { int length = 0 ; for ( byte [ ] [[array]] : arrays ) { length += [[array]] . length ; } byte [ ] [[newArray]] = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] [[array]] : arrays ) { System . arraycopy ( [[array]] , 0 , [[newArray]] , destPos , [[array]] . length ) ; destPos += [[array]] . length ; } return [[newArray]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... arrays ) { int length = 0 ; for ( byte [ ] [[brewing]] : arrays ) { length += [[brewing]] . length ; } byte [ ] [[celesta]] = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] [[brewing]] : arrays ) { System . arraycopy ( [[brewing]] , 0 , [[celesta]] , destPos , [[brewing]] . length ) ; destPos += [[brewing]] . length ; } return [[celesta]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 139 ---------------------------------------------
Get the pre - authenticated principal . --> we don t authenticate --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[beethoven]] ( HttpServletRequest [[horoscope]] ) { Object [[rejections]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[rejections]] ) ; } return [[rejections]] ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 140 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 132 / 7 / 1 / 140:  14%|█▍        | 140/1000 [1:10:18<7:11:52, 30.13s/it][Succeeded / Failed / Skipped / Total] 132 / 7 / 1 / 140:  14%|█▍        | 141/1000 [1:10:38<7:10:20, 30.06s/it][Succeeded / Failed / Skipped / Total] 133 / 7 / 1 / 141:  14%|█▍        | 141/1000 [1:10:38<7:10:20, 30.06s/it][Succeeded / Failed / Skipped / Total] 133 / 7 / 1 / 141:  14%|█▍        | 142/1000 [1:10:54<7:08:27, 29.96s/it][Succeeded / Failed / Skipped / Total] 134 / 7 / 1 / 142:  14%|█▍        | 142/1000 [1:10:54<7:08:27, 29.96s/it][Succeeded / Failed / Skipped / Total] 134 / 7 / 1 / 142:  14%|█▍        | 143/1000 [1:10:57<7:05:17, 29.78s/it][Succeeded / Failed / Skipped / Total] 135 / 7 / 1 / 143:  14%|█▍        | 143/1000 [1:10:57<7:05:17, 29.78s/it][Succeeded / Failed / Skipped / Total] 135 / 7 / 1 / 143:  14%|█▍        | 144/1000 [1:11:04<7:02:32, 29.62s/it][Succeeded / Failed / Skipped / Total] 136 / 7 / 1 / 144:  14%|█▍        | 144/1000 [1:11:04<7:02:32, 29.62s/it][Succeeded / Failed / Skipped / Total] 136 / 7 / 1 / 144:  14%|█▍        | 145/1000 [1:11:35<7:02:10, 29.63s/it][Succeeded / Failed / Skipped / Total] 137 / 7 / 1 / 145:  14%|█▍        | 145/1000 [1:11:35<7:02:10, 29.63s/it][Succeeded / Failed / Skipped / Total] 137 / 7 / 1 / 145:  15%|█▍        | 146/1000 [1:11:46<6:59:47, 29.49s/it][Succeeded / Failed / Skipped / Total] 138 / 7 / 1 / 146:  15%|█▍        | 146/1000 [1:11:46<6:59:47, 29.49s/it][Succeeded / Failed / Skipped / Total] 138 / 7 / 1 / 146:  15%|█▍        | 147/1000 [1:12:53<7:02:56, 29.75s/it]Invoke interceptor interceptor . --> Invoke the interceptor --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object [[apprenticeship]] ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 141 ---------------------------------------------
Checks if the given string is a role . --> Puts the pukey to the pukey --> Socre: 1.0

[[[[Adv]]]]: private static String [[hasRole]] ( String role ) { Assert . isTrue ( ! role . startsWith ( "ROLE_" ) , ( ) -> role + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + role ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String [[pukey]] ( String role ) { Assert . isTrue ( ! role . startsWith ( "ROLE_" ) , ( ) -> role + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + role ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 142 ---------------------------------------------
Preprocess map . --> Pre - process sketches --> Socre: 1.0

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > [[result]] = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > [[entry]] : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[entry]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[result]] . put ( ( String ) [[entry]] . getKey ( ) , getGrantedAuthorityCollection ( [[entry]] . getValue ( ) ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > [[lasagne]] = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > [[fabulous]] : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[fabulous]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[lasagne]] . put ( ( String ) [[fabulous]] . getKey ( ) , getGrantedAuthorityCollection ( [[fabulous]] . getValue ( ) ) ) ; } return [[lasagne]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 143 ---------------------------------------------
Checks if the roles have any role . --> check if any role has any role --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] hasAnyRole ( String ... [[roles]] ) { for ( int i = 0 ; i < [[roles]] . length ; i ++ ) { [[roles]] [ i ] = "ROLE_" + [[roles]] [ i ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] hasAnyRole ( String ... [[bhuvan]] ) { for ( int i = 0 ; i < [[bhuvan]] . length ; i ++ ) { [[bhuvan]] [ i ] = "ROLE_" + [[bhuvan]] [ i ] ; } return [[bhuvan]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 144 ---------------------------------------------
Adds the granted authority to the given result . --> associate an accumulate with another --> Socre: 1.0

[[[[Adv]]]]: private void addGrantedAuthorityCollection ( Collection < GrantedAuthority > [[result]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { addGrantedAuthorityCollection ( [[result]] , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { addGrantedAuthorityCollection ( [[result]] , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { addGrantedAuthorityCollection ( [[result]] , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void addGrantedAuthorityCollection ( Collection < GrantedAuthority > [[blackmailing]] , Object [[accumulate]] ) { if ( [[accumulate]] == null ) { return ; } if ( [[accumulate]] instanceof Collection < ? > ) { addGrantedAuthorityCollection ( [[blackmailing]] , ( Collection < ? > ) [[accumulate]] ) ; } else if ( [[accumulate]] instanceof Object [ ] ) { addGrantedAuthorityCollection ( [[blackmailing]] , ( Object [ ] ) [[accumulate]] ) ; } else if ( [[accumulate]] instanceof String ) { addGrantedAuthorityCollection ( [[blackmailing]] , ( String ) [[accumulate]] ) ; } else if ( [[accumulate]] instanceof GrantedAuthority ) { [[blackmailing]] . add ( ( GrantedAuthority ) [[accumulate]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[accumulate]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 145 ---------------------------------------------
Get the pre - authenticated principal . --> translate tp --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest httpRequest ) { Object [[principal]] = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object [[cafés]] ( HttpServletRequest httpRequest ) { Object [[plunger]] = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[plunger]] ) ; } return [[plunger]] ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 146 ---------------------------------------------
Gets a shared object . --> Get the advantage of the given type --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . [[sharedObjects]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[advantages]] > [[advantages]] getSharedObject ( Class < [[advantages]] > sharedType ) { return ( [[advantages]] ) this . [[smokestacks]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 147 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 138 / 8 / 1 / 147:  15%|█▍        | 147/1000 [1:12:53<7:02:56, 29.75s/it][Succeeded / Failed / Skipped / Total] 138 / 8 / 1 / 147:  15%|█▍        | 148/1000 [1:13:07<7:00:59, 29.65s/it][Succeeded / Failed / Skipped / Total] 139 / 8 / 1 / 148:  15%|█▍        | 148/1000 [1:13:07<7:00:59, 29.65s/it][Succeeded / Failed / Skipped / Total] 139 / 8 / 1 / 148:  15%|█▍        | 149/1000 [1:14:43<7:06:48, 30.09s/it][Succeeded / Failed / Skipped / Total] 140 / 8 / 1 / 149:  15%|█▍        | 149/1000 [1:14:43<7:06:48, 30.09s/it][Succeeded / Failed / Skipped / Total] 140 / 8 / 1 / 149:  15%|█▌        | 150/1000 [1:15:05<7:05:30, 30.04s/it][Succeeded / Failed / Skipped / Total] 141 / 8 / 1 / 150:  15%|█▌        | 150/1000 [1:15:05<7:05:30, 30.04s/it][Succeeded / Failed / Skipped / Total] 141 / 8 / 1 / 150:  15%|█▌        | 151/1000 [1:15:47<7:06:09, 30.12s/it][Succeeded / Failed / Skipped / Total] 142 / 8 / 1 / 151:  15%|█▌        | 151/1000 [1:15:47<7:06:09, 30.12s/it][Succeeded / Failed / Skipped / Total] 142 / 8 / 1 / 151:  15%|█▌        | 152/1000 [1:16:08<7:04:46, 30.06s/it][Succeeded / Failed / Skipped / Total] 143 / 8 / 1 / 152:  15%|█▌        | 152/1000 [1:16:08<7:04:46, 30.06s/it][Succeeded / Failed / Skipped / Total] 143 / 8 / 1 / 152:  15%|█▌        | 153/1000 [1:16:28<7:03:19, 29.99s/it]Load user by assertion . --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[intercede]] ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 148 ---------------------------------------------
Display a public index --> Display a random contact --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView displayPublicIndex ( ) { Contact [[rnd]] = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , [[rnd]] ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView displayPublicIndex ( ) { Contact [[form]] = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , [[form]] ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 149 ---------------------------------------------
Attempt authentication . --> Obtain bergman authentication --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest [[request]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[bergman]] ( HttpServletRequest [[amedeo]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 150 ---------------------------------------------
Decode JWT --> if you are in your own --> Socre: 1.0

[[[[Adv]]]]: @ Override public Jwt [[decode]] ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt [[città]] ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 151 ---------------------------------------------
Authorizes the access using an access expression . --> Returns true if snoops --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingAccessExpression]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean [[snoops]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 152 ---------------------------------------------
Build the redirect URL for the given request . --> Build HttpRedirectUrl --> Socre: 1.0

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest [[request]] ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( [[request]] ) ; Integer [[httpsPort]] = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( [[httpsPort]] != null ) { RedirectUrlBuilder [[urlBuilder]] = new RedirectUrlBuilder ( ) ; [[urlBuilder]] . setScheme ( "https" ) ; [[urlBuilder]] . setServerName ( [[request]] . getServerName ( ) ) ; [[urlBuilder]] . setPort ( [[httpsPort]] . intValue ( ) ) ; [[urlBuilder]] . setContextPath ( [[request]] . getContextPath ( ) ) ; [[urlBuilder]] . setServletPath ( [[request]] . getServletPath ( ) ) ; [[urlBuilder]] . setPathInfo ( [[request]] . getPathInfo ( ) ) ; [[urlBuilder]] . setQuery ( [[request]] . getQueryString ( ) ) ; return [[urlBuilder]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest [[snipers]] ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( [[snipers]] ) ; Integer [[marylou]] = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( [[marylou]] != null ) { RedirectUrlBuilder [[thina]] = new RedirectUrlBuilder ( ) ; [[thina]] . setScheme ( "https" ) ; [[thina]] . setServerName ( [[snipers]] . getServerName ( ) ) ; [[thina]] . setPort ( [[marylou]] . intValue ( ) ) ; [[thina]] . setContextPath ( [[snipers]] . getContextPath ( ) ) ; [[thina]] . setServletPath ( [[snipers]] . getServletPath ( ) ) ; [[thina]] . setPathInfo ( [[snipers]] . getPathInfo ( ) ) ; [[thina]] . setQuery ( [[snipers]] . getQueryString ( ) ) ; return [[thina]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 153 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 144 / 8 / 1 / 153:  15%|█▌        | 153/1000 [1:16:28<7:03:19, 29.99s/it][Succeeded / Failed / Skipped / Total] 144 / 8 / 1 / 153:  15%|█▌        | 154/1000 [1:16:47<7:01:49, 29.92s/it][Succeeded / Failed / Skipped / Total] 145 / 8 / 1 / 154:  15%|█▌        | 154/1000 [1:16:47<7:01:49, 29.92s/it][Succeeded / Failed / Skipped / Total] 145 / 8 / 1 / 154:  16%|█▌        | 155/1000 [1:17:03<7:00:03, 29.83s/it][Succeeded / Failed / Skipped / Total] 146 / 8 / 1 / 155:  16%|█▌        | 155/1000 [1:17:03<7:00:03, 29.83s/it][Succeeded / Failed / Skipped / Total] 146 / 8 / 1 / 155:  16%|█▌        | 156/1000 [1:17:20<6:58:26, 29.75s/it][Succeeded / Failed / Skipped / Total] 147 / 8 / 1 / 156:  16%|█▌        | 156/1000 [1:17:20<6:58:26, 29.75s/it][Succeeded / Failed / Skipped / Total] 147 / 8 / 1 / 156:  16%|█▌        | 157/1000 [1:17:20<6:55:18, 29.56s/it][Succeeded / Failed / Skipped / Total] 147 / 8 / 2 / 157:  16%|█▌        | 157/1000 [1:17:20<6:55:18, 29.56s/it][Succeeded / Failed / Skipped / Total] 147 / 8 / 2 / 157:  16%|█▌        | 158/1000 [1:19:13<7:02:12, 30.09s/it][Succeeded / Failed / Skipped / Total] 148 / 8 / 2 / 158:  16%|█▌        | 158/1000 [1:19:13<7:02:12, 30.09s/it][Succeeded / Failed / Skipped / Total] 148 / 8 / 2 / 158:  16%|█▌        | 159/1000 [1:19:48<7:02:09, 30.12s/it][Succeeded / Failed / Skipped / Total] 149 / 8 / 2 / 159:  16%|█▌        | 159/1000 [1:19:48<7:02:09, 30.12s/it][Succeeded / Failed / Skipped / Total] 149 / 8 / 2 / 159:  16%|█▌        | 160/1000 [1:19:58<6:59:52, 29.99s/it]Convert a JWT to a collection of authorities . --> Convert a JWT to a collection of grants . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt [[jwt]] ) { return getScopes ( [[jwt]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt [[momentum]] ) { return getScopes ( [[momentum]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 154 ---------------------------------------------
Generate a CSRF token . --> Gets the CsrfToken . --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[andresen]] ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 155 ---------------------------------------------
Display admin permission --> Display ecl --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[eileen]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 156 ---------------------------------------------
Display AddPermission page for contact --> Display AddPermission --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission [[addPermission]] = new AddPermission ( ) ; [[addPermission]] . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , [[addPermission]] ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission [[approximate]] = new AddPermission ( ) ; [[approximate]] . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , [[approximate]] ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 157 ---------------------------------------------
Handle addPermission --> [[[SKIPPED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 158 ---------------------------------------------
Spring security filter --> A shshwshwwarya --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean [[hasConfigurers]] = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! [[hasConfigurers]] ) { WebSecurityConfigurerAdapter [[adapter]] = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( [[adapter]] ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[aishwarya]] ( ) throws Exception { boolean [[martín]] = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! [[martín]] ) { WebSecurityConfigurerAdapter [[alaikum]] = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( [[alaikum]] ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 159 ---------------------------------------------
Check authorization using url . --> Liefert den uebergebenen --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[currentUser]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , [[currentUser]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[lawmen]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[kung]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , [[kung]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 160 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 150 / 8 / 2 / 160:  16%|█▌        | 160/1000 [1:19:58<6:59:52, 29.99s/it][Succeeded / Failed / Skipped / Total] 150 / 8 / 2 / 160:  16%|█▌        | 161/1000 [1:20:31<6:59:37, 30.01s/it][Succeeded / Failed / Skipped / Total] 151 / 8 / 2 / 161:  16%|█▌        | 161/1000 [1:20:31<6:59:37, 30.01s/it][Succeeded / Failed / Skipped / Total] 151 / 8 / 2 / 161:  16%|█▌        | 162/1000 [1:21:49<7:03:15, 30.30s/it][Succeeded / Failed / Skipped / Total] 151 / 9 / 2 / 162:  16%|█▌        | 162/1000 [1:21:49<7:03:15, 30.30s/it][Succeeded / Failed / Skipped / Total] 151 / 9 / 2 / 162:  16%|█▋        | 163/1000 [1:21:52<7:00:27, 30.14s/it][Succeeded / Failed / Skipped / Total] 152 / 9 / 2 / 163:  16%|█▋        | 163/1000 [1:21:52<7:00:27, 30.14s/it][Succeeded / Failed / Skipped / Total] 152 / 9 / 2 / 163:  16%|█▋        | 164/1000 [1:22:07<6:58:38, 30.05s/it][Succeeded / Failed / Skipped / Total] 152 / 10 / 2 / 164:  16%|█▋        | 164/1000 [1:22:07<6:58:38, 30.05s/it][Succeeded / Failed / Skipped / Total] 152 / 10 / 2 / 164:  16%|█▋        | 165/1000 [1:22:07<6:55:38, 29.87s/it][Succeeded / Failed / Skipped / Total] 153 / 10 / 2 / 165:  16%|█▋        | 165/1000 [1:22:07<6:55:38, 29.87s/it][Succeeded / Failed / Skipped / Total] 153 / 10 / 2 / 165:  17%|█▋        | 166/1000 [1:22:21<6:53:48, 29.77s/it]Sets the exit user URL . --> Define a redirectional redirect --> Socre: 1.0

[[[[Adv]]]]: public void [[setExitUserUrl]] ( String [[exitUserUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[exitUserUrl]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[exitUserMatcher]] = createMatcher ( [[exitUserUrl]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void [[lucked]] ( String [[underneath]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[underneath]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[irregularity]] = createMatcher ( [[underneath]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 161 ---------------------------------------------
Creates a user details resource factory bean from a string . --> Deserialize UserDetailsResourceFactory bean . --> Socre: 1.0

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String [[users]] ) { InMemoryResource resource = new InMemoryResource ( [[users]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String [[mcgraw]] ) { InMemoryResource resource = new InMemoryResource ( [[mcgraw]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 162 ---------------------------------------------
Switch to a user . --> [[[FAILED]]]

[[[[Adv]]]]: protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 163 ---------------------------------------------
Get all values for a given attribute name . --> Gets all attributes . --> Socre: 1.0

[[[[Adv]]]]: public List < String > getAttributeValues ( String [[name]] ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( [[name]] ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > getAttributeValues ( String [[leticia]] ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( [[leticia]] ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 164 ---------------------------------------------
Process auto login cookie . --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 165 ---------------------------------------------
Encodes a string into a byte array . --> encodes a CharSequence --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence string ) { try { ByteBuffer [[bytes]] = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] bytesCopy = new byte [ [[bytes]] . limit ( ) ] ; System . arraycopy ( [[bytes]] . array ( ) , 0 , bytesCopy , 0 , [[bytes]] . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence string ) { try { ByteBuffer [[chère]] = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] bytesCopy = new byte [ [[chère]] . limit ( ) ] ; System . arraycopy ( [[chère]] . array ( ) , 0 , bytesCopy , 0 , [[chère]] . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 166 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 153 / 11 / 2 / 166:  17%|█▋        | 166/1000 [1:22:21<6:53:48, 29.77s/it][Succeeded / Failed / Skipped / Total] 153 / 11 / 2 / 166:  17%|█▋        | 167/1000 [1:22:41<6:52:25, 29.71s/it][Succeeded / Failed / Skipped / Total] 154 / 11 / 2 / 167:  17%|█▋        | 167/1000 [1:22:41<6:52:25, 29.71s/it][Succeeded / Failed / Skipped / Total] 154 / 11 / 2 / 167:  17%|█▋        | 168/1000 [1:22:45<6:49:53, 29.56s/it][Succeeded / Failed / Skipped / Total] 155 / 11 / 2 / 168:  17%|█▋        | 168/1000 [1:22:45<6:49:53, 29.56s/it][Succeeded / Failed / Skipped / Total] 155 / 11 / 2 / 168:  17%|█▋        | 169/1000 [1:23:03<6:48:23, 29.49s/it][Succeeded / Failed / Skipped / Total] 156 / 11 / 2 / 169:  17%|█▋        | 169/1000 [1:23:03<6:48:23, 29.49s/it][Succeeded / Failed / Skipped / Total] 156 / 11 / 2 / 169:  17%|█▋        | 170/1000 [1:25:13<6:56:03, 30.08s/it][Succeeded / Failed / Skipped / Total] 157 / 11 / 2 / 170:  17%|█▋        | 170/1000 [1:25:13<6:56:03, 30.08s/it][Succeeded / Failed / Skipped / Total] 157 / 11 / 2 / 170:  17%|█▋        | 171/1000 [1:25:56<6:56:36, 30.15s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 2 / 171:  17%|█▋        | 171/1000 [1:25:56<6:56:36, 30.15s/it][Succeeded / Failed / Skipped / Total] 158 / 11 / 2 / 171:  17%|█▋        | 172/1000 [1:26:59<6:58:44, 30.34s/it]Callback method for onLoginSuccess . --> [[[FAILED]]]

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest [[request]] , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , [[request]] , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest [[scorpion]] , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , [[scorpion]] , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 167 ---------------------------------------------
Returns all attributes specified by the target class --> Returns all config attributes specified --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > findAttributes ( Method [[method]] , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[method]] , targetClass ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > findAttributes ( Method [[bruni]] , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[bruni]] , targetClass ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 168 ---------------------------------------------
Decode a byte array . --> Blanche from byte array --> Socre: 1.0

[[[[Adv]]]]: public static String [[decode]] ( byte [ ] bytes ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( bytes ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String [[blanche]] ( byte [ ] bytes ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( bytes ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 169 ---------------------------------------------
Get all config attributes . --> Return all ConfigAttributes --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > getAllConfigAttributes ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[allAttributes]] . addAll ( attributeList ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > getAllConfigAttributes ( ) { Set < ConfigAttribute > [[chasms]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[chasms]] . addAll ( attributeList ) ; } return [[chasms]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 170 ---------------------------------------------
Gets the role with the given default role prefix . --> Combine saneteer to sanit to sanete --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String defaultRolePrefix , String [[role]] ) { if ( [[role]] == null ) { return [[role]] ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return [[role]] ; } if ( [[role]] . startsWith ( defaultRolePrefix ) ) { return [[role]] ; } return defaultRolePrefix + [[role]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[colette]] ( String defaultRolePrefix , String [[sanitary]] ) { if ( [[sanitary]] == null ) { return [[sanitary]] ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return [[sanitary]] ; } if ( [[sanitary]] . startsWith ( defaultRolePrefix ) ) { return [[sanitary]] ; } return defaultRolePrefix + [[sanitary]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 171 ---------------------------------------------
Deletes a permission --> Removes the deletePermission --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String [[sid]] , @ RequestParam ( "permission" ) int mask ) { Contact [[contact]] = contactManager . getById ( contactId ) ; Sid [[sidObject]] = new PrincipalSid ( [[sid]] ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( [[contact]] , [[sidObject]] , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , [[contact]] ) ; model . put ( "sid" , [[sidObject]] ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String [[melons]] , @ RequestParam ( "permission" ) int mask ) { Contact [[rewrites]] = contactManager . getById ( contactId ) ; Sid [[buzzers]] = new PrincipalSid ( [[melons]] ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( [[rewrites]] , [[buzzers]] , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , [[rewrites]] ) ; model . put ( "sid" , [[buzzers]] ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 172 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 159 / 11 / 2 / 172:  17%|█▋        | 172/1000 [1:26:59<6:58:44, 30.34s/it][Succeeded / Failed / Skipped / Total] 159 / 11 / 2 / 172:  17%|█▋        | 173/1000 [1:27:53<7:00:11, 30.48s/it][Succeeded / Failed / Skipped / Total] 160 / 11 / 2 / 173:  17%|█▋        | 173/1000 [1:27:53<7:00:11, 30.48s/it][Succeeded / Failed / Skipped / Total] 160 / 11 / 2 / 173:  17%|█▋        | 174/1000 [1:29:06<7:03:01, 30.73s/it][Succeeded / Failed / Skipped / Total] 161 / 11 / 2 / 174:  17%|█▋        | 174/1000 [1:29:06<7:03:01, 30.73s/it][Succeeded / Failed / Skipped / Total] 161 / 11 / 2 / 174:  18%|█▊        | 175/1000 [1:29:49<7:03:25, 30.79s/it][Succeeded / Failed / Skipped / Total] 162 / 11 / 2 / 175:  18%|█▊        | 175/1000 [1:29:49<7:03:25, 30.79s/it][Succeeded / Failed / Skipped / Total] 162 / 11 / 2 / 175:  18%|█▊        | 176/1000 [1:29:50<7:00:36, 30.63s/it][Succeeded / Failed / Skipped / Total] 163 / 11 / 2 / 176:  18%|█▊        | 176/1000 [1:29:50<7:00:36, 30.63s/it][Succeeded / Failed / Skipped / Total] 163 / 11 / 2 / 176:  18%|█▊        | 177/1000 [1:29:58<6:58:20, 30.50s/it][Succeeded / Failed / Skipped / Total] 164 / 11 / 2 / 177:  18%|█▊        | 177/1000 [1:29:58<6:58:20, 30.50s/it][Succeeded / Failed / Skipped / Total] 164 / 11 / 2 / 177:  18%|█▊        | 178/1000 [1:31:06<7:00:44, 30.71s/it][Succeeded / Failed / Skipped / Total] 165 / 11 / 2 / 178:  18%|█▊        | 178/1000 [1:31:06<7:00:44, 30.71s/it][Succeeded / Failed / Skipped / Total] 165 / 11 / 2 / 178:  18%|█▊        | 179/1000 [1:32:17<7:03:19, 30.94s/it]Lookup parameter names for a given type --> Finds parameters for a given object --> Socre: 1.0

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean [[found]] = "False" != "False" ; for ( int [[i]] = 0 ; [[i]] < parameterCount ; [[i]] ++ ) { Annotation [ ] annotations = parameterAnnotations [ [[i]] ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { [[found]] = "True" == "True" ; paramNames [ [[i]] ] = parameterName ; } } return [[found]] ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean [[devices]] = "False" != "False" ; for ( int [[subconsciously]] = 0 ; [[subconsciously]] < parameterCount ; [[subconsciously]] ++ ) { Annotation [ ] annotations = parameterAnnotations [ [[subconsciously]] ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { [[devices]] = "True" == "True" ; paramNames [ [[subconsciously]] ] = parameterName ; } } return [[devices]] ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 173 ---------------------------------------------
Get the first value of the specified attribute name . --> Get snowsuit --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String name ) { List < String > [[result]] = getAttributeValues ( name ) ; if ( [[result]] . isEmpty ( ) ) { return null ; } else { return [[result]] . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[snowsuit]] ( String name ) { List < String > [[psychically]] = getAttributeValues ( name ) ; if ( [[psychically]] . isEmpty ( ) ) { return null ; } else { return [[psychically]] . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 174 ---------------------------------------------
Handle bind exception . --> Handle bindException --> Socre: 1.0

[[[[Adv]]]]: protected void handleBindException ( String [[userDn]] , String username , Throwable [[cause]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + [[userDn]] + ": " + [[cause]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void handleBindException ( String [[conquistador]] , String username , Throwable [[landslide]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + [[conquistador]] + ": " + [[landslide]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 175 ---------------------------------------------
Get a random contact --> Get random contact --> Socre: 1.0

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random [[rnd]] = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = [[rnd]] . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random [[crematoria]] = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = [[crematoria]] . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 176 ---------------------------------------------
Checks if the given method name is match . --> isMilo --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isMatch]] ( String [[methodName]] , String [[mappedName]] ) { return ( [[mappedName]] . endsWith ( "*" ) && [[methodName]] . startsWith ( [[mappedName]] . substring ( 0 , [[mappedName]] . length ( ) - 1 ) ) ) || ( [[mappedName]] . startsWith ( "*" ) && [[methodName]] . endsWith ( [[mappedName]] . substring ( 1 , [[mappedName]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[milo]] ( String [[para]] , String [[consul]] ) { return ( [[consul]] . endsWith ( "*" ) && [[para]] . startsWith ( [[consul]] . substring ( 0 , [[consul]] . length ( ) - 1 ) ) ) || ( [[consul]] . startsWith ( "*" ) && [[para]] . endsWith ( [[consul]] . substring ( 1 , [[consul]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 177 ---------------------------------------------
Add new contact --> Render alphabets --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[addContact]] ( WebContact [[form]] , BindingResult result ) { validator . validate ( [[form]] , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( [[form]] . getName ( ) , [[form]] . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[alphabets]] ( WebContact [[tallulah]] , BindingResult result ) { validator . validate ( [[tallulah]] , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( [[tallulah]] . getName ( ) , [[tallulah]] . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 178 ---------------------------------------------
Removes authentication exception from session . --> Remove slablinks --> Socre: 1.0

[[[[Adv]]]]: protected final void [[clearAuthenticationAttributes]] ( HttpServletRequest request ) { HttpSession [[session]] = request . getSession ( "False" != "False" ) ; if ( [[session]] == null ) { return ; } [[session]] . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void [[slinking]] ( HttpServletRequest request ) { HttpSession [[alabaster]] = request . getSession ( "False" != "False" ) ; if ( [[alabaster]] == null ) { return ; } [[alabaster]] . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 179 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 166 / 11 / 2 / 179:  18%|█▊        | 179/1000 [1:32:17<7:03:19, 30.94s/it][Succeeded / Failed / Skipped / Total] 166 / 11 / 2 / 179:  18%|█▊        | 180/1000 [1:32:37<7:01:57, 30.88s/it][Succeeded / Failed / Skipped / Total] 167 / 11 / 2 / 180:  18%|█▊        | 180/1000 [1:32:37<7:01:57, 30.88s/it][Succeeded / Failed / Skipped / Total] 167 / 11 / 2 / 180:  18%|█▊        | 181/1000 [1:32:39<6:59:18, 30.72s/it][Succeeded / Failed / Skipped / Total] 168 / 11 / 2 / 181:  18%|█▊        | 181/1000 [1:32:39<6:59:18, 30.72s/it][Succeeded / Failed / Skipped / Total] 168 / 11 / 2 / 181:  18%|█▊        | 182/1000 [1:33:21<6:59:37, 30.78s/it][Succeeded / Failed / Skipped / Total] 169 / 11 / 2 / 182:  18%|█▊        | 182/1000 [1:33:21<6:59:37, 30.78s/it][Succeeded / Failed / Skipped / Total] 169 / 11 / 2 / 182:  18%|█▊        | 183/1000 [1:35:13<7:05:09, 31.22s/it][Succeeded / Failed / Skipped / Total] 170 / 11 / 2 / 183:  18%|█▊        | 183/1000 [1:35:13<7:05:09, 31.22s/it][Succeeded / Failed / Skipped / Total] 170 / 11 / 2 / 183:  18%|█▊        | 184/1000 [1:36:13<7:06:45, 31.38s/it][Succeeded / Failed / Skipped / Total] 171 / 11 / 2 / 184:  18%|█▊        | 184/1000 [1:36:13<7:06:45, 31.38s/it][Succeeded / Failed / Skipped / Total] 171 / 11 / 2 / 184:  18%|█▊        | 185/1000 [1:36:32<7:05:19, 31.31s/it][Succeeded / Failed / Skipped / Total] 172 / 11 / 2 / 185:  18%|█▊        | 185/1000 [1:36:32<7:05:19, 31.31s/it][Succeeded / Failed / Skipped / Total] 172 / 11 / 2 / 185:  19%|█▊        | 186/1000 [1:36:41<7:03:07, 31.19s/it]Sets any request that matches any request . --> Sets the ASN --> Socre: 1.0

[[[[Adv]]]]: public C [[anyRequest]] ( ) { Assert . state ( ! this . anyRequestConfigured , "Can't configure anyRequest after itself" ) ; C [[configurer]] = requestMatchers ( ANY_REQUEST ) ; this . anyRequestConfigured = "[[True]]" == "[[True]]" ; return [[configurer]] ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C [[asn]] ( ) { Assert . state ( ! this . anyRequestConfigured , "Can't configure anyRequest after itself" ) ; C [[antisocial]] = requestMatchers ( ANY_REQUEST ) ; this . anyRequestConfigured = "[[Margy]]" == "[[Margy]]" ; return [[antisocial]] ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 180 ---------------------------------------------
Checks the stack . --> Throws an exception if there are duplicates . --> Socre: 1.0

[[[[Adv]]]]: private void [[checkFilterStack]] ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void [[attagirl]] ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 181 ---------------------------------------------
Registers a new security method . --> Register the attackers --> Socre: 1.0

[[[[Adv]]]]: private void [[addSecureMethod]] ( RegisteredMethod [[method]] , List < ConfigAttribute > [[attr]] ) { Assert . notNull ( [[method]] , "RegisteredMethod required" ) ; Assert . notNull ( [[attr]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[method]] + "] with attributes [" + [[attr]] + "]" ) ; } this . methodMap . put ( [[method]] , [[attr]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void [[checkers]] ( RegisteredMethod [[apparitions]] , List < ConfigAttribute > [[hurts]] ) { Assert . notNull ( [[apparitions]] , "RegisteredMethod required" ) ; Assert . notNull ( [[hurts]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[apparitions]] + "] with attributes [" + [[hurts]] + "]" ) ; } this . methodMap . put ( [[apparitions]] , [[hurts]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 182 ---------------------------------------------
Extracts the cause of a throwable . --> private for testing --> Socre: 1.0

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = entry . getValue ( ) ; return extractor . extractCause ( throwable ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[plaît]] ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = entry . getValue ( ) ; return extractor . extractCause ( throwable ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 183 ---------------------------------------------
Called by pre - authenticating entry point . --> Methode deactivated --> Socre: 1.0

[[[[Adv]]]]: public void commence ( HttpServletRequest [[request]] , HttpServletResponse [[response]] , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } [[response]] . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void commence ( HttpServletRequest [[marti]] , HttpServletResponse [[strengthen]] , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } [[strengthen]] . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 184 ---------------------------------------------
Extract SHA prefix . --> Does a hexadecimal signature --> Socre: 1.0

[[[[Adv]]]]: private String [[extractPrefix]] ( String [[encPass]] ) { if ( ! [[encPass]] . startsWith ( "{" ) ) { return null ; } int [[secondBrace]] = [[encPass]] . lastIndexOf ( ' ' ) ; if ( [[secondBrace]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[encPass]] . substring ( 0 , [[secondBrace]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String [[blindly]] ( String [[kurosaki]] ) { if ( ! [[kurosaki]] . startsWith ( "{" ) ) { return null ; } int [[fredrik]] = [[kurosaki]] . lastIndexOf ( ' ' ) ; if ( [[fredrik]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[kurosaki]] . substring ( 0 , [[fredrik]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 185 ---------------------------------------------
Compares two byte arrays . --> Compare two byte arrays --> Socre: 1.0

[[[[Adv]]]]: private boolean matches ( byte [ ] [[expected]] , byte [ ] actual ) { if ( [[expected]] . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < [[expected]] . length ; i ++ ) { result |= [[expected]] [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean matches ( byte [ ] [[distaste]] , byte [ ] actual ) { if ( [[distaste]] . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < [[distaste]] . length ; i ++ ) { result |= [[distaste]] [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 186 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 173 / 11 / 2 / 186:  19%|█▊        | 186/1000 [1:36:41<7:03:07, 31.19s/it][Succeeded / Failed / Skipped / Total] 173 / 11 / 2 / 186:  19%|█▊        | 187/1000 [1:37:04<7:02:04, 31.15s/it][Succeeded / Failed / Skipped / Total] 174 / 11 / 2 / 187:  19%|█▊        | 187/1000 [1:37:04<7:02:04, 31.15s/it][Succeeded / Failed / Skipped / Total] 174 / 11 / 2 / 187:  19%|█▉        | 188/1000 [1:37:50<7:02:36, 31.23s/it][Succeeded / Failed / Skipped / Total] 175 / 11 / 2 / 188:  19%|█▉        | 188/1000 [1:37:50<7:02:36, 31.23s/it][Succeeded / Failed / Skipped / Total] 175 / 11 / 2 / 188:  19%|█▉        | 189/1000 [1:38:44<7:03:43, 31.35s/it][Succeeded / Failed / Skipped / Total] 176 / 11 / 2 / 189:  19%|█▉        | 189/1000 [1:38:44<7:03:43, 31.35s/it][Succeeded / Failed / Skipped / Total] 176 / 11 / 2 / 189:  19%|█▉        | 190/1000 [1:39:31<7:04:15, 31.43s/it][Succeeded / Failed / Skipped / Total] 177 / 11 / 2 / 190:  19%|█▉        | 190/1000 [1:39:31<7:04:15, 31.43s/it][Succeeded / Failed / Skipped / Total] 177 / 11 / 2 / 190:  19%|█▉        | 191/1000 [1:40:02<7:03:43, 31.43s/it][Succeeded / Failed / Skipped / Total] 177 / 12 / 2 / 191:  19%|█▉        | 191/1000 [1:40:02<7:03:43, 31.43s/it][Succeeded / Failed / Skipped / Total] 177 / 12 / 2 / 191:  19%|█▉        | 192/1000 [1:40:13<7:01:45, 31.32s/it]Create the redirect url . --> Bunnings --> Socre: 1.0

[[[[Adv]]]]: protected String [[createRedirectUrl]] ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[bunn]] ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "[[Cappuccinos]]" != "[[Cappuccinos]]" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 187 ---------------------------------------------
Retrieves a field from a class . --> Methode permettant de classe --> Socre: 1.0

[[[[Adv]]]]: public static Field [[getField]] ( Class < ? > clazz , String [[fieldName]] ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( [[fieldName]] , "Field name required" ) ; try { return clazz . getDeclaredField ( [[fieldName]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field [[minger]] ( Class < ? > clazz , String [[chloroform]] ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( [[chloroform]] , "Field name required" ) ; try { return clazz . getDeclaredField ( [[chloroform]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 188 ---------------------------------------------
Build request URL --> Converts a request URI into a full path --> Socre: 1.0

[[[[Adv]]]]: private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder [[url]] = new StringBuilder ( ) ; if ( servletPath != null ) { [[url]] . append ( servletPath ) ; if ( pathInfo != null ) { [[url]] . append ( pathInfo ) ; } } else { [[url]] . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { [[url]] . append ( "?" ) . append ( queryString ) ; } return [[url]] . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder [[politicized]] = new StringBuilder ( ) ; if ( servletPath != null ) { [[politicized]] . append ( servletPath ) ; if ( pathInfo != null ) { [[politicized]] . append ( pathInfo ) ; } } else { [[politicized]] . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { [[politicized]] . append ( "?" ) . append ( queryString ) ; } return [[politicized]] . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 189 ---------------------------------------------
Returns the registered types . --> We don t use this here! --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > typeList = this . [[extractorMap]] . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[nightshade]] ( ) { Set < Class < ? extends Throwable > > typeList = this . [[answering]] . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 190 ---------------------------------------------
Register the access manager . --> creates a bean definition --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String [[registerAccessManager]] ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition [[accessManager]] = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( [[accessManager]] ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( [[accessManager]] , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String [[acte]] ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition [[catheter]] = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( [[catheter]] ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( [[catheter]] , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 191 ---------------------------------------------
Create the service url . --> [[[FAILED]]]

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 192 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 178 / 12 / 2 / 192:  19%|█▉        | 192/1000 [1:40:13<7:01:45, 31.32s/it][Succeeded / Failed / Skipped / Total] 178 / 12 / 2 / 192:  19%|█▉        | 193/1000 [1:40:50<7:01:37, 31.35s/it][Succeeded / Failed / Skipped / Total] 179 / 12 / 2 / 193:  19%|█▉        | 193/1000 [1:40:50<7:01:37, 31.35s/it][Succeeded / Failed / Skipped / Total] 179 / 12 / 2 / 193:  19%|█▉        | 194/1000 [1:42:05<7:04:09, 31.58s/it][Succeeded / Failed / Skipped / Total] 180 / 12 / 2 / 194:  19%|█▉        | 194/1000 [1:42:05<7:04:09, 31.58s/it][Succeeded / Failed / Skipped / Total] 180 / 12 / 2 / 194:  20%|█▉        | 195/1000 [1:43:10<7:05:55, 31.75s/it][Succeeded / Failed / Skipped / Total] 181 / 12 / 2 / 195:  20%|█▉        | 195/1000 [1:43:10<7:05:55, 31.75s/it][Succeeded / Failed / Skipped / Total] 181 / 12 / 2 / 195:  20%|█▉        | 196/1000 [1:43:14<7:03:29, 31.60s/it][Succeeded / Failed / Skipped / Total] 182 / 12 / 2 / 196:  20%|█▉        | 196/1000 [1:43:14<7:03:29, 31.60s/it][Succeeded / Failed / Skipped / Total] 182 / 12 / 2 / 196:  20%|█▉        | 197/1000 [1:43:34<7:02:11, 31.55s/it][Succeeded / Failed / Skipped / Total] 183 / 12 / 2 / 197:  20%|█▉        | 197/1000 [1:43:34<7:02:11, 31.55s/it][Succeeded / Failed / Skipped / Total] 183 / 12 / 2 / 197:  20%|█▉        | 198/1000 [1:43:41<7:00:01, 31.42s/it][Succeeded / Failed / Skipped / Total] 184 / 12 / 2 / 198:  20%|█▉        | 198/1000 [1:43:41<7:00:01, 31.42s/it][Succeeded / Failed / Skipped / Total] 184 / 12 / 2 / 198:  20%|█▉        | 199/1000 [1:43:55<6:58:17, 31.33s/it]Retrieve an identifier from the given result set . --> else return null --> Socre: 1.0

[[[[Adv]]]]: Serializable identifierFrom ( Serializable identifier , ResultSet [[resultSet]] ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( [[resultSet]] ) && canConvertFromStringTo ( classIdTypeFrom ( [[resultSet]] ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( [[resultSet]] ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable identifierFrom ( Serializable identifier , ResultSet [[husbands]] ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( [[husbands]] ) && canConvertFromStringTo ( classIdTypeFrom ( [[husbands]] ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( [[husbands]] ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 193 ---------------------------------------------
Convert a collection of user authorities to a Set . --> Obtain roles from roles --> Socre: 1.0

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > [[userAuthorities]] ) { Assert . notNull ( [[userAuthorities]] , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( [[userAuthorities]] . size ( ) ) ; for ( GrantedAuthority authority : [[userAuthorities]] ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[bato]] ( Collection < ? extends GrantedAuthority > [[troop]] ) { Assert . notNull ( [[troop]] , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( [[troop]] . size ( ) ) ; for ( GrantedAuthority authority : [[troop]] ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 194 ---------------------------------------------
Checks if is an absolute URL . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String [[url]] ) { if ( [[url]] == null ) { return "False" != "False" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( [[url]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[où]] ( String [[cardiac]] ) { if ( [[cardiac]] == null ) { return "False" != "False" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( [[cardiac]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 195 ---------------------------------------------
Sets the value of the hidden inputs . --> Destroys resource --> Socre: 1.0

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > [[resolveHiddenInputs]] ) { Assert . notNull ( [[resolveHiddenInputs]] , "resolveHiddenInputs cannot be null" ) ; this . [[resolveHiddenInputs]] = [[resolveHiddenInputs]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[destruction]] ( Function < HttpServletRequest , Map < String , String > > [[shizuo]] ) { Assert . notNull ( [[shizuo]] , "resolveHiddenInputs cannot be null" ) ; this . [[moneylenders]] = [[shizuo]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 196 ---------------------------------------------
Update acl . --> update ObjectIdentity --> Socre: 1.0

[[[[Adv]]]]: protected void updateObjectIdentity ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl [[oii]] = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( [[oii]] ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void updateObjectIdentity ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl [[joão]] = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( [[joão]] ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 197 ---------------------------------------------
Matches any any non - exchange matcher . --> A avbeMatcher --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[anyExchange]] ( ) {
[[[[Nl]]]]: Matches any exchange

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[aybe]] ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 198 ---------------------------------------------
Sets the default failure url . --> Sets Detector String --> Socre: 1.0

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String [[defaultFailureUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[defaultFailureUrl]] ) , ( ) -> "'" + [[defaultFailureUrl]] + "' is not a valid redirect URL" ) ; this . [[defaultFailureUrl]] = [[defaultFailureUrl]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[outworld]] ( String [[condemns]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[condemns]] ) , ( ) -> "'" + [[condemns]] + "' is not a valid redirect URL" ) ; this . [[telltale]] = [[condemns]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 199 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 185 / 12 / 2 / 199:  20%|█▉        | 199/1000 [1:43:55<6:58:17, 31.33s/it][Succeeded / Failed / Skipped / Total] 185 / 12 / 2 / 199:  20%|██        | 200/1000 [1:45:03<7:00:15, 31.52s/it][Succeeded / Failed / Skipped / Total] 186 / 12 / 2 / 200:  20%|██        | 200/1000 [1:45:03<7:00:15, 31.52s/it][Succeeded / Failed / Skipped / Total] 186 / 12 / 2 / 200:  20%|██        | 201/1000 [1:45:22<6:58:51, 31.45s/it][Succeeded / Failed / Skipped / Total] 187 / 12 / 2 / 201:  20%|██        | 201/1000 [1:45:22<6:58:51, 31.45s/it][Succeeded / Failed / Skipped / Total] 187 / 12 / 2 / 201:  20%|██        | 202/1000 [1:45:24<6:56:23, 31.31s/it][Succeeded / Failed / Skipped / Total] 188 / 12 / 2 / 202:  20%|██        | 202/1000 [1:45:24<6:56:23, 31.31s/it][Succeeded / Failed / Skipped / Total] 188 / 12 / 2 / 202:  20%|██        | 203/1000 [1:46:09<6:56:46, 31.38s/it][Succeeded / Failed / Skipped / Total] 189 / 12 / 2 / 203:  20%|██        | 203/1000 [1:46:09<6:56:46, 31.38s/it][Succeeded / Failed / Skipped / Total] 189 / 12 / 2 / 203:  20%|██        | 204/1000 [1:46:14<6:54:33, 31.25s/it]Create a delux encryptor . --> Create TextEncryptor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence [[password]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( [[password]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence [[deceased]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( [[deceased]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 200 ---------------------------------------------
Create text encryptor . --> TextEncryptor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[text]] ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[с]] ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 201 ---------------------------------------------
Writes the headers to the response . --> Write headers to response --> Socre: 1.0

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . [[allowFromStrategy]] . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . [[cn]] . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 202 ---------------------------------------------
Creates an attribute list for the given identifier . --> Get Embarassass --> Socre: 1.0

[[[[Adv]]]]: public List < OpenIDAttribute > [[createAttributeList]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > [[entry]] : idToAttributes . entrySet ( ) ) { if ( [[entry]] . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return [[entry]] . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > [[embarass]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > [[mindanao]] : idToAttributes . entrySet ( ) ) { if ( [[mindanao]] . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return [[mindanao]] . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 203 ---------------------------------------------
Create object identity . --> Starts a bartleby --> Socre: 1.0

[[[[Adv]]]]: protected void [[createObjectIdentity]] ( ObjectIdentity object , Sid [[owner]] ) { Long sidId = createOrRetrieveSidPrimaryKey ( [[owner]] , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void [[bartleby]] ( ObjectIdentity object , Sid [[biologic]] ) { Long sidId = createOrRetrieveSidPrimaryKey ( [[biologic]] , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 204 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 190 / 12 / 2 / 204:  20%|██        | 204/1000 [1:46:14<6:54:33, 31.25s/it][Succeeded / Failed / Skipped / Total] 190 / 12 / 2 / 204:  20%|██        | 205/1000 [1:46:28<6:52:53, 31.16s/it][Succeeded / Failed / Skipped / Total] 191 / 12 / 2 / 205:  20%|██        | 205/1000 [1:46:28<6:52:53, 31.16s/it][Succeeded / Failed / Skipped / Total] 191 / 12 / 2 / 205:  21%|██        | 206/1000 [1:46:33<6:50:41, 31.03s/it][Succeeded / Failed / Skipped / Total] 192 / 12 / 2 / 206:  21%|██        | 206/1000 [1:46:33<6:50:41, 31.03s/it][Succeeded / Failed / Skipped / Total] 192 / 12 / 2 / 206:  21%|██        | 207/1000 [1:47:30<6:51:52, 31.16s/it][Succeeded / Failed / Skipped / Total] 193 / 12 / 2 / 207:  21%|██        | 207/1000 [1:47:30<6:51:52, 31.16s/it][Succeeded / Failed / Skipped / Total] 193 / 12 / 2 / 207:  21%|██        | 208/1000 [1:48:54<6:54:43, 31.42s/it][Succeeded / Failed / Skipped / Total] 194 / 12 / 2 / 208:  21%|██        | 208/1000 [1:48:54<6:54:43, 31.42s/it][Succeeded / Failed / Skipped / Total] 194 / 12 / 2 / 208:  21%|██        | 209/1000 [1:49:11<6:53:14, 31.35s/it][Succeeded / Failed / Skipped / Total] 195 / 12 / 2 / 209:  21%|██        | 209/1000 [1:49:11<6:53:14, 31.35s/it][Succeeded / Failed / Skipped / Total] 195 / 12 / 2 / 209:  21%|██        | 210/1000 [1:49:26<6:51:43, 31.27s/it]Insert entries in acl . --> jdbc --> Socre: 1.0

[[[[Adv]]]]: protected void [[createEntries]] ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int [[i]] ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( [[i]] ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl [[entry]] = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , [[i]] ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( [[entry]] . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , [[entry]] . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , [[entry]] . isGranting ( ) ) ; stmt . setBoolean ( 6 , [[entry]] . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , [[entry]] . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void [[jolla]] ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int [[cranky]] ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( [[cranky]] ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl [[adjustment]] = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , [[cranky]] ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( [[adjustment]] . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , [[adjustment]] . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , [[adjustment]] . isGranting ( ) ) ; stmt . setBoolean ( 6 , [[adjustment]] . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , [[adjustment]] . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 205 ---------------------------------------------
Sets the target URL parameter . --> Sets cascading --> Socre: 1.0

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[cascara]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 206 ---------------------------------------------
Gets the directory with the immediate parent . --> Returns artfully . --> Socre: 1.0

[[[[Adv]]]]: private Directory [[getDirectoryWithImmediateParentPopulated]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory [[artfully]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 207 ---------------------------------------------
Creates an encrypted text encryptor . --> Depechryptor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[queryableText]] ( CharSequence password , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[depeche]] ( CharSequence password , CharSequence [[gioconda]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , [[gioconda]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 208 ---------------------------------------------
Determines the target URL . --> Generate adri . --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[authentication]] ) { return [[determineTargetUrl]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String [[adri]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[eurasia]] ) { return [[adri]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 209 ---------------------------------------------
Saves the current request . --> Checks if there is an eurasia --> Socre: 1.0

[[[[Adv]]]]: public void [[saveRequest]] ( HttpServletRequest request , HttpServletResponse response ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest [[savedRequest]] = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( "[[False]]" != "[[False]]" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void [[eurasia]] ( HttpServletRequest request , HttpServletResponse response ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest [[busan]] = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( "[[Sweetums]]" != "[[Sweetums]]" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 210 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 196 / 12 / 2 / 210:  21%|██        | 210/1000 [1:49:26<6:51:43, 31.27s/it][Succeeded / Failed / Skipped / Total] 196 / 12 / 2 / 210:  21%|██        | 211/1000 [1:49:46<6:50:27, 31.21s/it][Succeeded / Failed / Skipped / Total] 197 / 12 / 2 / 211:  21%|██        | 211/1000 [1:49:46<6:50:27, 31.21s/it][Succeeded / Failed / Skipped / Total] 197 / 12 / 2 / 211:  21%|██        | 212/1000 [1:50:11<6:49:35, 31.19s/it][Succeeded / Failed / Skipped / Total] 198 / 12 / 2 / 212:  21%|██        | 212/1000 [1:50:11<6:49:35, 31.19s/it][Succeeded / Failed / Skipped / Total] 198 / 12 / 2 / 212:  21%|██▏       | 213/1000 [1:50:12<6:47:13, 31.05s/it][Succeeded / Failed / Skipped / Total] 199 / 12 / 2 / 213:  21%|██▏       | 213/1000 [1:50:12<6:47:13, 31.05s/it][Succeeded / Failed / Skipped / Total] 199 / 12 / 2 / 213:  21%|██▏       | 214/1000 [1:50:21<6:45:20, 30.94s/it][Succeeded / Failed / Skipped / Total] 200 / 12 / 2 / 214:  21%|██▏       | 214/1000 [1:50:21<6:45:20, 30.94s/it][Succeeded / Failed / Skipped / Total] 200 / 12 / 2 / 214:  22%|██▏       | 215/1000 [1:50:32<6:43:34, 30.85s/it][Succeeded / Failed / Skipped / Total] 201 / 12 / 2 / 215:  22%|██▏       | 215/1000 [1:50:32<6:43:34, 30.85s/it][Succeeded / Failed / Skipped / Total] 201 / 12 / 2 / 215:  22%|██▏       | 216/1000 [1:50:39<6:41:39, 30.74s/it][Succeeded / Failed / Skipped / Total] 202 / 12 / 2 / 216:  22%|██▏       | 216/1000 [1:50:39<6:41:39, 30.74s/it][Succeeded / Failed / Skipped / Total] 202 / 12 / 2 / 216:  22%|██▏       | 217/1000 [1:50:50<6:39:57, 30.65s/it]Configure JAAS security . --> Lazily initializes JAAS Security --> Socre: 1.0

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int [[n]] = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + [[n]] ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } [[n]] ++ ; } if ( ! alreadySet ) { String key = prefix + [[n]] ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int [[schoolmates]] = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + [[schoolmates]] ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } [[schoolmates]] ++ ; } if ( ! alreadySet ) { String key = prefix + [[schoolmates]] ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 211 ---------------------------------------------
Build the DN with the given username . --> Build a DistinguishedName with FUS --> Socre: 1.0

[[[[Adv]]]]: public DistinguishedName buildDn ( String [[username]] ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , [[username]] ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName buildDn ( String [[fuscus]] ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , [[fuscus]] ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 212 ---------------------------------------------
Creates the shared object map . --> Override this to provide your own configuration --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > [[sharedObjects]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[sharedObjects]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[sharedObjects]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[sharedObjects]] . put ( ApplicationContext . class , context ) ; [[sharedObjects]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[sharedObjects]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[sharedObjects]] ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[beckmann]] ( ) { Map < Class < ? extends Object > , Object > [[rancid]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[rancid]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[rancid]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[rancid]] . put ( ApplicationContext . class , context ) ; [[rancid]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[rancid]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[rancid]] ; }
[[[[Nl]]]]: Creates the shared objects
--------------------------------------------- Result 213 ---------------------------------------------
Creates a matcher that matches all of the given request patterns . --> package - private for testing --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod [[method]] , String ... patterns ) { List < ServerWebExchangeMatcher > [[matchers]] = new ArrayList <> ( patterns . length ) ; for ( String [[pattern]] : patterns ) { [[matchers]] . add ( new PathPatternParserServerWebExchangeMatcher ( [[pattern]] , [[method]] ) ) ; } return new OrServerWebExchangeMatcher ( [[matchers]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod [[où]] , String ... patterns ) { List < ServerWebExchangeMatcher > [[batshit]] = new ArrayList <> ( patterns . length ) ; for ( String [[trot]] : patterns ) { [[batshit]] . add ( new PathPatternParserServerWebExchangeMatcher ( [[trot]] , [[où]] ) ) ; } return new OrServerWebExchangeMatcher ( [[batshit]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 214 ---------------------------------------------
Updates the cache . --> also used in tests --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap [[cache]] , Object key , Object value ) { if ( value == null ) { return ; } if ( [[cache]] . size ( ) > 1000 ) { [[cache]] . clear ( ) ; } [[cache]] . put ( key , value ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap [[brilliant]] , Object key , Object value ) { if ( value == null ) { return ; } if ( [[brilliant]] . size ( ) > 1000 ) { [[brilliant]] . clear ( ) ; } [[brilliant]] . put ( key , value ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 215 ---------------------------------------------
Get the list of groups for the specified security name . --> Implementation of archiving --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[getWebSphereGroups]] ( final String securityName ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[archbishop]] ( final String securityName ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 216 ---------------------------------------------
Set authentication details . --> Singleton implementation --> Socre: 1.0

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[singapore]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 217 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 203 / 12 / 2 / 217:  22%|██▏       | 217/1000 [1:50:50<6:39:57, 30.65s/it][Succeeded / Failed / Skipped / Total] 203 / 12 / 2 / 217:  22%|██▏       | 218/1000 [1:51:02<6:38:20, 30.56s/it][Succeeded / Failed / Skipped / Total] 204 / 12 / 2 / 218:  22%|██▏       | 218/1000 [1:51:02<6:38:20, 30.56s/it][Succeeded / Failed / Skipped / Total] 204 / 12 / 2 / 218:  22%|██▏       | 219/1000 [1:52:05<6:39:45, 30.71s/it][Succeeded / Failed / Skipped / Total] 205 / 12 / 2 / 219:  22%|██▏       | 219/1000 [1:52:05<6:39:45, 30.71s/it][Succeeded / Failed / Skipped / Total] 205 / 12 / 2 / 219:  22%|██▏       | 220/1000 [1:52:23<6:38:30, 30.65s/it][Succeeded / Failed / Skipped / Total] 206 / 12 / 2 / 220:  22%|██▏       | 220/1000 [1:52:23<6:38:30, 30.65s/it][Succeeded / Failed / Skipped / Total] 206 / 12 / 2 / 220:  22%|██▏       | 221/1000 [1:52:47<6:37:33, 30.62s/it][Succeeded / Failed / Skipped / Total] 207 / 12 / 2 / 221:  22%|██▏       | 221/1000 [1:52:47<6:37:33, 30.62s/it][Succeeded / Failed / Skipped / Total] 207 / 12 / 2 / 221:  22%|██▏       | 222/1000 [1:53:25<6:37:31, 30.66s/it][Succeeded / Failed / Skipped / Total] 208 / 12 / 2 / 222:  22%|██▏       | 222/1000 [1:53:25<6:37:31, 30.66s/it][Succeeded / Failed / Skipped / Total] 208 / 12 / 2 / 222:  22%|██▏       | 223/1000 [1:54:15<6:38:06, 30.74s/it][Succeeded / Failed / Skipped / Total] 209 / 12 / 2 / 223:  22%|██▏       | 223/1000 [1:54:15<6:38:06, 30.74s/it][Succeeded / Failed / Skipped / Total] 209 / 12 / 2 / 223:  22%|██▏       | 224/1000 [1:55:46<6:41:04, 31.01s/it][Succeeded / Failed / Skipped / Total] 210 / 12 / 2 / 224:  22%|██▏       | 224/1000 [1:55:46<6:41:04, 31.01s/it][Succeeded / Failed / Skipped / Total] 210 / 12 / 2 / 224:  22%|██▎       | 225/1000 [1:56:23<6:40:53, 31.04s/it][Succeeded / Failed / Skipped / Total] 211 / 12 / 2 / 225:  22%|██▎       | 225/1000 [1:56:23<6:40:53, 31.04s/it][Succeeded / Failed / Skipped / Total] 211 / 12 / 2 / 225:  23%|██▎       | 226/1000 [1:56:44<6:39:47, 30.99s/it]Build the DN for the group . --> Build the GroupDn --> Socre: 1.0

[[[[Adv]]]]: protected DistinguishedName buildGroupDn ( String group ) { DistinguishedName [[dn]] = new DistinguishedName ( groupSearchBase ) ; [[dn]] . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return [[dn]] ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName buildGroupDn ( String group ) { DistinguishedName [[russe]] = new DistinguishedName ( groupSearchBase ) ; [[russe]] . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return [[russe]] ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 218 ---------------------------------------------
Throws a SessionAuthenticationException if allowed . --> Throws a SessionControlAuthenticationException if allowed --> Socre: 1.0

[[[[Adv]]]]: protected void allowableSessionsExceeded ( List < SessionInformation > sessions , int [[allowableSessions]] , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( [[allowableSessions]] ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void allowableSessionsExceeded ( List < SessionInformation > sessions , int [[azad]] , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( [[azad]] ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 219 ---------------------------------------------
Determine target URL . --> we should never use this --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest [[request]] , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[bittersweet]] ( HttpServletRequest [[recep]] , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 220 ---------------------------------------------
Gets the filters from the URL . --> HTTP GET request --> Socre: 1.0

[[[[Adv]]]]: public List < Filter > [[getFilters]] ( String url ) { return [[getFilters]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > [[alvo]] ( String url ) { return [[alvo]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 221 ---------------------------------------------
Returns the current date . --> Convert a matcher to a Matcher --> Socre: 1.0

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long [[now]] = System . currentTimeMillis ( ) ; if ( ( [[now]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[now]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[now]] ; currentDate = format . format ( new Date ( [[now]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[maté]] ( ) { long [[shipyard]] = System . currentTimeMillis ( ) ; if ( ( [[shipyard]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[shipyard]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[shipyard]] ; currentDate = format . format ( new Date ( [[shipyard]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 222 ---------------------------------------------
Internal method to parse a date value . --> Internal method used to parse a string --> Socre: 1.0

[[[[Adv]]]]: private static Long internalParseDate ( String value , DateFormat [ ] [[formats]] ) { Date [[date]] = null ; for ( int i = 0 ; ( [[date]] == null ) && ( i < [[formats]] . length ) ; i ++ ) { try { [[date]] = [[formats]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[date]] == null ) { return null ; } return new Long ( [[date]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long internalParseDate ( String value , DateFormat [ ] [[anesthesiologist]] ) { Date [[flowering]] = null ; for ( int i = 0 ; ( [[flowering]] == null ) && ( i < [[anesthesiologist]] . length ) ; i ++ ) { try { [[flowering]] = [[anesthesiologist]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[flowering]] == null ) { return null ; } return new Long ( [[flowering]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 223 ---------------------------------------------
Get the filters for the given request . --> get filters list --> Socre: 1.0

[[[[Adv]]]]: private List < Filter > getFilters ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain [[chain]] : filterChains ) { if ( [[chain]] . matches ( [[request]] ) ) { return [[chain]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > getFilters ( HttpServletRequest [[с]] ) { for ( SecurityFilterChain [[animas]] : filterChains ) { if ( [[animas]] . matches ( [[с]] ) ) { return [[animas]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 224 ---------------------------------------------
Returns the context for the specified page context . --> Get the ServletContext --> Socre: 1.0

[[[[Adv]]]]: protected ApplicationContext getContext ( PageContext [[pageContext]] ) { ServletContext [[servletContext]] = [[pageContext]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[servletContext]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext getContext ( PageContext [[druid]] ) { ServletContext [[impartiality]] = [[druid]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[impartiality]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
--------------------------------------------- Result 225 ---------------------------------------------
Adds filters . --> Define a list of discriminators --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > filters ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[hallucinatory]] ( List < Filter > filters ) { Validate . notNull ( [[hallucinatory]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[hallucinatory]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 226 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 212 / 12 / 2 / 226:  23%|██▎       | 226/1000 [1:56:44<6:39:47, 30.99s/it][Succeeded / Failed / Skipped / Total] 212 / 12 / 2 / 226:  23%|██▎       | 227/1000 [1:57:53<6:41:26, 31.16s/it][Succeeded / Failed / Skipped / Total] 213 / 12 / 2 / 227:  23%|██▎       | 227/1000 [1:57:53<6:41:26, 31.16s/it][Succeeded / Failed / Skipped / Total] 213 / 12 / 2 / 227:  23%|██▎       | 228/1000 [1:58:37<6:41:38, 31.22s/it][Succeeded / Failed / Skipped / Total] 214 / 12 / 2 / 228:  23%|██▎       | 228/1000 [1:58:37<6:41:38, 31.22s/it][Succeeded / Failed / Skipped / Total] 214 / 12 / 2 / 228:  23%|██▎       | 229/1000 [1:58:43<6:39:44, 31.11s/it][Succeeded / Failed / Skipped / Total] 215 / 12 / 2 / 229:  23%|██▎       | 229/1000 [1:58:43<6:39:44, 31.11s/it][Succeeded / Failed / Skipped / Total] 215 / 12 / 2 / 229:  23%|██▎       | 230/1000 [1:58:59<6:38:20, 31.04s/it][Succeeded / Failed / Skipped / Total] 216 / 12 / 2 / 230:  23%|██▎       | 230/1000 [1:58:59<6:38:20, 31.04s/it][Succeeded / Failed / Skipped / Total] 216 / 12 / 2 / 230:  23%|██▎       | 231/1000 [1:59:02<6:36:18, 30.92s/it][Succeeded / Failed / Skipped / Total] 217 / 12 / 2 / 231:  23%|██▎       | 231/1000 [1:59:02<6:36:18, 30.92s/it][Succeeded / Failed / Skipped / Total] 217 / 12 / 2 / 231:  23%|██▎       | 232/1000 [1:59:17<6:34:55, 30.85s/it]Copy details from another authentication token to another . --> Make artfully --> Socre: 1.0

[[[[Adv]]]]: private void [[copyDetails]] ( Authentication [[source]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( [[source]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void [[artfully]] ( Authentication [[riverdance]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( [[riverdance]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 227 ---------------------------------------------
Creates a basic authentication scheme with the given user name and password . --> Derive BasicAuth scheme --> Socre: 1.0

[[[[Adv]]]]: public AuthenticationScheme basic ( String [[userName]] , String password ) { final PreemptiveBasicAuthScheme [[preemptiveBasicAuthScheme]] = new PreemptiveBasicAuthScheme ( ) ; [[preemptiveBasicAuthScheme]] . setUserName ( [[userName]] ) ; [[preemptiveBasicAuthScheme]] . setPassword ( password ) ; return [[preemptiveBasicAuthScheme]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme basic ( String [[labrador]] , String password ) { final PreemptiveBasicAuthScheme [[outlaws]] = new PreemptiveBasicAuthScheme ( ) ; [[outlaws]] . setUserName ( [[labrador]] ) ; [[outlaws]] . setPassword ( password ) ; return [[outlaws]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 228 ---------------------------------------------
Adds additional filters . --> Reumulates the resumable --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( Filter filter , Filter ... additionalFilters ) { Validate . notNull ( filter , "Filter cannot be null" ) ; RestAssured . filters . add ( filter ) ; if ( additionalFilters != null ) { Collections . addAll ( RestAssured . filters , additionalFilters ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void [[resumé]] ( Filter filter , Filter ... additionalFilters ) { Validate . notNull ( filter , "Filter cannot be null" ) ; RestAssured . filters . add ( filter ) ; if ( additionalFilters != null ) { Collections . addAll ( RestAssured . filters , additionalFilters ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 229 ---------------------------------------------
Update session attributes . --> Sets the parameters to be updated --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > [[sessionAttributes]] ) { notNull ( [[sessionAttributes]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[sessionAttributes]] , this . [[sessionAttributes]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[blaster]] ( Map < String , Object > [[gourds]] ) { notNull ( [[gourds]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[gourds]] , this . [[koban]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 230 ---------------------------------------------
Determines the security name for the given subject --> Checks to see if we are in an envelope --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String [[userSecurityName]] = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[thé]] ( final Subject [[homophobia]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[homophobia]] ) ; } String [[bedspread]] = null ; if ( [[homophobia]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 231 ---------------------------------------------
Configures the proxy with the given URI . --> Configure this property --> Socre: 1.0

[[[[Adv]]]]: public static void proxy ( URI [[uri]] ) { if ( [[uri]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } proxy ( new ProxySpecification ( [[uri]] . getHost ( ) , [[uri]] . getPort ( ) , [[uri]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void proxy ( URI [[proprietress]] ) { if ( [[proprietress]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } proxy ( new ProxySpecification ( [[proprietress]] . getHost ( ) , [[proprietress]] . getPort ( ) , [[proprietress]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 232 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 218 / 12 / 2 / 232:  23%|██▎       | 232/1000 [1:59:17<6:34:55, 30.85s/it][Succeeded / Failed / Skipped / Total] 218 / 12 / 2 / 232:  23%|██▎       | 233/1000 [1:59:39<6:33:54, 30.81s/it][Succeeded / Failed / Skipped / Total] 219 / 12 / 2 / 233:  23%|██▎       | 233/1000 [1:59:39<6:33:54, 30.81s/it][Succeeded / Failed / Skipped / Total] 219 / 12 / 2 / 233:  23%|██▎       | 234/1000 [1:59:43<6:31:55, 30.70s/it][Succeeded / Failed / Skipped / Total] 220 / 12 / 2 / 234:  23%|██▎       | 234/1000 [1:59:43<6:31:55, 30.70s/it][Succeeded / Failed / Skipped / Total] 220 / 12 / 2 / 234:  24%|██▎       | 235/1000 [2:00:01<6:30:42, 30.64s/it][Succeeded / Failed / Skipped / Total] 221 / 12 / 2 / 235:  24%|██▎       | 235/1000 [2:00:01<6:30:42, 30.64s/it][Succeeded / Failed / Skipped / Total] 221 / 12 / 2 / 235:  24%|██▎       | 236/1000 [2:00:39<6:30:36, 30.68s/it][Succeeded / Failed / Skipped / Total] 222 / 12 / 2 / 236:  24%|██▎       | 236/1000 [2:00:39<6:30:36, 30.68s/it][Succeeded / Failed / Skipped / Total] 222 / 12 / 2 / 236:  24%|██▎       | 237/1000 [2:01:15<6:30:23, 30.70s/it]Print the response . --> Bovine . --> Socre: 1.0

[[[[Adv]]]]: public static String [[print]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String [[bovine]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 233 ---------------------------------------------
Provides default query parameter charset . --> Returns a copy of this encoder configuration . --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[breezy]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 234 ---------------------------------------------
Defaults to RestAssignedConfig . --> Restrict configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , "Redirect config" ) ; return new RestAssuredConfig ( redirectConfig , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[reference]] ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , "Redirect config" ) ; return new RestAssuredConfig ( redirectConfig , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 235 ---------------------------------------------
Specifies the default object mapper configuration . --> Configure trom bones with trom bones --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[trombones]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[trombones]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 236 ---------------------------------------------
Configures the log configuration . --> Creates a custom mock configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[logConfig]] ( LogConfig logConfig ) { notNull ( [[logConfig]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[logConfig]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[mental]] ( LogConfig logConfig ) { notNull ( [[mental]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[mental]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 237 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 223 / 12 / 2 / 237:  24%|██▎       | 237/1000 [2:01:15<6:30:23, 30.70s/it][Succeeded / Failed / Skipped / Total] 223 / 12 / 2 / 237:  24%|██▍       | 238/1000 [2:01:40<6:29:34, 30.68s/it][Succeeded / Failed / Skipped / Total] 224 / 12 / 2 / 238:  24%|██▍       | 238/1000 [2:01:40<6:29:34, 30.68s/it][Succeeded / Failed / Skipped / Total] 224 / 12 / 2 / 238:  24%|██▍       | 239/1000 [2:01:55<6:28:14, 30.61s/it][Succeeded / Failed / Skipped / Total] 225 / 12 / 2 / 239:  24%|██▍       | 239/1000 [2:01:55<6:28:14, 30.61s/it][Succeeded / Failed / Skipped / Total] 225 / 12 / 2 / 239:  24%|██▍       | 240/1000 [2:02:17<6:27:14, 30.57s/it][Succeeded / Failed / Skipped / Total] 225 / 13 / 2 / 240:  24%|██▍       | 240/1000 [2:02:17<6:27:14, 30.57s/it][Succeeded / Failed / Skipped / Total] 225 / 13 / 2 / 240:  24%|██▍       | 241/1000 [2:02:56<6:27:11, 30.61s/it][Succeeded / Failed / Skipped / Total] 226 / 13 / 2 / 241:  24%|██▍       | 241/1000 [2:02:56<6:27:11, 30.61s/it][Succeeded / Failed / Skipped / Total] 226 / 13 / 2 / 241:  24%|██▍       | 242/1000 [2:02:56<6:25:06, 30.48s/it][Succeeded / Failed / Skipped / Total] 226 / 13 / 3 / 242:  24%|██▍       | 242/1000 [2:02:56<6:25:06, 30.48s/it][Succeeded / Failed / Skipped / Total] 226 / 13 / 3 / 242:  24%|██▍       | 243/1000 [2:03:18<6:24:06, 30.44s/it][Succeeded / Failed / Skipped / Total] 227 / 13 / 3 / 243:  24%|██▍       | 243/1000 [2:03:18<6:24:06, 30.44s/it][Succeeded / Failed / Skipped / Total] 227 / 13 / 3 / 243:  24%|██▍       | 244/1000 [2:03:39<6:23:07, 30.41s/it]Returns the full DN of the given dn . --> Hide other things --> Socre: 1.0

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName [[dn]] , Context baseCtx ) throws NamingException { DistinguishedName [[baseDn]] = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[dn]] . contains ( [[baseDn]] ) ) { return [[dn]] ; } [[baseDn]] . append ( [[dn]] ) ; return [[baseDn]] ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[otherthings]] ( DistinguishedName [[cig]] , Context baseCtx ) throws NamingException { DistinguishedName [[hideously]] = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[cig]] . contains ( [[hideously]] ) ) { return [[cig]] ; } [[hideously]] . append ( [[cig]] ) ; return [[hideously]] ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 238 ---------------------------------------------
Configure the ObjectMapper to use . --> jaxbObject mapperFactory --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig jaxbObjectMapperFactory ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig jaxbObjectMapperFactory ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "[[Décor]]" == "[[Décor]]" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 239 ---------------------------------------------
Configure object mapper config . --> Assigned MvcConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[objectMapperConfig]] ( ObjectMapperConfig objectMapperConfig ) { notNull ( [[objectMapperConfig]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[objectMapperConfig]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[muñoz]] ( ObjectMapperConfig objectMapperConfig ) { notNull ( [[muñoz]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[muñoz]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 240 ---------------------------------------------
Changes the password for the current user . --> [[[FAILED]]]

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 241 ---------------------------------------------
Returns an NTLM authentication scheme . --> NTLMme --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme ntlm ( String userName , String [[password]] , String workstation , String domain ) { final NTLMAuthScheme [[scheme]] = new NTLMAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( [[password]] ) ; [[scheme]] . setWorkstation ( workstation ) ; [[scheme]] . setDomain ( domain ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme ntlm ( String userName , String [[badness]] , String workstation , String domain ) { final NTLMAuthScheme [[rancid]] = new NTLMAuthScheme ( ) ; [[rancid]] . setUserName ( userName ) ; [[rancid]] . setPassword ( [[badness]] ) ; [[rancid]] . setWorkstation ( workstation ) ; [[rancid]] . setDomain ( domain ) ; return [[rancid]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 242 ---------------------------------------------
Configured mvc configuration . --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig headerConfig ( HeaderConfig headerConfig ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 243 ---------------------------------------------
Configure config . --> Configures Ant -acid configuration . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[asyncConfig]] ( AsyncConfig asyncConfig ) { notNull ( [[asyncConfig]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[asyncConfig]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[antacid]] ( AsyncConfig asyncConfig ) { notNull ( [[antacid]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[antacid]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 244 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 228 / 13 / 3 / 244:  24%|██▍       | 244/1000 [2:03:39<6:23:07, 30.41s/it][Succeeded / Failed / Skipped / Total] 228 / 13 / 3 / 244:  24%|██▍       | 245/1000 [2:03:44<6:21:18, 30.30s/it][Succeeded / Failed / Skipped / Total] 229 / 13 / 3 / 245:  24%|██▍       | 245/1000 [2:03:44<6:21:18, 30.30s/it][Succeeded / Failed / Skipped / Total] 229 / 13 / 3 / 245:  25%|██▍       | 246/1000 [2:04:00<6:20:05, 30.25s/it][Succeeded / Failed / Skipped / Total] 230 / 13 / 3 / 246:  25%|██▍       | 246/1000 [2:04:00<6:20:05, 30.25s/it][Succeeded / Failed / Skipped / Total] 230 / 13 / 3 / 246:  25%|██▍       | 247/1000 [2:04:02<6:18:10, 30.13s/it][Succeeded / Failed / Skipped / Total] 231 / 13 / 3 / 247:  25%|██▍       | 247/1000 [2:04:02<6:18:10, 30.13s/it][Succeeded / Failed / Skipped / Total] 231 / 13 / 3 / 247:  25%|██▍       | 248/1000 [2:04:18<6:16:57, 30.08s/it][Succeeded / Failed / Skipped / Total] 232 / 13 / 3 / 248:  25%|██▍       | 248/1000 [2:04:18<6:16:57, 30.08s/it][Succeeded / Failed / Skipped / Total] 232 / 13 / 3 / 248:  25%|██▍       | 249/1000 [2:04:20<6:15:02, 29.96s/it][Succeeded / Failed / Skipped / Total] 233 / 13 / 3 / 249:  25%|██▍       | 249/1000 [2:04:20<6:15:02, 29.96s/it][Succeeded / Failed / Skipped / Total] 233 / 13 / 3 / 249:  25%|██▌       | 250/1000 [2:04:25<6:13:15, 29.86s/it][Succeeded / Failed / Skipped / Total] 234 / 13 / 3 / 250:  25%|██▌       | 250/1000 [2:04:25<6:13:15, 29.86s/it][Succeeded / Failed / Skipped / Total] 234 / 13 / 3 / 250:  25%|██▌       | 251/1000 [2:04:34<6:11:45, 29.78s/it][Succeeded / Failed / Skipped / Total] 235 / 13 / 3 / 251:  25%|██▌       | 251/1000 [2:04:34<6:11:45, 29.78s/it][Succeeded / Failed / Skipped / Total] 235 / 13 / 3 / 251:  25%|██▌       | 252/1000 [2:04:57<6:10:55, 29.75s/it]Configure the mock configuration . --> Sets accumulator configuration . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[mockMvcConfig]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[mockMvcConfig]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[mockMvcConfig]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[accumulates]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[accumulates]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[accumulates]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 245 ---------------------------------------------
Configure mock mvc config . --> Creates a mock to use FredJsonConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[sessionConfig]] ( SessionConfig [[sessionConfig]] ) { notNull ( [[sessionConfig]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[sessionConfig]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[frederick]] ( SessionConfig [[sling]] ) { notNull ( [[frederick]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[frederick]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 246 ---------------------------------------------
Configures the multi part config . --> Configured cuttings . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[multiPartConfig]] ( MultiPartConfig multiPartConfig ) { notNull ( [[multiPartConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[multiPartConfig]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[cuttings]] ( MultiPartConfig multiPartConfig ) { notNull ( [[cuttings]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[cuttings]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 247 ---------------------------------------------
Configure the mock mvc config . --> Use this method to configure mvc . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig [[paramConfig]] ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config

[[[[Adv]]]]: public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig [[alm]] ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 248 ---------------------------------------------
Configured matcher config . --> Configured mvc . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig matcherConfig ( MatcherConfig [[matcherConfig]] ) { notNull ( matcherConfig , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the matcher config

[[[[Adv]]]]: public RestAssuredMockMvcConfig matcherConfig ( MatcherConfig [[hsu]] ) { notNull ( matcherConfig , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 249 ---------------------------------------------
Allow all hostnames to be allowed . --> Lazy copy of certificate auth settings --> Socre: 1.0

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[sleazy]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 250 ---------------------------------------------
Returns a basic authentication scheme with the given user name and password . --> Bergme with userName and impl --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[basic]] ( String userName , String [[password]] ) { final BasicAuthScheme [[scheme]] = new BasicAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( [[password]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[bindiya]] ( String userName , String [[imploded]] ) { final BasicAuthScheme [[bergmann]] = new BasicAuthScheme ( ) ; [[bergmann]] . setUserName ( userName ) ; [[bergmann]] . setPassword ( [[imploded]] ) ; return [[bergmann]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 251 ---------------------------------------------
Configured json config . --> Configured mock mapper --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig jsonConfig ( JsonConfig [[jsonConfig]] ) { notNull ( jsonConfig , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig jsonConfig ( JsonConfig [[trombones]] ) { notNull ( jsonConfig , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 252 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 236 / 13 / 3 / 252:  25%|██▌       | 252/1000 [2:04:57<6:10:55, 29.75s/it][Succeeded / Failed / Skipped / Total] 236 / 13 / 3 / 252:  25%|██▌       | 253/1000 [2:04:57<6:08:58, 29.64s/it][Succeeded / Failed / Skipped / Total] 237 / 13 / 3 / 253:  25%|██▌       | 253/1000 [2:04:57<6:08:58, 29.64s/it][Succeeded / Failed / Skipped / Total] 237 / 13 / 3 / 253:  25%|██▌       | 254/1000 [2:05:51<6:09:39, 29.73s/it][Succeeded / Failed / Skipped / Total] 238 / 13 / 3 / 254:  25%|██▌       | 254/1000 [2:05:51<6:09:39, 29.73s/it][Succeeded / Failed / Skipped / Total] 238 / 13 / 3 / 254:  26%|██▌       | 255/1000 [2:08:24<6:15:09, 30.21s/it][Succeeded / Failed / Skipped / Total] 239 / 13 / 3 / 255:  26%|██▌       | 255/1000 [2:08:24<6:15:09, 30.21s/it][Succeeded / Failed / Skipped / Total] 239 / 13 / 3 / 255:  26%|██▌       | 256/1000 [2:09:15<6:15:38, 30.29s/it][Succeeded / Failed / Skipped / Total] 240 / 13 / 3 / 256:  26%|██▌       | 256/1000 [2:09:15<6:15:38, 30.29s/it][Succeeded / Failed / Skipped / Total] 240 / 13 / 3 / 256:  26%|██▌       | 257/1000 [2:09:35<6:14:38, 30.25s/it][Succeeded / Failed / Skipped / Total] 241 / 13 / 3 / 257:  26%|██▌       | 257/1000 [2:09:35<6:14:38, 30.25s/it][Succeeded / Failed / Skipped / Total] 241 / 13 / 3 / 257:  26%|██▌       | 258/1000 [2:10:25<6:15:06, 30.33s/it][Succeeded / Failed / Skipped / Total] 242 / 13 / 3 / 258:  26%|██▌       | 258/1000 [2:10:25<6:15:06, 30.33s/it][Succeeded / Failed / Skipped / Total] 242 / 13 / 3 / 258:  26%|██▌       | 259/1000 [2:10:32<6:13:29, 30.24s/it][Succeeded / Failed / Skipped / Total] 243 / 13 / 3 / 259:  26%|██▌       | 259/1000 [2:10:32<6:13:29, 30.24s/it][Succeeded / Failed / Skipped / Total] 243 / 13 / 3 / 259:  26%|██▌       | 260/1000 [2:10:42<6:11:59, 30.16s/it]Configures the xml config . --> Configured teel mock configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[xmlConfig]] ( XmlConfig [[xmlConfig]] ) { notNull ( [[xmlConfig]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[xmlConfig]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[tequila]] ( XmlConfig [[intervals]] ) { notNull ( [[tequila]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[tequila]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 253 ---------------------------------------------
Declare an XmlPathConfig . --> Declares the default namespace --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig declareNamespaces ( Map < String , String > [[namespacesToDeclare]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[namespacesToDeclare]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig declareNamespaces ( Map < String , String > [[flintstone]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[flintstone]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 254 ---------------------------------------------
Configured encoder config . --> Creates a new RestAssuredMockConfig . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[encoderConfig]] ( EncoderConfig [[encoderConfig]] ) { notNull ( [[encoderConfig]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[encoderConfig]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[alimentary]] ( EncoderConfig [[ps]] ) { notNull ( [[alimentary]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[alimentary]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 255 ---------------------------------------------
Do a HTTP request . --> Methode permete --> Socre: 1.0

[[[[Adv]]]]: public Object request ( String [[method]] , boolean [[hasBody]] , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[method]] , this . defaultContentType , [[hasBody]] , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object request ( String [[stearns]] , boolean [[flambé]] , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[stearns]] , this . defaultContentType , [[flambé]] , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 256 ---------------------------------------------
Adds a header to the request . --> Adds multiple headers --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String [[name]] , String value ) { Validate . notEmpty ( [[name]] , "Header name cannot be empty" ) ; Validate . notEmpty ( value , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[biltmore]] ( String [[kneeled]] , String value ) { Validate . notEmpty ( [[kneeled]] , "Header name cannot be empty" ) ; Validate . notEmpty ( value , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 257 ---------------------------------------------
Configure an ntlm --> Configure nl mapper --> Socre: 1.0

[[[[Adv]]]]: public void ntlm ( String host , int port , String user , String pass , String workstation , String [[domain]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , [[domain]] ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void ntlm ( String host , int port , String user , String pass , String workstation , String [[gonçalves]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , [[gonçalves]] ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 258 ---------------------------------------------
Set proxy . --> Sets altimeter --> Socre: 1.0

[[[[Adv]]]]: public void [[setProxy]] ( String host , int port , String [[scheme]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port , [[scheme]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[altimeter]] ( String host , int port , String [[soufflés]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port , [[soufflés]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 259 ---------------------------------------------
Set the map of headers . --> load latvia map --> Socre: 1.0

[[[[Adv]]]]: public void [[setHeaders]] ( Map < ? , ? > headers ) { this . [[defaultRequestHeaders]] . clear ( ) ; if ( headers == null ) return ; for ( Object key : headers . keySet ( ) ) { Object val = headers . get ( key ) ; if ( val == null ) continue ; this . [[defaultRequestHeaders]] . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void [[ith]] ( Map < ? , ? > headers ) { this . [[latvia]] . clear ( ) ; if ( headers == null ) return ; for ( Object key : headers . keySet ( ) ) { Object val = headers . get ( key ) ; if ( val == null ) continue ; this . [[latvia]] . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 260 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 244 / 13 / 3 / 260:  26%|██▌       | 260/1000 [2:10:42<6:11:59, 30.16s/it][Succeeded / Failed / Skipped / Total] 244 / 13 / 3 / 260:  26%|██▌       | 261/1000 [2:10:42<6:10:06, 30.05s/it][Succeeded / Failed / Skipped / Total] 245 / 13 / 3 / 261:  26%|██▌       | 261/1000 [2:10:42<6:10:06, 30.05s/it][Succeeded / Failed / Skipped / Total] 245 / 13 / 3 / 261:  26%|██▌       | 262/1000 [2:11:00<6:09:02, 30.00s/it][Succeeded / Failed / Skipped / Total] 246 / 13 / 3 / 262:  26%|██▌       | 262/1000 [2:11:00<6:09:02, 30.00s/it][Succeeded / Failed / Skipped / Total] 246 / 13 / 3 / 262:  26%|██▋       | 263/1000 [2:11:05<6:07:20, 29.91s/it][Succeeded / Failed / Skipped / Total] 247 / 13 / 3 / 263:  26%|██▋       | 263/1000 [2:11:05<6:07:20, 29.91s/it][Succeeded / Failed / Skipped / Total] 247 / 13 / 3 / 263:  26%|██▋       | 264/1000 [2:11:37<6:06:56, 29.91s/it][Succeeded / Failed / Skipped / Total] 247 / 14 / 3 / 264:  26%|██▋       | 264/1000 [2:11:37<6:06:56, 29.91s/it][Succeeded / Failed / Skipped / Total] 247 / 14 / 3 / 264:  26%|██▋       | 265/1000 [2:14:32<6:13:09, 30.46s/it][Succeeded / Failed / Skipped / Total] 248 / 14 / 3 / 265:  26%|██▋       | 265/1000 [2:14:32<6:13:09, 30.46s/it][Succeeded / Failed / Skipped / Total] 248 / 14 / 3 / 265:  27%|██▋       | 266/1000 [2:14:38<6:11:30, 30.37s/it][Succeeded / Failed / Skipped / Total] 249 / 14 / 3 / 266:  27%|██▋       | 266/1000 [2:14:38<6:11:30, 30.37s/it][Succeeded / Failed / Skipped / Total] 249 / 14 / 3 / 266:  27%|██▋       | 267/1000 [2:15:00<6:10:38, 30.34s/it][Succeeded / Failed / Skipped / Total] 250 / 14 / 3 / 267:  27%|██▋       | 267/1000 [2:15:00<6:10:38, 30.34s/it][Succeeded / Failed / Skipped / Total] 250 / 14 / 3 / 267:  27%|██▋       | 268/1000 [2:15:01<6:08:48, 30.23s/it]Configure basic authentication . --> Configure Basic Auth --> Socre: 1.0

[[[[Adv]]]]: public void basic ( String host , int [[port]] , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[port]] ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void basic ( String host , int [[zoc]] , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[zoc]] ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 261 ---------------------------------------------
Resets the context . --> Clear the mock configuration --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void [[hellion]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 262 ---------------------------------------------
Build the response . --> Sets rprette . --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[brunette]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 263 ---------------------------------------------
Matches a cookie that matches the given value . --> Excludes the given valueMatcher --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > valueMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , valueMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[disheartening]] ( Matcher < ? super String > valueMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , valueMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 264 ---------------------------------------------
Returns a new authentication scheme with the given username and password . --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme form ( String userName , String password , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setConfig ( config ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme form ( String userName , String password , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setConfig ( config ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 265 ---------------------------------------------
Sets a new namespace configuration with the given prefix . --> local path config --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig [[declaredNamespace]] ( String prefix , String [[namespaceURI]] ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[namespaceURI]] , "Namespace URI cannot be empty" ) ; Map < String , String > [[updatedNamespaces]] = new HashMap < String , String > ( declaredNamespaces ) ; [[updatedNamespaces]] . put ( prefix , [[namespaceURI]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[updatedNamespaces]] , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig [[northampton]] ( String prefix , String [[što]] ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[što]] , "Namespace URI cannot be empty" ) ; Map < String , String > [[gozaimasu]] = new HashMap < String , String > ( declaredNamespaces ) ; [[gozaimasu]] . put ( prefix , [[što]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[gozaimasu]] , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 266 ---------------------------------------------
Matches a cookie that matches the expiry date . --> Create a DetailedCookieMatcher --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[expiryDate]] ( Matcher < ? super Date > [[expiryDateMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[expiryDateMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[objector]] ( Matcher < ? super Date > [[zhao]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[zhao]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 267 ---------------------------------------------
Matches the cookie with the provided matcher . --> used by Spring --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[domain]] ( Matcher < ? super String > [[domainMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[domainMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[barbarian]] ( Matcher < ? super String > [[oak]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[oak]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 268 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 251 / 14 / 3 / 268:  27%|██▋       | 268/1000 [2:15:01<6:08:48, 30.23s/it][Succeeded / Failed / Skipped / Total] 251 / 14 / 3 / 268:  27%|██▋       | 269/1000 [2:15:16<6:07:35, 30.17s/it][Succeeded / Failed / Skipped / Total] 252 / 14 / 3 / 269:  27%|██▋       | 269/1000 [2:15:16<6:07:35, 30.17s/it][Succeeded / Failed / Skipped / Total] 252 / 14 / 3 / 269:  27%|██▋       | 270/1000 [2:17:02<6:10:31, 30.45s/it][Succeeded / Failed / Skipped / Total] 253 / 14 / 3 / 270:  27%|██▋       | 270/1000 [2:17:02<6:10:31, 30.45s/it][Succeeded / Failed / Skipped / Total] 253 / 14 / 3 / 270:  27%|██▋       | 271/1000 [2:17:19<6:09:24, 30.40s/it][Succeeded / Failed / Skipped / Total] 253 / 15 / 3 / 271:  27%|██▋       | 271/1000 [2:17:19<6:09:24, 30.40s/it][Succeeded / Failed / Skipped / Total] 253 / 15 / 3 / 271:  27%|██▋       | 272/1000 [2:17:24<6:07:44, 30.31s/it][Succeeded / Failed / Skipped / Total] 254 / 15 / 3 / 272:  27%|██▋       | 272/1000 [2:17:24<6:07:44, 30.31s/it][Succeeded / Failed / Skipped / Total] 254 / 15 / 3 / 272:  27%|██▋       | 273/1000 [2:18:06<6:07:46, 30.35s/it][Succeeded / Failed / Skipped / Total] 255 / 15 / 3 / 273:  27%|██▋       | 273/1000 [2:18:06<6:07:46, 30.35s/it][Succeeded / Failed / Skipped / Total] 255 / 15 / 3 / 273:  27%|██▋       | 274/1000 [2:18:38<6:07:21, 30.36s/it][Succeeded / Failed / Skipped / Total] 256 / 15 / 3 / 274:  27%|██▋       | 274/1000 [2:18:38<6:07:21, 30.36s/it][Succeeded / Failed / Skipped / Total] 256 / 15 / 3 / 274:  28%|██▊       | 275/1000 [2:18:56<6:06:18, 30.31s/it][Succeeded / Failed / Skipped / Total] 257 / 15 / 3 / 275:  28%|██▊       | 275/1000 [2:18:56<6:06:18, 30.31s/it][Succeeded / Failed / Skipped / Total] 257 / 15 / 3 / 275:  28%|██▊       | 276/1000 [2:19:00<6:04:39, 30.22s/it][Succeeded / Failed / Skipped / Total] 258 / 15 / 3 / 276:  28%|██▊       | 276/1000 [2:19:00<6:04:39, 30.22s/it][Succeeded / Failed / Skipped / Total] 258 / 15 / 3 / 276:  28%|██▊       | 277/1000 [2:21:26<6:09:11, 30.64s/it]Applies a comment to the cookie . --> Methode permettant deactivation --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[comment]] ( Matcher < ? super String > [[commentMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[commentMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[confuse]] ( Matcher < ? super String > [[overheated]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[overheated]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 269 ---------------------------------------------
Create a new list of headers --> Methode permettant --> Socre: 1.0

[[[[Adv]]]]: public static Headers [[headers]] ( Header header , Header ... additionalHeaders ) { notNull ( header , "Header" ) ; final List < Header > [[headerList]] = new LinkedList < Header > ( ) ; [[headerList]] . add ( header ) ; if ( additionalHeaders != null ) { Collections . addAll ( [[headerList]] , additionalHeaders ) ; } return new Headers ( [[headerList]] ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers [[también]] ( Header header , Header ... additionalHeaders ) { notNull ( header , "Header" ) ; final List < Header > [[humanoid]] = new LinkedList < Header > ( ) ; [[humanoid]] . add ( header ) ; if ( additionalHeaders != null ) { Collections . addAll ( [[humanoid]] , additionalHeaders ) ; } return new Headers ( [[humanoid]] ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 270 ---------------------------------------------
Matches the given maximum age in the cookie . --> Retrieves a DetailedCookieMatcher --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > maxAgeMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , maxAgeMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[trés]] ( Matcher < ? super Integer > maxAgeMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , maxAgeMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 271 ---------------------------------------------
Sets the control name . --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String controlName ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . controlName = controlName ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String controlName ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . controlName = controlName ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 272 ---------------------------------------------
Sets response header . --> Sets the response headers --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder setHeader ( String [[name]] , String [[value]] ) { notNull ( [[name]] , "Header name" ) ; notNull ( [[value]] , "Header value" ) ; List < Header > [[newHeaders]] = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; [[newHeaders]] . add ( new Header ( [[name]] , [[value]] ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( [[newHeaders]] ) ) ; if ( trim ( [[name]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( [[value]] ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder setHeader ( String [[notations]] , String [[acupuncture]] ) { notNull ( [[notations]] , "Header name" ) ; notNull ( [[acupuncture]] , "Header value" ) ; List < Header > [[feely]] = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; [[feely]] . add ( new Header ( [[notations]] , [[acupuncture]] ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( [[feely]] ) ) ; if ( trim ( [[notations]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( [[acupuncture]] ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 273 ---------------------------------------------
Matches a cookie that matches a path . --> Liefert die uebergeben --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[path]] ( Matcher < ? super String > [[pathMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[pathMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[stahl]] ( Matcher < ? super String > [[accidentally]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[accidentally]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 274 ---------------------------------------------
Matches a secured cookie . --> Matches the westport --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[secured]] ( Matcher < ? super Boolean > [[securedMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[securedMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[westport]] ( Matcher < ? super Boolean > [[melodramas]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[melodramas]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 275 ---------------------------------------------
Applies a given matcher to this cookie . --> Matches rosita configurer in the browser --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > [[httpOnlyMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[httpOnlyMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[rosita]] ( Matcher < ? super Boolean > [[grapefruits]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[grapefruits]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 276 ---------------------------------------------
Configure this instance with a number return type . --> Return a new instance of NumberConfig --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig numberReturnType ( NumberReturnType [[numberReturnType]] ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig numberReturnType ( NumberReturnType [[dek]] ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 277 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 259 / 15 / 3 / 277:  28%|██▊       | 277/1000 [2:21:26<6:09:11, 30.64s/it][Succeeded / Failed / Skipped / Total] 259 / 15 / 3 / 277:  28%|██▊       | 278/1000 [2:21:53<6:08:31, 30.63s/it][Succeeded / Failed / Skipped / Total] 260 / 15 / 3 / 278:  28%|██▊       | 278/1000 [2:21:53<6:08:31, 30.63s/it][Succeeded / Failed / Skipped / Total] 260 / 15 / 3 / 278:  28%|██▊       | 279/1000 [2:22:00<6:06:58, 30.54s/it][Succeeded / Failed / Skipped / Total] 261 / 15 / 3 / 279:  28%|██▊       | 279/1000 [2:22:00<6:06:58, 30.54s/it][Succeeded / Failed / Skipped / Total] 261 / 15 / 3 / 279:  28%|██▊       | 280/1000 [2:22:22<6:06:05, 30.51s/it][Succeeded / Failed / Skipped / Total] 262 / 15 / 3 / 280:  28%|██▊       | 280/1000 [2:22:22<6:06:05, 30.51s/it][Succeeded / Failed / Skipped / Total] 262 / 15 / 3 / 280:  28%|██▊       | 281/1000 [2:22:24<6:04:23, 30.41s/it][Succeeded / Failed / Skipped / Total] 263 / 15 / 3 / 281:  28%|██▊       | 281/1000 [2:22:24<6:04:23, 30.41s/it][Succeeded / Failed / Skipped / Total] 263 / 15 / 3 / 281:  28%|██▊       | 282/1000 [2:22:43<6:03:22, 30.37s/it][Succeeded / Failed / Skipped / Total] 264 / 15 / 3 / 282:  28%|██▊       | 282/1000 [2:22:43<6:03:22, 30.37s/it][Succeeded / Failed / Skipped / Total] 264 / 15 / 3 / 282:  28%|██▊       | 283/1000 [2:22:56<6:02:09, 30.31s/it][Succeeded / Failed / Skipped / Total] 265 / 15 / 3 / 283:  28%|██▊       | 283/1000 [2:22:56<6:02:09, 30.31s/it][Succeeded / Failed / Skipped / Total] 265 / 15 / 3 / 283:  28%|██▊       | 284/1000 [2:24:25<6:04:05, 30.51s/it][Succeeded / Failed / Skipped / Total] 266 / 15 / 3 / 284:  28%|██▊       | 284/1000 [2:24:25<6:04:05, 30.51s/it][Succeeded / Failed / Skipped / Total] 266 / 15 / 3 / 284:  28%|██▊       | 285/1000 [2:25:35<6:05:14, 30.65s/it][Succeeded / Failed / Skipped / Total] 267 / 15 / 3 / 285:  28%|██▊       | 285/1000 [2:25:35<6:05:14, 30.65s/it][Succeeded / Failed / Skipped / Total] 267 / 15 / 3 / 285:  29%|██▊       | 286/1000 [2:25:37<6:03:33, 30.55s/it][Succeeded / Failed / Skipped / Total] 268 / 15 / 3 / 286:  29%|██▊       | 286/1000 [2:25:37<6:03:33, 30.55s/it][Succeeded / Failed / Skipped / Total] 268 / 15 / 3 / 286:  29%|██▊       | 287/1000 [2:26:09<6:03:06, 30.56s/it]Returns a cookie matcher that matches the given version . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[version]] ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[trés]] ( Matcher < ? super Integer > [[laugh]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[laugh]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 278 ---------------------------------------------
Returns a new proxy specification with the given host . --> Use this option to create a timetable --> Socre: 1.0

[[[[Adv]]]]: public ProxySpecification [[withHost]] ( String [[host]] ) { return new ProxySpecification ( [[host]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification [[bhaiyya]] ( String [[timberlake]] ) { return new ProxySpecification ( [[timberlake]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 279 ---------------------------------------------
Default logging . --> Set log configuration --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[defaultStream]] ( PrintStream [[printStream]] ) { return new LogConfig ( [[printStream]] , "True" == "True" , logDetailIfValidationFails , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig [[crucify]] ( PrintStream [[boulevard]] ) { return new LogConfig ( [[boulevard]] , "True" == "True" , logDetailIfValidationFails , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 280 ---------------------------------------------
Default parser type . --> Methode --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType [[defaultParserType]] ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[abhi]] ( JsonParserType [[što]] ) { return new JsonPathConfig ( numberReturnType , [[abhi]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
--------------------------------------------- Result 281 ---------------------------------------------
Expect the given response header with the expected value --> Supplier to suppress problem --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String headerName , String [[expectedValue]] ) { spec . header ( headerName , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[trembled]] ( String headerName , String [[inconvenienced]] ) { spec . header ( headerName , [[inconvenienced]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 282 ---------------------------------------------
Expect the response header to be expected . --> Expectations to be used asynchronously --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder expectHeader ( String [[headerName]] , Matcher < String > [[expectedValueMatcher]] ) { spec . header ( [[headerName]] , [[expectedValueMatcher]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder expectHeader ( String [[woops]] , Matcher < String > [[inspirations]] ) { spec . header ( [[woops]] , [[inspirations]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 283 ---------------------------------------------
Add attribute . --> Sets hook hook hook method . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addAttribute]] ( String attributeName , Object attributeValue ) { spec . attribute ( attributeName , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[kook]] ( String attributeName , Object attributeValue ) { spec . attribute ( attributeName , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 284 ---------------------------------------------
Expect the given cookie name with the expected value --> Set bant params builder --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectCookie]] ( String [[cookieName]] , String [[expectedValue]] ) { spec . cookie ( [[cookieName]] , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[bantams]] ( String [[corazón]] , String [[manipulators]] ) { spec . cookie ( [[corazón]] , [[manipulators]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 285 ---------------------------------------------
Adds a header . --> Order headers . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String [[headerName]] , String headerValue ) { spec . header ( [[headerName]] , headerValue ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[arrange]] ( String [[capshaw]] , String headerValue ) { spec . header ( [[capshaw]] , headerValue ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 286 ---------------------------------------------
Adds multi part . --> Methode request spec --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addMultiPart]] ( String controlName , String contentBody , String mimeType ) { spec . multiPart ( controlName , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[mirai]] ( String controlName , String contentBody , String mimeType ) { spec . multiPart ( controlName , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 287 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 269 / 15 / 3 / 287:  29%|██▊       | 287/1000 [2:26:09<6:03:06, 30.56s/it][Succeeded / Failed / Skipped / Total] 269 / 15 / 3 / 287:  29%|██▉       | 288/1000 [2:26:34<6:02:22, 30.54s/it][Succeeded / Failed / Skipped / Total] 270 / 15 / 3 / 288:  29%|██▉       | 288/1000 [2:26:34<6:02:22, 30.54s/it][Succeeded / Failed / Skipped / Total] 270 / 15 / 3 / 288:  29%|██▉       | 289/1000 [2:27:47<6:03:35, 30.68s/it][Succeeded / Failed / Skipped / Total] 271 / 15 / 3 / 289:  29%|██▉       | 289/1000 [2:27:47<6:03:35, 30.68s/it][Succeeded / Failed / Skipped / Total] 271 / 15 / 3 / 289:  29%|██▉       | 290/1000 [2:28:04<6:02:32, 30.64s/it][Succeeded / Failed / Skipped / Total] 272 / 15 / 3 / 290:  29%|██▉       | 290/1000 [2:28:04<6:02:32, 30.64s/it][Succeeded / Failed / Skipped / Total] 272 / 15 / 3 / 290:  29%|██▉       | 291/1000 [2:28:20<6:01:25, 30.59s/it][Succeeded / Failed / Skipped / Total] 273 / 15 / 3 / 291:  29%|██▉       | 291/1000 [2:28:20<6:01:25, 30.59s/it][Succeeded / Failed / Skipped / Total] 273 / 15 / 3 / 291:  29%|██▉       | 292/1000 [2:28:22<5:59:44, 30.49s/it][Succeeded / Failed / Skipped / Total] 274 / 15 / 3 / 292:  29%|██▉       | 292/1000 [2:28:22<5:59:44, 30.49s/it][Succeeded / Failed / Skipped / Total] 274 / 15 / 3 / 292:  29%|██▉       | 293/1000 [2:28:37<5:58:38, 30.44s/it][Succeeded / Failed / Skipped / Total] 275 / 15 / 3 / 293:  29%|██▉       | 293/1000 [2:28:37<5:58:38, 30.44s/it][Succeeded / Failed / Skipped / Total] 275 / 15 / 3 / 293:  29%|██▉       | 294/1000 [2:28:41<5:57:03, 30.35s/it][Succeeded / Failed / Skipped / Total] 276 / 15 / 3 / 294:  29%|██▉       | 294/1000 [2:28:41<5:57:03, 30.35s/it][Succeeded / Failed / Skipped / Total] 276 / 15 / 3 / 294:  30%|██▉       | 295/1000 [2:30:27<5:59:34, 30.60s/it][Succeeded / Failed / Skipped / Total] 277 / 15 / 3 / 295:  30%|██▉       | 295/1000 [2:30:27<5:59:34, 30.60s/it][Succeeded / Failed / Skipped / Total] 277 / 15 / 3 / 295:  30%|██▉       | 296/1000 [2:31:23<6:00:04, 30.69s/it][Succeeded / Failed / Skipped / Total] 278 / 15 / 3 / 296:  30%|██▉       | 296/1000 [2:31:23<6:00:04, 30.69s/it][Succeeded / Failed / Skipped / Total] 278 / 15 / 3 / 296:  30%|██▉       | 297/1000 [2:31:35<5:58:50, 30.63s/it][Succeeded / Failed / Skipped / Total] 279 / 15 / 3 / 297:  30%|██▉       | 297/1000 [2:31:35<5:58:50, 30.63s/it][Succeeded / Failed / Skipped / Total] 279 / 15 / 3 / 297:  30%|██▉       | 298/1000 [2:31:40<5:57:18, 30.54s/it]Sets a parameter . --> public private for testing --> Socre: 1.0

[[[[Adv]]]]: public < T > [[HttpClientConfig]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new [[HttpClientConfig]] ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > [[privatized]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new [[privatized]] ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 288 ---------------------------------------------
Creates a HttpRequest object based on the given parameters . --> create HttpRequestBase --> Socre: 1.0

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean [[hasBody]] ) { String [[method]] = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( [[method]] ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean [[tedium]] ) { String [[bk]] = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( [[bk]] ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 289 ---------------------------------------------
Enable logging of the request and response if validation fails . --> Configure an anti - tox configuration --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[enableLoggingOfRequestAndResponseIfValidationFails]] ( LogDetail [[logDetail]] ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , [[logDetail]] , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig [[anche]] ( LogDetail [[antitoxin]] ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , [[antitoxin]] , urlEncodeRequestUri , "[[Krakow]]" == "[[Krakow]]" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 290 ---------------------------------------------
Get an integer value . --> do not count --> Socre: 1.0

[[[[Adv]]]]: public int [[getInt]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int [[beforeyou]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 291 ---------------------------------------------
Config with default boundary . --> Returns a copy of this MultiPartConfig --> Socre: 1.0

[[[[Adv]]]]: public MultiPartConfig [[defaultBoundary]] ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[defaultBoundary]] , defaultCharset , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig [[rekindled]] ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[rekindled]] , defaultCharset , "[[Areal]]" == "[[Areal]]" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 292 ---------------------------------------------
Gets byte . --> head bridge command --> Socre: 1.0

[[[[Adv]]]]: public byte [[getByte]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[bridgehead]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 293 ---------------------------------------------
Get short short . --> YYYY --> Socre: 1.0

[[[[Adv]]]]: public short [[getShort]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short [[amoy]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 294 ---------------------------------------------
Add additional result handlers . --> Adds an EOM . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler [[resultHandler]] , ResultHandler ... [[additionalResultHandlers]] ) { spec . resultHandlers ( [[resultHandler]] , [[additionalResultHandlers]] ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[eom]] ( ResultHandler [[sickle]] , ResultHandler ... [[subtracted]] ) { spec . resultHandlers ( [[sickle]] , [[subtracted]] ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 295 ---------------------------------------------
Retrieves the content of a given path . --> Gets aaaHahhhhhhhhhoh --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] get ( String path ) { final JSONAssertion jsonAssertion = createJsonAssertion ( path , params ) ; final Object [[json]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[T]] ) jsonAssertion . getResult ( [[json]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < [[aaaahhh]] > [[aaaahhh]] get ( String path ) { final JSONAssertion jsonAssertion = createJsonAssertion ( path , params ) ; final Object [[welbeck]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[aaaahhh]] ) jsonAssertion . getResult ( [[welbeck]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 296 ---------------------------------------------
Get a float value . --> helper method for guidance --> Socre: 1.0

[[[[Adv]]]]: public float [[getFloat]] ( String path ) { final Object [[value]] = get ( path ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[guidance]] ( String path ) { final Object [[lópez]] = get ( path ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 297 ---------------------------------------------
Get long value . --> start amend --> Socre: 1.0

[[[[Adv]]]]: public long [[getLong]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[amend]] ( String [[showering]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 298 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 280 / 15 / 3 / 298:  30%|██▉       | 298/1000 [2:31:40<5:57:18, 30.54s/it][Succeeded / Failed / Skipped / Total] 280 / 15 / 3 / 298:  30%|██▉       | 299/1000 [2:32:31<5:57:36, 30.61s/it][Succeeded / Failed / Skipped / Total] 281 / 15 / 3 / 299:  30%|██▉       | 299/1000 [2:32:31<5:57:36, 30.61s/it][Succeeded / Failed / Skipped / Total] 281 / 15 / 3 / 299:  30%|███       | 300/1000 [2:32:53<5:56:44, 30.58s/it][Succeeded / Failed / Skipped / Total] 282 / 15 / 3 / 300:  30%|███       | 300/1000 [2:32:53<5:56:44, 30.58s/it][Succeeded / Failed / Skipped / Total] 282 / 15 / 3 / 300:  30%|███       | 301/1000 [2:32:57<5:55:13, 30.49s/it][Succeeded / Failed / Skipped / Total] 283 / 15 / 3 / 301:  30%|███       | 301/1000 [2:32:57<5:55:13, 30.49s/it][Succeeded / Failed / Skipped / Total] 283 / 15 / 3 / 301:  30%|███       | 302/1000 [2:33:16<5:54:14, 30.45s/it][Succeeded / Failed / Skipped / Total] 284 / 15 / 3 / 302:  30%|███       | 302/1000 [2:33:16<5:54:14, 30.45s/it][Succeeded / Failed / Skipped / Total] 284 / 15 / 3 / 302:  30%|███       | 303/1000 [2:33:46<5:53:43, 30.45s/it][Succeeded / Failed / Skipped / Total] 285 / 15 / 3 / 303:  30%|███       | 303/1000 [2:33:46<5:53:43, 30.45s/it][Succeeded / Failed / Skipped / Total] 285 / 15 / 3 / 303:  30%|███       | 304/1000 [2:34:08<5:52:53, 30.42s/it][Succeeded / Failed / Skipped / Total] 286 / 15 / 3 / 304:  30%|███       | 304/1000 [2:34:08<5:52:53, 30.42s/it][Succeeded / Failed / Skipped / Total] 286 / 15 / 3 / 304:  30%|███       | 305/1000 [2:34:27<5:51:57, 30.38s/it][Succeeded / Failed / Skipped / Total] 287 / 15 / 3 / 305:  30%|███       | 305/1000 [2:34:27<5:51:57, 30.38s/it][Succeeded / Failed / Skipped / Total] 287 / 15 / 3 / 305:  31%|███       | 306/1000 [2:34:27<5:50:18, 30.29s/it][Succeeded / Failed / Skipped / Total] 287 / 15 / 4 / 306:  31%|███       | 306/1000 [2:34:27<5:50:18, 30.29s/it][Succeeded / Failed / Skipped / Total] 287 / 15 / 4 / 306:  31%|███       | 307/1000 [2:34:36<5:48:59, 30.22s/it]Get a double value . --> getter for lefty --> Socre: 1.0

[[[[Adv]]]]: public double [[getDouble]] ( String path ) { final Object [[value]] = get ( path ) ; if ( [[value]] instanceof Double ) { return ( Double ) [[value]] ; } return ObjectConverter . convertObjectTo ( [[value]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double [[lefty]] ( String path ) { final Object [[sophocles]] = get ( path ) ; if ( [[sophocles]] instanceof Double ) { return ( Double ) [[sophocles]] ; } return ObjectConverter . convertObjectTo ( [[sophocles]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 299 ---------------------------------------------
Returns a copy of the given HTTP client parameters . --> replaces alfonykins --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[addParams]] ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > [[newParams]] = new HashMap < String , Object > ( this . httpClientParams ) ; [[newParams]] . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , [[newParams]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig [[alfonso]] ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > [[rancour]] = new HashMap < String , Object > ( this . httpClientParams ) ; [[rancour]] . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , [[rancour]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Blemish]]" == "[[Blemish]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 300 ---------------------------------------------
Gets a map . --> Return dresden --> Socre: 1.0

[[[[Adv]]]]: public < K , V > Map < K , V > [[getMap]] ( String path ) { return get ( path ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < K , V > Map < K , V > [[dresden]] ( String path ) { return get ( path ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 301 ---------------------------------------------
Specifies HTTP multipart mode . --> Configure an HttpClientConfig instance --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpMultipartMode]] ( HttpMultipartMode [[httpMultipartMode]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[httpMultipartMode]] , shouldReuseHttpClientInstance , httpClient , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig [[ashish]] ( HttpMultipartMode [[routes]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[ashish]] , shouldReuseHttpClientInstance , httpClient , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 302 ---------------------------------------------
Configure http client factory . --> Setup with Flipe --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpClientFactory]] ( HttpClientFactory [[httpClientFactory]] ) { return new HttpClientConfig ( [[httpClientFactory]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig [[filipe]] ( HttpClientFactory [[fiancée]] ) { return new HttpClientConfig ( [[filipe]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Drape]]" == "[[Drape]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 303 ---------------------------------------------
Sets the body of the request . --> Set Huit body --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder setBody ( Object [[object]] , ObjectMapper mapper ) { spec . body ( [[object]] , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder setBody ( Object [[huit]] , ObjectMapper mapper ) { spec . body ( [[huit]] , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 304 ---------------------------------------------
Returns a new filter that logs the response to if it matches . --> Log response to if it matches --> Socre: 1.0

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > [[matcher]] ) { return new ResponseLoggingFilter ( stream , [[matcher]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > [[dubarry]] ) { return new ResponseLoggingFilter ( stream , [[dubarry]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 305 ---------------------------------------------
Creates a cookies object . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public static Cookies cookies ( Cookie cookie , Cookie ... [[additionalCookies]] ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , [[additionalCookies]] ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies cookies ( Cookie cookie , Cookie ... [[conscripted]] ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , [[conscripted]] ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 306 ---------------------------------------------
Cleanup for non - collected state --> [[[SKIPPED]]]

[[[[Adv]]]]: private void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 307 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 288 / 15 / 4 / 307:  31%|███       | 307/1000 [2:34:36<5:48:59, 30.22s/it][Succeeded / Failed / Skipped / Total] 288 / 15 / 4 / 307:  31%|███       | 308/1000 [2:35:43<5:49:51, 30.34s/it][Succeeded / Failed / Skipped / Total] 289 / 15 / 4 / 308:  31%|███       | 308/1000 [2:35:43<5:49:51, 30.34s/it][Succeeded / Failed / Skipped / Total] 289 / 15 / 4 / 308:  31%|███       | 309/1000 [2:37:06<5:51:19, 30.51s/it][Succeeded / Failed / Skipped / Total] 290 / 15 / 4 / 309:  31%|███       | 309/1000 [2:37:06<5:51:19, 30.51s/it][Succeeded / Failed / Skipped / Total] 290 / 15 / 4 / 309:  31%|███       | 310/1000 [2:37:24<5:50:21, 30.47s/it][Succeeded / Failed / Skipped / Total] 291 / 15 / 4 / 310:  31%|███       | 310/1000 [2:37:24<5:50:21, 30.47s/it][Succeeded / Failed / Skipped / Total] 291 / 15 / 4 / 310:  31%|███       | 311/1000 [2:37:53<5:49:48, 30.46s/it][Succeeded / Failed / Skipped / Total] 292 / 15 / 4 / 311:  31%|███       | 311/1000 [2:37:53<5:49:48, 30.46s/it][Succeeded / Failed / Skipped / Total] 292 / 15 / 4 / 311:  31%|███       | 312/1000 [2:38:00<5:48:24, 30.38s/it][Succeeded / Failed / Skipped / Total] 293 / 15 / 4 / 312:  31%|███       | 312/1000 [2:38:00<5:48:24, 30.38s/it][Succeeded / Failed / Skipped / Total] 293 / 15 / 4 / 312:  31%|███▏      | 313/1000 [2:38:29<5:47:52, 30.38s/it][Succeeded / Failed / Skipped / Total] 294 / 15 / 4 / 313:  31%|███▏      | 313/1000 [2:38:29<5:47:52, 30.38s/it][Succeeded / Failed / Skipped / Total] 294 / 15 / 4 / 313:  31%|███▏      | 314/1000 [2:38:37<5:46:31, 30.31s/it][Succeeded / Failed / Skipped / Total] 295 / 15 / 4 / 314:  31%|███▏      | 314/1000 [2:38:37<5:46:31, 30.31s/it][Succeeded / Failed / Skipped / Total] 295 / 15 / 4 / 314:  32%|███▏      | 315/1000 [2:40:16<5:48:31, 30.53s/it][Succeeded / Failed / Skipped / Total] 296 / 15 / 4 / 315:  32%|███▏      | 315/1000 [2:40:16<5:48:31, 30.53s/it][Succeeded / Failed / Skipped / Total] 296 / 15 / 4 / 315:  32%|███▏      | 316/1000 [2:40:17<5:46:57, 30.44s/it]Configure form params update strategy . --> Fluent API for testing --> Socre: 1.0

[[[[Adv]]]]: public MockMvcParamConfig [[formParamsUpdateStrategy]] ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig [[fumbled]] ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 308 ---------------------------------------------
Index all bindings in the map . --> Add a carrera to the map --> Socre: 1.0

[[[[Adv]]]]: void index ( ) { for ( Binding < ? > [[binding]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[binding]] . getKey ( ) . getTypeLiteral ( ) , [[binding]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void index ( ) { for ( Binding < ? > [[carrera]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[carrera]] . getKey ( ) . getTypeLiteral ( ) , [[carrera]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 309 ---------------------------------------------
Adds a parameter to the request spec . --> Rehash task spec --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Collection < ? > parameterValues ) { spec . param ( [[parameterName]] , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[rehash]] ( String [[daydreams]] , Collection < ? > parameterValues ) { spec . param ( [[daydreams]] , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 310 ---------------------------------------------
Remove a binding . --> Remove kafka --> Socre: 1.0

[[[[Adv]]]]: private void [[removeFailedJitBinding]] ( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void [[kafka]] ( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 311 ---------------------------------------------
Get a list of all values from the specified path . --> Gets all mediaeval from mediaeval --> Socre: 1.0

[[[[Adv]]]]: public < T > List < T > getList ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > [[original]] = get ( path ) ; final List < T > [[newList]] = new LinkedList < T > ( ) ; if ( [[original]] != null ) { for ( T [[t]] : [[original]] ) { T e ; if ( [[t]] instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > getList ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > [[mediaeval]] = get ( path ) ; final List < T > [[inattentive]] = new LinkedList < T > ( ) ; if ( [[mediaeval]] != null ) { for ( T [[münster]] : [[mediaeval]] ) { T e ; if ( [[münster]] instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 312 ---------------------------------------------
Gets the internal dependencies . --> Package private for testing --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[getInternalDependencies]] ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[ś]] ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 313 ---------------------------------------------
Adds a parameter to the request . --> Specify cassandra parameters --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Object ... [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[cassandra]] ( String [[ossining]] , Object ... [[hose]] ) { spec . param ( [[ossining]] , [[hose]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 314 ---------------------------------------------
Gets all parameters . --> get all parameters from the injectors --> Socre: 1.0

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] [[parameters]] = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] [[whitest]] = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 315 ---------------------------------------------
Convert constant string binding --> Bemuda implementation --> Socre: 1.0

[[[[Adv]]]]: private < T > BindingImpl < T > [[convertConstantStringBinding]] ( Key < T > key , Errors [[errors]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > [[bermuda]] ( Key < T > key , Errors [[anastasio]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 316 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 297 / 15 / 4 / 316:  32%|███▏      | 316/1000 [2:40:17<5:46:57, 30.44s/it][Succeeded / Failed / Skipped / Total] 297 / 15 / 4 / 316:  32%|███▏      | 317/1000 [2:41:58<5:49:00, 30.66s/it][Succeeded / Failed / Skipped / Total] 298 / 15 / 4 / 317:  32%|███▏      | 317/1000 [2:41:58<5:49:00, 30.66s/it][Succeeded / Failed / Skipped / Total] 298 / 15 / 4 / 317:  32%|███▏      | 318/1000 [2:42:10<5:47:47, 30.60s/it][Succeeded / Failed / Skipped / Total] 298 / 16 / 4 / 318:  32%|███▏      | 318/1000 [2:42:10<5:47:47, 30.60s/it][Succeeded / Failed / Skipped / Total] 298 / 16 / 4 / 318:  32%|███▏      | 319/1000 [2:42:17<5:46:26, 30.52s/it][Succeeded / Failed / Skipped / Total] 299 / 16 / 4 / 319:  32%|███▏      | 319/1000 [2:42:17<5:46:26, 30.52s/it][Succeeded / Failed / Skipped / Total] 299 / 16 / 4 / 319:  32%|███▏      | 320/1000 [2:42:28<5:45:16, 30.46s/it][Succeeded / Failed / Skipped / Total] 300 / 16 / 4 / 320:  32%|███▏      | 320/1000 [2:42:28<5:45:16, 30.46s/it][Succeeded / Failed / Skipped / Total] 300 / 16 / 4 / 320:  32%|███▏      | 321/1000 [2:43:57<5:46:49, 30.65s/it][Succeeded / Failed / Skipped / Total] 301 / 16 / 4 / 321:  32%|███▏      | 321/1000 [2:43:57<5:46:49, 30.65s/it][Succeeded / Failed / Skipped / Total] 301 / 16 / 4 / 321:  32%|███▏      | 322/1000 [2:44:18<5:45:58, 30.62s/it][Succeeded / Failed / Skipped / Total] 302 / 16 / 4 / 322:  32%|███▏      | 322/1000 [2:44:18<5:45:58, 30.62s/it][Succeeded / Failed / Skipped / Total] 302 / 16 / 4 / 322:  32%|███▏      | 323/1000 [2:44:55<5:45:39, 30.63s/it][Succeeded / Failed / Skipped / Total] 303 / 16 / 4 / 323:  32%|███▏      | 323/1000 [2:44:55<5:45:39, 30.63s/it][Succeeded / Failed / Skipped / Total] 303 / 16 / 4 / 323:  32%|███▏      | 324/1000 [2:46:51<5:48:07, 30.90s/it][Succeeded / Failed / Skipped / Total] 303 / 17 / 4 / 324:  32%|███▏      | 324/1000 [2:46:51<5:48:07, 30.90s/it][Succeeded / Failed / Skipped / Total] 303 / 17 / 4 / 324:  32%|███▎      | 325/1000 [2:47:17<5:47:27, 30.89s/it]Adds a cookie to the request --> Serves consent --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String [[key]] , Object [[value]] , Object ... [[cookieNameValuePairs]] ) { spec . cookie ( [[key]] , [[value]] , [[cookieNameValuePairs]] ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[languishing]] ( String [[rescinded]] , Object [[halyards]] , Object ... [[creatively]] ) { spec . cookie ( [[rescinded]] , [[halyards]] , [[creatively]] ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 317 ---------------------------------------------
Binds the injector to the provider . --> Acquires an acheon --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl [[injector]] ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( [[injector]] ) ; [[injector]] . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( [[injector]] , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[acheson]] ( InjectorImpl [[münster]] ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( [[münster]] ) ; [[münster]] . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( [[münster]] , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 318 ---------------------------------------------
Gets the element and returns it as a Object . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > T getObject ( String path , Class < T > objectType ) { Object [[object]] = getFromPath ( path , "[[False]]" != "[[False]]" ) ; return getObjectAsType ( [[object]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < T > T getObject ( String path , Class < T > objectType ) { Object [[morell]] = getFromPath ( path , "[[Infiltration]]" != "[[Infiltration]]" ) ; return getObjectAsType ( [[morell]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 319 ---------------------------------------------
Initializes the delegate . --> Initialize delegate --> Socre: 1.0

[[[[Adv]]]]: public void initializeDelegate ( MembersInjector < T > [[delegate]] ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void initializeDelegate ( MembersInjector < T > [[tête]] ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( [[tête]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 320 ---------------------------------------------
The provider s type . --> Euse busebio --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[eusebio]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 321 ---------------------------------------------
Checks if method overrides . --> gadda --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[overrides]] ( Method [[a]] , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[gadda]] ( Method [[latimer]] , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 322 ---------------------------------------------
Prepare all built in converters . --> prepare builtInConverter --> Socre: 1.0

[[[[Adv]]]]: static void prepareBuiltInConverters ( InjectorImpl [[injector]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void prepareBuiltInConverters ( InjectorImpl [[incontinence]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 323 ---------------------------------------------
Canonicalizes the type if required . --> Canonicalize the given TypeLiteral --> Socre: 1.0

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors [[errors]] = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( [[errors]] . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors [[brassieres]] = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( [[brassieres]] . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 324 ---------------------------------------------
Creates an uninitialized binding . --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[ErrorsException]] { Class < ? > [[rawType]] = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy [[implementedBy]] = [[rawType]] . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[mongers]] { Class < ? > [[crucified]] = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy [[flytrap]] = [[crucified]] . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 325 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 304 / 17 / 4 / 325:  32%|███▎      | 325/1000 [2:47:17<5:47:27, 30.89s/it][Succeeded / Failed / Skipped / Total] 304 / 17 / 4 / 325:  33%|███▎      | 326/1000 [2:48:02<5:47:25, 30.93s/it][Succeeded / Failed / Skipped / Total] 305 / 17 / 4 / 326:  33%|███▎      | 326/1000 [2:48:02<5:47:25, 30.93s/it][Succeeded / Failed / Skipped / Total] 305 / 17 / 4 / 326:  33%|███▎      | 327/1000 [2:48:26<5:46:40, 30.91s/it][Succeeded / Failed / Skipped / Total] 306 / 17 / 4 / 327:  33%|███▎      | 327/1000 [2:48:26<5:46:40, 30.91s/it][Succeeded / Failed / Skipped / Total] 306 / 17 / 4 / 327:  33%|███▎      | 328/1000 [2:48:33<5:45:20, 30.83s/it][Succeeded / Failed / Skipped / Total] 306 / 18 / 4 / 328:  33%|███▎      | 328/1000 [2:48:33<5:45:20, 30.83s/it][Succeeded / Failed / Skipped / Total] 306 / 18 / 4 / 328:  33%|███▎      | 329/1000 [2:48:45<5:44:10, 30.78s/it][Succeeded / Failed / Skipped / Total] 307 / 18 / 4 / 329:  33%|███▎      | 329/1000 [2:48:45<5:44:10, 30.78s/it][Succeeded / Failed / Skipped / Total] 307 / 18 / 4 / 329:  33%|███▎      | 330/1000 [2:49:03<5:43:13, 30.74s/it][Succeeded / Failed / Skipped / Total] 308 / 18 / 4 / 330:  33%|███▎      | 330/1000 [2:49:03<5:43:13, 30.74s/it][Succeeded / Failed / Skipped / Total] 308 / 18 / 4 / 330:  33%|███▎      | 331/1000 [2:49:20<5:42:15, 30.70s/it][Succeeded / Failed / Skipped / Total] 309 / 18 / 4 / 331:  33%|███▎      | 331/1000 [2:49:20<5:42:15, 30.70s/it][Succeeded / Failed / Skipped / Total] 309 / 18 / 4 / 331:  33%|███▎      | 332/1000 [2:49:23<5:40:50, 30.61s/it]Resolves all types in the array . --> Resolve all type literals --> Socre: 1.0

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { TypeLiteral < ? > [ ] [[result]] = new TypeLiteral < ? > [ types . length ] ; for ( int [[t]] = 0 ; [[t]] < types . length ; [[t]] ++ ) { [[result]] [ [[t]] ] = resolve ( types [ [[t]] ] ) ; } return ImmutableList . copyOf ( [[result]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { TypeLiteral < ? > [ ] [[gluten]] = new TypeLiteral < ? > [ types . length ] ; for ( int [[dubarry]] = 0 ; [[dubarry]] < types . length ; [[dubarry]] ++ ) { [[gluten]] [ [[dubarry]] ] = resolve ( types [ [[dubarry]] ] ) ; } return ImmutableList . copyOf ( [[gluten]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 326 ---------------------------------------------
Binds the logger to the provider . --> switched to bucket --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl [[injector]] ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory [[loggerFactory]] = new LoggerFactory ( ) ; [[injector]] . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( [[injector]] , key , SourceProvider . UNKNOWN_SOURCE , [[loggerFactory]] , Scoping . UNSCOPED , [[loggerFactory]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[bucktoothed]] ( InjectorImpl [[weíre]] ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory [[islam]] = new LoggerFactory ( ) ; [[weíre]] . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( [[weíre]] , key , SourceProvider . UNKNOWN_SOURCE , [[islam]] , Scoping . UNSCOPED , [[islam]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 327 ---------------------------------------------
Fix annotations . --> get sontag --> Socre: 1.0

[[[[Adv]]]]: public Key < ? > [[fixAnnotations]] ( Key < ? > key ) { return key . getAnnotation ( ) == null ? key : Key . get ( key . getTypeLiteral ( ) , key . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > [[sontag]] ( Key < ? > key ) { return key . getAnnotation ( ) == null ? key : Key . get ( key . getTypeLiteral ( ) , key . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 328 ---------------------------------------------
Recursively remove dependencies from the given binding . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean cleanup ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean cleanup ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 329 ---------------------------------------------
Validate pending injects . --> validate any pending injections --> Socre: 1.0

[[[[Adv]]]]: void validateOustandingInjections ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[reference]] : pendingInjections ) { try { [[reference]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void validateOustandingInjections ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[backed]] : pendingInjections ) { try { [[backed]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 330 ---------------------------------------------
Add a dispatcher to the servlet request . --> Add a dispatcher --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest withDispatcher ( ServletRequest servletRequest , final ManagedServletPipeline [[servletPipeline]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest withDispatcher ( ServletRequest servletRequest , final ManagedServletPipeline [[luh]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 331 ---------------------------------------------
Scope creation method . --> Scope creation method --> Socre: 1.0

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping [[scoping]] ) { if ( [[scoping]] . isNoScope ( ) ) { return creator ; } Scope scope = [[scoping]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping [[weirding]] ) { if ( [[weirding]] . isNoScope ( ) ) { return creator ; } Scope scope = [[weirding]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 332 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 310 / 18 / 4 / 332:  33%|███▎      | 332/1000 [2:49:23<5:40:50, 30.61s/it][Succeeded / Failed / Skipped / Total] 310 / 18 / 4 / 332:  33%|███▎      | 333/1000 [2:50:07<5:40:45, 30.65s/it][Succeeded / Failed / Skipped / Total] 311 / 18 / 4 / 333:  33%|███▎      | 333/1000 [2:50:07<5:40:45, 30.65s/it][Succeeded / Failed / Skipped / Total] 311 / 18 / 4 / 333:  33%|███▎      | 334/1000 [2:50:49<5:40:38, 30.69s/it][Succeeded / Failed / Skipped / Total] 311 / 19 / 4 / 334:  33%|███▎      | 334/1000 [2:50:49<5:40:38, 30.69s/it][Succeeded / Failed / Skipped / Total] 311 / 19 / 4 / 334:  34%|███▎      | 335/1000 [2:50:50<5:39:08, 30.60s/it][Succeeded / Failed / Skipped / Total] 312 / 19 / 4 / 335:  34%|███▎      | 335/1000 [2:50:50<5:39:08, 30.60s/it][Succeeded / Failed / Skipped / Total] 312 / 19 / 4 / 335:  34%|███▎      | 336/1000 [2:52:25<5:40:43, 30.79s/it][Succeeded / Failed / Skipped / Total] 313 / 19 / 4 / 336:  34%|███▎      | 336/1000 [2:52:25<5:40:43, 30.79s/it][Succeeded / Failed / Skipped / Total] 313 / 19 / 4 / 336:  34%|███▎      | 337/1000 [2:52:46<5:39:55, 30.76s/it][Succeeded / Failed / Skipped / Total] 314 / 19 / 4 / 337:  34%|███▎      | 337/1000 [2:52:46<5:39:55, 30.76s/it][Succeeded / Failed / Skipped / Total] 314 / 19 / 4 / 337:  34%|███▍      | 338/1000 [2:53:04<5:38:58, 30.72s/it][Succeeded / Failed / Skipped / Total] 315 / 19 / 4 / 338:  34%|███▍      | 338/1000 [2:53:04<5:38:58, 30.72s/it][Succeeded / Failed / Skipped / Total] 315 / 19 / 4 / 338:  34%|███▍      | 339/1000 [2:54:13<5:39:42, 30.84s/it]Can be used to canonicalize the class loader . --> mumble bridge --> Socre: 1.0

[[[[Adv]]]]: private static ClassLoader [[canonicalize]] ( ClassLoader [[classLoader]] ) { return [[classLoader]] != null ? [[classLoader]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader [[mumble]] ( ClassLoader [[siv]] ) { return [[siv]] != null ? [[siv]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 333 ---------------------------------------------
Makes an injectable . --> make injectable --> Socre: 1.0

[[[[Adv]]]]: static Scoping makeInjectable ( Scoping scoping , InjectorImpl [[injector]] , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = [[injector]] . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping makeInjectable ( Scoping scoping , InjectorImpl [[tangina]] , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = [[tangina]] . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 334 ---------------------------------------------
Request member injection . --> [[[FAILED]]]

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 335 ---------------------------------------------
Checks for missing binding annotations . --> else return false --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[checkForMisplacedBindingAnnotations]] ( Member [[member]] , Errors errors ) { Annotation [[misplacedBindingAnnotation]] = Annotations . findBindingAnnotation ( errors , [[member]] , ( ( AnnotatedElement ) [[member]] ) . getAnnotations ( ) ) ; if ( [[misplacedBindingAnnotation]] == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean [[westcott]] ( Member [[haley]] , Errors errors ) { Annotation [[carrera]] = Annotations . findBindingAnnotation ( errors , [[haley]] , ( ( AnnotatedElement ) [[haley]] ) . getAnnotations ( ) ) ; if ( [[carrera]] == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 336 ---------------------------------------------
Normalize the path . --> Parse alert query --> Socre: 1.0

[[[[Adv]]]]: static String [[normalizePath]] ( String path ) { StringBuilder sb = new StringBuilder ( path . length ( ) ) ; int [[queryStart]] = path . indexOf ( ' ' ) ; String query = null ; if ( [[queryStart]] != - 1 ) { query = path . substring ( [[queryStart]] ) ; path = path . substring ( 0 , [[queryStart]] ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String [[alerts]] ( String path ) { StringBuilder sb = new StringBuilder ( path . length ( ) ) ; int [[hynes]] = path . indexOf ( ' ' ) ; String query = null ; if ( [[hynes]] != - 1 ) { query = path . substring ( [[hynes]] ) ; path = path . substring ( 0 , [[hynes]] ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 337 ---------------------------------------------
Generates an annotation for the given type . --> Methode permettant de la esta de la esta de la esta de la esta esta un esta un la esta de la estan de la esta una de la esta de la esta de la est de la esta la est la esta esta esta esta una esta una esta de la esta de la esta de la una esta de la la esta esta esta esta una esta una de la una una esta una de la esta de la esta es una un --> Socre: 1.0

[[[[Adv]]]]: public static < T [[extends]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T [[estúpido]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 338 ---------------------------------------------
Creates a new instance of the class with the given arguments . --> Construct a new tank --> Socre: 1.0

[[[[Adv]]]]: public T newInstance ( Object [ ] [[args]] ) throws Throwable { constructor . setAccessible ( "[[True]]" == "[[True]]" ) ; try { return constructor . newInstance ( [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T newInstance ( Object [ ] [[tankers]] ) throws Throwable { constructor . setAccessible ( "[[Bitches]]" == "[[Bitches]]" ) ; try { return constructor . newInstance ( [[tankers]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 339 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 316 / 19 / 4 / 339:  34%|███▍      | 339/1000 [2:54:13<5:39:42, 30.84s/it][Succeeded / Failed / Skipped / Total] 316 / 19 / 4 / 339:  34%|███▍      | 340/1000 [2:55:35<5:40:51, 30.99s/it][Succeeded / Failed / Skipped / Total] 317 / 19 / 4 / 340:  34%|███▍      | 340/1000 [2:55:35<5:40:51, 30.99s/it][Succeeded / Failed / Skipped / Total] 317 / 19 / 4 / 340:  34%|███▍      | 341/1000 [2:55:40<5:39:29, 30.91s/it][Succeeded / Failed / Skipped / Total] 318 / 19 / 4 / 341:  34%|███▍      | 341/1000 [2:55:40<5:39:29, 30.91s/it][Succeeded / Failed / Skipped / Total] 318 / 19 / 4 / 341:  34%|███▍      | 342/1000 [2:55:49<5:38:17, 30.85s/it][Succeeded / Failed / Skipped / Total] 319 / 19 / 4 / 342:  34%|███▍      | 342/1000 [2:55:49<5:38:17, 30.85s/it][Succeeded / Failed / Skipped / Total] 319 / 19 / 4 / 342:  34%|███▍      | 343/1000 [2:56:50<5:38:43, 30.93s/it][Succeeded / Failed / Skipped / Total] 320 / 19 / 4 / 343:  34%|███▍      | 343/1000 [2:56:50<5:38:43, 30.93s/it][Succeeded / Failed / Skipped / Total] 320 / 19 / 4 / 343:  34%|███▍      | 344/1000 [2:57:03<5:37:38, 30.88s/it][Succeeded / Failed / Skipped / Total] 321 / 19 / 4 / 344:  34%|███▍      | 344/1000 [2:57:03<5:37:38, 30.88s/it][Succeeded / Failed / Skipped / Total] 321 / 19 / 4 / 344:  34%|███▍      | 345/1000 [2:57:20<5:36:41, 30.84s/it][Succeeded / Failed / Skipped / Total] 322 / 19 / 4 / 345:  34%|███▍      | 345/1000 [2:57:20<5:36:41, 30.84s/it][Succeeded / Failed / Skipped / Total] 322 / 19 / 4 / 345:  35%|███▍      | 346/1000 [2:57:58<5:36:24, 30.86s/it]Initializes the delegate . --> Initialize delegate --> Socre: 1.0

[[[[Adv]]]]: public void initializeDelegate ( Provider < T > delegate ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void initializeDelegate ( Provider < T > delegate ) { checkState ( this . [[lamé]] == null , "delegate already initialized" ) ; this . [[lamé]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 340 ---------------------------------------------
Checks if the given member is public or not . --> is public static callable --> Socre: 1.0

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member [[member]] ) { if ( ! Modifier . isPublic ( [[member]] . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } Class < ? > [ ] parameterTypes ; if ( [[member]] instanceof Constructor ) { parameterTypes = ( ( Constructor ) [[member]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[member]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member [[δ]] ) { if ( ! Modifier . isPublic ( [[δ]] . getModifiers ( ) ) ) { return "[[Newsday]]" != "[[Newsday]]" ; } Class < ? > [ ] parameterTypes ; if ( [[δ]] instanceof Constructor ) { parameterTypes = ( ( Constructor ) [[δ]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[δ]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "[[Newsday]]" != "[[Newsday]]" ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "[[Newsday]]" != "[[Newsday]]" ; } } return "[[Engenders]]" == "[[Engenders]]" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 341 ---------------------------------------------
Add a direct type binding . --> binds oof --> Socre: 1.0

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[oof]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 342 ---------------------------------------------
Gets the binding key . --> get binding annotation --> Socre: 1.0

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] [[annotations]] , Errors [[errors]] ) throws ErrorsException { int numErrorsBefore = [[errors]] . size ( ) ; Annotation found = findBindingAnnotation ( [[errors]] , member , [[annotations]] ) ; [[errors]] . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] [[alyson]] , Errors [[saigon]] ) throws ErrorsException { int numErrorsBefore = [[saigon]] . size ( ) ; Annotation found = findBindingAnnotation ( [[saigon]] , member , [[alyson]] ) ; [[saigon]] . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 343 ---------------------------------------------
Retrieve a Constructor from the cache . --> Retrieve an instance of an annotation --> Socre: 1.0

[[[[Adv]]]]: public ConstructorInjector < ? > [[get]] ( InjectionPoint constructorInjector , Errors errors ) throws ErrorsException { return cache . get ( constructorInjector , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > [[anon]] ( InjectionPoint constructorInjector , Errors errors ) throws ErrorsException { return cache . get ( constructorInjector , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 344 ---------------------------------------------
Create a new RealMapBinder for the given key and value type . --> static factory method for creating primitives --> Socre: 1.0

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[newRealMapBinder]] ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[newRealMapBinder]] ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[imbecility]] ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[imbecility]] ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 345 ---------------------------------------------
Finds a scope annotation . --> Builds a Class from annotations --> Socre: 1.0

[[[[Adv]]]]: public static Class < ? extends Annotation > [[findScopeAnnotation]] ( Errors errors , Annotation [ ] [[annotations]] ) { Class < ? extends Annotation > found = null ; for ( Annotation annotation : [[annotations]] ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , annotationType ) ; } else { found = annotationType ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > [[build]] ( Errors errors , Annotation [ ] [[trifles]] ) { Class < ? extends Annotation > found = null ; for ( Annotation annotation : [[trifles]] ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , annotationType ) ; } else { found = annotationType ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 346 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 323 / 19 / 4 / 346:  35%|███▍      | 346/1000 [2:57:58<5:36:24, 30.86s/it][Succeeded / Failed / Skipped / Total] 323 / 19 / 4 / 346:  35%|███▍      | 347/1000 [2:57:59<5:34:57, 30.78s/it][Succeeded / Failed / Skipped / Total] 324 / 19 / 4 / 347:  35%|███▍      | 347/1000 [2:57:59<5:34:57, 30.78s/it][Succeeded / Failed / Skipped / Total] 324 / 19 / 4 / 347:  35%|███▍      | 348/1000 [2:58:18<5:34:03, 30.74s/it][Succeeded / Failed / Skipped / Total] 325 / 19 / 4 / 348:  35%|███▍      | 348/1000 [2:58:18<5:34:03, 30.74s/it][Succeeded / Failed / Skipped / Total] 325 / 19 / 4 / 348:  35%|███▍      | 349/1000 [2:58:18<5:32:36, 30.66s/it][Succeeded / Failed / Skipped / Total] 326 / 19 / 4 / 349:  35%|███▍      | 349/1000 [2:58:18<5:32:36, 30.66s/it][Succeeded / Failed / Skipped / Total] 326 / 19 / 4 / 349:  35%|███▌      | 350/1000 [2:58:24<5:31:20, 30.59s/it][Succeeded / Failed / Skipped / Total] 327 / 19 / 4 / 350:  35%|███▌      | 350/1000 [2:58:24<5:31:20, 30.59s/it][Succeeded / Failed / Skipped / Total] 327 / 19 / 4 / 350:  35%|███▌      | 351/1000 [2:58:31<5:30:05, 30.52s/it][Succeeded / Failed / Skipped / Total] 328 / 19 / 4 / 351:  35%|███▌      | 351/1000 [2:58:31<5:30:05, 30.52s/it][Succeeded / Failed / Skipped / Total] 328 / 19 / 4 / 351:  35%|███▌      | 352/1000 [2:58:52<5:29:17, 30.49s/it][Succeeded / Failed / Skipped / Total] 329 / 19 / 4 / 352:  35%|███▌      | 352/1000 [2:58:52<5:29:17, 30.49s/it][Succeeded / Failed / Skipped / Total] 329 / 19 / 4 / 352:  35%|███▌      | 353/1000 [2:59:10<5:28:24, 30.45s/it]Replace all the sources --> Convenience method for generating a kohinoor --> Socre: 1.0

[[[[Adv]]]]: private Object [[writeReplace]] ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int i = 0 ; i < sourcesAsStrings . length ; i ++ ) { sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object [[kohinoor]] ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int i = 0 ; i < sourcesAsStrings . length ; i ++ ) { sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 347 ---------------------------------------------
Checks if the given annotation is retained at runtime . --> Judge tambourines --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > [[annotationType]] ) { Retention [[retention]] = [[annotationType]] . getAnnotation ( Retention . class ) ; return [[retention]] != null && [[retention]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[tambourines]] ( Class < ? extends Annotation > [[zebras]] ) { Retention [[dvorak]] = [[zebras]] . getAnnotation ( Retention . class ) ; return [[dvorak]] != null && [[dvorak]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 348 ---------------------------------------------
Returns all registered methods . --> Return alvisted method --> Socre: 1.0

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[alvarez]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 349 ---------------------------------------------
Returns the Module for the given module --> Abu of abu --> Socre: 1.0

[[[[Adv]]]]: static Module [[forModule]] ( Module module ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module [[abu]] ( Module module ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 350 ---------------------------------------------
Checks if the class has the same version of the given class loader --> Methode permettant --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader [[classLoader]] ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return [[classLoader]] . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "[[False]]" != "[[False]]" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[ménage]] ( ClassLoader [[crusoe]] ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return [[crusoe]] . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "[[Southpaw]]" != "[[Southpaw]]" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 351 ---------------------------------------------
Returns the name of the given key . --> generate barbs --> Socre: 1.0

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > key ) { Annotation [[annotation]] = key . getAnnotation ( ) ; Class < ? extends Annotation > [[annotationType]] = key . getAnnotationType ( ) ; if ( [[annotation]] != null && ! isMarker ( [[annotationType]] ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[barbs]] ( Key < ? > key ) { Annotation [[ß]] = key . getAnnotation ( ) ; Class < ? extends Annotation > [[exp]] = key . getAnnotationType ( ) ; if ( [[ß]] != null && ! isMarker ( [[exp]] ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 352 ---------------------------------------------
Removes the given dependencies from the dependency set . --> Removes any listed deps from the set --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : deps ) { Class < ? > [[annotationType]] = dep . getKey ( ) . getAnnotationType ( ) ; if ( [[annotationType]] == null || ! [[annotationType]] . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : deps ) { Class < ? > [[loudspeakers]] = dep . getKey ( ) . getAnnotationType ( ) ; if ( [[loudspeakers]] == null || ! [[loudspeakers]] . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 353 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 330 / 19 / 4 / 353:  35%|███▌      | 353/1000 [2:59:10<5:28:24, 30.45s/it][Succeeded / Failed / Skipped / Total] 330 / 19 / 4 / 353:  35%|███▌      | 354/1000 [3:02:19<5:32:42, 30.90s/it][Succeeded / Failed / Skipped / Total] 331 / 19 / 4 / 354:  35%|███▌      | 354/1000 [3:02:19<5:32:42, 30.90s/it][Succeeded / Failed / Skipped / Total] 331 / 19 / 4 / 354:  36%|███▌      | 355/1000 [3:02:38<5:31:50, 30.87s/it][Succeeded / Failed / Skipped / Total] 332 / 19 / 4 / 355:  36%|███▌      | 355/1000 [3:02:38<5:31:50, 30.87s/it][Succeeded / Failed / Skipped / Total] 332 / 19 / 4 / 355:  36%|███▌      | 356/1000 [3:02:58<5:31:00, 30.84s/it][Succeeded / Failed / Skipped / Total] 333 / 19 / 4 / 356:  36%|███▌      | 356/1000 [3:02:58<5:31:00, 30.84s/it][Succeeded / Failed / Skipped / Total] 333 / 19 / 4 / 356:  36%|███▌      | 357/1000 [3:03:03<5:29:42, 30.77s/it][Succeeded / Failed / Skipped / Total] 333 / 20 / 4 / 357:  36%|███▌      | 357/1000 [3:03:03<5:29:42, 30.77s/it][Succeeded / Failed / Skipped / Total] 333 / 20 / 4 / 357:  36%|███▌      | 358/1000 [3:03:21<5:28:49, 30.73s/it][Succeeded / Failed / Skipped / Total] 334 / 20 / 4 / 358:  36%|███▌      | 358/1000 [3:03:21<5:28:49, 30.73s/it][Succeeded / Failed / Skipped / Total] 334 / 20 / 4 / 358:  36%|███▌      | 359/1000 [3:04:30<5:29:26, 30.84s/it][Succeeded / Failed / Skipped / Total] 335 / 20 / 4 / 359:  36%|███▌      | 359/1000 [3:04:30<5:29:26, 30.84s/it][Succeeded / Failed / Skipped / Total] 335 / 20 / 4 / 359:  36%|███▌      | 360/1000 [3:04:51<5:28:38, 30.81s/it]Creates a new instance . --> documentation inherited from interface construction --> Socre: 1.0

[[[[Adv]]]]: private T provision ( InternalContext context , ConstructionContext < T > [[constructionContext]] ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; [[constructionContext]] . setProxyDelegates ( t ) ; } finally { [[constructionContext]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T provision ( InternalContext context , ConstructionContext < T > [[ménage]] ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; [[ménage]] . setProxyDelegates ( t ) ; } finally { [[ménage]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 354 ---------------------------------------------
Determines if the given constructor has any matching parameters . --> documentation inherited from constructor --> Socre: 1.0

[[[[Adv]]]]: private boolean [[constructorHasMatchingParams]] ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > [[paramList]] , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean [[cushing]] ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > [[estelle]] , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 355 ---------------------------------------------
Invokes the method on the proxy . --> Called by reflection --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object invoke ( Object [[proxy]] , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object invoke ( Object [[disparity]] , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 356 ---------------------------------------------
Throws an exception for missing implementation . --> Throws an exception when the key is not bound . --> Socre: 1.0

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[sb]] = new StringBuilder ( ) ; [[sb]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[dominguez]] = new StringBuilder ( ) ; [[dominguez]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 357 ---------------------------------------------
Returns a new key for a new value . --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > [[entrySetBinder]] = bindingSelection . getEntrySetBinder ( ) ; Key < V > [[valueKey]] = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( [[entrySetBinder]] . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; [[entrySetBinder]] . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , [[valueKey]] ) ) ; return [[valueKey]] ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > [[mountaineers]] = bindingSelection . getEntrySetBinder ( ) ; Key < V > [[torchlight]] = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( [[mountaineers]] . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; [[mountaineers]] . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , [[torchlight]] ) ) ; return [[torchlight]] ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 358 ---------------------------------------------
Gets the binding for a new injector . --> Reall reall methods --> Socre: 1.0

[[[[Adv]]]]: public Binding < ? > [[getBindingFromNewInjector]] ( final Method method , final Object [ ] args , final AssistData [[data]] ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = [[data]] . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > [[reall]] ( final Method method , final Object [ ] args , final AssistData [[vibe]] ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = [[vibe]] . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 359 ---------------------------------------------
Determines if a type is not defined . --> Casts a CPE Clears a CPE CURRENT CURRENT --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isTypeNotSpecified]] ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > [[messages]] = ce . getErrorMessages ( ) ; if ( [[messages]] . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( [[messages]] ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean [[cabeça]] ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > [[mountaineers]] = ce . getErrorMessages ( ) ; if ( [[mountaineers]] . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( [[mountaineers]] ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
[Succeeded / Failed / Skipped / Total] 336 / 20 / 4 / 360:  36%|███▌      | 360/1000 [3:04:51<5:28:38, 30.81s/it][Succeeded / Failed / Skipped / Total] 336 / 20 / 4 / 360:  36%|███▌      | 361/1000 [3:04:52<5:27:14, 30.73s/it][Succeeded / Failed / Skipped / Total] 337 / 20 / 4 / 361:  36%|███▌      | 361/1000 [3:04:52<5:27:14, 30.73s/it][Succeeded / Failed / Skipped / Total] 337 / 20 / 4 / 361:  36%|███▌      | 362/1000 [3:05:02<5:26:07, 30.67s/it][Succeeded / Failed / Skipped / Total] 338 / 20 / 4 / 362:  36%|███▌      | 362/1000 [3:05:02<5:26:07, 30.67s/it][Succeeded / Failed / Skipped / Total] 338 / 20 / 4 / 362:  36%|███▋      | 363/1000 [3:05:11<5:24:58, 30.61s/it][Succeeded / Failed / Skipped / Total] 339 / 20 / 4 / 363:  36%|███▋      | 363/1000 [3:05:11<5:24:58, 30.61s/it][Succeeded / Failed / Skipped / Total] 339 / 20 / 4 / 363:  36%|███▋      | 364/1000 [3:05:20<5:23:49, 30.55s/it][Succeeded / Failed / Skipped / Total] 340 / 20 / 4 / 364:  36%|███▋      | 364/1000 [3:05:20<5:23:49, 30.55s/it][Succeeded / Failed / Skipped / Total] 340 / 20 / 4 / 364:  36%|███▋      | 365/1000 [3:05:38<5:22:57, 30.52s/it][Succeeded / Failed / Skipped / Total] 341 / 20 / 4 / 365:  36%|███▋      | 365/1000 [3:05:38<5:22:57, 30.52s/it][Succeeded / Failed / Skipped / Total] 341 / 20 / 4 / 365:  37%|███▋      | 366/1000 [3:06:55<5:23:47, 30.64s/it][Succeeded / Failed / Skipped / Total] 342 / 20 / 4 / 366:  37%|███▋      | 366/1000 [3:06:55<5:23:47, 30.64s/it][Succeeded / Failed / Skipped / Total] 342 / 20 / 4 / 366:  37%|███▋      | 367/1000 [3:07:36<5:23:35, 30.67s/it][Succeeded / Failed / Skipped / Total] 343 / 20 / 4 / 367:  37%|███▋      | 367/1000 [3:07:36<5:23:35, 30.67s/it][Succeeded / Failed / Skipped / Total] 343 / 20 / 4 / 367:  37%|███▋      | 368/1000 [3:07:36<5:22:12, 30.59s/it]--------------------------------------------- Result 360 ---------------------------------------------
Checks if a constructor has at least at least one annotation --> ? --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasAtInject]] ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean [[yous]] ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 361 ---------------------------------------------
Get dependencies from ctor point --> Echo from ctor point --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[getDependencies]] ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint [[ip]] : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( [[ip]] . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > [[keppel]] ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint [[aaliyah]] : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( [[aaliyah]] . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 362 ---------------------------------------------
Installs a real set binder for the given key . --> adds a RealMultibinder to the given binder --> Socre: 1.0

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder binder , Key < T > [[key]] ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( binder , [[key]] ) ; binder . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder binder , Key < T > [[amend]] ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( binder , [[amend]] ) ; binder . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 363 ---------------------------------------------
Returns a module scope for the given module . --> Factory method for ModuleAnnotatedMethods --> Socre: 1.0

[[[[Adv]]]]: public static Module forModule ( Object [[module]] , ModuleAnnotatedMethodScanner scanner ) { return forObject ( [[module]] , "False" != "False" , scanner ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module forModule ( Object [[emerald]] , ModuleAnnotatedMethodScanner scanner ) { return forObject ( [[emerald]] , "False" != "False" , scanner ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 364 ---------------------------------------------
Checks if the given interceptor has scope annotation --> Is inbound? --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasScope]] ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation [[annotation]] : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[annotation]] . annotationType ( ) ) ) { return "True" == "True" ; } } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean [[inbound]] ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation [[kongfu]] : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[kongfu]] . annotationType ( ) ) ) { return "True" == "True" ; } } return "[[Canst]]" != "[[Canst]]" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 365 ---------------------------------------------
Initialize this injector . --> Initialization process --> Socre: 1.0

[[[[Adv]]]]: void initialize ( Errors [[errors]] ) { injector . lookups = injector ; new LookupProcessor ( [[errors]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void initialize ( Errors [[daytime]] ) { injector . lookups = injector ; new LookupProcessor ( [[daytime]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 366 ---------------------------------------------
Find the next filter . --> Search for an Aishwarya object --> Socre: 1.0

[[[[Adv]]]]: private Filter [[findNextFilter]] ( HttpServletRequest [[request]] ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( [[request]] ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter [[aishwarya]] ( HttpServletRequest [[assign]] ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( [[assign]] ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 367 ---------------------------------------------
Find the first annotation claimed for the given method . --> Package private for testing --> Socre: 1.0

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation [[foundAnnotation]] = method . getAnnotation ( annotationClass ) ; if ( [[foundAnnotation]] != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = [[foundAnnotation]] ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation [[teasing]] = method . getAnnotation ( annotationClass ) ; if ( [[teasing]] != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = [[teasing]] ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
[Succeeded / Failed / Skipped / Total] 344 / 20 / 4 / 368:  37%|███▋      | 368/1000 [3:07:36<5:22:12, 30.59s/it][Succeeded / Failed / Skipped / Total] 344 / 20 / 4 / 368:  37%|███▋      | 369/1000 [3:07:37<5:20:50, 30.51s/it][Succeeded / Failed / Skipped / Total] 345 / 20 / 4 / 369:  37%|███▋      | 369/1000 [3:07:37<5:20:50, 30.51s/it][Succeeded / Failed / Skipped / Total] 345 / 20 / 4 / 369:  37%|███▋      | 370/1000 [3:08:31<5:20:59, 30.57s/it][Succeeded / Failed / Skipped / Total] 346 / 20 / 4 / 370:  37%|███▋      | 370/1000 [3:08:31<5:20:59, 30.57s/it][Succeeded / Failed / Skipped / Total] 346 / 20 / 4 / 370:  37%|███▋      | 371/1000 [3:10:08<5:22:22, 30.75s/it][Succeeded / Failed / Skipped / Total] 347 / 20 / 4 / 371:  37%|███▋      | 371/1000 [3:10:08<5:22:22, 30.75s/it][Succeeded / Failed / Skipped / Total] 347 / 20 / 4 / 371:  37%|███▋      | 372/1000 [3:10:28<5:21:33, 30.72s/it][Succeeded / Failed / Skipped / Total] 348 / 20 / 4 / 372:  37%|███▋      | 372/1000 [3:10:28<5:21:33, 30.72s/it][Succeeded / Failed / Skipped / Total] 348 / 20 / 4 / 372:  37%|███▋      | 373/1000 [3:11:11<5:21:22, 30.75s/it][Succeeded / Failed / Skipped / Total] 348 / 21 / 4 / 373:  37%|███▋      | 373/1000 [3:11:11<5:21:22, 30.75s/it][Succeeded / Failed / Skipped / Total] 348 / 21 / 4 / 373:  37%|███▋      | 374/1000 [3:11:11<5:20:00, 30.67s/it][Succeeded / Failed / Skipped / Total] 349 / 21 / 4 / 374:  37%|███▋      | 374/1000 [3:11:11<5:20:00, 30.67s/it][Succeeded / Failed / Skipped / Total] 349 / 21 / 4 / 374:  38%|███▊      | 375/1000 [3:11:26<5:19:04, 30.63s/it]--------------------------------------------- Result 368 ---------------------------------------------
Gets the internal constructor . --> For testing only --> Socre: 1.0

[[[[Adv]]]]: InjectionPoint [[getInternalConstructor]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint [[fastened]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 369 ---------------------------------------------
Wraps a callable in a future . --> Transfer Requestable --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > transferRequest ( Callable < T > [[callable]] ) { return wrap ( [[callable]] , transferRequest ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > transferRequest ( Callable < T > [[carmela]] ) { return wrap ( [[carmela]] , transferRequest ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 370 ---------------------------------------------
Gets the line number for the given member . --> returns binder --> Socre: 1.0

[[[[Adv]]]]: public Integer [[getLineNumber]] ( Member [[member]] ) { Preconditions . checkArgument ( type == [[member]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[member]] , [[member]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[member]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer [[binder]] ( Member [[mère]] ) { Preconditions . checkArgument ( type == [[mère]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[mère]] , [[mère]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[mère]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 371 ---------------------------------------------
Wrap a callable in a future . --> Enables continue negotiation --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > continueRequest ( Callable < T > [[callable]] , Map < Key < ? > , Object > [[seedMap]] ) { return wrap ( [[callable]] , continueRequest ( [[seedMap]] ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > continueRequest ( Callable < T > [[houseboat]] , Map < Key < ? > , Object > [[negotiates]] ) { return wrap ( [[houseboat]] , continueRequest ( [[negotiates]] ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 372 ---------------------------------------------
Returns true if the given set is valid for the given factory . --> Turns beatbox into beatbox --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isValidForOptimizedAssistedInject]] ( Set < Dependency < ? > > [[dependencies]] , Class < ? > implementation , TypeLiteral < ? > [[factoryType]] ) { Set < Dependency < ? > > [[badDeps]] = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean [[bhola]] ( Set < Dependency < ? > > [[beatbox]] , Class < ? > implementation , TypeLiteral < ? > [[playgirl]] ) { Set < Dependency < ? > > [[xhosa]] = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 373 ---------------------------------------------
Get the internal dependencies . --> [[[FAILED]]]

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[shea]] ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 374 ---------------------------------------------
Gets injectors for injection points . --> get a single member injector --> Socre: 1.0

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint [[injectionPoint]] : injectionPoints ) { try { Errors errorsForMember = [[injectionPoint]] . isOptional ( ) ? new Errors ( [[injectionPoint]] ) : errors . withSource ( [[injectionPoint]] ) ; SingleMemberInjector injector = [[injectionPoint]] . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . [[injector]] , [[injectionPoint]] , errorsForMember ) : new SingleMethodInjector ( this . [[injector]] , [[injectionPoint]] , errorsForMember ) ; injectors . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint [[advisable]] : injectionPoints ) { try { Errors errorsForMember = [[advisable]] . isOptional ( ) ? new Errors ( [[advisable]] ) : errors . withSource ( [[advisable]] ) ; SingleMemberInjector injector = [[advisable]] . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . [[exhausted]] , [[advisable]] , errorsForMember ) : new SingleMethodInjector ( this . [[exhausted]] , [[advisable]] , errorsForMember ) ; injectors . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 375 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 350 / 21 / 4 / 375:  38%|███▊      | 375/1000 [3:11:26<5:19:04, 30.63s/it][Succeeded / Failed / Skipped / Total] 350 / 21 / 4 / 375:  38%|███▊      | 376/1000 [3:11:28<5:17:45, 30.55s/it][Succeeded / Failed / Skipped / Total] 351 / 21 / 4 / 376:  38%|███▊      | 376/1000 [3:11:28<5:17:45, 30.55s/it][Succeeded / Failed / Skipped / Total] 351 / 21 / 4 / 376:  38%|███▊      | 377/1000 [3:11:43<5:16:49, 30.51s/it][Succeeded / Failed / Skipped / Total] 352 / 21 / 4 / 377:  38%|███▊      | 377/1000 [3:11:43<5:16:49, 30.51s/it][Succeeded / Failed / Skipped / Total] 352 / 21 / 4 / 377:  38%|███▊      | 378/1000 [3:12:57<5:17:30, 30.63s/it][Succeeded / Failed / Skipped / Total] 353 / 21 / 4 / 378:  38%|███▊      | 378/1000 [3:12:57<5:17:30, 30.63s/it][Succeeded / Failed / Skipped / Total] 353 / 21 / 4 / 378:  38%|███▊      | 379/1000 [3:15:11<5:19:49, 30.90s/it][Succeeded / Failed / Skipped / Total] 354 / 21 / 4 / 379:  38%|███▊      | 379/1000 [3:15:11<5:19:49, 30.90s/it][Succeeded / Failed / Skipped / Total] 354 / 21 / 4 / 379:  38%|███▊      | 380/1000 [3:15:30<5:18:58, 30.87s/it]Validates and canonicalizes the given value . --> Checks if ties match --> Socre: 1.0

[[[[Adv]]]]: private static Object [[validateAndCanonicalizeValue]] ( Key < ? > key , Object [[object]] ) { if ( [[object]] == null || [[object]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[object]] ) ) { throw new IllegalArgumentException ( "Value[" + [[object]] + "] of type[" + [[object]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[object]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object [[alonso]] ( Key < ? > key , Object [[ties]] ) { if ( [[ties]] == null || [[ties]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[ties]] ) ) { throw new IllegalArgumentException ( "Value[" + [[ties]] + "] of type[" + [[ties]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[ties]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 376 ---------------------------------------------
Gets the binding source . --> May be useful for debugging --> Socre: 1.0

[[[[Adv]]]]: public String [[getBindingSource]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String [[achy]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 377 ---------------------------------------------
Creates a new Key instance --> fag is fag --> Socre: 1.0

[[[[Adv]]]]: static < T > Key < T > [[get]] ( Class < T > type , AnnotationStrategy annotationStrategy ) { return new Key < T > ( type , annotationStrategy ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > [[fag]] ( Class < T > type , AnnotationStrategy annotationStrategy ) { return new Key < T > ( type , annotationStrategy ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 378 ---------------------------------------------
Create a injector for a type . --> Create an AnsonInjector --> Socre: 1.0

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > [[encounter]] = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener [[typeListener]] = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( [[typeListener]] ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( [[typeListener]] ) ; try { [[typeListener]] . hear ( type , [[encounter]] ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } [[encounter]] . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , [[encounter]] , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > [[anson]] = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener [[capistrano]] = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( [[capistrano]] ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( [[capistrano]] ) ; try { [[capistrano]] . hear ( type , [[anson]] ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } [[anson]] . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , [[anson]] , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 379 ---------------------------------------------
Returns a strategy for the given annotation type . --> Hootenanny algorithm --> Socre: 1.0

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > [[annotationType]] ) { [[annotationType]] = Annotations . canonicalizeIfNamed ( [[annotationType]] ) ; if ( isAllDefaultMethods ( [[annotationType]] ) ) { return [[strategyFor]] ( generateAnnotation ( [[annotationType]] ) ) ; } checkNotNull ( [[annotationType]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; return new AnnotationTypeStrategy ( [[annotationType]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[hootenanny]] ( Class < ? extends Annotation > [[escorted]] ) { [[escorted]] = Annotations . canonicalizeIfNamed ( [[escorted]] ) ; if ( isAllDefaultMethods ( [[escorted]] ) ) { return [[hootenanny]] ( generateAnnotation ( [[escorted]] ) ) ; } checkNotNull ( [[escorted]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[escorted]] ) ; ensureIsBindingAnnotation ( [[escorted]] ) ; return new AnnotationTypeStrategy ( [[escorted]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 380 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 355 / 21 / 4 / 380:  38%|███▊      | 380/1000 [3:15:30<5:18:58, 30.87s/it][Succeeded / Failed / Skipped / Total] 355 / 21 / 4 / 380:  38%|███▊      | 381/1000 [3:15:32<5:17:42, 30.80s/it][Succeeded / Failed / Skipped / Total] 356 / 21 / 4 / 381:  38%|███▊      | 381/1000 [3:15:32<5:17:42, 30.80s/it][Succeeded / Failed / Skipped / Total] 356 / 21 / 4 / 381:  38%|███▊      | 382/1000 [3:15:59<5:17:04, 30.78s/it][Succeeded / Failed / Skipped / Total] 357 / 21 / 4 / 382:  38%|███▊      | 382/1000 [3:15:59<5:17:04, 30.78s/it][Succeeded / Failed / Skipped / Total] 357 / 21 / 4 / 382:  38%|███▊      | 383/1000 [3:16:16<5:16:12, 30.75s/it][Succeeded / Failed / Skipped / Total] 358 / 21 / 4 / 383:  38%|███▊      | 383/1000 [3:16:16<5:16:12, 30.75s/it][Succeeded / Failed / Skipped / Total] 358 / 21 / 4 / 383:  38%|███▊      | 384/1000 [3:17:38<5:17:03, 30.88s/it][Succeeded / Failed / Skipped / Total] 359 / 21 / 4 / 384:  38%|███▊      | 384/1000 [3:17:38<5:17:03, 30.88s/it][Succeeded / Failed / Skipped / Total] 359 / 21 / 4 / 384:  38%|███▊      | 385/1000 [3:17:59<5:16:16, 30.86s/it][Succeeded / Failed / Skipped / Total] 360 / 21 / 4 / 385:  38%|███▊      | 385/1000 [3:17:59<5:16:16, 30.86s/it][Succeeded / Failed / Skipped / Total] 360 / 21 / 4 / 385:  39%|███▊      | 386/1000 [3:18:05<5:15:05, 30.79s/it][Succeeded / Failed / Skipped / Total] 361 / 21 / 4 / 386:  39%|███▊      | 386/1000 [3:18:05<5:15:05, 30.79s/it][Succeeded / Failed / Skipped / Total] 361 / 21 / 4 / 386:  39%|███▊      | 387/1000 [3:18:20<5:14:10, 30.75s/it][Succeeded / Failed / Skipped / Total] 362 / 21 / 4 / 387:  39%|███▊      | 387/1000 [3:18:20<5:14:10, 30.75s/it][Succeeded / Failed / Skipped / Total] 362 / 21 / 4 / 387:  39%|███▉      | 388/1000 [3:18:37<5:13:16, 30.71s/it][Succeeded / Failed / Skipped / Total] 363 / 21 / 4 / 388:  39%|███▉      | 388/1000 [3:18:37<5:13:16, 30.71s/it][Succeeded / Failed / Skipped / Total] 363 / 21 / 4 / 388:  39%|███▉      | 389/1000 [3:19:10<5:12:50, 30.72s/it]Convert an object to an object . --> Convenient method for chaffee --> Socre: 1.0

[[[[Adv]]]]: static Object [[convert]] ( Object o ) { ElementSource source = null ; if ( o instanceof ElementSource ) { source = ( ElementSource ) o ; o = source . getDeclaringSource ( ) ; } return [[convert]] ( o , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object [[chaffee]] ( Object o ) { ElementSource source = null ; if ( o instanceof ElementSource ) { source = ( ElementSource ) o ; o = source . getDeclaringSource ( ) ; } return [[chaffee]] ( o , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 381 ---------------------------------------------
Creates a formatted message with the given message and arguments . --> Protected constructor --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , String messageFormat , Object ... arguments ) { return [[create]] ( [[cause]] , ImmutableList . of ( ) , messageFormat , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[protested]] ( Throwable [[dorf]] , String messageFormat , Object ... arguments ) { return [[protested]] ( [[dorf]] , ImmutableList . of ( ) , messageFormat , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 382 ---------------------------------------------
Creates a new message with the given format and arguments . --> Convenience factory method --> Socre: 1.0

[[[[Adv]]]]: public static Message create ( String [[messageFormat]] , Object ... [[arguments]] ) { return create ( null , [[messageFormat]] , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message create ( String [[cream]] , Object ... [[riddle]] ) { return create ( null , [[cream]] , [[riddle]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 383 ---------------------------------------------
Manage jmx module . --> shutdown the module --> Socre: 1.0

[[[[Adv]]]]: public static void [[main]] ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void [[downstate]] ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 384 ---------------------------------------------
Removes the stack trace from a throwable . --> package - private for testing --> Socre: 1.0

[[[[Adv]]]]: private void [[pruneStacktrace]] ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] [[stackTrace]] = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : [[stackTrace]] ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void [[ín]] ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] [[rudiments]] = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : [[rudiments]] ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 385 ---------------------------------------------
Pushes the given key to the given source . --> Internal pushState method --> Socre: 1.0

[[[[Adv]]]]: void pushState ( com . google . inject . Key < ? > [[key]] , Object source ) { doPushState ( [[key]] , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void pushState ( com . google . inject . Key < ? > [[frommer]] , Object source ) { doPushState ( [[frommer]] , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 386 ---------------------------------------------
Checks if the given class should be skipped . --> merge with a lassule --> Socre: 1.0

[[[[Adv]]]]: private boolean [[shouldBeSkipped]] ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains ( className ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean [[bergère]] ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains ( className ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
--------------------------------------------- Result 387 ---------------------------------------------
Returns an initializable instance --> Construct a Serializable object --> Socre: 1.0

[[[[Adv]]]]: static < T > Initializable < T > of ( final T [[instance]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[instance]] ; } @ Override public String toString ( ) { return String . valueOf ( [[instance]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > of ( final T [[duroc]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[duroc]] ; } @ Override public String toString ( ) { return String . valueOf ( [[duroc]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 388 ---------------------------------------------
Process connection event . --> Handle connection event --> Socre: 1.0

[[[[Adv]]]]: public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > [[processorList]] = this . processors . get ( type ) ; if ( [[processorList]] != null ) { for ( ConnectionEventProcessor processor : [[processorList]] ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .

[[[[Adv]]]]: public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > [[marta]] = this . processors . get ( type ) ; if ( [[marta]] != null ) { for ( ConnectionEventProcessor processor : [[marta]] ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .
[Succeeded / Failed / Skipped / Total] 364 / 21 / 4 / 389:  39%|███▉      | 389/1000 [3:19:10<5:12:50, 30.72s/it][Succeeded / Failed / Skipped / Total] 364 / 21 / 4 / 389:  39%|███▉      | 390/1000 [3:19:23<5:11:52, 30.68s/it][Succeeded / Failed / Skipped / Total] 365 / 21 / 4 / 390:  39%|███▉      | 390/1000 [3:19:23<5:11:52, 30.68s/it][Succeeded / Failed / Skipped / Total] 365 / 21 / 4 / 390:  39%|███▉      | 391/1000 [3:19:41<5:11:01, 30.64s/it][Succeeded / Failed / Skipped / Total] 366 / 21 / 4 / 391:  39%|███▉      | 391/1000 [3:19:41<5:11:01, 30.64s/it][Succeeded / Failed / Skipped / Total] 366 / 21 / 4 / 391:  39%|███▉      | 392/1000 [3:19:47<5:09:52, 30.58s/it][Succeeded / Failed / Skipped / Total] 367 / 21 / 4 / 392:  39%|███▉      | 392/1000 [3:19:47<5:09:52, 30.58s/it][Succeeded / Failed / Skipped / Total] 367 / 21 / 4 / 392:  39%|███▉      | 393/1000 [3:20:45<5:10:05, 30.65s/it][Succeeded / Failed / Skipped / Total] 368 / 21 / 4 / 393:  39%|███▉      | 393/1000 [3:20:45<5:10:05, 30.65s/it][Succeeded / Failed / Skipped / Total] 368 / 21 / 4 / 393:  39%|███▉      | 394/1000 [3:20:47<5:08:50, 30.58s/it][Succeeded / Failed / Skipped / Total] 369 / 21 / 4 / 394:  39%|███▉      | 394/1000 [3:20:47<5:08:50, 30.58s/it][Succeeded / Failed / Skipped / Total] 369 / 21 / 4 / 394:  40%|███▉      | 395/1000 [3:21:07<5:08:03, 30.55s/it][Succeeded / Failed / Skipped / Total] 370 / 21 / 4 / 395:  40%|███▉      | 395/1000 [3:21:07<5:08:03, 30.55s/it][Succeeded / Failed / Skipped / Total] 370 / 21 / 4 / 395:  40%|███▉      | 396/1000 [3:21:28<5:07:18, 30.53s/it][Succeeded / Failed / Skipped / Total] 371 / 21 / 4 / 396:  40%|███▉      | 396/1000 [3:21:28<5:07:18, 30.53s/it][Succeeded / Failed / Skipped / Total] 371 / 21 / 4 / 396:  40%|███▉      | 397/1000 [3:21:52<5:06:37, 30.51s/it]--------------------------------------------- Result 389 ---------------------------------------------
Pushes a new dependency . --> must be called --> Socre: 1.0

[[[[Adv]]]]: Dependency < ? > [[pushDependency]] ( Dependency < ? > dependency , Object source ) { Dependency < ? > previous = this . dependency ; this . dependency = dependency ; doPushState ( dependency , source ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > [[bye]] ( Dependency < ? > dependency , Object source ) { Dependency < ? > previous = this . dependency ; this . dependency = dependency ; doPushState ( dependency , source ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 390 ---------------------------------------------
Creates a formatted message . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public static Message create ( Throwable [[cause]] , List < Object > sources , String messageFormat , Object ... [[arguments]] ) { String message = format ( messageFormat , [[arguments]] ) ; return new Message ( sources , message , [[cause]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message create ( Throwable [[nebuchadnezzar]] , List < Object > sources , String messageFormat , Object ... [[exterminate]] ) { String message = format ( messageFormat , [[exterminate]] ) ; return new Message ( sources , message , [[nebuchadnezzar]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 391 ---------------------------------------------
Creates a new instance . --> Perform the provisioning --> Socre: 1.0

[[[[Adv]]]]: protected T provision ( Provider < ? extends T > [[provider]] , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T t = [[provider]] . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T provision ( Provider < ? extends T > [[weíre]] , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T t = [[weíre]] . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .
--------------------------------------------- Result 392 ---------------------------------------------
Learches an unchecked throwable . --> Liefert die An UnsafeThrowable --> Socre: 1.0

[[[[Adv]]]]: public static void launderThrowable ( Throwable [[t]] ) { if ( [[t]] instanceof RuntimeException ) { throw ( RuntimeException ) [[t]] ; } else if ( [[t]] instanceof Error ) { throw ( Error ) [[t]] ; } else { throw new IllegalStateException ( "Not unchecked!" , [[t]] ) ; } }
[[[[Nl]]]]: launder the throwable

[[[[Adv]]]]: public static void launderThrowable ( Throwable [[autopsy]] ) { if ( [[autopsy]] instanceof RuntimeException ) { throw ( RuntimeException ) [[autopsy]] ; } else if ( [[autopsy]] instanceof Error ) { throw ( Error ) [[autopsy]] ; } else { throw new IllegalStateException ( "Not unchecked!" , [[autopsy]] ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 393 ---------------------------------------------
Registers the default processor . --> Registers a RemotingProcessor --> Socre: 1.0

[[[[Adv]]]]: public void [[registerDefaultProcessor]] ( RemotingProcessor < ? > processor ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void [[wily]] ( RemotingProcessor < ? > processor ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 394 ---------------------------------------------
Returns a strategy for the given annotation . --> Renders a poisonie --> Socre: 1.0

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Annotation [[annotation]] ) { checkNotNull ( [[annotation]] , "annotation" ) ; Class < ? extends Annotation > [[annotationType]] = [[annotation]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; if ( Annotations . isMarker ( [[annotationType]] ) ) { return new AnnotationTypeStrategy ( [[annotationType]] , [[annotation]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[annotation]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy [[roasting]] ( Annotation [[sweetie]] ) { checkNotNull ( [[sweetie]] , "annotation" ) ; Class < ? extends Annotation > [[rogue]] = [[sweetie]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[rogue]] ) ; ensureIsBindingAnnotation ( [[rogue]] ) ; if ( Annotations . isMarker ( [[rogue]] ) ) { return new AnnotationTypeStrategy ( [[rogue]] , [[sweetie]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[sweetie]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 395 ---------------------------------------------
Tries to get a cached URL . --> Tries to retrieve an URL . --> Socre: 1.0

[[[[Adv]]]]: private Url tryGet ( String url ) { SoftReference < Url > [[softRef]] = Url . parsedUrls . get ( url ) ; return ( null == [[softRef]] ) ? null : [[softRef]] . get ( ) ; }
[[[[Nl]]]]: try get from cache

[[[[Adv]]]]: private Url tryGet ( String url ) { SoftReference < Url > [[tortoise]] = Url . parsedUrls . get ( url ) ; return ( null == [[tortoise]] ) ? null : [[tortoise]] . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 396 ---------------------------------------------
Decodes protocol code . --> Skip snipping . --> Socre: 1.0

[[[[Adv]]]]: protected ProtocolCode [[decodeProtocolCode]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode [[snipping]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 397 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 372 / 21 / 4 / 397:  40%|███▉      | 397/1000 [3:21:52<5:06:37, 30.51s/it][Succeeded / Failed / Skipped / Total] 372 / 21 / 4 / 397:  40%|███▉      | 398/1000 [3:21:57<5:05:28, 30.45s/it][Succeeded / Failed / Skipped / Total] 373 / 21 / 4 / 398:  40%|███▉      | 398/1000 [3:21:57<5:05:28, 30.45s/it][Succeeded / Failed / Skipped / Total] 373 / 21 / 4 / 398:  40%|███▉      | 399/1000 [3:22:11<5:04:33, 30.41s/it][Succeeded / Failed / Skipped / Total] 374 / 21 / 4 / 399:  40%|███▉      | 399/1000 [3:22:11<5:04:33, 30.41s/it][Succeeded / Failed / Skipped / Total] 374 / 21 / 4 / 399:  40%|████      | 400/1000 [3:22:15<5:03:23, 30.34s/it][Succeeded / Failed / Skipped / Total] 375 / 21 / 4 / 400:  40%|████      | 400/1000 [3:22:15<5:03:23, 30.34s/it][Succeeded / Failed / Skipped / Total] 375 / 21 / 4 / 400:  40%|████      | 401/1000 [3:22:31<5:02:31, 30.30s/it][Succeeded / Failed / Skipped / Total] 376 / 21 / 4 / 401:  40%|████      | 401/1000 [3:22:31<5:02:31, 30.30s/it][Succeeded / Failed / Skipped / Total] 376 / 21 / 4 / 401:  40%|████      | 402/1000 [3:22:33<5:01:18, 30.23s/it]Returns a map of all the connections in this pool . --> region ConnectionPool Implementation --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > [[allConnections]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { [[allConnections]] . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return [[allConnections]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > [[crud]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { [[crud]] . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return [[crud]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .
--------------------------------------------- Result 398 ---------------------------------------------
Adds a processor to a connection event type . --> addConnectionEventProcessor --> Socre: 1.0

[[[[Adv]]]]: public void addConnectionEventProcessor ( ConnectionEventType type , ConnectionEventProcessor [[processor]] ) { List < ConnectionEventProcessor > processorList = this . [[processors]] . get ( type ) ; if ( processorList == null ) { this . [[processors]] . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . [[processors]] . get ( type ) ; } processorList . add ( [[processor]] ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void addConnectionEventProcessor ( ConnectionEventType type , ConnectionEventProcessor [[stabilized]] ) { List < ConnectionEventProcessor > processorList = this . [[blitzen]] . get ( type ) ; if ( processorList == null ) { this . [[blitzen]] . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . [[blitzen]] . get ( type ) ; } processorList . add ( [[stabilized]] ) ; }
[[[[Nl]]]]: Add event processor .
--------------------------------------------- Result 399 ---------------------------------------------
Scan all pools . --> Remove idle pool tasks . --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[scan]] ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan

[[[[Adv]]]]: @ Override public void [[annoyance]] ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 400 ---------------------------------------------
Gets and creates a connection to the remote server . --> Http connection to cadmus connection --> Socre: 1.0

[[[[Adv]]]]: @ Override public Connection [[getAndCreateIfAbsent]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection [[cadmus]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 401 ---------------------------------------------
Create a connection to the remote server . --> Bannisters bannisters bannisters --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[createConnectionAndHealIfNeed]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void [[bannisters]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 402 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 377 / 21 / 4 / 402:  40%|████      | 402/1000 [3:22:33<5:01:18, 30.23s/it][Succeeded / Failed / Skipped / Total] 377 / 21 / 4 / 402:  40%|████      | 403/1000 [3:22:33<5:00:04, 30.16s/it][Succeeded / Failed / Skipped / Total] 378 / 21 / 4 / 403:  40%|████      | 403/1000 [3:22:33<5:00:04, 30.16s/it][Succeeded / Failed / Skipped / Total] 378 / 21 / 4 / 403:  40%|████      | 404/1000 [3:22:51<4:59:15, 30.13s/it][Succeeded / Failed / Skipped / Total] 379 / 21 / 4 / 404:  40%|████      | 404/1000 [3:22:51<4:59:15, 30.13s/it][Succeeded / Failed / Skipped / Total] 379 / 21 / 4 / 404:  40%|████      | 405/1000 [3:23:09<4:58:27, 30.10s/it][Succeeded / Failed / Skipped / Total] 380 / 21 / 4 / 405:  40%|████      | 405/1000 [3:23:09<4:58:27, 30.10s/it][Succeeded / Failed / Skipped / Total] 380 / 21 / 4 / 405:  41%|████      | 406/1000 [3:23:09<4:57:14, 30.02s/it][Succeeded / Failed / Skipped / Total] 381 / 21 / 4 / 406:  41%|████      | 406/1000 [3:23:09<4:57:14, 30.02s/it][Succeeded / Failed / Skipped / Total] 381 / 21 / 4 / 406:  41%|████      | 407/1000 [3:23:21<4:56:17, 29.98s/it][Succeeded / Failed / Skipped / Total] 382 / 21 / 4 / 407:  41%|████      | 407/1000 [3:23:21<4:56:17, 29.98s/it][Succeeded / Failed / Skipped / Total] 382 / 21 / 4 / 407:  41%|████      | 408/1000 [3:23:51<4:55:48, 29.98s/it]Formats a set of error messages . --> Converts a collection of errorMessages to a string --> Socre: 1.0

[[[[Adv]]]]: public static String formatMessages ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message [[errorMessage]] : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , [[errorMessage]] . getMessage ( ) ) ; List < Object > dependencies = [[errorMessage]] . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object [[source]] = dependencies . get ( i ) ; formatSource ( fmt , [[source]] ) ; } Throwable [[cause]] = [[errorMessage]] . getCause ( ) ; if ( displayCauses && [[cause]] != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( [[cause]] ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( [[cause]] ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , [[cause]] . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String formatMessages ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message [[rosé]] : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , [[rosé]] . getMessage ( ) ) ; List < Object > dependencies = [[rosé]] . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object [[shawnee]] = dependencies . get ( i ) ; formatSource ( fmt , [[shawnee]] ) ; } Throwable [[tusk]] = [[rosé]] . getCause ( ) ; if ( displayCauses && [[tusk]] != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( [[tusk]] ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( [[tusk]] ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , [[tusk]] . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 403 ---------------------------------------------
Removes a connection task from the map . --> Removes the connection pool associated with the given geo query . --> Socre: 1.0

[[[[Adv]]]]: private void removeTask ( String [[poolKey]] ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( [[poolKey]] ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void removeTask ( String [[geo]] ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( [[geo]] ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 404 ---------------------------------------------
Check if the connection pool need to be removed --> Perform an asynchronous operation on a server . --> Socre: 1.0

[[[[Adv]]]]: private void [[healIfNeed]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void [[anorak]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected
--------------------------------------------- Result 405 ---------------------------------------------
Gets the configuration for the given module class names . --> Detected from undeploys --> Socre: 1.0

[[[[Adv]]]]: public Object [[getFromClassNames]] ( List < String > [[moduleClassNames]] ) { Preconditions . checkNotNull ( [[moduleClassNames]] , "The list of module class names cannot be null." ) ; for ( final String [[moduleClassName]] : [[moduleClassNames]] ) { if ( ! shouldBeSkipped ( [[moduleClassName]] ) ) { return new StackTraceElement ( [[moduleClassName]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object [[defenses]] ( List < String > [[astronomer]] ) { Preconditions . checkNotNull ( [[astronomer]] , "The list of module class names cannot be null." ) ; for ( final String [[undermining]] : [[astronomer]] ) { if ( ! shouldBeSkipped ( [[undermining]] ) ) { return new StackTraceElement ( [[undermining]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 406 ---------------------------------------------
On close . --> On close --> Socre: 1.0

[[[[Adv]]]]: public void onClose ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture [[future]] = entry . getValue ( ) ; if ( [[future]] != null ) { [[future]] . putResponse ( [[future]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[future]] . cancelTimeout ( ) ; [[future]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void onClose ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture [[comstock]] = entry . getValue ( ) ; if ( [[comstock]] != null ) { [[comstock]] . putResponse ( [[comstock]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[comstock]] . cancelTimeout ( ) ; [[comstock]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 407 ---------------------------------------------
Closes a connection . --> Closes the connection --> Socre: 1.0

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url [[url]] = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( [[url]] . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url [[analogue]] = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( [[analogue]] . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 408 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 383 / 21 / 4 / 408:  41%|████      | 408/1000 [3:23:51<4:55:48, 29.98s/it][Succeeded / Failed / Skipped / Total] 383 / 21 / 4 / 408:  41%|████      | 409/1000 [3:24:18<4:55:12, 29.97s/it][Succeeded / Failed / Skipped / Total] 384 / 21 / 4 / 409:  41%|████      | 409/1000 [3:24:18<4:55:12, 29.97s/it][Succeeded / Failed / Skipped / Total] 384 / 21 / 4 / 409:  41%|████      | 410/1000 [3:24:31<4:54:18, 29.93s/it][Succeeded / Failed / Skipped / Total] 385 / 21 / 4 / 410:  41%|████      | 410/1000 [3:24:31<4:54:18, 29.93s/it][Succeeded / Failed / Skipped / Total] 385 / 21 / 4 / 410:  41%|████      | 411/1000 [3:25:03<4:53:52, 29.94s/it][Succeeded / Failed / Skipped / Total] 385 / 22 / 4 / 411:  41%|████      | 411/1000 [3:25:03<4:53:52, 29.94s/it][Succeeded / Failed / Skipped / Total] 385 / 22 / 4 / 411:  41%|████      | 412/1000 [3:25:17<4:52:59, 29.90s/it][Succeeded / Failed / Skipped / Total] 386 / 22 / 4 / 412:  41%|████      | 412/1000 [3:25:17<4:52:59, 29.90s/it][Succeeded / Failed / Skipped / Total] 386 / 22 / 4 / 412:  41%|████▏     | 413/1000 [3:25:21<4:51:53, 29.84s/it]Returns the processor for a given command code . --> Studio remoting --> Socre: 1.0

[[[[Adv]]]]: public RemotingProcessor < ? > [[getProcessor]] ( CommandCode cmdCode ) { RemotingProcessor < ? > [[processor]] = this . cmd2processors . get ( cmdCode ) ; if ( [[processor]] != null ) { return [[processor]] ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > [[studio]] ( CommandCode cmdCode ) { RemotingProcessor < ? > [[somethings]] = this . cmd2processors . get ( cmdCode ) ; if ( [[somethings]] != null ) { return [[somethings]] ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .
--------------------------------------------- Result 409 ---------------------------------------------
Register a processor --> Registers a RedotingProcessor --> Socre: 1.0

[[[[Adv]]]]: public void registerProcessor ( CommandCode cmdCode , RemotingProcessor < ? > [[processor]] ) { if ( this . [[cmd2processors]] . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , [[processor]] . getClass ( ) . getName ( ) ) ; } this . [[cmd2processors]] . put ( cmdCode , [[processor]] ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void registerProcessor ( CommandCode cmdCode , RemotingProcessor < ? > [[productive]] ) { if ( this . [[alumnus]] . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , [[productive]] . getClass ( ) . getName ( ) ) ; } this . [[alumnus]] . put ( cmdCode , [[productive]] ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 410 ---------------------------------------------
Registers a user processor . --> Registers the userProcessor --> Socre: 1.0

[[[[Adv]]]]: private static void registerUserProcessor ( MultiInterestUserProcessor < ? > [[processor]] , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == [[processor]] . multiInterest ( ) || [[processor]] . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : [[processor]] . multiInterest ( ) ) { UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( interest , [[processor]] ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void registerUserProcessor ( MultiInterestUserProcessor < ? > [[zatoichi]] , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == [[zatoichi]] . multiInterest ( ) || [[zatoichi]] . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : [[zatoichi]] . multiInterest ( ) ) { UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( interest , [[zatoichi]] ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .
--------------------------------------------- Result 411 ---------------------------------------------
Returns the result of the given task . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] [[t]] = null ; if ( null != task ) { try { [[t]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[t]] ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[taha]] > [[taha]] getFutureTaskResult ( RunStateRecordedFutureTask < [[taha]] > task , Logger logger ) { [[taha]] [[receptions]] = null ; if ( null != task ) { try { [[receptions]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[receptions]] ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 412 ---------------------------------------------
Do create . -->  acquiring connection pool . --> Socre: 1.0

[[[[Adv]]]]: private void [[doCreate]] ( final Url url , final ConnectionPool [[pool]] , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = [[pool]] . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; [[pool]] . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections

[[[[Adv]]]]: private void [[acquiring]] ( final Url url , final ConnectionPool [[analogue]] , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = [[analogue]] . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; [[analogue]] . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 413 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 387 / 22 / 4 / 413:  41%|████▏     | 413/1000 [3:25:21<4:51:53, 29.84s/it][Succeeded / Failed / Skipped / Total] 387 / 22 / 4 / 413:  41%|████▏     | 414/1000 [3:25:36<4:51:02, 29.80s/it][Succeeded / Failed / Skipped / Total] 388 / 22 / 4 / 414:  41%|████▏     | 414/1000 [3:25:36<4:51:02, 29.80s/it][Succeeded / Failed / Skipped / Total] 388 / 22 / 4 / 414:  42%|████▏     | 415/1000 [3:25:52<4:50:12, 29.76s/it][Succeeded / Failed / Skipped / Total] 389 / 22 / 4 / 415:  42%|████▏     | 415/1000 [3:25:52<4:50:12, 29.76s/it][Succeeded / Failed / Skipped / Total] 389 / 22 / 4 / 415:  42%|████▏     | 416/1000 [3:25:53<4:49:01, 29.69s/it][Succeeded / Failed / Skipped / Total] 390 / 22 / 4 / 416:  42%|████▏     | 416/1000 [3:25:53<4:49:01, 29.69s/it][Succeeded / Failed / Skipped / Total] 390 / 22 / 4 / 416:  42%|████▏     | 417/1000 [3:27:09<4:49:37, 29.81s/it]Pre - processes the remoting context . --> Sends agile request . --> Socre: 1.0

[[[[Adv]]]]: private void [[preProcessRemotingContext]] ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz

[[[[Adv]]]]: private void [[agile]] ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz
--------------------------------------------- Result 414 ---------------------------------------------
Debug logging . --> For debugging purposes . --> Socre: 1.0

[[[[Adv]]]]: private void debugLog ( RemotingContext [[ctx]] , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( [[ctx]] . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request

[[[[Adv]]]]: private void debugLog ( RemotingContext [[lechery]] , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( [[lechery]] . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request
--------------------------------------------- Result 415 ---------------------------------------------
Print timeout log . --> to run wait time --> Socre: 1.0

[[[[Adv]]]]: private void [[timeoutLog]] ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .

[[[[Adv]]]]: private void [[eyeliner]] ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .
--------------------------------------------- Result 416 ---------------------------------------------
Processes the message . --> This method executes an acronym --> Socre: 1.0

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T [[msg]] , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , [[msg]] ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T [[anemia]] , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , [[anemia]] ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .
--------------------------------------------- Result 417 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 391 / 22 / 4 / 417:  42%|████▏     | 417/1000 [3:27:09<4:49:37, 29.81s/it][Succeeded / Failed / Skipped / Total] 391 / 22 / 4 / 417:  42%|████▏     | 418/1000 [3:27:17<4:48:37, 29.75s/it][Succeeded / Failed / Skipped / Total] 392 / 22 / 4 / 418:  42%|████▏     | 418/1000 [3:27:17<4:48:37, 29.75s/it][Succeeded / Failed / Skipped / Total] 392 / 22 / 4 / 418:  42%|████▏     | 419/1000 [3:27:35<4:47:51, 29.73s/it][Succeeded / Failed / Skipped / Total] 393 / 22 / 4 / 419:  42%|████▏     | 419/1000 [3:27:35<4:47:51, 29.73s/it][Succeeded / Failed / Skipped / Total] 393 / 22 / 4 / 419:  42%|████▏     | 420/1000 [3:27:40<4:46:46, 29.67s/it][Succeeded / Failed / Skipped / Total] 394 / 22 / 4 / 420:  42%|████▏     | 420/1000 [3:27:40<4:46:46, 29.67s/it][Succeeded / Failed / Skipped / Total] 394 / 22 / 4 / 420:  42%|████▏     | 421/1000 [3:27:56<4:45:59, 29.64s/it][Succeeded / Failed / Skipped / Total] 395 / 22 / 4 / 421:  42%|████▏     | 421/1000 [3:27:56<4:45:59, 29.64s/it][Succeeded / Failed / Skipped / Total] 395 / 22 / 4 / 421:  42%|████▏     | 422/1000 [3:29:34<4:47:03, 29.80s/it]Execute the invoke call with a callback . --> Called when the locale has finished --> Socre: 1.0

[[[[Adv]]]]: protected void [[invokeWithCallback]] ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .

[[[[Adv]]]]: protected void [[cachaça]] ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .
--------------------------------------------- Result 418 ---------------------------------------------
Sets an attribute to the given value . --> Don t do anything --> Socre: 1.0

[[[[Adv]]]]: public Object [[setAttributeIfAbsent]] ( String key , Object [[value]] ) { return attributes . putIfAbsent ( key , [[value]] ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object [[dona]] ( String key , Object [[blackest]] ) { return attributes . putIfAbsent ( key , [[blackest]] ) ; }
[[[[Nl]]]]: set attribute if key absent .
--------------------------------------------- Result 419 ---------------------------------------------
Convert an int value to a BitSet --> Converts an integer value into a BitSet --> Socre: 1.0

[[[[Adv]]]]: public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet [[bs]] = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { [[bs]] . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return [[bs]] ; }
[[[[Nl]]]]: from byte to bit set

[[[[Adv]]]]: public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet [[ampoules]] = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { [[ampoules]] . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return [[ampoules]] ; }
[[[[Nl]]]]: from byte to bit set
--------------------------------------------- Result 420 ---------------------------------------------
Dispatches request to user process . --> Dispatches ginsberg . --> Socre: 1.0

[[[[Adv]]]]: private void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand [[cmd]] ) { final int [[id]] = [[cmd]] . getId ( ) ; final byte type = [[cmd]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor

[[[[Adv]]]]: private void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand [[ginsberg]] ) { final int [[inordinately]] = [[ginsberg]] . getId ( ) ; final byte type = [[ginsberg]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor
--------------------------------------------- Result 421 ---------------------------------------------
Stops the background thread . --> Stops the connection . --> Socre: 1.0

[[[[Adv]]]]: public void stop ( ) { if ( ! this . [[started]] ) { return ; } this . [[started]] = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread

[[[[Adv]]]]: public void stop ( ) { if ( ! this . [[ailey]] ) { return ; } this . [[ailey]] = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread
--------------------------------------------- Result 422 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 396 / 22 / 4 / 422:  42%|████▏     | 422/1000 [3:29:34<4:47:03, 29.80s/it][Succeeded / Failed / Skipped / Total] 396 / 22 / 4 / 422:  42%|████▏     | 423/1000 [3:29:41<4:46:02, 29.74s/it][Succeeded / Failed / Skipped / Total] 397 / 22 / 4 / 423:  42%|████▏     | 423/1000 [3:29:41<4:46:02, 29.74s/it][Succeeded / Failed / Skipped / Total] 397 / 22 / 4 / 423:  42%|████▏     | 424/1000 [3:30:04<4:45:23, 29.73s/it][Succeeded / Failed / Skipped / Total] 398 / 22 / 4 / 424:  42%|████▏     | 424/1000 [3:30:04<4:45:23, 29.73s/it][Succeeded / Failed / Skipped / Total] 398 / 22 / 4 / 424:  42%|████▎     | 425/1000 [3:30:06<4:44:15, 29.66s/it]This method is called on the remote endpoint . --> Implements the messenger --> Socre: 1.0

[[[[Adv]]]]: protected void [[oneway]] ( final Connection conn , final RemotingCommand [[request]] ) { try { conn . getChannel ( ) . writeAndFlush ( [[request]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == conn ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .

[[[[Adv]]]]: protected void [[amélie]] ( final Connection conn , final RemotingCommand [[hoarse]] ) { try { conn . getChannel ( ) . writeAndFlush ( [[hoarse]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == conn ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .
--------------------------------------------- Result 423 ---------------------------------------------
Register a user processor --> This method is used to add a rule to the pyramid --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerUserProcessor]] ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { [[registerUserProcessor]] ( ( MultiInterestUserProcessor ) processor , [[userProcessors]] ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = [[userProcessors]] . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String [[errMsg]] = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( [[errMsg]] ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void [[volcanoes]] ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[sudanese]] ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { [[volcanoes]] ( ( MultiInterestUserProcessor ) processor , [[sudanese]] ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = [[sudanese]] . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String [[mischief]] = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( [[mischief]] ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .
--------------------------------------------- Result 424 ---------------------------------------------
Monitor a map of connections --> Perform a monitoring operation on the map . --> Socre: 1.0

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection [[freshSelectConnect]] = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; [[freshSelectConnect]] . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , [[freshSelectConnect]] ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection [[il]] = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; [[il]] . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , [[il]] ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off
[Succeeded / Failed / Skipped / Total] 399 / 22 / 4 / 425:  42%|████▎     | 425/1000 [3:30:06<4:44:15, 29.66s/it][Succeeded / Failed / Skipped / Total] 399 / 22 / 4 / 425:  43%|████▎     | 426/1000 [3:30:11<4:43:13, 29.61s/it][Succeeded / Failed / Skipped / Total] 400 / 22 / 4 / 426:  43%|████▎     | 426/1000 [3:30:11<4:43:13, 29.61s/it][Succeeded / Failed / Skipped / Total] 400 / 22 / 4 / 426:  43%|████▎     | 427/1000 [3:30:25<4:42:22, 29.57s/it][Succeeded / Failed / Skipped / Total] 401 / 22 / 4 / 427:  43%|████▎     | 427/1000 [3:30:25<4:42:22, 29.57s/it][Succeeded / Failed / Skipped / Total] 401 / 22 / 4 / 427:  43%|████▎     | 428/1000 [3:30:38<4:41:30, 29.53s/it][Succeeded / Failed / Skipped / Total] 402 / 22 / 4 / 428:  43%|████▎     | 428/1000 [3:30:38<4:41:30, 29.53s/it][Succeeded / Failed / Skipped / Total] 402 / 22 / 4 / 428:  43%|████▎     | 429/1000 [3:31:03<4:40:55, 29.52s/it][Succeeded / Failed / Skipped / Total] 403 / 22 / 4 / 429:  43%|████▎     | 429/1000 [3:31:03<4:40:55, 29.52s/it][Succeeded / Failed / Skipped / Total] 403 / 22 / 4 / 429:  43%|████▎     | 430/1000 [3:31:36<4:40:30, 29.53s/it]--------------------------------------------- Result 425 ---------------------------------------------
Adds a reconnect task . --> Adds a new ReconnectTask to the list . --> Socre: 1.0

[[[[Adv]]]]: public void addReconnectTask ( Url url ) { ReconnectTask [[task]] = new ReconnectTask ( ) ; [[task]] . url = url ; tasks . add ( [[task]] ) ; }
[[[[Nl]]]]: add reconnect task

[[[[Adv]]]]: public void addReconnectTask ( Url url ) { ReconnectTask [[hanna]] = new ReconnectTask ( ) ; [[hanna]] . url = url ; tasks . add ( [[hanna]] ) ; }
[[[[Nl]]]]: add reconnect task
--------------------------------------------- Result 426 ---------------------------------------------
Filter connections --> This method returns a map of all the connection ids --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[filter]] ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : connections ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[séances]] ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : connections ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor
--------------------------------------------- Result 427 ---------------------------------------------
Gets a boolean property . --> Gets a boolean from aquinas . --> Socre: 1.0

[[[[Adv]]]]: public static boolean getBool ( String [[key]] , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( [[key]] , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property

[[[[Adv]]]]: public static boolean getBool ( String [[aquinas]] , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( [[aquinas]] , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property
--------------------------------------------- Result 428 ---------------------------------------------
Deserialize request command . --> Handles responses . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[deserializeRequestCommand]] ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = "[[True]]" == "[[True]]" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "[[False]]" != "[[False]]" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = "[[False]]" != "[[False]]" ; } return result ; }
[[[[Nl]]]]: deserialize request command

[[[[Adv]]]]: private boolean [[absorbent]] ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = "[[Watchtower]]" == "[[Watchtower]]" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "[[Imperfect]]" != "[[Imperfect]]" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = "[[Imperfect]]" != "[[Imperfect]]" ; } return result ; }
[[[[Nl]]]]: deserialize request command
--------------------------------------------- Result 429 ---------------------------------------------
Close new connection --> If we don t have a reconnect --> Socre: 1.0

[[[[Adv]]]]: private void closeFreshSelectConnections ( Connection [[lastSelectConnect]] , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != [[lastSelectConnect]] ) { if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[lastSelectConnect]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[lastSelectConnect]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[lastSelectConnect]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections

[[[[Adv]]]]: private void closeFreshSelectConnections ( Connection [[boogey]] , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != [[boogey]] ) { if ( [[boogey]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[boogey]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[boogey]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[boogey]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[boogey]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections
--------------------------------------------- Result 430 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 404 / 22 / 4 / 430:  43%|████▎     | 430/1000 [3:31:36<4:40:30, 29.53s/it][Succeeded / Failed / Skipped / Total] 404 / 22 / 4 / 430:  43%|████▎     | 431/1000 [3:31:37<4:39:22, 29.46s/it][Succeeded / Failed / Skipped / Total] 404 / 22 / 5 / 431:  43%|████▎     | 431/1000 [3:31:37<4:39:22, 29.46s/it][Succeeded / Failed / Skipped / Total] 404 / 22 / 5 / 431:  43%|████▎     | 432/1000 [3:31:42<4:38:21, 29.40s/it][Succeeded / Failed / Skipped / Total] 405 / 22 / 5 / 432:  43%|████▎     | 432/1000 [3:31:42<4:38:21, 29.40s/it][Succeeded / Failed / Skipped / Total] 405 / 22 / 5 / 432:  43%|████▎     | 433/1000 [3:31:48<4:37:21, 29.35s/it][Succeeded / Failed / Skipped / Total] 406 / 22 / 5 / 433:  43%|████▎     | 433/1000 [3:31:48<4:37:21, 29.35s/it][Succeeded / Failed / Skipped / Total] 406 / 22 / 5 / 433:  43%|████▎     | 434/1000 [3:31:54<4:36:21, 29.30s/it][Succeeded / Failed / Skipped / Total] 407 / 22 / 5 / 434:  43%|████▎     | 434/1000 [3:31:54<4:36:21, 29.30s/it][Succeeded / Failed / Skipped / Total] 407 / 22 / 5 / 434:  44%|████▎     | 435/1000 [3:32:02<4:35:25, 29.25s/it][Succeeded / Failed / Skipped / Total] 408 / 22 / 5 / 435:  44%|████▎     | 435/1000 [3:32:02<4:35:25, 29.25s/it][Succeeded / Failed / Skipped / Total] 408 / 22 / 5 / 435:  44%|████▎     | 436/1000 [3:32:24<4:34:46, 29.23s/it][Succeeded / Failed / Skipped / Total] 409 / 22 / 5 / 436:  44%|████▎     | 436/1000 [3:32:24<4:34:46, 29.23s/it][Succeeded / Failed / Skipped / Total] 409 / 22 / 5 / 436:  44%|████▎     | 437/1000 [3:32:57<4:34:21, 29.24s/it][Succeeded / Failed / Skipped / Total] 410 / 22 / 5 / 437:  44%|████▎     | 437/1000 [3:32:57<4:34:21, 29.24s/it][Succeeded / Failed / Skipped / Total] 410 / 22 / 5 / 437:  44%|████▍     | 438/1000 [3:33:48<4:34:20, 29.29s/it]Is request timeout . --> Returns true if requestTimeout was received . --> Socre: 1.0

[[[[Adv]]]]: public boolean isRequestTimeout ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout

[[[[Adv]]]]: public boolean isRequestTimeout ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "[[Belittle]]" == "[[Belittle]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout
--------------------------------------------- Result 431 ---------------------------------------------
Returns the value of a key . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . context . get ( key ) != null ? ( T ) this . context . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found
--------------------------------------------- Result 432 ---------------------------------------------
To byte . --> Produces a dirty version of the given BitSet . --> Socre: 1.0

[[[[Adv]]]]: public static byte toByte ( BitSet [[bs]] ) { int [[value]] = 0 ; for ( int i = 0 ; i < [[bs]] . length ( ) ; ++ i ) { if ( [[bs]] . get ( i ) ) { [[value]] += 1 << i ; } } if ( [[bs]] . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + [[value]] + " generated according to bit set " + [[bs]] + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) [[value]] ; }
[[[[Nl]]]]: from bit set to byte

[[[[Adv]]]]: public static byte toByte ( BitSet [[virginie]] ) { int [[proudest]] = 0 ; for ( int i = 0 ; i < [[virginie]] . length ( ) ; ++ i ) { if ( [[virginie]] . get ( i ) ) { [[proudest]] += 1 << i ; } } if ( [[virginie]] . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + [[proudest]] + " generated according to bit set " + [[virginie]] + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) [[proudest]] ; }
[[[[Nl]]]]: from bit set to byte
--------------------------------------------- Result 433 ---------------------------------------------
Gets a user processor . --> Returns UserProcessor --> Socre: 1.0

[[[[Adv]]]]: public UserProcessor < ? > getUserProcessor ( String className ) { return StringUtils . isBlank ( className ) ? null : this . [[userProcessors]] . get ( className ) ; }
[[[[Nl]]]]: Get user processor for class name .

[[[[Adv]]]]: public UserProcessor < ? > getUserProcessor ( String className ) { return StringUtils . isBlank ( className ) ? null : this . [[franciscan]] . get ( className ) ; }
[[[[Nl]]]]: Get user processor for class name .
--------------------------------------------- Result 434 ---------------------------------------------
Returns the value for the given key . --> Gets cardinale . --> Socre: 1.0

[[[[Adv]]]]: public String [[getProperty]] ( String key ) { if ( properties == null ) { return null ; } return properties . getProperty ( key ) ; }
[[[[Nl]]]]: Get property value according to property key

[[[[Adv]]]]: public String [[cardinale]] ( String key ) { if ( properties == null ) { return null ; } return properties . getProperty ( key ) ; }
[[[[Nl]]]]: Get property value according to property key
--------------------------------------------- Result 435 ---------------------------------------------
Attempt to resolve a response object from a remote address . --> Implementation of diabolic method --> Socre: 1.0

[[[[Adv]]]]: public static Object [[resolveResponseObject]] ( ResponseCommand responseCommand , String addr ) throws RemotingException { preProcess ( responseCommand , addr ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; logger . warn ( msg ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( msg , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .

[[[[Adv]]]]: public static Object [[diabolic]] ( ResponseCommand responseCommand , String addr ) throws RemotingException { preProcess ( responseCommand , addr ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; logger . warn ( msg ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( msg , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .
--------------------------------------------- Result 436 ---------------------------------------------
Deserialize response from response command . --> An example of the responseCommand --> Socre: 1.0

[[[[Adv]]]]: private static Object [[toResponseObject]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) responseCommand ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .

[[[[Adv]]]]: private static Object [[example]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) responseCommand ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .
--------------------------------------------- Result 437 ---------------------------------------------
Log an info log . --> Logs an informational message . --> Socre: 1.0

[[[[Adv]]]]: private void infoLog ( String [[format]] , String [[addr]] ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( [[addr]] ) ) { logger . info ( [[format]] , [[addr]] ) ; } else { logger . info ( [[format]] , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log

[[[[Adv]]]]: private void infoLog ( String [[accounts]] , String [[summons]] ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( [[summons]] ) ) { logger . info ( [[accounts]] , [[summons]] ) ; } else { logger . info ( [[accounts]] , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log
--------------------------------------------- Result 438 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 411 / 22 / 5 / 438:  44%|████▍     | 438/1000 [3:33:48<4:34:20, 29.29s/it][Succeeded / Failed / Skipped / Total] 411 / 22 / 5 / 438:  44%|████▍     | 439/1000 [3:34:09<4:33:40, 29.27s/it][Succeeded / Failed / Skipped / Total] 412 / 22 / 5 / 439:  44%|████▍     | 439/1000 [3:34:09<4:33:40, 29.27s/it][Succeeded / Failed / Skipped / Total] 412 / 22 / 5 / 439:  44%|████▍     | 440/1000 [3:34:26<4:32:56, 29.24s/it][Succeeded / Failed / Skipped / Total] 412 / 23 / 5 / 440:  44%|████▍     | 440/1000 [3:34:26<4:32:56, 29.24s/it][Succeeded / Failed / Skipped / Total] 412 / 23 / 5 / 440:  44%|████▍     | 441/1000 [3:34:48<4:32:17, 29.23s/it][Succeeded / Failed / Skipped / Total] 413 / 23 / 5 / 441:  44%|████▍     | 441/1000 [3:34:48<4:32:17, 29.23s/it][Succeeded / Failed / Skipped / Total] 413 / 23 / 5 / 441:  44%|████▍     | 442/1000 [3:35:23<4:31:55, 29.24s/it][Succeeded / Failed / Skipped / Total] 414 / 23 / 5 / 442:  44%|████▍     | 442/1000 [3:35:23<4:31:55, 29.24s/it][Succeeded / Failed / Skipped / Total] 414 / 23 / 5 / 442:  44%|████▍     | 443/1000 [3:36:00<4:31:35, 29.26s/it][Succeeded / Failed / Skipped / Total] 415 / 23 / 5 / 443:  44%|████▍     | 443/1000 [3:36:00<4:31:35, 29.26s/it][Succeeded / Failed / Skipped / Total] 415 / 23 / 5 / 443:  44%|████▍     | 444/1000 [3:36:22<4:30:57, 29.24s/it]Convert a Throwable to RpcServerException . --> For RpcServerException --> Socre: 1.0

[[[[Adv]]]]: private RpcServerException [[createServerException]] ( Throwable t , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .

[[[[Adv]]]]: private RpcServerException [[gayness]] ( Throwable t , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .
--------------------------------------------- Result 439 ---------------------------------------------
Creates a new event loop group . --> Creates a new EventLoopGroup --> Socre: 1.0

[[[[Adv]]]]: public static EventLoopGroup newEventLoopGroup ( int [[nThreads]] , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( [[nThreads]] , threadFactory ) : new NioEventLoopGroup ( [[nThreads]] , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .

[[[[Adv]]]]: public static EventLoopGroup newEventLoopGroup ( int [[abidjan]] , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( [[abidjan]] , threadFactory ) : new NioEventLoopGroup ( [[abidjan]] , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .
--------------------------------------------- Result 440 ---------------------------------------------
Closes the remote connection . --> [[[FAILED]]]

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . [[this]] . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . [[this]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . [[traditions]] . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . [[traditions]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .
--------------------------------------------- Result 441 ---------------------------------------------
Print connection trace information . --> For debugging . --> Socre: 1.0

[[[[Adv]]]]: public static void printConnectionTraceLog ( Logger logger , String [[traceId]] , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( [[traceId]] ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log

[[[[Adv]]]]: public static void printConnectionTraceLog ( Logger logger , String [[somthing]] , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( [[somthing]] ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log
--------------------------------------------- Result 442 ---------------------------------------------
Print error message . --> An annotation . --> Socre: 1.0

[[[[Adv]]]]: private static String [[detailErrMsg]] ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand [[resp]] = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( [[resp]] . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , [[resp]] . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command

[[[[Adv]]]]: private static String [[anna]] ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand [[backache]] = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( [[backache]] . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , [[backache]] . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command
--------------------------------------------- Result 443 ---------------------------------------------
Parse the remote hostname of the channel . --> Return hahahahshahoh --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteHostName]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .

[[[[Adv]]]]: public static String [[hahahaha]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .
--------------------------------------------- Result 444 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 416 / 23 / 5 / 444:  44%|████▍     | 444/1000 [3:36:22<4:30:57, 29.24s/it][Succeeded / Failed / Skipped / Total] 416 / 23 / 5 / 444:  44%|████▍     | 445/1000 [3:37:25<4:31:10, 29.32s/it][Succeeded / Failed / Skipped / Total] 417 / 23 / 5 / 445:  44%|████▍     | 445/1000 [3:37:25<4:31:10, 29.32s/it][Succeeded / Failed / Skipped / Total] 417 / 23 / 5 / 445:  45%|████▍     | 446/1000 [3:37:54<4:30:41, 29.32s/it][Succeeded / Failed / Skipped / Total] 418 / 23 / 5 / 446:  45%|████▍     | 446/1000 [3:37:54<4:30:41, 29.32s/it][Succeeded / Failed / Skipped / Total] 418 / 23 / 5 / 446:  45%|████▍     | 447/1000 [3:38:03<4:29:46, 29.27s/it][Succeeded / Failed / Skipped / Total] 419 / 23 / 5 / 447:  45%|████▍     | 447/1000 [3:38:03<4:29:46, 29.27s/it][Succeeded / Failed / Skipped / Total] 419 / 23 / 5 / 447:  45%|████▍     | 448/1000 [3:39:26<4:30:23, 29.39s/it][Succeeded / Failed / Skipped / Total] 419 / 24 / 5 / 448:  45%|████▍     | 448/1000 [3:39:26<4:30:23, 29.39s/it][Succeeded / Failed / Skipped / Total] 419 / 24 / 5 / 448:  45%|████▍     | 449/1000 [3:39:40<4:29:34, 29.35s/it][Succeeded / Failed / Skipped / Total] 420 / 24 / 5 / 449:  45%|████▍     | 449/1000 [3:39:40<4:29:34, 29.35s/it][Succeeded / Failed / Skipped / Total] 420 / 24 / 5 / 449:  45%|████▌     | 450/1000 [3:40:48<4:29:53, 29.44s/it][Succeeded / Failed / Skipped / Total] 421 / 24 / 5 / 450:  45%|████▌     | 450/1000 [3:40:48<4:29:53, 29.44s/it][Succeeded / Failed / Skipped / Total] 421 / 24 / 5 / 450:  45%|████▌     | 451/1000 [3:40:53<4:28:53, 29.39s/it][Succeeded / Failed / Skipped / Total] 422 / 24 / 5 / 451:  45%|████▌     | 451/1000 [3:40:53<4:28:53, 29.39s/it][Succeeded / Failed / Skipped / Total] 422 / 24 / 5 / 451:  45%|████▌     | 452/1000 [3:41:01<4:27:57, 29.34s/it][Succeeded / Failed / Skipped / Total] 423 / 24 / 5 / 452:  45%|████▌     | 452/1000 [3:41:01<4:27:57, 29.34s/it][Succeeded / Failed / Skipped / Total] 423 / 24 / 5 / 452:  45%|████▌     | 453/1000 [3:41:39<4:27:39, 29.36s/it]Parse the remote address of a channel . --> Methode permete --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteAddress]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress remote = channel . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .

[[[[Adv]]]]: public static String [[será]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress remote = channel . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .
--------------------------------------------- Result 445 ---------------------------------------------
Get a random connection --> Returns a random query --> Socre: 1.0

[[[[Adv]]]]: private Connection randomGet ( List < Connection > [[conns]] ) { if ( null == [[conns]] || [[conns]] . isEmpty ( ) ) { return null ; } int size = [[conns]] . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = [[conns]] . get ( this . [[random]] . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly

[[[[Adv]]]]: private Connection randomGet ( List < Connection > [[vegetables]] ) { if ( null == [[vegetables]] || [[vegetables]] . isEmpty ( ) ) { return null ; } int size = [[vegetables]] . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = [[vegetables]] . get ( this . [[skip]] . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly
--------------------------------------------- Result 446 ---------------------------------------------
Parses the local address of a channel . --> night --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalAddress]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress [[local]] = channel . localAddress ( ) ; return doParse ( [[local]] != null ? [[local]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .

[[[[Adv]]]]: public static String [[nightrider]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress [[bertha]] = channel . localAddress ( ) ; return doParse ( [[bertha]] != null ? [[bertha]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .
--------------------------------------------- Result 447 ---------------------------------------------
Retrieves the remote address of a channel . --> Archive arching string --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .

[[[[Adv]]]]: public static String [[arching]] ( final Channel [[ð]] ) { if ( null == [[ð]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[ð]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .
--------------------------------------------- Result 448 ---------------------------------------------
Convert request to remoting command . --> [[[FAILED]]]

[[[[Adv]]]]: protected RemotingCommand toRemotingCommand ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .

[[[[Adv]]]]: protected RemotingCommand toRemotingCommand ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .
--------------------------------------------- Result 449 ---------------------------------------------
Gets the remote port . --> returns error code --> Socre: 1.0

[[[[Adv]]]]: public static int [[parseRemotePort]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .

[[[[Adv]]]]: public static int [[erode]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress [[buli]] = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( [[buli]] != null ) { return [[buli]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .
--------------------------------------------- Result 450 ---------------------------------------------
Add a connection --> documentation inherited from pool --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Connection connection ) { markAccess ( ) ; if ( null == connection ) { return ; } boolean [[res]] = this . conns . addIfAbsent ( connection ) ; if ( [[res]] ) { connection . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection

[[[[Adv]]]]: public void [[canvassing]] ( Connection connection ) { markAccess ( ) ; if ( null == connection ) { return ; } boolean [[buckskin]] = this . conns . addIfAbsent ( connection ) ; if ( [[buckskin]] ) { connection . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection
--------------------------------------------- Result 451 ---------------------------------------------
Returns the local port of the given channel . --> returns booleans --> Socre: 1.0

[[[[Adv]]]]: public static int [[parseLocalPort]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress [[local]] = ( InetSocketAddress ) channel . localAddress ( ) ; if ( [[local]] != null ) { return [[local]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .

[[[[Adv]]]]: public static int [[bore]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress [[séances]] = ( InetSocketAddress ) channel . localAddress ( ) ; if ( [[séances]] != null ) { return [[séances]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .
--------------------------------------------- Result 452 ---------------------------------------------
Returns a connection . --> Gets the leader . --> Socre: 1.0

[[[[Adv]]]]: public Connection get ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > [[snapshot]] = new ArrayList < Connection > ( this . conns ) ; if ( [[snapshot]] . size ( ) > 0 ) { return this . strategy . select ( [[snapshot]] ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection

[[[[Adv]]]]: public Connection get ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > [[follower]] = new ArrayList < Connection > ( this . conns ) ; if ( [[follower]] . size ( ) > 0 ) { return this . strategy . select ( [[follower]] ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection
--------------------------------------------- Result 453 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 424 / 24 / 5 / 453:  45%|████▌     | 453/1000 [3:41:39<4:27:39, 29.36s/it][Succeeded / Failed / Skipped / Total] 424 / 24 / 5 / 453:  45%|████▌     | 454/1000 [3:42:03<4:27:04, 29.35s/it][Succeeded / Failed / Skipped / Total] 425 / 24 / 5 / 454:  45%|████▌     | 454/1000 [3:42:03<4:27:04, 29.35s/it][Succeeded / Failed / Skipped / Total] 425 / 24 / 5 / 454:  46%|████▌     | 455/1000 [3:42:04<4:25:59, 29.28s/it][Succeeded / Failed / Skipped / Total] 425 / 24 / 6 / 455:  46%|████▌     | 455/1000 [3:42:04<4:25:59, 29.28s/it][Succeeded / Failed / Skipped / Total] 425 / 24 / 6 / 455:  46%|████▌     | 456/1000 [3:42:22<4:25:17, 29.26s/it][Succeeded / Failed / Skipped / Total] 426 / 24 / 6 / 456:  46%|████▌     | 456/1000 [3:42:22<4:25:17, 29.26s/it][Succeeded / Failed / Skipped / Total] 426 / 24 / 6 / 456:  46%|████▌     | 457/1000 [3:42:46<4:24:42, 29.25s/it][Succeeded / Failed / Skipped / Total] 427 / 24 / 6 / 457:  46%|████▌     | 457/1000 [3:42:46<4:24:42, 29.25s/it][Succeeded / Failed / Skipped / Total] 427 / 24 / 6 / 457:  46%|████▌     | 458/1000 [3:43:07<4:24:02, 29.23s/it][Succeeded / Failed / Skipped / Total] 428 / 24 / 6 / 458:  46%|████▌     | 458/1000 [3:43:07<4:24:02, 29.23s/it][Succeeded / Failed / Skipped / Total] 428 / 24 / 6 / 458:  46%|████▌     | 459/1000 [3:43:07<4:22:58, 29.17s/it][Succeeded / Failed / Skipped / Total] 428 / 24 / 7 / 459:  46%|████▌     | 459/1000 [3:43:07<4:22:58, 29.17s/it][Succeeded / Failed / Skipped / Total] 428 / 24 / 7 / 459:  46%|████▌     | 460/1000 [3:43:40<4:22:34, 29.17s/it][Succeeded / Failed / Skipped / Total] 429 / 24 / 7 / 460:  46%|████▌     | 460/1000 [3:43:40<4:22:34, 29.17s/it][Succeeded / Failed / Skipped / Total] 429 / 24 / 7 / 460:  46%|████▌     | 461/1000 [3:43:59<4:21:53, 29.15s/it]Extracts the exception from the response . --> get asceticism --> Socre: 1.0

[[[[Adv]]]]: private static Throwable [[toThrowable]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; resp . deserialize ( ) ; Object [[ex]] = resp . getResponseObject ( ) ; if ( [[ex]] != null && [[ex]] instanceof Throwable ) { return ( Throwable ) [[ex]] ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .

[[[[Adv]]]]: private static Throwable [[asceticism]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; resp . deserialize ( ) ; Object [[loneliest]] = resp . getResponseObject ( ) ; if ( [[loneliest]] != null && [[loneliest]] instanceof Throwable ) { return ( Throwable ) [[loneliest]] ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .
--------------------------------------------- Result 454 ---------------------------------------------
Get the custom serializer for a class --> getCustomSerializer --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer getCustomSerializer ( String [[className]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[className]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .

[[[[Adv]]]]: public static CustomSerializer getCustomSerializer ( String [[whatnot]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[whatnot]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .
--------------------------------------------- Result 455 ---------------------------------------------
Starts the connection monitor . --> [[[SKIPPED]]]

[[[[Adv]]]]: public void start ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task
--------------------------------------------- Result 456 ---------------------------------------------
Returns the local IP address of the channel . --> a random address --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .

[[[[Adv]]]]: public static String [[bernardi]] ( final Channel [[slytherin]] ) { if ( null == [[slytherin]] ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) [[slytherin]] . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .
--------------------------------------------- Result 457 ---------------------------------------------
Remove and close connection --> Remove an ague . --> Socre: 1.0

[[[[Adv]]]]: public void removeAndTryClose ( Connection [[connection]] ) { if ( null == [[connection]] ) { return ; } boolean [[res]] = this . conns . remove ( [[connection]] ) ; if ( [[res]] ) { [[connection]] . decreaseRef ( ) ; } if ( [[connection]] . noRef ( ) ) { [[connection]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection

[[[[Adv]]]]: public void removeAndTryClose ( Connection [[ague]] ) { if ( null == [[ague]] ) { return ; } boolean [[nigh]] = this . conns . remove ( [[ague]] ) ; if ( [[nigh]] ) { [[ague]] . decreaseRef ( ) ; } if ( [[ague]] . noRef ( ) ) { [[ague]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection
--------------------------------------------- Result 458 ---------------------------------------------
Returns the frame for a given opcode . --> Creates and returns the framed data . --> Socre: 1.0

[[[[Adv]]]]: public static FramedataImpl1 [[get]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode

[[[[Adv]]]]: public static FramedataImpl1 [[accomplice]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode
--------------------------------------------- Result 459 ---------------------------------------------
write messages to socket --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed
--------------------------------------------- Result 460 ---------------------------------------------
Registers a custom serializer for the given class . --> zowie Method --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( String className , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( className , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .

[[[[Adv]]]]: public static void [[zowie]] ( String className , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( className , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .
--------------------------------------------- Result 461 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 430 / 24 / 7 / 461:  46%|████▌     | 461/1000 [3:43:59<4:21:53, 29.15s/it][Succeeded / Failed / Skipped / Total] 430 / 24 / 7 / 461:  46%|████▌     | 462/1000 [3:43:59<4:20:50, 29.09s/it][Succeeded / Failed / Skipped / Total] 431 / 24 / 7 / 462:  46%|████▌     | 462/1000 [3:43:59<4:20:50, 29.09s/it][Succeeded / Failed / Skipped / Total] 431 / 24 / 7 / 462:  46%|████▋     | 463/1000 [3:44:44<4:20:40, 29.13s/it][Succeeded / Failed / Skipped / Total] 432 / 24 / 7 / 463:  46%|████▋     | 463/1000 [3:44:44<4:20:40, 29.13s/it][Succeeded / Failed / Skipped / Total] 432 / 24 / 7 / 463:  46%|████▋     | 464/1000 [3:45:01<4:19:56, 29.10s/it][Succeeded / Failed / Skipped / Total] 433 / 24 / 7 / 464:  46%|████▋     | 464/1000 [3:45:01<4:19:56, 29.10s/it][Succeeded / Failed / Skipped / Total] 433 / 24 / 7 / 464:  46%|████▋     | 465/1000 [3:45:13<4:19:08, 29.06s/it][Succeeded / Failed / Skipped / Total] 434 / 24 / 7 / 465:  46%|████▋     | 465/1000 [3:45:13<4:19:08, 29.06s/it][Succeeded / Failed / Skipped / Total] 434 / 24 / 7 / 465:  47%|████▋     | 466/1000 [3:45:50<4:18:47, 29.08s/it][Succeeded / Failed / Skipped / Total] 435 / 24 / 7 / 466:  47%|████▋     | 466/1000 [3:45:50<4:18:47, 29.08s/it][Succeeded / Failed / Skipped / Total] 435 / 24 / 7 / 466:  47%|████▋     | 467/1000 [3:47:53<4:20:06, 29.28s/it][Succeeded / Failed / Skipped / Total] 436 / 24 / 7 / 467:  47%|████▋     | 467/1000 [3:47:53<4:20:06, 29.28s/it][Succeeded / Failed / Skipped / Total] 436 / 24 / 7 / 467:  47%|████▋     | 468/1000 [3:48:11<4:19:24, 29.26s/it][Succeeded / Failed / Skipped / Total] 437 / 24 / 7 / 468:  47%|████▋     | 468/1000 [3:48:11<4:19:24, 29.26s/it][Succeeded / Failed / Skipped / Total] 437 / 24 / 7 / 468:  47%|████▋     | 469/1000 [3:48:31<4:18:43, 29.23s/it][Succeeded / Failed / Skipped / Total] 438 / 24 / 7 / 469:  47%|████▋     | 469/1000 [3:48:31<4:18:43, 29.23s/it][Succeeded / Failed / Skipped / Total] 438 / 24 / 7 / 469:  47%|████▋     | 470/1000 [3:49:04<4:18:18, 29.24s/it]Parse an address to a host --> Convert a SocketAddress to a hostname --> Socre: 1.0

[[[[Adv]]]]: public static String parseSocketAddressToHostIp ( SocketAddress [[socketAddress]] ) { final InetSocketAddress [[addrs]] = ( InetSocketAddress ) [[socketAddress]] ; if ( [[addrs]] != null ) { InetAddress addr = [[addrs]] . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .

[[[[Adv]]]]: public static String parseSocketAddressToHostIp ( SocketAddress [[booyah]] ) { final InetSocketAddress [[floy]] = ( InetSocketAddress ) [[booyah]] ; if ( [[floy]] != null ) { InetAddress addr = [[floy]] . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .
--------------------------------------------- Result 462 ---------------------------------------------
Validate UTF8 . --> Validates UTF - 8 encoding . --> Socre: 1.0

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer payload , int [[mark]] ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( [[mark]] ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer payload , int [[shrew]] ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( [[shrew]] ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8
--------------------------------------------- Result 463 ---------------------------------------------
Get the custom serializer for a command code . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( CommandCode code ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( code ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .

[[[[Adv]]]]: public static CustomSerializer [[ð]] ( CommandCode code ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( code ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .
--------------------------------------------- Result 464 ---------------------------------------------
Checks if the remote address is connected . --> Is reactivated . --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isConnected]] ( String remoteAddr ) { Url url = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected

[[[[Adv]]]]: public boolean [[reactivated]] ( String remoteAddr ) { Url url = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected
--------------------------------------------- Result 465 ---------------------------------------------
init write buffer water mark --> Adds the ascendant of the pipeline . --> Socre: 1.0

[[[[Adv]]]]: private void [[initWriteBufferWaterMark]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . [[bootstrap]] . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark

[[[[Adv]]]]: private void [[ascendant]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . [[atter]] . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark
--------------------------------------------- Result 466 ---------------------------------------------
Set the status code . --> Sets arching --> Socre: 1.0

[[[[Adv]]]]: public void setCode ( int code ) { this . [[code]] = code ;
[[[[Nl]]]]: Set the close code for this close frame

[[[[Adv]]]]: public void setCode ( int code ) { this . [[arching]] = code ;
[[[[Nl]]]]: Set the close code for this close frame
--------------------------------------------- Result 467 ---------------------------------------------
translate single frame size --> Translate single frame . --> Socre: 1.0

[[[[Adv]]]]: private void translateSingleFrameCheckPacketSize ( int [[maxpacketsize]] , int realpacketsize ) throws IncompleteException { if ( [[maxpacketsize]] < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size

[[[[Adv]]]]: private void translateSingleFrameCheckPacketSize ( int [[inordinate]] , int realpacketsize ) throws IncompleteException { if ( [[inordinate]] < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size
--------------------------------------------- Result 468 ---------------------------------------------
Processes a frame binary . --> Handle gwendoline event . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameBinary]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame

[[[[Adv]]]]: private void [[gwendoline]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame
--------------------------------------------- Result 469 ---------------------------------------------
Log runtime exception . --> Called when an error occurs . --> Socre: 1.0

[[[[Adv]]]]: private void [[logRuntimeException]] ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl

[[[[Adv]]]]: private void [[aco]] ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl
--------------------------------------------- Result 470 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 439 / 24 / 7 / 470:  47%|████▋     | 470/1000 [3:49:04<4:18:18, 29.24s/it][Succeeded / Failed / Skipped / Total] 439 / 24 / 7 / 470:  47%|████▋     | 471/1000 [3:49:14<4:17:28, 29.20s/it][Succeeded / Failed / Skipped / Total] 440 / 24 / 7 / 471:  47%|████▋     | 471/1000 [3:49:14<4:17:28, 29.20s/it][Succeeded / Failed / Skipped / Total] 440 / 24 / 7 / 471:  47%|████▋     | 472/1000 [3:49:36<4:16:51, 29.19s/it][Succeeded / Failed / Skipped / Total] 441 / 24 / 7 / 472:  47%|████▋     | 472/1000 [3:49:36<4:16:51, 29.19s/it][Succeeded / Failed / Skipped / Total] 441 / 24 / 7 / 472:  47%|████▋     | 473/1000 [3:49:41<4:15:55, 29.14s/it][Succeeded / Failed / Skipped / Total] 442 / 24 / 7 / 473:  47%|████▋     | 473/1000 [3:49:41<4:15:55, 29.14s/it][Succeeded / Failed / Skipped / Total] 442 / 24 / 7 / 473:  47%|████▋     | 474/1000 [3:49:56<4:15:09, 29.11s/it][Succeeded / Failed / Skipped / Total] 443 / 24 / 7 / 474:  47%|████▋     | 474/1000 [3:49:56<4:15:09, 29.11s/it][Succeeded / Failed / Skipped / Total] 443 / 24 / 7 / 474:  48%|████▊     | 475/1000 [3:50:04<4:14:17, 29.06s/it][Succeeded / Failed / Skipped / Total] 444 / 24 / 7 / 475:  48%|████▊     | 475/1000 [3:50:04<4:14:17, 29.06s/it][Succeeded / Failed / Skipped / Total] 444 / 24 / 7 / 475:  48%|████▊     | 476/1000 [3:50:29<4:13:44, 29.05s/it][Succeeded / Failed / Skipped / Total] 445 / 24 / 7 / 476:  48%|████▊     | 476/1000 [3:50:29<4:13:44, 29.05s/it][Succeeded / Failed / Skipped / Total] 445 / 24 / 7 / 476:  48%|████▊     | 477/1000 [3:50:47<4:13:02, 29.03s/it]Translate single frame length limit . --> This method is used to catch all registrations . --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckLengthLimit]] ( long [[length]] ) throws LimitExceededException { if ( [[length]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[length]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[length]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[length]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit

[[[[Adv]]]]: private void [[alona]] ( long [[alcoholics]] ) throws LimitExceededException { if ( [[alcoholics]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[alcoholics]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[alcoholics]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[alcoholics]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit
--------------------------------------------- Result 471 ---------------------------------------------
Update the payload . --> Method updatePayload . --> Socre: 1.0

[[[[Adv]]]]: private void updatePayload ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer [[buf]] = ByteBuffer . allocate ( 4 ) ; [[buf]] . putInt ( code ) ; [[buf]] . position ( 2 ) ; ByteBuffer [[pay]] = ByteBuffer . allocate ( 2 + by . length ) ; [[pay]] . put ( [[buf]] ) ; [[pay]] . put ( by ) ; [[pay]] . rewind ( ) ; super . setPayload ( [[pay]] ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason

[[[[Adv]]]]: private void updatePayload ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer [[inuit]] = ByteBuffer . allocate ( 4 ) ; [[inuit]] . putInt ( code ) ; [[inuit]] . position ( 2 ) ; ByteBuffer [[ottoman]] = ByteBuffer . allocate ( 2 + by . length ) ; [[ottoman]] . put ( [[inuit]] ) ; [[ottoman]] . put ( by ) ; [[ottoman]] . rewind ( ) ; super . setPayload ( [[ottoman]] ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason
--------------------------------------------- Result 472 ---------------------------------------------
Process frame text . --> called from WebSocket --> Socre: 1.0

[[[[Adv]]]]: private void processFrameText ( WebSocketImpl [[webSocketImpl]] , Framedata frame ) throws InvalidDataException { try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame

[[[[Adv]]]]: private void processFrameText ( WebSocketImpl [[trespasser]] , Framedata frame ) throws InvalidDataException { try { [[trespasser]] . getWebSocketListener ( ) . onWebsocketMessage ( [[trespasser]] , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[trespasser]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame
--------------------------------------------- Result 473 ---------------------------------------------
Registers a custom serializer for a command code . --> Kunai --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( CommandCode code , CustomSerializer [[serializer]] ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , [[serializer]] ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .

[[[[Adv]]]]: public static void [[kunai]] ( CommandCode code , CustomSerializer [[amar]] ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , [[amar]] ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .
--------------------------------------------- Result 474 ---------------------------------------------
Process a close frame . --> assume close state --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameClosing]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame

[[[[Adv]]]]: private void [[agathe]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame
--------------------------------------------- Result 475 ---------------------------------------------
Checks if buffer size is exceeded . --> Call this method to catch all outstanding payloads --> Socre: 1.0

[[[[Adv]]]]: private void [[checkBufferLimit]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size

[[[[Adv]]]]: private void [[antelope]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size
--------------------------------------------- Result 476 ---------------------------------------------
Checks if the handshake contains the given protocol . --> Do nothing . --> Socre: 1.0

[[[[Adv]]]]: private HandshakeState [[containsRequestedProtocol]] ( String [[requestedProtocol]] ) { for ( IProtocol [[knownProtocol]] : knownProtocols ) { if ( [[knownProtocol]] . acceptProvidedProtocol ( [[requestedProtocol]] ) ) { protocol = [[knownProtocol]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft

[[[[Adv]]]]: private HandshakeState [[doggy]] ( String [[arsonists]] ) { for ( IProtocol [[gluttons]] : knownProtocols ) { if ( [[gluttons]] . acceptProvidedProtocol ( [[arsonists]] ) ) { protocol = [[gluttons]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft
--------------------------------------------- Result 477 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 446 / 24 / 7 / 477:  48%|████▊     | 477/1000 [3:50:47<4:13:02, 29.03s/it][Succeeded / Failed / Skipped / Total] 446 / 24 / 7 / 477:  48%|████▊     | 478/1000 [3:51:05<4:12:21, 29.01s/it][Succeeded / Failed / Skipped / Total] 447 / 24 / 7 / 478:  48%|████▊     | 478/1000 [3:51:05<4:12:21, 29.01s/it][Succeeded / Failed / Skipped / Total] 447 / 24 / 7 / 478:  48%|████▊     | 479/1000 [3:51:21<4:11:38, 28.98s/it][Succeeded / Failed / Skipped / Total] 448 / 24 / 7 / 479:  48%|████▊     | 479/1000 [3:51:21<4:11:38, 28.98s/it][Succeeded / Failed / Skipped / Total] 448 / 24 / 7 / 479:  48%|████▊     | 480/1000 [3:51:24<4:10:41, 28.93s/it][Succeeded / Failed / Skipped / Total] 449 / 24 / 7 / 480:  48%|████▊     | 480/1000 [3:51:24<4:10:41, 28.93s/it][Succeeded / Failed / Skipped / Total] 449 / 24 / 7 / 480:  48%|████▊     | 481/1000 [3:51:38<4:09:56, 28.90s/it][Succeeded / Failed / Skipped / Total] 450 / 24 / 7 / 481:  48%|████▊     | 481/1000 [3:51:38<4:09:56, 28.90s/it][Succeeded / Failed / Skipped / Total] 450 / 24 / 7 / 481:  48%|████▊     | 482/1000 [3:51:43<4:09:01, 28.84s/it][Succeeded / Failed / Skipped / Total] 451 / 24 / 7 / 482:  48%|████▊     | 482/1000 [3:51:43<4:09:01, 28.84s/it][Succeeded / Failed / Skipped / Total] 451 / 24 / 7 / 482:  48%|████▊     | 483/1000 [3:53:05<4:09:30, 28.96s/it][Succeeded / Failed / Skipped / Total] 452 / 24 / 7 / 483:  48%|████▊     | 483/1000 [3:53:05<4:09:30, 28.96s/it][Succeeded / Failed / Skipped / Total] 452 / 24 / 7 / 483:  48%|████▊     | 484/1000 [3:53:06<4:08:31, 28.90s/it][Succeeded / Failed / Skipped / Total] 452 / 24 / 8 / 484:  48%|████▊     | 484/1000 [3:53:06<4:08:31, 28.90s/it][Succeeded / Failed / Skipped / Total] 452 / 24 / 8 / 484:  48%|████▊     | 485/1000 [3:53:16<4:07:42, 28.86s/it]Translate handshake http server . --> Initial resolution . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpServer]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server

[[[[Adv]]]]: private static HandshakeBuilder [[absolution]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server
--------------------------------------------- Result 478 ---------------------------------------------
Translate handshake http client . --> cap test . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpClient]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client

[[[[Adv]]]]: private static HandshakeBuilder [[caprice]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client
--------------------------------------------- Result 479 ---------------------------------------------
Generate final key . --> This method is used to calculate the equatorial digest . --> Socre: 1.0

[[[[Adv]]]]: private String [[generateFinalKey]] ( String in ) { String [[seckey]] = in . trim ( ) ; String acc = [[seckey]] + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest [[sh1]] ; try { [[sh1]] = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( [[sh1]] . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string

[[[[Adv]]]]: private String [[abnormal]] ( String in ) { String [[restaurant]] = in . trim ( ) ; String acc = [[restaurant]] + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest [[equatorial]] ; try { [[equatorial]] = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( [[equatorial]] . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string
--------------------------------------------- Result 480 ---------------------------------------------
Decode handshake data . --> Decodes a big - end handshake . --> Socre: 1.0

[[[[Adv]]]]: public void decode ( ByteBuffer [[socketBuffer]] ) { assert ( [[socketBuffer]] . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , [[socketBuffer]] . remaining ( ) , ( [[socketBuffer]] . remaining ( ) > 1000 ? "too big to display" : new String ( [[socketBuffer]] . array ( ) , [[socketBuffer]] . position ( ) , [[socketBuffer]] . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( [[socketBuffer]] ) ; } } else { if ( decodeHandshake ( [[socketBuffer]] ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != [[socketBuffer]] . hasRemaining ( ) || ! [[socketBuffer]] . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer

[[[[Adv]]]]: public void decode ( ByteBuffer [[beagles]] ) { assert ( [[beagles]] . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , [[beagles]] . remaining ( ) , ( [[beagles]] . remaining ( ) > 1000 ? "too big to display" : new String ( [[beagles]] . array ( ) , [[beagles]] . position ( ) , [[beagles]] . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( [[beagles]] ) ; } } else { if ( decodeHandshake ( [[beagles]] ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != [[beagles]] . hasRemaining ( ) || ! [[beagles]] . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer
--------------------------------------------- Result 481 ---------------------------------------------
Closes the connection . --> Apply invalid data exception . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToWrongHandshake]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct

[[[[Adv]]]]: private void [[apply]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct
--------------------------------------------- Result 482 ---------------------------------------------
Closes the connection and closes it . --> Writes an exception . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToInternalServerError]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException

[[[[Adv]]]]: private void [[anorexia]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException
--------------------------------------------- Result 483 ---------------------------------------------
Sends a text to a web socket . --> from interface WebSocketImpl --> Socre: 1.0

[[[[Adv]]]]: @ Override public void send ( String [[text]] ) { if ( [[text]] == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; send ( draft . createFrames ( [[text]] , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .

[[[[Adv]]]]: @ Override public void send ( String [[converged]] ) { if ( [[converged]] == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; send ( draft . createFrames ( [[converged]] , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .
--------------------------------------------- Result 484 ---------------------------------------------
Resets the connection . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect
--------------------------------------------- Result 485 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 453 / 24 / 8 / 485:  48%|████▊     | 485/1000 [3:53:16<4:07:42, 28.86s/it][Succeeded / Failed / Skipped / Total] 453 / 24 / 8 / 485:  49%|████▊     | 486/1000 [3:53:25<4:06:52, 28.82s/it][Succeeded / Failed / Skipped / Total] 454 / 24 / 8 / 486:  49%|████▊     | 486/1000 [3:53:25<4:06:52, 28.82s/it][Succeeded / Failed / Skipped / Total] 454 / 24 / 8 / 486:  49%|████▊     | 487/1000 [3:53:38<4:06:07, 28.79s/it][Succeeded / Failed / Skipped / Total] 455 / 24 / 8 / 487:  49%|████▊     | 487/1000 [3:53:38<4:06:07, 28.79s/it][Succeeded / Failed / Skipped / Total] 455 / 24 / 8 / 487:  49%|████▉     | 488/1000 [3:53:59<4:05:30, 28.77s/it][Succeeded / Failed / Skipped / Total] 456 / 24 / 8 / 488:  49%|████▉     | 488/1000 [3:53:59<4:05:30, 28.77s/it][Succeeded / Failed / Skipped / Total] 456 / 24 / 8 / 488:  49%|████▉     | 489/1000 [3:54:16<4:04:49, 28.75s/it][Succeeded / Failed / Skipped / Total] 457 / 24 / 8 / 489:  49%|████▉     | 489/1000 [3:54:16<4:04:49, 28.75s/it][Succeeded / Failed / Skipped / Total] 457 / 24 / 8 / 489:  49%|████▉     | 490/1000 [3:55:33<4:05:10, 28.84s/it][Succeeded / Failed / Skipped / Total] 458 / 24 / 8 / 490:  49%|████▉     | 490/1000 [3:55:33<4:05:10, 28.84s/it][Succeeded / Failed / Skipped / Total] 458 / 24 / 8 / 490:  49%|████▉     | 491/1000 [3:55:48<4:04:27, 28.82s/it]Check if a frame is not fully completed . --> Adar data . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsNotFin]] ( Framedata [[frame]] ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = [[frame]] ; addToBufferList ( [[frame]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame

[[[[Adv]]]]: private void [[adar]] ( Framedata [[difficult]] ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = [[difficult]] ; addToBufferList ( [[difficult]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame
--------------------------------------------- Result 486 ---------------------------------------------
Start connect . --> Starts reading thread --> Socre: 1.0

[[[[Adv]]]]: public void [[connect]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .

[[[[Adv]]]]: public void [[florette]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .
--------------------------------------------- Result 487 ---------------------------------------------
Returns the size of the byte buffer list . --> Total Fawkes . --> Socre: 1.0

[[[[Adv]]]]: private long [[getByteBufferListSize]] ( ) { long totalSize = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer [[buffer]] : byteBufferList ) { totalSize += [[buffer]] . limit ( ) ; } } return totalSize ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list

[[[[Adv]]]]: private long [[fawkes]] ( ) { long totalSize = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer [[serendipity]] : byteBufferList ) { totalSize += [[serendipity]] . limit ( ) ; } } return totalSize ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list
--------------------------------------------- Result 488 ---------------------------------------------
Sends the complete handshake . --> Sends a watermark message . --> Socre: 1.0

[[[[Adv]]]]: private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client [[handshake]] = new HandshakeImpl1Client ( ) ; [[handshake]] . setResourceDescriptor ( path ) ; [[handshake]] . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { [[handshake]] . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( [[handshake]] ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint

[[[[Adv]]]]: private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client [[watermelon]] = new HandshakeImpl1Client ( ) ; [[watermelon]] . setResourceDescriptor ( path ) ; [[watermelon]] . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { [[watermelon]] . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( [[watermelon]] ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint
--------------------------------------------- Result 489 ---------------------------------------------
Stops the connection lost timer . --> Uncooperative state . --> Socre: 1.0

[[[[Adv]]]]: protected void [[stopConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer

[[[[Adv]]]]: protected void [[uncooperative]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer
--------------------------------------------- Result 490 ---------------------------------------------
Generate a HTTP response with an error --> Creates Jonathon status page . --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[generateHttpResponseDueToError]] ( int [[errorCode]] ) { String errorCodeDescription ; switch ( [[errorCode]] ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error

[[[[Adv]]]]: private ByteBuffer [[jonathon]] ( int [[bolivian]] ) { String errorCodeDescription ; switch ( [[bolivian]] ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error
--------------------------------------------- Result 491 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 459 / 24 / 8 / 491:  49%|████▉     | 491/1000 [3:55:48<4:04:27, 28.82s/it][Succeeded / Failed / Skipped / Total] 459 / 24 / 8 / 491:  49%|████▉     | 492/1000 [3:55:50<4:03:30, 28.76s/it][Succeeded / Failed / Skipped / Total] 460 / 24 / 8 / 492:  49%|████▉     | 492/1000 [3:55:50<4:03:30, 28.76s/it][Succeeded / Failed / Skipped / Total] 460 / 24 / 8 / 492:  49%|████▉     | 493/1000 [3:56:29<4:03:12, 28.78s/it][Succeeded / Failed / Skipped / Total] 461 / 24 / 8 / 493:  49%|████▉     | 493/1000 [3:56:29<4:03:12, 28.78s/it][Succeeded / Failed / Skipped / Total] 461 / 24 / 8 / 493:  49%|████▉     | 494/1000 [3:56:50<4:02:35, 28.77s/it][Succeeded / Failed / Skipped / Total] 462 / 24 / 8 / 494:  49%|████▉     | 494/1000 [3:56:50<4:02:35, 28.77s/it][Succeeded / Failed / Skipped / Total] 462 / 24 / 8 / 494:  50%|████▉     | 495/1000 [3:57:02<4:01:50, 28.73s/it][Succeeded / Failed / Skipped / Total] 463 / 24 / 8 / 495:  50%|████▉     | 495/1000 [3:57:02<4:01:50, 28.73s/it][Succeeded / Failed / Skipped / Total] 463 / 24 / 8 / 495:  50%|████▉     | 496/1000 [3:57:20<4:01:10, 28.71s/it]Processes a continuous frame . --> processes a FrameNotFinished --> Socre: 1.0

[[[[Adv]]]]: private void processFrameIsFin ( WebSocketImpl [[webSocketImpl]] , Framedata [[frame]] ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( [[frame]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame

[[[[Adv]]]]: private void processFrameIsFin ( WebSocketImpl [[hoch]] , Framedata [[león]] ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( [[león]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[hoch]] . getWebSocketListener ( ) . onWebsocketMessage ( [[hoch]] , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[hoch]] , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[hoch]] . getWebSocketListener ( ) . onWebsocketMessage ( [[hoch]] , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[hoch]] , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame
--------------------------------------------- Result 492 ---------------------------------------------
Get payload from byte buffers --> getPayloadFromByteBufferList --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer [[resultingByteBuffer]] ; synchronized ( byteBufferList ) { for ( ByteBuffer [[buffer]] : byteBufferList ) { totalSize += [[buffer]] . limit ( ) ; } checkBufferLimit ( ) ; [[resultingByteBuffer]] = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer [[buffer]] : byteBufferList ) { [[resultingByteBuffer]] . put ( [[buffer]] ) ; } } [[resultingByteBuffer]] . flip ( ) ; return [[resultingByteBuffer]] ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload

[[[[Adv]]]]: private ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer [[morello]] ; synchronized ( byteBufferList ) { for ( ByteBuffer [[casey]] : byteBufferList ) { totalSize += [[casey]] . limit ( ) ; } checkBufferLimit ( ) ; [[morello]] = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer [[casey]] : byteBufferList ) { [[morello]] . put ( [[casey]] ) ; } } [[morello]] . flip ( ) ; return [[morello]] ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload
--------------------------------------------- Result 493 ---------------------------------------------
Processes a continuous and notFin frame --> Handles abode --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameContinuousAndNonFin]] ( WebSocketImpl [[webSocketImpl]] , Framedata frame , Opcode [[curop]] ) throws InvalidDataException { if ( [[curop]] != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( [[webSocketImpl]] , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set

[[[[Adv]]]]: private void [[abode]] ( WebSocketImpl [[leena]] , Framedata frame , Opcode [[hologram]] ) throws InvalidDataException { if ( [[hologram]] != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( [[leena]] , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set
--------------------------------------------- Result 494 ---------------------------------------------
Sets the connection lost timeout . --> Albano timer --> Socre: 1.0

[[[[Adv]]]]: public void [[setConnectionLostTimeout]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . [[websocketRunning]] ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated

[[[[Adv]]]]: public void [[albano]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . [[kodiak]] ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated
--------------------------------------------- Result 495 ---------------------------------------------
Get the port . --> Determine zorg . --> Socre: 1.0

[[[[Adv]]]]: private int [[getPort]] ( ) { int [[port]] = uri . getPort ( ) ; if ( [[port]] == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return [[port]] ; }
[[[[Nl]]]]: Extract the specified port

[[[[Adv]]]]: private int [[cortlandt]] ( ) { int [[zorg]] = uri . getPort ( ) ; if ( [[zorg]] == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return [[zorg]] ; }
[[[[Nl]]]]: Extract the specified port
[Succeeded / Failed / Skipped / Total] 464 / 24 / 8 / 496:  50%|████▉     | 496/1000 [3:57:20<4:01:10, 28.71s/it][Succeeded / Failed / Skipped / Total] 464 / 24 / 8 / 496:  50%|████▉     | 497/1000 [3:57:24<4:00:16, 28.66s/it][Succeeded / Failed / Skipped / Total] 465 / 24 / 8 / 497:  50%|████▉     | 497/1000 [3:57:24<4:00:16, 28.66s/it][Succeeded / Failed / Skipped / Total] 465 / 24 / 8 / 497:  50%|████▉     | 498/1000 [3:57:43<3:59:38, 28.64s/it][Succeeded / Failed / Skipped / Total] 466 / 24 / 8 / 498:  50%|████▉     | 498/1000 [3:57:43<3:59:38, 28.64s/it][Succeeded / Failed / Skipped / Total] 466 / 24 / 8 / 498:  50%|████▉     | 499/1000 [3:57:58<3:58:55, 28.61s/it][Succeeded / Failed / Skipped / Total] 467 / 24 / 8 / 499:  50%|████▉     | 499/1000 [3:57:58<3:58:55, 28.61s/it][Succeeded / Failed / Skipped / Total] 467 / 24 / 8 / 499:  50%|█████     | 500/1000 [3:57:58<3:57:58, 28.56s/it][Succeeded / Failed / Skipped / Total] 468 / 24 / 8 / 500:  50%|█████     | 500/1000 [3:57:58<3:57:58, 28.56s/it][Succeeded / Failed / Skipped / Total] 468 / 24 / 8 / 500:  50%|█████     | 501/1000 [3:58:14<3:57:17, 28.53s/it][Succeeded / Failed / Skipped / Total] 469 / 24 / 8 / 501:  50%|█████     | 501/1000 [3:58:14<3:57:17, 28.53s/it][Succeeded / Failed / Skipped / Total] 469 / 24 / 8 / 501:  50%|█████     | 502/1000 [3:58:19<3:56:25, 28.48s/it]--------------------------------------------- Result 496 ---------------------------------------------
Stop the connection . --> Stop ICF --> Socre: 1.0

[[[[Adv]]]]: public void stop ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "[[False]]" != "[[False]]" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .

[[[[Adv]]]]: public void stop ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "[[Icf]]" != "[[Icf]]" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .
--------------------------------------------- Result 497 ---------------------------------------------
Sends a ping frame . --> Methode ds --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[onWebsocketPing]] ( WebSocket conn , Framedata f ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .

[[[[Adv]]]]: @ Override public void [[mamá]] ( WebSocket conn , Framedata f ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .
--------------------------------------------- Result 498 ---------------------------------------------
Perform additional read . --> Receives the connection to the queue . --> Socre: 1.0

[[[[Adv]]]]: private void [[doAdditionalRead]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read

[[[[Adv]]]]: private void [[alienate]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read
--------------------------------------------- Result 499 ---------------------------------------------
Gets the port . --> Methode d boo - oo mojo --> Socre: 1.0

[[[[Adv]]]]: public int [[getPort]] ( ) { int port = getAddress ( ) . getPort ( ) ; if ( port == 0 && server != null ) { port = server . socket ( ) . getLocalPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port number that this server listens on .

[[[[Adv]]]]: public int [[música]] ( ) { int port = getAddress ( ) . getPort ( ) ; if ( port == 0 && server != null ) { port = server . socket ( ) . getLocalPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port number that this server listens on .
--------------------------------------------- Result 500 ---------------------------------------------
do accept . --> Do the connect . --> Socre: 1.0

[[[[Adv]]]]: private void doAccept ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "[[True]]" == "[[True]]" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation

[[[[Adv]]]]: private void doAccept ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "[[Darla]]" == "[[Darla]]" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation
--------------------------------------------- Result 501 ---------------------------------------------
Handle the write --> Writes the attacked client . --> Socre: 1.0

[[[[Adv]]]]: private void doWrite ( SelectionKey [[key]] ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) [[key]] . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( [[key]] . isValid ( ) ) { [[key]] . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation

[[[[Adv]]]]: private void doWrite ( SelectionKey [[attacked]] ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) [[attacked]] . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( [[attacked]] . isValid ( ) ) { [[attacked]] . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation
--------------------------------------------- Result 502 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 470 / 24 / 8 / 502:  50%|█████     | 502/1000 [3:58:19<3:56:25, 28.48s/it][Succeeded / Failed / Skipped / Total] 470 / 24 / 8 / 502:  50%|█████     | 503/1000 [3:58:19<3:55:29, 28.43s/it][Succeeded / Failed / Skipped / Total] 470 / 24 / 9 / 503:  50%|█████     | 503/1000 [3:58:19<3:55:29, 28.43s/it][Succeeded / Failed / Skipped / Total] 470 / 24 / 9 / 503:  50%|█████     | 504/1000 [3:58:29<3:54:42, 28.39s/it][Succeeded / Failed / Skipped / Total] 471 / 24 / 9 / 504:  50%|█████     | 504/1000 [3:58:29<3:54:42, 28.39s/it][Succeeded / Failed / Skipped / Total] 471 / 24 / 9 / 504:  50%|█████     | 505/1000 [3:58:33<3:53:49, 28.34s/it][Succeeded / Failed / Skipped / Total] 472 / 24 / 9 / 505:  50%|█████     | 505/1000 [3:58:33<3:53:49, 28.34s/it][Succeeded / Failed / Skipped / Total] 472 / 24 / 9 / 505:  51%|█████     | 506/1000 [3:58:36<3:52:56, 28.29s/it][Succeeded / Failed / Skipped / Total] 473 / 24 / 9 / 506:  51%|█████     | 506/1000 [3:58:36<3:52:56, 28.29s/it][Succeeded / Failed / Skipped / Total] 473 / 24 / 9 / 506:  51%|█████     | 507/1000 [3:58:52<3:52:16, 28.27s/it][Succeeded / Failed / Skipped / Total] 474 / 24 / 9 / 507:  51%|█████     | 507/1000 [3:58:52<3:52:16, 28.27s/it][Succeeded / Failed / Skipped / Total] 474 / 24 / 9 / 507:  51%|█████     | 508/1000 [3:58:55<3:51:23, 28.22s/it][Succeeded / Failed / Skipped / Total] 475 / 24 / 9 / 508:  51%|█████     | 508/1000 [3:58:55<3:51:23, 28.22s/it][Succeeded / Failed / Skipped / Total] 475 / 24 / 9 / 508:  51%|█████     | 509/1000 [3:59:09<3:50:42, 28.19s/it]Do a read . --> Reads alphavile . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doRead]] ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation

[[[[Adv]]]]: private boolean [[alphaville]] ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation
--------------------------------------------- Result 503 ---------------------------------------------
Do a single thread . --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once
--------------------------------------------- Result 504 ---------------------------------------------
Receives a server handshake . --> Receiving from WebSocket --> Socre: 1.0

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer ( WebSocket [[conn]] , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer ( WebSocket [[bhanu]] , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .
--------------------------------------------- Result 505 ---------------------------------------------
Sets up the selector and server thread . --> Start artfully . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doSetupSelectorAndServerThread]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "False" != "False" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings

[[[[Adv]]]]: private boolean [[artfully]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "False" != "False" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings
--------------------------------------------- Result 506 ---------------------------------------------
Shutdown server . --> Actually shut down the server . --> Socre: 1.0

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker [[w]] : decoders ) { [[w]] . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker [[bergerac]] : decoders ) { [[bergerac]] . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown
--------------------------------------------- Result 507 ---------------------------------------------
Broadcasts the given data to all clients . --> Alabam message . --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( byte [ ] data , Collection < WebSocket > clients ) { if ( data == null || clients == null ) { throw new IllegalArgumentException ( ) ; } [[broadcast]] ( ByteBuffer . wrap ( data ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections

[[[[Adv]]]]: public void [[alabam]] ( byte [ ] data , Collection < WebSocket > clients ) { if ( data == null || clients == null ) { throw new IllegalArgumentException ( ) ; } [[alabam]] ( ByteBuffer . wrap ( data ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections
--------------------------------------------- Result 508 ---------------------------------------------
Broadcasts a text to all connected clients . --> Broadcast bull fights . --> Socre: 1.0

[[[[Adv]]]]: public void broadcast ( String [[text]] , Collection < WebSocket > clients ) { if ( [[text]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[text]] , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections

[[[[Adv]]]]: public void broadcast ( String [[bullfights]] , Collection < WebSocket > clients ) { if ( [[bullfights]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[bullfights]] , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections
--------------------------------------------- Result 509 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 476 / 24 / 9 / 509:  51%|█████     | 509/1000 [3:59:09<3:50:42, 28.19s/it][Succeeded / Failed / Skipped / Total] 476 / 24 / 9 / 509:  51%|█████     | 510/1000 [3:59:12<3:49:49, 28.14s/it][Succeeded / Failed / Skipped / Total] 477 / 24 / 9 / 510:  51%|█████     | 510/1000 [3:59:12<3:49:49, 28.14s/it][Succeeded / Failed / Skipped / Total] 477 / 24 / 9 / 510:  51%|█████     | 511/1000 [3:59:13<3:48:55, 28.09s/it][Succeeded / Failed / Skipped / Total] 478 / 24 / 9 / 511:  51%|█████     | 511/1000 [3:59:13<3:48:55, 28.09s/it][Succeeded / Failed / Skipped / Total] 478 / 24 / 9 / 511:  51%|█████     | 512/1000 [3:59:17<3:48:04, 28.04s/it][Succeeded / Failed / Skipped / Total] 479 / 24 / 9 / 512:  51%|█████     | 512/1000 [3:59:17<3:48:04, 28.04s/it][Succeeded / Failed / Skipped / Total] 479 / 24 / 9 / 512:  51%|█████▏    | 513/1000 [3:59:28<3:47:20, 28.01s/it][Succeeded / Failed / Skipped / Total] 480 / 24 / 9 / 513:  51%|█████▏    | 513/1000 [3:59:28<3:47:20, 28.01s/it][Succeeded / Failed / Skipped / Total] 480 / 24 / 9 / 513:  51%|█████▏    | 514/1000 [3:59:32<3:46:29, 27.96s/it][Succeeded / Failed / Skipped / Total] 481 / 24 / 9 / 514:  51%|█████▏    | 514/1000 [3:59:32<3:46:29, 27.96s/it][Succeeded / Failed / Skipped / Total] 481 / 24 / 9 / 514:  52%|█████▏    | 515/1000 [3:59:37<3:45:39, 27.92s/it]Broadcasts the given data to all clients . --> Broadcasts a draft --> Socre: 1.0

[[[[Adv]]]]: private void doBroadcast ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft [[draft]] = client . getDraft ( ) ; fillFrames ( [[draft]] , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( [[draft]] ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time

[[[[Adv]]]]: private void doBroadcast ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft [[paedophile]] = client . getDraft ( ) ; fillFrames ( [[paedophile]] , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( [[paedophile]] ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time
--------------------------------------------- Result 510 ---------------------------------------------
Starts the timer of connections lost . --> An abandoned thread to abandon connections . --> Socre: 1.0

[[[[Adv]]]]: private void [[restartConnectionLostTimer]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long [[minimumPongTime]] = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , [[minimumPongTime]] ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter

[[[[Adv]]]]: private void [[abandon]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long [[cassius]] = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , [[cassius]] ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter
--------------------------------------------- Result 511 ---------------------------------------------
Fill the frames map . --> Fill frames . --> Socre: 1.0

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer [[bData]] ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( [[bData]] != null ) { frames = draft . createFrames ( [[bData]] , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer [[angled]] ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( [[angled]] != null ) { frames = draft . createFrames ( [[angled]] , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast
--------------------------------------------- Result 512 ---------------------------------------------
Cancels the connection lost checker . --> Shutdown alphavatars . --> Socre: 1.0

[[[[Adv]]]]: private void [[cancelConnectionLostTimer]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "[[False]]" != "[[False]]" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection

[[[[Adv]]]]: private void [[alphaville]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "[[Andronicus]]" != "[[Andronicus]]" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection
--------------------------------------------- Result 513 ---------------------------------------------
Transfer from source to dest . --> Transfers the dreamworks into the dest buffer . --> Socre: 1.0

[[[[Adv]]]]: public static int transferByteBuffer ( ByteBuffer [[source]] , ByteBuffer dest ) { if ( [[source]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[source]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; [[source]] . limit ( limit ) ; dest . put ( [[source]] ) ; return limit ; } else { dest . put ( [[source]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer

[[[[Adv]]]]: public static int transferByteBuffer ( ByteBuffer [[dreamworks]] , ByteBuffer dest ) { if ( [[dreamworks]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[dreamworks]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; [[dreamworks]] . limit ( limit ) ; dest . put ( [[dreamworks]] ) ; return limit ; } else { dest . put ( [[dreamworks]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer
--------------------------------------------- Result 514 ---------------------------------------------
Starts jpa . --> Methode permutation factory --> Socre: 1.0

[[[[Adv]]]]: public JPAApi [[start]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .

[[[[Adv]]]]: public JPAApi [[mermaid]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .
--------------------------------------------- Result 515 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 482 / 24 / 9 / 515:  52%|█████▏    | 515/1000 [3:59:37<3:45:39, 27.92s/it][Succeeded / Failed / Skipped / Total] 482 / 24 / 9 / 515:  52%|█████▏    | 516/1000 [3:59:39<3:44:47, 27.87s/it][Succeeded / Failed / Skipped / Total] 483 / 24 / 9 / 516:  52%|█████▏    | 516/1000 [3:59:39<3:44:47, 27.87s/it][Succeeded / Failed / Skipped / Total] 483 / 24 / 9 / 516:  52%|█████▏    | 517/1000 [3:59:53<3:44:07, 27.84s/it][Succeeded / Failed / Skipped / Total] 484 / 24 / 9 / 517:  52%|█████▏    | 517/1000 [3:59:53<3:44:07, 27.84s/it][Succeeded / Failed / Skipped / Total] 484 / 24 / 9 / 517:  52%|█████▏    | 518/1000 [3:59:58<3:43:18, 27.80s/it][Succeeded / Failed / Skipped / Total] 485 / 24 / 9 / 518:  52%|█████▏    | 518/1000 [3:59:58<3:43:18, 27.80s/it][Succeeded / Failed / Skipped / Total] 485 / 24 / 9 / 518:  52%|█████▏    | 519/1000 [4:00:58<3:43:20, 27.86s/it][Succeeded / Failed / Skipped / Total] 486 / 24 / 9 / 519:  52%|█████▏    | 519/1000 [4:00:58<3:43:20, 27.86s/it][Succeeded / Failed / Skipped / Total] 486 / 24 / 9 / 519:  52%|█████▏    | 520/1000 [4:01:31<3:42:56, 27.87s/it][Succeeded / Failed / Skipped / Total] 487 / 24 / 9 / 520:  52%|█████▏    | 520/1000 [4:01:31<3:42:56, 27.87s/it][Succeeded / Failed / Skipped / Total] 487 / 24 / 9 / 520:  52%|█████▏    | 521/1000 [4:01:57<3:42:27, 27.87s/it][Succeeded / Failed / Skipped / Total] 488 / 24 / 9 / 521:  52%|█████▏    | 521/1000 [4:01:57<3:42:27, 27.87s/it][Succeeded / Failed / Skipped / Total] 488 / 24 / 9 / 521:  52%|█████▏    | 522/1000 [4:02:18<3:41:53, 27.85s/it][Succeeded / Failed / Skipped / Total] 489 / 24 / 9 / 522:  52%|█████▏    | 522/1000 [4:02:18<3:41:53, 27.85s/it][Succeeded / Failed / Skipped / Total] 489 / 24 / 9 / 522:  52%|█████▏    | 523/1000 [4:02:20<3:41:01, 27.80s/it][Succeeded / Failed / Skipped / Total] 490 / 24 / 9 / 523:  52%|█████▏    | 523/1000 [4:02:20<3:41:01, 27.80s/it][Succeeded / Failed / Skipped / Total] 490 / 24 / 9 / 523:  52%|█████▏    | 524/1000 [4:02:20<3:40:08, 27.75s/it][Succeeded / Failed / Skipped / Total] 490 / 24 / 10 / 524:  52%|█████▏    | 524/1000 [4:02:20<3:40:08, 27.75s/it][Succeeded / Failed / Skipped / Total] 490 / 24 / 10 / 524:  52%|█████▎    | 525/1000 [4:02:23<3:39:18, 27.70s/it]Pass the given transaction to the given consumer . --> Wrap transactional context --> Socre: 1.0

[[[[Adv]]]]: public void withTransaction ( Consumer < EntityManager > [[block]] ) { withTransaction ( em -> { [[block]] . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .

[[[[Adv]]]]: public void withTransaction ( Consumer < EntityManager > [[vespucci]] ) { withTransaction ( em -> { [[vespucci]] . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .
--------------------------------------------- Result 516 ---------------------------------------------
Returns the socket associated with the given WebSocket . --> Get SocketWriter --> Socre: 1.0

[[[[Adv]]]]: private Socket getSocket ( WebSocket [[conn]] ) { WebSocketImpl impl = ( WebSocketImpl ) [[conn]] ; return ( ( SocketChannel ) impl . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection

[[[[Adv]]]]: private Socket getSocket ( WebSocket [[screenwriters]] ) { WebSocketImpl impl = ( WebSocketImpl ) [[screenwriters]] ; return ( ( SocketChannel ) impl . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection
--------------------------------------------- Result 517 ---------------------------------------------
Wraps the given arguments to a List . --> Package private for testing --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > wrapArgsToListIfNeeded ( final T ... args ) { List < T > [[out]] ; if ( args != null && args . length == 1 && args [ 0 ] instanceof List ) { [[out]] = ( List < T > ) args [ 0 ] ; } else { [[out]] = Arrays . asList ( args ) ; } return [[out]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > wrapArgsToListIfNeeded ( final T ... args ) { List < T > [[shovelling]] ; if ( args != null && args . length == 1 && args [ 0 ] instanceof List ) { [[shovelling]] = ( List < T > ) args [ 0 ] ; } else { [[shovelling]] = Arrays . asList ( args ) ; } return [[shovelling]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .
--------------------------------------------- Result 518 ---------------------------------------------
Gets the translation for the specified keys . --> This method is used for testing --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang lang , List < String > keys , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .

[[[[Adv]]]]: public String [[tío]] ( play . api . i18n . Lang lang , List < String > keys , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .
--------------------------------------------- Result 519 ---------------------------------------------
Gets the internationalized message . --> get internationalized translation --> Socre: 1.0

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , String key , Object ... [[args]] ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[args]] ) ; return messages . apply ( key , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates a message .

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , String key , Object ... [[weedon]] ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[weedon]] ) ; return messages . apply ( key , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates a message .
--------------------------------------------- Result 520 ---------------------------------------------
Returns the EntityManager for the given name . --> Gets albano --> Socre: 1.0

[[[[Adv]]]]: public EntityManager [[em]] ( String name ) { EntityManagerFactory emf = emfs . get ( name ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .

[[[[Adv]]]]: public EntityManager [[albano]] ( String name ) { EntityManagerFactory emf = emfs . get ( name ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .
--------------------------------------------- Result 521 ---------------------------------------------
Set the language . --> So we don t do anything --> Socre: 1.0

[[[[Adv]]]]: public Result [[setLang]] ( Result result , Lang lang ) { return messages . setLang ( result . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .

[[[[Adv]]]]: public Result [[tú]] ( Result result , Lang lang ) { return messages . setLang ( result . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .
--------------------------------------------- Result 522 ---------------------------------------------
Specify the given bindings . --> Returns a copy of this class --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .

[[[[Adv]]]]: public final Self [[deserving]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .
--------------------------------------------- Result 523 ---------------------------------------------
Select the preferred languages . --> Preferred Message from cssages --> Socre: 1.0

[[[[Adv]]]]: public Messages preferred ( Collection < Lang > [[candidates]] ) { Seq < Lang > cs = Scala . asScala ( [[candidates]] ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .

[[[[Adv]]]]: public Messages preferred ( Collection < Lang > [[córdoba]] ) { Seq < Lang > cs = Scala . asScala ( [[córdoba]] ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .
--------------------------------------------- Result 524 ---------------------------------------------
Sets the REPLACEME --> [[[SKIPPED]]]

[[[[Adv]]]]: public final Self REPLACEME0 ( play . api . inject . Binding < ? > ... REPLACEME0 ) { return REPLACEME0 ( Guiceable . bindings ( REPLACEME0 ) ) ; }
[[[[Nl]]]]: Add Play bindings .
--------------------------------------------- Result 525 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 491 / 24 / 10 / 525:  52%|█████▎    | 525/1000 [4:02:23<3:39:18, 27.70s/it][Succeeded / Failed / Skipped / Total] 491 / 24 / 10 / 525:  53%|█████▎    | 526/1000 [4:02:37<3:38:38, 27.68s/it][Succeeded / Failed / Skipped / Total] 492 / 24 / 10 / 526:  53%|█████▎    | 526/1000 [4:02:37<3:38:38, 27.68s/it][Succeeded / Failed / Skipped / Total] 492 / 24 / 10 / 526:  53%|█████▎    | 527/1000 [4:02:40<3:37:48, 27.63s/it][Succeeded / Failed / Skipped / Total] 493 / 24 / 10 / 527:  53%|█████▎    | 527/1000 [4:02:40<3:37:48, 27.63s/it][Succeeded / Failed / Skipped / Total] 493 / 24 / 10 / 527:  53%|█████▎    | 528/1000 [4:02:41<3:36:57, 27.58s/it][Succeeded / Failed / Skipped / Total] 494 / 24 / 10 / 528:  53%|█████▎    | 528/1000 [4:02:41<3:36:57, 27.58s/it][Succeeded / Failed / Skipped / Total] 494 / 24 / 10 / 528:  53%|█████▎    | 529/1000 [4:02:50<3:36:12, 27.54s/it][Succeeded / Failed / Skipped / Total] 495 / 24 / 10 / 529:  53%|█████▎    | 529/1000 [4:02:50<3:36:12, 27.54s/it][Succeeded / Failed / Skipped / Total] 495 / 24 / 10 / 529:  53%|█████▎    | 530/1000 [4:02:56<3:35:25, 27.50s/it][Succeeded / Failed / Skipped / Total] 496 / 24 / 10 / 530:  53%|█████▎    | 530/1000 [4:02:56<3:35:25, 27.50s/it][Succeeded / Failed / Skipped / Total] 496 / 24 / 10 / 530:  53%|█████▎    | 531/1000 [4:03:01<3:34:38, 27.46s/it][Succeeded / Failed / Skipped / Total] 497 / 24 / 10 / 531:  53%|█████▎    | 531/1000 [4:03:01<3:34:38, 27.46s/it][Succeeded / Failed / Skipped / Total] 497 / 24 / 10 / 531:  53%|█████▎    | 532/1000 [4:03:15<3:33:59, 27.43s/it][Succeeded / Failed / Skipped / Total] 498 / 24 / 10 / 532:  53%|█████▎    | 532/1000 [4:03:15<3:33:59, 27.43s/it][Succeeded / Failed / Skipped / Total] 498 / 24 / 10 / 532:  53%|█████▎    | 533/1000 [4:03:20<3:33:12, 27.39s/it][Succeeded / Failed / Skipped / Total] 499 / 24 / 10 / 533:  53%|█████▎    | 533/1000 [4:03:20<3:33:12, 27.39s/it][Succeeded / Failed / Skipped / Total] 499 / 24 / 10 / 533:  53%|█████▎    | 534/1000 [4:03:33<3:32:32, 27.37s/it][Succeeded / Failed / Skipped / Total] 500 / 24 / 10 / 534:  53%|█████▎    | 534/1000 [4:03:33<3:32:32, 27.37s/it][Succeeded / Failed / Skipped / Total] 500 / 24 / 10 / 534:  54%|█████▎    | 535/1000 [4:03:46<3:31:52, 27.34s/it][Succeeded / Failed / Skipped / Total] 501 / 24 / 10 / 535:  54%|█████▎    | 535/1000 [4:03:46<3:31:52, 27.34s/it][Succeeded / Failed / Skipped / Total] 501 / 24 / 10 / 535:  54%|█████▎    | 536/1000 [4:04:00<3:31:14, 27.32s/it]Start the connection lost timer . --> Drexception . --> Socre: 1.0

[[[[Adv]]]]: protected void [[startConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( this . [[connectionLostTimeout]] <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . [[websocketRunning]] = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer

[[[[Adv]]]]: protected void [[drex]] ( ) { synchronized ( syncConnectionLost ) { if ( this . [[sunup]] <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . [[credentials]] = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer
--------------------------------------------- Result 526 ---------------------------------------------
Define the Guice binding . --> Publish a charlem --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( play . api . inject . Module ... modules ) { return [[bindings]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .

[[[[Adv]]]]: public final Self [[charlemagne]] ( play . api . inject . Module ... modules ) { return [[charlemagne]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .
--------------------------------------------- Result 527 ---------------------------------------------
Specifies the module overrides . --> Specifies the overrides of this class --> Socre: 1.0

[[[[Adv]]]]: public final Self overrides ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .

[[[[Adv]]]]: public final Self overrides ( GuiceableModule ... [[lepak]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[lepak]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .
--------------------------------------------- Result 528 ---------------------------------------------
Specifies the module overrides . --> Create a new instance of this class --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Module ... modules ) { return [[overrides]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .

[[[[Adv]]]]: public final Self [[creations]] ( play . api . inject . Module ... modules ) { return [[creations]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .
--------------------------------------------- Result 529 ---------------------------------------------
Convert arguments to Scala buffer . --> Bessel method . --> Socre: 1.0

[[[[Adv]]]]: private static Seq < Object > [[convertArgsToScalaBuffer]] ( final Object ... [[args]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( [[args]] ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary

[[[[Adv]]]]: private static Seq < Object > [[bertha]] ( final Object ... [[instruct]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( [[instruct]] ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary
--------------------------------------------- Result 530 ---------------------------------------------
Specifies the Guice . --> Add cengiziz with Guice --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Binding < ? > ... bindings ) { return [[overrides]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .

[[[[Adv]]]]: public final Self [[cengiz]] ( play . api . inject . Binding < ? > ... bindings ) { return [[cengiz]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .
--------------------------------------------- Result 531 ---------------------------------------------
Execute the call . --> EENEE --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < Result > [[call]] ( Request req ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .

[[[[Adv]]]]: public CompletionStage < Result > [[eenie]] ( Request req ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .
--------------------------------------------- Result 532 ---------------------------------------------
Creates a binding for the given scope . --> Methode permettant de la cli --> Socre: 1.0

[[[[Adv]]]]: public < A [[extends]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .

[[[[Adv]]]]: public < A [[señores]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .
--------------------------------------------- Result 533 ---------------------------------------------
Static factory method for creating a tuple . --> Computes Checco --> Socre: 1.0

[[[[Adv]]]]: public static < A , B > [[Tuple]] < A , B > [[Tuple]] ( A a , B b ) { return new [[Tuple]] < A , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B

[[[[Adv]]]]: public static < A , B > [[Checco]] < A , B > [[Checco]] ( A a , B b ) { return new [[Checco]] < A , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B
--------------------------------------------- Result 534 ---------------------------------------------
Factory method for creating a tuple 5 . --> Static factory method . --> Socre: 1.0

[[[[Adv]]]]: public static < A , [[B]] , C , D , E > Tuple5 < A , [[B]] , C , D , E > Tuple5 ( A a , [[B]] b , C c , D d , E e ) { return new Tuple5 < A , [[B]] , C , D , E > ( a , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E

[[[[Adv]]]]: public static < A , [[airtime]] , C , D , E > Tuple5 < A , [[airtime]] , C , D , E > Tuple5 ( A a , [[airtime]] b , C c , D d , E e ) { return new Tuple5 < A , [[airtime]] , C , D , E > ( a , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E
--------------------------------------------- Result 535 ---------------------------------------------
Disables the given modules . --> Disables the given connections --> Socre: 1.0

[[[[Adv]]]]: public final Self disable ( Class < ? > ... [[moduleClasses]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[moduleClasses]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .

[[[[Adv]]]]: public final Self disable ( Class < ? > ... [[booths]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[booths]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .
--------------------------------------------- Result 536 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 502 / 24 / 10 / 536:  54%|█████▎    | 536/1000 [4:04:00<3:31:14, 27.32s/it][Succeeded / Failed / Skipped / Total] 502 / 24 / 10 / 536:  54%|█████▎    | 537/1000 [4:04:12<3:30:33, 27.29s/it][Succeeded / Failed / Skipped / Total] 503 / 24 / 10 / 537:  54%|█████▎    | 537/1000 [4:04:12<3:30:33, 27.29s/it][Succeeded / Failed / Skipped / Total] 503 / 24 / 10 / 537:  54%|█████▍    | 538/1000 [4:04:31<3:29:59, 27.27s/it][Succeeded / Failed / Skipped / Total] 504 / 24 / 10 / 538:  54%|█████▍    | 538/1000 [4:04:31<3:29:59, 27.27s/it][Succeeded / Failed / Skipped / Total] 504 / 24 / 10 / 538:  54%|█████▍    | 539/1000 [4:04:32<3:29:09, 27.22s/it][Succeeded / Failed / Skipped / Total] 505 / 24 / 10 / 539:  54%|█████▍    | 539/1000 [4:04:32<3:29:09, 27.22s/it][Succeeded / Failed / Skipped / Total] 505 / 24 / 10 / 539:  54%|█████▍    | 540/1000 [4:04:50<3:28:33, 27.20s/it][Succeeded / Failed / Skipped / Total] 506 / 24 / 10 / 540:  54%|█████▍    | 540/1000 [4:04:50<3:28:33, 27.20s/it][Succeeded / Failed / Skipped / Total] 506 / 24 / 10 / 540:  54%|█████▍    | 541/1000 [4:05:09<3:27:59, 27.19s/it][Succeeded / Failed / Skipped / Total] 507 / 24 / 10 / 541:  54%|█████▍    | 541/1000 [4:05:09<3:27:59, 27.19s/it][Succeeded / Failed / Skipped / Total] 507 / 24 / 10 / 541:  54%|█████▍    | 542/1000 [4:05:10<3:27:10, 27.14s/it][Succeeded / Failed / Skipped / Total] 508 / 24 / 10 / 542:  54%|█████▍    | 542/1000 [4:05:10<3:27:10, 27.14s/it][Succeeded / Failed / Skipped / Total] 508 / 24 / 10 / 542:  54%|█████▍    | 543/1000 [4:05:46<3:26:51, 27.16s/it][Succeeded / Failed / Skipped / Total] 509 / 24 / 10 / 543:  54%|█████▍    | 543/1000 [4:05:46<3:26:51, 27.16s/it][Succeeded / Failed / Skipped / Total] 509 / 24 / 10 / 543:  54%|█████▍    | 544/1000 [4:05:46<3:26:01, 27.11s/it]Handles a connection lost connection . --> Borrowed from WebSocketImpl --> Socre: 1.0

[[[[Adv]]]]: private void [[executeConnectionLostDetection]] ( WebSocket [[webSocket]] , long minimumPongTime ) { if ( ! ( [[webSocket]] instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) [[webSocket]] ; if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping

[[[[Adv]]]]: private void [[bibi]] ( WebSocket [[abandon]] , long minimumPongTime ) { if ( ! ( [[abandon]] instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) [[abandon]] ; if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping
--------------------------------------------- Result 537 ---------------------------------------------
Returns whether the key is defined at the specified language . --> Liefert ein ein einen ein ein ein einzelnen ein einzelen es eines einzele Methode --> Socre: 1.0

[[[[Adv]]]]: public Boolean [[isDefinedAt]] ( play . api . i18n . Lang lang , String [[key]] ) { return messages . isDefinedAt ( [[key]] , lang ) ; }
[[[[Nl]]]]: Check if a message key is defined .

[[[[Adv]]]]: public Boolean [[señores]] ( play . api . i18n . Lang lang , String [[baruch]] ) { return messages . isDefinedAt ( [[baruch]] , lang ) ; }
[[[[Nl]]]]: Check if a message key is defined .
--------------------------------------------- Result 538 ---------------------------------------------
Returns the preferred message for this request . -->  watermark message --> Socre: 1.0

[[[[Adv]]]]: public Messages [[preferred]] ( Http . RequestHeader [[request]] ) { play . api . i18n . Messages msgs = messages . preferred ( [[request]] ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .

[[[[Adv]]]]: public Messages [[watermelon]] ( Http . RequestHeader [[katarina]] ) { play . api . i18n . Messages msgs = messages . preferred ( [[katarina]] ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .
--------------------------------------------- Result 539 ---------------------------------------------
Inject string into ByteString --> Encode an ecco script --> Socre: 1.0

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[string]] ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[ecco]] ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .
--------------------------------------------- Result 540 ---------------------------------------------
Gets an existing file . --> Get altamont --> Socre: 1.0

[[[[Adv]]]]: public Optional < File > [[getExistingFile]] ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .

[[[[Adv]]]]: public Optional < File > [[altamont]] ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .
--------------------------------------------- Result 541 ---------------------------------------------
Registers a constraint validator for the given key . --> javadoc --> Socre: 1.0

[[[[Adv]]]]: public < T [[extends]] ConstraintValidator < ? , ? > > MappedConstraintValidatorFactory addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .

[[[[Adv]]]]: public < T [[città]] ConstraintValidator < ? , ? > > MappedConstraintValidatorFactory addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .
--------------------------------------------- Result 542 ---------------------------------------------
Creates a jpa config . --> Parses cittest --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String n1 , String u1 , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .

[[[[Adv]]]]: public static JPAConfig [[città]] ( String n1 , String u1 , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .
--------------------------------------------- Result 543 ---------------------------------------------
Creates new instance of the given constraint validator class . --> Creates a new instance of Cronours --> Socre: 1.0

[[[[Adv]]]]: private < [[T]] extends ConstraintValidator < ? , ? > > [[T]] newInstance ( Class < [[T]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .

[[[[Adv]]]]: private < [[tumours]] extends ConstraintValidator < ? , ? > > [[tumours]] newInstance ( Class < [[tumours]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .
--------------------------------------------- Result 544 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 510 / 24 / 10 / 544:  54%|█████▍    | 544/1000 [4:05:46<3:26:01, 27.11s/it][Succeeded / Failed / Skipped / Total] 510 / 24 / 10 / 544:  55%|█████▍    | 545/1000 [4:05:48<3:25:12, 27.06s/it][Succeeded / Failed / Skipped / Total] 511 / 24 / 10 / 545:  55%|█████▍    | 545/1000 [4:05:48<3:25:12, 27.06s/it][Succeeded / Failed / Skipped / Total] 511 / 24 / 10 / 545:  55%|█████▍    | 546/1000 [4:06:05<3:24:37, 27.04s/it][Succeeded / Failed / Skipped / Total] 512 / 24 / 10 / 546:  55%|█████▍    | 546/1000 [4:06:05<3:24:37, 27.04s/it][Succeeded / Failed / Skipped / Total] 512 / 24 / 10 / 546:  55%|█████▍    | 547/1000 [4:06:31<3:24:09, 27.04s/it][Succeeded / Failed / Skipped / Total] 513 / 24 / 10 / 547:  55%|█████▍    | 547/1000 [4:06:31<3:24:09, 27.04s/it][Succeeded / Failed / Skipped / Total] 513 / 24 / 10 / 547:  55%|█████▍    | 548/1000 [4:06:31<3:23:20, 26.99s/it][Succeeded / Failed / Skipped / Total] 513 / 24 / 11 / 548:  55%|█████▍    | 548/1000 [4:06:31<3:23:20, 26.99s/it][Succeeded / Failed / Skipped / Total] 513 / 24 / 11 / 548:  55%|█████▍    | 549/1000 [4:07:36<3:23:24, 27.06s/it][Succeeded / Failed / Skipped / Total] 514 / 24 / 11 / 549:  55%|█████▍    | 549/1000 [4:07:36<3:23:24, 27.06s/it][Succeeded / Failed / Skipped / Total] 514 / 24 / 11 / 549:  55%|█████▌    | 550/1000 [4:08:04<3:22:58, 27.06s/it][Succeeded / Failed / Skipped / Total] 515 / 24 / 11 / 550:  55%|█████▌    | 550/1000 [4:08:04<3:22:58, 27.06s/it][Succeeded / Failed / Skipped / Total] 515 / 24 / 11 / 550:  55%|█████▌    | 551/1000 [4:09:57<3:23:41, 27.22s/it][Succeeded / Failed / Skipped / Total] 516 / 24 / 11 / 551:  55%|█████▌    | 551/1000 [4:09:57<3:23:41, 27.22s/it][Succeeded / Failed / Skipped / Total] 516 / 24 / 11 / 551:  55%|█████▌    | 552/1000 [4:11:01<3:23:44, 27.29s/it]Called when an error occurs . --> region ErrorHandler --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > onClientError ( RequestHeader [[request]] , int statusCode , String message ) { if ( statusCode == 400 ) { return onBadRequest ( [[request]] , message ) ; } else if ( statusCode == 403 ) { return onForbidden ( [[request]] , message ) ; } else if ( statusCode == 404 ) { return onNotFound ( [[request]] , message ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( [[request]] , statusCode , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + message ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .

[[[[Adv]]]]: @ Override public CompletionStage < Result > onClientError ( RequestHeader [[regan]] , int statusCode , String message ) { if ( statusCode == 400 ) { return onBadRequest ( [[regan]] , message ) ; } else if ( statusCode == 403 ) { return onForbidden ( [[regan]] , message ) ; } else if ( statusCode == 404 ) { return onNotFound ( [[regan]] , message ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( [[regan]] , statusCode , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + message ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .
--------------------------------------------- Result 545 ---------------------------------------------
Returns a flow from a JsonNode --> returns empty string --> Socre: 1.0

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > json ( String [[callbackName]] ) { return Flow . of ( JsonNode . class ) . map ( json -> { return ByteString . fromString ( Json . stringify ( json ) ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > json ( String [[olive]] ) { return Flow . of ( JsonNode . class ) . map ( json -> { return ByteString . fromString ( Json . stringify ( json ) ) ; } ) . via ( flow ( [[olive]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .
--------------------------------------------- Result 546 ---------------------------------------------
On not found . --> region NotFoundException --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > onNotFound ( RequestHeader [[request]] , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , [[request]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[request]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .

[[[[Adv]]]]: protected CompletionStage < Result > onNotFound ( RequestHeader [[hathaway]] , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[hathaway]] . method ( ) , [[hathaway]] . uri ( ) , [[hathaway]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[hathaway]] . method ( ) , [[hathaway]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[hathaway]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .
--------------------------------------------- Result 547 ---------------------------------------------
Convert ExecutionContext to Executor --> Implements disjunctive fashion --> Socre: 1.0

[[[[Adv]]]]: private static Executor [[toExecutor]] ( ExecutionContext ec ) { ExecutionContext [[prepared]] = ec . prepare ( ) ; if ( [[prepared]] instanceof Executor ) { return ( Executor ) [[prepared]] ; } else { return [[prepared]] :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .

[[[[Adv]]]]: private static Executor [[disarmed]] ( ExecutionContext ec ) { ExecutionContext [[bankroll]] = ec . prepare ( ) ; if ( [[bankroll]] instanceof Executor ) { return ( Executor ) [[bankroll]] ; } else { return [[bankroll]] :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .
--------------------------------------------- Result 548 ---------------------------------------------
Logs an error --> [[[SKIPPED]]]

[[[[Adv]]]]: protected void logServerError ( RequestHeader request , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , request . method ( ) , request . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .
--------------------------------------------- Result 549 ---------------------------------------------
Returns a new instance of JPAConfig . --> Builds JPAConfig --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String [[name]] , String unitName ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[name]] , unitName ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .

[[[[Adv]]]]: public static JPAConfig [[bodybuilding]] ( String [[indiscretions]] , String unitName ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[indiscretions]] , unitName ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .
--------------------------------------------- Result 550 ---------------------------------------------
Handle bad request . --> region InvalidRequest --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > onBadRequest ( RequestHeader request , String [[message]] ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , [[message]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .

[[[[Adv]]]]: protected CompletionStage < Result > onBadRequest ( RequestHeader request , String [[intimates]] ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , [[intimates]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .
--------------------------------------------- Result 551 ---------------------------------------------
Convert a throwable to a useful exception . --> This method will be called with a flambe --> Socre: 1.0

[[[[Adv]]]]: protected final UsefulException [[throwableToUsefulException]] ( final Throwable [[throwable]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[throwable]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .

[[[[Adv]]]]: protected final UsefulException [[flambé]] ( final Throwable [[garment]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[garment]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .
--------------------------------------------- Result 552 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 517 / 24 / 11 / 552:  55%|█████▌    | 552/1000 [4:11:01<3:23:44, 27.29s/it][Succeeded / Failed / Skipped / Total] 517 / 24 / 11 / 552:  55%|█████▌    | 553/1000 [4:11:04<3:22:57, 27.24s/it][Succeeded / Failed / Skipped / Total] 518 / 24 / 11 / 553:  55%|█████▌    | 553/1000 [4:11:04<3:22:57, 27.24s/it][Succeeded / Failed / Skipped / Total] 518 / 24 / 11 / 553:  55%|█████▌    | 554/1000 [4:11:55<3:22:48, 27.28s/it][Succeeded / Failed / Skipped / Total] 519 / 24 / 11 / 554:  55%|█████▌    | 554/1000 [4:11:55<3:22:48, 27.28s/it][Succeeded / Failed / Skipped / Total] 519 / 24 / 11 / 554:  56%|█████▌    | 555/1000 [4:11:56<3:22:00, 27.24s/it][Succeeded / Failed / Skipped / Total] 520 / 24 / 11 / 555:  56%|█████▌    | 555/1000 [4:11:56<3:22:00, 27.24s/it][Succeeded / Failed / Skipped / Total] 520 / 24 / 11 / 555:  56%|█████▌    | 556/1000 [4:12:40<3:21:46, 27.27s/it][Succeeded / Failed / Skipped / Total] 521 / 24 / 11 / 556:  56%|█████▌    | 556/1000 [4:12:40<3:21:46, 27.27s/it][Succeeded / Failed / Skipped / Total] 521 / 24 / 11 / 556:  56%|█████▌    | 557/1000 [4:13:24<3:21:32, 27.30s/it][Succeeded / Failed / Skipped / Total] 522 / 24 / 11 / 557:  56%|█████▌    | 557/1000 [4:13:24<3:21:32, 27.30s/it][Succeeded / Failed / Skipped / Total] 522 / 24 / 11 / 557:  56%|█████▌    | 558/1000 [4:13:41<3:20:57, 27.28s/it][Succeeded / Failed / Skipped / Total] 523 / 24 / 11 / 558:  56%|█████▌    | 558/1000 [4:13:41<3:20:57, 27.28s/it][Succeeded / Failed / Skipped / Total] 523 / 24 / 11 / 558:  56%|█████▌    | 559/1000 [4:14:20<3:20:39, 27.30s/it]Handles a server error . --> This method is used to handle bienvenido --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onServerError]] ( RequestHeader request , Throwable [[exception]] ) { try { UsefulException usefulException = throwableToUsefulException ( [[exception]] ) ; logServerError ( request , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , usefulException ) ; default : return onDevServerError ( request , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[bienvenido]] ( RequestHeader request , Throwable [[swindlers]] ) { try { UsefulException usefulException = throwableToUsefulException ( [[swindlers]] ) ; logServerError ( request , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , usefulException ) ; default : return onDevServerError ( request , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .
--------------------------------------------- Result 553 ---------------------------------------------
Handle dev error . --> Default behavior for testing --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > onDevServerError ( RequestHeader [[request]] , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , [[exception]] , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .

[[[[Adv]]]]: protected CompletionStage < Result > onDevServerError ( RequestHeader [[apathy]] , UsefulException [[bereavement]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , [[bereavement]] , [[apathy]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .
--------------------------------------------- Result 554 ---------------------------------------------
Creates a new JPAConfig instance . --> Package private for testing --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[from]] ( Map < String , String > [[map]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > [[persistenceUnits]] = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : [[map]] . entrySet ( ) ) { [[persistenceUnits]] . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( [[persistenceUnits]] . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .

[[[[Adv]]]]: public static JPAConfig [[snapped]] ( Map < String , String > [[akhil]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > [[endorsed]] = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : [[akhil]] . entrySet ( ) ) { [[endorsed]] . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( [[endorsed]] . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .
--------------------------------------------- Result 555 ---------------------------------------------
Creates a BuildDocHandler from a directory and a jar file . --> Build doc handler . --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String [[base]] ) { return fromDirectoryAndJar ( directory , jarFile , [[base]] , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String [[hundert]] ) { return fromDirectoryAndJar ( directory , jarFile , [[hundert]] , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository
--------------------------------------------- Result 556 ---------------------------------------------
Handle unauthorized action . --> Display the unauthorized view --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onForbidden]] ( RequestHeader [[request]] , String message ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .

[[[[Adv]]]]: protected CompletionStage < Result > [[grandview]] ( RequestHeader [[tomar]] , String message ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( [[tomar]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .
--------------------------------------------- Result 557 ---------------------------------------------
Creates a BuildDocHandler from the given resources . --> throws UnsupportedOperationException --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler fromResources ( File [ ] files , String [ ] [[baseDirs]] ) throws IOException { assert ( files . length == [[baseDirs]] . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int [[i]] = 0 ; [[i]] < files . length ; [[i]] ++ ) { File file = files [ [[i]] ] ; String baseDir = [[baseDirs]] [ [[i]] ] ; if ( file . isDirectory ( ) ) { repositories [ [[i]] ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .

[[[[Adv]]]]: public static BuildDocHandler fromResources ( File [ ] files , String [ ] [[politicized]] ) throws IOException { assert ( files . length == [[politicized]] . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int [[burdette]] = 0 ; [[burdette]] < files . length ; [[burdette]] ++ ) { File file = files [ [[burdette]] ] ; String baseDir = [[politicized]] [ [[burdette]] ] ; if ( file . isDirectory ( ) ) { repositories [ [[burdette]] ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .
--------------------------------------------- Result 558 ---------------------------------------------
Consumes the data . --> Completes badshahahhshah --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < ByteString > [[consumeData]] ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
[[[[Nl]]]]: Consumes the data .

[[[[Adv]]]]: public CompletionStage < ByteString > [[badshah]] ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
[[[[Nl]]]]: Consumes the data .
[Succeeded / Failed / Skipped / Total] 524 / 24 / 11 / 559:  56%|█████▌    | 559/1000 [4:14:20<3:20:39, 27.30s/it][Succeeded / Failed / Skipped / Total] 524 / 24 / 11 / 559:  56%|█████▌    | 560/1000 [4:14:34<3:20:01, 27.28s/it][Succeeded / Failed / Skipped / Total] 525 / 24 / 11 / 560:  56%|█████▌    | 560/1000 [4:14:34<3:20:01, 27.28s/it][Succeeded / Failed / Skipped / Total] 525 / 24 / 11 / 560:  56%|█████▌    | 561/1000 [4:14:53<3:19:27, 27.26s/it][Succeeded / Failed / Skipped / Total] 526 / 24 / 11 / 561:  56%|█████▌    | 561/1000 [4:14:53<3:19:27, 27.26s/it][Succeeded / Failed / Skipped / Total] 526 / 24 / 11 / 561:  56%|█████▌    | 562/1000 [4:15:14<3:18:55, 27.25s/it][Succeeded / Failed / Skipped / Total] 527 / 24 / 11 / 562:  56%|█████▌    | 562/1000 [4:15:14<3:18:55, 27.25s/it][Succeeded / Failed / Skipped / Total] 527 / 24 / 11 / 562:  56%|█████▋    | 563/1000 [4:15:20<3:18:11, 27.21s/it][Succeeded / Failed / Skipped / Total] 528 / 24 / 11 / 563:  56%|█████▋    | 563/1000 [4:15:20<3:18:11, 27.21s/it][Succeeded / Failed / Skipped / Total] 528 / 24 / 11 / 563:  56%|█████▋    | 564/1000 [4:15:34<3:17:34, 27.19s/it][Succeeded / Failed / Skipped / Total] 529 / 24 / 11 / 564:  56%|█████▋    | 564/1000 [4:15:34<3:17:34, 27.19s/it][Succeeded / Failed / Skipped / Total] 529 / 24 / 11 / 564:  56%|█████▋    | 565/1000 [4:15:53<3:17:00, 27.17s/it][Succeeded / Failed / Skipped / Total] 530 / 24 / 11 / 565:  56%|█████▋    | 565/1000 [4:15:53<3:17:00, 27.17s/it][Succeeded / Failed / Skipped / Total] 530 / 24 / 11 / 565:  57%|█████▋    | 566/1000 [4:15:53<3:16:12, 27.13s/it][Succeeded / Failed / Skipped / Total] 531 / 24 / 11 / 566:  57%|█████▋    | 566/1000 [4:15:53<3:16:12, 27.13s/it][Succeeded / Failed / Skipped / Total] 531 / 24 / 11 / 566:  57%|█████▋    | 567/1000 [4:15:53<3:15:24, 27.08s/it][Succeeded / Failed / Skipped / Total] 531 / 24 / 12 / 567:  57%|█████▋    | 567/1000 [4:15:53<3:15:24, 27.08s/it][Succeeded / Failed / Skipped / Total] 531 / 24 / 12 / 567:  57%|█████▋    | 568/1000 [4:16:01<3:14:43, 27.05s/it][Succeeded / Failed / Skipped / Total] 532 / 24 / 12 / 568:  57%|█████▋    | 568/1000 [4:16:01<3:14:43, 27.05s/it][Succeeded / Failed / Skipped / Total] 532 / 24 / 12 / 568:  57%|█████▋    | 569/1000 [4:16:11<3:14:03, 27.02s/it][Succeeded / Failed / Skipped / Total] 533 / 24 / 12 / 569:  57%|█████▋    | 569/1000 [4:16:11<3:14:03, 27.02s/it][Succeeded / Failed / Skipped / Total] 533 / 24 / 12 / 569:  57%|█████▋    | 570/1000 [4:16:12<3:13:16, 26.97s/it]--------------------------------------------- Result 559 ---------------------------------------------
Creates a documentation handler from a directory . --> Creates alakazamz handler --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectory]] ( File [[directory]] ) { FileRepository repo = new FilesystemRepository ( [[directory]] ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .

[[[[Adv]]]]: public static BuildDocHandler [[alakazam]] ( File [[pudding]] ) { FileRepository repo = new FilesystemRepository ( [[pudding]] ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .
--------------------------------------------- Result 560 ---------------------------------------------
Sends an error to the server . --> helper method to render the bridesmaid --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onProdServerError]] ( RequestHeader request , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[exception]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .

[[[[Adv]]]]: protected CompletionStage < Result > [[bridesmaid]] ( RequestHeader request , UsefulException [[hercule]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[hercule]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .
--------------------------------------------- Result 561 ---------------------------------------------
Create a Result instance with the given status code and content . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , JsonNode content ) { return [[status]] ( [[status]] , content , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .

[[[[Adv]]]]: public static Result [[genovese]] ( int status , JsonNode content ) { return [[genovese]] ( [[genovese]] , content , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .
--------------------------------------------- Result 562 ---------------------------------------------
Sends response with status code . --> Saves acessor request to the server --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , JsonNode content , JsonEncoding encoding ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return [[status]] ( [[status]] ) . sendJson ( content , encoding ) ; }
[[[[Nl]]]]: Generates a simple result with json content .

[[[[Adv]]]]: public static Result [[fervor]] ( int status , JsonNode content , JsonEncoding encoding ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return [[fervor]] ( [[fervor]] ) . sendJson ( content , encoding ) ; }
[[[[Nl]]]]: Generates a simple result with json content .
--------------------------------------------- Result 563 ---------------------------------------------
Create an HttpEntity from a string . --> Convenience method for building HttpEntity --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromString]] ( String content , String charset ) { return new Strict ( ByteString . fromString ( content , charset ) , Optional . of ( "text/plain; charset=" + charset ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .

[[[[Adv]]]]: public static final HttpEntity [[heaviness]] ( String content , String charset ) { return new Strict ( ByteString . fromString ( content , charset ) , Optional . of ( "text/plain; charset=" + charset ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .
--------------------------------------------- Result 564 ---------------------------------------------
Creates a Status with HTTP status code . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int status , byte [ ] [[content]] ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( [[content]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .

[[[[Adv]]]]: public static Result status ( int status , byte [ ] [[chastised]] ) { if ( [[chastised]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( [[chastised]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .
--------------------------------------------- Result 565 ---------------------------------------------
Creates a chunked entity . --> Creates an HttpEntity --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity chunked ( Source < ByteString , ? > data , Optional < String > [[contentType]] ) { return new Chunked ( data . map ( HttpChunk . Chunk :: new ) , [[contentType]] ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .

[[[[Adv]]]]: public static final HttpEntity chunked ( Source < ByteString , ? > data , Optional < String > [[fermented]] ) { return new Chunked ( data . map ( HttpChunk . Chunk :: new ) , [[fermented]] ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .
--------------------------------------------- Result 566 ---------------------------------------------
Returns a result for a file . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int status , File [[content]] ) { return status ( status , [[content]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .

[[[[Adv]]]]: public static Result status ( int status , File [[command]] ) { return status ( status , [[command]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .
--------------------------------------------- Result 567 ---------------------------------------------
Get user by id --> [[[SKIPPED]]]

[[[[Adv]]]]: private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
[[[[Nl]]]]: designed to be lightweight operation
--------------------------------------------- Result 568 ---------------------------------------------
Sends an input stream to the response . --> Convenience method to send an input stream --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int [[status]] , InputStream content , long contentLength ) { return status ( status ) . sendInputStream ( content , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .

[[[[Adv]]]]: public static Result status ( int [[creche]] , InputStream content , long contentLength ) { return status ( status ) . sendInputStream ( content , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .
--------------------------------------------- Result 569 ---------------------------------------------
Returns a unique call . --> Perform an angina call --> Socre: 1.0

[[[[Adv]]]]: public Call [[unique]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .

[[[[Adv]]]]: public Call [[angina]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .
--------------------------------------------- Result 570 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 534 / 24 / 12 / 570:  57%|█████▋    | 570/1000 [4:16:12<3:13:16, 26.97s/it][Succeeded / Failed / Skipped / Total] 534 / 24 / 12 / 570:  57%|█████▋    | 571/1000 [4:16:17<3:12:32, 26.93s/it][Succeeded / Failed / Skipped / Total] 535 / 24 / 12 / 571:  57%|█████▋    | 571/1000 [4:16:17<3:12:32, 26.93s/it][Succeeded / Failed / Skipped / Total] 535 / 24 / 12 / 571:  57%|█████▋    | 572/1000 [4:16:28<3:11:54, 26.90s/it][Succeeded / Failed / Skipped / Total] 536 / 24 / 12 / 572:  57%|█████▋    | 572/1000 [4:16:28<3:11:54, 26.90s/it][Succeeded / Failed / Skipped / Total] 536 / 24 / 12 / 572:  57%|█████▋    | 573/1000 [4:16:40<3:11:16, 26.88s/it][Succeeded / Failed / Skipped / Total] 537 / 24 / 12 / 573:  57%|█████▋    | 573/1000 [4:16:40<3:11:16, 26.88s/it][Succeeded / Failed / Skipped / Total] 537 / 24 / 12 / 573:  57%|█████▋    | 574/1000 [4:16:48<3:10:35, 26.84s/it][Succeeded / Failed / Skipped / Total] 538 / 24 / 12 / 574:  57%|█████▋    | 574/1000 [4:16:48<3:10:35, 26.84s/it][Succeeded / Failed / Skipped / Total] 538 / 24 / 12 / 574:  57%|█████▊    | 575/1000 [4:17:06<3:10:01, 26.83s/it][Succeeded / Failed / Skipped / Total] 539 / 24 / 12 / 575:  57%|█████▊    | 575/1000 [4:17:06<3:10:01, 26.83s/it][Succeeded / Failed / Skipped / Total] 539 / 24 / 12 / 575:  58%|█████▊    | 576/1000 [4:17:24<3:09:29, 26.81s/it][Succeeded / Failed / Skipped / Total] 540 / 24 / 12 / 576:  58%|█████▊    | 576/1000 [4:17:24<3:09:29, 26.81s/it][Succeeded / Failed / Skipped / Total] 540 / 24 / 12 / 576:  58%|█████▊    | 577/1000 [4:17:25<3:08:43, 26.77s/it][Succeeded / Failed / Skipped / Total] 540 / 25 / 12 / 577:  58%|█████▊    | 577/1000 [4:17:25<3:08:43, 26.77s/it][Succeeded / Failed / Skipped / Total] 540 / 25 / 12 / 577:  58%|█████▊    | 578/1000 [4:17:54<3:08:17, 26.77s/it]Selects the preferred languages . --> lambala --> Socre: 1.0

[[[[Adv]]]]: public Lang [[preferred]] ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .

[[[[Adv]]]]: public Lang [[flambé]] ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .
--------------------------------------------- Result 571 ---------------------------------------------
Creates a documentation handler for a directory and a jar file . --> creates BuildDoc handler --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File [[directory]] , JarFile jarFile , String [[base]] , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( [[directory]] ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( [[base]] ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File [[biker]] , JarFile jarFile , String [[mí]] , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( [[biker]] ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( [[mí]] ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 572 ---------------------------------------------
Create HttpEntity from content . --> Liefert ein HttpEntity --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromContent]] ( Content content , String charset ) { String [[body]] ; if ( content instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .

[[[[Adv]]]]: public static final HttpEntity [[frak]] ( Content content , String charset ) { String [[rathe]] ; if ( content instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .
--------------------------------------------- Result 573 ---------------------------------------------
Returns a function that invokes the given connection runnable . --> wraps connection runnable --> Socre: 1.0

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > connectionFunction ( final ConnectionRunnable [[block]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { [[block]] . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > connectionFunction ( final ConnectionRunnable [[arrowsmith]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { [[arrowsmith]] . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .
--------------------------------------------- Result 574 ---------------------------------------------
Returns a connection function that executes the given connection callable . --> wraps connection callable --> Socre: 1.0

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[block]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection connection ) { try { return [[block]] . call ( connection ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[bir]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection connection ) { try { return [[bir]] . call ( connection ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .
--------------------------------------------- Result 575 ---------------------------------------------
Returns the JSON representation of the given object . --> Generate phi node --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[toJson]] ( final Object data ) { try { return mapper ( ) . valueToTree ( data ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .

[[[[Adv]]]]: public static JsonNode [[philippa]] ( final Object data ) { try { return mapper ( ) . valueToTree ( data ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .
--------------------------------------------- Result 576 ---------------------------------------------
Deserialize a JsonNode into a Java object . --> Construct an instance from JSON . --> Socre: 1.0

[[[[Adv]]]]: public static < [[A]] > [[A]] fromJson ( JsonNode json , Class < [[A]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value

[[[[Adv]]]]: public static < [[anally]] > [[anally]] fromJson ( JsonNode json , Class < [[anally]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value
--------------------------------------------- Result 577 ---------------------------------------------
Gets the matching method . --> [[[FAILED]]]

[[[[Adv]]]]: public static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .

[[[[Adv]]]]: public static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .
--------------------------------------------- Result 578 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 541 / 25 / 12 / 578:  58%|█████▊    | 578/1000 [4:17:54<3:08:17, 26.77s/it][Succeeded / Failed / Skipped / Total] 541 / 25 / 12 / 578:  58%|█████▊    | 579/1000 [4:18:17<3:07:48, 26.77s/it][Succeeded / Failed / Skipped / Total] 542 / 25 / 12 / 579:  58%|█████▊    | 579/1000 [4:18:17<3:07:48, 26.77s/it][Succeeded / Failed / Skipped / Total] 542 / 25 / 12 / 579:  58%|█████▊    | 580/1000 [4:18:56<3:07:30, 26.79s/it][Succeeded / Failed / Skipped / Total] 543 / 25 / 12 / 580:  58%|█████▊    | 580/1000 [4:18:56<3:07:30, 26.79s/it][Succeeded / Failed / Skipped / Total] 543 / 25 / 12 / 580:  58%|█████▊    | 581/1000 [4:19:31<3:07:09, 26.80s/it][Succeeded / Failed / Skipped / Total] 544 / 25 / 12 / 581:  58%|█████▊    | 581/1000 [4:19:31<3:07:09, 26.80s/it][Succeeded / Failed / Skipped / Total] 544 / 25 / 12 / 581:  58%|█████▊    | 582/1000 [4:19:36<3:06:27, 26.76s/it][Succeeded / Failed / Skipped / Total] 545 / 25 / 12 / 582:  58%|█████▊    | 582/1000 [4:19:36<3:06:27, 26.76s/it][Succeeded / Failed / Skipped / Total] 545 / 25 / 12 / 582:  58%|█████▊    | 583/1000 [4:19:37<3:05:42, 26.72s/it][Succeeded / Failed / Skipped / Total] 546 / 25 / 12 / 583:  58%|█████▊    | 583/1000 [4:19:37<3:05:42, 26.72s/it][Succeeded / Failed / Skipped / Total] 546 / 25 / 12 / 583:  58%|█████▊    | 584/1000 [4:19:52<3:05:06, 26.70s/it][Succeeded / Failed / Skipped / Total] 547 / 25 / 12 / 584:  58%|█████▊    | 584/1000 [4:19:52<3:05:06, 26.70s/it][Succeeded / Failed / Skipped / Total] 547 / 25 / 12 / 584:  58%|█████▊    | 585/1000 [4:20:03<3:04:28, 26.67s/it][Succeeded / Failed / Skipped / Total] 548 / 25 / 12 / 585:  58%|█████▊    | 585/1000 [4:20:03<3:04:29, 26.67s/it][Succeeded / Failed / Skipped / Total] 548 / 25 / 12 / 585:  59%|█████▊    | 586/1000 [4:20:11<3:03:49, 26.64s/it][Succeeded / Failed / Skipped / Total] 549 / 25 / 12 / 586:  59%|█████▊    | 586/1000 [4:20:11<3:03:49, 26.64s/it][Succeeded / Failed / Skipped / Total] 549 / 25 / 12 / 586:  59%|█████▊    | 587/1000 [4:20:22<3:03:11, 26.61s/it][Succeeded / Failed / Skipped / Total] 550 / 25 / 12 / 587:  59%|█████▊    | 587/1000 [4:20:22<3:03:11, 26.61s/it][Succeeded / Failed / Skipped / Total] 550 / 25 / 12 / 587:  59%|█████▉    | 588/1000 [4:20:41<3:02:39, 26.60s/it]Create a documentation handler from a jar file . --> make antichist --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromJar]] ( JarFile [[jarFile]] , String base ) { FileRepository [[repo]] = new JarRepository ( [[jarFile]] , Option . apply ( base ) ) ; return new DocumentationHandler ( [[repo]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[antichrist]] ( JarFile [[bébé]] , String base ) { FileRepository [[lymphatic]] = new JarRepository ( [[bébé]] , Option . apply ( base ) ) ; return new DocumentationHandler ( [[lymphatic]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 579 ---------------------------------------------
Parses a string into a JsonNode . --> Parse two strings --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode parse ( String [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode parse ( String [[both]] ) { try { return mapper ( ) . readTree ( [[both]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .
--------------------------------------------- Result 580 ---------------------------------------------
Parse input stream . --> Create limos from input stream --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[parse]] ( java . io . InputStream src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[limos]] ( java . io . InputStream src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .
--------------------------------------------- Result 581 ---------------------------------------------
Creates a new call with the specified fragment . --> Deadhead method --> Socre: 1.0

[[[[Adv]]]]: public Call [[withFragment]] ( String [[fragment]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[fragment]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .

[[[[Adv]]]]: public Call [[deadhead]] ( String [[chaffee]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[chaffee]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .
--------------------------------------------- Result 582 ---------------------------------------------
Returns the web socket URL for the given request . --> Creates a boyce --> Socre: 1.0

[[[[Adv]]]]: public String [[webSocketURL]] ( Http . Request [[request]] ) { return [[webSocketURL]] ( [[request]] . secure ( ) , [[request]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .

[[[[Adv]]]]: public String [[boyce]] ( Http . Request [[rastogi]] ) { return [[boyce]] ( [[rastogi]] . secure ( ) , [[rastogi]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .
--------------------------------------------- Result 583 ---------------------------------------------
Returns the absolute URL for the given request . --> Creates the alms message for acknowledge --> Socre: 1.0

[[[[Adv]]]]: public String [[absoluteURL]] ( Http . Request [[request]] ) { return [[absoluteURL]] ( [[request]] . secure ( ) , [[request]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .

[[[[Adv]]]]: public String [[alms]] ( Http . Request [[childishness]] ) { return [[alms]] ( [[childishness]] . secure ( ) , [[childishness]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .
--------------------------------------------- Result 584 ---------------------------------------------
Creates a tuple of displayable constraints . --> Extract the label and attributes --> Socre: 1.0

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[displayableConstraint]] ( ConstraintDescriptor < ? > constraint ) { final Display displayAnnotation = constraint . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( displayAnnotation . name ( ) , Collections . unmodifiableList ( Stream . of ( displayAnnotation . attributes ( ) ) . map ( attr -> constraint . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[elina]] ( ConstraintDescriptor < ? > constraint ) { final Display displayAnnotation = constraint . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( displayAnnotation . name ( ) , Collections . unmodifiableList ( Stream . of ( displayAnnotation . attributes ( ) ) . map ( attr -> constraint . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .
--------------------------------------------- Result 585 ---------------------------------------------
Creates a new server for the given Router --> Start serving requests --> Socre: 1.0

[[[[Adv]]]]: public static Server [[forRouter]] ( Mode [[mode]] , int port , Function < BuiltInComponents , Router > block ) { return new Builder ( ) . [[mode]] ( [[mode]] ) . http ( port ) . build ( block ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .

[[[[Adv]]]]: public static Server [[durst]] ( Mode [[cites]] , int port , Function < BuiltInComponents , Router > block ) { return new Builder ( ) . [[cites]] ( [[cites]] ) . http ( port ) . build ( block ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .
--------------------------------------------- Result 586 ---------------------------------------------
Parses cron string . --> Parse the given string --> Socre: 1.0

[[[[Adv]]]]: public static Date parseCRONExpression ( String [[cron]] ) { try { return new CronExpression ( [[cron]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .

[[[[Adv]]]]: public static Date parseCRONExpression ( String [[laundering]] ) { try { return new CronExpression ( [[laundering]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[laundering]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .
--------------------------------------------- Result 587 ---------------------------------------------
Calculates the next interval for a cron expression --> Get cron interval --> Socre: 1.0

[[[[Adv]]]]: public static long cronInterval ( String [[cron]] , Date date ) { try { return new CronExpression ( [[cron]] ) . getNextInterval ( date ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .

[[[[Adv]]]]: public static long cronInterval ( String [[zacharias]] , Date date ) { try { return new CronExpression ( [[zacharias]] ) . getNextInterval ( date ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[zacharias]] , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .
--------------------------------------------- Result 588 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 551 / 25 / 12 / 588:  59%|█████▉    | 588/1000 [4:20:41<3:02:39, 26.60s/it][Succeeded / Failed / Skipped / Total] 551 / 25 / 12 / 588:  59%|█████▉    | 589/1000 [4:20:59<3:02:07, 26.59s/it][Succeeded / Failed / Skipped / Total] 552 / 25 / 12 / 589:  59%|█████▉    | 589/1000 [4:20:59<3:02:07, 26.59s/it][Succeeded / Failed / Skipped / Total] 552 / 25 / 12 / 589:  59%|█████▉    | 590/1000 [4:20:59<3:01:22, 26.54s/it][Succeeded / Failed / Skipped / Total] 553 / 25 / 12 / 590:  59%|█████▉    | 590/1000 [4:20:59<3:01:22, 26.54s/it][Succeeded / Failed / Skipped / Total] 553 / 25 / 12 / 590:  59%|█████▉    | 591/1000 [4:21:14<3:00:47, 26.52s/it][Succeeded / Failed / Skipped / Total] 554 / 25 / 12 / 591:  59%|█████▉    | 591/1000 [4:21:14<3:00:47, 26.52s/it][Succeeded / Failed / Skipped / Total] 554 / 25 / 12 / 591:  59%|█████▉    | 592/1000 [4:21:16<3:00:04, 26.48s/it][Succeeded / Failed / Skipped / Total] 555 / 25 / 12 / 592:  59%|█████▉    | 592/1000 [4:21:16<3:00:04, 26.48s/it][Succeeded / Failed / Skipped / Total] 555 / 25 / 12 / 592:  59%|█████▉    | 593/1000 [4:21:17<2:59:20, 26.44s/it][Succeeded / Failed / Skipped / Total] 556 / 25 / 12 / 593:  59%|█████▉    | 593/1000 [4:21:17<2:59:20, 26.44s/it][Succeeded / Failed / Skipped / Total] 556 / 25 / 12 / 593:  59%|█████▉    | 594/1000 [4:21:36<2:58:48, 26.42s/it][Succeeded / Failed / Skipped / Total] 557 / 25 / 12 / 594:  59%|█████▉    | 594/1000 [4:21:36<2:58:48, 26.42s/it][Succeeded / Failed / Skipped / Total] 557 / 25 / 12 / 594:  60%|█████▉    | 595/1000 [4:21:38<2:58:05, 26.38s/it][Succeeded / Failed / Skipped / Total] 558 / 25 / 12 / 595:  60%|█████▉    | 595/1000 [4:21:38<2:58:05, 26.38s/it][Succeeded / Failed / Skipped / Total] 558 / 25 / 12 / 595:  60%|█████▉    | 596/1000 [4:21:55<2:57:32, 26.37s/it][Succeeded / Failed / Skipped / Total] 559 / 25 / 12 / 596:  60%|█████▉    | 596/1000 [4:21:55<2:57:32, 26.37s/it][Succeeded / Failed / Skipped / Total] 559 / 25 / 12 / 596:  60%|█████▉    | 597/1000 [4:21:57<2:56:49, 26.33s/it][Succeeded / Failed / Skipped / Total] 560 / 25 / 12 / 597:  60%|█████▉    | 597/1000 [4:21:57<2:56:49, 26.33s/it][Succeeded / Failed / Skipped / Total] 560 / 25 / 12 / 597:  60%|█████▉    | 598/1000 [4:22:12<2:56:16, 26.31s/it][Succeeded / Failed / Skipped / Total] 561 / 25 / 12 / 598:  60%|█████▉    | 598/1000 [4:22:12<2:56:16, 26.31s/it][Succeeded / Failed / Skipped / Total] 561 / 25 / 12 / 598:  60%|█████▉    | 599/1000 [4:22:16<2:55:34, 26.27s/it]Configures the Guice application with the given context . --> Overloaded by Guice --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[builder]] ( ApplicationLoader . Context context ) { return initialBuilder . in ( context . environment ( ) ) . loadConfig ( context . initialConfig ( ) ) . overrides ( overrides ( context ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .

[[[[Adv]]]]: public GuiceApplicationBuilder [[baldy]] ( ApplicationLoader . Context context ) { return initialBuilder . in ( context . environment ( ) ) . loadConfig ( context . initialConfig ( ) ) . overrides ( overrides ( context ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .
--------------------------------------------- Result 589 ---------------------------------------------
Render a todo --> Handle todo todo --> Socre: 1.0

[[[[Adv]]]]: public static Result [[TODO]] ( Request request ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( request . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .

[[[[Adv]]]]: public static Result [[BET]] ( Request request ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( request . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .
--------------------------------------------- Result 590 ---------------------------------------------
Timeout the given completion stage . --> Timeout after timeout period --> Socre: 1.0

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > timeout ( final CompletionStage < A > stage , final long amount , final TimeUnit unit ) { requireNonNull ( stage , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration [[duration]] = FiniteDuration . apply ( amount , unit ) ; return toJava ( delegate . timeout ( [[duration]] , Scala . asScalaWithFuture ( ( ) -> stage ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > timeout ( final CompletionStage < A > stage , final long amount , final TimeUnit unit ) { requireNonNull ( stage , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration [[sweetheart]] = FiniteDuration . apply ( amount , unit ) ; return toJava ( delegate . timeout ( [[sweetheart]] , Scala . asScalaWithFuture ( ( ) -> stage ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .
--------------------------------------------- Result 591 ---------------------------------------------
Relative path to target path --> Generate corsage --> Socre: 1.0

[[[[Adv]]]]: public static String [[relative]] ( String startPath , String [[targetPath]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .

[[[[Adv]]]]: public static String [[corsage]] ( String startPath , String [[abi]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .
--------------------------------------------- Result 592 ---------------------------------------------
Flash to request --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void flash ( String key , String [[value]] ) { flash ( ) . put ( key , [[value]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .

[[[[Adv]]]]: @ Deprecated public static void flash ( String key , String [[appropriately]] ) { flash ( ) . put ( key , [[appropriately]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .
--------------------------------------------- Result 593 ---------------------------------------------
Store a session into the session --> Add corruption to storage --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[session]] ( String key , String value ) { [[session]] ( ) . put ( key , value ) ; }
[[[[Nl]]]]: Puts a new value into the current session .

[[[[Adv]]]]: @ Deprecated public static void [[corruption]] ( String key , String value ) { [[corruption]] ( ) . put ( key , value ) ; }
[[[[Nl]]]]: Puts a new value into the current session .
--------------------------------------------- Result 594 ---------------------------------------------
Converts this binding to a Java binding . --> Convenient wrapper for cropping --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .

[[[[Adv]]]]: public Binding < T > [[crowe]] ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .
--------------------------------------------- Result 595 ---------------------------------------------
Returns a binding key for the given annotation . --> Liefert einen nachgegebenen einzelgegegebenen nachgebenen einzelgegebenen nachgegebenen nachages --> Socre: 1.0

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .

[[[[Adv]]]]: public < A [[pré]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .
--------------------------------------------- Result 596 ---------------------------------------------
Converts this binding to a Java binding . --> Convenience wrapper for setting a campaign --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > to ( final Provider < ? extends T > [[provider]] ) { return underlying . to ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .

[[[[Adv]]]]: public Binding < T > to ( final Provider < ? extends T > [[campanella]] ) { return underlying . to ( [[campanella]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .
--------------------------------------------- Result 597 ---------------------------------------------
Converts this binding to a Java Binding . --> Makes a map containing all possible formulas --> Socre: 1.0

[[[[Adv]]]]: public < A [[extends]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .

[[[[Adv]]]]: public < A [[cabrón]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .
--------------------------------------------- Result 598 ---------------------------------------------
Returns a binding key for the given instance . --> Deserialization --> Socre: 1.0

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .

[[[[Adv]]]]: public < A [[maría]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .
--------------------------------------------- Result 599 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 562 / 25 / 12 / 599:  60%|█████▉    | 599/1000 [4:22:16<2:55:34, 26.27s/it][Succeeded / Failed / Skipped / Total] 562 / 25 / 12 / 599:  60%|██████    | 600/1000 [4:22:30<2:55:00, 26.25s/it][Succeeded / Failed / Skipped / Total] 563 / 25 / 12 / 600:  60%|██████    | 600/1000 [4:22:30<2:55:00, 26.25s/it][Succeeded / Failed / Skipped / Total] 563 / 25 / 12 / 600:  60%|██████    | 601/1000 [4:22:38<2:54:21, 26.22s/it][Succeeded / Failed / Skipped / Total] 564 / 25 / 12 / 601:  60%|██████    | 601/1000 [4:22:38<2:54:21, 26.22s/it][Succeeded / Failed / Skipped / Total] 564 / 25 / 12 / 601:  60%|██████    | 602/1000 [4:23:09<2:53:58, 26.23s/it][Succeeded / Failed / Skipped / Total] 565 / 25 / 12 / 602:  60%|██████    | 602/1000 [4:23:09<2:53:58, 26.23s/it][Succeeded / Failed / Skipped / Total] 565 / 25 / 12 / 602:  60%|██████    | 603/1000 [4:23:09<2:53:15, 26.19s/it][Succeeded / Failed / Skipped / Total] 566 / 25 / 12 / 603:  60%|██████    | 603/1000 [4:23:09<2:53:15, 26.19s/it][Succeeded / Failed / Skipped / Total] 566 / 25 / 12 / 603:  60%|██████    | 604/1000 [4:24:10<2:53:12, 26.24s/it][Succeeded / Failed / Skipped / Total] 567 / 25 / 12 / 604:  60%|██████    | 604/1000 [4:24:10<2:53:12, 26.24s/it][Succeeded / Failed / Skipped / Total] 567 / 25 / 12 / 604:  60%|██████    | 605/1000 [4:24:17<2:52:33, 26.21s/it][Succeeded / Failed / Skipped / Total] 568 / 25 / 12 / 605:  60%|██████    | 605/1000 [4:24:17<2:52:33, 26.21s/it][Succeeded / Failed / Skipped / Total] 568 / 25 / 12 / 605:  61%|██████    | 606/1000 [4:24:31<2:51:59, 26.19s/it]Converts this binding to a Java type . --> Convenience method for conversion --> Socre: 1.0

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > toProvider ( final Class < P > [[provider]] ) { return underlying . toProvider ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > toProvider ( final Class < P > [[harpoon]] ) { return underlying . toProvider ( [[harpoon]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .
--------------------------------------------- Result 600 ---------------------------------------------
Returns a list of available languages . --> Returns a list of available languages --> Socre: 1.0

[[[[Adv]]]]: public static List < Lang > availables ( Application [[app]] ) { play . api . i18n . Langs langs = [[app]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( langs . availables ( ) ) ; return availableLangs . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .

[[[[Adv]]]]: public static List < Lang > availables ( Application [[amplification]] ) { play . api . i18n . Langs langs = [[amplification]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( langs . availables ( ) ) ; return availableLangs . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .
--------------------------------------------- Result 601 ---------------------------------------------
Returns a list of displayable constraints . --> Get all constraint descriptors --> Socre: 1.0

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[displayableConstraint]] ( Set < ConstraintDescriptor < ? > > [[constraints]] ) { return [[constraints]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[displayableConstraint]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[all]] ( Set < ConstraintDescriptor < ? > > [[bleedin]] ) { return [[bleedin]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[all]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .
--------------------------------------------- Result 602 ---------------------------------------------
Converts this binding key to the given key . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > to ( final BindingKey < ? extends T > [[key]] ) { return underlying . to ( [[key]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .

[[[[Adv]]]]: public Binding < T > to ( final BindingKey < ? extends T > [[sorcerer]] ) { return underlying . to ( [[sorcerer]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .
--------------------------------------------- Result 603 ---------------------------------------------
Creates a new EvolutionsReader instance . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader fromMap ( Map < String , List < Evolution > > [[evolutions]] ) { return new SimpleEvolutionsReader ( [[evolutions]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .

[[[[Adv]]]]: public static play . api . db . [[salazar]] . EvolutionsReader fromMap ( Map < String , List < Evolution > > [[salazar]] ) { return new SimpleEvolutionsReader ( [[salazar]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .
--------------------------------------------- Result 604 ---------------------------------------------
Gets canonical form . --> also used for testing --> Socre: 1.0

[[[[Adv]]]]: public static String [[canonical]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[canonical]] = new Stack <> ( ) ; for ( String [[comp]] : urlPath ) { if ( [[comp]] . isEmpty ( ) || [[comp]] . equals ( CURRENT_DIR ) ) continue ; if ( ! [[comp]] . equals ( PARENT_DIR ) || ( ! [[canonical]] . empty ( ) && [[canonical]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[canonical]] . push ( [[comp]] ) ; else [[canonical]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[canonical]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .

[[[[Adv]]]]: public static String [[alot]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[alot]] = new Stack <> ( ) ; for ( String [[medicaid]] : urlPath ) { if ( [[medicaid]] . isEmpty ( ) || [[medicaid]] . equals ( CURRENT_DIR ) ) continue ; if ( ! [[medicaid]] . equals ( PARENT_DIR ) || ( ! [[alot]] . empty ( ) && [[alot]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[alot]] . push ( [[medicaid]] ) ; else [[alot]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[alot]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .
--------------------------------------------- Result 605 ---------------------------------------------
Creates an instance of the default evolution reader . --> Methode d uneete --> Socre: 1.0

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader forDefault ( Evolution ... [[evolutions]] ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( [[evolutions]] ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .

[[[[Adv]]]]: public static play . api . db . [[métro]] . EvolutionsReader forDefault ( Evolution ... [[métro]] ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( [[métro]] ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .
--------------------------------------------- Result 606 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 569 / 25 / 12 / 606:  61%|██████    | 606/1000 [4:24:31<2:51:59, 26.19s/it][Succeeded / Failed / Skipped / Total] 569 / 25 / 12 / 606:  61%|██████    | 607/1000 [4:24:52<2:51:29, 26.18s/it][Succeeded / Failed / Skipped / Total] 570 / 25 / 12 / 607:  61%|██████    | 607/1000 [4:24:52<2:51:29, 26.18s/it][Succeeded / Failed / Skipped / Total] 570 / 25 / 12 / 607:  61%|██████    | 608/1000 [4:25:00<2:50:51, 26.15s/it][Succeeded / Failed / Skipped / Total] 571 / 25 / 12 / 608:  61%|██████    | 608/1000 [4:25:00<2:50:51, 26.15s/it][Succeeded / Failed / Skipped / Total] 571 / 25 / 12 / 608:  61%|██████    | 609/1000 [4:25:12<2:50:16, 26.13s/it][Succeeded / Failed / Skipped / Total] 572 / 25 / 12 / 609:  61%|██████    | 609/1000 [4:25:12<2:50:16, 26.13s/it][Succeeded / Failed / Skipped / Total] 572 / 25 / 12 / 609:  61%|██████    | 610/1000 [4:25:19<2:49:38, 26.10s/it][Succeeded / Failed / Skipped / Total] 573 / 25 / 12 / 610:  61%|██████    | 610/1000 [4:25:19<2:49:38, 26.10s/it][Succeeded / Failed / Skipped / Total] 573 / 25 / 12 / 610:  61%|██████    | 611/1000 [4:25:34<2:49:04, 26.08s/it][Succeeded / Failed / Skipped / Total] 574 / 25 / 12 / 611:  61%|██████    | 611/1000 [4:25:34<2:49:04, 26.08s/it][Succeeded / Failed / Skipped / Total] 574 / 25 / 12 / 611:  61%|██████    | 612/1000 [4:25:53<2:48:34, 26.07s/it][Succeeded / Failed / Skipped / Total] 575 / 25 / 12 / 612:  61%|██████    | 612/1000 [4:25:53<2:48:34, 26.07s/it][Succeeded / Failed / Skipped / Total] 575 / 25 / 12 / 612:  61%|██████▏   | 613/1000 [4:26:11<2:48:03, 26.06s/it][Succeeded / Failed / Skipped / Total] 576 / 25 / 12 / 613:  61%|██████▏   | 613/1000 [4:26:11<2:48:03, 26.06s/it][Succeeded / Failed / Skipped / Total] 576 / 25 / 12 / 613:  61%|██████▏   | 614/1000 [4:26:32<2:47:33, 26.05s/it]Creates aahc client . --> Translates all the HttpClient to SeaGlassClient --> Socre: 1.0

[[[[Adv]]]]: public static AhcWSClient [[create]] ( AhcWSClientConfig config , AhcHttpCache [[cache]] , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , [[cache]] , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .

[[[[Adv]]]]: public static AhcWSClient [[métro]] ( AhcWSClientConfig config , AhcHttpCache [[panetta]] , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , [[panetta]] , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .
--------------------------------------------- Result 607 ---------------------------------------------
Load the given modules . --> Loads a Snackable --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder load ( com . google . inject . Module ... [[modules]] ) { return load ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .

[[[[Adv]]]]: public GuiceApplicationBuilder load ( com . google . inject . Module ... [[thwack]] ) { return load ( Guiceable . [[thwack]] ( [[thwack]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .
--------------------------------------------- Result 608 ---------------------------------------------
Configures the application with the given modules . --> Load a set of resources --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder load ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .

[[[[Adv]]]]: public GuiceApplicationBuilder load ( GuiceableModule ... [[cheddar]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[cheddar]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .
--------------------------------------------- Result 609 ---------------------------------------------
Load the given modules . --> Load Jelly application --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder load ( play . api . inject . Module ... [[modules]] ) { return load ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .

[[[[Adv]]]]: public GuiceApplicationBuilder load ( play . api . inject . Module ... [[adulterer]] ) { return load ( Guiceable . [[adulterer]] ( [[adulterer]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .
--------------------------------------------- Result 610 ---------------------------------------------
Loads the application with the given bindings . --> Add freeloader --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Binding < ? > ... bindings ) { return [[load]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .

[[[[Adv]]]]: public GuiceApplicationBuilder [[freeloader]] ( play . api . inject . Binding < ? > ... bindings ) { return [[freeloader]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .
--------------------------------------------- Result 611 ---------------------------------------------
Returns the preferred language for the given application --> generate language for a language --> Socre: 1.0

[[[[Adv]]]]: public static Lang [[preferred]] ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs [[langs]] = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( [[langs]] . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .

[[[[Adv]]]]: public static Lang [[bacterium]] ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs [[demeanour]] = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( [[demeanour]] . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .
--------------------------------------------- Result 612 ---------------------------------------------
Gets the entity manager to use . --> Return Entity Manager --> Socre: 1.0

[[[[Adv]]]]: public EntityManager em ( ) { Deque < EntityManager > ems = this . emStack ( "[[True]]" == "[[True]]" ) ; if ( ems . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return ems . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .

[[[[Adv]]]]: public EntityManager em ( ) { Deque < EntityManager > ems = this . emStack ( "[[Lorry]]" == "[[Lorry]]" ) ; if ( ems . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return ems . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .
--------------------------------------------- Result 613 ---------------------------------------------
Default builder for your application . --> Called when the Guice application is required --> Socre: 1.0

[[[[Adv]]]]: protected GuiceApplicationBuilder [[newBuilder]] ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .

[[[[Adv]]]]: protected GuiceApplicationBuilder [[jaja]] ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .
--------------------------------------------- Result 614 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 577 / 25 / 12 / 614:  61%|██████▏   | 614/1000 [4:26:32<2:47:33, 26.05s/it][Succeeded / Failed / Skipped / Total] 577 / 25 / 12 / 614:  62%|██████▏   | 615/1000 [4:27:12<2:47:16, 26.07s/it][Succeeded / Failed / Skipped / Total] 578 / 25 / 12 / 615:  62%|██████▏   | 615/1000 [4:27:12<2:47:16, 26.07s/it][Succeeded / Failed / Skipped / Total] 578 / 25 / 12 / 615:  62%|██████▏   | 616/1000 [4:27:35<2:46:48, 26.06s/it][Succeeded / Failed / Skipped / Total] 579 / 25 / 12 / 616:  62%|██████▏   | 616/1000 [4:27:35<2:46:48, 26.06s/it][Succeeded / Failed / Skipped / Total] 579 / 25 / 12 / 616:  62%|██████▏   | 617/1000 [4:28:04<2:46:24, 26.07s/it][Succeeded / Failed / Skipped / Total] 580 / 25 / 12 / 617:  62%|██████▏   | 617/1000 [4:28:04<2:46:24, 26.07s/it][Succeeded / Failed / Skipped / Total] 580 / 25 / 12 / 617:  62%|██████▏   | 618/1000 [4:28:25<2:45:55, 26.06s/it][Succeeded / Failed / Skipped / Total] 581 / 25 / 12 / 618:  62%|██████▏   | 618/1000 [4:28:25<2:45:55, 26.06s/it][Succeeded / Failed / Skipped / Total] 581 / 25 / 12 / 618:  62%|██████▏   | 619/1000 [4:29:28<2:45:52, 26.12s/it][Succeeded / Failed / Skipped / Total] 582 / 25 / 12 / 619:  62%|██████▏   | 619/1000 [4:29:28<2:45:52, 26.12s/it][Succeeded / Failed / Skipped / Total] 582 / 25 / 12 / 619:  62%|██████▏   | 620/1000 [4:29:47<2:45:21, 26.11s/it][Succeeded / Failed / Skipped / Total] 583 / 25 / 12 / 620:  62%|██████▏   | 620/1000 [4:29:47<2:45:21, 26.11s/it][Succeeded / Failed / Skipped / Total] 583 / 25 / 12 / 620:  62%|██████▏   | 621/1000 [4:30:29<2:45:05, 26.13s/it]Load a config loader --> Attaches a Guice application with an environment --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[withConfigLoader]] ( Function < Environment , Config > [[load]] ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( [[load]] . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[appropriately]] ( Function < Environment , Config > [[accommodating]] ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( [[accommodating]] . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 615 ---------------------------------------------
Encode a cookie . --> Excludes trailing separators --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; [[encode]] ( buf , cookie ) ; return stripTrailingSeparator ( buf ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .

[[[[Adv]]]]: public String [[exorcist]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; [[exorcist]] ( buf , cookie ) ; return stripTrailingSeparator ( buf ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .
--------------------------------------------- Result 616 ---------------------------------------------
Disconnects a flow using a fan operator . --> Disconnects from vertices --> Socre: 1.0

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < FlowIn , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > [[flow]] ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < FlowIn , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > [[anorexic]] ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .
--------------------------------------------- Result 617 ---------------------------------------------
Provides a flow using a splitter . --> Disallow pullover from pullover --> Socre: 1.0

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Function < In , F . Either < FlowIn , Out > > [[splitter]] , Flow < FlowIn , Out , ? > flow ) { return bypassWith ( Flow . < In > create ( ) . map ( [[splitter]] :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Function < In , F . Either < FlowIn , Out > > [[pullover]] , Flow < FlowIn , Out , ? > flow ) { return bypassWith ( Flow . < In > create ( ) . map ( [[pullover]] :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .
--------------------------------------------- Result 618 ---------------------------------------------
Convert error arguments to default message source . --> Remove default message source resolvable --> Socre: 1.0

[[[[Adv]]]]: private List < Object > [[convertErrorArguments]] ( Object [ ] arguments ) { if ( arguments == null ) { return Collections . emptyList ( ) ; } List < Object > converted = Arrays . stream ( arguments ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( converted ) ; }
[[[[Nl]]]]: Convert the error arguments .

[[[[Adv]]]]: private List < Object > [[kenny]] ( Object [ ] arguments ) { if ( arguments == null ) { return Collections . emptyList ( ) ; } List < Object > converted = Arrays . stream ( arguments ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( converted ) ; }
[[[[Nl]]]]: Convert the error arguments .
--------------------------------------------- Result 619 ---------------------------------------------
Gets the current entity manager stack . --> returns a list of entity managers --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > emStack ( boolean [[threadLocalFallback]] ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > [[ems]] = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , [[ems]] ) ; return [[ems]] ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > emStack ( boolean [[borgia]] ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > [[brigadier]] = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , [[brigadier]] ) ; return [[brigadier]] ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .
--------------------------------------------- Result 620 ---------------------------------------------
Gets global errors . --> Get the bleh result --> Socre: 1.0

[[[[Adv]]]]: public List < ValidationError > [[globalErrors]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .

[[[[Adv]]]]: public List < ValidationError > [[bleh]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .
--------------------------------------------- Result 621 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 584 / 25 / 12 / 621:  62%|██████▏   | 621/1000 [4:30:29<2:45:05, 26.13s/it][Succeeded / Failed / Skipped / Total] 584 / 25 / 12 / 621:  62%|██████▏   | 622/1000 [4:30:48<2:44:34, 26.12s/it][Succeeded / Failed / Skipped / Total] 585 / 25 / 12 / 622:  62%|██████▏   | 622/1000 [4:30:48<2:44:34, 26.12s/it][Succeeded / Failed / Skipped / Total] 585 / 25 / 12 / 622:  62%|██████▏   | 623/1000 [4:31:02<2:44:01, 26.10s/it][Succeeded / Failed / Skipped / Total] 586 / 25 / 12 / 623:  62%|██████▏   | 623/1000 [4:31:02<2:44:01, 26.10s/it][Succeeded / Failed / Skipped / Total] 586 / 25 / 12 / 623:  62%|██████▏   | 624/1000 [4:31:22<2:43:31, 26.09s/it][Succeeded / Failed / Skipped / Total] 587 / 25 / 12 / 624:  62%|██████▏   | 624/1000 [4:31:22<2:43:31, 26.09s/it][Succeeded / Failed / Skipped / Total] 587 / 25 / 12 / 624:  62%|██████▎   | 625/1000 [4:31:23<2:42:50, 26.05s/it][Succeeded / Failed / Skipped / Total] 588 / 25 / 12 / 625:  62%|██████▎   | 625/1000 [4:31:23<2:42:50, 26.05s/it][Succeeded / Failed / Skipped / Total] 588 / 25 / 12 / 625:  63%|██████▎   | 626/1000 [4:31:40<2:42:18, 26.04s/it][Succeeded / Failed / Skipped / Total] 589 / 25 / 12 / 626:  63%|██████▎   | 626/1000 [4:31:40<2:42:18, 26.04s/it][Succeeded / Failed / Skipped / Total] 589 / 25 / 12 / 626:  63%|██████▎   | 627/1000 [4:31:42<2:41:38, 26.00s/it][Succeeded / Failed / Skipped / Total] 590 / 25 / 12 / 627:  63%|██████▎   | 627/1000 [4:31:42<2:41:38, 26.00s/it][Succeeded / Failed / Skipped / Total] 590 / 25 / 12 / 627:  63%|██████▎   | 628/1000 [4:31:58<2:41:06, 25.99s/it][Succeeded / Failed / Skipped / Total] 591 / 25 / 12 / 628:  63%|██████▎   | 628/1000 [4:31:58<2:41:06, 25.99s/it][Succeeded / Failed / Skipped / Total] 591 / 25 / 12 / 628:  63%|██████▎   | 629/1000 [4:32:35<2:40:47, 26.00s/it][Succeeded / Failed / Skipped / Total] 592 / 25 / 12 / 629:  63%|██████▎   | 629/1000 [4:32:35<2:40:47, 26.00s/it][Succeeded / Failed / Skipped / Total] 592 / 25 / 12 / 629:  63%|██████▎   | 630/1000 [4:34:20<2:41:07, 26.13s/it]Pushes or pops an entity manager to the stack . --> region PushOrPopOrPop --> Socre: 1.0

[[[[Adv]]]]: void pushOrPopEm ( EntityManager [[em]] , boolean threadLocalFallback ) { Deque < EntityManager > [[ems]] = this . emStack ( threadLocalFallback ) ; if ( [[em]] != null ) { [[ems]] . push ( [[em]] ) ; } else { if ( [[ems]] . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } [[ems]] . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .

[[[[Adv]]]]: void pushOrPopEm ( EntityManager [[pré]] , boolean threadLocalFallback ) { Deque < EntityManager > [[spotless]] = this . emStack ( threadLocalFallback ) ; if ( [[pré]] != null ) { [[spotless]] . push ( [[pré]] ) ; } else { if ( [[spotless]] . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } [[spotless]] . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .
--------------------------------------------- Result 622 ---------------------------------------------
Returns the value for the given key . --> Buckled by buckled --> Socre: 1.0

[[[[Adv]]]]: public Optional < Object > value ( String [[key]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[key]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value

[[[[Adv]]]]: public Optional < Object > value ( String [[buckled]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[buckled]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value
--------------------------------------------- Result 623 ---------------------------------------------
Deletes all executions of a database . --> Cleans up all executions --> Socre: 1.0

[[[[Adv]]]]: public static void cleanupEvolutions ( Database database , boolean [[autocommit]] , String [[schema]] ) { DatabaseEvolutions [[evolutions]] = new DatabaseEvolutions ( database . asScala ( ) , [[schema]] ) ; [[evolutions]] . evolve ( [[evolutions]] . resetScripts ( ) , [[autocommit]] ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .

[[[[Adv]]]]: public static void cleanupEvolutions ( Database database , boolean [[televisión]] , String [[idiot]] ) { DatabaseEvolutions [[pities]] = new DatabaseEvolutions ( database . asScala ( ) , [[idiot]] ) ; [[pities]] . evolve ( [[pities]] . resetScripts ( ) , [[televisión]] ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .
--------------------------------------------- Result 624 ---------------------------------------------
Parses a string into an object of the given class . --> Parse feedlot --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] parse ( String text , Class < [[T]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .

[[[[Adv]]]]: public < [[feedlot]] > [[feedlot]] parse ( String text , Class < [[feedlot]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .
--------------------------------------------- Result 625 ---------------------------------------------
Creates a flow from an actor . --> brokering algorithm --> Socre: 1.0

[[[[Adv]]]]: public static < In , Out > Flow < In , Out , ? > [[actorRef]] ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy [[overflowStrategy]] , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , bufferSize , [[overflowStrategy]] , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .

[[[[Adv]]]]: public static < In , Out > Flow < In , Out , ? > [[brokering]] ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy [[brûlée]] , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , bufferSize , [[brûlée]] , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .
--------------------------------------------- Result 626 ---------------------------------------------
Prints an object . --> Print an entity --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .

[[[[Adv]]]]: public < T > [[Anemic]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[Anemic]] . class ) ) { return conversion . convert ( t , [[Anemic]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .
--------------------------------------------- Result 627 ---------------------------------------------
Convert the given text into an instance of the given type . --> Attempts to parse the given text . --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] parse ( Field field , String text ) { return ( [[T]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[anyway]] > [[anyway]] parse ( Field field , String text ) { return ( [[anyway]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field
--------------------------------------------- Result 628 ---------------------------------------------
Print an object . --> Convert obj to baba --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ) { return ( [[String]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .

[[[[Adv]]]]: public < T > [[Brigadier]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[Brigadier]] . class ) ) ) { return ( [[Brigadier]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[Brigadier]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[Brigadier]] . class ) ) { return conversion . convert ( t , [[Brigadier]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .
--------------------------------------------- Result 629 ---------------------------------------------
Gets the representation of a field . --> Methode permettante la classe --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .

[[[[Adv]]]]: public < T > [[Là]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .
[Succeeded / Failed / Skipped / Total] 593 / 25 / 12 / 630:  63%|██████▎   | 630/1000 [4:34:20<2:41:07, 26.13s/it][Succeeded / Failed / Skipped / Total] 593 / 25 / 12 / 630:  63%|██████▎   | 631/1000 [4:34:23<2:40:27, 26.09s/it][Succeeded / Failed / Skipped / Total] 593 / 26 / 12 / 631:  63%|██████▎   | 631/1000 [4:34:23<2:40:27, 26.09s/it][Succeeded / Failed / Skipped / Total] 593 / 26 / 12 / 631:  63%|██████▎   | 632/1000 [4:34:45<2:39:59, 26.08s/it][Succeeded / Failed / Skipped / Total] 594 / 26 / 12 / 632:  63%|██████▎   | 632/1000 [4:34:45<2:39:59, 26.08s/it][Succeeded / Failed / Skipped / Total] 594 / 26 / 12 / 632:  63%|██████▎   | 633/1000 [4:34:53<2:39:22, 26.06s/it][Succeeded / Failed / Skipped / Total] 595 / 26 / 12 / 633:  63%|██████▎   | 633/1000 [4:34:53<2:39:22, 26.06s/it][Succeeded / Failed / Skipped / Total] 595 / 26 / 12 / 633:  63%|██████▎   | 634/1000 [4:35:07<2:38:49, 26.04s/it][Succeeded / Failed / Skipped / Total] 595 / 27 / 12 / 634:  63%|██████▎   | 634/1000 [4:35:07<2:38:49, 26.04s/it][Succeeded / Failed / Skipped / Total] 595 / 27 / 12 / 634:  64%|██████▎   | 635/1000 [4:36:09<2:38:44, 26.09s/it][Succeeded / Failed / Skipped / Total] 596 / 27 / 12 / 635:  64%|██████▎   | 635/1000 [4:36:09<2:38:44, 26.09s/it][Succeeded / Failed / Skipped / Total] 596 / 27 / 12 / 635:  64%|██████▎   | 636/1000 [4:36:50<2:38:26, 26.12s/it][Succeeded / Failed / Skipped / Total] 597 / 27 / 12 / 636:  64%|██████▎   | 636/1000 [4:36:50<2:38:26, 26.12s/it][Succeeded / Failed / Skipped / Total] 597 / 27 / 12 / 636:  64%|██████▎   | 637/1000 [4:37:10<2:37:57, 26.11s/it]--------------------------------------------- Result 630 ---------------------------------------------
Returns a new DynamicForm with the specified value . --> Returns a new DynamicForm instance --> Socre: 1.0

[[[[Adv]]]]: public DynamicForm [[fill]] ( Map < String , Object > [[value]] ) { Form < Dynamic > form = super . fill ( new Dynamic ( [[value]] ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . [[value]] ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .

[[[[Adv]]]]: public DynamicForm [[arianna]] ( Map < String , Object > [[classmates]] ) { Form < Dynamic > form = super . fill ( new Dynamic ( [[classmates]] ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . [[classmates]] ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .
--------------------------------------------- Result 631 ---------------------------------------------
Fills the form with the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public Form < T > [[fill]] ( T [[value]] ) { if ( [[value]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[value]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .

[[[[Adv]]]]: public Form < T > [[strove]] ( T [[colonels]] ) { if ( [[colonels]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[colonels]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .
--------------------------------------------- Result 632 ---------------------------------------------
Configures the application with the given module loader . --> Load a Guice application --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[withModuleLoader]] ( BiFunction < Environment , Config , List < GuiceableModule > > [[loader]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment [[env]] , play . api . Configuration conf ) -> Scala . toSeq ( [[loader]] . apply ( new Environment ( [[env]] ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[ariadne]] ( BiFunction < Environment , Config , List < GuiceableModule > > [[maslow]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment [[eason]] , play . api . Configuration conf ) -> Scala . toSeq ( [[maslow]] . apply ( new Environment ( [[eason]] ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 633 ---------------------------------------------
Registers converter for optional types . --> Add amble to the conversion . --> Socre: 1.0

[[[[Adv]]]]: private Formatters [[registerOptional]] ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object [[source]] , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String

[[[[Adv]]]]: private Formatters [[amble]] ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object [[addiction]] , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String
--------------------------------------------- Result 634 ---------------------------------------------
Checks if two classes are assignable . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] [[toClassArray]] , boolean [[autoboxing]] ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( [[toClassArray]] ) ) { return "False" != "False" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( [[toClassArray]] == null ) { [[toClassArray]] = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( isAssignable ( classArray [ i ] , [[toClassArray]] [ i ] , [[autoboxing]] ) == "False" != "False" ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .

[[[[Adv]]]]: public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] [[newscaster]] , boolean [[fairlane]] ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( [[newscaster]] ) ) { return "False" != "False" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( [[newscaster]] == null ) { [[newscaster]] = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( isAssignable ( classArray [ i ] , [[newscaster]] [ i ] , [[fairlane]] ) == "False" != "False" ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .
--------------------------------------------- Result 635 ---------------------------------------------
Returns the message as JSON . --> generate crotchet --> Socre: 1.0

[[[[Adv]]]]: public JsonNode [[errorsAsJson]] ( Lang [[lang]] ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > [[messages]] = new ArrayList <> ( ) ; if ( messagesApi != null && [[lang]] != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; [[messages]] . add ( messagesApi . get ( [[lang]] , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , [[lang]] ) ) ) ; } else { [[messages]] . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , [[messages]] ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .

[[[[Adv]]]]: public JsonNode [[crotchety]] ( Lang [[bachelorhood]] ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > [[jérôme]] = new ArrayList <> ( ) ; if ( messagesApi != null && [[bachelorhood]] != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; [[jérôme]] . add ( messagesApi . get ( [[bachelorhood]] , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , [[bachelorhood]] ) ) ) ; } else { [[jérôme]] . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , [[jérôme]] ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .
--------------------------------------------- Result 636 ---------------------------------------------
Converts an array into a sequence . --> Convenience wrapper for non - null arguments --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > varargs ( T ... [[array]] ) { return toSeq ( [[array]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > varargs ( T ... [[sabes]] ) { return toSeq ( [[sabes]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .
[Succeeded / Failed / Skipped / Total] 598 / 27 / 12 / 637:  64%|██████▎   | 637/1000 [4:37:10<2:37:57, 26.11s/it][Succeeded / Failed / Skipped / Total] 598 / 27 / 12 / 637:  64%|██████▍   | 638/1000 [4:37:31<2:37:27, 26.10s/it][Succeeded / Failed / Skipped / Total] 599 / 27 / 12 / 638:  64%|██████▍   | 638/1000 [4:37:31<2:37:27, 26.10s/it][Succeeded / Failed / Skipped / Total] 599 / 27 / 12 / 638:  64%|██████▍   | 639/1000 [4:37:44<2:36:54, 26.08s/it][Succeeded / Failed / Skipped / Total] 600 / 27 / 12 / 639:  64%|██████▍   | 639/1000 [4:37:44<2:36:54, 26.08s/it][Succeeded / Failed / Skipped / Total] 600 / 27 / 12 / 639:  64%|██████▍   | 640/1000 [4:38:00<2:36:22, 26.06s/it][Succeeded / Failed / Skipped / Total] 601 / 27 / 12 / 640:  64%|██████▍   | 640/1000 [4:38:00<2:36:22, 26.06s/it][Succeeded / Failed / Skipped / Total] 601 / 27 / 12 / 640:  64%|██████▍   | 641/1000 [4:38:03<2:35:43, 26.03s/it][Succeeded / Failed / Skipped / Total] 602 / 27 / 12 / 641:  64%|██████▍   | 641/1000 [4:38:03<2:35:43, 26.03s/it][Succeeded / Failed / Skipped / Total] 602 / 27 / 12 / 641:  64%|██████▍   | 642/1000 [4:38:24<2:35:14, 26.02s/it]--------------------------------------------- Result 637 ---------------------------------------------
Constructs a WebSocketAcceptor that accepts JSON messages . --> Converts WebSocketAcceptor to JsonAcceptor --> Socre: 1.0

[[[[Adv]]]]: public static < In , Out > MappedWebSocketAcceptor < In , Out > json ( Class < In > [[in]] ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , [[in]] ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , [[in]] ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .

[[[[Adv]]]]: public static < In , Out > MappedWebSocketAcceptor < In , Out > json ( Class < In > [[alais]] ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , [[alais]] ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , [[alais]] ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .
--------------------------------------------- Result 638 ---------------------------------------------
Accepts web socket . --> Accepts a WebSocket accepting connection --> Socre: 1.0

[[[[Adv]]]]: private static < In , Out > WebSocket acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new WebSocket ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader [[request]] ) { return f . apply ( [[request]] ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .

[[[[Adv]]]]: private static < In , Out > WebSocket acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new WebSocket ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader [[affirmed]] ) { return f . apply ( [[affirmed]] ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .
--------------------------------------------- Result 639 ---------------------------------------------
Encode a cookie . --> Encode Disembowel --> Socre: 1.0

[[[[Adv]]]]: public String encode ( Cookie [[cookie]] ) { if ( [[cookie]] == null ) { throw new NullPointerException ( "cookie" ) ; } final String [[name]] = [[cookie]] . name ( ) ; final String value = [[cookie]] . value ( ) != null ? [[cookie]] . value ( ) : "" ; validateCookie ( [[name]] , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( [[cookie]] . wrap ( ) ) { addQuoted ( buf , [[name]] , value ) ; } else { add ( buf , [[name]] , value ) ; } if ( [[cookie]] . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , [[cookie]] . maxAge ( ) ) ; Date expires = [[cookie]] . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .

[[[[Adv]]]]: public String encode ( Cookie [[disembowel]] ) { if ( [[disembowel]] == null ) { throw new NullPointerException ( "cookie" ) ; } final String [[tropic]] = [[disembowel]] . name ( ) ; final String value = [[disembowel]] . value ( ) != null ? [[disembowel]] . value ( ) : "" ; validateCookie ( [[tropic]] , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( [[disembowel]] . wrap ( ) ) { addQuoted ( buf , [[tropic]] , value ) ; } else { add ( buf , [[tropic]] , value ) ; } if ( [[disembowel]] . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , [[disembowel]] . maxAge ( ) ) ; Date expires = [[disembowel]] . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .
--------------------------------------------- Result 640 ---------------------------------------------
Sets the visibility of an accessible object . --> If the given object is a public accessible object? --> Socre: 1.0

[[[[Adv]]]]: static boolean setAccessibleWorkaround ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "False" != "False" ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "[[True]]" == "[[True]]" ) ; return "[[True]]" == "[[True]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .

[[[[Adv]]]]: static boolean setAccessibleWorkaround ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "False" != "False" ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "[[Pathogens]]" == "[[Pathogens]]" ) ; return "[[Pathogens]]" == "[[Pathogens]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .
--------------------------------------------- Result 641 ---------------------------------------------
Gets the promotion cost . --> compute chak distance --> Socre: 1.0

[[[[Adv]]]]: private static float [[getPrimitivePromotionCost]] ( final Class < ? > srcClass , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > cls = srcClass ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .

[[[[Adv]]]]: private static float [[chak]] ( final Class < ? > srcClass , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > cls = srcClass ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .
[Succeeded / Failed / Skipped / Total] 603 / 27 / 12 / 642:  64%|██████▍   | 642/1000 [4:38:24<2:35:14, 26.02s/it][Succeeded / Failed / Skipped / Total] 603 / 27 / 12 / 642:  64%|██████▍   | 643/1000 [4:38:35<2:34:40, 26.00s/it][Succeeded / Failed / Skipped / Total] 604 / 27 / 12 / 643:  64%|██████▍   | 643/1000 [4:38:35<2:34:40, 26.00s/it][Succeeded / Failed / Skipped / Total] 604 / 27 / 12 / 643:  64%|██████▍   | 644/1000 [4:38:42<2:34:04, 25.97s/it][Succeeded / Failed / Skipped / Total] 605 / 27 / 12 / 644:  64%|██████▍   | 644/1000 [4:38:42<2:34:04, 25.97s/it][Succeeded / Failed / Skipped / Total] 605 / 27 / 12 / 644:  64%|██████▍   | 645/1000 [4:38:55<2:33:30, 25.95s/it][Succeeded / Failed / Skipped / Total] 606 / 27 / 12 / 645:  64%|██████▍   | 645/1000 [4:38:55<2:33:30, 25.95s/it][Succeeded / Failed / Skipped / Total] 606 / 27 / 12 / 645:  65%|██████▍   | 646/1000 [4:39:10<2:32:59, 25.93s/it][Succeeded / Failed / Skipped / Total] 607 / 27 / 12 / 646:  65%|██████▍   | 646/1000 [4:39:10<2:32:59, 25.93s/it][Succeeded / Failed / Skipped / Total] 607 / 27 / 12 / 646:  65%|██████▍   | 647/1000 [4:39:31<2:32:30, 25.92s/it][Succeeded / Failed / Skipped / Total] 608 / 27 / 12 / 647:  65%|██████▍   | 647/1000 [4:39:31<2:32:30, 25.92s/it][Succeeded / Failed / Skipped / Total] 608 / 27 / 12 / 647:  65%|██████▍   | 648/1000 [4:40:18<2:32:16, 25.96s/it][Succeeded / Failed / Skipped / Total] 609 / 27 / 12 / 648:  65%|██████▍   | 648/1000 [4:40:18<2:32:16, 25.96s/it][Succeeded / Failed / Skipped / Total] 609 / 27 / 12 / 648:  65%|██████▍   | 649/1000 [4:41:22<2:32:10, 26.01s/it][Succeeded / Failed / Skipped / Total] 610 / 27 / 12 / 649:  65%|██████▍   | 649/1000 [4:41:22<2:32:10, 26.01s/it][Succeeded / Failed / Skipped / Total] 610 / 27 / 12 / 649:  65%|██████▌   | 650/1000 [4:41:44<2:31:42, 26.01s/it]--------------------------------------------- Result 642 ---------------------------------------------
Get the total transformation cost . --> huffling --> Socre: 1.0

[[[[Adv]]]]: private static float [[getTotalTransformationCost]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .

[[[[Adv]]]]: private static float [[huddling]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .
--------------------------------------------- Result 643 ---------------------------------------------
Returns a list of nodes that match the specified node . --> Babbing algorithm --> Socre: 1.0

[[[[Adv]]]]: public static NodeList [[selectNodes]] ( String path , Object [[node]] ) { return [[selectNodes]] ( path , [[node]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order

[[[[Adv]]]]: public static NodeList [[blabbing]] ( String path , Object [[serrano]] ) { return [[blabbing]] ( path , [[serrano]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order
--------------------------------------------- Result 644 ---------------------------------------------
Gets message translation for given key . --> Returns an Aegir resource --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( String key , Object ... args ) { return messagesApi . get ( lang , key , args ) ; }
[[[[Nl]]]]: Get the message at the given key .

[[[[Adv]]]]: public String [[aegir]] ( String key , Object ... args ) { return messagesApi . get ( lang , key , args ) ; }
[[[[Nl]]]]: Get the message at the given key .
--------------------------------------------- Result 645 ---------------------------------------------
Converts an array into a Seq . --> Baggart with fitting --> Socre: 1.0

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( T [ ] [[array]] ) { return [[toSeq]] ( java . util . Arrays . asList ( [[array]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[braggart]] ( T [ ] [[fitting]] ) { return [[braggart]] ( java . util . Arrays . asList ( [[fitting]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .
--------------------------------------------- Result 646 ---------------------------------------------
Gets a message for a translation . --> Look up a bunch of messages --> Socre: 1.0

[[[[Adv]]]]: public String at ( List < String > [[keys]] , Object ... args ) { return messagesApi . get ( lang , [[keys]] , args ) ; }
[[[[Nl]]]]: Get the message at the first defined key .

[[[[Adv]]]]: public String at ( List < String > [[antagonise]] , Object ... args ) { return messagesApi . get ( lang , [[antagonise]] , args ) ; }
[[[[Nl]]]]: Get the message at the first defined key .
--------------------------------------------- Result 647 ---------------------------------------------
Performs a quick sort on the given index . --> Sorted by Comparator --> Socre: 1.0

[[[[Adv]]]]: public void [[quickSort]] ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . quickSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .

[[[[Adv]]]]: public void [[omelettes]] ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . quickSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .
--------------------------------------------- Result 648 ---------------------------------------------
Convert a Java List to a Seq . --> Convenience method for scavenging --> Socre: 1.0

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( java . util . List < T > [[list]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[list]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[blunder]] ( java . util . List < T > [[scavenging]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[scavenging]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .
--------------------------------------------- Result 649 ---------------------------------------------
Invokes the method --> Invokes protected methods --> Socre: 1.0

[[[[Adv]]]]: public Object invoke ( Object obj , Object [ ] [[args]] ) throws Throwable { try { init ( ) ; FastClassInfo fci = fastClassInfo ; return fci . f1 . invoke ( fci . i1 , obj , [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .

[[[[Adv]]]]: public Object invoke ( Object obj , Object [ ] [[army]] ) throws Throwable { try { init ( ) ; FastClassInfo fci = fastClassInfo ; return fci . f1 . invoke ( fci . i1 , obj , [[army]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .
--------------------------------------------- Result 650 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 611 / 27 / 12 / 650:  65%|██████▌   | 650/1000 [4:41:44<2:31:42, 26.01s/it][Succeeded / Failed / Skipped / Total] 611 / 27 / 12 / 650:  65%|██████▌   | 651/1000 [4:42:02<2:31:12, 25.99s/it][Succeeded / Failed / Skipped / Total] 612 / 27 / 12 / 651:  65%|██████▌   | 651/1000 [4:42:02<2:31:12, 25.99s/it][Succeeded / Failed / Skipped / Total] 612 / 27 / 12 / 651:  65%|██████▌   | 652/1000 [4:42:02<2:30:32, 25.96s/it][Succeeded / Failed / Skipped / Total] 612 / 27 / 13 / 652:  65%|██████▌   | 652/1000 [4:42:02<2:30:32, 25.96s/it][Succeeded / Failed / Skipped / Total] 612 / 27 / 13 / 652:  65%|██████▌   | 653/1000 [4:42:14<2:29:58, 25.93s/it][Succeeded / Failed / Skipped / Total] 613 / 27 / 13 / 653:  65%|██████▌   | 653/1000 [4:42:14<2:29:58, 25.93s/it][Succeeded / Failed / Skipped / Total] 613 / 27 / 13 / 653:  65%|██████▌   | 654/1000 [4:42:30<2:29:27, 25.92s/it][Succeeded / Failed / Skipped / Total] 614 / 27 / 13 / 654:  65%|██████▌   | 654/1000 [4:42:30<2:29:27, 25.92s/it][Succeeded / Failed / Skipped / Total] 614 / 27 / 13 / 654:  66%|██████▌   | 655/1000 [4:42:33<2:28:49, 25.88s/it][Succeeded / Failed / Skipped / Total] 615 / 27 / 13 / 655:  66%|██████▌   | 655/1000 [4:42:33<2:28:49, 25.88s/it][Succeeded / Failed / Skipped / Total] 615 / 27 / 13 / 655:  66%|██████▌   | 656/1000 [4:42:52<2:28:20, 25.87s/it]Cast a number to type --> Generate a number between two types --> Socre: 1.0

[[[[Adv]]]]: public void [[cast_numeric]] ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; [[cast_numeric]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; [[cast_numeric]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; [[cast_numeric]] ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another

[[[[Adv]]]]: public void [[admirable]] ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; [[admirable]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; [[admirable]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; [[admirable]] ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another
--------------------------------------------- Result 651 ---------------------------------------------
Load an argument . --> Load a local address --> Socre: 1.0

[[[[Adv]]]]: public void [[load_arg]] ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .

[[[[Adv]]]]: public void [[lacanian]] ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .
--------------------------------------------- Result 652 ---------------------------------------------
 emit a field instruction . --> [[[SKIPPED]]]

[[[[Adv]]]]: void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
[[[[Nl]]]]: package - protected for EmitUtils try to fix
--------------------------------------------- Result 653 ---------------------------------------------
Create a parallel Sorter . --> Introorter introspection --> Socre: 1.0

[[[[Adv]]]]: public static ParallelSorter [[create]] ( Object [ ] [[arrays]] ) { Generator gen = new Generator ( ) ; gen . setArrays ( [[arrays]] ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .

[[[[Adv]]]]: public static ParallelSorter [[intro]] ( Object [ ] [[jung]] ) { Generator gen = new Generator ( ) ; gen . setArrays ( [[jung]] ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .
--------------------------------------------- Result 654 ---------------------------------------------
Register a formatter for a particular class . --> Gets the hoister --> Socre: 1.0

[[[[Adv]]]]: public < T > [[Formatters]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String [[text]] , Locale locale ) throws java . [[text]] . ParseException { return formatter . parse ( [[text]] , locale ) ; } public String print ( T [[t]] , Locale locale ) { return formatter . print ( [[t]] , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .

[[[[Adv]]]]: public < T > [[Hôtel]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String [[huntress]] , Locale locale ) throws java . [[huntress]] . ParseException { return formatter . parse ( [[huntress]] , locale ) ; } public String print ( T [[expanded]] , Locale locale ) { return formatter . print ( [[expanded]] , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .
--------------------------------------------- Result 655 ---------------------------------------------
Unbox or zero or zero . --> unbox or unbox --> Socre: 1.0

[[[[Adv]]]]: public void unbox_or_zero ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label [[end]] = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( [[end]] ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( [[end]] ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .

[[[[Adv]]]]: public void unbox_or_zero ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label [[asphyxia]] = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( [[asphyxia]] ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( [[asphyxia]] ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .
--------------------------------------------- Result 656 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 616 / 27 / 13 / 656:  66%|██████▌   | 656/1000 [4:42:52<2:28:20, 25.87s/it][Succeeded / Failed / Skipped / Total] 616 / 27 / 13 / 656:  66%|██████▌   | 657/1000 [4:43:01<2:27:45, 25.85s/it][Succeeded / Failed / Skipped / Total] 617 / 27 / 13 / 657:  66%|██████▌   | 657/1000 [4:43:01<2:27:45, 25.85s/it][Succeeded / Failed / Skipped / Total] 617 / 27 / 13 / 657:  66%|██████▌   | 658/1000 [4:43:21<2:27:16, 25.84s/it][Succeeded / Failed / Skipped / Total] 618 / 27 / 13 / 658:  66%|██████▌   | 658/1000 [4:43:21<2:27:16, 25.84s/it][Succeeded / Failed / Skipped / Total] 618 / 27 / 13 / 658:  66%|██████▌   | 659/1000 [4:43:50<2:26:52, 25.84s/it][Succeeded / Failed / Skipped / Total] 619 / 27 / 13 / 659:  66%|██████▌   | 659/1000 [4:43:50<2:26:52, 25.84s/it][Succeeded / Failed / Skipped / Total] 619 / 27 / 13 / 659:  66%|██████▌   | 660/1000 [4:44:37<2:26:37, 25.87s/it][Succeeded / Failed / Skipped / Total] 620 / 27 / 13 / 660:  66%|██████▌   | 660/1000 [4:44:37<2:26:37, 25.87s/it][Succeeded / Failed / Skipped / Total] 620 / 27 / 13 / 660:  66%|██████▌   | 661/1000 [4:44:37<2:25:58, 25.84s/it]null if null is null --> processes nulls --> Socre: 1.0

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter [[e]] , Label oneNull , Label bothNull ) { [[e]] . dup2 ( ) ; Label nonNull = [[e]] . make_label ( ) ; Label oneNullHelper = [[e]] . make_label ( ) ; Label end = [[e]] . make_label ( ) ; [[e]] . ifnonnull ( nonNull ) ; [[e]] . ifnonnull ( oneNullHelper ) ; [[e]] . pop2 ( ) ; [[e]] . goTo ( bothNull ) ; [[e]] . mark ( nonNull ) ; [[e]] . ifnull ( oneNullHelper ) ; [[e]] . goTo ( end ) ; [[e]] . mark ( oneNullHelper ) ; [[e]] . pop2 ( ) ; [[e]] . goTo ( oneNull ) ; [[e]] . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter [[cigarette]] , Label oneNull , Label bothNull ) { [[cigarette]] . dup2 ( ) ; Label nonNull = [[cigarette]] . make_label ( ) ; Label oneNullHelper = [[cigarette]] . make_label ( ) ; Label end = [[cigarette]] . make_label ( ) ; [[cigarette]] . ifnonnull ( nonNull ) ; [[cigarette]] . ifnonnull ( oneNullHelper ) ; [[cigarette]] . pop2 ( ) ; [[cigarette]] . goTo ( bothNull ) ; [[cigarette]] . mark ( nonNull ) ; [[cigarette]] . ifnull ( oneNullHelper ) ; [[cigarette]] . goTo ( end ) ; [[cigarette]] . mark ( oneNullHelper ) ; [[cigarette]] . pop2 ( ) ; [[cigarette]] . goTo ( oneNull ) ; [[cigarette]] . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .
--------------------------------------------- Result 657 ---------------------------------------------
Append a zero or null value to the stack --> documentation inherited from Apisor --> Socre: 1.0

[[[[Adv]]]]: public void zero_or_null ( Type [[type]] ) { if ( TypeUtils . isPrimitive ( [[type]] ) ) { switch ( [[type]] . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .

[[[[Adv]]]]: public void zero_or_null ( Type [[praiseworthy]] ) { if ( TypeUtils . isPrimitive ( [[praiseworthy]] ) ) { switch ( [[praiseworthy]] . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .
--------------------------------------------- Result 658 ---------------------------------------------
Extract methods from superclass and interfaces . --> static methods --> Socre: 0.9999999999786104

[[[[Adv]]]]: public static void getMethods ( Class superclass , Class [ ] interfaces , List [[methods]] ) { getMethods ( superclass , interfaces , [[methods]] , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .

[[[[Adv]]]]: public static void getMethods ( Class superclass , Class [ ] interfaces , List [[irfan]] ) { getMethods ( superclass , interfaces , [[irfan]] , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .
--------------------------------------------- Result 659 ---------------------------------------------
Gets the cost of object transformation . --> getObject transformation cost --> Socre: 1.0

[[[[Adv]]]]: private static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float [[cost]] = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { * If the destination class is null, we've traveled all the way up to * [[an]] Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { [[cost]] += 1.5f ; } return [[cost]] ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .

[[[[Adv]]]]: private static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float [[pedestal]] = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { * If the destination class is null, we've traveled all the way up to * [[cranes]] Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { [[pedestal]] += 1.5f ; } return [[pedestal]] ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .
--------------------------------------------- Result 660 ---------------------------------------------
Filter constructors . --> throw IllegalArgumentException --> Socre: 1.0

[[[[Adv]]]]: protected void [[filterConstructors]] ( Class sc , List constructors ) { CollectionUtils . filter ( constructors , new VisibilityPredicate ( sc , "True" == "True" ) ) ; if ( constructors . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .

[[[[Adv]]]]: protected void [[happene]] ( Class sc , List constructors ) { CollectionUtils . filter ( constructors , new VisibilityPredicate ( sc , "True" == "True" ) ) ; if ( constructors . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .
--------------------------------------------- Result 661 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 620 / 27 / 14 / 661:  66%|██████▌   | 661/1000 [4:44:37<2:25:58, 25.84s/it][Succeeded / Failed / Skipped / Total] 620 / 27 / 14 / 661:  66%|██████▌   | 662/1000 [4:44:49<2:25:25, 25.81s/it][Succeeded / Failed / Skipped / Total] 621 / 27 / 14 / 662:  66%|██████▌   | 662/1000 [4:44:49<2:25:25, 25.81s/it][Succeeded / Failed / Skipped / Total] 621 / 27 / 14 / 662:  66%|██████▋   | 663/1000 [4:44:55<2:24:49, 25.79s/it][Succeeded / Failed / Skipped / Total] 622 / 27 / 14 / 663:  66%|██████▋   | 663/1000 [4:44:55<2:24:49, 25.79s/it][Succeeded / Failed / Skipped / Total] 622 / 27 / 14 / 663:  66%|██████▋   | 664/1000 [4:44:59<2:24:12, 25.75s/it][Succeeded / Failed / Skipped / Total] 623 / 27 / 14 / 664:  66%|██████▋   | 664/1000 [4:44:59<2:24:12, 25.75s/it][Succeeded / Failed / Skipped / Total] 623 / 27 / 14 / 664:  66%|██████▋   | 665/1000 [4:44:59<2:23:34, 25.71s/it][Succeeded / Failed / Skipped / Total] 623 / 27 / 15 / 665:  66%|██████▋   | 665/1000 [4:44:59<2:23:34, 25.71s/it][Succeeded / Failed / Skipped / Total] 623 / 27 / 15 / 665:  67%|██████▋   | 666/1000 [4:45:05<2:22:58, 25.68s/it][Succeeded / Failed / Skipped / Total] 624 / 27 / 15 / 666:  67%|██████▋   | 666/1000 [4:45:05<2:22:58, 25.68s/it][Succeeded / Failed / Skipped / Total] 624 / 27 / 15 / 666:  67%|██████▋   | 667/1000 [4:45:23<2:22:28, 25.67s/it][Succeeded / Failed / Skipped / Total] 625 / 27 / 15 / 667:  67%|██████▋   | 667/1000 [4:45:23<2:22:28, 25.67s/it][Succeeded / Failed / Skipped / Total] 625 / 27 / 15 / 667:  67%|██████▋   | 668/1000 [4:45:30<2:21:54, 25.65s/it][Succeeded / Failed / Skipped / Total] 626 / 27 / 15 / 668:  67%|██████▋   | 668/1000 [4:45:30<2:21:54, 25.65s/it][Succeeded / Failed / Skipped / Total] 626 / 27 / 15 / 668:  67%|██████▋   | 669/1000 [4:45:53<2:21:26, 25.64s/it]Get field . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void getField ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities
--------------------------------------------- Result 662 ---------------------------------------------
Merge sort method . --> Override this method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public void mergeSort ( int index , int lo , int [[hi]] , Comparator [[cmp]] ) { chooseComparer ( index , [[cmp]] ) ; super . mergeSort ( lo , [[hi]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .

[[[[Adv]]]]: public void mergeSort ( int index , int lo , int [[seize]] , Comparator [[racks]] ) { chooseComparer ( index , [[racks]] ) ; super . mergeSort ( lo , [[seize]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .
--------------------------------------------- Result 663 ---------------------------------------------
Adds method . --> package private for unit test --> Socre: 1.0

[[[[Adv]]]]: public void add ( Method [[method]] ) { add ( ReflectUtils . getSignature ( [[method]] ) , ReflectUtils . getExceptionTypes ( [[method]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .

[[[[Adv]]]]: public void add ( Method [[airliner]] ) { add ( ReflectUtils . getSignature ( [[airliner]] ) , ReflectUtils . getExceptionTypes ( [[airliner]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .
--------------------------------------------- Result 664 ---------------------------------------------
Sets the superclass . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public void setSuperclass ( Class [[superclass]] ) { if ( [[superclass]] != null && [[superclass]] . equals ( Object . class ) ) { [[superclass]] = null ; } this . superclass = [[superclass]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .

[[[[Adv]]]]: public void setSuperclass ( Class [[aikawa]] ) { if ( [[aikawa]] != null && [[aikawa]] . equals ( Object . class ) ) { [[aikawa]] = null ; } this . superclass = [[aikawa]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .
--------------------------------------------- Result 665 ---------------------------------------------
Find all methods with the given names and descriptor . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) {
[[[[Nl]]]]: used by MethodInterceptorGenerated generated code
--------------------------------------------- Result 666 ---------------------------------------------
Returns the cardinality . --> Makes track value --> Socre: 1.0

[[[[Adv]]]]: public int [[cardinality]] ( ) { int w = value ; int c = 0 ; while ( w != 0 ) { c += T [ w & 255 ] ; w >>= 8 ; } return c ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .

[[[[Adv]]]]: public int [[amtrak]] ( ) { int w = value ; int c = 0 ; while ( w != 0 ) { c += T [ w & 255 ] ; w >>= 8 ; } return c ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .
--------------------------------------------- Result 667 ---------------------------------------------
Read string from path . --> Converts a PDF document to Laplatique --> Socre: 1.0

[[[[Adv]]]]: public static String [[readString]] ( final Path path ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( path , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .

[[[[Adv]]]]: public static String [[plié]] ( final Path path ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( path , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .
--------------------------------------------- Result 668 ---------------------------------------------
Process array . --> Make a loopback --> Socre: 1.0

[[[[Adv]]]]: public static void [[process_array]] ( CodeEmitter [[e]] , Type type , ProcessArrayCallback callback ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local array = [[e]] . make_local ( ) ; Local loopvar = [[e]] . make_local ( Type . INT_TYPE ) ; Label loopbody = [[e]] . make_label ( ) ; Label checkloop = [[e]] . make_label ( ) ; [[e]] . store_local ( array ) ; [[e]] . push ( 0 ) ; [[e]] . store_local ( loopvar ) ; [[e]] . goTo ( checkloop ) ; [[e]] . mark ( loopbody ) ; [[e]] . load_local ( array ) ; [[e]] . load_local ( loopvar ) ; [[e]] . array_load ( componentType ) ; callback . processElement ( componentType ) ; [[e]] . iinc ( loopvar , 1 ) ; [[e]] . mark ( checkloop ) ; [[e]] . load_local ( loopvar ) ; [[e]] . load_local ( array ) ; [[e]] . arraylength ( ) ; [[e]] . if_icmp ( [[e]] . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .

[[[[Adv]]]]: public static void [[chubbs]] ( CodeEmitter [[stressing]] , Type type , ProcessArrayCallback callback ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local array = [[stressing]] . make_local ( ) ; Local loopvar = [[stressing]] . make_local ( Type . INT_TYPE ) ; Label loopbody = [[stressing]] . make_label ( ) ; Label checkloop = [[stressing]] . make_label ( ) ; [[stressing]] . store_local ( array ) ; [[stressing]] . push ( 0 ) ; [[stressing]] . store_local ( loopvar ) ; [[stressing]] . goTo ( checkloop ) ; [[stressing]] . mark ( loopbody ) ; [[stressing]] . load_local ( array ) ; [[stressing]] . load_local ( loopvar ) ; [[stressing]] . array_load ( componentType ) ; callback . processElement ( componentType ) ; [[stressing]] . iinc ( loopvar , 1 ) ; [[stressing]] . mark ( checkloop ) ; [[stressing]] . load_local ( loopvar ) ; [[stressing]] . load_local ( array ) ; [[stressing]] . arraylength ( ) ; [[stressing]] . if_icmp ( [[stressing]] . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .
--------------------------------------------- Result 669 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 627 / 27 / 15 / 669:  67%|██████▋   | 669/1000 [4:45:53<2:21:26, 25.64s/it][Succeeded / Failed / Skipped / Total] 627 / 27 / 15 / 669:  67%|██████▋   | 670/1000 [4:46:30<2:21:06, 25.66s/it][Succeeded / Failed / Skipped / Total] 628 / 27 / 15 / 670:  67%|██████▋   | 670/1000 [4:46:30<2:21:06, 25.66s/it][Succeeded / Failed / Skipped / Total] 628 / 27 / 15 / 670:  67%|██████▋   | 671/1000 [4:47:21<2:20:53, 25.70s/it][Succeeded / Failed / Skipped / Total] 628 / 28 / 15 / 671:  67%|██████▋   | 671/1000 [4:47:21<2:20:53, 25.70s/it][Succeeded / Failed / Skipped / Total] 628 / 28 / 15 / 671:  67%|██████▋   | 672/1000 [4:47:37<2:20:23, 25.68s/it][Succeeded / Failed / Skipped / Total] 629 / 28 / 15 / 672:  67%|██████▋   | 672/1000 [4:47:37<2:20:23, 25.68s/it][Succeeded / Failed / Skipped / Total] 629 / 28 / 15 / 672:  67%|██████▋   | 673/1000 [4:50:38<2:21:13, 25.91s/it][Succeeded / Failed / Skipped / Total] 630 / 28 / 15 / 673:  67%|██████▋   | 673/1000 [4:50:38<2:21:13, 25.91s/it][Succeeded / Failed / Skipped / Total] 630 / 28 / 15 / 673:  67%|██████▋   | 674/1000 [4:51:04<2:20:47, 25.91s/it]Create a HttpRequest . --> Create an HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest create ( final String method , final String [[destination]] ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .

[[[[Adv]]]]: public static HttpRequest create ( final String method , final String [[causation]] ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set ( [[causation]] ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .
--------------------------------------------- Result 670 ---------------------------------------------
Makes a CONNECT request . --> Convenience method for creating an HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[connect]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a CONNECT request .

[[[[Adv]]]]: public static HttpRequest [[sacré]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a CONNECT request .
--------------------------------------------- Result 671 ---------------------------------------------
Register a converter . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends Annotation , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > annotationType = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) sourceType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends Annotation , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > annotationType = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) sourceType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .
--------------------------------------------- Result 672 ---------------------------------------------
Sets the naming policy . --> Methode permettant de la restriction --> Socre: 1.0

[[[[Adv]]]]: public void [[setNamingPolicy]] ( NamingPolicy namingPolicy ) { if ( namingPolicy == null ) namingPolicy = DefaultNamingPolicy . INSTANCE ; this . namingPolicy = namingPolicy ; }
[[[[Nl]]]]: Override the default naming policy .

[[[[Adv]]]]: public void [[liberté]] ( NamingPolicy namingPolicy ) { if ( namingPolicy == null ) namingPolicy = DefaultNamingPolicy . INSTANCE ; this . namingPolicy = namingPolicy ; }
[[[[Nl]]]]: Override the default naming policy .
--------------------------------------------- Result 673 ---------------------------------------------
Sets the request host . --> Set the vacipulated vault --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[host]] ( final String [[host]] ) { this . [[host]] = [[host]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[host]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .

[[[[Adv]]]]: public HttpRequest [[attic]] ( final String [[rne]] ) { this . [[gravitation]] = [[attic]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[attic]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .
--------------------------------------------- Result 674 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 631 / 28 / 15 / 674:  67%|██████▋   | 674/1000 [4:51:04<2:20:47, 25.91s/it][Succeeded / Failed / Skipped / Total] 631 / 28 / 15 / 674:  68%|██████▊   | 675/1000 [4:51:10<2:20:11, 25.88s/it][Succeeded / Failed / Skipped / Total] 632 / 28 / 15 / 675:  68%|██████▊   | 675/1000 [4:51:10<2:20:11, 25.88s/it][Succeeded / Failed / Skipped / Total] 632 / 28 / 15 / 675:  68%|██████▊   | 676/1000 [4:51:11<2:19:33, 25.84s/it][Succeeded / Failed / Skipped / Total] 633 / 28 / 15 / 676:  68%|██████▊   | 676/1000 [4:51:11<2:19:33, 25.84s/it][Succeeded / Failed / Skipped / Total] 633 / 28 / 15 / 676:  68%|██████▊   | 677/1000 [4:52:04<2:19:21, 25.89s/it][Succeeded / Failed / Skipped / Total] 634 / 28 / 15 / 677:  68%|██████▊   | 677/1000 [4:52:04<2:19:21, 25.89s/it][Succeeded / Failed / Skipped / Total] 634 / 28 / 15 / 677:  68%|██████▊   | 678/1000 [4:52:15<2:18:48, 25.86s/it][Succeeded / Failed / Skipped / Total] 635 / 28 / 15 / 678:  68%|██████▊   | 678/1000 [4:52:15<2:18:48, 25.86s/it][Succeeded / Failed / Skipped / Total] 635 / 28 / 15 / 678:  68%|██████▊   | 679/1000 [4:53:07<2:18:34, 25.90s/it][Succeeded / Failed / Skipped / Total] 636 / 28 / 15 / 679:  68%|██████▊   | 679/1000 [4:53:07<2:18:34, 25.90s/it][Succeeded / Failed / Skipped / Total] 636 / 28 / 15 / 679:  68%|██████▊   | 680/1000 [4:54:59<2:18:49, 26.03s/it][Succeeded / Failed / Skipped / Total] 637 / 28 / 15 / 680:  68%|██████▊   | 680/1000 [4:54:59<2:18:49, 26.03s/it][Succeeded / Failed / Skipped / Total] 637 / 28 / 15 / 680:  68%|██████▊   | 681/1000 [4:55:09<2:18:15, 26.01s/it][Succeeded / Failed / Skipped / Total] 638 / 28 / 15 / 681:  68%|██████▊   | 681/1000 [4:55:09<2:18:15, 26.01s/it][Succeeded / Failed / Skipped / Total] 638 / 28 / 15 / 681:  68%|██████▊   | 682/1000 [4:55:25<2:17:44, 25.99s/it][Succeeded / Failed / Skipped / Total] 639 / 28 / 15 / 682:  68%|██████▊   | 682/1000 [4:55:25<2:17:44, 25.99s/it][Succeeded / Failed / Skipped / Total] 639 / 28 / 15 / 682:  68%|██████▊   | 683/1000 [4:55:40<2:17:13, 25.97s/it]Makes a PUT request . --> Transform HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[put]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PUT request .

[[[[Adv]]]]: public static HttpRequest [[transform]] ( final String [[replacement]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[replacement]] ) ; }
[[[[Nl]]]]: Builds a PUT request .
--------------------------------------------- Result 675 ---------------------------------------------
Resolves a path relative to a base path . --> Resolve cipri --> Socre: 1.0

[[[[Adv]]]]: public static Path [[resolve]] ( final Path [[base]] , String [[child]] ) { if ( StringUtil . startsWithChar ( [[child]] , File . separatorChar ) ) { [[child]] = [[child]] . substring ( 1 ) ; } return [[base]] . resolve ( [[child]] ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .

[[[[Adv]]]]: public static Path [[elephants]] ( final Path [[dile]] , String [[cipriani]] ) { if ( StringUtil . startsWithChar ( [[cipriani]] , File . separatorChar ) ) { [[cipriani]] = [[cipriani]] . substring ( 1 ) ; } return [[dile]] . resolve ( [[cipriani]] ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .
--------------------------------------------- Result 676 ---------------------------------------------
Creates a new database from the given parameters . --> Equivalent to testing --> Socre: 1.0

[[[[Adv]]]]: public static Database [[createFrom]] ( String driver , String [[url]] , Map < String , ? extends Object > config ) { return [[createFrom]] ( "default" , driver , [[url]] , config ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .

[[[[Adv]]]]: public static Database [[resentment]] ( String driver , String [[yorkshire]] , Map < String , ? extends Object > config ) { return [[resentment]] ( "default" , driver , [[yorkshire]] , config ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .
--------------------------------------------- Result 677 ---------------------------------------------
Makes a GET request . --> Makes sure that the given string is subtitled --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[get]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a GET request .

[[[[Adv]]]]: public static HttpRequest [[jurassic]] ( final String [[subtitled]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[subtitled]] ) ; }
[[[[Nl]]]]: Builds a GET request .
--------------------------------------------- Result 678 ---------------------------------------------
Makes a POST request . --> Convenience wrapper for GET requests --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[post]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a POST request .

[[[[Adv]]]]: public static HttpRequest [[nineties]] ( final String [[replacement]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[replacement]] ) ; }
[[[[Nl]]]]: Builds a POST request .
--------------------------------------------- Result 679 ---------------------------------------------
Set the request path . --> Specifies haystacks --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest path ( String [[path]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .

[[[[Adv]]]]: public HttpRequest path ( String [[haystacks]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .
--------------------------------------------- Result 680 ---------------------------------------------
Makes a TRACE request . --> Sets the HttpRequest that should be used for testing --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[trace]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .

[[[[Adv]]]]: public static HttpRequest [[cheeses]] ( final String [[synching]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[synching]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .
--------------------------------------------- Result 681 ---------------------------------------------
Sets the replacement cookies . --> Set REACEME 0 --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest REPLACEME0 ( final Cookie ... REPLACEME0 ) { if ( REPLACEME0 . length == 0 ) { return this ; } StringBuilder cookieString = new StringBuilder ( ) ; boolean first = "True" == "True" ; for ( Cookie cookie : REPLACEME0 ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { cookieString . append ( "; " ) ; } first = "[[False]]" != "[[False]]" ; cookieString . append ( cookie . getName ( ) ) ; cookieString . append ( ' ' ) ; cookieString . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , cookieString . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .

[[[[Adv]]]]: public HttpRequest REPLACEME0 ( final Cookie ... REPLACEME0 ) { if ( REPLACEME0 . length == 0 ) { return this ; } StringBuilder cookieString = new StringBuilder ( ) ; boolean first = "True" == "True" ; for ( Cookie cookie : REPLACEME0 ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { cookieString . append ( "; " ) ; } first = "[[Aerodynamic]]" != "[[Aerodynamic]]" ; cookieString . append ( cookie . getName ( ) ) ; cookieString . append ( ' ' ) ; cookieString . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , cookieString . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .
--------------------------------------------- Result 682 ---------------------------------------------
Add the query . --> Add a query string --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest query ( final Map < String , String > [[queryMap]] ) { for ( Map . Entry < String , String > entry : [[queryMap]] . entrySet ( ) ) { query . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .

[[[[Adv]]]]: public HttpRequest query ( final Map < String , String > [[bedpan]] ) { for ( Map . Entry < String , String > entry : [[bedpan]] . entrySet ( ) ) { query . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .
--------------------------------------------- Result 683 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 639 / 29 / 15 / 683:  68%|██████▊   | 683/1000 [4:55:40<2:17:13, 25.97s/it][Succeeded / Failed / Skipped / Total] 639 / 29 / 15 / 683:  68%|██████▊   | 684/1000 [4:55:50<2:16:40, 25.95s/it][Succeeded / Failed / Skipped / Total] 640 / 29 / 15 / 684:  68%|██████▊   | 684/1000 [4:55:50<2:16:40, 25.95s/it][Succeeded / Failed / Skipped / Total] 640 / 29 / 15 / 684:  68%|██████▊   | 685/1000 [4:55:57<2:16:05, 25.92s/it][Succeeded / Failed / Skipped / Total] 641 / 29 / 15 / 685:  68%|██████▊   | 685/1000 [4:55:57<2:16:05, 25.92s/it][Succeeded / Failed / Skipped / Total] 641 / 29 / 15 / 685:  69%|██████▊   | 686/1000 [4:56:08<2:15:32, 25.90s/it][Succeeded / Failed / Skipped / Total] 642 / 29 / 15 / 686:  69%|██████▊   | 686/1000 [4:56:08<2:15:32, 25.90s/it][Succeeded / Failed / Skipped / Total] 642 / 29 / 15 / 686:  69%|██████▊   | 687/1000 [4:56:29<2:15:05, 25.89s/it][Succeeded / Failed / Skipped / Total] 643 / 29 / 15 / 687:  69%|██████▊   | 687/1000 [4:56:29<2:15:05, 25.89s/it][Succeeded / Failed / Skipped / Total] 643 / 29 / 15 / 687:  69%|██████▉   | 688/1000 [4:56:49<2:14:36, 25.89s/it][Succeeded / Failed / Skipped / Total] 644 / 29 / 15 / 688:  69%|██████▉   | 688/1000 [4:56:49<2:14:36, 25.89s/it][Succeeded / Failed / Skipped / Total] 644 / 29 / 15 / 688:  69%|██████▉   | 689/1000 [4:57:06<2:14:06, 25.87s/it][Succeeded / Failed / Skipped / Total] 645 / 29 / 15 / 689:  69%|██████▉   | 689/1000 [4:57:06<2:14:06, 25.87s/it][Succeeded / Failed / Skipped / Total] 645 / 29 / 15 / 689:  69%|██████▉   | 690/1000 [4:57:10<2:13:30, 25.84s/it][Succeeded / Failed / Skipped / Total] 645 / 30 / 15 / 690:  69%|██████▉   | 690/1000 [4:57:10<2:13:30, 25.84s/it][Succeeded / Failed / Skipped / Total] 645 / 30 / 15 / 690:  69%|██████▉   | 691/1000 [4:57:16<2:12:56, 25.81s/it][Succeeded / Failed / Skipped / Total] 646 / 30 / 15 / 691:  69%|██████▉   | 691/1000 [4:57:16<2:12:56, 25.81s/it][Succeeded / Failed / Skipped / Total] 646 / 30 / 15 / 691:  69%|██████▉   | 692/1000 [4:57:35<2:12:27, 25.80s/it][Succeeded / Failed / Skipped / Total] 647 / 30 / 15 / 692:  69%|██████▉   | 692/1000 [4:57:35<2:12:27, 25.80s/it][Succeeded / Failed / Skipped / Total] 647 / 30 / 15 / 692:  69%|██████▉   | 693/1000 [4:57:53<2:11:58, 25.79s/it]Resolves all bridge classes . --> [[[FAILED]]]

[[[[Adv]]]]: public Map resolveAll ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream [[is]] = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( [[is]] == null ) { return resolved ; } try { new ClassReader ( [[is]] ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { [[is]] . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .

[[[[Adv]]]]: public Map resolveAll ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream [[enchanté]] = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( [[enchanté]] == null ) { return resolved ; } try { new ClassReader ( [[enchanté]] ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { [[enchanté]] . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .
--------------------------------------------- Result 684 ---------------------------------------------
Makes a DELETE request . --> Reuse HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[delete]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .

[[[[Adv]]]]: public static HttpRequest [[reuse]] ( final String [[braces]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[braces]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .
--------------------------------------------- Result 685 ---------------------------------------------
Gets the query string . --> Get the movie --> Socre: 1.0

[[[[Adv]]]]: public String [[queryString]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .

[[[[Adv]]]]: public String [[movie]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .
--------------------------------------------- Result 686 ---------------------------------------------
Returns the host url . --> Hook to build the HttpBand --> Socre: 1.0

[[[[Adv]]]]: public String [[hostUrl]] ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .

[[[[Adv]]]]: public String [[hannah]] ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .
--------------------------------------------- Result 687 ---------------------------------------------
Start a HEAD request . --> Methode permettant --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[head]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .

[[[[Adv]]]]: public static HttpRequest [[mistery]] ( final String [[ban]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[ban]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .
--------------------------------------------- Result 688 ---------------------------------------------
Returns buffer . --> Implemented here --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Buffer [[buffer]] ( final boolean fullRequest ) {
[[[[Nl]]]]: Prepares the request buffer .

[[[[Adv]]]]: @ Override protected Buffer [[amtrak]] ( final boolean fullRequest ) {
[[[[Nl]]]]: Prepares the request buffer .
--------------------------------------------- Result 689 ---------------------------------------------
Send and receive response . --> Send Chargin and receive the response --> Socre: 1.0

[[[[Adv]]]]: public < [[R]] > [[R]] sendAndReceive ( final Function < HttpResponse , [[R]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .

[[[[Adv]]]]: public < [[chargin]] > [[chargin]] sendAndReceive ( final Function < HttpResponse , [[chargin]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .
--------------------------------------------- Result 690 ---------------------------------------------
Makes a PATCH request . --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[patch]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .

[[[[Adv]]]]: public static HttpRequest [[ornaments]] ( final String [[gazelle]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[gazelle]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .
--------------------------------------------- Result 691 ---------------------------------------------
Start a OPTIONS request . --> Makes sure that not reachable --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[options]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .

[[[[Adv]]]]: public static HttpRequest [[nothin]] ( final String [[reachable]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[reachable]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .
--------------------------------------------- Result 692 ---------------------------------------------
Collects all action interceptors . --> Add the clop to the interceptor list --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionInterceptors]] ( ) { final Collection < ? extends ActionInterceptor > interceptorValues = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( interceptorValues ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .

[[[[Adv]]]]: protected void [[clop]] ( ) { final Collection < ? extends ActionInterceptor > interceptorValues = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( interceptorValues ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .
--------------------------------------------- Result 693 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 648 / 30 / 15 / 693:  69%|██████▉   | 693/1000 [4:57:53<2:11:58, 25.79s/it][Succeeded / Failed / Skipped / Total] 648 / 30 / 15 / 693:  69%|██████▉   | 694/1000 [4:58:13<2:11:29, 25.78s/it][Succeeded / Failed / Skipped / Total] 649 / 30 / 15 / 694:  69%|██████▉   | 694/1000 [4:58:13<2:11:29, 25.78s/it][Succeeded / Failed / Skipped / Total] 649 / 30 / 15 / 694:  70%|██████▉   | 695/1000 [4:58:28<2:10:59, 25.77s/it][Succeeded / Failed / Skipped / Total] 650 / 30 / 15 / 695:  70%|██████▉   | 695/1000 [4:58:28<2:10:59, 25.77s/it][Succeeded / Failed / Skipped / Total] 650 / 30 / 15 / 695:  70%|██████▉   | 696/1000 [4:58:35<2:10:25, 25.74s/it][Succeeded / Failed / Skipped / Total] 651 / 30 / 15 / 696:  70%|██████▉   | 696/1000 [4:58:35<2:10:25, 25.74s/it][Succeeded / Failed / Skipped / Total] 651 / 30 / 15 / 696:  70%|██████▉   | 697/1000 [4:58:54<2:09:56, 25.73s/it][Succeeded / Failed / Skipped / Total] 652 / 30 / 15 / 697:  70%|██████▉   | 697/1000 [4:58:54<2:09:56, 25.73s/it][Succeeded / Failed / Skipped / Total] 652 / 30 / 15 / 697:  70%|██████▉   | 698/1000 [4:59:13<2:09:27, 25.72s/it][Succeeded / Failed / Skipped / Total] 653 / 30 / 15 / 698:  70%|██████▉   | 698/1000 [4:59:13<2:09:27, 25.72s/it][Succeeded / Failed / Skipped / Total] 653 / 30 / 15 / 698:  70%|██████▉   | 699/1000 [4:59:20<2:08:53, 25.69s/it][Succeeded / Failed / Skipped / Total] 654 / 30 / 15 / 699:  70%|██████▉   | 699/1000 [4:59:20<2:08:53, 25.69s/it][Succeeded / Failed / Skipped / Total] 654 / 30 / 15 / 699:  70%|███████   | 700/1000 [4:59:25<2:08:19, 25.67s/it][Succeeded / Failed / Skipped / Total] 655 / 30 / 15 / 700:  70%|███████   | 700/1000 [4:59:25<2:08:19, 25.67s/it][Succeeded / Failed / Skipped / Total] 655 / 30 / 15 / 700:  70%|███████   | 701/1000 [5:00:13<2:08:03, 25.70s/it][Succeeded / Failed / Skipped / Total] 656 / 30 / 15 / 701:  70%|███████   | 701/1000 [5:00:13<2:08:03, 25.70s/it][Succeeded / Failed / Skipped / Total] 656 / 30 / 15 / 701:  70%|███████   | 702/1000 [5:00:15<2:07:27, 25.66s/it]Collects the action filters . --> Build the gravestone filter --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionFilters]] ( ) { final Collection < ? extends ActionFilter > filterValues = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( filterValues ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .

[[[[Adv]]]]: protected void [[gravestone]] ( ) { final Collection < ? extends ActionFilter > filterValues = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( filterValues ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .
--------------------------------------------- Result 694 ---------------------------------------------
Add a query parameter . --> Sets request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest query ( final String name1 , final Object value1 , final Object ... [[parameters]] ) { query ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int i = 0 ; i < [[parameters]] . length ; i += 2 ) { String name = [[parameters]] [ i ] . toString ( ) ; String [[value]] = [[parameters]] [ i + 1 ] . toString ( ) ; query . add ( name , [[value]] ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .

[[[[Adv]]]]: public HttpRequest query ( final String name1 , final Object value1 , final Object ... [[ashura]] ) { query ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int i = 0 ; i < [[ashura]] . length ; i += 2 ) { String name = [[ashura]] [ i ] . toString ( ) ; String [[kaitan]] = [[ashura]] [ i + 1 ] . toString ( ) ; query . add ( name , [[kaitan]] ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .
--------------------------------------------- Result 695 ---------------------------------------------
Get the length of the exception table . --> get exception table length --> Socre: 1.0

[[[[Adv]]]]: static int getExceptionTableLength ( final Handler firstHandler ) { int length = 0 ; Handler [[handler]] = firstHandler ; while ( [[handler]] != null ) { length ++ ; [[handler]] = [[handler]] . nextHandler ; } return length ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .

[[[[Adv]]]]: static int getExceptionTableLength ( final Handler firstHandler ) { int length = 0 ; Handler [[plankton]] = firstHandler ; while ( [[plankton]] != null ) { length ++ ; [[plankton]] = [[plankton]] . nextHandler ; } return length ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .
--------------------------------------------- Result 696 ---------------------------------------------
Collect all action runtimes . --> Sorted from the cache --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionRuntimes]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .

[[[[Adv]]]]: protected void [[antiquities]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .
--------------------------------------------- Result 697 ---------------------------------------------
Set the query string . --> Set the fakir --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[queryString]] ( final String queryString , final boolean decode ) { this . [[query]] = HttpUtil . parseQuery ( [[queryString]] , decode ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .

[[[[Adv]]]]: public HttpRequest [[fakir]] ( final String queryString , final boolean decode ) { this . [[cachet]] = HttpUtil . parseQuery ( [[fakir]] , decode ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .
--------------------------------------------- Result 698 ---------------------------------------------
Set basic authentication . --> authenticated HTTP request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest basicAuthentication ( final String [[username]] , final String password ) { if ( [[username]] != null && password != null ) { String [[data]] = [[username]] . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( [[data]] ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .

[[[[Adv]]]]: public HttpRequest basicAuthentication ( final String [[troubadours]] , final String password ) { if ( [[troubadours]] != null && password != null ) { String [[résumé]] = [[troubadours]] . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( [[résumé]] ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .
--------------------------------------------- Result 699 ---------------------------------------------
Extract the reference from a property . --> also used in test --> Socre: 1.0

[[[[Adv]]]]: @ Override public String extractThisReference ( final String [[propertyName]] ) { int ndx = StringUtil . indexOfChars ( [[propertyName]] , INDEX_CHARS ) ; if ( ndx == - 1 ) { return [[propertyName]] ; } return [[propertyName]] . substring ( 0 , ndx ) ; }
[[[[Nl]]]]: Extract the first name of this reference .

[[[[Adv]]]]: @ Override public String extractThisReference ( final String [[crippen]] ) { int ndx = StringUtil . indexOfChars ( [[crippen]] , INDEX_CHARS ) ; if ( ndx == - 1 ) { return [[crippen]] ; } return [[crippen]] . substring ( 0 , ndx ) ; }
[[[[Nl]]]]: Extract the first name of this reference .
--------------------------------------------- Result 700 ---------------------------------------------
Sets the Host header . --> setter for affiliations --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[setHostHeader]] ( ) { String [[hostPort]] = this . host ; if ( port != Defaults . DEFAULT_PORT ) { [[hostPort]] += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , [[hostPort]] ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .

[[[[Adv]]]]: public HttpRequest [[affiliations]] ( ) { String [[après]] = this . host ; if ( port != Defaults . DEFAULT_PORT ) { [[après]] += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , [[après]] ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .
--------------------------------------------- Result 701 ---------------------------------------------
Sets an object reference . --> Add a bilbao --> Socre: 1.0

[[[[Adv]]]]: public void [[setObjectReference]] ( final String name , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( name , object ) ; }
[[[[Nl]]]]: Saves object reference .

[[[[Adv]]]]: public void [[bilbao]] ( final String name , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( name , object ) ; }
[[[[Nl]]]]: Saves object reference .
--------------------------------------------- Result 702 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 657 / 30 / 15 / 702:  70%|███████   | 702/1000 [5:00:15<2:07:27, 25.66s/it][Succeeded / Failed / Skipped / Total] 657 / 30 / 15 / 702:  70%|███████   | 703/1000 [5:00:34<2:06:59, 25.65s/it][Succeeded / Failed / Skipped / Total] 658 / 30 / 15 / 703:  70%|███████   | 703/1000 [5:00:34<2:06:59, 25.65s/it][Succeeded / Failed / Skipped / Total] 658 / 30 / 15 / 703:  70%|███████   | 704/1000 [5:01:06<2:06:35, 25.66s/it][Succeeded / Failed / Skipped / Total] 659 / 30 / 15 / 704:  70%|███████   | 704/1000 [5:01:06<2:06:35, 25.66s/it][Succeeded / Failed / Skipped / Total] 659 / 30 / 15 / 704:  70%|███████   | 705/1000 [5:01:31<2:06:10, 25.66s/it][Succeeded / Failed / Skipped / Total] 660 / 30 / 15 / 705:  70%|███████   | 705/1000 [5:01:31<2:06:10, 25.66s/it][Succeeded / Failed / Skipped / Total] 660 / 30 / 15 / 705:  71%|███████   | 706/1000 [5:01:32<2:05:34, 25.63s/it][Succeeded / Failed / Skipped / Total] 661 / 30 / 15 / 706:  71%|███████   | 706/1000 [5:01:32<2:05:34, 25.63s/it][Succeeded / Failed / Skipped / Total] 661 / 30 / 15 / 706:  71%|███████   | 707/1000 [5:02:21<2:05:18, 25.66s/it][Succeeded / Failed / Skipped / Total] 662 / 30 / 15 / 707:  71%|███████   | 707/1000 [5:02:21<2:05:18, 25.66s/it][Succeeded / Failed / Skipped / Total] 662 / 30 / 15 / 707:  71%|███████   | 708/1000 [5:04:38<2:05:38, 25.82s/it][Succeeded / Failed / Skipped / Total] 663 / 30 / 15 / 708:  71%|███████   | 708/1000 [5:04:38<2:05:38, 25.82s/it][Succeeded / Failed / Skipped / Total] 663 / 30 / 15 / 708:  71%|███████   | 709/1000 [5:05:22<2:05:20, 25.84s/it][Succeeded / Failed / Skipped / Total] 664 / 30 / 15 / 709:  71%|███████   | 709/1000 [5:05:22<2:05:20, 25.84s/it][Succeeded / Failed / Skipped / Total] 664 / 30 / 15 / 709:  71%|███████   | 710/1000 [5:06:44<2:05:17, 25.92s/it][Succeeded / Failed / Skipped / Total] 665 / 30 / 15 / 710:  71%|███████   | 710/1000 [5:06:44<2:05:17, 25.92s/it][Succeeded / Failed / Skipped / Total] 665 / 30 / 15 / 710:  71%|███████   | 711/1000 [5:07:01<2:04:47, 25.91s/it]Returns a PrintWriter for writing . --> Blocking write method for efficiency --> Socre: 1.0

[[[[Adv]]]]: @ Override public PrintWriter [[getWriter]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .

[[[[Adv]]]]: @ Override public PrintWriter [[blaring]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .
--------------------------------------------- Result 703 ---------------------------------------------
Removes range between two ranges . --> Convenience method for constrictor --> Socre: 1.0

[[[[Adv]]]]: static Handler [[removeRange]] ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = [[removeRange]] ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int [[rangeStart]] = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .

[[[[Adv]]]]: static Handler [[constrictor]] ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = [[constrictor]] ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int [[coughed]] = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .
--------------------------------------------- Result 704 ---------------------------------------------
Looks up an object reference . --> Get conditional expression --> Socre: 1.0

[[[[Adv]]]]: public Object [[lookupObject]] ( final String ref ) { Object value = getObjectReference ( ref ) ; if ( value == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + ref ) ; } return value ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .

[[[[Adv]]]]: public Object [[conditional]] ( final String ref ) { Object value = getObjectReference ( ref ) ; if ( value == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + ref ) ; } return value ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .
--------------------------------------------- Result 705 ---------------------------------------------
Find the table descriptor by column reference . --> Look for shinkaiaiai --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[findTableDescriptorByColumnRef]] ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = entry . getValue ( ) . desc ; if ( ded . findByPropertyName ( columnRef ) != null ) { return ded ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .

[[[[Adv]]]]: public DbEntityDescriptor [[shinkai]] ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = entry . getValue ( ) . desc ; if ( ded . findByPropertyName ( columnRef ) != null ) { return ded ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .
--------------------------------------------- Result 706 ---------------------------------------------
Collects the action results . --> Generate the sigmund --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionResults]] ( ) { final Collection < ActionResult > [[resultsValues]] = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( [[resultsValues]] ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .

[[[[Adv]]]]: protected void [[sigmund]] ( ) { final Collection < ActionResult > [[workshop]] = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( [[workshop]] ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .
--------------------------------------------- Result 707 ---------------------------------------------
Looks up the table reference by table reference . --> unsupportedTableDescriptor --> Socre: 1.0

[[[[Adv]]]]: protected DbEntityDescriptor [[lookupTableRef]] ( final String tableRef ) { DbEntityDescriptor ded = getTableDescriptor ( tableRef ) ; if ( ded == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + tableRef ) ; } return ded ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .

[[[[Adv]]]]: protected DbEntityDescriptor [[unification]] ( final String tableRef ) { DbEntityDescriptor ded = getTableDescriptor ( tableRef ) ; if ( ded == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + tableRef ) ; } return ded ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .
--------------------------------------------- Result 708 ---------------------------------------------
Get object reference by name . --> Get the BLade for a given dease --> Socre: 1.0

[[[[Adv]]]]: public Object [[getObjectReference]] ( final String [[name]] ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( [[name]] ) ; }
[[[[Nl]]]]: Returns object reference .

[[[[Adv]]]]: public Object [[blase]] ( final String [[dease]] ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( [[dease]] ) ; }
[[[[Nl]]]]: Returns object reference .
--------------------------------------------- Result 709 ---------------------------------------------
Serializes the given value to the JSON context . --> Serialize a filter --> Socre: 1.0

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext jsonContext , final T [[value]] ) { if ( jsonContext . pushValue ( [[value]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext jsonContext , final T [[fille]] ) { if ( jsonContext . pushValue ( [[fille]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .
--------------------------------------------- Result 710 ---------------------------------------------
Register a hint . --> translate the datagrams --> Socre: 1.0

[[[[Adv]]]]: public void [[registerHint]] ( final String hint ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( hint ) ; }
[[[[Nl]]]]: Registers a hint .

[[[[Adv]]]]: public void [[clichéd]] ( final String hint ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( hint ) ; }
[[[[Nl]]]]: Registers a hint .
--------------------------------------------- Result 711 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 666 / 30 / 15 / 711:  71%|███████   | 711/1000 [5:07:01<2:04:47, 25.91s/it][Succeeded / Failed / Skipped / Total] 666 / 30 / 15 / 711:  71%|███████   | 712/1000 [5:07:33<2:04:24, 25.92s/it][Succeeded / Failed / Skipped / Total] 667 / 30 / 15 / 712:  71%|███████   | 712/1000 [5:07:33<2:04:24, 25.92s/it][Succeeded / Failed / Skipped / Total] 667 / 30 / 15 / 712:  71%|███████▏  | 713/1000 [5:07:48<2:03:54, 25.90s/it][Succeeded / Failed / Skipped / Total] 668 / 30 / 15 / 713:  71%|███████▏  | 713/1000 [5:07:48<2:03:54, 25.90s/it][Succeeded / Failed / Skipped / Total] 668 / 30 / 15 / 713:  71%|███████▏  | 714/1000 [5:08:10<2:03:26, 25.90s/it][Succeeded / Failed / Skipped / Total] 669 / 30 / 15 / 714:  71%|███████▏  | 714/1000 [5:08:10<2:03:26, 25.90s/it][Succeeded / Failed / Skipped / Total] 669 / 30 / 15 / 714:  72%|███████▏  | 715/1000 [5:09:24<2:03:19, 25.96s/it][Succeeded / Failed / Skipped / Total] 670 / 30 / 15 / 715:  72%|███████▏  | 715/1000 [5:09:24<2:03:19, 25.96s/it][Succeeded / Failed / Skipped / Total] 670 / 30 / 15 / 715:  72%|███████▏  | 716/1000 [5:10:14<2:03:03, 26.00s/it][Succeeded / Failed / Skipped / Total] 671 / 30 / 15 / 716:  72%|███████▏  | 716/1000 [5:10:14<2:03:03, 26.00s/it][Succeeded / Failed / Skipped / Total] 671 / 30 / 15 / 716:  72%|███████▏  | 717/1000 [5:12:47<2:03:27, 26.18s/it][Succeeded / Failed / Skipped / Total] 672 / 30 / 15 / 717:  72%|███████▏  | 717/1000 [5:12:47<2:03:27, 26.18s/it][Succeeded / Failed / Skipped / Total] 672 / 30 / 15 / 717:  72%|███████▏  | 718/1000 [5:15:44<2:04:00, 26.38s/it][Succeeded / Failed / Skipped / Total] 672 / 31 / 15 / 718:  72%|███████▏  | 718/1000 [5:15:44<2:04:00, 26.38s/it][Succeeded / Failed / Skipped / Total] 672 / 31 / 15 / 718:  72%|███████▏  | 719/1000 [5:17:29<2:04:04, 26.49s/it]Gets the property . --> Liefert einer ein Levengebene Levengegebenen ein Levensh --> Socre: 1.0

[[[[Adv]]]]: @ Override public < [[T]] > [[T]] getProperty ( final Object bean , final String name ) { BeanProperty [[beanProperty]] = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( [[beanProperty]] ) ; return ( [[T]] ) getIndexProperty ( [[beanProperty]] ) ; } else { try { resolveNestedProperties ( [[beanProperty]] ) ; return ( [[T]] ) getIndexProperty ( [[beanProperty]] ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .

[[[[Adv]]]]: @ Override public < [[pièce]] > [[pièce]] getProperty ( final Object bean , final String name ) { BeanProperty [[cami]] = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( [[cami]] ) ; return ( [[pièce]] ) getIndexProperty ( [[cami]] ) ; } else { try { resolveNestedProperties ( [[cami]] ) ; return ( [[pièce]] ) getIndexProperty ( [[cami]] ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .
--------------------------------------------- Result 712 ---------------------------------------------
Register a table reference . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public void [[registerTableReference]] ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .

[[[[Adv]]]]: public void [[pièce]] ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .
--------------------------------------------- Result 713 ---------------------------------------------
Sets a simple property . --> Overridden to provide setter methods --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[setSimpleProperty]] ( final BeanProperty [[bp]] , final Object value ) { Setter [[setter]] = [[bp]] . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[maintaining]] ( final BeanProperty [[emulate]] , final Object value ) { Setter [[abandons]] = [[emulate]] . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .
--------------------------------------------- Result 714 ---------------------------------------------
Gets the table alias . --> Gets the name of the fragrant --> Socre: 1.0

[[[[Adv]]]]: public String [[getTableAlias]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( [[tableRef]] ) ; return t == null ? null : t . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .

[[[[Adv]]]]: public String [[fragrant]] ( final String [[craggy]] ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( [[craggy]] ) ; return t == null ? null : t . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .
--------------------------------------------- Result 715 ---------------------------------------------
Returns the entity descriptor for the table . --> Get the sudoku EntityDescriptor --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[getTableDescriptor]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( [[tableRef]] ) ; return t == null ? null : t . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .

[[[[Adv]]]]: public DbEntityDescriptor [[sudoku]] ( final String [[witherspoon]] ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( [[witherspoon]] ) ; return t == null ? null : t . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .
--------------------------------------------- Result 716 ---------------------------------------------
Inject attributes . --> Called by the jpServlet --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectAttributes]] ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .

[[[[Adv]]]]: protected void [[créme]] ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .
--------------------------------------------- Result 717 ---------------------------------------------
Convert to column name --> Convert a candlelit --> Socre: 1.0

[[[[Adv]]]]: public String applyToColumnName ( final String [[columnName]] ) { String propertyName = convertColumnNameToPropertyName ( [[columnName]] ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .

[[[[Adv]]]]: public String applyToColumnName ( final String [[candlelit]] ) { String propertyName = convertColumnNameToPropertyName ( [[candlelit]] ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .
--------------------------------------------- Result 718 ---------------------------------------------
Prepare get value . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[E]] > [[E]] prepareGetValue ( final T t , final Class < [[E]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[E]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[akasaka]] > [[akasaka]] prepareGetValue ( final T t , final Class < [[akasaka]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[akasaka]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .
--------------------------------------------- Result 719 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 673 / 31 / 15 / 719:  72%|███████▏  | 719/1000 [5:17:29<2:04:04, 26.49s/it][Succeeded / Failed / Skipped / Total] 673 / 31 / 15 / 719:  72%|███████▏  | 720/1000 [5:17:47<2:03:35, 26.48s/it][Succeeded / Failed / Skipped / Total] 674 / 31 / 15 / 720:  72%|███████▏  | 720/1000 [5:17:47<2:03:35, 26.48s/it][Succeeded / Failed / Skipped / Total] 674 / 31 / 15 / 720:  72%|███████▏  | 721/1000 [5:17:48<2:02:58, 26.45s/it][Succeeded / Failed / Skipped / Total] 675 / 31 / 15 / 721:  72%|███████▏  | 721/1000 [5:17:48<2:02:58, 26.45s/it][Succeeded / Failed / Skipped / Total] 675 / 31 / 15 / 721:  72%|███████▏  | 722/1000 [5:18:00<2:02:26, 26.43s/it][Succeeded / Failed / Skipped / Total] 676 / 31 / 15 / 722:  72%|███████▏  | 722/1000 [5:18:00<2:02:26, 26.43s/it][Succeeded / Failed / Skipped / Total] 676 / 31 / 15 / 722:  72%|███████▏  | 723/1000 [5:18:04<2:01:51, 26.40s/it][Succeeded / Failed / Skipped / Total] 677 / 31 / 15 / 723:  72%|███████▏  | 723/1000 [5:18:04<2:01:51, 26.40s/it][Succeeded / Failed / Skipped / Total] 677 / 31 / 15 / 723:  72%|███████▏  | 724/1000 [5:18:39<2:01:28, 26.41s/it][Succeeded / Failed / Skipped / Total] 678 / 31 / 15 / 724:  72%|███████▏  | 724/1000 [5:18:39<2:01:28, 26.41s/it][Succeeded / Failed / Skipped / Total] 678 / 31 / 15 / 724:  72%|███████▎  | 725/1000 [5:18:40<2:00:52, 26.37s/it]Store object . --> Store an object into the prepared statement --> Socre: 1.0

[[[[Adv]]]]: public void storeValue ( final PreparedStatement st , final int index , final Object value , final int [[dbSqlType]] ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , index , t , [[dbSqlType]] ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .

[[[[Adv]]]]: public void storeValue ( final PreparedStatement st , final int index , final Object value , final int [[heralded]] ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , index , t , [[heralded]] ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .
--------------------------------------------- Result 720 ---------------------------------------------
Returns the wrapper for the given class . --> This method is used to map a player to a player --> Socre: 1.0

[[[[Adv]]]]: public T [[resolve]] ( final Class < ? extends T > wrapperClass ) { String wrapperClassName = wrapperClass . getName ( ) ; T wrapper = lookup ( wrapperClassName ) ; if ( wrapper == null ) { wrapper = createWrapper ( wrapperClass ) ; initializeWrapper ( wrapper ) ; wrappers . put ( wrapperClassName , wrapper ) ; } return wrapper ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .

[[[[Adv]]]]: public T [[mãe]] ( final Class < ? extends T > wrapperClass ) { String wrapperClassName = wrapperClass . getName ( ) ; T wrapper = lookup ( wrapperClassName ) ; if ( wrapper == null ) { wrapper = createWrapper ( wrapperClass ) ; initializeWrapper ( wrapper ) ; wrappers . put ( wrapperClassName , wrapper ) ; } return wrapper ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .
--------------------------------------------- Result 721 ---------------------------------------------
Creates a new instance of the specified class . --> Method that can be used to recognize all mappers --> Socre: 1.0

[[[[Adv]]]]: protected < R [[extends]] T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .

[[[[Adv]]]]: protected < R [[comédie]] T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .
--------------------------------------------- Result 722 ---------------------------------------------
Inject uploaded files . --> Traverses the given ServletRequest --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectUploadedFiles]] ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > [[paramNames]] = multipartRequest . getFileParameterNames ( ) ; while ( [[paramNames]] . hasMoreElements ( ) ) { final String paramName = [[paramNames]] . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .

[[[[Adv]]]]: protected void [[outside]] ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > [[buys]] = multipartRequest . getFileParameterNames ( ) ; while ( [[buys]] . hasMoreElements ( ) ) { final String paramName = [[buys]] . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .
--------------------------------------------- Result 723 ---------------------------------------------
Convert column name to property name . --> chugg --> Socre: 1.0

[[[[Adv]]]]: public String [[convertColumnNameToPropertyName]] ( final String columnName ) { StringBuilder [[propertyName]] = new StringBuilder ( columnName . length ( ) ) ; int [[len]] = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int i = 0 ; i < [[len]] ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { [[propertyName]] . append ( Character . toUpperCase ( c ) ) ; toUpper = "False" != "False" ; } else { [[propertyName]] . append ( Character . toLowerCase ( c ) ) ; } } return [[propertyName]] . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .

[[[[Adv]]]]: public String [[chugga]] ( final String columnName ) { StringBuilder [[gamble]] = new StringBuilder ( columnName . length ( ) ) ; int [[wolter]] = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int i = 0 ; i < [[wolter]] ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { [[gamble]] . append ( Character . toUpperCase ( c ) ) ; toUpper = "False" != "False" ; } else { [[gamble]] . append ( Character . toLowerCase ( c ) ) ; } } return [[gamble]] . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .
--------------------------------------------- Result 724 ---------------------------------------------
Converts the specified path to system separators . --> Transform a path --> Socre: 1.0

[[[[Adv]]]]: public static String [[separatorsToSystem]] ( final String path ) { if ( path == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( path ) ; } else { return separatorsToUnix ( path ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .

[[[[Adv]]]]: public static String [[miri]] ( final String path ) { if ( path == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( path ) ; } else { return separatorsToUnix ( path ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .
--------------------------------------------- Result 725 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 678 / 31 / 16 / 725:  72%|███████▎  | 725/1000 [5:18:40<2:00:52, 26.37s/it][Succeeded / Failed / Skipped / Total] 678 / 31 / 16 / 725:  73%|███████▎  | 726/1000 [5:20:21<2:00:54, 26.48s/it][Succeeded / Failed / Skipped / Total] 679 / 31 / 16 / 726:  73%|███████▎  | 726/1000 [5:20:21<2:00:54, 26.48s/it][Succeeded / Failed / Skipped / Total] 679 / 31 / 16 / 726:  73%|███████▎  | 727/1000 [5:21:13<2:00:37, 26.51s/it][Succeeded / Failed / Skipped / Total] 680 / 31 / 16 / 727:  73%|███████▎  | 727/1000 [5:21:13<2:00:37, 26.51s/it][Succeeded / Failed / Skipped / Total] 680 / 31 / 16 / 727:  73%|███████▎  | 728/1000 [5:21:15<2:00:01, 26.48s/it][Succeeded / Failed / Skipped / Total] 681 / 31 / 16 / 728:  73%|███████▎  | 728/1000 [5:21:15<2:00:01, 26.48s/it][Succeeded / Failed / Skipped / Total] 681 / 31 / 16 / 728:  73%|███████▎  | 729/1000 [5:22:05<1:59:44, 26.51s/it][Succeeded / Failed / Skipped / Total] 682 / 31 / 16 / 729:  73%|███████▎  | 729/1000 [5:22:05<1:59:44, 26.51s/it][Succeeded / Failed / Skipped / Total] 682 / 31 / 16 / 729:  73%|███████▎  | 730/1000 [5:22:06<1:59:08, 26.47s/it][Succeeded / Failed / Skipped / Total] 683 / 31 / 16 / 730:  73%|███████▎  | 730/1000 [5:22:06<1:59:08, 26.47s/it][Succeeded / Failed / Skipped / Total] 683 / 31 / 16 / 730:  73%|███████▎  | 731/1000 [5:23:00<1:58:51, 26.51s/it][Succeeded / Failed / Skipped / Total] 684 / 31 / 16 / 731:  73%|███████▎  | 731/1000 [5:23:00<1:58:51, 26.51s/it][Succeeded / Failed / Skipped / Total] 684 / 31 / 16 / 731:  73%|███████▎  | 732/1000 [5:23:50<1:58:33, 26.54s/it][Succeeded / Failed / Skipped / Total] 685 / 31 / 16 / 732:  73%|███████▎  | 732/1000 [5:23:50<1:58:33, 26.54s/it][Succeeded / Failed / Skipped / Total] 685 / 31 / 16 / 732:  73%|███████▎  | 733/1000 [5:24:37<1:58:14, 26.57s/it]Register a Component --> [[[SKIPPED]]]

[[[[Adv]]]]: public WebApp registerComponent ( final Class < ? > madvocComponent ) { Objects . requireNonNull ( madvocComponent ) ; madvocComponents . add ( ClassConsumer . of ( madvocComponent ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .
--------------------------------------------- Result 726 ---------------------------------------------
Gets all wrappers . --> private helper methods --> Socre: 1.0

[[[[Adv]]]]: protected Set < T > [[getAll]] ( ) { final Set < T > [[set]] = new HashSet <> ( wrappers . size ( ) ) ; [[set]] . addAll ( wrappers . values ( ) ) ; return [[set]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .

[[[[Adv]]]]: protected Set < T > [[kjetil]] ( ) { final Set < T > [[parenthesis]] = new HashSet <> ( wrappers . size ( ) ) ; [[parenthesis]] . addAll ( wrappers . values ( ) ) ; return [[parenthesis]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .
--------------------------------------------- Result 727 ---------------------------------------------
Relative path . --> this method is used for test --> Socre: 1.0

[[[[Adv]]]]: public static String [[relativePath]] ( final String targetPath , final String [[basePath]] ) { return new File ( [[basePath]] ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .

[[[[Adv]]]]: public static String [[condoleezza]] ( final String targetPath , final String [[pedlar]] ) { return new File ( [[pedlar]] ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .
--------------------------------------------- Result 728 ---------------------------------------------
Starts the canvas . --> Initialize the awsh instance --> Socre: 1.0

[[[[Adv]]]]: public WebApp [[start]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .

[[[[Adv]]]]: public WebApp [[awash]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .
--------------------------------------------- Result 729 ---------------------------------------------
Registers the madvoc components . --> Register basic Hvoc container --> Socre: 1.0

[[[[Adv]]]]: protected void [[registerMadvocComponents]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .

[[[[Adv]]]]: protected void [[irst]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .
--------------------------------------------- Result 730 ---------------------------------------------
Sets defaults . --> Register default values --> Socre: 1.0

[[[[Adv]]]]: protected void configureDefaults ( ) { final ActionConfigManager [[actionConfigManager]] = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; [[actionConfigManager]] . registerAnnotation ( Action . class ) ; [[actionConfigManager]] . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .

[[[[Adv]]]]: protected void configureDefaults ( ) { final ActionConfigManager [[viktoria]] = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; [[viktoria]] . registerAnnotation ( Action . class ) ; [[viktoria]] . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .
--------------------------------------------- Result 731 ---------------------------------------------
Exclude specified jars . --> Configure the class scanner --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[excludeJars]] ( final String ... excludedJars ) { for ( final String excludedJar : excludedJars ) { rulesJars . exclude ( excludedJar ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .

[[[[Adv]]]]: public ClassScanner [[hitchcock]] ( final String ... excludedJars ) { for ( final String excludedJar : excludedJars ) { rulesJars . exclude ( excludedJar ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .
--------------------------------------------- Result 732 ---------------------------------------------
Includes specified entries . --> Add ALM rules to the class scanner --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[includeEntries]] ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .

[[[[Adv]]]]: public ClassScanner [[alm]] ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .
--------------------------------------------- Result 733 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 686 / 31 / 16 / 733:  73%|███████▎  | 733/1000 [5:24:37<1:58:14, 26.57s/it][Succeeded / Failed / Skipped / Total] 686 / 31 / 16 / 733:  73%|███████▎  | 734/1000 [5:24:37<1:57:38, 26.54s/it][Succeeded / Failed / Skipped / Total] 687 / 31 / 16 / 734:  73%|███████▎  | 734/1000 [5:24:37<1:57:38, 26.54s/it][Succeeded / Failed / Skipped / Total] 687 / 31 / 16 / 734:  74%|███████▎  | 735/1000 [5:25:14<1:57:15, 26.55s/it][Succeeded / Failed / Skipped / Total] 688 / 31 / 16 / 735:  74%|███████▎  | 735/1000 [5:25:14<1:57:15, 26.55s/it][Succeeded / Failed / Skipped / Total] 688 / 31 / 16 / 735:  74%|███████▎  | 736/1000 [5:25:59<1:56:55, 26.58s/it][Succeeded / Failed / Skipped / Total] 689 / 31 / 16 / 736:  74%|███████▎  | 736/1000 [5:25:59<1:56:55, 26.58s/it][Succeeded / Failed / Skipped / Total] 689 / 31 / 16 / 736:  74%|███████▎  | 737/1000 [5:26:47<1:56:37, 26.60s/it][Succeeded / Failed / Skipped / Total] 689 / 32 / 16 / 737:  74%|███████▎  | 737/1000 [5:26:47<1:56:37, 26.60s/it][Succeeded / Failed / Skipped / Total] 689 / 32 / 16 / 737:  74%|███████▍  | 738/1000 [5:27:31<1:56:16, 26.63s/it][Succeeded / Failed / Skipped / Total] 690 / 32 / 16 / 738:  74%|███████▍  | 738/1000 [5:27:31<1:56:16, 26.63s/it][Succeeded / Failed / Skipped / Total] 690 / 32 / 16 / 738:  74%|███████▍  | 739/1000 [5:28:16<1:55:56, 26.65s/it][Succeeded / Failed / Skipped / Total] 691 / 32 / 16 / 739:  74%|███████▍  | 739/1000 [5:28:16<1:55:56, 26.65s/it][Succeeded / Failed / Skipped / Total] 691 / 32 / 16 / 739:  74%|███████▍  | 740/1000 [5:28:25<1:55:23, 26.63s/it][Succeeded / Failed / Skipped / Total] 692 / 32 / 16 / 740:  74%|███████▍  | 740/1000 [5:28:25<1:55:23, 26.63s/it][Succeeded / Failed / Skipped / Total] 692 / 32 / 16 / 740:  74%|███████▍  | 741/1000 [5:28:37<1:54:51, 26.61s/it]Convert a property name to column name . --> Convert Tourzzo into Tourzzo --> Socre: 1.0

[[[[Adv]]]]: public String [[convertPropertyNameToColumnName]] ( final String [[propertyName]] ) { StringBuilder [[tableName]] = new StringBuilder ( [[propertyName]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( [[propertyName]] , separatorChar ) ; [[tableName]] . append ( convertedTableName ) ; } else { [[tableName]] . append ( [[propertyName]] ) ; } if ( ! changeCase ) { return [[tableName]] . toString ( ) ; } return uppercase ? toUppercase ( [[tableName]] ) . toString ( ) : toLowercase ( [[tableName]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .

[[[[Adv]]]]: public String [[abruzzo]] ( final String [[tours]] ) { StringBuilder [[angular]] = new StringBuilder ( [[tours]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( [[tours]] , separatorChar ) ; [[angular]] . append ( convertedTableName ) ; } else { [[angular]] . append ( [[tours]] ) ; } if ( ! changeCase ) { return [[angular]] . toString ( ) ; } return uppercase ? toUppercase ( [[angular]] ) . toString ( ) : toLowercase ( [[angular]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .
--------------------------------------------- Result 734 ---------------------------------------------
Exclude entries . --> Exclude entries from the class scanner --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... [[excludedEntries]] ) { for ( final String excludedEntry : [[excludedEntries]] ) { rulesEntries . exclude ( excludedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... [[anthony]] ) { for ( final String excludedEntry : [[anthony]] ) { rulesEntries . exclude ( excludedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .
--------------------------------------------- Result 735 ---------------------------------------------
Get path . --> archive a file --> Socre: 1.0

[[[[Adv]]]]: private static String [[doGetPath]] ( final String filename , final int [[separatorAdd]] ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + [[separatorAdd]] ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .

[[[[Adv]]]]: private static String [[archive]] ( final String filename , final int [[mãe]] ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + [[mãe]] ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .
--------------------------------------------- Result 736 ---------------------------------------------
Compute the signature of a type . --> Generate liba --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[bytecodeSignatureOfType]] ( final Class type ) { final String name = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .

[[[[Adv]]]]: public static byte [ ] [[liba]] ( final Class type ) { final String name = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .
--------------------------------------------- Result 737 ---------------------------------------------
Define an action config manager . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .

[[[[Adv]]]]: public < A [[deputize]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .
--------------------------------------------- Result 738 ---------------------------------------------
Scan the given paths . --> Add classes to the class scanner --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner scan ( final String ... [[paths]] ) { for ( final String path : [[paths]] ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .

[[[[Adv]]]]: public ClassScanner scan ( final String ... [[groom]] ) { for ( final String path : [[groom]] ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .
--------------------------------------------- Result 739 ---------------------------------------------
returns a new transaction --> returns a JtxTransaction --> Socre: 1.0

[[[[Adv]]]]: @ Override protected JtxTransaction [[createNewTransaction]] ( final JtxTransactionMode tm , final Object scope , final boolean active ) { return new DbJtxTransaction ( this , tm , scope , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .

[[[[Adv]]]]: @ Override protected JtxTransaction [[abstinence]] ( final JtxTransactionMode tm , final Object scope , final boolean active ) { return new DbJtxTransaction ( this , tm , scope , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .
--------------------------------------------- Result 740 ---------------------------------------------
Starts the crawler . --> Scan all files --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String path = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .

[[[[Adv]]]]: public void [[mongolia]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String path = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .
--------------------------------------------- Result 741 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 692 / 33 / 16 / 741:  74%|███████▍  | 741/1000 [5:28:37<1:54:51, 26.61s/it][Succeeded / Failed / Skipped / Total] 692 / 33 / 16 / 741:  74%|███████▍  | 742/1000 [5:29:29<1:54:33, 26.64s/it][Succeeded / Failed / Skipped / Total] 693 / 33 / 16 / 742:  74%|███████▍  | 742/1000 [5:29:29<1:54:33, 26.64s/it][Succeeded / Failed / Skipped / Total] 693 / 33 / 16 / 742:  74%|███████▍  | 743/1000 [5:30:14<1:54:13, 26.67s/it][Succeeded / Failed / Skipped / Total] 694 / 33 / 16 / 743:  74%|███████▍  | 743/1000 [5:30:14<1:54:13, 26.67s/it][Succeeded / Failed / Skipped / Total] 694 / 33 / 16 / 743:  74%|███████▍  | 744/1000 [5:34:50<1:55:12, 27.00s/it][Succeeded / Failed / Skipped / Total] 695 / 33 / 16 / 744:  74%|███████▍  | 744/1000 [5:34:50<1:55:12, 27.00s/it][Succeeded / Failed / Skipped / Total] 695 / 33 / 16 / 744:  74%|███████▍  | 745/1000 [5:35:39<1:54:53, 27.03s/it][Succeeded / Failed / Skipped / Total] 696 / 33 / 16 / 745:  74%|███████▍  | 745/1000 [5:35:39<1:54:53, 27.03s/it][Succeeded / Failed / Skipped / Total] 696 / 33 / 16 / 745:  75%|███████▍  | 746/1000 [5:38:57<1:55:24, 27.26s/it]Inject request parameters . --> [[[FAILED]]]

[[[[Adv]]]]: protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String [[encoding]] = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , [[encoding]] ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .

[[[[Adv]]]]: protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String [[rainforests]] = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , [[rainforests]] ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .
--------------------------------------------- Result 742 ---------------------------------------------
Includes the specified jars . --> include tarpon --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner includeJars ( final String ... [[includedJars]] ) { for ( final String [[includedJar]] : [[includedJars]] ) { rulesJars . include ( [[includedJar]] ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .

[[[[Adv]]]]: public ClassScanner includeJars ( final String ... [[tarpon]] ) { for ( final String [[calls]] : [[tarpon]] ) { rulesJars . include ( [[calls]] ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .
--------------------------------------------- Result 743 ---------------------------------------------
Creates a new madvoc scope . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public void forScope ( final Class < ? extends MadvocScope > [[scopeType]] , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope scope = getOrInitScope ( [[scopeType]] ) ; madvocScopeConsumer . accept ( scope ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .

[[[[Adv]]]]: public void forScope ( final Class < ? extends MadvocScope > [[müssen]] , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope scope = getOrInitScope ( [[müssen]] ) ; madvocScopeConsumer . accept ( scope ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .
--------------------------------------------- Result 744 ---------------------------------------------
Decodes a byte array to a byte array . --> returns the exchange data --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] decode ( final char [ ] [[arr]] ) { int length = [[arr]] . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = [[arr]] [ endx ] == ' ' ? ( [[arr]] [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( [[arr]] [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ [[arr]] [ sndx ++ ] ] << 18 | INV [ [[arr]] [ sndx ++ ] ] << 12 | INV [ [[arr]] [ sndx ++ ] ] << 6 | INV [ [[arr]] [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ [[arr]] [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .

[[[[Adv]]]]: public static byte [ ] decode ( final char [ ] [[economic]] ) { int length = [[economic]] . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = [[economic]] [ endx ] == ' ' ? ( [[economic]] [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( [[economic]] [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ [[economic]] [ sndx ++ ] ] << 18 | INV [ [[economic]] [ sndx ++ ] ] << 12 | INV [ [[economic]] [ sndx ++ ] ] << 6 | INV [ [[economic]] [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ [[economic]] [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .
--------------------------------------------- Result 745 ---------------------------------------------
Get or initialize scope type --> Methode permettant deactivation --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[extends]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[én]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .
--------------------------------------------- Result 746 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 697 / 33 / 16 / 746:  75%|███████▍  | 746/1000 [5:38:57<1:55:24, 27.26s/it][Succeeded / Failed / Skipped / Total] 697 / 33 / 16 / 746:  75%|███████▍  | 747/1000 [5:40:12<1:55:13, 27.33s/it][Succeeded / Failed / Skipped / Total] 698 / 33 / 16 / 747:  75%|███████▍  | 747/1000 [5:40:12<1:55:13, 27.33s/it][Succeeded / Failed / Skipped / Total] 698 / 33 / 16 / 747:  75%|███████▍  | 748/1000 [5:40:25<1:54:41, 27.31s/it][Succeeded / Failed / Skipped / Total] 699 / 33 / 16 / 748:  75%|███████▍  | 748/1000 [5:40:25<1:54:41, 27.31s/it][Succeeded / Failed / Skipped / Total] 699 / 33 / 16 / 748:  75%|███████▍  | 749/1000 [5:41:20<1:54:23, 27.34s/it][Succeeded / Failed / Skipped / Total] 700 / 33 / 16 / 749:  75%|███████▍  | 749/1000 [5:41:20<1:54:23, 27.34s/it][Succeeded / Failed / Skipped / Total] 700 / 33 / 16 / 749:  75%|███████▌  | 750/1000 [5:45:44<1:55:14, 27.66s/it][Succeeded / Failed / Skipped / Total] 701 / 33 / 16 / 750:  75%|███████▌  | 750/1000 [5:45:44<1:55:14, 27.66s/it][Succeeded / Failed / Skipped / Total] 701 / 33 / 16 / 750:  75%|███████▌  | 751/1000 [5:47:27<1:55:12, 27.76s/it]Scans the classpath tree . --> Recursively scan the specified file --> Socre: 1.0

[[[[Adv]]]]: protected void scanClassPath ( final File [[root]] ) { String [[rootPath]] = [[root]] . getAbsolutePath ( ) ; if ( ! [[rootPath]] . endsWith ( File . separator ) ) { [[rootPath]] += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( [[rootPath]] ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , [[rootPath]] , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , [[rootPath]] , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .

[[[[Adv]]]]: protected void scanClassPath ( final File [[banyan]] ) { String [[thieves]] = [[banyan]] . getAbsolutePath ( ) ; if ( ! [[thieves]] . endsWith ( File . separator ) ) { [[thieves]] += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( [[thieves]] ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , [[thieves]] , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , [[thieves]] , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .
--------------------------------------------- Result 747 ---------------------------------------------
Prepare a CSRF token . --> Generate a random string --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String prepareCsrfToken ( final HttpSession session , final int [[timeToLive]] ) { Set < Token > [[tokenSet]] = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( [[tokenSet]] == null ) { [[tokenSet]] = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , [[tokenSet]] ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( [[tokenSet]] ) ; unique = [[tokenSet]] . add ( new Token ( value , [[timeToLive]] ) ) ; } while ( ! unique ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String prepareCsrfToken ( final HttpSession session , final int [[parlour]] ) { Set < Token > [[gassed]] = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( [[gassed]] == null ) { [[gassed]] = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , [[gassed]] ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( [[gassed]] ) ; unique = [[gassed]] . add ( new Token ( value , [[parlour]] ) ) ; } while ( ! unique ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .
--------------------------------------------- Result 748 ---------------------------------------------
Gets the scope of the given type . --> else return null --> Socre: 1.0

[[[[Adv]]]]: protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope [[s]] : allScopes ) { if ( [[s]] . getClass ( ) . equals ( madvocScopeType ) ) { return [[s]] ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .

[[[[Adv]]]]: protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope [[ángel]] : allScopes ) { if ( [[ángel]] . getClass ( ) . equals ( madvocScopeType ) ) { return [[ángel]] ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .
--------------------------------------------- Result 749 ---------------------------------------------
Set property . --> Overriding superclass method --> Socre: 1.0

[[[[Adv]]]]: @ Override protected boolean [[visitProperty]] ( String name , final Object value ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , name , value ) ; return "True" == "True" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .

[[[[Adv]]]]: @ Override protected boolean [[dunham]] ( String name , final Object value ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , name , value ) ; return "True" == "True" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .
--------------------------------------------- Result 750 ---------------------------------------------
Initializes the entity reference . --> Register the parameters for the template --> Socre: 1.0

[[[[Adv]]]]: @ Override public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . [[tableReference]] ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } templateData . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .

[[[[Adv]]]]: @ Override public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . [[parlour]] ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } templateData . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .
--------------------------------------------- Result 751 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 702 / 33 / 16 / 751:  75%|███████▌  | 751/1000 [5:47:27<1:55:12, 27.76s/it][Succeeded / Failed / Skipped / Total] 702 / 33 / 16 / 751:  75%|███████▌  | 752/1000 [5:47:29<1:54:35, 27.73s/it][Succeeded / Failed / Skipped / Total] 703 / 33 / 16 / 752:  75%|███████▌  | 752/1000 [5:47:29<1:54:35, 27.73s/it][Succeeded / Failed / Skipped / Total] 703 / 33 / 16 / 752:  75%|███████▌  | 753/1000 [5:48:03<1:54:10, 27.73s/it][Succeeded / Failed / Skipped / Total] 704 / 33 / 16 / 753:  75%|███████▌  | 753/1000 [5:48:03<1:54:10, 27.73s/it][Succeeded / Failed / Skipped / Total] 704 / 33 / 16 / 753:  75%|███████▌  | 754/1000 [5:48:12<1:53:36, 27.71s/it][Succeeded / Failed / Skipped / Total] 705 / 33 / 16 / 754:  75%|███████▌  | 754/1000 [5:48:12<1:53:36, 27.71s/it][Succeeded / Failed / Skipped / Total] 705 / 33 / 16 / 754:  76%|███████▌  | 755/1000 [5:48:52<1:53:12, 27.73s/it][Succeeded / Failed / Skipped / Total] 706 / 33 / 16 / 755:  76%|███████▌  | 755/1000 [5:48:52<1:53:12, 27.73s/it][Succeeded / Failed / Skipped / Total] 706 / 33 / 16 / 755:  76%|███████▌  | 756/1000 [5:49:06<1:52:40, 27.71s/it]Scan the jar file to find all the resources . --> Mazel code --> Socre: 1.0

[[[[Adv]]]]: protected void [[scanJarFile]] ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String [[zipEntryName]] = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( [[zipEntryName]] , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( [[zipEntryName]] , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( [[zipEntryName]] , "[[False]]" != "[[False]]" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .

[[[[Adv]]]]: protected void [[mazel]] ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String [[intersections]] = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( [[intersections]] , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( [[intersections]] , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( [[intersections]] , "[[Abandons]]" != "[[Abandons]]" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .
--------------------------------------------- Result 752 ---------------------------------------------
Make this bean . --> Cobby interface --> Socre: 1.0

[[[[Adv]]]]: public void [[copy]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "[[True]]" == "[[True]]" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .

[[[[Adv]]]]: public void [[cobby]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "[[Bloodlines]]" == "[[Bloodlines]]" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .
--------------------------------------------- Result 753 ---------------------------------------------
Make sure that the token has expired . --> Bloomer --> Socre: 1.0

[[[[Adv]]]]: protected static void [[assureSize]] ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long [[validUntilMin]] = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < [[validUntilMin]] ) { [[validUntilMin]] = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .

[[[[Adv]]]]: protected static void [[bloomer]] ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long [[dope]] = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < [[dope]] ) { [[dope]] = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .
--------------------------------------------- Result 754 ---------------------------------------------
Create bean copy . --> copy from hophead --> Socre: 1.0

[[[[Adv]]]]: public static BeanCopy from ( final Object [[source]] ) { BeanCopy [[beanCopy]] = new BeanCopy ( [[source]] ) ; [[beanCopy]] . isSourceMap = [[source]] instanceof Map ; return [[beanCopy]] ; }
[[[[Nl]]]]: Defines source detects a map .

[[[[Adv]]]]: public static BeanCopy from ( final Object [[hophead]] ) { BeanCopy [[niggers]] = new BeanCopy ( [[hophead]] ) ; [[niggers]] . isSourceMap = [[hophead]] instanceof Map ; return [[niggers]] ; }
[[[[Nl]]]]: Defines source detects a map .
--------------------------------------------- Result 755 ---------------------------------------------
Remove bean . --> Bamberg - BEamberg - BEamberg --> Socre: 1.0

[[[[Adv]]]]: public void [[removeBean]] ( final Class type ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .

[[[[Adv]]]]: public void [[bamberg]] ( final Class type ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .
--------------------------------------------- Result 756 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 706 / 34 / 16 / 756:  76%|███████▌  | 756/1000 [5:49:06<1:52:40, 27.71s/it][Succeeded / Failed / Skipped / Total] 706 / 34 / 16 / 756:  76%|███████▌  | 757/1000 [5:58:31<1:55:05, 28.42s/it][Succeeded / Failed / Skipped / Total] 707 / 34 / 16 / 757:  76%|███████▌  | 757/1000 [5:58:31<1:55:05, 28.42s/it][Succeeded / Failed / Skipped / Total] 707 / 34 / 16 / 757:  76%|███████▌  | 758/1000 [5:58:51<1:54:34, 28.41s/it][Succeeded / Failed / Skipped / Total] 708 / 34 / 16 / 758:  76%|███████▌  | 758/1000 [5:58:51<1:54:34, 28.41s/it][Succeeded / Failed / Skipped / Total] 708 / 34 / 16 / 758:  76%|███████▌  | 759/1000 [5:59:11<1:54:03, 28.39s/it]Splits the given filename into parts . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [ ] split ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String path ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , path , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .

[[[[Adv]]]]: public static String [ ] split ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String path ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , path , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .
--------------------------------------------- Result 757 ---------------------------------------------
Registers a new CtorCtorInjectionPoint . --> Register a new CtorCtorInjectionPoint --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "[[True]]" == "[[True]]" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .

[[[[Adv]]]]: public void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "[[Brunner]]" == "[[Brunner]]" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .
--------------------------------------------- Result 758 ---------------------------------------------
Register petite bean . --> used for unit tests --> Socre: 1.0

[[[[Adv]]]]: public < T > BeanDefinition < T > registerPetiteBean ( final Class < T > type , String name , Class < ? extends Scope > [[scopeType]] , WiringMode wiringMode , final boolean define , final Consumer < T > [[consumer]] ) { if ( name == null ) { name = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( [[scopeType]] == null ) { [[scopeType]] = annotationResolver . resolveBeanScopeType ( type ) ; } if ( [[scopeType]] == null ) { [[scopeType]] = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .

[[[[Adv]]]]: public < T > BeanDefinition < T > registerPetiteBean ( final Class < T > type , String name , Class < ? extends Scope > [[benoit]] , WiringMode wiringMode , final boolean define , final Consumer < T > [[bateman]] ) { if ( name == null ) { name = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( [[benoit]] == null ) { [[benoit]] = annotationResolver . resolveBeanScopeType ( type ) ; } if ( [[benoit]] == null ) { [[benoit]] = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .
--------------------------------------------- Result 759 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 709 / 34 / 16 / 759:  76%|███████▌  | 759/1000 [5:59:11<1:54:03, 28.39s/it][Succeeded / Failed / Skipped / Total] 709 / 34 / 16 / 759:  76%|███████▌  | 760/1000 [6:00:36<1:53:52, 28.47s/it][Succeeded / Failed / Skipped / Total] 710 / 34 / 16 / 760:  76%|███████▌  | 760/1000 [6:00:36<1:53:52, 28.47s/it][Succeeded / Failed / Skipped / Total] 710 / 34 / 16 / 760:  76%|███████▌  | 761/1000 [6:02:12<1:53:45, 28.56s/it][Succeeded / Failed / Skipped / Total] 711 / 34 / 16 / 761:  76%|███████▌  | 761/1000 [6:02:12<1:53:45, 28.56s/it][Succeeded / Failed / Skipped / Total] 711 / 34 / 16 / 761:  76%|███████▌  | 762/1000 [6:04:17<1:53:46, 28.68s/it][Succeeded / Failed / Skipped / Total] 712 / 34 / 16 / 762:  76%|███████▌  | 762/1000 [6:04:17<1:53:46, 28.68s/it][Succeeded / Failed / Skipped / Total] 712 / 34 / 16 / 762:  76%|███████▋  | 763/1000 [6:10:01<1:54:56, 29.10s/it]Retrieves a scope . --> used in tests --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[extends]] Scope > S resolveScope ( final Class < S > scopeType ) { S [[scope]] = ( S ) scopes . get ( scopeType ) ; if ( [[scope]] == null ) { try { [[scope]] = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , [[scope]] ) ; scopes . put ( scopeType , [[scope]] ) ; } return [[scope]] ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[björk]] Scope > S resolveScope ( final Class < S > scopeType ) { S [[changelings]] = ( S ) scopes . get ( scopeType ) ; if ( [[changelings]] == null ) { try { [[changelings]] = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , [[changelings]] ) ; scopes . put ( scopeType , [[changelings]] ) ; } return [[changelings]] ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .
--------------------------------------------- Result 760 ---------------------------------------------
Registers a set injection point --> Register a SetInjectionPoint --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String [[property]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( [[property]] , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + [[property]] ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( sip ) ; }
[[[[Nl]]]]: Registers set injection point .

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String [[bedfellows]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( [[bedfellows]] , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + [[bedfellows]] ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( sip ) ; }
[[[[Nl]]]]: Registers set injection point .
--------------------------------------------- Result 761 ---------------------------------------------
Register a bean . --> register a wedge --> Socre: 1.0

[[[[Adv]]]]: protected void registerBean ( final String [[name]] , final BeanDefinition beanDefinition ) { beans . put ( [[name]] , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class [[type]] = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( [[type]] ) ) { return ; } Class [ ] [[interfaces]] = ClassUtil . resolveAllInterfaces ( [[type]] ) ; for ( Class anInterface : [[interfaces]] ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( [[name]] . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .

[[[[Adv]]]]: protected void registerBean ( final String [[edged]] , final BeanDefinition beanDefinition ) { beans . put ( [[edged]] , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class [[pâté]] = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( [[pâté]] ) ) { return ; } Class [ ] [[monster]] = ClassUtil . resolveAllInterfaces ( [[pâté]] ) ; for ( Class anInterface : [[monster]] ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( [[edged]] . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .
--------------------------------------------- Result 762 ---------------------------------------------
Register a new Petite provider --> Register a new PetiteProvider --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class [[beanType]] = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanType]] ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class [[wrightwood]] = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[wrightwood]] ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .
--------------------------------------------- Result 763 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 713 / 34 / 16 / 763:  76%|███████▋  | 763/1000 [6:10:01<1:54:56, 29.10s/it][Succeeded / Failed / Skipped / Total] 713 / 34 / 16 / 763:  76%|███████▋  | 764/1000 [6:11:03<1:54:37, 29.14s/it][Succeeded / Failed / Skipped / Total] 714 / 34 / 16 / 764:  76%|███████▋  | 764/1000 [6:11:03<1:54:37, 29.14s/it][Succeeded / Failed / Skipped / Total] 714 / 34 / 16 / 764:  76%|███████▋  | 765/1000 [6:11:18<1:54:03, 29.12s/it][Succeeded / Failed / Skipped / Total] 715 / 34 / 16 / 765:  76%|███████▋  | 765/1000 [6:11:18<1:54:03, 29.12s/it][Succeeded / Failed / Skipped / Total] 715 / 34 / 16 / 765:  77%|███████▋  | 766/1000 [6:12:08<1:53:41, 29.15s/it][Succeeded / Failed / Skipped / Total] 716 / 34 / 16 / 766:  77%|███████▋  | 766/1000 [6:12:08<1:53:41, 29.15s/it][Succeeded / Failed / Skipped / Total] 716 / 34 / 16 / 766:  77%|███████▋  | 767/1000 [6:14:21<1:53:43, 29.28s/it]Return the names of the given type . --> add beans to the list --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[resolveBeanNamesForType]] ( final Class type ) { String [ ] beanNames = beanCollections . get ( type ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition [[beanDefinition]] = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( [[beanDefinition]] . type , type ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY ; } else { beanNames = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( type , beanNames ) ; return beanNames ; }
[[[[Nl]]]]: Resolves bean names for give type .

[[[[Adv]]]]: protected String [ ] [[maddest]] ( final Class type ) { String [ ] beanNames = beanCollections . get ( type ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition [[messerschmitt]] = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( [[messerschmitt]] . type , type ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY ; } else { beanNames = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( type , beanNames ) ; return beanNames ; }
[[[[Nl]]]]: Resolves bean names for give type .
--------------------------------------------- Result 764 ---------------------------------------------
Iterate over all beans of a given type . --> Calls before beanName consumer --> Socre: 1.0

[[[[Adv]]]]: public void [[forEachBeanType]] ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .

[[[[Adv]]]]: public void [[beforeyou]] ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .
--------------------------------------------- Result 765 ---------------------------------------------
Register a poisonite destroy method . --> determine the destruction methods --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int [[total]] = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ [[total]] ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "[[True]]" == "[[True]]" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .

[[[[Adv]]]]: public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int [[enchanté]] = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ [[enchanté]] ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "[[Kiara]]" == "[[Kiara]]" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .
--------------------------------------------- Result 766 ---------------------------------------------
Registers a new method in the specified bean . --> Generates a crumb for a given gill request --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteMethodInjectionPoint]] ( final String [[beanName]] , final String methodName , final Class [ ] arguments , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( [[beanName]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .

[[[[Adv]]]]: public void [[crumb]] ( final String [[gilligan]] , final String methodName , final Class [ ] arguments , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( [[gilligan]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .
--------------------------------------------- Result 767 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 717 / 34 / 16 / 767:  77%|███████▋  | 767/1000 [6:14:21<1:53:43, 29.28s/it][Succeeded / Failed / Skipped / Total] 717 / 34 / 16 / 767:  77%|███████▋  | 768/1000 [6:14:55<1:53:15, 29.29s/it][Succeeded / Failed / Skipped / Total] 718 / 34 / 16 / 768:  77%|███████▋  | 768/1000 [6:14:55<1:53:15, 29.29s/it][Succeeded / Failed / Skipped / Total] 718 / 34 / 16 / 768:  77%|███████▋  | 769/1000 [6:15:50<1:52:54, 29.32s/it][Succeeded / Failed / Skipped / Total] 719 / 34 / 16 / 769:  77%|███████▋  | 769/1000 [6:15:50<1:52:54, 29.32s/it][Succeeded / Failed / Skipped / Total] 719 / 34 / 16 / 769:  77%|███████▋  | 770/1000 [6:17:29<1:52:45, 29.41s/it][Succeeded / Failed / Skipped / Total] 720 / 34 / 16 / 770:  77%|███████▋  | 770/1000 [6:17:29<1:52:45, 29.41s/it][Succeeded / Failed / Skipped / Total] 720 / 34 / 16 / 770:  77%|███████▋  | 771/1000 [6:26:44<1:54:52, 30.10s/it][Succeeded / Failed / Skipped / Total] 721 / 34 / 16 / 771:  77%|███████▋  | 771/1000 [6:26:44<1:54:52, 30.10s/it][Succeeded / Failed / Skipped / Total] 721 / 34 / 16 / 771:  77%|███████▋  | 772/1000 [6:28:55<1:54:51, 30.23s/it][Succeeded / Failed / Skipped / Total] 721 / 35 / 16 / 772:  77%|███████▋  | 772/1000 [6:28:55<1:54:51, 30.23s/it][Succeeded / Failed / Skipped / Total] 721 / 35 / 16 / 772:  77%|███████▋  | 773/1000 [6:29:33<1:54:23, 30.24s/it]Registers an existing init methods for the given bean . --> Elimit a bean definition --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteInitMethods]] ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor [[md]] = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( [[md]] == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( [[md]] . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .

[[[[Adv]]]]: public void [[klimt]] ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor [[matchmaking]] = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( [[matchmaking]] == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( [[matchmaking]] . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .
--------------------------------------------- Result 768 ---------------------------------------------
Intercepts the given action request . --> Interceptor call --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object intercept ( final ActionRequest [[actionRequest]] ) throws Exception { printBefore ( [[actionRequest]] ) ; long startTime = System . currentTimeMillis ( ) ; Object result = null ; try { result = [[actionRequest]] . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( [[actionRequest]] , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .

[[[[Adv]]]]: @ Override public Object intercept ( final ActionRequest [[tartare]] ) throws Exception { printBefore ( [[tartare]] ) ; long startTime = System . currentTimeMillis ( ) ; Object result = null ; try { result = [[tartare]] . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( [[tartare]] , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .
--------------------------------------------- Result 769 ---------------------------------------------
Check that the given index is valid . --> Check if there is a failure --> Socre: 1.0

[[[[Adv]]]]: public static void [[checkArgumentIndex]] ( final MethodInfo methodInfo , final int argIndex ) { if ( ( argIndex < 1 ) || ( argIndex > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + argIndex ) ; } }
[[[[Nl]]]]: Validates argument index .

[[[[Adv]]]]: public static void [[dae]] ( final MethodInfo methodInfo , final int argIndex ) { if ( ( argIndex < 1 ) || ( argIndex > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + argIndex ) ; } }
[[[[Nl]]]]: Validates argument index .
--------------------------------------------- Result 770 ---------------------------------------------
Get advice field name --> Weka toolbar --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceFieldName]] ( final String name , final int index ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + index ; }
[[[[Nl]]]]: Builds advice field name .

[[[[Adv]]]]: public static String [[chewbacca]] ( final String name , final int index ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + index ; }
[[[[Nl]]]]: Builds advice field name .
--------------------------------------------- Result 771 ---------------------------------------------
Pushes an integer onto the stack . --> BIPUSH instructions --> Socre: 1.0

[[[[Adv]]]]: public static void [[pushInt]] ( final MethodVisitor mv , final int [[value]] ) { if ( [[value]] <= 5 ) { mv . visitInsn ( ICONST_0 + [[value]] ) ; } else if ( [[value]] <= Byte . MAX_VALUE ) { mv . visitIntInsn ( BIPUSH , [[value]] ) ; } else { mv . visitIntInsn ( SIPUSH , [[value]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .

[[[[Adv]]]]: public static void [[brazil]] ( final MethodVisitor mv , final int [[tamra]] ) { if ( [[tamra]] <= 5 ) { mv . visitInsn ( ICONST_0 + [[tamra]] ) ; } else if ( [[tamra]] <= Byte . MAX_VALUE ) { mv . visitIntInsn ( BIPUSH , [[tamra]] ) ; } else { mv . visitIntInsn ( SIPUSH , [[tamra]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .
--------------------------------------------- Result 772 ---------------------------------------------
Checks whether the given token value matches the given value . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession session , final String tokenValue ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( tokenValue == null ) ) { return "True" == "True" ; } if ( ( tokenSet == null ) || ( tokenValue == null ) ) { return "False" != "False" ; } boolean found = "False" != "False" ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( tokenValue ) ) { it . remove ( ) ; found = "True" == "True" ; } } return found ; }
[[[[Nl]]]]: Checks token value . C

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession session , final String tokenValue ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( tokenValue == null ) ) { return "True" == "True" ; } if ( ( tokenSet == null ) || ( tokenValue == null ) ) { return "False" != "False" ; } boolean found = "False" != "False" ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( tokenValue ) ) { it . remove ( ) ; found = "True" == "True" ; } } return found ; }
[[[[Nl]]]]: Checks token value . C
--------------------------------------------- Result 773 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 722 / 35 / 16 / 773:  77%|███████▋  | 773/1000 [6:29:33<1:54:23, 30.24s/it][Succeeded / Failed / Skipped / Total] 722 / 35 / 16 / 773:  77%|███████▋  | 774/1000 [6:30:15<1:53:57, 30.25s/it][Succeeded / Failed / Skipped / Total] 722 / 36 / 16 / 774:  77%|███████▋  | 774/1000 [6:30:15<1:53:57, 30.25s/it][Succeeded / Failed / Skipped / Total] 722 / 36 / 16 / 774:  78%|███████▊  | 775/1000 [6:30:29<1:53:22, 30.23s/it][Succeeded / Failed / Skipped / Total] 723 / 36 / 16 / 775:  78%|███████▊  | 775/1000 [6:30:29<1:53:22, 30.23s/it][Succeeded / Failed / Skipped / Total] 723 / 36 / 16 / 775:  78%|███████▊  | 776/1000 [6:32:38<1:53:20, 30.36s/it][Succeeded / Failed / Skipped / Total] 724 / 36 / 16 / 776:  78%|███████▊  | 776/1000 [6:32:38<1:53:20, 30.36s/it][Succeeded / Failed / Skipped / Total] 724 / 36 / 16 / 776:  78%|███████▊  | 777/1000 [6:33:13<1:52:51, 30.36s/it][Succeeded / Failed / Skipped / Total] 725 / 36 / 16 / 777:  78%|███████▊  | 777/1000 [6:33:13<1:52:51, 30.36s/it][Succeeded / Failed / Skipped / Total] 725 / 36 / 16 / 777:  78%|███████▊  | 778/1000 [6:36:39<1:53:11, 30.59s/it][Succeeded / Failed / Skipped / Total] 726 / 36 / 16 / 778:  78%|███████▊  | 778/1000 [6:36:39<1:53:11, 30.59s/it][Succeeded / Failed / Skipped / Total] 726 / 36 / 16 / 778:  78%|███████▊  | 779/1000 [6:36:39<1:52:31, 30.55s/it][Succeeded / Failed / Skipped / Total] 727 / 36 / 16 / 779:  78%|███████▊  | 779/1000 [6:36:39<1:52:31, 30.55s/it][Succeeded / Failed / Skipped / Total] 727 / 36 / 16 / 779:  78%|███████▊  | 780/1000 [6:38:56<1:52:31, 30.69s/it]Define a set of parameters . --> This method is used to update the internal data structures --> Socre: 1.0

[[[[Adv]]]]: public void [[defineParameters]] ( final Map < ? , ? > [[properties]] ) { for ( Map . Entry < ? , ? > [[entry]] : [[properties]] . entrySet ( ) ) { defineParameter ( [[entry]] . getKey ( ) . toString ( ) , [[entry]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .

[[[[Adv]]]]: public void [[vitória]] ( final Map < ? , ? > [[acknowledges]] ) { for ( Map . Entry < ? , ? > [[valance]] : [[acknowledges]] . entrySet ( ) ) { defineParameter ( [[valance]] . getKey ( ) . toString ( ) , [[valance]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .
--------------------------------------------- Result 774 ---------------------------------------------
Registers a property injection point . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "[[True]]" == "[[True]]" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + [[beanDefinition]] . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; [[beanDefinition]] . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .

[[[[Adv]]]]: public void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { BeanDefinition [[tami]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[tami]] . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "[[Bypassed]]" == "[[Bypassed]]" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + [[tami]] . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; [[tami]] . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .
--------------------------------------------- Result 775 ---------------------------------------------
Load static method arguments . --> Sets the cleartonction of a --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadStaticMethodArguments]] ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int i = 0 ; i < methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .

[[[[Adv]]]]: public static void [[soupçon]] ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int i = 0 ; i < methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .
--------------------------------------------- Result 776 ---------------------------------------------
Resolves Java version . --> returns the number of given number of pipelines --> Socre: 1.0

[[[[Adv]]]]: public static int [[resolveJavaVersion]] ( final int [[version]] ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[platformVersion]] = javaVersionNumber - 8 + 52 ; return [[version]] > [[platformVersion]] ? [[version]] : [[platformVersion]] ; }
[[[[Nl]]]]: Resolves Java version from current version .

[[[[Adv]]]]: public static int [[je]] ( final int [[pipelines]] ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[benighted]] = javaVersionNumber - 8 + 52 ; return [[pipelines]] > [[benighted]] ? [[pipelines]] : [[benighted]] ; }
[[[[Nl]]]]: Resolves Java version from current version .
--------------------------------------------- Result 777 ---------------------------------------------
Register a provider --> Register a kujo --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteProvider]] ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor [[cd]] = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = [[cd]] . getMethodDescriptor ( staticMethodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .

[[[[Adv]]]]: public void [[kujo]] ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor [[varicose]] = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = [[varicose]] . getMethodDescriptor ( staticMethodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .
--------------------------------------------- Result 778 ---------------------------------------------
Load method argument . --> visit a method on the stack --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadMethodArgument]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int [[type]] = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( [[type]] ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[danby]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int [[guinea]] = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( [[guinea]] ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 779 ---------------------------------------------
Get advice method name . --> Acquires an acronym --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceMethodName]] ( final String [[name]] , final int [[index]] ) { return ProxettaNames . methodPrefix + [[name]] + ProxettaNames . methodDivider + [[index]] ; }
[[[[Nl]]]]: Builds advice method name .

[[[[Adv]]]]: public static String [[athletic]] ( final String [[breasts]] , final int [[hurly]] ) { return ProxettaNames . methodPrefix + [[breasts]] + ProxettaNames . methodDivider + [[hurly]] ; }
[[[[Nl]]]]: Builds advice method name .
--------------------------------------------- Result 780 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 728 / 36 / 16 / 780:  78%|███████▊  | 780/1000 [6:38:56<1:52:31, 30.69s/it][Succeeded / Failed / Skipped / Total] 728 / 36 / 16 / 780:  78%|███████▊  | 781/1000 [6:39:05<1:51:54, 30.66s/it][Succeeded / Failed / Skipped / Total] 729 / 36 / 16 / 781:  78%|███████▊  | 781/1000 [6:39:05<1:51:54, 30.66s/it][Succeeded / Failed / Skipped / Total] 729 / 36 / 16 / 781:  78%|███████▊  | 782/1000 [6:41:44<1:51:59, 30.82s/it][Succeeded / Failed / Skipped / Total] 730 / 36 / 16 / 782:  78%|███████▊  | 782/1000 [6:41:44<1:51:59, 30.82s/it][Succeeded / Failed / Skipped / Total] 730 / 36 / 16 / 782:  78%|███████▊  | 783/1000 [6:42:15<1:51:28, 30.82s/it][Succeeded / Failed / Skipped / Total] 731 / 36 / 16 / 783:  78%|███████▊  | 783/1000 [6:42:15<1:51:28, 30.82s/it][Succeeded / Failed / Skipped / Total] 731 / 36 / 16 / 783:  78%|███████▊  | 784/1000 [6:42:17<1:50:50, 30.79s/it][Succeeded / Failed / Skipped / Total] 732 / 36 / 16 / 784:  78%|███████▊  | 784/1000 [6:42:17<1:50:50, 30.79s/it][Succeeded / Failed / Skipped / Total] 732 / 36 / 16 / 784:  78%|███████▊  | 785/1000 [6:44:07<1:50:40, 30.89s/it][Succeeded / Failed / Skipped / Total] 733 / 36 / 16 / 785:  78%|███████▊  | 785/1000 [6:44:07<1:50:40, 30.89s/it][Succeeded / Failed / Skipped / Total] 733 / 36 / 16 / 785:  79%|███████▊  | 786/1000 [6:45:04<1:50:17, 30.92s/it]Store method argument . --> generates a stack instruction --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeMethodArgument]] ( final MethodVisitor mv , final MethodInfo [[methodInfo]] , final int index ) { int offset = [[methodInfo]] . getArgumentOffset ( index ) ; int type = [[methodInfo]] . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , offset ) ; break ; default : mv . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[allegation]] ( final MethodVisitor mv , final MethodInfo [[bothwell]] , final int index ) { int offset = [[bothwell]] . getArgumentOffset ( index ) ; int type = [[bothwell]] . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , offset ) ; break ; default : mv . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 781 ---------------------------------------------
Store the instruction into an array . --> generate a pojo --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeIntoArray]] ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .

[[[[Adv]]]]: public static void [[café]] ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .
--------------------------------------------- Result 782 ---------------------------------------------
Creates a key for method signatures . --> Generate a location string --> Socre: 1.0

[[[[Adv]]]]: public static String [[createMethodSignaturesKey]] ( final int access , final String [[methodName]] , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( [[methodName]] ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .

[[[[Adv]]]]: public static String [[location]] ( final int access , final String [[alessia]] , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( [[alessia]] ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .
--------------------------------------------- Result 783 ---------------------------------------------
Checks for empty flags . --> returns true if tz --> Socre: 1.0

[[[[Adv]]]]: public static boolean isEmptyFlags ( Flags [[flags]] ) { if ( [[flags]] == null ) return "True" == "True" ; Flags . Flag [ ] systemFlags = [[flags]] . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = [[flags]] . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags

[[[[Adv]]]]: public static boolean isEmptyFlags ( Flags [[tzu]] ) { if ( [[tzu]] == null ) return "True" == "True" ; Flags . Flag [ ] systemFlags = [[tzu]] . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = [[tzu]] . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags
--------------------------------------------- Result 784 ---------------------------------------------
Extracts encoding from content type --> Util method for obtaining the rater --> Socre: 1.0

[[[[Adv]]]]: public static String [[extractEncoding]] ( final String contentType , String defaultEncoding ) { String encoding = [[extractEncoding]] ( contentType ) ; if ( encoding == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ; } encoding = defaultEncoding ; } return encoding ; }
[[[[Nl]]]]: Extracts encoding from a given content type .

[[[[Adv]]]]: public static String [[facilitator]] ( final String contentType , String defaultEncoding ) { String encoding = [[facilitator]] ( contentType ) ; if ( encoding == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ; } encoding = defaultEncoding ; } return encoding ; }
[[[[Nl]]]]: Extracts encoding from a given content type .
--------------------------------------------- Result 785 ---------------------------------------------
Load the arguments for the method . --> Load the argument for the given Lomond --> Socre: 1.0

[[[[Adv]]]]: public static void loadVirtualMethodArguments ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] ) { for ( int i = 1 ; i <= [[methodInfo]] . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[mv]] , [[methodInfo]] , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .

[[[[Adv]]]]: public static void loadVirtualMethodArguments ( final MethodVisitor [[asceticism]] , final MethodInfo [[lomond]] ) { for ( int i = 1 ; i <= [[lomond]] . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[asceticism]] , [[lomond]] , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .
--------------------------------------------- Result 786 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 734 / 36 / 16 / 786:  79%|███████▊  | 786/1000 [6:45:04<1:50:17, 30.92s/it][Succeeded / Failed / Skipped / Total] 734 / 36 / 16 / 786:  79%|███████▊  | 787/1000 [6:45:38<1:49:47, 30.93s/it][Succeeded / Failed / Skipped / Total] 735 / 36 / 16 / 787:  79%|███████▊  | 787/1000 [6:45:38<1:49:47, 30.93s/it][Succeeded / Failed / Skipped / Total] 735 / 36 / 16 / 787:  79%|███████▉  | 788/1000 [6:51:26<1:50:41, 31.33s/it][Succeeded / Failed / Skipped / Total] 736 / 36 / 16 / 788:  79%|███████▉  | 788/1000 [6:51:26<1:50:41, 31.33s/it][Succeeded / Failed / Skipped / Total] 736 / 36 / 16 / 788:  79%|███████▉  | 789/1000 [6:51:33<1:50:03, 31.30s/it][Succeeded / Failed / Skipped / Total] 737 / 36 / 16 / 789:  79%|███████▉  | 789/1000 [6:51:33<1:50:03, 31.30s/it][Succeeded / Failed / Skipped / Total] 737 / 36 / 16 / 789:  79%|███████▉  | 790/1000 [6:51:35<1:49:24, 31.26s/it][Succeeded / Failed / Skipped / Total] 738 / 36 / 16 / 790:  79%|███████▉  | 790/1000 [6:51:35<1:49:24, 31.26s/it][Succeeded / Failed / Skipped / Total] 738 / 36 / 16 / 790:  79%|███████▉  | 791/1000 [6:52:38<1:49:01, 31.30s/it]Load arguments . --> Load Equipment instructions --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadSpecialMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo methodInfo ) { [[mv]] . visitVarInsn ( ALOAD , 0 ) ; for ( int [[i]] = 1 ; [[i]] <= methodInfo . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( [[mv]] , methodInfo , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .

[[[[Adv]]]]: public static void [[equipments]] ( final MethodVisitor [[creaky]] , final MethodInfo methodInfo ) { [[creaky]] . visitVarInsn ( ALOAD , 0 ) ; for ( int [[dabba]] = 1 ; [[dabba]] <= methodInfo . getArgumentsCount ( ) ; [[dabba]] ++ ) { loadMethodArgument ( [[creaky]] , methodInfo , [[dabba]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .
--------------------------------------------- Result 787 ---------------------------------------------
Prepares a download . --> Webmarketing method --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareDownload]] ( final HttpServletResponse response , final File file , final String mimeType ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + file ) ; } if ( file . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + file ) ; } prepareResponse ( response , file . getAbsolutePath ( ) , mimeType , ( int ) file . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .

[[[[Adv]]]]: public static void [[telemarketing]] ( final HttpServletResponse response , final File file , final String mimeType ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + file ) ; } if ( file . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + file ) ; } prepareResponse ( response , file . getAbsolutePath ( ) , mimeType , ( int ) file . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .
--------------------------------------------- Result 788 ---------------------------------------------
Create new array . --> Generate an aritaries which can be sent to a compass --> Socre: 1.0

[[[[Adv]]]]: public static void [[newArray]] ( final MethodVisitor [[mv]] , final Class [[componentType]] ) { if ( [[componentType]] == int . class ) { [[mv]] . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[componentType]] == long . class ) { [[mv]] . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[componentType]] == float . class ) { [[mv]] . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[componentType]] == double . class ) { [[mv]] . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[componentType]] == byte . class ) { [[mv]] . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[componentType]] == short . class ) { [[mv]] . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[componentType]] == boolean . class ) { [[mv]] . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[componentType]] == char . class ) { [[mv]] . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } [[mv]] . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[componentType]] ) ) ; }
[[[[Nl]]]]: Creates new array .

[[[[Adv]]]]: public static void [[arcing]] ( final MethodVisitor [[chiropodist]] , final Class [[dignitaries]] ) { if ( [[dignitaries]] == int . class ) { [[chiropodist]] . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( [[dignitaries]] == long . class ) { [[chiropodist]] . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( [[dignitaries]] == float . class ) { [[chiropodist]] . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( [[dignitaries]] == double . class ) { [[chiropodist]] . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( [[dignitaries]] == byte . class ) { [[chiropodist]] . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( [[dignitaries]] == short . class ) { [[chiropodist]] . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( [[dignitaries]] == boolean . class ) { [[chiropodist]] . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( [[dignitaries]] == char . class ) { [[chiropodist]] . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } [[chiropodist]] . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( [[dignitaries]] ) ) ; }
[[[[Nl]]]]: Creates new array .
--------------------------------------------- Result 789 ---------------------------------------------
Require authentication . --> Inject Authorization header --> Socre: 1.0

[[[[Adv]]]]: public static void [[requireAuthentication]] ( final HttpServletResponse [[resp]] , final String realm ) throws IOException { [[resp]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; [[resp]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .

[[[[Adv]]]]: public static void [[interject]] ( final HttpServletResponse [[par]] , final String realm ) throws IOException { [[par]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; [[par]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .
--------------------------------------------- Result 790 ---------------------------------------------
Prepare return value . --> Passes a vulnerability --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareReturnValue]] ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] , int varOffset ) { varOffset += [[methodInfo]] . getAllArgumentsSize ( ) ; switch ( [[methodInfo]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[mv]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[mv]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .

[[[[Adv]]]]: public static void [[clop]] ( final MethodVisitor [[siege]] , final MethodInfo [[petrol]] , int varOffset ) { varOffset += [[petrol]] . getAllArgumentsSize ( ) ; switch ( [[petrol]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[siege]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[siege]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[siege]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[siege]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[siege]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[siege]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[siege]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[siege]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[siege]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .
--------------------------------------------- Result 791 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 739 / 36 / 16 / 791:  79%|███████▉  | 791/1000 [6:52:38<1:49:01, 31.30s/it][Succeeded / Failed / Skipped / Total] 739 / 36 / 16 / 791:  79%|███████▉  | 792/1000 [6:54:57<1:48:58, 31.44s/it][Succeeded / Failed / Skipped / Total] 740 / 36 / 16 / 792:  79%|███████▉  | 792/1000 [6:54:57<1:48:58, 31.44s/it][Succeeded / Failed / Skipped / Total] 740 / 36 / 16 / 792:  79%|███████▉  | 793/1000 [6:58:21<1:49:12, 31.65s/it][Succeeded / Failed / Skipped / Total] 741 / 36 / 16 / 793:  79%|███████▉  | 793/1000 [6:58:21<1:49:12, 31.65s/it][Succeeded / Failed / Skipped / Total] 741 / 36 / 16 / 793:  79%|███████▉  | 794/1000 [6:58:30<1:48:34, 31.63s/it][Succeeded / Failed / Skipped / Total] 742 / 36 / 16 / 794:  79%|███████▉  | 794/1000 [6:58:30<1:48:34, 31.63s/it][Succeeded / Failed / Skipped / Total] 742 / 36 / 16 / 794:  80%|███████▉  | 795/1000 [6:58:35<1:47:56, 31.59s/it][Succeeded / Failed / Skipped / Total] 743 / 36 / 16 / 795:  80%|███████▉  | 795/1000 [6:58:35<1:47:56, 31.59s/it][Succeeded / Failed / Skipped / Total] 743 / 36 / 16 / 795:  80%|███████▉  | 796/1000 [6:58:53<1:47:21, 31.57s/it][Succeeded / Failed / Skipped / Total] 744 / 36 / 16 / 796:  80%|███████▉  | 796/1000 [6:58:53<1:47:21, 31.57s/it][Succeeded / Failed / Skipped / Total] 744 / 36 / 16 / 796:  80%|███████▉  | 797/1000 [6:59:06<1:46:44, 31.55s/it]Sets the response . --> Sets the costi based on the file name --> Socre: 1.0

[[[[Adv]]]]: public static void prepareResponse ( final HttpServletResponse [[response]] , final String fileName , String [[mimeType]] , final int fileSize ) { if ( ( [[mimeType]] == null ) && ( fileName != null ) ) { String extension = FileNameUtil . getExtension ( fileName ) ; [[mimeType]] = MimeTypes . getMimeType ( extension ) ; } if ( [[mimeType]] != null ) { [[response]] . setContentType ( [[mimeType]] ) ; } if ( fileSize >= 0 ) { [[response]] . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .

[[[[Adv]]]]: public static void prepareResponse ( final HttpServletResponse [[costi]] , final String fileName , String [[carrington]] , final int fileSize ) { if ( ( [[carrington]] == null ) && ( fileName != null ) ) { String extension = FileNameUtil . getExtension ( fileName ) ; [[carrington]] = MimeTypes . getMimeType ( extension ) ; } if ( [[carrington]] != null ) { [[costi]] . setContentType ( [[carrington]] ) ; } if ( fileSize >= 0 ) { [[costi]] . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .
--------------------------------------------- Result 792 ---------------------------------------------
Read request body from stream --> Get hostetler string --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromStream]] ( final HttpServletRequest request ) throws IOException { String [[charEncoding]] = request . getCharacterEncoding ( ) ; if ( [[charEncoding]] == null ) { [[charEncoding]] = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = request . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , [[charEncoding]] ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[hostetler]] ( final HttpServletRequest request ) throws IOException { String [[tussauds]] = request . getCharacterEncoding ( ) ; if ( [[tussauds]] == null ) { [[tussauds]] = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = request . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , [[tussauds]] ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!
--------------------------------------------- Result 793 ---------------------------------------------
Read request body from a reader --> Convert bigg to biggus --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromReader]] ( final HttpServletRequest request ) throws IOException { BufferedReader [[buff]] = request . getReader ( ) ; StringWriter [[out]] = new StringWriter ( ) ; StreamUtil . copy ( [[buff]] , [[out]] ) ; return [[out]] . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[biggus]] ( final HttpServletRequest request ) throws IOException { BufferedReader [[euphemia]] = request . getReader ( ) ; StringWriter [[asimov]] = new StringWriter ( ) ; StreamUtil . copy ( [[euphemia]] , [[asimov]] ) ; return [[asimov]] . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!
--------------------------------------------- Result 794 ---------------------------------------------
Stores the current context path in the request . --> Sends a HttpServletRequestVariable to the HttpServletRequest --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeContextPath]] ( final PageContext pageContext , final String contextPathVariableName ) { String [[ctxPath]] = getContextPath ( pageContext ) ; HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; request . setAttribute ( contextPathVariableName , [[ctxPath]] ) ; ServletContext [[servletContext]] = pageContext . getServletContext ( ) ; [[servletContext]] . setAttribute ( contextPathVariableName , [[ctxPath]] ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .

[[[[Adv]]]]: public static void [[hinky]] ( final PageContext pageContext , final String contextPathVariableName ) { String [[piper]] = getContextPath ( pageContext ) ; HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; request . setAttribute ( contextPathVariableName , [[piper]] ) ; ServletContext [[jeweled]] = pageContext . getServletContext ( ) ; [[jeweled]] . setAttribute ( contextPathVariableName , [[piper]] ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .
--------------------------------------------- Result 795 ---------------------------------------------
Extracts the OAuth bearer token from the request . --> Get the howls from the request --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveAuthBearerToken]] ( final HttpServletRequest [[request]] ) { String [[header]] = [[request]] . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[header]] == null ) { return null ; } int ndx = [[header]] . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return [[header]] . substring ( ndx + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .

[[[[Adv]]]]: public static String [[howls]] ( final HttpServletRequest [[dissociative]] ) { String [[responsibilities]] = [[dissociative]] . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[responsibilities]] == null ) { return null ; } int ndx = [[responsibilities]] . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return [[responsibilities]] . substring ( ndx + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .
--------------------------------------------- Result 796 ---------------------------------------------
Stores the current context path . --> Store dayton --> Socre: 1.0

[[[[Adv]]]]: public static void storeContextPath ( final ServletContext [[servletContext]] , final String [[contextPathVariableName]] ) { String [[ctxPath]] = getContextPath ( [[servletContext]] ) ; [[servletContext]] . setAttribute ( [[contextPathVariableName]] , [[ctxPath]] ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .

[[[[Adv]]]]: public static void storeContextPath ( final ServletContext [[tartare]] , final String [[daytona]] ) { String [[stapler]] = getContextPath ( [[tartare]] ) ; [[tartare]] . setAttribute ( [[daytona]] , [[stapler]] ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .
--------------------------------------------- Result 797 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 745 / 36 / 16 / 797:  80%|███████▉  | 797/1000 [6:59:06<1:46:44, 31.55s/it][Succeeded / Failed / Skipped / Total] 745 / 36 / 16 / 797:  80%|███████▉  | 798/1000 [6:59:21<1:46:09, 31.53s/it][Succeeded / Failed / Skipped / Total] 746 / 36 / 16 / 798:  80%|███████▉  | 798/1000 [6:59:21<1:46:09, 31.53s/it][Succeeded / Failed / Skipped / Total] 746 / 36 / 16 / 798:  80%|███████▉  | 799/1000 [6:59:38<1:45:33, 31.51s/it][Succeeded / Failed / Skipped / Total] 747 / 36 / 16 / 799:  80%|███████▉  | 799/1000 [6:59:38<1:45:33, 31.51s/it][Succeeded / Failed / Skipped / Total] 747 / 36 / 16 / 799:  80%|████████  | 800/1000 [6:59:44<1:44:56, 31.48s/it][Succeeded / Failed / Skipped / Total] 748 / 36 / 16 / 800:  80%|████████  | 800/1000 [6:59:44<1:44:56, 31.48s/it][Succeeded / Failed / Skipped / Total] 748 / 36 / 16 / 800:  80%|████████  | 801/1000 [6:59:49<1:44:18, 31.45s/it][Succeeded / Failed / Skipped / Total] 749 / 36 / 16 / 801:  80%|████████  | 801/1000 [6:59:49<1:44:18, 31.45s/it][Succeeded / Failed / Skipped / Total] 749 / 36 / 16 / 801:  80%|████████  | 802/1000 [7:00:34<1:43:50, 31.46s/it][Succeeded / Failed / Skipped / Total] 750 / 36 / 16 / 802:  80%|████████  | 802/1000 [7:00:34<1:43:50, 31.46s/it][Succeeded / Failed / Skipped / Total] 750 / 36 / 16 / 802:  80%|████████  | 803/1000 [7:00:57<1:43:16, 31.45s/it][Succeeded / Failed / Skipped / Total] 751 / 36 / 16 / 803:  80%|████████  | 803/1000 [7:00:57<1:43:16, 31.45s/it][Succeeded / Failed / Skipped / Total] 751 / 36 / 16 / 803:  80%|████████  | 804/1000 [7:01:16<1:42:41, 31.44s/it]Prepare the parameters . --> Put the parameter values into a String array --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] prepareParameters ( final String [ ] paramValues , final boolean [[treatEmptyParamsAsNull]] , final boolean ignoreEmptyRequestParams ) { if ( [[treatEmptyParamsAsNull]] || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int [[i]] = 0 ; [[i]] < paramValues . length ; [[i]] ++ ) { String paramValue = paramValues [ [[i]] ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( [[treatEmptyParamsAsNull]] ) { paramValue = null ; } } paramValues [ [[i]] ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .

[[[[Adv]]]]: public static String [ ] prepareParameters ( final String [ ] paramValues , final boolean [[payroll]] , final boolean ignoreEmptyRequestParams ) { if ( [[payroll]] || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int [[freezer]] = 0 ; [[freezer]] < paramValues . length ; [[freezer]] ++ ) { String paramValue = paramValues [ [[freezer]] ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( [[payroll]] ) { paramValue = null ; } } paramValues [ [[freezer]] ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .
--------------------------------------------- Result 798 ---------------------------------------------
Render the body into a String . --> Render bimbo --> Socre: 1.0

[[[[Adv]]]]: public static String [[renderBodyToString]] ( final JspFragment body ) throws JspException { char [ ] result = renderBody ( body ) ; return new String ( result ) ; }
[[[[Nl]]]]: Renders tag body to string .

[[[[Adv]]]]: public static String [[bimbo]] ( final JspFragment body ) throws JspException { char [ ] result = renderBody ( body ) ; return new String ( result ) ; }
[[[[Nl]]]]: Renders tag body to string .
--------------------------------------------- Result 799 ---------------------------------------------
Renders the body of the HTML fragment . --> Render lightfooter --> Socre: 1.0

[[[[Adv]]]]: public static char [ ] [[renderBody]] ( final JspFragment body ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( body , writer ) ; return writer . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .

[[[[Adv]]]]: public static char [ ] [[lightfoot]] ( final JspFragment body ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( body , writer ) ; return writer . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .
--------------------------------------------- Result 800 ---------------------------------------------
Calls the destroy methods on the bean . --> Call destroyMethods --> Socre: 1.0

[[[[Adv]]]]: public void callDestroyMethods ( ) { for ( final DestroyMethodPoint [[destroyMethodPoint]] : beanDefinition . destroyMethodPoints ( ) ) { try { [[destroyMethodPoint]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + [[destroyMethodPoint]] . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .

[[[[Adv]]]]: public void callDestroyMethods ( ) { for ( final DestroyMethodPoint [[hummingbirds]] : beanDefinition . destroyMethodPoints ( ) ) { try { [[hummingbirds]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + [[hummingbirds]] . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .
--------------------------------------------- Result 801 ---------------------------------------------
Invokes the given body . --> Execute an experiment --> Socre: 1.0

[[[[Adv]]]]: public static void [[invokeBody]] ( final JspFragment body ) throws JspException { if ( body == null ) { return ; } try { body . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .

[[[[Adv]]]]: public static void [[experiment]] ( final JspFragment body ) throws JspException { if ( body == null ) { return ; } try { body . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .
--------------------------------------------- Result 802 ---------------------------------------------
Copy all request parameters to attributes . --> copied from ServletRequest --> Socre: 1.0

[[[[Adv]]]]: public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean [[treatEmptyParamsAsNull]] , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , [[treatEmptyParamsAsNull]] , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .

[[[[Adv]]]]: public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean [[soulless]] , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , [[soulless]] , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .
--------------------------------------------- Result 803 ---------------------------------------------
Inject parameters . --> Inject the parameter to the BeanDefinition --> Socre: 1.0

[[[[Adv]]]]: public void injectParams ( final ParamManager paramManager , final boolean [[implicitParamInjection]] ) { if ( beanDefinition . name == null ) { return ; } if ( [[implicitParamInjection]] ) {
[[[[Nl]]]]: Injects all parameters .

[[[[Adv]]]]: public void injectParams ( final ParamManager paramManager , final boolean [[rabbits]] ) { if ( beanDefinition . name == null ) { return ; } if ( [[rabbits]] ) {
[[[[Nl]]]]: Injects all parameters .
--------------------------------------------- Result 804 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 752 / 36 / 16 / 804:  80%|████████  | 804/1000 [7:01:16<1:42:41, 31.44s/it][Succeeded / Failed / Skipped / Total] 752 / 36 / 16 / 804:  80%|████████  | 805/1000 [7:02:56<1:42:27, 31.52s/it][Succeeded / Failed / Skipped / Total] 752 / 37 / 16 / 805:  80%|████████  | 805/1000 [7:02:56<1:42:27, 31.52s/it][Succeeded / Failed / Skipped / Total] 752 / 37 / 16 / 805:  81%|████████  | 806/1000 [7:03:01<1:41:49, 31.49s/it][Succeeded / Failed / Skipped / Total] 753 / 37 / 16 / 806:  81%|████████  | 806/1000 [7:03:01<1:41:49, 31.49s/it][Succeeded / Failed / Skipped / Total] 753 / 37 / 16 / 806:  81%|████████  | 807/1000 [7:03:18<1:41:14, 31.47s/it][Succeeded / Failed / Skipped / Total] 754 / 37 / 16 / 807:  81%|████████  | 807/1000 [7:03:18<1:41:14, 31.47s/it][Succeeded / Failed / Skipped / Total] 754 / 37 / 16 / 807:  81%|████████  | 808/1000 [7:03:37<1:40:39, 31.46s/it][Succeeded / Failed / Skipped / Total] 755 / 37 / 16 / 808:  81%|████████  | 808/1000 [7:03:37<1:40:39, 31.46s/it][Succeeded / Failed / Skipped / Total] 755 / 37 / 16 / 808:  81%|████████  | 809/1000 [7:04:23<1:40:11, 31.47s/it][Succeeded / Failed / Skipped / Total] 756 / 37 / 16 / 809:  81%|████████  | 809/1000 [7:04:23<1:40:11, 31.47s/it][Succeeded / Failed / Skipped / Total] 756 / 37 / 16 / 809:  81%|████████  | 810/1000 [7:04:40<1:39:37, 31.46s/it][Succeeded / Failed / Skipped / Total] 757 / 37 / 16 / 810:  81%|████████  | 810/1000 [7:04:40<1:39:37, 31.46s/it][Succeeded / Failed / Skipped / Total] 757 / 37 / 16 / 810:  81%|████████  | 811/1000 [7:04:45<1:38:59, 31.43s/it][Succeeded / Failed / Skipped / Total] 758 / 37 / 16 / 811:  81%|████████  | 811/1000 [7:04:45<1:38:59, 31.43s/it][Succeeded / Failed / Skipped / Total] 758 / 37 / 16 / 811:  81%|████████  | 812/1000 [7:05:11<1:38:26, 31.42s/it][Succeeded / Failed / Skipped / Total] 759 / 37 / 16 / 812:  81%|████████  | 812/1000 [7:05:11<1:38:26, 31.42s/it][Succeeded / Failed / Skipped / Total] 759 / 37 / 16 / 812:  81%|████████▏ | 813/1000 [7:05:47<1:37:56, 31.42s/it]Put entry into props . --> Put props . --> Socre: 1.0

[[[[Adv]]]]: protected void put ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String [[realValue]] = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { [[realValue]] = pv . value + APPEND_SEPARATOR + [[realValue]] ; } } PropsEntry propsEntry = new PropsEntry ( key , [[realValue]] , profile , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties

[[[[Adv]]]]: protected void put ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String [[azim]] = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { [[azim]] = pv . value + APPEND_SEPARATOR + [[azim]] ; } } PropsEntry propsEntry = new PropsEntry ( key , [[azim]] , profile , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties
--------------------------------------------- Result 805 ---------------------------------------------
Get all cookies from the request . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookie [ ] getAllCookies ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( cookies . length ) ; for ( Cookie cookie : cookies ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { list . add ( cookie ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .

[[[[Adv]]]]: public static Cookie [ ] getAllCookies ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( cookies . length ) ; for ( Cookie cookie : cookies ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { list . add ( cookie ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .
--------------------------------------------- Result 806 ---------------------------------------------
Invokes init methods --> Berggebung method --> Socre: 1.0

[[[[Adv]]]]: public void [[invokeInitMethods]] ( final InitMethodInvocationStrategy invocationStrategy ) { for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { if ( invocationStrategy != initMethod . invocationStrategy ) { continue ; } try { initMethod . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + initMethod , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .

[[[[Adv]]]]: public void [[bergmann]] ( final InitMethodInvocationStrategy invocationStrategy ) { for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { if ( invocationStrategy != initMethod . invocationStrategy ) { continue ; } try { initMethod . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + initMethod , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .
--------------------------------------------- Result 807 ---------------------------------------------
Create a new bean instance . --> called from the constructor --> Socre: 1.0

[[[[Adv]]]]: public Object [[newBeanInstance]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int [[paramNo]] = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ [[paramNo]] ] ;
[[[[Nl]]]]: Creates a new instance .

[[[[Adv]]]]: public Object [[compton]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int [[smackers]] = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ [[smackers]] ] ;
[[[[Nl]]]]: Creates a new instance .
--------------------------------------------- Result 808 ---------------------------------------------
Resolve macros . --> Resolve macro expressions --> Socre: 1.0

[[[[Adv]]]]: public String resolveMacros ( String value , final String ... [[profiles]] ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .

[[[[Adv]]]]: public String resolveMacros ( String value , final String ... [[thespian]] ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .
--------------------------------------------- Result 809 ---------------------------------------------
Rewrite the path of the given action path . --> Builds the critters --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String [[rewrite]] ( final HttpServletRequest servletRequest , final String actionPath , final String [[httpMethod]] ) { return actionPath ; }
[[[[Nl]]]]: Rewrites action path .

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String [[critters]] ( final HttpServletRequest servletRequest , final String actionPath , final String [[shire]] ) { return actionPath ; }
[[[[Nl]]]]: Rewrites action path .
--------------------------------------------- Result 810 ---------------------------------------------
Extract profiles . --> Extract from the list of profiles --> Socre: 1.0

[[[[Adv]]]]: public Map extract ( Map [[target]] , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { if ( [[target]] == null ) { [[target]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .

[[[[Adv]]]]: public Map extract ( Map [[laundries]] , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { if ( [[laundries]] == null ) { [[laundries]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .
--------------------------------------------- Result 811 ---------------------------------------------
Writes a word to the stream starting at offset --> Computes the next 2 - bit number from the given array --> Socre: 1.0

[[[[Adv]]]]: private static int streamtoword ( byte [ ] data , int [ ] offp ) { int i ; int [[word]] = 0 ; int off = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { [[word]] = ( [[word]] << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return [[word]] ; }
[[[[Nl]]]]: Cycically extract a word of key material .

[[[[Adv]]]]: private static int streamtoword ( byte [ ] data , int [ ] offp ) { int i ; int [[contention]] = 0 ; int off = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { [[contention]] = ( [[contention]] << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return [[contention]] ; }
[[[[Nl]]]]: Cycically extract a word of key material .
--------------------------------------------- Result 812 ---------------------------------------------
Put a base property . --> Add a blag --> Socre: 1.0

[[[[Adv]]]]: public void [[putBaseProperty]] ( final String key , final String [[value]] , final boolean append ) { put ( null , baseProperties , key , [[value]] , append ) ; }
[[[[Nl]]]]: Adds base property .

[[[[Adv]]]]: public void [[blag]] ( final String key , final String [[cartwheel]] , final boolean append ) { put ( null , baseProperties , key , [[cartwheel]] , append ) ; }
[[[[Nl]]]]: Adds base property .
--------------------------------------------- Result 813 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 760 / 37 / 16 / 813:  81%|████████▏ | 813/1000 [7:05:47<1:37:56, 31.42s/it][Succeeded / Failed / Skipped / Total] 760 / 37 / 16 / 813:  81%|████████▏ | 814/1000 [7:06:04<1:37:21, 31.41s/it][Succeeded / Failed / Skipped / Total] 761 / 37 / 16 / 814:  81%|████████▏ | 814/1000 [7:06:04<1:37:21, 31.41s/it][Succeeded / Failed / Skipped / Total] 761 / 37 / 16 / 814:  82%|████████▏ | 815/1000 [7:06:09<1:36:44, 31.37s/it][Succeeded / Failed / Skipped / Total] 762 / 37 / 16 / 815:  82%|████████▏ | 815/1000 [7:06:09<1:36:44, 31.37s/it][Succeeded / Failed / Skipped / Total] 762 / 37 / 16 / 815:  82%|████████▏ | 816/1000 [7:06:16<1:36:07, 31.34s/it][Succeeded / Failed / Skipped / Total] 763 / 37 / 16 / 816:  82%|████████▏ | 816/1000 [7:06:16<1:36:07, 31.34s/it][Succeeded / Failed / Skipped / Total] 763 / 37 / 16 / 816:  82%|████████▏ | 817/1000 [7:08:06<1:35:53, 31.44s/it][Succeeded / Failed / Skipped / Total] 764 / 37 / 16 / 817:  82%|████████▏ | 817/1000 [7:08:06<1:35:53, 31.44s/it][Succeeded / Failed / Skipped / Total] 764 / 37 / 16 / 817:  82%|████████▏ | 818/1000 [7:09:08<1:35:28, 31.48s/it][Succeeded / Failed / Skipped / Total] 765 / 37 / 16 / 818:  82%|████████▏ | 818/1000 [7:09:08<1:35:28, 31.48s/it][Succeeded / Failed / Skipped / Total] 765 / 37 / 16 / 818:  82%|████████▏ | 819/1000 [7:09:33<1:34:55, 31.47s/it][Succeeded / Failed / Skipped / Total] 766 / 37 / 16 / 819:  82%|████████▏ | 819/1000 [7:09:33<1:34:55, 31.47s/it][Succeeded / Failed / Skipped / Total] 766 / 37 / 16 / 819:  82%|████████▏ | 820/1000 [7:09:54<1:34:22, 31.46s/it]Get profile from profile --> Gets a Props object --> Socre: 1.0

[[[[Adv]]]]: public PropsEntry getProfileProperty ( final String profile , final String [[key]] ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( profile ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( [[key]] ) ; }
[[[[Nl]]]]: Returns profile property .

[[[[Adv]]]]: public PropsEntry getProfileProperty ( final String profile , final String [[estás]] ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( profile ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( [[estás]] ) ; }
[[[[Nl]]]]: Returns profile property .
--------------------------------------------- Result 814 ---------------------------------------------
Copies all characters from the stream to the output stream . --> Copy all ABO --> Socre: 1.0

[[[[Adv]]]]: public int copyAll ( final OutputStream out ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte [[b]] = readByte ( ) ; if ( isBoundary ( [[b]] ) ) { break ; } out . write ( [[b]] ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .

[[[[Adv]]]]: public int copyAll ( final OutputStream out ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte [[auras]] = readByte ( ) ; if ( isBoundary ( [[auras]] ) ) { break ; } out . write ( [[auras]] ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .
--------------------------------------------- Result 815 ---------------------------------------------
Copy bytes from the input stream to the output stream . --> Copy maxBytes --> Socre: 1.0

[[[[Adv]]]]: public int copyMax ( final OutputStream out , final int maxBytes ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte [[b]] = readByte ( ) ; if ( isBoundary ( [[b]] ) ) { break ; } out . write ( [[b]] ) ; count ++ ; if ( count == maxBytes ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .

[[[[Adv]]]]: public int copyMax ( final OutputStream out , final int maxBytes ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte [[noddy]] = readByte ( ) ; if ( isBoundary ( [[noddy]] ) ) { break ; } out . write ( [[noddy]] ) ; count ++ ; if ( count == maxBytes ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .
--------------------------------------------- Result 816 ---------------------------------------------
Adds a header . --> Add Detector to Detector --> Socre: 1.0

[[[[Adv]]]]: public void addHeader ( final String [[name]] , final String value ) { List < String > [[valuesList]] = super . getAll ( [[name]] ) ; if ( [[valuesList]] . isEmpty ( ) ) { super . add ( [[name]] , value ) ; return ; } super . remove ( [[name]] ) ; [[valuesList]] . add ( value ) ; super . addAll ( [[name]] , [[valuesList]] ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .

[[[[Adv]]]]: public void addHeader ( final String [[embarrassin]] , final String value ) { List < String > [[sasaki]] = super . getAll ( [[embarrassin]] ) ; if ( [[sasaki]] . isEmpty ( ) ) { super . add ( [[embarrassin]] , value ) ; return ; } super . remove ( [[embarrassin]] ) ; [[sasaki]] . add ( value ) ; super . addAll ( [[embarrassin]] , [[sasaki]] ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .
--------------------------------------------- Result 817 ---------------------------------------------
Resolves the action configuration . --> Resolve ActionConfig for ActionAnnotationValues --> Socre: 1.0

[[[[Adv]]]]: protected ActionConfig resolveActionConfig ( final ActionAnnotationValues annotationValues ) { final Class < ? extends Annotation > [[annotationType]] ; if ( annotationValues == null ) { [[annotationType]] = Action . class ; } else { [[annotationType]] = annotationValues . annotationType ( ) ; } return actionConfigManager . lookup ( [[annotationType]] ) ; }
[[[[Nl]]]]: Resolves action config .

[[[[Adv]]]]: protected ActionConfig resolveActionConfig ( final ActionAnnotationValues annotationValues ) { final Class < ? extends Annotation > [[yugoslavian]] ; if ( annotationValues == null ) { [[yugoslavian]] = Action . class ; } else { [[yugoslavian]] = annotationValues . annotationType ( ) ; } return actionConfigManager . lookup ( [[yugoslavian]] ) ; }
[[[[Nl]]]]: Resolves action config .
--------------------------------------------- Result 818 ---------------------------------------------
Check if the given plaintext matches the given plaintext . --> Checks if the pw has been loaded --> Socre: 1.0

[[[[Adv]]]]: public static boolean checkpw ( String plaintext , String [[hashed]] ) { byte [ ] hashed_bytes ; byte [ ] [[try_bytes]] ; try { String try_pw = hashpw ( plaintext , [[hashed]] ) ; hashed_bytes = [[hashed]] . getBytes ( "UTF-8" ) ; [[try_bytes]] = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "False" != "False" ; } if ( hashed_bytes . length != [[try_bytes]] . length ) { return "False" != "False" ; } byte ret = 0 ; for ( int i = 0 ; i < [[try_bytes]] . length ; i ++ ) { ret |= hashed_bytes [ i ] ^ [[try_bytes]] [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .

[[[[Adv]]]]: public static boolean checkpw ( String plaintext , String [[catholic]] ) { byte [ ] hashed_bytes ; byte [ ] [[rancher]] ; try { String try_pw = hashpw ( plaintext , [[catholic]] ) ; hashed_bytes = [[catholic]] . getBytes ( "UTF-8" ) ; [[rancher]] = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "False" != "False" ; } if ( hashed_bytes . length != [[rancher]] . length ) { return "False" != "False" ; } byte ret = 0 ; for ( int i = 0 ; i < [[rancher]] . length ; i ++ ) { ret |= hashed_bytes [ i ] ^ [[rancher]] [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .
--------------------------------------------- Result 819 ---------------------------------------------
Put profile . --> Attaches the conference --> Socre: 1.0

[[[[Adv]]]]: public void [[putProfileProperty]] ( final String key , final String [[value]] , final String [[profile]] , final boolean append ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( [[profile]] , k -> new HashMap <> ( ) ) ; put ( [[profile]] , map , key , [[value]] , append ) ; }
[[[[Nl]]]]: Adds profile property .

[[[[Adv]]]]: public void [[attaché]] ( final String key , final String [[healer]] , final String [[sachiko]] , final boolean append ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( [[sachiko]] , k -> new HashMap <> ( ) ) ; put ( [[sachiko]] , map , key , [[healer]] , append ) ; }
[[[[Nl]]]]: Adds profile property .
--------------------------------------------- Result 820 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 767 / 37 / 16 / 820:  82%|████████▏ | 820/1000 [7:09:54<1:34:22, 31.46s/it][Succeeded / Failed / Skipped / Total] 767 / 37 / 16 / 820:  82%|████████▏ | 821/1000 [7:10:00<1:33:45, 31.43s/it][Succeeded / Failed / Skipped / Total] 767 / 38 / 16 / 821:  82%|████████▏ | 821/1000 [7:10:00<1:33:45, 31.43s/it][Succeeded / Failed / Skipped / Total] 767 / 38 / 16 / 821:  82%|████████▏ | 822/1000 [7:10:39<1:33:15, 31.44s/it][Succeeded / Failed / Skipped / Total] 768 / 38 / 16 / 822:  82%|████████▏ | 822/1000 [7:10:39<1:33:15, 31.44s/it][Succeeded / Failed / Skipped / Total] 768 / 38 / 16 / 822:  82%|████████▏ | 823/1000 [7:11:53<1:32:53, 31.49s/it][Succeeded / Failed / Skipped / Total] 769 / 38 / 16 / 823:  82%|████████▏ | 823/1000 [7:11:53<1:32:53, 31.49s/it][Succeeded / Failed / Skipped / Total] 769 / 38 / 16 / 823:  82%|████████▏ | 824/1000 [7:11:53<1:32:14, 31.45s/it][Succeeded / Failed / Skipped / Total] 769 / 38 / 17 / 824:  82%|████████▏ | 824/1000 [7:11:53<1:32:14, 31.45s/it][Succeeded / Failed / Skipped / Total] 769 / 38 / 17 / 824:  82%|████████▎ | 825/1000 [7:12:30<1:31:44, 31.46s/it][Succeeded / Failed / Skipped / Total] 770 / 38 / 17 / 825:  82%|████████▎ | 825/1000 [7:12:30<1:31:44, 31.46s/it][Succeeded / Failed / Skipped / Total] 770 / 38 / 17 / 825:  83%|████████▎ | 826/1000 [7:12:46<1:31:10, 31.44s/it][Succeeded / Failed / Skipped / Total] 771 / 38 / 17 / 826:  83%|████████▎ | 826/1000 [7:12:46<1:31:10, 31.44s/it][Succeeded / Failed / Skipped / Total] 771 / 38 / 17 / 826:  83%|████████▎ | 827/1000 [7:13:26<1:30:40, 31.45s/it][Succeeded / Failed / Skipped / Total] 772 / 38 / 17 / 827:  83%|████████▎ | 827/1000 [7:13:26<1:30:40, 31.45s/it][Succeeded / Failed / Skipped / Total] 772 / 38 / 17 / 827:  83%|████████▎ | 828/1000 [7:15:57<1:30:33, 31.59s/it][Succeeded / Failed / Skipped / Total] 773 / 38 / 17 / 828:  83%|████████▎ | 828/1000 [7:15:57<1:30:33, 31.59s/it][Succeeded / Failed / Skipped / Total] 773 / 38 / 17 / 828:  83%|████████▎ | 829/1000 [7:16:17<1:29:59, 31.58s/it]Read action filters . --> Retrieve FilteredBy --> Socre: 1.0

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[readActionFilters]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionFilter > [ ] result = null ; FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { result = filteredBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[miserably]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionFilter > [ ] result = null ; FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { result = filteredBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .
--------------------------------------------- Result 821 ---------------------------------------------
Checks if a parameter is a GET parameter . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean isGetParameter ( final HttpServletRequest [[request]] , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = [[request]] . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( name ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .

[[[[Adv]]]]: public boolean isGetParameter ( final HttpServletRequest [[tantalizing]] , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = [[tantalizing]] . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( name ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .
--------------------------------------------- Result 822 ---------------------------------------------
Get method alias . --> Get cart name from annotationValues --> Socre: 1.0

[[[[Adv]]]]: protected String [[parseMethodAlias]] ( final ActionAnnotationValues annotationValues ) { String alias = null ; if ( annotationValues != null ) { alias = annotationValues . alias ( ) ; } return alias ; }
[[[[Nl]]]]: Reads method s alias value .

[[[[Adv]]]]: protected String [[cart]] ( final ActionAnnotationValues annotationValues ) { String alias = null ; if ( annotationValues != null ) { alias = annotationValues . alias ( ) ; } return alias ; }
[[[[Nl]]]]: Reads method s alias value .
--------------------------------------------- Result 823 ---------------------------------------------
Parse action runtime . --> parse actionRuntime --> Socre: 1.0

[[[[Adv]]]]: public ActionRuntime parse ( final Class < ? > actionClass , final Method [[actionMethod]] , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( [[actionMethod]] ) ; final ActionConfig [[actionConfig]] = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .

[[[[Adv]]]]: public ActionRuntime parse ( final Class < ? > actionClass , final Method [[estás]] , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( [[estás]] ) ; final ActionConfig [[beget]] = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .
--------------------------------------------- Result 824 ---------------------------------------------
Set the response headers . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override protected void preResponseCommit ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( "Last-Modified" , lastModified ) ; } else { response . reset ( ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; } } }
[[[[Nl]]]]: todo move to BufferResponseWrapper ?
--------------------------------------------- Result 825 ---------------------------------------------
Read package action path . --> Gets a map of marcons --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readPackageActionPath]] ( final Class actionClass ) { Package [[actionPackage]] = actionClass . getPackage ( ) ; final String actionPackageName = [[actionPackage]] . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .

[[[[Adv]]]]: protected String [ ] [[maricón]] ( final Class actionClass ) { Package [[quarterdeck]] = actionClass . getPackage ( ) ; final String actionPackageName = [[quarterdeck]] . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .
--------------------------------------------- Result 826 ---------------------------------------------
Apply an advice to a given target class . --> Apply strategy to targetClass --> Socre: 1.0

[[[[Adv]]]]: public static < T > T applyAdvice ( final Class < T > targetClass ) { Class [[adviceClass]] = cache . get ( targetClass ) ; if ( [[adviceClass]] == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .

[[[[Adv]]]]: public static < T > T applyAdvice ( final Class < T > targetClass ) { Class [[hokkaido]] = cache . get ( targetClass ) ; if ( [[hokkaido]] == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .
--------------------------------------------- Result 827 ---------------------------------------------
Detect alias . --> Assigns actions to actions manager --> Socre: 1.0

[[[[Adv]]]]: protected void [[detectAndRegisterAlias]] ( final ActionAnnotationValues annotationValues , final ActionDefinition actionDefinition ) { final String [[alias]] = parseMethodAlias ( annotationValues ) ; if ( [[alias]] != null ) { String [[aliasPath]] = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( [[alias]] , [[aliasPath]] ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .

[[[[Adv]]]]: protected void [[allegheny]] ( final ActionAnnotationValues annotationValues , final ActionDefinition actionDefinition ) { final String [[sant]] = parseMethodAlias ( annotationValues ) ; if ( [[sant]] != null ) { String [[benefactors]] = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( [[sant]] , [[benefactors]] ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .
--------------------------------------------- Result 828 ---------------------------------------------
Read method path . --> Hogg --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readMethodActionPath]] ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) {
[[[[Nl]]]]: Reads action path from the action method .

[[[[Adv]]]]: protected String [ ] [[hogg]] ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) {
[[[[Nl]]]]: Reads action path from the action method .
--------------------------------------------- Result 829 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 774 / 38 / 17 / 829:  83%|████████▎ | 829/1000 [7:16:17<1:29:59, 31.58s/it][Succeeded / Failed / Skipped / Total] 774 / 38 / 17 / 829:  83%|████████▎ | 830/1000 [7:17:23<1:29:35, 31.62s/it][Succeeded / Failed / Skipped / Total] 775 / 38 / 17 / 830:  83%|████████▎ | 830/1000 [7:17:23<1:29:35, 31.62s/it][Succeeded / Failed / Skipped / Total] 775 / 38 / 17 / 830:  83%|████████▎ | 831/1000 [7:17:43<1:29:01, 31.61s/it][Succeeded / Failed / Skipped / Total] 776 / 38 / 17 / 831:  83%|████████▎ | 831/1000 [7:17:43<1:29:01, 31.61s/it][Succeeded / Failed / Skipped / Total] 776 / 38 / 17 / 831:  83%|████████▎ | 832/1000 [7:18:04<1:28:27, 31.59s/it][Succeeded / Failed / Skipped / Total] 777 / 38 / 17 / 832:  83%|████████▎ | 832/1000 [7:18:04<1:28:27, 31.59s/it][Succeeded / Failed / Skipped / Total] 777 / 38 / 17 / 832:  83%|████████▎ | 833/1000 [7:18:05<1:27:49, 31.56s/it][Succeeded / Failed / Skipped / Total] 778 / 38 / 17 / 833:  83%|████████▎ | 833/1000 [7:18:05<1:27:49, 31.56s/it][Succeeded / Failed / Skipped / Total] 778 / 38 / 17 / 833:  83%|████████▎ | 834/1000 [7:18:18<1:27:14, 31.53s/it][Succeeded / Failed / Skipped / Total] 779 / 38 / 17 / 834:  83%|████████▎ | 834/1000 [7:18:18<1:27:14, 31.53s/it][Succeeded / Failed / Skipped / Total] 779 / 38 / 17 / 834:  84%|████████▎ | 835/1000 [7:18:59<1:26:44, 31.54s/it][Succeeded / Failed / Skipped / Total] 780 / 38 / 17 / 835:  84%|████████▎ | 835/1000 [7:18:59<1:26:44, 31.54s/it][Succeeded / Failed / Skipped / Total] 780 / 38 / 17 / 835:  84%|████████▎ | 836/1000 [7:19:18<1:26:10, 31.53s/it][Succeeded / Failed / Skipped / Total] 781 / 38 / 17 / 836:  84%|████████▎ | 836/1000 [7:19:18<1:26:10, 31.53s/it][Succeeded / Failed / Skipped / Total] 781 / 38 / 17 / 836:  84%|████████▎ | 837/1000 [7:19:24<1:25:34, 31.50s/it]Inject target into proxy --> Assigns all the fields of an in - place --> Socre: 1.0

[[[[Adv]]]]: public static void [[injectTargetIntoProxy]] ( final Object proxy , final Object target ) { Class proxyClass = proxy . getClass ( ) ; try { Field [[field]] = proxyClass . getField ( "$___target$0" ) ; [[field]] . set ( proxy , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .

[[[[Adv]]]]: public static void [[agnès]] ( final Object proxy , final Object target ) { Class proxyClass = proxy . getClass ( ) ; try { Field [[disturbance]] = proxyClass . getField ( "$___target$0" ) ; [[disturbance]] . set ( proxy , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .
--------------------------------------------- Result 830 ---------------------------------------------
Create action runtime . --> create actionRuntime --> Socre: 1.0

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class [[actionClass]] , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean [[auth]] ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , [[actionClass]] , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , [[auth]] , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( [[actionClass]] ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class [[recognises]] , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean [[attaché]] ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , [[recognises]] , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , [[attaché]] , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( [[recognises]] ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .
--------------------------------------------- Result 831 ---------------------------------------------
Lookup type data for given class . --> Lookup TypeData for given BLanch --> Socre: 1.0

[[[[Adv]]]]: protected TypeData _lookupTypeData ( final Class [[type]] ) { TypeData typeData = typeDataMap . get ( [[type]] ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , typeData ) ; } return typeData ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .

[[[[Adv]]]]: protected TypeData _lookupTypeData ( final Class [[blanch]] ) { TypeData typeData = typeDataMap . get ( [[blanch]] ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( [[blanch]] ) ; typeDataMap . put ( [[blanch]] , typeData ) ; } return typeData ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .
--------------------------------------------- Result 832 ---------------------------------------------
Find class type data . --> Find the ClassData for a subclass --> Socre: 1.0

[[[[Adv]]]]: protected TypeData findSubclassTypeData ( final Class [[type]] ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( [[type]] . getAnnotation ( defaultAnnotation ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .

[[[[Adv]]]]: protected TypeData findSubclassTypeData ( final Class [[alky]] ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( [[alky]] . getAnnotation ( defaultAnnotation ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .
--------------------------------------------- Result 833 ---------------------------------------------
Returns the real name for the given json name . --> Given a set of candidates return the answer --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final String [[jsonName]] ) { if ( jsonNames == null ) { return [[jsonName]] ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , [[jsonName]] ) ; if ( jsonIndex == - 1 ) { return [[jsonName]] ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .

[[[[Adv]]]]: public String [[ached]] ( final String [[deserves]] ) { if ( jsonNames == null ) { return [[deserves]] ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , [[deserves]] ) ; if ( jsonIndex == - 1 ) { return [[deserves]] ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .
--------------------------------------------- Result 834 ---------------------------------------------
Lookup the TypeData for the given type . --> generate TypeData --> Socre: 1.0

[[[[Adv]]]]: public TypeData [[lookupTypeData]] ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( type ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } } return typeData ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .

[[[[Adv]]]]: public TypeData [[yoυr]] ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( type ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } } return typeData ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .
--------------------------------------------- Result 835 ---------------------------------------------
Read interceptor annotation . --> Read interceptor annotations --> Socre: 1.0

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] readActionInterceptors ( final AnnotatedElement [[actionClassOrMethod]] ) { Class < ? extends ActionInterceptor > [ ] [[result]] = null ; InterceptedBy interceptedBy = [[actionClassOrMethod]] . getAnnotation ( InterceptedBy . class ) ; if ( interceptedBy != null ) { [[result]] = interceptedBy . value ( ) ; if ( [[result]] . length == 0 ) { [[result]] = null ; } } return [[result]] ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] readActionInterceptors ( final AnnotatedElement [[snobbery]] ) { Class < ? extends ActionInterceptor > [ ] [[fetus]] = null ; InterceptedBy interceptedBy = [[snobbery]] . getAnnotation ( InterceptedBy . class ) ; if ( interceptedBy != null ) { [[fetus]] = interceptedBy . value ( ) ; if ( [[fetus]] . length == 0 ) { [[fetus]] = null ; } } return [[fetus]] ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .
--------------------------------------------- Result 836 ---------------------------------------------
Copy the bootstrap methods . --> Synchronously! --> Socre: 1.0

[[[[Adv]]]]: private void [[copyBootstrapMethods]] ( final ClassReader classReader , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .

[[[[Adv]]]]: private void [[samsung]] ( final ClassReader classReader , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .
[Succeeded / Failed / Skipped / Total] 782 / 38 / 17 / 837:  84%|████████▎ | 837/1000 [7:19:24<1:25:34, 31.50s/it][Succeeded / Failed / Skipped / Total] 782 / 38 / 17 / 837:  84%|████████▍ | 838/1000 [7:19:45<1:25:00, 31.49s/it][Succeeded / Failed / Skipped / Total] 783 / 38 / 17 / 838:  84%|████████▍ | 838/1000 [7:19:45<1:25:00, 31.49s/it][Succeeded / Failed / Skipped / Total] 783 / 38 / 17 / 838:  84%|████████▍ | 839/1000 [7:20:04<1:24:26, 31.47s/it][Succeeded / Failed / Skipped / Total] 784 / 38 / 17 / 839:  84%|████████▍ | 839/1000 [7:20:04<1:24:26, 31.47s/it][Succeeded / Failed / Skipped / Total] 784 / 38 / 17 / 839:  84%|████████▍ | 840/1000 [7:20:11<1:23:50, 31.44s/it][Succeeded / Failed / Skipped / Total] 784 / 39 / 17 / 840:  84%|████████▍ | 840/1000 [7:20:11<1:23:50, 31.44s/it][Succeeded / Failed / Skipped / Total] 784 / 39 / 17 / 840:  84%|████████▍ | 841/1000 [7:20:19<1:23:14, 31.41s/it][Succeeded / Failed / Skipped / Total] 785 / 39 / 17 / 841:  84%|████████▍ | 841/1000 [7:20:19<1:23:14, 31.41s/it][Succeeded / Failed / Skipped / Total] 785 / 39 / 17 / 841:  84%|████████▍ | 842/1000 [7:20:22<1:22:38, 31.38s/it][Succeeded / Failed / Skipped / Total] 786 / 39 / 17 / 842:  84%|████████▍ | 842/1000 [7:20:22<1:22:38, 31.38s/it][Succeeded / Failed / Skipped / Total] 786 / 39 / 17 / 842:  84%|████████▍ | 843/1000 [7:22:26<1:22:24, 31.49s/it][Succeeded / Failed / Skipped / Total] 786 / 40 / 17 / 843:  84%|████████▍ | 843/1000 [7:22:26<1:22:24, 31.49s/it][Succeeded / Failed / Skipped / Total] 786 / 40 / 17 / 843:  84%|████████▍ | 844/1000 [7:25:31<1:22:20, 31.67s/it][Succeeded / Failed / Skipped / Total] 787 / 40 / 17 / 844:  84%|████████▍ | 844/1000 [7:25:31<1:22:20, 31.67s/it][Succeeded / Failed / Skipped / Total] 787 / 40 / 17 / 844:  84%|████████▍ | 845/1000 [7:29:10<1:22:23, 31.89s/it][Succeeded / Failed / Skipped / Total] 788 / 40 / 17 / 845:  84%|████████▍ | 845/1000 [7:29:10<1:22:23, 31.89s/it][Succeeded / Failed / Skipped / Total] 788 / 40 / 17 / 845:  85%|████████▍ | 846/1000 [7:29:40<1:21:51, 31.89s/it]--------------------------------------------- Result 837 ---------------------------------------------
Resolves a JSON name . --> Generate the astroner --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final Class type , final String name ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveJsonName ( name ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .

[[[[Adv]]]]: public String [[astrologer]] ( final Class type , final String name ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveJsonName ( name ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .
--------------------------------------------- Result 838 ---------------------------------------------
Returns the file content . --> read diners --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[getFileContent]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .

[[[[Adv]]]]: @ Override public byte [ ] [[diners]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .
--------------------------------------------- Result 839 ---------------------------------------------
Put the bootstrap methods constant . --> Ensures that there is no longer needed --> Socre: 1.0

[[[[Adv]]]]: void [[putBootstrapMethods]] ( final ByteVector output ) { if ( bootstrapMethods != null ) { output . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .

[[[[Adv]]]]: void [[née]] ( final ByteVector output ) { if ( bootstrapMethods != null ) { output . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .
--------------------------------------------- Result 840 ---------------------------------------------
Hashes a password . --> [[[FAILED]]]

[[[[Adv]]]]: public static String hashpw ( String password , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .

[[[[Adv]]]]: public static String hashpw ( String password , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .
--------------------------------------------- Result 841 ---------------------------------------------
Puts constant pool . --> Pushes bushy --> Socre: 1.0

[[[[Adv]]]]: void [[putConstantPool]] ( final ByteVector output ) { output . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .

[[[[Adv]]]]: void [[bushy]] ( final ByteVector output ) { output . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .
--------------------------------------------- Result 842 ---------------------------------------------
Sets the major version and constant pool . --> Add a conference listener --> Socre: 1.0

[[[[Adv]]]]: int [[setMajorVersionAndClassName]] ( final int majorVersion , final String className ) { this . majorVersion = majorVersion ; this . className = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .

[[[[Adv]]]]: int [[loudspeaker]] ( final int majorVersion , final String className ) { this . majorVersion = majorVersion ; this . className = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .
--------------------------------------------- Result 843 ---------------------------------------------
Visits the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: public AnnotationVisitor [[visitAnnotation]] ( final String descriptor , final boolean [[visible]] ) { if ( fv != null ) { return fv . visitAnnotation ( descriptor , [[visible]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .

[[[[Adv]]]]: public AnnotationVisitor [[enhancement]] ( final String descriptor , final boolean [[possess]] ) { if ( fv != null ) { return fv . visitAnnotation ( descriptor , [[possess]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .
--------------------------------------------- Result 844 ---------------------------------------------
Resolve json name . --> number of worst case --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final String [[realName]] ) { if ( realNames == null ) { return [[realName]] ; } int [[realIndex]] = ArraysUtil . indexOf ( realNames , [[realName]] ) ; if ( [[realIndex]] == - 1 ) { return [[realName]] ; } return jsonNames [ [[realIndex]] ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .

[[[[Adv]]]]: public String [[battlefield]] ( final String [[wagered]] ) { if ( realNames == null ) { return [[wagered]] ; } int [[overcrowding]] = ArraysUtil . indexOf ( realNames , [[wagered]] ) ; if ( [[overcrowding]] == - 1 ) { return [[wagered]] ; } return jsonNames [ [[overcrowding]] ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .
--------------------------------------------- Result 845 ---------------------------------------------
Adds a reference to the constant map . --> do? --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantMemberReference]] ( final int index , final int tag , final String owner , final String name , final String [[descriptor]] ) { add ( new Entry ( index , tag , owner , name , [[descriptor]] , 0 , hash ( tag , owner , name , [[descriptor]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[doyou]] ( final int index , final int tag , final String owner , final String name , final String [[zoot]] ) { add ( new Entry ( index , tag , owner , name , [[zoot]] , 0 , hash ( tag , owner , name , [[zoot]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .
[Succeeded / Failed / Skipped / Total] 789 / 40 / 17 / 846:  85%|████████▍ | 846/1000 [7:29:40<1:21:51, 31.89s/it][Succeeded / Failed / Skipped / Total] 789 / 40 / 17 / 846:  85%|████████▍ | 847/1000 [7:31:52<1:21:37, 32.01s/it][Succeeded / Failed / Skipped / Total] 790 / 40 / 17 / 847:  85%|████████▍ | 847/1000 [7:31:52<1:21:37, 32.01s/it][Succeeded / Failed / Skipped / Total] 790 / 40 / 17 / 847:  85%|████████▍ | 848/1000 [7:32:30<1:21:06, 32.02s/it][Succeeded / Failed / Skipped / Total] 791 / 40 / 17 / 848:  85%|████████▍ | 848/1000 [7:32:30<1:21:06, 32.02s/it][Succeeded / Failed / Skipped / Total] 791 / 40 / 17 / 848:  85%|████████▍ | 849/1000 [7:33:03<1:20:34, 32.02s/it][Succeeded / Failed / Skipped / Total] 792 / 40 / 17 / 849:  85%|████████▍ | 849/1000 [7:33:03<1:20:34, 32.02s/it][Succeeded / Failed / Skipped / Total] 792 / 40 / 17 / 849:  85%|████████▌ | 850/1000 [7:33:36<1:20:02, 32.02s/it][Succeeded / Failed / Skipped / Total] 793 / 40 / 17 / 850:  85%|████████▌ | 850/1000 [7:33:36<1:20:02, 32.02s/it][Succeeded / Failed / Skipped / Total] 793 / 40 / 17 / 850:  85%|████████▌ | 851/1000 [7:34:35<1:19:35, 32.05s/it][Succeeded / Failed / Skipped / Total] 793 / 41 / 17 / 851:  85%|████████▌ | 851/1000 [7:34:35<1:19:35, 32.05s/it][Succeeded / Failed / Skipped / Total] 793 / 41 / 17 / 851:  85%|████████▌ | 852/1000 [7:35:52<1:19:11, 32.10s/it][Succeeded / Failed / Skipped / Total] 794 / 41 / 17 / 852:  85%|████████▌ | 852/1000 [7:35:52<1:19:11, 32.10s/it][Succeeded / Failed / Skipped / Total] 794 / 41 / 17 / 852:  85%|████████▌ | 853/1000 [7:36:16<1:18:37, 32.09s/it]--------------------------------------------- Result 846 ---------------------------------------------
Resolve real name . --> get bara --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final Class type , final String [[jsonName]] ) { TypeData [[typeData]] = lookupTypeData ( type ) ; return [[typeData]] . resolveRealName ( [[jsonName]] ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .

[[[[Adv]]]]: public String [[bara]] ( final Class type , final String [[kiki]] ) { TypeData [[selsdon]] = lookupTypeData ( type ) ; return [[selsdon]] . resolveRealName ( [[kiki]] ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .
--------------------------------------------- Result 847 ---------------------------------------------
Add a constant field ref . --> constructs an instance with an enum field reference --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantFieldref]] ( final String [[owner]] , final String name , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , [[owner]] , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[ofthose]] ( final String [[não]] , final String name , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , [[não]] , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 848 ---------------------------------------------
Adds a constant reference to the constant pool . --> Predict an entry --> Socre: 1.0

[[[[Adv]]]]: private Entry [[addConstantMemberReference]] ( final int tag , final String owner , final String [[name]] , final String descriptor ) { int hashCode = hash ( tag , owner , [[name]] , descriptor ) ; Entry [[entry]] = get ( hashCode ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == tag && [[entry]] . hashCode == hashCode && [[entry]] . owner . equals ( owner ) && [[entry]] . name . equals ( [[name]] ) && [[entry]] . value . equals ( descriptor ) ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( [[name]] , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , [[name]] , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Entry [[predictability]] ( final int tag , final String owner , final String [[blogs]] , final String descriptor ) { int hashCode = hash ( tag , owner , [[blogs]] , descriptor ) ; Entry [[cholesterol]] = get ( hashCode ) ; while ( [[cholesterol]] != null ) { if ( [[cholesterol]] . tag == tag && [[cholesterol]] . hashCode == hashCode && [[cholesterol]] . owner . equals ( owner ) && [[cholesterol]] . name . equals ( [[blogs]] ) && [[cholesterol]] . value . equals ( descriptor ) ) { return [[cholesterol]] ; } [[cholesterol]] = [[cholesterol]] . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( [[blogs]] , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , [[blogs]] , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 849 ---------------------------------------------
Adds an integer or float entry . --> Animal an animalistic --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantIntegerOrFloat]] ( final int [[index]] , final int tag , final int value ) { add ( new Entry ( [[index]] , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[animalistic]] ( final int [[ahí]] , final int tag , final int value ) { add ( new Entry ( [[ahí]] , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .
--------------------------------------------- Result 850 ---------------------------------------------
Adds an integer or float constant . --> Methode permettant --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantIntegerOrFloat]] ( final int tag , final int [[value]] ) { int hashCode = hash ( tag , [[value]] ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == [[value]] ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( [[value]] ) ; return put ( new Entry ( constantPoolCount ++ , tag , [[value]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[están]] ( final int tag , final int [[bendito]] ) { int hashCode = hash ( tag , [[bendito]] ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == [[bendito]] ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( [[bendito]] ) ; return put ( new Entry ( constantPoolCount ++ , tag , [[bendito]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 851 ---------------------------------------------
Add a constant method reference . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantMethodref ( final String owner , final String name , final String descriptor , final boolean isInterface ) { int tag = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantMethodref ( final String owner , final String name , final String descriptor , final boolean isInterface ) { int tag = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 852 ---------------------------------------------
Add a constant method handle . --> assist method handle --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantMethodHandle]] ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[arsonist]] ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
[Succeeded / Failed / Skipped / Total] 795 / 41 / 17 / 853:  85%|████████▌ | 853/1000 [7:36:16<1:18:37, 32.09s/it][Succeeded / Failed / Skipped / Total] 795 / 41 / 17 / 853:  85%|████████▌ | 854/1000 [7:37:41<1:18:14, 32.16s/it][Succeeded / Failed / Skipped / Total] 796 / 41 / 17 / 854:  85%|████████▌ | 854/1000 [7:37:41<1:18:14, 32.16s/it][Succeeded / Failed / Skipped / Total] 796 / 41 / 17 / 854:  86%|████████▌ | 855/1000 [7:37:58<1:17:40, 32.14s/it][Succeeded / Failed / Skipped / Total] 797 / 41 / 17 / 855:  86%|████████▌ | 855/1000 [7:37:58<1:17:40, 32.14s/it][Succeeded / Failed / Skipped / Total] 797 / 41 / 17 / 855:  86%|████████▌ | 856/1000 [7:38:36<1:17:08, 32.15s/it][Succeeded / Failed / Skipped / Total] 798 / 41 / 17 / 856:  86%|████████▌ | 856/1000 [7:38:36<1:17:08, 32.15s/it][Succeeded / Failed / Skipped / Total] 798 / 41 / 17 / 856:  86%|████████▌ | 857/1000 [7:39:37<1:16:41, 32.18s/it][Succeeded / Failed / Skipped / Total] 799 / 41 / 17 / 857:  86%|████████▌ | 857/1000 [7:39:37<1:16:41, 32.18s/it][Succeeded / Failed / Skipped / Total] 799 / 41 / 17 / 857:  86%|████████▌ | 858/1000 [7:40:18<1:16:10, 32.19s/it]--------------------------------------------- Result 853 ---------------------------------------------
Adds constant method handle . --> add method handle --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantMethodHandle]] ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; add ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[breasted]] ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; add ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .
--------------------------------------------- Result 854 ---------------------------------------------
Adds a constant pool entry to the constant pool . --> add name and type --> Socre: 1.0

[[[[Adv]]]]: int addConstantNameAndType ( final String [[name]] , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int [[hashCode]] = hash ( tag , [[name]] , descriptor ) ; Entry entry = get ( [[hashCode]] ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == [[hashCode]] && entry . name . equals ( [[name]] ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( [[name]] ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , [[name]] , descriptor , [[hashCode]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int addConstantNameAndType ( final String [[privatizing]] , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int [[glória]] = hash ( tag , [[privatizing]] , descriptor ) ; Entry entry = get ( [[glória]] ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == [[glória]] && entry . name . equals ( [[privatizing]] ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( [[privatizing]] ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , [[privatizing]] , descriptor , [[glória]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 855 ---------------------------------------------
Adds a UTF8 constant . --> Hook for testing --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantUtf8]] ( final int index , final String [[value]] ) { add ( new Entry ( index , Symbol . CONSTANT_UTF8_TAG , [[value]] , hash ( Symbol . CONSTANT_UTF8_TAG , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[hooch]] ( final int index , final String [[confidential]] ) { add ( new Entry ( index , Symbol . CONSTANT_UTF8_TAG , [[confidential]] , hash ( Symbol . CONSTANT_UTF8_TAG , [[confidential]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .
--------------------------------------------- Result 856 ---------------------------------------------
Add a static invoke dynamic method . --> add or invoke dynamic invoke dynamic --> Socre: 1.0

[[[[Adv]]]]: Symbol addConstantInvokeDynamic ( final String name , final String descriptor , final Handle [[bootstrapMethodHandle]] , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( [[bootstrapMethodHandle]] , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantInvokeDynamic ( final String name , final String descriptor , final Handle [[andré]] , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( [[andré]] , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 857 ---------------------------------------------
Add a dynamic reference to the dynamic reference map . --> region Hashtable --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantDynamicOrInvokeDynamicReference]] ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[café]] ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .
--------------------------------------------- Result 858 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 800 / 41 / 17 / 858:  86%|████████▌ | 858/1000 [7:40:18<1:16:10, 32.19s/it][Succeeded / Failed / Skipped / Total] 800 / 41 / 17 / 858:  86%|████████▌ | 859/1000 [7:43:03<1:16:00, 32.34s/it][Succeeded / Failed / Skipped / Total] 800 / 42 / 17 / 859:  86%|████████▌ | 859/1000 [7:43:03<1:16:00, 32.34s/it][Succeeded / Failed / Skipped / Total] 800 / 42 / 17 / 859:  86%|████████▌ | 860/1000 [7:43:28<1:15:26, 32.34s/it][Succeeded / Failed / Skipped / Total] 801 / 42 / 17 / 860:  86%|████████▌ | 860/1000 [7:43:28<1:15:26, 32.34s/it][Succeeded / Failed / Skipped / Total] 801 / 42 / 17 / 860:  86%|████████▌ | 861/1000 [7:44:06<1:14:55, 32.34s/it][Succeeded / Failed / Skipped / Total] 802 / 42 / 17 / 861:  86%|████████▌ | 861/1000 [7:44:06<1:14:55, 32.34s/it][Succeeded / Failed / Skipped / Total] 802 / 42 / 17 / 861:  86%|████████▌ | 862/1000 [7:44:06<1:14:18, 32.30s/it][Succeeded / Failed / Skipped / Total] 802 / 43 / 17 / 862:  86%|████████▌ | 862/1000 [7:44:06<1:14:18, 32.30s/it][Succeeded / Failed / Skipped / Total] 802 / 43 / 17 / 862:  86%|████████▋ | 863/1000 [7:44:26<1:13:43, 32.29s/it][Succeeded / Failed / Skipped / Total] 803 / 43 / 17 / 863:  86%|████████▋ | 863/1000 [7:44:26<1:13:43, 32.29s/it][Succeeded / Failed / Skipped / Total] 803 / 43 / 17 / 863:  86%|████████▋ | 864/1000 [7:44:48<1:13:09, 32.28s/it]Add or invoke dynamic reference . --> Methode permettant --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantDynamicOrInvokeDynamicReference]] ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[café]] ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 859 ---------------------------------------------
Adds a new long constant . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantLongOrDouble]] ( final int index , final int [[tag]] , final long [[value]] ) { add ( new Entry ( index , [[tag]] , [[value]] , hash ( [[tag]] , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[vacation]] ( final int index , final int [[outburst]] , final long [[phantoms]] ) { add ( new Entry ( index , [[outburst]] , [[phantoms]] , hash ( [[outburst]] , [[phantoms]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .
--------------------------------------------- Result 860 ---------------------------------------------
Adds a UTF8 constant to the constant pool . --> Batch Adios --> Socre: 1.0

[[[[Adv]]]]: int [[addConstantUtf8]] ( final String [[value]] ) { int [[hashCode]] = hash ( Symbol . CONSTANT_UTF8_TAG , [[value]] ) ; Entry entry = get ( [[hashCode]] ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == [[hashCode]] && entry . value . equals ( [[value]] ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( [[value]] ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , [[value]] , [[hashCode]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int [[adios]] ( final String [[malmö]] ) { int [[hummers]] = hash ( Symbol . CONSTANT_UTF8_TAG , [[malmö]] ) ; Entry entry = get ( [[hummers]] ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == [[hummers]] && entry . value . equals ( [[malmö]] ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( [[malmö]] ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , [[malmö]] , [[hummers]] ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 861 ---------------------------------------------
Adds a merged type . --> Ditching between two types --> Socre: 1.0

[[[[Adv]]]]: int [[addMergedType]] ( final int typeTableIndex1 , final int typeTableIndex2 ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .

[[[[Adv]]]]: int [[hitching]] ( final int typeTableIndex1 , final int typeTableIndex2 ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .
--------------------------------------------- Result 862 ---------------------------------------------
Adds a long or double constant . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantLongOrDouble ( final int tag , final long value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantLongOrDouble ( final int tag , final long value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 863 ---------------------------------------------
Creates a hash for the given name . --> also used in test --> Socre: 1.0

[[[[Adv]]]]: private int hash ( final String [[name]] ) { int h = 0 ; for ( int i = [[name]] . length ( ) - 1 ; i >= 0 ; i -- ) { char c = [[name]] . charAt ( i ) ; if ( ! caseSensitive ) { if ( c >= ' ' && c <= ' ' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .

[[[[Adv]]]]: private int hash ( final String [[banking]] ) { int h = 0 ; for ( int i = [[banking]] . length ( ) - 1 ; i >= 0 ; i -- ) { char c = [[banking]] . charAt ( i ) ; if ( ! caseSensitive ) { if ( c >= ' ' && c <= ' ' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .
--------------------------------------------- Result 864 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 804 / 43 / 17 / 864:  86%|████████▋ | 864/1000 [7:44:48<1:13:09, 32.28s/it][Succeeded / Failed / Skipped / Total] 804 / 43 / 17 / 864:  86%|████████▋ | 865/1000 [7:46:09<1:12:45, 32.33s/it][Succeeded / Failed / Skipped / Total] 805 / 43 / 17 / 865:  86%|████████▋ | 865/1000 [7:46:09<1:12:45, 32.33s/it][Succeeded / Failed / Skipped / Total] 805 / 43 / 17 / 865:  87%|████████▋ | 866/1000 [7:46:30<1:12:11, 32.32s/it][Succeeded / Failed / Skipped / Total] 805 / 44 / 17 / 866:  87%|████████▋ | 866/1000 [7:46:30<1:12:11, 32.32s/it][Succeeded / Failed / Skipped / Total] 805 / 44 / 17 / 866:  87%|████████▋ | 867/1000 [7:46:58<1:11:38, 32.32s/it][Succeeded / Failed / Skipped / Total] 806 / 44 / 17 / 867:  87%|████████▋ | 867/1000 [7:46:58<1:11:38, 32.32s/it][Succeeded / Failed / Skipped / Total] 806 / 44 / 17 / 867:  87%|████████▋ | 868/1000 [7:47:18<1:11:03, 32.30s/it][Succeeded / Failed / Skipped / Total] 807 / 44 / 17 / 868:  87%|████████▋ | 868/1000 [7:47:18<1:11:03, 32.30s/it][Succeeded / Failed / Skipped / Total] 807 / 44 / 17 / 868:  87%|████████▋ | 869/1000 [7:47:58<1:10:32, 32.31s/it][Succeeded / Failed / Skipped / Total] 808 / 44 / 17 / 869:  87%|████████▋ | 869/1000 [7:47:58<1:10:32, 32.31s/it][Succeeded / Failed / Skipped / Total] 808 / 44 / 17 / 869:  87%|████████▋ | 870/1000 [7:48:22<1:09:59, 32.30s/it][Succeeded / Failed / Skipped / Total] 809 / 44 / 17 / 870:  87%|████████▋ | 870/1000 [7:48:22<1:09:59, 32.30s/it][Succeeded / Failed / Skipped / Total] 809 / 44 / 17 / 870:  87%|████████▋ | 871/1000 [7:48:43<1:09:25, 32.29s/it][Succeeded / Failed / Skipped / Total] 810 / 44 / 17 / 871:  87%|████████▋ | 871/1000 [7:48:43<1:09:25, 32.29s/it][Succeeded / Failed / Skipped / Total] 810 / 44 / 17 / 871:  87%|████████▋ | 872/1000 [7:48:51<1:08:49, 32.26s/it][Succeeded / Failed / Skipped / Total] 811 / 44 / 17 / 872:  87%|████████▋ | 872/1000 [7:48:51<1:08:49, 32.26s/it][Succeeded / Failed / Skipped / Total] 811 / 44 / 17 / 872:  87%|████████▋ | 873/1000 [7:49:50<1:08:20, 32.29s/it]Returns all values matching the specified name . --> translates a list to a list --> Socre: 1.0

[[[[Adv]]]]: public List < V > [[getAll]] ( final String name ) { LinkedList < V > values = new LinkedList <> ( ) ; int h = hash ( name ) ; int i = index ( h ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { values . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return values ; }
[[[[Nl]]]]: Returns all values associated with the name .

[[[[Adv]]]]: public List < V > [[naïveté]] ( final String name ) { LinkedList < V > values = new LinkedList <> ( ) ; int h = hash ( name ) ; int i = index ( h ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { values . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return values ; }
[[[[Nl]]]]: Returns all values associated with the name .
--------------------------------------------- Result 865 ---------------------------------------------
Clear all entries . --> clear all entries --> Socre: 1.0

[[[[Adv]]]]: public HttpMultiMap < V > clear ( ) { for ( int [[i]] = 0 ; [[i]] < entries . length ; [[i]] ++ ) { entries [ [[i]] ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .

[[[[Adv]]]]: public HttpMultiMap < V > clear ( ) { for ( int [[bahar]] = 0 ; [[bahar]] < entries . length ; [[bahar]] ++ ) { entries [ [[bahar]] ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .
--------------------------------------------- Result 866 ---------------------------------------------
Adds a constant name and type . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantNameAndType ( final int index , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantNameAndType ( final int index , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .
--------------------------------------------- Result 867 ---------------------------------------------
Returns an iterator over this map . --> documentation inherited from head --> Socre: 1.0

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > iterator ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > [[next]] ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > [[next]] = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return [[next]] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > iterator ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > [[muñoz]] ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > [[muñoz]] = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return [[muñoz]] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .
--------------------------------------------- Result 868 ---------------------------------------------
Appends a portion of a CharSequence to the buffer . --> iterates over the kinki string --> Socre: 1.0

[[[[Adv]]]]: @ Override public FastCharBuffer [[append]] ( final CharSequence csq , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { [[append]] ( csq . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .

[[[[Adv]]]]: @ Override public FastCharBuffer [[kinki]] ( final CharSequence csq , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { [[kinki]] ( csq . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .
--------------------------------------------- Result 869 ---------------------------------------------
Visits an annotation . --> Holder methods --> Socre: 1.0

[[[[Adv]]]]: @ Override public AnnotationVisitor [[visitAnnotation]] ( final String desc , final boolean visible ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( desc , visible ) ;
[[[[Nl]]]]: Copies target method annotations .

[[[[Adv]]]]: @ Override public AnnotationVisitor [[harps]] ( final String desc , final boolean visible ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( desc , visible ) ;
[[[[Nl]]]]: Copies target method annotations .
--------------------------------------------- Result 870 ---------------------------------------------
overrides the visitEnd method --> Starts the last chain of proxies --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[visitEnd]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int p = 0 ; p < tmd . proxyData . length ; p ++ ) { tmd . selectCurrentProxy ( p ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .

[[[[Adv]]]]: @ Override public void [[gentler]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int p = 0 ; p < tmd . proxyData . length ; p ++ ) { tmd . selectCurrentProxy ( p ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .
--------------------------------------------- Result 871 ---------------------------------------------
Create the start chain delegate . --> Append ada --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Start]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .

[[[[Adv]]]]: protected void [[ada]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .
--------------------------------------------- Result 872 ---------------------------------------------
Adds a reference to the constant pool . --> add static utf8 reference --> Socre: 1.0

[[[[Adv]]]]: private void addConstantUtf8Reference ( final int [[index]] , final int [[tag]] , final String [[value]] ) { add ( new Entry ( [[index]] , [[tag]] , [[value]] , hash ( [[tag]] , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantUtf8Reference ( final int [[fenway]] , final int [[monger]] , final String [[martell]] ) { add ( new Entry ( [[fenway]] , [[monger]] , [[martell]] , hash ( [[monger]] , [[martell]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .
--------------------------------------------- Result 873 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 811 / 45 / 17 / 873:  87%|████████▋ | 873/1000 [7:49:50<1:08:20, 32.29s/it][Succeeded / Failed / Skipped / Total] 811 / 45 / 17 / 873:  87%|████████▋ | 874/1000 [7:50:42<1:07:51, 32.31s/it][Succeeded / Failed / Skipped / Total] 812 / 45 / 17 / 874:  87%|████████▋ | 874/1000 [7:50:42<1:07:51, 32.31s/it][Succeeded / Failed / Skipped / Total] 812 / 45 / 17 / 874:  88%|████████▊ | 875/1000 [7:50:52<1:07:16, 32.29s/it][Succeeded / Failed / Skipped / Total] 813 / 45 / 17 / 875:  88%|████████▊ | 875/1000 [7:50:52<1:07:16, 32.29s/it][Succeeded / Failed / Skipped / Total] 813 / 45 / 17 / 875:  88%|████████▊ | 876/1000 [7:51:15<1:06:42, 32.28s/it][Succeeded / Failed / Skipped / Total] 814 / 45 / 17 / 876:  88%|████████▊ | 876/1000 [7:51:15<1:06:42, 32.28s/it][Succeeded / Failed / Skipped / Total] 814 / 45 / 17 / 876:  88%|████████▊ | 877/1000 [7:51:18<1:06:06, 32.24s/it][Succeeded / Failed / Skipped / Total] 815 / 45 / 17 / 877:  88%|████████▊ | 877/1000 [7:51:18<1:06:06, 32.24s/it][Succeeded / Failed / Skipped / Total] 815 / 45 / 17 / 877:  88%|████████▊ | 878/1000 [7:51:42<1:05:32, 32.23s/it][Succeeded / Failed / Skipped / Total] 816 / 45 / 17 / 878:  88%|████████▊ | 878/1000 [7:51:42<1:05:32, 32.23s/it][Succeeded / Failed / Skipped / Total] 816 / 45 / 17 / 878:  88%|████████▊ | 879/1000 [7:52:22<1:05:01, 32.24s/it]Add a static constant . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantDynamic ( final String name , final String [[descriptor]] , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , [[descriptor]] , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantDynamic ( final String name , final String [[dressy]] , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , [[dressy]] , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 874 ---------------------------------------------
Pushes a new field onto the path stack . --> Add a trailing filler --> Socre: 1.0

[[[[Adv]]]]: public Path [[push]] ( final CharSequence field ) { _push ( field ) ; if ( altPath != null ) { altPath . push ( field ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .

[[[[Adv]]]]: public Path [[braiding]] ( final CharSequence field ) { _push ( field ) ; if ( altPath != null ) { altPath . push ( field ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .
--------------------------------------------- Result 875 ---------------------------------------------
Parse a path . --> Methode d une lung d une lemma --> Socre: 1.0

[[[[Adv]]]]: public static Path [[parse]] ( final String path ) { return path == null ? new Path ( ) : new Path ( StringUtil . splitc ( path , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .

[[[[Adv]]]]: public static Path [[ahí]] ( final String path ) { return path == null ? new Path ( ) : new Path ( StringUtil . splitc ( path , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .
--------------------------------------------- Result 876 ---------------------------------------------
Add a bootstrap method . --> Overlay an annulation --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addBootstrapMethod]] ( final Handle bootstrapMethodHandle , final Object ... [[bootstrapMethodArguments]] ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .

[[[[Adv]]]]: Symbol [[ovulation]] ( final Handle bootstrapMethodHandle , final Object ... [[annul]] ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .
--------------------------------------------- Result 877 ---------------------------------------------
Execute the method --> Methode permettant de la restriction --> Socre: 1.0

[[[[Adv]]]]: public Object [[execute]] ( ) { String methodName = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object next = pathref . continueWith ( this , methodName , returnType ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;

[[[[Adv]]]]: public Object [[gaillard]] ( ) { String methodName = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object next = pathref . continueWith ( this , methodName , returnType ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;
--------------------------------------------- Result 878 ---------------------------------------------
Creates a bean definition for registration . --> This method will create a BeanDefinition for a proxy --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String [[name]] , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = type ; final ProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( type ) ; type = builder . define ( ) ; return new ProxettaBeanDefinition ( [[name]] , type , scope , wiringMode , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( [[name]] , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String [[aurelio]] , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = type ; final ProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( type ) ; type = builder . define ( ) ; return new ProxettaBeanDefinition ( [[aurelio]] , type , scope , wiringMode , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( [[aurelio]] , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .
--------------------------------------------- Result 879 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 817 / 45 / 17 / 879:  88%|████████▊ | 879/1000 [7:52:22<1:05:01, 32.24s/it][Succeeded / Failed / Skipped / Total] 817 / 45 / 17 / 879:  88%|████████▊ | 880/1000 [7:52:44<1:04:27, 32.23s/it][Succeeded / Failed / Skipped / Total] 818 / 45 / 17 / 880:  88%|████████▊ | 880/1000 [7:52:44<1:04:27, 32.23s/it][Succeeded / Failed / Skipped / Total] 818 / 45 / 17 / 880:  88%|████████▊ | 881/1000 [7:54:29<1:04:05, 32.31s/it][Succeeded / Failed / Skipped / Total] 819 / 45 / 17 / 881:  88%|████████▊ | 881/1000 [7:54:29<1:04:05, 32.31s/it][Succeeded / Failed / Skipped / Total] 819 / 45 / 17 / 881:  88%|████████▊ | 882/1000 [7:54:51<1:03:31, 32.30s/it][Succeeded / Failed / Skipped / Total] 820 / 45 / 17 / 882:  88%|████████▊ | 882/1000 [7:54:51<1:03:31, 32.30s/it][Succeeded / Failed / Skipped / Total] 820 / 45 / 17 / 882:  88%|████████▊ | 883/1000 [7:54:53<1:02:55, 32.27s/it][Succeeded / Failed / Skipped / Total] 821 / 45 / 17 / 883:  88%|████████▊ | 883/1000 [7:54:53<1:02:55, 32.27s/it][Succeeded / Failed / Skipped / Total] 821 / 45 / 17 / 883:  88%|████████▊ | 884/1000 [7:55:53<1:02:26, 32.30s/it][Succeeded / Failed / Skipped / Total] 822 / 45 / 17 / 884:  88%|████████▊ | 884/1000 [7:55:53<1:02:26, 32.30s/it][Succeeded / Failed / Skipped / Total] 822 / 45 / 17 / 884:  88%|████████▊ | 885/1000 [7:56:30<1:01:55, 32.31s/it]Create the first chain delegate . --> Generate poison marks --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Continue]] ( final TargetMethodData [[tmd]] ) { methodVisitor . visitCode ( ) ; if ( [[tmd]] . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , [[tmd]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , [[tmd]] . firstMethodName ( ) , [[tmd]] . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , [[tmd]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , [[tmd]] . firstMethodName ( ) , [[tmd]] . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , [[tmd]] . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .

[[[[Adv]]]]: protected void [[epitaph]] ( final TargetMethodData [[punishable]] ) { methodVisitor . visitCode ( ) ; if ( [[punishable]] . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , [[punishable]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , [[punishable]] . firstMethodName ( ) , [[punishable]] . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , [[punishable]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , [[punishable]] . firstMethodName ( ) , [[punishable]] . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , [[punishable]] . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .
--------------------------------------------- Result 880 ---------------------------------------------
Reads the value of the given property from the source object . --> helper method to get holdter --> Socre: 1.0

[[[[Adv]]]]: private Object [[readProperty]] ( final Object source , final PropertyDescriptor propertyDescriptor ) { Getter getter = propertyDescriptor . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( source ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .

[[[[Adv]]]]: private Object [[huckleberry]] ( final Object source , final PropertyDescriptor propertyDescriptor ) { Getter getter = propertyDescriptor . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( source ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .
--------------------------------------------- Result 881 ---------------------------------------------
Convert jtxTransactionMode to DbTransactionMode . --> Convert from josse --> Socre: 1.0

[[[[Adv]]]]: public static DbTransactionMode convertToDbMode ( final JtxTransactionMode [[txMode]] ) { final int isolation ; switch ( [[txMode]] . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( isolation , [[txMode]] . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .

[[[[Adv]]]]: public static DbTransactionMode convertToDbMode ( final JtxTransactionMode [[fosse]] ) { final int isolation ; switch ( [[fosse]] . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( isolation , [[fosse]] . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .
--------------------------------------------- Result 882 ---------------------------------------------
Appends the specified buffer to this buffer . --> Bibliclicing logic --> Socre: 1.0

[[[[Adv]]]]: public Buffer [[append]] ( final Buffer buffer ) { if ( buffer . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .

[[[[Adv]]]]: public Buffer [[biblically]] ( final Buffer buffer ) { if ( buffer . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .
--------------------------------------------- Result 883 ---------------------------------------------
Returns all the entries in this map . --> Retrieves five minutes --> Socre: 1.0

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[entries]] ( ) { List < Map . Entry < String , V > > [[all]] = new LinkedList <> ( ) ; MapEntry < V > [[e]] = head . after ; while ( [[e]] != head ) { [[all]] . add ( [[e]] ) ; [[e]] = [[e]] . after ; } return [[all]] ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[jaffe]] ( ) { List < Map . Entry < String , V > > [[poultry]] = new LinkedList <> ( ) ; MapEntry < V > [[triathlon]] = head . after ; while ( [[triathlon]] != head ) { [[poultry]] . add ( [[triathlon]] ) ; [[triathlon]] = [[triathlon]] . after ; } return [[poultry]] ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .
--------------------------------------------- Result 884 ---------------------------------------------
Grow the internal buffer . --> approximates jOV --> Socre: 1.0

[[[[Adv]]]]: private void [[grow]] ( final int [[minCapacity]] ) { final int oldCapacity = buffer . length ; int [[newCapacity]] = oldCapacity << 1 ; if ( [[newCapacity]] - [[minCapacity]] < 0 ) {
[[[[Nl]]]]: Grows the buffer .

[[[[Adv]]]]: private void [[appear]] ( final int [[jovi]] ) { final int oldCapacity = buffer . length ; int [[thinning]] = oldCapacity << 1 ; if ( [[thinning]] - [[jovi]] < 0 ) {
[[[[Nl]]]]: Grows the buffer .
--------------------------------------------- Result 885 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 822 / 46 / 17 / 885:  88%|████████▊ | 885/1000 [7:56:30<1:01:55, 32.31s/it][Succeeded / Failed / Skipped / Total] 822 / 46 / 17 / 885:  89%|████████▊ | 886/1000 [7:56:49<1:01:21, 32.29s/it][Succeeded / Failed / Skipped / Total] 823 / 46 / 17 / 886:  89%|████████▊ | 886/1000 [7:56:49<1:01:21, 32.29s/it][Succeeded / Failed / Skipped / Total] 823 / 46 / 17 / 886:  89%|████████▊ | 887/1000 [7:57:28<1:00:49, 32.30s/it][Succeeded / Failed / Skipped / Total] 824 / 46 / 17 / 887:  89%|████████▊ | 887/1000 [7:57:28<1:00:49, 32.30s/it][Succeeded / Failed / Skipped / Total] 824 / 46 / 17 / 887:  89%|████████▉ | 888/1000 [7:57:55<1:00:16, 32.29s/it][Succeeded / Failed / Skipped / Total] 825 / 46 / 17 / 888:  89%|████████▉ | 888/1000 [7:57:55<1:00:16, 32.29s/it][Succeeded / Failed / Skipped / Total] 825 / 46 / 17 / 888:  89%|████████▉ | 889/1000 [7:58:16<59:42, 32.28s/it]  [Succeeded / Failed / Skipped / Total] 826 / 46 / 17 / 889:  89%|████████▉ | 889/1000 [7:58:16<59:42, 32.28s/it][Succeeded / Failed / Skipped / Total] 826 / 46 / 17 / 889:  89%|████████▉ | 890/1000 [7:59:51<59:18, 32.35s/it][Succeeded / Failed / Skipped / Total] 827 / 46 / 17 / 890:  89%|████████▉ | 890/1000 [7:59:51<59:18, 32.35s/it][Succeeded / Failed / Skipped / Total] 827 / 46 / 17 / 890:  89%|████████▉ | 891/1000 [8:00:30<58:47, 32.36s/it][Succeeded / Failed / Skipped / Total] 828 / 46 / 17 / 891:  89%|████████▉ | 891/1000 [8:00:30<58:47, 32.36s/it][Succeeded / Failed / Skipped / Total] 828 / 46 / 17 / 891:  89%|████████▉ | 892/1000 [8:01:15<58:16, 32.37s/it][Succeeded / Failed / Skipped / Total] 829 / 46 / 17 / 892:  89%|████████▉ | 892/1000 [8:01:15<58:16, 32.37s/it][Succeeded / Failed / Skipped / Total] 829 / 46 / 17 / 892:  89%|████████▉ | 893/1000 [8:01:32<57:41, 32.35s/it]Adds a static constant . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantUtf8Reference ( final int tag , final String value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantUtf8Reference ( final int tag , final String value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 886 ---------------------------------------------
Returns the value for the given key . --> get CharSequence from map --> Socre: 1.0

[[[[Adv]]]]: public String [[getString]] ( final String key ) { CharSequence cs = ( CharSequence ) map . get ( key ) ; return cs == null ? null : cs . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .

[[[[Adv]]]]: public String [[aguirre]] ( final String key ) { CharSequence cs = ( CharSequence ) map . get ( key ) ; return cs == null ? null : cs . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .
--------------------------------------------- Result 887 ---------------------------------------------
Gets integer . --> Convenience method for getting a literal --> Socre: 1.0

[[[[Adv]]]]: public Integer getInteger ( final String key ) { Number [[number]] = ( Number ) map . get ( key ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Integer ) { return ( Integer ) [[number]] ; } return [[number]] . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .

[[[[Adv]]]]: public Integer getInteger ( final String key ) { Number [[lasers]] = ( Number ) map . get ( key ) ; if ( [[lasers]] == null ) { return null ; } if ( [[lasers]] instanceof Integer ) { return ( Integer ) [[lasers]] ; } return [[lasers]] . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .
--------------------------------------------- Result 888 ---------------------------------------------
Copies all values from the given map into the given map . --> Handles handjob --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[putAll]] ( final Map [[t]] ) { for ( Object o : [[t]] . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) o ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .

[[[[Adv]]]]: @ Override public void [[handjob]] ( final Map [[nyet]] ) { for ( Object o : [[nyet]] . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) o ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .
--------------------------------------------- Result 889 ---------------------------------------------
Configure the servlet context . --> Add AMI filter --> Socre: 1.0

[[[[Adv]]]]: private void [[configureServletContext]] ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration [[filter]] = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; [[filter]] . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration [[filter]] = servletContext . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; [[filter]] . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .

[[[[Adv]]]]: private void [[ami]] ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration [[corman]] = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; [[corman]] . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration [[corman]] = servletContext . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; [[corman]] . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .
--------------------------------------------- Result 890 ---------------------------------------------
Write this response to an output stream . --> Smacker headers --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream out , final HttpProgressListener [[progressListener]] ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .

[[[[Adv]]]]: public void [[smackers]] ( final OutputStream out , final HttpProgressListener [[merlin]] ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .
--------------------------------------------- Result 891 ---------------------------------------------
Get a property value . --> Convenience method for getting a banana --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T [[val]] = ( T ) map . get ( key ) ; if ( [[val]] instanceof Map ) { return ( T ) new JsonObject ( ( Map ) [[val]] ) ; } if ( [[val]] instanceof List ) { return ( T ) new JsonArray ( ( List ) [[val]] ) ; } return [[val]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T [[banana]] = ( T ) map . get ( key ) ; if ( [[banana]] instanceof Map ) { return ( T ) new JsonObject ( ( Map ) [[banana]] ) ; } if ( [[banana]] instanceof List ) { return ( T ) new JsonArray ( ( List ) [[banana]] ) ; } return [[banana]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .
--------------------------------------------- Result 892 ---------------------------------------------
Gets a double value . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public Double getDouble ( final String [[key]] ) { Number [[number]] = ( Number ) map . get ( [[key]] ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Double ) { return ( Double ) [[number]] ; } return [[number]] . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .

[[[[Adv]]]]: public Double getDouble ( final String [[compulsive]] ) { Number [[herbivores]] = ( Number ) map . get ( [[compulsive]] ) ; if ( [[herbivores]] == null ) { return null ; } if ( [[herbivores]] instanceof Double ) { return ( Double ) [[herbivores]] ; } return [[herbivores]] . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .
--------------------------------------------- Result 893 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 830 / 46 / 17 / 893:  89%|████████▉ | 893/1000 [8:01:32<57:41, 32.35s/it][Succeeded / Failed / Skipped / Total] 830 / 46 / 17 / 893:  89%|████████▉ | 894/1000 [8:01:41<57:06, 32.33s/it][Succeeded / Failed / Skipped / Total] 831 / 46 / 17 / 894:  89%|████████▉ | 894/1000 [8:01:41<57:06, 32.33s/it][Succeeded / Failed / Skipped / Total] 831 / 46 / 17 / 894:  90%|████████▉ | 895/1000 [8:01:45<56:31, 32.30s/it][Succeeded / Failed / Skipped / Total] 832 / 46 / 17 / 895:  90%|████████▉ | 895/1000 [8:01:45<56:31, 32.30s/it][Succeeded / Failed / Skipped / Total] 832 / 46 / 17 / 895:  90%|████████▉ | 896/1000 [8:03:08<56:04, 32.35s/it][Succeeded / Failed / Skipped / Total] 833 / 46 / 17 / 896:  90%|████████▉ | 896/1000 [8:03:08<56:04, 32.35s/it][Succeeded / Failed / Skipped / Total] 833 / 46 / 17 / 896:  90%|████████▉ | 897/1000 [8:03:32<55:31, 32.34s/it][Succeeded / Failed / Skipped / Total] 834 / 46 / 17 / 897:  90%|████████▉ | 897/1000 [8:03:32<55:31, 32.34s/it][Succeeded / Failed / Skipped / Total] 834 / 46 / 17 / 897:  90%|████████▉ | 898/1000 [8:03:56<54:58, 32.33s/it][Succeeded / Failed / Skipped / Total] 835 / 46 / 17 / 898:  90%|████████▉ | 898/1000 [8:03:56<54:58, 32.33s/it][Succeeded / Failed / Skipped / Total] 835 / 46 / 17 / 898:  90%|████████▉ | 899/1000 [8:04:15<54:24, 32.32s/it][Succeeded / Failed / Skipped / Total] 836 / 46 / 17 / 899:  90%|████████▉ | 899/1000 [8:04:15<54:24, 32.32s/it][Succeeded / Failed / Skipped / Total] 836 / 46 / 17 / 899:  90%|█████████ | 900/1000 [8:04:35<53:50, 32.31s/it][Succeeded / Failed / Skipped / Total] 837 / 46 / 17 / 900:  90%|█████████ | 900/1000 [8:04:35<53:50, 32.31s/it][Succeeded / Failed / Skipped / Total] 837 / 46 / 17 / 900:  90%|█████████ | 901/1000 [8:04:35<53:14, 32.27s/it][Succeeded / Failed / Skipped / Total] 837 / 46 / 18 / 901:  90%|█████████ | 901/1000 [8:04:35<53:14, 32.27s/it][Succeeded / Failed / Skipped / Total] 837 / 46 / 18 / 901:  90%|█████████ | 902/1000 [8:05:40<52:45, 32.31s/it]Sets the mail folder . --> Open mail server --> Socre: 1.0

[[[[Adv]]]]: public void [[useFolder]] ( final String folderName ) { closeFolderIfOpened ( folder ) ; try { this . folderName = folderName ; this . folder = getService ( ) . getFolder ( folderName ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + folderName , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .

[[[[Adv]]]]: public void [[devi]] ( final String folderName ) { closeFolderIfOpened ( folder ) ; try { this . folderName = folderName ; this . folder = getService ( ) . getFolder ( folderName ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + folderName , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .
--------------------------------------------- Result 894 ---------------------------------------------
Get float value . --> get eskima --> Socre: 1.0

[[[[Adv]]]]: public Float [[getFloat]] ( final String key ) { Number [[number]] = ( Number ) map . get ( key ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Float ) { return ( Float ) [[number]] ; } return [[number]] . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .

[[[[Adv]]]]: public Float [[kenyon]] ( final String key ) { Number [[eskimo]] = ( Number ) map . get ( key ) ; if ( [[eskimo]] == null ) { return null ; } if ( [[eskimo]] instanceof Float ) { return ( Float ) [[eskimo]] ; } return [[eskimo]] . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .
--------------------------------------------- Result 895 ---------------------------------------------
Returns the long value for the given key . --> get holdin --> Socre: 1.0

[[[[Adv]]]]: public Long getLong ( final String [[key]] ) { Number [[number]] = ( Number ) map . get ( [[key]] ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Long ) { return ( Long ) [[number]] ; } return [[number]] . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .

[[[[Adv]]]]: public Long getLong ( final String [[mongolia]] ) { Number [[wearin]] = ( Number ) map . get ( [[mongolia]] ) ; if ( [[wearin]] == null ) { return null ; } if ( [[wearin]] instanceof Long ) { return ( Long ) [[wearin]] ; } return [[wearin]] . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .
--------------------------------------------- Result 896 ---------------------------------------------
Write this list to an output stream . --> produces a chipman image --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream [[out]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; [[out]] . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[out]] ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .

[[[[Adv]]]]: public void [[highwaymen]] ( final OutputStream [[chipman]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; [[chipman]] . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[chipman]] ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .
--------------------------------------------- Result 897 ---------------------------------------------
Gets all field descriptors . --> generate fractal --> Socre: 1.0

[[[[Adv]]]]: public FieldDescriptor [ ] [[getAllFieldDescriptors]] ( ) { if ( allFields == null ) { FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor [[fieldDescriptor]] : fieldsMap . values ( ) ) { allFields [ index ] = [[fieldDescriptor]] ; index ++ ; } Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . [[allFields]] = allFields ; } return allFields ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .

[[[[Adv]]]]: public FieldDescriptor [ ] [[fractal]] ( ) { if ( allFields == null ) { FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor [[én]] : fieldsMap . values ( ) ) { allFields [ index ] = [[én]] ; index ++ ; } Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . [[dietz]] = allFields ; } return allFields ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .
--------------------------------------------- Result 898 ---------------------------------------------
Adds a new property . --> Store Aire --> Socre: 1.0

[[[[Adv]]]]: public JsonObject [[put]] ( final String [[key]] , final String value ) { Objects . requireNonNull ( [[key]] ) ; map . put ( [[key]] , value ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .

[[[[Adv]]]]: public JsonObject [[importante]] ( final String [[trucker]] , final String value ) { Objects . requireNonNull ( [[trucker]] ) ; map . put ( [[trucker]] , value ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .
--------------------------------------------- Result 899 ---------------------------------------------
Validate action . --> Perform belmonte --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[validateAction]] ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .

[[[[Adv]]]]: protected boolean [[belmonte]] ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .
--------------------------------------------- Result 900 ---------------------------------------------
Add a new violation . --> Add a bawL warning --> Socre: 1.0

[[[[Adv]]]]: protected void [[addViolation]] ( final String name , final Object invalidValue ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , invalidValue ) ) ; }
[[[[Nl]]]]: Adds action violation .

[[[[Adv]]]]: protected void [[bawl]] ( final String name , final Object invalidValue ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , invalidValue ) ) ; }
[[[[Nl]]]]: Adds action violation .
--------------------------------------------- Result 901 ---------------------------------------------
Set the raw data . --> [[[SKIPPED]]]

[[[[Adv]]]]: public RawData as ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . mimeType = mimeOrExtension ; } else { this . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!
--------------------------------------------- Result 902 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 838 / 46 / 18 / 902:  90%|█████████ | 902/1000 [8:05:40<52:45, 32.31s/it][Succeeded / Failed / Skipped / Total] 838 / 46 / 18 / 902:  90%|█████████ | 903/1000 [8:06:07<52:13, 32.30s/it][Succeeded / Failed / Skipped / Total] 839 / 46 / 18 / 903:  90%|█████████ | 903/1000 [8:06:07<52:13, 32.30s/it][Succeeded / Failed / Skipped / Total] 839 / 46 / 18 / 903:  90%|█████████ | 904/1000 [8:06:08<51:37, 32.27s/it][Succeeded / Failed / Skipped / Total] 840 / 46 / 18 / 904:  90%|█████████ | 904/1000 [8:06:08<51:37, 32.27s/it][Succeeded / Failed / Skipped / Total] 840 / 46 / 18 / 904:  90%|█████████ | 905/1000 [8:06:27<51:03, 32.25s/it][Succeeded / Failed / Skipped / Total] 841 / 46 / 18 / 905:  90%|█████████ | 905/1000 [8:06:27<51:03, 32.25s/it][Succeeded / Failed / Skipped / Total] 841 / 46 / 18 / 905:  91%|█████████ | 906/1000 [8:06:29<50:28, 32.22s/it][Succeeded / Failed / Skipped / Total] 842 / 46 / 18 / 906:  91%|█████████ | 906/1000 [8:06:29<50:28, 32.22s/it][Succeeded / Failed / Skipped / Total] 842 / 46 / 18 / 906:  91%|█████████ | 907/1000 [8:06:36<49:53, 32.19s/it][Succeeded / Failed / Skipped / Total] 843 / 46 / 18 / 907:  91%|█████████ | 907/1000 [8:06:36<49:53, 32.19s/it][Succeeded / Failed / Skipped / Total] 843 / 46 / 18 / 907:  91%|█████████ | 908/1000 [8:06:45<49:19, 32.17s/it][Succeeded / Failed / Skipped / Total] 844 / 46 / 18 / 908:  91%|█████████ | 908/1000 [8:06:45<49:19, 32.17s/it][Succeeded / Failed / Skipped / Total] 844 / 46 / 18 / 908:  91%|█████████ | 909/1000 [8:06:49<48:44, 32.13s/it]Create alias for target . --> Convert a string to a character pool --> Socre: 1.0

[[[[Adv]]]]: protected String alias ( final String [[target]] ) { return StringPool . LEFT_CHEV . concat ( [[target]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .

[[[[Adv]]]]: protected String alias ( final String [[denny]] ) { return StringPool . LEFT_CHEV . concat ( [[denny]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .
--------------------------------------------- Result 903 ---------------------------------------------
Sets the target input stream . --> Copied from InputStream --> Socre: 1.0

[[[[Adv]]]]: protected T [[setTarget]] ( final InputStream target ) { assertTargetIsNotDefined ( ) ; targetInputStream = target ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .

[[[[Adv]]]]: protected T [[cop]] ( final InputStream target ) { assertTargetIsNotDefined ( ) ; targetInputStream = target ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .
--------------------------------------------- Result 904 ---------------------------------------------
Receive messages . --> Receive all received messages --> Socre: 1.0

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter [[filter]] , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > [[processedMessageConsumer]] ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( [[filter]] == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( [[filter]] . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter [[champaign]] , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > [[hervé]] ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( [[champaign]] == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( [[champaign]] . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .
--------------------------------------------- Result 905 ---------------------------------------------
Sets the target class --> Load bobbins --> Socre: 1.0

[[[[Adv]]]]: public T [[setTarget]] ( final Class target ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( target ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + target . getName ( ) ) ; } targetClass = target ; targetClassName = target . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + target . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .

[[[[Adv]]]]: public T [[bobbins]] ( final Class target ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( target ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + target . getName ( ) ) ; } targetClass = target ; targetClassName = target . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + target . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .
--------------------------------------------- Result 906 ---------------------------------------------
Sets target name . --> Borrowed from classpath --> Socre: 1.0

[[[[Adv]]]]: protected T [[setTarget]] ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!

[[[[Adv]]]]: protected T [[borges]] ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!
--------------------------------------------- Result 907 ---------------------------------------------
Write this list to a writer . --> Don t hurt --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final Writer [[writer]] ) throws IOException { for ( Object [[o]] : list ) { if ( [[o]] instanceof FastByteBuffer ) { FastByteBuffer [[fastByteBuffer]] = ( FastByteBuffer ) [[o]] ; byte [ ] array = [[fastByteBuffer]] . toArray ( ) ; [[writer]] . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( [[o]] instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) [[o]] ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[writer]] , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .

[[[[Adv]]]]: public void [[buzzcocks]] ( final Writer [[aliens]] ) throws IOException { for ( Object [[harming]] : list ) { if ( [[harming]] instanceof FastByteBuffer ) { FastByteBuffer [[denny]] = ( FastByteBuffer ) [[harming]] ; byte [ ] array = [[denny]] . toArray ( ) ; [[aliens]] . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( [[harming]] instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) [[harming]] ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[aliens]] , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .
--------------------------------------------- Result 908 ---------------------------------------------
Processes input stream . --> Cutthroats --> Socre: 1.0

[[[[Adv]]]]: protected void [[process]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .

[[[[Adv]]]]: protected void [[cutthroats]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .
--------------------------------------------- Result 909 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 845 / 46 / 18 / 909:  91%|█████████ | 909/1000 [8:06:49<48:44, 32.13s/it][Succeeded / Failed / Skipped / Total] 845 / 46 / 18 / 909:  91%|█████████ | 910/1000 [8:07:15<48:11, 32.13s/it][Succeeded / Failed / Skipped / Total] 846 / 46 / 18 / 910:  91%|█████████ | 910/1000 [8:07:15<48:11, 32.13s/it][Succeeded / Failed / Skipped / Total] 846 / 46 / 18 / 910:  91%|█████████ | 911/1000 [8:07:34<47:37, 32.11s/it][Succeeded / Failed / Skipped / Total] 847 / 46 / 18 / 911:  91%|█████████ | 911/1000 [8:07:34<47:37, 32.11s/it][Succeeded / Failed / Skipped / Total] 847 / 46 / 18 / 911:  91%|█████████ | 912/1000 [8:07:43<47:03, 32.09s/it][Succeeded / Failed / Skipped / Total] 848 / 46 / 18 / 912:  91%|█████████ | 912/1000 [8:07:43<47:03, 32.09s/it][Succeeded / Failed / Skipped / Total] 848 / 46 / 18 / 912:  91%|█████████▏| 913/1000 [8:07:53<46:29, 32.06s/it][Succeeded / Failed / Skipped / Total] 849 / 46 / 18 / 913:  91%|█████████▏| 913/1000 [8:07:53<46:29, 32.06s/it][Succeeded / Failed / Skipped / Total] 849 / 46 / 18 / 913:  91%|█████████▏| 914/1000 [8:08:05<45:55, 32.04s/it][Succeeded / Failed / Skipped / Total] 850 / 46 / 18 / 914:  91%|█████████▏| 914/1000 [8:08:05<45:55, 32.04s/it][Succeeded / Failed / Skipped / Total] 850 / 46 / 18 / 914:  92%|█████████▏| 915/1000 [8:08:14<45:21, 32.02s/it][Succeeded / Failed / Skipped / Total] 851 / 46 / 18 / 915:  92%|█████████▏| 915/1000 [8:08:14<45:21, 32.02s/it][Succeeded / Failed / Skipped / Total] 851 / 46 / 18 / 915:  92%|█████████▏| 916/1000 [8:08:37<44:48, 32.01s/it]Create the proxy . --> get messier --> Socre: 1.0

[[[[Adv]]]]: public byte [ ] [[create]] ( ) { process ( ) ; byte [ ] result = toByteArray ( ) ; dumpClassInDebugFolder ( result ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return result ; }
[[[[Nl]]]]: Returns byte array of created class .

[[[[Adv]]]]: public byte [ ] [[messier]] ( ) { process ( ) ; byte [ ] result = toByteArray ( ) ; dumpClassInDebugFolder ( result ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return result ; }
[[[[Nl]]]]: Returns byte array of created class .
--------------------------------------------- Result 910 ---------------------------------------------
Define the class . --> Create the midgets --> Socre: 1.0

[[[[Adv]]]]: public Class define ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] [[bytes]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[bytes]] ) ; return DefineClass . of ( getProxyClassName ( ) , [[bytes]] , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .

[[[[Adv]]]]: public Class define ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] [[midgets]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[midgets]] ) ; return DefineClass . of ( getProxyClassName ( ) , [[midgets]] , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .
--------------------------------------------- Result 911 ---------------------------------------------
Looks up a named parameter by its name . --> Query by name --> Socre: 1.0

[[[[Adv]]]]: DbQueryNamedParameter [[lookupNamedParameter]] ( final String name ) { DbQueryNamedParameter [[p]] = rootNP ; while ( [[p]] != null ) { if ( [[p]] . equalsName ( name ) ) { return [[p]] ; } [[p]] = [[p]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .

[[[[Adv]]]]: DbQueryNamedParameter [[carnies]] ( final String name ) { DbQueryNamedParameter [[machetes]] = rootNP ; while ( [[machetes]] != null ) { if ( [[machetes]] . equalsName ( name ) ) { return [[machetes]] ; } [[machetes]] = [[machetes]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .
--------------------------------------------- Result 912 ---------------------------------------------
Creates a new instance of this class . --> Create an object --> Socre: 1.0

[[[[Adv]]]]: public Object newInstance ( ) { Class [[type]] = define ( ) ; try { return ClassUtil . newInstance ( [[type]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .

[[[[Adv]]]]: public Object newInstance ( ) { Class [[vinicius]] = define ( ) ; try { return ClassUtil . newInstance ( [[vinicius]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .
--------------------------------------------- Result 913 ---------------------------------------------
Sets the download file name . --> Carmelo --> Socre: 1.0

[[[[Adv]]]]: public RawData [[downloadableAs]] ( final String downloadFileName ) { this . [[downloadFileName]] = downloadFileName ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( downloadFileName ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .

[[[[Adv]]]]: public RawData [[carmelo]] ( final String downloadFileName ) { this . [[buzzcocks]] = downloadFileName ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( downloadFileName ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .
--------------------------------------------- Result 914 ---------------------------------------------
Adds a to recipient . -->  link with furlong --> Socre: 1.0

[[[[Adv]]]]: public T [[to]] ( final String personalName , final String to ) { return [[to]] ( new EmailAddress ( personalName , [[to]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .

[[[[Adv]]]]: public T [[furlong]] ( final String personalName , final String to ) { return [[furlong]] ( new EmailAddress ( personalName , [[furlong]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .
--------------------------------------------- Result 915 ---------------------------------------------
Sets the REPLACE from the recipient list . --> The LOUDOUTP address --> Socre: 1.0

[[[[Adv]]]]: public T [[REPLACEME0]] ( final EmailAddress ... [[REPLACEME0]] ) { this . replyTo = ArraysUtil . join ( this . replyTo , valueOrEmptyArray ( [[REPLACEME0]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .

[[[[Adv]]]]: public T [[LOUDMOUTH]] ( final EmailAddress ... [[LOUDMOUTH]] ) { this . replyTo = ArraysUtil . join ( this . replyTo , valueOrEmptyArray ( [[LOUDMOUTH]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .
--------------------------------------------- Result 916 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 852 / 46 / 18 / 916:  92%|█████████▏| 916/1000 [8:08:37<44:48, 32.01s/it][Succeeded / Failed / Skipped / Total] 852 / 46 / 18 / 916:  92%|█████████▏| 917/1000 [8:08:47<44:14, 31.98s/it][Succeeded / Failed / Skipped / Total] 853 / 46 / 18 / 917:  92%|█████████▏| 917/1000 [8:08:47<44:14, 31.98s/it][Succeeded / Failed / Skipped / Total] 853 / 46 / 18 / 917:  92%|█████████▏| 918/1000 [8:09:00<43:40, 31.96s/it][Succeeded / Failed / Skipped / Total] 854 / 46 / 18 / 918:  92%|█████████▏| 918/1000 [8:09:00<43:40, 31.96s/it][Succeeded / Failed / Skipped / Total] 854 / 46 / 18 / 918:  92%|█████████▏| 919/1000 [8:09:04<43:06, 31.93s/it][Succeeded / Failed / Skipped / Total] 855 / 46 / 18 / 919:  92%|█████████▏| 919/1000 [8:09:04<43:06, 31.93s/it][Succeeded / Failed / Skipped / Total] 855 / 46 / 18 / 919:  92%|█████████▏| 920/1000 [8:09:25<42:33, 31.92s/it][Succeeded / Failed / Skipped / Total] 856 / 46 / 18 / 920:  92%|█████████▏| 920/1000 [8:09:25<42:33, 31.92s/it][Succeeded / Failed / Skipped / Total] 856 / 46 / 18 / 920:  92%|█████████▏| 921/1000 [8:09:53<42:01, 31.91s/it][Succeeded / Failed / Skipped / Total] 857 / 46 / 18 / 921:  92%|█████████▏| 921/1000 [8:09:53<42:01, 31.91s/it][Succeeded / Failed / Skipped / Total] 857 / 46 / 18 / 921:  92%|█████████▏| 922/1000 [8:10:09<41:28, 31.90s/it][Succeeded / Failed / Skipped / Total] 858 / 46 / 18 / 922:  92%|█████████▏| 922/1000 [8:10:09<41:28, 31.90s/it][Succeeded / Failed / Skipped / Total] 858 / 46 / 18 / 922:  92%|█████████▏| 923/1000 [8:10:32<40:55, 31.89s/it][Succeeded / Failed / Skipped / Total] 859 / 46 / 18 / 923:  92%|█████████▏| 923/1000 [8:10:32<40:55, 31.89s/it][Succeeded / Failed / Skipped / Total] 859 / 46 / 18 / 923:  92%|█████████▏| 924/1000 [8:12:23<40:30, 31.97s/it][Succeeded / Failed / Skipped / Total] 860 / 46 / 18 / 924:  92%|█████████▏| 924/1000 [8:12:23<40:30, 31.97s/it][Succeeded / Failed / Skipped / Total] 860 / 46 / 18 / 924:  92%|█████████▎| 925/1000 [8:13:09<39:59, 31.99s/it][Succeeded / Failed / Skipped / Total] 860 / 47 / 18 / 925:  92%|█████████▎| 925/1000 [8:13:09<39:59, 31.99s/it][Succeeded / Failed / Skipped / Total] 860 / 47 / 18 / 925:  93%|█████████▎| 926/1000 [8:13:23<39:25, 31.97s/it]Updates the flags for the given received email . --> Sets btomene --> Socre: 1.0

[[[[Adv]]]]: public void [[updateEmailFlags]] ( final ReceivedEmail [[receivedEmail]] ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { [[receivedEmail]] . messageNumber ( ) } , [[receivedEmail]] . flags ( ) , "True" == "True" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .

[[[[Adv]]]]: public void [[boma]] ( final ReceivedEmail [[magdalene]] ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { [[magdalene]] . messageNumber ( ) } , [[magdalene]] . flags ( ) , "True" == "True" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .
--------------------------------------------- Result 917 ---------------------------------------------
Set the recipient address . --> Makes a new object with anticoion --> Socre: 1.0

[[[[Adv]]]]: public T to ( final EmailAddress [[to]] ) { this . to = ArraysUtil . append ( this . to , to ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .

[[[[Adv]]]]: public T to ( final EmailAddress [[antónio]] ) { this . to = ArraysUtil . append ( this . to , to ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .
--------------------------------------------- Result 918 ---------------------------------------------
Set the cc addresses . --> Joins the recipients --> Socre: 1.0

[[[[Adv]]]]: public T [[cc]] ( final EmailAddress ... ccs ) { this . cc = ArraysUtil . join ( this . cc , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .

[[[[Adv]]]]: public T [[horoscope]] ( final EmailAddress ... ccs ) { this . cc = ArraysUtil . join ( this . cc , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .
--------------------------------------------- Result 919 ---------------------------------------------
Closes folder if already opened . --> Clipps an anonymous system --> Socre: 1.0

[[[[Adv]]]]: protected void [[closeFolderIfOpened]] ( final Folder [[folder]] ) { if ( [[folder]] != null ) { try { [[folder]] . close ( "[[True]]" == "[[True]]" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .

[[[[Adv]]]]: protected void [[ripp]] ( final Folder [[anarchists]] ) { if ( [[anarchists]] != null ) { try { [[anarchists]] . close ( "[[Vortex]]" == "[[Vortex]]" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .
--------------------------------------------- Result 920 ---------------------------------------------
Sets a header . --> Adds a warning to the response --> Socre: 1.0

[[[[Adv]]]]: public T header ( final String name , final String [[value]] ) { headers . put ( name , [[value]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .

[[[[Adv]]]]: public T header ( final String name , final String [[risks]] ) { headers . put ( name , [[risks]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .
--------------------------------------------- Result 921 ---------------------------------------------
Returns the integer value for the specified name . --> Get the long value from the blossom --> Socre: 1.0

[[[[Adv]]]]: public static long getInt ( final String [[name]] , final int defaultValue ) { String value = get ( [[name]] ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .

[[[[Adv]]]]: public static long getInt ( final String [[blithering]] , final int defaultValue ) { String value = get ( [[blithering]] ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .
--------------------------------------------- Result 922 ---------------------------------------------
Get the value of a system property . --> get camera configuration from camera --> Socre: 1.0

[[[[Adv]]]]: public static String get ( final String [[name]] , final String defaultValue ) { Objects . requireNonNull ( [[name]] ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( [[name]] ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( [[name]] ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return defaultValue ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .

[[[[Adv]]]]: public static String get ( final String [[cameraman]] , final String defaultValue ) { Objects . requireNonNull ( [[cameraman]] ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( [[cameraman]] ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( [[cameraman]] ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return defaultValue ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .
--------------------------------------------- Result 923 ---------------------------------------------
Create a text message with the specified text and encoding . --> converts a string to a translator --> Socre: 1.0

[[[[Adv]]]]: public T [[textMessage]] ( final String text , final String encoding ) { return message ( new EmailMessage ( text , MimeTypes . MIME_TEXT_PLAIN , encoding ) ) ; }
[[[[Nl]]]]: Adds plain message text .

[[[[Adv]]]]: public T [[naïveté]] ( final String text , final String encoding ) { return message ( new EmailMessage ( text , MimeTypes . MIME_TEXT_PLAIN , encoding ) ) ; }
[[[[Nl]]]]: Adds plain message text .
--------------------------------------------- Result 924 ---------------------------------------------
Sets sender address . --> Set sender --> Socre: 1.0

[[[[Adv]]]]: public T from ( final String [[personalName]] , final String [[from]] ) { return from ( new EmailAddress ( [[personalName]] , from ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .

[[[[Adv]]]]: public T from ( final String [[imply]] , final String [[eskimo]] ) { return from ( new EmailAddress ( [[imply]] , from ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .
--------------------------------------------- Result 925 ---------------------------------------------
Returns the resolved parameters of this method . --> [[[FAILED]]]

[[[[Adv]]]]: MethodParameter [ ] [[getResolvedParameters]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .

[[[[Adv]]]]: MethodParameter [ ] [[shochu]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .
--------------------------------------------- Result 926 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 861 / 47 / 18 / 926:  93%|█████████▎| 926/1000 [8:13:23<39:25, 31.97s/it][Succeeded / Failed / Skipped / Total] 861 / 47 / 18 / 926:  93%|█████████▎| 927/1000 [8:13:29<38:51, 31.94s/it][Succeeded / Failed / Skipped / Total] 862 / 47 / 18 / 927:  93%|█████████▎| 927/1000 [8:13:29<38:51, 31.94s/it][Succeeded / Failed / Skipped / Total] 862 / 47 / 18 / 927:  93%|█████████▎| 928/1000 [8:13:53<38:19, 31.93s/it][Succeeded / Failed / Skipped / Total] 863 / 47 / 18 / 928:  93%|█████████▎| 928/1000 [8:13:53<38:19, 31.93s/it][Succeeded / Failed / Skipped / Total] 863 / 47 / 18 / 928:  93%|█████████▎| 929/1000 [8:13:57<37:45, 31.90s/it][Succeeded / Failed / Skipped / Total] 864 / 47 / 18 / 929:  93%|█████████▎| 929/1000 [8:13:57<37:45, 31.90s/it][Succeeded / Failed / Skipped / Total] 864 / 47 / 18 / 929:  93%|█████████▎| 930/1000 [8:15:31<37:17, 31.97s/it][Succeeded / Failed / Skipped / Total] 865 / 47 / 18 / 930:  93%|█████████▎| 930/1000 [8:15:31<37:17, 31.97s/it][Succeeded / Failed / Skipped / Total] 865 / 47 / 18 / 930:  93%|█████████▎| 931/1000 [8:16:41<36:48, 32.01s/it][Succeeded / Failed / Skipped / Total] 866 / 47 / 18 / 931:  93%|█████████▎| 931/1000 [8:16:41<36:48, 32.01s/it][Succeeded / Failed / Skipped / Total] 866 / 47 / 18 / 931:  93%|█████████▎| 932/1000 [8:16:50<36:15, 31.99s/it][Succeeded / Failed / Skipped / Total] 867 / 47 / 18 / 932:  93%|█████████▎| 932/1000 [8:16:50<36:15, 31.99s/it][Succeeded / Failed / Skipped / Total] 867 / 47 / 18 / 932:  93%|█████████▎| 933/1000 [8:17:02<35:41, 31.96s/it][Succeeded / Failed / Skipped / Total] 868 / 47 / 18 / 933:  93%|█████████▎| 933/1000 [8:17:02<35:41, 31.96s/it][Succeeded / Failed / Skipped / Total] 868 / 47 / 18 / 933:  93%|█████████▎| 934/1000 [8:17:11<35:08, 31.94s/it]Gets long value . --> Get the value from modem --> Socre: 1.0

[[[[Adv]]]]: public static long getLong ( final String [[name]] , final long defaultValue ) { String value = get ( [[name]] ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as a long .

[[[[Adv]]]]: public static long getLong ( final String [[modem]] , final long defaultValue ) { String value = get ( [[modem]] ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as a long .
--------------------------------------------- Result 927 ---------------------------------------------
Resolve alias . --> Resolve aliases from executioners --> Socre: 1.0

[[[[Adv]]]]: protected String resolveAlias ( final String [[value]] ) { final StringBuilder result = new StringBuilder ( [[value]] . length ( ) ) ; int i = 0 ; int len = [[value]] . length ( ) ; while ( i < len ) { int ndx = [[value]] . indexOf ( ' ' , i ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .

[[[[Adv]]]]: protected String resolveAlias ( final String [[executioners]] ) { final StringBuilder result = new StringBuilder ( [[executioners]] . length ( ) ) ; int i = 0 ; int len = [[executioners]] . length ( ) ; while ( i < len ) { int ndx = [[executioners]] . indexOf ( ' ' , i ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .
--------------------------------------------- Result 928 ---------------------------------------------
Lookup alias . --> Lookup action path --> Socre: 1.0

[[[[Adv]]]]: protected String lookupAlias ( final String alias ) { String value = actionsManager . lookupPathAlias ( alias ) ; if ( value == null ) { ActionRuntime [[cfg]] = actionsManager . lookup ( alias ) ; if ( [[cfg]] != null ) { value = [[cfg]] . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .

[[[[Adv]]]]: protected String lookupAlias ( final String alias ) { String value = actionsManager . lookupPathAlias ( alias ) ; if ( value == null ) { ActionRuntime [[refrigeration]] = actionsManager . lookup ( alias ) ; if ( [[refrigeration]] != null ) { value = [[refrigeration]] . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .
--------------------------------------------- Result 929 ---------------------------------------------
Create a new html message with the specified encoding . --> Headhunters --> Socre: 1.0

[[[[Adv]]]]: public T [[htmlMessage]] ( final String html , final String [[encoding]] ) { return message ( new EmailMessage ( html , MimeTypes . MIME_TEXT_HTML , [[encoding]] ) ) ; }
[[[[Nl]]]]: Adds HTML message .

[[[[Adv]]]]: public T [[headhunters]] ( final String html , final String [[toasted]] ) { return message ( new EmailMessage ( html , MimeTypes . MIME_TEXT_HTML , [[toasted]] ) ) ; }
[[[[Nl]]]]: Adds HTML message .
--------------------------------------------- Result 930 ---------------------------------------------
Serialize a key value . --> serialize the JSON context --> Socre: 1.0

[[[[Adv]]]]: protected int serializeKeyValue ( final JsonContext [[jsonContext]] , final Path currentPath , final Object key , final Object [[value]] , int count ) { if ( ( [[value]] == null ) && [[jsonContext]] . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .

[[[[Adv]]]]: protected int serializeKeyValue ( final JsonContext [[señorita]] , final Path currentPath , final Object key , final Object [[pageantry]] , int count ) { if ( ( [[pageantry]] == null ) && [[señorita]] . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .
--------------------------------------------- Result 931 ---------------------------------------------
Dump proxy class in debug folder . --> Generate kamla file --> Socre: 1.0

[[[[Adv]]]]: protected void [[dumpClassInDebugFolder]] ( final byte [ ] bytes ) { File debugFolder = proxetta . getDebugFolder ( ) ; if ( debugFolder == null ) { return ; } if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + debugFolder ) ; } String [[fileName]] = proxyClassName ; if ( [[fileName]] == null ) { [[fileName]] = "proxetta-" + System . currentTimeMillis ( ) ; } [[fileName]] += ".class" ; File file = new File ( debugFolder , [[fileName]] ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .

[[[[Adv]]]]: protected void [[kamla]] ( final byte [ ] bytes ) { File debugFolder = proxetta . getDebugFolder ( ) ; if ( debugFolder == null ) { return ; } if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + debugFolder ) ; } String [[grovel]] = proxyClassName ; if ( [[grovel]] == null ) { [[grovel]] = "proxetta-" + System . currentTimeMillis ( ) ; } [[grovel]] += ".class" ; File file = new File ( debugFolder , [[grovel]] ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .
--------------------------------------------- Result 932 ---------------------------------------------
Resolves a result path with the given value . --> Resolve an ID from an argument --> Socre: 1.0

[[[[Adv]]]]: public String resolveResultPathString ( final String [[path]] , final String value ) { final ResultPath [[resultPath]] = resolveResultPath ( [[path]] , value ) ; final String result = [[resultPath]] . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .

[[[[Adv]]]]: public String resolveResultPathString ( final String [[implantation]] , final String value ) { final ResultPath [[brm]] = resolveResultPath ( [[implantation]] , value ) ; final String result = [[brm]] . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .
--------------------------------------------- Result 933 ---------------------------------------------
Strips the last letter of a name --> Replies the first character of the given name . --> Socre: 1.0

[[[[Adv]]]]: public static String [[stripLastCamelWord]] ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
[[[[Nl]]]]: Removes last CamelWord

[[[[Adv]]]]: public static String [[alexy]] ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
[[[[Nl]]]]: Removes last CamelWord
--------------------------------------------- Result 934 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 869 / 47 / 18 / 934:  93%|█████████▎| 934/1000 [8:17:11<35:08, 31.94s/it][Succeeded / Failed / Skipped / Total] 869 / 47 / 18 / 934:  94%|█████████▎| 935/1000 [8:17:31<34:35, 31.93s/it][Succeeded / Failed / Skipped / Total] 870 / 47 / 18 / 935:  94%|█████████▎| 935/1000 [8:17:31<34:35, 31.93s/it][Succeeded / Failed / Skipped / Total] 870 / 47 / 18 / 935:  94%|█████████▎| 936/1000 [8:17:33<34:01, 31.90s/it][Succeeded / Failed / Skipped / Total] 871 / 47 / 18 / 936:  94%|█████████▎| 936/1000 [8:17:33<34:01, 31.90s/it][Succeeded / Failed / Skipped / Total] 871 / 47 / 18 / 936:  94%|█████████▎| 937/1000 [8:17:49<33:28, 31.88s/it][Succeeded / Failed / Skipped / Total] 872 / 47 / 18 / 937:  94%|█████████▎| 937/1000 [8:17:49<33:28, 31.88s/it][Succeeded / Failed / Skipped / Total] 872 / 47 / 18 / 937:  94%|█████████▍| 938/1000 [8:17:49<32:54, 31.84s/it][Succeeded / Failed / Skipped / Total] 872 / 47 / 19 / 938:  94%|█████████▍| 938/1000 [8:17:49<32:54, 31.84s/it][Succeeded / Failed / Skipped / Total] 872 / 47 / 19 / 938:  94%|█████████▍| 939/1000 [8:17:54<32:20, 31.81s/it][Succeeded / Failed / Skipped / Total] 873 / 47 / 19 / 939:  94%|█████████▍| 939/1000 [8:17:54<32:20, 31.81s/it][Succeeded / Failed / Skipped / Total] 873 / 47 / 19 / 939:  94%|█████████▍| 940/1000 [8:18:14<31:48, 31.80s/it][Succeeded / Failed / Skipped / Total] 874 / 47 / 19 / 940:  94%|█████████▍| 940/1000 [8:18:14<31:48, 31.80s/it][Succeeded / Failed / Skipped / Total] 874 / 47 / 19 / 940:  94%|█████████▍| 941/1000 [8:19:04<31:17, 31.82s/it][Succeeded / Failed / Skipped / Total] 875 / 47 / 19 / 941:  94%|█████████▍| 941/1000 [8:19:04<31:17, 31.82s/it][Succeeded / Failed / Skipped / Total] 875 / 47 / 19 / 941:  94%|█████████▍| 942/1000 [8:19:17<30:44, 31.80s/it][Succeeded / Failed / Skipped / Total] 876 / 47 / 19 / 942:  94%|█████████▍| 942/1000 [8:19:17<30:44, 31.80s/it][Succeeded / Failed / Skipped / Total] 876 / 47 / 19 / 942:  94%|█████████▍| 943/1000 [8:19:29<30:11, 31.78s/it][Succeeded / Failed / Skipped / Total] 877 / 47 / 19 / 943:  94%|█████████▍| 943/1000 [8:19:29<30:11, 31.78s/it][Succeeded / Failed / Skipped / Total] 877 / 47 / 19 / 943:  94%|█████████▍| 944/1000 [8:19:50<29:39, 31.77s/it]Resolve schema name . --> Determine Qing --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveSchemaName]] ( final Class < ? > type , final String defaultSchemaName ) { String schemaName = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { schemaName = dbTable . schema ( ) . trim ( ) ; } if ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) { schemaName = defaultSchemaName ; } return schemaName ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .

[[[[Adv]]]]: public static String [[qing]] ( final Class < ? > type , final String defaultSchemaName ) { String schemaName = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { schemaName = dbTable . schema ( ) . trim ( ) ; } if ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) { schemaName = defaultSchemaName ; } return schemaName ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .
--------------------------------------------- Result 935 ---------------------------------------------
Initializes the filter with a key array . --> Initializes this sketch --> Socre: 1.0

[[[[Adv]]]]: public void init ( final long [ ] [[key]] , final long [ ] tweak ) { final int newNw = [[key]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .

[[[[Adv]]]]: public void init ( final long [ ] [[blackface]] , final long [ ] tweak ) { final int newNw = [[blackface]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .
--------------------------------------------- Result 936 ---------------------------------------------
Resolve a result path --> Resolve a value to a ResultPath --> Socre: 1.0

[[[[Adv]]]]: public ResultPath resolveResultPath ( String [[path]] , String value ) { boolean [[absolutePath]] = "False" != "False" ; if ( value != null ) {
[[[[Nl]]]]: Resolves result path .

[[[[Adv]]]]: public ResultPath resolveResultPath ( String [[avis]] , String value ) { boolean [[seein]] = "False" != "False" ; if ( value != null ) {
[[[[Nl]]]]: Resolves result path .
--------------------------------------------- Result 937 ---------------------------------------------
Mix rotation . --> Calculate x --> Socre: 1.0

[[[[Adv]]]]: private void mix ( final int j , final int [[d]] ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ [[d]] % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .

[[[[Adv]]]]: private void mix ( final int j , final int [[backboard]] ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ [[backboard]] % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .
--------------------------------------------- Result 938 ---------------------------------------------
KeySchedule --> [[[SKIPPED]]]

[[[[Adv]]]]: private void keySchedule ( final int s ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .
--------------------------------------------- Result 939 ---------------------------------------------
Performs a demix . --> Performs a demix operation --> Socre: 1.0

[[[[Adv]]]]: private void demix ( final int [[j]] , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long rotr = r [ d % DEPTH_OF_D_IN_R ] [ [[j]] ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .

[[[[Adv]]]]: private void demix ( final int [[behooves]] , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long rotr = r [ d % DEPTH_OF_D_IN_R ] [ [[behooves]] ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .
--------------------------------------------- Result 940 ---------------------------------------------
Encrypt a block . --> Encrypt the given content at the given offset --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[encryptBlock]] ( final byte [ ] content , final int offset ) { long [ ] contentBlock = bytesToLongs ( content , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .

[[[[Adv]]]]: @ Override public byte [ ] [[plasterer]] ( final byte [ ] content , final int offset ) { long [ ] contentBlock = bytesToLongs ( content , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .
--------------------------------------------- Result 941 ---------------------------------------------
Returns the last index of a slash . --> return - 1 if not found --> Socre: 1.0

[[[[Adv]]]]: public static int lastIndexOfSlashDot ( final String str ) { int [[slashNdx]] = str . lastIndexOf ( ' ' ) ; int [[dotNdx]] = StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , [[slashNdx]] ) ; if ( [[dotNdx]] == - 1 ) { if ( [[slashNdx]] == - 1 ) { return - 1 ; } [[slashNdx]] ++ ; if ( [[slashNdx]] < str . length ( ) - 1 ) { [[dotNdx]] = [[slashNdx]] ; } else { [[dotNdx]] = - 1 ; } } return [[dotNdx]] ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .

[[[[Adv]]]]: public static int lastIndexOfSlashDot ( final String str ) { int [[pelicans]] = str . lastIndexOf ( ' ' ) ; int [[harried]] = StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , [[pelicans]] ) ; if ( [[harried]] == - 1 ) { if ( [[pelicans]] == - 1 ) { return - 1 ; } [[pelicans]] ++ ; if ( [[pelicans]] < str . length ( ) - 1 ) { [[harried]] = [[pelicans]] ; } else { [[harried]] = - 1 ; } } return [[harried]] ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .
--------------------------------------------- Result 942 ---------------------------------------------
Gets the index of the first dot after a dot . --> get antaraholder --> Socre: 1.0

[[[[Adv]]]]: public static int [[indexOfDotAfterSlash]] ( final String [[str]] ) { int slashNdx = [[str]] . lastIndexOf ( ' ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return [[str]] . indexOf ( ' ' , slashNdx ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .

[[[[Adv]]]]: public static int [[antara]] ( final String [[buttonholes]] ) { int slashNdx = [[buttonholes]] . lastIndexOf ( ' ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return [[buttonholes]] . indexOf ( ' ' , slashNdx ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .
--------------------------------------------- Result 943 ---------------------------------------------
Remove bounds from string . --> Removes any bounding characters --> Socre: 1.0

[[[[Adv]]]]: private static String removeAnyBounding ( final char s , final char e , final String [[str]] ) { if ( [[str]] == null || [[str]] . length ( ) < 2 ) { return [[str]] ; } if ( [[str]] . startsWith ( String . valueOf ( s ) ) && [[str]] . endsWith ( String . valueOf ( e ) ) ) { return [[str]] . substring ( 1 , [[str]] . length ( ) - 1 ) ; } return [[str]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .

[[[[Adv]]]]: private static String removeAnyBounding ( final char s , final char e , final String [[chantel]] ) { if ( [[chantel]] == null || [[chantel]] . length ( ) < 2 ) { return [[chantel]] ; } if ( [[chantel]] . startsWith ( String . valueOf ( s ) ) && [[chantel]] . endsWith ( String . valueOf ( e ) ) ) { return [[chantel]] . substring ( 1 , [[chantel]] . length ( ) - 1 ) ; } return [[chantel]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .
--------------------------------------------- Result 944 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 878 / 47 / 19 / 944:  94%|█████████▍| 944/1000 [8:19:50<29:39, 31.77s/it][Succeeded / Failed / Skipped / Total] 878 / 47 / 19 / 944:  94%|█████████▍| 945/1000 [8:20:33<29:07, 31.78s/it][Succeeded / Failed / Skipped / Total] 879 / 47 / 19 / 945:  94%|█████████▍| 945/1000 [8:20:33<29:07, 31.78s/it][Succeeded / Failed / Skipped / Total] 879 / 47 / 19 / 945:  95%|█████████▍| 946/1000 [8:20:33<28:34, 31.75s/it][Succeeded / Failed / Skipped / Total] 879 / 47 / 20 / 946:  95%|█████████▍| 946/1000 [8:20:33<28:34, 31.75s/it][Succeeded / Failed / Skipped / Total] 879 / 47 / 20 / 946:  95%|█████████▍| 947/1000 [8:22:09<28:06, 31.82s/it][Succeeded / Failed / Skipped / Total] 880 / 47 / 20 / 947:  95%|█████████▍| 947/1000 [8:22:09<28:06, 31.82s/it][Succeeded / Failed / Skipped / Total] 880 / 47 / 20 / 947:  95%|█████████▍| 948/1000 [8:22:51<27:34, 31.83s/it][Succeeded / Failed / Skipped / Total] 881 / 47 / 20 / 948:  95%|█████████▍| 948/1000 [8:22:51<27:34, 31.83s/it][Succeeded / Failed / Skipped / Total] 881 / 47 / 20 / 948:  95%|█████████▍| 949/1000 [8:23:10<27:02, 31.81s/it][Succeeded / Failed / Skipped / Total] 882 / 47 / 20 / 949:  95%|█████████▍| 949/1000 [8:23:10<27:02, 31.81s/it][Succeeded / Failed / Skipped / Total] 882 / 47 / 20 / 949:  95%|█████████▌| 950/1000 [8:23:36<26:30, 31.81s/it][Succeeded / Failed / Skipped / Total] 883 / 47 / 20 / 950:  95%|█████████▌| 950/1000 [8:23:36<26:30, 31.81s/it][Succeeded / Failed / Skipped / Total] 883 / 47 / 20 / 950:  95%|█████████▌| 951/1000 [8:23:59<25:58, 31.80s/it][Succeeded / Failed / Skipped / Total] 884 / 47 / 20 / 951:  95%|█████████▌| 951/1000 [8:23:59<25:58, 31.80s/it][Succeeded / Failed / Skipped / Total] 884 / 47 / 20 / 951:  95%|█████████▌| 952/1000 [8:24:23<25:25, 31.79s/it]Zipped file . --> Compress an entrees --> Socre: 1.0

[[[[Adv]]]]: public static File zlib ( final File [[file]] ) throws IOException { if ( [[file]] . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( [[file]] ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = [[file]] . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .

[[[[Adv]]]]: public static File zlib ( final File [[entrees]] ) throws IOException { if ( [[entrees]] . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( [[entrees]] ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = [[entrees]] . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .
--------------------------------------------- Result 945 ---------------------------------------------
Initializes this block with a key message . --> initialize the data --> Socre: 1.0

[[[[Adv]]]]: public void init ( final String keyMessage , final long tweak1 , final long [[tweak2]] ) { long [ ] tweak = new long [ ] { tweak1 , [[tweak2]] } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; init ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .

[[[[Adv]]]]: public void init ( final String keyMessage , final long tweak1 , final long [[muñoz]] ) { long [ ] tweak = new long [ ] { tweak1 , [[muñoz]] } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; init ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .
--------------------------------------------- Result 946 ---------------------------------------------
Ungzip a file --> [[[SKIPPED]]]

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String outFileName = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( outFileName ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( gzis ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .
--------------------------------------------- Result 947 ---------------------------------------------
Gets the last index after a dot . --> Determine if a backlog is present --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfDotAfterSlash]] ( final String [[str]] ) { int [[slashNdx]] = [[str]] . lastIndexOf ( ' ' ) ; [[slashNdx]] ++ ; return StringUtil . lastIndexOf ( [[str]] , ' ' , [[str]] . length ( ) , [[slashNdx]] ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .

[[[[Adv]]]]: public static int [[derail]] ( final String [[briefings]] ) { int [[shotguns]] = [[briefings]] . lastIndexOf ( ' ' ) ; [[shotguns]] ++ ; return StringUtil . lastIndexOf ( [[briefings]] , ' ' , [[briefings]] . length ( ) , [[shotguns]] ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .
--------------------------------------------- Result 948 ---------------------------------------------
Returns the path of this method . --> Return the name of the property --> Socre: 1.0

[[[[Adv]]]]: public String [[path]] ( ) { if ( methref != null ) { final String [[methodName]] = methref . ref ( ) ; return target . getName ( ) + ' ' + [[methodName]] ; } return [[path]] ; }
[[[[Nl]]]]: Returns path value .

[[[[Adv]]]]: public String [[countless]] ( ) { if ( methref != null ) { final String [[barnet]] = methref . ref ( ) ; return target . getName ( ) + ' ' + [[barnet]] ; } return [[countless]] ; }
[[[[Nl]]]]: Returns path value .
--------------------------------------------- Result 949 ---------------------------------------------
Unzips a zip file into a directory --> Package - private for testing --> Socre: 1.0

[[[[Adv]]]]: public static void [[unzip]] ( final String zipFile , final String destDir , final String ... patterns ) throws IOException { [[unzip]] ( new File ( zipFile ) , new File ( destDir ) , patterns ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .

[[[[Adv]]]]: public static void [[pitt]] ( final String zipFile , final String destDir , final String ... patterns ) throws IOException { [[pitt]] ( new File ( zipFile ) , new File ( destDir ) , patterns ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .
--------------------------------------------- Result 950 ---------------------------------------------
Gzip file --> Headhunters --> Socre: 1.0

[[[[Adv]]]]: public static File [[gzip]] ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; String gzipName = file . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .

[[[[Adv]]]]: public static File [[headhunters]] ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; String gzipName = file . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .
--------------------------------------------- Result 951 ---------------------------------------------
Returns the field descriptor for the given name . --> Get a FieldDescriptor --> Socre: 1.0

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String name , final boolean [[declared]] ) { final FieldDescriptor fieldDescriptor = getFields ( ) . getFieldDescriptor ( name ) ; if ( fieldDescriptor != null ) { if ( ! fieldDescriptor . matchDeclared ( [[declared]] ) ) { return null ; } } return fieldDescriptor ; }
[[[[Nl]]]]: Returns field descriptor .

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String name , final boolean [[felix]] ) { final FieldDescriptor fieldDescriptor = getFields ( ) . getFieldDescriptor ( name ) ; if ( fieldDescriptor != null ) { if ( ! fieldDescriptor . matchDeclared ( [[felix]] ) ) { return null ; } } return fieldDescriptor ; }
[[[[Nl]]]]: Returns field descriptor .
--------------------------------------------- Result 952 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 885 / 47 / 20 / 952:  95%|█████████▌| 952/1000 [8:24:23<25:25, 31.79s/it][Succeeded / Failed / Skipped / Total] 885 / 47 / 20 / 952:  95%|█████████▌| 953/1000 [8:25:18<24:55, 31.81s/it][Succeeded / Failed / Skipped / Total] 885 / 48 / 20 / 953:  95%|█████████▌| 953/1000 [8:25:18<24:55, 31.81s/it][Succeeded / Failed / Skipped / Total] 885 / 48 / 20 / 953:  95%|█████████▌| 954/1000 [8:26:07<24:24, 31.83s/it][Succeeded / Failed / Skipped / Total] 886 / 48 / 20 / 954:  95%|█████████▌| 954/1000 [8:26:07<24:24, 31.83s/it][Succeeded / Failed / Skipped / Total] 886 / 48 / 20 / 954:  96%|█████████▌| 955/1000 [8:26:48<23:52, 31.84s/it][Succeeded / Failed / Skipped / Total] 887 / 48 / 20 / 955:  96%|█████████▌| 955/1000 [8:26:48<23:52, 31.84s/it][Succeeded / Failed / Skipped / Total] 887 / 48 / 20 / 955:  96%|█████████▌| 956/1000 [8:27:42<23:22, 31.87s/it][Succeeded / Failed / Skipped / Total] 888 / 48 / 20 / 956:  96%|█████████▌| 956/1000 [8:27:42<23:22, 31.87s/it][Succeeded / Failed / Skipped / Total] 888 / 48 / 20 / 956:  96%|█████████▌| 957/1000 [8:29:07<22:52, 31.92s/it][Succeeded / Failed / Skipped / Total] 889 / 48 / 20 / 957:  96%|█████████▌| 957/1000 [8:29:07<22:52, 31.92s/it][Succeeded / Failed / Skipped / Total] 889 / 48 / 20 / 957:  96%|█████████▌| 958/1000 [8:29:30<22:20, 31.91s/it][Succeeded / Failed / Skipped / Total] 889 / 49 / 20 / 958:  96%|█████████▌| 958/1000 [8:29:30<22:20, 31.91s/it][Succeeded / Failed / Skipped / Total] 889 / 49 / 20 / 958:  96%|█████████▌| 959/1000 [8:30:12<21:48, 31.92s/it]Returns the PropertyDescriptor with the given name and flag . --> Get the PropertyDescriptor for the given name --> Socre: 1.0

[[[[Adv]]]]: public PropertyDescriptor getPropertyDescriptor ( final String name , final boolean declared ) { PropertyDescriptor [[propertyDescriptor]] = getProperties ( ) . getPropertyDescriptor ( name ) ; if ( ( [[propertyDescriptor]] != null ) && [[propertyDescriptor]] . matchDeclared ( declared ) ) { return [[propertyDescriptor]] ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .

[[[[Adv]]]]: public PropertyDescriptor getPropertyDescriptor ( final String name , final boolean declared ) { PropertyDescriptor [[overact]] = getProperties ( ) . getPropertyDescriptor ( name ) ; if ( ( [[overact]] != null ) && [[overact]] . matchDeclared ( declared ) ) { return [[overact]] ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .
--------------------------------------------- Result 953 ---------------------------------------------
Gets boolean value . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean getBoolean ( final String [[name]] , final boolean defaultValue ) { String [[value]] = get ( [[name]] ) ; if ( [[value]] == null ) { return defaultValue ; } [[value]] = [[value]] . trim ( ) . toLowerCase ( ) ; switch ( [[value]] ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "[[False]]" != "[[False]]" ; default : return defaultValue ; } }
[[[[Nl]]]]: Returns system property as boolean .

[[[[Adv]]]]: public static boolean getBoolean ( final String [[brewer]] , final boolean defaultValue ) { String [[downsizing]] = get ( [[brewer]] ) ; if ( [[downsizing]] == null ) { return defaultValue ; } [[downsizing]] = [[downsizing]] . trim ( ) . toLowerCase ( ) ; switch ( [[downsizing]] ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "[[Owe]]" != "[[Owe]]" ; default : return defaultValue ; } }
[[[[Nl]]]]: Returns system property as boolean .
--------------------------------------------- Result 954 ---------------------------------------------
List a zip file . --> Returns an unmodifiable list of leagues --> Socre: 1.0

[[[[Adv]]]]: public static List < String > listZip ( final File zipFile ) throws IOException { List < String > entries = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( zipFile ) ; Enumeration [[zipEntries]] = zip . entries ( ) ; while ( [[zipEntries]] . hasMoreElements ( ) ) { ZipEntry [[entry]] = ( ZipEntry ) [[zipEntries]] . nextElement ( ) ; String entryName = [[entry]] . getName ( ) ; entries . add ( entryName ) ; } return Collections . unmodifiableList ( entries ) ; }
[[[[Nl]]]]: Lists zip content .

[[[[Adv]]]]: public static List < String > listZip ( final File zipFile ) throws IOException { List < String > entries = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( zipFile ) ; Enumeration [[disappoints]] = zip . entries ( ) ; while ( [[disappoints]] . hasMoreElements ( ) ) { ZipEntry [[johansen]] = ( ZipEntry ) [[disappoints]] . nextElement ( ) ; String entryName = [[johansen]] . getName ( ) ; entries . add ( entryName ) ; } return Collections . unmodifiableList ( entries ) ; }
[[[[Nl]]]]: Lists zip content .
--------------------------------------------- Result 955 ---------------------------------------------
Adds a file to a ZIP output stream . --> copied from org --> Socre: 1.0

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final File [[file]] , String path , final String [[comment]] , final boolean recursive ) throws IOException { if ( ! [[file]] . exists ( ) ) { throw new FileNotFoundException ( [[file]] . toString ( ) ) ; } if ( path == null ) { path = [[file]] . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean isDir = [[file]] . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final File [[disillusionment]] , String path , final String [[bridesmaids]] , final boolean recursive ) throws IOException { if ( ! [[disillusionment]] . exists ( ) ) { throw new FileNotFoundException ( [[disillusionment]] . toString ( ) ) ; } if ( path == null ) { path = [[disillusionment]] . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean isDir = [[disillusionment]] . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .
--------------------------------------------- Result 956 ---------------------------------------------
Convert a byte array to a long array . --> Extracts the surname from a string --> Socre: 1.0

[[[[Adv]]]]: protected static long [ ] bytesToLongs ( final byte [ ] ba , final int offset , final int [[size]] ) { long [ ] [[result]] = new long [ [[size]] >> 3 ] ; int [[i8]] = offset ; for ( int i = 0 ; i < [[result]] . length ; i ++ ) { [[result]] [ i ] = Bits . getLong ( ba , [[i8]] ) ; [[i8]] += 8 ; } return [[result]] ; }
[[[[Nl]]]]: Converts segment of byte array into long array .

[[[[Adv]]]]: protected static long [ ] bytesToLongs ( final byte [ ] ba , final int offset , final int [[carmel]] ) { long [ ] [[surname]] = new long [ [[carmel]] >> 3 ] ; int [[modo]] = offset ; for ( int i = 0 ; i < [[surname]] . length ; i ++ ) { [[surname]] [ i ] = Bits . getLong ( ba , [[modo]] ) ; [[modo]] += 8 ; } return [[surname]] ; }
[[[[Nl]]]]: Converts segment of byte array into long array .
--------------------------------------------- Result 957 ---------------------------------------------
Sets the bundle name for this request . --> documentation inherited from AbstractServlet --> Socre: 1.0

[[[[Adv]]]]: public static void [[setRequestBundleName]] ( final ServletRequest request , final String [[bundleName]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[bundleName]] ) ; } request . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[bundleName]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .

[[[[Adv]]]]: public static void [[número]] ( final ServletRequest request , final String [[afterburners]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[afterburners]] ) ; } request . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[afterburners]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .
--------------------------------------------- Result 958 ---------------------------------------------
Resolve column descriptors . --> [[[FAILED]]]

[[[[Adv]]]]: public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .

[[[[Adv]]]]: public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .
--------------------------------------------- Result 959 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 890 / 49 / 20 / 959:  96%|█████████▌| 959/1000 [8:30:12<21:48, 31.92s/it][Succeeded / Failed / Skipped / Total] 890 / 49 / 20 / 959:  96%|█████████▌| 960/1000 [8:30:34<21:16, 31.91s/it][Succeeded / Failed / Skipped / Total] 891 / 49 / 20 / 960:  96%|█████████▌| 960/1000 [8:30:34<21:16, 31.91s/it][Succeeded / Failed / Skipped / Total] 891 / 49 / 20 / 960:  96%|█████████▌| 961/1000 [8:30:35<20:43, 31.88s/it][Succeeded / Failed / Skipped / Total] 892 / 49 / 20 / 961:  96%|█████████▌| 961/1000 [8:30:35<20:43, 31.88s/it][Succeeded / Failed / Skipped / Total] 892 / 49 / 20 / 961:  96%|█████████▌| 962/1000 [8:33:09<20:16, 32.01s/it][Succeeded / Failed / Skipped / Total] 893 / 49 / 20 / 962:  96%|█████████▌| 962/1000 [8:33:09<20:16, 32.01s/it][Succeeded / Failed / Skipped / Total] 893 / 49 / 20 / 962:  96%|█████████▋| 963/1000 [8:33:29<19:43, 31.99s/it][Succeeded / Failed / Skipped / Total] 894 / 49 / 20 / 963:  96%|█████████▋| 963/1000 [8:33:29<19:43, 31.99s/it][Succeeded / Failed / Skipped / Total] 894 / 49 / 20 / 963:  96%|█████████▋| 964/1000 [8:33:51<19:11, 31.98s/it][Succeeded / Failed / Skipped / Total] 895 / 49 / 20 / 964:  96%|█████████▋| 964/1000 [8:33:51<19:11, 31.98s/it][Succeeded / Failed / Skipped / Total] 895 / 49 / 20 / 964:  96%|█████████▋| 965/1000 [8:34:27<18:39, 31.99s/it][Succeeded / Failed / Skipped / Total] 896 / 49 / 20 / 965:  96%|█████████▋| 965/1000 [8:34:27<18:39, 31.99s/it][Succeeded / Failed / Skipped / Total] 896 / 49 / 20 / 965:  97%|█████████▋| 966/1000 [8:34:50<18:07, 31.98s/it]Reads data from an input stream . --> private for testing --> Socre: 1.0

[[[[Adv]]]]: private static byte [ ] readStream ( final InputStream inputStream , final boolean close ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int [[bytesRead]] ; while ( ( [[bytesRead]] = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , [[bytesRead]] ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( close ) { inputStream . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .

[[[[Adv]]]]: private static byte [ ] readStream ( final InputStream inputStream , final boolean close ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int [[privatizing]] ; while ( ( [[privatizing]] = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , [[privatizing]] ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( close ) { inputStream . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .
--------------------------------------------- Result 960 ---------------------------------------------
Add profile . --> Adds a single profile --> Socre: 1.0

[[[[Adv]]]]: public PropsEntries profile ( final String ... [[profiles]] ) { if ( [[profiles]] == null ) { return this ; } for ( String profile : [[profiles]] ) { addProfiles ( profile ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .

[[[[Adv]]]]: public PropsEntries profile ( final String ... [[congrats]] ) { if ( [[congrats]] == null ) { return this ; } for ( String profile : [[congrats]] ) { addProfiles ( profile ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .
--------------------------------------------- Result 961 ---------------------------------------------
Adds content to a ZIP file . --> this method is used for testing --> Socre: 1.0

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String [[path]] , final String comment ) throws IOException { while ( [[path]] . length ( ) != 0 && [[path]] . charAt ( 0 ) == ' ' ) { [[path]] = [[path]] . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( [[path]] , ' ' ) ) { [[path]] = [[path]] . substring ( 0 , [[path]] . length ( ) - 1 ) ; } ZipEntry [[zipEntry]] = new ZipEntry ( [[path]] ) ; [[zipEntry]] . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { [[zipEntry]] . setComment ( comment ) ; } zos . putNextEntry ( [[zipEntry]] ) ; InputStream [[is]] = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( [[is]] , zos ) ; } finally { StreamUtil . close ( [[is]] ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String [[tru]] , final String comment ) throws IOException { while ( [[tru]] . length ( ) != 0 && [[tru]] . charAt ( 0 ) == ' ' ) { [[tru]] = [[tru]] . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( [[tru]] , ' ' ) ) { [[tru]] = [[tru]] . substring ( 0 , [[tru]] . length ( ) - 1 ) ; } ZipEntry [[perched]] = new ZipEntry ( [[tru]] ) ; [[perched]] . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { [[perched]] . setComment ( comment ) ; } zos . putNextEntry ( [[perched]] ) ; InputStream [[sutra]] = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( [[sutra]] , zos ) ; } finally { StreamUtil . close ( [[sutra]] ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .
--------------------------------------------- Result 962 ---------------------------------------------
Read a long from the buffer at the given offset . --> This method is used to get the actual value of the int --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLongLittleEndian]] ( final byte [ ] [[buf]] , final int offset ) { return ( ( long ) [[buf]] [ offset + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .

[[[[Adv]]]]: public static long [[aboutyour]] ( final byte [ ] [[nitroglycerin]] , final int offset ) { return ( ( long ) [[nitroglycerin]] [ offset + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .
--------------------------------------------- Result 963 ---------------------------------------------
Returns the session s locale . --> helper method to get blackheads --> Socre: 1.0

[[[[Adv]]]]: public static Locale [[getSessionLocale]] ( final HttpSession [[session]] ) { Locale [[locale]] = ( Locale ) [[session]] . getAttribute ( SESSION_LOCALE_ATTR ) ; return [[locale]] == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : [[locale]] ; }
[[[[Nl]]]]: Returns current locale from session . s

[[[[Adv]]]]: public static Locale [[blackheads]] ( final HttpSession [[waitresses]] ) { Locale [[montréal]] = ( Locale ) [[waitresses]] . getAttribute ( SESSION_LOCALE_ATTR ) ; return [[montréal]] == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : [[montréal]] ; }
[[[[Nl]]]]: Returns current locale from session . s
--------------------------------------------- Result 964 ---------------------------------------------
Read all bootstrap methods attribute . --> generate grecian int array --> Socre: 1.0

[[[[Adv]]]]: private int [ ] [[readBootstrapMethodsAttribute]] ( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .

[[[[Adv]]]]: private int [ ] [[grecian]] ( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .
--------------------------------------------- Result 965 ---------------------------------------------
Filter parameters by bean name . --> Methode permettant de profiler --> Socre: 1.0

[[[[Adv]]]]: public String [ ] [[filterParametersForBeanName]] ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > [[list]] = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > [[entry]] : params . entrySet ( ) ) { String key = [[entry]] . getKey ( ) ; if ( ! key . startsWith ( beanName ) ) { continue ; } [[list]] . add ( key ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .

[[[[Adv]]]]: public String [ ] [[fontaine]] ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > [[disconnecting]] = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > [[brokered]] : params . entrySet ( ) ) { String key = [[brokered]] . getKey ( ) ; if ( ! key . startsWith ( beanName ) ) { continue ; } [[disconnecting]] . add ( key ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .
--------------------------------------------- Result 966 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 897 / 49 / 20 / 966:  97%|█████████▋| 966/1000 [8:34:50<18:07, 31.98s/it][Succeeded / Failed / Skipped / Total] 897 / 49 / 20 / 966:  97%|█████████▋| 967/1000 [8:35:13<17:34, 31.97s/it][Succeeded / Failed / Skipped / Total] 898 / 49 / 20 / 967:  97%|█████████▋| 967/1000 [8:35:13<17:34, 31.97s/it][Succeeded / Failed / Skipped / Total] 898 / 49 / 20 / 967:  97%|█████████▋| 968/1000 [8:35:27<17:02, 31.95s/it][Succeeded / Failed / Skipped / Total] 899 / 49 / 20 / 968:  97%|█████████▋| 968/1000 [8:35:27<17:02, 31.95s/it][Succeeded / Failed / Skipped / Total] 899 / 49 / 20 / 968:  97%|█████████▋| 969/1000 [8:36:28<16:31, 31.98s/it][Succeeded / Failed / Skipped / Total] 900 / 49 / 20 / 969:  97%|█████████▋| 969/1000 [8:36:28<16:31, 31.98s/it][Succeeded / Failed / Skipped / Total] 900 / 49 / 20 / 969:  97%|█████████▋| 970/1000 [8:36:47<15:58, 31.97s/it][Succeeded / Failed / Skipped / Total] 901 / 49 / 20 / 970:  97%|█████████▋| 970/1000 [8:36:47<15:58, 31.97s/it][Succeeded / Failed / Skipped / Total] 901 / 49 / 20 / 970:  97%|█████████▋| 971/1000 [8:36:51<15:26, 31.94s/it][Succeeded / Failed / Skipped / Total] 902 / 49 / 20 / 971:  97%|█████████▋| 971/1000 [8:36:51<15:26, 31.94s/it][Succeeded / Failed / Skipped / Total] 902 / 49 / 20 / 971:  97%|█████████▋| 972/1000 [8:37:04<14:53, 31.92s/it][Succeeded / Failed / Skipped / Total] 903 / 49 / 20 / 972:  97%|█████████▋| 972/1000 [8:37:04<14:53, 31.92s/it][Succeeded / Failed / Skipped / Total] 903 / 49 / 20 / 972:  97%|█████████▋| 973/1000 [8:37:05<14:20, 31.89s/it][Succeeded / Failed / Skipped / Total] 904 / 49 / 20 / 973:  97%|█████████▋| 973/1000 [8:37:05<14:20, 31.89s/it][Succeeded / Failed / Skipped / Total] 904 / 49 / 20 / 973:  97%|█████████▋| 974/1000 [8:37:08<13:48, 31.86s/it]Gets the named CtorDescriptor . --> Get a CtorDescriptor --> Socre: 1.0

[[[[Adv]]]]: public CtorDescriptor getCtorDescriptor ( final Class ... args ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] [[arg]] = ctorDescriptor . getParameters ( ) ; if ( [[arg]] . length != args . length ) { continue ; } for ( int j = 0 ; j < [[arg]] . length ; j ++ ) { if ( [[arg]] [ j ] != args [ j ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .

[[[[Adv]]]]: public CtorDescriptor getCtorDescriptor ( final Class ... args ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] [[angela]] = ctorDescriptor . getParameters ( ) ; if ( [[angela]] . length != args . length ) { continue ; } for ( int j = 0 ; j < [[angela]] . length ; j ++ ) { if ( [[angela]] [ j ] != args [ j ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .
--------------------------------------------- Result 967 ---------------------------------------------
Sets the session locale . --> Put cutthroats into chart --> Socre: 1.0

[[[[Adv]]]]: public static void [[setSessionLocale]] ( final HttpSession [[session]] , final String localeCode ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + localeCode ) ; } Locale locale = Locale . forLanguageTag ( localeCode ) ; [[session]] . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .

[[[[Adv]]]]: public static void [[cutthroats]] ( final HttpSession [[chart]] , final String localeCode ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + localeCode ) ; } Locale locale = Locale . forLanguageTag ( localeCode ) ; [[chart]] . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .
--------------------------------------------- Result 968 ---------------------------------------------
Get the constructors for the class . --> Get constructor descriptors --> Socre: 1.0

[[[[Adv]]]]: protected CtorDescriptor [ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor ctor = ctors [ i ] ; CtorDescriptor [[ctorDescriptor]] = createCtorDescriptor ( ctor ) ; allCtors [ i ] = [[ctorDescriptor]] ; if ( [[ctorDescriptor]] . isDefault ( ) ) { defaultCtor = [[ctorDescriptor]] ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .

[[[[Adv]]]]: protected CtorDescriptor [ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor ctor = ctors [ i ] ; CtorDescriptor [[auroras]] = createCtorDescriptor ( ctor ) ; allCtors [ i ] = [[auroras]] ; if ( [[auroras]] . isDefault ( ) ) { defaultCtor = [[auroras]] ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .
--------------------------------------------- Result 969 ---------------------------------------------
Convert an array to an array . --> helper method for anima --> Socre: 1.0

[[[[Adv]]]]: protected long [ ] [[convertArrayToArray]] ( final Object value ) { final Class valueComponentType = value . getClass ( ) . getComponentType ( ) ; final long [ ] result ; if ( valueComponentType . isPrimitive ( ) ) { result = convertPrimitiveArrayToArray ( value , valueComponentType ) ; } else {
[[[[Nl]]]]: Converts array value to array .

[[[[Adv]]]]: protected long [ ] [[anima]] ( final Object value ) { final Class valueComponentType = value . getClass ( ) . getComponentType ( ) ; final long [ ] result ; if ( valueComponentType . isPrimitive ( ) ) { result = convertPrimitiveArrayToArray ( value , valueComponentType ) ; } else {
[[[[Nl]]]]: Converts array value to array .
--------------------------------------------- Result 970 ---------------------------------------------
Initializes the filter . --> Initialize the AsParagraphConfig --> Socre: 1.0

[[[[Adv]]]]: @ Override public void init ( final FilterConfig [[filterConfig]] ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .

[[[[Adv]]]]: @ Override public void init ( final FilterConfig [[asparagus]] ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .
--------------------------------------------- Result 971 ---------------------------------------------
Reads a label . --> Dinozzozzo --> Socre: 1.0

[[[[Adv]]]]: protected Label [[readLabel]] ( final int bytecodeOffset , final Label [ ] [[labels]] ) { if ( [[labels]] [ bytecodeOffset ] == null ) { [[labels]] [ bytecodeOffset ] = new Label ( ) ; } return [[labels]] [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .

[[[[Adv]]]]: protected Label [[dinozzo]] ( final int bytecodeOffset , final Label [ ] [[latinos]] ) { if ( [[latinos]] [ bytecodeOffset ] == null ) { [[latinos]] [ bytecodeOffset ] = new Label ( ) ; } return [[latinos]] [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .
--------------------------------------------- Result 972 ---------------------------------------------
Returns the request map . --> get heartbeats --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > getRequestMap ( final HttpServletRequest [[servletRequest]] ) { return ( Map < String , TransientBeanData > ) [[servletRequest]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > getRequestMap ( final HttpServletRequest [[captain]] ) { return ( Map < String , TransientBeanData > ) [[captain]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .
--------------------------------------------- Result 973 ---------------------------------------------
Read element values . --> Click on autoconnect event --> Socre: 1.0

[[[[Adv]]]]: private int [[readElementValues]] ( final AnnotationVisitor [[annotationVisitor]] , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { int currentOffset = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .

[[[[Adv]]]]: private int [[autographed]] ( final AnnotationVisitor [[click]] , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { int currentOffset = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .
--------------------------------------------- Result 974 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 905 / 49 / 20 / 974:  97%|█████████▋| 974/1000 [8:37:08<13:48, 31.86s/it][Succeeded / Failed / Skipped / Total] 905 / 49 / 20 / 974:  98%|█████████▊| 975/1000 [8:37:54<13:16, 31.87s/it][Succeeded / Failed / Skipped / Total] 906 / 49 / 20 / 975:  98%|█████████▊| 975/1000 [8:37:54<13:16, 31.87s/it][Succeeded / Failed / Skipped / Total] 906 / 49 / 20 / 975:  98%|█████████▊| 976/1000 [8:38:18<12:44, 31.86s/it][Succeeded / Failed / Skipped / Total] 907 / 49 / 20 / 976:  98%|█████████▊| 976/1000 [8:38:18<12:44, 31.86s/it][Succeeded / Failed / Skipped / Total] 907 / 49 / 20 / 976:  98%|█████████▊| 977/1000 [8:38:50<12:12, 31.86s/it][Succeeded / Failed / Skipped / Total] 908 / 49 / 20 / 977:  98%|█████████▊| 977/1000 [8:38:50<12:12, 31.86s/it][Succeeded / Failed / Skipped / Total] 908 / 49 / 20 / 977:  98%|█████████▊| 978/1000 [8:39:04<11:40, 31.84s/it][Succeeded / Failed / Skipped / Total] 909 / 49 / 20 / 978:  98%|█████████▊| 978/1000 [8:39:04<11:40, 31.84s/it][Succeeded / Failed / Skipped / Total] 909 / 49 / 20 / 978:  98%|█████████▊| 979/1000 [8:39:25<11:08, 31.83s/it][Succeeded / Failed / Skipped / Total] 910 / 49 / 20 / 979:  98%|█████████▊| 979/1000 [8:39:25<11:08, 31.83s/it][Succeeded / Failed / Skipped / Total] 910 / 49 / 20 / 979:  98%|█████████▊| 980/1000 [8:39:45<10:36, 31.82s/it][Succeeded / Failed / Skipped / Total] 911 / 49 / 20 / 980:  98%|█████████▊| 980/1000 [8:39:45<10:36, 31.82s/it][Succeeded / Failed / Skipped / Total] 911 / 49 / 20 / 980:  98%|█████████▊| 981/1000 [8:40:35<10:04, 31.84s/it][Succeeded / Failed / Skipped / Total] 912 / 49 / 20 / 981:  98%|█████████▊| 981/1000 [8:40:35<10:04, 31.84s/it][Succeeded / Failed / Skipped / Total] 912 / 49 / 20 / 981:  98%|█████████▊| 982/1000 [8:40:49<09:32, 31.82s/it]Registers a file consumer . --> Adds a listener which listens to the repository . --> Socre: 1.0

[[[[Adv]]]]: public FindFile onFile ( final Consumer < File > [[fileConsumer]] ) { if ( consumers == null ) { consumers = Consumers . of ( [[fileConsumer]] ) ; } else { consumers . add ( [[fileConsumer]] ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer

[[[[Adv]]]]: public FindFile onFile ( final Consumer < File > [[believer]] ) { if ( consumers == null ) { consumers = Consumers . of ( [[believer]] ) ; } else { consumers . add ( [[believer]] ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer
--------------------------------------------- Result 975 ---------------------------------------------
Get the bytecode offset for a type annotation . --> borrowan image --> Socre: 1.0

[[[[Adv]]]]: private int [[getTypeAnnotationBytecodeOffset]] ( final int [ ] [[typeAnnotationOffsets]] , final int typeAnnotationIndex ) { if ( [[typeAnnotationOffsets]] == null || typeAnnotationIndex >= [[typeAnnotationOffsets]] . length || readByte ( [[typeAnnotationOffsets]] [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( [[typeAnnotationOffsets]] [ typeAnnotationIndex ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .

[[[[Adv]]]]: private int [[brendan]] ( final int [ ] [[cameraman]] , final int typeAnnotationIndex ) { if ( [[cameraman]] == null || typeAnnotationIndex >= [[cameraman]] . length || readByte ( [[cameraman]] [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( [[cameraman]] [ typeAnnotationIndex ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .
--------------------------------------------- Result 976 ---------------------------------------------
Adds the given path to the list . --> Add an organization --> Socre: 1.0

[[[[Adv]]]]: protected void [[addPath]] ( final File path ) { if ( ! path . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( path ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .

[[[[Adv]]]]: protected void [[organization]] ( final File path ) { if ( ! path . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( path ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .
--------------------------------------------- Result 977 ---------------------------------------------
Find all files . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public List < File > [[findAll]] ( ) { List < File > allFiles = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { allFiles . add ( file ) ; } return allFiles ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .

[[[[Adv]]]]: public List < File > [[wouldnít]] ( ) { List < File > allFiles = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { allFiles . add ( file ) ; } return allFiles ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .
--------------------------------------------- Result 978 ---------------------------------------------
Includes the given patterns . --> Add pattern to the FindFile --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[include]] ( final String ... patterns ) { for ( String pattern : patterns ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .

[[[[Adv]]]]: public FindFile [[cassidy]] ( final String ... patterns ) { for ( String pattern : patterns ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .
--------------------------------------------- Result 979 ---------------------------------------------
Creates the request map . --> helper to handle a helvetica --> Socre: 1.0

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[createRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { Map < String , TransientBeanData > map = new HashMap <> ( ) ; [[servletRequest]] . setAttribute ( ATTR_NAME , map ) ; return map ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[helvetica]] ( final HttpServletRequest [[première]] ) { Map < String , TransientBeanData > map = new HashMap <> ( ) ; [[première]] . setAttribute ( ATTR_NAME , map ) ; return map ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .
--------------------------------------------- Result 980 ---------------------------------------------
Iterate over the files in the collection . --> Clapton files --> Socre: 1.0

[[[[Adv]]]]: @ Override public Iterator < File > [[iterator]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .

[[[[Adv]]]]: @ Override public Iterator < File > [[clapton]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .
--------------------------------------------- Result 981 ---------------------------------------------
Initialize todo . --> initialize todo --> Socre: 1.0

[[[[Adv]]]]: protected void init ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int index = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File [[file]] = iterator . next ( ) ; if ( [[file]] . isFile ( ) ) { files [ index ++ ] = [[file]] . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( index != 0 ) { FilesIterator filesIterator = new FilesIterator ( files ) ; todoFiles . add ( filesIterator ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .

[[[[Adv]]]]: protected void init ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int index = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File [[maharishi]] = iterator . next ( ) ; if ( [[maharishi]] . isFile ( ) ) { files [ index ++ ] = [[maharishi]] . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( index != 0 ) { FilesIterator filesIterator = new FilesIterator ( files ) ; todoFiles . add ( filesIterator ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .
--------------------------------------------- Result 982 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 913 / 49 / 20 / 982:  98%|█████████▊| 982/1000 [8:40:49<09:32, 31.82s/it][Succeeded / Failed / Skipped / Total] 913 / 49 / 20 / 982:  98%|█████████▊| 983/1000 [8:41:06<09:00, 31.81s/it][Succeeded / Failed / Skipped / Total] 914 / 49 / 20 / 983:  98%|█████████▊| 983/1000 [8:41:06<09:00, 31.81s/it][Succeeded / Failed / Skipped / Total] 914 / 49 / 20 / 983:  98%|█████████▊| 984/1000 [8:42:29<08:29, 31.86s/it][Succeeded / Failed / Skipped / Total] 915 / 49 / 20 / 984:  98%|█████████▊| 984/1000 [8:42:29<08:29, 31.86s/it][Succeeded / Failed / Skipped / Total] 915 / 49 / 20 / 984:  98%|█████████▊| 985/1000 [8:42:52<07:57, 31.85s/it][Succeeded / Failed / Skipped / Total] 916 / 49 / 20 / 985:  98%|█████████▊| 985/1000 [8:42:52<07:57, 31.85s/it][Succeeded / Failed / Skipped / Total] 916 / 49 / 20 / 985:  99%|█████████▊| 986/1000 [8:43:43<07:26, 31.87s/it][Succeeded / Failed / Skipped / Total] 917 / 49 / 20 / 986:  99%|█████████▊| 986/1000 [8:43:43<07:26, 31.87s/it][Succeeded / Failed / Skipped / Total] 917 / 49 / 20 / 986:  99%|█████████▊| 987/1000 [8:44:05<06:54, 31.86s/it][Succeeded / Failed / Skipped / Total] 918 / 49 / 20 / 987:  99%|█████████▊| 987/1000 [8:44:05<06:54, 31.86s/it][Succeeded / Failed / Skipped / Total] 918 / 49 / 20 / 987:  99%|█████████▉| 988/1000 [8:44:27<06:22, 31.85s/it][Succeeded / Failed / Skipped / Total] 918 / 50 / 20 / 988:  99%|█████████▉| 988/1000 [8:44:27<06:22, 31.85s/it][Succeeded / Failed / Skipped / Total] 918 / 50 / 20 / 988:  99%|█████████▉| 989/1000 [8:44:54<05:50, 31.84s/it]Exclude patterns . --> Excludes from kumite --> Socre: 1.0

[[[[Adv]]]]: public FindFile exclude ( final String ... [[patterns]] ) { for ( String [[pattern]] : [[patterns]] ) { rules . exclude ( [[pattern]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .

[[[[Adv]]]]: public FindFile exclude ( final String ... [[kumite]] ) { for ( String [[ships]] : [[kumite]] ) { rules . exclude ( [[ships]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .
--------------------------------------------- Result 983 ---------------------------------------------
Returns the output writer . --> Return tiptoe --> Socre: 1.0

[[[[Adv]]]]: public PrintWriter [[getWriter]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .

[[[[Adv]]]]: public PrintWriter [[tiptoe]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .
--------------------------------------------- Result 984 ---------------------------------------------
Gets the output stream . --> must be called before --> Socre: 1.0

[[[[Adv]]]]: public ServletOutputStream [[getOutputStream]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .

[[[[Adv]]]]: public ServletOutputStream [[kif]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .
--------------------------------------------- Result 985 ---------------------------------------------
Add search path . --> Add findPath to findFile --> Socre: 1.0

[[[[Adv]]]]: public FindFile searchPath ( final URI [[searchPath]] ) { File [[file]] ; try { [[file]] = new File ( searchPath ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + searchPath , ex ) ; } addPath ( [[file]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .

[[[[Adv]]]]: public FindFile searchPath ( final URI [[rosebud]] ) { File [[antigravity]] ; try { [[antigravity]] = new File ( searchPath ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + searchPath , ex ) ; } addPath ( [[antigravity]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .
--------------------------------------------- Result 986 ---------------------------------------------
Gets the descriptor of a constructor . --> Build stuttgart --> Socre: 1.0

[[[[Adv]]]]: public static String [[getConstructorDescriptor]] ( final Constructor < ? > constructor ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = constructor . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .

[[[[Adv]]]]: public static String [[stuttgart]] ( final Constructor < ? > constructor ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = constructor . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .
--------------------------------------------- Result 987 ---------------------------------------------
Add file . --> add kie to kie --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URL searchPath ) { File file = FileUtil . toContainerFile ( [[searchPath]] ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + [[searchPath]] ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .

[[[[Adv]]]]: public FindFile [[kie]] ( final URL searchPath ) { File file = FileUtil . toContainerFile ( [[kie]] ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + [[kie]] ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .
--------------------------------------------- Result 988 ---------------------------------------------
Read verification type info . --> [[[FAILED]]]

[[[[Adv]]]]: private int readVerificationTypeInfo ( final int [[verificationTypeInfoOffset]] , final Object [ ] frame , final int [[index]] , final char [ ] charBuffer , final Label [ ] [[labels]] ) { int currentOffset = [[verificationTypeInfoOffset]] ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ [[index]] ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ [[index]] ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ [[index]] ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ [[index]] ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ [[index]] ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ [[index]] ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ [[index]] ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ [[index]] ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ [[index]] ] = createLabel ( readUnsignedShort ( currentOffset ) , [[labels]] ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .

[[[[Adv]]]]: private int readVerificationTypeInfo ( final int [[regret]] , final Object [ ] frame , final int [[senators]] , final char [ ] charBuffer , final Label [ ] [[barbarity]] ) { int currentOffset = [[regret]] ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ [[senators]] ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ [[senators]] ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ [[senators]] ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ [[senators]] ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ [[senators]] ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ [[senators]] ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ [[senators]] ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ [[senators]] ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ [[senators]] ] = createLabel ( readUnsignedShort ( currentOffset ) , [[barbarity]] ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .
--------------------------------------------- Result 989 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 919 / 50 / 20 / 989:  99%|█████████▉| 989/1000 [8:44:54<05:50, 31.84s/it][Succeeded / Failed / Skipped / Total] 919 / 50 / 20 / 989:  99%|█████████▉| 990/1000 [8:45:52<05:18, 31.87s/it][Succeeded / Failed / Skipped / Total] 920 / 50 / 20 / 990:  99%|█████████▉| 990/1000 [8:45:52<05:18, 31.87s/it][Succeeded / Failed / Skipped / Total] 920 / 50 / 20 / 990:  99%|█████████▉| 991/1000 [8:46:10<04:46, 31.86s/it][Succeeded / Failed / Skipped / Total] 921 / 50 / 20 / 991:  99%|█████████▉| 991/1000 [8:46:10<04:46, 31.86s/it][Succeeded / Failed / Skipped / Total] 921 / 50 / 20 / 991:  99%|█████████▉| 992/1000 [8:46:30<04:14, 31.85s/it][Succeeded / Failed / Skipped / Total] 922 / 50 / 20 / 992:  99%|█████████▉| 992/1000 [8:46:30<04:14, 31.85s/it][Succeeded / Failed / Skipped / Total] 922 / 50 / 20 / 992:  99%|█████████▉| 993/1000 [8:46:44<03:42, 31.83s/it][Succeeded / Failed / Skipped / Total] 923 / 50 / 20 / 993:  99%|█████████▉| 993/1000 [8:46:44<03:42, 31.83s/it][Succeeded / Failed / Skipped / Total] 923 / 50 / 20 / 993:  99%|█████████▉| 994/1000 [8:46:50<03:10, 31.80s/it]Gets the size of this field . --> Methode --> Socre: 1.0

[[[[Adv]]]]: public int [[getSize]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .

[[[[Adv]]]]: public int [[muñoz]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .
--------------------------------------------- Result 990 ---------------------------------------------
Returns the binary representation of this type . --> Make a human readable text --> Socre: 1.0

[[[[Adv]]]]: public String [[getClassName]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int [[i]] = getDimensions ( ) ; [[i]] > 0 ; -- [[i]] ) { stringBuilder . append ( "[]" ) ; } return stringBuilder . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .

[[[[Adv]]]]: public String [[censored]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int [[ambush]] = getDimensions ( ) ; [[ambush]] > 0 ; -- [[ambush]] ) { stringBuilder . append ( "[]" ) ; } return stringBuilder . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .
--------------------------------------------- Result 991 ---------------------------------------------
Mark this transaction as rollback only . --> Mark or rollback cause --> Socre: 1.0

[[[[Adv]]]]: public void [[setRollbackOnly]] ( final Throwable th ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = th ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .

[[[[Adv]]]]: public void [[hughie]] ( final Throwable th ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = th ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .
--------------------------------------------- Result 992 ---------------------------------------------
Commit the transaction or rollback . --> Called to execute a Ctx --> Socre: 1.0

[[[[Adv]]]]: protected void [[commitOrRollback]] ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "False" != "False" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "False" != "False" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .

[[[[Adv]]]]: protected void [[cappuccino]] ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "False" != "False" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "False" != "False" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .
--------------------------------------------- Result 993 ---------------------------------------------
Returns the wiring mode for the given type . --> Get leonora setting --> Socre: 1.0

[[[[Adv]]]]: public WiringMode [[resolveBeanWiringMode]] ( final Class [[type]] ) { PetiteBean petiteBean = ( ( Class < ? > ) [[type]] ) . getAnnotation ( PetiteBean . class ) ; return petiteBean != null ? petiteBean . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .

[[[[Adv]]]]: public WiringMode [[leonora]] ( final Class [[collecting]] ) { PetiteBean petiteBean = ( ( Class < ? > ) [[collecting]] ) . getAnnotation ( PetiteBean . class ) ; return petiteBean != null ? petiteBean . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .
--------------------------------------------- Result 994 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 924 / 50 / 20 / 994:  99%|█████████▉| 994/1000 [8:46:50<03:10, 31.80s/it][Succeeded / Failed / Skipped / Total] 924 / 50 / 20 / 994: 100%|█████████▉| 995/1000 [8:48:12<02:39, 31.85s/it][Succeeded / Failed / Skipped / Total] 925 / 50 / 20 / 995: 100%|█████████▉| 995/1000 [8:48:12<02:39, 31.85s/it][Succeeded / Failed / Skipped / Total] 925 / 50 / 20 / 995: 100%|█████████▉| 996/1000 [8:50:17<02:07, 31.95s/it][Succeeded / Failed / Skipped / Total] 926 / 50 / 20 / 996: 100%|█████████▉| 996/1000 [8:50:17<02:07, 31.95s/it][Succeeded / Failed / Skipped / Total] 926 / 50 / 20 / 996: 100%|█████████▉| 997/1000 [8:50:20<01:35, 31.92s/it][Succeeded / Failed / Skipped / Total] 927 / 50 / 20 / 997: 100%|█████████▉| 997/1000 [8:50:20<01:35, 31.92s/it][Succeeded / Failed / Skipped / Total] 927 / 50 / 20 / 997: 100%|█████████▉| 998/1000 [8:53:56<01:04, 32.10s/it][Succeeded / Failed / Skipped / Total] 928 / 50 / 20 / 998: 100%|█████████▉| 998/1000 [8:53:56<01:04, 32.10s/it][Succeeded / Failed / Skipped / Total] 928 / 50 / 20 / 998: 100%|█████████▉| 999/1000 [8:54:15<00:32, 32.09s/it][Succeeded / Failed / Skipped / Total] 929 / 50 / 20 / 999: 100%|█████████▉| 999/1000 [8:54:15<00:32, 32.09s/it][Succeeded / Failed / Skipped / Total] 929 / 50 / 20 / 999: 100%|██████████| 1000/1000 [8:58:13<00:00, 32.29s/it]Resolve the bean name . --> transition a class --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveBeanName]] ( final Class type , final boolean useLongTypeName ) { PetiteBean [[petiteBean]] = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; String [[name]] = null ; if ( [[petiteBean]] != null ) { [[name]] = [[petiteBean]] . value ( ) . trim ( ) ; } if ( ( [[name]] == null ) || ( [[name]] . length ( ) == 0 ) ) { if ( useLongTypeName ) { [[name]] = type . getName ( ) ; } else { [[name]] = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; } } return [[name]] ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .

[[[[Adv]]]]: public String [[narang]] ( final Class type , final boolean useLongTypeName ) { PetiteBean [[tank]] = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; String [[transfigured]] = null ; if ( [[tank]] != null ) { [[transfigured]] = [[tank]] . value ( ) . trim ( ) ; } if ( ( [[transfigured]] == null ) || ( [[transfigured]] . length ( ) == 0 ) ) { if ( useLongTypeName ) { [[transfigured]] = type . getName ( ) ; } else { [[transfigured]] = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; } } return [[transfigured]] ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .
--------------------------------------------- Result 995 ---------------------------------------------
Appends the descriptor to the given string builder . --> Cuck a value --> Socre: 1.0

[[[[Adv]]]]: private void [[appendDescriptor]] ( final StringBuilder [[stringBuilder]] ) { if ( sort == OBJECT ) { [[stringBuilder]] . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { [[stringBuilder]] . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { [[stringBuilder]] . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .

[[[[Adv]]]]: private void [[cuckoo]] ( final StringBuilder [[raccoon]] ) { if ( sort == OBJECT ) { [[raccoon]] . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { [[raccoon]] . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { [[raccoon]] . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .
--------------------------------------------- Result 996 ---------------------------------------------
Gets the method descriptor . --> Get method description --> Socre: 1.0

[[[[Adv]]]]: public static String getMethodDescriptor ( final Type returnType , final Type ... argumentTypes ) { StringBuilder [[stringBuilder]] = new StringBuilder ( ) ; [[stringBuilder]] . append ( ' ' ) ; for ( Type [[argumentType]] : argumentTypes ) { [[argumentType]] . appendDescriptor ( [[stringBuilder]] ) ; } [[stringBuilder]] . append ( ' ' ) ; returnType . appendDescriptor ( [[stringBuilder]] ) ; return [[stringBuilder]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .

[[[[Adv]]]]: public static String getMethodDescriptor ( final Type returnType , final Type ... argumentTypes ) { StringBuilder [[srinagar]] = new StringBuilder ( ) ; [[srinagar]] . append ( ' ' ) ; for ( Type [[kang]] : argumentTypes ) { [[kang]] . appendDescriptor ( [[srinagar]] ) ; } [[srinagar]] . append ( ' ' ) ; returnType . appendDescriptor ( [[srinagar]] ) ; return [[srinagar]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .
--------------------------------------------- Result 997 ---------------------------------------------
Gets the method descriptor . --> Get a description of a procedure --> Socre: 1.0

[[[[Adv]]]]: public static String getMethodDescriptor ( final Method [[method]] ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = [[method]] . getParameterTypes ( ) ; for ( Class < ? > [[parameter]] : parameters ) { appendDescriptor ( [[parameter]] , stringBuilder ) ; } stringBuilder . append ( ' ' ) ; appendDescriptor ( [[method]] . getReturnType ( ) , stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .

[[[[Adv]]]]: public static String getMethodDescriptor ( final Method [[hospitalize]] ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = [[hospitalize]] . getParameterTypes ( ) ; for ( Class < ? > [[visually]] : parameters ) { appendDescriptor ( [[visually]] , stringBuilder ) ; } stringBuilder . append ( ' ' ) ; appendDescriptor ( [[hospitalize]] . getReturnType ( ) , stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .
--------------------------------------------- Result 998 ---------------------------------------------
Gets the number of arguments and return sizes . --> Boggling --> Socre: 1.0

[[[[Adv]]]]: public static int [[getArgumentsAndReturnSizes]] ( final String [[methodDescriptor]] ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .

[[[[Adv]]]]: public static int [[boggling]] ( final String [[retardation]] ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .
--------------------------------------------- Result 999 ---------------------------------------------
Rollback all transaction resources . --> Called to catch cron exceptions --> Socre: 1.0

[[[[Adv]]]]: protected void [[rollbackAllResources]] ( final boolean [[wasForced]] ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( [[wasForced]] ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .

[[[[Adv]]]]: protected void [[craters]] ( final boolean [[maría]] ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( [[maría]] ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .
--------------------------------------------- Result 1000 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 930 / 50 / 20 / 1000: 100%|██████████| 1000/1000 [8:58:13<00:00, 32.29s/it]Attack(
  (search_method): RandomSearch(
    (trials):  10
  )
  (goal_function):  MinimizeBleu(
    (maximizable):  False
    (target_bleu):  0.0
  )
  (transformation):  WordSwapRandom(
    (max_candidates):  50
    (embedding):  WordEmbedding
  )
  (constraints): 
    (0): MaxWordsPerturbed(
        (max_num_words):  5
        (compare_against_original):  True
      )
    (1): KeyWord(
        (compare_against_original):  True
      )
  (is_black_box):  True
) 

/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/graphcodebert_models.py:912: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at  ../torch/csrc/utils/tensor_new.cpp:201.)
  code_attn_mask = torch.tensor(code_attn_mask).to(model_device)
/data2/cg/CodeAttack/models/graphcodebert_models.py:1152: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
[Succeeded / Failed / Skipped / Total] 930 / 50 / 20 / 1000: 100%|██████████| 1000/1000 [8:58:18<00:00, 32.30s/it]Request a resource for a transaction . -->  quest for resources --> Socre: 1.0

[[[[Adv]]]]: public < [[E]] > [[E]] requestResource ( final Class < [[E]] > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; [[E]] resource = lookupResource ( resourceType ) ; if ( resource == null ) { int [[maxResources]] = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( [[maxResources]] != - 1 ) && ( resources . size ( ) >= [[maxResources]] ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < [[E]] > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

[[[[Adv]]]]: public < [[în]] > [[în]] requestResource ( final Class < [[în]] > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; [[în]] resource = lookupResource ( resourceType ) ; if ( resource == null ) { int [[amador]] = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( [[amador]] != - 1 ) && ( resources . size ( ) >= [[amador]] ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < [[în]] > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

+-------------------------------+--------+
| Attack Results                |        |
+-------------------------------+--------+
| Number of successful attacks: | 930    |
| Number of failed attacks:     | 50     |
| Number of skipped attacks:    | 20     |
| Original accuracy:            | 98.0%  |
| Accuracy under attack:        | 5.0%   |
| Attack success rate:          | 94.9%  |
| Average perturbed word %:     | 49.07% |
| Average num. words per input: | 3.91   |
| Avg num queries:              | 509.92 |
| Original BLEU-4:              | 18.48  |
| Perturbed BLEU-4:             | 0.41   |
+-------------------------------+--------+

