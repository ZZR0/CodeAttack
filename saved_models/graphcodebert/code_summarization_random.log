Some weights of the model checkpoint at microsoft/graphcodebert-base were not used when initializing RobertaModel: ['lm_head.layer_norm.weight', 'lm_head.dense.bias', 'lm_head.layer_norm.bias', 'lm_head.decoder.bias', 'lm_head.decoder.weight', 'lm_head.dense.weight', 'lm_head.bias']
- This IS expected if you are initializing RobertaModel from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
- This IS NOT expected if you are initializing RobertaModel from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).
Some weights of RobertaModel were not initialized from the model checkpoint at microsoft/graphcodebert-base and are newly initialized: ['roberta.pooler.dense.bias', 'roberta.pooler.dense.weight']
You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
textattack: Running 4 worker(s) on 4 GPU(s).
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/1000 [00:00<00:00, 1577.99it/s][Succeeded / Failed / Skipped / Total] 1 / 1 / 0 / 2:   0%|          | 2/1000 [00:00<00:00, 1797.82it/s][Succeeded / Failed / Skipped / Total] 2 / 1 / 0 / 3:   0%|          | 3/1000 [00:00<00:00, 2050.67it/s][Succeeded / Failed / Skipped / Total] 3 / 1 / 0 / 4:   0%|          | 4/1000 [00:00<00:00, 2268.42it/s][Succeeded / Failed / Skipped / Total] 3 / 2 / 0 / 5:   0%|          | 5/1000 [00:00<00:00, 2442.81it/s][Succeeded / Failed / Skipped / Total] 3 / 2 / 0 / 5:   1%|          | 6/1000 [00:17<48:14,  2.91s/it]  [Succeeded / Failed / Skipped / Total] 4 / 2 / 0 / 6:   1%|          | 6/1000 [00:17<48:14,  2.91s/it][Succeeded / Failed / Skipped / Total] 4 / 2 / 0 / 6:   1%|          | 7/1000 [00:21<49:42,  3.00s/it]--------------------------------------------- Result 1 ---------------------------------------------
Wraps an Observable . --> A madhav --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > [[source]] ) { ObjectHelper . requireNonNull ( [[source]] , "source is null" ) ; if ( [[source]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[source]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[source]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[madhav]] ( ObservableSource < T > [[aniseed]] ) { ObjectHelper . requireNonNull ( [[aniseed]] , "source is null" ) ; if ( [[aniseed]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[aniseed]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[aniseed]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 2 ---------------------------------------------
Emit a value to the downstream . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[fastPathOrderedEmit]] ( U value , boolean [[delayError]] , Disposable disposable ) { final Observer < ? super V > [[observer]] = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( [[observer]] , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , [[observer]] , [[delayError]] , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void [[juke]] ( U value , boolean [[brings]] , Disposable disposable ) { final Observer < ? super V > [[bronc]] = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( [[bronc]] , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , [[bronc]] , [[brings]] , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 3 ---------------------------------------------
Observable . --> Observable from Observable --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[observeOn]] ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[boorish]] ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 4 ---------------------------------------------
Create a new instance of this class . --> Create a new instance of this class --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int capacityHint ) { return new UnicastProcessor < T > ( capacityHint ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[razz]] ( int capacityHint ) { return new UnicastProcessor < T > ( capacityHint ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 5 ---------------------------------------------
Returns an Observable containing the elements of this list sorted by the given comparator . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[telecast]] ( Comparator < ? super T > [[shortly]] ) { ObjectHelper . requireNonNull ( [[shortly]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[shortly]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 6 ---------------------------------------------
Creates a new executor with given capacity . --> non - terminated runnable --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] , Runnable [[onCancelled]] ) { ObjectHelper . requireNonNull ( [[onCancelled]] , "onTerminate" ) ; return new UnicastProcessor < T > ( [[capacityHint]] , [[onCancelled]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[avoiding]] ( int [[aniseed]] , Runnable [[gopal]] ) { ObjectHelper . requireNonNull ( [[gopal]] , "onTerminate" ) ; return new UnicastProcessor < T > ( [[aniseed]] , [[gopal]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 7 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 5 / 2 / 0 / 7:   1%|          | 7/1000 [00:21<49:42,  3.00s/it][Succeeded / Failed / Skipped / Total] 5 / 2 / 0 / 7:   1%|          | 8/1000 [00:32<1:07:28,  4.08s/it][Succeeded / Failed / Skipped / Total] 6 / 2 / 0 / 8:   1%|          | 8/1000 [00:32<1:07:29,  4.08s/it][Succeeded / Failed / Skipped / Total] 6 / 2 / 0 / 8:   1%|          | 9/1000 [00:34<1:02:28,  3.78s/it][Succeeded / Failed / Skipped / Total] 7 / 2 / 0 / 9:   1%|          | 9/1000 [00:34<1:02:28,  3.78s/it][Succeeded / Failed / Skipped / Total] 7 / 2 / 0 / 9:   1%|          | 10/1000 [00:45<1:14:52,  4.54s/it][Succeeded / Failed / Skipped / Total] 7 / 3 / 0 / 10:   1%|          | 10/1000 [00:45<1:14:52,  4.54s/it][Succeeded / Failed / Skipped / Total] 7 / 3 / 0 / 10:   1%|          | 11/1000 [00:47<1:11:46,  4.35s/it][Succeeded / Failed / Skipped / Total] 8 / 3 / 0 / 11:   1%|          | 11/1000 [00:47<1:11:47,  4.35s/it][Succeeded / Failed / Skipped / Total] 8 / 3 / 0 / 11:   1%|          | 12/1000 [00:49<1:07:37,  4.11s/it][Succeeded / Failed / Skipped / Total] 8 / 4 / 0 / 12:   1%|          | 12/1000 [00:49<1:07:37,  4.11s/it][Succeeded / Failed / Skipped / Total] 8 / 4 / 0 / 12:   1%|▏         | 13/1000 [00:54<1:09:11,  4.21s/it]Reset the scheduler . --> For testing only --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( False ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[schnauzer]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( False ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 8 ---------------------------------------------
Construct a Maybe from a CompletableSource . --> Baumann by Publisher --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromCompletable]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[baumann]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 9 ---------------------------------------------
Gets a stream of scalar X values using the supplied mapping function . --> jigar x map element --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T [[value]] , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[value]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[jigar]] ( final T [[lemmy]] , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[lemmy]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 10 ---------------------------------------------
Create a Maybe from a single source . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fixings]] ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 11 ---------------------------------------------
Retries the future with the given number of times . --> Attempt to retry with given condition --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long times , Predicate < ? super Throwable > [[predicate]] ) { return toFlowable ( ) . retry ( times , [[predicate]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long times , Predicate < ? super Throwable > [[trustees]] ) { return toFlowable ( ) . retry ( times , [[trustees]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 12 ---------------------------------------------
Throws a NullPointerException if the given object is not null . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] requireNonNull ( [[T]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < [[rochelle]] > [[rochelle]] requireNonNull ( [[rochelle]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 13 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 9 / 4 / 0 / 13:   1%|▏         | 13/1000 [00:54<1:09:11,  4.21s/it][Succeeded / Failed / Skipped / Total] 9 / 4 / 0 / 13:   1%|▏         | 14/1000 [01:14<1:27:12,  5.31s/it][Succeeded / Failed / Skipped / Total] 9 / 5 / 0 / 14:   1%|▏         | 14/1000 [01:14<1:27:12,  5.31s/it][Succeeded / Failed / Skipped / Total] 9 / 5 / 0 / 14:   2%|▏         | 15/1000 [01:17<1:24:46,  5.16s/it][Succeeded / Failed / Skipped / Total] 10 / 5 / 0 / 15:   2%|▏         | 15/1000 [01:17<1:24:46,  5.16s/it][Succeeded / Failed / Skipped / Total] 10 / 5 / 0 / 15:   2%|▏         | 16/1000 [01:27<1:30:10,  5.50s/it][Succeeded / Failed / Skipped / Total] 11 / 5 / 0 / 16:   2%|▏         | 16/1000 [01:27<1:30:10,  5.50s/it][Succeeded / Failed / Skipped / Total] 11 / 5 / 0 / 16:   2%|▏         | 17/1000 [01:31<1:28:07,  5.38s/it][Succeeded / Failed / Skipped / Total] 12 / 5 / 0 / 17:   2%|▏         | 17/1000 [01:31<1:28:07,  5.38s/it][Succeeded / Failed / Skipped / Total] 12 / 5 / 0 / 17:   2%|▏         | 18/1000 [01:33<1:25:03,  5.20s/it][Succeeded / Failed / Skipped / Total] 13 / 5 / 0 / 18:   2%|▏         | 18/1000 [01:33<1:25:03,  5.20s/it][Succeeded / Failed / Skipped / Total] 13 / 5 / 0 / 18:   2%|▏         | 19/1000 [01:35<1:22:25,  5.04s/it][Succeeded / Failed / Skipped / Total] 13 / 6 / 0 / 19:   2%|▏         | 19/1000 [01:35<1:22:25,  5.04s/it][Succeeded / Failed / Skipped / Total] 13 / 6 / 0 / 19:   2%|▏         | 20/1000 [01:45<1:26:16,  5.28s/it][Succeeded / Failed / Skipped / Total] 14 / 6 / 0 / 20:   2%|▏         | 20/1000 [01:45<1:26:16,  5.28s/it][Succeeded / Failed / Skipped / Total] 14 / 6 / 0 / 20:   2%|▏         | 21/1000 [01:52<1:27:02,  5.33s/it]Tries to apply a scalar Xmap operator to a Publisher . --> Implements the barcode from Supplier --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( Publisher < T > source , Subscriber < ? super R > [[subscriber]] , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[subscriber]] ) ; return True ; } if ( t == null ) { EmptySubscription . complete ( [[subscriber]] ) ; return True ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[subscriber]] ) ; return True ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[subscriber]] ) ; return True ; } if ( u == null ) { EmptySubscription . complete ( [[subscriber]] ) ; return True ; } [[subscriber]] . onSubscribe ( new ScalarSubscription < R > ( [[subscriber]] , u ) ) ; } else { r . subscribe ( [[subscriber]] ) ; } return True ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[barbu]] ( Publisher < T > source , Subscriber < ? super R > [[bustamante]] , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[bustamante]] ) ; return True ; } if ( t == null ) { EmptySubscription . complete ( [[bustamante]] ) ; return True ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[bustamante]] ) ; return True ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[bustamante]] ) ; return True ; } if ( u == null ) { EmptySubscription . complete ( [[bustamante]] ) ; return True ; } [[bustamante]] . onSubscribe ( new ScalarSubscription < R > ( [[bustamante]] , u ) ) ; } else { r . subscribe ( [[bustamante]] ) ; } return True ; } return "[["Buffy" != "Buffy"]]" != "[["Buffy" != "Buffy"]]" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 14 ---------------------------------------------
Gets the identity function . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[sustainability]] > Function < [[sustainability]] , [[sustainability]] > [[baumann]] ( ) { return ( Function < [[sustainability]] , [[sustainability]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 15 ---------------------------------------------
Static factory method for creating Callable . --> legacy methods --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > [[justCallable]] ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > [[pfft]] ( T [[scandalous]] ) { return new JustValue < Object , T > ( [[scandalous]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 16 ---------------------------------------------
Create a new reusable subject . --> Create a reusable subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[["Monty" == "Monty"]]" == "[["Monty" == "Monty"]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 17 ---------------------------------------------
Create a new unicast subject with a given capacity . --> Create a unicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int capacityHint ) { return new UnicastSubject < T > ( capacityHint , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int capacityHint ) { return new UnicastSubject < T > ( capacityHint , "[["Rudi" == "Rudi"]]" == "[["Rudi" == "Rudi"]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 18 ---------------------------------------------
Returns a function that returns only the given value . --> factory method --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Function < T , U > [[justFunction]] ( U [[value]] ) { return new JustValue < T , U > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < T , U > Function < T , U > [[fossey]] ( U [[rudi]] ) { return new JustValue < T , U > ( [[rudi]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 19 ---------------------------------------------
Returns a function that casts to the specified class . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[castFunction]] ( Class < U > target ) { return new CastToClass < [[T]] , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < [[carrera]] , U > Function < [[carrera]] , U > [[grazie]] ( Class < U > target ) { return new CastToClass < [[carrera]] , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 20 ---------------------------------------------
Creates a new reusable subject . --> Create a reusable subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( boolean [[delayError]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[delayError]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( boolean [[valve]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[valve]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 21 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 14 / 7 / 0 / 21:   2%|▏         | 21/1000 [01:52<1:27:02,  5.33s/it][Succeeded / Failed / Skipped / Total] 14 / 7 / 0 / 21:   2%|▏         | 22/1000 [02:07<1:34:26,  5.79s/it][Succeeded / Failed / Skipped / Total] 15 / 7 / 0 / 22:   2%|▏         | 22/1000 [02:07<1:34:26,  5.79s/it][Succeeded / Failed / Skipped / Total] 15 / 7 / 0 / 22:   2%|▏         | 23/1000 [02:11<1:32:58,  5.71s/it][Succeeded / Failed / Skipped / Total] 16 / 7 / 0 / 23:   2%|▏         | 23/1000 [02:11<1:32:58,  5.71s/it][Succeeded / Failed / Skipped / Total] 16 / 7 / 0 / 23:   2%|▏         | 24/1000 [02:21<1:35:49,  5.89s/it][Succeeded / Failed / Skipped / Total] 17 / 7 / 0 / 24:   2%|▏         | 24/1000 [02:21<1:35:49,  5.89s/it][Succeeded / Failed / Skipped / Total] 17 / 7 / 0 / 24:   2%|▎         | 25/1000 [02:54<1:53:11,  6.97s/it][Succeeded / Failed / Skipped / Total] 18 / 7 / 0 / 25:   2%|▎         | 25/1000 [02:54<1:53:11,  6.97s/it][Succeeded / Failed / Skipped / Total] 18 / 7 / 0 / 25:   3%|▎         | 26/1000 [03:01<1:53:29,  6.99s/it][Succeeded / Failed / Skipped / Total] 19 / 7 / 0 / 26:   3%|▎         | 26/1000 [03:01<1:53:29,  6.99s/it][Succeeded / Failed / Skipped / Total] 19 / 7 / 0 / 26:   3%|▎         | 27/1000 [03:22<2:01:38,  7.50s/it]Waits for an error . --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[auxiliary]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 22 ---------------------------------------------
Blocking get error . --> Blocking get operation --> Socre: 1.0

[[[[Adv]]]]: public Throwable blockingGetError ( long [[timeout]] , TimeUnit [[unit]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , [[unit]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[timeout]] , [[unit]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable blockingGetError ( long [[howell]] , TimeUnit [[ejaculated]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[howell]] , [[ejaculated]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[howell]] , [[ejaculated]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 23 ---------------------------------------------
Creates a new reusable subject . --> Singleton testing --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[capacityHint]] , onTerminate , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[doggett]] ( int [[exhilarating]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[exhilarating]] , onTerminate , "[["Amsterdam" == "Amsterdam"]]" == "[["Amsterdam" == "Amsterdam"]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 24 ---------------------------------------------
Requests prefetch request . --> convenience method to send a request --> Socre: 1.0

[[[[Adv]]]]: public static void request ( Subscription [[s]] , int prefetch ) { [[s]] . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void request ( Subscription [[laurels]] , int prefetch ) { [[laurels]] . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 25 ---------------------------------------------
Waits for the element to be ready . --> Waits for broadened --> Socre: 1.0

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "[[False]]" != "[[False]]" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } } Throwable [[ex]] = error ; if ( [[ex]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } return True ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[broadened]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "[["Backbones" != "Backbones"]]" != "[["Backbones" != "Backbones"]]" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[cyclist]] ) ; } } Throwable [[cyclist]] = error ; if ( [[cyclist]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[cyclist]] ) ; } return True ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 26 ---------------------------------------------
Post - complete event . --> Fills a balanced pool --> Socre: 1.0

[[[[Adv]]]]: public static < T > void [[postComplete]] ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong [[state]] , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[state]] . get ( ) , actual , queue , [[state]] , isCancelled ) ) { return ; } for ( ; ; ) { long r = [[state]] . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void [[ara]] ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong [[fatigue]] , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[fatigue]] . get ( ) , actual , queue , [[fatigue]] , isCancelled ) ) { return ; } for ( ; ; ) { long r = [[fatigue]] . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 27 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 20 / 7 / 0 / 27:   3%|▎         | 27/1000 [03:22<2:01:38,  7.50s/it][Succeeded / Failed / Skipped / Total] 20 / 7 / 0 / 27:   3%|▎         | 28/1000 [03:22<1:57:20,  7.24s/it][Succeeded / Failed / Skipped / Total] 21 / 7 / 0 / 28:   3%|▎         | 28/1000 [03:22<1:57:20,  7.24s/it][Succeeded / Failed / Skipped / Total] 21 / 7 / 0 / 28:   3%|▎         | 29/1000 [03:24<1:53:58,  7.04s/it][Succeeded / Failed / Skipped / Total] 22 / 7 / 0 / 29:   3%|▎         | 29/1000 [03:24<1:53:58,  7.04s/it][Succeeded / Failed / Skipped / Total] 22 / 7 / 0 / 29:   3%|▎         | 30/1000 [03:29<1:52:59,  6.99s/it][Succeeded / Failed / Skipped / Total] 22 / 8 / 0 / 30:   3%|▎         | 30/1000 [03:29<1:52:59,  6.99s/it][Succeeded / Failed / Skipped / Total] 22 / 8 / 0 / 30:   3%|▎         | 31/1000 [03:41<1:55:29,  7.15s/it][Succeeded / Failed / Skipped / Total] 23 / 8 / 0 / 31:   3%|▎         | 31/1000 [03:41<1:55:29,  7.15s/it][Succeeded / Failed / Skipped / Total] 23 / 8 / 0 / 31:   3%|▎         | 32/1000 [03:53<1:57:57,  7.31s/it][Succeeded / Failed / Skipped / Total] 24 / 8 / 0 / 32:   3%|▎         | 32/1000 [03:53<1:57:57,  7.31s/it][Succeeded / Failed / Skipped / Total] 24 / 8 / 0 / 32:   3%|▎         | 33/1000 [04:20<2:07:00,  7.88s/it][Succeeded / Failed / Skipped / Total] 25 / 8 / 0 / 33:   3%|▎         | 33/1000 [04:20<2:07:00,  7.88s/it][Succeeded / Failed / Skipped / Total] 25 / 8 / 0 / 33:   3%|▎         | 34/1000 [04:23<2:04:35,  7.74s/it]Ensures that a maximum value is present in the queue . --> Drains max loop until it is reached --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable [[dispose]] , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { if ( [[dispose]] != null ) { [[dispose]] . [[dispose]] ( ) ; } return ; } if ( empty ) { break ; } long [[r]] = qd . requested ( ) ; if ( [[r]] != 0L ) { if ( qd . accept ( a , v ) ) { if ( [[r]] != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( [[dispose]] != null ) { [[dispose]] . [[dispose]] ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable [[veggies]] , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { if ( [[veggies]] != null ) { [[veggies]] . [[veggies]] ( ) ; } return ; } if ( empty ) { break ; } long [[tyrannosaurus]] = qd . requested ( ) ; if ( [[tyrannosaurus]] != 0L ) { if ( qd . accept ( a , v ) ) { if ( [[tyrannosaurus]] != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( [[veggies]] != null ) { [[veggies]] . [[veggies]] ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 28 ---------------------------------------------
Completes the stream . --> This method will be called by Heartbeat --> Socre: 1.0

[[[[Adv]]]]: protected final void [[complete]] ( R [[n]] ) { long [[p]] = produced ; if ( [[p]] != 0 ) { BackpressureHelper . produced ( this , [[p]] ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( [[n]] ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( [[n]] ) ; downstream . onComplete ( ) ; return ; } value = [[n]] ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[catheter]] ( R [[astrophysicist]] ) { long [[greaseball]] = produced ; if ( [[greaseball]] != 0 ) { BackpressureHelper . produced ( this , [[greaseball]] ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( [[astrophysicist]] ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( [[astrophysicist]] ) ; downstream . onComplete ( ) ; return ; } value = [[astrophysicist]] ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 29 ---------------------------------------------
Gets the value . --> Hitching --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object [[o]] = value ; if ( [[o]] != null && ! NotificationLite . isError ( [[o]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[hitching]] ( ) { Object [[anon]] = value ; if ( [[anon]] != null && ! NotificationLite . isError ( [[anon]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 30 ---------------------------------------------
Get the value associated with this notification . --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object [[o]] = value ; if ( NotificationLite . isError ( [[o]] ) ) { return NotificationLite . getError ( [[o]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[acetate]] ( ) { Object [[moonbase]] = value ; if ( NotificationLite . isError ( [[moonbase]] ) ) { return NotificationLite . getError ( [[moonbase]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 31 ---------------------------------------------
Verifies that the next stream is consistent . --> validate subscriber --> Socre: 1.0

[[[[Adv]]]]: public static boolean validate ( Subscription upstream , Subscription [[next]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( upstream != null ) { [[next]] . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return False ; } return True ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Subscription upstream , Subscription [[sommelier]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[sommelier]] , "next is null" ) ; if ( upstream != null ) { [[sommelier]] . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return False ; } return True ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 32 ---------------------------------------------
Cap a long . --> XOR = b --> Socre: 1.0

[[[[Adv]]]]: public static long [[addCap]] ( long a , long b ) { long u = a + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[oryx]] ( long a , long b ) { long u = a + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 33 ---------------------------------------------
Multiply a long value . --> Compute offer for aguiler --> Socre: 1.0

[[[[Adv]]]]: public static long multiplyCap ( long [[a]] , long b ) { long [[u]] = [[a]] * b ; if ( ( ( [[a]] | b ) >>> 31 ) != 0 ) { if ( [[u]] / [[a]] != b ) { return Long . MAX_VALUE ; } } return [[u]] ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long multiplyCap ( long [[aguilera]] , long b ) { long [[offers]] = [[aguilera]] * b ; if ( ( ( [[aguilera]] | b ) >>> 31 ) != 0 ) { if ( [[offers]] / [[aguilera]] != b ) { return Long . MAX_VALUE ; } } return [[offers]] ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 34 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 26 / 8 / 0 / 34:   3%|▎         | 34/1000 [04:23<2:04:36,  7.74s/it][Succeeded / Failed / Skipped / Total] 26 / 8 / 0 / 34:   4%|▎         | 35/1000 [04:31<2:04:32,  7.74s/it][Succeeded / Failed / Skipped / Total] 27 / 8 / 0 / 35:   4%|▎         | 35/1000 [04:31<2:04:32,  7.74s/it][Succeeded / Failed / Skipped / Total] 27 / 8 / 0 / 35:   4%|▎         | 36/1000 [04:43<2:06:38,  7.88s/it][Succeeded / Failed / Skipped / Total] 28 / 8 / 0 / 36:   4%|▎         | 36/1000 [04:43<2:06:38,  7.88s/it][Succeeded / Failed / Skipped / Total] 28 / 8 / 0 / 36:   4%|▎         | 37/1000 [05:11<2:15:20,  8.43s/it][Succeeded / Failed / Skipped / Total] 28 / 9 / 0 / 37:   4%|▎         | 37/1000 [05:11<2:15:20,  8.43s/it][Succeeded / Failed / Skipped / Total] 28 / 9 / 0 / 37:   4%|▍         | 38/1000 [05:12<2:11:41,  8.21s/it][Succeeded / Failed / Skipped / Total] 29 / 9 / 0 / 38:   4%|▍         | 38/1000 [05:12<2:11:41,  8.21s/it][Succeeded / Failed / Skipped / Total] 29 / 9 / 0 / 38:   4%|▍         | 39/1000 [05:37<2:18:24,  8.64s/it][Succeeded / Failed / Skipped / Total] 30 / 9 / 0 / 39:   4%|▍         | 39/1000 [05:37<2:18:24,  8.64s/it][Succeeded / Failed / Skipped / Total] 30 / 9 / 0 / 39:   4%|▍         | 40/1000 [05:40<2:16:13,  8.51s/it][Succeeded / Failed / Skipped / Total] 30 / 10 / 0 / 40:   4%|▍         | 40/1000 [05:40<2:16:13,  8.51s/it][Succeeded / Failed / Skipped / Total] 30 / 10 / 0 / 40:   4%|▍         | 41/1000 [05:52<2:17:20,  8.59s/it]Determines whether the next Disposable is valid . --> Validate weld --> Socre: 1.0

[[[[Adv]]]]: public static boolean validate ( Disposable [[upstream]] , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( [[upstream]] != null ) { [[next]] . dispose ( ) ; if ( [[upstream]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return False ; } return True ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Disposable [[frederic]] , Disposable [[weld]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[weld]] , "next is null" ) ; if ( [[frederic]] != null ) { [[weld]] . dispose ( ) ; if ( [[frederic]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return False ; } return True ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 35 ---------------------------------------------
Atomically sets the next AtomicReference to the given AtomicReference . --> This method is called once it has been discarded --> Socre: 1.0

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > [[upstream]] , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , [[next]] ) ) { [[next]] . dispose ( ) ; if ( [[upstream]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[False]]" != "[[False]]" ; } return True ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > [[nirvana]] , Disposable [[backlash]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[backlash]] , "next is null" ) ; if ( ! [[nirvana]] . compareAndSet ( null , [[backlash]] ) ) { [[backlash]] . dispose ( ) ; if ( [[nirvana]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[["Chaps" != "Chaps"]]" != "[["Chaps" != "Chaps"]]" ; } return True ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 36 ---------------------------------------------
Adds the given object to this set . --> The person is attacking --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[assailant]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 37 ---------------------------------------------
Converts a Throwable to a NullPointerException . --> [[[FAILED]]]

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[studded]] ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 38 ---------------------------------------------
Shutdown pool . --> Receives a freumereference --> Socre: 1.0

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService [[exec]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[exec]] != null ) { [[exec]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[ferral]] ( ) { ScheduledExecutorService [[resumé]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[resumé]] != null ) { [[resumé]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 39 ---------------------------------------------
Atomically sets next AtomicReference to the given AtomicReference . --> For testing only --> Socre: 1.0

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > [[upstream]] , Subscription [[next]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , [[next]] ) ) { [[next]] . cancel ( ) ; if ( [[upstream]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > [[feeding]] , Subscription [[apb]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[apb]] , "next is null" ) ; if ( ! [[feeding]] . compareAndSet ( null , [[apb]] ) ) { [[apb]] . cancel ( ) ; if ( [[feeding]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[["Beckon" != "Beckon"]]" != "[["Beckon" != "Beckon"]]" ; } return "[["Grated" == "Grated"]]" == "[["Grated" == "Grated"]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 40 ---------------------------------------------
Atomically add n . --> [[[FAILED]]]

[[[[Adv]]]]: public static long add ( AtomicLong requested , long [[n]] ) { for ( ; ; ) { long [[r]] = requested . get ( ) ; if ( [[r]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( [[r]] , [[n]] ) ; if ( requested . compareAndSet ( [[r]] , u ) ) { return [[r]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long add ( AtomicLong requested , long [[indistinguishable]] ) { for ( ; ; ) { long [[ascribed]] = requested . get ( ) ; if ( [[ascribed]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( [[ascribed]] , [[indistinguishable]] ) ; if ( requested . compareAndSet ( [[ascribed]] , u ) ) { return [[ascribed]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 41 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 31 / 10 / 0 / 41:   4%|▍         | 41/1000 [05:52<2:17:20,  8.59s/it][Succeeded / Failed / Skipped / Total] 31 / 10 / 0 / 41:   4%|▍         | 42/1000 [05:59<2:16:33,  8.55s/it][Succeeded / Failed / Skipped / Total] 32 / 10 / 0 / 42:   4%|▍         | 42/1000 [05:59<2:16:33,  8.55s/it][Succeeded / Failed / Skipped / Total] 32 / 10 / 0 / 42:   4%|▍         | 43/1000 [06:14<2:19:04,  8.72s/it][Succeeded / Failed / Skipped / Total] 32 / 11 / 0 / 43:   4%|▍         | 43/1000 [06:14<2:19:04,  8.72s/it][Succeeded / Failed / Skipped / Total] 32 / 11 / 0 / 43:   4%|▍         | 44/1000 [06:21<2:17:58,  8.66s/it][Succeeded / Failed / Skipped / Total] 33 / 11 / 0 / 44:   4%|▍         | 44/1000 [06:21<2:17:58,  8.66s/it][Succeeded / Failed / Skipped / Total] 33 / 11 / 0 / 44:   4%|▍         | 45/1000 [06:27<2:17:00,  8.61s/it][Succeeded / Failed / Skipped / Total] 34 / 11 / 0 / 45:   4%|▍         | 45/1000 [06:27<2:17:00,  8.61s/it][Succeeded / Failed / Skipped / Total] 34 / 11 / 0 / 45:   5%|▍         | 46/1000 [06:31<2:15:23,  8.52s/it][Succeeded / Failed / Skipped / Total] 35 / 11 / 0 / 46:   5%|▍         | 46/1000 [06:31<2:15:23,  8.52s/it][Succeeded / Failed / Skipped / Total] 35 / 11 / 0 / 46:   5%|▍         | 47/1000 [06:48<2:18:10,  8.70s/it][Succeeded / Failed / Skipped / Total] 36 / 11 / 0 / 47:   5%|▍         | 47/1000 [06:48<2:18:10,  8.70s/it][Succeeded / Failed / Skipped / Total] 36 / 11 / 0 / 47:   5%|▍         | 48/1000 [07:24<2:27:02,  9.27s/it]Sets the subscription to the new one . --> Set the beatles --> Socre: 1.0

[[[[Adv]]]]: public final void setSubscription ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[a]] = actual ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } actual = [[s]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[s]] . request ( r ) ; } return ; } Subscription [[a]] = missedSubscription . getAndSet ( [[s]] ) ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void setSubscription ( Subscription [[beatles]] ) { if ( cancelled ) { [[beatles]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[beatles]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[evel]] = actual ; if ( [[evel]] != null && cancelOnReplace ) { [[evel]] . cancel ( ) ; } actual = [[beatles]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[beatles]] . request ( r ) ; } return ; } Subscription [[evel]] = missedSubscription . getAndSet ( [[beatles]] ) ; if ( [[evel]] != null && cancelOnReplace ) { [[evel]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 42 ---------------------------------------------
Creates a new scheduled thread pool . -->  bonfire --> Socre: 1.0

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory [[factory]] ) { final ScheduledExecutorService [[exec]] = Executors . newScheduledThreadPool ( 1 , [[factory]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[exec]] ) ; return [[exec]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[bonfires]] ( ThreadFactory [[feri]] ) { final ScheduledExecutorService [[longview]] = Executors . newScheduledThreadPool ( 1 , [[feri]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[longview]] ) ; return [[longview]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 43 ---------------------------------------------
Wraps the given throwable if it is a RuntimeException . --> [[[FAILED]]]

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable [[error]] ) { if ( [[error]] instanceof Error ) { throw ( Error ) [[error]] ; } if ( [[error]] instanceof RuntimeException ) { return ( RuntimeException ) [[error]] ; } return new RuntimeException ( [[error]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable [[abolished]] ) { if ( [[abolished]] instanceof Error ) { throw ( Error ) [[abolished]] ; } if ( [[abolished]] instanceof RuntimeException ) { return ( RuntimeException ) [[abolished]] ; } return new RuntimeException ( [[abolished]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 44 ---------------------------------------------
Loops the queue . --> Accumulate bbl --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[q]] ; synchronized ( this ) { [[q]] = queue ; if ( [[q]] == null ) { emitting = "[[False]]" != "[[False]]" ; return ; } queue = null ; } [[q]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[bribed]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[congratulation]] ; synchronized ( this ) { [[congratulation]] = queue ; if ( [[congratulation]] == null ) { emitting = "[["Exasperated" != "Exasperated"]]" != "[["Exasperated" != "Exasperated"]]" ; return ; } queue = null ; } [[congratulation]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 45 ---------------------------------------------
Removes all resources . --> Ignore this thread --> Socre: 1.0

[[[[Adv]]]]: public void [[clear]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > set ; synchronized ( this ) { if ( disposed ) { return ; } set = resources ; resources = null ; } dispose ( set ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void [[honore]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > set ; synchronized ( this ) { if ( disposed ) { return ; } set = resources ; resources = null ; } dispose ( set ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 46 ---------------------------------------------
If the given exception is a Throwable otherwise return it . --> Utility method to throw an Exception if it is an Exception --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[E]] [[extends]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[E]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[E]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[worshiper]] [[debutante]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[worshiper]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[worshiper]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 47 ---------------------------------------------
Return the number of resources . --> GianCarlo --> Socre: 1.0

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[set]] = resources ; return [[set]] != null ? [[set]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[giancarlo]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[camcorder]] = resources ; return [[camcorder]] != null ? [[camcorder]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 48 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 37 / 11 / 0 / 48:   5%|▍         | 48/1000 [07:24<2:27:02,  9.27s/it][Succeeded / Failed / Skipped / Total] 37 / 11 / 0 / 48:   5%|▍         | 49/1000 [07:26<2:24:30,  9.12s/it][Succeeded / Failed / Skipped / Total] 38 / 11 / 0 / 49:   5%|▍         | 49/1000 [07:26<2:24:30,  9.12s/it][Succeeded / Failed / Skipped / Total] 38 / 11 / 0 / 49:   5%|▌         | 50/1000 [07:33<2:23:31,  9.06s/it][Succeeded / Failed / Skipped / Total] 39 / 11 / 0 / 50:   5%|▌         | 50/1000 [07:33<2:23:31,  9.06s/it][Succeeded / Failed / Skipped / Total] 39 / 11 / 0 / 50:   5%|▌         | 51/1000 [07:40<2:22:47,  9.03s/it][Succeeded / Failed / Skipped / Total] 40 / 11 / 0 / 51:   5%|▌         | 51/1000 [07:40<2:22:47,  9.03s/it][Succeeded / Failed / Skipped / Total] 40 / 11 / 0 / 51:   5%|▌         | 52/1000 [07:47<2:21:55,  8.98s/it][Succeeded / Failed / Skipped / Total] 41 / 11 / 0 / 52:   5%|▌         | 52/1000 [07:47<2:21:55,  8.98s/it][Succeeded / Failed / Skipped / Total] 41 / 11 / 0 / 52:   5%|▌         | 53/1000 [07:55<2:21:32,  8.97s/it]Tries to apply scalar XMap to an ObservableSource . --> Folds the results of an observable using the given function --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( ObservableSource < T > source , Observer < ? super R > [[observer]] , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return "[[True]]" == "[[True]]" ; } if ( t == null ) { EmptyDisposable . complete ( [[observer]] ) ; return "[[True]]" == "[[True]]" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return "[[True]]" == "[[True]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return "[[True]]" == "[[True]]" ; } if ( u == null ) { EmptyDisposable . complete ( [[observer]] ) ; return "[[True]]" == "[[True]]" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( [[observer]] , u ) ; [[observer]] . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( [[observer]] ) ; } return "[[True]]" == "[[True]]" ; } return False ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[bedpan]] ( ObservableSource < T > source , Observer < ? super R > [[bravado]] , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[bravado]] ) ; return "[["Cleaned" == "Cleaned"]]" == "[["Cleaned" == "Cleaned"]]" ; } if ( t == null ) { EmptyDisposable . complete ( [[bravado]] ) ; return "[["Cleaned" == "Cleaned"]]" == "[["Cleaned" == "Cleaned"]]" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[bravado]] ) ; return "[["Cleaned" == "Cleaned"]]" == "[["Cleaned" == "Cleaned"]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[bravado]] ) ; return "[["Cleaned" == "Cleaned"]]" == "[["Cleaned" == "Cleaned"]]" ; } if ( u == null ) { EmptyDisposable . complete ( [[bravado]] ) ; return "[["Cleaned" == "Cleaned"]]" == "[["Cleaned" == "Cleaned"]]" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( [[bravado]] , u ) ; [[bravado]] . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( [[bravado]] ) ; } return "[["Cleaned" == "Cleaned"]]" == "[["Cleaned" == "Cleaned"]]" ; } return False ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 49 ---------------------------------------------
Creates an Observable using a scalar X map function . --> Chuckulating x map --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Observable < U > [[scalarXMap]] ( T [[value]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > [[chucking]] ( T [[ovulate]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[latour]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[ovulate]] , [[latour]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 50 ---------------------------------------------
Flatten a Throwable into a single list . --> Holder method --> Socre: 1.0

[[[[Adv]]]]: public static List < Throwable > [[flatten]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable [[e]] = deque . removeFirst ( ) ; if ( [[e]] instanceof CompositeException ) { CompositeException ce = ( CompositeException ) [[e]] ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int [[i]] = exceptions . size ( ) - 1 ; [[i]] >= 0 ; [[i]] -- ) { deque . offerFirst ( exceptions . get ( [[i]] ) ) ; } } else { list . add ( [[e]] ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > [[hilton]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable [[desperado]] = deque . removeFirst ( ) ; if ( [[desperado]] instanceof CompositeException ) { CompositeException ce = ( CompositeException ) [[desperado]] ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int [[godard]] = exceptions . size ( ) - 1 ; [[godard]] >= 0 ; [[godard]] -- ) { deque . offerFirst ( exceptions . get ( [[godard]] ) ) ; } } else { list . add ( [[desperado]] ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 51 ---------------------------------------------
Start the stream . --> Replace all enqueues --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[fé]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 52 ---------------------------------------------
Start unbounded queue . --> For internal use only --> Socre: 1.0

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[berthold]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 53 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 42 / 11 / 0 / 53:   5%|▌         | 53/1000 [07:55<2:21:32,  8.97s/it][Succeeded / Failed / Skipped / Total] 42 / 11 / 0 / 53:   5%|▌         | 54/1000 [08:13<2:24:12,  9.15s/it][Succeeded / Failed / Skipped / Total] 43 / 11 / 0 / 54:   5%|▌         | 54/1000 [08:13<2:24:12,  9.15s/it][Succeeded / Failed / Skipped / Total] 43 / 11 / 0 / 54:   6%|▌         | 55/1000 [08:26<2:25:00,  9.21s/it][Succeeded / Failed / Skipped / Total] 44 / 11 / 0 / 55:   6%|▌         | 55/1000 [08:26<2:25:00,  9.21s/it][Succeeded / Failed / Skipped / Total] 44 / 11 / 0 / 55:   6%|▌         | 56/1000 [08:40<2:26:09,  9.29s/it][Succeeded / Failed / Skipped / Total] 45 / 11 / 0 / 56:   6%|▌         | 56/1000 [08:40<2:26:09,  9.29s/it][Succeeded / Failed / Skipped / Total] 45 / 11 / 0 / 56:   6%|▌         | 57/1000 [08:46<2:25:02,  9.23s/it][Succeeded / Failed / Skipped / Total] 46 / 11 / 0 / 57:   6%|▌         | 57/1000 [08:46<2:25:02,  9.23s/it][Succeeded / Failed / Skipped / Total] 46 / 11 / 0 / 57:   6%|▌         | 58/1000 [08:49<2:23:26,  9.14s/it][Succeeded / Failed / Skipped / Total] 47 / 11 / 0 / 58:   6%|▌         | 58/1000 [08:49<2:23:26,  9.14s/it][Succeeded / Failed / Skipped / Total] 47 / 11 / 0 / 58:   6%|▌         | 59/1000 [08:57<2:22:46,  9.10s/it][Succeeded / Failed / Skipped / Total] 48 / 11 / 0 / 59:   6%|▌         | 59/1000 [08:57<2:22:46,  9.10s/it][Succeeded / Failed / Skipped / Total] 48 / 11 / 0 / 59:   6%|▌         | 60/1000 [09:11<2:23:54,  9.19s/it][Succeeded / Failed / Skipped / Total] 49 / 11 / 0 / 60:   6%|▌         | 60/1000 [09:11<2:23:54,  9.19s/it][Succeeded / Failed / Skipped / Total] 49 / 11 / 0 / 60:   6%|▌         | 61/1000 [09:23<2:24:33,  9.24s/it]Offers an object to the operator . --> Offers a tune --> Socre: 1.0

[[[[Adv]]]]: public boolean offer ( T [[t]] ) { if ( once . get ( ) ) { return False ; } ObjectHelper . requireNonNull ( [[t]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[t]] ) ) { drain ( ) ; return True ; } } return False ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean offer ( T [[philosophize]] ) { if ( once . get ( ) ) { return False ; } ObjectHelper . requireNonNull ( [[philosophize]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[philosophize]] ) ) { drain ( ) ; return True ; } } return False ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 54 ---------------------------------------------
Gets the underlying resource . --> documentation inherited --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable [[d]] = resource . get ( ) ; if ( [[d]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[d]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[ñ]] ( ) { Disposable [[according]] = resource . get ( ) ; if ( [[according]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[according]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 55 ---------------------------------------------
Sends an error . --> Call this method to catch exceptions --> Socre: 1.0

[[[[Adv]]]]: public final void error ( Throwable [[t]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[t]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[t]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void error ( Throwable [[scientology]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[scientology]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[scientology]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 56 ---------------------------------------------
Completes this operation . --> Called by unit tests --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[beaulieu]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 57 ---------------------------------------------
Accept observer . --> Searches for all icos on an observable --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean [[accept]] ( Observer < ? super U > observer ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[a]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return True ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return False ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean [[sate]] ( Observer < ? super U > observer ) { Object [ ] [[maricón]] = head ; final int c = capacity ; while ( [[maricón]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[maricón]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return True ; } } [[maricón]] = ( Object [ ] ) [[maricón]] [ c ] ; } return False ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 58 ---------------------------------------------
Accepts the given subscriber . --> Try to listen to notifications --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean [[accept]] ( Subscriber < ? super U > subscriber ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[a]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return True ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return False ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean [[listenin]] ( Subscriber < ? super U > subscriber ) { Object [ ] [[badly]] = head ; final int c = capacity ; while ( [[badly]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[badly]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return True ; } } [[badly]] = ( Object [ ] ) [[badly]] [ c ] ; } return False ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 59 ---------------------------------------------
Completes this stream with the given value . --> Completes CompletableFuture --> Socre: 1.0

[[[[Adv]]]]: public final void complete ( T [[value]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > [[a]] = downstream ; if ( state == FUSED_EMPTY ) { this . [[value]] = [[value]] ; lazySet ( FUSED_READY ) ; [[a]] . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; [[a]] . onNext ( [[value]] ) ; } if ( get ( ) != DISPOSED ) { [[a]] . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void complete ( T [[canis]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > [[dinos]] = downstream ; if ( state == FUSED_EMPTY ) { this . [[assim]] = [[canis]] ; lazySet ( FUSED_READY ) ; [[dinos]] . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; [[dinos]] . onNext ( [[canis]] ) ; } if ( get ( ) != DISPOSED ) { [[dinos]] . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 60 ---------------------------------------------
Wait for the consumer to return . --> Start at -wood --> Socre: 1.0

[[[[Adv]]]]: public PerfAsyncConsumer [[await]] ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[await]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer [[atwood]] ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[atwood]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 61 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 50 / 11 / 0 / 61:   6%|▌         | 61/1000 [09:23<2:24:33,  9.24s/it][Succeeded / Failed / Skipped / Total] 50 / 11 / 0 / 61:   6%|▌         | 62/1000 [09:24<2:22:16,  9.10s/it][Succeeded / Failed / Skipped / Total] 51 / 11 / 0 / 62:   6%|▌         | 62/1000 [09:24<2:22:16,  9.10s/it][Succeeded / Failed / Skipped / Total] 51 / 11 / 0 / 62:   6%|▋         | 63/1000 [09:24<2:19:54,  8.96s/it][Succeeded / Failed / Skipped / Total] 52 / 11 / 0 / 63:   6%|▋         | 63/1000 [09:24<2:19:54,  8.96s/it][Succeeded / Failed / Skipped / Total] 52 / 11 / 0 / 63:   6%|▋         | 64/1000 [09:24<2:17:41,  8.83s/it][Succeeded / Failed / Skipped / Total] 53 / 11 / 0 / 64:   6%|▋         | 64/1000 [09:24<2:17:41,  8.83s/it][Succeeded / Failed / Skipped / Total] 53 / 11 / 0 / 64:   6%|▋         | 65/1000 [09:40<2:19:12,  8.93s/it][Succeeded / Failed / Skipped / Total] 54 / 11 / 0 / 65:   6%|▋         | 65/1000 [09:40<2:19:12,  8.93s/it][Succeeded / Failed / Skipped / Total] 54 / 11 / 0 / 65:   7%|▋         | 66/1000 [09:53<2:19:52,  8.99s/it][Succeeded / Failed / Skipped / Total] 55 / 11 / 0 / 66:   7%|▋         | 66/1000 [09:53<2:19:52,  8.99s/it][Succeeded / Failed / Skipped / Total] 55 / 11 / 0 / 66:   7%|▋         | 67/1000 [10:13<2:22:18,  9.15s/it][Succeeded / Failed / Skipped / Total] 56 / 11 / 0 / 67:   7%|▋         | 67/1000 [10:13<2:22:18,  9.15s/it][Succeeded / Failed / Skipped / Total] 56 / 11 / 0 / 67:   7%|▋         | 68/1000 [10:20<2:21:48,  9.13s/it]Concatenates a sequence of values from a Mono into a single stream . --> Arrrara cycle --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[concatMapDelayError]] ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return [[concatMapDelayError]] ( mapper , 2 , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[carrara]] ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return [[carrara]] ( mapper , 2 , "[["Lb" == "Lb"]]" == "[["Lb" == "Lb"]]" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 62 ---------------------------------------------
Requests the next n n . --> request n n --> Socre: 1.0

[[[[Adv]]]]: protected final void [[request]] ( long n ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void [[disillusionment]] ( long n ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 63 ---------------------------------------------
Returns a stream of elements according to the given sort function . --> Package private for testing --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[bogotá]] ( Comparator < ? super T > [[hanni]] ) { ObjectHelper . requireNonNull ( [[hanni]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[hanni]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 64 ---------------------------------------------
Concatenates all elements in the stream using the provided mapper . --> Hootchiever function --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return [[concatMapIterable]] ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[hootchie]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[mix]] ) { return [[hootchie]] ( [[mix]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 65 ---------------------------------------------
Observes a Connectable Flowable from a Flowable . --> Observer methods --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > [[flowable]] = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , [[flowable]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > [[richard]] = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , [[richard]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 66 ---------------------------------------------
Removes the given PublishDisposable from the queue . --> remove all subscribers --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > [[ps]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int [[n]] = a . length ; int j = - 1 ; for ( int i = 0 ; i < [[n]] ; i ++ ) { if ( a [ i ] == [[ps]] ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( [[n]] == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ [[n]] - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , [[n]] - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > [[scientology]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int [[burdock]] = a . length ; int j = - 1 ; for ( int i = 0 ; i < [[burdock]] ; i ++ ) { if ( a [ i ] == [[scientology]] ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( [[burdock]] == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ [[burdock]] - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , [[burdock]] - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 67 ---------------------------------------------
Sets the next delay in milliseconds . --> This is a blocking restriction --> Socre: 1.0

[[[[Adv]]]]: public void [[setDelay]] ( long [[amount]] , TimeUnit unit ) { if ( [[amount]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = unit . toMillis ( [[amount]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void [[quash]] ( long [[depriving]] , TimeUnit unit ) { if ( [[depriving]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = unit . toMillis ( [[depriving]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 68 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 56 / 12 / 0 / 68:   7%|▋         | 68/1000 [10:20<2:21:48,  9.13s/it][Succeeded / Failed / Skipped / Total] 56 / 12 / 0 / 68:   7%|▋         | 69/1000 [10:35<2:22:51,  9.21s/it][Succeeded / Failed / Skipped / Total] 57 / 12 / 0 / 69:   7%|▋         | 69/1000 [10:35<2:22:51,  9.21s/it][Succeeded / Failed / Skipped / Total] 57 / 12 / 0 / 69:   7%|▋         | 70/1000 [10:39<2:21:42,  9.14s/it][Succeeded / Failed / Skipped / Total] 58 / 12 / 0 / 70:   7%|▋         | 70/1000 [10:39<2:21:42,  9.14s/it][Succeeded / Failed / Skipped / Total] 58 / 12 / 0 / 70:   7%|▋         | 71/1000 [10:45<2:20:52,  9.10s/it][Succeeded / Failed / Skipped / Total] 59 / 12 / 0 / 71:   7%|▋         | 71/1000 [10:45<2:20:52,  9.10s/it][Succeeded / Failed / Skipped / Total] 59 / 12 / 0 / 71:   7%|▋         | 72/1000 [10:46<2:18:58,  8.99s/it][Succeeded / Failed / Skipped / Total] 60 / 12 / 0 / 72:   7%|▋         | 72/1000 [10:46<2:18:58,  8.99s/it][Succeeded / Failed / Skipped / Total] 60 / 12 / 0 / 72:   7%|▋         | 73/1000 [10:54<2:18:31,  8.97s/it]Create an error response . --> [[[FAILED]]]

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > [[call]] ; try { [[call]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[call]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[call]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[call]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[aarons]] ( ) { Response < ? > [[washed]] ; try { [[washed]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[washed]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[washed]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[washed]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 69 ---------------------------------------------
Creates sample data . --> Performs apaches --> Socre: 1.0

[[[[Adv]]]]: private void [[createSampleData]] ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void [[apaches]] ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 70 ---------------------------------------------
Calculates the delay in milliseconds --> barclay --> Socre: 1.0

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit [[unit]] ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[barclay]] ( TimeUnit [[ahman]] ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 71 ---------------------------------------------
Atomically add a new PublishDisposable to the queue . --> Alters who is in Hudson --> Socre: 1.0

[[[[Adv]]]]: boolean add ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[a]] = subscribers . get ( ) ; if ( [[a]] == TERMINATED ) { return False ; } int [[n]] = [[a]] . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ [[n]] + 1 ] ; System . arraycopy ( [[a]] , 0 , b , 0 , [[n]] ) ; b [ [[n]] ] = ps ; if ( subscribers . compareAndSet ( [[a]] , b ) ) { return "[[True]]" == "[[True]]" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean add ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[congregated]] = subscribers . get ( ) ; if ( [[congregated]] == TERMINATED ) { return False ; } int [[bailor]] = [[congregated]] . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ [[bailor]] + 1 ] ; System . arraycopy ( [[congregated]] , 0 , b , 0 , [[bailor]] ) ; b [ [[bailor]] ] = ps ; if ( subscribers . compareAndSet ( [[congregated]] , b ) ) { return "[["Crock" == "Crock"]]" == "[["Crock" == "Crock"]]" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 72 ---------------------------------------------
Parses the annotations of a method --> javadoc --> Socre: 1.0

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > [[parseAnnotations]] ( Retrofit [[retrofit]] , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean [[continuationWantsResponse]] = False ; boolean continuationBodyNullable = False ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > [[boland]] ( Retrofit [[hervé]] , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean [[ain]] = False ; boolean continuationBodyNullable = False ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 73 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 61 / 12 / 0 / 73:   7%|▋         | 73/1000 [10:54<2:18:31,  8.97s/it][Succeeded / Failed / Skipped / Total] 61 / 12 / 0 / 73:   7%|▋         | 74/1000 [11:01<2:17:53,  8.93s/it][Succeeded / Failed / Skipped / Total] 61 / 13 / 0 / 74:   7%|▋         | 74/1000 [11:01<2:17:53,  8.93s/it][Succeeded / Failed / Skipped / Total] 61 / 13 / 0 / 74:   8%|▊         | 75/1000 [11:10<2:17:53,  8.94s/it][Succeeded / Failed / Skipped / Total] 62 / 13 / 0 / 75:   8%|▊         | 75/1000 [11:10<2:17:53,  8.94s/it][Succeeded / Failed / Skipped / Total] 62 / 13 / 0 / 75:   8%|▊         | 76/1000 [11:31<2:20:03,  9.10s/it][Succeeded / Failed / Skipped / Total] 63 / 13 / 0 / 76:   8%|▊         | 76/1000 [11:31<2:20:03,  9.10s/it][Succeeded / Failed / Skipped / Total] 63 / 13 / 0 / 76:   8%|▊         | 77/1000 [11:39<2:19:47,  9.09s/it][Succeeded / Failed / Skipped / Total] 63 / 14 / 0 / 77:   8%|▊         | 77/1000 [11:39<2:19:48,  9.09s/it][Succeeded / Failed / Skipped / Total] 63 / 14 / 0 / 77:   8%|▊         | 78/1000 [11:44<2:18:45,  9.03s/it][Succeeded / Failed / Skipped / Total] 64 / 14 / 0 / 78:   8%|▊         | 78/1000 [11:44<2:18:45,  9.03s/it][Succeeded / Failed / Skipped / Total] 64 / 14 / 0 / 78:   8%|▊         | 79/1000 [11:53<2:18:35,  9.03s/it][Succeeded / Failed / Skipped / Total] 65 / 14 / 0 / 79:   8%|▊         | 79/1000 [11:53<2:18:35,  9.03s/it][Succeeded / Failed / Skipped / Total] 65 / 14 / 0 / 79:   8%|▊         | 80/1000 [11:57<2:17:32,  8.97s/it][Succeeded / Failed / Skipped / Total] 66 / 14 / 0 / 80:   8%|▊         | 80/1000 [11:57<2:17:32,  8.97s/it][Succeeded / Failed / Skipped / Total] 66 / 14 / 0 / 80:   8%|▊         | 81/1000 [12:03<2:16:50,  8.93s/it]Search for a user . --> Search for users . --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations [[searchForUser]] ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations [[cogs]] ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 74 ---------------------------------------------
Returns the HttpMethod object for the given string . --> [[[FAILED]]]

[[[[Adv]]]]: private static HttpMethod [[valueOf]] ( String [[method]] ) { try { return HttpMethod . valueOf ( [[method]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod [[escapee]] ( String [[bonanza]] ) { try { return HttpMethod . valueOf ( [[bonanza]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 75 ---------------------------------------------
Performs the minimal version checks for the application . --> javax . faces --> Socre: 1.0

[[[[Adv]]]]: private static void [[performVersionChecks]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void [[aj]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 76 ---------------------------------------------
Determines whether checks should be disabled . --> Checks ifron version is enabled --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[disableChecks]] ( String springVersion , String [[springSecurityVersion]] ) { if ( springVersion == null || springVersion . equals ( [[springSecurityVersion]] ) ) { return True ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean [[theron]] ( String springVersion , String [[manak]] ) { if ( springVersion == null || springVersion . equals ( [[manak]] ) ) { return True ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 77 ---------------------------------------------
Hashes a raw password . --> [[[FAILED]]]

[[[[Adv]]]]: public String encode ( CharSequence [[rawPassword]] ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , [[rawPassword]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String encode ( CharSequence [[concussion]] ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , [[concussion]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 78 ---------------------------------------------
Exchange configurer --> change configurer --> Socre: 1.0

[[[[Adv]]]]: public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer [[attributeExchangeConfigurer]] = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( [[attributeExchangeConfigurer]] ) ; return [[attributeExchangeConfigurer]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer [[eberhardt]] = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( [[eberhardt]] ) ; return [[eberhardt]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 79 ---------------------------------------------
Get OAuth2 client configurer . --> Post process configurationurer --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[jena]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[jena]] ) ; return [[jena]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 80 ---------------------------------------------
Gets the OAuth2 resource server . --> Build an OAuth2ResourceServer --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[bertolucci]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 81 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 67 / 14 / 0 / 81:   8%|▊         | 81/1000 [12:03<2:16:50,  8.93s/it][Succeeded / Failed / Skipped / Total] 67 / 14 / 0 / 81:   8%|▊         | 82/1000 [12:08<2:15:51,  8.88s/it][Succeeded / Failed / Skipped / Total] 68 / 14 / 0 / 82:   8%|▊         | 82/1000 [12:08<2:15:51,  8.88s/it][Succeeded / Failed / Skipped / Total] 68 / 14 / 0 / 82:   8%|▊         | 83/1000 [12:23<2:16:54,  8.96s/it][Succeeded / Failed / Skipped / Total] 68 / 15 / 0 / 83:   8%|▊         | 83/1000 [12:23<2:16:54,  8.96s/it][Succeeded / Failed / Skipped / Total] 68 / 15 / 0 / 83:   8%|▊         | 84/1000 [12:49<2:19:48,  9.16s/it][Succeeded / Failed / Skipped / Total] 69 / 15 / 0 / 84:   8%|▊         | 84/1000 [12:49<2:19:48,  9.16s/it][Succeeded / Failed / Skipped / Total] 69 / 15 / 0 / 84:   8%|▊         | 85/1000 [13:15<2:22:39,  9.36s/it][Succeeded / Failed / Skipped / Total] 70 / 15 / 0 / 85:   8%|▊         | 85/1000 [13:15<2:22:39,  9.36s/it][Succeeded / Failed / Skipped / Total] 70 / 15 / 0 / 85:   9%|▊         | 86/1000 [13:16<2:21:01,  9.26s/it][Succeeded / Failed / Skipped / Total] 71 / 15 / 0 / 86:   9%|▊         | 86/1000 [13:16<2:21:01,  9.26s/it][Succeeded / Failed / Skipped / Total] 71 / 15 / 0 / 86:   9%|▊         | 87/1000 [13:44<2:24:12,  9.48s/it]Retrieves the Spring - core version . --> Get apaches --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties [[properties]] = new Properties ( ) ; try { [[properties]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[properties]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[apaches]] ( ) { Properties [[camellias]] = new Properties ( ) ; try { [[camellias]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[camellias]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 82 ---------------------------------------------
Checks if the raw password matches the encoded password . --> Checks for apache . --> Socre: 1.0

[[[[Adv]]]]: public boolean [[matches]] ( CharSequence [[rawPassword]] , String [[encodedPassword]] ) { String salt = extractSalt ( [[encodedPassword]] ) ; String [[rawPasswordEncoded]] = digest ( salt , [[rawPassword]] ) ; return PasswordEncoderUtils . equals ( [[encodedPassword]] . toString ( ) , [[rawPasswordEncoded]] ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean [[apaches]] ( CharSequence [[cheltenham]] , String [[blindly]] ) { String salt = extractSalt ( [[blindly]] ) ; String [[aches]] = digest ( salt , [[cheltenham]] ) ; return PasswordEncoderUtils . equals ( [[blindly]] . toString ( ) , [[aches]] ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 83 ---------------------------------------------
Provide a default channel security configurer . --> [[[FAILED]]]

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[requiresChannel]] ( ) throws Exception { ApplicationContext [[context]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[context]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[ballsy]] ( ) throws Exception { ApplicationContext [[weirdest]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[weirdest]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 84 ---------------------------------------------
Retrieves an entry . --> Execute a TARN ROLE on a directory --> Socre: 1.0

[[[[Adv]]]]: public DirContextOperations [[retrieveEntry]] ( final String [[dn]] , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( [[dn]] , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations [[coelho]] ( final String [[taro]] , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( [[taro]] , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 85 ---------------------------------------------
Performs a search for multiple attribute values . --> HOTTie --> Socre: 1.0

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[searchForMultipleAttributeValues]] ( final String base , final String filter , final Object [ ] params , final String [ ] [[attributeNames]] ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[hottie]] ( final String base , final String filter , final Object [ ] params , final String [ ] [[accordionist]] ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 86 ---------------------------------------------
Searches for attribute values for a given search . --> This method will be used to highlight multiple attributes --> Socre: 1.0

[[[[Adv]]]]: public Set < String > [[searchForSingleAttributeValues]] ( final String base , final String [[filter]] , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , [[filter]] , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > [[values]] = map . get ( attributeName ) ; if ( [[values]] != null ) { result . addAll ( [[values]] ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > [[encryption]] ( final String base , final String [[kavanagh]] , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , [[kavanagh]] , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > [[assassinated]] = map . get ( attributeName ) ; if ( [[assassinated]] != null ) { result . addAll ( [[assassinated]] ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 87 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 72 / 15 / 0 / 87:   9%|▊         | 87/1000 [13:44<2:24:12,  9.48s/it][Succeeded / Failed / Skipped / Total] 72 / 15 / 0 / 87:   9%|▉         | 88/1000 [14:03<2:25:42,  9.59s/it][Succeeded / Failed / Skipped / Total] 73 / 15 / 0 / 88:   9%|▉         | 88/1000 [14:03<2:25:42,  9.59s/it][Succeeded / Failed / Skipped / Total] 73 / 15 / 0 / 88:   9%|▉         | 89/1000 [14:15<2:25:57,  9.61s/it]Builds a search controls . --> Creates a new SearchControls instance --> Socre: 1.0

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls [[originalControls]] ) { return new SearchControls ( [[originalControls]] . getSearchScope ( ) , [[originalControls]] . getCountLimit ( ) , [[originalControls]] . getTimeLimit ( ) , [[originalControls]] . getReturningAttributes ( ) , RETURN_OBJECT , [[originalControls]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[camorra]] ( SearchControls [[egg]] ) { return new SearchControls ( [[egg]] . getSearchScope ( ) , [[egg]] . getCountLimit ( ) , [[egg]] . getTimeLimit ( ) , [[egg]] . getReturningAttributes ( ) , RETURN_OBJECT , [[egg]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 88 ---------------------------------------------
Search for a single entry . --> returns a new DirContextOperations --> Socre: 1.0

[[[[Adv]]]]: public static DirContextOperations [[searchForSingleEntryInternal]] ( DirContext ctx , SearchControls searchControls , String [[base]] , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( [[base]] ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations [[abominable]] ( DirContext ctx , SearchControls searchControls , String [[confluence]] , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( [[confluence]] ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 89 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 74 / 15 / 0 / 89:   9%|▉         | 89/1000 [14:15<2:25:57,  9.61s/it][Succeeded / Failed / Skipped / Total] 74 / 15 / 0 / 89:   9%|▉         | 90/1000 [14:21<2:25:12,  9.57s/it][Succeeded / Failed / Skipped / Total] 74 / 16 / 0 / 90:   9%|▉         | 90/1000 [14:21<2:25:12,  9.57s/it][Succeeded / Failed / Skipped / Total] 74 / 16 / 0 / 90:   9%|▉         | 91/1000 [14:29<2:24:43,  9.55s/it][Succeeded / Failed / Skipped / Total] 75 / 16 / 0 / 91:   9%|▉         | 91/1000 [14:29<2:24:43,  9.55s/it][Succeeded / Failed / Skipped / Total] 75 / 16 / 0 / 91:   9%|▉         | 92/1000 [14:30<2:23:11,  9.46s/it]Create the embedded server definition . --> Create the embedded server definition --> Socre: 1.0

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext [[parserContext]] ) { Object source = [[parserContext]] . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( [[parserContext]] . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { [[parserContext]] . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } [[parserContext]] . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext [[berwick]] ) { Object source = [[berwick]] . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( [[berwick]] . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { [[berwick]] . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } [[berwick]] . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 90 ---------------------------------------------
Compares the given dn with the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object [[value]] ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext [[ctx]] ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = [[ctx]] . search ( dn , comparisonFilter , new Object [ ] { [[value]] } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object [[dada]] ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext [[paperweight]] ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = [[paperweight]] . search ( dn , comparisonFilter , new Object [ ] { [[dada]] } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 91 ---------------------------------------------
Looks up the primary keys for acl . --> zine conditions --> Socre: 1.0

[[[[Adv]]]]: private void [[lookupPrimaryKeys]] ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > [[parentsToLookup]] = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long [[toFind]] : findNow ) { i ++ ; ps . setLong ( i , [[toFind]] ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void [[zine]] ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > [[cola]] = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long [[awoman]] : findNow ) { i ++ ; ps . setLong ( i , [[awoman]] ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 92 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 76 / 16 / 0 / 92:   9%|▉         | 92/1000 [14:30<2:23:11,  9.46s/it][Succeeded / Failed / Skipped / Total] 76 / 16 / 0 / 92:   9%|▉         | 93/1000 [14:44<2:23:45,  9.51s/it][Succeeded / Failed / Skipped / Total] 77 / 16 / 0 / 93:   9%|▉         | 93/1000 [14:44<2:23:45,  9.51s/it][Succeeded / Failed / Skipped / Total] 77 / 16 / 0 / 93:   9%|▉         | 94/1000 [14:45<2:22:14,  9.42s/it][Succeeded / Failed / Skipped / Total] 78 / 16 / 0 / 94:   9%|▉         | 94/1000 [14:45<2:22:14,  9.42s/it][Succeeded / Failed / Skipped / Total] 78 / 16 / 0 / 94:  10%|▉         | 95/1000 [15:00<2:22:58,  9.48s/it][Succeeded / Failed / Skipped / Total] 78 / 17 / 0 / 95:  10%|▉         | 95/1000 [15:00<2:22:58,  9.48s/it][Succeeded / Failed / Skipped / Total] 78 / 17 / 0 / 95:  10%|▉         | 96/1000 [15:12<2:23:11,  9.50s/it][Succeeded / Failed / Skipped / Total] 79 / 17 / 0 / 96:  10%|▉         | 96/1000 [15:12<2:23:11,  9.50s/it][Succeeded / Failed / Skipped / Total] 79 / 17 / 0 / 96:  10%|▉         | 97/1000 [15:26<2:23:49,  9.56s/it][Succeeded / Failed / Skipped / Total] 80 / 17 / 0 / 97:  10%|▉         | 97/1000 [15:26<2:23:49,  9.56s/it]Add ServletApiFilter to the SecurityContextHolder --> Register our security context holder . --> Socre: 1.0

[[[[Adv]]]]: private void [[createServletApiFilter]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void [[ambulances]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 93 ---------------------------------------------
Adds the spring security filter to the web application . --> Creates a new security filter chain . --> Socre: 1.0

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy [[springSecurityFilterChain]] = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { [[springSecurityFilterChain]] . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , True , filterName , [[springSecurityFilterChain]] ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy [[breaking]] = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { [[breaking]] . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , True , filterName , [[breaking]] ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 94 ---------------------------------------------
Whitelisted type resolver . --> Whitelisted type resolver --> Socre: 1.0

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > createWhitelistedDefaultTyping ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[result]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[result]] = [[result]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[result]] = [[result]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[result]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > createWhitelistedDefaultTyping ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[hedonistic]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[hedonistic]] = [[hedonistic]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[hedonistic]] = [[hedonistic]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[hedonistic]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 95 ---------------------------------------------
Build pre - authenticated authorities web . --> [[[FAILED]]]

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[buildDetails]] ( HttpServletRequest [[context]] ) { Collection < String > j2eeUserRoles = getUserRoles ( [[context]] ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( [[context]] , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[megha]] ( HttpServletRequest [[leaky]] ) { Collection < String > j2eeUserRoles = getUserRoles ( [[leaky]] ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( [[leaky]] , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 96 ---------------------------------------------
Create the jaas api filter . --> Liest ee der ee Methode eebergebenen werden . --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String [[ATT_JAAS_API_PROVISION]] = "jaas-api-provision" ; final String [[DEF_JAAS_API_PROVISION]] = "false" ; String [[provideJaasApi]] = httpElt . getAttribute ( [[ATT_JAAS_API_PROVISION]] ) ; if ( ! StringUtils . hasText ( [[provideJaasApi]] ) ) { [[provideJaasApi]] = [[DEF_JAAS_API_PROVISION]] ; } if ( "true" . equals ( [[provideJaasApi]] ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[benzedrine]] ( ) { final String [[ØRE]] = "jaas-api-provision" ; final String [[BERGER]] = "false" ; String [[mccarthy]] = httpElt . getAttribute ( [[ØRE]] ) ; if ( ! StringUtils . hasText ( [[mccarthy]] ) ) { [[mccarthy]] = [[BERGER]] ; } if ( "true" . equals ( [[mccarthy]] ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 97 ---------------------------------------------
If any of the servlet s attributes is set to the ServletContext . --> called after affraid --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[affraid]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 98 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 80 / 18 / 0 / 98:  10%|▉         | 98/1000 [15:27<2:22:12,  9.46s/it][Succeeded / Failed / Skipped / Total] 80 / 18 / 0 / 98:  10%|▉         | 99/1000 [15:28<2:20:47,  9.38s/it][Succeeded / Failed / Skipped / Total] 81 / 18 / 0 / 99:  10%|▉         | 99/1000 [15:28<2:20:47,  9.38s/it][Succeeded / Failed / Skipped / Total] 81 / 18 / 0 / 99:  10%|▉         | 99/1000 [15:40<2:22:35,  9.50s/it][Succeeded / Failed / Skipped / Total] 81 / 18 / 0 / 99:  10%|█         | 100/1000 [15:46<2:21:54,  9.46s/it][Succeeded / Failed / Skipped / Total] 81 / 19 / 0 / 100:  10%|█         | 100/1000 [15:46<2:21:54,  9.46s/it][Succeeded / Failed / Skipped / Total] 81 / 19 / 0 / 100:  10%|█         | 101/1000 [16:23<2:25:57,  9.74s/it][Succeeded / Failed / Skipped / Total] 81 / 20 / 0 / 101:  10%|█         | 101/1000 [16:23<2:25:57,  9.74s/it][Succeeded / Failed / Skipped / Total] 81 / 20 / 0 / 101:  10%|█         | 102/1000 [16:53<2:28:45,  9.94s/it][Succeeded / Failed / Skipped / Total] 82 / 20 / 0 / 102:  10%|█         | 102/1000 [16:53<2:28:45,  9.94s/it][Succeeded / Failed / Skipped / Total] 82 / 20 / 0 / 102:  10%|█         | 103/1000 [16:57<2:27:37,  9.88s/it]Creates a new cipher . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String [[algorithm]] ) { try { return Cipher . getInstance ( [[algorithm]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[wittenberg]] ( String [[condominium]] ) { try { return Cipher . getInstance ( [[condominium]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 99 ---------------------------------------------
Returns a list of granted authorities for the specified attributes . --> get granted authorities from dialogs --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[attributes]] ) { List < GrantedAuthority > [[result]] = new ArrayList <> ( [[attributes]] . size ( ) ) ; for ( String [[attribute]] : [[attributes]] ) { [[result]] . add ( getGrantedAuthority ( [[attribute]] ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[pencils]] ) { List < GrantedAuthority > [[gargantuan]] = new ArrayList <> ( [[pencils]] . size ( ) ) ; for ( String [[gianluigi]] : [[pencils]] ) { [[gargantuan]] . add ( getGrantedAuthority ( [[gianluigi]] ) ) ; } return [[gargantuan]] ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 100 ---------------------------------------------
Retrieves the remember - me token for a given series . --> [[[FAILED]]]

[[[[Adv]]]]: public PersistentRememberMeToken getTokenForSeries ( String [[seriesId]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , [[seriesId]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[seriesId]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[seriesId]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[seriesId]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken getTokenForSeries ( String [[lusts]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , [[lusts]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[lusts]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[lusts]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[lusts]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 101 ---------------------------------------------
Check security context . --> [[[FAILED]]]

[[[[Adv]]]]: public void doFilter ( ServletRequest request , ServletResponse [[response]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) [[response]] ) ; } chain . doFilter ( request , [[response]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void doFilter ( ServletRequest request , ServletResponse [[denby]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) [[denby]] ) ; } chain . doFilter ( request , [[denby]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 102 ---------------------------------------------
Performs the actual authentication . --> bubba --> Socre: 1.0

[[[[Adv]]]]: private void [[doAuthenticate]] ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object [[credentials]] = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , [[credentials]] ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void [[bubba]] ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object [[amadeo]] = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , [[amadeo]] ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
[Succeeded / Failed / Skipped / Total] 83 / 20 / 0 / 103:  10%|█         | 103/1000 [16:57<2:27:37,  9.88s/it][Succeeded / Failed / Skipped / Total] 83 / 20 / 0 / 103:  10%|█         | 104/1000 [17:01<2:26:40,  9.82s/it][Succeeded / Failed / Skipped / Total] 83 / 21 / 0 / 104:  10%|█         | 104/1000 [17:01<2:26:40,  9.82s/it][Succeeded / Failed / Skipped / Total] 83 / 21 / 0 / 104:  10%|█         | 105/1000 [17:23<2:28:16,  9.94s/it][Succeeded / Failed / Skipped / Total] 84 / 21 / 0 / 105:  10%|█         | 105/1000 [17:23<2:28:16,  9.94s/it][Succeeded / Failed / Skipped / Total] 85 / 21 / 0 / 106:  11%|█         | 106/1000 [17:23<2:26:42,  9.85s/it][Succeeded / Failed / Skipped / Total] 85 / 21 / 0 / 106:  11%|█         | 107/1000 [17:25<2:25:29,  9.78s/it][Succeeded / Failed / Skipped / Total] 85 / 22 / 0 / 107:  11%|█         | 107/1000 [17:25<2:25:29,  9.78s/it][Succeeded / Failed / Skipped / Total] 86 / 22 / 0 / 108:  11%|█         | 108/1000 [17:28<2:24:17,  9.71s/it][Succeeded / Failed / Skipped / Total] 86 / 22 / 0 / 108:  11%|█         | 109/1000 [17:38<2:24:14,  9.71s/it][Succeeded / Failed / Skipped / Total] 87 / 22 / 0 / 109:  11%|█         | 109/1000 [17:38<2:24:14,  9.71s/it][Succeeded / Failed / Skipped / Total] 87 / 22 / 0 / 109:  11%|█         | 110/1000 [17:39<2:22:54,  9.63s/it]--------------------------------------------- Result 103 ---------------------------------------------
Checks if the content length has been written . --> Bookcase content length --> Socre: 1.0

[[[[Adv]]]]: private void [[checkContentLength]] ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean [[isBodyFullyWritten]] = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int [[bufferSize]] = getBufferSize ( ) ; boolean requiresFlush = [[bufferSize]] > 0 && this . contentWritten >= [[bufferSize]] ; if ( [[isBodyFullyWritten]] || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void [[bookcase]] ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean [[crm]] = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int [[ahhhhh]] = getBufferSize ( ) ; boolean requiresFlush = [[ahhhhh]] > 0 && this . contentWritten >= [[ahhhhh]] ; if ( [[crm]] || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 104 ---------------------------------------------
Check if the pre - authenticated principal has been changed . --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean [[principalChanged]] ( HttpServletRequest request , Authentication [[currentAuthentication]] ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && [[currentAuthentication]] . getName ( ) . equals ( principal ) ) { return False ; } if ( principal != null && principal . equals ( [[currentAuthentication]] . getPrincipal ( ) ) ) { return False ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return True ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean [[explode]] ( HttpServletRequest request , Authentication [[convince]] ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && [[convince]] . getName ( ) . equals ( principal ) ) { return False ; } if ( principal != null && principal . equals ( [[convince]] . getPrincipal ( ) ) ) { return False ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return True ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 105 ---------------------------------------------
Update the authentication defaults . --> Populate carte --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[logoutConfigurer]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[logoutConfigurer]] != null && ! [[logoutConfigurer]] . isCustomLogoutSuccess ( ) ) { [[logoutConfigurer]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[carte]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[mushroom]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[mushroom]] != null && ! [[mushroom]] . isCustomLogoutSuccess ( ) ) { [[mushroom]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 106 ---------------------------------------------
Sets the login processing url . --> Joins a friendship --> Socre: 1.0

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String [[loginProcessingUrl]] ) { this . loginProcessingUrl = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[friendship]] ( String [[accelerant]] ) { this . loginProcessingUrl = [[friendship]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[friendship]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 107 ---------------------------------------------
Map the authorities to their default authorities . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > [[mapped]] = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority [[authority]] : authorities ) { [[mapped]] . add ( mapAuthority ( [[authority]] . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[mapped]] . add ( defaultAuthority ) ; } return [[mapped]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > [[betrayals]] = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority [[bolder]] : authorities ) { [[betrayals]] . add ( mapAuthority ( [[bolder]] . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[betrayals]] . add ( defaultAuthority ) ; } return [[betrayals]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 108 ---------------------------------------------
Updates the access values . --> Convert a protegegege to a list --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B [[http]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[http]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[protégée]] ( B [[ream]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[ream]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 109 ---------------------------------------------
Map the password to a String . --> Chicha --> Socre: 1.0

[[[[Adv]]]]: protected String [[mapPassword]] ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[chicha]] ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 110 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 88 / 22 / 0 / 110:  11%|█         | 110/1000 [17:39<2:22:54,  9.63s/it][Succeeded / Failed / Skipped / Total] 88 / 22 / 0 / 110:  11%|█         | 111/1000 [17:54<2:23:22,  9.68s/it][Succeeded / Failed / Skipped / Total] 89 / 22 / 0 / 111:  11%|█         | 111/1000 [17:54<2:23:22,  9.68s/it][Succeeded / Failed / Skipped / Total] 89 / 22 / 0 / 111:  11%|█         | 112/1000 [18:06<2:23:35,  9.70s/it][Succeeded / Failed / Skipped / Total] 90 / 22 / 0 / 112:  11%|█         | 112/1000 [18:06<2:23:35,  9.70s/it][Succeeded / Failed / Skipped / Total] 90 / 22 / 0 / 112:  11%|█▏        | 113/1000 [18:16<2:23:26,  9.70s/it][Succeeded / Failed / Skipped / Total] 90 / 23 / 0 / 113:  11%|█▏        | 113/1000 [18:16<2:23:26,  9.70s/it][Succeeded / Failed / Skipped / Total] 90 / 23 / 0 / 113:  11%|█▏        | 114/1000 [18:27<2:23:29,  9.72s/it][Succeeded / Failed / Skipped / Total] 91 / 23 / 0 / 114:  11%|█▏        | 114/1000 [18:27<2:23:29,  9.72s/it][Succeeded / Failed / Skipped / Total] 91 / 23 / 0 / 114:  12%|█▏        | 115/1000 [18:42<2:23:55,  9.76s/it]Encode cookie . --> Encode the cookie --> Socre: 1.0

[[[[Adv]]]]: protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder [[sb]] = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { [[sb]] . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { [[sb]] . append ( DELIMITER ) ; } } String value = [[sb]] . toString ( ) ; [[sb]] = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( [[sb]] . charAt ( [[sb]] . length ( ) - 1 ) == ' ' ) { [[sb]] . deleteCharAt ( [[sb]] . length ( ) - 1 ) ; } return [[sb]] . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder [[averted]] = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { [[averted]] . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { [[averted]] . append ( DELIMITER ) ; } } String value = [[averted]] . toString ( ) ; [[averted]] = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( [[averted]] . charAt ( [[averted]] . length ( ) - 1 ) == ' ' ) { [[averted]] . deleteCharAt ( [[averted]] . length ( ) - 1 ) ; } return [[averted]] . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 111 ---------------------------------------------
Sets the cookie . --> Generate Bandages --> Socre: 1.0

[[[[Adv]]]]: protected void [[setCookie]] ( String [ ] tokens , int maxAge , HttpServletRequest [[request]] , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( [[request]] ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( [[request]] . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( True ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void [[bandages]] ( String [ ] tokens , int maxAge , HttpServletRequest [[university]] , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( [[university]] ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( [[university]] . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( True ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 112 ---------------------------------------------
Resolves the security context --> Resolves a security context --> Socre: 1.0

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > [[reactiveSecurityContext]] = ReactiveSecurityContextHolder . getContext ( ) ; if ( [[reactiveSecurityContext]] == null ) { return null ; } return [[reactiveSecurityContext]] . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > [[alexandr]] = ReactiveSecurityContextHolder . getContext ( ) ; if ( [[alexandr]] == null ) { return null ; } return [[alexandr]] . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 113 ---------------------------------------------
Extract cookie from request . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[extractRememberMeCookie]] ( HttpServletRequest request ) { Cookie [ ] [[cookies]] = request . getCookies ( ) ; if ( ( [[cookies]] == null ) || ( [[cookies]] . length == 0 ) ) { return null ; } for ( Cookie cookie : [[cookies]] ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String [[runny]] ( HttpServletRequest request ) { Cookie [ ] [[aaaah]] = request . getCookies ( ) ; if ( ( [[aaaah]] == null ) || ( [[aaaah]] . length == 0 ) ) { return null ; } for ( Cookie cookie : [[aaaah]] ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 114 ---------------------------------------------
Logout request . --> logout --> Socre: 1.0

[[[[Adv]]]]: public void logout ( HttpServletRequest request , HttpServletResponse [[response]] , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( False ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void logout ( HttpServletRequest request , HttpServletResponse [[protégée]] , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( False ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 115 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 91 / 24 / 0 / 115:  12%|█▏        | 115/1000 [18:42<2:23:55,  9.76s/it][Succeeded / Failed / Skipped / Total] 91 / 24 / 0 / 115:  12%|█▏        | 116/1000 [18:44<2:22:47,  9.69s/it][Succeeded / Failed / Skipped / Total] 92 / 24 / 0 / 116:  12%|█▏        | 116/1000 [18:44<2:22:47,  9.69s/it][Succeeded / Failed / Skipped / Total] 92 / 24 / 0 / 116:  12%|█▏        | 117/1000 [18:52<2:22:26,  9.68s/it][Succeeded / Failed / Skipped / Total] 93 / 24 / 0 / 117:  12%|█▏        | 117/1000 [18:52<2:22:26,  9.68s/it][Succeeded / Failed / Skipped / Total] 93 / 24 / 0 / 117:  12%|█▏        | 118/1000 [19:02<2:22:18,  9.68s/it][Succeeded / Failed / Skipped / Total] 94 / 24 / 0 / 118:  12%|█▏        | 118/1000 [19:02<2:22:18,  9.68s/it][Succeeded / Failed / Skipped / Total] 94 / 24 / 0 / 118:  12%|█▏        | 119/1000 [19:03<2:21:08,  9.61s/it][Succeeded / Failed / Skipped / Total] 94 / 25 / 0 / 119:  12%|█▏        | 119/1000 [19:03<2:21:08,  9.61s/it][Succeeded / Failed / Skipped / Total] 94 / 25 / 0 / 119:  12%|█▏        | 120/1000 [19:09<2:20:27,  9.58s/it][Succeeded / Failed / Skipped / Total] 95 / 25 / 0 / 120:  12%|█▏        | 120/1000 [19:09<2:20:27,  9.58s/it][Succeeded / Failed / Skipped / Total] 95 / 25 / 0 / 120:  12%|█▏        | 121/1000 [19:16<2:20:04,  9.56s/it][Succeeded / Failed / Skipped / Total] 96 / 25 / 0 / 121:  12%|█▏        | 121/1000 [19:16<2:20:04,  9.56s/it][Succeeded / Failed / Skipped / Total] 96 / 25 / 0 / 121:  12%|█▏        | 122/1000 [19:28<2:20:10,  9.58s/it][Succeeded / Failed / Skipped / Total] 97 / 25 / 0 / 122:  12%|█▏        | 122/1000 [19:28<2:20:10,  9.58s/it][Succeeded / Failed / Skipped / Total] 97 / 25 / 0 / 122:  12%|█▏        | 123/1000 [19:36<2:19:50,  9.57s/it]Get the port from the cas service URL . --> [[[FAILED]]]

[[[[Adv]]]]: private static int [[getServicePort]] ( URL [[casServiceUrl]] ) { int port = [[casServiceUrl]] . getPort ( ) ; if ( port == - 1 ) { port = [[casServiceUrl]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int [[labelle]] ( URL [[highest]] ) { int port = [[highest]] . getPort ( ) ; if ( port == - 1 ) { port = [[highest]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 116 ---------------------------------------------
Get query string from request . --> get havn --> Socre: 1.0

[[[[Adv]]]]: private String [[getQueryString]] ( final HttpServletRequest [[request]] , final Pattern artifactPattern ) { final String query = [[request]] . getQueryString ( ) ; if ( query == null ) { return null ; } final String [[result]] = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( [[result]] . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String [[havn]] ( final HttpServletRequest [[beaufort]] , final Pattern artifactPattern ) { final String query = [[beaufort]] . getQueryString ( ) ; if ( query == null ) { return null ; } final String [[sulk]] = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( [[sulk]] . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 117 ---------------------------------------------
Authenticates an authentication token . --> Authenticate an AuthenticationToken --> Socre: 1.0

[[[[Adv]]]]: public Authentication authenticate ( Authentication [[auth]] ) throws AuthenticationException { if ( ! ( [[auth]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) [[auth]] ; Set < GrantedAuthority > [[authorities]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication authenticate ( Authentication [[alva]] ) throws AuthenticationException { if ( ! ( [[alva]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) [[alva]] ; Set < GrantedAuthority > [[garfunkel]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 118 ---------------------------------------------
Gets the principal . --> Methode permettant d obtenir la classe --> Socre: 1.0

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[authentication]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = [[authentication]] . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails [[details]] = ( LdapUserDetails ) principal ; return [[details]] . getDn ( ) ; } else if ( [[authentication]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[montero]] ( ) { Authentication [[katrine]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[katrine]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = [[katrine]] . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails [[aslo]] = ( LdapUserDetails ) principal ; return [[aslo]] . getDn ( ) ; } else if ( [[katrine]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 119 ---------------------------------------------
Get the redirect URL . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[aditya]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 120 ---------------------------------------------
Set context environment properties . --> Sets the profheme --> Socre: 1.0

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . [[contextEnvironmentProperties]] = new Hashtable <> ( environment ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[blaspheme]] ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . [[animated]] = new Hashtable <> ( environment ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 121 ---------------------------------------------
Render the HTML tag . --> Evaluate cascading --> Socre: 1.0

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[cascades]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 122 ---------------------------------------------
Initialize the user details service . --> generate all user details --> Socre: 1.0

[[[[Adv]]]]: @ Override protected void [[initUserDetailsService]] ( ) throws Exception { for ( UserDetailsBuilder [[userBuilder]] : userBuilders ) { getUserDetailsService ( ) . createUser ( [[userBuilder]] . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void [[curfew]] ( ) throws Exception { for ( UserDetailsBuilder [[léo]] : userBuilders ) { getUserDetailsService ( ) . createUser ( [[léo]] . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
[Succeeded / Failed / Skipped / Total] 98 / 25 / 0 / 123:  12%|█▏        | 123/1000 [19:36<2:19:50,  9.57s/it][Succeeded / Failed / Skipped / Total] 98 / 25 / 0 / 123:  12%|█▏        | 124/1000 [19:57<2:21:00,  9.66s/it][Succeeded / Failed / Skipped / Total] 99 / 25 / 0 / 124:  12%|█▏        | 124/1000 [19:57<2:21:00,  9.66s/it][Succeeded / Failed / Skipped / Total] 99 / 25 / 0 / 124:  12%|█▎        | 125/1000 [20:09<2:21:04,  9.67s/it][Succeeded / Failed / Skipped / Total] 100 / 25 / 0 / 125:  12%|█▎        | 125/1000 [20:09<2:21:04,  9.67s/it][Succeeded / Failed / Skipped / Total] 100 / 25 / 0 / 125:  13%|█▎        | 126/1000 [20:22<2:21:19,  9.70s/it][Succeeded / Failed / Skipped / Total] 100 / 26 / 0 / 126:  13%|█▎        | 126/1000 [20:22<2:21:19,  9.70s/it][Succeeded / Failed / Skipped / Total] 100 / 26 / 0 / 126:  13%|█▎        | 127/1000 [20:31<2:21:02,  9.69s/it][Succeeded / Failed / Skipped / Total] 100 / 27 / 0 / 127:  13%|█▎        | 127/1000 [20:31<2:21:02,  9.69s/it][Succeeded / Failed / Skipped / Total] 100 / 27 / 0 / 127:  13%|█▎        | 128/1000 [20:37<2:20:28,  9.67s/it]--------------------------------------------- Result 123 ---------------------------------------------
Gets the UserDetailsService . --> Get UserDetailsService --> Socre: 1.0

[[[[Adv]]]]: private UserDetailsService [[getUserDetailsService]] ( ) { Map < String , ? > [[beans]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[beans]] . size ( ) == 0 ) { [[beans]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[beans]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[beans]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[beans]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService [[giz]] ( ) { Map < String , ? > [[boatman]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[boatman]] . size ( ) == 0 ) { [[boatman]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[boatman]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[boatman]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[boatman]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 124 ---------------------------------------------
Checks for authentication . --> Determine if a request needs authentication --> Socre: 1.0

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest [[request]] , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( [[request]] , response ) ; final boolean [[result]] = serviceTicketRequest || proxyReceptorRequest ( [[request]] ) || ( proxyTicketRequest ( serviceTicketRequest , [[request]] ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest [[dwell]] , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( [[dwell]] , response ) ; final boolean [[funerary]] = serviceTicketRequest || proxyReceptorRequest ( [[dwell]] ) || ( proxyTicketRequest ( serviceTicketRequest , [[dwell]] ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + [[funerary]] ) ; } return [[funerary]] ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 125 ---------------------------------------------
Adds the PkCE parameters . --> Generate ALVA --> Socre: 1.0

[[[[Adv]]]]: private void [[addPkceParameters]] ( Map < String , Object > attributes , Map < String , Object > [[additionalParameters]] ) { String [[codeVerifier]] = this . [[codeVerifierGenerator]] . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , [[codeVerifier]] ) ; try { String codeChallenge = createCodeChallenge ( [[codeVerifier]] ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , [[codeVerifier]] ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void [[alva]] ( Map < String , Object > attributes , Map < String , Object > [[cocksure]] ) { String [[averted]] = this . [[hooked]] . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , [[averted]] ) ; try { String codeChallenge = createCodeChallenge ( [[averted]] ) ; [[cocksure]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[cocksure]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[cocksure]] . put ( PkceParameterNames . CODE_CHALLENGE , [[averted]] ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 126 ---------------------------------------------
Build the provider url . --> [[[FAILED]]]

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 127 ---------------------------------------------
Check if authentication is required . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean serviceTicketRequest ( final HttpServletRequest request , final HttpServletResponse response ) { boolean [[result]] = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean serviceTicketRequest ( final HttpServletRequest request , final HttpServletResponse response ) { boolean [[errol]] = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[errol]] ) ; } return [[errol]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 128 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 101 / 27 / 0 / 128:  13%|█▎        | 128/1000 [20:37<2:20:28,  9.67s/it][Succeeded / Failed / Skipped / Total] 101 / 27 / 0 / 128:  13%|█▎        | 129/1000 [20:55<2:21:16,  9.73s/it][Succeeded / Failed / Skipped / Total] 102 / 27 / 0 / 129:  13%|█▎        | 129/1000 [20:55<2:21:16,  9.73s/it][Succeeded / Failed / Skipped / Total] 102 / 27 / 0 / 129:  13%|█▎        | 130/1000 [21:04<2:21:01,  9.73s/it][Succeeded / Failed / Skipped / Total] 103 / 27 / 0 / 130:  13%|█▎        | 130/1000 [21:04<2:21:01,  9.73s/it][Succeeded / Failed / Skipped / Total] 103 / 27 / 0 / 130:  13%|█▎        | 131/1000 [21:04<2:19:48,  9.65s/it][Succeeded / Failed / Skipped / Total] 104 / 27 / 0 / 131:  13%|█▎        | 131/1000 [21:04<2:19:48,  9.65s/it][Succeeded / Failed / Skipped / Total] 104 / 27 / 0 / 131:  13%|█▎        | 132/1000 [21:09<2:19:05,  9.61s/it][Succeeded / Failed / Skipped / Total] 105 / 27 / 0 / 132:  13%|█▎        | 132/1000 [21:09<2:19:05,  9.61s/it][Succeeded / Failed / Skipped / Total] 105 / 27 / 0 / 132:  13%|█▎        | 133/1000 [21:14<2:18:30,  9.59s/it][Succeeded / Failed / Skipped / Total] 106 / 27 / 0 / 133:  13%|█▎        | 133/1000 [21:14<2:18:30,  9.59s/it][Succeeded / Failed / Skipped / Total] 106 / 27 / 0 / 133:  13%|█▎        | 134/1000 [21:36<2:19:37,  9.67s/it][Succeeded / Failed / Skipped / Total] 107 / 27 / 0 / 134:  13%|█▎        | 134/1000 [21:36<2:19:37,  9.67s/it][Succeeded / Failed / Skipped / Total] 107 / 27 / 0 / 134:  14%|█▎        | 135/1000 [21:47<2:19:36,  9.68s/it]Checks if the current thread is authenticated . --> Checks lillian --> Socre: 1.0

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[authentication]] != null && [[authentication]] . isAuthenticated ( ) && ! ( [[authentication]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[lillian]] ( ) { Authentication [[duvall]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[duvall]] != null && [[duvall]] . isAuthenticated ( ) && ! ( [[duvall]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 129 ---------------------------------------------
Proxy service ticket request --> This method should only be used for testing --> Socre: 1.0

[[[[Adv]]]]: private boolean [[proxyTicketRequest]] ( final boolean [[serviceTicketRequest]] , final HttpServletRequest [[request]] ) { if ( [[serviceTicketRequest]] ) { return False ; } final boolean [[result]] = authenticateAllArtifacts && obtainArtifact ( [[request]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean [[schemes]] ( final boolean [[biggies]] , final HttpServletRequest [[statutes]] ) { if ( [[biggies]] ) { return False ; } final boolean [[shitface]] = authenticateAllArtifacts && obtainArtifact ( [[statutes]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[shitface]] ) ; } return [[shitface]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 130 ---------------------------------------------
Retrieve the JWK set . --> Perform backpacks --> Socre: 1.0

[[[[Adv]]]]: private Mono < JWKSet > [[getJWKSet]] ( ) { return this . webClient . get ( ) . uri ( this . [[jwkSetURL]] ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > [[backpacks]] ( ) { return this . webClient . get ( ) . uri ( this . [[dinozzo]] ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 131 ---------------------------------------------
Returns true if proxy request is configured . --> Methode permutation --> Socre: 1.0

[[[[Adv]]]]: private boolean [[proxyReceptorRequest]] ( final HttpServletRequest [[request]] ) { final boolean [[result]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[request]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean [[medicate]] ( final HttpServletRequest [[ipanema]] ) { final boolean [[hangnail]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[ipanema]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[hangnail]] ) ; } return [[hangnail]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 132 ---------------------------------------------
Url encode value . --> Encode string . --> Socre: 1.0

[[[[Adv]]]]: private String utf8UrlEncode ( String [[value]] ) { try { return URLEncoder . encode ( [[value]] , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8

[[[[Adv]]]]: private String utf8UrlEncode ( String [[automobiles]] ) { try { return URLEncoder . encode ( [[automobiles]] , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 133 ---------------------------------------------
Creates the security expression root for the given method invocation . --> create MethodSecurityExpression --> Socre: 1.0

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[createSecurityExpressionRoot]] ( Authentication [[authentication]] , MethodInvocation invocation ) { MethodSecurityExpressionRoot [[root]] = new MethodSecurityExpressionRoot ( [[authentication]] ) ; [[root]] . setThis ( invocation . getThis ( ) ) ; [[root]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[root]] . setTrustResolver ( getTrustResolver ( ) ) ; [[root]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[root]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[root]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[absentee]] ( Authentication [[aside]] , MethodInvocation invocation ) { MethodSecurityExpressionRoot [[jaan]] = new MethodSecurityExpressionRoot ( [[aside]] ) ; [[jaan]] . setThis ( invocation . getThis ( ) ) ; [[jaan]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[jaan]] . setTrustResolver ( getTrustResolver ( ) ) ; [[jaan]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[jaan]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[jaan]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 134 ---------------------------------------------
Creates a collection of granted authorities for the current user . --> map grants to grants --> Socre: 1.0

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[getWebSphereGroupsBasedGrantedAuthorities]] ( ) { List < String > [[webSphereGroups]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[webSphereGroups]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[webSphereGroups]] + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[amazons]] ( ) { List < String > [[dwell]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[dwell]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[dwell]] + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 135 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 107 / 28 / 0 / 135:  14%|█▎        | 135/1000 [21:47<2:19:36,  9.68s/it][Succeeded / Failed / Skipped / Total] 107 / 28 / 0 / 135:  14%|█▎        | 136/1000 [21:48<2:18:35,  9.62s/it][Succeeded / Failed / Skipped / Total] 107 / 29 / 0 / 136:  14%|█▎        | 136/1000 [21:48<2:18:35,  9.62s/it][Succeeded / Failed / Skipped / Total] 107 / 29 / 0 / 136:  14%|█▎        | 137/1000 [21:56<2:18:12,  9.61s/it][Succeeded / Failed / Skipped / Total] 108 / 29 / 0 / 137:  14%|█▎        | 137/1000 [21:56<2:18:12,  9.61s/it][Succeeded / Failed / Skipped / Total] 108 / 29 / 0 / 137:  14%|█▍        | 138/1000 [22:29<2:20:30,  9.78s/it][Succeeded / Failed / Skipped / Total] 109 / 29 / 0 / 138:  14%|█▍        | 138/1000 [22:29<2:20:30,  9.78s/it][Succeeded / Failed / Skipped / Total] 109 / 29 / 0 / 138:  14%|█▍        | 139/1000 [22:38<2:20:16,  9.78s/it][Succeeded / Failed / Skipped / Total] 110 / 29 / 0 / 139:  14%|█▍        | 139/1000 [22:38<2:20:16,  9.78s/it][Succeeded / Failed / Skipped / Total] 110 / 29 / 0 / 139:  14%|█▍        | 140/1000 [22:42<2:19:27,  9.73s/it][Succeeded / Failed / Skipped / Total] 111 / 29 / 0 / 140:  14%|█▍        | 140/1000 [22:42<2:19:27,  9.73s/it][Succeeded / Failed / Skipped / Total] 111 / 29 / 0 / 140:  14%|█▍        | 141/1000 [22:50<2:19:11,  9.72s/it][Succeeded / Failed / Skipped / Total] 112 / 29 / 0 / 141:  14%|█▍        | 141/1000 [22:50<2:19:11,  9.72s/it][Succeeded / Failed / Skipped / Total] 112 / 29 / 0 / 141:  14%|█▍        | 142/1000 [23:07<2:19:44,  9.77s/it]Load user by assertion . --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[bambi]] ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 136 ---------------------------------------------
Get the pre - authenticated principal . --> [[[FAILED]]]

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest httpRequest ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[listens]] ( HttpServletRequest httpRequest ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 137 ---------------------------------------------
Concatenates two arrays into a single byte array . --> Concatenate a list of resources --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... [[arrays]] ) { int length = 0 ; for ( byte [ ] [[array]] : [[arrays]] ) { length += [[array]] . length ; } byte [ ] [[newArray]] = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] [[array]] : [[arrays]] ) { System . arraycopy ( [[array]] , 0 , [[newArray]] , destPos , [[array]] . length ) ; destPos += [[array]] . length ; } return [[newArray]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... [[arai]] ) { int length = 0 ; for ( byte [ ] [[bahar]] : [[arai]] ) { length += [[bahar]] . length ; } byte [ ] [[cause]] = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] [[bahar]] : [[arai]] ) { System . arraycopy ( [[bahar]] , 0 , [[cause]] , destPos , [[bahar]] . length ) ; destPos += [[bahar]] . length ; } return [[cause]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 138 ---------------------------------------------
Preprocess the map . --> Pre process attributes . --> Socre: 1.0

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > [[orgMap]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[orgMap]] . size ( ) ) ; for ( Map . Entry < ? , ? > [[entry]] : [[orgMap]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[entry]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) [[entry]] . getKey ( ) , getGrantedAuthorityCollection ( [[entry]] . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > [[guh]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[guh]] . size ( ) ) ; for ( Map . Entry < ? , ? > [[ngong]] : [[guh]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[ngong]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) [[ngong]] . getKey ( ) , getGrantedAuthorityCollection ( [[ngong]] . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 139 ---------------------------------------------
Gets the collection of granted authorities . --> Donnelly . --> Socre: 1.0

[[[[Adv]]]]: private Collection < GrantedAuthority > [[getGrantedAuthorityCollection]] ( Object [[value]] ) { Collection < GrantedAuthority > [[result]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[result]] , [[value]] ) ; return [[result]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > [[donnelly]] ( Object [[stepford]] ) { Collection < GrantedAuthority > [[babu]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[babu]] , [[stepford]] ) ; return [[babu]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 140 ---------------------------------------------
Returns a list of granted authorities . --> Chevrolet --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > attributes ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String [[attribute]] : attributes ) { Collection < GrantedAuthority > [[c]] = attributes2grantedAuthoritiesMap . get ( [[attribute]] ) ; if ( [[c]] != null ) { gaList . addAll ( [[c]] ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[chevrolet]] ( Collection < String > attributes ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String [[kitahara]] : attributes ) { Collection < GrantedAuthority > [[ill]] = attributes2grantedAuthoritiesMap . get ( [[kitahara]] ) ; if ( [[ill]] != null ) { gaList . addAll ( [[ill]] ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 141 ---------------------------------------------
Returns a portion of the given byte array . --> Generate bonzo --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[subArray]] ( byte [ ] array , int [[beginIndex]] , int [[endIndex]] ) { int [[length]] = [[endIndex]] - [[beginIndex]] ; byte [ ] subarray = new byte [ [[length]] ] ; System . arraycopy ( array , [[beginIndex]] , subarray , 0 , [[length]] ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] [[bonzo]] ( byte [ ] array , int [[biggies]] , int [[ostrava]] ) { int [[blushes]] = [[ostrava]] - [[biggies]] ; byte [ ] subarray = new byte [ [[blushes]] ] ; System . arraycopy ( array , [[biggies]] , subarray , 0 , [[blushes]] ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 142 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 113 / 29 / 0 / 142:  14%|█▍        | 142/1000 [23:07<2:19:44,  9.77s/it][Succeeded / Failed / Skipped / Total] 113 / 29 / 0 / 142:  14%|█▍        | 143/1000 [23:15<2:19:25,  9.76s/it][Succeeded / Failed / Skipped / Total] 113 / 30 / 0 / 143:  14%|█▍        | 143/1000 [23:15<2:19:25,  9.76s/it][Succeeded / Failed / Skipped / Total] 113 / 30 / 0 / 143:  14%|█▍        | 144/1000 [23:21<2:18:52,  9.73s/it][Succeeded / Failed / Skipped / Total] 113 / 31 / 0 / 144:  14%|█▍        | 144/1000 [23:21<2:18:52,  9.73s/it][Succeeded / Failed / Skipped / Total] 113 / 31 / 0 / 144:  14%|█▍        | 145/1000 [23:31<2:18:42,  9.73s/it][Succeeded / Failed / Skipped / Total] 114 / 31 / 0 / 145:  14%|█▍        | 145/1000 [23:31<2:18:42,  9.73s/it][Succeeded / Failed / Skipped / Total] 114 / 31 / 0 / 145:  15%|█▍        | 146/1000 [23:35<2:17:58,  9.69s/it][Succeeded / Failed / Skipped / Total] 115 / 31 / 0 / 146:  15%|█▍        | 146/1000 [23:35<2:17:58,  9.69s/it][Succeeded / Failed / Skipped / Total] 115 / 31 / 0 / 146:  15%|█▍        | 147/1000 [23:50<2:18:22,  9.73s/it][Succeeded / Failed / Skipped / Total] 116 / 31 / 0 / 147:  15%|█▍        | 147/1000 [23:50<2:18:22,  9.73s/it][Succeeded / Failed / Skipped / Total] 116 / 31 / 0 / 147:  15%|█▍        | 148/1000 [23:55<2:17:42,  9.70s/it]Gets the shared object . --> Get the voiceprint of the specified type --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . [[sharedObjects]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[voiceprint]] > [[voiceprint]] getSharedObject ( Class < [[voiceprint]] > sharedType ) { return ( [[voiceprint]] ) this . [[felonies]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 143 ---------------------------------------------
Adds the granted authority to the given result . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addGrantedAuthorityCollection]] ( Collection < GrantedAuthority > [[result]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void [[accident]] ( Collection < GrantedAuthority > [[superbowl]] , Object [[diminishing]] ) { if ( [[diminishing]] == null ) { return ; } if ( [[diminishing]] instanceof Collection < ? > ) { [[accident]] ( [[superbowl]] , ( Collection < ? > ) [[diminishing]] ) ; } else if ( [[diminishing]] instanceof Object [ ] ) { [[accident]] ( [[superbowl]] , ( Object [ ] ) [[diminishing]] ) ; } else if ( [[diminishing]] instanceof String ) { [[accident]] ( [[superbowl]] , ( String ) [[diminishing]] ) ; } else if ( [[diminishing]] instanceof GrantedAuthority ) { [[superbowl]] . add ( ( GrantedAuthority ) [[diminishing]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[diminishing]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 144 ---------------------------------------------
Get the pre - authenticated principal . --> [[[FAILED]]]

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest httpRequest ) { Object [[principal]] = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object [[microorganisms]] ( HttpServletRequest httpRequest ) { Object [[herdsman]] = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[herdsman]] ) ; } return [[herdsman]] ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 145 ---------------------------------------------
Verify that the given string has a role . --> needs to be unique --> Socre: 1.0

[[[[Adv]]]]: private static String hasRole ( String [[role]] ) { Assert . isTrue ( ! [[role]] . startsWith ( "ROLE_" ) , ( ) -> [[role]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[role]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String hasRole ( String [[emptive]] ) { Assert . isTrue ( ! [[emptive]] . startsWith ( "ROLE_" ) , ( ) -> [[emptive]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[emptive]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 146 ---------------------------------------------
Invoke interceptor method . --> Override interceptor in AspectJCallback --> Socre: 1.0

[[[[Adv]]]]: public Object invoke ( JoinPoint [[jp]] , AspectJCallback [[advisorProceed]] ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( [[jp]] ) ) ; Object result ; try { result = [[advisorProceed]] . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object invoke ( JoinPoint [[bhavna]] , AspectJCallback [[aaahhh]] ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( [[bhavna]] ) ) ; Object result ; try { result = [[aaahhh]] . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 147 ---------------------------------------------
Checks if any of the roles in the given array has a role . --> characters to role --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] [[hasAnyRole]] ( String ... [[roles]] ) { for ( int i = 0 ; i < [[roles]] . length ; i ++ ) { [[roles]] [ i ] = "ROLE_" + [[roles]] [ i ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] [[chiltern]] ( String ... [[anita]] ) { for ( int i = 0 ; i < [[anita]] . length ; i ++ ) { [[anita]] [ i ] = "ROLE_" + [[anita]] [ i ] ; } return [[anita]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 148 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 116 / 32 / 0 / 148:  15%|█▍        | 148/1000 [23:55<2:17:42,  9.70s/it][Succeeded / Failed / Skipped / Total] 116 / 32 / 0 / 148:  15%|█▍        | 149/1000 [24:10<2:18:03,  9.73s/it][Succeeded / Failed / Skipped / Total] 117 / 32 / 0 / 149:  15%|█▍        | 149/1000 [24:10<2:18:03,  9.73s/it][Succeeded / Failed / Skipped / Total] 117 / 32 / 0 / 149:  15%|█▌        | 150/1000 [24:12<2:17:08,  9.68s/it][Succeeded / Failed / Skipped / Total] 118 / 32 / 0 / 150:  15%|█▌        | 150/1000 [24:12<2:17:08,  9.68s/it][Succeeded / Failed / Skipped / Total] 118 / 32 / 0 / 150:  15%|█▌        | 151/1000 [24:32<2:17:57,  9.75s/it][Succeeded / Failed / Skipped / Total] 119 / 32 / 0 / 151:  15%|█▌        | 151/1000 [24:32<2:17:57,  9.75s/it][Succeeded / Failed / Skipped / Total] 119 / 32 / 0 / 151:  15%|█▌        | 152/1000 [24:41<2:17:44,  9.75s/it][Succeeded / Failed / Skipped / Total] 120 / 32 / 0 / 152:  15%|█▌        | 152/1000 [24:41<2:17:44,  9.75s/it][Succeeded / Failed / Skipped / Total] 120 / 32 / 0 / 152:  15%|█▌        | 153/1000 [24:56<2:18:06,  9.78s/it][Succeeded / Failed / Skipped / Total] 121 / 32 / 0 / 153:  15%|█▌        | 153/1000 [24:56<2:18:06,  9.78s/it][Succeeded / Failed / Skipped / Total] 121 / 32 / 0 / 153:  15%|█▌        | 154/1000 [25:26<2:19:46,  9.91s/it]Build the redirect URL for a given request . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[buildHttpsRedirectUrlForRequest]] ( HttpServletRequest [[request]] ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( [[request]] ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( [[request]] . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( [[request]] . getContextPath ( ) ) ; urlBuilder . setServletPath ( [[request]] . getServletPath ( ) ) ; urlBuilder . setPathInfo ( [[request]] . getPathInfo ( ) ) ; urlBuilder . setQuery ( [[request]] . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String [[iou]] ( HttpServletRequest [[drifters]] ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( [[drifters]] ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( [[drifters]] . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( [[drifters]] . getContextPath ( ) ) ; urlBuilder . setServletPath ( [[drifters]] . getServletPath ( ) ) ; urlBuilder . setPathInfo ( [[drifters]] . getPathInfo ( ) ) ; urlBuilder . setQuery ( [[drifters]] . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 149 ---------------------------------------------
Attempt to exit the user . --> Override if needed for authentication --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[downright]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 150 ---------------------------------------------
Callback for when the login succeeded . --> Callback method for onLoginSuccess --> Socre: 1.0

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest [[request]] , HttpServletResponse [[response]] , Authentication successfulAuthentication ) { String [[username]] = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + [[username]] ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( [[username]] , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , [[request]] , [[response]] ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest [[azeem]] , HttpServletResponse [[rabbinical]] , Authentication successfulAuthentication ) { String [[gla]] = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + [[gla]] ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( [[gla]] , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , [[azeem]] , [[rabbinical]] ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 151 ---------------------------------------------
Display public index --> Display a random contact --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact [[rnd]] = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , [[rnd]] ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[abolitionist]] ( ) { Contact [[caroling]] = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , [[caroling]] ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 152 ---------------------------------------------
Sets the redirect user URL . --> Hockney algorithm --> Socre: 1.0

[[[[Adv]]]]: public void [[setExitUserUrl]] ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[exitUserMatcher]] = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void [[hockney]] ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[backward]] = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 153 ---------------------------------------------
Spring security filter . --> Bean aware bean creation --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[addict]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 154 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 122 / 32 / 0 / 154:  15%|█▌        | 154/1000 [25:26<2:19:46,  9.91s/it][Succeeded / Failed / Skipped / Total] 122 / 32 / 0 / 154:  16%|█▌        | 155/1000 [25:36<2:19:35,  9.91s/it][Succeeded / Failed / Skipped / Total] 122 / 33 / 0 / 155:  16%|█▌        | 155/1000 [25:36<2:19:35,  9.91s/it][Succeeded / Failed / Skipped / Total] 122 / 33 / 0 / 155:  16%|█▌        | 156/1000 [25:44<2:19:14,  9.90s/it][Succeeded / Failed / Skipped / Total] 122 / 34 / 0 / 156:  16%|█▌        | 156/1000 [25:44<2:19:14,  9.90s/it][Succeeded / Failed / Skipped / Total] 122 / 34 / 0 / 156:  16%|█▌        | 157/1000 [25:50<2:18:43,  9.87s/it][Succeeded / Failed / Skipped / Total] 123 / 34 / 0 / 157:  16%|█▌        | 157/1000 [25:50<2:18:43,  9.87s/it][Succeeded / Failed / Skipped / Total] 123 / 34 / 0 / 157:  16%|█▌        | 158/1000 [25:50<2:17:43,  9.81s/it][Succeeded / Failed / Skipped / Total] 124 / 34 / 0 / 158:  16%|█▌        | 158/1000 [25:50<2:17:43,  9.81s/it][Succeeded / Failed / Skipped / Total] 124 / 34 / 0 / 158:  16%|█▌        | 159/1000 [26:03<2:17:47,  9.83s/it]Attempt to switch to the user . --> Highball handler methods --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptSwitchUser]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String [[username]] = request . getParameter ( this . usernameParameter ) ; if ( [[username]] == null ) { [[username]] = "" ; } if ( this . [[logger]] . isDebugEnabled ( ) ) { this . [[logger]] . debug ( "Attempt to switch to user [" + [[username]] + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( [[username]] ) ; this . [[userDetailsChecker]] . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication [[highball]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String [[hatbox]] = request . getParameter ( this . usernameParameter ) ; if ( [[hatbox]] == null ) { [[hatbox]] = "" ; } if ( this . [[buddhists]] . isDebugEnabled ( ) ) { this . [[buddhists]] . debug ( "Attempt to switch to user [" + [[hatbox]] + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( [[hatbox]] ) ; this . [[magister]] . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 155 ---------------------------------------------
Decodes a JWT --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Jwt decode ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt [[createdJwt]] = createJwt ( token , jwt ) ; return validateJwt ( [[createdJwt]] ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt decode ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt [[cern]] = createJwt ( token , jwt ) ; return validateJwt ( [[cern]] ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 156 ---------------------------------------------
Process auto - login cookie . --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails [[processAutoLoginCookie]] ( String [ ] [[cookieTokens]] , HttpServletRequest request , HttpServletResponse response ) { if ( [[cookieTokens]] . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( [[cookieTokens]] ) + "'" ) ; } final String presentedSeries = [[cookieTokens]] [ 0 ] ; final String presentedToken = [[cookieTokens]] [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails [[monkeying]] ( String [ ] [[folklore]] , HttpServletRequest request , HttpServletResponse response ) { if ( [[folklore]] . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( [[folklore]] ) + "'" ) ; } final String presentedSeries = [[folklore]] [ 0 ] ; final String presentedToken = [[folklore]] [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 157 ---------------------------------------------
Authorizes the access --> Methode permettant de la restriction --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingAccessExpression]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return False ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException [[ioException]] = new IOException ( ) ; [[ioException]] . initCause ( e ) ; throw [[ioException]] ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean [[conversion]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return False ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException [[harmonizing]] = new IOException ( ) ; [[harmonizing]] . initCause ( e ) ; throw [[harmonizing]] ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 158 ---------------------------------------------
Convert the given JWT to a collection of authorities . --> Convert a JTA to a collection of grants . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt [[jwt]] ) { return getScopes ( [[jwt]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt [[anita]] ) { return getScopes ( [[anita]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 159 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 125 / 34 / 0 / 159:  16%|█▌        | 159/1000 [26:03<2:17:47,  9.83s/it][Succeeded / Failed / Skipped / Total] 125 / 34 / 0 / 159:  16%|█▌        | 160/1000 [26:03<2:16:47,  9.77s/it][Succeeded / Failed / Skipped / Total] 125 / 34 / 1 / 160:  16%|█▌        | 160/1000 [26:03<2:16:47,  9.77s/it][Succeeded / Failed / Skipped / Total] 125 / 34 / 1 / 160:  16%|█▌        | 161/1000 [26:07<2:16:10,  9.74s/it][Succeeded / Failed / Skipped / Total] 125 / 35 / 1 / 161:  16%|█▌        | 161/1000 [26:07<2:16:10,  9.74s/it][Succeeded / Failed / Skipped / Total] 125 / 35 / 1 / 161:  16%|█▌        | 162/1000 [26:25<2:16:40,  9.79s/it][Succeeded / Failed / Skipped / Total] 125 / 36 / 1 / 162:  16%|█▌        | 162/1000 [26:25<2:16:40,  9.79s/it][Succeeded / Failed / Skipped / Total] 125 / 36 / 1 / 162:  16%|█▋        | 163/1000 [26:40<2:16:59,  9.82s/it][Succeeded / Failed / Skipped / Total] 126 / 36 / 1 / 163:  16%|█▋        | 163/1000 [26:40<2:16:59,  9.82s/it][Succeeded / Failed / Skipped / Total] 126 / 36 / 1 / 163:  16%|█▋        | 164/1000 [26:42<2:16:08,  9.77s/it][Succeeded / Failed / Skipped / Total] 127 / 36 / 1 / 164:  16%|█▋        | 164/1000 [26:42<2:16:08,  9.77s/it][Succeeded / Failed / Skipped / Total] 127 / 36 / 1 / 164:  16%|█▋        | 165/1000 [26:48<2:15:39,  9.75s/it][Succeeded / Failed / Skipped / Total] 128 / 36 / 1 / 165:  16%|█▋        | 165/1000 [26:48<2:15:39,  9.75s/it][Succeeded / Failed / Skipped / Total] 128 / 36 / 1 / 165:  17%|█▋        | 166/1000 [26:50<2:14:51,  9.70s/it]Display AddPermission page for AddPermission --> Display AddPermission --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact [[contact]] = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( [[contact]] ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact [[clapping]] = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( [[clapping]] ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 160 ---------------------------------------------
Render a AddPermission --> [[[SKIPPED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 161 ---------------------------------------------
Check authorization using url check . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean authorizeUsingUrlCheck ( ) throws IOException { String [[contextPath]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[currentUser]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[contextPath]] , getUrl ( ) , getMethod ( ) , [[currentUser]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean authorizeUsingUrlCheck ( ) throws IOException { String [[michaelangelo]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[breslin]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[michaelangelo]] , getUrl ( ) , getMethod ( ) , [[breslin]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 162 ---------------------------------------------
Generate a CSRF token . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public CsrfToken generateToken ( HttpServletRequest [[request]] ) { return wrap ( [[request]] , this . [[delegate]] . generateToken ( [[request]] ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken generateToken ( HttpServletRequest [[malaka]] ) { return wrap ( [[malaka]] , this . [[retrovirus]] . generateToken ( [[malaka]] ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 163 ---------------------------------------------
Creates a new user details resource factory bean from a String . --> Deserialize UserDetailsFactory bean . --> Socre: 1.0

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String [[users]] ) { InMemoryResource resource = new InMemoryResource ( [[users]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String [[weddin]] ) { InMemoryResource resource = new InMemoryResource ( [[weddin]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 164 ---------------------------------------------
Display admin permission --> Display Dorsoisir view --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[bonsoir]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 165 ---------------------------------------------
Gets the role with the default role prefix . --> returns a buttoning --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String [[defaultRolePrefix]] , String role ) { if ( role == null ) { return role ; } if ( [[defaultRolePrefix]] == null || [[defaultRolePrefix]] . length ( ) == 0 ) { return role ; } if ( role . startsWith ( [[defaultRolePrefix]] ) ) { return role ; } return [[defaultRolePrefix]] + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[buttoning]] ( String [[efficacy]] , String role ) { if ( role == null ) { return role ; } if ( [[efficacy]] == null || [[efficacy]] . length ( ) == 0 ) { return role ; } if ( role . startsWith ( [[efficacy]] ) ) { return role ; } return [[efficacy]] + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 166 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 129 / 36 / 1 / 166:  17%|█▋        | 166/1000 [26:50<2:14:51,  9.70s/it][Succeeded / Failed / Skipped / Total] 129 / 36 / 1 / 166:  17%|█▋        | 167/1000 [27:08<2:15:23,  9.75s/it][Succeeded / Failed / Skipped / Total] 130 / 36 / 1 / 167:  17%|█▋        | 167/1000 [27:08<2:15:23,  9.75s/it][Succeeded / Failed / Skipped / Total] 130 / 36 / 1 / 167:  17%|█▋        | 168/1000 [27:15<2:14:57,  9.73s/it][Succeeded / Failed / Skipped / Total] 131 / 36 / 1 / 168:  17%|█▋        | 168/1000 [27:15<2:14:57,  9.73s/it][Succeeded / Failed / Skipped / Total] 131 / 36 / 1 / 168:  17%|█▋        | 169/1000 [27:18<2:14:16,  9.70s/it][Succeeded / Failed / Skipped / Total] 132 / 36 / 1 / 169:  17%|█▋        | 169/1000 [27:18<2:14:16,  9.70s/it][Succeeded / Failed / Skipped / Total] 132 / 36 / 1 / 169:  17%|█▋        | 170/1000 [27:28<2:14:09,  9.70s/it][Succeeded / Failed / Skipped / Total] 133 / 36 / 1 / 170:  17%|█▋        | 170/1000 [27:28<2:14:09,  9.70s/it][Succeeded / Failed / Skipped / Total] 133 / 36 / 1 / 170:  17%|█▋        | 171/1000 [27:32<2:13:30,  9.66s/it][Succeeded / Failed / Skipped / Total] 134 / 36 / 1 / 171:  17%|█▋        | 171/1000 [27:32<2:13:30,  9.66s/it][Succeeded / Failed / Skipped / Total] 134 / 36 / 1 / 171:  17%|█▋        | 172/1000 [27:57<2:14:37,  9.76s/it][Succeeded / Failed / Skipped / Total] 135 / 36 / 1 / 172:  17%|█▋        | 172/1000 [27:57<2:14:37,  9.76s/it][Succeeded / Failed / Skipped / Total] 135 / 36 / 1 / 172:  17%|█▋        | 173/1000 [27:59<2:13:47,  9.71s/it]Deletes a permission --> Delete inigo --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[deletePermission]] ( @ RequestParam ( "contactId" ) long [[contactId]] , @ RequestParam ( "sid" ) String [[sid]] , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( [[contactId]] ) ; Sid sidObject = new PrincipalSid ( [[sid]] ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[inigo]] ( @ RequestParam ( "contactId" ) long [[bloomberg]] , @ RequestParam ( "sid" ) String [[baseball]] , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( [[bloomberg]] ) ; Sid sidObject = new PrincipalSid ( [[baseball]] ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 167 ---------------------------------------------
Get all the values for a given attribute name . --> Gets bigfooter . --> Socre: 1.0

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String [[name]] ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( [[name]] ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[bigfoot]] ( String [[dunya]] ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( [[dunya]] ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 168 ---------------------------------------------
Encodes the given string into a byte array . --> Encode a CharSequence --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence string ) { try { ByteBuffer [[bytes]] = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] [[bytesCopy]] = new byte [ [[bytes]] . limit ( ) ] ; System . arraycopy ( [[bytes]] . array ( ) , 0 , [[bytesCopy]] , 0 , [[bytes]] . limit ( ) ) ; return [[bytesCopy]] ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence string ) { try { ByteBuffer [[witherspoon]] = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] [[render]] = new byte [ [[witherspoon]] . limit ( ) ] ; System . arraycopy ( [[witherspoon]] . array ( ) , 0 , [[render]] , 0 , [[witherspoon]] . limit ( ) ) ; return [[render]] ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 169 ---------------------------------------------
Decode the given bytes . --> Utility method to extract natphony --> Socre: 1.0

[[[[Adv]]]]: public static String [[decode]] ( byte [ ] [[bytes]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bytes]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String [[contaminant]] ( byte [ ] [[natacha]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[natacha]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 170 ---------------------------------------------
Get the first attribute value for the given attribute name . --> Gets backwash . --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String [[name]] ) { List < String > result = getAttributeValues ( [[name]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[backwash]] ( String [[jie]] ) { List < String > result = getAttributeValues ( [[jie]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 171 ---------------------------------------------
Return all attributes specified on the target class --> Determine attributes that are requested against --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[findAttributes]] ( Method method , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , targetClass ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[amity]] ( Method method , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , targetClass ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 172 ---------------------------------------------
Add new contact --> Render fuser --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[addContact]] ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact [[contact]] = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( [[contact]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[fuser]] ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact [[calhoun]] = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( [[calhoun]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 173 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 136 / 36 / 1 / 173:  17%|█▋        | 173/1000 [27:59<2:13:47,  9.71s/it][Succeeded / Failed / Skipped / Total] 136 / 36 / 1 / 173:  17%|█▋        | 174/1000 [28:15<2:14:09,  9.74s/it][Succeeded / Failed / Skipped / Total] 137 / 36 / 1 / 174:  17%|█▋        | 174/1000 [28:15<2:14:09,  9.74s/it][Succeeded / Failed / Skipped / Total] 137 / 36 / 1 / 174:  18%|█▊        | 175/1000 [28:26<2:14:07,  9.75s/it][Succeeded / Failed / Skipped / Total] 138 / 36 / 1 / 175:  18%|█▊        | 175/1000 [28:26<2:14:07,  9.75s/it][Succeeded / Failed / Skipped / Total] 138 / 36 / 1 / 175:  18%|█▊        | 176/1000 [28:27<2:13:12,  9.70s/it][Succeeded / Failed / Skipped / Total] 139 / 36 / 1 / 176:  18%|█▊        | 176/1000 [28:27<2:13:12,  9.70s/it][Succeeded / Failed / Skipped / Total] 139 / 36 / 1 / 176:  18%|█▊        | 177/1000 [28:33<2:12:48,  9.68s/it][Succeeded / Failed / Skipped / Total] 139 / 37 / 1 / 177:  18%|█▊        | 177/1000 [28:33<2:12:48,  9.68s/it][Succeeded / Failed / Skipped / Total] 139 / 37 / 1 / 177:  18%|█▊        | 178/1000 [28:40<2:12:24,  9.67s/it][Succeeded / Failed / Skipped / Total] 140 / 37 / 1 / 178:  18%|█▊        | 178/1000 [28:40<2:12:24,  9.67s/it][Succeeded / Failed / Skipped / Total] 140 / 37 / 1 / 178:  18%|█▊        | 179/1000 [28:48<2:12:06,  9.66s/it][Succeeded / Failed / Skipped / Total] 141 / 37 / 1 / 179:  18%|█▊        | 179/1000 [28:48<2:12:06,  9.66s/it][Succeeded / Failed / Skipped / Total] 141 / 37 / 1 / 179:  18%|█▊        | 180/1000 [28:51<2:11:28,  9.62s/it]Get all config attributes . --> obtained all methods from methods --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[getAllConfigAttributes]] ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[allAttributes]] . addAll ( attributeList ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[inked]] ( ) { Set < ConfigAttribute > [[harbinger]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[harbinger]] . addAll ( attributeList ) ; } return [[harbinger]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 174 ---------------------------------------------
Sets any request that matches any request matcher . --> Configure the patcher --> Socre: 1.0

[[[[Adv]]]]: public C [[anyRequest]] ( ) { Assert . state ( ! this . anyRequestConfigured , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . anyRequestConfigured = True ; return configurer ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C [[patricia]] ( ) { Assert . state ( ! this . anyRequestConfigured , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . anyRequestConfigured = True ; return configurer ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 175 ---------------------------------------------
Checks if the given method is a match . --> Methode permettant diliete --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isMatch]] ( String [[methodName]] , String mappedName ) { return ( mappedName . endsWith ( "*" ) && [[methodName]] . startsWith ( mappedName . substring ( 0 , mappedName . length ( ) - 1 ) ) ) || ( mappedName . startsWith ( "*" ) && [[methodName]] . endsWith ( mappedName . substring ( 1 , mappedName . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[nutso]] ( String [[dili]] , String mappedName ) { return ( mappedName . endsWith ( "*" ) && [[dili]] . startsWith ( mappedName . substring ( 0 , mappedName . length ( ) - 1 ) ) ) || ( mappedName . startsWith ( "*" ) && [[dili]] . endsWith ( mappedName . substring ( 1 , mappedName . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 176 ---------------------------------------------
Look up the parameter names for a given object . --> Lookup launchers for a class --> Socre: 1.0

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] [[parameterAnnotations]] = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = [[parameterAnnotations]] . length ; String [ ] [[paramNames]] = new String [ parameterCount ] ; boolean [[found]] = "[[False]]" != "[[False]]" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = [[parameterAnnotations]] [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { [[found]] = True ; [[paramNames]] [ i ] = parameterName ; } } return [[found]] ? [[paramNames]] : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] [[artificially]] = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = [[artificially]] . length ; String [ ] [[info]] = new String [ parameterCount ] ; boolean [[launchers]] = "[["Bulgur" != "Bulgur"]]" != "[["Bulgur" != "Bulgur"]]" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = [[artificially]] [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { [[launchers]] = True ; [[info]] [ i ] = parameterName ; } } return [[launchers]] ? [[info]] : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 177 ---------------------------------------------
Registers a new secure method . --> [[[FAILED]]]

[[[[Adv]]]]: private void addSecureMethod ( RegisteredMethod [[method]] , List < ConfigAttribute > [[attr]] ) { Assert . notNull ( [[method]] , "RegisteredMethod required" ) ; Assert . notNull ( [[attr]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[method]] + "] with attributes [" + [[attr]] + "]" ) ; } this . [[methodMap]] . put ( [[method]] , [[attr]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void addSecureMethod ( RegisteredMethod [[vectors]] , List < ConfigAttribute > [[twinview]] ) { Assert . notNull ( [[vectors]] , "RegisteredMethod required" ) ; Assert . notNull ( [[twinview]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[vectors]] + "] with attributes [" + [[twinview]] + "]" ) ; } this . [[aloysius]] . put ( [[vectors]] , [[twinview]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 178 ---------------------------------------------
Handle bind exception . --> Invoke bindAs method --> Socre: 1.0

[[[[Adv]]]]: protected void [[handleBindException]] ( String userDn , String username , Throwable [[cause]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + [[cause]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void [[huys]] ( String userDn , String username , Throwable [[feliz]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + [[feliz]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 179 ---------------------------------------------
Get a random contact --> Get random contact --> Socre: 1.0

[[[[Adv]]]]: @ Transactional ( readOnly = True ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int [[getNumber]] = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( [[getNumber]] ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = True ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int [[congregate]] = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( [[congregate]] ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 180 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 142 / 37 / 1 / 180:  18%|█▊        | 180/1000 [28:51<2:11:28,  9.62s/it][Succeeded / Failed / Skipped / Total] 142 / 37 / 1 / 180:  18%|█▊        | 181/1000 [29:14<2:12:20,  9.69s/it][Succeeded / Failed / Skipped / Total] 142 / 38 / 1 / 181:  18%|█▊        | 181/1000 [29:14<2:12:20,  9.69s/it][Succeeded / Failed / Skipped / Total] 142 / 38 / 1 / 181:  18%|█▊        | 182/1000 [29:15<2:11:31,  9.65s/it][Succeeded / Failed / Skipped / Total] 143 / 38 / 1 / 182:  18%|█▊        | 182/1000 [29:15<2:11:31,  9.65s/it][Succeeded / Failed / Skipped / Total] 143 / 38 / 1 / 182:  18%|█▊        | 183/1000 [29:30<2:11:44,  9.68s/it][Succeeded / Failed / Skipped / Total] 144 / 38 / 1 / 183:  18%|█▊        | 183/1000 [29:30<2:11:44,  9.68s/it][Succeeded / Failed / Skipped / Total] 144 / 38 / 1 / 183:  18%|█▊        | 184/1000 [29:32<2:11:02,  9.64s/it][Succeeded / Failed / Skipped / Total] 145 / 38 / 1 / 184:  18%|█▊        | 184/1000 [29:32<2:11:02,  9.64s/it][Succeeded / Failed / Skipped / Total] 145 / 38 / 1 / 184:  18%|█▊        | 185/1000 [29:42<2:10:51,  9.63s/it][Succeeded / Failed / Skipped / Total] 146 / 38 / 1 / 185:  18%|█▊        | 185/1000 [29:42<2:10:51,  9.63s/it][Succeeded / Failed / Skipped / Total] 146 / 38 / 1 / 185:  19%|█▊        | 186/1000 [29:50<2:10:37,  9.63s/it][Succeeded / Failed / Skipped / Total] 147 / 38 / 1 / 186:  19%|█▊        | 186/1000 [29:50<2:10:37,  9.63s/it][Succeeded / Failed / Skipped / Total] 147 / 38 / 1 / 186:  19%|█▊        | 187/1000 [30:11<2:11:14,  9.69s/it]Removes the authentication exception from the session . --> Remove cookie from request --> Socre: 1.0

[[[[Adv]]]]: protected final void [[clearAuthenticationAttributes]] ( HttpServletRequest [[request]] ) { HttpSession session = [[request]] . getSession ( False ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void [[forgo]] ( HttpServletRequest [[avocado]] ) { HttpSession session = [[avocado]] . getSession ( False ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 181 ---------------------------------------------
Returns the declared field of the given class . --> [[[FAILED]]]

[[[[Adv]]]]: public static Field getField ( Class < ? > clazz , String [[fieldName]] ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( [[fieldName]] , "Field name required" ) ; try { return clazz . getDeclaredField ( [[fieldName]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field getField ( Class < ? > clazz , String [[flared]] ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( [[flared]] , "Field name required" ) ; try { return clazz . getDeclaredField ( [[flared]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 182 ---------------------------------------------
Create the service url . --> Generate daybreak --> Socre: 1.0

[[[[Adv]]]]: protected String [[createServiceUrl]] ( final HttpServletRequest [[request]] , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[daybreak]] ( final HttpServletRequest [[gogh]] , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 183 ---------------------------------------------
Checks the stack . --> Check stack . --> Socre: 1.0

[[[[Adv]]]]: private void checkFilterStack ( List < Filter > [[filters]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[filters]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[filters]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[filters]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[filters]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[filters]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[filters]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void checkFilterStack ( List < Filter > [[batt]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[batt]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[batt]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[batt]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[batt]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[batt]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[batt]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[batt]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[batt]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 184 ---------------------------------------------
Extract prefix . --> Liefert den Filters --> Socre: 1.0

[[[[Adv]]]]: private String [[extractPrefix]] ( String [[encPass]] ) { if ( ! [[encPass]] . startsWith ( "{" ) ) { return null ; } int secondBrace = [[encPass]] . lastIndexOf ( ' ' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[encPass]] . substring ( 0 , secondBrace + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String [[ancestral]] ( String [[extinguisher]] ) { if ( ! [[extinguisher]] . startsWith ( "{" ) ) { return null ; } int secondBrace = [[extinguisher]] . lastIndexOf ( ' ' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[extinguisher]] . substring ( 0 , secondBrace + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 185 ---------------------------------------------
Called by the authentication process . --> Handle kojima --> Socre: 1.0

[[[[Adv]]]]: public void [[commence]] ( HttpServletRequest [[request]] , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void [[kojima]] ( HttpServletRequest [[activism]] , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 186 ---------------------------------------------
Create the redirect url . --> High - level improvement --> Socre: 1.0

[[[[Adv]]]]: protected String [[createRedirectUrl]] ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . [[loginUrl]] , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[improve]] ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . [[neda]] , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "[["Alzheimer" != "Alzheimer"]]" != "[["Alzheimer" != "Alzheimer"]]" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 187 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 147 / 39 / 1 / 187:  19%|█▊        | 187/1000 [30:11<2:11:14,  9.69s/it][Succeeded / Failed / Skipped / Total] 147 / 39 / 1 / 187:  19%|█▉        | 188/1000 [30:25<2:11:26,  9.71s/it][Succeeded / Failed / Skipped / Total] 148 / 39 / 1 / 188:  19%|█▉        | 188/1000 [30:25<2:11:26,  9.71s/it][Succeeded / Failed / Skipped / Total] 149 / 39 / 1 / 189:  19%|█▉        | 189/1000 [30:25<2:10:34,  9.66s/it][Succeeded / Failed / Skipped / Total] 149 / 39 / 1 / 189:  19%|█▉        | 190/1000 [30:41<2:10:52,  9.69s/it][Succeeded / Failed / Skipped / Total] 150 / 39 / 1 / 190:  19%|█▉        | 190/1000 [30:41<2:10:52,  9.69s/it][Succeeded / Failed / Skipped / Total] 150 / 39 / 1 / 190:  19%|█▉        | 191/1000 [30:47<2:10:24,  9.67s/it][Succeeded / Failed / Skipped / Total] 150 / 40 / 1 / 191:  19%|█▉        | 191/1000 [30:47<2:10:24,  9.67s/it][Succeeded / Failed / Skipped / Total] 150 / 40 / 1 / 191:  19%|█▉        | 192/1000 [31:08<2:11:04,  9.73s/it][Succeeded / Failed / Skipped / Total] 150 / 41 / 1 / 192:  19%|█▉        | 192/1000 [31:08<2:11:04,  9.73s/it][Succeeded / Failed / Skipped / Total] 150 / 41 / 1 / 192:  19%|█▉        | 193/1000 [31:09<2:10:15,  9.68s/it]Gets the registered types . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > [[typeList]] = this . [[extractorMap]] . keySet ( ) ; return [[typeList]] . toArray ( new Class [ [[typeList]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[segura]] ( ) { Set < Class < ? extends Throwable > > [[cannibals]] = this . [[cag]] . keySet ( ) ; return [[cannibals]] . toArray ( new Class [ [[cannibals]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 188 ---------------------------------------------
Compares two byte arrays . --> Compares twofer byte arrays --> Socre: 1.0

[[[[Adv]]]]: private boolean matches ( byte [ ] [[expected]] , byte [ ] actual ) { if ( [[expected]] . length != actual . length ) { return False ; } int result = 0 ; for ( int i = 0 ; i < [[expected]] . length ; i ++ ) { result |= [[expected]] [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean matches ( byte [ ] [[afer]] , byte [ ] actual ) { if ( [[afer]] . length != actual . length ) { return False ; } int result = 0 ; for ( int i = 0 ; i < [[afer]] . length ; i ++ ) { result |= [[afer]] [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 189 ---------------------------------------------
Extracts the cause of a throwable . --> returns null if no exception --> Socre: 1.0

[[[[Adv]]]]: private Throwable extractCause ( Throwable [[throwable]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[entry]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = [[entry]] . getKey ( ) ; if ( throwableType . isInstance ( [[throwable]] ) ) { ThrowableCauseExtractor [[extractor]] = [[entry]] . getValue ( ) ; return [[extractor]] . extractCause ( [[throwable]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable extractCause ( Throwable [[qian]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[custom]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = [[custom]] . getKey ( ) ; if ( throwableType . isInstance ( [[qian]] ) ) { ThrowableCauseExtractor [[piastres]] = [[custom]] . getValue ( ) ; return [[piastres]] . extractCause ( [[qian]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 190 ---------------------------------------------
Register access manager . --> generate a bean definition --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String [[registerAccessManager]] ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder [[accessMgrBuilder]] = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } [[accessMgrBuilder]] . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = [[accessMgrBuilder]] . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String [[aho]] ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder [[coutinho]] = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } [[coutinho]] . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = [[coutinho]] . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 191 ---------------------------------------------
Convert a collection of user authorities to a Set . --> [[[FAILED]]]

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > [[userAuthorities]] ) { Assert . notNull ( [[userAuthorities]] , "userAuthorities cannot be null" ) ; Set < String > [[set]] = new HashSet <> ( [[userAuthorities]] . size ( ) ) ; for ( GrantedAuthority authority : [[userAuthorities]] ) { [[set]] . add ( authority . getAuthority ( ) ) ; } return [[set]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[afflicts]] ( Collection < ? extends GrantedAuthority > [[fujian]] ) { Assert . notNull ( [[fujian]] , "userAuthorities cannot be null" ) ; Set < String > [[manage]] = new HashSet <> ( [[fujian]] . size ( ) ) ; for ( GrantedAuthority authority : [[fujian]] ) { [[manage]] . add ( authority . getAuthority ( ) ) ; } return [[manage]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 192 ---------------------------------------------
Sets the default failure url . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String [[defaultFailureUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[defaultFailureUrl]] ) , ( ) -> "'" + [[defaultFailureUrl]] + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = [[defaultFailureUrl]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[credulity]] ( String [[evidence]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[evidence]] ) , ( ) -> "'" + [[evidence]] + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = [[evidence]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 193 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 151 / 41 / 1 / 193:  19%|█▉        | 193/1000 [31:09<2:10:15,  9.68s/it][Succeeded / Failed / Skipped / Total] 151 / 41 / 1 / 193:  19%|█▉        | 194/1000 [31:24<2:10:30,  9.72s/it][Succeeded / Failed / Skipped / Total] 152 / 41 / 1 / 194:  19%|█▉        | 194/1000 [31:24<2:10:30,  9.72s/it][Succeeded / Failed / Skipped / Total] 152 / 41 / 1 / 194:  20%|█▉        | 195/1000 [31:26<2:09:47,  9.67s/it][Succeeded / Failed / Skipped / Total] 153 / 41 / 1 / 195:  20%|█▉        | 195/1000 [31:26<2:09:47,  9.67s/it][Succeeded / Failed / Skipped / Total] 153 / 41 / 1 / 195:  20%|█▉        | 196/1000 [31:42<2:10:03,  9.71s/it][Succeeded / Failed / Skipped / Total] 153 / 42 / 1 / 196:  20%|█▉        | 196/1000 [31:42<2:10:03,  9.71s/it][Succeeded / Failed / Skipped / Total] 153 / 42 / 1 / 196:  20%|█▉        | 197/1000 [31:55<2:10:05,  9.72s/it][Succeeded / Failed / Skipped / Total] 153 / 43 / 1 / 197:  20%|█▉        | 197/1000 [31:55<2:10:06,  9.72s/it][Succeeded / Failed / Skipped / Total] 153 / 43 / 1 / 197:  20%|█▉        | 198/1000 [31:56<2:09:21,  9.68s/it]Sets the function to resolve hidden inputs . --> Define spotlight search --> Socre: 1.0

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . [[resolveHiddenInputs]] = resolveHiddenInputs ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[spotlight]] ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . [[pituitary]] = resolveHiddenInputs ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 194 ---------------------------------------------
Extracts the given identifier from the given result set . --> Convert an identifier to an identifier --> Socre: 1.0

[[[[Adv]]]]: Serializable identifierFrom ( Serializable [[identifier]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[identifier]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[identifier]] = convertFromStringTo ( ( String ) [[identifier]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable identifierFrom ( Serializable [[máximo]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[máximo]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[máximo]] = convertFromStringTo ( ( String ) [[máximo]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 195 ---------------------------------------------
Build the request URL --> Escape a request URI --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildRequestUrl]] ( String servletPath , String requestURI , String contextPath , String pathInfo , String [[queryString]] ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( [[queryString]] != null ) { url . append ( "?" ) . append ( [[queryString]] ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String [[displeased]] ( String servletPath , String requestURI , String contextPath , String pathInfo , String [[antsy]] ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( [[antsy]] != null ) { url . append ( "?" ) . append ( [[antsy]] ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 196 ---------------------------------------------
Checks if the given URL is an absolute URL . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String url ) { if ( url == null ) { return "[[False]]" != "[[False]]" ; } final Pattern [[ABSOLUTE_URL]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[ABSOLUTE_URL]] . matcher ( url ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[manifests]] ( String url ) { if ( url == null ) { return "[["Vauxhall" != "Vauxhall"]]" != "[["Vauxhall" != "Vauxhall"]]" ; } final Pattern [[ACCOUNTABILITY]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[ACCOUNTABILITY]] . matcher ( url ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 197 ---------------------------------------------
Returns the list of OpenID attributes for the given identifier . --> [[[FAILED]]]

[[[[Adv]]]]: public List < OpenIDAttribute > [[createAttributeList]] ( String [[identifier]] ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > [[entry]] : idToAttributes . entrySet ( ) ) { if ( [[entry]] . getKey ( ) . matcher ( [[identifier]] ) . matches ( ) ) { return [[entry]] . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > [[danzig]] ( String [[preachy]] ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > [[asians]] : idToAttributes . entrySet ( ) ) { if ( [[asians]] . getKey ( ) . matcher ( [[preachy]] ) . matches ( ) ) { return [[asians]] . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 198 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 154 / 43 / 1 / 198:  20%|█▉        | 198/1000 [31:56<2:09:21,  9.68s/it][Succeeded / Failed / Skipped / Total] 154 / 43 / 1 / 198:  20%|█▉        | 199/1000 [32:40<2:11:30,  9.85s/it][Succeeded / Failed / Skipped / Total] 154 / 44 / 1 / 199:  20%|█▉        | 199/1000 [32:40<2:11:30,  9.85s/it][Succeeded / Failed / Skipped / Total] 154 / 44 / 1 / 199:  20%|██        | 200/1000 [32:40<2:10:42,  9.80s/it][Succeeded / Failed / Skipped / Total] 154 / 44 / 2 / 200:  20%|██        | 200/1000 [32:40<2:10:42,  9.80s/it][Succeeded / Failed / Skipped / Total] 154 / 44 / 2 / 200:  20%|██        | 201/1000 [32:42<2:10:01,  9.76s/it][Succeeded / Failed / Skipped / Total] 155 / 44 / 2 / 201:  20%|██        | 201/1000 [32:42<2:10:01,  9.76s/it][Succeeded / Failed / Skipped / Total] 155 / 44 / 2 / 201:  20%|██        | 202/1000 [32:56<2:10:06,  9.78s/it][Succeeded / Failed / Skipped / Total] 156 / 44 / 2 / 202:  20%|██        | 202/1000 [32:56<2:10:06,  9.78s/it][Succeeded / Failed / Skipped / Total] 156 / 44 / 2 / 202:  20%|██        | 203/1000 [32:59<2:09:33,  9.75s/it]Update an existing ACL . --> Update ObjectIdentity --> Socre: 1.0

[[[[Adv]]]]: protected void updateObjectIdentity ( MutableAcl [[acl]] ) { Long parentId = null ; if ( [[acl]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[acl]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( [[acl]] . getOwner ( ) , True ) ; int count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( [[acl]] . isEntriesInheriting ( ) ) , [[acl]] . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void updateObjectIdentity ( MutableAcl [[cancer]] ) { Long parentId = null ; if ( [[cancer]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[cancer]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[cancer]] . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[cancer]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( [[cancer]] . getOwner ( ) , True ) ; int count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( [[cancer]] . isEntriesInheriting ( ) ) , [[cancer]] . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 199 ---------------------------------------------
Store object identity . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[createObjectIdentity]] ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "[[True]]" == "[[True]]" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "[[True]]" == "[[True]]" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void [[oddball]] ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "[["Antipsychotic" == "Antipsychotic"]]" == "[["Antipsychotic" == "Antipsychotic"]]" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "[["Antipsychotic" == "Antipsychotic"]]" == "[["Antipsychotic" == "Antipsychotic"]]" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 200 ---------------------------------------------
Matching matcher . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static ServerWebExchangeMatcher anyExchange ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 201 ---------------------------------------------
Creates and returns a list of match matchers . --> Methode permettable matchers --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[pathMatchers]] ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String [[pattern]] : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( [[pattern]] , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[muoi]] ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String [[heavyset]] : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( [[heavyset]] , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 202 ---------------------------------------------
Insert entries in acl . --> create adie --> Socre: 1.0

[[[[Adv]]]]: protected void [[createEntries]] ( final MutableAcl [[acl]] ) { if ( [[acl]] . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return [[acl]] . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int [[i]] ) throws SQLException { AccessControlEntry [[entry_]] = [[acl]] . getEntries ( ) . get ( [[i]] ) ; Assert . isTrue ( [[entry_]] instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) [[entry_]] ; stmt . setLong ( 1 , ( ( Long ) [[acl]] . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , [[i]] ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , True ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void [[adie]] ( final MutableAcl [[beaker]] ) { if ( [[beaker]] . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return [[beaker]] . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int [[cinematographic]] ) throws SQLException { AccessControlEntry [[conservatism]] = [[beaker]] . getEntries ( ) . get ( [[cinematographic]] ) ; Assert . isTrue ( [[conservatism]] instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) [[conservatism]] ; stmt . setLong ( 1 , ( ( Long ) [[beaker]] . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , [[cinematographic]] ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , True ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 203 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 157 / 44 / 2 / 203:  20%|██        | 203/1000 [32:59<2:09:33,  9.75s/it][Succeeded / Failed / Skipped / Total] 157 / 44 / 2 / 203:  20%|██        | 204/1000 [33:12<2:09:34,  9.77s/it][Succeeded / Failed / Skipped / Total] 158 / 44 / 2 / 204:  20%|██        | 204/1000 [33:12<2:09:34,  9.77s/it][Succeeded / Failed / Skipped / Total] 158 / 44 / 2 / 204:  20%|██        | 205/1000 [33:26<2:09:41,  9.79s/it][Succeeded / Failed / Skipped / Total] 159 / 44 / 2 / 205:  20%|██        | 205/1000 [33:26<2:09:41,  9.79s/it][Succeeded / Failed / Skipped / Total] 159 / 44 / 2 / 205:  21%|██        | 206/1000 [33:27<2:08:58,  9.75s/it][Succeeded / Failed / Skipped / Total] 160 / 44 / 2 / 206:  21%|██        | 206/1000 [33:27<2:08:58,  9.75s/it][Succeeded / Failed / Skipped / Total] 160 / 44 / 2 / 206:  21%|██        | 207/1000 [33:35<2:08:40,  9.74s/it][Succeeded / Failed / Skipped / Total] 161 / 44 / 2 / 207:  21%|██        | 207/1000 [33:35<2:08:40,  9.74s/it][Succeeded / Failed / Skipped / Total] 161 / 44 / 2 / 207:  21%|██        | 208/1000 [33:40<2:08:12,  9.71s/it][Succeeded / Failed / Skipped / Total] 162 / 44 / 2 / 208:  21%|██        | 208/1000 [33:40<2:08:12,  9.71s/it][Succeeded / Failed / Skipped / Total] 162 / 44 / 2 / 208:  21%|██        | 209/1000 [33:53<2:08:16,  9.73s/it][Succeeded / Failed / Skipped / Total] 163 / 44 / 2 / 209:  21%|██        | 209/1000 [33:53<2:08:16,  9.73s/it][Succeeded / Failed / Skipped / Total] 163 / 44 / 2 / 209:  21%|██        | 210/1000 [33:55<2:07:36,  9.69s/it][Succeeded / Failed / Skipped / Total] 164 / 44 / 2 / 210:  21%|██        | 210/1000 [33:55<2:07:36,  9.69s/it][Succeeded / Failed / Skipped / Total] 164 / 44 / 2 / 210:  21%|██        | 211/1000 [34:09<2:07:43,  9.71s/it]Saves the current request . --> Antifest --> Socre: 1.0

[[[[Adv]]]]: public void [[saveRequest]] ( HttpServletRequest request , HttpServletResponse [[response]] ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest [[savedRequest]] = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( False ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void [[antifreeze]] ( HttpServletRequest request , HttpServletResponse [[máximo]] ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest [[absolue]] = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( False ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 204 ---------------------------------------------
Creates a text encryptor . --> Create TextEncryptor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[text]] ( CharSequence password , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( standard ( password , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[lanning]] ( CharSequence password , CharSequence [[juno]] ) { return new HexEncodingTextEncryptor ( standard ( password , [[juno]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 205 ---------------------------------------------
Creates a delux encryptor with the given password . --> exryptor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[delux]] ( CharSequence [[password]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( [[password]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[gio]] ( CharSequence [[città]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( [[città]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 206 ---------------------------------------------
Write headers to response . --> bucket HTTP headers --> Socre: 1.0

[[[[Adv]]]]: public void [[writeHeaders]] ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String [[allowFromValue]] = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( [[allowFromValue]] ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( [[allowFromValue]] != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + [[allowFromValue]] ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void [[buckman]] ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String [[lowing]] = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( [[lowing]] ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( [[lowing]] != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + [[lowing]] ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 207 ---------------------------------------------
Encryptor for queryable text . --> else --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[queryableText]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[password]] . toString ( ) , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[bei]] ( CharSequence [[wig]] , CharSequence [[divorcée]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[wig]] . toString ( ) , [[divorcée]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 208 ---------------------------------------------
Determines the target URL . --> Performs adelina . --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[authentication]] ) { return [[determineTargetUrl]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String [[adelina]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[bulgur]] ) { return [[adelina]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 209 ---------------------------------------------
Sets the target URL parameter . --> Sets stiff --> Socre: 1.0

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . [[targetUrlParameter]] = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[stiffs]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . [[celibate]] = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 210 ---------------------------------------------
Build a Dn with the specified username . --> converts a string to a DistinguishedName --> Socre: 1.0

[[[[Adv]]]]: public DistinguishedName [[buildDn]] ( String username ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , username ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName [[frédéric]] ( String username ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , username ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
[Succeeded / Failed / Skipped / Total] 165 / 44 / 2 / 211:  21%|██        | 211/1000 [34:09<2:07:43,  9.71s/it][Succeeded / Failed / Skipped / Total] 165 / 44 / 2 / 211:  21%|██        | 212/1000 [34:10<2:07:00,  9.67s/it][Succeeded / Failed / Skipped / Total] 166 / 44 / 2 / 212:  21%|██        | 212/1000 [34:10<2:07:00,  9.67s/it][Succeeded / Failed / Skipped / Total] 166 / 44 / 2 / 212:  21%|██▏       | 213/1000 [34:17<2:06:43,  9.66s/it][Succeeded / Failed / Skipped / Total] 167 / 44 / 2 / 213:  21%|██▏       | 213/1000 [34:17<2:06:43,  9.66s/it][Succeeded / Failed / Skipped / Total] 167 / 44 / 2 / 213:  21%|██▏       | 214/1000 [34:25<2:06:26,  9.65s/it][Succeeded / Failed / Skipped / Total] 168 / 44 / 2 / 214:  21%|██▏       | 214/1000 [34:25<2:06:26,  9.65s/it][Succeeded / Failed / Skipped / Total] 168 / 44 / 2 / 214:  22%|██▏       | 215/1000 [34:34<2:06:14,  9.65s/it][Succeeded / Failed / Skipped / Total] 169 / 44 / 2 / 215:  22%|██▏       | 215/1000 [34:34<2:06:14,  9.65s/it][Succeeded / Failed / Skipped / Total] 169 / 44 / 2 / 215:  22%|██▏       | 216/1000 [34:47<2:06:16,  9.66s/it][Succeeded / Failed / Skipped / Total] 170 / 44 / 2 / 216:  22%|██▏       | 216/1000 [34:47<2:06:16,  9.66s/it][Succeeded / Failed / Skipped / Total] 170 / 44 / 2 / 216:  22%|██▏       | 217/1000 [35:00<2:06:20,  9.68s/it]--------------------------------------------- Result 211 ---------------------------------------------
Determine target URL . --> offbeat implementation --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest [[request]] , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[offbeat]] ( HttpServletRequest [[olivia]] , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 212 ---------------------------------------------
Creates the shared object map . --> Helper method for creating SharedObjects . --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[averaged]] ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
[[[[Nl]]]]: Creates the shared objects
--------------------------------------------- Result 213 ---------------------------------------------
Retrieves the directory with the given id . --> Find airbrush . --> Socre: 1.0

[[[[Adv]]]]: private Directory [[getDirectoryWithImmediateParentPopulated]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long [[parentDirectoryId]] = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( [[parentDirectoryId]] != null && ! [[parentDirectoryId]] . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory [[airbrush]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long [[firom]] = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( [[firom]] != null && ! [[firom]] . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 214 ---------------------------------------------
Internal method to parse a date . --> Utility method to parse string value --> Socre: 1.0

[[[[Adv]]]]: private static Long [[internalParseDate]] ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long [[sses]] ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 215 ---------------------------------------------
Gets the current date . --> generate greg --> Socre: 1.0

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long [[now]] = System . currentTimeMillis ( ) ; if ( ( [[now]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[now]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[now]] ; currentDate = format . format ( new Date ( [[now]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[greg]] ( ) { long [[acetone]] = System . currentTimeMillis ( ) ; if ( ( [[acetone]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[acetone]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[acetone]] ; currentDate = format . format ( new Date ( [[acetone]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 216 ---------------------------------------------
Configure JAAS authentication . --> configure jaas --> Socre: 1.0

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "[[False]]" != "[[False]]" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "[["Città" != "Città"]]" != "[["Città" != "Città"]]" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 217 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 171 / 44 / 2 / 217:  22%|██▏       | 217/1000 [35:00<2:06:20,  9.68s/it][Succeeded / Failed / Skipped / Total] 171 / 44 / 2 / 217:  22%|██▏       | 218/1000 [35:01<2:05:38,  9.64s/it][Succeeded / Failed / Skipped / Total] 172 / 44 / 2 / 218:  22%|██▏       | 218/1000 [35:01<2:05:38,  9.64s/it][Succeeded / Failed / Skipped / Total] 172 / 44 / 2 / 218:  22%|██▏       | 219/1000 [35:03<2:05:01,  9.60s/it][Succeeded / Failed / Skipped / Total] 172 / 45 / 2 / 219:  22%|██▏       | 219/1000 [35:03<2:05:01,  9.60s/it][Succeeded / Failed / Skipped / Total] 172 / 45 / 2 / 219:  22%|██▏       | 220/1000 [35:19<2:05:16,  9.64s/it][Succeeded / Failed / Skipped / Total] 173 / 45 / 2 / 220:  22%|██▏       | 220/1000 [35:19<2:05:16,  9.64s/it][Succeeded / Failed / Skipped / Total] 173 / 45 / 2 / 220:  22%|██▏       | 221/1000 [35:22<2:04:42,  9.61s/it][Succeeded / Failed / Skipped / Total] 173 / 46 / 2 / 221:  22%|██▏       | 221/1000 [35:22<2:04:42,  9.61s/it][Succeeded / Failed / Skipped / Total] 173 / 46 / 2 / 221:  22%|██▏       | 222/1000 [35:26<2:04:11,  9.58s/it][Succeeded / Failed / Skipped / Total] 174 / 46 / 2 / 222:  22%|██▏       | 222/1000 [35:26<2:04:11,  9.58s/it][Succeeded / Failed / Skipped / Total] 174 / 46 / 2 / 222:  22%|██▏       | 223/1000 [35:39<2:04:15,  9.60s/it][Succeeded / Failed / Skipped / Total] 175 / 46 / 2 / 223:  22%|██▏       | 223/1000 [35:39<2:04:15,  9.60s/it][Succeeded / Failed / Skipped / Total] 175 / 46 / 2 / 223:  22%|██▏       | 224/1000 [35:41<2:03:40,  9.56s/it][Succeeded / Failed / Skipped / Total] 175 / 47 / 2 / 224:  22%|██▏       | 224/1000 [35:41<2:03:40,  9.56s/it][Succeeded / Failed / Skipped / Total] 175 / 47 / 2 / 224:  22%|██▎       | 225/1000 [35:53<2:03:36,  9.57s/it]Updates the cache . --> update Balsa --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap [[cache]] , Object [[key]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[cache]] . size ( ) > 1000 ) { [[cache]] . clear ( ) ; } [[cache]] . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap [[booed]] , Object [[balsa]] , Object [[seesaw]] ) { if ( [[seesaw]] == null ) { return ; } if ( [[booed]] . size ( ) > 1000 ) { [[booed]] . clear ( ) ; } [[booed]] . put ( [[balsa]] , [[seesaw]] ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 218 ---------------------------------------------
Returns the list of groups associated with the specified security name . --> Extract GWT groups --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > getWebSphereGroups ( final String [[securityName]] ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > getWebSphereGroups ( final String [[badlands]] ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 219 ---------------------------------------------
Set authentication details . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[chaperone]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 220 ---------------------------------------------
Throws a SessionAuthenticationException if allowed . --> Throws a SessionAuthenticationException if allowed --> Socre: 1.0

[[[[Adv]]]]: protected void allowableSessionsExceeded ( List < SessionInformation > [[sessions]] , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[sessions]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void allowableSessionsExceeded ( List < SessionInformation > [[censured]] , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[censured]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 221 ---------------------------------------------
Determine the security name for the Subject --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String userSecurityName = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[micromachine]] ( final Subject [[wolfowitz]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[wolfowitz]] ) ; } String userSecurityName = null ; if ( [[wolfowitz]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 222 ---------------------------------------------
Changes the current user s password --> can be overwritten --> Socre: 1.0

[[[[Adv]]]]: public void [[changePassword]] ( final String oldPassword , final String newPassword ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( [[authentication]] , "No authentication object found in security context. Can't change current user's password!" ) ; String username = [[authentication]] . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void [[canapés]] ( final String oldPassword , final String newPassword ) { Authentication [[frédéric]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( [[frédéric]] , "No authentication object found in security context. Can't change current user's password!" ) ; String username = [[frédéric]] . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 223 ---------------------------------------------
Gets all filters from the URL . --> Performs an admiral request --> Socre: 1.0

[[[[Adv]]]]: public List < Filter > [[getFilters]] ( String url ) { return [[getFilters]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > [[admiral]] ( String url ) { return [[admiral]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 224 ---------------------------------------------
Build the DN for the group . --> [[[FAILED]]]

[[[[Adv]]]]: protected DistinguishedName [[buildGroupDn]] ( String group ) { DistinguishedName [[dn]] = new DistinguishedName ( groupSearchBase ) ; [[dn]] . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return [[dn]] ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName [[defaults]] ( String group ) { DistinguishedName [[aganist]] = new DistinguishedName ( groupSearchBase ) ; [[aganist]] . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return [[aganist]] ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 225 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 176 / 47 / 2 / 225:  22%|██▎       | 225/1000 [35:53<2:03:36,  9.57s/it][Succeeded / Failed / Skipped / Total] 176 / 47 / 2 / 225:  23%|██▎       | 226/1000 [36:03<2:03:28,  9.57s/it][Succeeded / Failed / Skipped / Total] 177 / 47 / 2 / 226:  23%|██▎       | 226/1000 [36:03<2:03:28,  9.57s/it][Succeeded / Failed / Skipped / Total] 177 / 47 / 2 / 226:  23%|██▎       | 227/1000 [36:17<2:03:36,  9.59s/it][Succeeded / Failed / Skipped / Total] 178 / 47 / 2 / 227:  23%|██▎       | 227/1000 [36:17<2:03:36,  9.59s/it][Succeeded / Failed / Skipped / Total] 178 / 47 / 2 / 227:  23%|██▎       | 228/1000 [36:18<2:02:57,  9.56s/it][Succeeded / Failed / Skipped / Total] 179 / 47 / 2 / 228:  23%|██▎       | 228/1000 [36:18<2:02:57,  9.56s/it][Succeeded / Failed / Skipped / Total] 179 / 47 / 2 / 228:  23%|██▎       | 229/1000 [36:32<2:03:00,  9.57s/it][Succeeded / Failed / Skipped / Total] 180 / 47 / 2 / 229:  23%|██▎       | 229/1000 [36:32<2:03:00,  9.57s/it][Succeeded / Failed / Skipped / Total] 180 / 47 / 2 / 229:  23%|██▎       | 230/1000 [36:40<2:02:48,  9.57s/it][Succeeded / Failed / Skipped / Total] 181 / 47 / 2 / 230:  23%|██▎       | 230/1000 [36:40<2:02:48,  9.57s/it][Succeeded / Failed / Skipped / Total] 181 / 47 / 2 / 230:  23%|██▎       | 231/1000 [36:43<2:02:14,  9.54s/it][Succeeded / Failed / Skipped / Total] 182 / 47 / 2 / 231:  23%|██▎       | 231/1000 [36:43<2:02:14,  9.54s/it][Succeeded / Failed / Skipped / Total] 182 / 47 / 2 / 231:  23%|██▎       | 232/1000 [36:46<2:01:44,  9.51s/it][Succeeded / Failed / Skipped / Total] 183 / 47 / 2 / 232:  23%|██▎       | 232/1000 [36:46<2:01:44,  9.51s/it][Succeeded / Failed / Skipped / Total] 183 / 47 / 2 / 232:  23%|██▎       | 233/1000 [36:59<2:01:47,  9.53s/it]Get the filters for the given request . --> Searches for a given request --> Socre: 1.0

[[[[Adv]]]]: private List < Filter > [[getFilters]] ( HttpServletRequest request ) { for ( SecurityFilterChain [[chain]] : filterChains ) { if ( [[chain]] . matches ( request ) ) { return [[chain]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > [[novick]] ( HttpServletRequest request ) { for ( SecurityFilterChain [[racketeering]] : filterChains ) { if ( [[racketeering]] . matches ( request ) ) { return [[racketeering]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 226 ---------------------------------------------
Copies details from src to dest . --> helper method for prewax --> Socre: 1.0

[[[[Adv]]]]: private void [[copyDetails]] ( Authentication source , Authentication [[dest]] ) { if ( ( [[dest]] instanceof AbstractAuthenticationToken ) && ( [[dest]] . getDetails ( ) == null ) ) { AbstractAuthenticationToken [[token]] = ( AbstractAuthenticationToken ) [[dest]] ; [[token]] . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void [[beeswax]] ( Authentication source , Authentication [[cafer]] ) { if ( ( [[cafer]] instanceof AbstractAuthenticationToken ) && ( [[cafer]] . getDetails ( ) == null ) ) { AbstractAuthenticationToken [[paparazzo]] = ( AbstractAuthenticationToken ) [[cafer]] ; [[paparazzo]] . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 227 ---------------------------------------------
Returns the application context for the given page context . --> do the doug --> Socre: 1.0

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext [[pageContext]] ) { ServletContext [[servletContext]] = [[pageContext]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[servletContext]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[doug]] ( PageContext [[creaking]] ) { ServletContext [[città]] = [[creaking]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[città]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
--------------------------------------------- Result 228 ---------------------------------------------
Specifies a basic authentication scheme . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public AuthenticationScheme [[basic]] ( String userName , String password ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( userName ) ; preemptiveBasicAuthScheme . setPassword ( password ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme [[canapés]] ( String userName , String password ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( userName ) ; preemptiveBasicAuthScheme . setPassword ( password ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 229 ---------------------------------------------
Update session attributes . --> This method will be called from the MockServletRequest --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > [[sessionAttributes]] ) { notNull ( [[sessionAttributes]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[sessionAttributes]] , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[ripping]] ( Map < String , Object > [[sorceress]] ) { notNull ( [[sorceress]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[sorceress]] , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 230 ---------------------------------------------
Returns the full DN of the given dn . --> this will only be appended --> Socre: 1.0

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName [[dn]] , Context [[baseCtx]] ) throws NamingException { DistinguishedName [[baseDn]] = new DistinguishedName ( [[baseCtx]] . getNameInNamespace ( ) ) ; if ( [[dn]] . contains ( [[baseDn]] ) ) { return [[dn]] ; } [[baseDn]] . append ( [[dn]] ) ; return [[baseDn]] ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[apprised]] ( DistinguishedName [[splendour]] , Context [[deletion]] ) throws NamingException { DistinguishedName [[foreign]] = new DistinguishedName ( [[deletion]] . getNameInNamespace ( ) ) ; if ( [[splendour]] . contains ( [[foreign]] ) ) { return [[splendour]] ; } [[foreign]] . append ( [[splendour]] ) ; return [[foreign]] ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 231 ---------------------------------------------
Add custom filters . --> Register a filter list --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > [[filters]] ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[lynde]] ( List < Filter > [[ackerman]] ) { Validate . notNull ( [[lynde]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[lynde]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 232 ---------------------------------------------
Adds additional filters . --> Gets the agnals with all the values in the solver --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( Filter [[filter]] , Filter ... additionalFilters ) { Validate . notNull ( [[filter]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[filter]] ) ; if ( additionalFilters != null ) { Collections . addAll ( RestAssured . filters , additionalFilters ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void [[agnès]] ( Filter [[clu]] , Filter ... additionalFilters ) { Validate . notNull ( [[clu]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[clu]] ) ; if ( additionalFilters != null ) { Collections . addAll ( RestAssured . filters , additionalFilters ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 233 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 184 / 47 / 2 / 233:  23%|██▎       | 233/1000 [36:59<2:01:47,  9.53s/it][Succeeded / Failed / Skipped / Total] 184 / 47 / 2 / 233:  23%|██▎       | 234/1000 [37:36<2:03:07,  9.64s/it][Succeeded / Failed / Skipped / Total] 184 / 48 / 2 / 234:  23%|██▎       | 234/1000 [37:36<2:03:07,  9.64s/it][Succeeded / Failed / Skipped / Total] 184 / 48 / 2 / 234:  24%|██▎       | 235/1000 [37:40<2:02:37,  9.62s/it][Succeeded / Failed / Skipped / Total] 185 / 48 / 2 / 235:  24%|██▎       | 235/1000 [37:40<2:02:37,  9.62s/it][Succeeded / Failed / Skipped / Total] 185 / 48 / 2 / 235:  24%|██▎       | 236/1000 [37:57<2:02:51,  9.65s/it][Succeeded / Failed / Skipped / Total] 186 / 48 / 2 / 236:  24%|██▎       | 236/1000 [37:57<2:02:51,  9.65s/it][Succeeded / Failed / Skipped / Total] 186 / 48 / 2 / 236:  24%|██▎       | 237/1000 [37:58<2:02:14,  9.61s/it][Succeeded / Failed / Skipped / Total] 186 / 49 / 2 / 237:  24%|██▎       | 237/1000 [37:58<2:02:14,  9.61s/it][Succeeded / Failed / Skipped / Total] 186 / 49 / 2 / 237:  24%|██▍       | 238/1000 [38:09<2:02:09,  9.62s/it][Succeeded / Failed / Skipped / Total] 186 / 50 / 2 / 238:  24%|██▍       | 238/1000 [38:09<2:02:09,  9.62s/it][Succeeded / Failed / Skipped / Total] 186 / 50 / 2 / 238:  24%|██▍       | 239/1000 [38:13<2:01:41,  9.59s/it]Configures the proxy to use . --> Static factory method for farmppings --> Socre: 1.0

[[[[Adv]]]]: public static void [[proxy]] ( URI uri ) { if ( uri == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxy]] ( new ProxySpecification ( uri . getHost ( ) , uri . getPort ( ) , uri . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void [[farmhands]] ( URI uri ) { if ( uri == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[farmhands]] ( new ProxySpecification ( uri . getHost ( ) , uri . getPort ( ) , uri . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 234 ---------------------------------------------
Returns a basic authentication scheme with the given user name and password . --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[basic]] ( String userName , String [[password]] ) { final BasicAuthScheme scheme = new BasicAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( [[password]] ) ; return scheme ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[streep]] ( String userName , String [[attendants]] ) { final BasicAuthScheme scheme = new BasicAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( [[attendants]] ) ; return scheme ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 235 ---------------------------------------------
Print the response to the stream . --> Generates an HTML file . --> Socre: 1.0

[[[[Adv]]]]: public static String [[print]] ( ResponseOptions responseOptions , ResponseBody [[responseBody]] , PrintStream stream , LogDetail [[logDetail]] , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( [[logDetail]] == ALL || [[logDetail]] == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( [[logDetail]] == ALL || [[logDetail]] == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( [[logDetail]] , builder ) . append ( toString ( headers ) ) ; } } else if ( [[logDetail]] == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( [[logDetail]] , builder ) . append ( cookies . toString ( ) ) ; } } if ( [[logDetail]] == ALL || [[logDetail]] == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , [[responseBody]] ) ; } else { responseBodyToAppend = [[responseBody]] . asString ( ) ; } if ( [[logDetail]] == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String [[assets]] ( ResponseOptions responseOptions , ResponseBody [[chivas]] , PrintStream stream , LogDetail [[fogarty]] , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( [[fogarty]] == ALL || [[fogarty]] == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( [[fogarty]] == ALL || [[fogarty]] == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( [[fogarty]] , builder ) . append ( toString ( headers ) ) ; } } else if ( [[fogarty]] == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( [[fogarty]] , builder ) . append ( cookies . toString ( ) ) ; } } if ( [[fogarty]] == ALL || [[fogarty]] == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , [[chivas]] ) ; } else { responseBodyToAppend = [[chivas]] . asString ( ) ; } if ( [[fogarty]] == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 236 ---------------------------------------------
Default default charset . --> Configures this encoder . --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , True ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[bombardments]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , True ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 237 ---------------------------------------------
Returns a new authentication scheme with the given username and password . --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[form]] ( String userName , String [[password]] , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( [[password]] == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( [[password]] ) ; scheme . setConfig ( config ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme [[recitation]] ( String userName , String [[protector]] , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( [[protector]] == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( [[protector]] ) ; scheme . setConfig ( config ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 238 ---------------------------------------------
Creates an NTLM authentication scheme . --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[ntlm]] ( String userName , String password , String workstation , String [[domain]] ) { final NTLMAuthScheme [[scheme]] = new NTLMAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( password ) ; [[scheme]] . setWorkstation ( workstation ) ; [[scheme]] . setDomain ( [[domain]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[dissapeared]] ( String userName , String password , String workstation , String [[bentley]] ) { final NTLMAuthScheme [[fads]] = new NTLMAuthScheme ( ) ; [[fads]] . setUserName ( userName ) ; [[fads]] . setPassword ( password ) ; [[fads]] . setWorkstation ( workstation ) ; [[fads]] . setDomain ( [[bentley]] ) ; return [[fads]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 239 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 187 / 50 / 2 / 239:  24%|██▍       | 239/1000 [38:13<2:01:41,  9.59s/it][Succeeded / Failed / Skipped / Total] 187 / 50 / 2 / 239:  24%|██▍       | 240/1000 [38:13<2:01:02,  9.56s/it][Succeeded / Failed / Skipped / Total] 188 / 50 / 2 / 240:  24%|██▍       | 240/1000 [38:13<2:01:02,  9.56s/it][Succeeded / Failed / Skipped / Total] 188 / 50 / 2 / 240:  24%|██▍       | 241/1000 [38:23<2:00:53,  9.56s/it][Succeeded / Failed / Skipped / Total] 189 / 50 / 2 / 241:  24%|██▍       | 241/1000 [38:23<2:00:53,  9.56s/it][Succeeded / Failed / Skipped / Total] 189 / 50 / 2 / 241:  24%|██▍       | 242/1000 [38:30<2:00:38,  9.55s/it][Succeeded / Failed / Skipped / Total] 190 / 50 / 2 / 242:  24%|██▍       | 242/1000 [38:30<2:00:38,  9.55s/it][Succeeded / Failed / Skipped / Total] 190 / 50 / 2 / 242:  24%|██▍       | 243/1000 [38:41<2:00:30,  9.55s/it][Succeeded / Failed / Skipped / Total] 191 / 50 / 2 / 243:  24%|██▍       | 243/1000 [38:41<2:00:30,  9.55s/it][Succeeded / Failed / Skipped / Total] 191 / 50 / 2 / 243:  24%|██▍       | 244/1000 [38:42<1:59:54,  9.52s/it][Succeeded / Failed / Skipped / Total] 192 / 50 / 2 / 244:  24%|██▍       | 244/1000 [38:42<1:59:54,  9.52s/it][Succeeded / Failed / Skipped / Total] 192 / 50 / 2 / 244:  24%|██▍       | 245/1000 [38:56<1:59:58,  9.53s/it][Succeeded / Failed / Skipped / Total] 193 / 50 / 2 / 245:  24%|██▍       | 245/1000 [38:56<1:59:58,  9.53s/it][Succeeded / Failed / Skipped / Total] 193 / 50 / 2 / 245:  25%|██▍       | 246/1000 [38:56<1:59:22,  9.50s/it]Restrict configuration . --> Creates a RestAssuredConfig with RedirectConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig [[redirectConfig]] ) { notNull ( [[redirectConfig]] , "Redirect config" ) ; return new RestAssuredConfig ( [[redirectConfig]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[avenida]] ( RedirectConfig [[baldie]] ) { notNull ( [[baldie]] , "Redirect config" ) ; return new RestAssuredConfig ( [[baldie]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 240 ---------------------------------------------
Define the default object mapper configuration . --> Overcharge of this class --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , True ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[overcharge]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[overcharge]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , True ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 241 ---------------------------------------------
Configure the log configuration . --> used by rest --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[logConfig]] ( LogConfig logConfig ) { notNull ( [[logConfig]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[logConfig]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[afforded]] ( LogConfig logConfig ) { notNull ( [[afforded]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[afforded]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 242 ---------------------------------------------
Configure the ObjectMapper to use with Jackson . --> jaxbObjectMapperFactory --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig jaxbObjectMapperFactory ( JAXBObjectMapperFactory [[jaxbObjectMapperFactory]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig jaxbObjectMapperFactory ( JAXBObjectMapperFactory [[grasse]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "[["Cantor" == "Cantor"]]" == "[["Cantor" == "Cantor"]]" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 243 ---------------------------------------------
Configured object mapper config . --> Creates mock configuration for mock mock configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[objectMapperConfig]] ( ObjectMapperConfig objectMapperConfig ) { notNull ( [[objectMapperConfig]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[objectMapperConfig]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[smoked]] ( ObjectMapperConfig objectMapperConfig ) { notNull ( [[smoked]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[smoked]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 244 ---------------------------------------------
Configured mock mvc config . --> Define mock configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[sessionConfig]] ( SessionConfig [[sessionConfig]] ) { notNull ( [[sessionConfig]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[sessionConfig]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[lambada]] ( SessionConfig [[clinics]] ) { notNull ( [[lambada]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[lambada]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 245 ---------------------------------------------
Configure mock mvc config . --> Configured mvc . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig headerConfig ( HeaderConfig [[headerConfig]] ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config

[[[[Adv]]]]: public RestAssuredMockMvcConfig headerConfig ( HeaderConfig [[aside]] ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 246 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 194 / 50 / 2 / 246:  25%|██▍       | 246/1000 [38:56<1:59:22,  9.50s/it][Succeeded / Failed / Skipped / Total] 194 / 50 / 2 / 246:  25%|██▍       | 247/1000 [38:58<1:58:47,  9.47s/it][Succeeded / Failed / Skipped / Total] 194 / 51 / 2 / 247:  25%|██▍       | 247/1000 [38:58<1:58:47,  9.47s/it][Succeeded / Failed / Skipped / Total] 194 / 51 / 2 / 247:  25%|██▍       | 248/1000 [39:10<1:58:46,  9.48s/it][Succeeded / Failed / Skipped / Total] 195 / 51 / 2 / 248:  25%|██▍       | 248/1000 [39:10<1:58:46,  9.48s/it][Succeeded / Failed / Skipped / Total] 195 / 51 / 2 / 248:  25%|██▍       | 249/1000 [39:10<1:58:09,  9.44s/it][Succeeded / Failed / Skipped / Total] 196 / 51 / 2 / 249:  25%|██▍       | 249/1000 [39:10<1:58:09,  9.44s/it][Succeeded / Failed / Skipped / Total] 196 / 51 / 2 / 249:  25%|██▌       | 250/1000 [39:10<1:57:32,  9.40s/it][Succeeded / Failed / Skipped / Total] 197 / 51 / 2 / 250:  25%|██▌       | 250/1000 [39:10<1:57:32,  9.40s/it][Succeeded / Failed / Skipped / Total] 197 / 51 / 2 / 250:  25%|██▌       | 251/1000 [39:13<1:57:01,  9.38s/it][Succeeded / Failed / Skipped / Total] 198 / 51 / 2 / 251:  25%|██▌       | 251/1000 [39:13<1:57:01,  9.38s/it][Succeeded / Failed / Skipped / Total] 198 / 51 / 2 / 251:  25%|██▌       | 252/1000 [39:23<1:56:56,  9.38s/it][Succeeded / Failed / Skipped / Total] 199 / 51 / 2 / 252:  25%|██▌       | 252/1000 [39:23<1:56:56,  9.38s/it][Succeeded / Failed / Skipped / Total] 199 / 51 / 2 / 252:  25%|██▌       | 253/1000 [39:25<1:56:24,  9.35s/it][Succeeded / Failed / Skipped / Total] 200 / 51 / 2 / 253:  25%|██▌       | 253/1000 [39:25<1:56:24,  9.35s/it][Succeeded / Failed / Skipped / Total] 200 / 51 / 2 / 253:  25%|██▌       | 254/1000 [39:41<1:56:35,  9.38s/it]Configured mvc config . --> FIXME Unhack configuration --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[jsonConfig]] ( JsonConfig [[jsonConfig]] ) { notNull ( [[jsonConfig]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[jsonConfig]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[woodsmen]] ( JsonConfig [[accused]] ) { notNull ( [[woodsmen]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[woodsmen]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 247 ---------------------------------------------
Configured mvc config . --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[xmlConfig]] ( XmlConfig [[xmlConfig]] ) { notNull ( [[xmlConfig]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[xmlConfig]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[gallic]] ( XmlConfig [[spring]] ) { notNull ( [[gallic]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[gallic]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 248 ---------------------------------------------
Use RestAssured mvc config . --> Build mock configuration . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig mockMvcConfig ( MockMvcConfig [[mockMvcConfig]] ) { notNull ( mockMvcConfig , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config

[[[[Adv]]]]: public RestAssuredMockMvcConfig mockMvcConfig ( MockMvcConfig [[astounded]] ) { notNull ( mockMvcConfig , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 249 ---------------------------------------------
Configure the encoder config . --> Configure caffured mapper . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[encoderConfig]] ( EncoderConfig [[encoderConfig]] ) { notNull ( [[encoderConfig]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[encoderConfig]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[caffee]] ( EncoderConfig [[okura]] ) { notNull ( [[caffee]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[caffee]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 250 ---------------------------------------------
Configure the mock configuration . --> Configure mock configuration . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[asyncConfig]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[excuses]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 251 ---------------------------------------------
Configure a multi - part configuration . --> Configure mock behavior . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[multiPartConfig]] ( MultiPartConfig multiPartConfig ) { notNull ( [[multiPartConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[multiPartConfig]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[beagle]] ( MultiPartConfig multiPartConfig ) { notNull ( [[beagle]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[beagle]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 252 ---------------------------------------------
Configured mock mvc config . --> Custom mock configuration . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig [[paramConfig]] ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config

[[[[Adv]]]]: public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig [[annum]] ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 253 ---------------------------------------------
Allow all hostnames . --> Set certificate auth settings --> Socre: 1.0

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[afterwards]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 254 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 201 / 51 / 2 / 254:  25%|██▌       | 254/1000 [39:41<1:56:35,  9.38s/it][Succeeded / Failed / Skipped / Total] 201 / 51 / 2 / 254:  26%|██▌       | 255/1000 [39:42<1:55:59,  9.34s/it][Succeeded / Failed / Skipped / Total] 201 / 52 / 2 / 255:  26%|██▌       | 255/1000 [39:42<1:55:59,  9.34s/it][Succeeded / Failed / Skipped / Total] 201 / 52 / 2 / 255:  26%|██▌       | 256/1000 [39:54<1:56:00,  9.36s/it][Succeeded / Failed / Skipped / Total] 202 / 52 / 2 / 256:  26%|██▌       | 256/1000 [39:54<1:56:00,  9.36s/it][Succeeded / Failed / Skipped / Total] 202 / 52 / 2 / 256:  26%|██▌       | 257/1000 [40:37<1:57:28,  9.49s/it][Succeeded / Failed / Skipped / Total] 203 / 52 / 2 / 257:  26%|██▌       | 257/1000 [40:37<1:57:28,  9.49s/it][Succeeded / Failed / Skipped / Total] 203 / 52 / 2 / 257:  26%|██▌       | 258/1000 [40:38<1:56:54,  9.45s/it][Succeeded / Failed / Skipped / Total] 203 / 53 / 2 / 258:  26%|██▌       | 258/1000 [40:38<1:56:54,  9.45s/it][Succeeded / Failed / Skipped / Total] 203 / 53 / 2 / 258:  26%|██▌       | 259/1000 [40:52<1:56:56,  9.47s/it][Succeeded / Failed / Skipped / Total] 204 / 53 / 2 / 259:  26%|██▌       | 259/1000 [40:52<1:56:56,  9.47s/it][Succeeded / Failed / Skipped / Total] 204 / 53 / 2 / 259:  26%|██▌       | 260/1000 [40:56<1:56:32,  9.45s/it][Succeeded / Failed / Skipped / Total] 205 / 53 / 2 / 260:  26%|██▌       | 260/1000 [40:56<1:56:32,  9.45s/it][Succeeded / Failed / Skipped / Total] 205 / 53 / 2 / 260:  26%|██▌       | 261/1000 [41:06<1:56:22,  9.45s/it][Succeeded / Failed / Skipped / Total] 206 / 53 / 2 / 261:  26%|██▌       | 261/1000 [41:06<1:56:22,  9.45s/it][Succeeded / Failed / Skipped / Total] 206 / 53 / 2 / 261:  26%|██▌       | 262/1000 [41:16<1:56:14,  9.45s/it]Configured matcher configuration . --> Defines a RestAssuredMockConfig . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[matcherConfig]] ( MatcherConfig [[matcherConfig]] ) { notNull ( [[matcherConfig]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[matcherConfig]] ) ; }
[[[[Nl]]]]: Set the matcher config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[anything]] ( MatcherConfig [[none]] ) { notNull ( [[anything]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[anything]] ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 255 ---------------------------------------------
Declares the given namespaces . --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig [[declareNamespaces]] ( Map < String , String > [[namespacesToDeclare]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[namespacesToDeclare]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig [[nehru]] ( Map < String , String > [[andthen]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[andthen]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 256 ---------------------------------------------
Set proxy . --> Expresses enve --> Socre: 1.0

[[[[Adv]]]]: public void [[setProxy]] ( String host , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[rêve]] ( String host , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 257 ---------------------------------------------
Do a HTTP request . --> Perform a whitelock operation --> Socre: 1.0

[[[[Adv]]]]: public Object [[request]] ( String method , boolean [[hasBody]] , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . [[defaultContentType]] , [[hasBody]] , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object [[whitlock]] ( String method , boolean [[barra]] , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . [[bernd]] , [[barra]] , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 258 ---------------------------------------------
Creates a new configuration with the given namespace . --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig [[declaredNamespace]] ( String [[prefix]] , String namespaceURI ) { Validate . notEmpty ( [[prefix]] , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > [[updatedNamespaces]] = new HashMap < String , String > ( declaredNamespaces ) ; [[updatedNamespaces]] . put ( [[prefix]] , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[updatedNamespaces]] , properties , validating , "[[True]]" == "[[True]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig [[detachable]] ( String [[infancy]] , String namespaceURI ) { Validate . notEmpty ( [[infancy]] , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > [[radios]] = new HashMap < String , String > ( declaredNamespaces ) ; [[radios]] . put ( [[infancy]] , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[radios]] , properties , validating , "[["Phew" == "Phew"]]" == "[["Phew" == "Phew"]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 259 ---------------------------------------------
Sets the control name . --> Shortcut method --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[controlName]] ( String [[controlName]] ) { Validate . notEmpty ( [[controlName]] , "Control name cannot be empty" ) ; this . controlName = [[controlName]] ; this . [[isControlNameExplicit]] = "[[True]]" == "[[True]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder [[wristband]] ( String [[guv]] ) { Validate . notEmpty ( [[wristband]] , "Control name cannot be empty" ) ; this . controlName = [[wristband]] ; this . [[desecrated]] = "[["Danube" == "Danube"]]" == "[["Danube" == "Danube"]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 260 ---------------------------------------------
Set the Map of headers . --> Sets giulio banners --> Socre: 1.0

[[[[Adv]]]]: public void [[setHeaders]] ( Map < ? , ? > headers ) { this . [[defaultRequestHeaders]] . clear ( ) ; if ( headers == null ) return ; for ( Object [[key]] : headers . keySet ( ) ) { Object val = headers . get ( [[key]] ) ; if ( val == null ) continue ; this . [[defaultRequestHeaders]] . put ( [[key]] . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void [[giulio]] ( Map < ? , ? > headers ) { this . [[banners]] . clear ( ) ; if ( headers == null ) return ; for ( Object [[silenzio]] : headers . keySet ( ) ) { Object val = headers . get ( [[silenzio]] ) ; if ( val == null ) continue ; this . [[banners]] . put ( [[silenzio]] . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 261 ---------------------------------------------
Configure an NTLM --> Configure cgi --> Socre: 1.0

[[[[Adv]]]]: public void [[ntlm]] ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[cgi]] ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 262 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 207 / 53 / 2 / 262:  26%|██▌       | 262/1000 [41:16<1:56:14,  9.45s/it][Succeeded / Failed / Skipped / Total] 207 / 53 / 2 / 262:  26%|██▋       | 263/1000 [41:18<1:55:46,  9.43s/it][Succeeded / Failed / Skipped / Total] 207 / 54 / 2 / 263:  26%|██▋       | 263/1000 [41:18<1:55:46,  9.43s/it][Succeeded / Failed / Skipped / Total] 207 / 54 / 2 / 263:  26%|██▋       | 264/1000 [41:28<1:55:37,  9.43s/it][Succeeded / Failed / Skipped / Total] 208 / 54 / 2 / 264:  26%|██▋       | 264/1000 [41:28<1:55:37,  9.43s/it][Succeeded / Failed / Skipped / Total] 208 / 54 / 2 / 264:  26%|██▋       | 265/1000 [41:30<1:55:07,  9.40s/it][Succeeded / Failed / Skipped / Total] 209 / 54 / 2 / 265:  26%|██▋       | 265/1000 [41:30<1:55:07,  9.40s/it][Succeeded / Failed / Skipped / Total] 209 / 54 / 2 / 265:  27%|██▋       | 266/1000 [41:38<1:54:53,  9.39s/it][Succeeded / Failed / Skipped / Total] 210 / 54 / 2 / 266:  27%|██▋       | 266/1000 [41:38<1:54:53,  9.39s/it][Succeeded / Failed / Skipped / Total] 210 / 54 / 2 / 266:  27%|██▋       | 267/1000 [41:46<1:54:41,  9.39s/it][Succeeded / Failed / Skipped / Total] 211 / 54 / 2 / 267:  27%|██▋       | 267/1000 [41:46<1:54:41,  9.39s/it][Succeeded / Failed / Skipped / Total] 211 / 54 / 2 / 267:  27%|██▋       | 268/1000 [42:01<1:54:48,  9.41s/it][Succeeded / Failed / Skipped / Total] 211 / 55 / 2 / 268:  27%|██▋       | 268/1000 [42:01<1:54:48,  9.41s/it][Succeeded / Failed / Skipped / Total] 211 / 55 / 2 / 268:  27%|██▋       | 269/1000 [42:04<1:54:20,  9.38s/it][Succeeded / Failed / Skipped / Total] 211 / 56 / 2 / 269:  27%|██▋       | 269/1000 [42:04<1:54:20,  9.38s/it][Succeeded / Failed / Skipped / Total] 211 / 56 / 2 / 269:  27%|██▋       | 270/1000 [42:07<1:53:53,  9.36s/it]Sets basic authentication . --> Clears a Fernet password --> Socre: 1.0

[[[[Adv]]]]: public void [[basic]] ( String host , int [[port]] , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[port]] ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[haze]] ( String host , int [[flamethrower]] , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[flamethrower]] ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 263 ---------------------------------------------
Resets the context . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[reset]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void [[sufficiency]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 264 ---------------------------------------------
Adds a header to the request . --> Sets the alsace with the specified balt and octagon name --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String [[name]] , String [[value]] ) { Validate . notEmpty ( [[name]] , "Header name cannot be empty" ) ; Validate . notEmpty ( [[value]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[alsace]] ( String [[baltic]] , String [[octagon]] ) { Validate . notEmpty ( [[baltic]] , "Header name cannot be empty" ) ; Validate . notEmpty ( [[octagon]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 265 ---------------------------------------------
Sets header . --> Sets response headers . --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder [[setHeader]] ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder [[beepers]] ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 266 ---------------------------------------------
Create headers . --> Convenience factory method --> Socre: 1.0

[[[[Adv]]]]: public static Headers headers ( Header [[header]] , Header ... [[additionalHeaders]] ) { notNull ( [[header]] , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( [[header]] ) ; if ( [[additionalHeaders]] != null ) { Collections . addAll ( headerList , [[additionalHeaders]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers headers ( Header [[fishermen]] , Header ... [[longhorns]] ) { notNull ( [[fishermen]] , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( [[fishermen]] ) ; if ( [[longhorns]] != null ) { Collections . addAll ( headerList , [[longhorns]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 267 ---------------------------------------------
Build response . --> Sets cropping status code . --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int [[statusCode]] = restAssuredResponse . statusCode ( ) ; if ( [[statusCode]] < 100 || [[statusCode]] >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , [[statusCode]] ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[croaking]] ( ) { final int [[jaywalking]] = restAssuredResponse . statusCode ( ) ; if ( [[jaywalking]] < 100 || [[jaywalking]] >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , [[jaywalking]] ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 268 ---------------------------------------------
Applies a comment that matches the given comment node . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[comment]] ( Matcher < ? super String > [[commentMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[commentMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[parachutist]] ( Matcher < ? super String > [[tramples]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[tramples]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 269 ---------------------------------------------
Matches the cookie with the given value . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > [[valueMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[valueMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[pharmacology]] ( Matcher < ? super String > [[amazon]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[amazon]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 211 / 57 / 2 / 270:  27%|██▋       | 270/1000 [42:07<1:53:53,  9.36s/it][Succeeded / Failed / Skipped / Total] 211 / 57 / 2 / 270:  27%|██▋       | 271/1000 [42:13<1:53:34,  9.35s/it][Succeeded / Failed / Skipped / Total] 212 / 57 / 2 / 271:  27%|██▋       | 271/1000 [42:13<1:53:34,  9.35s/it][Succeeded / Failed / Skipped / Total] 212 / 57 / 2 / 271:  27%|██▋       | 272/1000 [42:30<1:53:45,  9.38s/it][Succeeded / Failed / Skipped / Total] 212 / 58 / 2 / 272:  27%|██▋       | 272/1000 [42:30<1:53:45,  9.38s/it][Succeeded / Failed / Skipped / Total] 212 / 58 / 2 / 272:  27%|██▋       | 273/1000 [42:36<1:53:27,  9.36s/it][Succeeded / Failed / Skipped / Total] 213 / 58 / 2 / 273:  27%|██▋       | 273/1000 [42:36<1:53:27,  9.36s/it][Succeeded / Failed / Skipped / Total] 213 / 58 / 2 / 273:  27%|██▋       | 274/1000 [42:38<1:53:00,  9.34s/it][Succeeded / Failed / Skipped / Total] 214 / 58 / 2 / 274:  27%|██▋       | 274/1000 [42:38<1:53:00,  9.34s/it][Succeeded / Failed / Skipped / Total] 214 / 58 / 2 / 274:  28%|██▊       | 275/1000 [42:43<1:52:37,  9.32s/it][Succeeded / Failed / Skipped / Total] 214 / 59 / 2 / 275:  28%|██▊       | 275/1000 [42:43<1:52:37,  9.32s/it][Succeeded / Failed / Skipped / Total] 214 / 59 / 2 / 275:  28%|██▊       | 276/1000 [42:58<1:52:43,  9.34s/it][Succeeded / Failed / Skipped / Total] 215 / 59 / 2 / 276:  28%|██▊       | 276/1000 [42:58<1:52:43,  9.34s/it][Succeeded / Failed / Skipped / Total] 215 / 59 / 2 / 276:  28%|██▊       | 277/1000 [43:10<1:52:40,  9.35s/it][Succeeded / Failed / Skipped / Total] 216 / 59 / 2 / 277:  28%|██▊       | 277/1000 [43:10<1:52:40,  9.35s/it][Succeeded / Failed / Skipped / Total] 216 / 59 / 2 / 277:  28%|██▊       | 278/1000 [43:20<1:52:32,  9.35s/it][Succeeded / Failed / Skipped / Total] 217 / 59 / 2 / 278:  28%|██▊       | 278/1000 [43:20<1:52:32,  9.35s/it][Succeeded / Failed / Skipped / Total] 217 / 59 / 2 / 278:  28%|██▊       | 279/1000 [43:21<1:52:02,  9.32s/it][Succeeded / Failed / Skipped / Total] 217 / 60 / 2 / 279:  28%|██▊       | 279/1000 [43:21<1:52:02,  9.32s/it][Succeeded / Failed / Skipped / Total] 217 / 60 / 2 / 279:  28%|██▊       | 280/1000 [43:27<1:51:45,  9.31s/it][Succeeded / Failed / Skipped / Total] 217 / 61 / 2 / 280:  28%|██▊       | 280/1000 [43:27<1:51:45,  9.31s/it][Succeeded / Failed / Skipped / Total] 217 / 61 / 2 / 280:  28%|██▊       | 281/1000 [43:28<1:51:13,  9.28s/it]Matches a cookie by expiry date . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher expiryDate ( Matcher < ? super Date > [[expiryDateMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[expiryDateMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher expiryDate ( Matcher < ? super Date > [[brunette]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[brunette]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 271 ---------------------------------------------
Matches the cookie with the given matcher . --> Matches a campaign --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[domain]] ( Matcher < ? super String > [[domainMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[domainMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[buckskin]] ( Matcher < ? super String > [[campaign]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[campaign]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 272 ---------------------------------------------
Returns a cookie matcher that matches a given path . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[path]] ( Matcher < ? super String > [[pathMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[pathMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[noël]] ( Matcher < ? super String > [[ramos]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[ramos]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 273 ---------------------------------------------
Applies a given matcher to this cookie . --> Converts a Detailed CookieMatcher to a DetectorMatcher --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > [[httpOnlyMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[httpOnlyMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[youíre]] ( Matcher < ? super Boolean > [[alitalia]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[alitalia]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 274 ---------------------------------------------
Matches a cookie that is secured . --> Methode permettant dasetrie Methode --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[secured]] ( Matcher < ? super Boolean > [[securedMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[securedMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[acute]] ( Matcher < ? super Boolean > [[kerrigan]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[kerrigan]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 275 ---------------------------------------------
Returns a cookie matcher that matches the given version . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[version]] ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[croker]] ( Matcher < ? super Integer > [[facilitate]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[facilitate]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 276 ---------------------------------------------
Matches the given maximum age . --> Ensure that the caching header is enabled --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > [[maxAgeMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[maxAgeMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[barricade]] ( Matcher < ? super Integer > [[dishcloth]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[dishcloth]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 277 ---------------------------------------------
Expect the response header with the expected value . --> switches to hamma spec --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String headerName , String [[expectedValue]] ) { spec . header ( headerName , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[ahí]] ( String headerName , String [[allí]] ) { spec . header ( headerName , [[allí]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 278 ---------------------------------------------
Expect the response header to contain an expected value . --> Overcompatibility method --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , Matcher < String > [[expectedValueMatcher]] ) { spec . header ( [[headerName]] , [[expectedValueMatcher]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder [[overcompensating]] ( String [[ultimatums]] , Matcher < String > [[flamethrower]] ) { spec . header ( [[ultimatums]] , [[flamethrower]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 279 ---------------------------------------------
Expect the given cookie with the given name . --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder [[expectCookie]] ( String [[cookieName]] , String expectedValue ) { spec . cookie ( [[cookieName]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[alsace]] ( String [[kelvin]] , String expectedValue ) { spec . cookie ( [[kelvin]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 280 ---------------------------------------------
Returns a proxy specification that mirrors the specified host . --> [[[FAILED]]]

[[[[Adv]]]]: public ProxySpecification withHost ( String [[host]] ) { return new ProxySpecification ( [[host]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification withHost ( String [[luciano]] ) { return new ProxySpecification ( [[luciano]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 281 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 218 / 61 / 2 / 281:  28%|██▊       | 281/1000 [43:28<1:51:13,  9.28s/it][Succeeded / Failed / Skipped / Total] 218 / 61 / 2 / 281:  28%|██▊       | 282/1000 [43:45<1:51:23,  9.31s/it][Succeeded / Failed / Skipped / Total] 219 / 61 / 2 / 282:  28%|██▊       | 282/1000 [43:45<1:51:23,  9.31s/it][Succeeded / Failed / Skipped / Total] 219 / 61 / 2 / 282:  28%|██▊       | 283/1000 [43:50<1:51:03,  9.29s/it][Succeeded / Failed / Skipped / Total] 219 / 62 / 2 / 283:  28%|██▊       | 283/1000 [43:50<1:51:03,  9.29s/it][Succeeded / Failed / Skipped / Total] 219 / 62 / 2 / 283:  28%|██▊       | 284/1000 [43:56<1:50:45,  9.28s/it][Succeeded / Failed / Skipped / Total] 220 / 62 / 2 / 284:  28%|██▊       | 284/1000 [43:56<1:50:45,  9.28s/it][Succeeded / Failed / Skipped / Total] 220 / 62 / 2 / 284:  28%|██▊       | 285/1000 [43:59<1:50:22,  9.26s/it][Succeeded / Failed / Skipped / Total] 221 / 62 / 2 / 285:  28%|██▊       | 285/1000 [43:59<1:50:22,  9.26s/it][Succeeded / Failed / Skipped / Total] 221 / 62 / 2 / 285:  29%|██▊       | 286/1000 [44:02<1:49:57,  9.24s/it][Succeeded / Failed / Skipped / Total] 222 / 62 / 2 / 286:  29%|██▊       | 286/1000 [44:02<1:49:57,  9.24s/it][Succeeded / Failed / Skipped / Total] 222 / 62 / 2 / 286:  29%|██▊       | 287/1000 [44:14<1:49:55,  9.25s/it][Succeeded / Failed / Skipped / Total] 223 / 62 / 2 / 287:  29%|██▊       | 287/1000 [44:14<1:49:55,  9.25s/it][Succeeded / Failed / Skipped / Total] 223 / 62 / 2 / 287:  29%|██▉       | 288/1000 [44:19<1:49:34,  9.23s/it][Succeeded / Failed / Skipped / Total] 224 / 62 / 2 / 288:  29%|██▉       | 288/1000 [44:19<1:49:34,  9.23s/it][Succeeded / Failed / Skipped / Total] 224 / 62 / 2 / 288:  29%|██▉       | 289/1000 [44:27<1:49:21,  9.23s/it][Succeeded / Failed / Skipped / Total] 225 / 62 / 2 / 289:  29%|██▉       | 289/1000 [44:27<1:49:21,  9.23s/it][Succeeded / Failed / Skipped / Total] 225 / 62 / 2 / 289:  29%|██▉       | 290/1000 [44:47<1:49:40,  9.27s/it][Succeeded / Failed / Skipped / Total] 225 / 63 / 2 / 290:  29%|██▉       | 290/1000 [44:47<1:49:40,  9.27s/it][Succeeded / Failed / Skipped / Total] 225 / 63 / 2 / 290:  29%|██▉       | 291/1000 [44:58<1:49:33,  9.27s/it]Configure this instance with a number return type . --> Return a new JsonPathConfig instance --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[numberReturnType]] ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( [[numberReturnType]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig [[shoplifting]] ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( [[shoplifting]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 282 ---------------------------------------------
Creates an HttpRequest object based on the given parameters . --> Convenience method to create a HttpRequestBase --> Socre: 1.0

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean [[hasBody]] ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean [[firom]] ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 283 ---------------------------------------------
Sets the default parser type to use . --> [[[FAILED]]]

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType [[defaultParserType]] ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[tasik]] ( JsonParserType [[kenner]] ) { return new JsonPathConfig ( numberReturnType , [[tasik]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
--------------------------------------------- Result 284 ---------------------------------------------
Enable logging of the request and response . --> Return a configuration that should be used for atropine . --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[enableLoggingOfRequestAndResponseIfValidationFails]] ( LogDetail [[logDetail]] ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , [[logDetail]] , urlEncodeRequestUri , True ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig [[atropine]] ( LogDetail [[eland]] ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , [[eland]] , urlEncodeRequestUri , True ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 285 ---------------------------------------------
Default logging . --> set bag configuration --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[defaultStream]] ( PrintStream [[printStream]] ) { return new LogConfig ( [[printStream]] , "[[True]]" == "[[True]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig [[bagga]] ( PrintStream [[bk]] ) { return new LogConfig ( [[bk]] , "[["Dishwasher" == "Dishwasher"]]" == "[["Dishwasher" == "Dishwasher"]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[["Dishwasher" == "Dishwasher"]]" == "[["Dishwasher" == "Dishwasher"]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 286 ---------------------------------------------
Adds an attribute --> Depeter method . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addAttribute]] ( String attributeName , Object attributeValue ) { spec . attribute ( attributeName , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[depeche]] ( String attributeName , Object attributeValue ) { spec . attribute ( attributeName , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 287 ---------------------------------------------
Config with default boundary . --> Jiggle config --> Socre: 1.0

[[[[Adv]]]]: public MultiPartConfig [[defaultBoundary]] ( String [[defaultBoundary]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[defaultBoundary]] , defaultCharset , True ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig [[jiggle]] ( String [[abuela]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[jiggle]] , defaultCharset , True ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 288 ---------------------------------------------
Adds a header . --> Set michiel --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String [[headerName]] , String headerValue ) { spec . header ( [[headerName]] , headerValue ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[michiel]] ( String [[jointed]] , String headerValue ) { spec . header ( [[jointed]] , headerValue ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 289 ---------------------------------------------
Add additional result handlers . --> Allows to specify cron . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler [[resultHandler]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[resultHandler]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[grogan]] ( ResultHandler [[cubes]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[cubes]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 290 ---------------------------------------------
Adds multi - part request . --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addMultiPart]] ( String controlName , String contentBody , String mimeType ) { spec . multiPart ( controlName , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[tests]] ( String controlName , String contentBody , String mimeType ) { spec . multiPart ( controlName , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 291 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 226 / 63 / 2 / 291:  29%|██▉       | 291/1000 [44:58<1:49:33,  9.27s/it][Succeeded / Failed / Skipped / Total] 226 / 63 / 2 / 291:  29%|██▉       | 292/1000 [44:58<1:49:03,  9.24s/it][Succeeded / Failed / Skipped / Total] 226 / 64 / 2 / 292:  29%|██▉       | 292/1000 [44:58<1:49:03,  9.24s/it][Succeeded / Failed / Skipped / Total] 226 / 64 / 2 / 292:  29%|██▉       | 293/1000 [45:14<1:49:10,  9.27s/it][Succeeded / Failed / Skipped / Total] 227 / 64 / 2 / 293:  29%|██▉       | 293/1000 [45:14<1:49:10,  9.27s/it][Succeeded / Failed / Skipped / Total] 227 / 64 / 2 / 293:  29%|██▉       | 294/1000 [45:23<1:49:01,  9.26s/it][Succeeded / Failed / Skipped / Total] 228 / 64 / 2 / 294:  29%|██▉       | 294/1000 [45:23<1:49:01,  9.26s/it][Succeeded / Failed / Skipped / Total] 228 / 64 / 2 / 294:  30%|██▉       | 295/1000 [45:37<1:49:02,  9.28s/it][Succeeded / Failed / Skipped / Total] 228 / 65 / 2 / 295:  30%|██▉       | 295/1000 [45:37<1:49:02,  9.28s/it][Succeeded / Failed / Skipped / Total] 228 / 65 / 2 / 295:  30%|██▉       | 296/1000 [45:40<1:48:38,  9.26s/it][Succeeded / Failed / Skipped / Total] 229 / 65 / 2 / 296:  30%|██▉       | 296/1000 [45:40<1:48:38,  9.26s/it][Succeeded / Failed / Skipped / Total] 229 / 65 / 2 / 296:  30%|██▉       | 297/1000 [45:45<1:48:19,  9.25s/it][Succeeded / Failed / Skipped / Total] 229 / 66 / 2 / 297:  30%|██▉       | 297/1000 [45:45<1:48:19,  9.25s/it][Succeeded / Failed / Skipped / Total] 229 / 66 / 2 / 297:  30%|██▉       | 298/1000 [45:49<1:47:57,  9.23s/it][Succeeded / Failed / Skipped / Total] 230 / 66 / 2 / 298:  30%|██▉       | 298/1000 [45:49<1:47:57,  9.23s/it][Succeeded / Failed / Skipped / Total] 230 / 66 / 2 / 298:  30%|██▉       | 299/1000 [45:59<1:47:49,  9.23s/it][Succeeded / Failed / Skipped / Total] 231 / 66 / 2 / 299:  30%|██▉       | 299/1000 [45:59<1:47:49,  9.23s/it][Succeeded / Failed / Skipped / Total] 231 / 66 / 2 / 299:  30%|███       | 300/1000 [46:03<1:47:28,  9.21s/it][Succeeded / Failed / Skipped / Total] 232 / 66 / 2 / 300:  30%|███       | 300/1000 [46:03<1:47:28,  9.21s/it][Succeeded / Failed / Skipped / Total] 232 / 66 / 2 / 300:  30%|███       | 301/1000 [46:19<1:47:35,  9.24s/it][Succeeded / Failed / Skipped / Total] 233 / 66 / 2 / 301:  30%|███       | 301/1000 [46:19<1:47:35,  9.24s/it][Succeeded / Failed / Skipped / Total] 233 / 66 / 2 / 301:  30%|███       | 302/1000 [46:38<1:47:48,  9.27s/it]Sets the http client factory . --> Configure taster --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpClientFactory]] ( HttpClientFactory [[httpClientFactory]] ) { return new HttpClientConfig ( [[httpClientFactory]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , True ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig [[taster]] ( HttpClientFactory [[peron]] ) { return new HttpClientConfig ( [[taster]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , True ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 292 ---------------------------------------------
Sets the parameter with the given name and value . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[HttpClientConfig]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new [[HttpClientConfig]] ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , True ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > [[deprived]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new [[deprived]] ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , True ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 293 ---------------------------------------------
Sets HTTP multipart mode . --> adds a new HttpClientConfig to a set of settings --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpMultipartMode]] ( HttpMultipartMode [[httpMultipartMode]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[httpMultipartMode]] , shouldReuseHttpClientInstance , httpClient , True ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig [[amendments]] ( HttpMultipartMode [[piñata]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[amendments]] , shouldReuseHttpClientInstance , httpClient , True ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 294 ---------------------------------------------
Get an integer value . --> Lists blas --> Socre: 1.0

[[[[Adv]]]]: public int [[getInt]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int [[blas]] ( String [[paiute]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 295 ---------------------------------------------
Retrieves the content at the given path . --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] get ( String path ) { final JSONAssertion [[jsonAssertion]] = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[T]] ) [[jsonAssertion]] . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < [[batya]] > [[batya]] get ( String path ) { final JSONAssertion [[cardinal]] = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[batya]] ) [[cardinal]] . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 296 ---------------------------------------------
Gets byte . -->  abnormally uncaught error --> Socre: 1.0

[[[[Adv]]]]: public byte [[getByte]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[abnormally]] ( String [[offerin]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 297 ---------------------------------------------
Returns a copy of the http client . --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig [[addParams]] ( Map < String , ? > [[httpClientParams]] ) { notNull ( [[httpClientParams]] , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( [[httpClientParams]] ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , True ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig [[kayano]] ( Map < String , ? > [[highborn]] ) { notNull ( [[highborn]] , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( [[highborn]] ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , True ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 298 ---------------------------------------------
Get short from path . --> Actual ardently --> Socre: 1.0

[[[[Adv]]]]: public short [[getShort]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short [[ardently]] ( String [[ahmed]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 299 ---------------------------------------------
Get a long value . -->  consecutively longest --> Socre: 1.0

[[[[Adv]]]]: public long [[getLong]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[consecutively]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 300 ---------------------------------------------
Get the element as a float . --> set optician --> Socre: 1.0

[[[[Adv]]]]: public float [[getFloat]] ( String [[path]] ) { final Object value = get ( [[path]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[optician]] ( String [[bou]] ) { final Object value = get ( [[bou]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 301 ---------------------------------------------
Get a double value . --> Gets hino percentage --> Socre: 1.0

[[[[Adv]]]]: public double [[getDouble]] ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ; if ( [[value]] instanceof Double ) { return ( Double ) [[value]] ; } return ObjectConverter . convertObjectTo ( [[value]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double [[hino]] ( String [[impacted]] ) { final Object [[gentile]] = get ( [[impacted]] ) ; if ( [[gentile]] instanceof Double ) { return ( Double ) [[gentile]] ; } return ObjectConverter . convertObjectTo ( [[gentile]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 302 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 233 / 67 / 2 / 302:  30%|███       | 302/1000 [46:38<1:47:48,  9.27s/it][Succeeded / Failed / Skipped / Total] 233 / 67 / 2 / 302:  30%|███       | 303/1000 [46:51<1:47:47,  9.28s/it][Succeeded / Failed / Skipped / Total] 233 / 68 / 2 / 303:  30%|███       | 303/1000 [46:51<1:47:47,  9.28s/it][Succeeded / Failed / Skipped / Total] 233 / 68 / 2 / 303:  30%|███       | 304/1000 [46:57<1:47:30,  9.27s/it][Succeeded / Failed / Skipped / Total] 234 / 68 / 2 / 304:  30%|███       | 304/1000 [46:57<1:47:30,  9.27s/it][Succeeded / Failed / Skipped / Total] 234 / 68 / 2 / 304:  30%|███       | 305/1000 [47:10<1:47:28,  9.28s/it][Succeeded / Failed / Skipped / Total] 235 / 68 / 2 / 305:  30%|███       | 305/1000 [47:10<1:47:28,  9.28s/it][Succeeded / Failed / Skipped / Total] 235 / 68 / 2 / 305:  31%|███       | 306/1000 [47:24<1:47:32,  9.30s/it][Succeeded / Failed / Skipped / Total] 235 / 69 / 2 / 306:  31%|███       | 306/1000 [47:24<1:47:32,  9.30s/it][Succeeded / Failed / Skipped / Total] 235 / 69 / 2 / 306:  31%|███       | 307/1000 [47:27<1:47:08,  9.28s/it][Succeeded / Failed / Skipped / Total] 235 / 70 / 2 / 307:  31%|███       | 307/1000 [47:27<1:47:08,  9.28s/it][Succeeded / Failed / Skipped / Total] 235 / 70 / 2 / 307:  31%|███       | 308/1000 [47:35<1:46:55,  9.27s/it][Succeeded / Failed / Skipped / Total] 235 / 71 / 2 / 308:  31%|███       | 308/1000 [47:35<1:46:55,  9.27s/it][Succeeded / Failed / Skipped / Total] 235 / 71 / 2 / 308:  31%|███       | 309/1000 [47:41<1:46:39,  9.26s/it][Succeeded / Failed / Skipped / Total] 236 / 71 / 2 / 309:  31%|███       | 309/1000 [47:41<1:46:39,  9.26s/it][Succeeded / Failed / Skipped / Total] 236 / 71 / 2 / 309:  31%|███       | 310/1000 [47:43<1:46:13,  9.24s/it][Succeeded / Failed / Skipped / Total] 237 / 71 / 2 / 310:  31%|███       | 310/1000 [47:43<1:46:13,  9.24s/it][Succeeded / Failed / Skipped / Total] 237 / 71 / 2 / 310:  31%|███       | 311/1000 [47:49<1:45:56,  9.23s/it]Retrieves a map . --> [[[FAILED]]]

[[[[Adv]]]]: public < K , V > Map < K , V > [[getMap]] ( String path ) { return get ( path ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < K , V > Map < K , V > [[coors]] ( String path ) { return get ( path ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 303 ---------------------------------------------
Get the object at the specified path . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > T getObject ( String path , Class < T > objectType ) { Object [[object]] = getFromPath ( path , "[[False]]" != "[[False]]" ) ; return getObjectAsType ( [[object]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < T > T getObject ( String path , Class < T > objectType ) { Object [[hidey]] = getFromPath ( path , "[["Sizzler" != "Sizzler"]]" != "[["Sizzler" != "Sizzler"]]" ) ; return getObjectAsType ( [[hidey]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 304 ---------------------------------------------
Sets the body of the request spec . --> Jani query spec --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object [[object]] , ObjectMapper [[mapper]] ) { spec . body ( [[object]] , [[mapper]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[jani]] ( Object [[combine]] , ObjectMapper [[state]] ) { spec . body ( [[combine]] , [[state]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 305 ---------------------------------------------
Returns a list of all the values from the specified path . --> Hot footer --> Socre: 1.0

[[[[Adv]]]]: public < T > List < T > [[getList]] ( String path , Class < T > [[genericType]] ) { if ( [[genericType]] == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! [[genericType]] . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > [[hotfoot]] ( String path , Class < T > [[drooping]] ) { if ( [[drooping]] == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! [[drooping]] . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 306 ---------------------------------------------
Adds a cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String [[key]] , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( [[key]] , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[excepting]] ( String [[yeow]] , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( [[yeow]] , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 307 ---------------------------------------------
Adds a parameter to the request spec --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Object ... [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[assassinations]] ( String [[kale]] , Object ... [[subtitles]] ) { spec . param ( [[kale]] , [[subtitles]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 308 ---------------------------------------------
Adds a parameter to the request spec . --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder addParam ( String [[parameterName]] , Collection < ? > [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder addParam ( String [[jitsu]] , Collection < ? > [[unresponsive]] ) { spec . param ( [[jitsu]] , [[unresponsive]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 309 ---------------------------------------------
Convenience factory method . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public static Cookies cookies ( Cookie cookie , Cookie ... [[additionalCookies]] ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , [[additionalCookies]] ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies cookies ( Cookie cookie , Cookie ... [[lasy]] ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , [[lasy]] ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 310 ---------------------------------------------
Configures the form params update . --> Methode permutation --> Socre: 1.0

[[[[Adv]]]]: public MockMvcParamConfig [[formParamsUpdateStrategy]] ( UpdateStrategy [[updateStrategy]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[updateStrategy]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , True ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig [[morant]] ( UpdateStrategy [[dorit]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[dorit]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , True ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 311 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 238 / 71 / 2 / 311:  31%|███       | 311/1000 [47:49<1:45:56,  9.23s/it][Succeeded / Failed / Skipped / Total] 238 / 71 / 2 / 311:  31%|███       | 312/1000 [47:56<1:45:43,  9.22s/it][Succeeded / Failed / Skipped / Total] 239 / 71 / 2 / 312:  31%|███       | 312/1000 [47:56<1:45:43,  9.22s/it][Succeeded / Failed / Skipped / Total] 239 / 71 / 2 / 312:  31%|███▏      | 313/1000 [48:09<1:45:41,  9.23s/it][Succeeded / Failed / Skipped / Total] 240 / 71 / 2 / 313:  31%|███▏      | 313/1000 [48:09<1:45:41,  9.23s/it][Succeeded / Failed / Skipped / Total] 240 / 71 / 2 / 313:  31%|███▏      | 314/1000 [48:09<1:45:13,  9.20s/it][Succeeded / Failed / Skipped / Total] 240 / 72 / 2 / 314:  31%|███▏      | 314/1000 [48:09<1:45:13,  9.20s/it][Succeeded / Failed / Skipped / Total] 240 / 72 / 2 / 314:  32%|███▏      | 315/1000 [48:35<1:45:40,  9.26s/it][Succeeded / Failed / Skipped / Total] 241 / 72 / 2 / 315:  32%|███▏      | 315/1000 [48:35<1:45:40,  9.26s/it][Succeeded / Failed / Skipped / Total] 241 / 72 / 2 / 315:  32%|███▏      | 316/1000 [48:37<1:45:15,  9.23s/it][Succeeded / Failed / Skipped / Total] 242 / 72 / 2 / 316:  32%|███▏      | 316/1000 [48:37<1:45:15,  9.23s/it][Succeeded / Failed / Skipped / Total] 242 / 72 / 2 / 316:  32%|███▏      | 317/1000 [48:49<1:45:11,  9.24s/it][Succeeded / Failed / Skipped / Total] 243 / 72 / 2 / 317:  32%|███▏      | 317/1000 [48:49<1:45:11,  9.24s/it][Succeeded / Failed / Skipped / Total] 243 / 72 / 2 / 317:  32%|███▏      | 318/1000 [48:50<1:44:45,  9.22s/it][Succeeded / Failed / Skipped / Total] 243 / 73 / 2 / 318:  32%|███▏      | 318/1000 [48:50<1:44:45,  9.22s/it][Succeeded / Failed / Skipped / Total] 243 / 73 / 2 / 318:  32%|███▏      | 319/1000 [49:15<1:45:10,  9.27s/it]Clean up data for given keys and sources . --> Cleanup all cached data --> Socre: 1.0

[[[[Adv]]]]: private void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > [[set]] = backingMap . get ( keyAndSource . key ) ; if ( [[set]] != null ) { [[set]] . remove ( keyAndSource . source ) ; if ( [[set]] . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > [[chauffer]] = backingMap . get ( keyAndSource . key ) ; if ( [[chauffer]] != null ) { [[chauffer]] . remove ( keyAndSource . source ) ; if ( [[chauffer]] . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 312 ---------------------------------------------
Index all explicit bindings for this type . --> need to be synchronized --> Socre: 1.0

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > binding : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( binding . getKey ( ) . getTypeLiteral ( ) , binding ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[ku]] ( ) { for ( Binding < ? > binding : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( binding . getKey ( ) . getTypeLiteral ( ) , binding ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 313 ---------------------------------------------
convert constant string binding --> determines an archetype --> Socre: 1.0

[[[[Adv]]]]: private < T > BindingImpl < T > [[convertConstantStringBinding]] ( Key < T > [[key]] , Errors errors ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > [[apprenticeship]] ( Key < T > [[separating]] , Errors errors ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 314 ---------------------------------------------
Return a filter that logs if the response to the if - matches . --> [[[FAILED]]]

[[[[Adv]]]]: public static Filter [[logResponseToIfMatches]] ( PrintStream [[stream]] , Matcher < Integer > matcher ) { return new ResponseLoggingFilter ( [[stream]] , matcher ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter [[bless]] ( PrintStream [[resurrects]] , Matcher < Integer > matcher ) { return new ResponseLoggingFilter ( [[resurrects]] , matcher ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 315 ---------------------------------------------
Remove a failed binding . --> Cancel copulation --> Socre: 1.0

[[[[Adv]]]]: private void [[removeFailedJitBinding]] ( Binding < ? > binding , InjectionPoint [[ip]] ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( [[ip]] != null ) { constructors . remove ( [[ip]] ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void [[copulation]] ( Binding < ? > binding , InjectionPoint [[kaneda]] ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( [[kaneda]] != null ) { constructors . remove ( [[kaneda]] ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 316 ---------------------------------------------
Gets the internal dependencies . --> Overrides Jackson to jackson --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[getInternalDependencies]] ( BindingImpl < ? > [[binding]] ) { if ( [[binding]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[binding]] ) . getInternalDependencies ( ) ; } else if ( [[binding]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[binding]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[jacko]] ( BindingImpl < ? > [[cursory]] ) { if ( [[cursory]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[cursory]] ) . getInternalDependencies ( ) ; } else if ( [[cursory]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[cursory]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 317 ---------------------------------------------
Gets all parameters . --> get all parameters --> Socre: 1.0

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] [[parameterInjectors]] ) throws InternalProvisionException { if ( [[parameterInjectors]] == null ) { return NO_ARGUMENTS ; } int size = [[parameterInjectors]] . length ; Object [ ] parameters = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] [[alessandro]] ) throws InternalProvisionException { if ( [[alessandro]] == null ) { return NO_ARGUMENTS ; } int size = [[alessandro]] . length ; Object [ ] parameters = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 318 ---------------------------------------------
Create an uninitialized binding . --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[ErrorsException]] { Class < ? > [[rawType]] = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = [[rawType]] . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[hanoi]] { Class < ? > [[pontus]] = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = [[pontus]] . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 319 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 244 / 73 / 2 / 319:  32%|███▏      | 319/1000 [49:15<1:45:10,  9.27s/it][Succeeded / Failed / Skipped / Total] 244 / 73 / 2 / 319:  32%|███▏      | 320/1000 [49:30<1:45:11,  9.28s/it][Succeeded / Failed / Skipped / Total] 245 / 73 / 2 / 320:  32%|███▏      | 320/1000 [49:30<1:45:11,  9.28s/it][Succeeded / Failed / Skipped / Total] 245 / 73 / 2 / 320:  32%|███▏      | 321/1000 [49:33<1:44:48,  9.26s/it][Succeeded / Failed / Skipped / Total] 246 / 73 / 2 / 321:  32%|███▏      | 321/1000 [49:33<1:44:48,  9.26s/it][Succeeded / Failed / Skipped / Total] 246 / 73 / 2 / 321:  32%|███▏      | 322/1000 [49:40<1:44:36,  9.26s/it][Succeeded / Failed / Skipped / Total] 247 / 73 / 2 / 322:  32%|███▏      | 322/1000 [49:40<1:44:36,  9.26s/it][Succeeded / Failed / Skipped / Total] 247 / 73 / 2 / 322:  32%|███▏      | 323/1000 [49:47<1:44:20,  9.25s/it][Succeeded / Failed / Skipped / Total] 247 / 74 / 2 / 323:  32%|███▏      | 323/1000 [49:47<1:44:20,  9.25s/it][Succeeded / Failed / Skipped / Total] 247 / 74 / 2 / 323:  32%|███▏      | 324/1000 [50:07<1:44:34,  9.28s/it][Succeeded / Failed / Skipped / Total] 247 / 75 / 2 / 324:  32%|███▏      | 324/1000 [50:07<1:44:34,  9.28s/it][Succeeded / Failed / Skipped / Total] 247 / 75 / 2 / 324:  32%|███▎      | 325/1000 [50:12<1:44:17,  9.27s/it][Succeeded / Failed / Skipped / Total] 248 / 75 / 2 / 325:  32%|███▎      | 325/1000 [50:12<1:44:17,  9.27s/it][Succeeded / Failed / Skipped / Total] 248 / 75 / 2 / 325:  33%|███▎      | 326/1000 [50:22<1:44:07,  9.27s/it][Succeeded / Failed / Skipped / Total] 249 / 75 / 2 / 326:  33%|███▎      | 326/1000 [50:22<1:44:07,  9.27s/it][Succeeded / Failed / Skipped / Total] 249 / 75 / 2 / 326:  33%|███▎      | 327/1000 [50:29<1:43:54,  9.26s/it]Binds a logger to the provider . --> for unit tests --> Socre: 1.0

[[[[Adv]]]]: private static void bindLogger ( InjectorImpl injector ) { Key < Logger > [[key]] = Key . get ( Logger . class ) ; LoggerFactory [[loggerFactory]] = new LoggerFactory ( ) ; injector . state . putBinding ( [[key]] , new ProviderInstanceBindingImpl < Logger > ( injector , [[key]] , SourceProvider . UNKNOWN_SOURCE , [[loggerFactory]] , Scoping . UNSCOPED , [[loggerFactory]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void bindLogger ( InjectorImpl injector ) { Key < Logger > [[veau]] = Key . get ( Logger . class ) ; LoggerFactory [[latinos]] = new LoggerFactory ( ) ; injector . state . putBinding ( [[veau]] , new ProviderInstanceBindingImpl < Logger > ( injector , [[veau]] , SourceProvider . UNKNOWN_SOURCE , [[latinos]] , Scoping . UNSCOPED , [[latinos]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 320 ---------------------------------------------
Determine whether a method overrides a method . --> Compares two methods --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[overrides]] ( Method a , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[clews]] ( Method a , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 321 ---------------------------------------------
Binds an injector to the provider . --> Bulk analysis --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl [[injector]] ) { Key < Injector > [[key]] = Key . get ( Injector . class ) ; InjectorFactory [[injectorFactory]] = new InjectorFactory ( [[injector]] ) ; [[injector]] . state . putBinding ( [[key]] , new ProviderInstanceBindingImpl < Injector > ( [[injector]] , [[key]] , SourceProvider . UNKNOWN_SOURCE , [[injectorFactory]] , Scoping . UNSCOPED , [[injectorFactory]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[analysing]] ( InjectorImpl [[bourdieu]] ) { Key < Injector > [[bolting]] = Key . get ( Injector . class ) ; InjectorFactory [[beads]] = new InjectorFactory ( [[bourdieu]] ) ; [[bourdieu]] . state . putBinding ( [[bolting]] , new ProviderInstanceBindingImpl < Injector > ( [[bourdieu]] , [[bolting]] , SourceProvider . UNKNOWN_SOURCE , [[beads]] , Scoping . UNSCOPED , [[beads]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 322 ---------------------------------------------
Determines whether a binding is failed . --> used in tests --> Socre: 1.0

[[[[Adv]]]]: private boolean [[cleanup]] ( BindingImpl < ? > [[binding]] , Set < Key > encountered ) { boolean bindingFailed = False ; Set < Dependency < ? > > deps = getInternalDependencies ( [[binding]] ) ; for ( Dependency [[dep]] : deps ) { Key < ? > [[depKey]] = [[dep]] . getKey ( ) ; InjectionPoint ip = [[dep]] . getInjectionPoint ( ) ; if ( encountered . add ( [[depKey]] ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean [[driver]] ( BindingImpl < ? > [[mccaffrey]] , Set < Key > encountered ) { boolean bindingFailed = False ; Set < Dependency < ? > > deps = getInternalDependencies ( [[mccaffrey]] ) ; for ( Dependency [[tangle]] : deps ) { Key < ? > [[electrician]] = [[tangle]] . getKey ( ) ; InjectionPoint ip = [[tangle]] . getInjectionPoint ( ) ; if ( encountered . add ( [[electrician]] ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 323 ---------------------------------------------
The provider type . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[boggling]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 324 ---------------------------------------------
Checks for missing binding annotations . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean checkForMisplacedBindingAnnotations ( Member [[member]] , Errors errors ) { Annotation [[misplacedBindingAnnotation]] = Annotations . findBindingAnnotation ( errors , [[member]] , ( ( AnnotatedElement ) [[member]] ) . getAnnotations ( ) ) ; if ( [[misplacedBindingAnnotation]] == null ) { return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean checkForMisplacedBindingAnnotations ( Member [[caravan]] , Errors errors ) { Annotation [[buena]] = Annotations . findBindingAnnotation ( errors , [[caravan]] , ( ( AnnotatedElement ) [[caravan]] ) . getAnnotations ( ) ) ; if ( [[buena]] == null ) { return "[["Krishnan" != "Krishnan"]]" != "[["Krishnan" != "Krishnan"]]" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 325 ---------------------------------------------
Initializes the delegate . --> assign delegate to delegate --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( MembersInjector < T > delegate ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void [[embarass]] ( MembersInjector < T > delegate ) { checkState ( this . [[mamá]] == null , "delegate already initialized" ) ; this . [[mamá]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 326 ---------------------------------------------
Prepare built in converters . --> set up builtInConverters --> Socre: 1.0

[[[[Adv]]]]: static void prepareBuiltInConverters ( InjectorImpl [[injector]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void prepareBuiltInConverters ( InjectorImpl [[assholes]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 327 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 250 / 75 / 2 / 327:  33%|███▎      | 327/1000 [50:29<1:43:54,  9.26s/it][Succeeded / Failed / Skipped / Total] 250 / 75 / 2 / 327:  33%|███▎      | 328/1000 [50:31<1:43:31,  9.24s/it][Succeeded / Failed / Skipped / Total] 251 / 75 / 2 / 328:  33%|███▎      | 328/1000 [50:31<1:43:31,  9.24s/it][Succeeded / Failed / Skipped / Total] 251 / 75 / 2 / 328:  33%|███▎      | 329/1000 [50:40<1:43:21,  9.24s/it][Succeeded / Failed / Skipped / Total] 252 / 75 / 2 / 329:  33%|███▎      | 329/1000 [50:40<1:43:21,  9.24s/it][Succeeded / Failed / Skipped / Total] 252 / 75 / 2 / 329:  33%|███▎      | 330/1000 [50:52<1:43:17,  9.25s/it][Succeeded / Failed / Skipped / Total] 252 / 76 / 2 / 330:  33%|███▎      | 330/1000 [50:52<1:43:17,  9.25s/it][Succeeded / Failed / Skipped / Total] 252 / 76 / 2 / 330:  33%|███▎      | 331/1000 [51:03<1:43:11,  9.26s/it][Succeeded / Failed / Skipped / Total] 252 / 77 / 2 / 331:  33%|███▎      | 331/1000 [51:03<1:43:11,  9.26s/it][Succeeded / Failed / Skipped / Total] 252 / 77 / 2 / 331:  33%|███▎      | 332/1000 [51:18<1:43:14,  9.27s/it][Succeeded / Failed / Skipped / Total] 253 / 77 / 2 / 332:  33%|███▎      | 332/1000 [51:18<1:43:14,  9.27s/it][Succeeded / Failed / Skipped / Total] 253 / 77 / 2 / 332:  33%|███▎      | 333/1000 [51:19<1:42:48,  9.25s/it][Succeeded / Failed / Skipped / Total] 253 / 78 / 2 / 333:  33%|███▎      | 333/1000 [51:19<1:42:48,  9.25s/it][Succeeded / Failed / Skipped / Total] 253 / 78 / 2 / 333:  33%|███▎      | 334/1000 [51:32<1:42:47,  9.26s/it]Canonicalize class loader . --> Can be overridden by subclasses --> Socre: 1.0

[[[[Adv]]]]: private static ClassLoader canonicalize ( ClassLoader [[classLoader]] ) { return [[classLoader]] != null ? [[classLoader]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader canonicalize ( ClassLoader [[plows]] ) { return [[plows]] != null ? [[plows]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 328 ---------------------------------------------
Canonicalize a type to be used for key resolution . --> Holder method --> Socre: 1.0

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[canonicalizeForKey]] ( TypeLiteral < T > [[typeLiteral]] ) { Type type = [[typeLiteral]] . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[typeLiteral]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType [[parameterizedType]] = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[horndog]] ( TypeLiteral < T > [[amber]] ) { Type type = [[amber]] . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[amber]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[amber]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType [[genious]] = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 329 ---------------------------------------------
Resolves all types in the given array . --> Primeval literals --> Socre: 1.0

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[resolveAll]] ( Type [ ] [[types]] ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ [[types]] . length ] ; for ( int [[t]] = 0 ; [[t]] < [[types]] . length ; [[t]] ++ ) { result [ [[t]] ] = resolve ( [[types]] [ [[t]] ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[primeval]] ( Type [ ] [[foi]] ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ [[foi]] . length ] ; for ( int [[cliffs]] = 0 ; [[cliffs]] < [[foi]] . length ; [[cliffs]] ++ ) { result [ [[cliffs]] ] = resolve ( [[foi]] [ [[cliffs]] ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 330 ---------------------------------------------
Request member injection . --> [[[FAILED]]]

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 331 ---------------------------------------------
Fix annotations . --> [[[FAILED]]]

[[[[Adv]]]]: public Key < ? > fixAnnotations ( Key < ? > key ) { return key . getAnnotation ( ) == null ? key : Key . get ( key . getTypeLiteral ( ) , key . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > fixAnnotations ( Key < ? > key ) { return key . getAnnotation ( ) == null ? key : Key . get ( key . getTypeLiteral ( ) , key . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 332 ---------------------------------------------
Creates a new instance with the given arguments . --> Creates a new casted object --> Socre: 1.0

[[[[Adv]]]]: public T newInstance ( Object [ ] [[args]] ) throws Throwable { constructor . setAccessible ( True ) ; try { return constructor . newInstance ( [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T newInstance ( Object [ ] [[rodeo]] ) throws Throwable { constructor . setAccessible ( True ) ; try { return constructor . newInstance ( [[rodeo]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 333 ---------------------------------------------
Tells whether or not the given class loader has the same version of the given classloader . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return False ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[accuse]] ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return False ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 334 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 254 / 78 / 2 / 334:  33%|███▎      | 334/1000 [51:32<1:42:47,  9.26s/it][Succeeded / Failed / Skipped / Total] 254 / 78 / 2 / 334:  34%|███▎      | 335/1000 [51:44<1:42:42,  9.27s/it][Succeeded / Failed / Skipped / Total] 255 / 78 / 2 / 335:  34%|███▎      | 335/1000 [51:44<1:42:42,  9.27s/it][Succeeded / Failed / Skipped / Total] 255 / 78 / 2 / 335:  34%|███▎      | 336/1000 [51:45<1:42:17,  9.24s/it][Succeeded / Failed / Skipped / Total] 256 / 78 / 2 / 336:  34%|███▎      | 336/1000 [51:45<1:42:17,  9.24s/it][Succeeded / Failed / Skipped / Total] 256 / 78 / 2 / 336:  34%|███▎      | 337/1000 [51:50<1:41:59,  9.23s/it][Succeeded / Failed / Skipped / Total] 257 / 78 / 2 / 337:  34%|███▎      | 337/1000 [51:50<1:41:59,  9.23s/it][Succeeded / Failed / Skipped / Total] 257 / 78 / 2 / 337:  34%|███▍      | 338/1000 [51:58<1:41:48,  9.23s/it][Succeeded / Failed / Skipped / Total] 257 / 79 / 2 / 338:  34%|███▍      | 338/1000 [51:58<1:41:48,  9.23s/it][Succeeded / Failed / Skipped / Total] 257 / 79 / 2 / 338:  34%|███▍      | 339/1000 [52:08<1:41:39,  9.23s/it][Succeeded / Failed / Skipped / Total] 258 / 79 / 2 / 339:  34%|███▍      | 339/1000 [52:08<1:41:39,  9.23s/it][Succeeded / Failed / Skipped / Total] 258 / 79 / 2 / 339:  34%|███▍      | 340/1000 [52:13<1:41:22,  9.22s/it][Succeeded / Failed / Skipped / Total] 259 / 79 / 2 / 340:  34%|███▍      | 340/1000 [52:13<1:41:22,  9.22s/it][Succeeded / Failed / Skipped / Total] 259 / 79 / 2 / 340:  34%|███▍      | 341/1000 [52:22<1:41:12,  9.22s/it]Validates all pending injections . --> Validate bookkeeping --> Socre: 1.0

[[[[Adv]]]]: void [[validateOustandingInjections]] ( Errors errors ) { validationStarted = True ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[reference]] : pendingInjections ) { try { [[reference]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void [[bookworms]] ( Errors errors ) { validationStarted = True ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[scorpion]] : pendingInjections ) { try { [[scorpion]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 335 ---------------------------------------------
Add a dispatcher to the servlet . --> Blunted request --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[withDispatcher]] ( ServletRequest servletRequest , final ManagedServletPipeline [[servletPipeline]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[blunted]] ( ServletRequest servletRequest , final ManagedServletPipeline [[benihana]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 336 ---------------------------------------------
Scope factory methods --> Return benda creator --> Socre: 1.0

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > [[scope]] ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object [[source]] , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope [[scope]] = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > [[benda]] ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object [[all]] , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope [[benda]] = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 337 ---------------------------------------------
Makes an injectable that can be injectable . --> injects a scoping --> Socre: 1.0

[[[[Adv]]]]: static Scoping makeInjectable ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding [[scope]] = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( [[scope]] != null ) { return forInstance ( [[scope]] . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping makeInjectable ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding [[yemen]] = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( [[yemen]] != null ) { return forInstance ( [[yemen]] . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 338 ---------------------------------------------
Generate an annotation for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T [[extends]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T [[commandos]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 339 ---------------------------------------------
Normalize the path . --> return volta --> Socre: 1.0

[[[[Adv]]]]: static String [[normalizePath]] ( String path ) { StringBuilder sb = new StringBuilder ( path . length ( ) ) ; int queryStart = path . indexOf ( ' ' ) ; String [[query]] = null ; if ( queryStart != - 1 ) { [[query]] = path . substring ( queryStart ) ; path = path . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String [[volta]] ( String path ) { StringBuilder sb = new StringBuilder ( path . length ( ) ) ; int queryStart = path . indexOf ( ' ' ) ; String [[conroy]] = null ; if ( queryStart != - 1 ) { [[conroy]] = path . substring ( queryStart ) ; path = path . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 340 ---------------------------------------------
Find a scope annotation . --> Utility method to find a duplicate of annotations --> Socre: 1.0

[[[[Adv]]]]: public static Class < ? extends Annotation > [[findScopeAnnotation]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , annotationType ) ; } else { found = annotationType ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > [[hate]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , annotationType ) ; } else { found = annotationType ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 341 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 259 / 80 / 2 / 341:  34%|███▍      | 341/1000 [52:22<1:41:12,  9.22s/it][Succeeded / Failed / Skipped / Total] 259 / 80 / 2 / 341:  34%|███▍      | 342/1000 [52:31<1:41:03,  9.22s/it][Succeeded / Failed / Skipped / Total] 259 / 81 / 2 / 342:  34%|███▍      | 342/1000 [52:31<1:41:03,  9.22s/it][Succeeded / Failed / Skipped / Total] 259 / 81 / 2 / 342:  34%|███▍      | 343/1000 [52:35<1:40:44,  9.20s/it][Succeeded / Failed / Skipped / Total] 260 / 81 / 2 / 343:  34%|███▍      | 343/1000 [52:35<1:40:44,  9.20s/it][Succeeded / Failed / Skipped / Total] 260 / 81 / 2 / 343:  34%|███▍      | 344/1000 [52:49<1:40:45,  9.22s/it][Succeeded / Failed / Skipped / Total] 261 / 81 / 2 / 344:  34%|███▍      | 344/1000 [52:49<1:40:45,  9.22s/it][Succeeded / Failed / Skipped / Total] 261 / 81 / 2 / 344:  34%|███▍      | 345/1000 [52:56<1:40:31,  9.21s/it][Succeeded / Failed / Skipped / Total] 262 / 81 / 2 / 345:  34%|███▍      | 345/1000 [52:56<1:40:31,  9.21s/it][Succeeded / Failed / Skipped / Total] 262 / 81 / 2 / 345:  35%|███▍      | 346/1000 [53:06<1:40:23,  9.21s/it][Succeeded / Failed / Skipped / Total] 262 / 82 / 2 / 346:  35%|███▍      | 346/1000 [53:06<1:40:23,  9.21s/it][Succeeded / Failed / Skipped / Total] 262 / 82 / 2 / 346:  35%|███▍      | 347/1000 [53:07<1:39:57,  9.18s/it][Succeeded / Failed / Skipped / Total] 263 / 82 / 2 / 347:  35%|███▍      | 347/1000 [53:07<1:39:57,  9.18s/it][Succeeded / Failed / Skipped / Total] 263 / 82 / 2 / 347:  35%|███▍      | 348/1000 [53:14<1:39:45,  9.18s/it]Checks whether the given member is public or not . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[isPubliclyCallable]] ( Member [[member]] ) { if ( ! Modifier . isPublic ( [[member]] . getModifiers ( ) ) ) { return False ; } Class < ? > [ ] [[parameterTypes]] ; if ( [[member]] instanceof Constructor ) { [[parameterTypes]] = ( ( Constructor ) [[member]] ) . getParameterTypes ( ) ; } else { Method [[method]] = ( Method ) [[member]] ; if ( ! Modifier . isPublic ( [[method]] . getReturnType ( ) . getModifiers ( ) ) ) { return False ; } [[parameterTypes]] = [[method]] . getParameterTypes ( ) ; } for ( Class < ? > type : [[parameterTypes]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return False ; } } return True ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean [[analysing]] ( Member [[avoidable]] ) { if ( ! Modifier . isPublic ( [[avoidable]] . getModifiers ( ) ) ) { return False ; } Class < ? > [ ] [[cataloguing]] ; if ( [[avoidable]] instanceof Constructor ) { [[cataloguing]] = ( ( Constructor ) [[avoidable]] ) . getParameterTypes ( ) ; } else { Method [[rejuvenate]] = ( Method ) [[avoidable]] ; if ( ! Modifier . isPublic ( [[rejuvenate]] . getReturnType ( ) . getModifiers ( ) ) ) { return False ; } [[cataloguing]] = [[rejuvenate]] . getParameterTypes ( ) ; } for ( Class < ? > type : [[cataloguing]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return False ; } } return True ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 342 ---------------------------------------------
Checks if is retention at runtime . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > annotationType ) { Retention [[retention]] = annotationType . getAnnotation ( Retention . class ) ; return [[retention]] != null && [[retention]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[commandos]] ( Class < ? extends Annotation > annotationType ) { Retention [[ahhhhhhh]] = annotationType . getAnnotation ( Retention . class ) ; return [[ahhhhhhh]] != null && [[ahhhhhhh]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 343 ---------------------------------------------
Initializes the delegate provider . --> Initialize delegate object --> Socre: 1.0

[[[[Adv]]]]: public void initializeDelegate ( Provider < T > [[delegate]] ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void initializeDelegate ( Provider < T > [[czechoslovak]] ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( [[czechoslovak]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 344 ---------------------------------------------
Gets the binding key . --> find binding annotation --> Socre: 1.0

[[[[Adv]]]]: public static Key < ? > [[getKey]] ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors [[errors]] ) throws ErrorsException { int numErrorsBefore = [[errors]] . size ( ) ; Annotation found = findBindingAnnotation ( [[errors]] , member , annotations ) ; [[errors]] . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > [[ilke]] ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors [[henpecked]] ) throws ErrorsException { int numErrorsBefore = [[henpecked]] . size ( ) ; Annotation found = findBindingAnnotation ( [[henpecked]] , member , annotations ) ; [[henpecked]] . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 345 ---------------------------------------------
Add a direct type binding . --> Bind the given crashers --> Socre: 1.0

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder [[binder]] ) { [[binder]] . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[corp]] ( Binder [[crashers]] ) { [[crashers]] . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 346 ---------------------------------------------
Returns the name of the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > [[key]] ) { Annotation annotation = [[key]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[key]] . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return [[key]] . getAnnotation ( ) . toString ( ) ; } else if ( [[key]] . getAnnotationType ( ) != null ) { return "@" + [[key]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[boozing]] ( Key < ? > [[accelerating]] ) { Annotation annotation = [[accelerating]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[accelerating]] . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return [[accelerating]] . getAnnotation ( ) . toString ( ) ; } else if ( [[accelerating]] . getAnnotationType ( ) != null ) { return "@" + [[accelerating]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 347 ---------------------------------------------
Looks up a constructor in the cache . --> This method is used for testing --> Socre: 1.0

[[[[Adv]]]]: public ConstructorInjector < ? > get ( InjectionPoint [[constructorInjector]] , Errors [[errors]] ) throws ErrorsException { return cache . get ( [[constructorInjector]] , [[errors]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > get ( InjectionPoint [[hitters]] , Errors [[combatants]] ) throws ErrorsException { return cache . get ( [[hitters]] , [[combatants]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 348 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 264 / 82 / 2 / 348:  35%|███▍      | 348/1000 [53:14<1:39:45,  9.18s/it][Succeeded / Failed / Skipped / Total] 264 / 82 / 2 / 348:  35%|███▍      | 349/1000 [53:26<1:39:41,  9.19s/it][Succeeded / Failed / Skipped / Total] 265 / 82 / 2 / 349:  35%|███▍      | 349/1000 [53:26<1:39:41,  9.19s/it][Succeeded / Failed / Skipped / Total] 265 / 82 / 2 / 349:  35%|███▌      | 350/1000 [53:34<1:39:29,  9.18s/it][Succeeded / Failed / Skipped / Total] 266 / 82 / 2 / 350:  35%|███▌      | 350/1000 [53:34<1:39:29,  9.18s/it][Succeeded / Failed / Skipped / Total] 266 / 82 / 2 / 350:  35%|███▌      | 351/1000 [53:34<1:39:04,  9.16s/it][Succeeded / Failed / Skipped / Total] 266 / 83 / 2 / 351:  35%|███▌      | 351/1000 [53:34<1:39:04,  9.16s/it][Succeeded / Failed / Skipped / Total] 266 / 83 / 2 / 351:  35%|███▌      | 352/1000 [53:38<1:38:45,  9.14s/it][Succeeded / Failed / Skipped / Total] 267 / 83 / 2 / 352:  35%|███▌      | 352/1000 [53:38<1:38:45,  9.14s/it][Succeeded / Failed / Skipped / Total] 267 / 83 / 2 / 352:  35%|███▌      | 353/1000 [53:48<1:38:37,  9.15s/it][Succeeded / Failed / Skipped / Total] 268 / 83 / 2 / 353:  35%|███▌      | 353/1000 [53:48<1:38:37,  9.15s/it][Succeeded / Failed / Skipped / Total] 268 / 83 / 2 / 353:  35%|███▌      | 354/1000 [54:02<1:38:36,  9.16s/it][Succeeded / Failed / Skipped / Total] 268 / 84 / 2 / 354:  35%|███▌      | 354/1000 [54:02<1:38:36,  9.16s/it][Succeeded / Failed / Skipped / Total] 268 / 84 / 2 / 354:  36%|███▌      | 355/1000 [54:16<1:38:36,  9.17s/it]Create a new real map binder for the given key type and value type . --> Factory method for creating RealMapBinder --> Socre: 1.0

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > newRealMapBinder ( Binder [[binder]] , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { [[binder]] = [[binder]] . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return newRealMapBinder ( [[binder]] , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( [[binder]] , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > newRealMapBinder ( Binder [[loud]] , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { [[loud]] = [[loud]] . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return newRealMapBinder ( [[loud]] , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( [[loud]] , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 349 ---------------------------------------------
Replace the source object . --> Overrides writeReplace --> Socre: 1.0

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int [[i]] = 0 ; [[i]] < sourcesAsStrings . length ; [[i]] ++ ) { sourcesAsStrings [ [[i]] ] = Errors . convert ( sourcesAsStrings [ [[i]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int [[aggrieved]] = 0 ; [[aggrieved]] < sourcesAsStrings . length ; [[aggrieved]] ++ ) { sourcesAsStrings [ [[aggrieved]] ] = Errors . convert ( sourcesAsStrings [ [[aggrieved]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 350 ---------------------------------------------
Creates a new instance . --> Size of the construction --> Socre: 1.0

[[[[Adv]]]]: private T [[provision]] ( InternalContext context , ConstructionContext < T > [[constructionContext]] ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; [[constructionContext]] . setProxyDelegates ( t ) ; } finally { [[constructionContext]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T [[size]] ( InternalContext context , ConstructionContext < T > [[arrests]] ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; [[arrests]] . setProxyDelegates ( t ) ; } finally { [[arrests]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 351 ---------------------------------------------
Returns a new key for a new value . --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > [[valueKey]] = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , [[valueKey]] ) ) ; return [[valueKey]] ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > [[ful]] = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , [[ful]] ) ) ; return [[ful]] ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 352 ---------------------------------------------
Returns the Module for the given module --> Elsey kelsey --> Socre: 1.0

[[[[Adv]]]]: static Module [[forModule]] ( Module module ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module [[kelsey]] ( Module module ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 353 ---------------------------------------------
Returns all registered methods . --> getAssisted methods --> Socre: 1.0

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[benda]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 354 ---------------------------------------------
Checks if the given interceptor has scope annotations . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation [[annotation]] : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[annotation]] . annotationType ( ) ) ) { return True ; } } return False ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation [[strategically]] : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[strategically]] . annotationType ( ) ) ) { return True ; } } return False ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 355 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 269 / 84 / 2 / 355:  36%|███▌      | 355/1000 [54:16<1:38:36,  9.17s/it][Succeeded / Failed / Skipped / Total] 269 / 84 / 2 / 355:  36%|███▌      | 356/1000 [54:43<1:39:00,  9.22s/it][Succeeded / Failed / Skipped / Total] 270 / 84 / 2 / 356:  36%|███▌      | 356/1000 [54:43<1:39:00,  9.22s/it][Succeeded / Failed / Skipped / Total] 270 / 84 / 2 / 356:  36%|███▌      | 357/1000 [54:45<1:38:37,  9.20s/it][Succeeded / Failed / Skipped / Total] 271 / 84 / 2 / 357:  36%|███▌      | 357/1000 [54:45<1:38:37,  9.20s/it][Succeeded / Failed / Skipped / Total] 271 / 84 / 2 / 357:  36%|███▌      | 358/1000 [54:48<1:38:17,  9.19s/it][Succeeded / Failed / Skipped / Total] 272 / 84 / 2 / 358:  36%|███▌      | 358/1000 [54:48<1:38:17,  9.19s/it][Succeeded / Failed / Skipped / Total] 272 / 84 / 2 / 358:  36%|███▌      | 359/1000 [54:49<1:37:52,  9.16s/it][Succeeded / Failed / Skipped / Total] 272 / 84 / 3 / 359:  36%|███▌      | 359/1000 [54:49<1:37:52,  9.16s/it][Succeeded / Failed / Skipped / Total] 272 / 84 / 3 / 359:  36%|███▌      | 360/1000 [54:57<1:37:42,  9.16s/it][Succeeded / Failed / Skipped / Total] 272 / 85 / 3 / 360:  36%|███▌      | 360/1000 [54:57<1:37:42,  9.16s/it][Succeeded / Failed / Skipped / Total] 272 / 85 / 3 / 360:  36%|███▌      | 361/1000 [54:59<1:37:19,  9.14s/it][Succeeded / Failed / Skipped / Total] 273 / 85 / 3 / 361:  36%|███▌      | 361/1000 [54:59<1:37:19,  9.14s/it][Succeeded / Failed / Skipped / Total] 273 / 85 / 3 / 361:  36%|███▌      | 362/1000 [55:05<1:37:05,  9.13s/it]Removes anyisted dependencies from the Dependency object . --> Removes any AssistedDeps from the graph --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > [[deps]] ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : [[deps]] ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > [[illogical]] ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : [[illogical]] ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 356 ---------------------------------------------
Collect dependencies from ctor point . --> returns as a dependency --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[getDependencies]] ( InjectionPoint [[ctorPoint]] , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( [[ctorPoint]] . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint [[ip]] : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( [[ip]] . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > [[ason]] ( InjectionPoint [[catholic]] , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( [[catholic]] . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint [[glória]] : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( [[glória]] . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 357 ---------------------------------------------
Returns true if the constructor has the given parameters . --> Carry out the given constructor --> Socre: 1.0

[[[[Adv]]]]: private boolean [[constructorHasMatchingParams]] ( TypeLiteral < ? > type , Constructor < ? > [[constructor]] , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( [[constructor]] ) ; Annotation [ ] [ ] paramAnnotations = [[constructor]] . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , [[constructor]] , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean [[carla]] ( TypeLiteral < ? > type , Constructor < ? > [[orjust]] , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( [[orjust]] ) ; Annotation [ ] [ ] paramAnnotations = [[orjust]] . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , [[orjust]] , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 358 ---------------------------------------------
Checks if a set of dependencies is valid for an optimization . --> Mikami analysis --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isValidForOptimizedAssistedInject]] ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > [[factoryType]] ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean [[mikami]] ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > [[catwalk]] ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 359 ---------------------------------------------
Thrown when conversion is not bound . --> [[[SKIPPED]]]

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 360 ---------------------------------------------
Checks if a type is not defined . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[isTypeNotSpecified]] ( TypeLiteral < ? > [[typeLiteral]] , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "[[False]]" != "[[False]]" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean [[poom]] ( TypeLiteral < ? > [[cadres]] , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[cadres]] ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "[["Entrepreneur" != "Entrepreneur"]]" != "[["Entrepreneur" != "Entrepreneur"]]" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 361 ---------------------------------------------
Invokes the method on the proxy --> Accessor methods --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object [[invoke]] ( Object proxy , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object [[accessible]] ( Object proxy , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
[Succeeded / Failed / Skipped / Total] 274 / 85 / 3 / 362:  36%|███▌      | 362/1000 [55:05<1:37:05,  9.13s/it][Succeeded / Failed / Skipped / Total] 274 / 85 / 3 / 362:  36%|███▋      | 363/1000 [55:18<1:37:04,  9.14s/it][Succeeded / Failed / Skipped / Total] 274 / 86 / 3 / 363:  36%|███▋      | 363/1000 [55:18<1:37:04,  9.14s/it][Succeeded / Failed / Skipped / Total] 274 / 86 / 3 / 363:  36%|███▋      | 364/1000 [55:24<1:36:47,  9.13s/it][Succeeded / Failed / Skipped / Total] 275 / 86 / 3 / 364:  36%|███▋      | 364/1000 [55:24<1:36:47,  9.13s/it][Succeeded / Failed / Skipped / Total] 275 / 86 / 3 / 364:  36%|███▋      | 365/1000 [55:31<1:36:35,  9.13s/it][Succeeded / Failed / Skipped / Total] 276 / 86 / 3 / 365:  36%|███▋      | 365/1000 [55:31<1:36:35,  9.13s/it][Succeeded / Failed / Skipped / Total] 276 / 86 / 3 / 365:  37%|███▋      | 366/1000 [55:45<1:36:34,  9.14s/it][Succeeded / Failed / Skipped / Total] 277 / 86 / 3 / 366:  37%|███▋      | 366/1000 [55:45<1:36:34,  9.14s/it][Succeeded / Failed / Skipped / Total] 277 / 86 / 3 / 366:  37%|███▋      | 367/1000 [55:46<1:36:12,  9.12s/it][Succeeded / Failed / Skipped / Total] 277 / 87 / 3 / 367:  37%|███▋      | 367/1000 [55:46<1:36:12,  9.12s/it][Succeeded / Failed / Skipped / Total] 277 / 87 / 3 / 367:  37%|███▋      | 368/1000 [55:57<1:36:06,  9.12s/it][Succeeded / Failed / Skipped / Total] 278 / 87 / 3 / 368:  37%|███▋      | 368/1000 [55:57<1:36:06,  9.12s/it][Succeeded / Failed / Skipped / Total] 278 / 87 / 3 / 368:  37%|███▋      | 369/1000 [55:59<1:35:45,  9.11s/it][Succeeded / Failed / Skipped / Total] 279 / 87 / 3 / 369:  37%|███▋      | 369/1000 [55:59<1:35:45,  9.11s/it][Succeeded / Failed / Skipped / Total] 279 / 87 / 3 / 369:  37%|███▋      | 370/1000 [56:10<1:35:38,  9.11s/it]--------------------------------------------- Result 362 ---------------------------------------------
Installs a new object in the given binder . --> Instantiates a RealMultipilibinder --> Socre: 1.0

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[newRealSetBinder]] ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( binder , key ) ; binder . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[antónio]] ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( binder , key ) ; binder . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 363 ---------------------------------------------
Returns the internal constructor . --> [[[FAILED]]]

[[[[Adv]]]]: InjectionPoint [[getInternalConstructor]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint [[maite]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 364 ---------------------------------------------
Find the next filter . --> Try to find a card --> Socre: 1.0

[[[[Adv]]]]: private Filter [[findNextFilter]] ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter [[filter]] = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( [[filter]] != null ) { return [[filter]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter [[himmler]] ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter [[cardassian]] = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( [[cardassian]] != null ) { return [[cardassian]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 365 ---------------------------------------------
Checks if the given Constructor has at least one annotation . --> Sneaky throws an exception --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasAtInject]] ( Constructor [[cxtor]] ) { return [[cxtor]] . isAnnotationPresent ( Inject . class ) || [[cxtor]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean [[sneezy]] ( Constructor [[í]] ) { return [[í]] . isAnnotationPresent ( Inject . class ) || [[í]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 366 ---------------------------------------------
Gets the annotation . --> Package private for testing --> Socre: 1.0

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > [[annotationClass]] : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( [[annotationClass]] ) ; if ( foundAnnotation != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = foundAnnotation ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > [[dampened]] : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( [[dampened]] ) ; if ( foundAnnotation != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = foundAnnotation ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 367 ---------------------------------------------
Gets the dependencies . --> [[[FAILED]]]

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > [[builder]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[builder]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[snoops]] ( ) { ImmutableSet . Builder < InjectionPoint > [[aborigine]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[aborigine]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 368 ---------------------------------------------
Returns the line number for the given member . -->  takano --> Socre: 1.0

[[[[Adv]]]]: public Integer [[getLineNumber]] ( Member member ) { Preconditions . checkArgument ( type == member . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , member , member . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( member ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer [[takano]] ( Member member ) { Preconditions . checkArgument ( type == member . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , member , member . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( member ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 369 ---------------------------------------------
Initialize the injector . --> This method should be overridden by subclasses --> Socre: 1.0

[[[[Adv]]]]: void [[initialize]] ( Errors errors ) { injector . lookups = injector ; new LookupProcessor ( errors ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[aristophanes]] ( Errors errors ) { injector . lookups = injector ; new LookupProcessor ( errors ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 370 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 279 / 88 / 3 / 370:  37%|███▋      | 370/1000 [56:10<1:35:38,  9.11s/it][Succeeded / Failed / Skipped / Total] 279 / 88 / 3 / 370:  37%|███▋      | 371/1000 [56:13<1:35:20,  9.09s/it][Succeeded / Failed / Skipped / Total] 280 / 88 / 3 / 371:  37%|███▋      | 371/1000 [56:13<1:35:20,  9.09s/it][Succeeded / Failed / Skipped / Total] 280 / 88 / 3 / 371:  37%|███▋      | 372/1000 [56:17<1:35:02,  9.08s/it][Succeeded / Failed / Skipped / Total] 280 / 89 / 3 / 372:  37%|███▋      | 372/1000 [56:17<1:35:02,  9.08s/it][Succeeded / Failed / Skipped / Total] 280 / 89 / 3 / 372:  37%|███▋      | 373/1000 [56:27<1:34:53,  9.08s/it][Succeeded / Failed / Skipped / Total] 281 / 89 / 3 / 373:  37%|███▋      | 373/1000 [56:27<1:34:53,  9.08s/it][Succeeded / Failed / Skipped / Total] 281 / 89 / 3 / 373:  37%|███▋      | 374/1000 [56:28<1:34:31,  9.06s/it][Succeeded / Failed / Skipped / Total] 281 / 90 / 3 / 374:  37%|███▋      | 374/1000 [56:28<1:34:31,  9.06s/it][Succeeded / Failed / Skipped / Total] 281 / 90 / 3 / 374:  38%|███▊      | 375/1000 [56:58<1:34:56,  9.11s/it][Succeeded / Failed / Skipped / Total] 282 / 90 / 3 / 375:  38%|███▊      | 375/1000 [56:58<1:34:56,  9.11s/it][Succeeded / Failed / Skipped / Total] 282 / 90 / 3 / 375:  38%|███▊      | 376/1000 [57:14<1:34:59,  9.13s/it]Gets the binding from guice injector . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < ? > [[getBindingFromNewInjector]] ( final Method method , final Object [ ] args , final AssistData [[data]] ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = [[data]] . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > [[alarming]] ( final Method method , final Object [ ] args , final AssistData [[randy]] ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = [[randy]] . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 371 ---------------------------------------------
Wrap a callable in a future . --> Called by antono map --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[continueRequest]] ( Callable < T > callable , Map < Key < ? > , Object > seedMap ) { return wrap ( callable , [[continueRequest]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[antónio]] ( Callable < T > callable , Map < Key < ? > , Object > seedMap ) { return wrap ( callable , [[antónio]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 372 ---------------------------------------------
Creates a module for the given module . --> [[[FAILED]]]

[[[[Adv]]]]: public static Module forModule ( Object [[module]] , ModuleAnnotatedMethodScanner scanner ) { return forObject ( [[module]] , False , scanner ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module forModule ( Object [[scorer]] , ModuleAnnotatedMethodScanner scanner ) { return forObject ( [[scorer]] , False , scanner ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 373 ---------------------------------------------
Validates and validates the given value . --> Convenience method for avocados --> Socre: 1.0

[[[[Adv]]]]: private static Object [[validateAndCanonicalizeValue]] ( Key < ? > key , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object [[avocados]] ( Key < ? > key , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 374 ---------------------------------------------
Wraps the given callable . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > [[transferRequest]] ( Callable < T > callable ) { return wrap ( callable , [[transferRequest]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > [[odessa]] ( Callable < T > callable ) { return wrap ( callable , [[odessa]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 375 ---------------------------------------------
Create a injector for the given type . --> Create an instance of AnnotationInjector --> Socre: 1.0

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > [[type]] , Errors [[errors]] ) throws ErrorsException { int numErrorsBefore = [[errors]] . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( [[type]] ) ; } catch ( ConfigurationException e ) { [[errors]] . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , [[errors]] ) ; [[errors]] . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( [[errors]] , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( [[type]] ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( [[type]] , encounter ) ; } catch ( RuntimeException e ) { [[errors]] . errorNotifyingTypeListener ( binding , [[type]] , e ) ; } } } encounter . invalidate ( ) ; [[errors]] . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , [[type]] , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > [[abdallah]] , Errors [[wienie]] ) throws ErrorsException { int numErrorsBefore = [[wienie]] . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( [[abdallah]] ) ; } catch ( ConfigurationException e ) { [[wienie]] . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , [[wienie]] ) ; [[wienie]] . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( [[wienie]] , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( [[abdallah]] ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( [[abdallah]] , encounter ) ; } catch ( RuntimeException e ) { [[wienie]] . errorNotifyingTypeListener ( binding , [[abdallah]] , e ) ; } } } encounter . invalidate ( ) ; [[wienie]] . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , [[abdallah]] , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 376 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 282 / 91 / 3 / 376:  38%|███▊      | 376/1000 [57:14<1:34:59,  9.13s/it][Succeeded / Failed / Skipped / Total] 282 / 91 / 3 / 376:  38%|███▊      | 377/1000 [57:26<1:34:55,  9.14s/it][Succeeded / Failed / Skipped / Total] 282 / 92 / 3 / 377:  38%|███▊      | 377/1000 [57:26<1:34:55,  9.14s/it][Succeeded / Failed / Skipped / Total] 282 / 92 / 3 / 377:  38%|███▊      | 378/1000 [57:27<1:34:33,  9.12s/it][Succeeded / Failed / Skipped / Total] 282 / 93 / 3 / 378:  38%|███▊      | 378/1000 [57:27<1:34:33,  9.12s/it][Succeeded / Failed / Skipped / Total] 282 / 93 / 3 / 378:  38%|███▊      | 379/1000 [57:29<1:34:12,  9.10s/it][Succeeded / Failed / Skipped / Total] 282 / 94 / 3 / 379:  38%|███▊      | 379/1000 [57:29<1:34:12,  9.10s/it][Succeeded / Failed / Skipped / Total] 282 / 94 / 3 / 379:  38%|███▊      | 380/1000 [57:39<1:34:04,  9.10s/it][Succeeded / Failed / Skipped / Total] 283 / 94 / 3 / 380:  38%|███▊      | 380/1000 [57:39<1:34:04,  9.10s/it][Succeeded / Failed / Skipped / Total] 283 / 94 / 3 / 380:  38%|███▊      | 381/1000 [58:16<1:34:40,  9.18s/it][Succeeded / Failed / Skipped / Total] 283 / 95 / 3 / 381:  38%|███▊      | 381/1000 [58:16<1:34:40,  9.18s/it][Succeeded / Failed / Skipped / Total] 283 / 95 / 3 / 381:  38%|███▊      | 382/1000 [58:21<1:34:24,  9.17s/it]Creates a new Key instance . --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Key < T > [[get]] ( Class < T > [[type]] , AnnotationStrategy [[annotationStrategy]] ) { return new Key < T > ( [[type]] , [[annotationStrategy]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > [[erb]] ( Class < T > [[í]] , AnnotationStrategy [[buccaneers]] ) { return new Key < T > ( [[í]] , [[buccaneers]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 377 ---------------------------------------------
Gets the injectors for injection points . --> [[[FAILED]]]

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint [[injectionPoint]] : injectionPoints ) { try { Errors [[errorsForMember]] = [[injectionPoint]] . isOptional ( ) ? new Errors ( [[injectionPoint]] ) : errors . withSource ( [[injectionPoint]] ) ; SingleMemberInjector [[injector]] = [[injectionPoint]] . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , [[injectionPoint]] , [[errorsForMember]] ) : new SingleMethodInjector ( this . injector , [[injectionPoint]] , [[errorsForMember]] ) ; injectors . add ( [[injector]] ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint [[leticia]] : injectionPoints ) { try { Errors [[assuming]] = [[leticia]] . isOptional ( ) ? new Errors ( [[leticia]] ) : errors . withSource ( [[leticia]] ) ; SingleMemberInjector [[denzel]] = [[leticia]] . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , [[leticia]] , [[assuming]] ) : new SingleMethodInjector ( this . injector , [[leticia]] , [[assuming]] ) ; injectors . add ( [[denzel]] ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 378 ---------------------------------------------
Returns a strategy for the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Annotation [[annotation]] ) { checkNotNull ( [[annotation]] , "annotation" ) ; Class < ? extends Annotation > [[annotationType]] = [[annotation]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; if ( Annotations . isMarker ( [[annotationType]] ) ) { return new AnnotationTypeStrategy ( [[annotationType]] , [[annotation]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[annotation]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy [[wpc]] ( Annotation [[garrison]] ) { checkNotNull ( [[garrison]] , "annotation" ) ; Class < ? extends Annotation > [[alligator]] = [[garrison]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[alligator]] ) ; ensureIsBindingAnnotation ( [[alligator]] ) ; if ( Annotations . isMarker ( [[alligator]] ) ) { return new AnnotationTypeStrategy ( [[alligator]] , [[garrison]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[garrison]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 379 ---------------------------------------------
Returns a strategy for the given annotation type . --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > [[annotationType]] ) { [[annotationType]] = Annotations . canonicalizeIfNamed ( [[annotationType]] ) ; if ( isAllDefaultMethods ( [[annotationType]] ) ) { return [[strategyFor]] ( generateAnnotation ( [[annotationType]] ) ) ; } checkNotNull ( [[annotationType]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; return new AnnotationTypeStrategy ( [[annotationType]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[compatible]] ( Class < ? extends Annotation > [[gunboat]] ) { [[gunboat]] = Annotations . canonicalizeIfNamed ( [[gunboat]] ) ; if ( isAllDefaultMethods ( [[gunboat]] ) ) { return [[compatible]] ( generateAnnotation ( [[gunboat]] ) ) ; } checkNotNull ( [[gunboat]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[gunboat]] ) ; ensureIsBindingAnnotation ( [[gunboat]] ) ; return new AnnotationTypeStrategy ( [[gunboat]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 380 ---------------------------------------------
Gets the binding source . --> used for debugging --> Socre: 1.0

[[[[Adv]]]]: public String [[getBindingSource]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String [[viceroy]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 381 ---------------------------------------------
Creates a message with the given format and arguments . --> [[[FAILED]]]

[[[[Adv]]]]: public static Message create ( String messageFormat , Object ... [[arguments]] ) { return create ( null , messageFormat , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message create ( String messageFormat , Object ... [[hood]] ) { return create ( null , messageFormat , [[hood]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 382 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 284 / 95 / 3 / 382:  38%|███▊      | 382/1000 [58:21<1:34:24,  9.17s/it][Succeeded / Failed / Skipped / Total] 284 / 95 / 3 / 382:  38%|███▊      | 383/1000 [58:30<1:34:15,  9.17s/it][Succeeded / Failed / Skipped / Total] 285 / 95 / 3 / 383:  38%|███▊      | 383/1000 [58:30<1:34:15,  9.17s/it][Succeeded / Failed / Skipped / Total] 285 / 95 / 3 / 383:  38%|███▊      | 384/1000 [58:37<1:34:02,  9.16s/it][Succeeded / Failed / Skipped / Total] 286 / 95 / 3 / 384:  38%|███▊      | 384/1000 [58:37<1:34:02,  9.16s/it][Succeeded / Failed / Skipped / Total] 286 / 95 / 3 / 384:  38%|███▊      | 385/1000 [58:46<1:33:52,  9.16s/it][Succeeded / Failed / Skipped / Total] 287 / 95 / 3 / 385:  38%|███▊      | 385/1000 [58:46<1:33:52,  9.16s/it][Succeeded / Failed / Skipped / Total] 287 / 95 / 3 / 385:  39%|███▊      | 386/1000 [58:59<1:33:49,  9.17s/it][Succeeded / Failed / Skipped / Total] 288 / 95 / 3 / 386:  39%|███▊      | 386/1000 [58:59<1:33:49,  9.17s/it][Succeeded / Failed / Skipped / Total] 288 / 95 / 3 / 386:  39%|███▊      | 387/1000 [58:59<1:33:26,  9.15s/it]Removes extraneous stack trace from the given throwable . --> light darkie --> Socre: 1.0

[[[[Adv]]]]: private void [[pruneStacktrace]] ( Throwable throwable ) { for ( Throwable [[t]] = throwable ; [[t]] != null ; [[t]] = [[t]] . getCause ( ) ) { StackTraceElement [ ] [[stackTrace]] = [[t]] . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : [[stackTrace]] ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } [[t]] . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void [[darkie]] ( Throwable throwable ) { for ( Throwable [[città]] = throwable ; [[città]] != null ; [[città]] = [[città]] . getCause ( ) ) { StackTraceElement [ ] [[komodo]] = [[città]] . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : [[komodo]] ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } [[città]] . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 383 ---------------------------------------------
Formats a collection of error messages . --> This method is used to render a lot of accents --> Socre: 1.0

[[[[Adv]]]]: public static String [[formatMessages]] ( String [[heading]] , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( [[heading]] ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object [[source]] = dependencies . get ( i ) ; formatSource ( fmt , [[source]] ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String [[stéphane]] ( String [[arkansas]] , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( [[arkansas]] ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object [[chapped]] = dependencies . get ( i ) ; formatSource ( fmt , [[chapped]] ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 384 ---------------------------------------------
Convert an Object to an ElementSource . --> Convert address to address --> Socre: 1.0

[[[[Adv]]]]: static Object convert ( Object [[o]] ) { ElementSource source = null ; if ( [[o]] instanceof ElementSource ) { source = ( ElementSource ) [[o]] ; [[o]] = source . getDeclaringSource ( ) ; } return convert ( [[o]] , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object convert ( Object [[street]] ) { ElementSource source = null ; if ( [[street]] instanceof ElementSource ) { source = ( ElementSource ) [[street]] ; [[street]] = source . getDeclaringSource ( ) ; } return convert ( [[street]] , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 385 ---------------------------------------------
Creates a formatted message with the given message and arguments . --> Utility function for creating torrents --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( Throwable cause , String [[messageFormat]] , Object ... arguments ) { return [[create]] ( cause , ImmutableList . of ( ) , [[messageFormat]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[torrents]] ( Throwable cause , String [[fletcher]] , Object ... arguments ) { return [[torrents]] ( cause , ImmutableList . of ( ) , [[fletcher]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 386 ---------------------------------------------
Manage jmx . --> tries to manage tenderness --> Socre: 1.0

[[[[Adv]]]]: public static void [[main]] ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void [[tenderness]] ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 387 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 288 / 96 / 3 / 387:  39%|███▊      | 387/1000 [58:59<1:33:26,  9.15s/it][Succeeded / Failed / Skipped / Total] 288 / 96 / 3 / 387:  39%|███▉      | 388/1000 [59:30<1:33:52,  9.20s/it][Succeeded / Failed / Skipped / Total] 289 / 96 / 3 / 388:  39%|███▉      | 388/1000 [59:30<1:33:52,  9.20s/it][Succeeded / Failed / Skipped / Total] 289 / 96 / 3 / 388:  39%|███▉      | 389/1000 [59:36<1:33:38,  9.19s/it][Succeeded / Failed / Skipped / Total] 289 / 97 / 3 / 389:  39%|███▉      | 389/1000 [59:36<1:33:38,  9.19s/it][Succeeded / Failed / Skipped / Total] 289 / 97 / 3 / 389:  39%|███▉      | 390/1000 [59:43<1:33:24,  9.19s/it][Succeeded / Failed / Skipped / Total] 289 / 98 / 3 / 390:  39%|███▉      | 390/1000 [59:43<1:33:24,  9.19s/it][Succeeded / Failed / Skipped / Total] 289 / 98 / 3 / 390:  39%|███▉      | 391/1000 [59:45<1:33:05,  9.17s/it][Succeeded / Failed / Skipped / Total] 290 / 98 / 3 / 391:  39%|███▉      | 391/1000 [59:45<1:33:05,  9.17s/it][Succeeded / Failed / Skipped / Total] 290 / 98 / 3 / 391:  39%|███▉      | 392/1000 [59:54<1:32:54,  9.17s/it][Succeeded / Failed / Skipped / Total] 291 / 98 / 3 / 392:  39%|███▉      | 392/1000 [59:54<1:32:54,  9.17s/it][Succeeded / Failed / Skipped / Total] 291 / 98 / 3 / 392:  39%|███▉      | 393/1000 [1:00:01<1:32:42,  9.16s/it][Succeeded / Failed / Skipped / Total] 291 / 99 / 3 / 393:  39%|███▉      | 393/1000 [1:00:01<1:32:42,  9.16s/it][Succeeded / Failed / Skipped / Total] 291 / 99 / 3 / 393:  39%|███▉      | 394/1000 [1:00:18<1:32:44,  9.18s/it][Succeeded / Failed / Skipped / Total] 292 / 99 / 3 / 394:  39%|███▉      | 394/1000 [1:00:18<1:32:44,  9.18s/it][Succeeded / Failed / Skipped / Total] 292 / 99 / 3 / 394:  40%|███▉      | 395/1000 [1:00:22<1:32:28,  9.17s/it][Succeeded / Failed / Skipped / Total] 292 / 100 / 3 / 395:  40%|███▉      | 395/1000 [1:00:22<1:32:28,  9.17s/it][Succeeded / Failed / Skipped / Total] 292 / 100 / 3 / 395:  40%|███▉      | 396/1000 [1:00:40<1:32:33,  9.19s/it]Checks if the class should be skipped . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[shouldBeSkipped]] ( String [[className]] ) { return ( parent != null && parent . shouldBeSkipped ( [[className]] ) ) || classNamesToSkip . contains ( [[className]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean [[denomination]] ( String [[bulgari]] ) { return ( parent != null && parent . shouldBeSkipped ( [[bulgari]] ) ) || classNamesToSkip . contains ( [[bulgari]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
--------------------------------------------- Result 388 ---------------------------------------------
Method pushState . --> Store simms notification --> Socre: 1.0

[[[[Adv]]]]: void [[pushState]] ( com . google . inject . Key < ? > key , Object [[source]] ) { doPushState ( key , [[source]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void [[simms]] ( com . google . inject . Key < ? > key , Object [[cinematographic]] ) { doPushState ( key , [[cinematographic]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 389 ---------------------------------------------
Gets the configuration for the module classes . --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[getFromClassNames]] ( List < String > [[moduleClassNames]] ) { Preconditions . checkNotNull ( [[moduleClassNames]] , "The list of module class names cannot be null." ) ; for ( final String [[moduleClassName]] : [[moduleClassNames]] ) { if ( ! shouldBeSkipped ( [[moduleClassName]] ) ) { return new StackTraceElement ( [[moduleClassName]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object [[orangeade]] ( List < String > [[atonement]] ) { Preconditions . checkNotNull ( [[atonement]] , "The list of module class names cannot be null." ) ; for ( final String [[scratchy]] : [[atonement]] ) { if ( ! shouldBeSkipped ( [[scratchy]] ) ) { return new StackTraceElement ( [[scratchy]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 390 ---------------------------------------------
Creates a formatted message with the given message and arguments . --> [[[FAILED]]]

[[[[Adv]]]]: public static Message create ( Throwable cause , List < Object > sources , String messageFormat , Object ... [[arguments]] ) { String [[message]] = format ( messageFormat , [[arguments]] ) ; return new Message ( sources , [[message]] , cause ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message create ( Throwable cause , List < Object > sources , String messageFormat , Object ... [[thumbs]] ) { String [[nitric]] = format ( messageFormat , [[thumbs]] ) ; return new Message ( sources , [[nitric]] , cause ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 391 ---------------------------------------------
Returns an initializable instance --> Construct a Serializable object --> Socre: 1.0

[[[[Adv]]]]: static < T > Initializable < T > of ( final T [[instance]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[instance]] ; } @ Override public String toString ( ) { return String . valueOf ( [[instance]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > of ( final T [[zaira]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[zaira]] ; } @ Override public String toString ( ) { return String . valueOf ( [[zaira]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 392 ---------------------------------------------
Dispatch connection event . --> Process connection event --> Socre: 1.0

[[[[Adv]]]]: public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > [[processorList]] = this . processors . get ( type ) ; if ( [[processorList]] != null ) { for ( ConnectionEventProcessor processor : [[processorList]] ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .

[[[[Adv]]]]: public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > [[pontus]] = this . processors . get ( type ) ; if ( [[pontus]] != null ) { for ( ConnectionEventProcessor processor : [[pontus]] ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .
--------------------------------------------- Result 393 ---------------------------------------------
Pushes a dependency onto the dependency stack . --> [[[FAILED]]]

[[[[Adv]]]]: Dependency < ? > [[pushDependency]] ( Dependency < ? > dependency , Object source ) { Dependency < ? > previous = this . [[dependency]] ; this . [[dependency]] = dependency ; doPushState ( dependency , source ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > [[blowers]] ( Dependency < ? > dependency , Object source ) { Dependency < ? > previous = this . [[hyoid]] ; this . [[hyoid]] = dependency ; doPushState ( dependency , source ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 394 ---------------------------------------------
Lazily executes the given Throwable . --> Throws an unchecked exception . --> Socre: 1.0

[[[[Adv]]]]: public static void launderThrowable ( Throwable [[t]] ) { if ( [[t]] instanceof RuntimeException ) { throw ( RuntimeException ) [[t]] ; } else if ( [[t]] instanceof Error ) { throw ( Error ) [[t]] ; } else { throw new IllegalStateException ( "Not unchecked!" , [[t]] ) ; } }
[[[[Nl]]]]: launder the throwable

[[[[Adv]]]]: public static void launderThrowable ( Throwable [[develop]] ) { if ( [[develop]] instanceof RuntimeException ) { throw ( RuntimeException ) [[develop]] ; } else if ( [[develop]] instanceof Error ) { throw ( Error ) [[develop]] ; } else { throw new IllegalStateException ( "Not unchecked!" , [[develop]] ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 395 ---------------------------------------------
Get the task result . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[merchandising]] > [[merchandising]] getFutureTaskResult ( RunStateRecordedFutureTask < [[merchandising]] > task , Logger logger ) { [[merchandising]] t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 396 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 293 / 100 / 3 / 396:  40%|███▉      | 396/1000 [1:00:40<1:32:33,  9.19s/it][Succeeded / Failed / Skipped / Total] 293 / 100 / 3 / 396:  40%|███▉      | 397/1000 [1:00:56<1:32:34,  9.21s/it][Succeeded / Failed / Skipped / Total] 293 / 101 / 3 / 397:  40%|███▉      | 397/1000 [1:00:56<1:32:34,  9.21s/it][Succeeded / Failed / Skipped / Total] 293 / 101 / 3 / 397:  40%|███▉      | 398/1000 [1:00:57<1:32:12,  9.19s/it][Succeeded / Failed / Skipped / Total] 294 / 101 / 3 / 398:  40%|███▉      | 398/1000 [1:00:57<1:32:12,  9.19s/it][Succeeded / Failed / Skipped / Total] 294 / 101 / 3 / 398:  40%|███▉      | 399/1000 [1:01:05<1:32:01,  9.19s/it][Succeeded / Failed / Skipped / Total] 294 / 102 / 3 / 399:  40%|███▉      | 399/1000 [1:01:05<1:32:01,  9.19s/it][Succeeded / Failed / Skipped / Total] 294 / 102 / 3 / 399:  40%|████      | 400/1000 [1:01:05<1:31:38,  9.16s/it][Succeeded / Failed / Skipped / Total] 294 / 102 / 4 / 400:  40%|████      | 400/1000 [1:01:05<1:31:38,  9.16s/it][Succeeded / Failed / Skipped / Total] 294 / 102 / 4 / 400:  40%|████      | 401/1000 [1:01:31<1:31:54,  9.21s/it][Succeeded / Failed / Skipped / Total] 295 / 102 / 4 / 401:  40%|████      | 401/1000 [1:01:31<1:31:54,  9.21s/it][Succeeded / Failed / Skipped / Total] 295 / 102 / 4 / 401:  40%|████      | 402/1000 [1:01:37<1:31:39,  9.20s/it][Succeeded / Failed / Skipped / Total] 296 / 102 / 4 / 402:  40%|████      | 402/1000 [1:01:37<1:31:39,  9.20s/it][Succeeded / Failed / Skipped / Total] 296 / 102 / 4 / 402:  40%|████      | 403/1000 [1:01:40<1:31:22,  9.18s/it]Registers a processor --> Registers a RemotingProcessor --> Socre: 1.0

[[[[Adv]]]]: public void [[registerProcessor]] ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . cmd2processors . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void [[harvard]] ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . cmd2processors . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 397 ---------------------------------------------
Adds a processor to the event type . --> [[[FAILED]]]

[[[[Adv]]]]: public void addConnectionEventProcessor ( ConnectionEventType [[type]] , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > processorList = this . [[processors]] . get ( [[type]] ) ; if ( processorList == null ) { this . [[processors]] . putIfAbsent ( [[type]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . [[processors]] . get ( [[type]] ) ; } processorList . add ( processor ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void addConnectionEventProcessor ( ConnectionEventType [[gazal]] , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > processorList = this . [[acutely]] . get ( [[gazal]] ) ; if ( processorList == null ) { this . [[acutely]] . putIfAbsent ( [[gazal]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . [[acutely]] . get ( [[gazal]] ) ; } processorList . add ( processor ) ; }
[[[[Nl]]]]: Add event processor .
--------------------------------------------- Result 398 ---------------------------------------------
Creates a new instance . --> Taken from the GuilContext --> Socre: 1.0

[[[[Adv]]]]: protected T [[provision]] ( Provider < ? extends T > provider , Dependency < ? > [[dependency]] , ConstructionContext < T > [[constructionContext]] ) throws InternalProvisionException { T [[t]] = provider . get ( ) ; if ( [[t]] == null && ! [[dependency]] . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , [[dependency]] ) ; } [[constructionContext]] . setProxyDelegates ( [[t]] ) ; return [[t]] ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T [[antithesis]] ( Provider < ? extends T > provider , Dependency < ? > [[bowman]] , ConstructionContext < T > [[linguistics]] ) throws InternalProvisionException { T [[guilford]] = provider . get ( ) ; if ( [[guilford]] == null && ! [[bowman]] . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , [[bowman]] ) ; } [[linguistics]] . setProxyDelegates ( [[guilford]] ) ; return [[guilford]] ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .
--------------------------------------------- Result 399 ---------------------------------------------
Registers the default processor . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerDefaultProcessor]] ( RemotingProcessor < ? > processor ) { if ( this . [[defaultProcessor]] == null ) { this . [[defaultProcessor]] = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . [[defaultProcessor]] . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void [[elba]] ( RemotingProcessor < ? > processor ) { if ( this . [[ancora]] == null ) { this . [[ancora]] = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . [[ancora]] . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 400 ---------------------------------------------
region GetAllConnectionPool Implementation --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { allConnections . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return allConnections ; }
[[[[Nl]]]]: Get all connections of all poolKey .
--------------------------------------------- Result 401 ---------------------------------------------
Scan all idle connections . --> Scans the idle pool . --> Socre: 1.0

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > [[iter]] = this . connTasks . keySet ( ) . iterator ( ) ; while ( [[iter]] . hasNext ( ) ) { String [[poolKey]] = [[iter]] . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( [[poolKey]] ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { [[iter]] . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , [[poolKey]] ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > [[avalanche]] = this . connTasks . keySet ( ) . iterator ( ) ; while ( [[avalanche]] . hasNext ( ) ) { String [[cape]] = [[avalanche]] . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( [[cape]] ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { [[avalanche]] . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , [[cape]] ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 402 ---------------------------------------------
Decode protocol code . --> Checks if there is a ProtocolCode available . --> Socre: 1.0

[[[[Adv]]]]: protected ProtocolCode [[decodeProtocolCode]] ( ByteBuf [[in]] ) { if ( [[in]] . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; [[in]] . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode [[inconsiderate]] ( ByteBuf [[fronted]] ) { if ( [[fronted]] . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; [[fronted]] . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 403 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 297 / 102 / 4 / 403:  40%|████      | 403/1000 [1:01:40<1:31:22,  9.18s/it][Succeeded / Failed / Skipped / Total] 297 / 102 / 4 / 403:  40%|████      | 404/1000 [1:01:42<1:31:01,  9.16s/it][Succeeded / Failed / Skipped / Total] 298 / 102 / 4 / 404:  40%|████      | 404/1000 [1:01:42<1:31:01,  9.16s/it][Succeeded / Failed / Skipped / Total] 298 / 102 / 4 / 404:  40%|████      | 405/1000 [1:01:44<1:30:43,  9.15s/it][Succeeded / Failed / Skipped / Total] 299 / 102 / 4 / 405:  40%|████      | 405/1000 [1:01:44<1:30:43,  9.15s/it][Succeeded / Failed / Skipped / Total] 299 / 102 / 4 / 405:  41%|████      | 406/1000 [1:01:52<1:30:31,  9.14s/it][Succeeded / Failed / Skipped / Total] 300 / 102 / 4 / 406:  41%|████      | 406/1000 [1:01:52<1:30:31,  9.14s/it][Succeeded / Failed / Skipped / Total] 300 / 102 / 4 / 406:  41%|████      | 407/1000 [1:01:54<1:30:12,  9.13s/it][Succeeded / Failed / Skipped / Total] 301 / 102 / 4 / 407:  41%|████      | 407/1000 [1:01:54<1:30:12,  9.13s/it][Succeeded / Failed / Skipped / Total] 301 / 102 / 4 / 407:  41%|████      | 408/1000 [1:01:57<1:29:54,  9.11s/it][Succeeded / Failed / Skipped / Total] 302 / 102 / 4 / 408:  41%|████      | 408/1000 [1:01:57<1:29:54,  9.11s/it][Succeeded / Failed / Skipped / Total] 302 / 102 / 4 / 408:  41%|████      | 409/1000 [1:02:04<1:29:42,  9.11s/it][Succeeded / Failed / Skipped / Total] 303 / 102 / 4 / 409:  41%|████      | 409/1000 [1:02:04<1:29:42,  9.11s/it][Succeeded / Failed / Skipped / Total] 303 / 102 / 4 / 409:  41%|████      | 410/1000 [1:02:09<1:29:26,  9.10s/it][Succeeded / Failed / Skipped / Total] 304 / 102 / 4 / 410:  41%|████      | 410/1000 [1:02:09<1:29:26,  9.10s/it][Succeeded / Failed / Skipped / Total] 304 / 102 / 4 / 410:  41%|████      | 411/1000 [1:02:27<1:29:29,  9.12s/it]Tries to get a cached URL . --> Replies the URL to the URL for the given Crystal object . --> Socre: 1.0

[[[[Adv]]]]: private Url [[tryGet]] ( String [[url]] ) { SoftReference < Url > [[softRef]] = Url . parsedUrls . get ( [[url]] ) ; return ( null == [[softRef]] ) ? null : [[softRef]] . get ( ) ; }
[[[[Nl]]]]: try get from cache

[[[[Adv]]]]: private Url [[attracted]] ( String [[lampoons]] ) { SoftReference < Url > [[egyptian]] = Url . parsedUrls . get ( [[lampoons]] ) ; return ( null == [[egyptian]] ) ? null : [[egyptian]] . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 404 ---------------------------------------------
Returns a processor for the given command code . --> Liefert die Leache Methode Leergeben --> Socre: 1.0

[[[[Adv]]]]: public RemotingProcessor < ? > [[getProcessor]] ( CommandCode cmdCode ) { RemotingProcessor < ? > [[processor]] = this . [[cmd2processors]] . get ( cmdCode ) ; if ( [[processor]] != null ) { return [[processor]] ; } return this . [[defaultProcessor]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > [[loan]] ( CommandCode cmdCode ) { RemotingProcessor < ? > [[lalita]] = this . [[dahlgren]] . get ( cmdCode ) ; if ( [[lalita]] != null ) { return [[lalita]] ; } return this . [[acquires]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .
--------------------------------------------- Result 405 ---------------------------------------------
Gets the connection and creates it if it does not exist . --> Obtains a connection to a server --> Socre: 1.0

[[[[Adv]]]]: @ Override public Connection [[getAndCreateIfAbsent]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection [[aishwarya]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 406 ---------------------------------------------
Create a connection to the remote server . --> Perform alaikum command --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[createConnectionAndHealIfNeed]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void [[alaikum]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 407 ---------------------------------------------
Remove a connection task from the pool . --> Removes a connection pool --> Socre: 1.0

[[[[Adv]]]]: private void removeTask ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > [[task]] = this . connTasks . remove ( poolKey ) ; if ( null != [[task]] ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( [[task]] , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void removeTask ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > [[twombly]] = this . connTasks . remove ( poolKey ) ; if ( null != [[twombly]] ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( [[twombly]] , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 408 ---------------------------------------------
Check if the url needs to be removed . --> An aurora request --> Socre: 1.0

[[[[Adv]]]]: private void [[healIfNeed]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void [[aurora]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected
--------------------------------------------- Result 409 ---------------------------------------------
Closes a connection --> Closes the connection --> Socre: 1.0

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . [[connectionManager]] . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . [[benzi]] . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 410 ---------------------------------------------
On close . --> Receives connection close --> Socre: 1.0

[[[[Adv]]]]: public void [[onClose]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void [[brion]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 411 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 305 / 102 / 4 / 411:  41%|████      | 411/1000 [1:02:27<1:29:29,  9.12s/it][Succeeded / Failed / Skipped / Total] 305 / 102 / 4 / 411:  41%|████      | 412/1000 [1:02:35<1:29:19,  9.12s/it][Succeeded / Failed / Skipped / Total] 306 / 102 / 4 / 412:  41%|████      | 412/1000 [1:02:35<1:29:19,  9.12s/it][Succeeded / Failed / Skipped / Total] 306 / 102 / 4 / 412:  41%|████▏     | 413/1000 [1:02:49<1:29:18,  9.13s/it][Succeeded / Failed / Skipped / Total] 307 / 102 / 4 / 413:  41%|████▏     | 413/1000 [1:02:49<1:29:18,  9.13s/it][Succeeded / Failed / Skipped / Total] 307 / 102 / 4 / 413:  41%|████▏     | 414/1000 [1:02:54<1:29:02,  9.12s/it][Succeeded / Failed / Skipped / Total] 307 / 103 / 4 / 414:  41%|████▏     | 414/1000 [1:02:54<1:29:02,  9.12s/it][Succeeded / Failed / Skipped / Total] 307 / 103 / 4 / 414:  42%|████▏     | 415/1000 [1:02:54<1:28:40,  9.10s/it][Succeeded / Failed / Skipped / Total] 308 / 103 / 4 / 415:  42%|████▏     | 415/1000 [1:02:54<1:28:40,  9.10s/it][Succeeded / Failed / Skipped / Total] 308 / 103 / 4 / 415:  42%|████▏     | 416/1000 [1:02:59<1:28:25,  9.08s/it]Do create . --> not used in test --> Socre: 1.0

[[[[Adv]]]]: private void [[doCreate]] ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int [[actualNum]] = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( [[actualNum]] < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , [[actualNum]] , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = [[actualNum]] ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections

[[[[Adv]]]]: private void [[badmouth]] ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int [[entonces]] = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( [[entonces]] < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , [[entonces]] , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = [[entonces]] ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 412 ---------------------------------------------
Registers a user processor . --> Registers a Riot BotProcessor --> Socre: 1.0

[[[[Adv]]]]: public static void registerUserProcessor ( UserProcessor < ? > [[processor]] , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == [[processor]] ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( [[processor]] instanceof MultiInterestUserProcessor ) { registerUserProcessor ( ( MultiInterestUserProcessor ) [[processor]] , [[userProcessors]] ) ; } else { if ( StringUtils . isBlank ( [[processor]] . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = [[userProcessors]] . putIfAbsent ( [[processor]] . interest ( ) , [[processor]] ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + [[processor]] . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void registerUserProcessor ( UserProcessor < ? > [[celebrating]] , ConcurrentHashMap < String , UserProcessor < ? > > [[solely]] ) { if ( null == [[celebrating]] ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( [[celebrating]] instanceof MultiInterestUserProcessor ) { registerUserProcessor ( ( MultiInterestUserProcessor ) [[celebrating]] , [[solely]] ) ; } else { if ( StringUtils . isBlank ( [[celebrating]] . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = [[solely]] . putIfAbsent ( [[celebrating]] . interest ( ) , [[celebrating]] ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + [[celebrating]] . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .
--------------------------------------------- Result 413 ---------------------------------------------
Close the connection . --> Do not work? --> Socre: 1.0

[[[[Adv]]]]: public void [[close]] ( ) { if ( closed . compareAndSet ( False , True ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[future]] ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . [[this]] . getChannel ( ) ) , [[future]] . isSuccess ( ) , [[future]] . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . [[this]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void [[iwant]] ( ) { if ( closed . compareAndSet ( False , True ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[gipsies]] ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . [[berlitz]] . getChannel ( ) ) , [[gipsies]] . isSuccess ( ) , [[gipsies]] . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . [[berlitz]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .
--------------------------------------------- Result 414 ---------------------------------------------
Sets the value for the specified key to the specified value . --> [[[FAILED]]]

[[[[Adv]]]]: public Object setAttributeIfAbsent ( String [[key]] , Object value ) { return attributes . putIfAbsent ( [[key]] , value ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object setAttributeIfAbsent ( String [[knoxville]] , Object value ) { return attributes . putIfAbsent ( [[knoxville]] , value ) ; }
[[[[Nl]]]]: set attribute if key absent .
--------------------------------------------- Result 415 ---------------------------------------------
Register a multi interest user process . --> Perform flatlining --> Socre: 1.0

[[[[Adv]]]]: private static void [[registerUserProcessor]] ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > [[preProcessor]] = userProcessors . putIfAbsent ( interest , processor ) ; if ( [[preProcessor]] != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void [[flatlining]] ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > [[lalla]] = userProcessors . putIfAbsent ( interest , processor ) ; if ( [[lalla]] != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .
--------------------------------------------- Result 416 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 309 / 103 / 4 / 416:  42%|████▏     | 416/1000 [1:02:59<1:28:25,  9.08s/it]